<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Jenkins的一些笔记 - ZepheryWen</title>
<link>http://www.cnblogs.com/w1570631036/p/9861473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w1570631036/p/9861473.html</guid>
<description>&lt;p&gt;公司主要要开发自己的paas平台，集成了Jenkins，真的是遇到了很多很多困难，特别是在api调用的权限这一块，这里，把自己遇到的一些坑的解决方法做一下笔记吧。当然，首先要讲的，就是如何在开启安全的情况下进行API调用。&lt;/p&gt;
&lt;h2 id=&quot;一在全局安全配置中&quot;&gt;一、在全局安全配置中&lt;/h2&gt;
&lt;h4 id=&quot;启用安全&quot;&gt;1.1 启用安全&lt;/h4&gt;
&lt;p&gt;如果勾选不对，那么Jenkins有可能崩溃掉，亲身经历，之前一直没有勾选安全域，然后授权策略为登录用户可以做任何事，之后权限这一块就彻底崩溃了，重装了又重装，才知道，需要勾选安全域。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20181027023132911846860.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;跨域&quot;&gt;1.2 跨域&lt;/h4&gt;
&lt;p&gt;同时开启跨站请求伪造保护，Jenkins的一些API需要用到的。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/201810270231471528136147.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;二获取token&quot;&gt;二、获取TOKEN&lt;/h2&gt;
&lt;h4 id=&quot;token&quot;&gt;2.1 TOKEN&lt;/h4&gt;
&lt;p&gt;Jenkins的用户token可以在用户的设置下面获得，但是这种方式如果需要重装Jenkins的话，就得重新修改一次配置文件&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20181027023526539361439.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;经过对&lt;a href=&quot;https://github.com/jenkinsci/java-client-api&quot;&gt;Jenkins-client&lt;/a&gt;的抓包分析，token可以由username+&quot;:&quot;+password，然后进行base64加密组成，之后在token前面加上&quot;Basic &quot;即可，代码如下：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20181027024305570167743.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;三获取jenkins-crumb&quot;&gt;三、获取Jenkins-Crumb&lt;/h2&gt;
&lt;p&gt;在远程API调用的时候，Jenkins对于某些接口的要求不仅限于Authorization，还必须要有Jenkins-Crumb，这个东西之前在进行获取的时候，有时候会变来变去，比如用curl命令和f12查看的时候发现不一致，实在受不了，感觉毫无规律可言，之后才发现上面的Authorization来直接调用接口获取的才是正确的，再然后想想，可能是之前调用api的时候，没有开启启用安全，再或者是有没有勾选上使用碎片算法。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/201810270251031329488332.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;另，附上curl查询Jenkins-Crumb的命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;curl -s 'http://admin:yourtoken@jenkins-url/crumbIssuer/api/xml?xpath=concat(//crumbRequestField,&quot;:&quot;,//crumb)'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;替换掉yourtoken和jenkins-url即可。&lt;/p&gt;
&lt;h2 id=&quot;四值得注意的事&quot;&gt;四、值得注意的事&lt;/h2&gt;
&lt;h4 id=&quot;api设计&quot;&gt;4.1 API设计&lt;/h4&gt;
&lt;p&gt;Jenkins的API设计可谓是独领风骚，能把一个提交设计成这样真实佩服测试之后才发现只要提交个表单，key为json，value为值即可，其他的都不需要，这个设计我也不知道怎么来的，感觉超级坑。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20181027030059348201424.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;生成构建job&quot;&gt;4.2 生成构建job&lt;/h4&gt;
&lt;p&gt;由于我们是将Jenkins集成在我们自己的平台里面，并不暴露Jenkins给用户，所以，创建一个job的时候，必须由我们平台的参数往Jenkins里面提交，这一提交，发现的问题不少。&lt;br/&gt;一是Jenkins的整个job的提交是由两步组成的，先是创建job，再提交配置。即：/createItem?name=xxx接口。&lt;br/&gt;二是提交的配置参数，提交的是整个xml，而不是由一个一个参数组成的。对于java来说，就得使用xstream或者其他来转化，甚是折腾，如图这种转化。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20181029112422597829257.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;构建的队列&quot;&gt;4.3 构建的队列&lt;/h4&gt;
&lt;p&gt;在点击立即构建的时候，Jenkins是没有返回任何信息，但是在Jenkins的内部，它是通过放到队列里等待的，如果有空闲，就开始构建，否则等待，这个队列是可以获取得到的，我们从里面可以获取上一次构建的信息，是成功还是失败。这种情况下，假设我们多个人同时点击，这下子就有点慌了，如何获取到具体某个人的构建结果，有点虐心。想了半天，最终得出的事：代码相同，意味着每次构建的结果相同，为什么要允许多个人同时点击？就这么解决了：从一个job的构建队列中获取最后一次构建的信息，如果是正在构建，那么不允许构建了，直到构建结果出来。&lt;/p&gt;
&lt;h4 id=&quot;构建进度的查看&quot;&gt;4.4 构建进度的查看&lt;/h4&gt;
&lt;p&gt;需要将Jenkins中的构建进度移植到我们自有的平台，Jenkins的构建进度时通过ajax轮询实现的，获取文本的规则主要从response header里面的两个字段获取&lt;br/&gt;（1）X-More-Data：是否有更多的数据&lt;br/&gt;（2）X-Text-Size：从开始到该次调用的文本大小&lt;br/&gt;我们是通过websocket来将文本内容推送到前端，使用的stomp协议，部分代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        while (true) {
            ...
            String string = response.body().string();
            String header = response.header(&quot;X-More-Data&quot;);
            if (!Strings.isNullOrEmpty(header) || start == 0) {
                template.convertAndSend(&quot;/topic/&quot; + uuid, string);
                String textSize = response.header(&quot;X-Text-Size&quot;);
                if (!Strings.isNullOrEmpty(textSize)) {
                    start = Integer.parseInt(textSize);
                }
                TimeUnit.SECONDS.sleep(5);
            } else {
                template.convertAndSend(&quot;/topic/&quot; + uuid, string);
                return;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;br/&gt;1.&lt;a href=&quot;https://www.cnblogs.com/jwentest/p/8204421.html&quot;&gt;通过jenkins API去build一个job&lt;/a&gt;&lt;br/&gt;2.&lt;a href=&quot;https://wiki.jenkins.io/display/JENKINS/Remote+access+API&quot;&gt;Jenkins Remote API&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 15:29:00 +0000</pubDate>
<dc:creator>ZepheryWen</dc:creator>
<og:description>公司主要要开发自己的paas平台，集成了Jenkins，真的是遇到了很多很多困难，特别是在api调用的权限这一块，这里，把自己遇到的一些坑的解决方法做一下笔记吧。当然，首先要讲的，就是如何在开启安全的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w1570631036/p/9861473.html</dc:identifier>
</item>
<item>
<title>Spring 12 种 常用注解! - Java-live-begin</title>
<link>http://www.cnblogs.com/wang-Java-begining/p/9874063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-Java-begining/p/9874063.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.声明bean的注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Component 组件，没有明确的角色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Service 在业务逻辑层使用（service层）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Repository 在数据访问层使用（dao层）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Controller 在展现层使用，控制器的声明（C）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.注入bean的注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Autowired：由Spring提供&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Inject：由JSR-330提供&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Resource：由JSR-250提供&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　都可以注解在set方法和属性上，推荐注解在属性上（一目了然，少写代码）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.java配置类相关注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Configuration 声明当前类为配置类，相当于xml形式的Spring配置（类上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式（方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean（类上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ComponentScan 用于对Component进行扫描，相当于xml中的（类上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.切面（AOP）相关注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Spring支持AspectJ的注解式切面编程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Aspect 声明一个切面（类上） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@After 在方法执行之后执行（方法上） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　@Before 在方法执行之前执行（方法上） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　@Around 在方法执行之前与之后执行（方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@PointCut 声明切点 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.@Bean的属性支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Scope 设置Spring容器如何新建Bean实例（方法上，得有@Bean） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　其设置类型包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Singleton （单例,一个Spring容器中只有一个bean实例，默认模式）, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　Protetype （每次调用新建一个bean）, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　Request （web项目中，给每个http request新建一个bean）, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　Session （web项目中，给每个http session新建一个bean）, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　GlobalSession（给每一个 global http session新建一个Bean实例）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@StepScope 在Spring Batch中还有涉及&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.@Value注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Value 为属性注入值（属性上） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　支持如下方式的注入： &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　》注入普通字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;Michael Jackson&quot;)String&lt;span class=&quot;Apple-converted-space&quot;&gt; name;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入操作系统属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;#{systemProperties['os.name']}&quot;)String&lt;span class=&quot;Apple-converted-space&quot;&gt; osName;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入表达式结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;#{&lt;span class=&quot;Apple-converted-space&quot;&gt; T(java.lang.Math).random() *&lt;span class=&quot;Apple-converted-space&quot;&gt; 100&lt;span class=&quot;Apple-converted-space&quot;&gt; }&quot;) String&lt;span class=&quot;Apple-converted-space&quot;&gt; randomNumber;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入其它bean属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;#{domeClass.name}&quot;)String&lt;span class=&quot;Apple-converted-space&quot;&gt; name;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入文件资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;classpath:com/hgs/hello/test.txt&quot;)String&lt;span class=&quot;Apple-converted-space&quot;&gt; Resource file;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入网站资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Value(&quot;http://www.javastack.cn&quot;)Resource url;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　》注入配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Value(&quot;${book.name}&quot;)String&lt;span class=&quot;Apple-converted-space&quot;&gt; bookName;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注入配置使用方法： &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　① 编写配置文件（test.properties）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　book.name=《三体》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② @PropertySource 加载配置文件(类上)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@PropertySource(&quot;classpath:com/hgs/hello/test/test.propertie&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③ 还需配置一个PropertySourcesPlaceholderConfigurer的bean。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.环境切换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Profile 通过设定Environment的ActiveProfiles来设定当前context需要使用的配置环境。（类或方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Conditional Spring4中可以使用此注解定义条件话的bean，通过实现Condition接口，并重写matches方法，从而决定该bean是否被实例化。（方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247484241&amp;amp;idx=1&amp;amp;sn=2d0378b4842db91985f61c5388584b0c&amp;amp;chksm=eb538667dc240f71c1746f6dd74cc9b3d94a58868139c4a102a8bd794f821467dddb06b543b0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;8.异步相关&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableAsync 配置类中，通过此注解开启对异步任务的支持，叙事性AsyncConfigurer接口（类上），点击&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247484241&amp;amp;idx=1&amp;amp;sn=2d0378b4842db91985f61c5388584b0c&amp;amp;chksm=eb538667dc240f71c1746f6dd74cc9b3d94a58868139c4a102a8bd794f821467dddb06b543b0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;这里&lt;/em&gt;&lt;/a&gt;了解使用详情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Async 在实际执行的bean方法使用该注解来申明其是一个异步任务（方法上或类上&lt;em&gt;所有的方法都将异步&lt;/em&gt;，需要@EnableAsync开启异步任务）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9.定时任务相关&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableScheduling 在配置类上使用，开启计划任务的支持（类上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Scheduled 来申明这是一个任务，包括cron,fixDelay,fixRate等类型（方法上，需先开启计划任务的支持）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.@Enable*注解说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些注解主要用来开启对xxx的支持。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　@EnableAspectJAutoProxy 开启对AspectJ自动代理的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableAsync 开启异步方法的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableScheduling 开启计划任务的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableWebMvc 开启Web MVC的配置支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableConfigurationProperties 开启对@ConfigurationProperties注解配置Bean的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableJpaRepositories 开启对SpringData JPA Repository的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableTransactionManagement 开启注解式事务的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableTransactionManagement 开启注解式事务的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableCaching 开启注解式的缓存支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;11.测试相关注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@RunWith 运行器，Spring中通常用于对JUnit的支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@RunWith(SpringJUnit4ClassRunner.class)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ContextConfiguration 用来加载配置ApplicationContext，其中classes属性用来加载配置类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ContextConfiguration(classes={TestConfig.class})&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;12.SpringMVC相关注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@EnableWebMvc 在配置类中开启Web MVC的配置支持，如一些ViewResolver或者MessageConverter等，若无此句，重写WebMvcConfigurerAdapter方法（用于对SpringMVC的配置）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@Controller 声明该类为SpringMVC中的Controller&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@RequestMapping 用于映射Web请求，包括访问路径和参数（类或方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ResponseBody 支持将返回值放在response内，而不是一个页面，通常用户返回json数据（返回值旁或方法上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@RequestBody 允许request的参数在request体中，而不是在直接连接在地址后面。（放在参数前）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@PathVariable 用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@RestController 该注解为一个组合注解，相当于@Controller和@ResponseBody的组合，注解在类上，意味着，该Controller的所有方法都默认加上了@ResponseBody。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ControllerAdvice 通过该注解，我们可以将对于控制器的全局配置放置在同一个位置，注解了@Controller的类的方法可使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上， &lt;/span&gt;&lt;br/&gt;&lt;span&gt;这对所有注解了 @RequestMapping的控制器内的方法有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ExceptionHandler 用于全局处理控制器里的异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@InitBinder 用来设置WebDataBinder，WebDataBinder用来自动绑定前台请求参数到Model中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　@ModelAttribute 本来的作用是绑定键值对到Model里，在@ControllerAdvice中是让全局的@RequestMapping都能获得在此处设置的键值对。 &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 15:26:00 +0000</pubDate>
<dc:creator>Java-live-begin</dc:creator>
<og:description>Java 必须掌握的 12 种 Spring 常用注解！ 1.声明bean的注解 @Component 组件，没有明确的角色 @Service 在业务逻辑层使用（service层） @Reposito</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wang-Java-begining/p/9874063.html</dc:identifier>
</item>
<item>
<title>傻瓜式解读koa中间件处理模块koa-compose - 若邪</title>
<link>http://www.cnblogs.com/jaycewu/p/9873980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaycewu/p/9873980.html</guid>
<description>&lt;p&gt;最近需要单独使用到koa-compose这个模块，虽然使用koa的时候大致知道中间件的执行流程，但是没仔细研究过源码用起来还是不放心(主要是这个模块代码少，多的话也没兴趣去研究了)。&lt;/p&gt;
&lt;p&gt;koa-compose看起来代码少，但是确实绕。闭包，递归，Promise。。。看了一遍脑子里绕不清楚。看了网上几篇解读文章，都是针对单行代码做解释，还是绕不清楚。最后只好采取一种傻瓜的方式：&lt;/p&gt;
&lt;p&gt;koa-compose去掉一些注释，类型校验后，源码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function compose (middleware) {
  return function (context, next) {
    // last called middleware #
    let index = -1
    return dispatch(0)
    function dispatch (i) {
      if (i &amp;lt;= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve()
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写出如下代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var index = -1;
function compose() {
    return dispatch(0)
}
function dispatch (i) {
      if (i &amp;lt;= index) return Promise.reject(new Error('next() called multiple times'))
      index = i
      var fn = middleware[i]
      if (i === middleware.length) fn = next
      if (!fn) return Promise.resolve('fn is undefined')
      try {
        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
      } catch (err) {
        return Promise.reject(err)
      }
 }
 
 function f1(context,next){
    console.log('middleware 1');
    next().then(data=&amp;gt;console.log(data));
    console.log('middleware 1');
    return 'middleware 1 return';
  }
  function f2(context,next){
    console.log('middleware 2');
    next().then(data=&amp;gt;console.log(data));
    console.log('middleware 2');
    return 'middleware 2 return';
  }
  function f3(context,next){
    console.log('middleware 3');
    next().then(data=&amp;gt;console.log(data));
    console.log('middleware 3');
    return 'middleware 3 return';
  }
var middleware=[
  f1,f2,f3
]

var context={};
var next=function(context,next){
    console.log('middleware 4');
    next().then(data=&amp;gt;console.log(data));
    console.log('middleware 4');
    return 'middleware 4 return';
};
compose().then(data=&amp;gt;console.log(data));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接运行结果如下：&lt;/p&gt;
&lt;p&gt;&quot;middleware 1&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 1&quot;&lt;/p&gt;
&lt;p&gt;&quot;fn is undefined&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 1 return&quot;&lt;/p&gt;
&lt;p&gt;按着代码运行流程一步步分析：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dispatch(0)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;i==0,index==-1 i&amp;gt;index 往下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;index=0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;fn=f1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve(f1(context, dispatch.bind(null, 0 + 1)))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这就会执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;f1(context, dispatch.bind(null, 0 + 1))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;进入到f1执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 1');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 1&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实就是调用&lt;code&gt;dispatch(1)&lt;/code&gt; bind的功劳&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;递归开始&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dispatch(1)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;i==1,index==0 i&amp;gt;index 往下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;index=1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;fn=f2&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve(f2(context, dispatch.bind(null, 1 + 1)))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这就会执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;f2(context, dispatch.bind(null, 1 + 1))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;进入到f2执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 2');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 2&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实就是调用&lt;code&gt;dispatch(2)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着递归&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dispatch(2)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;i==2,index==1 i&amp;gt;index 往下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;index=2&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;fn=f3&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve(f3(context, dispatch.bind(null, 2 + 1)))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这就会执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;f3(context, dispatch.bind(null, 2 + 1))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;进入到f3执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 3');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 3&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实就是调用&lt;code&gt;dispatch(3)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着递归&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dispatch(3)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;i==3,index==2 i&amp;gt;index 往下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;index=3&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;i === middleware.length&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fn=next&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve(next(context, dispatch.bind(null, 3 + 1)))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这就会执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;next(context, dispatch.bind(null, 3 + 1))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;进入到next执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 4');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 4&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实就是调用&lt;code&gt;dispatch(4)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着递归&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dispatch(4)&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;i==4,index==3 i&amp;gt;index 往下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;index=4&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fn=middleware[4]&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;fn=undefined&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;reuturn Promise.resolve('fn is undefined')&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;回到next执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 4');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 4&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;return 'middleware 4 return'&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve('middleware 4 return')&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;回到f3执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 3');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 3&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;return 'middleware 3 return'&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve('middleware 3 return')&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;回到f2执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 2');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 2&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;return 'middleware 2 return'&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve('middleware 2 return')&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;回到f1执行上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;console.log('middleware 1');&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输出middleware 1&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;return 'middleware 1 return'&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Promise.resolve('middleware 1 return')&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;回到全局上下文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;至此已经输出&lt;/p&gt;
&lt;p&gt;&quot;middleware 1&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 1&quot;&lt;/p&gt;
&lt;p&gt;那么&lt;/p&gt;
&lt;p&gt;&quot;fn is undefined&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 4 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 3 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 2 return&quot;&lt;/p&gt;
&lt;p&gt;&quot;middleware 1 return&quot;&lt;/p&gt;
&lt;p&gt;怎么来的呢&lt;/p&gt;
&lt;p&gt;回头看一下，每个中间件里都有&lt;/p&gt;
&lt;p&gt;&lt;code&gt;next().then(data=&amp;gt;console.log(data));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照之前的分析，then里最先拿到结果的应该是next中间件的，而且结果就是&lt;code&gt;Promise.resolve('fn is undefined')&lt;/code&gt;的结果，然后分别是f4,f3,f2,f1。那么为什么都是最后才输出呢？&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Promise.resolve('fn is undefined').then(data=&amp;gt;console.log(data));
console.log('middleware 4');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下就清楚了&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;setTimeout(()=&amp;gt;console.log('fn is undefined'),0);
console.log('middleware 4');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个调用过程还可以看成是这样的：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function composeDetail(){
  return Promise.resolve(
    f1(context,function(){
      return Promise.resolve(
        f2(context,function(){
          return Promise.resolve(
            f3(context,function(){
              return Promise.resolve(
                next(context,function(){
                  return Promise.resolve('fn is undefined')
                })
              )
            })
          )
        })
      )
    })
  )
}
composeDetail().then(data=&amp;gt;console.log(data));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法虽蠢，但是compose的作用不言而喻了&lt;/p&gt;
&lt;p&gt;最后，&lt;code&gt;if (i &amp;lt;= index) return Promise.reject(new Error('next() called multiple times'))&lt;/code&gt;这句代码何时回其作用呢？&lt;/p&gt;
&lt;p&gt;一个中间件里调用两次&lt;code&gt;next()&lt;/code&gt;，按照上面的套路走，相信很快就明白了。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 15:06:00 +0000</pubDate>
<dc:creator>若邪</dc:creator>
<og:description>最近需要单独使用到koa compose这个模块，虽然使用koa的时候大致知道中间件的执行流程，但是没仔细研究过源码用起来还是不放心(主要是这个模块代码少，多的话也没兴趣去研究了)。 koa comp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jaycewu/p/9873980.html</dc:identifier>
</item>
<item>
<title>实验的方差分析（R语言） - EndlessCoding</title>
<link>http://www.cnblogs.com/endlesscoding/p/9863790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endlesscoding/p/9863790.html</guid>
<description>&lt;blockquote readability=&quot;5.709219858156&quot;&gt;
&lt;p&gt;实验设计与数据处理（大数据分析B中也用到F分布，故总结一下，加深印象）第3课小结——实验的方差分析（one-way analysis of variance）&lt;br/&gt;文章出自：&lt;a href=&quot;https://www.cnblogs.com/endlesscoding/p/9863790.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/endlesscoding/p/9863790.html&lt;/a&gt;，未经博主同意，请勿转载。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;实验结果&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;受多个因素&lt;span class=&quot;math inline&quot;&gt;\(A_i\)&lt;/span&gt;影响，但影响的程度各不相同，如何通过实验数据来确定因素的影响程度呢？其函数关系为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ S=f(A_1,A_2,\cdots,A_n) \tag{1} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方差&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;标准差的平方&lt;/code&gt;，表征&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(\bar{x}\)&lt;/span&gt;的&lt;strong&gt;偏离程度&lt;/strong&gt;。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;方差分析（ANalysis Of VAriance，简称&lt;code&gt;ANOVA&lt;/code&gt;）&lt;br/&gt;利用实验数据与均值的&lt;strong&gt;偏离程度&lt;/strong&gt;来判断各因素对实验结果影响&lt;code&gt;显著性&lt;/code&gt;程度的方法。 方差分析实质上是研究&lt;code&gt;自变量&lt;/code&gt;（因素）与&lt;code&gt;因变量&lt;/code&gt;（实验结果）的相互关系&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;指标（experimental index）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;衡量或考核实验效果的参数 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因素（experimental factor）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;影响实验指标的条件，可控因素&lt;/p&gt;
&lt;p&gt;因素的不同状态或内容&lt;/p&gt;

&lt;h2 id=&quot;单因素实验方差分析基本问题&quot;&gt;单因素实验方差分析基本问题&lt;/h2&gt;
&lt;p&gt;（1）目的：检验一个因素对实验结果的影响是否显著性&lt;/p&gt;
&lt;h2 id=&quot;单因素实验方差分析基本步骤&quot;&gt;单因素实验方差分析基本步骤&lt;/h2&gt;
&lt;h3 id=&quot;计算平均值&quot;&gt;1）计算平均值&lt;/h3&gt;
&lt;p&gt;组内平均值（同一水平的平均值）&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x_i}=\frac{1}{n_i}\sum_{j=1}^{n_i}{x_{ij}} \tag{2} \]&lt;/span&gt;&lt;br/&gt;总平均值&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline {x_i}=\frac{1}{n}\sum_{i=1}^{r}\sum_{j=1}^{n_i}{x_{ij}} \tag{3} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算离差平方和&quot;&gt;2）计算离差平方和&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;总离差平方和&lt;span class=&quot;math inline&quot;&gt;\(SS_T\)&lt;/span&gt;（sum of squares for total）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_T = \sum_{i=1}^{r}{\sum_{j=1}^{n_i}({x_{ij}-\overline{x}})^2} \tag{4} \]&lt;/span&gt;&lt;br/&gt;表示了各实验值与总平均值的偏差的平方和&lt;br/&gt;反映了实验结果之间存在的总差异&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;组间离差平方和 &lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt; （sum of square for factor A）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_A = \sum_{i=1}^{r}{\sum_{j=1}^{n_i}({\overline{x_{i}}-\overline{x}})^2} =\sum_{i=1}^{r}n_i({\overline{x_{i}}-\overline{x}})^2 \tag{5} \]&lt;/span&gt;&lt;br/&gt;反映了各组内平均值之间的差异程度&lt;br/&gt;由于因素A不同水平的不同作用造成的&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;组内离差平方和$ SS_e $（sum of square for error）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_T = \sum_{i=1}^{r}{\sum_{j=1}^{n_i}({x_{ij}-\overline{x}_i})^2} \tag{6} \]&lt;/span&gt;&lt;/p&gt;
反映了在各水平内，各实验值之间的差异程度&lt;br/&gt;由于随机误差的作用产生&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;三种离差平方和之间关系：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_T = SS_A + SS_e \tag{7} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;计算自由度degree-of-freedom&quot;&gt;3）计算自由度（degree of freedom）&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;总自由度（&lt;span class=&quot;math inline&quot;&gt;\(SS_T\)&lt;/span&gt;对应的自由度）：&lt;span class=&quot;math inline&quot;&gt;\(df_T=n-1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;组间自由度（&lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt;对应的自由度）：&lt;span class=&quot;math inline&quot;&gt;\(df_A=r-1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;组内自由度（&lt;span class=&quot;math inline&quot;&gt;\(SS_e\)&lt;/span&gt;对就的自由度）：&lt;span class=&quot;math inline&quot;&gt;\(df_e=n-r\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;三者关系：&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_T=df_A+df_e\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算平均平方&quot;&gt;4）计算平均平方&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;均方 = 离差平方和除以对应的自由度&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ MS_A = SS_A/df_A \quad \quad MS_e = SS_e / df_e \]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;式中，&lt;span class=&quot;math inline&quot;&gt;\(MA_A\)&lt;/span&gt;——组间均方，&lt;span class=&quot;math inline&quot;&gt;\(MS_e\)&lt;/span&gt;——组内均方/误差的均方&lt;/p&gt;
&lt;h3 id=&quot;f检验&quot;&gt;5）F检验&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ F_A = \frac{组间均方}{组内均方}=\frac{MS_A}{MS_e} \tag{8} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_A,df_e)\)&lt;/span&gt;的&lt;code&gt;F分布&lt;/code&gt;（F distribution）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于给定的显著性水平&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;，从&lt;code&gt;F分布表&lt;/code&gt;查得临界值&lt;span class=&quot;math inline&quot;&gt;\(F_{\alpha}(df_A,df_e)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_A &amp;gt; F_{\alpha}(df_A,df_e)\)&lt;/span&gt;，则认为因素A对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素A对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;方差分析表&quot;&gt;6）方差分析表&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;组间（因素A）&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(r-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A=SS_A/(r-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;组内（误差）&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(n-r\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_e=SS_e/(n-r)\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;总和&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_T\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(n-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;若&lt;span class=&quot;math inline&quot;&gt;\(F_A &amp;gt; F_{0.01}(df_A,df_e)\)&lt;/span&gt;，称因素A对实验结果有&lt;code&gt;非常显著&lt;/code&gt;的影响，用&lt;code&gt;**&lt;/code&gt;号表示；&lt;/li&gt;
&lt;li&gt;若&lt;span class=&quot;math inline&quot;&gt;\(F_{0.05}(df_A,df_e)&amp;lt;F_A&amp;lt;F_{0.01}(df_A,df_e)\)&lt;/span&gt;，则因素A对实验结果&lt;code&gt;有显著&lt;/code&gt;的影响，用&lt;code&gt;*&lt;/code&gt;号表示；&lt;/li&gt;
&lt;li&gt;若&lt;span class=&quot;math inline&quot;&gt;\(F_A &amp;lt; F_{0.05}(df_A,df_e)\)&lt;/span&gt;，称因素A对实验结果的影响&lt;code&gt;不显著&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;讨论两个因素对实验结果影响的显著性，以称&lt;code&gt;二元方差分析&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;双因素无重复实验的方差分析&quot;&gt;双因素无重复实验的方差分析&lt;/h2&gt;
&lt;p&gt;双因素无重复实验&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{11}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{12}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{1s}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{21}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{22}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{2s}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_r\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{r1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{r2}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(\cdots\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_{rs}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;计算平均值-1&quot;&gt;1）计算平均值&lt;/h3&gt;
&lt;p&gt;总平均：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} = \frac{1}{rs}\sum_{i=1}^{r}{\sum_{j=1}^{s}x_{ij}} \tag{9} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_i\)&lt;/span&gt;水平时：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x}_{i\cdot} = \frac{1}{s}\sum_{j=1}^{s}x_{ij} \tag{10} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(B_j\)&lt;/span&gt;水平时：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x}_{{\cdot}j}= \frac{1}{r}\sum_{i=1}^{s}x_{ij} \tag{11} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算离差平方和-1&quot;&gt;2）计算离差平方和&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;总离差平方和：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} =\sum_{i=1}^{r}{\sum_{j=1}^{s}{(x_{ij}-\overline{x})^2}} \tag{12} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因素A引起离差平方和:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} =\sum_{i=1}^{r}{\sum_{j=1}^{s}{(x_{i{\cdot}}-\overline{x})^2}}=s\sum_{j=1}^{r}{(x_{i{\cdot}}-\overline{x})^2} \tag{13} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因素B引起的离差平方和:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} =\sum_{i=1}^{r}{\sum_{j=1}^{s}{(x_{{\cdot}j}-\overline{x})^2}}=r\sum_{j=1}^{s}{(x_{{\cdot}j}-\overline{x})^2} \tag{14} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;误差平方和:&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} =\sum_{i=1}^{r}{\sum_{j=1}^{s}{(x_{ij}-x_{i{\cdot}}-x_{{\cdot}j}-\overline{x})^2}} \tag{15} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算自由度&quot;&gt;3）计算自由度&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_A=r-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_B=s-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_e=(r-1)(s-f)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_T=n-1=rs-1\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;计算均方&quot;&gt;4）计算均方&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A=\dfrac{SS_A}{df_A}=\dfrac{SS_A}{r-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B=\dfrac{SS_B}{df_A}=\dfrac{SS_B}{s-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_e=\dfrac{SS_e}{df_e}=\dfrac{SS_e}{(r-1)(s-1)}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;f-检验&quot;&gt;5）F 检验&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_A\)&lt;/span&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_A,df_e)\)&lt;/span&gt;的F分布：&lt;span class=&quot;math inline&quot;&gt;\(F_A=\dfrac{MS_A}{MS_e}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_B\)&lt;/span&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_B,df_e)\)&lt;/span&gt;的F分布：&lt;span class=&quot;math inline&quot;&gt;\(F_A=\dfrac{MS_B}{MS_e}\)&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于给定的的显著性水平&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;，查F分布表：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ F_{\alpha}(df_A,df_e) \quad \quad F_{\alpha}(df_B,df_e) \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_A &amp;gt; F_{\alpha}(df_A,df_e)\)&lt;/span&gt;，则认为因素A对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素A对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_B &amp;gt; F_{\alpha}(df_B,df_e)​\)&lt;/span&gt;，则认为因素A对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素A对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;无重复实验双因素方差分析表&quot;&gt;6）无重复实验双因素方差分析表&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;因素A&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(r-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A=SS_A/(r-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;因素B&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_B\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(s-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B=SS_B/(s-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;误差&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\((r-1)(s-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_e=SS_e/((r-1)(s-1))\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;总和&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_T\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(rs-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;双因素重复实验基本问题&quot;&gt;双因素重复实验基本问题&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;交互作用——因素间的联全作用称为交互作用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;因素间没有联合作用——相互独立，独立效应&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;因素间有联合作用——交互作用，交互效应&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;双因素重复实验方差分析基本步骤&quot;&gt;双因素重复实验方差分析基本步骤&lt;/h2&gt;
&lt;h3 id=&quot;计算平均值-2&quot;&gt;1）计算平均值&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;组合水平&lt;span class=&quot;math inline&quot;&gt;\(（A_i,B_i）\)&lt;/span&gt;上的&lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;次实验值的算术平均值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x}_{ij{\cdot}}=\frac{1}{c}\sum_{k=1}^{c}{x_{ijk}},i=1,2,\cdots,r;j=1,2,\cdots,s \tag{16} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_i\)&lt;/span&gt;水平时所有实验值的算术平均值：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x}_{i\cdot\cdot} = \frac{1}{sc}\sum_{j=1}^{s}x_{ijk} = \frac{1}{s}\sum_{j=1}^{s}x_{ijk},i=1,2,\cdots,r \tag{17} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(B_j\)&lt;/span&gt;水平时：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x}_{i\cdot\cdot} = \frac{1}{rc}\sum_{j=1}^{s}x_{ijk} = \frac{1}{r}\sum_{j=1}^{r}x_{ij\cdot},j=1,2,\cdots,s \tag{18} \]&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有实验的总平均值：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} = \frac{1}{rsc} \sum_{i=1}^{r}\sum_{j=1}^{s}\sum_{k=1}^{c}x_{ijk} \tag{19} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算离差平方和-2&quot;&gt;2）计算离差平方和&lt;/h3&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;总离差平方和：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_T=\frac{1}{rsc}\sum_{i=1}^{r}\sum_{j=1}^{s}\sum_{k=1}^{c}{(x_{ijk}-\overline{x})^2} = SS_A+SS_B+SS_{A\times{B}}+SS_e \tag{20} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt;为A引起的离差平方和：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_A = sc\sum_{i=1}^{r}{(\overline{x}_{i\cdot\cdot}-\overline{x})^2} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_B\)&lt;/span&gt;为B引起的离差平方和：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_B = rc\sum_{j=1}^{s}{(\overline{x}_{\cdot{j}\cdot}-\overline{x})^2} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_{A\times{B}}\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(A\times{B}\)&lt;/span&gt;引起的离差平方和：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ SS_{A\times{B}} = c\sum_{i=1}^{r}\sum_{j=1}{s}{(\overline{x}_{ij\cdot}-\overline{x}_{i\cdot\cdot}-\overline{x}_{\cdot{j}\cdot}+\overline{x})^2} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_e\)&lt;/span&gt;为误差平方和：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \overline{x} = \sum_{i=1}^{r}\sum_{j=1}^{s}\sum_{k=1}^{c}{(x_{ijk}-\overline{x}_{ij\cdot})^2} \]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算自由度-1&quot;&gt;3）计算自由度&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_A=r-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_B=s-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_{A\times{B}}=(r-1)(n-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_e=rs(c-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(df_T=n-1=rsc-1\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;计算均方-1&quot;&gt;4）计算均方&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A=\dfrac{SS_A}{df_A}=\dfrac{SS_A}{r-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B=\dfrac{SS_B}{df_A}=\dfrac{SS_B}{s-1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_{A\times{B}}=\dfrac{SS_{A\times{B}}}{(r-1)(s-1)}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_e=\dfrac{SS_e}{df_e}=\dfrac{SS_e}{rs(c-1)}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;f-检验-1&quot;&gt;5）F 检验&lt;/h3&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_A\)&lt;/span&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_A,df_e)\)&lt;/span&gt;的F分布：&lt;span class=&quot;math inline&quot;&gt;\(F_A=\dfrac{MS_A}{MS_e}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_B\)&lt;/span&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_B,df_e)\)&lt;/span&gt;的F分布：&lt;span class=&quot;math inline&quot;&gt;\(F_A=\dfrac{MS_B}{MS_e}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(F_{A\times{B}}\)&lt;/span&gt;服从自由度为&lt;span class=&quot;math inline&quot;&gt;\((df_{A\times{B}},df_e)\)&lt;/span&gt;的F分布：&lt;span class=&quot;math inline&quot;&gt;\(F_A=\dfrac{MS_{A\times{B}}}{MS_e}\)&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;对于给定的的显著性水平&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;，查F分布表：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ F_{\alpha}(df_A,df_e) \quad \quad F_{\alpha}(df_B,df_e) \quad \quad F_{\alpha}(df_{A\times{B}},df_e) \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_A &amp;gt; F_{\alpha}(df_A,df_e)\)&lt;/span&gt;，则认为因素A对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素A对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_B &amp;gt; F_{\alpha}(df_B,df_e)\)&lt;/span&gt;，则认为因素B对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素B对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(F_{A\times{B}}&amp;gt; F_{\alpha}(df_{A\times{B}},df_e)\)&lt;/span&gt;，则认为交互作用&lt;span class=&quot;math display&quot;&gt;\[A\times{B}\]&lt;/span&gt;对实验结果&lt;code&gt;有显著影响&lt;/code&gt;，否则认为因素&lt;span class=&quot;math inline&quot;&gt;\(A\times{B}\)&lt;/span&gt;对实验结果&lt;code&gt;没有显著影响&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;重复实验双因素方差分析表&quot;&gt;6）重复实验双因素方差分析表&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;因素A&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_A\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(r-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A=SS_A/(r-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_A/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;因素B&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_B\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(s-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B=SS_B/(s-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_B/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;交互作用&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_{A\times{B}}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\((r-1)(s-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_{A\times{B}}=\dfrac{SS_{A\times{B}}}{(r-1)(s-1)}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_{A\times{B}}/MS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;误差&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_e\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(rs(c-1)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(MS_c=SS_e/(rs(c-1))\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;总和&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(SS_T\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(rsc-1\)&lt;/span&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;r语言重复实验方差分析&quot;&gt;R语言重复实验方差分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;例:&lt;/strong&gt;下表中给出了某种化式产品在3种浓度、4种温度水平下得率的数据，试检验各因素及交互作用对产品得率的影响是否显著。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;14,11&lt;/td&gt;
&lt;td&gt;11,11&lt;/td&gt;
&lt;td&gt;13,9&lt;/td&gt;
&lt;td&gt;10,12&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;9,7&lt;/td&gt;
&lt;td&gt;10,8&lt;/td&gt;
&lt;td&gt;7,11&lt;/td&gt;
&lt;td&gt;6,10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5,11&lt;/td&gt;
&lt;td&gt;13,14&lt;/td&gt;
&lt;td&gt;12,13&lt;/td&gt;
&lt;td&gt;14,10&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们令：A因素：&lt;strong&gt;浓度&lt;/strong&gt;，B因素：&lt;strong&gt;温度&lt;/strong&gt;，由题可得，重复次数&lt;span class=&quot;math inline&quot;&gt;\(c=2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以分析出如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td/&gt;
&lt;td&gt;浓度/%&lt;/td&gt;
&lt;td&gt;10℃&lt;/td&gt;
&lt;td&gt;24℃&lt;/td&gt;
&lt;td&gt;38℃&lt;/td&gt;
&lt;td&gt;52℃&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;14,11&lt;/td&gt;
&lt;td&gt;11,11&lt;/td&gt;
&lt;td&gt;13,9&lt;/td&gt;
&lt;td&gt;10,12&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_2\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;9,7&lt;/td&gt;
&lt;td&gt;10,8&lt;/td&gt;
&lt;td&gt;7,11&lt;/td&gt;
&lt;td&gt;6,10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;span class=&quot;math inline&quot;&gt;\(A_3\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;5,11&lt;/td&gt;
&lt;td&gt;13,14&lt;/td&gt;
&lt;td&gt;12,13&lt;/td&gt;
&lt;td&gt;14,10&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;接下来，我们在&lt;code&gt;RStudio&lt;/code&gt;（如果RStudio没有安装的，网上有大量的教程）中录入我们的数据，代码如下&lt;/p&gt;
&lt;pre class=&quot;r&quot;&gt;
&lt;code&gt;X &amp;lt;- c(14,9,5,11,10,13,13,7,12,10,6,14,10,7,11,11,8,14,9,11,13,12,10,10)
chemistryProduct&amp;lt;-data.frame(X,A=gl(3,1,24),B=gl(4,3,24),c=gl(12,1,24))
chemistryProduct.aov&amp;lt;-aov(X~A*B,data = chemistryProduct)
summary(chemistryProduct.aov)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;对上述代码的第1行和第2行简单说明一下。&lt;br/&gt;第1行中，X数据的输入，是以列的方向输入，先输入第1次实验的数据，输入完成后再按第1次的顺序输入第2次实验数据。&lt;/p&gt;
&lt;p&gt;第2行中，&lt;code&gt;A=gl(3,1,24)&lt;/code&gt;，第一个数&lt;code&gt;3&lt;/code&gt;表示有3行，第二个数&lt;code&gt;1&lt;/code&gt;表示行方向只增加1，第三个数&lt;code&gt;24&lt;/code&gt;表示总共有24个数据。后面的同理。可以查看一下它的输出如下，不难发现其中的输入规律。&lt;/p&gt;
&lt;p&gt;可以在RStudio中查看chemistryProduct的数据结构，多试一下，自行体会一下其中的A，B，c的规律。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;&amp;gt; chemistryProduct
    X A B  c
1  14 1 1  1
2   9 2 1  2
3   5 3 1  3
4  11 1 2  4
5  10 2 2  5
6  13 3 2  6
7  13 1 3  7
8   7 2 3  8
9  12 3 3  9
10 10 1 4 10
11  6 2 4 11
12 14 3 4 12
13 10 1 1  1
14  7 2 1  2
15 11 3 1  3
16 11 1 2  4
17  8 2 2  5
18 14 3 2  6
19  9 1 3  7
20 11 2 3  8
21 13 3 3  9
22 12 1 4 10
23 10 2 4 11
24 10 3 4 12&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到如下输出结果：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;            Df Sum Sq Mean Sq F value Pr(&amp;gt;F)  
A            2  44.33  22.167   4.092 0.0442 *
B            3  11.50   3.833   0.708 0.5657  
A:B          6  27.00   4.500   0.831 0.5684  
Residuals   12  65.00   5.417                 
---
Signif. codes:  
0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将实验结果写成上文所述的方差分析表，如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;因素A&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;44.33&lt;/td&gt;
&lt;td&gt;22.167&lt;/td&gt;
&lt;td&gt;4.092&lt;/td&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;因素B&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;11.50&lt;/td&gt;
&lt;td&gt;3.833&lt;/td&gt;
&lt;td&gt;0.708&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;交互作用&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;27.00&lt;/td&gt;
&lt;td&gt;4.500&lt;/td&gt;
&lt;td&gt;0.831&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;误差&lt;/td&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;65.00&lt;/td&gt;
&lt;td&gt;5.417&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;总和&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;由分析结果可知，因素A对产品得率有显著性影响。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 15:00:00 +0000</pubDate>
<dc:creator>EndlessCoding</dc:creator>
<og:description>实验设计与数据处理（大数据分析B中也用到F分布，故总结一下，加深印象）第3课小结——实验的方差分析（one way analysis of variance） 文章出自：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/endlesscoding/p/9863790.html</dc:identifier>
</item>
<item>
<title>Python 装饰器入门(下) - 丁壮</title>
<link>http://www.cnblogs.com/flashBoxer/p/9873918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashBoxer/p/9873918.html</guid>
<description>&lt;p&gt;继续上次的进度:https://www.cnblogs.com/flashBoxer/p/9847521.html&lt;/p&gt;

&lt;h3&gt;装饰类&lt;/h3&gt;
&lt;p&gt;在类中有两种不通的方式使用装饰器，第一个和我们之前做过的函数非常相似:在类的方法上应用。这也是当时引入装饰器的原因之一&lt;/p&gt;&lt;p&gt;一些常用的装饰器已经内置到python中，像@classmethod @staticmethod @property。这三个装饰器我们之前都介绍过，这段就不翻译了(打字手酸，偷懒下)&lt;/p&gt;&lt;p&gt;下面的Circle 类使用了@classmethod @staticmethod和@property三个装饰器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Circle:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, radius):
        self._radius &lt;/span&gt;=&lt;span&gt; radius

    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; radius(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Get value of radius&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._radius

    @radius.setter
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; radius(self, value):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Set radius, raise error if negative&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; value &amp;gt;=&lt;span&gt; 0:
            self._radius &lt;/span&gt;=&lt;span&gt; value
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; ValueError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Radius must be positive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    @property
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; area(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Calculate area inside circle&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self.pi() * self.radius**2

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; cylinder_volume(self, height):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Calculate volume of cylinder with circle as base&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; self.area *&lt;span&gt; height

    @classmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; unit_circle(cls):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Factory method creating a circle with radius 1&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; cls(1&lt;span&gt;)

    @staticmethod
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pi():
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Value of π, could use math.pi instead though&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; 3.1415926535
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个类中&lt;br/&gt;    .cylinder_volume()是一个常规函数&lt;br/&gt;    .radius是一个可变属性:它可以被设置不同的值.然而通过定义setter方法，我们可以做一些判断来确保它不会被设置成一个没有意义的负数，.radius作为属性访问，不使用括号&lt;br/&gt;    .area 是一个不可变的属性:没有.setter()方法的属性是无法更改的，即使它被定义为一个方法，它也被作为不需要括号的属性来使用。&lt;br/&gt;    .unit_circle() 是一个类方法。它不被绑定到Circle的实例上.类方法通常用在工厂模式，用来创建类的特殊实例&lt;br/&gt;    .pi() 是一个静态方法.除了命名空间外它不依赖Circle类。静态方法可以在实例或类上调用。&lt;/p&gt;

&lt;p&gt;Circle类的使用例子:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; c = Circle(5&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; c.radius
&lt;/span&gt;5

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; c.area
&lt;/span&gt;78.5398163375

&amp;gt;&amp;gt;&amp;gt; c.radius = 2
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; c.area
&lt;/span&gt;12.566370614

&amp;gt;&amp;gt;&amp;gt; c.area = 100&lt;span&gt;
AttributeError: can&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t set attribute&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt; c.cylinder_volume(height=4&lt;span&gt;)
&lt;/span&gt;50.265482456

&amp;gt;&amp;gt;&amp;gt; c.radius = -1&lt;span&gt;
ValueError: Radius must be positive

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; c =&lt;span&gt; Circle.unit_circle()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; c.radius
&lt;/span&gt;1

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; c.pi()
&lt;/span&gt;3.1415926535

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; Circle.pi()
&lt;/span&gt;3.1415926535
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让我们定义一个类，在这个类中，我们会用到前面的@debug和@timer装饰器:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; debug, timer

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TimeWaster:
    @debug
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, max_num):
        self.max_num &lt;/span&gt;=&lt;span&gt; max_num

    @timer
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; waste_time(self, num_times):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_times):
            sum([i&lt;/span&gt;**2 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(self.max_num)])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看一下结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; tw = TimeWaster(1000&lt;span&gt;)
Calling &lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;(&amp;lt;time_waster.TimeWaster object at 0x7efccce03908&amp;gt;, 1000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; returned None

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; tw.waste_time(999&lt;span&gt;)
Finished &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;waste_time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; 0.3376 secs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外一种方式是在整个类上使用装饰器.这里有个Python3.7中的dataclasses方法用例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; dataclasses &lt;span&gt;import&lt;/span&gt;&lt;span&gt; dataclass

@dataclass
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PlayingCard:
    rank: str
    suit: str&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语法的类似于函数装饰器。在上面的例子中，也可以通过PlayingCard = dataclass(PlayingCard)来实现。&lt;/p&gt;&lt;p&gt;类装饰器的一种简单用法是作为元类方式的替代.在两种情况下，你都在动态的改变一个类的定义&lt;/p&gt;&lt;p&gt;类的装饰器和函数的装饰器语法接近，不同的是装饰器需要接收一个类而不是一个函数作为参数.事实上，上面的装饰器都可以作用于类，但当你这么用的时候，你可能得不到预期的结果。下面将@timer装饰器应用到一个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; timer

@timer
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TimeWaster:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, max_num):
        self.max_num &lt;/span&gt;=&lt;span&gt; max_num

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; waste_time(self, num_times):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_times):
            sum([i&lt;/span&gt;**2 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(self.max_num)])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@timer只是TimeWaster = timer(TimeWaster)的缩写&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在这里@timer只能显示类实例化需要的时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; tw = TimeWaster(1000&lt;span&gt;)
Finished &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TimeWaster&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; 0.0000&lt;span&gt; secs

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; tw.waste_time(999&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在后面会有一个正确的类装饰器的示例@singleton。它保证一个类只有一个实例&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;嵌套的装饰器&lt;/h3&gt;
&lt;p&gt;&lt;br/&gt;可以将多个装饰器叠加到一个函数上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; debug, do_twice

@debug
@do_twice
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; greet(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行的顺序会按照叠加的顺序, @debug 调用 @do_twice @do_twice 调用greet()，或者debug(do_twice(greet()))  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; greet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Eva&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Calling greet(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Eva&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Hello Eva
Hello Eva
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greet&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; returned None        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更改@debug和@do_twice的顺序:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; debug, do_twice

@do_twice
@debug
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; greet(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这种情况下，@do_twice也会被应用到@debug中: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; greet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Eva&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Calling greet(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Eva&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Hello Eva
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greet&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; returned None
Calling greet(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Eva&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Hello Eva
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;greet&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; returned None       
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;带参数的装饰器&lt;/h3&gt;
&lt;p&gt; 在需要传参给你的装饰器是这个例子会非常有用。例如,@do_twice可以扩展到@repeat(num_times)装饰器.然后，可以将执行的被装饰函数的次数作为参数给出。      &lt;br/&gt;可以这么做:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@repeat(num_times=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; greet(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)      
        
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; greet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Hello World
Hello World
Hello World
Hello World        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       &lt;br/&gt;考虑下如何实现这个功能&lt;/p&gt;&lt;p&gt;到目前为止,写在@后面写的名字引用一个可以被另外一个函数调用的函数对象，需要repeat(num_times=4)来返回一个函数对象，这个对象可以被作为装饰器，幸运的是，我们已经知道如何返回函数!一般来说，需要以下内容:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; repeat(num_times):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_repeat(func):
        ...  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create and return a wrapper function&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; decorator_repeat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常，装饰器创建并返回一个内部包装函数，所以完整地写出这个例子会给你一个内部函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; repeat(num_times):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_repeat(func):
        @functools.wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_repeat(*args, **&lt;span&gt;kwargs):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_times):
                value &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_repeat
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_repeat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子看起来有点乱，但我们只是添加了一个def来接收参数，这个装饰器语法我们之前处理过多次.让我们从最里面的函数开始:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; wrapper_repeat(*args, **&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_times):
        value &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;wrapper_repeat()函数接收任意参数，并放回被装饰函数的值，func(). 这个包装函数还包括了被装饰函数num_times的循环 ，除了必须要使用外部参数num_times外，和之前看到的装饰器函数没有什么不同，&lt;/p&gt;&lt;p&gt;再走一步，你就会发现装饰器函数:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_repeat(func):
    @functools.wraps(func)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_repeat(*args, **&lt;span&gt;kwargs):
        ...
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; wrapper_repeat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;decorator_repeat()和我们之前写的装饰器函数非常像,除了他的名字不同,因为我们为最外层的函数保留了基础名称repeat()，这个是用户要调用的函数。&lt;/p&gt;&lt;p&gt;最外层返回装饰器函数的引用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; repeat(num_times):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_repeat(func):
        ...
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_repeat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在repeat()中有一些细节:&lt;/p&gt;
&lt;p&gt;        将decorator_repeat()作为一个内部函数意味着repeat()将引用一个函数对象-decotator_repeat.之前，我们用没有括号的repeat来引用函数对象.定义带有参数的装饰器，就需要添加括号&lt;br/&gt;        &lt;br/&gt;        num_times参数看起来没有在repeat()本身中使用，但是通过传递num_times，会创建一个闭包，来存储num_times的值，直到wrapper_repeat()使用它为止。&lt;br/&gt;    &lt;br/&gt;一切就绪后，让我们看看结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@repeat(num_times=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; greet(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; greet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Hello World
Hello World
Hello World
Hello World&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;这是我们想要的结果&lt;/p&gt;
&lt;h3&gt;Both Please, But Never Mind the Bread&lt;/h3&gt;
&lt;p&gt;稍微注意下.你可以把装饰器同时定义为带参数或者不带参数.你可能不需要这样，但更有灵活性也不错&lt;/p&gt;&lt;p&gt;前面已经看到，当装饰器需要参数的时候，需要有一个额外的外部函数，困难在于，代码需要知道装饰器是否被调用了，是否有参数&lt;/p&gt;&lt;p&gt;因为只有在没有参数的情况下调用装饰器时才会直接传递装饰的函数，这个函数必须是可选参数.意味着装饰器参数必须要友关键字指定，可以使用特殊的*，也就是说，下面的参数都是关键字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; name(_func=None, *, kw1=val1, kw2=val2, ...):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_name(func):
        ...  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create and return a wrapper function.&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; _func &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_name                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_name(_func)               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;_func参数是一个标记，提示装饰器被调用的时候是否有参数&lt;br/&gt;    1.如果name调用的时候没有传参,被装饰函数会被作为_func传入.如果有参数传入,_func会被置为None,一些关键字参数可能已不再是默认值， 参数列表中的*表示其余参数不能作为位置参数调用。&lt;/p&gt;&lt;p&gt;    2.装饰器可以传参调用，返回一个装饰器函数，它可以读取和返回一个函数&lt;br/&gt;    &lt;br/&gt;    3.装饰器不可以传参调用,会只将装饰器应用到函数上&lt;/p&gt;
&lt;p&gt;改造下之前的@repeat装饰器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; repeat(_func=None, *, num_times=2&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_repeat(func):
        @functools.wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_repeat(*args, **&lt;span&gt;kwargs):
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(num_times):
                value &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_repeat

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; _func &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator_repeat
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_repeat(_func)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和之前的对比,唯一的变化是在末尾添加了_func参数和if-else。&lt;br/&gt;这些例子表明，@repeat现在可以在有或没有参数的情况下使用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@repeat
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; say_whee():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Whee!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

@repeat(num_times&lt;/span&gt;=3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; greet(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello {name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况num_times的值是2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee()
Whee!
Whee!

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; greet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Penny&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Hello Penny
Hello Penny
Hello Penny&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;有状态的装饰器&lt;/h3&gt;
&lt;p&gt;有时候，可以跟踪状态的装饰器也是很有用的.一个简单的例子，我们会创建一个统计函数调用次数的装饰器&lt;/p&gt;&lt;p&gt;注意:在教程的前面，我们讨论了基于给定参数返回值的纯函数.有状态的装饰器正好相反,返回值取决于当前状态以及给定的参数。&lt;/p&gt;&lt;p&gt;在下一节中，您将看到如何使用类来保持状态。但在简单的情况下，也可以使用函数属性:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; count_calls(func):
    @functools.wraps(func)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_count_calls(*args, **&lt;span&gt;kwargs):
        wrapper_count_calls.num_calls &lt;/span&gt;+= 1
        &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Call {wrapper_count_calls.num_calls} of {func.__name__!r}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*args, **&lt;span&gt;kwargs)
    wrapper_count_calls.num_calls &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_count_calls

@count_calls
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; say_whee():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Whee!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;状态——函数的调用次数——存储在包裹函数(wrapper_count_calls)的函数属性.num_calls中。下面是使用它的效果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee()
Call &lt;/span&gt;1 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;say_whee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Whee!

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee()
Call &lt;/span&gt;2 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;say_whee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Whee!

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee.num_calls
&lt;/span&gt;2
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;类装饰器&lt;/h3&gt;
&lt;p&gt;典型的维护状态的方式是使用类。在本节中，将看到如何重写@count_calls的例子来实现类装饰器&lt;/p&gt;&lt;p&gt;回想一下，装饰器语法@my_decorator只是func = my_decorator(func)一种方便快捷的用法.因此，如果my_decorator是一个类，需要在它的.__init__方法中接收func作为一个参数.而且,这个类需要是可以被调用的,这样它就可以替代装饰器函数了&lt;/p&gt;&lt;p&gt;如果需要一个类可以被调用,要实现.__call__方法(看示例:https://www.cnblogs.com/flashBoxer/tag/python/)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Counter:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, start=&lt;span&gt;0):
        self.count &lt;/span&gt;=&lt;span&gt; start

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;&lt;span&gt;(self):
        self.count &lt;/span&gt;+= 1
        &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Current count is {self.count}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.__call__方法每次运行都会尝试调用一个类的实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; counter =&lt;span&gt; Counter()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; counter()
Current count &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; 1

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; counter()
Current count &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; 2

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; counter.count
&lt;/span&gt;2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此，实现类装饰器需要实现.__init__和.__call__&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountCalls:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, func):
        functools.update_wrapper(self, func)
        self.func &lt;/span&gt;=&lt;span&gt; func
        self.num_calls &lt;/span&gt;=&lt;span&gt; 0

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__call__&lt;/span&gt;(self, *args, **&lt;span&gt;kwargs):
        self.num_calls &lt;/span&gt;+= 1
        &lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Call {self.num_calls} of {self.func.__name__!r}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.func(*args, **&lt;span&gt;kwargs)

@CountCalls
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; say_whee():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Whee!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.__init__方法必须可以存储一个函数的引用和能够做一些必要的初始化. 调用.__call__方法来替代装饰器函数.它做的和我们之前的 wrapper()函数基本一样，注意，这里使用functools.update_wrapper()函数，而不是@functools.wraps&lt;/p&gt;&lt;p&gt;这个@CountCalls装饰器的工作原理与前一节相同:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee()
Call &lt;/span&gt;1 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;say_whee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Whee!

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee()
Call &lt;/span&gt;2 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;say_whee&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
Whee!

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; say_whee.num_calls
&lt;/span&gt;2
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;

&lt;p&gt;&lt;br/&gt;我们已经学到了很多(看了下翻译的行数量，已经1K+了，确实很多)，已经学会如何创建各种各样的装饰师，把我们的新知识应用到创建更多的示例中，这些示例在现实中可能非常有用。&lt;/p&gt;
&lt;h3&gt;&lt;br/&gt;代码降速,重新访问&lt;/h3&gt;
&lt;p&gt;&lt;br/&gt;我们之前实现的@slow_down一直是保持sleep 1秒.现在你知道了如何给装饰器添加参数,因此，让我们来重写@slow_down，使用一个可选的rate参数来控制它的sleep时间:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; slow_down(_func=None, *, rate=1&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Sleep given amount of seconds before calling the function&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_slow_down(func):
        @functools.wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_slow_down(*args, **&lt;span&gt;kwargs):
            time.sleep(rate)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_slow_down

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; _func &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator_slow_down
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_slow_down(_func)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们使用  Both Please, But Never Mind the Bread  这里的样例来让@slow_down有参数和没有参数时都可调用，countdown()函数现在在每次计数之间休眠2秒:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@slow_down(rate=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; countdown(from_number):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; from_number &amp;lt; 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Liftoff!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(from_number)
        countdown(from_number &lt;/span&gt;- 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和前面一样，你最好自己写写，跑下看看结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; countdown(3&lt;span&gt;)
&lt;/span&gt;3
2
1&lt;span&gt;
Liftoff!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;创建单例模式&lt;/h3&gt;
&lt;p&gt;单例模式是一个只有一个实例的类.在Python经常使用的单例对象包括None,True和False.可以使用is来比较,像我们之前在Both Please的章节中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; _func &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator_name
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_name(_func)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is只对完全相同实例的对象返回True。下面的@singleton装饰器将类的第一个实例存储为属性，从而将类转换为单例对象。之后创建实例只是返回已经存储的实例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; singleton(cls):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Make a class a Singleton class (only one instance)&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    @functools.wraps(cls)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_singleton(*args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; wrapper_singleton.instance:
            wrapper_singleton.instance &lt;/span&gt;= cls(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_singleton.instance
    wrapper_singleton.instance &lt;/span&gt;=&lt;span&gt; None
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_singleton

@singleton
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TheOne:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个类装饰器和我们的函数装饰器基本一样.唯一不同的地方在于使用cls代替了fun来表示这是一个类装饰器&lt;/p&gt;
&lt;p&gt;看下运行结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; first_one =&lt;span&gt; TheOne()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; another_one =&lt;span&gt; TheOne()

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; id(first_one)
&lt;/span&gt;140094218762280

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; id(another_one)
&lt;/span&gt;140094218762280

&amp;gt;&amp;gt;&amp;gt; first_one &lt;span&gt;is&lt;/span&gt;&lt;span&gt; another_one
True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;很明显，first_one确实与另一个实例完全相同。&lt;/p&gt;
&lt;h3&gt;缓存返回值&lt;/h3&gt;
&lt;p&gt;装饰器可以提供很方便的缓存和记忆机制.作为一个例子，我们来看看斐波那契数列的递归定义:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; count_calls

@count_calls
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fibonacci(num):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num &amp;lt; 2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fibonacci(num - 1) + fibonacci(num - 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现很简单，性能很糟糕&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; fibonacci(10&lt;span&gt;)
&lt;/span&gt;&amp;lt;Lots of output &lt;span&gt;from&lt;/span&gt; count_calls&amp;gt;
55

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; fibonacci.num_calls
&lt;/span&gt;177
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了计算第10个斐波那契数，你实际上只需要计算前面的斐波那契数，但是这个实现需要177次计算。更糟糕的是:斐波纳契数列(20)需要21891次计算，第30次需要270万次计算。这是因为代码一直在重新计算已知的斐波那契数。&lt;/p&gt;&lt;p&gt;通常的解决方案是使用for循环和查找表来实现斐波那契数。但是，简单的计算缓存也可以做到这一点:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; count_calls

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; cache(func):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Keep a cache of previous function calls&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    @functools.wraps(func)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_cache(*args, **&lt;span&gt;kwargs):
        cache_key &lt;/span&gt;= args +&lt;span&gt; tuple(kwargs.items())
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; cache_key &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; wrapper_cache.cache:
            wrapper_cache.cache[cache_key] &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_cache.cache[cache_key]
    wrapper_cache.cache &lt;/span&gt;=&lt;span&gt; dict()
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_cache

@cache
@count_calls
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fibonacci(num):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num &amp;lt; 2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fibonacci(num - 1) + fibonacci(num - 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缓存作为查找表工作，所以现在fibonacci()只执行一次计算:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; fibonacci(10&lt;span&gt;)
Call &lt;/span&gt;1 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fibonacci&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
...
Call &lt;/span&gt;11 of &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fibonacci&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
55

&amp;gt;&amp;gt;&amp;gt; fibonacci(8&lt;span&gt;)
&lt;/span&gt;21
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，在对fibonacci(8)的最后调用中，没有进行新的计算，因为fibonacci(10)已经计算了第8个fibonacci数。&lt;br/&gt;在标准库中，提供了@functools.lru_cache。&lt;/p&gt;&lt;p&gt;这个装饰器比上面的例子要具备更多特性.我们应该使用@functools.lru_cache来代替我们自己写的缓存装饰器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools

@functools.lru_cache(maxsize&lt;/span&gt;=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fibonacci(num):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Calculating fibonacci({num})&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; num &amp;lt; 2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fibonacci(num - 1) + fibonacci(num - 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;maxsize参数指定缓存了多少次调用。默认值是128，但是可以指定maxsize=None来缓存所有函数调用。但是，请注意，如果正在缓存许多很大的对象，这可能会导致内存问题。&lt;/p&gt;&lt;p&gt;可以使用.cache_info()方法查看缓存的执行情况，并在需要时进行调优。在我们的示例中，我们设定一个小maxsize来查看从缓存中删除元素的效果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; fibonacci(10&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;10&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;9&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;8&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;7&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;6&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;5&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;4&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;3&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;2&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;1&lt;span&gt;)
Calculating fibonacci(0)
&lt;/span&gt;55

&amp;gt;&amp;gt;&amp;gt; fibonacci(8&lt;span&gt;)
&lt;/span&gt;21

&amp;gt;&amp;gt;&amp;gt; fibonacci(5&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;5&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;4&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;3&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;2&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;1&lt;span&gt;)
Calculating fibonacci(0)
&lt;/span&gt;5

&amp;gt;&amp;gt;&amp;gt; fibonacci(8&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;8&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;7&lt;span&gt;)
Calculating fibonacci(&lt;/span&gt;6&lt;span&gt;)
&lt;/span&gt;21

&amp;gt;&amp;gt;&amp;gt; fibonacci(5&lt;span&gt;)
&lt;/span&gt;5

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; fibonacci.cache_info()
CacheInfo(hits&lt;/span&gt;=17, misses=20, maxsize=4, currsize=4)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;添加单元信息&lt;/h3&gt;
&lt;p&gt;下面的示例与前面的Registering Plugins示例有点类似，因为它不会真正改变被装饰函数的行为。相反，它只是将unit添加为函数属性:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; set_unit(unit):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Register a unit on a function&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_set_unit(func):
        func.unit &lt;/span&gt;=&lt;span&gt; unit
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_set_unit
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的示例根据圆柱体的半径和高度(以厘米为单位)来计算体积:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; math

@set_unit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cm^3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; volume(radius, height):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; math.pi * radius**2 *&lt;span&gt; height   
    
这个.unit函数属性是可以访问的:    
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; volume(3, 5&lt;span&gt;)
&lt;/span&gt;141.3716694115407

&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; volume.unit
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cm^3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，可以使用函数注释实现类似的功能: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; math

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; volume(radius, height) -&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cm^3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; math.pi * radius**2 * height   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，由于注释用于类型提示，因此很难将注释和静态类型检查相结合。   &lt;br/&gt;    &lt;br/&gt;在连接到一个能够在单位间转换的库，单位可以变得更加强大和有趣.pip install pint,  您可以将体积转换为立方英寸或加仑: &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pint
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; ureg =&lt;span&gt; pint.UnitRegistry()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; vol = volume(3, 5) *&lt;span&gt; ureg(volume.unit)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; vol
&lt;/span&gt;&amp;lt;Quantity(141.3716694115407, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;centimeter ** 3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; vol.to(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cubic inches&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;lt;Quantity(8.627028576414954, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;inch ** 3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; vol.to(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gallons&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).m  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Magnitude&lt;/span&gt;
0.0373464440537444  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;你还可以修改装饰器来直接返回一个Pint数量.数量是通过与单位相乘得到的，在pint中，units必须只能在UnitRegistry中查询.这里注册用来存储函数属性来避免命名空间混乱&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; use_unit(unit):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;Have a function return a Quantity with given unit&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    use_unit.ureg &lt;/span&gt;=&lt;span&gt; pint.UnitRegistry()
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_use_unit(func):
        @functools.wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_use_unit(*args, **&lt;span&gt;kwargs):
            value &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value *&lt;span&gt; use_unit.ureg(unit)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_use_unit
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decorator_use_unit

@use_unit(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;meters per second&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; average_speed(distance, duration):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; distance / duration
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;使用@use_unit装饰器，转换单位实际上是很容易&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; bolt = average_speed(100, 9.58&lt;span&gt;)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; bolt
&lt;/span&gt;&amp;lt;Quantity(10.438413361169102, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;meter / second&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; bolt.to(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;km per hour&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;lt;Quantity(37.578288100208766, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kilometer / hour&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&amp;gt;

&amp;gt;&amp;gt;&amp;gt; bolt.to(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mph&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).m  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Magnitude&lt;/span&gt;
23.350065679064745
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;验证JSON&lt;/h3&gt;
&lt;p&gt;让我们看最后一个用例。快速看下Flask路由的管理程序:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@app.route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/grade&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, methods=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; update_grade():
    json_data &lt;/span&gt;=&lt;span&gt; request.get_json()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; json_data:
        abort(&lt;/span&gt;400&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Update database&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们确保key student_id是请求的一部分.虽然验证有效，但它实际上并不属于函数本身.另外，可能还有其他使用相同验证的路由。因此，让我们Don't repeat yourself，来使用装饰器抽象出任何不必要的逻辑，下面的@validate_json装饰器会完成这个工作:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask, request, abort
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; functools
app &lt;/span&gt;= Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; validate_json(*expected_args):                  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; decorator_validate_json(func):
        @functools.wraps(func)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper_validate_json(*args, **&lt;span&gt;kwargs):
            json_object &lt;/span&gt;=&lt;span&gt; request.get_json()
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; expected_arg &lt;span&gt;in&lt;/span&gt; expected_args:      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; expected_arg &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; json_object:
                    abort(&lt;/span&gt;400&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(*args, **&lt;span&gt;kwargs)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper_validate_json
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decorator_validate_json
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，装饰器采用了一个可变长度列表作为参数，这样我们就可以传递尽可能多的字符串参数，每个参数都代表一个用于验证JSON数据的键:&lt;/p&gt;
&lt;p&gt;    1.json的keys列表作为参数传递给装饰器&lt;br/&gt;    2.包裹函数验证JSON数据中出现的每个预期键&lt;/p&gt;
&lt;p&gt;然后，路由管理程序可以关注其真正的业务级别——因为它可以安全地假设JSON数据是有效的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@app.route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/grade&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, methods=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
@validate_json(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;student_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; update_grade():
    json_data &lt;/span&gt;=&lt;span&gt; request.get_json()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Update database.&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结束语:翻译就到这里吧,这篇文章的作者对装饰器的理解很是深入，文章很长，翻起来确实花了不少时间。文中如果有翻译不稳妥的地方，请留言给我。最后老铁们如果觉得对理解python的装饰器有帮助，右下角点个赞吧，结尾附上原文地址:https://realpython.com/primer-on-python-decorators/&lt;/p&gt;

</description>
<pubDate>Mon, 29 Oct 2018 14:53:00 +0000</pubDate>
<dc:creator>丁壮</dc:creator>
<og:description>继续上次的进度:https://www.cnblogs.com/flashBoxer/p/9847521.html 正文: 装饰类 在类中有两种不通的方式使用装饰器，第一个和我们之前做过的函数非常相似</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flashBoxer/p/9873918.html</dc:identifier>
</item>
<item>
<title>Java进阶篇设计模式之九----- 解释器模式和迭代器模式 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9873514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9873514.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/xuwujing/p/9794886.html&quot;&gt;上一篇&lt;/a&gt;中我们学习了行为型模式的责任链模式(Chain of Responsibility Pattern)和命令模式（Command Pattern）。本篇则来学习下行为型模式的两个模式， 解释器模式(Interpreter Pattern)和迭代器模式（Iterator Pattern）。&lt;/p&gt;
&lt;h2 id=&quot;解释器模式&quot;&gt;解释器模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;解释器模式顾名思义，就是对某事物进行解释。给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解释器模式其实就是对某事物进行解释。比如生活中经常用到的计算器，将我们用的语言转换成计算器预言，还有我们编写代码时用到的&lt;strong&gt;正则表达式&lt;/strong&gt;等等。《大话设计模式》中对这个模式有个比较有意思的讲解，其中示例就是把老板对不同人说相同的话，不同的人会理解不同。这也说明的解释器模式核心就是进行解释。&lt;/p&gt;
&lt;p&gt;解释器模式主要由这四个角色组成，抽象表达式(Expression)角色、终结符表达式(Terminal Expression)角色、非终结符表达式(Nonterminal Expression)角色和环境(Context)角色。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象解释器：声明一个所有具体表达式都要实现的抽象接口（或者抽象类），接口中主要是一个interpret()方法，称为解释操作。具体解释任务由它的各个实现类来完成，具体的解释器分别由终结符解释器TerminalExpression和非终结符解释器NonterminalExpression完成。&lt;/li&gt;
&lt;li&gt;终结符表达式：实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。终结符一半是文法中的运算单元，比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。&lt;/li&gt;
&lt;li&gt;非终结符表达式：文法中的每条规则对应于一个非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，+就是非终结符，解析+的解释器就是一个非终结符表达式。非终结符表达式根据逻辑的复杂程度而增加，原则上每个文法规则都对应一个非终结符表达式。&lt;/li&gt;
&lt;li&gt;环境角色：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里为了方便理解，我们使用一个简单的示例来加以说明。&lt;br/&gt;平常我们在进行英语学习的时候，会自行翻译或者用到翻译工具。但是不同的翻译工具翻译的结果也可能不一样，这时我们只需要拿到自己想要的结果就行了。比如，使用百度和有道翻译“好好学习，天天向上！”，它们翻译的结果分别为“Study hard and keep up!”和“study hard and make progress every day！”，而xuwujing翻译的结果是“ Good good study, day day up！”。&lt;br/&gt;那么我们便可以用解释器模式来实现这种场景。&lt;br/&gt;首先定义一个抽象的解释器接口，有解释的这个方法，然后再定义不同的解释器实现该接口和方法，最后再来进行测试。那么代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface Expreeion{
   void interpert(String word);
}

class  BaiduExpreeion implements Expreeion{
   String str =&quot;好好学习，天天向上!&quot;;
   @Override
   public void interpert(String word) {
       if(str.equals(word)) {
           System.out.println(&quot;百度翻译：&quot;+word+&quot; 的英文是  Study hard and keep up!&quot;);
       }
   }
}

class  YouDaoExpreeion implements Expreeion{
   String str =&quot;好好学习，天天向上!&quot;;
   @Override
   public void interpert(String word) {
       if(str.equals(word)) {
           System.out.println(&quot;有道翻译：&quot;+word+&quot; 的英文是  study hard and make progress every day！&quot;);
       }
   }
}

class  XuWuJingExpreeion implements Expreeion{
   String str =&quot;好好学习，天天向上!&quot;;
   @Override
   public void interpert(String word) {
       if(str.equals(word)) {
           System.out.println(&quot;xuwujing翻译：&quot;+word+&quot; 的英文是  Good good study, day day up！&quot;);
       }
   }
}

public class InterpreterTest {
   public static void main(String[] args) {
       String word = &quot;好好学习，天天向上!&quot;;
       Expreeion expreeion =new  BaiduExpreeion();
       Expreeion expreeion2 =new  YouDaoExpreeion();
       Expreeion expreeion3 =new  XuWuJingExpreeion();
       expreeion.interpert(word);
       expreeion2.interpert(word);
       expreeion3.interpert(word);
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
百度翻译：好好学习，天天向上! 的英文是  Study hard and keep up!
有道翻译：好好学习，天天向上! 的英文是  study hard and make progress every day！
xuwujing翻译：好好学习，天天向上! 的英文是  Good good study, day day up！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解释器模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;扩展性好，子类扩展非常方便。&lt;br/&gt;实现简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;解释器模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可使用的场景比较少；&lt;br/&gt;类过多的话，会使代码臃肿，难以维护；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个简单的语法规则需要解释的场景，比如sql。&lt;br/&gt;有重复的问题的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;迭代器模式&quot;&gt;迭代器模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;迭代器模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示，属于行为型模式。 它提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们对迭代器（Iterator）肯定不陌生，因为我们在Java开发中会经常用到，比如对List、Set和Map集合进行遍历或对数组进行遍历的时候。但是迭代器模式的话，可能就不太理解了，这里我们就简单讲讲迭代器模式。&lt;/p&gt;
&lt;p&gt;迭代器模式主要由这四个角色组成，迭代器角色（Iterator）、具体迭代器角色（Concrete Iterator）、容器角色（Container）和具体容器角色（Concrete Container）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;迭代器角色（Iterator）：通过接口或抽象类声明实现的方法。&lt;/li&gt;
&lt;li&gt;具体迭代器角色（Concrete Iterator）：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。&lt;/li&gt;
&lt;li&gt;容器角色（Container）：容器角色负责提供创建具体迭代器角色的接口。&lt;/li&gt;
&lt;li&gt;具体容器角色（Concrete Container）：具体容器角色实现创建具体迭代器角色的接口——这个具体迭代器角色于该容器的结构相关。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为迭代器我们平时用的比较多，这里也不在过多描述了，这里就简单的介绍下迭代器模式的运作。&lt;br/&gt;首先，定义一个迭代器角色（MyIterator ）和容器角色（MyIterable）的接口。&lt;br/&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface MyIterator {
    boolean hasNext();
    String next();
}

interface MyIterable{
    MyIterator getIterator();
    void add(String str);
    String get(int index);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后定义一个 具体容器角色（ListContainer ）实现容器角色的接口，这里的实现方法通过List自带的进行实现；然后再定义一个具体迭代器角色（ListIterator ）实现迭代器角色的接口，这里的实现的方法由自己实现。&lt;br/&gt;那么代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
class ListContainer implements MyIterable {
    
     private List&amp;lt;String&amp;gt; list =new ArrayList&amp;lt;&amp;gt;(); 

     
    @Override
    public MyIterator getIterator() {
        return new ListIterator();
    }

    @Override
    public void add(String str) {
        list.add(str);
    }

    @Override
    public String get(int index) {
        return list.get(index);
    }
    
    class ListIterator implements MyIterator{
        int index;
        @Override
        public boolean hasNext() {
            return index &amp;lt; list.size();
        }

        @Override
        public String next() {
            if (this.hasNext()) {
                return list.get(index++);
            }
            return null;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来进行代码的测试。&lt;br/&gt;测试代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {
        MyIterable myIterable = new ListContainer();
        myIterable.add(&quot;1&quot;);
        myIterable.add(&quot;zhangsan&quot;);
        myIterable.add(&quot;2&quot;);
        myIterable.add(&quot;lisi&quot;);
        myIterable.add(&quot;3&quot;);
        myIterable.add(&quot;xuwujing&quot;); 
        MyIterator myIterator = myIterable.getIterator();
        while (myIterator.hasNext()){
            String str = myIterator.next();
            System.out.println(str);
        }      
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出结果:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        1
        zhangsan
        2
        lisi
        3
        xuwujing&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;迭代器模式优点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;灵活度高，可以通过不同的方式遍历对象；&lt;br/&gt;扩展性好，可以很方便的增加新的聚合类和迭代器类而不用修改之前的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;迭代器模式缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要为聚合对象提供遍历的功能的时候。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;分享一首很好听的日语歌曲！&lt;/p&gt;

&lt;h3 id=&quot;项目的代码&quot;&gt;项目的代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xuwujing/java-study&quot;&gt;java-study&lt;/a&gt;是本人在学习Java过程中记录的一些代码，也包括之前博文中使用的代码。如果感觉不错，希望顺手给个start，当然如果有不足，也希望提出。&lt;br/&gt;github地址: https://github.com/xuwujing/java-study&lt;/p&gt;
&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：http://www.cnblogs.com/xuwujing&lt;br/&gt;CSDN出处：http://blog.csdn.net/qazwsxpcm　&lt;br/&gt;个人博客出处：http://www.panchengming.com&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 13:44:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/9873514.html</dc:identifier>
</item>
<item>
<title>Java自动拆装箱(Autoboxing and unboxing)学习 - 虚拟机里的牧羊人</title>
<link>http://www.cnblogs.com/ShepherdInJVM/p/9873307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ShepherdInJVM/p/9873307.html</guid>
<description>&lt;p data-anchor-id=&quot;x5lw&quot;&gt;在学习并发的过程中，用“Boolean bool = true”的自动装箱方式初始化了两个对象锁去锁两块代码，结果运行的时候出现了竞争等待，调试了一下发现两个锁变量指向的是同一个对象，由此可见我对自动拆装箱的机制想的太简单了，查了一下，发现这个机制还挺细节，那就记录一下：&lt;/p&gt;
&lt;p data-anchor-id=&quot;9gst&quot;&gt;本文主要有以下几个方面：&lt;/p&gt;
&lt;blockquote class=&quot;white-blockquote&quot; data-anchor-id=&quot;pyic&quot;&gt;
&lt;ul&gt;&lt;li&gt;什么是自动拆装箱&lt;/li&gt;
&lt;li&gt;拆装箱的实现&lt;/li&gt;
&lt;li&gt;拆装箱发生的场景&lt;/li&gt;
&lt;li&gt;关于String&lt;/li&gt;
&lt;li&gt;回首望月&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p data-anchor-id=&quot;scx1&quot;&gt;尝试的第一篇博客，不当之处，求轻喷！&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;一-什么是自动拆箱与装箱&quot; data-anchor-id=&quot;yl1r&quot;&gt;一. 什么是自动拆箱与装箱&lt;/h2&gt;
&lt;p data-anchor-id=&quot;4lrh&quot;&gt;我们都知道，Java定义了8种基本类型和与之对应的8中包装器，其中6种数据类型，1种字符类型以及1种布尔类型：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1436263/201810/1436263-20181029211651675-78084624.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;4lrh&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;在Java5之前，定义生成一个Integer包装器类型的对象，只能通过以下方式：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Integer i = &lt;span&gt;new&lt;/span&gt; Integer(0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;16ei&quot;&gt;Java5支持了基本类型和对应的包装类型之前的自动转换机制，即自动拆箱（包装器类型转换成基本类型）与装箱（基本类型封装成包装器类型）。于是，就有了以下两行代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Integer i = 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动装箱&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; j = i; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动拆箱&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;二-自动拆装箱的实现int-integer为例&quot; data-anchor-id=&quot;5js3&quot;&gt;二. 自动拆装箱的实现（int-Integer为例）&lt;/h2&gt;
&lt;p data-anchor-id=&quot;e35z&quot;&gt;我们将下面自动拆装箱的代码反编译一下，拆装箱的动作就一目了然。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Integer i = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; j =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1436263/201810/1436263-20181029212655022-89008756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;e35z&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;通过反编译的结果看，在&quot;Integer i = 0&quot;自动装箱的过程中，调用了Integer.valueOf(int i)方法；在&quot;int j = i;&quot;的自动装箱的过程中，调用了Integer.intValue()方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;rppx&quot;&gt;其中，拆箱方法Integer.intValue()方法很简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;      &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;     * Returns the value of this {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Integer} as an
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; int}.
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; intValue() {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;yvpf&quot;&gt;只是返回了当前对象的value值，没什么好说的。&lt;/p&gt;
&lt;p data-anchor-id=&quot;yvpf&quot;&gt; &lt;/p&gt;
&lt;p data-anchor-id=&quot;c1vm&quot;&gt;但是装箱方法Integer.valueOf(int i)就有细节了，一起看下：&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Returns an {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Integer} instance representing the specified
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; int} value.  If a new {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Integer} instance is not
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * required, this method should generally be used in preference to
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * the constructor {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #Integer(int)}, as this method is likely
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * to yield significantly better space and time performance by
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * caching frequently requested values.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * This method will always cache values in the range -128 to 127,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * inclusive, and may cache other values outside of this range.
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt;  i an {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; int} value.
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; an {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Integer} instance representing {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; i}.
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt;  1.5
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Integer valueOf(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;=&lt;span&gt; IntegerCache.high)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; IntegerCache.cache[i + (-&lt;span&gt;IntegerCache.low)];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(i);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;schc&quot;&gt;这边的源码比预想的多了一个细节操作，值落在[IntegerCache.low, IntegerCache.high]区间上时，是直接从一个Integer类型的缓存数组IntegerCache.cache中取一个对象返回出去，值不在这个区间时才new一个新对象返回。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;看一下IntegerCache的实现，它是Integer类的一个私有静态内部类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Cache to support the object identity semantics of autoboxing for values between
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * -128 and 127 (inclusive) as required by JLS.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * The cache is initialized on first usage.  The size of the cache
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * may be controlled by the {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; -XX:AutoBoxCacheMax=&amp;lt;size&amp;gt;} option.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * During VM initialization, java.lang.Integer.IntegerCache.high property
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * may be set and saved in the private system properties in the
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * sun.misc.VM class.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IntegerCache {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; low = -128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; high;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Integer cache[];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; high value may be configured by property&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; h = 127&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             String integerCacheHighPropValue =
&lt;span&gt;21&lt;/span&gt;                 sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (integerCacheHighPropValue != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; parseInt(integerCacheHighPropValue);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     i = Math.max(i, 127&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Maximum array size is Integer.MAX_VALUE&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                     h = Math.min(i, Integer.MAX_VALUE - (-low) -1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt;( NumberFormatException nfe) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the property cannot be parsed into an int, ignore it.&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             high =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;             cache = &lt;span&gt;new&lt;/span&gt; Integer[(high - low) + 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; j =&lt;span&gt; low;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; k = 0; k &amp;lt; cache.length; k++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 cache[k] = &lt;span&gt;new&lt;/span&gt; Integer(j++&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; range [-128, 127] must be interned (JLS7 5.1.7)&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;assert&lt;/span&gt; IntegerCache.high &amp;gt;= 127&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; IntegerCache() {}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;bs5c&quot;&gt;IntegerCache中有3个final类型的变量：&lt;/p&gt;
&lt;blockquote class=&quot;white-blockquote&quot; data-anchor-id=&quot;ib4r&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;low&lt;/strong&gt;：-128（一个字节能够表示的最小值）；&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;strong&gt;high&lt;/strong&gt;：127（一个字节能够表示的最大值），JVM中设置的属性值（通过-XX:AutoBoxCacheMax=设置）二者取大值，再和Integer.MAX_VALUE取小值；&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;strong&gt;cache&lt;/strong&gt;：在静态块中初始化为由区间[low, high]上的所有整数组成的升序数组。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-anchor-id=&quot;kf5r&quot;&gt;综上，Java在虚拟机堆内存中维持了一个缓存池，在装箱的过程中，如果发现目标包装器对象在缓存池中已经存在，就直接取缓存池中的，否则就新建一个对象。&lt;/p&gt;
&lt;p data-anchor-id=&quot;qq67&quot;&gt;测试一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Integer i = 127&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Integer j = 127&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         System.out.println(System.identityHashCode(i));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地输出i的地址：1173230247&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         System.out.println(System.identityHashCode(j));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地输出j的地址：1173230247&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         
&lt;span&gt; 7&lt;/span&gt;         Integer m = 128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Integer n = 128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(System.identityHashCode(m));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地输出m的地址：856419764&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         System.out.println(System.identityHashCode(n));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地输出n的地址：621009875&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-anchor-id=&quot;azhg&quot;&gt;由测试结果来看，值为127时，两次装箱返回的是同一个对象，值为128时，两次装箱返回的是不同的对象。&lt;/p&gt;
&lt;p data-anchor-id=&quot;azhg&quot;&gt; &lt;/p&gt;
&lt;p data-anchor-id=&quot;wbpn&quot;&gt;因为小数的区间取值无限，所以float-&amp;gt;Float，double-&amp;gt;Double两种类型装箱机制没有缓存机制，其他5中基本类型的封装机制也是类似int-&amp;gt;Integer的装箱套路，不过缓存的边界不可改变：&lt;/p&gt;
&lt;table class=&quot;table table-striped-white table-bordered&quot; data-anchor-id=&quot;u6xh&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;基本类型&lt;/th&gt;
&lt;th&gt;包装器类型&lt;/th&gt;
&lt;th&gt;缓存区间&lt;/th&gt;
&lt;th&gt;缓存是否可变&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;td&gt;[-128, 127]&lt;/td&gt;
&lt;td&gt;不可变&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;td&gt;[-128, 127]&lt;/td&gt;
&lt;td&gt;不可变&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;[-128, 127]&lt;/td&gt;
&lt;td&gt;上限可设置&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;td&gt;[-128, 127]&lt;/td&gt;
&lt;td&gt;不可变&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;td&gt;--&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;td&gt;[0, 127]&lt;/td&gt;
&lt;td&gt;不可变&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;{true, false}&lt;/td&gt;
&lt;td&gt;不可变&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-anchor-id=&quot;3i8e&quot;&gt;因为基本类型对应的包装器都是不可变类，多以他们的缓存区间一旦初始化，里面的值就无法再改变，所以在JVM运行过程中，所有的基本类型包装器的缓存池都是不变的。&lt;/p&gt;

&lt;h2 id=&quot;三-拆装箱发生的场景&quot; data-anchor-id=&quot;qg85&quot;&gt;三. 拆装箱发生的场景&lt;/h2&gt;
&lt;h3 id=&quot;1定义变量和方法参数传递&quot; data-anchor-id=&quot;954q&quot;&gt;1.定义变量和方法参数传递：&lt;/h3&gt;
&lt;p data-anchor-id=&quot;whh3&quot;&gt;这里的拆装箱是指开发者通过编写代码控制的拆装箱，比较明显：&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Integer i = 0;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;装箱&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; j = i;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拆箱&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         aa(i);           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拆箱，传值时发生了：int fi = i;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         bb(j);           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;装箱，传值时发生了：Integer fi = j;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; aa(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; fi){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bb(Integer fi){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3 id=&quot;2运算时拆箱&quot; data-anchor-id=&quot;m922&quot;&gt;2.运算时拆箱&lt;/h3&gt;
&lt;p data-anchor-id=&quot;04zr&quot;&gt;我们都知道，当一个变量的定义类型不是基本类型，其实变量的值是对象的在虚拟机中的地址，当用初始化后的包装器类型变量进行运算时，会发生什么呢？&lt;/p&gt;
&lt;h4 id=&quot;1-等运算时拆箱&quot; data-anchor-id=&quot;qjkd&quot;&gt;1.“+，-，*，/ ...”等运算时拆箱&lt;/h4&gt;
&lt;p data-anchor-id=&quot;y0xv&quot;&gt;当用包装器类型的数据进行运算时，JAVA会先执行拆箱操作，然后进行运算。&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Integer i = 127&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         Integer j = 127&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         i = i +&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;99m7&quot;&gt;将上面一段代码反编译：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1436263/201810/1436263-20181029213333846-82561784.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;99m7&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;发现，除了在分别源码的3,4行进行了装箱操作后，在执行add操作之前，有两次拆箱操作，add之后，又把结果装箱赋值给变量i。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;2判等运算&quot; data-anchor-id=&quot;pfqq&quot;&gt;2.“==”判等运算&lt;/h4&gt;
&lt;p data-anchor-id=&quot;w42z&quot;&gt;“==”运算比较特殊：&lt;/p&gt;
&lt;blockquote class=&quot;white-blockquote&quot; data-anchor-id=&quot;wnlt&quot;&gt;
&lt;p&gt;A == B&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当A,B都是基本类型时，直接进行比较两个变量的值是否相等&lt;/li&gt;
&lt;li&gt;当A,B都是包装器类型时，比较两个变量指向的对象所在的地址是否相等&lt;/li&gt;
&lt;li&gt;当A,B中有一个是基本类型时，会将另一个包装器类型拆箱成基本类型，然后再进行基本类型的判等比较&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p data-anchor-id=&quot;i2ik&quot;&gt;测试如下：&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; m = 128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; n = 128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         Integer i = 128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         Integer j = 128&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         System.out.println(m == n);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：true&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         System.out.println(m == i);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：true&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;         System.out.println(i == j);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：false&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;q80u&quot;&gt;前文已经说了，JVM没有设置Integer类型的缓存上限的时候，128不在缓存池内，所以两次封装后的对象是不同的对象。在此基础上：&lt;/p&gt;
&lt;blockquote class=&quot;white-blockquote&quot; data-anchor-id=&quot;b8di&quot;&gt;
&lt;ul&gt;&lt;li&gt;第6行输出true：如果比较的是装箱后的对象地址，结果肯定是false，实际结果是true，说明比较的是基本类型的值，没有发生自动拆装箱动作&lt;/li&gt;
&lt;li&gt;第7行输出true：如果比较的是装箱后的对象地址，结果肯定是false，实际结果是true，说明比较的是基本类型的值，那么包装器类型的变量肯定进行了自动拆箱动作&lt;/li&gt;
&lt;li&gt;第8行输出false：如果比较的是拆箱后的基本类型的值，结果肯定是true，实际结果是false，说明比较的是对象的地址，没有发生自动拆装箱动作&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p data-anchor-id=&quot;33il&quot;&gt;看一下反编译的结果：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1436263/201810/1436263-20181029213530015-2057121418.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-anchor-id=&quot;33il&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;对应源码中除了第4、5行出现了自动装箱动作，就只有在第7行发生了自动拆箱动作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;四-关于string类型&quot; data-anchor-id=&quot;pfnx&quot;&gt;四. 关于String类型&lt;/h2&gt;
&lt;p data-anchor-id=&quot;7fx6&quot;&gt;String类型没有对应的基本类型，所以没有自动拆装箱的机制，之所以在这里提一下，是因为String的初始化过程和自动装箱的过程很像。&lt;/p&gt;
&lt;div class=&quot;md-section-divider&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         String s1 = &quot;hello&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         String s2 = &quot;hello&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         String s3 = &lt;span&gt;new&lt;/span&gt; String(&quot;hello&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         String s4 = &lt;span&gt;new&lt;/span&gt; String(&quot;hello&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         System.out.println(System.identityHashCode(s1)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出s1地址：1173230247&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         System.out.println(System.identityHashCode(s2)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出s2地址：1173230247&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         System.out.println(System.identityHashCode(s3)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出s3地址：856419764&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         System.out.println(System.identityHashCode(s4)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出s5地址：621009875&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p data-anchor-id=&quot;2pkw&quot;&gt;从上面的输出结果可以看出，两个直接用字符串赋值的变量s1,s2指向的是同一个对象，而new String()生成对象赋值的变量s3,s4则是不同的对象。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;其实，JVM中存在一个字符串缓存池，当直接使用字符串初始化变量的时候，JAVA会先到字符串缓存池中查看有没有相同值的String对象，如果有，直接返回缓存池中的对象；如果没有，就new出一个新的对象存入缓存池，再返回这个对象。而String的不可变性质则能保证在对象共享的过程中不会出现线程安全问题。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;与基本类型的缓存池相比，String类型的缓存池在运行时是动态变化的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;五-回首望月&quot; data-anchor-id=&quot;f8m2&quot;&gt;五. 回首望月&lt;/h2&gt;
&lt;p data-anchor-id=&quot;mysr&quot;&gt;回到最开始我碰到的问题，当我用“Boolean bool = true”的自动装箱方式定义变量的时候，这两个变量其实指向的都是Boolean类型的缓存池中的那个值为true的对象，所以用他们当做同步锁，其实是用的同一把锁，自然会出现竞争等待。&lt;/p&gt;
&lt;p data-anchor-id=&quot;fey8&quot;&gt;经验：当我们使用自动装箱机制初始化变量的时候，就相当于告诉JAVA这里需要一个对象，而不是告诉JAVA这里需要一个新的对象。当我们需要一个新的对象的时候，为了保险起见，自己new一个出来，比如锁。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 13:42:00 +0000</pubDate>
<dc:creator>虚拟机里的牧羊人</dc:creator>
<og:description>在学习并发的过程中，用“Boolean bool = true”的自动装箱方式初始化了两个对象锁去锁两块代码，结果运行的时候出现了竞争等待，调试了一下发现两个锁变量指向的是同一个对象，由此可见我对自动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ShepherdInJVM/p/9873307.html</dc:identifier>
</item>
<item>
<title>读读《编写高质量代码:改善Java程序的151条建议》 - 挑战者V</title>
<link>http://www.cnblogs.com/youcong/p/9873261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youcong/p/9873261.html</guid>
<description>&lt;p&gt;这本书可以作为平时写代码的一个参考书，这本书以我个人读的经验看来，最好是通过平时代码驱动的方式来读，这样吸收的快，也读的快。&lt;/p&gt;
&lt;p&gt;这本书主要讲什么，我自己用了个思维导图概述:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201810/1255290-20181029193356984-1964769105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据这种导图可知，主要讲的就是Java语法、JDK API、程序性能、开源工具和框架、编程风格和编程思想等五个点。&lt;/p&gt;
&lt;p&gt;我这次主要读的是关于开源世界和思想开源这两章，这两章相当于导图中提到的开源工具和框架、编程风格和编程思想。所以今天讲的也是这两个方面。&lt;/p&gt;
&lt;p&gt;一、开源工具和框架&lt;/p&gt;
&lt;p&gt;导图如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201810/1255290-20181029193844976-1753149941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者的观点是:大胆采用开源项目。并对此提出五点建议。不过在我看来的话除了选择框架和工具需遵循六个原则外，其它四点从导图上看似乎没有多大用处。所以我也不打算详细说，但是这四点我将其理解为这些想法和建议。&lt;/p&gt;
&lt;p&gt;想法和建议如下:&lt;/p&gt;
&lt;p&gt;使用的相关工具类要统一，比如apache common对于String相关的有其专门处理类，尽可能不要引用其它具备此功能的，因为容易弄混,而且导包的时候，有些时候安ctrl+alt显示的太多,如果你不是对对应的API十分熟悉的情况下，很容易眼花缭乱,在此我要说明的是，工具类统一的好处避免导包眼花缭乱,同时也避免出现为了实现某个功能需要对应的工具类时，你引用这个，我引用那个。&lt;/p&gt;
&lt;p&gt;目前开源项目，我认为比较不错的工具类集成项目，就是Hutool,它不仅文档相对完整，而且不少开源项目及其对应的公司也在用。&lt;/p&gt;
&lt;p&gt;Hutool官方地址为:http://www.hutool.cn/&lt;/p&gt;
&lt;p&gt;但是在选择开源框架和工具的时候，最好遵循六个原则:&lt;/p&gt;
&lt;p&gt;(1)普适性;&lt;/p&gt;
&lt;p&gt;选择工具或框架必须要考虑项目整体团队的技术水平，不能有太大的跨度和跳跃性，要确保大部分项目成员对工具比较熟悉，比如在关于持久层的选择下，选择MyBatis比Hibernate要好，原因是因为上手快，学习成本低，再比如MyBatis替换为MyBatis-Plus，跨度和跳跃性也不大，因为MyBatis-Plus本质上还是MyBatis，这样一来团队学习的成本很少，项目重构的成本很低，同时开发的效率也会提高。&lt;/p&gt;
&lt;p&gt;(2)唯一性;&lt;/p&gt;
&lt;p&gt;相同的工具只能选择一种或多种，不要让多种相同或相似职能的工具并存。例如，hutools可以代替apache common的相关功能，尽可能的选择其中一种，这样当项目成员在开发时，有的时候ctrl+shift+O导包时不用考虑导的对不对。&lt;/p&gt;
&lt;p&gt;(3)大树纳凉;&lt;/p&gt;
&lt;p&gt;找知名的开源项目，比如目前在Java中广泛应用的Spring+MyBatis+SpringMVC等。或者是现在开源项目之一的Jeesite4.0。因为有很多人在用，我们不必担心遇到很多Bug,虽然也有，但是由于用户的群体广泛，可以避免我们踩很多坑。&lt;/p&gt;
&lt;p&gt;(4)精而专;&lt;/p&gt;
&lt;p&gt;(5)高热度;&lt;/p&gt;
&lt;p&gt;选择开源项目尽可能选择那些更新频繁的。频繁意味着有人负责维护，出问题了有人负责解决。更新频繁的总比一年甚至两年更新甚至已经不更新的项目要好吧。因此我们再采用开源项目的时候应抱有这样的观点，大胆采用，仔细筛选。当然了，还有就是最后如果发现选择了某个开源项目，突然作者因为某种原因不维护了，遇到这种情况时，不要抱怨对方，也不要诋毁人家，毕竟我们享受的是他人辛苦贡献的成果。&lt;/p&gt;

&lt;p&gt;二、编程风格与编程思想&lt;/p&gt;
&lt;p&gt;关于编程风格与编程思想，该作者提出了八点建议，我觉得挺棒的。所以我将其用思维导图归纳成如下:&lt;/p&gt;
&lt;p&gt;1.提倡良好的代码风格&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201810/1255290-20181029200815882-1761097956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 换行排版总得要把，不然看起来乱七八糟也不好，这个目前大多数人都可以做到。但是风格统一的话，就有点难了，俗话说，一百个人眼里有一百个哈姆莱特。有点难并不代码没有办法解决，比如现在流行的Java规范手册《阿里巴巴Java开发手册》，就可以借鉴参考。便捷(通用性工具，比如sonar这个代码质量分析或者是sonar lite这个Eclipse代码分析插件也是有利于塑造良好的代码风格。&lt;/p&gt;

&lt;p&gt; 2.不要完全依赖单元测试来发现问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201810/1255290-20181029200921644-412202788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 单元测试确实不能覆盖所有的场景，因为我们开发人员在有限的时间内，所能做的测试及其对应的数据场景，也就三种:&lt;/p&gt;
&lt;p&gt;(1)正常;&lt;/p&gt;
&lt;p&gt;(2)边界;&lt;/p&gt;
&lt;p&gt;(3)异常;&lt;/p&gt;
&lt;p&gt;其它的我们也没有这个时间去考虑那么多，即便是有专门的测试人员，测试的场景也还是有限。更何况像没有测试的小公司呢。&lt;/p&gt;

&lt;p&gt;3.让注释正确、清晰、简洁&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201810/1255290-20181029201003372-1649951466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我觉得上面的这个思维导图已经足够详细了，所以关于注释我不再赘述。&lt;/p&gt;
&lt;p&gt;4.接口职责单一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201810/1255290-20181029201104386-1848470697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5.增强类的可替换性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201810/1255290-20181029201154499-330302900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;6.依赖抽象而不是实现&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201810/1255290-20181029201229295-2086381462.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;4、5、6涉及对应的设计模式，但是这些设计模式，我们实际开发中，一直在遵守，同时也一直在破坏。很难有人完全遵从设计模式的那一套。&lt;/p&gt;
&lt;p&gt;7.抛弃七条不良编码习惯&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201810/1255290-20181029201300863-1248574126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;(1)自由格式的代码，随心所欲想怎么写就怎么写，最后你就等着哭吧。&lt;/p&gt;
&lt;p&gt;(2)不使用抽象的代码，比如在Java中，一般项目会这么写:&lt;/p&gt;
&lt;p&gt;entity、dao、service、serviceImpl、controller&lt;/p&gt;
&lt;p&gt;entity对应数据实体&lt;/p&gt;
&lt;p&gt;dao相当于数据访问层&lt;/p&gt;
&lt;p&gt;service及其实现类相当于业务逻辑层&lt;/p&gt;
&lt;p&gt;controller自然就是接口或者是视图控制层&lt;/p&gt;
&lt;p&gt;有的人图省事，按照自己的想法来，将service和serviceImpl合并为一个，我们之前说过单一职责原则。如果是service和serviceImpl合并为一个，就不符合作者所说的，单一职责和依赖倒置或面向接口。因为无论是单一职责也好，依赖倒置或者面向接口也罢，遵从的核心就是，“高内聚，低耦合”。他这么做，自然就是“低内聚，高耦合”。&lt;/p&gt;
&lt;p&gt;(3)像彰显个性，比如自认为将代码写的让别人看不懂，就认为自己很牛逼。&lt;/p&gt;
&lt;p&gt;(4)像死代码，比如某某功能代码已经暂时弃用，但是以后可能用,就用个注释将其注释掉，等待以后再用，实际情况是以后都不会再用，放在这影响可读性。&lt;/p&gt;
&lt;p&gt;(5)像冗余代码,比如有工具类可以做字符串和非空判断，你却还要写个if-else if-else等等。&lt;/p&gt;
&lt;p&gt;(6)像拒绝变化的代码，就好比人拒绝成长那样，总有一天呢会吃亏的。&lt;/p&gt;
&lt;p&gt;(7)像自以为是的代码，自己很快的写完初步测试了几个场景，或者是不测试就盲目的自信认为自己写的完全没有问题，一点bug都不会有，到最后，一般情况都会有问题的。这一点我深有感触。&lt;/p&gt;

&lt;p&gt;8.以技术人自律而不是工人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1255290/201810/1255290-20181029201334075-2044980409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;(1)关于熟悉工具，比如Eclipse，你如果十分熟悉的话，无论是当项目越来越庞大时，或者是调试时，你总会比那些熟悉程度相对于比你低的多的人在错误排查或者说找某个包下的类，效率上要快的多。&lt;/p&gt;
&lt;p&gt;(2)关于IDE，每个编程语言都有其独特的IDE，如果没有IDE，想象着你用记事本或者notepad写代码，然后命令行编译，那是一件多么痛苦的事情啊，IDE的出现与广泛应用就是为了提高程序员的开发效率，减少不必要的体力劳动。&lt;/p&gt;
&lt;p&gt;(3)坚持编码,这里要提一点，只要还是在技术这个圈子里面混，代码还是要写的，不然哪来的灵感呢。&lt;/p&gt;
&lt;p&gt;(4)编码前思考，这里之前我也说过，编码前不思考直接开干，最后的结果是效率低，无用功。&lt;/p&gt;
&lt;p&gt;(5)坚持重构，重构不一定是大规模，它可以是一步一步，比如你之前的controller一般都是作为控制层，通常是接收请求，处理数据，返回数据等，像与安卓对接，一般都是JSON数据，你可以将之前引用的JSONObject抽取出来为一个类复用，省得每次controller都要导包。&lt;/p&gt;
&lt;p&gt;(6)多写文档，之前也说过，写文档不仅仅是为了理清业务逻辑和解决问题，还是为了提高自己的思维能力。&lt;/p&gt;
&lt;p&gt;(7)保持程序版本的简单性，一个项目不要太多版本，否则往往会将简单的事情变为复杂。&lt;/p&gt;
&lt;p&gt;(8)做单元测试，关于单元测试的重要性，我在这篇文章说过，文章链接:https://www.cnblogs.com/youcong/p/9291184.html 所以就不再多说。&lt;/p&gt;
&lt;p&gt;(9)做好备份，不怕一万就怕万一，总得留个后手。&lt;/p&gt;
&lt;p&gt;(10)不要重复造轮子，有现成的工具，就不要自己千辛万苦的去写了，直接用现成的，当然了，你如果觉得你可以改造这个轮子，让这个轮子变的更好，那么，我个人觉得不妨试一试，也许能推陈出新。&lt;/p&gt;
&lt;p&gt;(11)不要拷贝，你可以理解为了有很多处代码段需要引用某段函数，既然是需要引用相同的某段函数，为何不将其写成一个代码块方便调用呢。&lt;/p&gt;
&lt;p&gt;(12）代码充满灵性的体现是，至少你看到这段代码知道是什么意思，见其便知意。而不是看天书似的。&lt;/p&gt;
&lt;p&gt;(13)测试自动化，不管是性能测试、单元测试，还是功能测试，想尽办法让它自动化，不要在测试之前手动配置触发条件。&lt;/p&gt;
&lt;p&gt;(14)做压力测试，这个就不必多说了，现在压力测试工具有很多，loadrunner或是jmeter,整体来说，都还不错。&lt;/p&gt;
&lt;p&gt;(15)&quot;剽窃“不可耻，学习人家怎么写代码的，好的借鉴，不好的引以为戒，也是一种提高自我编码质量的有效方式之一。&lt;/p&gt;
&lt;p&gt;(16)坚持向敏捷学习,提高软件开发流程的效率。&lt;/p&gt;
&lt;p&gt;(17)重里更重面，把握好用户的第一面。&lt;/p&gt;
&lt;p&gt;(18)分享，分享自己的技术，分享自己解决问题的方式，分享自己是怎么写代码的。&lt;/p&gt;
&lt;p&gt;(19)刨根问底，凡是对于问题或者事物，都要心中有为什么，特别是开发任务繁重的时候，业务不问清楚，很容易导致做无用功。&lt;/p&gt;
&lt;p&gt;(20)横向扩展，主要是又一点到多面，相当于在某些业务时，你接触过数据库、接触过安卓、接触过IOS或者是运维等，借此可以扩大自己的知识面，这也是发展为全栈工程师的途径之一。&lt;/p&gt;

&lt;p&gt;小结:&lt;/p&gt;
&lt;p&gt;上述说的，有些来自这本书，也有些来自我个人的想法。希望能给大家带来帮助。&lt;/p&gt;
</description>
<pubDate>Mon, 29 Oct 2018 13:04:00 +0000</pubDate>
<dc:creator>挑战者V</dc:creator>
<og:description>这本书可以作为平时写代码的一个参考书，这本书以我个人读的经验看来，最好是通过平时代码驱动的方式来读，这样吸收的快，也读的快。 这本书主要讲什么，我自己用了个思维导图概述: 根据这种导图可知，主要讲的就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youcong/p/9873261.html</dc:identifier>
</item>
<item>
<title>IdentityServer4之JWT签名(RSA加密证书)及验签 - LouieGuo</title>
<link>http://www.cnblogs.com/guolianyu/p/9872661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guolianyu/p/9872661.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;在IdentityServer4中有两种令牌，一个是JWT和Reference Token，在IDS4中默认用的是JWT，那么这两者有什么区别呢？&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、JWT与Reference Token的区别&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 1、JWT(不可撤回)　&lt;/span&gt;　&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;JWT是一个非常轻巧的规范，一般被用来在身份提供者和服务提供者间传递安全可靠的信息。JWT令牌是一个自包含的访问令牌 - 它是一个带有声明和过期的受保护数据结构。一旦API了解了密钥材料，它就可以验证自包含的令牌，而无需与发行者进行通信。这使得JWT难以撤销。它们将一直有效，直到它们过期。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　JWT常被用于前后端分离，可以和 Restful API 配合使用，常用于构建身份认证机制，一个 JWT 实际上就是一个字符串，它包含了使用.分隔的三部分： Header 头部 Payload 负载 Signature 签名（格式：Header.Payload.Signature）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个三个部分中最关键的就是signature。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;signature：&lt;/strong&gt;被用来确认JWT信息的发送者是谁，并保证信息没有被篡改，使用header中指定的算法将编码后的header、编码后的payload、一个secret进行加密。因此签名算法推荐使用RSA或ECDSA非对称加密算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;JWT特点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　A、JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　B、为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　C、jwt去中心化的思想：api资源收到第一个请求之后，会去id4服务器获取公钥，然后用公钥验证token是否合法，如果合法进行后面的有效性验证。有且只有第一个请求才会去id4服务器请求公钥，后面的请求都会用第一次请求的公钥来验证，这也是jwt去中心化验证的思想。（注：如果签名证书发生改变则需要重启有请求ids4服务器的资源服务器。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　D、JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、Reference Token(不携带任何用户数据，可撤回)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当使用 Reference token 的时候，服务端会对 Token 进行持久化，当客户端请求资源端（API）的时候，资源端需要每次都去服务端通信去验证 Token 的合法性[/connect/introspect]，IdentityServer4.AccessTokenValidation 中间件中可以配置缓存一定的时候去验证,并且 Token 是支持撤销[/connect/revocation]的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用引用令牌时 - IdentityServer会将令牌的内容存储在数据存储中，并且只会将此令牌的唯一标识符发回给客户端。接收此引用的API必须打开与IdentityServer的反向通道通信以验证令牌。如下：access_token就是唯一标识。（注不携带任何数据）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192349075-845487310.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;/span&gt;&lt;span&gt;当 AccessTokenType 定义为 Reference 的时候，验证资源端要注意配置 ApiSecrets 以确保 POST /connect/introspect HTTP/1.1 接口能验证通过,当 AccessTokenType 定义为 Jwt 的时候则资源端可不配置 options.ApiSecret 选项。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192402535-735400085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Reference Token官方图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192408995-399114814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 以上就是JWT与Reference token的区别。为了减少访问中心服务器的资源，使用JWT还是非常棒的，毕竟与服务器交互的资源还是非常的昂贵的。&lt;strong&gt;不过具体的还得视实际情况而定。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;那么我们来看一下在IDS4中API使用JWT以及Reference Token的交互流程图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、&lt;strong&gt;IDS4中API使用JWT以及Reference Token与认证中心的交互流程图&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;此图为：JWT，当然大家可以通过fiddler 抓包工具来查看一下具体的数据流就能明白其中的道理。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;资源服务器在第一次解析AccessToken的时候会先到授权服务器获取配置数据（例如会访问：http://localhost:5000/.well-known/openid-configuration 获取配置的，http://localhost:5000/.well-known/openid-configuration/jwks 获取jwks）），之后解析AccessToken都会使用第一次获取到的配置数据，因此如果授权服务的配置更改了(加密证书等等修改了)，那么应该重启资源服务器使之重新获取新的配置数据；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192414446-1731539680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 此图为：Reference Token&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192423525-2001809843.png&quot; alt=&quot;&quot; width=&quot;1045&quot; height=&quot;859&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 以上即JWT与Reference Token 流程图。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、JWT中使用RSA加密&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在说明JWT使用RSA加密之前我们先来比较一下其他的加密算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、HS256与RS256的区别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　HS256 使用密钥生成&lt;span&gt;&lt;strong&gt;固定的签名&lt;/strong&gt;&lt;/span&gt;，RS256 使用成非对称进行签名。简单地说，HS256 必须与任何想要验证 JWT的 客户端或 API 共享秘密。即 如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192430565-944781617.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;RS256 生成&lt;span&gt;&lt;strong&gt;非对称签名&lt;/strong&gt;&lt;/span&gt;，这意味着必须使用私钥来签签名 JWT，并且必须使用对应的公钥来验证签名。与对称算法不同，使用 RS256 可以保证服务端是 JWT 的签名者，因为服务端是唯一拥有私钥的一方。这样做将不再需要在许多应用程序之间共享私钥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;2、创建自签名证书(操作步骤)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;生产环境（负载集群）一般需要使用固定的证书签名与验签,以确保重启服务端或负载的时候 Token 都能验签通过。（不使用临时证书）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么证书如何生成请看下面分解步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;第一种：&lt;/strong&gt;使用OpenSSL生成证书，&lt;/span&gt;&lt;span&gt;注：RSA加密证书长度要2048以上，否则服务运行会抛异常&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#Linux系统生成证书：（推荐使用）
sudo yum install openssl (CentOS)&lt;br/&gt;#生成私钥文件
openssl genrsa &lt;/span&gt;-&lt;span&gt;out&lt;/span&gt; idsrv4.key &lt;span&gt;2048&lt;/span&gt;&lt;span&gt;
#创建证书签名请求文件 CSR（Certificate Signing Request），用于提交给证书颁发机构（即 Certification Authority (CA)）即对证书签名，申请一个数字证书。
openssl req &lt;/span&gt;-&lt;span&gt;new&lt;/span&gt; -key idsrv4.key -&lt;span&gt;out&lt;/span&gt;&lt;span&gt; idsrv4.csr &lt;br/&gt;#生成自签名证书（证书颁发机构（CA）签名后的证书，因为自己做测试那么证书的申请机构和颁发机构都是自己,crt 证书包含持有人的信息，持有人的公钥，以及签署者的签名等信息。当用户安装了证书之后，便意味着信任了这份证书，同时拥有了其中的公钥。）
openssl x509 &lt;/span&gt;-req -days &lt;span&gt;365&lt;/span&gt; -&lt;span&gt;in&lt;/span&gt; idsrv4.csr -signkey idsrv4.key -&lt;span&gt;out&lt;/span&gt;&lt;span&gt; idsrv4.crt &lt;strong&gt;&lt;span&gt;（包含公钥）&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;#自签名证书与私匙合并成一个文件（注：.pfx中可以加密码保护，所以相对安全些）
openssl pkcs12 &lt;/span&gt;-export -&lt;span&gt;in&lt;/span&gt; idsrv4.crt -inkey idsrv4.key -&lt;span&gt;out&lt;/span&gt; idsrv4.pfx (&lt;span&gt;&lt;strong&gt;注：在生成的过程中会让我们输入Export Password&lt;/strong&gt;&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 证书截图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192435631-1334445795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192443702-2045567015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　第二种:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;openssl req -newkey rsa:&lt;span&gt;2048&lt;/span&gt; -nodes -keyout idsrv4.key -x509 -days &lt;span&gt;365&lt;/span&gt; -&lt;span&gt;out&lt;/span&gt;&lt;span&gt; idsrv4.cer
openssl pkcs12 &lt;/span&gt;-export -&lt;span&gt;in&lt;/span&gt; idsrv4.cer -inkey idsrv4.key -&lt;span&gt;out&lt;/span&gt; idsrv4.pfx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;生成如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192448478-826645463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、证书生成之后就可进入VS2017中配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拷贝生成的证书，放到认证/授权服务器项目中。(VS中配置文件设置文件始终复制)，最后把证书路径和密码配置到 IdentityServer 中，因为我们自签名的证书是 PKCS12 (个人数字证书标准，Public Key Cryptography Standards #12) 标准包含私钥与公钥）标准，包含了公钥和私钥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; A、在appsetting.json 配置文件中添加如下：此处需要配置password，自定义即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192453655-1200482466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;B、在starup.cs中ConfigureServices方法中配置如下即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192459185-333070453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;配置完后即可。我们启动IDS4项目即可生成加密的token。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192505220-2062216781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;将得到的token在jwt.io 网站来认证一下：把后缀为 crt 公钥、key私钥复制到验证中，发现认证ok。这样即可实现防篡改。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651008/201810/651008-20181029192510965-1987798348.png&quot; alt=&quot;&quot; width=&quot;889&quot; height=&quot;441&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;五、总结&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在实际环境中应该使用加密的token，而不应该使用临时令牌。以及尽量设置token的过期时间短，以及刷新token的机制，这样可以尽可能的保护token以及数据安全。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;asp.net core 交流群：&lt;span&gt;787464275 &lt;/span&gt;欢迎加群交流&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;如果您认为这篇文章还不错或者有所收获，您可以点击右下角的&lt;span&gt;【推荐】&lt;/span&gt;按钮精神支持，因为这种支持是我继续写作，分享的最大动力！&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;11.282505910165&quot;&gt;

&lt;p&gt;&lt;strong&gt;声明：原创博客请在转载时保留原文链接或者在文章开头加上本人博客地址，如发现错误，欢迎批评指正。凡是转载于本人的文章，不能设置打赏功能，如有特殊需求请与本人联系！&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;微信公众号：欢迎关注                                                 QQ技术交流群： &lt;/strong&gt;欢迎加群&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201809/651008-20180909162914580-1787420461.jpg&quot; alt=&quot;&quot; width=&quot;267&quot; height=&quot;267&quot;/&gt;                &lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201809/651008-20180909182103726-1395406084.jpg&quot; alt=&quot;&quot; width=&quot;246&quot; height=&quot;249&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 29 Oct 2018 12:56:00 +0000</pubDate>
<dc:creator>LouieGuo</dc:creator>
<og:description>一、前言 在IdentityServer4中有两种令牌，一个是JWT和Reference Token，在IDS4中默认用的是JWT，那么这两者有什么区别呢？ 二、JWT与Reference Token</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guolianyu/p/9872661.html</dc:identifier>
</item>
<item>
<title>day65_Lucene学习笔记 - 黑泽明军</title>
<link>http://www.cnblogs.com/chenmingjun/p/9873209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/9873209.html</guid>
<description>&lt;ul&gt;&lt;li&gt;课程计划：
&lt;ul&gt;&lt;li&gt;1、Lucene介绍
&lt;ul&gt;&lt;li&gt;&lt;span&gt;a) 什么是lucene&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;b) 全文检索的应用场景&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;c) 全文检索定义&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2、Luence实现全文检索的流程（重点）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3、Lucene入门程序&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4、Field域（重点）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;5、索引的维护
&lt;ul&gt;&lt;li&gt;&lt;span&gt;a) 添加索引&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;b) 删除索引&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;c) 修改索引&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;6、索引的搜索（重点）
&lt;ul&gt;&lt;li&gt;&lt;span&gt;a) 通过Query子类创建查询对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;b) 通过QueryParser创建查询对象&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;7、相关度排序&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;8、中文分词器（重点）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h1lucene&quot;&gt;&lt;span&gt;&lt;strong&gt;1、Lucene介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h11lucene&quot;&gt;&lt;span&gt;&lt;strong&gt;1.1、什么是lucene&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Lucene是Apache的一个&lt;code&gt;全文检索引擎工具包&lt;/code&gt;，通过lucene可以让程序员快速开发一个全文检索功能。
&lt;ul&gt;&lt;li&gt;&lt;span&gt;引擎：核心组件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;工具包：jar包、类库&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h12&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2、全文检索的应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h121&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2.1、搜索引擎&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2JjHK.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h122&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2.2、站内搜索（关注）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2JzND.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h123&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2.3、文件系统的搜索&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2JOnx.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h124&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2.4、总结&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Lucene和搜索引擎不是一回事！&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Lucene是一个工具包，它&lt;code&gt;不能独立运行&lt;/code&gt;，不能单独对外&lt;code&gt;提供服务&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;搜索引擎可以独立运行对外提供搜索服务。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h13&quot;&gt;&lt;span&gt;&lt;strong&gt;1.3、全文检索的定义&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;全文检索首先对要搜索的文档进行&lt;code&gt;分词&lt;/code&gt;，然后形成索引，通过查询索引来查询文档。这种&lt;code&gt;先创建索引&lt;/code&gt;，然后&lt;code&gt;根据索引来进行搜索&lt;/code&gt;的过程，就叫全文检索。&lt;/li&gt;
&lt;li&gt;比如：字典
&lt;ul&gt;&lt;li&gt;&lt;span&gt;字典的偏旁部首页，就类似于luence的索引。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;字典的具体内容，就类似于luence的文档内容。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h2lucene&quot;&gt;&lt;span&gt;&lt;strong&gt;2、Lucene实现全文检索的流程&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2JXB6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;详解如下：
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;全文检索的流程：创建索引流程、搜索索引流程&lt;br/&gt;  创建索引流程：采集数据 --&amp;gt; 文档处理存储到索引库中&lt;br/&gt;  搜索索引流程：输入查询条件 --&amp;gt; 通过lucene的查询器查询索引 --&amp;gt; 从索引库中取出结果 --&amp;gt; 视图渲染&lt;br/&gt;注意：Lucene本身不能进行视图渲染。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;h3lucene&quot;&gt;&lt;span&gt;&lt;strong&gt;3、Lucene入门程序&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h31&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1、需求&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用Lucene实现电商项目中图书类商品的索引和搜索功能。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h32&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2、环境准备&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Jdk环境：1.7.0_80&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Ide环境：Eclipse Oxygen&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据库环境：mysql 5.X&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Lucene：4.10.3（从4.8版本以后，必须使用jdk1.7及以上）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h321&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.1、数据库脚本初始化&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2Jqj1.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;内容如下：
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs sql&quot; readability=&quot;8&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;exists&lt;/span&gt; book;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; book&lt;br/&gt;(&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;                     &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt;                 &lt;span class=&quot;hljs-built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;192&lt;/span&gt;),&lt;br/&gt;privce               &lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt;,&lt;br/&gt;pic                   &lt;span class=&quot;hljs-built_in&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;96&lt;/span&gt;),&lt;br/&gt;description          &lt;span class=&quot;hljs-built_in&quot;&gt;text&lt;/span&gt;,&lt;br/&gt;primary &lt;span class=&quot;hljs-keyword&quot;&gt;key&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;)&lt;br/&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h322lucene&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2.2、Lucene下载安装&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Lucene是开发全文检索功能的工具包，使用时从官方网站下载，并解压。&lt;br/&gt;官方网站：http://lucene.apache.org/&lt;br/&gt;目前最新版本：7.5.0&lt;br/&gt;下载地址：http://archive.apache.org/dist/lucene/java/&lt;br/&gt;下载版本：4.10.3（学习使用版本）&lt;br/&gt;JDK要求：1.7以上（从版本4.8开始，不支持1.7以下）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要学习的3个文件夹&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2JxAO.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h33&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3、工程搭建（两步）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h331java&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.1、第一步：创建普通的java工程&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2Y99H.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h332jar&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3.2、第二步：添加jar包&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;入门程序只需要添加以下jar包：&lt;br/&gt;  mysql5.1驱动包：mysql-connector-java-5.1.7-bin.jar&lt;br/&gt;  核心包：lucene-core-4.10.3.jar&lt;br/&gt;  分析器通用包：lucene-analyzers-common-4.10.3.jar&lt;br/&gt;  查询解析器包：lucene-queryparser-4.10.3.jar&lt;br/&gt;  junit包(非必须)：junit-4.9.jar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h34&quot;&gt;&lt;span&gt;&lt;strong&gt;3.4、创建索引的流程&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;对文档索引的过程，就是将用户要搜索的文档内容进行索引，然后把索引存储在索引库（index）中。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h341&quot;&gt;&lt;span&gt;&lt;strong&gt;3.4.1、为什么要采集数据&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;详解如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;为什么要采集数据？&lt;/strong&gt;&lt;br/&gt;  全文检索要搜索的数据信息格式多种多样，拿搜索引擎（百度、google）来说，通过搜索引擎网站能搜索互联网站上的网页(html)、互联网上的音乐(mp3)、视频(avi)、pdf电子书等。对于这种格式不同的数据，需要先将他们采集到本地，然后统一封装到&lt;code&gt;lucene的文档对象&lt;/code&gt;中，也就是说需要将存储的内容进行统一后才能对它进行查询。&lt;br/&gt;  全文检索搜索的这些数据称为非结构化数据。&lt;br/&gt;&lt;strong&gt;什么是非结构化数据？&lt;/strong&gt;&lt;br/&gt;  结构化数据：指具有固定格式或有限长度的数据，如数据库、元数据等。&lt;br/&gt;  非结构化数据：指不定长或无固定格式的数据，如邮件、word文档等。&lt;br/&gt;&lt;strong&gt;如何对结构化数据进行搜索？&lt;/strong&gt;&lt;br/&gt;  由于结构化数据是固定格式，所以就可以针对固定格式的数据设计算法来搜索，比如数据库like查询，like查询采用顺序扫描法，使用关键字匹配内容，对于内容量大的like查询速度慢。&lt;br/&gt;&lt;strong&gt;如何对非结构化数据进行搜索？&lt;/strong&gt;&lt;br/&gt;  需要将所有要搜索的非结构化数据通过技术手段采集到一个固定的地方，将这些非结构化的数据想办法组成结构化的数据，再以一定的算法去搜索。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h342&quot;&gt;&lt;span&gt;&lt;strong&gt;3.4.2、如何采集数据&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;详解如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;采集数据技术有哪些？&lt;/strong&gt;&lt;br/&gt;  1、对于互联网上网页采用http将网页抓取到本地生成html文件。（网页采集：使用爬虫工具（http工具）将网页爬取到本地）&lt;br/&gt;  2、&lt;code&gt;如果数据在数据库中就连接数据库读取表中的数据。（数据库采集：使用jdbc程序进行数据采集）&lt;/code&gt;&lt;br/&gt;  3、如果数据是文件系统中的某个文件，就通过文件系统读取文件的内容。（文件系统采集：使用io流采集）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（1）网页采集（了解）&lt;/strong&gt;&lt;br/&gt;详解如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;因为目前&lt;code&gt;搜索引擎&lt;/code&gt;主要搜索数据的来源是互联网，搜索引擎使用一种&lt;code&gt;爬虫程序&lt;/code&gt;抓取网页（通过http抓取html网页信息），以下是一些&lt;code&gt;爬虫&lt;/code&gt;项目：&lt;br/&gt;  &lt;strong&gt;Solr&lt;/strong&gt;（http://lucene.apache.org/solr），solr 是apache的一个子项目，支持&lt;code&gt;从关系数据库、xml文档中&lt;/code&gt;提取原始数据。&lt;br/&gt;  &lt;strong&gt;Nutch&lt;/strong&gt;（http://lucene.apache.org/nutch），Nutch 是apache的一个子项目，包括&lt;code&gt;大规模爬虫工具&lt;/code&gt;，能够抓取和分辨web网站数据。&lt;br/&gt;  &lt;strong&gt;jsoup&lt;/strong&gt;（http://jsoup.org/），jsoup 是一款java的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套&lt;code&gt;非常省力的API&lt;/code&gt;，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。&lt;br/&gt;  &lt;strong&gt;heritrix&lt;/strong&gt;（http://sourceforge.net/projects/archive-crawler/files/），Heritrix 是一个由java开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它&lt;code&gt;良好的可扩展性&lt;/code&gt;，方便用户实现自己的抓取逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（2）数据库采集（掌握）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;针对电商站内搜索功能，全文检索的数据源在数据库中，需要通过jdbc访问数据库中book表的内容。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YijI.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;po类：Book.java&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;8&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.itheima.lucene.po;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Book&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Integer id;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Float price;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String pic;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String description;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Integer &lt;span class=&quot;hljs-title&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; id;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;setId&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Integer id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; name;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;setName&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; Float &lt;span class=&quot;hljs-title&quot;&gt;getPrice&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; price;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;setPrice&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Float price)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.price = price;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;getPic&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; pic;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;setPic&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String pic)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.pic = pic;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;hljs-title&quot;&gt;getDescription&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; description;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;setDescription&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String description)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.description = description;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dao：BookDao.java&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BookDao&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;Book&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;queryBookList&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dao：BookDaoImpl.java&lt;/p&gt;
&lt;pre readability=&quot;14.5&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;23&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BookDaoImpl&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BookDao&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;Book&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;queryBookList&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;Connection connection = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;PreparedStatement preparedStatement = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;ResultSet resultSet = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;List&amp;lt;Book&amp;gt; list = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Book&amp;gt;();&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;Class.forName(&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);&lt;br/&gt;connection = DriverManager.getConnection(&lt;span class=&quot;hljs-string&quot;&gt;&quot;jdbc:mysql://localhost:3306/solr&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;root&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;root&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;String sql = &lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM book&quot;&lt;/span&gt;;&lt;br/&gt;preparedStatement = connection.prepareStatement(sql);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;resultSet = preparedStatement.executeQuery();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (resultSet.next()) {&lt;br/&gt;Book book = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Book();&lt;br/&gt;book.setId(resultSet.getInt(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;));&lt;br/&gt;book.setName(resultSet.getString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;));&lt;br/&gt;book.setPrice(resultSet.getFloat(&lt;span class=&quot;hljs-string&quot;&gt;&quot;price&quot;&lt;/span&gt;));&lt;br/&gt;book.setPic(resultSet.getString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pic&quot;&lt;/span&gt;));&lt;br/&gt;book.setDescription(resultSet.getString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description&quot;&lt;/span&gt;));&lt;br/&gt;list.add(book);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; list;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以进行单元测试一下。这里省略啦！&lt;/p&gt;
&lt;h4 id=&quot;h343&quot;&gt;&lt;span&gt;&lt;strong&gt;3.4.3、索引文件的逻辑结构&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YS4e.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;详解如下：
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;文档域&lt;/strong&gt;&lt;br/&gt;  文档域存储的信息就是采集到的信息，通过Document对象来存储，具体说是通过Document对象中Field域来存储数据。对于非结构化的数据统一格式为Document文档格式，&lt;code&gt;一个文档有多个Field域&lt;/code&gt;，不同的文档其Field的个数可以不同，&lt;code&gt;建议相同类型的文档包括相同的Field&lt;/code&gt;。&lt;br/&gt;  比如：数据库中一条记录会存储一个一个Document对象，数据库中一列会存储成Document中一个field域。&lt;br/&gt;  文档域中，Document对象之间是没有关系的。而且每个Document中的field域也不一定一样。&lt;br/&gt;  本例子一个Document对应一 条 Book表的记录。&lt;br/&gt;&lt;strong&gt;索引域&lt;/strong&gt;&lt;br/&gt;  用于&lt;code&gt;搜索&lt;/code&gt;，搜索程序将从索引域中搜索一个一个词，&lt;code&gt;根据词找到对应的文档&lt;/code&gt;。&lt;br/&gt;  将Document中的Field的内容进行分词，将分好的词创建索引，&lt;code&gt;索引=Field域名:词&lt;/code&gt;。&lt;br/&gt;  索引域主要是为了搜索使用的。&lt;code&gt;索引域内容是经过lucene分词之后存储的&lt;/code&gt;。&lt;br/&gt;&lt;strong&gt;倒排索引表&lt;/strong&gt;&lt;br/&gt;  传统方法是先找到文件，如何在文件中找内容，在文件内容中匹配搜索关键字，这种方法是&lt;code&gt;顺序扫描方法&lt;/code&gt;，数据量大就搜索慢。&lt;br/&gt;  倒排索引结构是根据内容（词语）找文档，&lt;code&gt;倒排索引结构&lt;/code&gt;也叫&lt;code&gt;反向索引结构&lt;/code&gt;，包括索引和文档两部分，&lt;code&gt;索引即词汇表&lt;/code&gt;，它是在索引中匹配搜索&lt;code&gt;关键字&lt;/code&gt;，由于索引内容量有限并且采用&lt;code&gt;固定优化算法&lt;/code&gt;搜索速度很快，找到了索引中的词汇，&lt;code&gt;词汇与文档关联&lt;/code&gt;，从而最终找到了文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h344&quot;&gt;&lt;span&gt;&lt;strong&gt;3.4.4、创建索引&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;创建索引流程图解：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YZE8.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;详解如下：
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;  &lt;strong&gt;IndexWriter&lt;/strong&gt;：是索引过程的核心组件，通过IndexWriter可以&lt;code&gt;创建新索引&lt;/code&gt;、&lt;code&gt;更新索引&lt;/code&gt;、&lt;code&gt;删除索引&lt;/code&gt;操作。IndexWriter需要通过&lt;code&gt;Directory&lt;/code&gt;对索引进行存储操作。&lt;br/&gt;  &lt;strong&gt;Directory&lt;/strong&gt;：描述了索引的存储位置，底层封装了I/O操作，负责对索引进行存储。它是一个抽象类，它的子类常用的包括&lt;code&gt;FSDirectory&lt;/code&gt;（在文件系统存储索引）、&lt;code&gt;RAMDirectory&lt;/code&gt;（在内存存储索引）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（1）创建Document&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;采集数据的目的是为了索引，在索引前需要将原始内容创建成&lt;code&gt;文档（Document）&lt;/code&gt;，&lt;code&gt;文档（Document）中包括一个一个的域（Field）&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（2）分词&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;  在对Docuemnt中的内容创建索引之前需要使用分词器进行分词，主要过程就是分词、过滤两步。&lt;br/&gt;  &lt;strong&gt;分词&lt;/strong&gt;：就是将采集到的文档内容切分成一个一个的词，具体应该说是将Document中Field的value值切分成一个一个的词。&lt;br/&gt;  &lt;strong&gt;过滤&lt;/strong&gt;：包括去除标点符号、去除停用词（的、是、a、an、the等）、大写转小写、词的形还原（复数形式转成单数形参、过去式转成现在式）等。&lt;br/&gt;  &lt;strong&gt;什么是停用词？&lt;/strong&gt;停用词是为节省存储空间和提高搜索效率，搜索引擎在索引页面或处理搜索请求时会自动忽略某些字或词，这些字或词即被称为Stop Words(停用词)。比如语气助词、副词、介词、连接词等，通常自身并无明确的意义，只有将其放入一个完整的句子中才有一定作用，如常见的“的”、“在”、“是”、“啊”等。&lt;br/&gt;  示例：&lt;br/&gt;  要分词的内容：Lucene is a Java full-text search engine.&lt;br/&gt;  分词：&lt;br/&gt;    Lucene&lt;br/&gt;    is&lt;br/&gt;    a&lt;br/&gt;    Java&lt;br/&gt;    full&lt;br/&gt;    -&lt;br/&gt;    text&lt;br/&gt;    search&lt;br/&gt;    engine&lt;br/&gt;    .&lt;br/&gt;  过滤：&lt;br/&gt;  去掉标点符号&lt;br/&gt;    Lucene&lt;br/&gt;    is&lt;br/&gt;    a&lt;br/&gt;    Java&lt;br/&gt;    full&lt;br/&gt;    text&lt;br/&gt;    search&lt;br/&gt;    engine&lt;br/&gt;  去掉停用词&lt;br/&gt;    Lucene&lt;br/&gt;    Java&lt;br/&gt;    full&lt;br/&gt;    text&lt;br/&gt;    search&lt;br/&gt;    engine&lt;br/&gt;  大写转小写&lt;br/&gt;    lucene&lt;br/&gt;    java&lt;br/&gt;    full&lt;br/&gt;    text&lt;br/&gt;    search&lt;br/&gt;    engine&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Lucene作为了一个工具包提供不同国家的分词器，如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YPgA.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;注意由于语言不同分析器的切分规则也不同，本例子使用StandardAnalyzer，它可以对用英文进行分词。&lt;br/&gt;如下是org.apache.lucene.analysis.standard.standardAnalyzer的部分源码：
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; TokenStreamComponents &lt;span class=&quot;hljs-title&quot;&gt;createComponents&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; String fieldName, &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; Reader reader)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; StandardTokenizer src = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StandardTokenizer(getVersion(), reader);&lt;br/&gt;src.setMaxTokenLength(maxTokenLength);&lt;br/&gt;TokenStream tok = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StandardFilter(getVersion(), src);&lt;br/&gt;tok = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LowerCaseFilter(getVersion(), tok);&lt;br/&gt;tok = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StopFilter(getVersion(), tok, stopwords);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TokenStreamComponents(src, tok) {&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;setReader&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; Reader reader)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;src.setMaxTokenLength(StandardAnalyzer.&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.maxTokenLength);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt;.setReader(reader);&lt;br/&gt;}&lt;br/&gt;};&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详解如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;Tokenizer是分词器&lt;/code&gt;，负责将reader转换为语汇单元即进行分词，Lucene提供了很多的分词器，也可以使用第三方的分词，比如：&lt;code&gt;IKAnalyzer是一个中文分词器&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;tokenFilter是分词过滤器&lt;/code&gt;，负责对语汇单元进行过滤，tokenFilter可以是一个&lt;code&gt;过滤器链儿&lt;/code&gt;，Lucene提供了很多的分词器过滤器，比如：大小写转换、去除停用词等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如下图是语汇单元的生成过程：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YC3d.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;从一个Reader字符流开始，创建一个基于Reader的Tokenizer分词器，经过三个TokenFilter生成&lt;code&gt;语汇单元Token&lt;/code&gt;。
&lt;ul&gt;&lt;li&gt;&lt;code&gt;同一个域中相同的语汇单元（Token）对应同一个Term（词）&lt;/code&gt;，Term（词）记录了语汇单元的内容及所在域的域名等，还包括了该token出现的频率及位置。
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不同的域中拆分出来的相同的单词对应不同的term。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;相同的域中拆分出来的相同的单词对应相同的term。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;例如：图书信息里面，图书名称中的java和图书描述中的java对应不同的term。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;pre readability=&quot;17&quot;&gt;
&lt;code class=&quot;hljs cs&quot; readability=&quot;28&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IndexManager&lt;/span&gt; {&lt;br/&gt;@&lt;span class=&quot;hljs-function&quot;&gt;Test&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;createIndex&lt;/span&gt;() throws Exception &lt;/span&gt;{&lt;br/&gt;BookDao dao = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BookDaoImpl();&lt;br/&gt;List&amp;lt;Book&amp;gt; list = dao.queryBookList();&lt;p&gt;&lt;br/&gt;List&amp;lt;Document&amp;gt; docList = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;Document document = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Book book : list) {&lt;br/&gt;document = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Document();&lt;br/&gt;Field id = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TextField(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;, book.getId().toString(), Store.YES);&lt;br/&gt;Field name = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TextField(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;, book.getName(), Store.YES);&lt;br/&gt;Field price = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TextField(&lt;span class=&quot;hljs-string&quot;&gt;&quot;price&quot;&lt;/span&gt;, book.getPrice().toString(), Store.YES);&lt;br/&gt;Field pic = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TextField(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pic&quot;&lt;/span&gt;, book.getPic(), Store.YES);&lt;br/&gt;Field description = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TextField(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description&quot;&lt;/span&gt;, book.getDescription(), Store.YES);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;document.&lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt;(id);&lt;br/&gt;document.&lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt;(name);&lt;br/&gt;document.&lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt;(price);&lt;br/&gt;document.&lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt;(pic);&lt;br/&gt;document.&lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt;(description);&lt;/p&gt;&lt;p&gt;docList.&lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt;(document);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Analyzer analyzer = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StandardAnalyzer();&lt;/p&gt;&lt;p&gt;&lt;br/&gt;File indexFile = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;hljs-string&quot;&gt;&quot;E:\\index\\hm19&quot;&lt;/span&gt;);&lt;br/&gt;Directory directory = FSDirectory.open(indexFile);&lt;br/&gt;IndexWriterConfig cfg = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IndexWriterConfig(Version.LUCENE_4_10_3, analyzer);&lt;br/&gt;IndexWriter indexWriter = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IndexWriter(directory, cfg);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Document doc : docList) {&lt;br/&gt;indexWriter.addDocument(doc);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;indexWriter.close();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h345luke&quot;&gt;&lt;span&gt;3.4.5、使用Luke查看索引&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Luke作为Lucene工具包中的一个工具（http://www.getopt.org/luke/），可以&lt;code&gt;通过界面&lt;/code&gt;来进行索引文件的查询、修改。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YeUS.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;打开Luke方法：&lt;br/&gt;  命令运行：cmd运行：java -jar lukeall-4.10.3.jar&lt;br/&gt;  手动执行：双击lukeall-4.10.3.jar&lt;br/&gt;Luke的界面：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2Ykut.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;连接索引库成功的界面：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YEHf.png&quot; alt=&quot;&quot;/&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h35&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5、搜索索引的流程&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;搜索流程图：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YwvR.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;详解如下：
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、Query 用户定义查询语句，用户确定查询什么内容（输入什么关键字）&lt;br/&gt;  指定查询语法，相当于sql语句。&lt;br/&gt;2、&lt;code&gt;IndexSearcher 索引搜索对象，定义了很多搜索方法，程序员调用此方法搜索&lt;/code&gt;。&lt;br/&gt;3、IndexReader 索引读取对象，它对应的索引维护对象IndexWriter，IndexSearcher通过IndexReader读取索引目录中的索引文件。&lt;br/&gt;4、Directory 索引流对象，IndexReader需要Directory读取索引库，使用FSDirectory文件系统流对象。&lt;br/&gt;5、IndexSearcher 搜索完成，返回一个TopDocs（&lt;code&gt;匹配度高的前边的一些记录&lt;/code&gt;）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h351&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.1、输入查询语句&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;详解如下：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;同数据库的sql一样，lucene全文检索也有固定的语法：&lt;br/&gt;最基本的有比如：AND, OR, NOT 等&lt;br/&gt;举个例子，用户想找一个description中包括java关键字和spring关键字的文档。&lt;br/&gt;它对应的查询语句：&lt;code&gt;description:java AND spring&lt;/code&gt;&lt;br/&gt;如下是使用Luke搜索的例子：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2Ym4g.png&quot; alt=&quot;&quot;/&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;h352&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.2、搜索分词&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;详解如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;和索引过程的分词一样，这里要对用户输入的关键字进行分词，一般情况索引和搜索使用的分词器一致。&lt;br/&gt;比如：输入搜索关键字“java培训”，分词后为java和培训两个词，与java和培训有关的内容都搜索出来了，如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YQvn.png&quot; alt=&quot;&quot;/&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;h353&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.3、搜索索引&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;详解如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;根据关键字从索引中找到对应的索引信息，即词term。term与document相关联，找到了term就找到了关联的document，从document取出Field中的信息即是要搜索的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre readability=&quot;11&quot;&gt;
&lt;code class=&quot;hljs cs&quot; readability=&quot;16&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IndexSearch&lt;/span&gt; {&lt;br/&gt;@&lt;span class=&quot;hljs-function&quot;&gt;Test&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;searchIndex&lt;/span&gt;() throws Exception &lt;/span&gt;{&lt;br/&gt;Analyzer analyzer = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StandardAnalyzer();&lt;br/&gt;QueryParser queryParser = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; QueryParser(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description&quot;&lt;/span&gt;, analyzer); &lt;br/&gt;Query query = queryParser.parse(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description:java AND spring&quot;&lt;/span&gt;); &lt;p&gt;&lt;br/&gt;File indexFile = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;hljs-string&quot;&gt;&quot;E:\\index\\hm19\\&quot;&lt;/span&gt;);&lt;br/&gt;Directory directory = FSDirectory.open(indexFile);&lt;br/&gt;IndexReader indexReader = DirectoryReader.open(directory);&lt;br/&gt;IndexSearcher indexSearcher = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IndexSearcher(indexReader );&lt;/p&gt;&lt;p&gt;&lt;br/&gt;TopDocs topDocs = indexSearcher.search(query, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;); &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; totalHits = topDocs.totalHits; &lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;匹配出的记录总数:&quot;&lt;/span&gt; + totalHits);&lt;/p&gt;&lt;p&gt;ScoreDoc[] scoreDocs = topDocs.scoreDocs;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (ScoreDoc scoreDoc : scoreDocs) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; docId = scoreDoc.doc; &lt;br/&gt;Document document = indexSearcher.doc(docId); &lt;/p&gt;&lt;p&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;商品ID：&quot;&lt;/span&gt; + document.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;));&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;商品名称：&quot;&lt;/span&gt; + document.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;));&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;商品价格：&quot;&lt;/span&gt; + document.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;price&quot;&lt;/span&gt;));&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;商品图片地址：&quot;&lt;/span&gt; + document.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pic&quot;&lt;/span&gt;));&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;商品描述：&quot;&lt;/span&gt; + document.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description&quot;&lt;/span&gt;));&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;indexReader.close();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h4field&quot;&gt;&lt;span&gt;&lt;strong&gt;4、Field域&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h41field&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1、Field的属性&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Field是文档中的域，包括&lt;code&gt;Field名&lt;/code&gt;和&lt;code&gt;Field值&lt;/code&gt;两部分，一个文档可以包括多个Field，Document只是Field的一个承载体，Field值即为要索引的内容，也是要搜索的内容。&lt;br/&gt;&lt;strong&gt;是否进行分词(tokenized)&lt;/strong&gt;&lt;br/&gt;　　是：作分词处理，即将Field值进行分词，&lt;code&gt;分词的目的是为了索引&lt;/code&gt;。&lt;br/&gt;　　　　比如：商品名称、商品价格、商品简介等，这些内容用户要输入关键字搜索，由于搜索的内容格式大、内容多需要分词后后作为&lt;code&gt;语汇单元索引&lt;/code&gt;。&lt;br/&gt;　　否：不作分词处理。不分词，不代表不索引，而是将整个内容进行索引。&lt;br/&gt;　　　　比如：商品id、订单号、身份证号等 。&lt;br/&gt;&lt;strong&gt;是否进行索引(indexed)&lt;/strong&gt;&lt;br/&gt;　　是：进行索引。将Field分词后的词或整个Field值进行索引，&lt;code&gt;索引的目的是为了搜索&lt;/code&gt;。&lt;br/&gt;　　　　比如：商品名称、商品价格、商品简介分词后进行索引，&lt;code&gt;商品id、订单号、身份证号不用分词但也要索引&lt;/code&gt;，这些将来整个内容都要作为查询条件。&lt;br/&gt;　　否：不索引。该域的内容无法搜索到。&lt;br/&gt;　　　　比如：文件路径、图片路径等，不用作为查询条件的不用索引。&lt;br/&gt;&lt;strong&gt;是否进行存储(stored)&lt;/strong&gt;&lt;br/&gt;　　是：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取。&lt;code&gt;存储的目的是为了搜索页面显示取值用的&lt;/code&gt;。&lt;br/&gt;　　　　比如：商品名称、商品价格、订单号、商品图片地址，&lt;code&gt;凡是将来要从Document中获取的Field都要存储&lt;/code&gt;。&lt;br/&gt;　　否：不存储Field值，不存储的Field无法通过Document获取。&lt;br/&gt;　　　　比如：商品简介，由于商品描述在搜索页面中不需要显示，且商品描述的内容较大不用存储。如果需要商品描述，则根据搜索出的商品ID去数据库中查询，然后显示出商品描述信息即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h42field&quot;&gt;&lt;span&gt;&lt;strong&gt;4.2、Field的常用类型&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;下边列出了开发中常用的Filed类型，注意Field的属性，根据需求选择：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YuCQ.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h43field&quot;&gt;&lt;span&gt;&lt;strong&gt;4.3、修改入门程序Field的代码&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;详解如下：&lt;/p&gt;
&lt;pre readability=&quot;12&quot;&gt;
&lt;code class=&quot;hljs objectivec&quot; readability=&quot;18&quot;&gt;图书&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;：&lt;br/&gt;是否分词：不分词。&lt;br/&gt;是否索引：要索引，因为需要根据图书&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;进行搜索。&lt;br/&gt;是否存储：要存储，因为查询结果页面需要使用&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;这个值。&lt;p&gt;图书名称：&lt;br/&gt;是否分词：要分词，因为要将图书的名称内容分词索引，根据关键搜索图书名称抽取的词。&lt;br/&gt;是否索引：要索引。&lt;br/&gt;是否存储：要存储。&lt;/p&gt;&lt;p&gt;图书价格：&lt;br/&gt;是否分词：要分词，`lucene对数字型的值只要有搜索需求的都要分词和索引`，因为`lucene对数字型的内容要特殊分词处`理，本例子可能要根据价格范围搜索，需要分词和索引。&lt;br/&gt;是否索引：要索引。&lt;br/&gt;是否存储：要存储。&lt;/p&gt;&lt;p&gt;图书图片地址：&lt;br/&gt;是否分词：不分词。&lt;br/&gt;是否索引：不索引。&lt;br/&gt;是否存储：要存储。&lt;/p&gt;&lt;p&gt;图书描述：&lt;br/&gt;是否分词：要分词。&lt;br/&gt;是否索引：要索引。&lt;br/&gt;是否存储：不存储，因为图书描述内容量大，不在查询结果页面直接显示。&lt;/p&gt;&lt;p&gt;`不存储是用来不在lucene的索引文件中记录`，`节省lucene的索引文件空间`，如果要在详情页面显示描述：&lt;br/&gt;思路：从lucene中取出图书的&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;，根据图书的&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;查询关系数据库中book表得到描述信息。&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2Yt5F.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们需要重新生成索引库，重新执行生成索引库代码，&lt;code&gt;注意：执行之前我们先删除掉原先的索引库&lt;/code&gt;。
&lt;h2 id=&quot;h5&quot;&gt;&lt;span&gt;&lt;strong&gt;5、索引的维护&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h51&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1、需求&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;管理人员通过电商系统更改图书信息，这时更新的是数据库，如果使用lucene搜索图书信息需要在数据库表book信息变化时及时更新lucene索引库。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h52&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2、添加索引&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;调用 indexWriter.addDocument(doc); 添加索引。&lt;br/&gt;参考入门程序的创建索引。&lt;/p&gt;
&lt;h3 id=&quot;h53&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3、删除索引&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;注意：增删改操作，都是需要通过IndexWriter对象来操作的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h531&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3.1、删除指定索引&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  Term是索引域中最小的单位。根据条件删除时，建议根据唯一键来进行删除。在solr中就是根据ID来进行删除和修改操作的。&lt;br/&gt;  根据Term项删除索引，满足条件的将全部删除。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;3&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;deleteIndex&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;File indexFile = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;hljs-string&quot;&gt;&quot;E:\\index\\hm19&quot;&lt;/span&gt;);&lt;br/&gt;Directory directory = FSDirectory.open(indexFile);&lt;br/&gt;IndexWriterConfig cfg = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IndexWriterConfig(Version.LUCENE_4_10_3, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StandardAnalyzer());&lt;br/&gt;IndexWriter indexWriter = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IndexWriter(directory, cfg);&lt;p&gt;&lt;br/&gt;indexWriter.deleteDocuments(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Term(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;1&quot;&lt;/span&gt;));&lt;/p&gt;&lt;p&gt;&lt;br/&gt;indexWriter.close();&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h532&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3.2、删除全部索引（慎用）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  将索引目录的索引信息全部删除，直接彻底删除，无法恢复。慎用！！！&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;2&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;deleteAllIndex&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;File indexFile = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;hljs-string&quot;&gt;&quot;E:\\index\\hm19&quot;&lt;/span&gt;);&lt;br/&gt;Directory directory = FSDirectory.open(indexFile);&lt;br/&gt;IndexWriterConfig cfg = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IndexWriterConfig(Version.LUCENE_4_10_3, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StandardAnalyzer());&lt;br/&gt;IndexWriter indexWriter = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IndexWriter(directory, cfg);&lt;p&gt;&lt;br/&gt;indexWriter.deleteAll();;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;indexWriter.close();&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  建议参照关系数据库基于主键删除方式，所以在创建索引时需要创建一个主键Field，删除时根据此主键Field删除。&lt;br/&gt;  索引删除后将放在Lucene的回收站中，Lucene3.X版本可以恢复删除的文档，3.X之后无法恢复。&lt;/p&gt;
&lt;h3 id=&quot;h54&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4、修改索引&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  更新索引是根据查询条件，可以查询出结果，则将以前的删掉，然后覆盖新的Document对象，如果没有查询出结果，则新增一个Document&lt;br/&gt;  修改流程即：先查询，再删除，再添加。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;hljs java&quot; readability=&quot;9&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;updateIndex&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;File indexFile = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;hljs-string&quot;&gt;&quot;E:\\index\\hm19&quot;&lt;/span&gt;);&lt;br/&gt;Directory directory = FSDirectory.open(indexFile);&lt;br/&gt;IndexWriterConfig cfg = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IndexWriterConfig(Version.LUCENE_4_10_3, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StandardAnalyzer());&lt;br/&gt;IndexWriter indexWriter = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IndexWriter(directory, cfg);&lt;p&gt;&lt;br/&gt;Document document = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Document();&lt;br/&gt;Field name = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TextField(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;黑泽&quot;&lt;/span&gt;, Store.YES); &lt;br/&gt;document.add(name);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;indexWriter.updateDocument(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Term(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;晓艺&quot;&lt;/span&gt;), document);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;indexWriter.close();&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h6&quot;&gt;&lt;span&gt;&lt;strong&gt;6、搜索&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h61&quot;&gt;&lt;span&gt;&lt;strong&gt;6.1、创建查询对象的两种方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法。类似关系数据库Sql语法一样，Lucene也有自己的查询语法，比如：&quot;name:lucene&quot; 表示查询Field域的name值为&quot;lucene&quot;的文档信息。&lt;/p&gt;
&lt;p&gt;可通过两种方法创建查询对象：&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;hljs coffeescript&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;）使用Lucene提供的Query子类，不能输入lucene的查询语法，不需要指定分词器&lt;br/&gt;Query是一个抽象类，lucene提供了很多查询对象，比如：TermQuery精确词项查询、NumericRangeQuery数字范围查询、BooleanQuery布尔查询(实现组合查询)等。&lt;br/&gt;如下代码：&lt;br/&gt;Query query = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TermQuery(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Term(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;lucene&quot;&lt;/span&gt;));&lt;p&gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;）使用QueryParse解析查询表达式（常用）、MultiFieldQueryParser多域查询，可以输入lucene的查询语法、需要指定分词器&lt;br/&gt;QueryParser会将用户输入的查询表达式解析成Query对象实例。&lt;br/&gt;如下代码：&lt;br/&gt;QueryParser queryParser = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; QueryParser(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IKAnalyzer());&lt;br/&gt;Query query = queryParser.parse(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name:lucene&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h62query&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2、通过Query的子类创建查询对象&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h621termquery&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.1、TermQuery&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;TermQuery项查询，TermQuery不需要使用分析器，搜索关键词作为整体来匹配Field域中的词进行查询，比如：订单号、分类ID号等。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;15.5&quot;&gt;
&lt;code class=&quot;hljs cs&quot; readability=&quot;25&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;IndexSearch&lt;/span&gt; {&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;doSearch&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;Query query&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;IndexReader indexReader = &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;; &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;File indexFile = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;hljs-string&quot;&gt;&quot;E:\\index\\hm19\\&quot;&lt;/span&gt;);&lt;br/&gt;Directory directory = FSDirectory.open(indexFile);&lt;br/&gt;indexReader = DirectoryReader.open(directory);&lt;br/&gt;IndexSearcher indexSearcher = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; IndexSearcher(indexReader );&lt;/p&gt;&lt;p&gt;&lt;br/&gt;TopDocs topDocs = indexSearcher.search(query, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;); &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; totalHits = topDocs.totalHits; &lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;匹配出的记录总数:&quot;&lt;/span&gt; + totalHits);&lt;/p&gt;&lt;p&gt;ScoreDoc[] scoreDocs = topDocs.scoreDocs;&lt;br/&gt;Document document; &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (ScoreDoc scoreDoc : scoreDocs) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; docId = scoreDoc.doc; &lt;br/&gt;document = indexSearcher.doc(docId); &lt;/p&gt;&lt;p&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;商品ID：&quot;&lt;/span&gt; + document.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;id&quot;&lt;/span&gt;));&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;商品名称：&quot;&lt;/span&gt; + document.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;));&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;商品价格：&quot;&lt;/span&gt; + document.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;price&quot;&lt;/span&gt;));&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;商品图片地址：&quot;&lt;/span&gt; + document.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;pic&quot;&lt;/span&gt;));&lt;br/&gt;System.&lt;span class=&quot;hljs-keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;商品描述：&quot;&lt;/span&gt; + document.&lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description&quot;&lt;/span&gt;));&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (indexReader != &lt;span class=&quot;hljs-literal&quot;&gt;null&lt;/span&gt;) { &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; { &lt;br/&gt;indexReader.close();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;@&lt;span class=&quot;hljs-function&quot;&gt;Test&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;searchIndex&lt;/span&gt;() throws Exception &lt;/span&gt;{&lt;br/&gt;Analyzer analyzer = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StandardAnalyzer();&lt;br/&gt;QueryParser queryParser = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; QueryParser(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description&quot;&lt;/span&gt;, analyzer); &lt;br/&gt;Query query = queryParser.parse(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description:java AND spring&quot;&lt;/span&gt;); &lt;/p&gt;&lt;p&gt;&lt;br/&gt;doSearch(query);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;@&lt;span class=&quot;hljs-function&quot;&gt;Test&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testTermQuery&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;Query query = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TermQuery(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Term(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;java&quot;&lt;/span&gt;));&lt;br/&gt;doSearch(query);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出结果如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YK3j.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;通过Luck测试的结果如下：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YMgs.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;二者得到的结果一样！
&lt;h4 id=&quot;h622numericrangequery&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.2、NumericRangeQuery&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;NumericRangeQuery，指定数字范围查询。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;    &lt;br/&gt;@&lt;span class=&quot;hljs-function&quot;&gt;Test&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testNumericRangeQuery&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Query query = NumericRangeQuery.newFloatRange(&lt;span class=&quot;hljs-string&quot;&gt;&quot;price&quot;&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;50f&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;70f&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;);&lt;br/&gt;doSearch(query);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h623booleanquery&quot;&gt;&lt;span&gt;&lt;strong&gt;6.2.3、BooleanQuery&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;BooleanQuery，布尔查询，实现组合条件查询。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs php&quot; readability=&quot;4&quot;&gt;    &lt;br/&gt;@Test&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; void testBooleanQuery() {&lt;br/&gt;BooleanQuery query = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; BooleanQuery();&lt;br/&gt;Query query1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TermQuery(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Term(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;java&quot;&lt;/span&gt;));&lt;br/&gt;Query query2 = NumericRangeQuery.newFloatRange(&lt;span class=&quot;hljs-string&quot;&gt;&quot;price&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;f, &lt;span class=&quot;hljs-number&quot;&gt;70&lt;/span&gt;f, &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);&lt;p&gt;&lt;br/&gt;query.add(query1, Occur.MUST);&lt;br/&gt;query.add(query2, Occur.SHOULD);&lt;br/&gt;System.out.println(query);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;doSearch(query);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组合关系代表的意思如下:&lt;br/&gt;  1、MUST和MUST 表示“与”的关系，即“交集”。&lt;br/&gt;  2、MUST和MUST_NOT 前者包含后者不包含。&lt;br/&gt;  3、MUST_NOT和MUST_NOT 没意义。&lt;br/&gt;  4、SHOULD和MUST 表示MUST，SHOULD失去意义。&lt;br/&gt;  5、SHOUlD和MUST_NOT 相当于MUST与MUST_NOT。&lt;br/&gt;  6、SHOULD和SHOULD 表示“或”的关系，即“并集”。&lt;/p&gt;
&lt;h3 id=&quot;h63queryparser&quot;&gt;&lt;span&gt;&lt;strong&gt;6.3、通过QueryParser创建查询对象&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h631queryparser&quot;&gt;&lt;span&gt;&lt;strong&gt;6.3.1、QueryParser&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;通过QueryParser也可以创建Query，QueryParser提供一个Parse()方法，此方法可以直接根据查询语法来查询。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Query对象执行的查询语法可以通过 System.out.println(query); 来查看。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;通过QueryParser来创建query对象，需要指定分词器，&lt;code&gt;注意：搜索索引时使用的分词器要和创建索引时使用的分词器一致&lt;/code&gt;。还可以输入查询语句。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考我们入门程序代码即可。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;searchIndex&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;Analyzer analyzer = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StandardAnalyzer();&lt;br/&gt;QueryParser queryParser = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; QueryParser(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description&quot;&lt;/span&gt;, analyzer); &lt;br/&gt;Query query = queryParser.parse(&lt;span class=&quot;hljs-string&quot;&gt;&quot;description:java AND spring&quot;&lt;/span&gt;); &lt;p&gt;&lt;br/&gt;doSearch(query);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h632multifieldqueryparser&quot;&gt;&lt;span&gt;&lt;strong&gt;6.3.2、MultiFieldQueryParser&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;通过MuliFieldQueryParse对多个域查询。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testMultiFieldQueryParser&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;String[] fields = {&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;description&quot;&lt;/span&gt;}; &lt;br/&gt;Analyzer analyzer = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StandardAnalyzer();&lt;br/&gt;QueryParser queryParser = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MultiFieldQueryParser(fields, analyzer);&lt;br/&gt;Query query = queryParser.parse(&lt;span class=&quot;hljs-string&quot;&gt;&quot;java&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(query);&lt;p&gt;&lt;br/&gt;doSearch(query);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h633&quot;&gt;&lt;span&gt;&lt;strong&gt;6.3.3、查询语法&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;详解如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;1、基础的查询语法，关键词查询：&lt;br/&gt;域名+&quot;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:&quot;+&lt;/span&gt;搜索的关键字&lt;br/&gt;例如：&lt;span class=&quot;hljs-selector-tag&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:java&lt;/span&gt;&lt;br/&gt;2、范围查询&lt;br/&gt;域名+&quot;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:&quot;+&lt;/span&gt;&lt;span class=&quot;hljs-selector-attr&quot;&gt;[最小值 TO 最大值]&lt;/span&gt;&lt;br/&gt;例如：&lt;span class=&quot;hljs-selector-tag&quot;&gt;price&lt;/span&gt;:&lt;span class=&quot;hljs-selector-attr&quot;&gt;[1 TO 1000]&lt;/span&gt;&lt;br/&gt;`注意`：&lt;span class=&quot;hljs-selector-tag&quot;&gt;QueryParser&lt;/span&gt;不支持对数字范围的搜索，它支持字符串范围。&lt;br/&gt;数字范围搜索建议使用&lt;span class=&quot;hljs-selector-tag&quot;&gt;NumericRangeQuery&lt;/span&gt;。&lt;br/&gt;3、组合条件查询&lt;br/&gt;第一种写法：&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Occur&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.MUST&lt;/span&gt;          查询条件必须满足，相当于&lt;span class=&quot;hljs-selector-tag&quot;&gt;and&lt;/span&gt;         +（加号）&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Occur&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.SHOULD&lt;/span&gt;        查询条件可选，相当于&lt;span class=&quot;hljs-selector-tag&quot;&gt;or&lt;/span&gt;              空（不用符号）&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;Occur&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.MUST_NOT&lt;/span&gt;      查询条件不能满足，相当于&lt;span class=&quot;hljs-selector-tag&quot;&gt;not&lt;/span&gt;非       &lt;span class=&quot;hljs-selector-tag&quot;&gt;-&lt;/span&gt;（减号）&lt;br/&gt;1）+条件1 +条件2：两个条件之间是并且的关系&lt;span class=&quot;hljs-selector-tag&quot;&gt;and&lt;/span&gt;&lt;br/&gt;例如：+&lt;span class=&quot;hljs-selector-tag&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:java&lt;/span&gt; +&lt;span class=&quot;hljs-selector-tag&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:java&lt;/span&gt;&lt;br/&gt;2）+条件1 条件2：必须满足第一个条件，忽略第二个条件&lt;br/&gt;例如：+&lt;span class=&quot;hljs-selector-tag&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:java&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:java&lt;/span&gt;&lt;br/&gt;3）条件1 条件2：两个条件满足其一即可。&lt;br/&gt;例如：&lt;span class=&quot;hljs-selector-tag&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:java&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:java&lt;/span&gt;&lt;br/&gt;4）&lt;span class=&quot;hljs-selector-tag&quot;&gt;-&lt;/span&gt;条件1 条件2：必须不满足条件1，要满足条件2&lt;br/&gt;例如：&lt;span class=&quot;hljs-selector-tag&quot;&gt;-name&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:java&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:java&lt;/span&gt;&lt;br/&gt;第二种写法：&lt;br/&gt;条件1 &lt;span class=&quot;hljs-selector-tag&quot;&gt;AND&lt;/span&gt; 条件2&lt;br/&gt;条件1 &lt;span class=&quot;hljs-selector-tag&quot;&gt;OR&lt;/span&gt; 条件2&lt;br/&gt;条件1 &lt;span class=&quot;hljs-selector-tag&quot;&gt;NOT&lt;/span&gt; 条件2&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h64topdocs&quot;&gt;&lt;span&gt;&lt;strong&gt;6.4、TopDocs&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Lucene搜索结果可通过TopDocs遍历，TopDocs类提供了少量的属性，如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2Y1uq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br/&gt;  Search方法需要指定匹配记录数量n：indexSearcher.search(query, n);&lt;br/&gt;  topDocs.totalHits; // 表示匹配索引库中所有记录的数量。&lt;br/&gt;  topDocs.scoreDocs; // 表示匹配相关度高的前边记录数组，scoreDocs的长度小于等于search方法指定的参数n。
&lt;h2 id=&quot;h7&quot;&gt;&lt;span&gt;&lt;strong&gt;7、相关度排序&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h71&quot;&gt;&lt;span&gt;&lt;strong&gt;7.1、什么是相关度排序&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;相关度排序是查询结果按照与查询关键字的相关性进行排序&lt;/code&gt;，越相关的越靠前。比如：搜索“java”关键字，与该关键字最相关的文章应该排在前边。Lucene是通过&lt;code&gt;打分&lt;/code&gt;来进行相关度排序的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h72&quot;&gt;&lt;span&gt;&lt;strong&gt;7.2、相关度打分&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;详解如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Lucene对查询关键字和索引文档的相关度进行打分，得分高的就排在前边。如何打分呢？&lt;br/&gt;Lucene是在&lt;code&gt;用户进行检索时实时根据搜索的关键字计算出来的&lt;/code&gt;，分两步：&lt;br/&gt;  &lt;strong&gt;1）计算出词（Term）的权重。&lt;/strong&gt;&lt;br/&gt;  &lt;strong&gt;2）根据词的权重值，计算文档相关度得分。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;什么是词的权重？&lt;/strong&gt;&lt;br/&gt;  通过索引部分的学习，明确索引的最小单位是一个Term(索引词典中的一个词)，搜索也是要从Term中搜索，再根据Term找到文档，&lt;code&gt;Term对文档的重要性称为权重&lt;/code&gt;，影响Term权重有两个因素：&lt;br/&gt;&lt;code&gt;Term Frequency (tf)：&lt;/code&gt;&lt;br/&gt;  &lt;strong&gt;指此Term在同一文档中出现了多少次，即词在同一个文档中出现的频率。tf 越大说明越重要。&lt;/strong&gt;&lt;br/&gt;  词(Term)在文档中出现的次数越多，说明此词(Term)对该文档越重要，比如：“java”这个词，在文档中出现的次数很多，说明该文档主要就是讲java技术的。&lt;br/&gt;&lt;code&gt;Document Frequency (df)：&lt;/code&gt;&lt;br/&gt;  &lt;strong&gt;指有多少文档包含次Term，即词在多个文档中出现的频率。df 越大说明越不重要。&lt;/strong&gt;&lt;br/&gt;  比如：在一篇英语文档中，this出现的次数更多，就说明越重要吗？不是的，有越多的文档包含此词(Term)，说明此词(Term)太普通，不足以区分这些文档，因而重要性越低。&lt;br/&gt;  &lt;strong&gt;以上是自然打分的规则。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h73boost&quot;&gt;&lt;span&gt;&lt;strong&gt;7.3、设置boost值影响相关度排序&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;boost是一个加权值（默认加权值为1.0f），它可以影响权重的计算。&lt;/strong&gt;&lt;br/&gt;  在创建索引时对&lt;code&gt;某个文档&lt;/code&gt;中的field设置加权值高，在搜索时匹配到这个文档就可能排在前边。&lt;br/&gt;  在搜索索引时对&lt;code&gt;某个域&lt;/code&gt;进行加权，在进行组合域查询时，匹配到加权值高的域最后计算的相关度得分就高。&lt;br/&gt;  即：设置加权值可以在创建索引时设置，也可以在查询索引时设置。&lt;br/&gt;设置boost是给域（field）或者Document设置的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h731boost&quot;&gt;&lt;span&gt;&lt;strong&gt;7.3.1、在创建索引时设置boost值&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果希望某些文档更重要，当此文档中包含所要查询的词则应该得分较高，这样相关度排序可以排在前边，可以在创建索引时设定文档中某些域（Field）的boost值来实现，如果不进行设定，则Field Boost默认为1.0f。&lt;strong&gt;一旦设定，除非删除此文档，否则无法改变。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2Y3D0.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h732boost&quot;&gt;&lt;span&gt;&lt;strong&gt;7.3.2、在搜索索引时设置boost值&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在MultiFieldQueryParser创建时设置boost值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YJET.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h8&quot;&gt;&lt;span&gt;&lt;strong&gt;8、中文分词器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h81&quot;&gt;&lt;span&gt;&lt;strong&gt;8.1、什么是中文分词器&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;学过英文的都知道，&lt;code&gt;英文是以单词为单位的&lt;/code&gt;，单词与单词之间以空格或者逗号句号隔开。而&lt;code&gt;中文则以字为单位&lt;/code&gt;，字又组成词，字和词再组成句子。所以对于英文，我们可以简单以空格判断某个字符串是否为一个单词，比如：I love China，love和China很容易被程序区分开来；但中文“我爱中国”就不一样了，电脑不知道“中国”是一个词语还是“爱中”是一个词语。把&lt;code&gt;中文的句子切分成有意义的词，就是中文分词&lt;/code&gt;，也称&lt;code&gt;切词&lt;/code&gt;。我爱中国，分词的结果是：我 爱 中国。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h82lucene&quot;&gt;&lt;span&gt;&lt;strong&gt;8.2、Lucene自带的中文分词器&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;StandardAnalyzer：&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;单字分词&lt;/code&gt;：就是按照中文一个字一个字地进行分词。&lt;br/&gt;比如：“我爱中国”&lt;br/&gt;效果：“我”、“爱”、“中”、“国”&lt;br/&gt;&lt;strong&gt;CJKAnalyzer&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;二分法分词&lt;/code&gt;：按两个字进行切分。&lt;br/&gt;比如：“我是中国人”&lt;br/&gt;效果：“我是”、“是中”、“中国”、“国人”&lt;br/&gt;上边两个分词器无法满足需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h83&quot;&gt;&lt;span&gt;&lt;strong&gt;8.3、第三方中文分词器&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;paoding&lt;/strong&gt;：庖丁解牛最新版在 https://code.google.com/p/paoding/ 中最多支持Lucene 3.0，且最新提交的代码在 2008-06-03，在svn中最新也是2010年提交，已经过时，不予考虑。&lt;br/&gt;&lt;strong&gt;mmseg4j&lt;/strong&gt;：最新版已从 https://code.google.com/p/mmseg4j/ 移至 https://github.com/chenlb/mmseg4j-solr，支持Lucene 4.10，且在github中最新提交代码是2014年6月，从09年～14年一共有：18个版本，也就是一年几乎有3个大小版本，有较大的活跃度，用了&lt;code&gt;mmseg算法&lt;/code&gt;。&lt;br/&gt;&lt;strong&gt;IK-analyzer&lt;/strong&gt;：最新版在https://code.google.com/p/ik-analyzer/上，支持Lucene 4.10，从2006年12月推出1.0版开始，IKAnalyzer已经推出了4个大版本。最初，它是以开源项目Luence为应用主体的，&lt;code&gt;结合词典分词&lt;/code&gt;和&lt;code&gt;文法分析算法&lt;/code&gt;的中文分词组件。从3.0版本开始，IK发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。在2012版本中，IK实现了简单的&lt;code&gt;分词歧义排除算法&lt;/code&gt;，标志着IK分词器从单纯的词典分词向模拟语义分词衍化。 但是也就是2012年12月后没有在更新。&lt;br/&gt;&lt;strong&gt;ansj_seg&lt;/strong&gt;：最新版本在 https://github.com/NLPchina/ansj_seg tags/，仅有1.1版本，从2012年到2014年更新了大小6次，但是作者本人在2014年10月10日说明：“可能我以后没有精力来维护ansj_seg了”，现在由”nlp_china”管理。2014年11月有更新。并未说明是否支持Lucene，是一个由CRF（条件随机场）算法所做的分词算法。&lt;br/&gt;&lt;strong&gt;imdict-chinese-analyzer&lt;/strong&gt;：最新版在 https://code.google.com/p/imdict-chinese-analyzer/，最新更新也在2009年5月，下载源码，不支持Lucene 4.10 。是利用&lt;code&gt;HMM（隐马尔科夫链）算法&lt;/code&gt;。&lt;br/&gt;&lt;strong&gt;cseg&lt;/strong&gt;：最新版本在git.oschina.net/lionsoul/jcseg，支持Lucene 4.10，作者有较高的活跃度。利用&lt;code&gt;mmseg算法&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h84ikanalyzer&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4、使用中文分词器IKAnalyzer&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;IKAnalyzer继承Lucene的Analyzer抽象类，使用IKAnalyzer和Lucene自带的分词器方法一样，将Analyzer测试代码改为IKAnalyzer测试中文分词效果。&lt;br/&gt;如果使用中文分词器ik-analyzer，就在&lt;code&gt;创建索引&lt;/code&gt;和&lt;code&gt;搜索程序&lt;/code&gt;中使用&lt;code&gt;一致的分词器ik-analyzer&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;h841jar&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.1、添加jar包至项目中&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2Y8bV.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h842&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.2、修改分词器代码&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;修改创建索引时的分词器代码：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2Yd29.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;修改搜索索引时的分词器代码：
&lt;h3 id=&quot;h85&quot;&gt;&lt;span&gt;&lt;strong&gt;8.5、扩展中文词库&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;将以下文件拷贝到config目录下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YYUU.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;从ikanalyzer包中拷贝配置文件到classpath下。
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs xml&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&amp;gt;&lt;/span&gt;  &lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;properties&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;comment&lt;/span&gt;&amp;gt;&lt;/span&gt;IK Analyzer 扩展配置&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;comment&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;key&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;ext_dict&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;dicdata/mydict.dic&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;entry&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;entry&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;key&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;ext_stopwords&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;dicdata/ext_stopword.dic&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;entry&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;properties&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想配置扩展词和停用词，就创建扩展词的文件和停用词的文件，&lt;strong&gt;文件的编码要是utf-8&lt;/strong&gt;。&lt;br/&gt;&lt;code&gt;注意：不要用记事本保存扩展词文件和停用词文件，那样的话，格式中是含有bom的。&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;h86luke&quot;&gt;&lt;span&gt;&lt;strong&gt;8.6、使用luke测试中文分词效果&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;第一步：将ikanalyzer的jar包，拷贝到luke工具的目录&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2Ya8J.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;第二步：使用命令行方式打开luke工具&lt;br/&gt;运行lukeall，如果需要加载第三方分词器，需通过-Djava.ext.dirs加载jar包，&lt;br/&gt;可简单的将第三方分词器和lukeall放在一块儿，cmd下运行：&lt;br/&gt;命令：java -Djava.ext.dirs=. -jar lukeall-4.10.3.jar&lt;br/&gt;之后指定第三方分词器的类路径&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax1x.com/2018/10/29/i2YUC4.png&quot; alt=&quot;&quot;/&gt;</description>
<pubDate>Mon, 29 Oct 2018 12:55:00 +0000</pubDate>
<dc:creator>黑泽明军</dc:creator>
<og:description>课程计划： 1、Lucene介绍 a) 什么是lucene b) 全文检索的应用场景 c) 全文检索定义 2、Luence实现全文检索的流程（重点） 3、Lucene入门程序 4、Field域（重点）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/9873209.html</dc:identifier>
</item>
</channel>
</rss>