<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何将现有 git 仓库中的子项目单独抽出来作为一个独立仓库并保留其提交历史 - 猴子猿</title>
<link>http://www.cnblogs.com/giggle/p/9578927.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/giggle/p/9578927.html</guid>
<description>&lt;p&gt;很多时候，我们会遇到在一个git仓库下包含了很多小项目，但是随着有些项目的需求逐渐增大或则市场需求，我们需要将其抽离出来，作为一个单独的项目进行维护并开发。&lt;/p&gt;
&lt;p&gt;但是，如果直接拷贝文件粘贴到新建的git repository中，会丢掉原有的commit，所以我们不能这么粗暴地做。&lt;/p&gt;
&lt;p&gt;怎么办呢？下面会根据一个例子，详细说明。&lt;/p&gt;
&lt;p&gt;假如我们在demos仓库中，包含了如下小项目，其中，我们想将Comet这个目录下的文件单独抽出来，作为一个单独的项目维护开发，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/887360/201809/887360-20180903152034632-1112601857.png&quot; alt=&quot;&quot; width=&quot;353&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，我们通过git clone 将demos导入到本地，然后通过git remote rm origin，切断与远程仓库的关联，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/887360/201809/887360-20180903153110792-1968187899.png&quot; alt=&quot;&quot; width=&quot;221&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，运行git filter-branch --tag-name-filter cat --prune-empty --subdirectory-filter &amp;lt;name-of-folder&amp;gt;命令，过滤掉并保留对指定子目录的commit，并将该子目录设为该仓库的根目录：&lt;/p&gt;
&lt;p&gt;1. --tag-name-filter：控制我们如何处理旧tag，cat表示原样输出&lt;/p&gt;
&lt;p&gt;2. --prune-empty：删除空提交，即对子目录没有影响的&lt;/p&gt;
&lt;p&gt;3. --subdirectory-filter：指定子目录路径&lt;/p&gt;
&lt;p&gt;运行该命令后，我们可以看见我们的原仓库变为了这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/887360/201809/887360-20180903153225040-1016710103.png&quot; alt=&quot;&quot; width=&quot;250&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然从表面上看，我们到达了我们的目的，新仓库已变成了子目录的内容，并且也保留了相关commit，但是新仓库的.git目录并没有被reset，所以我们还需运行如下命令，去为.git瘦身，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/887360/201809/887360-20180903153805420-1228385519.png&quot; alt=&quot;&quot; width=&quot;263&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，到目前为止，子项目提取工作完成。&lt;/p&gt;
&lt;p&gt;最后，就是将本地的这个子项目push到远程仓库中了。因为在此之前，我们已经断了原有的远程仓库链接，所以此时我们需要将这个子项目链接到新的远程仓库中。&lt;/p&gt;
&lt;p&gt;假设，我们新建一个远程仓库名为testRepo，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/887360/201809/887360-20180903154402209-624533192.png&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照提示，我们通过git remote add命令，将子项目与该远程仓库链接并push，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/887360/201809/887360-20180903154729444-543655492.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就完成了我们的目的，下面是远程仓库testRepo结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/887360/201809/887360-20180903154850491-932884959.png&quot; alt=&quot;&quot; width=&quot;386&quot; height=&quot;189&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 03 Sep 2018 07:53:00 +0000</pubDate>
<dc:creator>猴子猿</dc:creator>
<og:description>如何将现有 git 仓库中的子项目单独抽出来作为一个独立仓库并保留其提交历史</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/giggle/p/9578927.html</dc:identifier>
</item>
<item>
<title>react学习（6）——关于组件生命周期的问题 - 朝曦Z</title>
<link>http://www.cnblogs.com/chaoxiZ/p/9578878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaoxiZ/p/9578878.html</guid>
<description>&lt;p&gt;在项目开发的过程中，遇到了一个问题：&lt;/p&gt;
&lt;p&gt;父组件请求后台数据，收到后将数据以props传给子组件，子组件根据收到数据的不同，显示不同的内容，同时，子组件自身可以根据click操作改变根据父组件的数据显示的内容。&lt;/p&gt;
&lt;p&gt;因此，子组件收到父组件的props传值后，由于props值不能修改，因此子组件需要将该props值放入state，子组件根据自身click操作改变state，进而改变组件显示的内容。&lt;/p&gt;
&lt;p&gt;而父组件传过来的值，子组件在componentDidMount中无法获取，可以在render中获取。但是若将获取值的部分写在render中，会导致页面每次更新都从父组件拿值，子组件的click操作修改值无法起作用。&lt;/p&gt;
&lt;p&gt;子组件代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; child extends PureComponent {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; propTypes =&lt;span&gt; {
        value: PropTypes.&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;.isRequired
    };
    constructor(props) {
        super( props);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
            value: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        };
    }
    changeValue &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
            value: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        });
    }
    render() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
            value: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.value
        };
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div  style={{ display: value ? &lt;span&gt;'&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; }}&amp;gt;
               &amp;lt;img src={src} alt=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;
               &amp;lt;div className={styles.value}&amp;gt;这是父组件的传值：{value}&amp;lt;/div&amp;gt;
               &amp;lt;div className={styles[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;icon-close&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]} onClick={&lt;span&gt;this&lt;/span&gt;.changeValue}&amp;gt;
                   &amp;lt;img src={close} alt=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;
               &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;&lt;span&gt;
        );
    }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Child;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;解决方法1：将click的close方法写在render中&lt;/h2&gt;
&lt;p&gt;但该写法不是很规范，render() 函数应该是纯粹的，也就是说该函数不修改组件state，每次调用都返回相同的结果，不读写 DOM 信息，也不和浏览器交互（例如通过使用 setTimeout）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; child extends PureComponent {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; propTypes =&lt;span&gt; {
        value: PropTypes.&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;.isRequired
    };
    constructor(props) {
        super( props);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
            value: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        };
    }
    render() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
            value: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.value
        };
&lt;strong&gt;&lt;span&gt;        changeValue &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;= () =&amp;gt; {
            this.setState({
                value: false
            });
        }
        &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div  style={{ display: value ? &lt;span&gt;'&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; }}&amp;gt;
               &amp;lt;img src={src} alt=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;
               &amp;lt;div className={styles.value}&amp;gt;这是父组件的传值：{value}&amp;lt;/div&amp;gt;
               &amp;lt;div className={styles[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;icon-close&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]} onClick={changeValue}&amp;gt;
                   &amp;lt;img src={close} alt=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;
               &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;&lt;span&gt;
        );
    }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Child;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;解决方法2：使用componentWillReceiveProps&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; child extends PureComponent {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; propTypes =&lt;span&gt; {
        value: PropTypes.&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;.isRequired
    };
    constructor(props) {
        super( props);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
            value: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        };
    }
&lt;strong&gt;&lt;span&gt;    componentWillReceiveProps(nextProps) {
        &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;this&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;.setState({
            value: nextProps.value
        });
    }
&lt;/span&gt;&lt;/strong&gt;    changeValue &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
            value: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        });
    }
    render() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
            &lt;/span&gt;&amp;lt;div  style={{ display: value ? &lt;span&gt;'&lt;/span&gt;&lt;span&gt;block&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; }}&amp;gt;
               &amp;lt;img src={src} alt=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;
               &amp;lt;div className={styles.value}&amp;gt;这是父组件的传值：{value}&amp;lt;/div&amp;gt;
               &amp;lt;div className={styles[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;icon-close&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]} onClick={&lt;span&gt;this&lt;/span&gt;.changeValue}&amp;gt;
                   &amp;lt;img src={close} alt=&lt;span&gt;&quot;&quot;&lt;/span&gt; /&amp;gt;
               &amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;&lt;span&gt;
        );
    }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Child;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;react组件的生命周期&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;componentWillMount&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;componentDidMount&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;componentWillReceiveProps&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;shouldComponentUpdate&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;componentWillUpdate&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;componentDidUpdate&lt;/strong&gt; &lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;componentWillUnmount&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;strong&gt;componentWillMount&lt;/strong&gt; 组件将要挂载&lt;/h3&gt;
&lt;p&gt;组件刚经历constructor,初始完数据&lt;/p&gt;
&lt;p&gt;在初始化渲染执行之前立刻调用，服务器端和客户端都只调用一次&lt;/p&gt;
&lt;p&gt;组件还未进入render，组件还未渲染完成，dom还未渲染&lt;/p&gt;
&lt;p&gt;如果在这个方法内调用setState，render() 将会感知到更新后的state，将会执行仅一次，尽管 state 改变了。&lt;/p&gt;
&lt;h3&gt; 2. componentDidMount 组件渲染完成&lt;/h3&gt;
&lt;p&gt;在初始化渲染执行之后立刻调用一次，仅客户端有效（服务器端不会调用）&lt;/p&gt;
&lt;p&gt;此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染&lt;/p&gt;
&lt;p&gt;在生命周期中的这个时间点，组件拥有一个DOM 展现，你可以通过 this.getDOMNode() 来获取相应 DOM 节点&lt;/p&gt;
&lt;p&gt;可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI)&lt;/p&gt;
&lt;h3&gt;3.componentWillReceiveProps (nextProps)&lt;/h3&gt;
&lt;p&gt;在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;在接受父组件改变后的props需要重新渲染组件时用到的比较多&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;用此函数可以作为react 在 prop 传入之后， render() 渲染之前更新 state 的机会。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;21.5&quot;&gt;
&lt;div readability=&quot;24.5&quot;&gt;
&lt;p&gt;在该函数中调用 this.setState() 将不会引起第二次渲染。&lt;/p&gt;
&lt;blockquote readability=&quot;8.5&quot;&gt;
&lt;p&gt;通过对比nextProps和this.props，将nextProps setState为当前组件的state，从而重新渲染组件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentWillReceiveProps (nextProps) {
    nextProps.openNotice &lt;/span&gt;!== &lt;span&gt;this&lt;/span&gt;.props.openNotice &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
        openNotice:nextProps.openNotice
    }，() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state.openNotice:nextProps) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将state更新为nextProps,在setState的第二个参数（回调）可以打印出新的state&lt;/span&gt;
&lt;span&gt;  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h3&gt;4. shouldComponentUpdate(nextProps,nextState)&lt;/h3&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;唯一用于控制组件重新渲染的生命周期&lt;/p&gt;
&lt;p&gt;由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程（暂时这么理解，其实setState以后有些情况并不会重新渲染，比如数组引用不变）。react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断。在这里return false可以阻止组件的更新&lt;/p&gt;
&lt;p&gt;如果 shouldComponentUpdate 返回false，则 render() 将不会执行，直到下一次 state 改变。（另外，componentWillUpdate 和 componentDidUpdate 也不会被调用。）&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;在接收到新的props 或者 state，将要渲染之前调用。该方法在初始化渲染的时候不会调用，在使用 forceUpdate 方法的时候也不会。&lt;/p&gt;
&lt;p&gt;默认情况下，shouldComponentUpdate 总会返回true，在 state 改变的时候避免细微的bug，但是如果总是小心地把 state 当做不可变的，在 render() 中只从 props 和state 读取值，此时你可以覆盖 shouldComponentUpdate 方法，实现新老 props 和state 的比对逻辑。&lt;/p&gt;
&lt;p&gt;如果性能是个瓶颈，尤其是有几十个甚至上百个组件的时候，使用 shouldComponentUpdate可以提升应用的性能。&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;5. componentWillUpdate (nextProps,nextState)&lt;/h3&gt;
&lt;p&gt;在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。&lt;/p&gt;
&lt;p&gt;shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState&lt;/p&gt;
&lt;p&gt;你不能在该方法中使用this.setState()。如果需要更新state来响应某个prop的改变，可使用componentWillReceiveProps。&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;6. componentDidUpdate(prevProps,prevState)&lt;/h3&gt;
&lt;p&gt;在组件完成更新后立即调用。在初始化时不会被调用。&lt;/p&gt;
&lt;p&gt;组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期&lt;/p&gt;
&lt;p&gt;在组件的更新已经同步到DOM 中之后立刻被调用。&lt;/p&gt;
&lt;p&gt;这里可以拿到prevProps和prevState，即更新前的props和state。&lt;/p&gt;
&lt;p&gt;使用该方法可以在组件更新之后操作DOM 元素。&lt;/p&gt;
&lt;p&gt;为了兼容 v0.9，DOM节点会作为最后一个参数传入。如果使用这个方法，你仍然可以使用 this.getDOMNode() 来访问 DOM 节点。&lt;/p&gt;
&lt;h3&gt;7.componentWillUnmount()&lt;/h3&gt;
&lt;p&gt;在组件从DOM 中移除的时候立刻被调用。&lt;/p&gt;
&lt;p&gt;在该方法中执行任何必要的清理，比如无效的定时器，或者清除在 componentDidMount 中创建的 DOM 元素，移除所有组建中的监听 removeEventListener&lt;/p&gt;
&lt;h2&gt;除此之外，&lt;/h2&gt;
&lt;h3&gt;8.constructor&lt;/h3&gt;
&lt;p&gt;constructor参数接受两个参数props,context，可以获取到父组件传下来的的props,context,&lt;/p&gt;
&lt;p&gt;如果你想在constructor构造函数内部使用props或context,则需要传入，并传入super对象。&lt;/p&gt;
&lt;p&gt;只要组件存在constructor,就必要要写super,否则this指向会错误&lt;/p&gt;
&lt;div readability=&quot;12.660869565217&quot;&gt;
&lt;h3&gt;9. render函数&lt;/h3&gt;
&lt;div readability=&quot;25.455195424214&quot;&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，&lt;/p&gt;
&lt;p&gt;在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染&lt;/p&gt;
&lt;p&gt;react16中 render函数允许返回一个数组，单个字符串等，不在只限制为一个顶级DOM节点，可以减少很多不必要的div&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;组件生命周期的执行顺序：&lt;/h2&gt;
&lt;p&gt;在react的组件挂载及render过程中，最底层的子组件是最先完成挂载及更新的。&lt;/p&gt;
&lt;p&gt;constructor()构造函数、componentWillMount执行顺序：顶层父组件 -&amp;gt;子组件 -&amp;gt;子组件 -&amp;gt;底层子组件&lt;/p&gt;
&lt;p&gt;render、componentDidMount顺序：底层子组件 -&amp;gt;子组件 -&amp;gt;子组件 -&amp;gt;顶层父组件&lt;/p&gt;
&lt;p&gt;以下是&lt;a href=&quot;http://www.runoob.com/&quot; target=&quot;_blank&quot;&gt;http://www.runoob.com&lt;/a&gt;菜鸟教程上面的一个实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Button extends React.Component {
  constructor(props) {
      super(props);
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state = {data: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setNewNumber = &lt;span&gt;this&lt;/span&gt;.setNewNumber.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }
  
  setNewNumber() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setState({data: &lt;span&gt;this&lt;/span&gt;.state.data + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;})
  }
  render() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
         &lt;/span&gt;&amp;lt;div&amp;gt;
            &amp;lt;button onClick = {&lt;span&gt;this&lt;/span&gt;.setNewNumber}&amp;gt;INCREMENT&amp;lt;/button&amp;gt;
            &amp;lt;Content myNumber = {&lt;span&gt;this&lt;/span&gt;.state.data}&amp;gt;&amp;lt;/Content&amp;gt;
         &amp;lt;/div&amp;gt;&lt;span&gt;
      );
    }
}
 
 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Content extends React.Component {
  componentWillMount() {
      console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Component WILL MOUNT!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  }
  componentDidMount() {
       console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Component DID MOUNT!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  }
  componentWillReceiveProps(newProps) {
        console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Component WILL RECEIVE PROPS!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  }
  shouldComponentUpdate(newProps, newState) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  }
  componentWillUpdate(nextProps, nextState) {
        console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Component WILL UPDATE!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
  }
  componentDidUpdate(prevProps, prevState) {
        console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Component DID UPDATE!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  }
  componentWillUnmount() {
         console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Component WILL UNMOUNT!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  }
 
    render() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
        &lt;/span&gt;&amp;lt;div&amp;gt;
          &amp;lt;h3&amp;gt;{&lt;span&gt;this&lt;/span&gt;.props.myNumber}&amp;lt;/h3&amp;gt;
        &amp;lt;/div&amp;gt;&lt;span&gt;
      );
    }
}
ReactDOM.render(
   &lt;/span&gt;&amp;lt;div&amp;gt;
      &amp;lt;Button /&amp;gt;
   &amp;lt;/div&amp;gt;&lt;span&gt;,
  document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;example&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;（控制台info）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/788599/201809/788599-20180903154214946-399001100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/788599/201809/788599-20180903154254171-1796128003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://www.jianshu.com/p/c9bc994933d5&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/c9bc994933d5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;          &lt;a href=&quot;https://www.jianshu.com/p/ee122bb5b14b&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/ee122bb5b14b&lt;/a&gt;&lt;/p&gt;
          &lt;a href=&quot;http://www.runoob.com/react/react-component-life-cycle.html&quot; target=&quot;_blank&quot;&gt;http://www.runoob.com/react/react-component-life-cycle.html&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;          &lt;a href=&quot;https://blog.csdn.net/limm33/article/details/50942808&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/limm33/article/details/50942808&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 03 Sep 2018 07:44:00 +0000</pubDate>
<dc:creator>朝曦Z</dc:creator>
<og:description>在项目开发的过程中，遇到了一个问题： 父组件请求后台数据，收到后将数据以props传给子组件，子组件根据收到数据的不同，显示不同的内容，同时，子组件自身可以根据click操作改变根据父组件的数据显示的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaoxiZ/p/9578878.html</dc:identifier>
</item>
<item>
<title>深入理解 JVM(上) - 阿苍老师</title>
<link>http://www.cnblogs.com/nullering/p/9545058.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nullering/p/9545058.html</guid>
<description>&lt;p&gt;菜鸟拙见，望请纠正（首先：推荐一本书【链接：&lt;a href=&quot;https://pan.baidu.com/s/15I062n5LPYtRmueAAUFuFA&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/15I062n5LPYtRmueAAUFuFA&lt;/a&gt; 密码：kyo1】）&lt;/p&gt;
&lt;h2&gt;一：JVM体系概述&lt;/h2&gt;
&lt;p&gt;1：JVM是运行在操作系统之上的，他与硬件没有直接的交互。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180902221118991-2037138907.png&quot; alt=&quot;&quot; width=&quot;403&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;二：JVM内存结构&lt;/h2&gt;
&lt;p&gt;　　Java虚拟机在运行时，会把内存空间分为若干个区域。Java虚拟机所管理的内存区域分为如下部分：方法区、堆内存、虚拟机栈、本地方法栈、程序计数器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180902214304017-949467976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;strong&gt;类装载器ClassLoader&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　负责加载class文件，class文件在文件开头有特定的文件标识，并且ClassLoader只负责class文件的加载，至于它是否可以运行，则是由执行引擎（Execution Engine）决定。&lt;/p&gt;
&lt;p&gt;虚拟机自带的加载器：&lt;/p&gt;
&lt;p&gt;启动类加载器（Bootstrap）：由C++编写，不是前端框架Bootstrap。&lt;/p&gt;
&lt;p&gt;扩展类加载器（Extension）：由Java语言编写&lt;/p&gt;
&lt;p&gt;应用程序类加载器（App）：由Java语言编写，也叫系统类加载器，加载当前应用的classpath的所有类。&lt;/p&gt;
&lt;p&gt;用户自定义加载器&lt;/p&gt;
&lt;p&gt;Java.lang.ClassLoader的之类，用户可以定制的加载方式。&lt;/p&gt;
&lt;p&gt;类加载器的双亲委派机制&lt;/p&gt;
&lt;p&gt;某个特定的类加载器在加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成该加载任务时，才自己去加载。&lt;/p&gt;

&lt;p&gt;沙箱机制（防止恶意代码对java本身的破坏）&lt;/p&gt;
&lt;p&gt;当用户命名了和Java一样的类时，Java会首先加载自带的类。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;2、方法区&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　方法区是线程共享的，通常用来保存装载的类的元结构信息。主要用于存储虚拟机加载的类信息、常量、静态变量，以及编译器编译后的代码等数据。&lt;/p&gt;
&lt;p&gt;　　在jdk1.7及其之前，方法区是堆的一个“逻辑部分”（一片连续的堆空间）。也有人用“永久代”表示方法区。&lt;/p&gt;
&lt;p&gt;　　在jdk1.8中，方法区已经不存在，原方法区中存储的类信息、编译后的代码数据等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180902213912718-1549203411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3：堆内存&lt;/h3&gt;
&lt;p&gt;一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类，方法，穿变量放到堆内存中去，　　&lt;/p&gt;
&lt;p&gt;　　它是JVM管理的内存中最大的一块区域，堆内存和方法区都被所有线程共享，在虚拟机启动时创建。在垃圾收集的层面上来看，由于现在收集器基本上都采用分代收集算法，因此堆还可以分为新生代（YoungGeneration）和老年代（OldGeneration），新生代还可以分为Eden、From Survivor、To Survivor。&lt;/p&gt;
&lt;p&gt;JAVA1.7如下图，但在Java1.8中，其他基本没变，只是将Perm变成了元空间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180903132129526-1439854362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4：程序计数器&lt;/h3&gt;
&lt;p&gt;　　程序计数器是一块非常小的内存空间，可以看做是当前线程执行字节码的行号指示器，每个线程都有一个独立的程序计数器，因此程序计数器是线程私有的一块空间，此外，程序计数器是Java虚拟机规定的唯一不会发生内存溢出的区域。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5：虚拟机&lt;/strong&gt;&lt;strong&gt;栈&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;虚拟机栈也是每个线程私有的一块内存空间，它描述的是方法的内存模型。&lt;/p&gt;
&lt;p&gt;虚拟机会为每个线程分配一个虚拟机栈，每个虚拟机栈中都有若干个栈帧，每个栈帧中存储了局部变量表、操作数栈、动态链接、返回地址等。一个栈帧就对应Java代码中的一个方法，当线程执行到一个方法时，就代表这个方法对应的栈帧已经进入虚拟机栈并且处于栈顶的位置，每一个Java方法从被调用到执行结束，就对应了一个栈帧从入栈到出栈的过程。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;6、本地方法栈&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 虚拟机栈执行的是Java方法，本地方法栈执行的是本地方法（Native Method）,其他基本上一致&lt;/p&gt;
&lt;h3&gt;7：元空间&lt;/h3&gt;
&lt;p&gt;上面说到，jdk1.8中，已经不存在永久代（方法区），替代它的一块空间叫做“元空间”，和永久代类似，都是JVM规范对方法区的实现，但是元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制，但可以通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize来指定元空间的大小。&lt;/p&gt;
&lt;h2&gt;三：垃圾回收机制&lt;/h2&gt;
&lt;p&gt;垃圾回收，就是通过垃圾收集器把内存中没用的对象清理掉。垃圾回收涉及到的内容有：1、判断对象是否已死；2、选择垃圾收集算法；3、选择垃圾收集的时间；4、选择适当的垃圾收集器清理垃圾（已死的对象）。&lt;/p&gt;
&lt;h3&gt;1:判断对象是否以死&lt;/h3&gt;
&lt;p&gt;判断对象是否已死就是找出哪些对象是已经死掉的，以后不会再用到的，就像地上有废纸、饮料瓶和百元大钞，扫地前要先判断出地上废纸和饮料瓶是垃圾，百元大钞不是垃圾。判断对象是否已死有&lt;strong&gt;引用计数算法&lt;/strong&gt;和&lt;strong&gt;可达性分析算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）引用计数算法&lt;/p&gt;
&lt;p&gt;给每一个对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1；每当有一个地方不再引用它时，计数器值减1，这样只要计数器的值不为0，就说明还有地方引用它，它就不是无用的对象。如下图，对象2有1个引用，它的引用计数器值为1，对象1有两个地方引用，它的引用计数器值为2 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180903145028945-1490347819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这种方法看起来非常简单，但目前许多主流的虚拟机都没有选用这种算法来管理内存，原因就是当某些对象之间互相引用时，无法判断出这些对象是否已死，如下图，对象1和对象2都没有被堆外的变量引用，而是被对方互相引用，这时他们虽然没有用处了，但是引用计数器的值仍然是1，无法判断他们是死对象，垃圾回收器也就无法回收。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180903145056691-161930275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）可达性分析算法&lt;/p&gt;
&lt;p&gt;了解可达性分析算法之前先了解一个概念——GC Roots，垃圾收集的起点，可以作为GC Roots的有虚拟机栈中本地变量表中引用的对象、方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象。 &lt;br/&gt;当一个对象到GC Roots没有任何引用链相连（GC Roots到这个对象不可达）时，就说明此对象是不可用的，是死对象。如下图：object1、object2、object3、object4和GC Roots之间有可达路径，这些对象不会被回收，但object5、object6、object7到GC Roots之间没有可达路径，这些对象就被判了死刑。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180903145222863-1575319777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）方法区回收&lt;/p&gt;
&lt;p&gt;上面说的都是对堆内存中对象的判断，方法区中主要回收的是废弃的常量和无用的类。 &lt;br/&gt;判断常量是否废弃可以判断是否有地方引用这个常量，如果没有引用则为废弃的常量。 &lt;br/&gt;判断类是否废弃需要同时满足如下条件：&lt;/p&gt;
&lt;div class=&quot;list-paddingleft-2&quot;&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;该类所有的实例已经被回收（堆中不存在任何该类的实例）&lt;/li&gt;
&lt;li&gt;加载该类的ClassLoader已经被回收&lt;/li&gt;
&lt;li&gt;该类对应的java.lang.Class对象在任何地方没有被引用（无法通过反射访问该类的方法）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;2、常用垃圾回收算法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;（1）标记-清除算法：分为标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象，如下图。&lt;/p&gt;
&lt;p&gt;缺点：标记和清除两个过程效率都不高；标记清除之后会产生大量不连续的内存碎片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180903145911860-144286251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）复制算法：把内存分为大小相等的两块，每次存储只用其中一块，当这一块用完了，就把存活的对象全部复制到另一块上，同时把使用过的这块内存空间全部清理掉，往复循环，如下图。&lt;/p&gt;
&lt;p&gt;缺点：实际可使用的内存空间缩小为原来的一半，比较适合。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180903150058108-875744868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）标记-整理算法：先对可用的对象进行标记，然后所有被标记的对象向一段移动，最后清除可用对象边界以外的内存，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180903150134577-1706946049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）分代收集算法：把堆内存分为新生代和老年代，新生代又分为Eden区、From Survivor和To Survivor。一般新生代中的对象基本上都是朝生夕灭的，每次只有少量对象存活，因此采用复制算法，只需要复制那些少量存活的对象就可以完成垃圾收集；老年代中的对象存活率较高，就采用标记-清除和标记-整理算法来进行回收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1174906/201809/1174906-20180903150217196-889202889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3、选择垃圾收集的时间&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当程序运行时，各种数据、对象、线程、内存等都时刻在发生变化，当下达垃圾收集命令后就立刻进行收集吗？肯定不是，他们要在保证线程安全的前提下进行垃圾回收&lt;/p&gt;
&lt;p&gt;　　安全点：从线程角度看，安全点可以理解为是在代码执行过程中的一些特殊位置，当线程执行到安全点的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这里暂停用户线程。当垃圾收集时，如果需要暂停当前的用户线程，但用户线程当时没在安全点上，则应该等待这些线程执行到安全点再暂停。理论上，解释器的每条字节码的边界上都可以放一个安全点，实际上，安全点基本上以“是否具有让程序长时间执行的特征”为标准进行选定。&lt;/p&gt;
&lt;p&gt;　　安全区：安全点是相对于运行中的线程来说的，对于如sleep或blocked等状态的线程，收集器不会等待这些线程被分配CPU时间，这时候只要线程处于安全区中，就可以算是安全的。安全区就是在一段代码片段中，引用关系不会发生变化，可以看作是被扩展、拉长了的安全点。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4、常见垃圾收集器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;新生代收集器：&lt;strong&gt;Serial&lt;/strong&gt;、&lt;strong&gt;ParNew&lt;/strong&gt;、&lt;strong&gt;Parallel Scavenge&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;老年代收集器：&lt;strong&gt;Serial Old&lt;/strong&gt;、&lt;strong&gt;CMS&lt;/strong&gt;、&lt;strong&gt;Parallel Old&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;堆内存垃圾收集器：&lt;strong&gt;G1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 这些垃圾收集器同样很重要，可以自行百度了解其原理。&lt;/p&gt;

</description>
<pubDate>Mon, 03 Sep 2018 07:26:00 +0000</pubDate>
<dc:creator>阿苍老师</dc:creator>
<og:description>菜鸟拙见，望请纠正（首先：推荐一本书【链接：https://pan.baidu.com/s/15I062n5LPYtRmueAAUFuFA 密码：kyo1】） 一：JVM体系概述 1：JVM是运行在操</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nullering/p/9545058.html</dc:identifier>
</item>
<item>
<title>go微服务框架go-micro深度学习(一) 整体架构介绍 - lpxxn</title>
<link>http://www.cnblogs.com/li-peng/p/9558421.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/li-peng/p/9558421.html</guid>
<description>&lt;p&gt;&lt;span&gt;      产品嘴里的一个小项目，从立项到开发上线，随着时间和需求的不断激增，会越来越复杂，变成一个大项目，如果前期项目架构没设计的不好，代码会越来越臃肿，难以维护，后期的每次产品迭代上线都会牵一发而动全身。项目微服务化，松耦合模块间的关系，是一个很好的选择，随然增加了维护成本，但是还是很值得的。 &lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;169&quot;&gt;
&lt;p&gt;     微服务化项目除了稳定性我个人还比较关心的几个问题：&lt;/p&gt;
&lt;p&gt;     一: 服务间数据传输的效率和安全性。&lt;/p&gt;
&lt;p&gt;     二: 服务的动态扩充，也就是服务的注册和发现，服务集群化。&lt;/p&gt;
&lt;p&gt;     三: 微服务功能的可订制化，因为并不是所有的功能都会很符合你的需求，难免需要根据自己的需要二次开发一些功能。&lt;/p&gt;

&lt;p&gt;     go-micro是go语言下的一个很好的rpc微服务框架，功能很完善，而且我关心的几个问题也解决的很好：&lt;/p&gt;
&lt;p&gt;     一：服务间传输格式为protobuf，效率上没的说，非常的快，也很安全。&lt;/p&gt;
&lt;p&gt;     二：go-micro的服务注册和发现是多种多样的。我个人比较喜欢etcdv3的服务服务发现和注册。&lt;/p&gt;
&lt;p&gt;     三：主要的功能都有相应的接口，只要实现相应的接口，就可以根据自己的需要订制插件。&lt;/p&gt;

&lt;p&gt;     业余时间把go-micro的源码系统地读了一遍，越读越感觉这个框架写的好，从中也学到了很多东西。就想整理一系列的帖子，把学习go-micro的心得和大家分享。&lt;/p&gt;
&lt;h3&gt;通信流程&lt;/h3&gt;
&lt;p&gt;     go-micro的通信流程大至如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/342595/201809/342595-20180902111548035-623345718.png&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    Server监听客户端的调用，和Brocker推送过来的信息进行处理。并且Server端需要向Register注册自己的存在或消亡，这样Client才能知道自己的状态。&lt;/p&gt;
&lt;p&gt;    Register服务的注册的发现。&lt;/p&gt;
&lt;p&gt;    Client端从Register中得到Server的信息，然后每次调用都根据算法选择一个的Server进行通信，当然通信是要经过编码/解码，选择传输协议等一系列过程的。&lt;/p&gt;
&lt;p&gt;    如果有需要通知所有的Server端可以使用Brocker进行信息的推送。&lt;/p&gt;
&lt;p&gt;    Brocker 信息队列进行信息的接收和发布。&lt;/p&gt;

&lt;p&gt;     go-micro之所以可以高度订制和他的框架结构是分不开的，go-micro由8个关键的interface组成，每一个interface都可以根据自己的需求重新实现，这8个主要的inteface也构成了go-micro的框架结构。 &lt;/p&gt;
 &lt;img src=&quot;https://images2018.cnblogs.com/blog/342595/201808/342595-20180830100606690-791118590.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/342595/201808/342595-20180830100356516-934773265.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/342595/201808/342595-20180830100719388-634421306.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;    这些接口go-micir都有他自己默认的实现方式，还有一个go-plugins是对这些接口实现的可替换项。你也可以根据需求实现自己的插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/342595/201809/342595-20180901173858400-2107631138.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;305&quot;/&gt; &lt;/p&gt;

&lt;p&gt;   这篇帖子主要是给大家介绍go-micro的主体结构和这些接口的功能，具体细节以后的文章我们再慢慢说：&lt;/p&gt;
&lt;h3&gt;   Transort&lt;/h3&gt;
&lt;p&gt;    服务之间通信的接口。也就是服务发送和接收的最终实现方式，是由这些接口定制的。&lt;/p&gt;
&lt;p&gt;   源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
type Socket &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Recv(&lt;/span&gt;*&lt;span&gt;Message) error
    Send(&lt;/span&gt;*&lt;span&gt;Message) error
    Close() error
}

type Client &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Socket
}

type Listener &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Addr() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Close() error
    Accept(func(Socket)) error
}

type Transport &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Dial(addr &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;, opts ...DialOption) (Client, error)
    Listen(addr &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;, opts ...ListenOption) (Listener, error)
    String() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    Transport 的Listen方法是一般是Server端进行调用的，他监听一个端口，等待客户端调用。&lt;/p&gt;
&lt;p&gt;    Transport 的Dial就是客户端进行连接服务的方法。他返回一个Client接口，这个接口返回一个Client接口，这个Client嵌入了Socket接口，这个接口的方法就是具体发送和接收通信的信息。&lt;/p&gt;
&lt;p&gt;    http传输是go-micro默认的同步通信机制。当然还有很多其他的插件：grpc,nats,tcp,udp,rabbitmq,nats，都是目前已经实现了的方式。在go-plugins里你都可以找到。&lt;/p&gt;
&lt;h3&gt;Codec&lt;/h3&gt;
&lt;p&gt;     有了传输方式，下面要解决的就是传输编码和解码问题，go-micro有很多种编码解码方式，默认的实现方式是protobuf,当然也有其他的实现方式，json、protobuf、jsonrpc、mercury等等。&lt;/p&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
type Codec &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    ReadHeader(&lt;/span&gt;*&lt;span&gt;Message, MessageType) error
    ReadBody(&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}) error
    Write(&lt;/span&gt;*Message, &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}) error
    Close() error
    String() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
}

type Message &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    Id     uint64
    Type   MessageType
    Target &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Method &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Error  &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Header map[&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     Codec接口的Write方法就是编码过程，两个Read是解码过程。&lt;/p&gt;
&lt;h3&gt;Registry&lt;/h3&gt;
&lt;p&gt;     服务的注册和发现，目前实现的consul,mdns, etcd,etcdv3,zookeeper,kubernetes.等等，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
type Registry &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Register(&lt;/span&gt;*&lt;span&gt;Service, ...RegisterOption) error
    Deregister(&lt;/span&gt;*&lt;span&gt;Service) error
    GetService(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;) ([]*&lt;span&gt;Service, error)
    ListServices() ([]&lt;/span&gt;*&lt;span&gt;Service, error)
    Watch(...WatchOption) (Watcher, error)
    String() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Options() Options
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     简单来说，就是Service 进行Register，来进行注册，Client 使用watch方法进行监控，当有服务加入或者删除时这个方法会被触发，以提醒客户端更新Service信息。&lt;/p&gt;
&lt;p&gt;     默认的是服务注册和发现是consul，但是个人不推荐使用，因为你不能直接使用consul集群&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/342595/201809/342595-20180903114944511-1085926901.png&quot; alt=&quot;&quot; width=&quot;556&quot; height=&quot;303&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     我个人比较喜欢etcdv3集群。大家可以根据自己的喜好选择。&lt;/p&gt;

&lt;h3&gt;Selector&lt;/h3&gt;
&lt;p&gt;    以Registry为基础，Selector 是客户端级别的负载均衡，当有客户端向服务发送请求时， selector根据不同的算法从Registery中的主机列表，得到可用的Service节点，进行通信。目前实现的有循环算法和随机算法，默认的是随机算法。&lt;/p&gt;
&lt;p&gt;    源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
type Selector &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Init(opts ...Option) error
    Options() Options
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Select returns a function which should return the next node&lt;/span&gt;
    Select(service &lt;span&gt;string&lt;/span&gt;&lt;span&gt;, opts ...SelectOption) (Next, error)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Mark sets the success/error against a node&lt;/span&gt;
    Mark(service &lt;span&gt;string&lt;/span&gt;, node *&lt;span&gt;registry.Node, err error)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Reset returns state back to zero for a service&lt;/span&gt;
    Reset(service &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Close renders the selector unusable&lt;/span&gt;
&lt;span&gt;    Close() error
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Name of the selector&lt;/span&gt;
    String() &lt;span&gt;string&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     默认的是实现是本地缓存，当前实现的有blacklist,label,named等方式。&lt;/p&gt;
&lt;h3&gt; Broker&lt;/h3&gt;
&lt;p&gt;     Broker是消息发布和订阅的接口。很简单的一个例子，因为服务的节点是不固定的，如果有需要修改所有服务行为的需求，可以使服务订阅某个主题，当有信息发布时，所有的监听服务都会收到信息，根据你的需要做相应的行为。&lt;/p&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
type Broker &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Options() Options
    Address() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    Connect() error
    Disconnect() error
    Init(...Option) error
    Publish(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;, *&lt;span&gt;Message, ...PublishOption) error
    Subscribe(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;, Handler, ...SubscribeOption) (Subscriber, error)
    String() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     Broker默认的实现方式是http方式，但是这种方式不要在生产环境用。go-plugins里有很多成熟的消息队列实现方式，有kafka、nsq、rabbitmq、redis，等等。&lt;/p&gt;
&lt;h3&gt; Client&lt;/h3&gt;
&lt;p&gt;    Client是请求服务的接口，他封装Transport和Codec进行rpc调用，也封装了Brocker进行信息的发布。&lt;/p&gt;
&lt;p&gt;源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
type Client &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Init(...Option) error
    Options() Options
    NewMessage(topic &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;, msg &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}, opts ...MessageOption) Message
    NewRequest(service, method &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;, req &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}, reqOpts ...RequestOption) Request
    Call(ctx context.Context, req Request, rsp &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}, opts ...CallOption) error
    Stream(ctx context.Context, req Request, opts ...CallOption) (Stream, error)
    Publish(ctx context.Context, msg Message, opts ...PublishOption) error
    String() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     当然他也支持双工通信 Stream 这些具体的实现方式和使用方式，以后会详细解说。&lt;/p&gt;
&lt;p&gt;     默认的是rpc实现方式，他还有grpc和http方式，在go-plugins里可以找到&lt;/p&gt;
&lt;h3&gt;Server&lt;/h3&gt;
&lt;p&gt;     Server看名字大家也知道是做什么的了。监听等待rpc请求。监听broker的订阅信息，等待信息队列的推送等。&lt;/p&gt;
&lt;p&gt;源码 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
type Server &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Options() Options
    Init(...Option) error
    Handle(Handler) error
    NewHandler(&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}, ...HandlerOption) Handler
    NewSubscriber(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}, ...SubscriberOption) Subscriber
    Subscribe(Subscriber) error
    Register() error
    Deregister() error
    Start() error
    Stop() error
    String() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     默认的是rpc实现方式，他还有grpc和http方式，在go-plugins里可以找到&lt;/p&gt;

&lt;h3&gt;Service&lt;/h3&gt;
&lt;p&gt;     Service是Client和Server的封装，他包含了一系列的方法使用初始值去初始化Service和Client，使我们可以很简单的创建一个rpc服务。&lt;/p&gt;
&lt;p&gt;源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
type Service &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; {
    Init(...Option)
    Options() Options
    Client() client.Client
    Server() server.Server
    Run() error
    String() &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     具体的细节，我以后的帖子会给大家一一展开，希望这篇帖子，可以帮助你对go-micro的整体框架有个初步了解&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Mon, 03 Sep 2018 07:17:00 +0000</pubDate>
<dc:creator>lpxxn</dc:creator>
<og:description>产品嘴里的一个小项目，从立项到开发上线，随着时间和需求的不断激增，会越来越复杂，变成一个大项目，如果前期项目架构没设计的不好，代码会越来越臃肿，难以维护，后期的每次产品迭代上线都会牵一发而动全身。项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/li-peng/p/9558421.html</dc:identifier>
</item>
<item>
<title>java 线程池对象ThreadPoolExecutor - 大雨如注</title>
<link>http://www.cnblogs.com/loveyoumi/p/9578251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loveyoumi/p/9578251.html</guid>
<description>[unable to retrieve full-text content]ThreadPoolExecutor 介绍： java 提供的线程池类； ThreadPoolExecutor 作用： 两个作用： 1，用于分离执行任务和当前线程； 2，主要设计初衷：重复利用Thread 对象； ThreadPoolExecutor 使用： 实例化: 这是ThreadPoolExe</description>
<pubDate>Mon, 03 Sep 2018 06:27:00 +0000</pubDate>
<dc:creator>大雨如注</dc:creator>
<dc:identifier>http://www.cnblogs.com/loveyoumi/p/9578251.html</dc:identifier>
</item>
<item>
<title>Jmeter笔记（Ⅱ）使用Jmeter实现轻量级的接口自动化测试 - 这个达</title>
<link>http://www.cnblogs.com/rd-ddddd/p/9578242.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rd-ddddd/p/9578242.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;接口测试虽然作为版本的一环，但是也是有一套完整的体系，有接口的功能测试、性能测试、安全测试；同时，由于接口的特性，接口的自动化低成本高收益的，使用一些开源工具或一些轻量级的方法，在测试用例开发的成本不高的情况下能去的比较好的测试效果。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 开源测试工具Jmeter可以承担接口请求、结果解析和断言的工作，可以作为轻量级接口自动化的实现手段，对于开发能力不强或规模不大的团队也能接受。Jmeter可以在协议层实现基本的功能，包括接口访问、参数化构造、返回值断言和数据库访问，基本足够满足一个轻量级的接口自动化框架的功能。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;我们定义一个如下的接口：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;入参：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    SearchKeys: 我亲爱的你, //用户输入的查询数据，不能为空

    PageSize: 10,//分页的Page大小，默认入参为10，前端传入

    PageIndex: 1,//分页的PageIndex，第几页，前端传入

    OrderBy: 0,//排序条件：0-销量，1-价格，由前端传入，前端的通过单选控件实现

    Method: ASC//排序方式：ASC-升序，DESC-降序，前端通过单选控件实现
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44.860510805501&quot;&gt;
&lt;p align=&quot;left&quot;&gt;{&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    &quot;data&quot;:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    [&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &quot;CommodityID&quot;:&quot;03445f1e-ba55-421d-80fa-1777741bb57e&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &quot;CategoryID&quot;:2,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &quot;CommodityName&quot;:&quot;双人床solo抽泣&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &quot;Thumb&quot;:&quot;&lt;a href=&quot;http://img4.imgtn.bdimg.com/it/u=1924829949&quot;&gt;http://img4.imgtn.bdimg.com/it/u=1924829949&lt;/a&gt;,2185178641&amp;amp;fm=27&amp;amp;gp=0.jpg&quot;,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &quot;SalePrice&quot;:16.0,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &quot;SaleAmount&quot;:13&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        }&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    ],&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    &quot;records&quot;:1,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    &quot;status&quot;:true,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    &quot;message&quot;:&quot;&quot;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;代码处理逻辑：按照分页的页面和大小，从Commodity表一张表中直接查询到对应数据，查询结果进行实例化为Json处理后返回，对应字段均存在Commodity表中，对应数据如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141005607-393828436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;测试的思路为，按照实现的业务逻辑，取除了Thumb的字段作为断言字段，并构造SQL进行查询，如果查询到对应数据，则证明接口返回通过。具体构造的SQL如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;
    &lt;span&gt;*&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt;
    Commodity
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt;&lt;span&gt;
    CommodityID &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;03445f1e-ba55-421d-80fa-1777741bb57d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; CategoryID &lt;span&gt;=&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; CommodityName &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;我亲爱的你大事不妙&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; SalePrice &lt;span&gt;=&lt;/span&gt; &lt;span&gt;13.0&lt;/span&gt;
&lt;span&gt;AND&lt;/span&gt; SaleAmount &lt;span&gt;=&lt;/span&gt; &lt;span&gt;130&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;那么我们需要进行的工作，按照顺序即为访问接口-获取返回值-解析回参-构造SQL-查询-判断结果。整个过程，都能通过Jmeter进行实现，上手起来也比较容易。具体操作过程如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt; 一.Http请求：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在测试计划下新增一个线程组，并在线程组下新增一个http请求：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141124320-743160724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;添加Http请求以后，按照下图所示可以设置请求，需要注意的是如果要输入协议，就不要在服务器名称或IP前加http或https了，否则会直接访问到&lt;a href=&quot;http://http/&quot;&gt;http://http://&lt;/a&gt;上去 ：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141139856-1163186638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般来说，接口在访问的时候都需要在验证Header中的身份信息，Jmeter中提供了头信息管理的功能：添加-配置元件-Http请求头管理器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141211723-800386368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;使用结果树查看接口返回值：添加-监听器-查看结果树，可以明确看到接口的返回报文：、&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;入参：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141227607-1749473935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：Jmeter记录的入参会进行自动URL编码处理，有需要的可以自己做URL解码即可&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;回参：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141246223-134174238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，我们就完成了一个基本的Http请求的访问。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 二.实现参数化&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;想必大家注意到了，我们之前在通过Http请求构造入参时，对SearchKey这个入参并没有填入之前构造的参入，而是使用了${Key}，在Jmeter中，参数的传入就是通过${参数名}的方式进行的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;一般来说，我们测试过程中不一定能保证数据的稳定或需要构造多个不同的参数进行处理 ，很多时候需要考虑做参数化的处理，一定程度上实现动态构造。Jmeter中提供了通过读取本地文件进行参数化的功能：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;读取配置文件中的参数：在添加的http请求下添加配置元件-CSV DATA SET CONFIG：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141404137-621031799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;添加CSV 数据配置器后，按照如下设置即可设置参数：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141413246-455318362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要调用的时候， 直接使用 ${参数名} 进行调用即可。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;三.使用JSON Extractor处理返回值中的Json&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;通常来说，现在大部分的接口返回值都序列化处理成为Json格式进行返回。虽然使用正则获取返回值也可以，但是Jmeter提供了一个更加方便的插件：JSON Extractor处理Json。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下载插件&lt;a href=&quot;https://jmeter-plugins.org/wiki/JSONPathExtractor/&quot;&gt;https://jmeter-plugins.org/wiki/JSONPathExtractor/&lt;/a&gt;，下载解压后，把lib里的两个jar拷贝到jmeter的lib目录，lib/ext里面的两个jar拷贝到jmeter的lib/ext目录，重启jmeter即可。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141542445-476479954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们以处理以下Json中的CommodityID为例，来获得对应的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:

    [

        {

            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CommodityID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;03445f1e-ba55-421d-80fa-1777741bb57e&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CategoryID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,

            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CommodityName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;双人床solo抽泣&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Thumb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://img4.imgtn.bdimg.com/it/u=1924829949,2185178641&amp;amp;fm=27&amp;amp;gp=0.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SalePrice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;16.0&lt;/span&gt;&lt;span&gt;,

            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SaleAmount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;&lt;span&gt;

        }

    ],

    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,

    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,

    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注意到CommodityID在Json数组中，所以Json路径为&lt;strong&gt;data[0][&quot;&lt;/strong&gt;&lt;strong&gt;CommodityID&lt;/strong&gt;&lt;strong&gt;&quot;]&lt;/strong&gt;，需要添加Json数组中的索引值 。我们在Json Path Expreeions填入 $.data[0].[CommodityID],这样我们就取出了CommodityID的值；在后续之后，我们就可以通过${CommodityID}的方式调用取出的值。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141601061-356840743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如法炮制，我们可以取出所有的断言字段。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;按照之前的分析，我们可以构造使用断言字段构造一条SQL访问数据库，如果所有的字段都返回正确，那么查询结果应该是不为空的；按照如下的格式，我们就可以构造出我们所需要的断言SQL了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT

    &lt;/span&gt;*&lt;span&gt;

FROM
    Commodity
WHERE
    CommodityID &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;${CommodityID}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
AND CategoryID &lt;/span&gt;=&lt;span&gt; ${CategoryID}
AND CommodityName &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;${ CommodityName }&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
AND SalePrice &lt;/span&gt;=&lt;span&gt; ${SalePrice}
AND SaleAmount &lt;/span&gt;= ${SaleAmount}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;接下来，我们只需要使用Jmeter执行该SQL，并对返回结果进行验证，即可实现这个轻量级的接口自动化。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;四.使用JDBC访问MySql：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Jmeter提供了JDBC的插件进行数据库访问，但是在此之前，我们需要下载MySql的JDBC驱动包。一般来说，JDBC驱动包版本需要和数据库版本匹配，否则可能因为驱动的关系导致出错。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1.在测试计划下添加，导入对应的JDBC驱动包：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141650889-1280365385.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2.添加-配置元件，JDBC Connection Configuration&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141705312-1277950346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体设置如下所示，蓝色框线内的部分一般可以直接使用默认设置，红色框线内需要我们手动填写：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141729310-1413576924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;底部的数据库连接字符串填写如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;DataBaseURL： 数据库连接字符串，使用MySql的同学按照以下格式填写即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:2000/AutoTest?useUnicode=true&amp;amp;characterEncoding=utf8&lt;/span&gt;
jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库服务器地址:端口号/数据库名，在测试过程中遇到过因为编码问题，查询条件中的中文字符串不生效导致断言结果错误，所以需要添加编码方式，设置的与数据库本身的编码方式相同即可，我使用的是UTF-8&lt;/span&gt;
&lt;span&gt;JDBC Driver Class：直接填写com.mysql.jdbc.Driver即可
UserName&lt;/span&gt;/Password：连接数据库的账号和密码
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.使用JDBC Request进行数据库操作：添加-Sampler-JDBC Request&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141815587-552481596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JDBC的操作比较简单，我们只需要通过参数名调用设置的JDBC Connection Configuration，然后输入要执行的SQL即可：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141825729-681081949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加一个查看结果树，我们就能看到SQL的执行结果了：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;构造的SQL：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141835921-269264083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;查询的结果：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141843809-1828891657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五.使用断言验证返回结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Jmeter提供了丰富的断言功能，可以用于检查响应数据与预期是否一致，可以用作接口自动化测试的结果校验。对于一次请求，如果通过的话，断言结果中只会打印一行请求的名称；如果失败，则除了请求的名称外，还会有一行失败的原因（不同类型的断言，结果不同），也可以帮助我们定位返回值错误的内容。此外，一个Sampler可以添加多个断言，根据你的检查需求来添加相应的断言，当Sampler下所有的断言都通过了，那么才算request成功。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;那么针对这个用例，我们可以把问题简单化：既然数据库返回的查询结果查询到数据就算测试通过，那么JDBC Request的返回值中是一定有我们的传入的参数的，那么我们就可以直接使用基本的文本工具来进行断言的验证，返回结果包含一个或几个断言字段，那么就能断言测试通过了：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;添加-断言-响应断言，响应文本中包括关键的参数即可：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141903542-1707375681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么如果返回结果正确，断言测试通过，结果树中只有一条返回的数据：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903141912164-1235450522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果返回结果错误，那么断言测试失败，结果树中会新增一行失败的原因：&lt;/p&gt;
&lt;p&gt;我们构造一个错误的场景，将返回字段中的SaleAmount（销量）返回为SalePrice（价格），那么我们的查询结果为空，返回的断言结果就会是失败的，因为返回值中没有包括传入的CommodityID：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1082288/201809/1082288-20180903142005790-244264460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;断言失败，因为没有匹配到对应的CommodityID数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;至此，我们就使用Jmeter完成了一个轻量级的接口自动化测试的用例构造，构造好的用例可以用于后续版本的回归测试。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Mon, 03 Sep 2018 06:21:00 +0000</pubDate>
<dc:creator>这个达</dc:creator>
<og:description>接口测试虽然作为版本的一环，但是也是有一套完整的体系，有接口的功能测试、性能测试、安全测试；同时，由于接口的特性，接口的自动化低成本高收益的，使用一些开源工具或一些轻量级的方法，在测试用例开发的成本不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rd-ddddd/p/9578242.html</dc:identifier>
</item>
<item>
<title>虚拟内存 - 猴健居士</title>
<link>http://www.cnblogs.com/HopeGi/p/9577968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HopeGi/p/9577968.html</guid>
<description>&lt;p&gt;&lt;span&gt;在正式讲述虚拟内存之前需要提及存储器的层级结构以及进程在内存中的结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存储器的层级结构速度从快到慢排列如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;寄存器——&lt;/span&gt;L&lt;span&gt;1高速缓存——L2高速缓存——L3高速缓存——主存——磁盘——分布式文件系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132557949-1637761725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而成本也是从高到低，空间是从低到高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个相邻的存储设备，前者往往是充当后者的高速缓存，后者往往存储比前者更完整的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后面的内容会涉及到高速缓存和主存。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;为了简单的理解可以假设主存是一个线性的数组。每个元素可以是一个字节。而主存与硬盘或者与高速缓存间做数据传输时，每次可以传输若干个字节，我们可以把这若干个字节定为一个新的单位，叫&quot;块&quot;。而高速缓存中每个存储的元素则是一个块。高速缓存的存储结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132600590-1603549637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示，高速缓存被分成&lt;/span&gt;S&lt;span&gt;个组，每个组里面有&lt;/span&gt;E&lt;span&gt;行，每行都有一个有效位，&lt;/span&gt;t&lt;span&gt;个标记为和&lt;/span&gt;B&lt;span&gt;个字节，这&lt;/span&gt;B&lt;span&gt;个字节就组成了之前提到的块。并且和内存地址有这样的一个关系&lt;/span&gt;m&lt;span&gt;=t+s+b。即有&lt;/span&gt;t&lt;span&gt;个标记位，&lt;/span&gt;s&lt;span&gt;个位作为组索引，&lt;/span&gt;b&lt;span&gt;个位作为块偏移，并且是&lt;/span&gt;t&lt;span&gt;,s,b是从高位到低位排列。这个关系决定了给定一个地址，它该存放在高速缓存中的哪个位置。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;另外整个高速缓存的总容量是&lt;/span&gt;C&lt;span&gt;=S*B*E；按照S和B的变换可以把高速缓存分成下面三种类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;span&gt;直接映射&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;组相联&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;span&gt;全相联&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接映射和全相联是两种极端情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接映射是缓存中每个组只有&lt;/span&gt;1&lt;span&gt;行，即&lt;/span&gt;E&lt;span&gt;=1。对于这种情况，当某个当某个地址在缓存中发生冲突时则直接替换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132602282-51302054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全相联是缓存中只有一个组，所有行都在这个唯一的组里面，相当于&lt;/span&gt;S=&lt;span&gt;1。这种情况所有缓存都放在一个组里面，然后轮询找出哪一行是未使用的，如果全部组都已经使用了，那就按照一定的算法找出一个块踢出，再放上新的块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组相连则是介于上面两种情况，每个组最少有两行。这种情况跟全相联一样，不命中的时候在组里面找不到未使用的块，也是需要有策略选出一个牺牲的块，替换上新的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132603380-472547996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面则用直接映射来模拟一下读取高速缓存的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在有一个直接映射的高速缓存如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;S&lt;span&gt;，&lt;/span&gt;E&lt;span&gt;，&lt;/span&gt;B&lt;span&gt;，&lt;/span&gt;m&lt;span&gt;）&lt;/span&gt;=&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;，&lt;/span&gt;1&lt;span&gt;，&lt;/span&gt;2&lt;span&gt;，&lt;/span&gt;4&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由此可以得出&lt;/span&gt;s=&lt;span&gt;2，b=1，t=m-b-s=4-1-2=1，整个地址构成如下&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody valign=&quot;top&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;t=&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;s&lt;span&gt;=2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;b=1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所有地址的标记位，组索引和块偏移如下表所示，另外给内存中的块编上一个序号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132604770-578298773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高速缓存如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132605286-273079089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设现在读地址&lt;/span&gt;0&lt;span&gt;的字，按照上面的表，组块索引是&lt;/span&gt;0&lt;span&gt;，标记位是&lt;/span&gt;0&lt;span&gt;，缓存不命中，需要从内存中读取块&lt;/span&gt;0&lt;span&gt;写入高速缓存，因此&lt;/span&gt;m&lt;span&gt;[0]和m[1]会被写入组0，标记位是0，有效位置1，写后高速缓存如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132605779-1869846204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着读地址&lt;/span&gt;1&lt;span&gt;的字，内存地址是&lt;/span&gt;0001&lt;span&gt;，组索引为&lt;/span&gt;0&lt;span&gt;，标记位是&lt;/span&gt;0&lt;span&gt;，查找高速缓存，组号和标记位对上，有效位是&lt;/span&gt;1&lt;span&gt;，取偏移是&lt;/span&gt;1&lt;span&gt;的值&lt;/span&gt;m&lt;span&gt;[1]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来读地址&lt;/span&gt;8&lt;span&gt;的字，内存地址是&lt;/span&gt;1001&lt;span&gt;，组索引是&lt;/span&gt;0&lt;span&gt;，标记位是&lt;/span&gt;1&lt;span&gt;，查找高速缓存不命中，而且该组已经被用上了，牺牲了原本的&lt;/span&gt;0&lt;span&gt;组的两个值&lt;/span&gt;m&lt;span&gt;[0]和m[1]，读取新的值&lt;/span&gt;m&lt;span&gt;[&lt;/span&gt;8&lt;span&gt;]和m[&lt;/span&gt;9&lt;span&gt;]，块偏移是&lt;/span&gt;1&lt;span&gt;，取值&lt;/span&gt;m&lt;span&gt;[8]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132606197-2015590045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设再读地址&lt;/span&gt;0&lt;span&gt;的字时，又会发现不命中，重复类似第一次读地址&lt;/span&gt;0&lt;span&gt;的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132606580-1470418429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来补充链接的少部分的内容，这些内容会在内存映射和内存分配的时候会涉及到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132607249-280837268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的这幅图在众多&lt;/span&gt;C&lt;span&gt;语言的书都有出现，其他语言的都有类似的流程图。一个&lt;/span&gt;C&lt;span&gt;文件经过预处理和编译，得出了一份汇编语言的源码文件。这个文件经过汇编器汇编之后，就产生了人类无法直接阅读的可重定向目标文件。这个文件具有一定的结构，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132608023-1445069230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它会把原本程序员写的源代码拆分成若干部分：指令放到&lt;/span&gt;.text&lt;span&gt;节；全局静态变量放到&lt;/span&gt;.data&lt;span&gt;节；内部定义的函数名、引用外部函数名这些符号信息放到&lt;/span&gt;.symtab&lt;span&gt;节……但是外部引用的函数地址（如我们最常用的&lt;/span&gt;printf&lt;span&gt;）在这个阶段还是没有的，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132609508-701377628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些需要引用地址的信息都放到一个叫&quot;可重定向条目&quot;的结构里面，此时需要往下走到链接这个过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132610427-916051238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后链接器链接时会把这些外部引用的函数地址给填上去，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132612594-212430732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终生成了像上图结构的可执行文件，常见的是&lt;/span&gt;windows&lt;span&gt;的&lt;/span&gt;exe&lt;span&gt;文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可执行文件结构如此，一个程序运行后，进程在内存中的结构是如下这样子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132615437-1964476500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这幅图跟可执行文件的结构较为相似，底部是低地址，地址往上递增。低地址处是代码区&lt;/span&gt;.text&lt;span&gt;已初始化数据区&lt;/span&gt;.data&lt;span&gt;未初始化数据区&lt;/span&gt;.bss&lt;span&gt;。这几个区是在程序运行的时候通过内存映射附加上去的。在高地址处有个区域是用户栈，这个栈栈底在高地址处，栈顶在低地址处。栈顶和栈底由两个指针记录他们的地址，指针的值存放在&lt;/span&gt;CPU&lt;span&gt;寄存器中，分别是%rbp和%rsp。用户栈的作用有两个，其一是存放函数调用的栈帧，其二是存放函数调用期间所用到的临时变量。另外一个区域是位于整个空间中部的运行时堆，这个运行时堆主要是用于给程序申请内存空间的时候用的，即调用malloc的时候。动态内存分配也属于虚拟内存范畴的内容，但本篇暂不作介绍。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面则进入虚拟内存范畴的内容。从物理内存讲起，因为物理内存大家较为熟悉，一个内存上分配了若干的存储空间，每个存储空间都有一个唯一能定位到它的地址称为物理地址。把一个物理地址传给内存控制器就能往指定地址的内存空间上读/写数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而虚拟内存则是现代操作系统对内存做了一层抽象。与物理地址对应，虚拟内存上的每个存储空间的地址称为虚拟地址。尽管是虚拟地址，最终提供或者存放数据的地方还是物理地址，在这个过程中虚拟地址会同通过一个在CPU上的名为内存管理单元（简称MMU）的硬件翻译成物理地址，这个过程就叫做地址翻译。在之前可执行文件的汇编语言截图中的地址是虚拟地址，进程的内存结构中的几个地址都是虚拟地址。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;虚拟内存实际是存放在磁盘中的，在该空间中划分了一段一段的连续的空间，这个空间叫作一个&quot;页&quot;，与之前高速缓存中的&quot;块&quot;概念类似。同样地，在内存中也有一样的分页机制。这个页就用于主存跟磁盘间相互传递数据的最小单元。一个虚拟页被存放到物理内存中，这个行为也叫作缓存。磁盘空间比物理内存空间要大得多，同样地虚拟地址空间也会比用作虚拟页的空间要大。通常一个虚拟页的状态有三个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;span&gt;未分配：实际上该页是未存在的，在磁盘上未开辟空间；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;已分配：与未分配对应，已经在磁盘上开辟了空间；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;span&gt;已缓存：该页已经被分配了，并已经被存放到物理内存中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132616742-767125323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一个比较重要的结构叫做页表，页表中每个元素叫作页表条目（简称&lt;/span&gt;PTE&lt;span&gt;）&lt;/span&gt;,PTE&lt;span&gt;的数量与虚拟页数量相同。页表是存放在物理内存中。每个&lt;/span&gt;PTE&lt;span&gt;都有一个有效位，当有效位为&lt;/span&gt;0&lt;span&gt;时，表明该页未分配；当有效位为&lt;/span&gt;1&lt;span&gt;是&lt;/span&gt;,PTE&lt;span&gt;中存放的要么是虚拟页的页号，要么是已经缓存到物理内存的物理地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132617721-1295716644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CPU&lt;span&gt;平时只能往物理内存读写数据，当刚好取到的页属于已分配状态，就会引发缺页异常，这时候系统会从物理内存中选出一页作为牺牲页，把&lt;/span&gt;PTE&lt;span&gt;指回虚拟内存的页号，把新的页从磁盘加载到物理内存，&lt;/span&gt;PTE&lt;span&gt;指向物理内存的地址中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前也有提及从虚拟地址转换得出物理地址的过程叫地址翻译，由&lt;/span&gt;CPU&lt;span&gt;里面的&lt;/span&gt;MMU&lt;span&gt;执行。下面则来讲述这个过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132620152-205466416.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示，一个虚拟地址可以划分成两部分，低的&lt;/span&gt;p&lt;span&gt;位作为虚拟页的偏移量，而剩下部分是作为虚拟页的页号，实质上就是&lt;/span&gt;PTE&lt;span&gt;在页表上的索引而已。同样物理地址也是分了两部分，物理页偏移量和物理页号，有个额外的规则是物理页的偏移量&lt;/span&gt;=&lt;span&gt;虚拟页的偏移量。这里&lt;/span&gt;P&lt;span&gt;=2&lt;sup&gt;p&lt;/sup&gt;，P是页的大小，字节为单位。各种量的简称如上图所示。地址翻译过程的简述如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;span&gt;给定一个虚拟地址，划分出虚拟页偏移量和虚拟页号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;通过页表基址寄存器找出页表，找出对应页号的&lt;/span&gt;PTE&lt;/p&gt;
&lt;p&gt;3.&lt;span&gt;看从&lt;/span&gt;PTE&lt;span&gt;得出页是否已缓存，不缓存则要找出牺牲页替换，得出物理页号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;span&gt;把物理页号和虚拟页偏移量组合成物理地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上述过程中的第三部查找页表搜出&lt;/span&gt;PTE&lt;span&gt;在整个过程中较为耗时，因为涉及到访存。假设这部分操作利用上缓存则会节省一部分的时间。&lt;/span&gt;TLB&lt;span&gt;正是解决了这个问题，&lt;/span&gt;TLB&lt;span&gt;叫翻译后备缓存器（&lt;/span&gt;T&lt;span&gt;ranslation Lookaside Buffer），存放在MMU中。有了这种机制一个虚拟地址的结构将再次被划分，这次划分的区域是虚拟页号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132620555-538922042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面通过一个例子，结合主存，高速缓存，&lt;/span&gt;PTE&lt;span&gt;，TLB，页表来模拟这个地址翻译的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132621402-2109676809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TLB&lt;span&gt;，页表，高速缓存入下面所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132622092-391943972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132622702-221694707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132623736-885122934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在要求出虚拟地址&lt;/span&gt;0x&lt;span&gt;03d4的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按照前面的条件得出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;p=6&lt;span&gt;，所以&lt;/span&gt;VPN=&lt;span&gt;14-6=8；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;TLB&lt;span&gt;是&lt;/span&gt;4&lt;span&gt;路组相联，所以&lt;/span&gt;TLB&lt;span&gt;索引占两位，剩余的标记位是&lt;/span&gt;TLBT&lt;span&gt;=VPN-TLBI=8-2=6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虚拟地址可以拆成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132624049-52586122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;TLB&lt;span&gt;行数是&lt;/span&gt;3&lt;span&gt;，标记位是&lt;/span&gt;03&lt;span&gt;的命中，&lt;/span&gt;PPN&lt;span&gt;是&lt;/span&gt;0D&lt;span&gt;，&lt;/span&gt;PPN&lt;span&gt;是&lt;/span&gt;12-&lt;span&gt;6=6位，因为&lt;/span&gt;PPO&lt;span&gt;=VPO，所以重新组织后物理地址是&lt;/span&gt;0x&lt;span&gt;354，MMU的地址翻译就到此结束了，。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高速缓存是直接映射，行大小是&lt;/span&gt;4&lt;span&gt;字节，一共有&lt;/span&gt;16&lt;span&gt;个组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以得出以下信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;B&lt;span&gt;=4=2^2,b=2;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;S=&lt;span&gt;16=2^4,s=4;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;t=m-s-b=12-4-2=6&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132624284-295356414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高速缓存索引号是&lt;/span&gt;5&lt;span&gt;，标记位&lt;/span&gt;0D&lt;span&gt;命中，偏移是&lt;/span&gt;0&lt;span&gt;。最终结果虚拟地址&lt;/span&gt;0x&lt;span&gt;03d4的值是&lt;/span&gt;0x&lt;span&gt;36。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设上面&lt;/span&gt;TLB&lt;span&gt;不命中，虚拟页号是&lt;/span&gt;0x&lt;span&gt;0F的，查页表也得出有效位是&lt;/span&gt;1&lt;span&gt;，&lt;/span&gt;PPN&lt;span&gt;是&lt;/span&gt;0x&lt;span&gt;0D。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;内存映射&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存映射与虚拟内存极为相似，也利用了虚拟内存。这两者也是利用了页表。内存映射是与磁盘上的文件加载有关的。比如我们的可执行文件加载到内存，或者一些像lib&lt;/span&gt;c.so&lt;span&gt;共享库，也或者是普通一个txt。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132625773-337100747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132626594-1664585153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132627149-1226795939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个文件要加载到内存中时，实际上在虚拟内存中开辟了一开虚拟内存空间，这个区域的地址是指向了一个页表，这个页表类似于虚拟内存那样与磁盘的内容进行关联。比如现在要读取某共享库的一个地址的内容，该地址是位于进程的虚拟内存的共享库的区域内，而这个地址指向的是一个内存映射的页表PTE。如同虚拟寻址那样，如果该PTE是无效的或者是指向文件中的某个地址，则会发生缺页异常，然后会就在物理内存中选中一个牺牲的物理页替换成这个待读取的页。加载到物理页完毕后，就可以在物理页中读取想要的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存映射有利于节省内存空间，现在如lib&lt;/span&gt;c.so&lt;span&gt;这样的文件加载到内存中，如果每个进程都加载一份到内存中那回造成浪费，现在利用内存映射，每个进程都可以把他们共同需要的libc&lt;/span&gt;.so&lt;span&gt;映射到同一片的内存区域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132628136-568985171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。另外一种场景，假设两个进程A和B都打开了某个文件，现在有一个进程&lt;/span&gt;B&lt;span&gt;需要写文件的内容，但是另外一个&lt;/span&gt;A&lt;span&gt;进程完全不能受到这次写的影响，那进程B则会在物理内存中拷贝一份跟原有页一样的内容，把虚拟内存指向到这个新的页。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/441298/201809/441298-20180903132629407-543423343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户态的内存映射实际上利用了一个叫mm&lt;/span&gt;ap&lt;span&gt;的函数。函数的定义如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;void* mmap(void* start ,size_t length , int prot , int flags , int fd , off_t offset);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Start是待映射的虚拟内存的起始地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;length是映射的长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;fd&lt;span&gt;是文件描述符，指定了磁盘文件中的起始地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;offset是最后一个参数，他指定了开始映射的地址距离文件起始地址的偏移量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;prot是映射后虚拟内存的访问权限，这个权限是可读可写之类的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;flag指定了映射的对象类型，这些类型是匿名对象，共享对象，私有对象之类的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇属于个人学习完的总结。文中有摘抄了网上或书籍中的图片。如有错误的请及时指出，以便本人及时更正。谢谢&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Sep 2018 05:29:00 +0000</pubDate>
<dc:creator>猴健居士</dc:creator>
<og:description>在正式讲述虚拟内存之前需要提及存储器的层级结构以及进程在内存中的结构。 存储器的层级结构速度从快到慢排列如下 寄存器——L1高速缓存——L2高速缓存——L3高速缓存——主存——磁盘——分布式文件系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HopeGi/p/9577968.html</dc:identifier>
</item>
<item>
<title>微信小游戏和白鹭引擎开发实践 - 子慕大诗人</title>
<link>http://www.cnblogs.com/1wen/p/9391372.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1wen/p/9391372.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;文章按照作者调研和开发顺序初步介绍和理解了微信小游戏和白鹭引擎，并产出了基于白鹭引擎的应用初始化程序&lt;a href=&quot;https://github.com/zimv/egret-wechat-start&quot; target=&quot;_blank&quot;&gt;egret-wechat-start&lt;/a&gt;。  以下是正文——&lt;/span&gt;&lt;a href=&quot;https://github.com/zimv/egret-wechat-start&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;微信小游戏&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;官方文档&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;12.339226519337&quot;&gt;如何开发和理解微信小游戏，先从官方文档和官方demo入手。  提供一个链接&lt;a href=&quot;https://developers.weixin.qq.com/minigame/dev/&quot; target=&quot;_blank&quot;&gt;https://developers.weixin.qq.com/minigame/dev/&lt;/a&gt;，可以快速浏览一下官方文档再继续看下面的内容。  这里对微信文档做个简单的理解总结，小游戏和小程序很多地方类似，都是提供了同一套微信Api，比如获取用户信息、toast等等，只是有部分提供的api不同。  小游戏对canvas做了封装，通过 &lt;code class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span&gt;wx.createCanvas()&lt;/span&gt; 创建画布，&lt;/code&gt;&lt;/code&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span&gt;getContext&lt;/span&gt;获取对象后，剩下的就是对原生canvas接口的操作了。  理解到这一点之后，我们就会发现小游戏仅仅是封装了下创建画布的接口，剩下的就是用户需要在画布里用原生canvas绘制了，并没有提供其他方便开发的功能。到此我们再看看微信开发者工具创建小游戏项目时，初始化的一个飞机游戏的demo。 &lt;/code&gt;&lt;/div&gt;
&lt;div&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201808/623144-20180831115219438-2103792633.png&quot; alt=&quot;&quot; width=&quot;373&quot; height=&quot;622&quot;/&gt;&lt;/code&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-javascript&quot;&gt;是如上图的一个很简单的游戏，说下这个游戏的大致实现逻辑：&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.  绘制游戏区域，背景图片&lt;/p&gt;
&lt;p&gt;2. 创建敌机对象，用户飞机对象，子弹对象&lt;/p&gt;
&lt;p&gt;3. 控制3种对象载入画布和位置改变，控制背景图片移动，添加音效&lt;/p&gt;
&lt;p&gt;4. 判断子弹碰撞，机身碰撞，并且生成对应结果（敌机消失，游戏结束）&lt;/p&gt;

&lt;p&gt;游戏中和用户有交互操作有拖动飞机和弹框中的按钮，总体是一个很简单的小游戏，实现过程也并不复杂。  官方demo中最核心的动画内容就在loop方法里，使用的是帧动画（ requestAnimationFrame ）来实现界面动画。  针对游戏实现动画效果主要有两种方式，一种就是&lt;span&gt;requestAnimationFrame&lt;/span&gt;帧动画，一种是用定时器实现。  帧动画和设备的处理速度有关系，默认1秒60帧，但是在手机设备里即便很简单的动画，性能差点的设备可能帧率都只有20-30左右。  因为帧动画每秒就要调用n次，也许并不需要那么高频率的函数调用，而定时器总的来说对时间的把控和函数调用次数更准确。 比如这个飞机游戏里如果有血条的概念，血条的加减其实可以用单独的定时器来控制。 一个游戏里可以两种方式都使用，根据应用场景选择更合理的方式。  &lt;/p&gt;

&lt;p&gt;现在根据一个新的需求来做一个游戏，再来理解小游戏的开发。  &lt;span&gt;现在需求实现一个回合制游戏，这个游戏也有很多页面，首页就包含很多按钮和可能出现的弹窗，也有各种列表页，还有最关键的战斗页面。  在做实现需求之前，需要提供一些公共的基础模块：资源预加载，接口拦截器，简易路由等等。 &lt;/span&gt; 跳过这些阶段，如果我们拿到ui设计，开始做首页了，首页有很多按钮，我们需要给A按钮添加绑定事件，那我们需要给canvas画布绑定一个点击事件，点击触发以后我们获取到当前用户点击位置，并取出A按钮的位置宽高并计算出范围，进行判断是否点击位置在范围内，最后再触发绑定的方法。 好像有点麻烦，但是还能实现，继续做下去。  后来需要在首页做一个弹框，这个时候，给弹框的B按钮绑定点击事件，又需要通过同样的方法判断是否点击到B按钮。  这个时候弹框的B按钮刚好和A按钮重叠都在一个点击范围内，那按钮A和B的回调都会被执行。  代码如下：&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
canvas.addEventListener('click', (event)=&amp;gt;&lt;span&gt;{
    获取event对象x,y

    获取 buttonA：x,y,width,height
    判断是否点击

    获取 buttonB：x,y,width,height
    判断是否点击
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一个弹窗上面的按钮点击，反而把弹框下面的按钮也点击到了，这不符合预期，那要解决这个问题，我们还需要一个层级管理器，根据层级判断谁应该触发，谁不应该触发。  目前就事件处理我们需要实现两个基础功能，事件监听池和元素对象层级管理器，因为事件只能绑定在canvas上，canvas事件触发以后，需要一个事件监听池来遍历监听池里的元素对象并判断谁被触发了（监听池也会随时增减监听对象），监听池获取的依然是一个对象集，层级管理器判断出对象集里最上层的元素进行触发。  想想功能好像越来越复杂了。  目前还没考虑完善，不仅仅是事件处理问题，还可能会有其它大大小小的问题。  用canvas原生开发，工作量可能会非常大。  所以这样看来，自己把这些实现了是不科学的，需要使用三方引擎开发才行。  因为两年前用过白鹭引擎，所以就事件监听和层级管理这个事情，我知道白鹭引擎已经实现了，除开事件，图形绘制，动画等等印象中白鹭都提供了，如果用引擎开发小游戏实现成本被大大降低。&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;白鹭引擎&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;白鹭引擎功能很强大并且丰富。  这里我先介绍一下我主要使用的工具。  &lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;ul&gt;&lt;li&gt;Egret Engine2D&lt;/li&gt;
&lt;li&gt;Texture Merger&lt;/li&gt;
&lt;li&gt;Egret 扩展库&lt;/li&gt;
&lt;li&gt;Egret Wing&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201808/623144-20180831185544248-261059006.png&quot; alt=&quot;&quot; width=&quot;932&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Egret Engine2D&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;开发中主要的核心api&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Texture Merger&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Texture Merger 可将零散纹理拼合为整图，同时也可以解析SWF、GIF动画，制作Egret位图文本，导出可供Egret使用的配置文件。  我主要使用其中的精灵图功能，把图片集合到一张图上，并且会同时导出一个json的精灵图的在图片中的位置等配置信息&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Egret 扩展库&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;扩展库在核心引擎功能之上提供了更高级的api，扩展库在引擎配置文件里配置好以后，会直接把方法和对象载入到egret全局对象中，目前我主要使用的扩展库有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;　RES：  资源管理库&lt;/li&gt;
&lt;li&gt;　EUI： EUI是一套基于Egret核心显示列表的UI扩展库，它封装了大量的常用UI组件，能够满足大部分的交互界面需求，即使更加复杂的组件需求，您也可以基于EUI已有组件进行组合或扩展，从而快速实现需求。&lt;/li&gt;
&lt;li&gt;　Game：这个库好像没有什么专门的定义，我主要使用了：ScrollView 滚动视图。 来处理需要滚动的页面&lt;/li&gt;
&lt;li&gt;　Tween： 缓动动画库，类似于GreenSock库&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201808/623144-20180831190830047-1114796052.png&quot; alt=&quot;&quot; width=&quot;196&quot; height=&quot;430&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Egret Wing&lt;/span&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;白鹭开发的代码编辑器，像其他编辑器一样，推荐使用它。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;egret launcher&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;当然还需要安装一个egret launcher来管理引擎、工具和项目打包，小游戏就需要打包之后才能在微信开发者工具里使用&lt;/p&gt;

&lt;div readability=&quot;71.12335121032&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180902214945923-1790976601.png&quot; alt=&quot;&quot; width=&quot;806&quot; height=&quot;492&quot;/&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180902215133048-384795319.png&quot; alt=&quot;&quot; width=&quot;808&quot; height=&quot;471&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;开始egret开发&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;你可以快速浏览一遍官方教程，以便更好对下文有所理解，&lt;a href=&quot;http://developer.egret.com/cn/github/egret-docs/Engine2D/getStarted/helloWorld/index.html&quot; target=&quot;_blank&quot;&gt;http://developer.egret.com/cn/github/egret-docs/Engine2D/getStarted/helloWorld/index.html&lt;/a&gt; 。  文章不是教程所以会省略掉那些白鹭官网里的教程。  现在我们使用&lt;span&gt;egret launcher&lt;/span&gt;创建一个初始化项目，初始化后的文件结构如下图，我展开了&lt;span&gt;resource&lt;/span&gt;和&lt;span&gt;src&lt;/span&gt;文件夹，因为我们需要操作的主要是这两个文件夹，&lt;span&gt;resource&lt;/span&gt;文件夹主要是存放静态资源，我们的代码都在&lt;span&gt;src&lt;/span&gt;里，白鹭使用的是&lt;span&gt;typescript&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180902223025648-1255346854.png&quot; alt=&quot;&quot; width=&quot;201&quot; height=&quot;536&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在&lt;span&gt;wing&lt;/span&gt;工具里，我们可以马上开启调试，就可以在浏览器或者它自带的容器里预览效果。  &lt;span&gt;main.ts&lt;/span&gt;是启动文件，&lt;span&gt;main&lt;/span&gt;中首先使用&lt;span&gt;await&lt;/span&gt;对&lt;span&gt;resource&lt;/span&gt;中定义好的图片资源进行了预加载，所以预览开始后会出现&lt;span&gt;loading&lt;/span&gt;效果，&lt;span&gt;loading&lt;/span&gt;的绘制是写在&lt;span&gt;src&lt;/span&gt;中&lt;span&gt;LoadingUI.ts&lt;/span&gt;，图片加载完成以后，&lt;span&gt;main&lt;/span&gt;里直接创建了下图2的页面，并且添加了一个按钮，点击后会出现一个弹窗。  效果如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180902224052768-277852284.png&quot; alt=&quot;&quot; width=&quot;429&quot; height=&quot;319&quot;/&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180902223528002-1621877768.png&quot; alt=&quot;&quot; width=&quot;416&quot; height=&quot;324&quot;/&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180902224202650-115202608.png&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，初始化demo已经告诉了我们如何绘制图像和绑定事件了，如下图，我只截取了&lt;span&gt;click&lt;/span&gt;按钮的代码，图像绘制首先需要创建一个相应的&lt;span&gt;egret&lt;/span&gt;或者&lt;span&gt;eui&lt;/span&gt;对象，比如&lt;span&gt;eui.Button、egret.TextField、egret.Bitmap&lt;/span&gt;等等，然后给对象设置相应属性，比如&lt;span&gt;label、x y&lt;/span&gt;坐标，&lt;span&gt;width, height&lt;/span&gt;等。  再使用&lt;span&gt;main&lt;/span&gt;的&lt;span&gt;addChild&lt;/span&gt;载入到画布中（下面的&lt;span&gt;this&lt;/span&gt;就是&lt;span&gt;main&lt;/span&gt;对象，&lt;span&gt;main&lt;/span&gt;继承于&lt;span&gt;eui.UILayer&lt;/span&gt;）。  demo中的代码在载入loading的时候，使用了&lt;span&gt;this.stage.addChild&lt;/span&gt;，直接&lt;span&gt;addChild&lt;/span&gt;或者使用&lt;span&gt;stage.addChild&lt;/span&gt;都可以载入到画布中。  白鹭封装的addEventListener方法和原生js的监听方法是一样的使用方法。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180902225322477-1632546019.png&quot; alt=&quot;&quot; width=&quot;762&quot; height=&quot;143&quot;/&gt;&lt;/p&gt;

&lt;p&gt;demo的代码说到这里总结一下，我们在&lt;span&gt;main&lt;/span&gt;入口对象中可以使用&lt;span&gt;addChild&lt;/span&gt;载入一个视图对象到画布中，比如文本，按钮等。  我们也可以在&lt;span&gt;main&lt;/span&gt;里&lt;span&gt;addChild&lt;/span&gt;一个视图容器A，视图容器A也可以添加文本按钮等，那我们在视图容器A中再次&lt;span&gt;addChild&lt;/span&gt;视图容器B，那么这样就形成了层级嵌套&lt;span&gt;main-&amp;gt;A-&amp;gt;B&lt;/span&gt;，如果想象成dom元素就是&lt;span&gt;div.main-&amp;gt;div.A-&amp;gt;div.B&lt;/span&gt;的关系，我们用代码来对比一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Main extends eui.UILayer {


    protected createChildren(): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {

        let A &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; egret.DisplayObjectContainer();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.addChild(A);

        let textA &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; egret.TextField();
        textA.text &lt;/span&gt;= 'text A Description'&lt;span&gt;;
        A.addChild(textA);

        let B &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; egret.DisplayObjectContainer();
        A.addChild(B);
        
        let buttonB &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; eui.Button();
        buttonB.label &lt;/span&gt;= 'button B'&lt;span&gt;;
        B.addChild(buttonB);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;A&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;text A Description&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;B&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;button B&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据以上代码的理解和我们要做的需求（实现一个回合制游戏，这个游戏也有很多页面，首页就包含很多按钮和可能出现的弹窗，也有各种列表页，还有最关键的战斗页面）。  我在&lt;span&gt;main&lt;/span&gt;里写一个&lt;span&gt;initElement&lt;/span&gt;方法，创建顶层容器，代码如下图，&lt;span&gt;addChild&lt;/span&gt;默认根据先后顺序确定上下层关系，先载入的在下层。  首先最下层创建了一个背景层，接着是&lt;span&gt;ScrollView&lt;/span&gt;和&lt;span&gt;baseContent&lt;/span&gt;，页面容器会载入到他们之中，如果页面需要滚动会把页面视图对象载入到SV中，不需要滚动会载入到&lt;span&gt;baseContent&lt;/span&gt;中，&lt;span&gt;Layer&lt;/span&gt;和&lt;span&gt;loading&lt;/span&gt;在更上层的位置。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180902233228812-861606018.png&quot; alt=&quot;&quot; width=&quot;544&quot; height=&quot;440&quot;/&gt;&lt;/p&gt;

&lt;p&gt;顶层容器准备好以后，我们可以创建一个首页页面。  我会创建3个文件：&lt;span&gt;base.ts，Index_ui.ts，Index.ts&lt;/span&gt;。  &lt;span&gt;Index&lt;/span&gt;继承&lt;span&gt;Index_ui&lt;/span&gt;，&lt;span&gt;Index_ui&lt;/span&gt;继承&lt;span&gt;base&lt;/span&gt;。  所有的&lt;span&gt;_ui&lt;/span&gt;都会继承&lt;span&gt;base&lt;/span&gt;，&lt;span&gt;base&lt;/span&gt;会定义通用方法和属性。  因为一个页面到最后可能代码量会比较大，甚至比较乱，所以才把一个页面拆分成&lt;span&gt;page&lt;/span&gt;和&lt;span&gt;page_ui&lt;/span&gt;，&lt;span&gt;_ui&lt;/span&gt;里写视图相关代码，&lt;span&gt;page&lt;/span&gt;里调用&lt;span&gt;_ui&lt;/span&gt;的方法、处理请求和编写逻辑，达到视图和逻辑分离的效果。  当首页写好以后，需要创建一个简易路由，用路由提供的方法把&lt;span&gt;Index&lt;/span&gt;添加到&lt;span&gt;SV&lt;/span&gt;容器中。  我把路由直接写到了&lt;span&gt;main&lt;span&gt;中&lt;/span&gt;&lt;/span&gt;，&lt;span&gt;changePage&lt;/span&gt;就是页面切换的方法，代码大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180902235537163-1565358913.png&quot; alt=&quot;&quot; width=&quot;614&quot; height=&quot;784&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过&lt;span&gt;remove&lt;/span&gt;和&lt;span&gt;add&lt;/span&gt;视图容器达到了切换页面的效果。  下面说说编写&lt;span&gt;_ui&lt;/span&gt;页面的规则，下面是&lt;span&gt;Index_ui&lt;/span&gt;的部分代码，&lt;span&gt;el_layout&lt;/span&gt;提前把页面元素的布局信息提前定义并统一管理。  把&lt;span&gt;Index&lt;/span&gt;逻辑页面需要操作的元素引用到&lt;span&gt;$el&lt;/span&gt;对象里方便调用和操作。  把数据信息统一放在&lt;span&gt;$data&lt;/span&gt;中。  创建页面视图元素之前，需要把第一个元素的y坐标传给 &lt;span&gt;$firstEleY&lt;/span&gt; 这是为了后面&lt;span&gt;pageContentCenter&lt;/span&gt;方法能获取到准确的页面内容高度，&lt;span&gt;pageContentCenter&lt;/span&gt;要执行在所有页面元素创建完成之后，&lt;span&gt;pageContentCenter&lt;/span&gt;会根据当前页面的高度再匹配当前设备的高度进行垂直居中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Index_ui extends Base {
    public el_layout = {
        indexbg: {x:0, y:0, w:750, h:1665},
        gold: {x:300, y:100, w:300, h:39}
    };
    public constructor() {
        super();
        this.RES_index = RES.getRes('index');
        this.RES_common = RES.getRes('common');
    }
    public RES_index;
    public RES_common;
    public $el = {
        gold: Object(egret.TextField)
    }
    public $data = {
        gold: '0'
    }

    public async createView() {&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　//背景&lt;br/&gt;　　　　　　let RES_bg = new egret.Bitmap( RES.getRes('indexbg') );&lt;br/&gt;　　　　　　$util.setLayout(RES_bg, this.el_layout['indexbg']);&lt;br/&gt;　　　　　　RES_bg.fillMode = egret.BitmapFillMode.REPEAT;&lt;br/&gt;　　　　　　this.$main.PageBg.addChild(RES_bg);//加载到main的PageBg里去，保证背景不滚动&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;
        //顶部元素必传值
        this.$firstEleY = this.el_layout.gold.y;

        this.pageContentCenter(true);//根据内容计算处理居中
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一个简易的开发封装的核心代码已经搭建好了，而后我们还需要封装一些其它工具类，如下图：配置文件（$config）、封装拦截器（$api）、滤镜（$filter）、工具函数（$util）、微信api封装（Wx）。  &lt;span&gt;Platform.ts&lt;/span&gt;是白鹭自动生成的文件，根据它的规则自己写了一个Wx.ts文件，由于不同平台的接口形式各有不同，白鹭推荐开发者通过这种方式封装平台逻辑，以保证整体结构的稳定，白鹭推荐开发者将所有接口封装为基于 Promise 的异步形式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180903085208750-1154271961.png&quot; alt=&quot;&quot; width=&quot;182&quot; height=&quot;455&quot;/&gt;&lt;/p&gt;

&lt;p&gt;和src同级的还有一个texture文件夹，里面是TextureMeger使用精灵图的相关文件，放在仓库里是方便后期管理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180903090811727-261930479.png&quot; alt=&quot;&quot; width=&quot;206&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;


&lt;p&gt;简易的初始化demo，我已经更新到github上&lt;a href=&quot;https://github.com/zimv/egret-wechat-start&quot; target=&quot;_blank&quot;&gt;https://github.com/zimv/egret-wechat-start&lt;/a&gt;。  &lt;span&gt;egret-resource&lt;/span&gt;是源码，&lt;span&gt;egret-resource_wxgame&lt;/span&gt;是白鹭打包后的文件夹，它在开发者工具里运行。  &lt;span&gt;egret-resource_wxgame&lt;/span&gt;应该在ignore里忽略，这里没有忽略是方便下载源码的朋友直接在开发者工具里运行demo。  当前程序使用白鹭引擎版本5.2.5。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180903090345755-1719008890.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;272&quot;/&gt;&lt;/p&gt;

&lt;p&gt;demo里随便写了几个页面，看下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/623144/201809/623144-20180903132459665-1057575808.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;&lt;span&gt;坑&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;还有踩过很多坑，下面记录一下：&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在公众号后台把设置里的服务类设置成游戏类，输入appId后会自动打开开发者工具游戏开发的界面 &lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;小游戏自定义字体微信支持程度差&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 03 Sep 2018 05:09:00 +0000</pubDate>
<dc:creator>子慕大诗人</dc:creator>
<og:description>前言 文章按照作者调研和开发顺序初步介绍和理解了微信小游戏和白鹭引擎，并产出了基于白鹭引擎的应用初始化程序egret-wechat-start。 以下是正文—— 微信小游戏 官方文档 如何开发和理解微</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1wen/p/9391372.html</dc:identifier>
</item>
<item>
<title>从技术转管理，我做了什么来拯救自己？ - zer0black</title>
<link>http://www.cnblogs.com/zer0Black/p/9571987.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zer0Black/p/9571987.html</guid>
<description>&lt;p&gt;我是一名新手项目经理，转项目管理岗1年半。在做管理之前，我是一名开发。也就是说，我是最常见的技术转管理了。&lt;/p&gt;
&lt;p&gt;最开始，我极度不适应这个岗位。很累，但是不见成效。经过一年多的摸索，我终于在工作中总结出了一些心得，一些套路。所以我想给技术转管理的同学们讲一讲：&lt;br/&gt;我做了什么，来拯救自己&lt;/p&gt;
&lt;h2 id=&quot;个人背景和公司背景&quot;&gt;个人背景和公司背景&lt;/h2&gt;
&lt;p&gt;1.目前为止工作4年半，也就是说，我做了3年开发，1年半管理&lt;br/&gt;2.我是一名野生程序员（就是非计算机专业毕业）&lt;br/&gt;3.我写过Android、iOS、web页面、java后端、python后端等等，看起来像传说中的全栈程序员。但其实心知肚明，我就是那种啥都会但啥也不行的程序员&lt;br/&gt;4.公司此前做产品，后来在产品的基础上转型外包扩大规模&lt;br/&gt;5.公司转型的基础上，我也转型成了管理&lt;br/&gt;6.我司项目经理是一个专门的职位，负责项目管理、技术架构、客户对接。总之项目的一切相关问题，包括技术问题，都由项目经理负责&lt;/p&gt;
&lt;h2 id=&quot;我做了什么&quot;&gt;我做了什么&lt;/h2&gt;
&lt;h4 id=&quot;事必躬亲会毁了团队也会毁了自己&quot;&gt;事必躬亲，会毁了团队也会毁了自己&lt;/h4&gt;
&lt;p&gt;这恐怕是所有从技术转管理的人，都会犯的通病。我刚开始带团队的时候，核心代码都要自己写。然后看同事进度的时候总是嫌这个慢，那个不行的。看不下去了索性自己上手吭哧吭哧写好。弄得自己非常疲惫。&lt;/p&gt;
&lt;p&gt;通常技术能力强的人，更有机会转型管理岗。所以在带团队的过程中，总是情不自禁的亲自动手完成别人应该做的事情。最终结果就是总会替代同事做他们自己本应该做的事情。&lt;/p&gt;
&lt;p&gt;但这个行为对管理者来说，只会让管理者越来越疲惫。而对整个团队来说，更是温水煮青蛙，一步一步把团队带进深渊。管理者负担太多工作，导致团队长期无法成长。轻则导致管理者累崩。重则导致项目崩塌、团队分崩离析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;我应该怎么办：&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;实际上，影响别人去做好一件事，比亲自去做要难的多。而我处理这个问题的方式&lt;br/&gt;1.忍住自己亲自动手的心理&lt;br/&gt;2.复杂任务拆解细化，分派任务时明确任务目标和验收标准&lt;br/&gt;3.分派任务时给予同事鼓励，对他们保持充分信任&lt;br/&gt;4.有难度的任务，提供一定的辅助或者培训&lt;/p&gt;
&lt;h4 id=&quot;多想多说多做&quot;&gt;多想、多说、多做&lt;/h4&gt;
&lt;p&gt;我开始带团队的时候，一直忙于处理各种各样的项目问题，写代码、沟通需求、进度汇报、现场演示。大部分时间都埋头于项目本身，以为只要把项目做好，按时交付就行。做的太多， 导致思考的时间少了，对团队同事的关注也就少了。&lt;/p&gt;
&lt;p&gt;而一个团队领导者，多做是应该的，更重要的是多思考，多说&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;思考什么：&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;1.项目干系人是否清楚，干系人不清楚会导致项目管理混乱，出的东西不满足要求&lt;br/&gt;2.需求是否合理，需求是否可以优化、技术架构是否满足需求&lt;br/&gt;3.功能是否拆解到位，任务分派是否可合理&lt;br/&gt;4.若尝试新技术，是否有把握在出问题的时候力挽狂澜&lt;br/&gt;5.团队成员状态如何，要如何激励他们&lt;br/&gt;6.项目流程是否合理，如何改进&lt;br/&gt;7.项目成本如何控制，时间节点如何把握，质量如何保证&lt;/p&gt;
&lt;p&gt;以上都是我目前每个项目都会思考的问题。项目管理者一定要告诫自己：&lt;code&gt;不要用战术上的勤奋掩盖战略上的懒惰&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;说什么：&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;1.需求不清楚要问&lt;br/&gt;2.需求可以优化要说，不要闷声发大财，坑的是自己&lt;br/&gt;3.有困难处理不了要及时汇报给领导，悉知客户&lt;br/&gt;4.团队成员有问题要给予正确指导，而不是放任自由&lt;br/&gt;5.进度情况、项目情况要积极和客户保持沟通&lt;/p&gt;
&lt;h4 id=&quot;不仅是监督更要是指引&quot;&gt;不仅是监督，更要是指引&lt;/h4&gt;
&lt;p&gt;“那个功能写完了吗？”；“这个功能怎么还没做好”；“你这个东西什么时候能够写完”。&lt;/p&gt;
&lt;p&gt;以上是我日常工作中最常做的事情，即便到了目前，我依然在做这些事。监督催促同事干活！每天像个监工一样，漫步在同事周围，监督他们的进度，在他们耳边逼逼叨。&lt;/p&gt;
&lt;p&gt;但我认为，催促同事干活的不应该是项目经理，而是项目流程，是规则。每个人明确自己的角色，各司其职，由规则约束着大家前行。而不是简单靠项目经理赶着大家往前走。&lt;/p&gt;
&lt;p&gt;但我并没有做好这个工作，目前还是处于制定计划、监督执行的死循环中。对于规则、流程只是有个模糊的想法，还不成型，也未经试验。暂不与大家分享。&lt;/p&gt;
&lt;h4 id=&quot;救火能力固然重要但更要防范于未然&quot;&gt;救火能力固然重要，但更要防范于未然&lt;/h4&gt;
&lt;p&gt;我由技术转管理的初期，最擅长的事情就是技术。所以一直在项目中充当救火队员的角色。&lt;/p&gt;
&lt;p&gt;有突发情况？我自己来；没有人能攻克技术难点？那我自己来；开发了很久，发现需求理解错误？咔咔咔自己一顿改；总之就是这有问题，咔咔咔自己一顿弄，那有问题，嗒嗒嗒自己一顿搞。总用自己的技术能力挽救项目中的各种突发情况。&lt;/p&gt;
&lt;p&gt;而作为一个项目管理者，救火能力固然重要，要在关键时刻能够站出来力挽狂澜。但更重要的，我想是如何去避免突发情况吧。而要避免突发情况，就要思考如何做好风险管理。提早做好准备，把可能出现的未知风险扼杀在襁褓中。&lt;/p&gt;
&lt;p&gt;在IT项目管理中，我认为风险主要存在于以下几点，应思考准备以便规避风险：&lt;br/&gt;1.需求变更。开发中需求变更是难免的，但如何控制需求变更，如何管理需求变更是我们着重要考虑的问题。SCALPEL方法，大家可以了解一下&lt;br/&gt;2.项目干系人不清楚，导致项目需求分歧&lt;br/&gt;3.技术难点预估不足。总是会存在开发过程中才发某项功能无法实现或者实现成本过高，这主要是由于前期对需求理解不足，对自我或团队太自信造成的&lt;br/&gt;4.计划制定问题。开发计划制定有问题，可能由于错误的估计了团队的能力，项目的难度造成的。计划风险通常是由项目经理自己造成，需自我强化、学习、思考来避免此问题&lt;br/&gt;5.组织成员问题。开发成员不足、人员离职、其它项目需紧急支援人手、团队沟通不畅都可能引起此问题&lt;br/&gt;6.流程风险。过于流程化，导致流程工作占用太多开发时间，流程和灵活是一对冲突的概念。如何解决项目管理中流程化和灵活度的问题，我认为是项目经理较重要的能力之一&lt;br/&gt;7.性能问题。开发过程中，最怕的是功能做完了，最后发现性能不行。导致前期开发工作全白费。所以在需求阶段，软件的用户量，数据量都是要考虑在内的。在开发之初，就要在程序设计过程中将性能问题考虑进去&lt;/p&gt;
&lt;h4 id=&quot;保持内心强大&quot;&gt;保持内心强大&lt;/h4&gt;
&lt;p&gt;项目管理是一个磨人的工作。虽然外面说要做风险管理，但突发情况避免不了。一个合格的项目管理者，要有泰山崩于前而色不变的内心。&lt;/p&gt;
&lt;p&gt;需求变了不要紧、计划变了不要紧、成员情况发生变化不要紧。毕竟我们都知道&lt;code&gt;世界上唯一不变的就是变化&lt;/code&gt;，尽可能的给自己准备好&lt;code&gt;Plan B&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;背黑锅要上邀功也要上&quot;&gt;背黑锅要上，邀功也要上&lt;/h4&gt;
&lt;p&gt;我相信各位做开发的时候，最讨厌的就是那种黑锅你背，有功他领的leader。既然如此，希望我们也不要变成这样的人。&lt;/p&gt;
&lt;p&gt;项目经理嘛，统管这个项目的一切。项目出了问题，不管因为什么原因，都一定是项目经理的责任。你的同事可能在项目里表现不佳，你的客户可能经常变更需求。不管多少理由，都不是你甩锅的理由。有锅一定要自己扛着，所以，&lt;code&gt;背黑锅要上&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;做的好，也要说出来。超出客户预期的项目闪光点，要告诉客户团队的优秀。项目完成的不错，要告诉老板团队的优秀。让客户让老板知道你们团队做的好，下一次他们才会给你们更充分的信任。项目成员表现优秀的地方，不光要表扬，也要和上级说。你是和你团队成员接触最紧密的人，他们的有点别人不知道，但你知道。所以他们优秀的地方，要宣扬，要让别的部门知道，要让上级知道。所以&lt;code&gt;邀功也要上&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在帮派里，不能为兄弟们挡刀并引领兄弟们前进的老大是不值得追随的，弟兄们在你手下做事受尽委屈，争不了一口气，那这个老大也做不长。&lt;/p&gt;
&lt;p&gt;技术出身的管理者中，我相信&lt;code&gt;背黑锅要上&lt;/code&gt;是大家都能做到的。但技术人员不善言辞，总是闷头干活，不会表达。所以要适当学会邀功，为团队邀功。希望大家都能学会&lt;code&gt;邀功也要上&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;不要抛弃技术它可能是你的救命良药&quot;&gt;不要抛弃技术，它可能是你的救命良药&lt;/h4&gt;
&lt;p&gt;做项目管理以后，尤其是像我现在这种一个人带多个项目的情况。管理工作会占用每天极多的时间。这是工作本身需要你做的，无可厚非。我想说的是，即便如此，也要保证自己对技术的学习。&lt;/p&gt;
&lt;p&gt;了解新技术也好，写写开源项目也好，总之要保持对技术的持续学习。他总能在你需要的时候帮到你。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;学如逆水行舟,不进则退&lt;/code&gt;，与大家共勉&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;总体而言，我认为一个新手项目经理，要学会以下事情：&lt;br/&gt;1.要学会带领团队成长，不要事必躬亲&lt;br/&gt;2.要多进行思考&lt;br/&gt;3.要学会风险管理&lt;br/&gt;4.要保持内心的强大&lt;br/&gt;5.要学会邀功&lt;/p&gt;
&lt;p&gt;以上，就是我想和大家分享的内容，其中很多点，我自己做的也不是很好，依然需要自我练习和努力。希望各位技术转管理的同学，都能尽快适应自己的工作。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Sep 2018 04:56:00 +0000</pubDate>
<dc:creator>zer0black</dc:creator>
<og:description>我是一名新手项目经理，转项目管理岗1年半。在做管理之前，我是一名开发。也就是说，我是最常见的技术转管理了。 最开始，我极度不适应这个岗位。很累，但是不见成效。经过一年多的摸索，我终于在工作中总结出了一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zer0Black/p/9571987.html</dc:identifier>
</item>
<item>
<title>比特币初始版本VC6.0编译 - weiwei22844</title>
<link>http://www.cnblogs.com/zhaoweiwei/p/bitcoinVC6.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaoweiwei/p/bitcoinVC6.html</guid>
<description>&lt;h2&gt;1 源码下载&lt;/h2&gt;
&lt;p&gt;github上初始版本是bitcoin-0.1.5，可以从&lt;a href=&quot;https://github.com/bitcoin/bitcoin&quot; target=&quot;_blank&quot;&gt;https://github.com/bitcoin/bitcoin&lt;/a&gt;下载，但是从网上可以找到更老版本bitcoin-0.1.0，例如可以从如下地址下载：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Dan-McG/bitcoin-0.1.0&quot;&gt;https://github.com/Dan-McG/bitcoin-0.1.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;网上可以搜到一封关于这个版本的说明邮件，内容如下&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Announcing the first release of Bitcoin, a new electronic cash&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;system that uses a peer-to-peer network to prevent double-spending.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;It's completely decentralized with no server or central authority.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;See bitcoin.org for screenshots.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Download link:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;http://downloads.sourceforge.net/bitcoin/bitcoin-0.1.0.rar&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Windows only for now. Open source C++ code is included.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;- Unpack the files into a directory&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;- Run BITCOIN.EXE&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;- It automatically connects to other nodes&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If you can keep a node running that accepts incoming connections,&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;you'll really be helping the network a lot. Port 8333 on your&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;firewall needs to be open to receive incoming connections.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The software is still alpha and experimental. There's no guarantee&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;the system's state won't have to be restarted at some point if it&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;becomes necessary, although I've done everything I can to build in&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;extensibility and versioning.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;You can get coins by getting someone to send you some, or turn on&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Options-&amp;gt;Generate Coins to run a node and generate blocks. I made&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;the proof-of-work difficulty ridiculously easy to start with, so&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;for a little while in the beginning a typical PC will be able to&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;generate coins in just a few hours. It'll get a lot harder when&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;competition makes the automatic adjustment drive up the difficulty.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Generated coins must wait 120 blocks to mature before they can be&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;spent.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;There are two ways to send money. If the recipient is online, you&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;can enter their IP address and it will connect, get a new public&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;key and send the transaction with comments. If the recipient is&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;not online, it is possible to send to their Bitcoin address, which&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;is a hash of their public key that they give you. They'll receive&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;the transaction the next time they connect and get the block it's&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;in. This method has the disadvantage that no comment information&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;is sent, and a bit of privacy may be lost if the address is used&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;multiple times, but it is a useful alternative if both users can't&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;be online at the same time or the recipient can't receive incoming&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;connections.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Total circulation will be 21,000,000 coins. It'll be distributed&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;to network nodes when they make blocks, with the amount cut in half&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;every 4 years.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;first 4 years: 10,500,000 coins&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;next 4 years: 5,250,000 coins&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;next 4 years: 2,625,000 coins&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;next 4 years: 1,312,500 coins&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;etc...&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;When that runs out, the system can support transaction fees if&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;needed. It's based on open market competition, and there will&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;probably always be nodes willing to process transactions for free.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Satoshi Nakamoto&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;该版本是用VC6.0进行编译的，结合源码中的说明文档可知，完成编译还需如下依赖库&lt;/p&gt;
&lt;p&gt;wxWidgets &lt;a href=&quot;http://www.wxwidgets.org/downloads/&quot;&gt;http://www.wxwidgets.org/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OpenSSL &lt;a href=&quot;http://www.openssl.org/source/&quot;&gt;http://www.openssl.org/source/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Berkeley DB &lt;a href=&quot;http://www.oracle.com/technology/software/products/berkeley-db/index.html&quot;&gt;http://www.oracle.com/technology/software/products/berkeley-db/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Boost &lt;a href=&quot;http://www.boost.org/users/download/&quot;&gt;http://www.boost.org/users/download/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;2 编译依赖库&lt;/h2&gt;
&lt;h3&gt;2.1 编译wxWidgets&lt;/h3&gt;
&lt;p&gt;初始版本中界面库用的是wxWidgets，这里选用版本wxWidgets-2.8.10，编译时尽量使用和该文中相同的版本，否则可能会有问题，该库编译过程很简单，直接用VC6.0打开图中静态工程wx.dsw，并编译相应的Debug和Release版本即可，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465567/201809/465567-20180903101826187-50635644.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;424&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2 编译OpenSSL&lt;/h3&gt;
&lt;p&gt;OpenSSL 是一个安全套接字层密码库，囊括主要的加密算法，比特币源码直接使用了该库中的相关加密算法。这里选用的是源码说明文件readme.txt中的版本openssl-0.9.8h.tar.gz，编译OpenSSL需要安装nasm和ActivePerl可参考如下网址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/passedbylove/p/5977777.html&quot;&gt;https://www.cnblogs.com/passedbylove/p/5977777.html&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://blog.csdn.net/liangyuannao/article/details/7788004&quot;&gt;https://blog.csdn.net/liangyuannao/article/details/7788004&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打开命令行并进入到源码目录，执行如下命令即可完成编译&lt;/p&gt;
&lt;p&gt;&lt;em&gt;perl Configure VC-WIN32&lt;br/&gt;&lt;/em&gt;&lt;em&gt;ms\do_ms.bat&lt;br/&gt;&lt;/em&gt;&lt;em&gt;nmake -f ms\ntdll.mak&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;em&gt;2.3 编译Berkeley DB&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;Berkeley DB是一个开源的文件数据库，比特币借助该库实现文件存取，这里选用的版本是db-4.7.25.tar.gz，直接用VC6.0打开图中工程，并编译其中Win32 Debug x86和Win32 Release x86版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465567/201809/465567-20180903103125688-556760539.png&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;392&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.4 编译Boost&lt;/h3&gt;
&lt;p&gt;这里选用版本boost_1_34_1.tar.gz，更新的版本用VC6.0编译会有很多编译错误。&lt;br/&gt;（1）生成bjam.exe，打开cmd命令行，进入到boost_1_34_1\tools\jam\src目录下，运行build.bat，build.bat会运行VCVARS32.BAT，设置环境变量，并编译生成bjam，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465567/201809/465567-20180903104126586-394899852.png&quot; alt=&quot;&quot; width=&quot;1076&quot; height=&quot;229&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果系统安装多个VS版本，可以通过注释其他版本来选择VC6.0版本生成bjam.exe&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465567/201809/465567-20180903104527414-1218245044.png&quot; alt=&quot;&quot; width=&quot;708&quot; height=&quot;718&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终会在目录下生成一个名为bin.ntx86的文件夹里面包含一个bjam.exe可执行文件，将其拷贝到boost_1_34_1目录下。&lt;/p&gt;
&lt;p&gt;（2）有了bjam之后，运行 bjam --toolset=msvc-6.0进行编译，bjam --toolset=msvc-6.0 install 生成相应的头文件（include）和 库文件（lib），默认生成在C:\boost下面。&lt;/p&gt;
&lt;h2&gt;3 新建VC工程并编译&lt;/h2&gt;
&lt;h3&gt;3.1 新建工程&lt;/h3&gt;
&lt;p&gt;新建Win32应用工程bitcoin&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465567/201809/465567-20180903105357883-2121763022.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2 添加源码文件&lt;/h3&gt;
&lt;p&gt; 将源码中的头文件源文件及资源文件添加到新建的工程中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465567/201809/465567-20180903111103729-2011462372.png&quot; alt=&quot;&quot; width=&quot;310&quot; height=&quot;536&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.3 修改编译选项&lt;/h3&gt;
&lt;p&gt;将第2节编译好的库文件及相关头文件拷贝到工程目录下（如果不拷贝到工程目录，则添加头文件目录时请填写相应的文件路径），添加相应库头文件路径到附加头文件目录，添加宏定义D__WXMSW__,__WXDEBUG__到预定义中；添加相应的库文件目录到附加文件目录，添加相应的依赖库文件，libeay32.lib libdb47sd.lib wxmsw28d_richtext.lib wxmsw28d_html.lib wxmsw28d_core.lib wxbase28d.lib wxtiffd.lib wxjpegd.lib wxpngd.lib wxzlibd.lib wxregexd.lib wxexpatd.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib winmm.lib shell32.lib comctl32.lib ole32.lib oleaut32.lib uuid.lib rpcrt4.lib advapi32.lib ws2_32.lib，改Code Generation中Use run-time library为Debug Multithreaded DLL，在编译选项中添加/Zm300，否则编译时会有“compiler limit : internal heap limit reached; use /Zm to specify a higher limit”错误提示，在Resources设置下添加附件包含路径include，主要编译设置如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465567/201809/465567-20180903113520279-349441469.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;298&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465567/201809/465567-20180903114159054-1676948856.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;299&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465567/201809/465567-20180903120845451-1405519350.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Release版本的编译需要类似的设置，这里不在进行重复说明，已在CSDN上上传了编译好的版本，有需要的可自行下载&lt;a href=&quot;https://download.csdn.net/download/weiwei22844/10642479&quot; target=&quot;_blank&quot;&gt;https://download.csdn.net/download/weiwei22844/10642479&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Mon, 03 Sep 2018 04:31:00 +0000</pubDate>
<dc:creator>weiwei22844</dc:creator>
<og:description>用VC6.0来编译比特币的原始版本0.1.0，详细说明了所需的依赖库，及其相关编译过程！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaoweiwei/p/bitcoinVC6.html</dc:identifier>
</item>
</channel>
</rss>