<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>webpack-loader是怎样炼成的 - nobody-junior</title>
<link>http://www.cnblogs.com/imgss/p/9813868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imgss/p/9813868.html</guid>
<description>&lt;h3 id=&quot;啰嗦两句&quot;&gt;啰嗦两句&lt;/h3&gt;
&lt;p&gt;学习这件事从学习动机上来看，可以分成两种情况：主动学习和被动学习。主动学习就是，某天你浏览网页的时候，看到一个酷到没朋友的效果，赶紧打开开发者工具，看看用了什么 css 属性，用了什么库或者框架实现的，这是主动学习。&lt;/p&gt;
&lt;p&gt;还有一种是被动学习。就拿我来说，之前用 mpvue 写小程序的时候，页面的 json 配置都是写在 main.js 里面的，loader 会从 main.js 解析出对应的代码块，然后为我生成对应的配置文件。但是前两天，当我又初始化一个新项目的时候（使用的是 mpvue-loader1.1.4），这个好用的特性居然消失了，我需要在目录下自己手动建一个 json 文件写页面配置。&lt;/p&gt;
&lt;p&gt;人有这么一种本性，从不好的体验切换到好的体验很快，但是再切回去就很难受😢。所以，这回只有硬着头皮写个 webpack loader 来回归原来的体验了。实现的功能很简单，就是重新实现 mpvue 原有的功能，从 js 文件中解析出配置项的内容，并生成到对应的文件夹中。&lt;/p&gt;
&lt;h3 id=&quot;loader-是干什么的&quot;&gt;loader 是干什么的&lt;/h3&gt;
&lt;p&gt;无图言卵，先上个图：&lt;br/&gt;￼&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201810/1016471-20181018233505457-1923882168.jpg&quot; alt=&quot;1539876855690.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把 webpack 想像成一个工厂，loader 就是一个个身怀绝技的流水线工人，有的会处理 svg，有的会压缩 css 或者图片，有的会处理 less，有的会将 es6 转换为 es5。他们在 webpack 的调度下 (确切的说是 loader-runer)，井井有条的完成自己工作后，把自己处理的结果交给下一个工人，直到最后由 webpack 将他们的劳动成果生成 dist 目录下的文件。&lt;/p&gt;
&lt;p&gt;所以一个 loader 用一个函数来表示，应该是这样的：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;module.exports = function(content, map, meta) {
  return content;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们就定义了一个什么都不干还拿工资的 loader，它就是拿到内容后原样交给下一个 loader 同学。但是，它现在其实还只是一个函数 -- 因为它还没有混入 webpack loader 内部啊，现在我们帮他打入 webpack 的 loader 内部：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js

...
module: {
  rules: [
    {
      test: /\.js$/,
      include: [resolve('src'), resolve('test')],
      use: [
        {
          loader: path.resolve('path/to/my-loader.js'), // 本 loader😊
          options: {a: 1}
        },
        ... 其他 loader
      ]
    }
  ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为一个什么都不做的 loader，它在 rules 下面使用 &lt;code&gt;/\.js$/&lt;/code&gt; 这个正则表达式，告 (hu) 诉 (you) webpack 它可以处理 js 文件, 还通过 includes 字段，说明了它的业务范围只负责 src 和 test 目录下的 js 文件。&lt;/p&gt;
&lt;p&gt;现在回到上面的图，大部分 loader 还是实实在在办事的。有的可以处理文本文件，如 css 预处理，进去的是 less 语法的文件，出来的是 css 语法的文件；有的可以处理二进制文件，比如将较小的图片变成 base64 字符串。还有的 loader 买一送二，比如 mpvue-loader, 输入的是 vue 文件，但是会输出 wxss,wxml,js 三个文件。但是，这些工作仅靠 loader 自己是办不到的，它需要和 webpack 沟通。也就是说，干活是需要工具的，这个工具就是 loader 的上下文 (context)。&lt;/p&gt;
&lt;h3 id=&quot;loader-的工具箱---context&quot;&gt;loader 的工具箱 --context&lt;/h3&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://webpack.docschina.org/api/loaders/#loader-%E4%B8%8A%E4%B8%8B%E6%96%87&quot;&gt;官方文档&lt;/a&gt; 的解释，loader context 表示在 loader 内使用 this 可以访问的一些方法或属性。还是在上面的那个啥都不干 loader 上说明：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const path = require('path')
module.exports = function(content){
  console.log('resource', this.resource) // 文件路径带 query
  console.log('query', this.query)// 对应配置中的 options {a: 1}
  console.log('resourcePath', this.resourcePath)// 文件路径
  this.emitFile('main.json', JSON.stringify({hello: 'world'}))// dist目录下生成一个 json 文件
  this.emitWarning('这个 loader 啥都不干')// 会触发一个警告⚠️
  // this.emitError('这个 loader 啥都不干')// 会导致本次编译过程失败
  return content
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如上面的例子那样，有了上下文提供的工具包，loader 就可以干更多的事情而不只是对 content 进行处理，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过 this.emitError 向 webpack 抛出一个错误，中断本次编译&lt;/li&gt;
&lt;li&gt;通过 this.emitFile 生成一个新的文件，&lt;strong&gt;emitFile接受的第一个参数是相对于dist目录的文件路径&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过 this.resource 获得资源路径&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外还有很多工具，大家可以看文档了解。&lt;/p&gt;
&lt;h3 id=&quot;loader-实战&quot;&gt;loader 实战&lt;/h3&gt;
&lt;p&gt;把这些了解清楚之后，我们就可以实现之前想要的功能了：从所有文件名为 main.js 的文件中提取 export default 的内容，并在同级目录下生成一个 json 文件，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 生成前 src 目录

page
|-main.js

// 生成后 dist 目录
page
|-main.js
|-main.json&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全部代码如下，解释见注释：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;module.exports = function(source){

  if(/main\.js$/.test(this.resource)){// 只处理 main.js 文件
    let jsonPath = this.resource.replace(/.+src\//, '') +'on'// 生成 json 文件相对于 dist 目录的路径
    let re = /export\s+?default\s*(\{[\s\S]+\})/m; // 解析出文件中的 export default 代码块
    if (re.test(source)) {
      let config = eval('a=' + re.exec(source)[1]); // 将配置转成对象
      console.log(config)
      this.emitFile(jsonPath, JSON.stringify(config)); // 写到文件中
    }
  }
  return source;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是本文的全部内容了，今天参加了同学的婚礼，见了几个老同学，包括还在船厂🚢 打拼的同学。吃饭的时候聊着大家的现状，真的很开心，没有想象中的局促和无话可说。转眼毕业都三年了，时间过的真 tm 快。（完）&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 07:35:00 +0000</pubDate>
<dc:creator>nobody-junior</dc:creator>
<og:description>啰嗦两句 学习这件事从学习动机上来看，可以分成两种情况：主动学习和被动学习。主动学习就是，某天你浏览网页的时候，看到一个酷到没朋友的效果，赶紧打开开发者工具，看看用了什么 css 属性，用了什么库或者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imgss/p/9813868.html</dc:identifier>
</item>
<item>
<title>JAVA 反射 - 不该相遇在秋天</title>
<link>http://www.cnblogs.com/fengyumeng/p/9821939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengyumeng/p/9821939.html</guid>
<description>&lt;h3&gt;一、什么是反射？&lt;/h3&gt;
&lt;p&gt;能够分析类能力的程序 称之为反射&lt;/p&gt;

&lt;h3&gt;二、反射能做什么？&lt;/h3&gt;
&lt;p&gt;反射机制的功能极其强大，打个比方，假如你有反射功能，那么你不管看到谁，都可以看透对方的一切，并且还可以调用对方的肢体做一些你想做的事情。&lt;/p&gt;

&lt;h3&gt;三、怎么反射？&lt;/h3&gt;
&lt;h4&gt;1. 利用Class对象来反射&lt;/h4&gt;
&lt;p&gt;每当编译一个类，便会生成一个同名的.class文件，此文件中保存了类相关的信息，称之为Class对象。&lt;br/&gt;每当程序需要实例化一个对象时（或者是创建静态成员的引用时），JVM将使用类加载器来载入这个类的Class对象，再用Class对象来创建这个对象&lt;br/&gt;可以这么理解：每一个类都有自己的class对象，class对象是保存在文件中的，在使用的时候会被加载到JVM中，class对象是用来创建对象的模板。&lt;/p&gt;

&lt;h4&gt;2. 得到Class&lt;/h4&gt;
&lt;p&gt;第一种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一般来说 这种方式几乎不会使用&lt;/span&gt;
        User user = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;);
        Class c1 &lt;/span&gt;= user.getClass();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在程序中反射某个类的信息时一般会使用这种方式&lt;/span&gt;
        Class c2 = User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当类路径从配置文件加载的时候会使用此种方式&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无论何时使用这种方式必须提供一个错误处理器&lt;/span&gt;
            Class c3 = Class.forName(&quot;model.User&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e){
            System.out.println(&lt;/span&gt;&quot;类不存在&quot;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3. 根据Class获取对象实例&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        Class c1 = User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            Object object &lt;/span&gt;= c1.newInstance();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用无参构造器  必须是显式构造器&lt;/span&gt;
            User user =&lt;span&gt; (User) object;
            System.out.println(user.toString());
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;四、实现反射&lt;/h3&gt;
&lt;h4&gt;1. 反射构造函数&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        Class cla = User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        Constructor[] constructors &lt;/span&gt;=  cla.getConstructors();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前类的所有public构造函数
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Constructor[] constructors =  cla.getDeclaredConstructors();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前类的所有构造函数&lt;/span&gt;
        Arrays.stream(constructors).forEach((v)-&amp;gt;&lt;span&gt;{
            System.out.print(Modifier.toString(v.getModifiers()) &lt;/span&gt;+ &quot; &quot; + v.getName() + &quot;(&quot;&lt;span&gt;);
            String string &lt;/span&gt;= Arrays.stream(v.getParameterTypes()).map(Class::getName).collect(Collectors.joining(&quot;,&quot;&lt;span&gt;));
            System.out.println(string &lt;/span&gt;+ &quot;)&quot;&lt;span&gt;);
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2. 反射属性&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        Class cla = User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Field[] fields = cla.getFields();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前类包括超类的public属性&lt;/span&gt;
        Field[] fields = cla.getDeclaredFields();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前类的所有属性 包括私有属性&lt;/span&gt;
&lt;span&gt;
        Arrays.stream(fields).forEach((v)&lt;/span&gt;-&amp;gt;&lt;span&gt;{
            String s &lt;/span&gt;= Modifier.toString(v.getModifiers()) + &quot; &quot; + v.getType().getName() + &quot; &quot; +&lt;span&gt; v.getName();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                s &lt;/span&gt;+= &quot; = &quot; +&lt;span&gt; v.get(cla.newInstance());
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){

            }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                System.out.println(s);
            }
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3. 反射方法&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        Class cla = User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Method[] methods = cla.getMethods();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前对象包括超类对象包括Object对象的所有public方法&lt;/span&gt;
        Method[] methods = cla.getDeclaredMethods();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前对象的所有方法 包括私有方法&lt;/span&gt;
        Arrays.stream(methods).forEach((v)-&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Type type = v.getGenericReturnType();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;与getReturnType一样&lt;/span&gt;
            Type type =&lt;span&gt; v.getReturnType();
            System.out.print(type.getTypeName()&lt;/span&gt;+&quot; &quot;+v.getName() + &quot;(&quot;&lt;span&gt;);

            Class[] params &lt;/span&gt;=&lt;span&gt; v.getParameterTypes();
            String string &lt;/span&gt;= Arrays.stream(params).map(Class::getName).collect(Collectors.joining(&quot;,&quot;&lt;span&gt;));
            System.out.println(string &lt;/span&gt;+ &quot;)&quot;&lt;span&gt;);
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4. 调用方法&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        Class cla = User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用某个类的某个方法&lt;/span&gt;
            User user =&lt;span&gt; (User)cla.newInstance();

            Method method1 &lt;/span&gt;= cla.getMethod(&quot;setId&quot;, Long.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            method1.invoke(user,&lt;/span&gt;2L&lt;span&gt;);

            Method method11 &lt;/span&gt;= cla.getMethod(&quot;getId&quot;&lt;span&gt;);
            System.out.println(method11.invoke(user));


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态方法可传Null&lt;/span&gt;
            Method method2 = cla.getMethod(&quot;setSex&quot;, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            method2.invoke(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;,&quot;不男不女&quot;&lt;span&gt;);

            Method method22 &lt;/span&gt;= cla.getMethod(&quot;getSex&quot;&lt;span&gt;);
            System.out.println(method22.invoke(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;));

        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 五、源码分享&lt;/h3&gt;
&lt;p&gt;https://gitee.com/zhao-baolin/reflection&lt;/p&gt;

</description>
<pubDate>Sat, 20 Oct 2018 07:35:00 +0000</pubDate>
<dc:creator>不该相遇在秋天</dc:creator>
<og:description>一、什么是反射？ 能够分析类能力的程序 称之为反射 二、反射能做什么？ 反射机制的功能极其强大，打个比方，假如你有反射功能，那么你不管看到谁，都可以看透对方的一切，并且还可以调用对方的肢体做一些你想做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengyumeng/p/9821939.html</dc:identifier>
</item>
<item>
<title>深入理解Java中的同步静态方法和synchronized（class）代码块的类锁 - 真正的小明被占用了</title>
<link>http://www.cnblogs.com/SAM-CJM/p/9810820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SAM-CJM/p/9810820.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一.回顾学习内容&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 在前面几篇博客中我我们已经理解了synchronized对象锁、对象锁的重入、synchronized方法块、synchronized非本对象的代码块，&lt;/p&gt;
&lt;p&gt; 链接：&lt;a href=&quot;https://www.cnblogs.com/SAM-CJM/category/1314992.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/SAM-CJM/category/1314992.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 我们来总结一下，上面几篇讲到内容：&lt;/p&gt;
&lt;p&gt; 1.创建线程类的两个方式：继承Thread类和实现Runable接口。&lt;/p&gt;
&lt;p&gt; 2.了解了Thread类的几个基本构造器。&lt;/p&gt;
&lt;p&gt; 3.启动多线程时要使用start方法，不要直接调用run方法。&lt;/p&gt;
&lt;p&gt; 4.几个多线程中常用的方法。&lt;/p&gt;
&lt;p&gt; 5.解决一个共享资源被多个线程调用时采用了synchronized同步化一个对象的方法。&lt;/p&gt;
&lt;p&gt; 6.一个线程可以在进入一个同步化的方法时再去进入这个对象的另外一个同步化方法，这个就是对象锁的重入。&lt;/p&gt;
&lt;p&gt; 7.为了提高程序的执行效率，我们可以不去直接同步一个方法，直接同步这个方法中有关共享数据的部分，其他部分就是异步执行的。&lt;/p&gt;
&lt;p&gt; 8.上一篇讲到了使用synchronized同步一个不是本对象的代码块&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.导入问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们到现在使用的synchronized方法同步的都是非静态的方法也就是给一个对象上来一把对象锁，那么我们去给一个静态方法会有什么效果呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三.同步将静态方法、同步类资源&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其实在Java中给一个静态方法上锁就是给一个类上锁，因为类也可以是一个共享资源。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SynClass {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个类为共享资源
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个静态方法没有被同步&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fun() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        System.out.println(&lt;/span&gt;&quot;**************begin**************&quot;&lt;span&gt;);
        Thread.sleep(&lt;/span&gt;4000&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;**************end**************&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
       ThreadA t1&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadA();
       ThreadA t2&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadA();
       t1.start();
       t2.start();
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ThreadA &lt;span&gt;extends&lt;/span&gt; Thread {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建线程&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            SynClass.fun();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用静态方法&lt;/span&gt;
        } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果就是出现了线程不同步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181020121033961-797417928.png&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;97&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个静态方法被同步&lt;/span&gt;
   &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fun() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        System.out.println(&lt;/span&gt;&quot;**************begin**************&quot;&lt;span&gt;);
        Thread.sleep(&lt;/span&gt;4000&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;**************end**************&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果被同步：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181020121441031-1809972246.png&quot; alt=&quot;&quot; width=&quot;272&quot; height=&quot;101&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明类也可以是共享资源，同步静态方法也是在同步类资源。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四.类锁和对象锁的认识&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 假如我们有两把锁一把是类锁，一把是对象锁，那么会出现什么情况呢？&lt;/p&gt;
&lt;p&gt; 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SynClassObject {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个同步的静态的方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; static_fun(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类锁&lt;/span&gt;
        System.out.println(&quot;**********静态方法begin*********&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;**********静态方法end***********&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建同步的非静态方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; notStatic_fun(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象锁&lt;/span&gt;
        System.out.println(&quot;***********非静态方法begin*************&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;***********非静态方法end***************&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SynClassObjectThread1().start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SynClassObjectThread2().start();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; SynClassObjectThread1 &lt;span&gt;extends&lt;/span&gt; Thread{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个线程类调用的是同步化的静态方法&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        SynClassObject.static_fun();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; SynClassObjectThread2 &lt;span&gt;extends&lt;/span&gt; Thread{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个线程类是调用非静态方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; SynClassObject synClassObject =&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SynClassObject();
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        synClassObject.notStatic_fun();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 结果入下： &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201810/1433995-20181020123531787-1520030363.png&quot; alt=&quot;&quot; width=&quot;312&quot; height=&quot;104&quot;/&gt;明显他是不同步的，因为对象锁和类锁是两把不同的锁。&lt;/p&gt;
&lt;p&gt; 同样的道理对于同步静态代码块，也是对类资源实现了一个同步。&lt;/p&gt;

&lt;p&gt;***************************往期博客纠错******************************&lt;/p&gt;
&lt;p&gt;在此要感谢@老哥，帮助指出了&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/SAM-CJM/p/9810385.html&quot;&gt;深入理解Java并发synchronized同步化的代码块不是this对象时的操作&lt;/a&gt;中的错误，这一篇文章只是为了说明synchronized关键字同步的是对象而不是方法，我举的列子的确有失偏颇，本人水平有限，如有错误请大家斧正。&lt;/p&gt;
&lt;p&gt; ************************************************************************&lt;/p&gt;

</description>
<pubDate>Sat, 20 Oct 2018 04:49:00 +0000</pubDate>
<dc:creator>真正的小明被占用了</dc:creator>
<og:description>一.回顾学习内容 在前面几篇博客中我我们已经理解了synchronized对象锁、对象锁的重入、synchronized方法块、synchronized非本对象的代码块， 链接：https://www</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SAM-CJM/p/9810820.html</dc:identifier>
</item>
<item>
<title>白话SpringCloud | 第十一章：路由网关(Zuul)：利用swagger2聚合API文档 - oKong_趔趄的猿</title>
<link>http://www.cnblogs.com/okong/p/springcloud-eleven.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okong/p/springcloud-eleven.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;通过之前的两篇文章，可以简单的搭建一个路由网关了。而我们知道，现在都奉行&lt;code&gt;前后端分离&lt;/code&gt;开发，前后端开发的沟通成本就增加了，所以一般上我们都是通过&lt;code&gt;swagger&lt;/code&gt;进行api文档生成的。现在由于使用了统一路由网关了，都希望各微服务的&lt;code&gt;api文档&lt;/code&gt;统一的聚合在网关服务中，也方便前端用户查阅，不需要每个服务单独查看。当然了，也是可以做一个文档索引网页进行各微服务的api文档链接的。今天，我们就来讲下使用&lt;code&gt;swagger&lt;/code&gt;实现&lt;strong&gt;自动化聚合&lt;/strong&gt;微服务文档功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：关于&lt;code&gt;Swagger&lt;/code&gt;的介绍和使用，由于在之前的&lt;code&gt;SpringBoot&lt;/code&gt;系列文章中有提及，这里就不在过多阐述了，不理解的可以点击：&lt;a href=&quot;http://blog.lqdev.cn/2018/07/21/springboot/chapter-ten/&quot; title=&quot;第十章：Swagger2的集成和使用&quot;&gt;第十章：Swagger2的集成和使用&lt;/a&gt;进行查看，了解下基本用法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;zuul聚合示例&quot;&gt;Zuul聚合示例&lt;/h2&gt;
&lt;p&gt;为了实现&lt;strong&gt;自动聚合&lt;/strong&gt;功能，简单来说就是通过&lt;code&gt;Zuul&lt;/code&gt;api获取所有的路由信息，根据其具体地址进行自动转配到&lt;code&gt;Swagger&lt;/code&gt;的&lt;code&gt;SwaggerResource&lt;/code&gt;下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外，为了项目的独立，本章节创建个&lt;code&gt;maven&lt;/code&gt;多模块工程项目。整体结构如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-10-19/3969386.jpg&quot; alt=&quot;项目结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同时，会启动一个基于&lt;code&gt;Eureka&lt;/code&gt;的注册服务，具体可以查看源码：&lt;a href=&quot;https://github.com/xie19900123/spring-cloud-learning/tree/master/spring-cloud-eureka-server&quot; title=&quot;spring-cloud-eureka-server&quot;&gt;spring-cloud-eureka-server&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;微服务端&quot;&gt;微服务端&lt;/h3&gt;
&lt;p&gt;为了演示，创建两个微服务&lt;code&gt;spring-cloud-zuul-service-one&lt;/code&gt;和&lt;code&gt;spring-cloud-zuul-service-two&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里以构建&lt;code&gt;spring-cloud-zuul-service-one&lt;/code&gt;为例，&lt;code&gt;spring-cloud-zuul-service-two&lt;/code&gt;基本上是一样的，可以查看源码示例。&lt;/p&gt;
&lt;p&gt;0.引入相关依赖&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 客户端依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;       
        &amp;lt;!--swagger --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.编写swagger配置类。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * swagger配置类
 * @author oKong
 *
 */
@EnableSwagger2
@Configuration
public class SwaggerConfig {

    //是否开启swagger，正式环境一般是需要关闭的，可根据springboot的多环境配置进行设置
    @Value(value = &quot;${swagger.enabled}&quot;)
    Boolean swaggerEnabled;

    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())
                // 是否开启
                .enable(swaggerEnabled).select()
                // 扫描的路径包
                .apis(RequestHandlerSelectors.basePackage(&quot;cn.lqdev.learning.springcloud.zuul.service&quot;))
                // 指定路径处理PathSelectors.any()代表所有的路径
                .paths(PathSelectors.any()).build().pathMapping(&quot;/&quot;);
    }

    //设置api信息
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title(&quot;路由网关(Zuul)：利用swagger2聚合API文档-service-one&quot;)
                .description(&quot;oKong | 趔趄的猿&quot;)
                // 作者信息
                .contact(new Contact(&quot;oKong&quot;, &quot;https://blog.lqdev.cn/&quot;, &quot;499452441@qq.com&quot;))
                .version(&quot;1.0.0&quot;)
                .build();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.编写控制层，设置对外api服务信息,同时创建了&lt;strong&gt;请求&lt;/strong&gt;和&lt;strong&gt;响应&lt;/strong&gt;的实体类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DemoController.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * demo示例
 * @author oKong
 *
 */
@RestController
@Api(tags=&quot;servicie-one服务&quot;)
@Slf4j
public class DemoController {

    @GetMapping(&quot;/hello&quot;)
    @ApiOperation(value=&quot;demo示例&quot;)
    public DemoResp hello(DemoReq demoReq) {
        log.info(&quot;DemoReq:{}&quot;, demoReq);
        
        return DemoResp.builder()
                .code(demoReq.getCode())
                .name(demoReq.getName())
                .remark(demoReq.getRemark())
                .build();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;DemoReq.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 请求实体
 * @author oKong
 *
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@ApiModel
public class DemoReq {

    @ApiModelProperty(name=&quot;code&quot;,value=&quot;编码&quot;,example=&quot;oKong&quot;)
    String code;
    
    @ApiModelProperty(name=&quot;name&quot;,value=&quot;名称&quot;,example=&quot;趔趄的猿&quot;)
    String name;
    
    @ApiModelProperty(name=&quot;remark&quot;,value=&quot;备注&quot;,example=&quot;blog：blog.lqdev.cn&quot;)
    String remark;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;DemoResp.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 响应实体
 * @author Okong
 *
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@ApiModel
public class DemoResp {

    @ApiModelProperty(name=&quot;code&quot;,value=&quot;编码&quot;,example=&quot;oKong&quot;)
    String code;
    
    @ApiModelProperty(name=&quot;name&quot;,value=&quot;名称&quot;,example=&quot;趔趄的猿&quot;)
    String name;
    
    @ApiModelProperty(name=&quot;remark&quot;,value=&quot;备注&quot;,example=&quot;blog：blog.lqdev.cn&quot;)
    String remark;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.编写启动类。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * api服务1 示例
 * @author oKong
 *
 */
@SpringBootApplication
@EnableDiscoveryClient
@Slf4j
public class ServiceOneApplication {

    public static void main(String[] args) throws Exception {
        SpringApplication.run(ServiceOneApplication.class, args);
        log.info(&quot;spring-cloud-zuul-service-one启动!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.添加配置信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.application.name=api-service-one
server.port=789

# 注册中心地址 -此为单机模式
eureka.client.service-url.defaultZone=http://127.0.0.1:1000/eureka
# 启用ip配置 这样在注册中心列表中看见的是以ip+端口呈现的
eureka.instance.prefer-ip-address=true
# 实例名称  最后呈现地址：ip:2000
eureka.instance.instance-id=${spring.cloud.client.ip-address}:${server.port}
# swagger开关
swagger.enabled=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.启动应用，访问：http://127.0.0.1:789/swagger-ui.html 就可以单应用api文档配置成功了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-10-19/39860668.jpg&quot; alt=&quot;service-one-swagger&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;路由网关端&quot;&gt;路由网关端&lt;/h3&gt;
&lt;p&gt;创建项目：&lt;code&gt;spring-cloud-zuul-gateway&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关于zuul的使用，可以查看：&lt;a href=&quot;http://blog.lqdev.cn/2018/10/14/SpringCloud/chapter-nine&quot; title=&quot;第九章：路由网关(Zuul)的使用&quot;&gt;第九章：路由网关(Zuul)的使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;0.引入相关依赖。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;!-- zuul 依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-zuul&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 客户端依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!--swagger --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.添加相关配置信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.application.name=zuul-gateway
server.port=8899

# 注册中心地址 -此为单机模式
eureka.client.service-url.defaultZone=http://127.0.0.1:1000/eureka
# 启用ip配置 这样在注册中心列表中看见的是以ip+端口呈现的
eureka.instance.prefer-ip-address=true
# 实例名称  最后呈现地址：ip:15678
eureka.instance.instance-id=${spring.cloud.client.ip-address}:${server.port}

# swagger开启开关
swagger.enabled=true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.&lt;strong&gt;编写swagger配置类(重点)&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableSwagger2
@Configuration
@Primary //多个bean时 此类优先使用
public class SwaggerConfig implements SwaggerResourcesProvider{

    //是否开启swagger，正式环境一般是需要关闭的，可根据springboot的多环境配置进行设置
    @Value(value = &quot;${swagger.enabled}&quot;)
    Boolean swaggerEnabled;

    @Autowired
    RouteLocator routeLocator;
    
    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo())
                // 是否开启
                .enable(swaggerEnabled).select()
                // 扫描的路径包
                .apis(RequestHandlerSelectors.basePackage(&quot;cn.lqdev.learning.springcloud.zuul.swagger2&quot;))
                // 指定路径处理PathSelectors.any()代表所有的路径
                .paths(PathSelectors.any()).build().pathMapping(&quot;/&quot;);
    }

    //设置api信息
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title(&quot;路由网关(Zuul)：利用swagger2聚合API文档&quot;)
                .description(&quot;oKong | 趔趄的猿&quot;)
                // 作者信息
                .contact(new Contact(&quot;oKong&quot;, &quot;https://blog.lqdev.cn/&quot;, &quot;499452441@qq.com&quot;))
                .version(&quot;1.0.0&quot;)
                .termsOfServiceUrl(&quot;https://github.com/xie19900123/&quot;)
                .build();
    }

    @Override
    public List&amp;lt;SwaggerResource&amp;gt; get() {
        //利用routeLocator动态引入微服务
        List&amp;lt;SwaggerResource&amp;gt; resources = new ArrayList&amp;lt;&amp;gt;();
        resources.add(swaggerResource(&quot;zuul-gateway&quot;,&quot;/v2/api-docs&quot;,&quot;1.0&quot;));
        //循环 使用Lambda表达式简化代码
        routeLocator.getRoutes().forEach(route -&amp;gt;{
            //动态获取
            resources.add(swaggerResource(route.getId(),route.getFullPath().replace(&quot;**&quot;, &quot;v2/api-docs&quot;), &quot;1.0&quot;));
        });
        //也可以直接 继承 Consumer接口
//      routeLocator.getRoutes().forEach(new Consumer&amp;lt;Route&amp;gt;() {
//
//          @Override
//          public void accept(Route t) {
//              // TODO Auto-generated method stub
//              
//          }
//      });
        return resources;
    }
    
    private SwaggerResource swaggerResource(String name,String location, String version) {
        SwaggerResource swaggerResource = new SwaggerResource();
        swaggerResource.setName(name);
        swaggerResource.setLocation(location);
        swaggerResource.setSwaggerVersion(version);
        return swaggerResource;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里继承&lt;code&gt;SwaggerResourcesProvider&lt;/code&gt;接口是实现聚合api的关键，另外通过&lt;code&gt;RouteLocator&lt;/code&gt;类获取&lt;code&gt;路由&lt;/code&gt;列表是实现&lt;strong&gt;自动聚合&lt;/strong&gt;的关键。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然，这里也是可以手动进行添加的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.编写zuul内部控制层。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * zuul 内部提供对外服务示例
 * @author oKong
 *
 */
@RestController
@RequestMapping(&quot;/demo&quot;)
@Api(tags=&quot;zuul内部rest api&quot;)
public class DemoController {

    @GetMapping(&quot;/hello&quot;)
    @ApiOperation(value=&quot;demo示例&quot;,notes=&quot;demo示例&quot;)
    @ApiImplicitParam(name=&quot;name&quot;,value=&quot;名称&quot;,example=&quot;oKong&quot;)
    public String hello(String name) {
        return &quot;hi,&quot; + name + &quot;,this is zuul api! &quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.编写启动类。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * zuul使用swagger2聚合微服务api示例
 * @author oKong
 *
 */
@SpringBootApplication
@EnableZuulProxy
@EnableDiscoveryClient
@Slf4j
public class ZuulSwaggerApplication {
    public static void main(String[] args) throws Exception {
        SpringApplication.run(ZuulSwaggerApplication.class, args);
        log.info(&quot;spring-cloud-zuul-gateway启动!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.启动应用，访问：http://127.0.0.1:8899/swagger-ui.html 可以看见页面显示的是网关项目的&lt;code&gt;swagger&lt;/code&gt;文档信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-10-19/62132002.jpg&quot; alt=&quot;zuul-gate-swagger-ui&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在看看右上角的&lt;code&gt;Select a spec&lt;/code&gt;下拉框，可以看见下拉框中包含了注册中心下的所有微服务了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-10-19/28476262.jpg&quot; alt=&quot;Select a spec&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，我们切换下&lt;code&gt;api-service-one&lt;/code&gt;,可以看见&lt;code&gt;api-service-one&lt;/code&gt;的api列表了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-10-19/89055366.jpg&quot; alt=&quot;api-service-one&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切换到&lt;code&gt;api-service-two&lt;/code&gt;，也可以看见都要的api列表信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-10-19/67114356.jpg&quot; alt=&quot;api-service-two&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://piotrminkowski.wordpress.com/2017/04/14/microservices-api-documentation-with-swagger2/&quot; class=&quot;uri&quot; title=&quot;https://piotrminkowski.wordpress.com/2017/04/14/microservices-api-documentation-with-swagger2/&quot;&gt;https://piotrminkowski.wordpress.com/2017/04/14/microservices-api-documentation-with-swagger2/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本章节主要简单介绍了如何在&lt;code&gt;Zuul&lt;/code&gt;路由网关服务利用&lt;code&gt;Swagger2&lt;/code&gt;进行微服务api的聚合功能。这样查看各微服务的api文档就很方便，集中，不需要在切换不同文档地址了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;目前互联网上大佬都有分享&lt;code&gt;SpringCloud&lt;/code&gt;系列教程，内容可能会类似，望多多包涵了。&lt;strong&gt;原创不易，码字不易&lt;/strong&gt;，还希望大家多多支持。若文中有错误之处，还望提出，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;老生常谈&quot;&gt;老生常谈&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;个人QQ：&lt;code&gt;499452441&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;微信公众号：&lt;code&gt;lqdevOps&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/default/wxgzh8cm.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;http://blog.lqdev.cn/&quot; class=&quot;uri&quot; title=&quot;http://blog.lqdev.cn&quot;&gt;http://blog.lqdev.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码示例：&lt;a href=&quot;https://github.com/xie19900123/spring-cloud-learning&quot; class=&quot;uri&quot; title=&quot;https://github.com/xie19900123/spring-cloud-learning&quot;&gt;https://github.com/xie19900123/spring-cloud-learning&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下教程可能你会感兴趣：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原文地址：https://blog.lqdev.cn/2018/10/19/SpringCloud/chapter-eleven/&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 04:31:00 +0000</pubDate>
<dc:creator>oKong_趔趄的猿</dc:creator>
<og:description>前言 通过之前的两篇文章，可以简单的搭建一个路由网关了。而我们知道，现在都奉行 开发，前后端开发的沟通成本就增加了，所以一般上我们都是通过 进行api文档生成的。现在由于使用了统一路由网关了，都希望各</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okong/p/springcloud-eleven.html</dc:identifier>
</item>
<item>
<title>.NET Core开发日志——Edge.js - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9819890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9819890.html</guid>
<description>&lt;p&gt;最近在项目中遇到这样的需求：要将旧有系统的一部分业务逻辑集成到新的自动化流程工具中。这套正在开发的自动化工具使用的是C#语言，而旧有系统的业务逻辑则是使用AngularJS在前端构建而成。所以最初的考虑中有两个解决方案，一是将原有JavaScript代码改写成C#代码，以便集成；二是将所需代码抽离后将它们放置在通过Node.js搭建的RESTful API里，再在C#代码中以HttpClient调用之。&lt;/p&gt;
&lt;p&gt;但是之后发现了Edge.js这一有趣的类库，于是又多了一项选择。&lt;/p&gt;
&lt;p&gt;Edge.js的作用在于连通Node.js与.NET两个世界。通过其开发者能够在Node.js进程中调用.NET代码或者在.NET进程中调用Node.js代码。&lt;/p&gt;
&lt;p&gt;根据需求，这里是要用到在C#代码里调用Node.js，即JavaScript代码。&lt;/p&gt;
&lt;p&gt;想要了解如何使用该类库，可以从&lt;a href=&quot;https://github.com/tjanczuk/edge#how-to-nodejs-hello-world&quot;&gt;官网&lt;/a&gt;上的例子入手：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        var func = Edge.Func(@&quot;
            return function (data, callback) {
                callback(null, 'Node.js welcomes ' + data);
            }
        &quot;);

        Console.WriteLine(func(&quot;.NET&quot;).Result);
        Console.Read();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，需要通过Nuget引入它的类库，&lt;code&gt;Install-Package Edge.js&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后，使用EdgeJs中Edge类的Func静态方法。该方法需要传入Node.js中使用的代码，并且必须返回一个JavaScript函数。该函数有一个用于外部传入数据的参数，以及一个回调函数参数。此回调函数中的第一个参数为JavaScript中的异常信息，第二个是返回值。&lt;/p&gt;
&lt;p&gt;Edge.Func方法返回的是&lt;code&gt;Func&amp;lt;object,Task&amp;lt;object&amp;gt;&amp;gt;&lt;/code&gt;委托对象，意味着在.NET可以以异步的方式处理返回内容。&lt;/p&gt;
&lt;p&gt;接下来，看一下接近实际工程的例子。&lt;/p&gt;
&lt;p&gt;以下的代码是AngularJS中的常用写法。现在的计划是要把其中sayHello函数的逻辑放到C#代码中调用。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;app.controller('myCtrl', function($scope) {
    $scope.name = &quot;World&quot;;
    $scope.sayHello = function(data) {
        $scope.greeting = 'Hello ' + $scope.name + ' ' + data + '!';
    };
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一步要解决的是要考虑如何处理$scope。因为其本质上是一个对象，那么就将其定义为一个全局对象变量即可。&lt;/p&gt;
&lt;p&gt;第二步是把核心代码移入Edge的Func方法参数中。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var func = Edge.Func(@&quot;
    var $scope = {};

    $scope.name = 'World';
    $scope.sayHello = function(data) {
        $scope.greeting = 'Hello ' + $scope.name + ' ' + data + '!';
    };
&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步加入返回方法并对JavaScript代码中可能出现的异常作捕获处理。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var func = Edge.Func(@&quot;
    var $scope = {};

    $scope.name = 'World';
    $scope.sayHello = function(data) {
        $scope.greeting = 'Hello ' + $scope.name + ' ' + data + '!';
    };

    return function (data, callback) {
        var exception = null;
        try {
            $scope.sayHello(data);    
        } catch(err) {
            exception = err;
        }
        callback(exception, $scope.greeting);
    }
&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行完整代码能夠得到预期的结果。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        var func = Edge.Func(@&quot;
            var $scope = {};

            $scope.name = 'World';
            $scope.sayHello = function(data) {
                $scope.greeting = 'Hello ' + $scope.name + ' ' + data + '!';
            };

            return function (data, callback) {
                var exception = null;
                try {
                    $scope.sayHello(data);    
                } catch(err) {
                    exception = err;
                }
                callback(exception, $scope.greeting);
            }
        &quot;);

        Console.WriteLine(func(&quot;.NET&quot;).Result);
        Console.Read();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201810/991496-20181020110546577-287297611.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过上述.NET代码还未能处理JavaScript中可能发现的异常情况，比如在sayHello函数中加上一句抛出异常语句，代码在执行时则会发生预期中的错误。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;$scope.sayHello = function(data) {
    $scope.greeting = 'Hello ' + $scope.name + ' ' + data + '!';
    throw 'there is an error!';
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201810/991496-20181020111100862-85065352.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此更好地做法是在.NET代码里也加上相应的异常处理。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        try
        {
            var func = Edge.Func(@&quot;
                var $scope = {};

                $scope.name = 'World';
                $scope.sayHello = function(data) {
                    $scope.greeting = 'Hello ' + $scope.name + ' ' + data + '!';
                    throw 'there is an error!';
                };

                return function (data, callback) {
                    var exception = null;
                    try {
                        $scope.sayHello(data);    
                    } catch(err) {
                        exception = err;
                    }
                    callback(exception, $scope.greeting);
                }
            &quot;);
            Console.WriteLine(func(&quot;.NET&quot;).Result);
        }
        catch (Exception ex)
        {
            // 处理异常
        }

        Console.Read();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种方法比直接翻译JavaScript代码的解决方案要更加节省工时，而且可以避免很多在翻译语言过程中可能会产生的Bug。而与第二种建立Node.js Restful API的方式相比，又少了额外布署服务的工作。所以综合考虑下来，是十分适合实际需求的一种方案。&lt;/p&gt;
&lt;p&gt;唯一令人遗憾的是，Edge.js目前在.NET代码调用Node.js代码方面还不支持.NET Core。希望官网所述的coming soon能够尽早到来。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201810/991496-20181020112426973-60490930.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 03:28:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>最近在项目中遇到这样的需求：要将旧有系统的一部分业务逻辑集成到新的自动化流程工具中。这套正在开发的自动化工具使用的是C 语言，而旧有系统的业务逻辑则是使用AngularJS在前端构建而成。所以最初的考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9819890.html</dc:identifier>
</item>
<item>
<title>Java入门系列-17-多态 - 极客大全</title>
<link>http://www.cnblogs.com/AIThink/p/9821017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AIThink/p/9821017.html</guid>
<description>&lt;p&gt;这篇文章贯穿游戏中的一些功能带你掌握多态的使用&lt;/p&gt;
&lt;h2 id=&quot;为什么要使用多态&quot;&gt;为什么要使用多态&lt;/h2&gt;
&lt;p&gt;在一款对战类游戏中(如有雷同纯属巧合)，有两个不同的法师英雄：小乔、妲己。&lt;br/&gt;两个法师英雄的都有攻击的方法，小乔的攻击伤害为10，消耗魔法20。妲己的攻击伤害为15，消耗魔法30。玩家可以操作两个英雄进行攻击，下面看看实现的代码。&lt;/p&gt;
&lt;p&gt;父类-英雄：&lt;code&gt;whyusepolymorphic.Hero.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

public class Hero {
    private int magicPoint;//魔法值
    private int hurt;//伤害
    private String name;//姓名
    
    public Hero(int magicPoint, int hurt, String name) {
        super();
        this.magicPoint = magicPoint;
        this.hurt = hurt;
        this.name = name;
    }

    public int getMagicPoint() {
        return magicPoint;
    }

    public void setMagicPoint(int magicPoint) {
        this.magicPoint = magicPoint;
    }
    
    //省略属性的 getter 和 setter 方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子类-小乔：&lt;code&gt;whyusepolymorphic.LittleJoe.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

public class LittleJoe extends Hero {

    public LittleJoe(int magicPoint, int hurt, String name) {
        super(magicPoint, hurt, name);
    }

    //攻击的方法
    public void attack() {
        System.out.println(this.getName()+&quot; 发动攻击，伤害为：&quot;+this.getHurt()
        +&quot;。消耗 20的魔法值&quot;);
        this.setMagicPoint(getMagicPoint()-20);//魔法值-20
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子类-妲己：&lt;code&gt;whyusepolymorphic.Daji.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

public class Daji extends Hero{

    public Daji(int magicPoint, int hurt, String name) {
        super(magicPoint, hurt, name);
    }
    
    public void attack() {
        System.out.println(this.getName()+&quot; 发动攻击，伤害为：&quot;+this.getHurt()
        +&quot;。消耗 30的魔法值&quot;);
        this.setMagicPoint(getMagicPoint()-30);//魔法值-30
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;玩家：&lt;code&gt;whyusepolymorphic.Player.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

public class Player {
    public void play(LittleJoe littleJoe) {
        littleJoe.attack();
    }
    public void play(Daji daji) {
        daji.attack();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码完整的实现了要求中的功能，那我们知道英雄不可能就这几个，后期如果添加新的魔法英雄，伤害不一样，怎么办？&lt;/p&gt;
&lt;p&gt;我们可以添加新的类，实现攻击的方法，修改玩家类添加操作英雄的方法。这个方式可以完成 Hero 扩展的需求，但是后面有更多的 Hero 添加进来，我们维护起来就不是那么方便了。&lt;/p&gt;
&lt;p&gt;研究上面的代码我们发现，Player 类中的 play 方法的参数都是 Hero 类的子类，能否使用一个 play(Hero hero) 方法操作所有的英雄？使用多态就能够实现这种优化设计。&lt;/p&gt;
&lt;h2 id=&quot;什么是多态&quot;&gt;什么是多态&lt;/h2&gt;
&lt;p&gt;简明扼要，多态就是多种形态。在自然界中碳的多态就有石墨、钻石等，剪这个动作就有剪纸、剪头发等。同一个操作，由于条件的不同，产生的结果也不同。&lt;/p&gt;
&lt;p&gt;那么在程序中的多态，就是指同一个引用类型，使用不同的实例而执行不同的操作(父类引用指定子类对象 &lt;code&gt;Hero h=new Daji();&lt;/code&gt;)。&lt;/p&gt;
&lt;h2 id=&quot;如何实现多态&quot;&gt;如何实现多态&lt;/h2&gt;
&lt;p&gt;实现多态的步骤：&lt;/p&gt;
&lt;p&gt;1.编写具有&lt;strong&gt;继承关系&lt;/strong&gt;的父类和子类&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;子类重写父类方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.使用&lt;strong&gt;父类的引用指向子类的对象&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;父类作为方法形参实现多态&quot;&gt;父类作为方法形参实现多态&lt;/h3&gt;
&lt;p&gt;使用多态优化上面代码&lt;/p&gt;
&lt;p&gt;修改 Hero.java 添加攻击的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

public class Hero {
    //省略属性和构造方法
    
    //攻击的方法
    public void attack() {
        System.out.println(this.getName()+&quot; 发动攻击，伤害为：&quot;+this.getHurt()
        +&quot;。消耗 20的魔法值&quot;);
        this.setMagicPoint(getMagicPoint()-20);//魔法值-20
    }
    //省略 getter 和 setter 方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个子类不用修改&lt;/p&gt;
&lt;p&gt;修改玩家类 Player.java 将 play方法的参数设为父类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

public class Player {
    public void play(Hero hero) {
        hero.attack();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改测试类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

public class TestPlay {
    public static void main(String[] args) {
        Player p=new Player();
        Hero daji=new Daji(100,15,&quot;妲己&quot;);
        p.play(daji);
        System.out.println(daji.getName()+&quot; 剩余魔法：&quot;+daji.getMagicPoint());
        Hero littleJoe=new LittleJoe(100,10,&quot;小乔&quot;);
        p.play(littleJoe);
        System.out.println(littleJoe.getName()+&quot; 剩余魔法：&quot;+littleJoe.getMagicPoint());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;父类作为返回值实现多态&quot;&gt;父类作为返回值实现多态&lt;/h3&gt;
&lt;p&gt;玩家购买英雄使用多态实现，购买的方法有返回值，返回购买后的英雄，父类作为返回值实现这个功能。&lt;/p&gt;
&lt;p&gt;修改玩家类 Player.java 添加获取英雄的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

public class Player {
    public void play(Hero hero) {
        hero.attack();
    }
    
    public Hero getHero(int id) {
        if(1==id) {
            return new Daji(100,15,&quot;妲己&quot;);
        }else if(2==id){
            return new LittleJoe(100,10,&quot;小乔&quot;);
        }else {
            System.out.println(&quot;没有这个英雄&quot;);
            return null;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

import java.util.Scanner;

public class TestPlay {
    public static void main(String[] args) {
        Player p=new Player();
        System.out.println(&quot;欢迎来到英雄商店，请选择要购买的英雄：1.妲己2.小乔&quot;);
        Scanner input=new Scanner(System.in);
        int id=input.nextInt();
        Hero h=p.getHero(id);
        if(null!=h) {
            h.attack();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;父类到子类的转换&quot;&gt;父类到子类的转换&lt;/h2&gt;
&lt;p&gt;如果子类中有一些子类特有的方法，父类引用不能调用子类的特有的方法。&lt;/p&gt;
&lt;p&gt;向 Daji.java 中添加一个方法 queenWorship&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

public class Daji extends Hero{
    //省略构造方法及之前其他方法
    public void queenWorship() {
        System.out.println(&quot;释放大招：女王崇拜&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向 LittleJoe.java 中添加一个方法 dazzlingStar&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

public class LittleJoe extends Hero {
    //省略构造方法及之前其他方法
    public void dazzlingStar() {
        System.out.println(&quot;释放大招：星华缭乱&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Player.java 中添加 bigMove 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package whyusepolymorphic;

public class Player {
    //省略构造方法及之前其他方法
    public void bigMove(Hero hero) {
        hero.dazzlingStar();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现代码 &lt;code&gt;hero.dazzlingStar();&lt;/code&gt; 报错&lt;/p&gt;
&lt;p&gt;那么这个时候就需要将父类转换为子类(强制类型转换)&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Hero joe=new LittleJoe(100,10,&quot;小乔&quot;);
Daji daji=(Daji) joe;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是直接这样写也会报错，用 instanceof 运算符可以保证不会转换错误&lt;/p&gt;
&lt;p&gt;语法：&lt;br/&gt;&lt;code&gt;对象 instanceof 类或接口&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;instanceof通常和强制类型转换结合使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改 Player.java 中的 bigMove 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void bigMove(Hero hero) {
        if (hero instanceof Daji) {
            ((Daji)hero).queenWorship();
        }else if(hero instanceof LittleJoe) {
            ((LittleJoe)hero).dazzlingStar();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 main 方法中编写测试代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Player p=new Player();
p.bigMove(new LittleJoe(100,10,&quot;小乔&quot;));
p.bigMove(new Daji(100,15,&quot;妲己&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本人能力和水平有限，欢迎在文章下方给建议&lt;/p&gt;
&lt;p&gt;搜索关注公众号「享智同行」，第一时间获取技术干货&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 03:20:00 +0000</pubDate>
<dc:creator>极客大全</dc:creator>
<og:description>这篇文章贯穿游戏中的一些功能带你掌握多态的使用 为什么要使用多态 在一款对战类游戏中(如有雷同纯属巧合)，有两个不同的法师英雄：小乔、妲己。 两个法师英雄的都有攻击的方法，小乔的攻击伤害为10，消耗魔</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AIThink/p/9821017.html</dc:identifier>
</item>
<item>
<title>linux每日命令(1)：ls命令 - 听风。</title>
<link>http://www.cnblogs.com/huchong/p/9820876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huchong/p/9820876.html</guid>
<description>&lt;p&gt;ls命令是linux下最常用的命令。ls命令就是list的缩写缺省下ls用来打印出当前目录的清单如果ls指定其他目录那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。ls 命令在日常的linux操作中用的很多!&lt;/p&gt;

&lt;p&gt;ls [选项] [目录名]&lt;/p&gt;

&lt;p&gt;列出目标目录中所有的子目录和文件。（不包含.开头的文件）&lt;/p&gt;

&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;25&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-g&lt;/td&gt;
&lt;td&gt;类似 -l,但不列出所有者&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-o&lt;/td&gt;
&lt;td&gt;类似 -l,显示文件的除组信息外的详细信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;列出目录下的所有文件，包括以 . 开头的文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-A&lt;/td&gt;
&lt;td&gt;同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-F&lt;/td&gt;
&lt;td&gt;使得ls命令可以在显示子目录的时候在它的文件名之后加上一个斜线(“/”)字符。而文件后面的星号(“*”)字符表示这是一个可执行程序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;–reverse 依相反次序排列&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-R&lt;/td&gt;
&lt;td&gt;–recursive 同时列出所有子目录层&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;以文件修改时间排序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-S&lt;/td&gt;
&lt;td&gt;根据文件大小排序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;根据 ctime(文件状态最后更改的时间) 排序；配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序；配合-lt:根据 ctime 排序及显示 ctime&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;配合 -lt:显示访问时间而且依访问时间排序；配合 -l:显示访问时间但根据名称排序；否则：根据访问时间排序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-U&lt;/td&gt;
&lt;td&gt;不进行排序;依文件系统原有的次序列出项目&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;根据版本进行排序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-h&lt;/td&gt;
&lt;td&gt;以容易理解的格式列出文件大小 (例如 1K 234M 2G)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;–si&lt;/td&gt;
&lt;td&gt;类似 -h,但文件大小取 1000 的次方而不是 1024&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-k&lt;/td&gt;
&lt;td&gt;以 k 字节的形式表示文件的大小。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;以块大小为单位列出所有文件的大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-m&lt;/td&gt;
&lt;td&gt;所有项目以逗号分隔，并填满整行行宽&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-w&lt;/td&gt;
&lt;td&gt;自行指定屏幕宽度而不使用目前的数值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-x&lt;/td&gt;
&lt;td&gt;逐行列出项目而不是逐栏列出&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-X&lt;/td&gt;
&lt;td&gt;根据扩展名排序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-1&lt;/td&gt;
&lt;td&gt;每行只列出一个文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;–help&lt;/td&gt;
&lt;td&gt;显示此帮助信息并离开&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;–version&lt;/td&gt;
&lt;td&gt;显示版本信息并离开&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2 id=&quot;列出homehc文件夹下的所有文件和目录的详细资料&quot;&gt;1：列出/home/hc文件夹下的所有文件和目录的详细资料&lt;/h2&gt;
&lt;p&gt;命令1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -l -R /home/hc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用 ls 命令时要注意命令的格式：在命令提示符后，首先是命令的关键字，接下来是命令参数，在命令参数之前要有一短横线“-”，所有的命令参数都有特定的作用，自己可以根据需要选用一个或者多个参数，在命令参数的后面是命令的操作对象。在以上这条命令“ ls -l -R /home/hc”中，“ls” 是命令关键字，“-l -R”是参数，“ /home/hc”是命令的操作对象。在这条命令中，使用到了两个参数，分别为“l”和“R”，当然，你也可以把他们放在一起使用，如下所示：&lt;/p&gt;
&lt;p&gt;命令2&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -lR /home/hc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种形式和上面的命令形式执行的结果是完全一样的。另外，如果命令的操作对象位于当前目录中，可以直接对操作对象进行操作;如果不在当前目录则需要给出操作对象的完整路径，例如上面的例子中，我的当前文件夹是hc文件夹，我想对home文件夹下的hc文件进行操作，我可以直接输入 ls -lR hc，也可以用 ls -lR /home/hc。&lt;/p&gt;
&lt;h2 id=&quot;列出当前目录中所有以t开头的目录的详细内容可以使用如下命令&quot;&gt;2：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：&lt;/h2&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -l t*   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。&lt;/p&gt;
&lt;h2 id=&quot;只列出文件下的子目录&quot;&gt;3：只列出文件下的子目录&lt;/h2&gt;
&lt;h3 id=&quot;列出-homehcpycharmprojects-文件下面的子目录&quot;&gt;列出 /home/hc/PycharmProjects 文件下面的子目录&lt;/h3&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -F /home/hc/PycharmProjects  |grep /$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~$ ls -F /home/hc/PycharmProjects  |grep /$
FreshOnline/
FreshOnline_env/
my_test/
py3_test/ &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;列出-homehcpycharmprojects-文件下面的子目录详细情况&quot;&gt;列出 /home/hc/PycharmProjects 文件下面的子目录详细情况&lt;/h3&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -l /home/hc/PycharmProjects | grep &quot;^d&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~$ ls -l /home/hc/PycharmProjects  | grep &quot;^d&quot;
drwxr-xr-x 9 hc hc 4096 10月 20 08:56 FreshOnline
drwxrwxr-x 6 hc hc 4096 10月 19 19:07 FreshOnline_env
drwxrwxr-x 3 hc hc 4096 10月 18 15:24 my_test
drwxrwxr-x 4 hc hc 4096 10月 18 17:58 py3_test&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;列出目前工作目录下所有名称是s-开头的档案愈新的排愈后面可以使用如下命令&quot;&gt;4：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令：&lt;/h2&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -ltr s*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~$ ls -ltr s*
总用量 8
drwxr-xr-x 5 hc hc 4096 9月  28 21:28 gnome-system-monitor
drwxr-xr-x 4 hc hc 4096 9月  29 08:39 pycharm-professional&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;列出目前工作目录下所有档案及目录目录于名称后加-可执行档于名称后加&quot;&gt;5：列出目前工作目录下所有档案及目录;目录于名称后加&quot;/&quot;, 可执行档于名称后加&quot;*&quot;&lt;/h2&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -AF&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~/PycharmProjects$ ls -AF
FreshOnline/  FreshOnline_env/  my_test/  py3_test/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;计算当前目录下的文件数和目录数&quot;&gt;6：计算当前目录下的文件数和目录数&lt;/h2&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -l * |grep &quot;^-&quot;|wc -l ---文件个数  

ls -l * |grep &quot;^d&quot;|wc -l    ---目录个数&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在ls中列出文件的绝对路径&quot;&gt;7: 在ls中列出文件的绝对路径&lt;/h2&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls | sed &quot;s:^:`pwd`/:&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~/PycharmProjects$ ls | sed &quot;s:^:`pwd`/:&quot;
/home/hc/PycharmProjects/FreshOnline
/home/hc/PycharmProjects/FreshOnline_env
/home/hc/PycharmProjects/my_test
/home/hc/PycharmProjects/py3_test
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;列出当前目录下的所有文件包括隐藏文件的绝对路径-对目录不做递归&quot;&gt;8：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归&lt;/h2&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find $PWD -maxdepth 1 | xargs ls -ld&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~/PycharmProjects$ find $PWD -maxdepth 1 | xargs ls -ld
drwxrwxr-x 6 hc hc 4096 10月 19 18:22 /home/hc/PycharmProjects
drwxr-xr-x 9 hc hc 4096 10月 20 08:56 /home/hc/PycharmProjects/FreshOnline
drwxrwxr-x 6 hc hc 4096 10月 19 19:07 /home/hc/PycharmProjects/FreshOnline_env
drwxrwxr-x 3 hc hc 4096 10月 18 15:24 /home/hc/PycharmProjects/my_test
drwxrwxr-x 4 hc hc 4096 10月 18 17:58 /home/hc/PycharmProjects/py3_test&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;递归列出当前目录下的所有文件包括隐藏文件的绝对路径&quot;&gt;9：递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径&lt;/h2&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find $PWD | xargs ls -ld &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;指定文件时间输出格式&quot;&gt;10：指定文件时间输出格式&lt;/h2&gt;
&lt;p&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -tl --time-style=full-iso&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~/PycharmProjects$ ls -tl --time-style=full-iso
总用量 16
drwxr-xr-x 9 hc hc 4096 2018-10-20 08:56:55.833765666 +0800 FreshOnline
drwxrwxr-x 6 hc hc 4096 2018-10-19 19:07:08.330876787 +0800 FreshOnline_env
drwxrwxr-x 4 hc hc 4096 2018-10-18 17:58:39.489690632 +0800 py3_test
drwxrwxr-x 3 hc hc 4096 2018-10-18 15:24:06.613354334 +0800 my_test&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ls -ctl --time-style=long-iso&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hc@hc-virtual-machine:~/PycharmProjects$ ls -ctl --time-style=long-iso
总用量 16
drwxr-xr-x 9 hc hc 4096 2018-10-20 08:56 FreshOnline
drwxrwxr-x 6 hc hc 4096 2018-10-19 19:07 FreshOnline_env
drwxrwxr-x 4 hc hc 4096 2018-10-18 17:58 py3_test
drwxrwxr-x 3 hc hc 4096 2018-10-18 15:24 my_test&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;扩展&quot;&gt;扩展：&lt;/h2&gt;
&lt;h3 id=&quot;显示彩色目录列表&quot;&gt;显示彩色目录列表&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;打开/etc/bashrc, 加入如下一行:

alias ls=&quot;ls --color&quot;

下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下:

1. 蓝色--&amp;gt;目录

2. 绿色--&amp;gt;可执行文件

3. 红色--&amp;gt;压缩文件

4. 浅蓝色--&amp;gt;链接文件

5. 灰色--&amp;gt;其他文件&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 20 Oct 2018 02:43:00 +0000</pubDate>
<dc:creator>听风。</dc:creator>
<og:description>ls命令是linux下最常用的命令。ls命令就是list的缩写缺省下ls用来打印出当前目录的清单如果ls指定其他目录那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huchong/p/9820876.html</dc:identifier>
</item>
<item>
<title>mysql系列详解四：mysql事务-技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9818520.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9818520.html</guid>
<description>&lt;p&gt;MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。&lt;/li&gt;
&lt;li&gt;事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。&lt;/li&gt;
&lt;li&gt;事务用来管理 insert,update,delete 语句&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，事务是必须满足4个条件（ACID）：：原子性（&lt;strong&gt;A&lt;/strong&gt;tomicity，或称不可分割性）、一致性（&lt;strong&gt;C&lt;/strong&gt;onsistency）、隔离性（&lt;strong&gt;I&lt;/strong&gt;solation，又称独立性）、持久性（&lt;strong&gt;D&lt;/strong&gt;urability）。&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;原子性：&lt;/strong&gt;一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;一致性：&lt;/strong&gt;在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;隔离性：&lt;/strong&gt;数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;持久性：&lt;/strong&gt;事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在 MySQL 命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;事务控制语句：&lt;/h3&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;BEGIN或START TRANSACTION；显式地开启一个事务；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改成为永久性的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;SAVEPOINT identifier；SAVEPOINT允许在事务中创建一个保存点，一个事务中可以有多个SAVEPOINT；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;RELEASE SAVEPOINT identifier；删除一个事务的保存点，当没有指定的保存点时，执行该语句会抛出一个异常；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ROLLBACK TO identifier；把事务回滚到标记点；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;SET TRANSACTION；用来设置事务的隔离级别。InnoDB存储引擎提供事务的隔离级别有READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ和SERIALIZABLE。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;MYSQL 事务处理主要有两种方法：&lt;/h3&gt;
&lt;p&gt;1、用 BEGIN, ROLLBACK, COMMIT来实现&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;BEGIN&lt;/strong&gt; 开始一个事务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ROLLBACK&lt;/strong&gt; 事务回滚&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;COMMIT&lt;/strong&gt; 事务确认&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、直接用 SET 来改变 MySQL 的自动提交模式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;SET GLOBAL AUTOCOMMIT=0&lt;/strong&gt; 禁止自动提交&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SET GLOBAL AUTOCOMMIT=1&lt;/strong&gt; 开启自动提交&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt; 准备&lt;/h2&gt;
&lt;h3&gt;切换至相应的数据库下，并查看表信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt;&lt;span&gt; use jobs;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; mysql&amp;gt; show table status like &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;teachers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\G
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; *************************** &lt;span&gt;1&lt;/span&gt;. row ***************************
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;           Name: teachers
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         Engine:  MyISAM                 &amp;lt;&amp;lt;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         Version: &lt;span&gt;10&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     Row_format: Dynamic
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;            Rows: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;  Avg_row_length: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     Data_length: &lt;span&gt;16384&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; Max_data_length: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;    Index_length: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;       Data_free: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;  Auto_increment: &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     Create_time: &lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;10&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;52&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     Update_time: &lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;10&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;18&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;     Check_time: NULL
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      Collation: utf8_general_ci
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;       Checksum: NULL
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt; Create_options: 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        Comment: 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;修改表引擎为InnoDB&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; alter table teachers engine=&lt;span&gt;innodb;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; Query OK, &lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.03&lt;/span&gt;&lt;span&gt; sec)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; Records: &lt;span&gt;1&lt;/span&gt;  Duplicates: &lt;span&gt;0&lt;/span&gt;  Warnings: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; mysql&amp;gt; show table status like &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;teachers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\G
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; *************************** &lt;span&gt;1&lt;/span&gt;. row ***************************
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;           Name: teachers
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;         Engine: InnoDB
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Version: &lt;span&gt;10&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     Row_format: Dynamic
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            Rows: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;  Avg_row_length: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     Data_length: &lt;span&gt;16384&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; Max_data_length: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;    Index_length: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;       Data_free: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;  Auto_increment: &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     Create_time: &lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;10&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     Update_time: &lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;10&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;17&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     Check_time: NULL
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;      Collation: utf8_general_ci
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;       Checksum: NULL
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt; Create_options: 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        Comment: 
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;回滚事务演示&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt;&lt;span&gt; start transaction;               &amp;lt;&amp;lt;启动事务
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; Query OK, &lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;          &amp;lt;&amp;lt;查看表信息
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; +-----+------------+-----+--------+
&lt;span&gt; 6&lt;/span&gt; | TID | Name       | Age | Gender |
&lt;span&gt; 7&lt;/span&gt; +-----+------------+-----+--------+
&lt;span&gt; 8&lt;/span&gt; |   &lt;span&gt;1&lt;/span&gt; | Song Jiang |  &lt;span&gt;45&lt;/span&gt; | M      |
&lt;span&gt; 9&lt;/span&gt; +-----+------------+-----+--------+
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; mysql&amp;gt; delete &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;           &amp;lt;&amp;lt;删除表中数据
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; Query OK, &lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;         &amp;lt;&amp;lt;查看表中数据，现在数据为空
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; Empty &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; mysql&amp;gt;&lt;span&gt; rollback;                       &amp;lt;&amp;lt;回滚事务       
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; Query OK, &lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;         &amp;lt;&amp;lt;再次查看数据，发现数据已经恢复
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; +-----+------------+-----+--------+
&lt;span&gt;23&lt;/span&gt; | TID | Name       | Age | Gender |
&lt;span&gt;24&lt;/span&gt; +-----+------------+-----+--------+
&lt;span&gt;25&lt;/span&gt; |   &lt;span&gt;1&lt;/span&gt; | Song Jiang |  &lt;span&gt;45&lt;/span&gt; | M      |
&lt;span&gt;26&lt;/span&gt; +-----+------------+-----+--------+
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;提交事务演示&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;&lt;span&gt; start transaction;                      &amp;lt;&amp;lt;启动事务
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;                 &amp;lt;&amp;lt;查询表中数据
&lt;/span&gt;+-----+------------+-----+--------+
| TID | Name       | Age | Gender |
+-----+------------+-----+--------+
|   &lt;span&gt;1&lt;/span&gt; | Song Jiang |  &lt;span&gt;45&lt;/span&gt; | M      |
+-----+------------+-----+--------+
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; insert into teachers values (&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ken&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;25&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;M&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;); &amp;lt;&amp;lt;向表中插入一些数据
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;                  &amp;lt;&amp;lt;再次查看表中数据
&lt;/span&gt;+-----+------------+-----+--------+
| TID | Name       | Age | Gender |
+-----+------------+-----+--------+
|   &lt;span&gt;1&lt;/span&gt; | Song Jiang |  &lt;span&gt;45&lt;/span&gt; | M      |
|   &lt;span&gt;2&lt;/span&gt; | ken        |  &lt;span&gt;25&lt;/span&gt; | M      |
+-----+------------+-----+--------+
&lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt;&lt;span&gt; commit;                                &amp;lt;&amp;lt;进行提交数据操作
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;                 &amp;lt;&amp;lt;数据已经生效
&lt;/span&gt;+-----+------------+-----+--------+
| TID | Name       | Age | Gender |
+-----+------------+-----+--------+
|   &lt;span&gt;1&lt;/span&gt; | Song Jiang |  &lt;span&gt;45&lt;/span&gt; | M      |
|   &lt;span&gt;2&lt;/span&gt; | ken        |  &lt;span&gt;25&lt;/span&gt; | M      |
+-----+------------+-----+--------+
&lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;设置和使用保存点演示&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
mysql&amp;gt;&lt;span&gt; start transaction;              &amp;lt;&amp;lt;启动事务
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;         &amp;lt;&amp;lt;查看表中数据
&lt;/span&gt;+-----+------------+-----+--------+
| TID | Name       | Age | Gender |
+-----+------------+-----+--------+
|   &lt;span&gt;1&lt;/span&gt; | Song Jiang |  &lt;span&gt;45&lt;/span&gt; | M      |
|   &lt;span&gt;2&lt;/span&gt; | ken        |  &lt;span&gt;25&lt;/span&gt; | M      |
+-----+------------+-----+--------+
&lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt;&lt;span&gt; savepoint ken1;                &amp;lt;&amp;lt;设置保存点
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; delete &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;          &amp;lt;&amp;lt;删除表中全部的数据
Query OK, &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;        &amp;lt;&amp;lt;查看表中的信息，现在为空
Empty &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt;&lt;span&gt; rollback to ken1;             &amp;lt;&amp;lt;回滚到刚才设置的ken1节点
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;       &amp;lt;&amp;lt;再次查看表中信息，已经回到ken1时候的状态
&lt;/span&gt;+-----+------------+-----+--------+
| TID | Name       | Age | Gender |
+-----+------------+-----+--------+
|   &lt;span&gt;1&lt;/span&gt; | Song Jiang |  &lt;span&gt;45&lt;/span&gt; | M      |
|   &lt;span&gt;2&lt;/span&gt; | ken        |  &lt;span&gt;25&lt;/span&gt; | M      |
+-----+------------+-----+--------+
&lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt;&lt;span&gt; commit;                       &amp;lt;&amp;lt;进行事务的提交，结束事务
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; teachers;       &amp;lt;&amp;lt;可以再查看一下表中信息，进行确认
&lt;/span&gt;+-----+------------+-----+--------+
| TID | Name       | Age | Gender |
+-----+------------+-----+--------+
|   &lt;span&gt;1&lt;/span&gt; | Song Jiang |  &lt;span&gt;45&lt;/span&gt; | M      |
|   &lt;span&gt;2&lt;/span&gt; | ken        |  &lt;span&gt;25&lt;/span&gt; | M      |
+-----+------------+-----+--------+
&lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;关闭自动提交&lt;/h2&gt;
&lt;p&gt;mysql中一个sql语句就是一个事务，mysql系统默认是开启了事务提交的功能，可以使用如下命令进行查看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; show &lt;span&gt;global&lt;/span&gt; variables like &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;autocommit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.01&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果想要关闭自动提交的功能，可以试下如下命令进行操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; autocommit=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&amp;gt; show &lt;span&gt;global&lt;/span&gt; variables like &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;autocommit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | OFF   |
+---------------+-------+
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 20 Oct 2018 02:37:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>MySQL 事务 MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9818520.html</dc:identifier>
</item>
<item>
<title>QT源码分析：QObject - 平凡的编程者</title>
<link>http://www.cnblogs.com/WushiShengFei/p/9820835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WushiShengFei/p/9820835.html</guid>
<description>&lt;p&gt;　　QT框架里面最大的特色就是在C++的基础上增加了元对象系统（Meta-Object System），而元对象系统里面最重要的内容就是信号与槽机制，这个机制是在C++语法的基础上实现的，使用了函数、函数指针、回调函数等概念。当然与我们自己去写函数所不同的是槽与信号机制会自动帮我们生成部分代码，比如我们写的信号函数就不需要写它的实现部分，这是因为在我们编译程序的时候，编译器会自动生成这一部分代码，当我们调用connect函数的时候，系统会自动将信号函数与槽函数相连接，于是当我们调用信号函数的时候，系统就会自动回调槽函数，不管你是在同一线程下调用或者在不同线程下调用，系统都会自动评估，并在合理的时候触发函数，以此来保证线程的安全。信号与槽机制是线程安全的，这可以使得我们在调用的时候不用再额外的增加过多保证线程同步的代码，为了实现元对象系统，QT把所有相关实现写在了QObject类中，所以当你想使用元对象系统的时候，你所写的类需要继承自QObject，包括QT自带的所有类都是继承自QObject，所以分析QObject的代码，对了解QT的元对象机制有非常大的帮助，我并不打算把QObject类的每一行代码都写下来，只想把其中比较关键的内容或者对分析QT源码有帮助的内容介绍一下。&lt;/p&gt;
&lt;p&gt;1.宏Q_OBJECT&lt;/p&gt;
&lt;p&gt;这个宏展开以后是如下定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#define Q_OBJECT \
public: \
    QT_WARNING_PUSH \
    Q_OBJECT_NO_OVERRIDE_WARNING \
    static const QMetaObject staticMetaObject; \
    virtual const QMetaObject *metaObject() const; \
    virtual void *qt_metacast(const char *); \
    virtual int qt_metacall(QMetaObject::Call, int, void **); \
    QT_TR_FUNCTIONS \
private: \
    Q_OBJECT_NO_ATTRIBUTES_WARNING \
    Q_DECL_HIDDEN_STATIC_METACALL static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); \
    QT_WARNING_POP \
    struct QPrivateSignal {}; \
QT_ANNOTATE_CLASS(qt_qobject, &quot;&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　你可以看到这个宏定义了一些函数，并且函数名都带有&lt;/span&gt;meta&lt;span&gt;，所以不难猜到这些函数和&lt;/span&gt;&lt;span&gt;QT&lt;/span&gt;&lt;span&gt;的元对象系统是有关系的，实际上你在&lt;/span&gt;&lt;span&gt;qobject.cpp&lt;/span&gt;&lt;span&gt;里面是找不到这些函数的实现的，它们的实现都在&lt;/span&gt;&lt;span&gt;moc_qobject.cpp&lt;/span&gt;&lt;span&gt;里面。&lt;/span&gt;&lt;span&gt;QT&lt;/span&gt;&lt;span&gt;的元对象系统是这样处理的，当你编译你的工程时，它会去遍历所有&lt;/span&gt;&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;文件，当发现某一个类的私有部分有声明&lt;/span&gt;&lt;span&gt;Q_OBJECT&lt;/span&gt;&lt;span&gt;这个宏时，就会自动生成一个&lt;/span&gt;&lt;span&gt;moc_*.cpp&lt;/span&gt;&lt;span&gt;的文件，这个文件会生成信号的实现函数，&lt;/span&gt;&lt;span&gt;Q_OBJECT宏&lt;/span&gt;&lt;span&gt;里面定义的那些函数也会在这个文件里面实现，并生成与类相关的元对象。这就是为什么我们定义一个信号的时候，不需要实现它，因为它的实现已经写在&lt;/span&gt;&lt;span&gt;moc_*.cpp&lt;/span&gt;&lt;span&gt;文件里面了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2.Q_PROPERTY(QString objectName READ objectName WRITE setObjectName NOTIFY objectNameChanged)&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;这个宏是定义一个属性，属性也是元对象系统的内容之一，实际上我们在做界面设计的时候经常会用到属性，比如修改Label的显示内容，需要用到Text属性，修改窗体长宽等等，在你做界面设计的时候，属性编辑框里面所显示的就是当前对象的所有属性，而这些属性的定义就是用上面的宏来定义的。实际上属性和变量是有点相似的，都是读值和写值的功能，那为什么不直接对变量操作就好了？虽然看起来相似，但是还是有不同点，第一属性可以定义为可读写的，也可以定义为只读的，比如有些数据我们只在类的内部做修改不允许在外部做修改，但是有时候又需要在外部查看这个值，就可以设置为只读属性，而变量是做不到这点的，你把变量放在public部分，那么这个变量就可以在任何地方被修改，这就破坏了类的封装性。第二属性可以定义信号，当属性变化的时候触发信号，这样我们可以在信号触发时做一些工作，比如当你设置LineEdit为readonly时，你会发现输入框的背景颜色被改变了，这就可以通过属性变化的信号来处理。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;3.Q_DECLARE_PRIVATE(QObject)&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;这个宏的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#define Q_DECLARE_PRIVATE(Class) \
    inline Class##Private* d_func() { return reinterpret_cast&amp;lt;Class##Private *&amp;gt;(qGetPtrHelper(d_ptr)); } \
    inline const Class##Private* d_func() const { return reinterpret_cast&amp;lt;const Class##Private *&amp;gt;(qGetPtrHelper(d_ptr)); } \
friend class Class##Private;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这个宏首先创建了两个内联函数，返回值都是&lt;/span&gt;QObjectPrivate *&lt;span&gt;，并且声明&lt;/span&gt;&lt;span&gt;QObjectPrivate&lt;/span&gt; &lt;span&gt;为友元类，&lt;/span&gt;&lt;span&gt;QObjectPrivate&lt;/span&gt;&lt;span&gt;这个类是在&lt;/span&gt;&lt;span&gt;qobject_p.h&lt;/span&gt;&lt;span&gt;中定义，它继承至&lt;/span&gt;&lt;span&gt;QObjectData&lt;/span&gt;&lt;span&gt;，你可以看到&lt;/span&gt;&lt;span&gt;d_func()&lt;/span&gt;&lt;span&gt;是将&lt;/span&gt;&lt;span&gt;d_prt&lt;/span&gt;&lt;span&gt;强制转换为&lt;/span&gt;&lt;span&gt;QObjectPrivate *&lt;/span&gt;&lt;span&gt;类型，而&lt;/span&gt;&lt;span&gt;d_prt&lt;/span&gt;&lt;span&gt;这个指针在&lt;/span&gt;&lt;span&gt;QObject&lt;/span&gt;&lt;span&gt;里面定义的是&lt;/span&gt;&lt;span&gt;QObjectData&lt;/span&gt;&lt;span&gt;的指针类型，所以这里可以进行强转，&lt;/span&gt;&lt;span&gt;QObjectPrivate&lt;/span&gt;&lt;span&gt;这个类主要存放&lt;/span&gt;&lt;span&gt;QOject&lt;/span&gt;&lt;span&gt;类需要用到的一些子对象，变量等。为什么要介绍这个宏，如果你有看QT源码习惯的话，&lt;/span&gt;&lt;span&gt;你会发现几乎每一个类都用到了这个宏，我们自己写的类会经常把类内部用的变量声明在private部分，但是&lt;/span&gt;&lt;span&gt;QT&lt;/span&gt;&lt;span&gt;源码并不是这样做的，它的做法是给每个类创建一个以类名&lt;/span&gt;&lt;span&gt;+Private&lt;/span&gt;&lt;span&gt;的类，例如&lt;/span&gt;&lt;span&gt;QObject&lt;/span&gt;&lt;span&gt;对应的就是&lt;/span&gt;&lt;span&gt;QObjectPrivate&lt;/span&gt;&lt;span&gt;，这个类实际上就是用来存放&lt;/span&gt;&lt;span&gt;QObject&lt;/span&gt;&lt;span&gt;需要用到的所有私有变量和私有对象，而QObject更多的是函数实现，你去看其他的源码也是如此，子对象声明在Q*Private中，而本类只实现函数&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.构造函数&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
QObject::QObject(QObject *parent)
    : d_ptr(new QObjectPrivate)
{
    Q_D(QObject);
    d_ptr-&amp;gt;q_ptr = this;
    d-&amp;gt;threadData = (parent &amp;amp;&amp;amp; !parent-&amp;gt;thread()) ? parent-&amp;gt;d_func()-&amp;gt;threadData : QThreadData::current();
    d-&amp;gt;threadData-&amp;gt;ref();
    if (parent) {
        QT_TRY {
            if (!check_parent_thread(parent, parent ? parent-&amp;gt;d_func()-&amp;gt;threadData : 0, d-&amp;gt;threadData))
                parent = 0;
            setParent(parent);
        } QT_CATCH(...) {
            d-&amp;gt;threadData-&amp;gt;deref();
            QT_RETHROW;
        }
    }
#if QT_VERSION &amp;lt; 0x60000
    qt_addObject(this);
#endif
    if (Q_UNLIKELY(qtHookData[QHooks::AddQObject]))
        reinterpret_cast&amp;lt;QHooks::AddQObjectCallback&amp;gt;(qtHookData[QHooks::AddQObject])(this);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（1）首先第一步就创建&lt;/span&gt;&lt;span&gt;d_ptr&lt;/span&gt;&lt;span&gt;指针。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Q_D(QObject);&lt;/span&gt;&lt;span&gt;这个宏你可以在&lt;/span&gt;QT&lt;span&gt;的很多源码里面看到。它展开以后是下面的样子：&lt;/span&gt;#define Q_D(Class) Class##Private * const d = d_func();&lt;/p&gt;
&lt;p&gt;　　  d_fun()&lt;span&gt;函数前面讲到了，其实就是返回&lt;/span&gt;&lt;span&gt;d_ptr&lt;/span&gt;&lt;span&gt;了。所以这个宏的意思是定义一个指针&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;指向&lt;/span&gt;&lt;span&gt;d_ptr;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）d_ptr-&amp;gt;q_ptr = this;&lt;/p&gt;
&lt;p&gt;　　 q_ptr&lt;span&gt;是&lt;/span&gt;&lt;span&gt;QOject&lt;/span&gt;&lt;span&gt;类型，这里把&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;指针赋给了它，所以使得&lt;/span&gt;&lt;span&gt;QObjectPrivate&lt;/span&gt;&lt;span&gt;可以回调&lt;/span&gt;&lt;span&gt;QOject&lt;/span&gt;&lt;span&gt;的函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（4）&lt;span&gt;初始化&lt;/span&gt;threadData&lt;/p&gt;

&lt;p&gt;5.moveToThread&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）如果要移动的线程和&lt;/span&gt;Object&lt;span&gt;本身就是同一线程，那么直接返回&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
Q_D(QObject);
    if (d-&amp;gt;threadData-&amp;gt;thread == targetThread) {
        // object is already in this thread
        return;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）&lt;span&gt;如果&lt;/span&gt;parent&lt;span&gt;不为空，不允许移动到其他线程，子类必需与父类在同一线程。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
if (d-&amp;gt;parent != 0) {
        qWarning(&quot;QObject::moveToThread: Cannot move objects with a parent&quot;);
        return;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）如果对象是窗体类，不允许移动到线程，窗体类必需在主线程运行，在子线程去直接调用窗体控件都是不安全的，可能导致程序崩溃，合理的做法是通过信号槽机制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
if (d-&amp;gt;isWidget) {
        qWarning(&quot;QObject::moveToThread: Widgets cannot be moved to a new thread&quot;);
        return;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）只有在对象所在线程才能将对象移动到另一个线程，不能在其他线程将对象移动到某个线程，这种操作是不被允许的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
QThreadData *currentData = QThreadData::current();
    QThreadData *targetData = targetThread ? QThreadData::get2(targetThread) : Q_NULLPTR;
    if (d-&amp;gt;threadData-&amp;gt;thread == 0 &amp;amp;&amp;amp; currentData == targetData) {
        // one exception to the rule: we allow moving objects with no thread affinity to the current thread
        currentData = d-&amp;gt;threadData;
    } else if (d-&amp;gt;threadData != currentData) {
        qWarning(&quot;QObject::moveToThread: Current thread (%p) is not the object's thread (%p).\n&quot;
                 &quot;Cannot move to target thread (%p)\n&quot;,
                 currentData-&amp;gt;thread.load(), d-&amp;gt;threadData-&amp;gt;thread.load(), targetData ? targetData-&amp;gt;thread.load() : Q_NULLPTR);

#ifdef Q_OS_MAC
        qWarning(&quot;You might be loading two sets of Qt binaries into the same process. &quot;
                 &quot;Check that all plugins are compiled against the right Qt binaries. Export &quot;
                 &quot;DYLD_PRINT_LIBRARIES=1 and check that only one set of binaries are being loaded.&quot;);
#endif

        return;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）线程转移&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
    //为转移线程准备，遍历所有子对象，并给每一个子对象发送一个QEvent::ThreadChange的事件。
    d-&amp;gt;moveToThread_helper();
    if (!targetData)
        targetData = new QThreadData(0);
//为转移事件上锁
    QOrderedMutexLocker locker(&amp;amp;currentData-&amp;gt;postEventList.mutex,
                               &amp;amp;targetData-&amp;gt;postEventList.mutex);

currentData-&amp;gt;ref();
//遍历所有子对象及自身，将currentData的postEventList里面的对象转移到targetData，将所有子对象及自身的threadData设置为targetData
    d_func()-&amp;gt;setThreadData_helper(currentData, targetData);
    locker.unlock();
currentData-&amp;gt;deref();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6.connect&lt;span&gt;函数&lt;/span&gt;&lt;/p&gt;


&lt;p align=&quot;justify&quot;&gt;connet&lt;span&gt;的重构函数很多，这里选择其中一个来分析。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
QMetaObject::Connection QObject::connect(const QObject *sender, const QMetaMethod &amp;amp;signal,
                                     const QObject *receiver, const QMetaMethod &amp;amp;method,
                                     Qt::ConnectionType type)
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;（1）&lt;span&gt;首选&lt;/span&gt;sender&lt;span&gt;，&lt;/span&gt;&lt;span&gt;receiver&lt;/span&gt;&lt;span&gt;不能为空，&lt;/span&gt;&lt;span&gt;signal&lt;/span&gt;&lt;span&gt;必须是&lt;/span&gt;&lt;span&gt;Signal&lt;/span&gt;&lt;span&gt;类型，也就是声明在&lt;/span&gt;&lt;span&gt;signals:&lt;/span&gt;&lt;span&gt;下面，&lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;不能为构造函数，不满足这几个条件则返回。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
if (sender == 0
            || receiver == 0
            || signal.methodType() != QMetaMethod::Signal
            || method.methodType() == QMetaMethod::Constructor) {
        qWarning(&quot;QObject::connect: Cannot connect %s::%s to %s::%s&quot;,
                 sender ? sender-&amp;gt;metaObject()-&amp;gt;className() : &quot;(null)&quot;,
                 signal.methodSignature().constData(),
                 receiver ? receiver-&amp;gt;metaObject()-&amp;gt;className() : &quot;(null)&quot;,
                 method.methodSignature().constData() );
        return QMetaObject::Connection(0);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）检查&lt;/span&gt;&lt;span&gt;signal&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;是否真实存在，在编译期即使传入的信号不存在也不会报错，在运行期会检查是否存在，所以在写&lt;/span&gt;&lt;span&gt;connect&lt;/span&gt;&lt;span&gt;函数的时候要仔细检查，尽量使用&lt;/span&gt;&lt;span&gt;&amp;amp;ClassName::functionName&lt;/span&gt;&lt;span&gt;的方式让系统自动补全，当然也可以通过&lt;/span&gt;&lt;span&gt;connect&lt;/span&gt;&lt;span&gt;的返回值来判断调用是否成功，如调用不成功则抛出异常。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int signal_index;
    int method_index;
    {
        int dummy;
        QMetaObjectPrivate::memberIndexes(sender, signal, &amp;amp;signal_index, &amp;amp;dummy);
        QMetaObjectPrivate::memberIndexes(receiver, method, &amp;amp;dummy, &amp;amp;method_index);
    }

    const QMetaObject *smeta = sender-&amp;gt;metaObject();
    const QMetaObject *rmeta = receiver-&amp;gt;metaObject();
    if (signal_index == -1) {
        qWarning(&quot;QObject::connect: Can't find signal %s on instance of class %s&quot;,
                 signal.methodSignature().constData(), smeta-&amp;gt;className());
        return QMetaObject::Connection(0);
    }
    if (method_index == -1) {
        qWarning(&quot;QObject::connect: Can't find method %s on instance of class %s&quot;,
                 method.methodSignature().constData(), rmeta-&amp;gt;className());
        return QMetaObject::Connection(0);
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;justify&quot;&gt;（3）&lt;span&gt;检查&lt;/span&gt;signal&lt;span&gt;和&lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;的参数个数和类型是否是一致的，不一致则返回。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
if (!QMetaObject::checkConnectArgs(signal.methodSignature().constData(), method.methodSignature().constData())) {
        qWarning(&quot;QObject::connect: Incompatible sender/receiver arguments&quot;
                 &quot;\n        %s::%s --&amp;gt; %s::%s&quot;,
                 smeta-&amp;gt;className(), signal.methodSignature().constData(),
                 rmeta-&amp;gt;className(), method.methodSignature().constData());
        return QMetaObject::Connection(0);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）如果你设置的连接方式为&lt;/span&gt;&lt;span&gt;QueuedConnection&lt;/span&gt;&lt;span&gt;，那么所有的参数都必须是元数据类型，自定义的类型，如自定义的结构体或枚举必须注册为元数据类型，否则无法作为信号和槽的参数，因为最终要将这些参数加入到消息队列里面。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
int *types = 0;
    if ((type == Qt::QueuedConnection)
            &amp;amp;&amp;amp; !(types = queuedConnectionTypes(signal.parameterTypes())))
        return QMetaObject::Connection(0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（&lt;/span&gt;5&lt;span&gt;）所有的检查完毕，调用&lt;/span&gt;&lt;span&gt;QMetaObject&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;函数，而&lt;/span&gt;&lt;span&gt;QMetaObject&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;会创建一个&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;的对象，这个对象会保存信号和槽的函数对象，然后会把这个&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;对象保存到&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;的一个数组中，当你触发信号的时候，因为&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;对象保存在了&lt;/span&gt;&lt;span&gt;sender&lt;/span&gt;&lt;span&gt;中，所以可以找到原来绑定的槽函数，然后回调槽函数。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
QMetaObject::Connection handle = QMetaObject::Connection(QMetaObjectPrivate::connect(
        sender, signal_index, signal.enclosingMetaObject(), receiver, method_index, 0, type, types));
    return handle;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Sat, 20 Oct 2018 02:34:00 +0000</pubDate>
<dc:creator>平凡的编程者</dc:creator>
<og:description>QT框架里面最大的特色就是在C++的基础上增加了元对象系统（Meta-Object System），而元对象系统里面最重要的内容就是信号与槽机制，这个机制是在C++语法的基础上实现的，使用了函数、函数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WushiShengFei/p/9820835.html</dc:identifier>
</item>
<item>
<title>【漫画】什么是外部排序？(绝对让你有所收获) - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/9820830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/9820830.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;西天取经的路上，一样上演着编程的乐趣.....&lt;/p&gt;
&lt;p&gt;这篇文章我将通过对话的形式带大家由浅入深着读懂外部排序。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu6t0t4Via1iaibArH97aKY0kibtKp1TibibThSwyXIibia1ZUs6M21RO56uHANg/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.583044982698962&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu6t0t4Via1iaibArH97aKY0kibtKp1TibibThSwyXIibia1ZUs6M21RO56uHANg/640&quot; data-type=&quot;png&quot; data-w=&quot;578&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwukzF8VaibeluFGrfueZSib4cE5lWhyaGQJE5k8YWR2cagOuMHeABOADZA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.7869955156950673&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwukzF8VaibeluFGrfueZSib4cE5lWhyaGQJE5k8YWR2cagOuMHeABOADZA/640&quot; data-type=&quot;png&quot; data-w=&quot;446&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuR9hA4NiaD96PoDXkd41M0lfibV1GnNPIm2DAYwAjV6BVDeLHyzBIfebw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6912878787878788&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuR9hA4NiaD96PoDXkd41M0lfibV1GnNPIm2DAYwAjV6BVDeLHyzBIfebw/640&quot; data-type=&quot;png&quot; data-w=&quot;528&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuicQT3tj9RNVHWrCZXXvDaD58JOu8dpqhDdVib1HzKMpG6LWR0FjkFfCA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5984848484848485&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuicQT3tj9RNVHWrCZXXvDaD58JOu8dpqhDdVib1HzKMpG6LWR0FjkFfCA/640&quot; data-type=&quot;png&quot; data-w=&quot;528&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuLP8fibVHW7PEQUjsC6Zoahic1UzIsG3muVgiaVMdicofbFZjDJ3zTnpANw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6605839416058394&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuLP8fibVHW7PEQUjsC6Zoahic1UzIsG3muVgiaVMdicofbFZjDJ3zTnpANw/640&quot; data-type=&quot;png&quot; data-w=&quot;548&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuiapnSNLuh8xBn8micPt7ek9scSkPXftDyZLpnxa5dK8z5LxG67E8nTzg/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.3092896174863388&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuiapnSNLuh8xBn8micPt7ek9scSkPXftDyZLpnxa5dK8z5LxG67E8nTzg/640&quot; data-type=&quot;png&quot; data-w=&quot;915&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;排序的时候我们可以&lt;strong&gt;选择快速排序或归并排序&lt;/strong&gt;等算法。为了方便，我们把排序好的2G有序数据称之为有序子串吧。接着我们可以把两个小的有序子串合并成一个大的有序子串。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu4fuW9AVL0MK7lXjI5g9o1AxBrqX4mFmGMtJBibeNiaWvZjRQ139JaDuQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.19517102615694165&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu4fuW9AVL0MK7lXjI5g9o1AxBrqX4mFmGMtJBibeNiaWvZjRQ139JaDuQ/640&quot; data-type=&quot;png&quot; data-w=&quot;994&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;读取的时候是每次读取一个int数，通过比较之后在输出。&lt;/p&gt;

&lt;p&gt;按照这个方法来回合并，总共经过三次合并之后就可以得到8G的有序子串。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu9yBzUmQhSyIrZvXTxNLglqvKQRDMwmpqNK8nlDW7nZyQJH0s6Yp7pA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6363636363636364&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu9yBzUmQhSyIrZvXTxNLglqvKQRDMwmpqNK8nlDW7nZyQJH0s6Yp7pA/640&quot; data-type=&quot;png&quot; data-w=&quot;539&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuXAx1fT1Or7WaLBMj3fhARxNaoExcicicLfTbAJj1hv8vuoJ6YnUV6YOQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6434782608695652&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuXAx1fT1Or7WaLBMj3fhARxNaoExcicicLfTbAJj1hv8vuoJ6YnUV6YOQ/640&quot; data-type=&quot;png&quot; data-w=&quot;575&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuiaMO4IWX5iaqG5EuLO39XibDibd4Cb5Ja1twicXA1ZuPxAtlITXh8TbZ9vg/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.1970260223048327&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuiaMO4IWX5iaqG5EuLO39XibDibd4Cb5Ja1twicXA1ZuPxAtlITXh8TbZ9vg/640&quot; data-type=&quot;png&quot; data-w=&quot;807&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来把12个数据分成4份，然后排序成有序子串&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu5wNzqibA6tqrqLnYoUzZ0W59ItrnNcIAricQiaJQKvCapncAbym7Up0YQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.36682242990654207&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu5wNzqibA6tqrqLnYoUzZ0W59ItrnNcIAricQiaJQKvCapncAbym7Up0YQ/640&quot; data-type=&quot;png&quot; data-w=&quot;856&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后把子串进行两两合并&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuUVGrmZsGiadvOd9PLiaaicCO47k5qky4qtNs3BJcT6MxL4C6XEcicZbfnA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.2288698955365622&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuUVGrmZsGiadvOd9PLiaaicCO47k5qky4qtNs3BJcT6MxL4C6XEcicZbfnA/640&quot; data-type=&quot;png&quot; data-w=&quot;1053&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;输出哪个元素，就在那个元素所在的有序子串再次读入一个元素&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwukPfCbssNTWOnyIXVjKwoDspDIWYBkRlia8Jfv4RbfZKHmLibL879LrZA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.2143559488692232&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwukPfCbssNTWOnyIXVjKwoDspDIWYBkRlia8Jfv4RbfZKHmLibL879LrZA/640&quot; data-type=&quot;png&quot; data-w=&quot;1017&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;继续&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwubicheVOFWlR4aa58OstGTrw1p7XSoUdOFMATOFWVngRI2ViceG71I7Gw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.21382488479262673&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwubicheVOFWlR4aa58OstGTrw1p7XSoUdOFMATOFWVngRI2ViceG71I7Gw/640&quot; data-type=&quot;png&quot; data-w=&quot;1085&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;重复直到合并成一个包含6个int的有序子串&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuaha64k2J02L8lj6AX4zYUAswZhSQA3vOH5LKWOTibLgmu0IuaEpAaAg/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.3192488262910798&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuaha64k2J02L8lj6AX4zYUAswZhSQA3vOH5LKWOTibLgmu0IuaEpAaAg/640&quot; data-type=&quot;png&quot; data-w=&quot;426&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再把两个包含6个int的有序子串合并成一个包含12个int数据的最终有序子串&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuF7zx6vDib5dMlPSicZnH94chOlScIhkxdEPkZv95rl3GYMGZoQnk2dKw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.3153846153846154&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuF7zx6vDib5dMlPSicZnH94chOlScIhkxdEPkZv95rl3GYMGZoQnk2dKw/640&quot; data-type=&quot;png&quot; data-w=&quot;910&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwue0iarlXCBDto5ib52WhqJP4Z8s5Vm4RRAFp97PNYMcVqeiamhuFXiaF4sw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6750448833034112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwue0iarlXCBDto5ib52WhqJP4Z8s5Vm4RRAFp97PNYMcVqeiamhuFXiaF4sw/640&quot; data-type=&quot;png&quot; data-w=&quot;557&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优化策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuO3CpjuIjqYeulybUVsNMdW3jRAecCHe35alTgff9vm73JZWmnMQqjQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6893542757417103&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuO3CpjuIjqYeulybUVsNMdW3jRAecCHe35alTgff9vm73JZWmnMQqjQ/640&quot; data-type=&quot;png&quot; data-w=&quot;573&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;解释下&lt;/strong&gt;：例如对于数据2，我们把无序的12个数据分成有序的4个子串需要读写各一次，把2份3个有序子串合并成6个有序子串读写各一次；把2份6个有序子串合并从12个有序子串读写各一次，一共需要读写各3次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuspEkKLLiap9h6vaLG7B6zCx2yJJvwTuUmqSULCMiaLb6zO4oc6cDEibDA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5957446808510638&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuspEkKLLiap9h6vaLG7B6zCx2yJJvwTuUmqSULCMiaLb6zO4oc6cDEibDA/640&quot; data-type=&quot;png&quot; data-w=&quot;611&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwusKD65J2icbTFQo96x6YU43mUmQTSIjgeMbq1sySeUXtepkemKU7sqWQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5467511885895404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwusKD65J2icbTFQo96x6YU43mUmQTSIjgeMbq1sySeUXtepkemKU7sqWQ/640&quot; data-type=&quot;png&quot; data-w=&quot;631&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuXY65j2KsF4cibLqzkykNgQ91syype9d63GnN6vQzP5T0nuia6JzPA33w/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6099518459069021&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuXY65j2KsF4cibLqzkykNgQ91syype9d63GnN6vQzP5T0nuia6JzPA33w/640&quot; data-type=&quot;png&quot; data-w=&quot;623&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;多路归并&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为了方便讲解，我们假设&lt;strong&gt;内存一共可以装4个int型数据&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuLhvtJwEeuUDN0E7yjJrT1zljKzwYEAmhoHe4oiahkTqFPw2PuBsN9Wg/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5959933222036727&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuLhvtJwEeuUDN0E7yjJrT1zljKzwYEAmhoHe4oiahkTqFPw2PuBsN9Wg/640&quot; data-type=&quot;png&quot; data-w=&quot;599&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwudWsKfZjC9alGREpDTbibJia7nX1c0BYuMXc1bR1VC4s09dFpnrHZSdQw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6518883415435139&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwudWsKfZjC9alGREpDTbibJia7nX1c0BYuMXc1bR1VC4s09dFpnrHZSdQw/640&quot; data-type=&quot;png&quot; data-w=&quot;609&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu7hV3aiavHNrSKqLSUMnwsV1piaZJLx7ibvHllNQ2A9nGeGRNkicroXdCnA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.27773749093546046&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu7hV3aiavHNrSKqLSUMnwsV1piaZJLx7ibvHllNQ2A9nGeGRNkicroXdCnA/640&quot; data-type=&quot;png&quot; data-w=&quot;1379&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuV7nqMm5RrqjdicGYycbvOu1m0gicXWialEFVIJSuIrIPRh5jkO4VcjuEg/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6452702702702703&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuV7nqMm5RrqjdicGYycbvOu1m0gicXWialEFVIJSuIrIPRh5jkO4VcjuEg/640&quot; data-type=&quot;png&quot; data-w=&quot;592&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu0EX5INNUWu9iaaHc6Xk573R4UdbiaceXLe8QopfBroWWqd2BgqdKiatBg/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.599025974025974&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu0EX5INNUWu9iaaHc6Xk573R4UdbiaceXLe8QopfBroWWqd2BgqdKiatBg/640&quot; data-type=&quot;png&quot; data-w=&quot;616&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwum1nbg5yCK5989aHwIezNtj8BmCtmXMjBx3cicxM4wzSQsPZoeeVZ1FA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.9280575539568345&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwum1nbg5yCK5989aHwIezNtj8BmCtmXMjBx3cicxM4wzSQsPZoeeVZ1FA/640&quot; data-type=&quot;png&quot; data-w=&quot;417&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwumibLZNhRooY2nmBCZbEf2NQXcQ7A1u55MJb7vibrd22TwCgAUTlQku0g/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6292834890965732&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwumibLZNhRooY2nmBCZbEf2NQXcQ7A1u55MJb7vibrd22TwCgAUTlQku0g/640&quot; data-type=&quot;png&quot; data-w=&quot;642&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;置换选择&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuBaibk3ozhibnLJngF0pJFAVRIkwwV4yOAUctGybK6kbnXBv92fgeOhoQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.600326264274062&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuBaibk3ozhibnLJngF0pJFAVRIkwwV4yOAUctGybK6kbnXBv92fgeOhoQ/640&quot; data-type=&quot;png&quot; data-w=&quot;613&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuhyMn6iaBicSnk87dDM50GmdqwJeRFEpqMzbBHke7icDW2feuH148DiaWSQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;1.2076923076923076&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuhyMn6iaBicSnk87dDM50GmdqwJeRFEpqMzbBHke7icDW2feuH148DiaWSQ/640&quot; data-type=&quot;png&quot; data-w=&quot;260&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwunPa0x0GQ6qA4WXtIibnnRG9b6KblSz5LB88KicLCbKs5siaibic3k8zpdpw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5602605863192183&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwunPa0x0GQ6qA4WXtIibnnRG9b6KblSz5LB88KicLCbKs5siaibic3k8zpdpw/640&quot; data-type=&quot;png&quot; data-w=&quot;614&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwukd6ERbiboDWdu3KCrDU9t0fUibJqwRQrdMictJyWW0Hdagst2tKsZDV6A/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5972927241962775&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwukd6ERbiboDWdu3KCrDU9t0fUibJqwRQrdMictJyWW0Hdagst2tKsZDV6A/640&quot; data-type=&quot;png&quot; data-w=&quot;591&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu4Jymq290m5ZQ9MKrIXIWUqLOehBIVT9ktrACKlAV2xOsavKArCd2BQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5579119086460033&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu4Jymq290m5ZQ9MKrIXIWUqLOehBIVT9ktrACKlAV2xOsavKArCd2BQ/640&quot; data-type=&quot;png&quot; data-w=&quot;613&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuvF0suiaVEMIF59saGGG8mDtPqBTmyPMib6R9cIXZTeS4wxHEPFlZLlPQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5283630470016207&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuvF0suiaVEMIF59saGGG8mDtPqBTmyPMib6R9cIXZTeS4wxHEPFlZLlPQ/640&quot; data-type=&quot;png&quot; data-w=&quot;617&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwumeSBxNL2ibFibibLgicJenZ8aWDeK1ucVBBpkce8USdvOQFw69yK6jmGPQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5509259259259259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwumeSBxNL2ibFibibLgicJenZ8aWDeK1ucVBBpkce8USdvOQFw69yK6jmGPQ/640&quot; data-type=&quot;png&quot; data-w=&quot;648&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;例如我们可以从12个数据读取3个存到内存中，然后从内存中选出最小的那个数放进子串p1里；&lt;/p&gt;

&lt;p&gt;之后再从在从剩余的9个数据读取一个放到内存中，然后再从内存中选出一个数放进子串p1里，&lt;strong&gt;这个数必须满足比p1中的其他数大，且在内存中尽量小&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;这样一直重复，直到内存中的数都比p1中的数小，这时p1子串存放结束，继续来p2子串的存放。例如(&lt;strong&gt;&lt;em&gt;这时假设内存只能存放3个int型数据&lt;/em&gt;&lt;/strong&gt;)：&lt;/p&gt;

&lt;p&gt;12个无序的int数据&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu3gXlzlGoicmAJPSKuwsXKEZxn6uMjaP0qToicWOS7qqiaZKoUDrjvNibhw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.1820388349514563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu3gXlzlGoicmAJPSKuwsXKEZxn6uMjaP0qToicWOS7qqiaZKoUDrjvNibhw/640&quot; data-type=&quot;png&quot; data-w=&quot;824&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;读入3个到内存中，且选出一个最小的到子串p1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuFQOlVSSoZC2KbRlk01Jrgrjcj4H1mjWscqbWggs5r1E7P11YrUk0Wg/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.24816446402349487&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuFQOlVSSoZC2KbRlk01Jrgrjcj4H1mjWscqbWggs5r1E7P11YrUk0Wg/640&quot; data-type=&quot;png&quot; data-w=&quot;681&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从内存中再次读取一个元素86&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu4NhoQzeJ80caicnjgcjGV5ic4icykURAXAH4hzvGibgdM3aaCqq0e7xiacQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.2546230440967283&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu4NhoQzeJ80caicnjgcjGV5ic4icykURAXAH4hzvGibgdM3aaCqq0e7xiacQ/640&quot; data-type=&quot;png&quot; data-w=&quot;703&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从内存中再次读取一个元素3&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuGCh5h87l13uScro4jMRQrFice1qiahoJQLkP2WF7eesicDqmeA2mQlabA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.28653295128939826&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuGCh5h87l13uScro4jMRQrFice1qiahoJQLkP2WF7eesicDqmeA2mQlabA/640&quot; data-type=&quot;png&quot; data-w=&quot;698&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从内存中再次读取一个元素24&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuWwK6DQicpByRER6NTroqRSaricypSG2FKfaIXfCFoW5xatoFZic3yBg3w/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.3020527859237537&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuWwK6DQicpByRER6NTroqRSaricypSG2FKfaIXfCFoW5xatoFZic3yBg3w/640&quot; data-type=&quot;png&quot; data-w=&quot;682&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从内存中再次读取一个元素8&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu5duPe6S6qu2fcfmQsxdFnZ614d5K0x0icibgCePPSdGdRBItmIucfTrg/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.2905027932960894&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwu5duPe6S6qu2fcfmQsxdFnZ614d5K0x0icibgCePPSdGdRBItmIucfTrg/640&quot; data-type=&quot;png&quot; data-w=&quot;716&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个时候，已经没有符合要求的数了，且内存已满，进而用p2子串来存放，以此类推。&lt;/p&gt;

&lt;p&gt;通过这种方法，p1子串存放了4个数据，而原来的那种方法p1子串只能存放3个数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuyEe0TeNfSVW2zsgyU6qYgpzjVuhsxPkXeflc63yicoTHs4tozE26hcw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5524691358024691&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuyEe0TeNfSVW2zsgyU6qYgpzjVuhsxPkXeflc63yicoTHs4tozE26hcw/640&quot; data-type=&quot;png&quot; data-w=&quot;648&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuOJtj2WI4fl5cy6JLfLjQjDdrVdKXgfTZFfjvE8CQpVicn3LV4r8jFBA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6093247588424437&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuOJtj2WI4fl5cy6JLfLjQjDdrVdKXgfTZFfjvE8CQpVicn3LV4r8jFBA/640&quot; data-type=&quot;png&quot; data-w=&quot;622&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(不知道堆排序的可以看下我之前写的文章：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNzg0MDc1Mg==&amp;amp;mid=2247484222&amp;amp;idx=1&amp;amp;sn=2a3d3f0e95df9d1fdcc2e21123721e66&amp;amp;chksm=f9934921cee4c037fe37eb9a27454f095376117985187867b09bd95b564e4941956ead73ed93&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;【算法与数据结构】堆排序是什么鬼？&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;从12个数据中读取3个数据，构建成一个&lt;strong&gt;最小堆&lt;/strong&gt;，然后从&lt;strong&gt;堆顶&lt;/strong&gt;选择一个数写入到p1中。&lt;/p&gt;

&lt;p&gt;之后再从剩余的9个数中读取一个数，如果这个数比刚才那个写入到p1中的数大，则把这个数插入到最小堆中，重新调整最小堆结构，然后在堆顶选一个数写入到p1中。&lt;/p&gt;

&lt;p&gt;否则，把这个数&lt;strong&gt;暂放在一边，暂时不处理&lt;/strong&gt;。之后一样需要调整堆结构，从堆顶选择一个数写入到p1中。&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;这里说明一下&lt;/strong&gt;，那个被放在一边的数是不能再放入p1中的了，因为它一定比p1中的数都要小，所以它会放在下一个子串中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看这些文字会让人头大，我画图解释下吧。&lt;/p&gt;

&lt;p&gt;从12数据读取3个数据&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuoIDrvUyugxj8BkZoCLcdYGIfgiasaSa8cUf7n3ZoSMAKAIWz7fjm8Cg/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5597014925373134&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuoIDrvUyugxj8BkZoCLcdYGIfgiasaSa8cUf7n3ZoSMAKAIWz7fjm8Cg/640&quot; data-type=&quot;png&quot; data-w=&quot;268&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;构建最小堆，且选出目标数&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuoKXVtabiaCPA8cCCeyTpxjapmljDmicAMXBM3ialFHVTl6F7QQ496GSaw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.34761321909424725&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuoKXVtabiaCPA8cCCeyTpxjapmljDmicAMXBM3ialFHVTl6F7QQ496GSaw/640&quot; data-type=&quot;png&quot; data-w=&quot;817&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;读入下一个数86&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwudhY2xqvEw02W1051CiaVKVaCKZSosNicr98QektSKQicdkyHVj4LpZn5Q/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.240432612312812&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwudhY2xqvEw02W1051CiaVKVaCKZSosNicr98QektSKQicdkyHVj4LpZn5Q/640&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;读入下一个数3，比70小，暂放一边，不加入堆结构中&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuEnAVMT5sCf1u4yyYQmJzzhxGicGia3UwpT0LXAeO91twsGjACSicyN91w/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.23575129533678757&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuEnAVMT5sCf1u4yyYQmJzzhxGicGia3UwpT0LXAeO91twsGjACSicyN91w/640&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;读入下一个数据24，比81小，不加入堆结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuRFPHe6GCia160BibBgElBCZJfDhia97kXgKPcyBGUWiclKKD3Y0YWopJXA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.2223175965665236&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuRFPHe6GCia160BibBgElBCZJfDhia97kXgKPcyBGUWiclKKD3Y0YWopJXA/640&quot; data-type=&quot;png&quot; data-w=&quot;1165&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;读入下一个数据8，比86小，不加入堆结构。此时p1已经完成了，把那些刚才暂放一边的数重新构成一个堆，继续p2的存放。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwupnohcBsibVMUib9g059YSytQgX1y1gyOcicDAmYwqgEL9E0SFHu7mzia0w/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.2553373185311699&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwupnohcBsibVMUib9g059YSytQgX1y1gyOcicDAmYwqgEL9E0SFHu7mzia0w/640&quot; data-type=&quot;png&quot; data-w=&quot;1171&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以此类推...&lt;/p&gt;
&lt;p&gt;最后生成的p2如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwukM2V46dWjMWicYzrxEJ4TNRtJjL1nHuWTxAmg9bLRb2PWxRGib37vDbA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.3268206039076377&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwukM2V46dWjMWicYzrxEJ4TNRtJjL1nHuWTxAmg9bLRb2PWxRGib37vDbA/640&quot; data-type=&quot;png&quot; data-w=&quot;563&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwupibZ6fhRskKcQuuLnD7icMcXjqmcLvwjAgNxqrrrcsQbdrkDQKhic1MIA/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5646359583952452&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwupibZ6fhRskKcQuuLnD7icMcXjqmcLvwjAgNxqrrrcsQbdrkDQKhic1MIA/640&quot; data-type=&quot;png&quot; data-w=&quot;673&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuttPZelicWYt0NluNYDOPns4DDmXn2ExficjXiaC7UotfqfhFozNRfb8zQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6267942583732058&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuttPZelicWYt0NluNYDOPns4DDmXn2ExficjXiaC7UotfqfhFozNRfb8zQ/640&quot; data-type=&quot;png&quot; data-w=&quot;627&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuOyW3BX2LqDib3xKk88v26jV58e3IFgT9UiaSiajDx2aL9v55FEmBQeIqQ/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6003062787136294&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuOyW3BX2LqDib3xKk88v26jV58e3IFgT9UiaSiajDx2aL9v55FEmBQeIqQ/640&quot; data-type=&quot;png&quot; data-w=&quot;653&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuBLiaIJvqFw35BAAibDgibJW00tmEj8cQghDUjibVXJT08uBl4j6Shdiaqjw/640?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.5160349854227405&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gsQM61GSzIM24zEDgCuibjl9JVBhEWDwuBLiaIJvqFw35BAAibDgibJW00tmEj8cQghDUjibVXJT08uBl4j6Shdiaqjw/640&quot; data-type=&quot;png&quot; data-w=&quot;686&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这种方法适合要排序的数据太多，以至于内存一次性装载不下。只能通过把数据分几次的方式来排序，我们也把这种方法称之为&lt;strong&gt;外部排序&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 更多&lt;strong&gt;高质量漫画原创文章&lt;/strong&gt;，大家可以关注我的微信公众号：&lt;strong&gt;苦逼的码农&lt;/strong&gt;。文章将第一时刻发表于我的公众号。&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本公众号（&lt;strong&gt;苦逼的码农&lt;/strong&gt;）专注于写【Java】、【计算机网络】、【数据结构与算法】，期待你的关注。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 20 Oct 2018 02:32:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>背景 西天取经的路上，一样上演着编程的乐趣..... 这篇文章我将通过对话的形式带大家由浅入深着读懂外部排序。 排序的时候我们可以选择快速排序或归并排序等算法。为了方便，我们把排序好的2G有序数据称之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/9820830.html</dc:identifier>
</item>
</channel>
</rss>