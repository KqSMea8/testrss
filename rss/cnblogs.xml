<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>安卓多个RecyclerView滑动与显示问题 - Asche</title>
<link>http://www.cnblogs.com/asche/p/10049633.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/asche/p/10049633.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;
 最近在项目遇到这样的问题：在一线性垂直布局内，有两个垂直的RecyclerView，如果直接高度直接设置wrap-content，
 通常会导致滑动冲突或是内容显示不全。

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先说下解决的思路，就是在最外面嵌套一层自定义的ScrollView，重写其相关方法，判断若为垂直滑动则拦截下来，不交由RecyclerView来处理。&lt;br/&gt;这样的话，滑动冲突就能解决，并且是很流畅的。&lt;/p&gt;
&lt;p&gt;不过这样在有些设备可能还会出现个问题， 就是内容显示不全。这里可以通过在显示不全的RecyclerView外面套一层RelativeLayout，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
           &amp;lt;RelativeLayout
                    android:layout_width=&quot;match_parent&quot;
                    android:layout_height=&quot;wrap_content&quot;
                    &amp;gt;
                    &amp;lt;!-- 和项目为androidx无关 --&amp;gt;

                    &amp;lt;androidx.recyclerview.widget.RecyclerView
                        android:id=&quot;@+id/recyclerview&quot;
                        android:layout_width=&quot;match_parent&quot;
                        android:layout_height=&quot;wrap_content&quot; /&amp;gt;
           &amp;lt;/RelativeLayout&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的话， 内容就可以显示完全了。&lt;/p&gt;
&lt;p&gt;下面继续ScrollView的滑动事件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
自定义一个view，并继承自ScrollView， 再重写onInterceptTouchEvent方法；
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体内容则是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @Override
    public boolean onInterceptTouchEvent(MotionEvent e) {
        int action = e.getAction();
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                // downX = (int) e.getRawX();
                downY = (int) e.getRawY();
                break;
            case MotionEvent.ACTION_MOVE:
                int moveY = (int) e.getRawY();
                if (Math.abs(moveY - downY) &amp;gt; touchSlop) {
                    return true;
                }
        }
        return super.onInterceptTouchEvent(e);
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取触屏开始和结束位置坐标的Y值，取相减的绝对值，再与touchSlop比较，大于这个值则判断此次为滑动事件，则拦截。&lt;br/&gt;其中touchSlop 是判断是否滑动的参考值。官方给出的解释是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Distance in pixels a touch can wander before we think the user is scrolling&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大体过程就是这样，下面贴上自定义ScrollView的全部代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;

package com.asche.wetalk.helper;

import android.content.Context;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.ViewConfiguration;
import android.widget.ScrollView;

/**
 *  拦截滑动事件，不由recyclerview处理
 */
public class MyScrollViewScroll extends ScrollView {
    // private int downX;
    private int downY;
    private int touchSlop;

    public MyScrollViewScroll(Context context) {
        super(context);
        touchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
    }

    public MyScrollViewScroll(Context context, AttributeSet attrs) {
        super(context, attrs);
        touchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
    }

    public MyScrollViewScroll(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        touchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent e) {
        int action = e.getAction();
        switch (action) {
            case MotionEvent.ACTION_DOWN:
                // downX = (int) e.getRawX();
                downY = (int) e.getRawY();
                break;
            case MotionEvent.ACTION_MOVE:
                int moveY = (int) e.getRawY();
                if (Math.abs(moveY - downY) &amp;gt; touchSlop) {
                    return true;
                }
        }
        return super.onInterceptTouchEvent(e);
    }

    @Override
    protected void onOverScrolled(int scrollX, int scrollY, boolean clampedX, boolean clampedY) {
        super.onOverScrolled(scrollX, scrollY, clampedX, clampedY);
    }
}



&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 01 Dec 2018 07:54:00 +0000</pubDate>
<dc:creator>Asche</dc:creator>
<og:description>首先说下解决的思路，就是在最外面嵌套一层自定义的ScrollView，重写其相关方法，判断若为垂直滑动则拦截下来，不交由RecyclerView来处理。 这样的话，滑动冲突就能解决，并且是很流畅的。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/asche/p/10049633.html</dc:identifier>
</item>
<item>
<title>AppBoxFuture(二): Say goodbye to sql! - 白菜园</title>
<link>http://www.cnblogs.com/BaiCai/p/10049643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BaiCai/p/10049643.html</guid>
<description>&lt;p&gt;  信息管理类应用系统离不开关系数据存储，目前大家基本都使用的是传统的数据库如MySql、Postgres等。作者从事信息化建设十多年，个人认为传统的数据库存在以下的问题：&lt;/p&gt;
&lt;h4 id=&quot;扩展问题&quot;&gt;扩展问题：&lt;/h4&gt;
&lt;p&gt;  系统数据的不断增长是个绕不过去的坎，传统数据库的存储结构一般都基于B+tree，单表数据在一定范围内没有问题，但数据量增大到一定程度后性能便会不断下降，只能通过分库分表的方式或升级硬件来解决，随之而来的是提高了应用软件的开发难度及相应的硬件成本。作者曾建设过一个北斗监控平台，其中单表记录10多亿，经过优化虽能实行秒级查询一天轨迹，但备份及定期删除历史数据非常慢且影响在线操作，后来只能手工实现了一套文件存储来解决（那个时代还没有NoSql)。&lt;/p&gt;
&lt;h4 id=&quot;可用性问题&quot;&gt;可用性问题：&lt;/h4&gt;
&lt;p&gt;  传统数据库只能使用主从的方式来保障可用性，运维较复杂。作者曾经碰到过一次闪电导致机房（等保三级）内一台数据库用SAN存储的电源背板烧坏，虽这台存储冗余电源，RAID10统统没用，导致系统停用两天。&lt;/p&gt;
&lt;h4 id=&quot;开发人员问题&quot;&gt;开发人员问题：&lt;/h4&gt;
&lt;p&gt;  由于开发人员对sql的熟悉程度不同，经常能碰到写的很烂的sql语句。另外如果使用ORM，则ORM-&amp;gt;Sql字符串-&amp;gt;网络传输-&amp;gt;Sql引擎分析-&amp;gt;执行-&amp;gt;网络传输-&amp;gt;ORM存在较大性能损耗。作者的一个朋友在一家公司做运维，他说他公司的开发只管程序能否跑通，从不管sql优化问题，导致系统很慢，出了问题全丢给运维处理。&lt;/p&gt;
&lt;p&gt;  由于存在上述问题，作者一直在寻找新的适合于信息管理类系统的存储技术，既能简单的随需扩展，又能保障高可用高性能，还能兼顾大数据存储与分析，最好建设与运维的成本尽可能的低（作者接触的都是中小微企业）。因此先后学习了互联网企业常用的NewSql（TiDB, Cockroach）、NoSql(Cassandra, Kudu, ES等）技术，希望能将这些技术应用于传统的信息管理系统的建设。但随着进一步的深入了解，这些技术都存在这样或那样的问题，比如或架构复杂问题，或事务一致性问题，或性能问题（如并发扣减库存）。&lt;/p&gt;
&lt;p&gt;  在学习了上述技术的原理后，作者就想能否重新实现一套适合于上述要求的分布式数据库，直接集成至应用框架内，从而可以：&lt;/p&gt;
&lt;h4 id=&quot;简化应用系统架构&quot;&gt;简化应用系统架构&lt;/h4&gt;
&lt;p&gt;整个应用系统由一个或多个节点组成，每个节点负责处理用户请求及存储，随需扩展节点。&lt;/p&gt;
&lt;h4 id=&quot;表分区&quot;&gt;表分区&lt;/h4&gt;
&lt;p&gt;大表支持定义为按分区键分区存储（类似于Cassandra的PartionKey），同时支持分区索引及全局索引，以避免热点问题，另外删除整个分区对性能的影响较小。&lt;/p&gt;
&lt;h4 id=&quot;强一致性事务&quot;&gt;强一致性事务&lt;/h4&gt;
&lt;p&gt;基于Raft及2PC支持分布式事务（类似于TiDB, Cockroach)。&lt;/p&gt;
&lt;h4 id=&quot;简单的api&quot;&gt;简单的Api&lt;/h4&gt;
&lt;p&gt;支持框架的实体模型与存储结构的直接映射，避免sql字符串转换与分析损耗，另由于直接进程内访问存储引擎，可减少网络通信开销。&lt;br/&gt;举个简单的保存例子：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var pos = new Entities.VehiclePosition(vehicleId); //车辆位置，根据id分区
pos.LAT = 32.22223;
pos.LNG = 100.2123;
await EntityStore.SaveAsync(pos);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再举个简单的表扫描查询例子，支持其他查询方式如索引扫描，聚合扫描等：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var q = new TableScan&amp;lt;Entities.VehiclePosition&amp;gt;();
q.Partions(p =&amp;gt; p.VehicleId == vehicleId); //指定分区条件
q.Filter(t =&amp;gt; t.CreateTime &amp;gt;= startday &amp;amp;&amp;amp; t.CreateTime &amp;lt; endday); //指定分区内记录过滤条件
var list = await q.ToListAsync(t =&amp;gt; new {t.Id, t.LAT, t.LNG}); //选择指定列&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小Tip:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在实现表扫描及聚合扫描时，作者利用C#的Emit直接生成条件过滤代码，类似于PG10 llvm生成代码。&lt;/li&gt;
&lt;li&gt;关于Join将只支持LeftJoin，复杂Join只能在服务代码内利用C#的Linq处理。&lt;/li&gt;
&lt;li&gt;目前事务隔离级别只支持ReadCommitted及Seializable，但纯读支持本地读、线性一致性读、事务读。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  目前作者还在不断踩坑与尝试实现上述目标，当然首先要感谢上述所提的那些技术先驱们，在此希望有志同道合者来共同完成它。已实现的技术原型参考前篇&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/BaiCai/p/10018947.html&quot;&gt;AppBoxFuture(一): Hello Future!&lt;/a&gt;，下篇“分而治之”将介绍框架如何在较低的硬件下保障高性能。&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 07:29:00 +0000</pubDate>
<dc:creator>白菜园</dc:creator>
<og:description>  信息管理类应用系统离不开关系数据存储，目前大家基本都使用的是传统的数据库如MySql、Postgres等。作者从事信息化建设十多年，个人认为传统的数据库存在以下的问题： 扩展问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BaiCai/p/10049643.html</dc:identifier>
</item>
<item>
<title>分享知识-快乐自己：反射机制Demo解析 - GDBD</title>
<link>http://www.cnblogs.com/mlq2017/p/10049441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mlq2017/p/10049441.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java-Reflect专题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基本反射简介：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意一个对象&lt;/span&gt;&lt;span&gt;能够调用它的任意方法和属性;这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）：JAVA反射(放射)机制:&quot;程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言&quot;。从这个观看，Perl，&lt;/span&gt;&lt;span&gt;PythonRuby是动态语言，C++，Java，C#不是动态语言。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）：但是JAVA有着一个非常突出的动态相关机制：Reflection&lt;/span&gt;&lt;span&gt;用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）：换句话说，Java程序可以&lt;/span&gt;&lt;span&gt;加载一个运行时才得知名称的class，获悉其完整构造(但不包括methods定义)，并生成其对象实体、或对其fields&lt;/span&gt;&lt;span&gt;设值、或唤起其methods。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Java反射机制提供的功能：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）：在运行时判断任意一个对象所属的类在运行时构造任意一个类的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）：在运行时判断任意一个类所具有的成员变量和方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）：在运行时调用任意一个对象的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）：生成动态代理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Class类介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Class 类描述Java程序运行时的所有 Classes 和 interfaces，同时也用来描述enum、array、Java基本数据类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生成Class：&lt;/span&gt;&lt;span&gt;当一个class文件被加载或者类加载器的defineClass()被JVM调用时，JVM便自动产生一个Class 对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;常用API：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;生成Class对象的方法：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）：根据完整类名获取类，调用 Class 的静态方法 forName()：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Class&amp;lt;?&amp;gt; classType = Class.forName(“java.lang.String”);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2）：通过类名获取，使用class语法，这里ReflectionTest为一个类名：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Class&amp;lt;?&amp;gt; classType = ReflectionTest.&lt;span&gt;class&lt;/span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3）：通过对象的getClass()方法获取：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User()；
Class&lt;/span&gt;&amp;lt;?&amp;gt; classType =&lt;span&gt; user.getClass();&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//获取user的父类的Class对象&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;Class superClass &lt;/span&gt;= classType.getSuperclass();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4）：对于包装类的Class的获取，使用包装类的TYPE语法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Class classType = Integer.Type;&lt;br/&gt;Class c = Integer.class;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创建反射获取的类的实例的方法：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）：调用Class的newInstance()方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Class c = Class.forName(&quot;mlq.Student&quot;);&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;Student student = (Student) c.newInstance();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2）：通过Class获取构造方法再实例化：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Class c = Class.forName(&quot;mlq.Student&quot;&lt;span&gt;);
Student student&lt;/span&gt;=(Student)c.getConstructor(&lt;span&gt;new&lt;/span&gt; Class[]{}).newInstance(&lt;span&gt;new&lt;/span&gt; Object[]{});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;提示：当Class数组为空时，本质上等价于①，即调用无参构造函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;获取方法信息函数：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1）：获取所有公共方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Method getMethod(String name, Class[] params) --&lt;span&gt; 使用特定的参数类型，获得命名的公共方法

Method[] getMethods() &lt;/span&gt;-- 获得类的所有公共方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2）：获取所有方法：（不问访问权限）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Method getDeclaredMethod(String name, Class[] params) -&lt;span&gt;使用特写的参数类型，获得类声明的命名的方法

Method[] getDeclaredMethods() &lt;/span&gt;-- 获取的是所有该类自己声明的方法，不问访问权限&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;获取成员变量：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1）：获取所有的 public 的成员变量的信息&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Field getField(String name) --&lt;span&gt; 获得指定命名的公共字段

Field[]  getFields()&lt;/span&gt;--方法获取的是所有的public的成员变量的信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2）：获取所有成员变量：（不问访问权限）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;span&gt;Field getDeclaredField(String name) --&lt;span&gt; 获取指定的域，返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段：

Field[]  getDeclaredFields()&lt;/span&gt;--获取所有的域，包括公共、保护、默认（包）访问和私有域，但不包括继承的域：&lt;/span&gt;&lt;span&gt;field.setAccessible(true);--设置压制访问控制检查，这样就可以获取和设置私有域的值了：&lt;/span&gt;&lt;p&gt;&lt;span&gt;Field field = classType.getDeclaredField(&quot;fieldName&quot;);--获取某个对象的域的对应值：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;field.get(object);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Field field = classType.getDeclaredField(&quot;fieldName&quot;);--设置某个对象的域的对应值：&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;field.set(obj, &quot;arthinking&quot;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;获取构造函数信息：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）：获取所有public的函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Constructor getConstructor(Class[] params) --&lt;span&gt; 获得使用特殊的参数类型的公共构造函数，&lt;br/&gt;Constructor[]  getConstructors()&lt;/span&gt;--获取所有的public的构造函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2）：获取构造函数：（不问访问权限）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Constructor getDeclaredConstructor(Class[] params) --&lt;span&gt; 获得使用特定参数类型的构造函数(与接入级别无关)&lt;br/&gt;Constructor[]  getDeclaredConstructors()&lt;/span&gt;--得到自己声明的构造函数，推荐使用(与接入级别无关)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;案例Demo：&lt;a href=&quot;https://github.com/MlqBeginner/BlogGardenWarehouse/blob/master/Reflection.rar&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;点我下载源码&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1）：获取Student类的完整限定名==》全类名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取Student类的完整限定名==》全类名
     * 01、Class.forName(类的完整限定名) 来加载类 （常用）
     * 02、Student.class 任何类名.class都是获取了Class类
     * 03、new Student().getClass() 任何对象.getClass（）都是获取了Class类
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test01() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

            System.out.println(&lt;/span&gt;&quot;打印类的完整限定名、会走静态代码块：&quot; + Class.forName(&quot;mlq.Student&quot;&lt;span&gt;));
            System.out.println(&lt;/span&gt;&quot;====================================&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;只打印类的全名称：&quot; + Student.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;====================================&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;无参、静态与非静态块、类完整名称;都会执行&quot; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student().getClass().getName());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）：获取包名、类名、访问修饰符值 和 name&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取包名、类名、访问修饰符值 和 name
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test02() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载Student 类&lt;/span&gt;
            Class c = Class.forName(&quot;mlq.Student&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;Student所在包名称：&quot; +&lt;span&gt; c.getPackage().getName());
            System.out.println(&lt;/span&gt;&quot;Student全类名：&quot; +&lt;span&gt; c.getName());
            System.out.println(&lt;/span&gt;&quot;Student类名：&quot; +&lt;span&gt; c.getSimpleName());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取类的访问修饰符&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; c.getModifiers();
            System.out.println(&lt;/span&gt;&quot;public访问修饰符对应的数值：&quot; +&lt;span&gt; num);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问修饰符对相应的名称&lt;/span&gt;
&lt;span&gt;            System.out.println(Modifier.toString(num));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;3）： 获取类中所有的属性相关信息&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取类中所有的属性相关信息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test03() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Class c &lt;/span&gt;= Class.forName(&quot;mlq.Student&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有字段&lt;/span&gt;
            Field[] fields =&lt;span&gt; c.getDeclaredFields();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; fields.length; i++&lt;span&gt;) {
                System.out.println(fields[i]);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有字段的访问修饰符&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; fields.length; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修饰符值对象的修饰符名称&lt;/span&gt;
&lt;span&gt;                System.out.print(Modifier.toString(fields[i].getModifiers()));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问修饰符对应的数值&lt;/span&gt;
                System.out.println(&quot;:&quot; +&lt;span&gt; fields[i].getModifiers());
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）：获取类中所有的方法相关信息  不包含构造方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取类中所有的方法相关信息  不包含构造方法
     * 01、c.getMethod(方法名称，参数类型)只能是public修饰的
     * 02、c.getMethods()只能是public修饰的
     * 03、c.getDeclaredMethods() 所有
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test04() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Class c &lt;/span&gt;= Class.forName(&quot;mlq.Student&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有方法，包含private私有的&lt;/span&gt;
            Method[] declaredMethods =&lt;span&gt; c.getDeclaredMethods();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; declaredMethods.length; i++&lt;span&gt;) {
                System.out.println(&lt;/span&gt;&quot;方法的名称是：&quot; +&lt;span&gt; declaredMethods[i].getName());
                System.out.println(&lt;/span&gt;&quot;方法的修饰符数值时：&quot; +&lt;span&gt; declaredMethods[i].getModifiers());
                System.out.println(&lt;/span&gt;&quot;方法的修饰符名称是：&quot; +&lt;span&gt; Modifier.toString(declaredMethods[i].getModifiers()));
                System.out.println(&lt;/span&gt;&quot;方法的返回值类型是：&quot; +&lt;span&gt; declaredMethods[i].getReturnType());
                System.out.println(&lt;/span&gt;&quot;=============================================&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;5）：获取类中的所有构造方法相关信息&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取类中的所有构造方法相关信息
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test05() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Class c &lt;/span&gt;= Class.forName(&quot;mlq.Student&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取所有构造，包含private私有的&lt;/span&gt;
            Constructor[] declaredConstructors =&lt;span&gt; c.getDeclaredConstructors();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; declaredConstructors.length; i++&lt;span&gt;) {
                System.out.println(&lt;/span&gt;&quot;构造方法的名称是：&quot; +&lt;span&gt; declaredConstructors[i].getName());
                System.out.println(&lt;/span&gt;&quot;构造方法的修饰符数值是：&quot; +&lt;span&gt; declaredConstructors[i].getModifiers());
                System.out.print(&lt;/span&gt;&quot;构造的访问修饰符及参数列表：&quot; + Modifier.toString(declaredConstructors[i].getModifiers()) + &quot;(&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取构造中的参数&lt;/span&gt;
                Class[] parameterTypes =&lt;span&gt; declaredConstructors[i].getParameterTypes();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; parameterTypes.length; j++&lt;span&gt;) {
                    System.out.print(parameterTypes[j].getName() &lt;/span&gt;+ &quot;,&quot;&lt;span&gt;);
                }
                System.out.println(&lt;/span&gt;&quot;)&quot;&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;=======================================&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6）：访问类中私有的属性和方法并且让它执行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 访问类中私有的属性和方法并且让它执行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test06() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Class c &lt;/span&gt;= Class.forName(&quot;mlq.Student&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Student student=(Student)c.getConstructor(new Class[]{}).newInstance(new Object[]{});
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化&lt;/span&gt;
            Student student =&lt;span&gt; (Student) c.newInstance();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取私有字段&lt;/span&gt;
            Field userName = c.getDeclaredField(&quot;userName&quot;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出字段名称&lt;/span&gt;
            System.out.println(&quot;输出字段名称:&quot;+&lt;span&gt;userName.getName());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打开字段开关&lt;/span&gt;
            userName.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;userName.set(student,&quot;abc&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出字段信息&lt;/span&gt;
            System.out.println(&quot;输出字段信息:&quot;+&lt;span&gt;userName.get(student));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取私有的方法&lt;/span&gt;
            Method getSum = c.getDeclaredMethod(&quot;getSum&quot;, &lt;span&gt;double&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启方法开关&lt;/span&gt;
            getSum.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用执行方法&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; invoke = (Double) getSum.invoke(student, 50.5&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出返回值&lt;/span&gt;
&lt;span&gt;            System.out.println(invoke);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalAccessException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InstantiationException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchFieldException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvocationTargetException e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Face your past without regret. Handle your present with confidence.Prepare for future without fear. keep the faith and drop the fear.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;面对过去无怨无悔，把握现在充满信心，备战未来无所畏惧。保持信念，克服恐惧！一点一滴的积累，一点一滴的沉淀，学技术需要不断的积淀！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 01 Dec 2018 07:07:00 +0000</pubDate>
<dc:creator>GDBD</dc:creator>
<og:description>Java-Reflect专题 基本反射简介： 1）：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意一个对象能够调用它的任意方法和属性;这种动态获取信息以及动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mlq2017/p/10049441.html</dc:identifier>
</item>
<item>
<title>Docker之使用Dockerfile指令创建镜像（四）--技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/10040805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/10040805.html</guid>
<description>
&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;在之前的博客《&lt;a id=&quot;post_title_link_10030567&quot; href=&quot;https://www.cnblogs.com/kenken2018/p/10030567.html&quot;&gt;Docker端口映射及创建镜像演示（二）--技术流ken&lt;/a&gt;》，演示了如何使用一个现有容器创建一个镜像，以及镜像在阿里云的上传和下载。&lt;/p&gt;
&lt;p&gt;但是这样的镜像有很大的局限性，不能根据我们的生产需要进行个性化定制，所以我们急需学习一种能够满足我们需要的制作镜像的工具。&lt;/p&gt;
&lt;p&gt;这个时候Dockerfile就出现了。&lt;/p&gt;

&lt;p&gt;使用dockerfile指令可以根据自己的需要，制作满足自己生产需要的镜像。&lt;/p&gt;
&lt;p&gt;本篇博客将详细讲解如何使用dockerfile制作自己的专属镜像。&lt;/p&gt;

&lt;h2&gt;Dockerfile简介&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么哪些无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Dockerfile 是一个文本文件，其内包含了一条条的指令，每一条指令构建一层，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因此每一条指令的内容，就是描述该层应当如何构建&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;Dockerfile编写注意项&lt;/h2&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;# 备注&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;指令参数，指令的大小写不敏感&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;第一个非注释行必须是FROM指令&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;编写Dockerfile必须在一个目录下进行，这个目录称之为 工作目录（WORKSPACE）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Dockerfile文件命令的首字母必须大写&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;制作镜像所要用的文件必须放在工作目录或者工作目录的子目录之下，不能放在父目录&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以通过隐藏文件 .dockeringnore 来指定不要放入到镜像中的文件，一行是一个文件，可以用通配符&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;基于dockerfile做镜像，本质上还是基于一个现有的镜像做新镜像&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Dockerfile指令详解&lt;/h2&gt;

&lt;h4&gt;1. FROM&lt;/h4&gt;
&lt;p&gt;作用：FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;FROM &amp;lt;registry&amp;gt;:[tag]&lt;/p&gt;
&lt;p&gt;FROM &amp;lt;registry&amp;gt;@&amp;lt;digest&amp;gt;&lt;/p&gt;
&lt;p&gt;FROM 示例：&lt;/p&gt;
&lt;p&gt;第一步：创建工作目录及dockerfile&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# mkdir /&lt;span&gt;ken&lt;/span&gt;&lt;span&gt;
[root@ken ~]# cd /ken
[root@ken ken]# touch Dockerfile&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：写入from指令&lt;/p&gt;
&lt;p&gt;docker.io：注册表&lt;/p&gt;
&lt;p&gt;nginx：仓库&lt;/p&gt;
&lt;p&gt;latest：版本号&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@ken ken]# cat Dockerfile
FROM docker.io&lt;/span&gt;/nginx:latest
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2. LABEL&lt;/h4&gt;
&lt;p&gt;作用：设定一些元数据&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;LABEL 信息&lt;/p&gt;
&lt;p&gt;LABEL示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;LABEL author &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3. COPY&lt;/h4&gt;
&lt;p&gt;作用：将工作目录下的文件复制到所做得镜像中的文件系统中&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;复制单个文件：COPY &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;&lt;/p&gt;
&lt;p&gt;复制多个文件：COPY [&amp;lt;src&amp;gt; &amp;lt;src&amp;gt; &amp;lt;src&amp;gt;... &amp;lt;dest&amp;gt;]&lt;/p&gt;
&lt;p&gt;COPY示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;COPY &lt;/span&gt;passwd /data/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;源文件路径用相对路径，目标一般用绝对路径&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;也可以通配符&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;源文件必须在工作目录或者工作目录的子目录中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;目标路径可以不存在，会自动创建&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果源文件是一个目录，会自动递归复制目录下的文件到目标位置，但是目录自身不会复制&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果复制多个文件，或者源文件中用了通配符，那么目标路径必须以 / 为结尾&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4. ADD&lt;/h4&gt;
&lt;p&gt;作用：和COPY类似，可以实现将文件和目录加载镜像中，但是区别是可以实现将&lt;span&gt;tar&lt;/span&gt;包解压，也可以实现从网络下载文件到镜像&lt;/p&gt;
&lt;p&gt;注意：下载的tar无法解压&lt;/p&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;p&gt;ADD &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;&lt;/p&gt;
&lt;p&gt;ADD [&quot;&amp;lt;src&amp;gt;&quot; &quot;&amp;lt;src&amp;gt;&quot; &quot;&amp;lt;src&amp;gt;&quot; &quot;&amp;lt;dest&amp;gt;&quot;]&lt;/p&gt;
&lt;p&gt; ADD示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ADD &lt;/span&gt;nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.tar.gz /data/
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;5. WORKDIR&lt;/h4&gt;
&lt;p&gt;作用：相当于执行cd命令。切换目录，为后续的RUN、CMD、ENTRYPOINT 指令配置工作目录。&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;WORKDIR 容器目录&lt;/p&gt;
&lt;p&gt; WORKDIR示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;WORKDIR &lt;/span&gt;/pack/nginx/&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;6. VOLUME&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;作用：指定数据卷的挂载点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;VOLUME 容器目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;VOLUME示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;VOLUME &lt;/span&gt;/data/mysql/mysql3306/data
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;7. EXPOSE&lt;/h4&gt;
&lt;p&gt;作用：设置Docker容器内部暴露的端口号，如果需要外部访问，还需要启动容器时增加-p或者-P参数进行分配。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;EXPOSE PORT/[PROTOCOL]&lt;/p&gt;
&lt;p&gt;EXPOSE示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;EXPOSE &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;/tcp
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;9. ENV&lt;/h4&gt;
&lt;p&gt;作用：设置环境变量&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;ENV var value&lt;/p&gt;
&lt;p&gt;ENV var1=value1 var2=value2 ...&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过ENV所定义的变量是可以传递到容器之中，但是，在创建容器的时候，如果手动指定了变量的值，那么这个值会覆盖掉镜像中原有的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; ENV示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ENV  pkgname&lt;/span&gt;=nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.tar.gz root=/data/mysql/mysql3306/data&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;10. RUN&lt;/h4&gt;
&lt;p&gt;作用：基于镜像构建容器时候要执行命令&lt;/p&gt;
&lt;p&gt;阶段：第一阶段，也就是构建镜像的时候执行&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;RUN 命令&lt;/p&gt;
&lt;p&gt;RUN示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;RUN tar xf $root$pkgname&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;11. CMD&lt;/h4&gt;
&lt;p&gt;作用：定义容器启动以后要默认运行的程序，pid为&lt;span&gt;1&lt;/span&gt;的程序&lt;/p&gt;
&lt;p&gt;阶段：第二阶段，也就是将镜像构成成容器的时候执行&lt;/p&gt;
&lt;p&gt;注意：可以在启动容器的时候用指定的命令替换掉镜像所要执行的命令&lt;/p&gt;
&lt;p&gt;CMD指定容器启动是执行的命令，每个Dockerfile只能有一条CMD命令，如果指定了多条，只有最后一条会被执行。如果你在启动容器的时候也指定的命令，那么会覆盖Dockerfile构建的镜像里面的CMD命令&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;CMD &amp;lt;命令&lt;span&gt;&amp;gt;   &lt;/span&gt;相当于执行的是&lt;span&gt;/bin/sh -c&lt;/span&gt; 命令，也相当于执行&lt;span&gt;exec&lt;/span&gt;来运行命令&lt;/p&gt;
&lt;p&gt;CMD [&quot;&amp;lt;命令&lt;span&gt;&amp;gt;&quot;, &quot;&amp;lt;&lt;/span&gt;参数&lt;span&gt;&amp;gt;&quot;, &quot;&amp;lt;&lt;/span&gt;参数&lt;span&gt;&amp;gt;&quot;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CMD [&quot;&amp;lt;参数&lt;span&gt;&amp;gt;&quot;, &quot;&amp;lt;&lt;/span&gt;参数&lt;span&gt;&amp;gt;&quot;]   &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt; 需要借助于&lt;span&gt;ENTRYPOINT&lt;/span&gt;指令&lt;/p&gt;
&lt;p&gt;CMD示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CMD mkdir &lt;/span&gt;/ken
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;12. ENTRYPOINT&lt;/h4&gt;
&lt;p&gt;作用：定义容器启动以后要默认运行的程序，pid为&lt;span&gt;1&lt;/span&gt;的程序&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;在运行RUN的时候所执行的命令无法覆盖&lt;span&gt;ENTRYPOINT&lt;/span&gt;中的命令&lt;/p&gt;
&lt;p&gt;RUN 后面的命令会被以参数的方式追加到原本要执行的命令的末尾，而不是替换&lt;/p&gt;
&lt;p&gt;基于一个镜像，在创建容器的时候，通过传递不同的参数实现创建不同的容器&lt;/p&gt;
&lt;p&gt;每个 Dockerfile 中只能有一个 ENTRYPOINT，当指定多个时，只有最后一个起效&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;ENTRYPOINT  [&quot;执行命令&quot;，&quot;参数1&quot;，&quot;参数2&quot;...]&lt;/p&gt;
&lt;p&gt; ENTRYPOINT示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
ENTRYPOINT [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;curl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://10.220.5.138&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;13. ARG&lt;/h4&gt;
&lt;p&gt;作用：定义变量，这个变量是用在第一阶段（构建镜像——&lt;span&gt;build&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;ARG 变量名=变量值&lt;/p&gt;
&lt;p&gt; ARG示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ARG name=ken
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;补充：Dockerfile中ENV 和 ARG的区别&lt;/p&gt;
&lt;p&gt;在指定docker build 过程中传参数，要用ARG&lt;/p&gt;
&lt;p&gt;在执行docker run的过程中传参数，要用ENV&lt;/p&gt;
&lt;p&gt;ARG构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是， ARG 所设置的构建环境的&lt;br/&gt;环境变量，在将来容器运行时是不会存在这些环境变量的&lt;/p&gt;

&lt;h4&gt;14. USER&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;作用：指定运行容器时的用户名和UID，后续的RUN指令也会使用这里指定的用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;该用户必须存在于容器的用户空间中（容器的文件系统的中的/etc/passwd中）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;USER &amp;lt;UID&amp;gt;|&amp;lt;USERNAME&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; USER示例：&lt;/p&gt;

&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;15. HEALTHCHECK&lt;/h4&gt;
&lt;p&gt;作用：docker daemon&lt;span&gt;检查&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;容器是否正常，如果异常会将该容器&lt;/span&gt;&lt;span&gt;stop&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将容器&lt;/span&gt;stop&lt;span&gt;的条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）主进程停止了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;）主进程工作在了后台&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HEALTHCHECK [options] CMD&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;options&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--interval=#s|m          指定健康检查的时间间隔（例如：30s,30m）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--timeout=#s|m           指定等待响应的超时时间&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--start-period=#s|m      指定容器启动多久以后才可以做监控检查&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--retries=#              指定重试次数&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;返回值&lt;/p&gt;
&lt;p&gt;0&lt;span&gt;：&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;：&lt;/span&gt;&lt;span&gt;unhealth&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;HEALTHCHECK示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HEALTHCHECK --interval=5m --timeout=1s --retries=&lt;span&gt;3&lt;/span&gt; CMD curl http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.220.5.138/ken.html || exit 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;16. SHELL&lt;/h4&gt;
&lt;p&gt;可以用来指定系统中默认的shell类型&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;SHELL [&quot;/bin/sh&quot;, &quot;-c&quot;]    （linux系统中）&lt;/p&gt;
&lt;p&gt;SHELL示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
SHELL [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/sh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;17. STOPSIGNAL&lt;/h4&gt;
&lt;p&gt;向容器中pid为&lt;span&gt;1&lt;/span&gt;的进程发送一个信号，通过这个信号来关闭这个主进程&lt;/p&gt;
&lt;p&gt;默认是15信号&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;STOPSIGNAL 数值&lt;/p&gt;
&lt;p&gt;STOPSIGNAL示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
STOPSIGNAL &lt;span&gt;9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;18. ONBULID&lt;/h4&gt;
&lt;p&gt;作用：定义一个触发器，指定的命令在构建镜像时并不执行，用来实现当基于这个这个镜像做新镜像的时候要执行的命令&lt;/p&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;ONBUILD 其他指令&lt;/p&gt;
&lt;p&gt;ONBUILD示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ONBUILD COPY ken /app/
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;Dokcerfile完整演示创建nginx镜像&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;根据上面各个指令的介绍，我就直接用上面写的dockerfile进行演示。整个dockerifle内容如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /ken/&lt;span&gt;Dockerfile 
FROM docker.io&lt;/span&gt;/&lt;span&gt;nginx:latest
LABEL author &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
COPY .&lt;/span&gt;/passwd /data/&lt;span&gt;
WORKDIR &lt;/span&gt;/pack/nginx/&lt;span&gt;
ENV  pkgname&lt;/span&gt;=nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.tar.gz  root=/data/mysql/mysql3306/data/&lt;span&gt;
COPY nginx&lt;/span&gt;-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.tar.gz $root
VOLUME $root
EXPOSE &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;/&lt;span&gt;tcp
RUN tar xf $root$pkgname
CMD nginx &lt;/span&gt;-g &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;daemon off;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第一步：构建镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;build：是指根据dockerfile制作镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-t：指定一个tag标签&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.：表示上下文。你也可以理解为dockfile所在的目录，但是并不是准确的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果下方出现successfully就表示镜像已经构建成功了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ken]# docker build -t ken:v1-&lt;span&gt;0&lt;/span&gt;&lt;span&gt; .
Sending build context to Docker daemon &lt;/span&gt;&lt;span&gt;1.021&lt;/span&gt;&lt;span&gt; MB
Step &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt; : FROM docker.io/&lt;span&gt;nginx:latest
 &lt;/span&gt;---&amp;gt;&lt;span&gt; 568c4670fa80
Step &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt; : LABEL author &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ken&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
 ---&amp;gt;&lt;span&gt; Using cache
 &lt;/span&gt;---&amp;gt;&lt;span&gt; 80e4e5846fd9
Step &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt; : COPY ./passwd /data/
 ---&amp;gt;&lt;span&gt; Using cache
 &lt;/span&gt;---&amp;gt;&lt;span&gt; 685a7ceb74b3
Step &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt; : WORKDIR /pack/nginx/
 ---&amp;gt;&lt;span&gt; Using cache
 &lt;/span&gt;---&amp;gt;&lt;span&gt; 0fc65f8c36df
Step &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt; : ENV pkgname nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.tar.gz root /data/mysql/mysql3306/data/
 ---&amp;gt;&lt;span&gt; Using cache
 &lt;/span&gt;---&amp;gt;&lt;span&gt; 3f6038473472
Step &lt;/span&gt;&lt;span&gt;6&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt; : COPY nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.tar.gz $root
 &lt;/span&gt;---&amp;gt;&lt;span&gt; Using cache
 &lt;/span&gt;---&amp;gt;&lt;span&gt; 0cbff6223d5b
Step &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt;&lt;span&gt; : VOLUME $root
 &lt;/span&gt;---&amp;gt;&lt;span&gt; Using cache
 &lt;/span&gt;---&amp;gt;&lt;span&gt; b74ac1c36c31
Step &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt; : EXPOSE &lt;span&gt;80&lt;/span&gt;/&lt;span&gt;tcp
 &lt;/span&gt;---&amp;gt;&lt;span&gt; Using cache
 &lt;/span&gt;---&amp;gt;&lt;span&gt; 6863a87a61a2
Step &lt;/span&gt;&lt;span&gt;9&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt;&lt;span&gt; : RUN tar xf $root$pkgname
 &lt;/span&gt;---&amp;gt;&lt;span&gt; Using cache
 &lt;/span&gt;---&amp;gt;&lt;span&gt; b32ac636a389
Step &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;/&lt;span&gt;10&lt;/span&gt; : CMD nginx -g &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;daemon off;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
 ---&amp;gt; Running &lt;span&gt;in&lt;/span&gt;&lt;span&gt; 02308825301d
 &lt;/span&gt;---&amp;gt;&lt;span&gt; 4a91d70a57eb
Removing intermediate container 02308825301d
Successfully built 4a91d70a57eb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二步：查看镜像&lt;/p&gt;
&lt;p&gt;可以发现构建的名为ken标签为v1-0的镜像已经存在了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@ken ken]# docker image ls
REPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZE
ken                                             v1&lt;/span&gt;-&lt;span&gt;0&lt;/span&gt;                4a91d70a57eb        &lt;span&gt;21&lt;/span&gt; minutes ago      &lt;span&gt;116&lt;/span&gt; MB
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第三步：启动容器&lt;/p&gt;
&lt;p&gt;可以发现基于我们刚才的创建的镜像的容器已经顺利跑起来了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ken]# docker run -d --name ken3 -d ken:v1-&lt;span&gt;0&lt;/span&gt;&lt;span&gt; 
11f492a28b943e619b0ed5d6b19f212f1c9cc47f9bdbe132845e7a7129e5b419                    
[root@ken ken]# docker container ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
11f492a28b94        ken:v1&lt;/span&gt;-&lt;span&gt;0&lt;/span&gt;            &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/sh -c 'nginx...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;16&lt;/span&gt; seconds ago      Up &lt;span&gt;11&lt;/span&gt; seconds       &lt;span&gt;80&lt;/span&gt;/tcp              ken3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第四步：登录容器&lt;/p&gt;
&lt;p&gt;可以发现我们这个启动的容器里面已经有我们指定的工作目录&lt;/p&gt;
&lt;p&gt;复制过来的passwd文件&lt;/p&gt;
&lt;p&gt;已经下载并传送到/data下了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@ken ken]# docker exec -&lt;span&gt;it ken3 bash
root@11f492a28b94:&lt;/span&gt;/pack/nginx# ls /data/&lt;span&gt;
mysql&lt;/span&gt;/&lt;span&gt;  passwd  
root@11f492a28b94:&lt;/span&gt;/pack/nginx# ls /data/&lt;span&gt;
mysql&lt;/span&gt;/&lt;span&gt;  passwd  
 oot@11f492a28b94:&lt;/span&gt;/pack/nginx# ls /data/mysql/mysql3306/data/nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.tar.gz 
&lt;/span&gt;/data/mysql/mysql3306/data/nginx-&lt;span&gt;1.14&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.tar.gz
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样基于dockerfile自主创建镜像的过程就演示完了，快去自己制作一个属于自己的镜像吧。&lt;/p&gt;

</description>
<pubDate>Sat, 01 Dec 2018 06:50:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>前言 在之前的博客《Docker端口映射及创建镜像演示（二）--技术流ken》，演示了如何使用一个现有容器创建一个镜像，以及镜像在阿里云的上传和下载。 但是这样的镜像有很大的局限性，不能根据我们的生产</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/10040805.html</dc:identifier>
</item>
<item>
<title>SDOI2013直径（树的直径） - mxrmxr</title>
<link>http://www.cnblogs.com/mxrmxr/p/10049410.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mxrmxr/p/10049410.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;#include&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;queue&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cmath&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;vector&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstring&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstdlib&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;algorithm&amp;gt;
&lt;span&gt;#define&lt;/span&gt; ll long long 
&lt;span&gt;#define&lt;/span&gt; rint register int
&lt;span&gt;#define&lt;/span&gt; M 200005
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
inline &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; read()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s=&lt;span&gt;0&lt;/span&gt;,f=&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;char&lt;/span&gt; ch=&lt;span&gt;getchar();
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(ch&amp;lt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;||ch&amp;gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;){&lt;span&gt;if&lt;/span&gt;(ch==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)f=-&lt;span&gt;1&lt;/span&gt;;ch=&lt;span&gt;getchar();}
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(ch&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;ch&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;){s=s*&lt;span&gt;10&lt;/span&gt;+ch-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;ch=&lt;span&gt;getchar();}
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s*&lt;span&gt;f;
}
inline ll max(ll a,ll b){&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a&amp;gt;b?&lt;span&gt;a:b;}
ll dis[M],maxx,s,t;
ll n,m,cnt,head[M],vis[M];
ll dep[M],father[M],l,r,ans,son[M];
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; edge
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; to,nex,v;       
}e[M&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; u,&lt;span&gt;int&lt;/span&gt; v,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; w)
{
    e[&lt;/span&gt;++cnt].to=&lt;span&gt;v;
    e[cnt].v&lt;/span&gt;=&lt;span&gt;w;
    e[cnt].nex&lt;/span&gt;=&lt;span&gt;head[u];
    head[u]&lt;/span&gt;=&lt;span&gt;cnt;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dfs(&lt;span&gt;int&lt;/span&gt; u,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; fa)
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(rint i=head[u];i;i=&lt;span&gt;e[i].nex)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v=e[i].to;&lt;span&gt;if&lt;/span&gt;(v==fa) &lt;span&gt;continue&lt;/span&gt;;father[v]=&lt;span&gt;u;
        dis[v]&lt;/span&gt;=dis[u]+&lt;span&gt;e[i].v;dfs(v,u);
    }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; find(&lt;span&gt;int&lt;/span&gt; u,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; fa)
{
    dep[u]&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;;ll maxn=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(rint i=head[u];i;i=&lt;span&gt;e[i].nex)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v=e[i].to;&lt;span&gt;if&lt;/span&gt;(v==father[u] || vis[v]==&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        find(v,u);maxn&lt;/span&gt;=max(maxn,dep[v]+&lt;span&gt;e[i].v);
    }
    dep[u]&lt;/span&gt;=&lt;span&gt;maxn;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    n&lt;/span&gt;=&lt;span&gt;read();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(rint i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n-&lt;span&gt;1&lt;/span&gt;;++&lt;span&gt;i)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x=read(),y=read(),z=&lt;span&gt;read();
        add(x,y,z),add(y,x,z);
    }
    dfs(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(rint i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;++&lt;span&gt;i)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dis[i]&amp;gt;maxx) maxx=dis[i],s=&lt;span&gt;i;
        dis[i]&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    dfs(s,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;);maxx=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(rint i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;++&lt;span&gt;i)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dis[i]&amp;gt;maxx) maxx=dis[i],t=&lt;span&gt;i;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,maxx);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; l=t,r=s,now=&lt;span&gt;t;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(now!=&lt;span&gt;s)
    {
        vis[now]&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        son[father[now]]&lt;/span&gt;=&lt;span&gt;now;
        now&lt;/span&gt;=&lt;span&gt;father[now];
    }
    now&lt;/span&gt;=&lt;span&gt;t;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(now!=&lt;span&gt;s)
    {
        dep[now]&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        find(now,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dep[now]==maxx-dis[now]) l=&lt;span&gt;now;
        now&lt;/span&gt;=&lt;span&gt;father[now];
    }
    now&lt;/span&gt;=&lt;span&gt;s;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(now)
    {
        find(now,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dep[now]==dis[now]) r=&lt;span&gt;now;
        now&lt;/span&gt;=&lt;span&gt;son[now];
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(l!=r &amp;amp;&amp;amp;&lt;span&gt; l)
    {
        l&lt;/span&gt;=&lt;span&gt;father[l];
        &lt;/span&gt;++&lt;span&gt;ans;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ans);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 01 Dec 2018 06:43:00 +0000</pubDate>
<dc:creator>mxrmxr</dc:creator>
<og:description>题目描述： 点这里 题目大意： 就是在一个树上找其直径的长度是多少，以及有多少条边满足所有的直径都经过该边。 题解： 首先，第一问很好求，两边dfs就行了，第一次从任一点找距它最远的点，再从这个点找距</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mxrmxr/p/10049410.html</dc:identifier>
</item>
<item>
<title>Elasticsearch查询 - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/9910788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/9910788.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;Query DSL&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Elasticsearch提供了一个基于JSON的完整的查询DSL（领域特定语言）。它定义的查询语言由两种类型的子句组成：“叶子查询子句”和“组合查询子句”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;叶子查询子句&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;叶子查询子句查找特定字段中的特定值，例如 &lt;span&gt;match&lt;/span&gt;、&lt;span&gt;term&lt;/span&gt; 或 &lt;span&gt;range&lt;/span&gt; 查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;复合查询子句&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复合查询子句包装其他叶子或复合查询，并用于以逻辑方式组合多个查询（如 bool 或 dis_max 查询），或更改其行为（如 constant_score 查询）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.  Query and filter context&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询子句的行为取决于它是用在查询上下文（query context）还是用在过滤器上下文（filter context）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.1.  Query context&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在查询上下文中的查询子句回答了“这个文档与这个查询子句的匹配程度是怎样的？”问题。除了决定文档是否匹配以外，查询子句还会计算一个“&lt;span&gt;_score&lt;/span&gt;”，它表示文档与其他文档的相关程度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2.  Filter context&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在过滤器上下文中，一个查询子句回答了“这个文档与查询子句匹配吗？”的问题。这个答案是简单的Yes或者No，也不会计算分数。过滤上下文主要用于过滤结构化数据，例如：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这个timestamp在2015年到2016年的范围内吗？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这个status字段的值是“published”吗？&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;（&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS：Query VS Filter&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;查询反应的是文档与查询子句的匹配程度，而过滤反应的是文档是否匹配查询子句&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个是筛选是否满足条件，情况无非两种：是或不是；一个是看满足条件的记录与查询条件的匹配程度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;哪些满足条件，这是过滤；满足条件的这些记录与条件的匹配程度，这是查询&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;过滤不会计算评分，查询会计算评分&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;频繁使用的过滤器将被Elasticsearch自动缓存，以提高性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当查询子句中被传递了一个filter参数时过滤器上下文就生效了。例如，bool查询中的filter参数或者must_not参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是一个查询子句的例子，这个查询将匹配满足以下所有条件的文档：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;title&lt;/span&gt; 字段包含单词“&lt;span&gt;search&lt;/span&gt;”&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;content&lt;/span&gt; 字段包含单词“&lt;span&gt;elasticsearch&lt;/span&gt;”&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;status&lt;/span&gt; 字段包含明确的单词“&lt;span&gt;published&lt;/span&gt;”&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;publish_date&lt;/span&gt; 字段的包含的日期大于或等于&lt;span&gt;2015-01-01&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: { 
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: { 
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;must&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
                { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;        }}, 
                { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Elasticsearch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }}  
            ],
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [ 
                { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:  { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;published&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }}, 
                { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publish_date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2015-01-01&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }}} 
            ]
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;关于上面的查询子句作如下说明：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;quary&lt;/span&gt; 参数表示这是一个查询上下文&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;bool&lt;/span&gt; 和 两个&lt;span&gt;match&lt;/span&gt;子句用在查询上下文中，表明它们参与每条文档的打分&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;filter&lt;/span&gt; 参数表明这是过滤器上下文&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;term&lt;/span&gt; 和 &lt;span&gt;range&lt;/span&gt; 子句用在过滤器上下文中，它们会过滤掉不匹配的文档，而且不会影响匹配文档的分数&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;（PS：类比SQL的话，match相当于模糊查询，term相当于精确查询，range相当于范围查询）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.  Match All Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最简单的查询，匹配所有文档，使它们的&lt;span&gt;_score&lt;/span&gt;为1.0&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match_all&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {}
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;_score&lt;/span&gt;可以被改变，通过用&lt;span&gt;boost&lt;/span&gt;参数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match_all&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;1.2&lt;/span&gt;&lt;span&gt; }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;与&lt;span&gt;match_all&lt;/span&gt;相反的是&lt;span&gt;match_none&lt;/span&gt;，它不匹配任何文档&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match_none&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {}
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.  Full text queries&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.1.  Match Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;match&lt;/span&gt;查询接受文本/数值/日期类型的数据，分析它们，并构造一个查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;match是一种布尔类型的查询。这意味着它对提供的文本进行分析，并在分析的过程中为提供的文本构造一个布尔查询。operator 选项可以设置为 or 或者 and 以此来控制布尔子句（默认是 or ）。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意，查询语句都是以“query”开头的，这里“message”是字段名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你也可以加一些参数，比如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;operator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;（PS：match是模糊查询）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.2.  Match Phrase Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;match_phrase&lt;/span&gt; 查询与 match类似，但是它是用于&lt;strong&gt;精确匹配或单词接近匹配&lt;/strong&gt;的。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match_phrase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然，你也可以加参数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match_phrase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;analyzer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my_analyzer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里“analyzer”是用来设置用那个分析器来分析文本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.3.  Match Phrase Prefix Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类似于match_phrase查询，但是对最后一个单词进行通配符搜索。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;match_phrase_prefix&lt;/span&gt;&lt;strong&gt;允许文本的最后一个单词进行前缀匹配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match_phrase_prefix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;quick brown f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;除了match_phrase允许的那些参数外，match_phrase_prefix还可以接受一个max_expansions参数，它是用来控制最后一个单词可以扩展多少后缀（默认50）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match_phrase_prefix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;quick brown f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max_expansions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.4.  Multi Match Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;multi_match&lt;/span&gt; 相当于 match 的多字段版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;顾名思义，multi_match可以指定多个字段，而match只能针对一个字段&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multi_match&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fields&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;subject&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ] 
    }
  }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;另外，字段可以用通配符，例如下面的例子中可以查询 title ， first_name ， last_name 等字段：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multi_match&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:    &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Will Smith&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fields&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ] 
    }
  }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;单个字段可以被提升，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;multi_match&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fields&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;subject^3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ] 
    }
  }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的例子，subject字段的重要性是message字段的三倍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.5.  Query String Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持Lucene查询字符串语法，允许指定 AND | OR | NOT ，并且在单个查询字符串中进行多字段查询&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query_string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default_field&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this AND that OR thus&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;query_string查询解析输入并围绕操作符拆分文本，每个文本部分都是独立分析的，例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query_string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default_field&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(new york city) OR (big apple)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的例子中，将被拆分成 “new york city” 和 “big apple” 两部分，并且每一部分都被分析器独立分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，&lt;strong&gt;按操作符拆分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;query_string的参数包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;query&lt;/span&gt;　　实例被解析的查询文本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;default_field&lt;/span&gt;　　如果没有指定前缀字段的话，这是默认的查询字段。（默认查询所有字段）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;default_operator&lt;/span&gt;　　如果没有明确指定操作符的话，那么这是默认的操作符。例如，如果默认操作符是OR的话，那么“my name is jack”将被翻译成“my OR name OR is OR jack”，同理，如果是AND，则被翻译成“my AND name AND is AND jack”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;analyzer&lt;/span&gt;　　用来解析查询字符串的解析器的名字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;allow_leading_wildcard&lt;/span&gt;　　如果设置了，那么 * 或 ? 允许作为第一个字符。默认是true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;lenient&lt;/span&gt;　　如果设置为true，则格式失败将被忽略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在query_string中，多字段查询应该这样写：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query_string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fields&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this AND that&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;等价于&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query_string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(content:this OR name:this) AND (content:that OR name:that)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面两个是等价的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.6.  Simple Query String Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;simple_query_string 是query_string的一个更简单、更健壮、更适合面向用户的版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用SimpleQueryParser解析上下文的查询。与常规的query_string查询不同，simple_query_string查询永远不会抛出异常，并丢弃查询的无效部分。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;simple_query_string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\&quot;fried eggs\&quot; +(eggplant | potato) -frittata&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fields&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title^5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default_operator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129174915879-250038590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.7.  实例练习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129190452130-2003044879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    删除索引&lt;/span&gt;
curl -X DELETE &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.1.134:9200/book&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    创建索引&lt;/span&gt;
curl -X PUT &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.1.134:9200/book&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;settings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;number_of_shards&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mappings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_doc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:        { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  }, 
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:         { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  }, 
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;introduction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  },
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publish_date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: { 
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;'
&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    查看索引&lt;/span&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.1.134:9200/book?pretty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    插入文档&lt;/span&gt;
curl -X PUT &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.1.134:9200/book/_doc/1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello Java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publish_date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2008-11-15&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;introduction&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is a book for novice.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;'
&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    查看文档&lt;/span&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.1.134:9200/book/_search?pretty&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;match_all&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {}
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129190634450-1321276240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;match查询（注意，match查询只能是针对单个字段）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129220806855-1967842635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个例子中，我们用“Java”查询到2条，接下来用“Java入门”将查到5条&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129221359335-1131043952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是因为解析器会将“Java入门”拆分为“Java”和“入门”两个单词，而且默认的操作符是or&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说，查询的结果是title中包含“Java”或者“入门”的记录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129221913298-272462909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在变成查询title中同时包含“Java”和“入门”的记录，因此只有1条&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; multi_match多字段查询&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129222559407-488304462.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129222944556-1441550964.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;match_phrase查询&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129223325255-848593347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129223334471-240480007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对比不难发现，同样的关键字“Java从”，用match查出5条，用match_phrase只查出1条&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129224132938-1301628245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;query_string查询&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129224721702-293342808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129224736138-1338592683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201811/874963-20181129225139907-722410392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.  Term level queries（单词级别查询）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全文本查询会在执行之前对查询字符串进行分析，而单词级别查询会对存储在反向索引中的精确的term进行操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些查询通常用于结构化的数据，比如：numbers ， dates ，enums 等，而不是对全文本字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（PS：也就是说，全文本查询之前要先对文本内容进行分词，而单词级别的查询直接在相应字段的反向索引中精确查找，单词级别的查询一般用于数值、日期等类型的字段上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.1.  Term Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在指定的字段中查找包含指定的精确的term的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;term查询将在反向索引&lt;span&gt;（或者叫倒排索引）&lt;/span&gt;中查找包含特定的精确的term的文档。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X POST &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Kimchy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; } 
  }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的例子，在user字段的反向索引中查找包含精确的Kimchy的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还可以指定一个boost参数，使这个term查询比另一个查询具有更高的相关性得分。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;should&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
            {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urgent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt; 
                    }
                }
            },
            {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;normal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 
                }
            }
          ]
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个例子中，urgent查询子句有一个boost参数值为2.0，这就意味着它的重要程度是后面的normal查询子句的两倍，normal子句默认的boost是1.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.2.  Terms Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查找包含指定字段中指定的任何确切term的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;筛选出与所提供的terms中任何一个匹配的文档&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;terms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kimchy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;elasticsearch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.3.  Range Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查找指定字段在指定范围内包含值（日期、数字或字符串）的文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面的例子返回age字段的值在10到20之间的文档：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;10&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;20&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;range查询可以接受下列参数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;gte&lt;/span&gt;　　大于或等于&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;gt&lt;/span&gt;　　  大于&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;lte&lt;/span&gt;　　 小于或等于&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;lt&lt;/span&gt;　　   小于&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;boost&lt;/span&gt;　　设置boost值，默认是1.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.3.1.  Range on date fields&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当range查询用于date类型的字段时，范围可以用Date Math表示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now-1d/d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; :  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now/d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当使用Date Math将日期四舍五入到最近的日期、月份、小时等时，四舍五入日期取决于范围的两端是包含的还是排除的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;rounded up 向上舍入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;rounded down 向下舍入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;gt 大于2014-11-18||/M  变成 2014-11-30T23:59:59.999 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;gte 大于或等于2014-11-18||/M  变成 2014-11-01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lt 小于2014-11-18||/M  变成  2014-11-01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;lte 小于或等于2014-11-18||/M  变成2014-11-30T23:59:59.999 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个其实很好理解，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大于2014-11-18||/M相当于是大于2014年11月，因此大于2014-11-18||/M等价于大于2014-11-30 23:59:59&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说，大于11月，相当于是大于11月的最后一天，即11-30 23:59:59&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理，大于或等于2014-11-18||/M，相当于大于或等于11月，自然是11月的第一天，即2014-11-01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理，小于2014-11-18||/M，相当于小于11月，自然是小于11月1日，故而小于2014-11-18||/M等价于小于2014-11-01&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理，小于或等于2014-11-18||/M，等于11月自然是包含11月的，意味着小于11月30日，故而小于或等于2014-11-18||/M等价于小于或等于2014-11-30 23:59:59&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.3.2.  Date format in range query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在日期范围查询的时候，我们可以指定日期格式。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;born&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;01/01/2012&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2013&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dd/MM/yyyy||yyyy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个例子是查询在2012-01-01到2013-12-31之间出生的人&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面看时间范围查询&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2015-01-01 00:00:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;now&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time_zone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+01:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.4.  Exsit Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在特定的字段中查找非空值的文档&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exists&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;field&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.5.  Prefix Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查找包含带有指定前缀的term的文档&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;{ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prefix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ki&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
  }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以关联boost&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;{ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prefix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; :  { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ki&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt; } }
  }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.6.  Wildcard Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持通配符查询，*表示任意字符，?表示任意单个字符&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wildcard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ki*y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以加boost参数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wildcard&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ki*y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt; } }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.7.  Regexp Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正则表达式查询&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;regexp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name.first&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s.*y&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.8.  Ids Query&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用_uid字段查询&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ids&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_doc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;values&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.9.  实例练习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201134036450-1560029823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201134046326-1261854643.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201134055176-397229534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201134107221-1545957553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201134118740-1709883408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201134128270-2046736979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201134140126-1018500646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.  复合查询&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复合查询包装其他复合查询或叶子查询，以组合它们的结果和得分，更改它们的行为，或从查询切换到筛选上下文。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.1.  固定分数查询&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;constant_score&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kimchy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            },
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;1.2&lt;/span&gt;&lt;span&gt;
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5.2.  布尔查询&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201134358699-1279964819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于should子句，特别要注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果这个布尔查询位于查询上下文，并且有must或者filter子句，那么即使should子句没有匹配任何文档，也没关系&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果是位于过滤器上下文，或者既没有must也没有filter，那么至少有一个should查询必须匹配文档。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这个行为可以通过设置minimum_should_match参数来显式地控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201134433373-297882943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
curl -X POST &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;must&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kimchy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
            },
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tag&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tech&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
            },
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;must_not&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;range&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : {
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lte&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;20&lt;/span&gt;&lt;span&gt; }
                }
            },
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;should&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : [
                { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tag&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; } },
                { &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tag&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;elasticsearch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; } }
            ],
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;minimum_should_match&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;boost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;
        }
    }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查询user为“kimchy”，并且tag为“tech”，并且age不在10~20之间，并且tag为wow或elasticsearch的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;filter查询分数默认是0&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -X GET &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:9200/_search&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -H &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type: application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; -d&lt;span&gt;'
&lt;/span&gt;&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;term&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;active&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
      }
    }
  }
}
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5.3.  实例练习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201134917514-163604496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201135252533-1963564772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201140122020-1376415968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201135615008-1349606533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201812/874963-20181201135906641-323137893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&quot; target=&quot;_blank&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 01 Dec 2018 06:32:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<og:description>Query DSL Elasticsearch提供了一个基于JSON的完整的查询DSL（领域特定语言）。它定义的查询语言由两种类型的子句组成：“叶子查询子句”和“组合查询子句”。 叶子查询子句 叶子查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/9910788.html</dc:identifier>
</item>
<item>
<title>Redis数据类型（下） - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/10049236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/10049236.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;集合Set &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;Redis 的集合不是 个线性结构，而是一个&lt;span&gt;哈希表结构&lt;/span&gt;，它的内部会根据 &lt;span&gt;hash 分子&lt;/span&gt;来&lt;/p&gt;
&lt;p&gt;存储和查找数据，理论上 个集合可以存储 232 （大约 42 亿）个元素，因为采用哈希表结&lt;/p&gt;
&lt;p&gt;构，所以对于 &lt;span&gt;Redis 集合的插入、删除和查找的复杂度都是 0(1&lt;/span&gt; ），只是我们需要注意：&lt;/p&gt;

&lt;p&gt;1.对于集合而言，它的每 个元素都是不能重复的，当插入相同记录的时候都会失败&lt;/p&gt;
&lt;p&gt;2.集合是无序的。&lt;/p&gt;
&lt;p&gt;3.集合的每 个元素都是 String 数据结构类型。&lt;/p&gt;

&lt;p&gt;Red is 的集合可以对于不同的集合进行操作，比如求出两个或者以上集合的交集、 差集和并集等。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134445106-1639697718.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134453214-1020421471.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sadd/smembers/sismember&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sadd key number [member2 .....]  给键为key的集合增加成员，可增加多个&lt;/p&gt;
&lt;p&gt;smembers key  返回集合所有成员&lt;/p&gt;
&lt;p&gt;sismember  key member  判断member是否是key集合的成员&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134613452-1965162662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; scard，获取集合里面的元素个数&lt;/p&gt;
&lt;p&gt;    获取集合里面的元素个数&lt;/p&gt;
&lt;p&gt;scard key&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134649602-680225179.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;srem key value 删除集合中元素&lt;/p&gt;
&lt;p&gt;&lt;span&gt;srem key member [ member2 .... ]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;移除集合中 元素，可以是多个元素&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134704914-1203497022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; srandmember key 某个整数(随机出几个数)&lt;/p&gt;
&lt;p&gt; *   从set集合里面随机取出2个&lt;/p&gt;
&lt;p&gt; *   如果超过最大数量就全部取出，&lt;/p&gt;
&lt;p&gt; *   如果写的值是负数，比如-3 ，表示需要取出3个，但是可能会有重复值。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;srandmember key [count]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;count为随机出数的个数，默认为1，为负数则取绝对值&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134721755-1752050869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;spop key 随机出栈&lt;/p&gt;
&lt;p&gt;随机弹 集合的一个元素&lt;/p&gt;
&lt;p&gt;注意其随机性 因为集合是无序的&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134730432-287981847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;smove key1 key2 在key1里某个值      作用是将key1里的某个值赋给key2&lt;/p&gt;
&lt;p&gt;&lt;span&gt;smove src des member&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将成员 member 从集合 src 迁移到集合 des&lt;/p&gt;
&lt;p&gt;原来集合的值可以说已经没有了，直接去了另一个集合，另一个集合可以存在，不存在则创建&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134748285-213707846.png&quot; alt=&quot;&quot; width=&quot;431&quot; height=&quot;283&quot;/&gt;&lt;/p&gt;
&lt;p&gt;差集：sdiff&lt;/p&gt;
&lt;p&gt;交集：sinter&lt;/p&gt;
&lt;p&gt;并集：sunion&lt;/p&gt;

&lt;p&gt;sdiff key I [key2]   找出两个综合的差集                参数如果是单 key ，那么 Red is 就返回这key 的所有元素&lt;/p&gt;
&lt;p&gt;sinter key I [key2]  key key2 两个集合的交集。    参数如果是单 key ，那么 Red is 就返回这key 的所有元素&lt;/p&gt;
&lt;p&gt;sunion key l [key2]     求两 集合 并集                   参数如果是单 key ，那么 Red is 就返回这key 的所有元素&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134803706-11166935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;Hash哈希&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Redis 中哈希结构就如同 Java map 一样 个对象里面有许多键值对，它是特别&lt;/p&gt;
&lt;p&gt;合存储对象的 ，如果内存足够大，那么 Redis hash 结构可以存储 232_ 键值对 40&lt;/p&gt;
&lt;p&gt;多亿）。 般而言 不会使用到那么大的一个键值对，所以我们认为 Redis 可以存储很多的&lt;/p&gt;
&lt;p&gt;键值对。在 Redis 中， hash 是一个 String 类型的 field value 映射表，因此我们存储的&lt;/p&gt;
&lt;p&gt;数据实际在 Redis内存中的一个字符串&lt;/p&gt;

&lt;p&gt;hash 的键值对在内存中是一种无序的状态&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134824345-1410891825.png&quot; alt=&quot;&quot; width=&quot;471&quot; height=&quot;221&quot;/&gt;&lt;p&gt;&lt;strong&gt;KV模式不变，但V是一个键值对&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;11&quot;&gt; 
&lt;p&gt;hset/hget/hmset/hmget/hgetall/hdel&lt;/p&gt;
&lt;p&gt;hset key file value:设置键值对&lt;span&gt;  单个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;hget ：获取属性值  &lt;span&gt;单个&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134903782-115809841.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;hmset key field1 value1 [filed2 value2...]  设置键值对， &lt;span&gt;多个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;hmget：获取多个hash指定键的值   &lt;span&gt;多个&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134919604-1975778821.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;hgetall：获取所有hash结构中的值&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134928359-1177008909.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;hdel：删除hash中的某些字段&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134940968-623317841.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; hlen返回key中的数量&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134948597-1459017706.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; hexists key 在key里面的某个值的key&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201134955088-478314238.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;hkeys/hvals&lt;/p&gt;
&lt;p&gt;hkeys：获取所有的键&lt;/p&gt;
&lt;p&gt;hvals：获取所有的值&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135002761-1339363339.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;hincrby/hincrbyfloat&lt;/p&gt;
&lt;p&gt;hincrby key field incremen：指定给 hash 结构中的某 字段加上 个整，要求该字段也是整数字符串&lt;/p&gt;
&lt;p&gt;hincrbyfloat key field increment：指定给 hash 结构中的某 字段加上 个浮点数，要求该字段也是整数字符串&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135011507-597388023.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; hsetnx：不存在赋值，&lt;span&gt;存在了无效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;hsetnx key field value&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135028519-910375290.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;div readability=&quot;14&quot;&gt; 
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;有序集合：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;只是说它是有序的&lt;/p&gt;
&lt;p&gt;和无序集合的主要区别在于每 个元素除了值之外，它还会&lt;span&gt;多一个分数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分数是一个浮点数，在 Java 中是使用双精度表示的&lt;/p&gt;

&lt;p&gt;Redis 就可以支持对分数从小到大或者从大到小的排序。这里和无序集合一样，对于&lt;/p&gt;
&lt;p&gt;每一个元素都是唯一的 ，但是对于不同元素而 ，它的分&lt;span&gt;数可以一样。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135445366-1672049857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有序集合是依赖 key 标示它是属于哪个集合，依赖分数进行排序，所以值和分数是必须的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135503141-522903566.png&quot; alt=&quot;&quot; width=&quot;479&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135509085-1997918991.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;203&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135523215-390960779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; zadd/zrange&lt;/p&gt;
&lt;p&gt;zadd key &lt;span&gt;score value（value1&lt;/span&gt;） 【score2 value2 ...] :增加一个或多个成员，key不存在则创建有序集合&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135553441-476656467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135558193-781692518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; zrangebyscore key 开始score 结束score&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135606489-1930320426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135608979-134861276.png&quot; alt=&quot;&quot; width=&quot;539&quot; height=&quot;283&quot;/&gt;&lt;/p&gt;
&lt;p&gt;zrem key 某score下对应的value值，作用是删除元素&lt;/p&gt;

&lt;p&gt;zcard/zcount key score区间/zrank key values值，作用是获得下标值/zscore key 对应值,获得分数&lt;/p&gt;
&lt;p&gt;zcard：统计个数&lt;/p&gt;
&lt;p&gt;zcount key score： zcount key min max        根据&lt;span&gt;分数&lt;/span&gt;返回对应的成员列表&lt;/p&gt;
&lt;p&gt;zrank key values：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135639485-1633013589.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;227&quot;/&gt;&lt;/p&gt;
&lt;p&gt;zrevrank key values值，作用是&lt;span&gt;逆序&lt;/span&gt;获得&lt;span&gt;下标值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135703304-1600870737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; zrevrange  从大到小的按分数排序&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;zrevrange key start end&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135710448-605304265.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;zrevrangebyscore  key 结束score 开始score&lt;/p&gt;
&lt;p&gt;从大到小的按分数排序&lt;/p&gt;
&lt;p&gt;zrevrangebyscore key max min [withscores&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181201135720702-1611638524.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 05:58:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>集合Set Redis 的集合不是 个线性结构，而是一个哈希表结构，它的内部会根据 hash 分子来 存储和查找数据，理论上 个集合可以存储 232 （大约 42 亿）个元素，因为采用哈希表结 构，所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/10049236.html</dc:identifier>
</item>
<item>
<title>css-flex布局知识梳理 - 玲小径</title>
<link>http://www.cnblogs.com/xiaolingyan/p/10049235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaolingyan/p/10049235.html</guid>
<description>&lt;h2&gt;一.传统的布局&lt;/h2&gt;
&lt;p&gt;布局的传统解决方案，基于盒装模型，依赖 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/display&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;display&lt;/code&gt;&lt;/a&gt; 属性 + &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/position&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;position&lt;/code&gt;&lt;/a&gt;属性 + &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/float&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;属性。它对于那些特殊布局非常不方便，比如，&lt;a href=&quot;https://css-tricks.com/centering-css-complete-guide/&quot; target=&quot;_blank&quot;&gt;垂直居中&lt;/a&gt;就不容易实现。&lt;/p&gt;
&lt;h2&gt;二. Flex的兼容性写法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.flex &lt;/span&gt;{&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; -webkit-box&lt;/span&gt;;&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; -webkit-flex&lt;/span&gt;; /*safair*/&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; -ms-flexbox&lt;/span&gt;;&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; flex&lt;/span&gt;;&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; -moz-box&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 老版本火狐语法 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意，设为 Flex 布局以后，子元素的&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;clear&lt;/code&gt;和&lt;code&gt;vertical-align&lt;/code&gt;属性将失效。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三. 原理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;采用Flex布局的称其为“容器”，它的所有子元素称为 “项目”。容器默认存在两根轴，从数学角度，我称其分别为：x轴和y轴。Flex布局基本以这两根轴为准。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四. 容器的属性&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;flex-direction&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;flex-wrap&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;flex-flow&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;justify-content&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;align-items&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;align-content&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;4.1 flex-direaction属性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;flex-direction属性决定项目的排列方向, &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box &lt;/span&gt;{&lt;span&gt;
  flex-direction&lt;/span&gt;:&lt;span&gt; row | row-reverse | column | column-reverse&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.2 flex-wrap属性&lt;/h3&gt;
&lt;p&gt;默认情况下，项目都排在一条线（又称&quot;轴线&quot;）上。&lt;code&gt;flex-wrap&lt;/code&gt;属性定义，如果一条轴线排不下，如何换行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box&lt;/span&gt;{&lt;span&gt;
  flex-wrap&lt;/span&gt;:&lt;span&gt; nowrap | wrap | wrap-reverse&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;nowrap: 默认不换行；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wrap&lt;/code&gt;：换行，第一行在上方。&lt;/p&gt;
&lt;p&gt;wrap-reverse: 换行，第一行在下方。&lt;/p&gt;
&lt;h3&gt;4.3 flex-flow属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-flow&lt;/code&gt;属性是&lt;code&gt;flex-direction&lt;/code&gt;属性和&lt;code&gt;flex-wrap&lt;/code&gt;属性的简写形式，默认值为&lt;code&gt;row nowrap&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box &lt;/span&gt;{&lt;span&gt;
  flex-flow&lt;/span&gt;:&lt;span&gt; &amp;lt;flex-direction&amp;gt; || &amp;lt;flex-wrap&amp;gt;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.4 justify-content属性&lt;/h3&gt;
&lt;p&gt;justify-content属性定义了项目在X轴上的对齐方式。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box &lt;/span&gt;{&lt;span&gt;
  justify-content&lt;/span&gt;:&lt;span&gt; flex-start | flex-end | center | space-between | space-around&lt;/span&gt;;      
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1516520/201812/1516520-20181201133054414-2013866662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;flex-start&lt;/code&gt;（默认值）：左对齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flex-end&lt;/code&gt;：右对齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;center&lt;/code&gt;： 居中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;space-between&lt;/code&gt;：两端对齐，项目之间的间隔都相等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;space-around&lt;/code&gt;：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.5 align-item 属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-items&lt;/code&gt;属性定义项目在Y轴上如何对齐。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box &lt;/span&gt;{&lt;span&gt;
  align-items&lt;/span&gt;:&lt;span&gt; flex-start | flex-end | center | baseline | stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1516520/201812/1516520-20181201133737577-657756384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4.6 align-content属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-content&lt;/code&gt;属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box &lt;/span&gt;{&lt;span&gt;
  align-content&lt;/span&gt;:&lt;span&gt; flex-start | flex-end | center | space-between | space-around | stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1516520/201812/1516520-20181201134104883-982195923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;五.项目的属性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;order&lt;/li&gt;
&lt;li&gt;flex-grow&lt;/li&gt;
&lt;li&gt;flex-shrink&lt;/li&gt;
&lt;li&gt;flex-basis&lt;/li&gt;
&lt;li&gt;flex&lt;/li&gt;
&lt;li&gt;align-self&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5.1 order属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;order&lt;/code&gt;属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item &lt;/span&gt;{&lt;span&gt;
  order&lt;/span&gt;:&lt;span&gt; &amp;lt;integer&amp;gt;&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.2 flex-grow属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-grow&lt;/code&gt;属性定义项目的放大比例，默认为&lt;code&gt;0&lt;/code&gt;，即如果存在剩余空间，也不放大。&lt;/p&gt;
&lt;p&gt;如果所有项目的&lt;code&gt;flex-grow&lt;/code&gt;属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的&lt;code&gt;flex-grow&lt;/code&gt;属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item &lt;/span&gt;{&lt;span&gt;
  flex-grow&lt;/span&gt;:&lt;span&gt; &amp;lt;number&amp;gt;&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; default 0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1516520/201812/1516520-20181201134915123-1484667384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5.3 flex-shrink属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-shrink&lt;/code&gt;属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。&lt;/p&gt;
&lt;p&gt;如果所有项目的&lt;code&gt;flex-shrink&lt;/code&gt;属性都为1，当空间不足时，都将等比例缩小。如果一个项目的&lt;code&gt;flex-shrink&lt;/code&gt;属性为0，其他项目都为1，则空间不足时，前者不缩小。&lt;/p&gt;
&lt;h3&gt;5.4 flex-basis属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-basis&lt;/code&gt;属性定义了在分配多余空间之前，项目占据的X轴空间（main size）。浏览器根据这个属性，计算X轴是否有多余空间。它的默认值为&lt;code&gt;auto&lt;/code&gt;，即项目的本来大小。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item &lt;/span&gt;{&lt;span&gt;
  flex-basis&lt;/span&gt;:&lt;span&gt; &amp;lt;length&amp;gt; | auto&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; default auto &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.5 flex属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex&lt;/code&gt;属性是&lt;code&gt;flex-grow&lt;/code&gt;, &lt;code&gt;flex-shrink&lt;/code&gt; 和 &lt;code&gt;flex-basis&lt;/code&gt;的简写，默认值为&lt;code&gt;0 1 auto&lt;/code&gt;。后两个属性可选。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item &lt;/span&gt;{&lt;span&gt;
  flex&lt;/span&gt;:&lt;span&gt; none | [ &amp;lt;'flex-grow'&amp;gt; &amp;lt;'flex-shrink'&amp;gt;? || &amp;lt;'flex-basis'&amp;gt; ]
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该属性有两个快捷值：&lt;code&gt;auto&lt;/code&gt; (&lt;code&gt;1 1 auto&lt;/code&gt;) 和 none (&lt;code&gt;0 0 auto&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。&lt;/p&gt;

&lt;h3&gt;5.6 align-self属性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-self&lt;/code&gt;属性允许单个项目有与其他项目不一样的对齐方式，可覆盖&lt;code&gt;align-items&lt;/code&gt;属性。默认值为&lt;code&gt;auto&lt;/code&gt;，表示继承父元素的&lt;code&gt;align-items&lt;/code&gt;属性，如果没有父元素，则等同于&lt;code&gt;stretch&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.item &lt;/span&gt;{&lt;span&gt;
  align-self&lt;/span&gt;:&lt;span&gt; auto | flex-start | flex-end | center | baseline | stretch&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1516520/201812/1516520-20181201135345578-1118165850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 参考资料： http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 05:57:00 +0000</pubDate>
<dc:creator>玲小径</dc:creator>
<og:description>一.传统的布局 布局的传统解决方案，基于盒装模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaolingyan/p/10049235.html</dc:identifier>
</item>
<item>
<title>ES 6 promiss - 天凉好个秋ウ</title>
<link>http://www.cnblogs.com/feixian0903/p/10049119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixian0903/p/10049119.html</guid>
<description>&lt;p&gt;ES6 规定 Promise对象是一个构造函数，用来生成 Promise实列, 如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
var promise = new Promise((resolve, reject) =&amp;gt; {
  if (true) {
    resolve(value);
  } else {
    reject(error);
  }
});
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;resolve 函数的作用是&lt;/strong&gt;，将promise对象的状态从 &quot;未完成&quot;（Pending） 变为 “成功”(Resolved), 在异步操作成功调用时，并将异步操作的结果，作为参数传递出去。&lt;br/&gt;&lt;strong&gt;reject函数的作用是&lt;/strong&gt;，将promise对象的状态 从 &quot;未完成&quot;(Pending) 变为 &quot;失败&quot;（Rejected）, 在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。&lt;br/&gt;promise实列生成以后，可以使用then方法分别指定 Resolved状态 和 （Rejected）状态的回调函数。&lt;/p&gt;
&lt;p&gt;下面是一个Promise对象的简单列子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
function timeout (ms) {
  return new Promise ((resolve, reject) =&amp;gt; {
    setTimeout(resolve, ms, 'done');
  });
}

timeout(100).then((value) =&amp;gt; {
  console.log(value); // done
})
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如上代码，timeout函数返回一个Promise对象的实例，过了指定的时间以后，Promise的实例状态变为Resolved，然后触发then指定的回调。参数值就是实例状态变为Resolved传进来的 done，因此输出done。&lt;/p&gt;
&lt;p&gt;Promise新建后就会立即执行，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
const promise = new Promise((resolve, reject) =&amp;gt; {
  console.log('Promise');
  resolve();
});
promise.then(()=&amp;gt; {
  console.log('Resilved');
});
console.log('Hi');
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;输出结果是 Promise  Hi  Resilved done&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Promise新建后立即执行，所以首先输出的是 Promise， 然后promise对象resolve方法是异步的，所以先执行完所有同步的方法才会执行resolve中的方法， 因此输出HI，&lt;br/&gt;最后输出 Resilved, 最后100ms后，又执行timeout方法，最后输出 done&lt;/p&gt;
&lt;p&gt;下面是一个用&lt;code&gt;Promise&lt;/code&gt;对象实现的 Ajax 操作的例子。&lt;/p&gt;
&lt;p&gt;如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
var getJSON = function(url) {
  var promise = new Promise((resolve, reject) =&amp;gt; {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onreadystatechange = handler;
    xhr.responseType = 'json';
    xhr.setRequestHeader('Accept', 'application/json');
    xhr.send();
    function handler() {
      if (this.readyState !== 4) {
        return;
      }
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    }
  });
  return promise;
};

var url = 'http://httpbin.org/get';
getJSON(url).then((json) =&amp;gt; {
  console.log(json); // 返回json对象
}, (error)=&amp;gt; {
  console.log(error);
});
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面调用resolve函数和reject函数都带有参数，他们的参数会传递给回调函数，reject函数的参数一般是Error对象的实列，表示抛出的错误，resolve函数的参数一般是正常的值，当然还有可能是promise对象的实列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-2 理解 Promise.prototype.then()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Promise实例具有then方法，该作用是为Promise实例添加状态改变时的回调函数。该方法的第一个参数是Resolved状态的回调函数，第二个参数是Rejected状态的回调函数。&lt;br/&gt;then方法返回的是一个新的Promise实例。因此我们可以采用链式的写法，即then方法后面再调用另一个then方法。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
getJSON(url).then((json)=&amp;gt;{
  console.log(2);
  console.log(json); // 返回json对象
  return json;
}).then((data) =&amp;gt; {
  console.log(1);
  console.log(data); // 返回和上面一样的json对象
});
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面的代码使用then方法，使用了2个回调函数，第一个回调函数完成以后，将返回的结果作为参数，传入第二个回调函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-3 理解 Promise.prototype.catch()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Promise.prototype.catch方法是 .then(null, rejection)的别名，用于指定发生错误时的回调函数。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
getJSON(url).then((json)=&amp;gt; {
  // ...
}).catch((error) =&amp;gt; {
  console.log('发生错误');
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved, 则会调用then方法的回调函数，如果异步操作抛出错误，状态就会变为 Rejected，就会调用catch方法的回调函数，来处理这个错误。如下是一个发生错误的demo.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
var promise2 = new Promise((resolve, reject) =&amp;gt; {
  throw new Error('test');
});
promise2.catch((error)=&amp;gt; {
  console.log(error);
});
// 其实上面的代码和下面的代码是等价的
// 写法一
var p3 = new Promise((resolve, reject) =&amp;gt; {
  try {
    throw new Error('test')
  } catch (e) {
    reject(e);
  }
});
p3.catch((error) =&amp;gt; {
  console.log(error);
});

// 写法二
var p4 = new Promise((resolve, reject) =&amp;gt; {
  reject(new Error('test'));
});
p4.catch((error) =&amp;gt; {
  console.log(error);
});
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;但是如果Promise状态已经变成 Resolved的话，再抛出错误是没有用的了。如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
var p5 = new Promise((resolve, reject) =&amp;gt; {
  resolve('ok');
  throws new Error('test'); // 这句无效
});

p5.then((value) =&amp;gt; {
  console.log(value);
}).catch((error)=&amp;gt; {
  console.log(error);
})
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面代码中，在resolve后面再抛出错误是不会被扑获到的，因为Promise的状态一旦改变，就永久保持该状态。&lt;br/&gt;Promise对象的错误具有传递性质，它会一直往下传递，直到被catch捕获到为止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 一般来讲，不要在then方法里面定义Reject状态的回调函数(then的第二个参数)，总是使用catch语句。比如如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
// bad的写法
  var p6 = new Promise((resolve, reject) =&amp;gt; {
    
  });
  p6.then((data) =&amp;gt; {
    // success
  }, (error)=&amp;gt;{
    // error
  });

  // good的写法
  p6.then((data) =&amp;gt; {
    // success
  }).catch((error) =&amp;gt; {
    // error
  });
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面的代码中，第二种写法比第一种写法好，第二种写法可以捕获到前面then方法执行中的错误。因此我们建议使用catch方法，而不使用then方法的第二个参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-4 理解Promise.all()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。如下代码：&lt;br/&gt;&lt;strong&gt;var P = Promise.all([p1, p2, p3]);&lt;/strong&gt;&lt;br/&gt;该方法接收一个数组作为参数，p1, p2, p3都是Promise的实列，如果他们不是实列的话，会先调用 Promise.resolve方法，将参数转为Promise实例。&lt;br/&gt;当p1, p2, p3的状态都变成 fulfilled的时候，p的状态才会变成成功状态。当他们之中有一个是 rejected的话，那么p的状态就变为失败的状态。&lt;br/&gt;注意点： 如果作为参数的Promise实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
const p11 = new Promise((resolve, reject) =&amp;gt; {
   resolve('hello');
 }).then(res =&amp;gt; res).catch(e =&amp;gt; e);
 const p22 = new Promise((resolve, reject) =&amp;gt; {
   throw new Error('报错了');
 }).then(res =&amp;gt; res).catch(e=&amp;gt;e);

 Promise.all([p1, p2]).then(res =&amp;gt; console.log(res)).catch(e=&amp;gt;console.log(e));
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;上面代码中， p11会 resolved， p22首先会rejected，但是p22有自己的catch方法，该方法会返回一个新的Promise的实例，执行完catch方法后，也会变成resolved，导致promise.all方法参数里面的两个实例都会resolved，因此会调用then方法指定的回调函数，不会调用catch方法指定的回调函数。&lt;br/&gt;&lt;strong&gt;1-5 理解Promise.race()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该方法同样是将多个Promise的实例，包装成一个新的Promise实例。&lt;br/&gt;var p = Promise.race([p1, p2, p3]);&lt;br/&gt;Promise.race 与 Promise.all的相同点：如果不是Promise的实例，就会先调用 Promise.resolve方法，将参数转为Promise的实例。&lt;br/&gt;不同点是： 只要p1, p2, p3 其中任何一个实例先改变状态，那么P的状态就会跟着改变。也就是说那个先改变Promise实例的返回值，就传递给P的回调函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-6 理解Promise.resolve()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该方法的作用是：可以将现有的对象转为Promise对象。比如如下代码：&lt;br/&gt;var jsPromise = Promise.resolve({&quot;a&quot;:1});&lt;br/&gt;其实上面的代码等价与下面的代码：&lt;br/&gt;new Promise(resolve =&amp;gt; resolve({&quot;a&quot;: 1}));&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-7 理解 Promise.reject()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Promise.reject()方法返回一个新的Promise实例，该实例的状态为 rejected。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
var p33 = Promise.reject('出错了');
 p33.then(null, (s) =&amp;gt; {
   console.log(s); // 出错了
 });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码生成一个Promise对象的实例p33，状态为rejected，回调函数会立即执行。&lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 05:16:00 +0000</pubDate>
<dc:creator>天凉好个秋ウ</dc:creator>
<og:description>ES6 规定 Promise对象是一个构造函数，用来生成 Promise实列, 如下代码： resolve 函数的作用是，将promise对象的状态从 &quot;未完成&quot;（Pending）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixian0903/p/10049119.html</dc:identifier>
</item>
<item>
<title>WebGL之shaderToy初使用 - ccentry</title>
<link>http://www.cnblogs.com/ccentry/p/10049113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ccentry/p/10049113.html</guid>
<description>&lt;p&gt;　　做图形就要玩shader，我的shader进阶之路，从学习怎么使用shaderToy开始。首先介绍我是看哪篇文章学习的，给出参考文章地址：https://blog.csdn.net/xufeng0991/article/details/78076824，由于本菜鸟是第一次玩shaderToy，就完全根据&lt;a id=&quot;uid&quot; href=&quot;https://blog.csdn.net/xufeng0991&quot; target=&quot;_blank&quot;&gt;丿寒灬风丨&lt;/a&gt;博主的脚步往前走，一步一步学。&lt;/p&gt;
&lt;p&gt;　　第一步，咱来注册一个账号哈。简单方便，有账号了，我的shaderToy账号就是ccentry，截图一张&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445864/201812/1445864-20181201110152178-1782583103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　好了，我们已经可以看到，有很多demo可供学习，那么我们就来做一个我们自己的小demo吧。我们新建一个demo，我们看到新建的demo给出了示例代码，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445864/201812/1445864-20181201114536376-1546130988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在右侧的editor中我们可以看到，片段着色器的主函数是mainImage，带2个参数 fragColor和fragCoord，其中fragColor是out vec4思维向量，fragCoord是in vec2二维向量，前者代表rgba颜色，后者代表屏幕XY的坐标。我们来看看片段着色器对这两个参数都做了什么事。下面先把代码贴出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; mainImage( &lt;span&gt;out&lt;/span&gt; vec4 fragColor, &lt;span&gt;in&lt;/span&gt;&lt;span&gt; vec2 fragCoord )
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Normalized pixel coordinates (from 0 to 1)&lt;/span&gt;
    vec2 uv = fragCoord/&lt;span&gt;iResolution.xy;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Time varying pixel color&lt;/span&gt;
    vec3 col = &lt;span&gt;0.1&lt;/span&gt; + &lt;span&gt;0.5&lt;/span&gt;*cos(iTime+uv.xyx+vec3(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Output to screen&lt;/span&gt;
    fragColor = vec4(col,&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们看到第一句注释//Normalized pixel coordinates (from 0 to 1)，这句是说单位化片段的XY坐标，使片段XY处于0到1区间内，这是怎么做到的呢，他是通过将片段坐标去除以iResolution分辨率的xy，这就很讨巧了，不管你屏幕分辨率怎么变化，都能将你的片段坐标单位化到空间(0, 1)区间内，这样就能统一空间坐标系了不是。&lt;/p&gt;
&lt;p&gt;　　接下来的第二件事就和时间轴有关系了我们在第二句代码中一点一点来分析，第二句代码是变色的关键，我们先来看这个0.1，这个我把他理解为环境光，当该值为0.1时，我们来看看显式的效果是怎么样的，如下图所示。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445864/201812/1445864-20181201121601030-1883826538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，画布的颜色是偏暗的，接下来就要满足我的好奇心，我们把他改成0.7看看会怎么样，请看修改后的结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445864/201812/1445864-20181201122316603-905471771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到，画布整个变亮了，这说明就是这个参数调节整个画布的明暗程度，此参数越大，画布越亮，越小越暗。&lt;/p&gt;
&lt;p&gt;　　接下来我们看看第二句代码还做了什么事，我们看到0.5*cos()，那么这个0.5所代表的是啥，这里做个实验，我改成0.1试试啥效果，请看下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445864/201812/1445864-20181201123856207-68331681.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再把他改成0.7试试看，效果如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1445864/201812/1445864-20181201124103369-1194414012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们对比一下发现，这是透明度的参数，越小越透明，越大越不透明。接下去我们看cos()内部的操作。我们在cos()内部是这样写的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
iTime*&lt;span&gt;0.3&lt;/span&gt;+uv.xyx+vec3(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的iTime是帧刷新率，这个数越大，动画速度越快，也就是同样的操作帧速越高。这里*0.3就是减缓速度。uv.xyx是片段的坐标，很多小伙伴问，为啥是xyx不是xxx也不是xyy呢，那么我做了一下实验，这个xyx是横向纵向横向绘制，xyy是横向纵向纵向绘制，xxx是横向横向横向绘制，最后的vec3()是绘制的颜色。不好理解，我就是靠自己不断的改参数实验出来的结论。接下来这个cos我也改成sin，发现也是呈渐变的绘制，所以这个数学函数可以改成任意的三角函数，就是一个时间曲线，类似bezier曲线。控制绘制时间周期的&lt;br/&gt;　　最后我们来看看最后一句代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Output to screen&lt;/span&gt;
    fragColor = vec4(col,&lt;span&gt;1.0&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单，如注释所言，输出绘制的片段到屏幕上。&lt;br/&gt;　　这是我第一次尝试shaderToy，谨以此篇记录第一步，再接再厉，给自己打打气。感谢J.C大佬，继续学习shader。如需引用本文，请注明出处：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: WebGL之shaderToy初使用&quot; href=&quot;https://www.cnblogs.com/ccentry/p/10049113.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ccentry/p/10049113.html&lt;/a&gt;                       &lt;/p&gt;
</description>
<pubDate>Sat, 01 Dec 2018 05:14:00 +0000</pubDate>
<dc:creator>ccentry</dc:creator>
<og:description>做图形就要玩shader，我的shader进阶之路，从学习怎么使用shaderToy开始。首先介绍我是看哪篇文章学习的，给出参考文章地址：https://blog.csdn.net/xufeng099</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ccentry/p/10049113.html</dc:identifier>
</item>
</channel>
</rss>