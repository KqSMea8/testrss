<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>在做vue计算属性，v-for处理数组时遇到的一个bug - CodingHot</title>
<link>http://www.cnblogs.com/stephentian/p/8322378.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stephentian/p/8322378.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;h3 id=&quot;bug-you-may-have-an-infinite-update-loop-in-a-component-render-function-无限循环&quot;&gt;bug: You may have an infinite update loop in a component render function 无限循环&lt;/h3&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li&gt;需要处理的数组(在 ** ssq **里)：&lt;br/&gt;&lt;code&gt;bonus_code: ['01', '19', '25', '26', '27', '33', '10']&lt;/code&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;计算属性 computed：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssqRed: function() {
return this.ssq.bonus_code.splice(0, 6)
},
ssqBlue: function() {
return this.ssq.bonus_code.splice(6, 7)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;v-for 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;em class=&quot;red-ball tac mr5 fl&quot; v-for=&quot;(item, index) in ssqRed&quot;&amp;gt;{{ item }}&amp;lt;/em&amp;gt;
&amp;lt;em class=&quot;blue-ball tac mr5 fl&quot; v-for=&quot;(item, index) in ssqBlue&quot;&amp;gt;{{ item }}&amp;lt;/em&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最终结果我想把数组前6个数渲染成红色球，最后一个（也就是第7个）渲染成蓝色。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;解答&quot;&gt;解答&lt;/h2&gt;
&lt;h3 id=&quot;我已经在-segmentfault上提问地址vue计算属性computed同时操作一个数组&quot;&gt;我已经在 SegmentFault上提问，地址：&lt;a href=&quot;https://segmentfault.com/q/1010000012919077&quot;&gt;vue计算属性computed同时操作一个数组&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我已采纳答案，将代码改成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssqRed: function() {
    return this.ssq.bonus_code.slice(0, 6)
},
ssqBlue: function() {
    return this.ssq.bonus_code.slice(6, 7)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题就在于自己没搞清楚 splice会对原数组造成改变。&lt;/p&gt;
&lt;h3 id=&quot;在寻找解决方案时朋友少晖教给我一种更好的解决方式很感谢&quot;&gt;在寻找解决方案时，朋友少晖教给我一种更好的解决方式，很感谢&lt;/h3&gt;
&lt;p&gt;即类名判断&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li&gt;如果数组大小已知，就做一个类名判断，索引大于多少展示蓝色的类名就行了；&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;处理后的 html代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;em v-for=&quot;(item, index) in ssq.bonus_code&quot; :class=&quot;['tac','mr5','fl',index&amp;gt;5?'blue-ball':'red-ball']&quot; &amp;gt;{{ item }}&amp;lt;/em&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;增加的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;index&amp;gt;5?'blue-ball':'red-ball'&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 20 Jan 2018 15:45:00 +0000</pubDate>
<dc:creator>CodingHot</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stephentian/p/8322378.html</dc:identifier>
</item>
<item>
<title>通过一个案例分析贝叶斯公式与机器识别 - kingking512</title>
<link>http://www.cnblogs.com/kingking512/p/8322360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingking512/p/8322360.html</guid>
<description>&lt;p&gt;贝叶斯公式定义如下，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/882900/201801/882900-20180120224159740-428898762.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公式大家都知道，如何理解呢？下面给一个机器识别相关的例子，直观地说明。&lt;/p&gt;
&lt;p&gt;在机器识别中，假设机器要识别“一”所在的这个小图像块表示什么字符（可以想象为拿手机对着一页书拍了张照片，机器要认出照片中“一”这个区域代表的是什么字）。&lt;/p&gt;
&lt;p&gt;我们先看“一”字在几何上的特点是什么呢？大概认为是 宽高比很大 + 宽度与整篇文章的平均字宽度相当 + 纵向位置在其所在行的中间位置附近。&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;p&gt;“待识别的图像是一”  是 “事件”，&lt;/p&gt;
&lt;p&gt;“宽高比很大 + 宽度与整篇文章的平均字宽度相当 + 纵向位置在其所在行的中间位置附近”  是  “信息”，&lt;/p&gt;
&lt;p&gt;则 P(信息|事件) 的物理意义为， 在图像代表的字符为“一”的情况下， 它的几何特点为 “宽高比很大 + 宽度与整篇文章的平均字宽度相当 + 纵向位置在其所在行的中间位置附近” 的概率。&lt;/p&gt;
&lt;p&gt;基本上，在编写类似OCR这样的模式识别软件时，我们都需要做数据字典，此时每个字符到底是什么是已知的，要做的是尽量准确地提出其特征。对这个例子而言就是要提取字符“一”的几何特点描述，固化为数据字典中“一”这个内码对应的描述数据。用贝叶斯公式的语音来说，就是要不断修正 P(信息|事件)。&lt;/p&gt;
&lt;p&gt;再看，&lt;/p&gt;
&lt;p&gt;P(信息)表示什么呢？ 表示在所有待识别的图像小方块中，满足 “宽高比很大 + 宽度与整篇文章的平均字宽度相当 + 纵向位置在其所在行的中间位置附近”  这个几何特点的小方块占所有小方块的比例是多少，或者说概率是多少。&lt;/p&gt;
&lt;p&gt;P(事件)，表示“一”这个字的字频， 也即是在所有文章中出现“一”的概率有多少（我们认为机器需要识别所有的中文文章）&lt;/p&gt;
&lt;p&gt;现在来看 P(事件|信息)，&lt;/p&gt;
&lt;p&gt;P(事件|信息) 表示 当软件遇到一个小图像块，而这个小图形块的几何特点是“宽高比很大 + 宽度与整篇文章的平均字宽度相当 + 纵向位置在其所在行的中间位置附近”时， 它是“一”的概率 —— 可以认为这就是对机器识别，或人工智能最简单的描述。&lt;/p&gt;
&lt;p&gt;可以看到，&lt;/p&gt;
&lt;p&gt;1.  P(事件|信息)与 P(信息|事件)正相关，这表示我们在进行机器学习训练时，对“一”的几何特征训练得越精确（即是P(信息|事件)越大），则在对实际样张的识别中，遇到这样的几何特征时，将它识别为“一”是正确的概率越高（即是P(事件|信息)越大）。&lt;/p&gt;
&lt;p&gt;2.  P(事件|信息)与 P(信息)负相关，这表示如果很多待识别的小图像方块几何特点都是“宽高比很大 + 宽度与整篇文章的平均字宽度相当 + 纵向位置在其所在行的中间位置附近”（P(信息)很大）， 就意味着“如果这么多字符的特点都是这个吊样，那么我就没把握说它恰好是“一”了”（P(事件|信息)很小）；反之，如果只有“一“的特点是“宽高比很大 + 宽度与整篇文章的平均字宽度相当 + 纵向位置在其所在行的中间位置附近”（P(信息)很小），其它字符的特点都不是这样，那我遇到这个具有这个特点的小图像块，就可以信心满满地说它就是“一”字了（P(事件|信息)很大）。&lt;/p&gt;
&lt;p&gt;3. P(事件|信息)与 P(事件)正相关，这表示如果“一”的字频很高、在所有的文章中出现的频率很高（P(事件)大），那我说待识别的小图像块是“一”的正确性概率当然就比较高（P(事件|信息)大）；反之，如果“一”是个生僻字，在一般的文章中根本就没出现过几次（P(事件)小），那我说待识别的小图像块是“一”的正确性概率当然也就比较低了（P(事件|信息)小）。&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jan 2018 15:38:00 +0000</pubDate>
<dc:creator>kingking512</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingking512/p/8322360.html</dc:identifier>
</item>
<item>
<title>Angular17 Angular自定义指令 - NeverCtrl_C</title>
<link>http://www.cnblogs.com/NeverCtrl-C/p/8322327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeverCtrl-C/p/8322327.html</guid>
<description>&lt;h2&gt;1 什么是HTML&lt;/h2&gt;
&lt;p&gt;　　HTML文档就是一个纯文本文件，该文件包含了HTML元素、CSS样式以及JavaScript代码；HTML元素是由标签呈现，浏览器会为每个标签创建带有属性的DOM对象，浏览器通过渲染这些DOM节点来呈现内容，用户在浏览器中看到的内容就是浏览器渲染DOM对象后的结果。&lt;/p&gt;

&lt;h2&gt;2 指令的分类&lt;/h2&gt;
&lt;p&gt;　　组件、属性指令、结构性指令&lt;/p&gt;
&lt;p&gt;　　具体的知识点请参见《Angular2揭秘》&lt;/p&gt;

&lt;h2&gt;3 指定义指令常用到的一些常量&lt;/h2&gt;
&lt;h3&gt;　　3.1 Directive&lt;/h3&gt;
&lt;p&gt;　　　　用于装饰控制器类来指明该控制器类是一个自定义指令控制器类&lt;/p&gt;
&lt;h3&gt;　　3.2 ElementRef&lt;/h3&gt;
&lt;p&gt;　　　　作为DOM对象的引用使用，通过构造器进行依赖注入，它的实例代表标注有自定义指令那个元素的DOM对象；每个标注了自定义指令的元素都会自动拥有一个ElementRef对象来作为该元素DOM对象的引用（前提：在自定义指令的控制器中依赖注入了ElementRef）&lt;/p&gt;
&lt;h3&gt;　　3.3 Render2&lt;/h3&gt;
&lt;p&gt;　　　　Render2的实例是用来操作DOM节点的，因为Angular不推荐直接操作DOM节点；Render2是从Angular4才开始支持的，之前的版本是使用的Render；每个标注有自定义指令的元素都会拥有一个Render2实例来操作该元素的DOM属性（前提：在自定义指令的控制器中依赖注入了Render2）&lt;/p&gt;
&lt;h3&gt;　　3.4 HostListener&lt;/h3&gt;
&lt;p&gt;　　　　用于装饰事件触发方法的注解&lt;/p&gt;

&lt;h2&gt;4 自定义属性指令&lt;/h2&gt;
&lt;p&gt;　　一个自定义的属性指令需要一个有@Directive装饰器进行装饰的控制器类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import { Directive } from '@angular/core'&lt;span&gt;;

@Directive({
  selector: &lt;/span&gt;'[appDirectiveTest02]'&lt;span&gt;
})
export class DirectiveTest02Directive {

  constructor() { }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4.1 实现自定义属性指令&lt;/h3&gt;
&lt;h4&gt;　　　　4.1.1 创建自定义属性指令控制类&lt;/h4&gt;
&lt;p&gt;　　　　　　技巧01：创建一个模块来专门放自定义指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ng g d directive/test/directive-test02 --spec=&lt;span&gt;false&lt;/span&gt; --module=directive
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　　　4.1.2 在控制器类中依赖注入ElementRef　　&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  constructor(
    private el: ElementRef
  ) {}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　　　4.1.3 通过ElementRef实例改变标有自定义指令元素对应的DOM对象的背景颜色　&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  ngOnInit() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.el.nativeElement.style.backgroundColor = 'skyblue'&lt;span&gt;;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　　　4.1.3 在自定义指令模块中指定exports&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180120225728928-105916298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_fc5d921b-a123-49b8-a9b9-32e397d37aad&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fc5d921b-a123-49b8-a9b9-32e397d37aad&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fc5d921b-a123-49b8-a9b9-32e397d37aad&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
import { NgModule } from '@angular/core'&lt;span&gt;;
import { CommonModule } from &lt;/span&gt;'@angular/common'&lt;span&gt;;
import { DirectiveTest01Directive } from &lt;/span&gt;'./test/directive-test01.directive'&lt;span&gt;;
import { SharedModule } from &lt;/span&gt;'../shared/shared.module'&lt;span&gt;;
import { DirectiveTest02Directive } from &lt;/span&gt;'./test/directive-test02.directive'&lt;span&gt;;

@NgModule({
  imports: [
    CommonModule
  ],
  declarations: [
    DirectiveTest01Directive,
    DirectiveTest02Directive],
  exports: [
    DirectiveTest01Directive,
    DirectiveTest02Directive
  ]
})
  
export class DirectiveModule { }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;　　　　4.1.4 将自定义指令模块导入到需要用到指定指令的组件所在的模块中&lt;/h4&gt;
&lt;p&gt;　　　　　　技巧01：自定义指令一般会被多次用到，所以一般会将自定义指令模块导入到共享模块在从共享模块导出，这样其它模块只需要导入共享模块就可以啦&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180120230001787-555101690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49.5&quot;&gt;&lt;img id=&quot;code_img_closed_98a1be71-cadd-47d9-952f-e59e97c0ed9b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_98a1be71-cadd-47d9-952f-e59e97c0ed9b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_98a1be71-cadd-47d9-952f-e59e97c0ed9b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;94&quot;&gt;
&lt;pre&gt;
import { NgModule } from '@angular/core'&lt;span&gt;;
import { CommonModule } from &lt;/span&gt;'@angular/common'&lt;span&gt;;
import { RouterModule } from &lt;/span&gt;'@angular/router'&lt;span&gt;;
import { 
  MdToolbarModule,
  MdSidenavModule,
  MdIconModule,
  MdButtonModule,
  MdCardModule,
  MdInputModule,
  MdRadioModule,
  MdRadioButton
 } from &lt;/span&gt;'@angular/material'&lt;span&gt;;
import { FormsModule, ReactiveFormsModule } from &lt;/span&gt;'@angular/forms'&lt;span&gt;;
import { HttpModule } from &lt;/span&gt;'@angular/http'&lt;span&gt;;
import { DirectiveModule } from &lt;/span&gt;'../directive/directive.module'&lt;span&gt;; 

@NgModule({
  imports: [
    CommonModule,
    RouterModule,
    FormsModule,
    ReactiveFormsModule,
    HttpModule,
    MdToolbarModule,
    MdSidenavModule,
    MdIconModule,
    MdButtonModule,
    MdCardModule,
    MdInputModule,
    DirectiveModule,
    MdRadioModule
  ],
  declarations: [],
  exports: [
    CommonModule,
    RouterModule,
    FormsModule,
    ReactiveFormsModule,
    HttpModule,
    MdToolbarModule,
    MdSidenavModule,
    MdIconModule,
    MdButtonModule,
    MdCardModule,
    MdInputModule,
    DirectiveModule,
    MdRadioButton
  ]
})
export class SharedModule { }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;　　　　4.1.5 在组件中使用自定组件对应的选择器即可&lt;/h4&gt;
&lt;p&gt;　　　　　　自定义指令的选择器是由@Directive装饰器的selector元数据指定的&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180120230242271-1206593457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　在元素中直接标注自定义指令的选择器就行啦&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180120230602053-185476036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_838962c1-e708-4eec-bad1-fe8e567d365d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_838962c1-e708-4eec-bad1-fe8e567d365d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_838962c1-e708-4eec-bad1-fe8e567d365d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;panel panel-primary&quot;&amp;gt;
    &amp;lt;div class=&quot;panel panel-heading&quot;&amp;gt;实现自定义属性指令&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;panel-body&quot;&amp;gt;
        &amp;lt;button md-raised-button appDirectiveTest02&amp;gt;实现自定义指令的按钮&amp;lt;/button&amp;gt;
        &amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;button md-raised-button&amp;gt;未实现自定以指令的按钮&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;panel-footer&quot;&amp;gt;2018-1-20 22:47:06&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;　　　　4.1.6 代码汇总&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
import { Directive, ElementRef } from '@angular/core'&lt;span&gt;;
import { OnInit } from &lt;/span&gt;'../../../../node_modules/_@angular_core@4.4.6@@angular/core/src/metadata/lifecycle_hooks'&lt;span&gt;;

@Directive({
  selector: &lt;/span&gt;'[appDirectiveTest02]'&lt;span&gt;
})
export class DirectiveTest02Directive implements OnInit {

  constructor(
    private el: ElementRef
  ) {}

  ngOnInit() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.el.nativeElement.style.backgroundColor = 'skyblue'&lt;span&gt;;
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4.2 给自定义属性指令绑定输入属性&lt;/h3&gt;
&lt;p&gt;　　　　在4.1中实现的自定义属性指令中背景颜色是写死的不能更改，我们可以给指令绑定输入属性实现数据传递，从而达到动态改变的目的&lt;/p&gt;
&lt;h4&gt;　　　　4.2.1 在自定义属性指令的控制器中添加一个输入属性myColor&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180120231541537-295013241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_d285941f-1e63-4e95-a4fa-8b84b22ad5fa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d285941f-1e63-4e95-a4fa-8b84b22ad5fa&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d285941f-1e63-4e95-a4fa-8b84b22ad5fa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
import { Directive, ElementRef, OnInit, Input } from '@angular/core'&lt;span&gt;;

@Directive({
  selector: &lt;/span&gt;'[appDirectiveTest02]'&lt;span&gt;
})
export class DirectiveTest02Directive implements OnInit {

  @Input()
  myColor: string;

  constructor(
    private el: ElementRef
  ) {}

  ngOnInit() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.el.nativeElement.style.backgroundColor = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.myColor;
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;　　　　4.2.2 在组件中给myColor属性赋值&lt;/h4&gt;
&lt;p&gt;　　　　　　技巧01：在给输入属性赋值时，等号右边如果不是一个变量就需要用单引号括起来&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180120231655474-1375621086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ddcf548c-7133-4ebf-ad3d-72c5d032bfe1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ddcf548c-7133-4ebf-ad3d-72c5d032bfe1&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ddcf548c-7133-4ebf-ad3d-72c5d032bfe1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;panel panel-primary&quot;&amp;gt;
    &amp;lt;div class=&quot;panel panel-heading&quot;&amp;gt;实现自定义属性指令&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;panel-body&quot;&amp;gt;
        &amp;lt;button md-raised-button appDirectiveTest02 [myColor]=&quot;'red'&quot;&amp;gt;实现自定义指令的按钮&amp;lt;/button&amp;gt;
        &amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;button md-raised-button&amp;gt;未实现自定以指令的按钮&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;panel-footer&quot;&amp;gt;2018-1-20 22:47:06&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;　　　　4.2.3 效果展示&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180120231926521-1132937415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　4.2.4 改进&lt;/h4&gt;
&lt;p&gt;　　　　　　可以通过自定义属性指令的选择器来实现数据传输&lt;/p&gt;
&lt;p&gt;　　　　　　》利用自定义属性指令的选择器作为输入属性myColor输入属性的别名&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180120232135068-421895866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　》在组件中直接利用自定义指令的选择器作为输入属性&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180120232316521-194603853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7b27f7e5-7011-4bb4-adb5-3a799a947b81&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7b27f7e5-7011-4bb4-adb5-3a799a947b81&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7b27f7e5-7011-4bb4-adb5-3a799a947b81&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;div class=&quot;panel panel-primary&quot;&amp;gt;
    &amp;lt;div class=&quot;panel panel-heading&quot;&amp;gt;实现自定义属性指令&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;panel-body&quot;&amp;gt;
        &amp;lt;button md-raised-button [appDirectiveTest02]=&quot;'yellow'&quot;&amp;gt;实现自定义指令的按钮&amp;lt;/button&amp;gt;
        &amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt;
        &amp;lt;button md-raised-button&amp;gt;未实现自定以指令的按钮&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;panel-footer&quot;&amp;gt;2018-1-20 22:47:06&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　》 效果展示&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057762/201801/1057762-20180120232417193-979544936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　4.3 响应用户操作&lt;/h3&gt;
&lt;p&gt;　　　　daigengxin......2018-1-20 23:25:11&lt;/p&gt;




</description>
<pubDate>Sat, 20 Jan 2018 15:26:00 +0000</pubDate>
<dc:creator>NeverCtrl_C</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeverCtrl-C/p/8322327.html</dc:identifier>
</item>
<item>
<title>JAXB应用实例 - 陈本布衣</title>
<link>http://www.cnblogs.com/chenbenbuyi/p/8283657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenbenbuyi/p/8283657.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;&lt;span&gt;过往的项目中数据存储都离不开数据库，不过最近做的一个项目的某些数据（比如人员信息、菜单、权限等等）却完全没有涉及任何数据库操作，直接&lt;span&gt;XML搞定。这里无意比较优劣，因为数据库存储和XML存储本就有不同的适用场景，盲目比较毫无意义，只是因为业务需要，仅此而已。先来概念一下——XML，可扩展标记语言，设计宗旨是用来&lt;strong&gt;传输数据&lt;/strong&gt;而非显示数据，其遵循W3C标准，是一种通用的数据交换格式,具有很强的跨平台性，并且数据无需转换，所以，如果你要将数据做跨平台传输，那么把数据保存在 XML 文件中是有好处的。当然，这里要说明，由于&lt;span&gt;XML仅仅是作为一种&lt;strong&gt;文档模式的结构化存储&lt;/strong&gt;，所以并不适用于大数据量的存储。现在的Java中有很多类库比如DOM、SAX、JDOM和DOM4J等等都可以操作XML，但如果仅仅是想做JavaBean和XML节点元素的互相转换，而不涉及动态XML的处理，那么JAXB绝对是一个不错的选择。在比较新的jdk版本中，JAXB都是jdk的扩展包javax中自带的类库，不需要你引入第三方jar包。下面，博主正式给看客上菜，详细介绍一下JAXB的实际用法——&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 一 JavaBean和XML相互转换初体验&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_fa4623da-d15b-4981-b0cc-ec43dbb142d1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fa4623da-d15b-4981-b0cc-ec43dbb142d1&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fa4623da-d15b-4981-b0cc-ec43dbb142d1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; model;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.xml.bind.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;JavaBean代码&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; @XmlType(propOrder =&lt;span&gt; {})
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; @XmlRootElement(name = &quot;user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;@XmlAccessorType(XmlAccessType.PROPERTY)
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;@XmlAccessorOrder(XmlAccessOrder.ALPHABETICAL)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userName;
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String role;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String bibi;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User() {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; User(String userName, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age, String role, String bibi) {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.role =&lt;span&gt; role;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.bibi =&lt;span&gt; bibi;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserName() {
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; userName;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserName(String userName) {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    @XmlAttribute
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;    @XmlElement
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRole() {
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; role;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRole(String role) {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.role =&lt;span&gt; role;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;    @XmlTransient
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getBibi() {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bibi;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBibi(String bibi) {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.bibi =&lt;span&gt; bibi;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;User{&quot; +
&lt;span&gt; 67&lt;/span&gt;                 &quot;userName='&quot; + userName + '\'' +
&lt;span&gt; 68&lt;/span&gt;                 &quot;, age=&quot; + age +
&lt;span&gt; 69&lt;/span&gt;                 &quot;, role='&quot; + role + '\'' +
&lt;span&gt; 70&lt;/span&gt;                 &quot;, bibi='&quot; + bibi + '\'' +
&lt;span&gt; 71&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; test {
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; saveXmlTest() {
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt; User(&quot;陈本布衣&quot;, 2018, &quot;超级管理员&quot;,&quot;瞎哔哔&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         File file = &lt;span&gt;new&lt;/span&gt; File(&quot;E://user.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             JAXBContext jaxbContext = JAXBContext.newInstance(User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;             Marshaller marshaller =&lt;span&gt; jaxbContext.createMarshaller();
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;格式化输出，即按标签自动换行，否则就是一行输出&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置编码（默认编码就是utf-8）&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;             marshaller.setProperty(Marshaller.JAXB_ENCODING, &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否省略xml头信息，默认不省略（false）&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;             marshaller.setProperty(Marshaller.JAXB_FRAGMENT, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;            marshaller.marshal(user, file);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JAXBException e) {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getUserTest() {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         File file = &lt;span&gt;new&lt;/span&gt; File(&quot;E://user.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             JAXBContext jaxbContext = JAXBContext.newInstance(User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;             Unmarshaller unmarshaller =&lt;span&gt; jaxbContext.createUnmarshaller();
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;             User user =&lt;span&gt; (User) unmarshaller.unmarshal(file);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;            System.out.println(user.toString());
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JAXBException e) {
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;生成的XML:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1231169/201801/1231169-20180114203319707-362590675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二 JAXB使用基础介绍&lt;/h2&gt;
&lt;h4&gt;　　① 常用API&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;JAXBContext类，是应用的入口，通过该类创建序列化和反序列化对象，也即&lt;strong&gt;编组&lt;/strong&gt;对象和&lt;strong&gt;&lt;span&gt;&lt;strong&gt;解组&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对象&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Marshaller 编组接口，将Java对象序列化为XML数据；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Unmarshaller 解组接口，将XML数据反序列化为Java对象。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;　　② 常用注解&lt;/h4&gt;
&lt;div class=&quot;para&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;@XmlRootElement，将Java类或枚举映射成XML元素&lt;span&gt;根节点&lt;/span&gt;，是唯一一个必须注解，&lt;span&gt;name属性&lt;/span&gt;指定根节点名称，不指定默认为类名的小写；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@XmlElement，将Java类的一个属性映射为XML节点元素，name属性可自定义元素名；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@XmlAttribute，将Java类的一个属性映射为XML节点元素的属性，&lt;span&gt;name属性可自定义属性名&lt;/span&gt;；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@XmlType，将Java类或枚举类型映射到XML模式类型，常与@XmlRootElement、@XmlAccessorT&lt;/span&gt;&lt;span&gt;ype共用，propOrder属性定义字段生成的XML节点顺序；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@XmlAccessorType，控制字段或属性的序列化。属性&lt;span&gt;XmlAccessType有4个常量值:&lt;/span&gt;FIELD表示JAXB将自动绑定Java类中的每个非静态的（static）、非瞬态的（由@XmlTransient标注）字段到XML；PROPERTY表示java对象中所有通过getter/setter方式绑定成属性到XML；PUBLIC_MEMBER表示Java对象中所有的public访问权限的成员变量和通过getter/setter方式访问的成员变量，该值为默认值；&lt;span&gt;&lt;span&gt;NONE表示&lt;/span&gt;&lt;/span&gt;Java对象的所有属性都不映射为XML的元素；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@XmlAccessorOrder，控制JAXB 绑定类中属性和字段的排序，有两个属性，AccessorOrder.ALPHABETICAL——对生成的XML元素按字母书序排序，XmlAccessOrder.UNDEFINED——不排序，默认为该值；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@XmlJavaTypeAdapter，自定义适配器（即扩展抽象类XmlAdapter并覆盖marshal()和unmarshal()方法），解决日期（Date）,数字（Number）格式化问题；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@XmlElementWrapper ，对于数组或集合（即包含多个元素的成员变量），生成一个包装该数组或集合的XML元素（称为包装器），该注解只能用在集合上；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;@XmlTransient ，用于标示在由Java对象映射XML时，忽略此属性，在生成的XML文件中将不出现此元素。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4&gt;　　③ 实际应用中注意的问题&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　① 如果JavaBean中定义了有参的构造器，那么必须同时定义无参构造器，否则转XML会抛无默认构造函数的异常;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② 成员变量值为NULL时，将不会映射成对应的XML元素——&lt;em&gt;由于基本数据类型默认值不为空，所以基本数据类型不设值也会映射成XML元素，值为默认值；&lt;/em&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③ &lt;span&gt;@XmlAccessorType&lt;/span&gt; 注解中如果属性值为XmlAccessType.&lt;span&gt;FIELD，则表示通过成员变量来映射，set/get方法上的映射注解就是多余的，所以如果此时set/get方法上再标注元素或者属性映射注解，将抛属性重复性异常；&lt;span&gt;属性值为XmlAccessType.NONE&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;不映射为&lt;span&gt;&lt;span&gt;XML&lt;/span&gt;&lt;/span&gt;元素的前提是Java字段或set/get方法上都没有映射注解；&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　④ @XmlType propOrder属性能够自定义字段的排序，该属性如果设置，要么写成{}的形式，否则在就必须将所有&lt;span&gt;@XmlElement标注或者没有&lt;span&gt;&lt;span&gt;@XmlElement&lt;/span&gt;&lt;/span&gt;标注&lt;/span&gt;的但实际上会被映射为XML节点的字段添加到排序列表，不然会抛异常；如果&lt;span&gt;propOrder&lt;/span&gt;属性设置有值，@XmlAccessorOrder注解的元素排序规则将失效；&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 三 应用实际&lt;/h2&gt;
&lt;p&gt;　　先准备好测试用的工具方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; util;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; model.User;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.bind.JAXBContext;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.bind.JAXBException;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.bind.Marshaller;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.bind.Unmarshaller;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JaxbUtil {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; convertToXml(Object obj, File file) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             JAXBContext jaxbContext = JAXBContext.newInstance(User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             Marshaller marshaller =&lt;span&gt; jaxbContext.createMarshaller();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;格式化输出，即按标签自动换行，否则就是一行输出&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置编码（默认编码就是utf-8）&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             marshaller.setProperty(Marshaller.JAXB_ENCODING, &quot;UTF-8&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否省略xml头信息，默认不省略（false）&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             marshaller.setProperty(Marshaller.JAXB_FRAGMENT, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            marshaller.marshal(obj, file);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制台输出&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            marshaller.marshal(obj,System.out);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JAXBException e) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T convertToJavaBean(Class&amp;lt;T&amp;gt;&lt;span&gt; clz, File file) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             JAXBContext jaxbContext =&lt;span&gt; JAXBContext.newInstance(clz);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             Unmarshaller unmarshaller =&lt;span&gt; jaxbContext.createUnmarshaller();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             T t =&lt;span&gt; (T) unmarshaller.unmarshal(file);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (JAXBException e) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　① 简单对象处理&lt;/h4&gt;
&lt;p&gt;　　&lt;span&gt;简单对象处理起来比较简单，譬如人员对象User中包含菜单Menu,只需将定义的普通Menu对象也按照JAXB的注解进行标注，在User对象中当成普通字段一样的定义即可——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_f029394d-9dff-4a37-9366-240d1296d0f0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f029394d-9dff-4a37-9366-240d1296d0f0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f029394d-9dff-4a37-9366-240d1296d0f0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
@XmlType(propOrder = {&quot;userName&quot;,&quot;role&quot;,&quot;menu&quot;&lt;span&gt;})
@XmlRootElement(name &lt;/span&gt;= &quot;user&quot;&lt;span&gt;)
@XmlAccessorOrder(XmlAccessOrder.ALPHABETICAL)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String role;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String bibi;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Menu menu;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; User(String userName, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age, String role, String bibi) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.role =&lt;span&gt; role;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bibi =&lt;span&gt; bibi;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userName;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserName(String userName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
    }

    @XmlAttribute
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    @XmlElement(nillable&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRole() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; role;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRole(String role) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.role =&lt;span&gt; role;
    }

    @XmlTransient
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getBibi() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bibi;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBibi(String bibi) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bibi =&lt;span&gt; bibi;
    }

    @XmlElement
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Menu getMenu() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; menu;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMenu(Menu menu) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.menu =&lt;span&gt; menu;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;User{&quot; +
                &quot;userName='&quot; + userName + '\'' +
                &quot;, age=&quot; + age +
                &quot;, role='&quot; + role + '\'' +
                &quot;, menu=&quot; + menu +
                '}'&lt;span&gt;;
    }
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;菜单对象&lt;/span&gt;
&lt;span&gt;
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Menu {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String id;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Menu() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Menu(String name, String id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Menu{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, id='&quot; + id + '\'' +
                '}'&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1231169/201801/1231169-20180117225123537-1507213244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　② 集合处理&lt;/h4&gt;
&lt;p&gt;　　&lt;span&gt;实际应用场景中集合应用要更常见一些，比如上面的用户菜单，一个用户肯定会有多个不同的菜单，所以，我们来将上面的菜单改用集合处理——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_cf5022dc-ea68-4b37-ac49-74d574936005&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cf5022dc-ea68-4b37-ac49-74d574936005&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cf5022dc-ea68-4b37-ac49-74d574936005&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; model;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.xml.bind.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; @XmlType(propOrder = {&quot;userName&quot;, &quot;role&quot;, &quot;menus&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; @XmlRootElement(name = &quot;user&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@XmlAccessorOrder(XmlAccessOrder.ALPHABETICAL)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String userName;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String role;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String bibi;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;Menu&amp;gt;&lt;span&gt; menus;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; User() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; User(String userName, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age, String role, String bibi) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.role =&lt;span&gt; role;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.bibi =&lt;span&gt; bibi;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUserName() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; userName;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserName(String userName) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    @XmlAttribute
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    @XmlElement
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getRole() {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; role;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setRole(String role) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.role =&lt;span&gt; role;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    @XmlTransient
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getBibi() {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bibi;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBibi(String bibi) {
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.bibi =&lt;span&gt; bibi;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;    @XmlElement
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Menu&amp;gt;&lt;span&gt; getMenus() {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; menus;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setMenus(List&amp;lt;Menu&amp;gt;&lt;span&gt; menus) {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.menus =&lt;span&gt; menus;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;User{&quot; +
&lt;span&gt;76&lt;/span&gt;                 &quot;userName='&quot; + userName + '\'' +
&lt;span&gt;77&lt;/span&gt;                 &quot;, age=&quot; + age +
&lt;span&gt;78&lt;/span&gt;                 &quot;, role='&quot; + role + '\'' +
&lt;span&gt;79&lt;/span&gt;                 &quot;, menus=&quot; + menus +
&lt;span&gt;80&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_5d81a23f-85b1-4e14-b474-ed76f9cf20f8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5d81a23f-85b1-4e14-b474-ed76f9cf20f8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5d81a23f-85b1-4e14-b474-ed76f9cf20f8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; model;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.bind.annotation.XmlAttribute;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.bind.annotation.XmlRootElement;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;@XmlRootElement
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Menu {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String id;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;Menu&amp;gt;&lt;span&gt; child;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Menu() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Menu(String name, String id) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @XmlAttribute
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    @XmlAttribute
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getId() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(String id) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Menu&amp;gt;&lt;span&gt; getChild() {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; child;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setChild(List&amp;lt;Menu&amp;gt;&lt;span&gt; child) {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.child =&lt;span&gt; child;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Menu{&quot; +
&lt;span&gt;48&lt;/span&gt;                 &quot;name='&quot; + name + '\'' +
&lt;span&gt;49&lt;/span&gt;                 &quot;, id='&quot; + id + '\'' +
&lt;span&gt;50&lt;/span&gt;                 '}'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_87e12e56-a76c-4235-8a90-8c24380f2c33&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_87e12e56-a76c-4235-8a90-8c24380f2c33&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_87e12e56-a76c-4235-8a90-8c24380f2c33&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; model.Menu;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; model.User;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; util.JaxbUtil;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; test {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; saveXmlTest() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         User user = &lt;span&gt;new&lt;/span&gt; User(&quot;陈本布衣&quot;, 2018, &quot;超级管理员&quot;,&quot;瞎哔哔&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         List&amp;lt;Menu&amp;gt; list1 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Menu menu1 = &lt;span&gt;new&lt;/span&gt; Menu(&quot;系统管理&quot;,&quot;9527&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         Menu child1 = &lt;span&gt;new&lt;/span&gt; Menu(&quot;权限管理&quot;,&quot;9999&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Menu child2 = &lt;span&gt;new&lt;/span&gt; Menu(&quot;用户管理&quot;,&quot;2322&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        list1.add(child1);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        list1.add(child2);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        menu1.setChild(list1);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         List&amp;lt;Menu&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Menu menu2 = &lt;span&gt;new&lt;/span&gt; Menu(&quot;参数配置&quot;,&quot;2222&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         Menu child3 = &lt;span&gt;new&lt;/span&gt; Menu(&quot;权限管理&quot;,&quot;3333&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         Menu child4 = &lt;span&gt;new&lt;/span&gt; Menu(&quot;用户管理&quot;,&quot;4444&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        list2.add(child3);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        list2.add(child4);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        menu2.setChild(list2);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         List&amp;lt;Menu&amp;gt; menus = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        menus.add(menu1);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        menus.add(menu2);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        user.setMenus(menus);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         File file = &lt;span&gt;new&lt;/span&gt; File(&quot;E://user.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        JaxbUtil.convertToXml(user,file);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getUserTest() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         File file = &lt;span&gt;new&lt;/span&gt; File(&quot;E://user.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         User user = JaxbUtil.convertToJavaBean(User.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, file);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        System.out.println(user);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1231169/201801/1231169-20180120162532053-803159336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;上面的菜单中似乎少了点层次关系，这个时候可以使用集合包装器注解@XmlElementWrapper自定义一个包装节点，这样产生的XML文档才更有层次：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     @XmlElementWrapper(name = &quot;menu&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @XmlElement
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Menu&amp;gt;&lt;span&gt; getMenus() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; menus;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;最终产生的XML文档就是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1231169/201801/1231169-20180120164230678-1030011649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　③ 格式化处理&lt;/h4&gt;
&lt;p&gt; &lt;span&gt;　　业务数据中日期、数值通常是必不可少的，在数据存储的时候，这些数据通常都需要做格式化处理，比如将日期格式化，货币型数值处理等等。JAXB中格式化处理需要继承适配器抽象类&lt;span&gt;XmlAdapter&lt;/span&gt;，并覆写其序列化和反序列化的方法，这里仅用常用的日期格式化为例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; adapter;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.bind.annotation.adapters.XmlAdapter;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.DateFormat;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DateAdapter &lt;span&gt;extends&lt;/span&gt; XmlAdapter&amp;lt;String, Date&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; DateFormat SDF = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Date unmarshal(String date) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; SDF.parse(date);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String marshal(Date date) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; SDF.format(date);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将该适配器通过注解应用到User类表时间的date字段上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     @XmlJavaTypeAdapter(DateAdapter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getDate() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; date;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDate(Date date) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.date =&lt;span&gt; date;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　最后的时间就是按照格式化输出——&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1231169/201801/1231169-20180120213234365-129483736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四 问题补充&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　上述博文中描述的工具方法仅仅是出于学习中追根问本的目的写得稍微冗余了些，实际上，我所知道的是最迟从jdk1.7开始，JAXB就对解组和编组的方法进行了更简单的封装，所以，实际项目中除非自己要进行个性化设置，否则大可不用自己再创建JAXBContext实例，直接通过JAXB静态调用相应的工具方法就行了，有兴趣的看官稍微跟踪一下源码就能了然，于是上面的工具方法可以写得更简单——&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; util;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.xml.bind.JAXB;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JaxbUtil {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; convertToXml(Object obj, File file) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        JAXB.marshal(obj,file);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T convertToJavaBean(Class&amp;lt;T&amp;gt;&lt;span&gt; clz, File file) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; JAXB.unmarshal(file, clz);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　OK,&lt;span&gt;对于JAXB的知识分享就差不多这么些了。对于这种比较单一技能点的学习，就是根据API多写点代码练习测试，从测试的结果对错中总结出自己的深层理解，并在实际项目学以致用，不变应万变，望看官读毕都有所收获！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Jan 2018 15:21:00 +0000</pubDate>
<dc:creator>陈本布衣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenbenbuyi/p/8283657.html</dc:identifier>
</item>
<item>
<title>Python 之 基础知识（一） - 叶碎夜</title>
<link>http://www.cnblogs.com/lzhh/p/python_3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lzhh/p/python_3.html</guid>
<description>&lt;p&gt;首先，对于初学者在一个项目中设置多个程序可以执行，是非常方便的，可以方便对不同知识点的练习和测试&lt;/p&gt;
&lt;p&gt;对于商业项目而言，通常在一个项目中，只有一个可以执行的Python程序&lt;/p&gt;

&lt;p&gt;为了提高可读性，注释应该至少离开代码至少两个空格&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单行注释（行注释）
&lt;ul&gt;&lt;li&gt;以#开头，右边是说明文字　　最好#后加一个空格 保持代码的优雅~&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180119195537599-1538598920.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180119195709068-1320080670.png&quot; alt=&quot;&quot;/&gt;（一键修改）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多行注释（块注释）
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
这是一个多行注释

在多行注释之间，可以写很多很多内容。。。。
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1、设置断点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180119201456646-1694585143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、单步调试 F8&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180119201526287-427280184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、F9&lt;/p&gt;
&lt;p&gt;4、Ctrl + F2 停止调试&lt;/p&gt;
&lt;p&gt;5、shift + F9 会直接新开启一个调试环境　　最好是F9继续执行完成再 执行shift + F9&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180119221424599-2054414106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1、运算符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180119212844053-391184607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS 在Python中 * 还可以用于字符串中，计算结果就是字符串重复指定次数的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180119213214756-322505667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、优先级&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先乘除后加减&lt;/li&gt;
&lt;li&gt;同级运算符是从左至右计算&lt;/li&gt;
&lt;li&gt;可以使用()调整计算的优先级&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;**　　　　 幂 （最高优先级）&lt;/p&gt;
&lt;p&gt;*/%//　　　乘、除、取余数、取整数&lt;/p&gt;
&lt;p&gt; + -　　　  加法、减法&lt;/p&gt;

&lt;ul&gt;&lt;li&gt; 直接可以使用之前定义了的变量&lt;/li&gt;
&lt;li&gt;变量名只有在第一次出现才是定义变量&lt;/li&gt;
&lt;li&gt;变量名再次出现，不是定义变量，而是直接使用之前定义过的变量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Python中，定义变量时不需要指定变量的类型，在运行时，Python解释器会根据赋语句等号右侧的数据，自动推导出变量中保存数据的准确类型&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1、类型&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;数字型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　整型（int）
&lt;ul&gt;&lt;li&gt;int（整数）&lt;/li&gt;
&lt;li&gt;long（长整数）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180120213737037-1298353487.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;PS（Python2.7中区分 3.0后合并了）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　浮点型（float）&lt;/li&gt;
&lt;li&gt;　布尔型（bool）
&lt;ul&gt;&lt;li&gt;　真True 非0数  ——&lt;span&gt;非零即真&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;　假False&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;　复数型（complex）
&lt;ul&gt;&lt;li&gt;　　主要用于科学计算，例如:平面场问题、波动问题、电感电容等问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;非数字型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　字符串&lt;/li&gt;
&lt;li&gt;　列表&lt;/li&gt;
&lt;li&gt;　元组&lt;/li&gt;
&lt;li&gt;　字典&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;type 函数 　　可以查看一个变量的类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
type(name)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2、 计算&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;（1）数字型&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数字型可以直接进行算术运算&lt;/li&gt;
&lt;li&gt;如果有一个bool型
&lt;ol&gt;&lt;li&gt;True      1&lt;/li&gt;
&lt;li&gt;False　 0　&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; （2）字符型&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字符串间可以用+拼接生成新的字符串&lt;/li&gt;
&lt;li&gt;字符串变量可以和整数使用*重复拼接相同的字符串&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;（3）数字型和字符型不能进行其他任何运算&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3、输入&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;获取用户在键盘上的输入信息，需要使用input函数（即交互式）&lt;/p&gt;
&lt;p&gt;PS（用户输入的任何内容Python）都&lt;span&gt;认为是一个字符串&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
字符串变量 = input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提示信息:  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;类型转换函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;int(x)　　　　将x转换为一个整数&lt;/li&gt;
&lt;li&gt;　　float(x)　　　将x转换为一个浮点数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在Python2.7中内置函数input()会将输入数据当成指令，从键盘中输入数据应该使用raw_input()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在Python3中input()函数用于从键盘中读取数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180120220442271-194286262.png&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;355&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180120220557787-1468728025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180120220517740-2065885731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;4、格式化 输出&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;%s　　　　字符串&lt;/li&gt;
&lt;li&gt;%d　　　　有符号十进制整数，%06d表示输出的整数显示位数，不足的地方使用0补全&lt;/li&gt;
&lt;li&gt;%f 　　　　浮点数，%.02f表示小数点后只显示两位&lt;/li&gt;
&lt;li&gt;%% 　　　　输出%&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;格式化字符串&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; 变量1)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;格式化字符串&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (变量1, 变量2...))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180120223246006-1958964725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下两图解释了 因为字符串的一个运算性质导致了一种书写习惯的错误　而加上小括号&lt;span&gt;表示先进行算术运算&lt;/span&gt;即可；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180120223955818-1210872005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1008287/201801/1008287-20180120224012490-441344982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;5、命名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;标识符&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标识符可以由字母、下划线和数字组成&lt;/li&gt;
&lt;li&gt;不能以数字开头&lt;/li&gt;
&lt;li&gt;不能与关键字重名&lt;/li&gt;
&lt;li&gt;标识符区分大小写&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看Python中的关键字&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; keyword

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(keyword, kwlist)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;命名规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;1、(Guido 吉多 - 仁慈的仲裁者推荐的规范)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个单词都使用小写字母&lt;/li&gt;
&lt;li&gt;单词与单词之间使用_下划线连接&lt;/li&gt;
&lt;li&gt;例如：qq_number&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2、（&lt;/strong&gt;&lt;strong&gt;驼峰命名法）&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小驼峰命名法
&lt;ul&gt;&lt;li&gt;第一个单词以小写字母开始，后续单词的首字母大写&lt;/li&gt;
&lt;li&gt;如:firstName、lastName&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大驼峰命名法
&lt;ul&gt;&lt;li&gt;每一个单词的首字母都采用大写字母&lt;/li&gt;
&lt;li&gt;如:FirstName、CamelCase&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 20 Jan 2018 15:05:00 +0000</pubDate>
<dc:creator>叶碎夜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lzhh/p/python_3.html</dc:identifier>
</item>
<item>
<title>SSE图像算法优化系列十三：超高速BoxBlur算法的实现和优化（Opencv的速度的五倍） - Imageshop</title>
<link>http://www.cnblogs.com/Imageshop/p/8302990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Imageshop/p/8302990.html</guid>
<description>&lt;p&gt;&lt;span&gt;      在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/Imageshop/p/6849611.html&quot;&gt;SSE图像算法优化系列五：超高速指数模糊算法的实现和优化（10000*10000在100ms左右实现）&lt;/a&gt; 一文中，我曾经说过优化后的ExpBlur比BoxBlur还要快，那个时候我比较的BoxBlur算法是通过积分图+SSE实现的，我在09年另外一个博客账号上曾经提供过一篇这个文章&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/laviewpbt/archive/2009/07/23/1529250.html&quot;&gt;彩色图像高速模糊之懒惰算法&lt;/a&gt;，里面也介绍了一种快速的图像模糊算法，这个算法的执行时间基本也是和半径无关的。在今年的SSE优化学习之路上我曾经也考虑过将该算法使用SSE实现，但当时觉得这个算法逐像素同时逐行都是前后依赖的（单纯的逐像素依赖算法我在指数模糊里有提到如何用SSE优化），是无法用SSE处理的，一直没考虑，直到最近有朋友提出某个基于局部局方差的算法希望能提速，我又再次触发灵感，终于将这种算法也实现的指令集实现，并且测试速度比积分图快二倍，比&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl19_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/Imageshop/p/5053013.html&quot;&gt;解析opencv中Box Filter的实现并提出进一步加速的方案（源码共享）&lt;/a&gt;这篇文章的速度快3倍，比opencv的cvSmooth函数快5倍，在一台老旧的I3笔记本上处理3000*2000的灰度图达到了6ms的速度，本文分享该优化过程并提供灰度版本的优化代码供大家学习和讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/laviewpbt/archive/2009/07/23/1529250.html&quot;&gt;彩色图像高速模糊之懒惰算法&lt;/a&gt;一文附带的代码中（VB6的代码）是针对24位的图像，为了讨论方便，我们先贴出8位灰度的C++的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 按照Tile方式进行数据的扩展，得到扩展后在原尺寸中的位置，以0为下标。
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; IM_GetMirrorPos(&lt;span&gt;int&lt;/span&gt; Length, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Pos)
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Pos &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;Pos;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Pos &amp;gt;=&lt;span&gt; Length)
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Length + Length - Pos - &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;    
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Pos;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; FillLeftAndRight_Mirror_C(&lt;span&gt;int&lt;/span&gt; *Array, &lt;span&gt;int&lt;/span&gt; Length, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Radius)
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Radius; X++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;         Array[X] = Array[Radius + Radius -&lt;span&gt; X];
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;         Array[Radius + Length + X] = Array[Radius + Length - X - &lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SumofArray_C(&lt;span&gt;int&lt;/span&gt; *Array, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Length)
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; Sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Length; X++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         Sum +=&lt;span&gt; Array[X];
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Sum;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 将整数限幅到字节数据类型。
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt; inline unsigned &lt;span&gt;char&lt;/span&gt; IM_ClampToByte(&lt;span&gt;int&lt;/span&gt; Value)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    现代PC还是这样直接写快些&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Value &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Value &amp;gt; &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;255&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;)Value;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;return ((Value | ((signed int)(255 - Value) &amp;gt;&amp;gt; 31)) &amp;amp; ~((signed int)Value &amp;gt;&amp;gt; 31));&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; IM_BoxBlur_C(unsigned &lt;span&gt;char&lt;/span&gt; *Src, unsigned &lt;span&gt;char&lt;/span&gt; *Dest, &lt;span&gt;int&lt;/span&gt; Width, &lt;span&gt;int&lt;/span&gt; Height, &lt;span&gt;int&lt;/span&gt; Stride, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Radius)
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; Channel = Stride /&lt;span&gt; Width;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((Src == NULL) || (Dest == NULL))                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_NULLREFRENCE;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((Width &amp;lt;= &lt;span&gt;0&lt;/span&gt;) || (Height &amp;lt;= &lt;span&gt;0&lt;/span&gt;) || (Radius &amp;lt;= &lt;span&gt;0&lt;/span&gt;))        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_INVALIDPARAMETER;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Radius &amp;lt; &lt;span&gt;1&lt;/span&gt;)                                            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_INVALIDPARAMETER;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((Channel != &lt;span&gt;1&lt;/span&gt;) &amp;amp;&amp;amp; (Channel != &lt;span&gt;3&lt;/span&gt;) &amp;amp;&amp;amp; (Channel != &lt;span&gt;4&lt;/span&gt;))    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_NOTSUPPORTED;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;     Radius = IM_Min(IM_Min(Radius, Width - &lt;span&gt;1&lt;/span&gt;), Height - &lt;span&gt;1&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    由于镜像的需求，要求半径不能大于宽度或高度-1的数据&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; SampleAmount = (&lt;span&gt;2&lt;/span&gt; * Radius + &lt;span&gt;1&lt;/span&gt;) * (&lt;span&gt;2&lt;/span&gt; * Radius + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; Inv = &lt;span&gt;1.0&lt;/span&gt; /&lt;span&gt; SampleAmount;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; *ColValue = (&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;((Width + Radius + Radius) * (Channel == &lt;span&gt;1&lt;/span&gt; ? Channel : &lt;span&gt;4&lt;/span&gt;) * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; *ColOffset = (&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;((Height + Radius + Radius) * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((ColValue == NULL) || (ColOffset ==&lt;span&gt; NULL))
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ColValue != NULL)    &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(ColValue);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ColOffset != NULL)    &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(ColOffset);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_OUTOFMEMORY;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height + Radius + Radius; Y++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         ColOffset[Y] = IM_GetMirrorPos(Height, Y -&lt;span&gt; Radius);
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height; Y++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             unsigned &lt;span&gt;char&lt;/span&gt; *LinePD = Dest + Y *&lt;span&gt; Stride;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (Y == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                 memset(ColValue + Radius, &lt;span&gt;0&lt;/span&gt;, Width * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Z = -Radius; Z &amp;lt;= Radius; Z++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                     unsigned &lt;span&gt;char&lt;/span&gt; *LinePS = Src + ColOffset[Z + Radius] *&lt;span&gt; Stride;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                         ColValue[X + Radius] += LinePS[X];                                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    更新列数据&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 unsigned &lt;span&gt;char&lt;/span&gt; *RowMoveOut = Src + ColOffset[Y - &lt;span&gt;1&lt;/span&gt;] * Stride;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    即将减去的那一行的首地址    &lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;                 unsigned &lt;span&gt;char&lt;/span&gt; *RowMoveIn = Src + ColOffset[Y + Radius + Radius] * Stride;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    即将加上的那一行的首地址&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                     ColValue[X + Radius] -= RowMoveOut[X] - RowMoveIn[X];                                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    更新列数据&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             FillLeftAndRight_Mirror_C(ColValue, Width, Radius);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    镜像填充左右数据&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; LastSum = SumofArray_C(ColValue, Radius * &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    处理每行第一个数据                                &lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;             LinePD[&lt;span&gt;0&lt;/span&gt;] = IM_ClampToByte(LastSum *&lt;span&gt; Inv);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;1&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; NewSum = LastSum - ColValue[X - &lt;span&gt;1&lt;/span&gt;] + ColValue[X + Radius +&lt;span&gt; Radius];
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                 LinePD[X] = IM_ClampToByte(NewSum *&lt;span&gt; Inv);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                 LastSum =&lt;span&gt; NewSum;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(ColValue);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;     &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(ColOffset);
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_OK;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;以前没意识到，就这么简单的代码用C写后能产生速度也是很诱人的，3000*2000的图能做到39ms，如果在编译选项里勾选编译器的“启用增强指令集：流式处理 SIMD 扩展 2 (/arch:SSE2)”， 则系统会对上述具有浮点计算的部分使用相关的SIMD指令优化，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                          &lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201801/349293-20180119225354037-745371949.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个时候3000*2000的图能做到25ms,,基本上接近我改进的OPENCV的代码的速度了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　简单的描述下各函数的作用先。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　IM_GetMirrorPos函数主要是得到某一个位置Pos按照镜像的方式处理时在Length方向的坐标，这里Pos可以为负值，这个主要是用来获得后期的坐标偏移的。　　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　FillLeftAndRight_Mirror_C主要是用来获取两边镜像数据的（直接获取，不调用IM_GetMirrorPos函数），比如比如Array原始数据为 ***abcdefgh*** (Length = 8, Radius = 3)，则结果为dcbabcdefghgfe。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SumofArray_C主要是计算一个数组的所有的元素的和。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　IM_BoxBlur_C函数内部即为模糊的函数体，采用的优化思路整体和&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/Imageshop/archive/2013/04/26/3045672.html&quot;&gt;任意半径中值滤波（扩展至百分比滤波器）O(1)时间复杂度算法的原理、实现及效果&lt;/a&gt;是一致的。当半径为R时，方框模糊的值等于以某点为中心，左右上下各扩展R像素的的范围内所有像素的综合，像素总个数为（2*R+1）*（2*R+1）个，当然我们也可以把他分成（2*R+1）列，每列有（2*R+1）个元素本例的优化方式我们就是把累加数据分成一列一列的，充分利用重复信息来达到速度提升。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
　 我们定义一个Radius + Width + Radius的内存数据ColValue，用来保存列方向的累加数据，对于第一行数据，需要做特殊处理，也就是用原始的方式计算一行像素所有元素在列方向上的和，&lt;br/&gt;详见78至于86行代码，当然这里只计算了中间Width范围内的数据，当不是第一行时，如下图左边所示，新的累加值只需减去移出的哪一行像素值同时加上移入的一行像素值，详见90到96&lt;br/&gt;行代码。
&lt;/pre&gt;
&lt;pre&gt;
 　上面只计算了中间Width范围内的累加值，为了方便后续代码的编写以及使用SSE优化，下面的FillLeftAndRight_Mirror_C主要作用就是填充左边和右边分别填充数据，而且是按照镜像的方式进行填充。
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;        在更新了上述累加值后，我们开始处理计算均值了，对于每行的第一个点，SumofArray_C计算了前2*R + 1个列的累加值，这个累加值就是该点周边（2*R+1）*（2*R+1）个元素的累积和，对于一行的其他像素，其实就类似于行方向列累加值的更新，减去移出的加入新进的列，如下图右侧图所示，102到104行即实现了该过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201801/349293-20180119195456974-811299318.jpg&quot; alt=&quot;&quot;/&gt;     &lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201801/349293-20180119195506724-407193349.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
　　原理基本上就是这样，这个算法占用的额外内存很明显很少，但是不支持In-Place操作。&lt;br/&gt;　　为了追求速度，我们把整个过程能用SSE优化的地方都用SSE优化。&lt;br/&gt;　　首先是第79至86行的数据，这个很容易优化：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Z = -Radius; Z &amp;lt;= Radius; Z++&lt;span&gt;)
{
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *LinePS = Src + ColOffset[Z + Radius] *&lt;span&gt; Stride;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;8&lt;/span&gt;, Block = Width /&lt;span&gt; BlockSize;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Block * BlockSize; X +=&lt;span&gt; BlockSize)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *DestP = ColValue + X +&lt;span&gt; Radius;
        __m128i Sample &lt;/span&gt;= _mm_cvtepu8_epi16(_mm_loadl_epi64((__m128i *)(LinePS +&lt;span&gt; X)));
        _mm_storeu_si128((__m128i &lt;/span&gt;*)DestP, _mm_add_epi32(_mm_loadu_si128((__m128i *&lt;span&gt;)DestP), _mm_cvtepi16_epi32(Sample)));
        _mm_storeu_si128((__m128i &lt;/span&gt;*)(DestP + &lt;span&gt;4&lt;/span&gt;), _mm_add_epi32(_mm_loadu_si128((__m128i *)(DestP + &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)), _mm_unpackhi_epi16(Sample, _mm_setzero_si128())));
    }
    //　　处理剩余不能被SSE优化的数据&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　用_mm_loadl_epi64加载8个字节数据到内存，并用_mm_cvtepu8_epi16将其转换为16位的__m128i变量，后面再把低4位和高4位的数据分别转换成32位的，然后用&lt;/span&gt;&lt;span&gt;_mm_add_epi32累加，注意后面我转换函数用了两种不同的方式，因为这里的数据绝对都是正数，因此也是可以使用_mm_cvtepi16_epi32和&lt;/span&gt;&lt;span&gt;_mm_unpackhi_epi16组合Zero实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　再来看看92到95行代码，这个也很简单。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;8&lt;/span&gt;, Block = Width /&lt;span&gt; BlockSize;
__m128i Zero &lt;/span&gt;=&lt;span&gt; _mm_setzero_si128();
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Block * BlockSize; X +=&lt;span&gt; BlockSize)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *DestP = ColValue + X +&lt;span&gt; Radius;
    __m128i MoveOut &lt;/span&gt;= _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *)(RowMoveOut +&lt;span&gt; X)), Zero);
    __m128i MoveIn &lt;/span&gt;= _mm_unpacklo_epi8(_mm_loadl_epi64((__m128i *)(RowMoveIn +&lt;span&gt; X)), Zero);
    __m128i Diff &lt;/span&gt;= _mm_sub_epi16(MoveIn, MoveOut);                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    注意这个有负数也有正数的，有负数时转换为32位是不能用_mm_unpackxx_epi16体系的函数&lt;/span&gt;
    _mm_storeu_si128((__m128i *)DestP, _mm_add_epi32(_mm_loadu_si128((__m128i *&lt;span&gt;)DestP), _mm_cvtepi16_epi32(Diff)));
    _mm_storeu_si128((__m128i &lt;/span&gt;*)(DestP + &lt;span&gt;4&lt;/span&gt;), _mm_add_epi32(_mm_loadu_si128((__m128i *)(DestP + &lt;span&gt;4&lt;/span&gt;)), _mm_cvtepi16_epi32(_mm_srli_si128(Diff, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;))));
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;　　处理剩余不能被SSE优化的数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这里也是一次性处理8个像素，这里我使用了另外一种转换技巧来把8位转换为16位，但是后面的Diff因为有正有负，要转换为32位就必须使用&lt;/span&gt;&lt;span&gt;_mm_cvtepi16_epi32来转换，不能用unpack系列组合函数来实现，因为unpack不会移动符号位，我在这里吃了好几次亏了。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着是FillLeftAndRight_Mirror_C函数的优化，改写如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; FillLeftAndRight_Mirror_SSE(&lt;span&gt;int&lt;/span&gt; *Array, &lt;span&gt;int&lt;/span&gt; Length, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Radius)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;4&lt;/span&gt;, Block = Radius /&lt;span&gt; BlockSize;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Block * BlockSize; X +=&lt;span&gt; BlockSize)
    {
        __m128i SrcV1 &lt;/span&gt;= _mm_loadu_si128((__m128i *)(Array + Radius + Radius - X - &lt;span&gt;3&lt;/span&gt;&lt;span&gt;));
        __m128i SrcV2 &lt;/span&gt;= _mm_loadu_si128((__m128i *)(Array + Radius + Length - X - &lt;span&gt;5&lt;/span&gt;&lt;span&gt;));
        _mm_storeu_si128((__m128i &lt;/span&gt;*)(Array + X), _mm_shuffle_epi32(SrcV1, _MM_SHUFFLE(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)));
        _mm_storeu_si128((__m128i &lt;/span&gt;*)(Array + Radius + Length + X), _mm_shuffle_epi32(SrcV2, _MM_SHUFFLE(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)));
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;　　处理剩余不能被SSE优化的数据&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　镜像就是倒序的过程，直接使用SSE的shuffle函数很方便实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　计算数组的累加和优化也方便。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; SumofArray_SSE(&lt;span&gt;int&lt;/span&gt; *Array, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Length)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;8&lt;/span&gt;, Block = Length /&lt;span&gt; BlockSize;
    __m128i Sum1 &lt;/span&gt;=&lt;span&gt; _mm_setzero_si128();
    __m128i Sum2 &lt;/span&gt;=&lt;span&gt; _mm_setzero_si128();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Block * BlockSize; X +=&lt;span&gt; BlockSize)
    {
        Sum1 &lt;/span&gt;= _mm_add_epi32(Sum1, _mm_loadu_si128((__m128i *)(Array + X + &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)));
        Sum2 &lt;/span&gt;= _mm_add_epi32(Sum2, _mm_loadu_si128((__m128i *)(Array + X + &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)));
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Sum =&lt;span&gt; SumI32(_mm_add_epi32(Sum1, Sum2));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;　　处理剩余不能被SSE优化的数据&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Sum;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　使用两个__m128i 变量主要是为了充分利用XMM寄存器，其中SumI32函数如下，主要是为了计算__m128i 内四个整数的累加值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Convert 4 32-bit integer values to 4 unsigned char values.&lt;br/&gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; _mm_storesi128_4char(__m128i Src, unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;Dest)
{
    __m128i T &lt;/span&gt;=&lt;span&gt; _mm_packs_epi32(Src, Src);
    T &lt;/span&gt;=&lt;span&gt; _mm_packus_epi16(T, T);
    &lt;/span&gt;*((&lt;span&gt;int&lt;/span&gt;*)Dest) =&lt;span&gt; _mm_cvtsi128_si32(T);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　代码不解释。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后就是100到104行的代码的转换。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; BlockSize = &lt;span&gt;4&lt;/span&gt;, Block = (Width - &lt;span&gt;1&lt;/span&gt;) /&lt;span&gt; BlockSize;
__m128i OldSum &lt;/span&gt;=&lt;span&gt; _mm_set1_epi32(LastSum);
__m128 Inv128 &lt;/span&gt;=&lt;span&gt; _mm_set1_ps(Inv);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;1&lt;/span&gt;; X &amp;lt; Block * BlockSize + &lt;span&gt;1&lt;/span&gt;; X +=&lt;span&gt; BlockSize)
{
    __m128i ColValueOut &lt;/span&gt;= _mm_loadu_si128((__m128i *)(ColValue + X - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
    __m128i ColValueIn &lt;/span&gt;= _mm_loadu_si128((__m128i *)(ColValue + X + Radius +&lt;span&gt; Radius));
    __m128i ColValueDiff &lt;/span&gt;= _mm_sub_epi32(ColValueIn, ColValueOut);                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    P3 P2 P1 P0                                                &lt;/span&gt;
    __m128i Value_Temp = _mm_add_epi32(ColValueDiff, _mm_slli_si128(ColValueDiff, &lt;span&gt;4&lt;/span&gt;));        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    P3+P2 P2+P1 P1+P0 P0&lt;/span&gt;
    __m128i Value = _mm_add_epi32(Value_Temp, _mm_slli_si128(Value_Temp, &lt;span&gt;8&lt;/span&gt;));                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    P3+P2+P1+P0 P2+P1+P0 P1+P0 P0&lt;/span&gt;
    __m128i NewSum =&lt;span&gt; _mm_add_epi32(OldSum, Value);
    OldSum &lt;/span&gt;= _mm_shuffle_epi32(NewSum, _MM_SHUFFLE(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;));                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    重新赋值为最新值&lt;/span&gt;
    __m128 Mean =&lt;span&gt; _mm_mul_ps(_mm_cvtepi32_ps(NewSum), Inv128);
    _mm_storesi128_4char(_mm_cvtps_epi32(Mean), LinePD &lt;/span&gt;+&lt;span&gt; X);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　以前认为这个算法难以使用SSE优化，主要难处就在这里，但是在学习了Opencv的积分图技术时，这个问题就迎刃而解了，进一步分析还发现Opencv的代码写的并不完美，还有改&lt;/span&gt;&lt;span&gt;进的空间，见上述代码，使用两次对同一数据移位就可以获取累加，由P3 P2 P1 P0变为P3+P2+P1+P0 P2+P1+P0 P1+P0 P0。我们稍微分析一下。             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　__m128i ColValueDiff = _mm_sub_epi32(ColValueIn, ColValueOut); 这句代码得到了移入和移出序列的差值，我们计为；　　P3 P2 P1 P0 （高位到低位）由于算法的累加特性，如果说OldSum的原始值为A3 A3 A3 A3，那么新的NewSum就应该是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　A3+P3+P2+P1+P0　　A3+P2+P1+P0　　A3+P1+P0　　A3+P0；&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;__m128i Value_Temp = _mm_add_epi32(ColValueDiff, _mm_slli_si128(ColValueDiff, 4)); 这句的_mm_slli_si128得到中间结果　P2 P1 P0 0, 再和P3 P2 P1 P0相加得到&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
　　　　Value_Temp =　　&lt;span&gt;P3+P2 　　P2+P1　　P1+P0 　　P0&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
__m128i Value = _mm_add_epi32(Value_Temp, _mm_slli_si128(Value_Temp, 8));这句的_mm_slli_si128得到中间结果P1+P0 P0 0 0,再和P3+P2 P2+P1　P1+P0  P0相加得到：
&lt;/pre&gt;
&lt;pre&gt;
　　　　Value =　P3+P2+P1+P0 　　P2+P1+P0 　　P1+P0 　　P0&lt;br/&gt;好简单的过程。
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　OldSum = _mm_shuffle_epi32(NewSum, _MM_SHUFFLE(3, 3, 3, 3)); 这一句为什么要这样写，恐怕还是读者自己体会比较好，似乎不好用文字表达。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; 　　最后一个_mm_storesi128_4char是我自己定义的一个将1个__m128i里面的4个32位整数转换为字节数并保存到内存中的函数，详见附件代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　至于24位图像的优化，是个比较尴尬的处境，因为SSE一次性处理4个32位数，而24位每个像素只有3个分量，这种情况一般还是把他扩展到4个分量，比如说ColValue就可以改成4通道的，然后累积和也需要处理成4通道的，这当然需要一定的奇巧淫技，这里我不想多谈，留点东西给自己。当然也可以考虑先把24位分解到3个灰度内存，然后利用灰度的算法进行计算，后面在合成到24位，这个分解和合成的过程也是可以使用SSE加速的，如果你结合多线程，还可以把3个灰度过程的处理并行化，这样除了多占用内存外，速度比至二级处理24位要快（因为直接处理算法无法并行的，前后依赖的缘故）。另外就是最后在计算列累积求平均值的过程也变得更加自然了，不会出现灰度那种要在__mm128i内部进行累加的过程，而是直接得两个SSE变量累加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　还说一点，现在大部分的CPU都支持AVX256了，还可以使用AVX进一步加速，似乎代码该起来也不是很难，有兴趣的朋友可以自己试试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以说，目前这个速度已经基本上达到了CPU的极限了，但是测试过IPP的速度，似乎比这个还要快点，不排除他使用了AVX，也不排除他使用多核的资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个的优化对于BoxBlur来说是重要的一步，但是更重要的是他可以运用在很多场合，比如图像的局部均方差计算，也可以使用类似的技术进行加速，两幅图像大的局部平方差也是可以这样优化的，后续我会简单的谈下他在这方面加速的应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　源代码下载：&lt;a href=&quot;https://files.cnblogs.com/files/Imageshop/FastBlur.rar&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/Imageshop/FastBlur.rar&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　彩色图工程：&lt;a href=&quot;https://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201801/349293-20180119233731724-286368083.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　不好意思，图太小，速度为0ms了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201801/349293-20180119233846693-1796698599.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;




&lt;pre&gt;
&lt;/pre&gt;

</description>
<pubDate>Sat, 20 Jan 2018 13:25:00 +0000</pubDate>
<dc:creator>Imageshop</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Imageshop/p/8302990.html</dc:identifier>
</item>
<item>
<title>大数据学习系列之九---- Hive整合Spark和HBase以及相关测试 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/8322022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/8322022.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在之前的&lt;a href=&quot;http://www.panchengming.com/2017/12/30/pancm64/&quot;&gt;大数据学习系列之七 ----- Hadoop+Spark+Zookeeper+HBase+Hive集群搭建&lt;/a&gt; 中介绍了集群的环境搭建，但是在使用hive进行数据查询的时候会非常的慢，因为hive默认使用的引擎是MapReduce。因此就将spark作为hive的引擎来对hbase进行查询，在成功的整合之后，我将如何整合的过程写成本篇博文。具体如下！&lt;/p&gt;
&lt;h2 id=&quot;事前准备&quot;&gt;事前准备&lt;/h2&gt;
&lt;p&gt;在进行整合之前，首先确保Hive、HBase、Spark的环境已经搭建成功！如果没有成功搭建，具体可以看我之前写的&lt;a href=&quot;http://www.panchengming.com/2017/12/30/pancm64/&quot;&gt;大数据学习系列之七 ----- Hadoop+Spark+Zookeeper+HBase+Hive集群搭建&lt;/a&gt; 这篇文章。&lt;br/&gt;那么开始将hive、hbase、spark整合吧。&lt;br/&gt;目前集群的配置如下:&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180120203608874?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;hive整合hbase&quot;&gt;Hive整合HBase&lt;/h2&gt;
&lt;p&gt;因为Hive与HBase整合的实现是利用两者本身对外的API接口互相通信来完成的，其具体工作交由Hive的lib目录中的&lt;code&gt;hive-hbase-handler-*.jar&lt;/code&gt;工具类来实现。所以只需要将hive的 &lt;code&gt;hive-hbase-handler-*.jar&lt;/code&gt; 复制到hbase/lib中就可以了。&lt;br/&gt;切换到hive/lib目录下&lt;br/&gt;输入:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp hive-hbase-handler-*.jar /opt/hbase/hbase1.2/lib&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;: 如果在hive整合hbase中，出现版本之类的问题，那么以hbase的版本为主，将hbase中的jar包覆盖hive的jar包。&lt;/p&gt;
&lt;p&gt;至于Hive和HBase之间的相关测试可以查看我之前的&lt;a href=&quot;http://www.panchengming.com/2017/12/18/pancm62/&quot;&gt;大数据学习系列之五 ----- Hive整合HBase图文详解&lt;/a&gt; 这篇文章，本篇就不再过多描述了。&lt;/p&gt;
&lt;h2 id=&quot;hive整合spark&quot;&gt;Hive整合Spark&lt;/h2&gt;
&lt;p&gt;其实Hive整合Spark其实就是Hive使用Spark成功编译好的架包，但是Hive整合Spark比较坑的是版本不能随意，必须使用指定的进行编译。当初因为这个问题困扰了很久，最后查阅资料找到了已经编译好的spark和hive的版本，我们只需要将编译好的jar拿过来进行使用就行了。具体使用如下。&lt;/p&gt;
&lt;h3 id=&quot;hive的配置更改&quot;&gt;hive的配置更改&lt;/h3&gt;
&lt;p&gt;切换到hive/conf 目录下&lt;br/&gt;编辑 &lt;code&gt;hive-env.sh&lt;/code&gt; 文件&lt;br/&gt;添加spark的环境:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export  SPARK_HOME=/opt/spark/spark1.6-hadoop2.4-hive&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后编辑 &lt;code&gt;hive-site.xml&lt;/code&gt; 文件&lt;br/&gt;在hive-site.xml 添加 这些配置&lt;br/&gt;这些配置的说明:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hive.execution.engine&lt;/strong&gt;： 表示 hive 执行的默认引擎是，这里我们填的是spark。如果不想 加这个配置，希望手动使用spark，那么进入hive shell之后，输入:&lt;br/&gt;&lt;code&gt;set hive.execution.engine=spark;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spark.master&lt;/strong&gt;: spark的主机地址，这里我们填spark的默认地址。&lt;br/&gt;&lt;strong&gt;spark.home&lt;/strong&gt;: spark 的安装路径，写spark的安装路径。&lt;br/&gt;&lt;strong&gt;spark.submit.deployMode&lt;/strong&gt;：spark的提交方式，默认就写client。&lt;br/&gt;&lt;strong&gt;spark.serializer&lt;/strong&gt;: spark 的序列化方式。&lt;br/&gt;&lt;strong&gt;spark.eventLog.enabled&lt;/strong&gt;:是否使用spark的日志，默认true。&lt;br/&gt;&lt;strong&gt;spark.eventLog.dir&lt;/strong&gt; : spark的日志存放路径，注意这个路径要用hadoop创建！&lt;br/&gt;&lt;strong&gt;spark.executor.memory&lt;/strong&gt;:分配给spark的执行内存，根据个人机器来配置。&lt;br/&gt;&lt;strong&gt;spark.driver.memory&lt;/strong&gt;: spark总内存，根据个人机器来配置。&lt;/p&gt;
&lt;p&gt;完整配置:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--  Hive On Spark 配置 --&amp;gt;
  
    &amp;lt;property&amp;gt;
       &amp;lt;name&amp;gt;hive.execution.engine&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;spark&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

     &amp;lt;property&amp;gt;
           &amp;lt;name&amp;gt;spark.master&amp;lt;/name&amp;gt;
           &amp;lt;value&amp;gt;spark://master:7077&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

        &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;spark.home&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;/opt/spark/spark1.6-hadoop2.4-hive&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;

        &amp;lt;property&amp;gt;
        &amp;lt;name&amp;gt;spark.submit.deployMode&amp;lt;/name&amp;gt;
        &amp;lt;value&amp;gt;client&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;

        &amp;lt;property&amp;gt;
           &amp;lt;name&amp;gt;spark.serializer&amp;lt;/name&amp;gt;
           &amp;lt;value&amp;gt;org.apache.spark.serializer.KryoSerializer&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;

    &amp;lt;property&amp;gt;
       &amp;lt;name&amp;gt;spark.eventLog.enabled&amp;lt;/name&amp;gt;
       &amp;lt;value&amp;gt;true&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;property&amp;gt;
       &amp;lt;name&amp;gt;spark.eventLog.dir&amp;lt;/name&amp;gt;
       &amp;lt;value&amp;gt;hdfs://master:9000/directory&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

   &amp;lt;property&amp;gt;
       &amp;lt;name&amp;gt;spark.executor.memory&amp;lt;/name&amp;gt;
       &amp;lt;value&amp;gt;10G&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

   &amp;lt;property&amp;gt;
       &amp;lt;name&amp;gt;spark.driver.memory&amp;lt;/name&amp;gt;
       &amp;lt;value&amp;gt;10G&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功配置这些之后，进入hive shell中。&lt;br/&gt;简单进行两个表的关联查询&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180120205832596?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;可以看到hive已经成功使用spark作为引擎了。&lt;/p&gt;
&lt;h2 id=&quot;hive-on-hbase-使用spark引擎测试&quot;&gt;Hive on HBase 使用spark引擎测试&lt;/h2&gt;
&lt;p&gt;在成功整合环境之后，并且建立了两张hive 外联hbase的表之后。进行数据查询测试。&lt;br/&gt;两张表的创建脚本:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create table t_student(id int,name string) stored by 'org.apache.hadoop.hive.hbase.HBaseStorageHandler' with serdeproperties(&quot;hbase.columns.mapping&quot;=&quot;:key,st1:name&quot;) tblproperties(&quot;hbase.table.name&quot;=&quot;t_student&quot;,&quot;hbase.mapred.output.outputtable&quot; = &quot;t_student&quot;);

create table t_student_info(id int,age int,sex string) stored by 'org.apache.hadoop.hive.hbase.HBaseStorageHandler' with serdeproperties(&quot;hbase.columns.mapping&quot;=&quot;:key,st1:age,st1:sex&quot;) tblproperties(&quot;hbase.table.name&quot;=&quot;t_student_info&quot;,&quot;hbase.mapred.output.outputtable&quot; = &quot;t_student_info&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在两张表中个插入插入100万数据测试&lt;br/&gt;注：我这里是在HBase中直接插入100w数据的，使用HBase的Api完成的，具体可以&lt;a href=&quot;http://www.panchengming.com/2017/12/14/pancm59/&quot;&gt;大数据学习系列之三 ----- HBase Java Api 图文详解&lt;/a&gt;这篇博文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180120211421282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功插入之后，我们在hive shell中来测试查询速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条数测试:&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180120211735498?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主键管理查询测试:&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180120211814385?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非主键查询测试:&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180120211846883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWF6d3N4cGNt/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注:其实也是可以使用hive的Api ，就是普通的JDBC连接，只不过连接驱动要换成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class.forName(&quot;org.apache.hive.jdbc.HiveDriver&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体实现可以看我的github中的代码:&lt;a href=&quot;https://github.com/xuwujing/pancm_project/blob/master/src/main/java/com/pancm/test/hiveTest/hiveUtil.java&quot; class=&quot;uri&quot;&gt;https://github.com/xuwujing/pancm_project/blob/master/src/main/java/com/pancm/test/hiveTest/hiveUtil.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论:&lt;/strong&gt; 使用 hive on spark 查询可以看出，如果查询条件是主键，也就是hbase中的rowkey的话，查询100w数据可以在2.3s左右就查出来了(个人感觉打开spark估计就要用2s左右，如果量大的话，速度估计也不会很慢)， 但是如果使用非主键的条件去查询，就可以看到速度明显变慢了。&lt;br/&gt;所以在使用 hive on hbase 的时候，尽量使用rowkey进行查询。&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;其实集群的环境搭建以及整合在我写第一篇大数据学习系列博客的时候就已经搭建好了。至于博客为什么写得这么迟，&lt;strong&gt;第一点&lt;/strong&gt;是当初搭建环境的时候，并没有真正的理解那些配置的作用；&lt;strong&gt;第二点&lt;/strong&gt;是环境搭建有些莫名其妙，经常出现问题，不过大部分问题和解决反感我都记录并写成博客了，所以慢慢写博客其实也是个人知识的重新整理；&lt;strong&gt;第三是&lt;/strong&gt;个人的精力有限，无法一口气将这些都写成博客，毕竟写博客也需要一定时间和精力的。&lt;br/&gt;完成本篇博文之后，暂时先不写大数据这方面的博客了。感觉目前的自己能力还不够，如果就这样勉强的去自学，估计也很难学到知识点，更何况将其写成博客来讲解了。所以目前就先放放，有能力之后再来续写！&lt;br/&gt;大数据学习系列的文章:&lt;a href=&quot;http://blog.csdn.net/column/details/18120.html&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/column/details/18120.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jan 2018 13:24:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/8322022.html</dc:identifier>
</item>
<item>
<title>测试经验分享：做一个靠谱的软件测试人员 - 资深Tester_王豆豆</title>
<link>http://www.cnblogs.com/evangline/p/8322018.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evangline/p/8322018.html</guid>
<description>&lt;p&gt;&lt;strong&gt;何为靠谱？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在带新人过程中，交待测试新人测试任务时，都不会忘记交待这样的一句话：这个开发如何如何……&lt;/p&gt;

&lt;p&gt;比如这个开发代码质量很好，少bug，修改bug也快。&lt;/p&gt;
&lt;p&gt;比如这个开发编码有点慢，跟任务时多催一下。&lt;/p&gt;
&lt;p&gt;比如这个开发编码质量不怎么样，bug多，你测试的时候多注意一点，仔细测试下。&lt;/p&gt;

&lt;p&gt;像这样的交代有很多，特别刚开始还不熟悉开发的时候，等时间久了，只要测试过某个开发人员的项目一二次，就这个开发人员的编码质量基本也就清楚了。&lt;/p&gt;

&lt;p&gt;靠谱的开发人员代码质量高，转测之前会先进行自测，代码bug少，有bug时影响也很快，和这类开发人员一起搭档做项目会感觉很轻松，代码质量高，上线有保证，测试人员都喜欢这样的靠谱开发，王豆豆就经常碰到这类开发，真是好运爆棚。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/iaO2X20KfEIFgCicsRE121fqRqWVtLC5wibMKy8HUJP5mLM8dibFyIWkAo5WJ2p6ZqmIZQsDn0icu6TNGaG3Iqf6mYg/0/jpeg?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-ratio=&quot;0.6671875&quot; data-w=&quot;640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/iaO2X20KfEIFgCicsRE121fqRqWVtLC5wibMKy8HUJP5mLM8dibFyIWkAo5WJ2p6ZqmIZQsDn0icu6TNGaG3Iqf6mYg/0/jpeg&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;今天王豆豆并不是想分析如何找一个靠谱的开发，而是要分析如何成为一个靠谱的测试人员。&lt;/p&gt;

&lt;p&gt;既然测试人员喜欢靠谱开发，那相反开发人员也会喜欢靠谱的测试人员。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那靠谱的测试人员是什么样的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;王豆豆认为靠谱测试人员应该具备以下几个特点：&lt;/p&gt;
&lt;p&gt;1.业务能力强，测试流程清晰&lt;/p&gt;
&lt;p&gt;2.测试覆盖面广，测试深度足够&lt;/p&gt;
&lt;p&gt;3.对bug敏感，能发现隐藏极深的bug&lt;/p&gt;
&lt;p&gt;总之一句话，你测试，我放心，软件质量有保证。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;靠谱技能之一：尽可能多的覆盖测试范围&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个技能特别适合那种项目时间很短，需要紧急上线的小项目，这类项目需求太多不明确，且留给测试人员的时间非常少，测试之前测试人员对项目需求不了解，这类项目如果一拿到就开始测试，很容易就造成了漏测，那作为一个靠谱的测试人员就要想办法避免这种情况。&lt;/p&gt;

&lt;p&gt;该类项目大部分都无需求，只靠与产品经理和开发人员的沟通整理需求。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.6671875&quot; data-w=&quot;640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/iaO2X20KfEIFgCicsRE121fqRqWVtLC5wibEUYnkLDiaL327DhrPPcm8vYyju1wvll0o88sUicu60Rq5tRV13ib06axQ/0/jpeg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.沟通确定测试范围&lt;/p&gt;

&lt;p&gt;接到项目之后，首先查看提测邮件，配置测试环境和数据库，根据情况判断是否先进行一笔正常场景的测试，当成熟悉需求一种方法，当自己对需求有了大致的了解之后，就与找产品经理或开发人员进行沟通。&lt;/p&gt;

&lt;p&gt;沟通内容主要围绕以下几点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.此项目修改点是什么？主要做了哪些功能？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.代码是如何实现的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如一个对用户敏感信息的加密解密功能，当前端将用户信息传入进来时，调用加密API，将用户的敏感信息进行加密操作，然后存表数据，当再次取表数据进行其他操作时，这时调用解密api，将用户的敏感信息进行解密操作。&lt;/p&gt;
&lt;p&gt;这时业务流程上的实现方式，那对应到代码中代码是如何实现的？加解密API是怎么调用的？地址是多少？如何传参的等等&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.本次项目修改的代码覆盖的范围，确实测试范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.测试过程中需要注意哪些点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.异常情况会有哪些？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对照这几个问题一个一个的问清楚，理清楚。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.5625&quot; data-w=&quot;640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/iaO2X20KfEIFgCicsRE121fqRqWVtLC5wibDibXFHiaLuhU9daem8uAOSLZkQ9TQBB47VywElMCwV1qDC4wcUOKDl1A/0/jpeg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.画出测试范围&lt;/p&gt;

&lt;p&gt;如果上面几点在沟通中能到位，那测试人员基本对整个项目有了相对清晰的认识了。&lt;/p&gt;

&lt;p&gt;这时拿出一个本子和一支笔画出测试流程，测试范围，注意点等等。&lt;/p&gt;

&lt;p&gt;这个地方大家注意，王豆豆说的是画，并不是写，画代表在这个过程中会有修改或不明确的地方，将不确定的地方再次明确。&lt;/p&gt;

&lt;p&gt;（今天以最近做的一个小项目为例，隐去了业务，见谅）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaO2X20KfEIFgCicsRE121fqRqWVtLC5wibOuUykwOfbf7iaAxaiaDy5RHzBwHEabyibicyRmRCks7bf4ydTpP0icsIicrQ/0/png?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-ratio=&quot;1.3333333&quot; data-w=&quot;549&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaO2X20KfEIFgCicsRE121fqRqWVtLC5wibOuUykwOfbf7iaAxaiaDy5RHzBwHEabyibicyRmRCks7bf4ydTpP0icsIicrQ/0/png&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;王豆豆经常在桌子上准备一个本子和一支笔，不管是对需求不理解的点，还是测试过程中遇到的不明确问题都先在本子上记录下来，这种方法特别适合新人，当上级或带你的前辈在安排任务或讲业务的时候，都拿笔记下来，俗话说得好“好记性不如烂笔头”，这是古人留给我们的智慧，我们理当好好传承。&lt;/p&gt;

&lt;p&gt;3.明确测试范围&lt;/p&gt;

&lt;p&gt;将在本子上整理的测试点，测试范围，用XMIND等工具快速整理出来。&lt;/p&gt;

&lt;p&gt;这时推荐用这种思维导图的工具整理，不推荐用excel或word文档整理，将整理好的内容发给开发人员和产品经理确认是否覆盖完全，检查点是否设置正确等问题。&lt;/p&gt;

&lt;p&gt;为什么要做这步？因为每个人的理解都有所不同，做这步其主要目的在于消灭这种因理解不同，而导致后期测试不全，出现漏测的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/iaO2X20KfEIFgCicsRE121fqRqWVtLC5wibLDBYuwcu8gG9Tg0YDg6pan9lY0QgVWMxdiaibR9fGY4qel7AuibHYWmcA/0/jpeg?tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-ratio=&quot;0.9328125&quot; data-w=&quot;640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/iaO2X20KfEIFgCicsRE121fqRqWVtLC5wibLDBYuwcu8gG9Tg0YDg6pan9lY0QgVWMxdiaibR9fGY4qel7AuibHYWmcA/0/jpeg&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这些操作其实对应到测试流程就是需求分析，写测试用例和用例评审，在项目时间偏紧的情况下，可以通过这样的方式来进行，这些操作一定不能省，如果以这样的方式来做也需要不了多少时间就能完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;靠谱的测试人员经手的项目覆盖面全，测试结果会很让人放心，测试质量更有保证，只有成为一个靠谱的测试人员，你的上级才会放心把项目交给你负责。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;看了王豆豆的分享，大家有什么不同的看法？欢迎一起来分享你们在工作中是使用何种技能让自己更靠谱的。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jan 2018 13:23:00 +0000</pubDate>
<dc:creator>资深Tester_王豆豆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evangline/p/8322018.html</dc:identifier>
</item>
<item>
<title>Beyond Globally Optimal: Focused Learning - 笨兔勿应</title>
<link>http://www.cnblogs.com/bentuwuying/p/8322002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bentuwuying/p/8322002.html</guid>
<description>&lt;p&gt;这里对WWW 2017文章《Beyond Globally Optimal: Focused Learning for Improved Recommendations》进行一个简单的分析解读。&lt;/p&gt;
&lt;p&gt;文章亮点：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;作者群来自Google和Pinterest&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第一次系统性的解释了为什么用全局模型可能会在局部数据上表现不好&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;文章提出了简单易行的解决办法，可以让全局模型在局部数据上依然能够达到最优&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;文章很全面得在一些数据及上进行了比较完整的比较&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章来自一群前CMU的学者，目前在Google和Pinterest。那么这篇文章试图解决什么问题呢？具体说来，就是作者们发现，传统的推荐系统，基于优化一个全局的目标函数，通常情况下往往只能给出一个非常有“偏差”（Skewed）的预测分布。也就是说，传统的推荐系统追求的是平均表现情况，在很多情况下的预测其实是十分不准确的。这个情况在评价指标是Root Mean Squared Error（RMSE）的时候，就显得尤为明显。&lt;/p&gt;

&lt;p&gt;这篇文章的作者是这么定义了一个叫做Focused Learning的问题，那就是如果让模型在一个局部的数据上能够表现出色。那么，为什么需要模型在一个局部的数据上表现出色呢？作者们做了这么一件事情，那就是对每个用户，以及每一个物品的预测误差（Error）进行了分析统计，发现有不小比例的用户的预测误差比较大，也有不小比例的物品的预测误差比较大。作者们发现模型在一些数据上存在着系统性的误差较大的问题，而不是偶然发生的情况。&lt;/p&gt;

&lt;p&gt;作者们又从理论上进行了对这个问题一番讨论。这里的讨论十分巧妙，大概的思路就是，假定现在在全局最优的情况下，模型的参数的梯度已经为0了，但模型的Loss依然不为0（这种情况很常见）。那么，就一定存在部分数据的参数梯度不为0，因为某一部分数据的Loss不为0。这也就证明了部分数据的模型参数在这些数据上的表现一定不是最优的。值得注意的是，这个证明非常普遍，和具体的模型是什么类型没有关系。&lt;/p&gt;

&lt;p&gt;在有了这么一番讨论之后，那么作者们如何解决这个问题呢？这篇文章走了Hyper-parameter Optimization的道路。文章展示了这在普通的Matrix Factorization里面是如何做到。具体说来，就是对于某个Focused Set做Hyper-parameter的调优，使得当前的Hyper-parameter能够在Focused Set上能够有最好表现。而这组参数自然是针对不同的Focused Set有不同的选择。文章提到的另外一个思路，则是对Focused Set以及非Focused Set的Hyper-parameter进行区分对待，这样有助于最后的模型能够有一个比较Flexible的表达。&lt;/p&gt;

&lt;p&gt;文章在实验的部分针对几种不同的Focused Set进行了比较实验。比如，针对Cold-Start的物品，针对Outlier的物品，以及更加复杂的libFM模型都进行了实验。我们在这里就不去复述了。总体来说，Focused Learning在不同的数据集上都得到了比较好的提升效果。同时，作者们还针对为什么Focused Learning能够Work进行了一番探讨，&lt;span&gt;&lt;strong&gt;总体看来，Focused Learning既照顾了Global的信息，同时又通过附加的Hyper-parameter调优对某一个局部的数据进行优化，所以往往好于Global的模型以及也好于单独的Local模型。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Jan 2018 13:16:00 +0000</pubDate>
<dc:creator>笨兔勿应</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bentuwuying/p/8322002.html</dc:identifier>
</item>
<item>
<title>使用 GStreamer appsrc 等插件实现视频音频混流，录制和推流 - hejiangyuan</title>
<link>http://www.cnblogs.com/luckbird/p/GStreamer_appsrc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luckbird/p/GStreamer_appsrc.html</guid>
<description>&lt;p&gt;目前在做的在线直播教室，需要将老师分享的屏幕和老师的声音、学生的声音录制为一个视频文件，以便学生上课后还可以再看回放。&lt;/p&gt;
&lt;p&gt;直播服务我们采用的是腾讯的视频服务，有现成的 SDK 可以用。但 SDK 自带的录制接口满足不了我们的需求，考察了 ffmpeg 和 GStreamer 后，决定在项目中使用 GStreamer 来实现。&lt;/p&gt;
&lt;p&gt;在开始编写代码以前，先用命令行进行测试，命令行如下：&lt;br/&gt;&lt;/p&gt;
&lt;pre&gt;
gst-launch-1.0.exe -v --gst-debug-level=4 flvmux name=mux ! tee name=t ! queue ! filesink name=file location=test.flv \
t. ! queue ! rtmpsink location=&quot;rtmp://live.abc.com/live/........&quot; \
adder name=mix ! queue ! audiorate ! audioconvert ! voaacenc ! mux.audio \
videotestsrc name=screen_src ! queue ! videorate ! x264enc ! mux.video \
audiotestsrc name=send_audio_src ! queue ! audiorate ! mix. \
audiotestsrc wave=5 name=receive_audio_src ! queue ! audiorate ! mix.
&lt;/pre&gt;
&lt;p&gt;命令看起来有点复杂，但其实逻辑挺简单的，看下面这个逻辑图就比较容易理解了（点击查看大图） &lt;a href=&quot;http://images2017.cnblogs.com/blog/19628/201801/19628-20180120170134678-1951369388.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/19628/201801/19628-20180120170134678-1951369388.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上面的命令中的推流地址需要替换为你的推流地址，如果没有，可以先把下面这部分内容去掉不推流&lt;/p&gt;
&lt;pre&gt;
t. ! queue ! rtmpsink location=&quot;rtmp://live.abc.com/live/........&quot; \
&lt;/pre&gt;
&lt;p&gt;另外这个命令是在 Windows 中的 MINGW64 的 bash 环境里面运行的， 如果在 Windows 的 cmd 环境中运行，把每行最后的 \ 和换行去掉就可以了。&lt;/p&gt;
&lt;p&gt;上面命令中用到了几个关键的插件，分别解释一下：&lt;br/&gt;adder： 音频混流，将两路音频混为一路&lt;br/&gt;voaacenc：音频编码，将原始的音频流编码为 aac 格式&lt;br/&gt;x264enc：视频编码，将原始的视频流编码为 h264 格式&lt;br/&gt;flvmux：flv 组装，将视频和音频组装在一起&lt;br/&gt;tee：分流器，将一路输入变为两路输出，以分别进行后续的处理。一路保存为文件，一路进行推流&lt;br/&gt;filesink：文件存储，将输入数据存储到指定的文件中&lt;br/&gt;rtmpsink：推流，将输入数据推流到指定的视频服务器&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;接下来进行代码实现，我们的项目是 QT C++ 项目，目前仅在 Windows 平台使用&lt;/p&gt;
&lt;p&gt;将 gstream 管道的初始化等放在 GStreamProcess 类中，代码如下：&lt;/p&gt;
&lt;p&gt;GStreamProcess.h&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#pragma once

#include &quot;stdafx.h&quot;

#include &amp;lt;gst/gst.h&amp;gt;
#include &amp;lt;gst/app/gstappsrc.h&amp;gt;
#include &amp;lt;gst/base/gstbaseparse.h&amp;gt;

typedef struct _AppSrcOption AppSrcOption;

struct _AppSrcOption
{
        _AppSrcOption()
                : pipeline(nullptr)
                , shareScreenAppsrc(nullptr)
                , sendAudioAppsrc(nullptr)
                , bus(nullptr)
                , gloop(nullptr)
                , width(0)
                , height(0)
        {}

        GstElement *pipeline;
        GstElement *shareScreenAppsrc;
        GstElement *sendAudioAppsrc;
        GstElement *receiveAudioAppsrc;
        GstElement *rtmp;
        GstBus *bus;
        GMainLoop *gloop;

        QString recordFileName;

        iLiveSucCallback sucCallback;
        iLiveErrCallback errCallback;
        void* callbackData;

        uint width;
        uint height;

        QString pushStreamUrl;
};

//int gstreamerInit(AppSrcOption *app, int argc, char *argv[]);


class GStreamProcess : public QThread
{
        Q_OBJECT

public:
        AppSrcOption* app;

protected:              
        void run() Q_DECL_OVERRIDE;

signals:
        void resultReady(const QString &amp;amp;s);
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GStreamProcess.cpp&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;stdafx.h&quot;

GST_DEBUG_CATEGORY(appsrc_pipeline_debug);
#define GST_CAT_DEFAULT appsrc_pipeline_debug

static gboolean
bus_message(GstBus * bus, GstMessage * message, AppSrcOption * app)
{
        GST_DEBUG(&quot;got message %s&quot;,
                gst_message_type_get_name(GST_MESSAGE_TYPE(message)));

        switch (GST_MESSAGE_TYPE(message)) {
        case GST_MESSAGE_ERROR: {
                GError *err = NULL;
                gchar *dbg_info = NULL;

                gst_message_parse_error(message, &amp;amp;err, &amp;amp;dbg_info);

                gchar* elename = GST_OBJECT_NAME(message-&amp;gt;src);

                g_printerr(&quot;ERROR from element %s: %s\n&quot;,
                        elename, err-&amp;gt;message);
                g_printerr(&quot;Debugging info: %s\n&quot;, (dbg_info) ? dbg_info : &quot;none&quot;);

                app-&amp;gt;errCallback(-90001, err-&amp;gt;message, app-&amp;gt;callbackData);

                g_error_free(err);
                g_free(dbg_info);
                g_main_loop_quit(app-&amp;gt;gloop);
                break;
        }
        case GST_MESSAGE_EOS: {
                g_main_loop_quit(app-&amp;gt;gloop);
                break;
        }
        default:
                break;
        }

        return TRUE;
}

void GStreamProcess::run()
{
        GError *error = NULL;

        int argc = 1;

        char *mock[1] = {&quot;empty&quot;};
        char **argv[1];
        *argv = mock;

        gst_init(&amp;amp;argc, argv);

        GST_DEBUG_CATEGORY_INIT(appsrc_pipeline_debug, &quot;appsrc-pipeline&quot;, 0,
                &quot;appsrc pipeline example&quot;);

        app-&amp;gt;gloop = g_main_loop_new(NULL, TRUE);

        GstElement *pipeline = gst_parse_launch(&quot;flvmux name=mux ! queue ! tee name=t ! queue ! filesink name=file t. ! queue ! rtmpsink name=rtmp adder name=mix ! queue ! audiorate ! audioconvert ! voaacenc ! mux.audio appsrc name=screen_src ! queue ! videorate ! x264enc ! mux.video appsrc name=send_audio_src ! queue ! audiorate ! mix. appsrc wave=5 name=receive_audio_src ! queue ! audiorate ! mix.&quot;, NULL);
        g_assert(pipeline);

        app-&amp;gt;bus = gst_pipeline_get_bus(GST_PIPELINE(pipeline));
        g_assert(app-&amp;gt;bus);

        /* add watch for messages */
        gst_bus_add_watch(app-&amp;gt;bus, (GstBusFunc)bus_message, app);


        /* 设置 screen src 属性 */

        app-&amp;gt;shareScreenAppsrc = gst_bin_get_by_name(GST_BIN(pipeline), &quot;screen_src&quot;);
        g_assert(app-&amp;gt;shareScreenAppsrc);

        GstCaps *caps = gst_caps_new_simple(&quot;video/x-raw&quot;,
                &quot;format&quot;, G_TYPE_STRING, &quot;I420&quot;,
                &quot;width&quot;, G_TYPE_INT, app-&amp;gt;width,
                &quot;height&quot;, G_TYPE_INT, app-&amp;gt;height,
                &quot;framerate&quot;, GST_TYPE_FRACTION, 15, 1,
                NULL);

        gst_app_src_set_caps(GST_APP_SRC(app-&amp;gt;shareScreenAppsrc), caps);

        g_object_set(app-&amp;gt;shareScreenAppsrc, &quot;format&quot;, GST_FORMAT_TIME, NULL);
        g_object_set(app-&amp;gt;shareScreenAppsrc, &quot;is-live&quot;, TRUE, NULL);


        /* 设置 send audio src 属性 */

        app-&amp;gt;sendAudioAppsrc = gst_bin_get_by_name(GST_BIN(pipeline), &quot;send_audio_src&quot;);
        g_assert(app-&amp;gt;sendAudioAppsrc);

        caps = gst_caps_new_simple(&quot;audio/x-raw&quot;,
                &quot;format&quot;, G_TYPE_STRING, &quot;S16LE&quot;,
                &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;,
                &quot;channels&quot;, G_TYPE_INT, 2,
                &quot;rate&quot;, G_TYPE_INT, 48000,
                NULL);

        gst_app_src_set_caps(GST_APP_SRC(app-&amp;gt;sendAudioAppsrc), caps);
        g_object_set(app-&amp;gt;sendAudioAppsrc, &quot;format&quot;, GST_FORMAT_TIME, NULL);
        g_object_set(app-&amp;gt;sendAudioAppsrc, &quot;is-live&quot;, TRUE, NULL);


        /* 设置 receive audio src 属性 */

        app-&amp;gt;receiveAudioAppsrc = gst_bin_get_by_name(GST_BIN(pipeline), &quot;receive_audio_src&quot;);
        g_assert(app-&amp;gt;receiveAudioAppsrc);

        caps = gst_caps_new_simple(&quot;audio/x-raw&quot;,
                &quot;format&quot;, G_TYPE_STRING, &quot;S16LE&quot;,
                &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;,
                &quot;channels&quot;, G_TYPE_INT, 2,
                &quot;rate&quot;, G_TYPE_INT, 48000,
                NULL);

        gst_app_src_set_caps(GST_APP_SRC(app-&amp;gt;receiveAudioAppsrc), caps);
        g_object_set(app-&amp;gt;receiveAudioAppsrc, &quot;format&quot;, GST_FORMAT_TIME, NULL);
        g_object_set(app-&amp;gt;receiveAudioAppsrc, &quot;is-live&quot;, TRUE, NULL);


        /* 设置 filesink 属性 */

        GstElement *filesink = gst_bin_get_by_name(GST_BIN(pipeline), &quot;file&quot;);
        g_assert(filesink);

        g_object_set(G_OBJECT(filesink), &quot;location&quot;, app-&amp;gt;recordFileName.toStdString().c_str(), NULL);


        /* 设置 rtmp 属性 */

        GstElement *rtmp = gst_bin_get_by_name(GST_BIN(pipeline), &quot;rtmp&quot;);
        g_assert(rtmp);

        g_object_set(G_OBJECT(rtmp), &quot;location&quot;, app-&amp;gt;pushStreamUrl.toStdString().c_str(), NULL);

        /* go to playing */
        gst_element_set_state(pipeline, GST_STATE_PLAYING);

        //GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS(GST_BIN(pipeline), GST_DEBUG_GRAPH_SHOW_ALL, &quot;pipeline_dot&quot;);

        app-&amp;gt;pipeline = pipeline;

        app-&amp;gt;sucCallback(app-&amp;gt;callbackData);

        g_main_loop_run(app-&amp;gt;gloop);

        GST_DEBUG(&quot;stopping&quot;);

        gst_element_set_state(app-&amp;gt;pipeline, GST_STATE_NULL);

        gst_object_unref(app-&amp;gt;bus);
        g_main_loop_unref(app-&amp;gt;gloop);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，比较关键的地方是 appsrc 的 format 属性需要设置为 GST_FORMAT_TIME，如果不设置的话，视频和音频会无法同步，就是下面这几行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
g_object_set(app-&amp;gt;shareScreenAppsrc, &quot;format&quot;, GST_FORMAT_TIME, NULL);
...
g_object_set(app-&amp;gt;sendAudioAppsrc, &quot;format&quot;, GST_FORMAT_TIME, NULL);
...
g_object_set(app-&amp;gt;receiveAudioAppsrc, &quot;format&quot;, GST_FORMAT_TIME, NULL);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在需要启动录制的地方开启线程，启动 GStreamer 处理线程（因为项目比较复杂，这里只截取部分）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
m_pAppSrcOption = new AppSrcOption();
m_pAppSrcOption-&amp;gt;recordFileName = filePath;
m_pAppSrcOption-&amp;gt;pushStreamUrl = m_pushStreamUrl;

m_pAppSrcOption-&amp;gt;callbackData = this;
m_pAppSrcOption-&amp;gt;sucCallback = OnLocalRecordSuc;
m_pAppSrcOption-&amp;gt;errCallback = OnLocalRecordErr;

m_pLocalRecordProcessThread = new GStreamProcess();
m_pLocalRecordProcessThread-&amp;gt;app = m_pAppSrcOption;

connect(m_pLocalRecordProcessThread, &amp;amp;GStreamProcess::finished, m_pLocalRecordProcessThread, &amp;amp;QObject::deleteLater);
connect(m_pLocalRecordProcessThread, &amp;amp;GStreamProcess::finished, this, &amp;amp;MainForm::OnLocalRecordClose);

m_pLocalRecordProcessThread-&amp;gt;start();

m_pFillBlankAudioTimer-&amp;gt;start(2000);
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来注入视频帧数据。 这个项目在分享屏幕时，每一帧的视频数据会回调指定方法。在回调方法中，我们将数据传给管道中的 shareScreenAppsrc&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void MainForm::localVideoHook(const LiveVideoFrame* video_frame)
{
        if (m_pAppSrcOption &amp;amp;&amp;amp; m_pAppSrcOption-&amp;gt;pipeline)
        {
                GstBuffer *buffer;
                guint8 *ptr;
                ptr = (guint8 *)g_malloc(video_frame-&amp;gt;dataSize * sizeof(uint8));
                if (NULL == ptr)
                {
                        qDebug(&quot;OnLocalVideo::malloc failed!&quot;);
                }
                else
                {
                        memcpy(ptr, video_frame-&amp;gt;data, video_frame-&amp;gt;dataSize);
                        buffer = gst_buffer_new_wrapped((void*)ptr, video_frame-&amp;gt;dataSize);

                        //设置时间戳
                        GST_BUFFER_PTS(buffer) = gst_clock_get_time(m_pAppSrcOption-&amp;gt;pipeline-&amp;gt;clock) - m_pAppSrcOption-&amp;gt;pipeline-&amp;gt;base_time;

                        GstFlowReturn ret;
                        //注入视频帧数据
                        g_signal_emit_by_name(m_pAppSrcOption-&amp;gt;shareScreenAppsrc, &quot;push-buffer&quot;, buffer, &amp;amp;ret);

                        gst_buffer_unref(buffer);
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，设置时间戳的代码非常关键，如果没有时间戳，会导致管道中的 videorate 由于缺少时间戳信息而失败。 这里的时间戳取的是：当前管道时间 - 管道启动时的时间&lt;/p&gt;
&lt;p&gt;然后以类似的方式注入音频帧数据，音频帧有两路，一路为老师的声音，一路为学生的声音。 老师的声音：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void MainForm::sendAudioHook(const iLiveAudioFrame* audio_frame)
{

        if (m_pAppSrcOption &amp;amp;&amp;amp; m_pAppSrcOption-&amp;gt;pipeline)
        {
                GstBuffer *buffer;

                guint8 *ptr;
                ptr = (guint8 *)g_malloc(audio_frame-&amp;gt;dataSize * sizeof(uint8));
                if (NULL == ptr)
                {
                        qDebug(&quot;OnSendAudioCallback::malloc failed!&quot;);
                }
                else
                {
                        memcpy(ptr, audio_frame-&amp;gt;data, audio_frame-&amp;gt;dataSize);

                        buffer = gst_buffer_new_wrapped((void*)ptr, audio_frame-&amp;gt;dataSize);

                        //设置时间戳
                        GST_BUFFER_PTS(buffer) = gst_clock_get_time(m_pAppSrcOption-&amp;gt;pipeline-&amp;gt;clock) - m_pAppSrcOption-&amp;gt;pipeline-&amp;gt;base_time;

                        GstFlowReturn ret;
                        //注入音频帧数据
                        g_signal_emit_by_name(m_pAppSrcOption-&amp;gt;sendAudioAppsrc, &quot;push-buffer&quot;, buffer, &amp;amp;ret);

                        gst_buffer_unref(buffer);
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;学生的声音：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void MainForm::receiveAudioHook(const iLiveAudioFrame* audio_frame)
{

        if (m_pAppSrcOption &amp;amp;&amp;amp; m_pAppSrcOption-&amp;gt;pipeline)
        {
                GstBuffer *buffer;

                guint8 *ptr;
                ptr = (guint8 *)g_malloc(audio_frame-&amp;gt;dataSize * sizeof(uint8));
                if (NULL == ptr)
                {
                        qDebug(&quot;receiveAudioHook::malloc failed!&quot;);
                }
                else
                {
                        memcpy(ptr, audio_frame-&amp;gt;data, audio_frame-&amp;gt;dataSize);

                        buffer = gst_buffer_new_wrapped((void*)ptr, audio_frame-&amp;gt;dataSize);

                        //设置时间戳
                        GST_BUFFER_PTS(buffer) = gst_clock_get_time(m_pAppSrcOption-&amp;gt;pipeline-&amp;gt;clock) - m_pAppSrcOption-&amp;gt;pipeline-&amp;gt;base_time;

                        GstFlowReturn ret;
                        //注入音频帧数据
                        g_signal_emit_by_name(m_pAppSrcOption-&amp;gt;receiveAudioAppsrc, &quot;push-buffer&quot;, buffer, &amp;amp;ret);

                        gst_buffer_unref(buffer);
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在项目中还有一个特殊的地方，因为声音并不是一直有数据的，如果学生没有连麦或老师没有开启麦克风，是没有音频帧数据回调的，这会导致音频混流时因为缺少数据而一直等待，造成阻塞。&lt;/p&gt;
&lt;p&gt;这里采取了一个变通的方法，就是设置一个定时器，每隔 2 秒注入一帧空白数据。上面代码中的 m_pFillBlankAudioTimer-&amp;gt;start(2000); 就是用于启动这个定时器的。下面是注入空白帧的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//填充音频无信号时的空白声音，音频断流的话，会导致 adder 混流 block
void MainForm::OnFillBlankAudioTimer()
{
        if (m_pAppSrcOption &amp;amp;&amp;amp; m_pAppSrcOption-&amp;gt;pipeline &amp;amp;&amp;amp; m_pAppSrcOption-&amp;gt;receiveAudioAppsrc)
        {

                GstBuffer *buffer;
                guint size;
                GstFlowReturn ret;

                size = 3840;

                buffer = gst_buffer_new_allocate(NULL, size, NULL);

                gst_buffer_memset(buffer, 0, 0x0, size);

                GST_BUFFER_PTS(buffer) = gst_clock_get_time(m_pAppSrcOption-&amp;gt;pipeline-&amp;gt;clock) - m_pAppSrcOption-&amp;gt;pipeline-&amp;gt;base_time;

                g_signal_emit_by_name(m_pAppSrcOption-&amp;gt;receiveAudioAppsrc, &quot;push-buffer&quot;, buffer, &amp;amp;ret);
                gst_buffer_unref(buffer);

        }

        if (m_pAppSrcOption &amp;amp;&amp;amp; m_pAppSrcOption-&amp;gt;pipeline &amp;amp;&amp;amp; m_pAppSrcOption-&amp;gt;sendAudioAppsrc)
        {
                GstBuffer *buffer;
                guint size;
                GstFlowReturn ret;

                size = 3840;

                buffer = gst_buffer_new_allocate(NULL, size, NULL);

                gst_buffer_memset(buffer, 0, 0x0, size);

                GST_BUFFER_PTS(buffer) = gst_clock_get_time(m_pAppSrcOption-&amp;gt;pipeline-&amp;gt;clock) - m_pAppSrcOption-&amp;gt;pipeline-&amp;gt;base_time;

                g_signal_emit_by_name(m_pAppSrcOption-&amp;gt;sendAudioAppsrc, &quot;push-buffer&quot;, buffer, &amp;amp;ret);
                gst_buffer_unref(buffer);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当需要结束混流和录制时，向管道中的各个 appsrc 发送 end-of-stream 消息，管道在处理完所有数据后，就会正常结束，关闭退出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void MainForm::onBtnStopPushStream()
{
        QMessageBox::StandardButton ret = QMessageBox::question(this, FromBits(&quot;确认&quot;), FromBits(&quot;是否要停止视频录制？（多次录制会产生多个视频文件，会影响回放的体验，应尽量避免多次录制）&quot;));

        if (ret == QMessageBox::Yes)
        {
                stopPushStream();

                if (m_pAppSrcOption &amp;amp;&amp;amp; m_pAppSrcOption-&amp;gt;pipeline)
                {
                        GstFlowReturn ret;
                        g_signal_emit_by_name(m_pAppSrcOption-&amp;gt;shareScreenAppsrc, &quot;end-of-stream&quot;, &amp;amp;ret);
                        g_signal_emit_by_name(m_pAppSrcOption-&amp;gt;sendAudioAppsrc, &quot;end-of-stream&quot;, &amp;amp;ret);
                        g_signal_emit_by_name(m_pAppSrcOption-&amp;gt;receiveAudioAppsrc, &quot;end-of-stream&quot;, &amp;amp;ret);

                        m_pFillBlankAudioTimer-&amp;gt;stop();
                }

                m_pushStreamStatus = E_ChangingPushStream;
                setStatus(m_status);
        }
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之前我们在启动线程时，用下面这句代码注册了事件，当线程结束时会调用 OnLocalRecordClose 方法，可以在这个方法中更改 UI 控件的状态和释放资源&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
connect(m_pLocalRecordProcessThread, &amp;amp;GStreamProcess::finished, this, &amp;amp;MainForm::OnLocalRecordClose);
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为第一次使用 GStreamer 进行开发，走了很多弯路，踩了很多坑。好在最后还是完成了需要的功能，直播录制和推流的效果还是不错的。&lt;/p&gt;
&lt;p&gt;但这个方案还存在一个问题，就是rtmp 推流时如果失败，会导致整个管道出错停止，这个还需要设法解决。&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;开发过程中参考了很多资料，比较有用的是下面这几个：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;appsrc 的 demo 代码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://gist.github.com/nzjrs/725122/16ceee88aafae389bab207818e0661328921e1ab&quot;&gt;https://gist.github.com/nzjrs/725122/16ceee88aafae389bab207818e0661328921e1ab&lt;/a&gt; （需要FQ）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/u010312436/article/details/53610599&quot;&gt;http://blog.csdn.net/u010312436/article/details/53610599&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gstreamer.freedesktop.org/documentation/application-development/advanced/pipeline-manipulation.html&quot;&gt;https://gstreamer.freedesktop.org/documentation/application-development/advanced/pipeline-manipulation.html&lt;/a&gt;&lt;/p&gt;
&lt;br/&gt;&lt;ul&gt;&lt;li&gt;GStreamer 时钟机制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://gstreamer.freedesktop.org/documentation/application-development/advanced/clocks.html&quot;&gt;https://gstreamer.freedesktop.org/documentation/application-development/advanced/clocks.html&lt;/a&gt;&lt;/p&gt;
&lt;br/&gt;&lt;ul&gt;&lt;li&gt;GStreamer 写日志和生成管道逻辑图的方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://gstreamer.freedesktop.org/documentation/tutorials/basic/debugging-tools.html&quot;&gt;https://gstreamer.freedesktop.org/documentation/tutorials/basic/debugging-tools.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer/html/gst-running.html&quot;&gt;https://gstreamer.freedesktop.org/data/doc/gstreamer/head/gstreamer/html/gst-running.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jan 2018 13:14:00 +0000</pubDate>
<dc:creator>hejiangyuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luckbird/p/GStreamer_appsrc.html</dc:identifier>
</item>
</channel>
</rss>