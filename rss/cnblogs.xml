<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>巧用浏览器F12调试器定位系统前后端bug - 韬哥（NickJiang）</title>
<link>http://www.cnblogs.com/nickjiang/p/9893278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nickjiang/p/9893278.html</guid>
<description>&lt;p&gt;做测试的小伙伴可能用过httpwatch，firebug，fiddler，charles等抓包（数据包）工具，但实际上除了这些还有一个简单实用并的抓包工具，那就是浏览器的F12调试器。&lt;/p&gt;
&lt;p&gt;httpwatch，firebug都是浏览器的插件，需要额外下载，fiddler，charles也需要额外下载安装包另行安装，但是浏览器F12调试器却是所有浏览器内置的调试器，不需要大家额外去安装的，打开它只是一个顺手的事情，而且它提供的功能也比较强大，因此如果在开发或者测试web系统的时候，我们可以先考虑使用这个调试器去抓包，来调试系统或者用它来协助定位系统中的bug。&lt;/p&gt;
&lt;p&gt;下文中我准备了几个小案例来说明这个工具的用法以及使用它的便捷性。&lt;/p&gt;
&lt;p&gt;废话不多说，我们首先来一睹它的阵容，以火狐为例，打开浏览器，再按F12就可以打开调试器，如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101213922689-1913839105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：不同的浏览器，调试器在ui上可能会有少许差异，但基本功能都差不多，掌握了某种浏览器调试器的用法后，其他也很容易上手。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232242120-292424776.gif&quot; alt=&quot;&quot;/&gt;下面我们通过几个小案例来说明我们测试人员在系统测试中有哪些场景能够应用上调试器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;场景：在对web系统进行测试时，如何分析一个bug是来自于前端还是后端。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 首先说一下，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232319928-1616257687.jpg&quot; alt=&quot;&quot;/&gt;为什么找到网站中的bug后还要去分析它到底是属于前端bug还是后端bug，三个原因：&lt;/p&gt;
&lt;p&gt;1.在一些公司，一个系统可能是由前端团队和后端团队共同开发出来的，因此在分配bug的时候，不同模块的bug一般都会指派给对应的负责团队乃至于个人。&lt;/p&gt;
&lt;p&gt;2.提bug的时候，如果能尽量提供有价值的信息给开发人员，来缩小定位范围，甚至于如果能够直接协助定位到bug出在哪里，那么开发人员将更容易去fix掉bug，从而降低了测试和开发之间的沟通成本，提高了工作效率。&lt;/p&gt;
&lt;p&gt;3.bug提的好从侧面也能体现测试人员具备了较高的技术专业性，而不是只会点点点，个人形象在项目团队中也会得到迅速提升。别人也会认为你是大佬，他们看你的表情如图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232341685-1089478948.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们在分析一个系统bug来自于前端还是后台时，最有用的两个是调试器提供的两个标签，这两个标签底下都记录了一些数据，&lt;span&gt;&lt;span&gt;&lt;strong&gt;一个是控制台，一个网络&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;控制台&lt;/strong&gt;&lt;/span&gt;：记录了前端js执行的情况，以及前端向服务器发出去的所有http请求信息，，如果有js错误可以在控制台下看到，同样如果发送到后台的某个http请求没有得到服务器正常响应，也能看到他的状态信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;网络&lt;/strong&gt;&lt;/span&gt;：记录了前端往服务器发的所有的http请求信息，而且每个请求发送了什么数据，服务器是否正常响应了请求，如果响应了，响应回来的状态码是什么，响应数据是什么都可以在“网络”标签下看到。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101223239826-107491529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;说了这么多，到底怎么用呢。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232444582-1795017514.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一个小案例&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;1）访问：http://39.108.136.60:8380/ningmengban/app/login/login.html&lt;/p&gt;
&lt;p&gt;2）输入登录账号(用户名 / 密码)：304034318@qq.com / 123456&lt;/p&gt;
&lt;p&gt;3）点击登录，无任何反映（没有提示也没有跳转）&lt;/p&gt;
&lt;p&gt;从页面交互看，输入账号，点击登录要么登录成功进入系统，跳转到系统其他页面，要么登录失败给出错误提示，而现在没有任何反应，这肯定是一个bug，但是这个bug到底是属于前端bug还是后端，我们无从而知，但是我们可以顺手打开浏览器调试器来分析定位一下。&lt;/p&gt;
&lt;p&gt;打开控制台，我们看到了控制台有一个js错误，并且是login.js这个脚本在执行的时候报的一个错误，login是登录的意思，所以我们下意识认为这个js脚本就是定义了登录前端逻辑的js脚本，点击登录按钮没任何反应这个bug很可能就是因为前端js执行报错引起的，截个图，写上自己的分析。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101222849540-990705291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 为了进一步验证自己的猜想，还可以再看下“网络”标签:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101224054853-2038949320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;定论：经过分析，前端登录脚本执行报错导致了前端没有对后台登录接口发起调用，页面点击登录按钮没有任何提示，这个bug属于前端的bug。我们提bug的时候带上上面的两个截图，里面有我们的分析。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232517416-1969830571.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二个小案例&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）访问：http://39.108.136.60:8380/ningmengban/app/login/login.html&lt;/p&gt;
&lt;p&gt;2）输入登录账号(用户名 / 密码)：304034318@qq.com / 123456&lt;/p&gt;
&lt;p&gt;3）点击登录，无任何反映（没有提示也没有跳转）&lt;/p&gt;
&lt;p&gt;从页面交互看，输入账号，点击登录要么登录成功进入系统，跳转到系统其他页面，要么登录失败给出错误提示，而现在没有任何反应，这肯定是一个bug，但是这个bug到底是属于前端bug还是后端，我们无从而知，但是我们可以顺手打开浏览器调试器来分析定位一下。&lt;/p&gt;
&lt;p&gt;打开控制台，我们看到了控制台并没有js错误，但是有向后台发起一个请求，此时还无法有效定位到问题到底发生在前端还是后端，但是可以截个图，写上自己的测试过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101224828451-1954878389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为了进一步定位，可以打开“网络”标签：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101225101991-2136921111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定论：这个404 not found请求路径找不到的问题，可能是前端后台开发人员改了接口地址，也有可能是前端js发起登录请求是接口地址写错了，所以这个bug可以题给前端开发，也可以提给后端。只要提供了上面分析截图，开发人员也能秒改这个bug。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232802058-2053966791.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三个小案例&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）访问：http://39.108.136.60:8380/ningmengban/app/login/login.html&lt;/p&gt;
&lt;p&gt;2）输入登录账号(用户名 / 密码)：304034318@qq.com / 123456&lt;/p&gt;
&lt;p&gt;3）点击登录，无任何反映（没有提示也没有跳转）&lt;/p&gt;
&lt;p&gt;从页面交互看，输入账号，点击登录要么登录成功进入系统，跳转到系统其他页面，要么登录失败给出错误提示，而现在没有任何反应，这肯定是一个bug，但是这个bug到底是属于前端bug还是后端，我们无从而知，但是我们可以顺手打开浏览器调试器来分析定位一下。&lt;/p&gt;
&lt;p&gt;打开控制台，我们看到了控制台并没有js错误，但是有向后台发起一个请求，同样，此时还无法有效定位到问题到底发生在前端还是后端，但是可以截个图，写上自己的测试过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101224828451-1954878389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 继续打开“网络”标签，我们看到这个底下有一个500请求，根据请求中的关键字眼login我们断定这个就是登录接口，而500则说明是后端服务器内部异常，一般是由于后台代码执行中报错导致的，所以截图写上我们的分析，到时候提bug附上这个截图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101230330780-191835725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 定论：根据请求返回的状态码500，我们就能断定这个bug是后台代码执行时候报错导致的，提bug带上上面的这个信息，开发人员就知道要去检查登录接口的代码了，因此缩小了开发定位问题的范围，保证了开发能在第一时间快速fix掉bug。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232536677-144185844.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;好了，给大家演示了三个小案例，教大家在碰到bug时，如何顺手借助浏览器调试器定位到bug到底来自于前端还是后端，当然我建议大家平时多关注一下http请求的响应状态码，对于常见的http code，比如200、302、404、500这些最好都去了解下，这样结合了我们的工具，在定位分析问题的时候，我们会更坚定和自信。&lt;/p&gt;
&lt;p&gt;小工具，但是很实用，这个技能大家get到了么。希望大家在工作当中能够应用起来。用的多了就自然熟练了。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1416840/201811/1416840-20181101232552822-2037034425.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 15:29:00 +0000</pubDate>
<dc:creator>韬哥（NickJiang）</dc:creator>
<og:description>做测试的小伙伴可能用过httpwatch，firebug，fiddler，charles等抓包（数据包）工具，但实际上除了这些还有一个简单实用并的抓包工具，那就是浏览器的F12调试器。 httpwat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nickjiang/p/9893278.html</dc:identifier>
</item>
<item>
<title>记录一则expdp任务异常处理案例 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9893302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9893302.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;AIX 6.1 + Oracle 10.2.0.4&lt;br/&gt;&lt;strong&gt;现象：&lt;/strong&gt;在XTTS迁移测试阶段，遇到执行几个expdp的导出任务，迟迟没有返回任何信息，对应日志无任何输出，查看任务状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; 
set lines 300
col OWNER_NAME for a10
col OPERATION for a15
col JOB_MODE for a20
col STATE for a15
select * from dba_datapump_jobs; 

OWNER_NAME JOB_NAME                       OPERATION       JOB_MODE             STATE               DEGREE ATTACHED_SESSIONS DATAPUMP_SESSIONS
---------- ------------------------------ --------------- -------------------- --------------- ---------- ----------------- -----------------
SYS        SYS_EXPORT_TRANSPORTABLE_01    EXPORT          TRANSPORTABLE        DEFINING                 1                 0                 1
SYS        SYS_EXPORT_TRANSPORTABLE_02    EXPORT          TRANSPORTABLE        DEFINING                 1                 1                 2
SYS        SYS_EXPORT_TRANSPORTABLE_03    EXPORT          TRANSPORTABLE        DEFINING                 1                 1                 2
SYS        SYS_EXPORT_SCHEMA_01           EXPORT          SCHEMA               DEFINING                 1                 1                 2
SYS        SYS_EXPORT_TRANSPORTABLE_04    EXPORT          TRANSPORTABLE        DEFINING                 1                 1                 2
SYS        SYS_EXPORT_SCHEMA_02           EXPORT          SCHEMA               DEFINING                 1                 1                 2

6 rows selected.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到所有的expdp导出任务的STATE都停留在DEFINING状态。&lt;/p&gt;

&lt;p&gt;先强制杀掉后台执行的所有expdp任务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ps -ef|grep expdp|grep -v grep|awk '{print $2}'|xargs kill -9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后尝试删除这些表（其实应该在not running状态下删除）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select 'drop table '||OWNER_NAME||'.'||JOB_NAME||' purge;' from dba_datapump_jobs where STATE='NOT RUNNING';

drop table sys.SYS_EXPORT_TRANSPORTABLE_01 purge;
..&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可这样是没有作用的，查询结果不变。&lt;br/&gt;甚至尝试正常shutdown immediate停止数据库，也无法成功，告警日志看到有活动调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thu Nov  1 15:14:24 2018
Active call for process 4522064 user 'oracle' program 'oracle@localhost (DM00)'
Active call for process 4456536 user 'oracle' program 'oracle@localhost (DM01)'
Active call for process 10027180 user 'oracle' program 'oracle@localhost (DM02)'
Active call for process 7340140 user 'oracle' program 'oracle@localhost (DM03)'
Active call for process 6291888 user 'oracle' program 'oracle@localhost (DM04)'
Active call for process 8126596 user 'oracle' program 'oracle@localhost (DM05)'
SHUTDOWN: waiting for active calls to complete.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现这些进程的id都对应了ora_dm的进程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ps -ef|grep ora_dm
  oracle  4456536        1   0 17:00:09      -  0:00 ora_dm01_xxxxdb
  oracle  4522064        1   0 16:50:57      -  0:00 ora_dm00_xxxxdb
  oracle  7340140        1   0 14:06:07      -  0:00 ora_dm03_xxxxdb
  oracle  8126596        1   0 14:35:03      -  0:00 ora_dm05_xxxxdb
  oracle 10027180        1   0 13:55:08      -  0:00 ora_dm02_xxxxdb
  oracle  6291888        1   0 14:31:17      -  0:00 ora_dm04_xxxxdb
  oracle  7340432  8388786   0 15:22:59  pts/4  0:00 grep ora_dm&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，这就是expdp任务的相关进程，强制杀掉这些进程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ps -ef|grep ora_dm|grep -v grep|awk '{print $2}'|xargs kill -9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后数据库关闭成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thu Nov  1 15:24:37 2018
All dispatchers and shared servers shutdown
Thu Nov  1 15:24:37 2018
ALTER DATABASE CLOSE NORMAL&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动数据库后，再次查询发现已经成功清理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; 
set lines 300
col OWNER_NAME for a10
col OPERATION for a15
col JOB_MODE for a20
col STATE for a15
select * from dba_datapump_jobs; 

no rows selected&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;数据泵任务与ora_dm进程相关；如果数据泵任务发生异常，但任务并没有退出的情况，需要同时杀掉这类进程（杀掉后状态就会变为NOT RUNNING）。关库不是必须的，只是演示此时正常关闭被阻塞的场景。这也能说明为什么要保证在NOT RUNNING状态下才可以清理。&lt;/p&gt;

&lt;p&gt;上面的步骤只是清理了异常的数据泵任务，但没有解决问题，再次后台执行备份任务依然会重现故障：&lt;br/&gt;nohup sh expdp_xtts.sh &amp;amp;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ps -ef|grep expdp
  oracle  6684914  8061208   0 15:30:07  pts/2  0:00 grep expdp
  oracle  7143482  8061208   0 15:30:03  pts/2  0:00 sh expdp_xtts.sh
  oracle  6685096  7143482   0 15:30:03  pts/2  0:00 expdp '/ as sysdba' parfile=expdp_xtts.par
$ ps -ef|grep ora_dm
  oracle  7602308  8061208   0 15:30:10  pts/2  0:00 grep ora_dm
  oracle  3997964        1   1 15:30:05      -  0:00 ora_dm00_xxxxdb
$ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时查询dba_datapump_jobs,state依然一直是defining状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;OWNER_NAME JOB_NAME                       OPERATION       JOB_MODE                       STATE                              DEGREE ATTACHED_SESSIONS DATAPUMP_SESSIONS
---------- ------------------------------ --------------- ------------------------------ ------------------------------ ---------- ----------------- -----------------
SYS        SYS_EXPORT_TRANSPORTABLE_01    EXPORT          TRANSPORTABLE                  DEFINING                                1                 1                 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他的导出任务都一样，不再赘述。&lt;br/&gt;为了方便测试，写一个简单的单表expdp导出，现象也一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;expdp \'/ as sysdba\' directory=XTTS tables=query.test dumpfile=query_test.dmp logfile=query_test.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据故障现象，用如下关键字在MOS中搜索: expdp state DEFINING，匹配到文档：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DataPump Export/Import Hangs With &quot;DEFINING&quot; Status When Using A Directory On NFS Filesystem (文档 ID 2262196.1)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正好这次测试是在NFS文件系统上，MOS建议移动到本地文件系统导出。&lt;/p&gt;
&lt;p&gt;这次再将expdp进程全部杀掉：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ps -ef|grep ora_dm|grep -v grep|awk '{print $2}'|xargs kill -9
ps -ef|grep expdp|grep -v grep|awk '{print $2}'|xargs kill -9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时查询dba_datapump_jobs：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;OWNER_NAME JOB_NAME                       OPERATION       JOB_MODE                       STATE               DEGREE ATTACHED_SESSIONS DATAPUMP_SESSIONS
---------- ------------------------------ --------------- ------------------------------ --------------- ---------- ----------------- -----------------
SYS        SYS_EXPORT_TABLE_04            EXPORT          TABLE                          NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_SCHEMA_01           EXPORT          SCHEMA                         NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_TABLE_02            EXPORT          TABLE                          NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_TABLE_05            EXPORT          TABLE                          NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_TABLE_03            EXPORT          TABLE                          NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_TABLE_01            EXPORT          TABLE                          NOT RUNNING              0                 0                 0
SYS        SYS_EXPORT_TRANSPORTABLE_01    EXPORT          TRANSPORTABLE                  NOT RUNNING              0                 0                 0

7 rows selected.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清理NOT RUNNING的master表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select 'drop table '||OWNER_NAME||'.'||JOB_NAME||' purge;' from dba_datapump_jobs where STATE='NOT RUNNING';
--执行结果用来执行，再次查看结果为空：
SQL&amp;gt; select * from dba_datapump_jobs;
no rows selected&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按MOS建议，将导出任务移动到本地文件系统：&lt;br/&gt;AIX源端导出XTTS源数据至源端/hxbak/xtts_exp目录中，而后copy至nfs共享存储/xtts/dmp中:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /hxbak/xtts_exp
chown oracle:dba /hxbak/xtts_exp
ls -ld /hxbak/xtts_exp

select * from dba_directories;
create or replace directory XTTS as '/hxbak/xtts_exp';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时测试expdp任务可正常运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ expdp \'/ as sysdba\' directory=XTTS tables=query.test dumpfile=query_test.dmp logfile=query_test.log
Export: Release 10.2.0.4.0 - 64bit Production on Thursday, 01 November, 2018 16:03:21

Copyright (c) 2003, 2007, Oracle.  All rights reserved.

Connected to: Oracle Database 10g Enterprise Edition Release 10.2.0.4.0 - 64bit Production
With the Partitioning, OLAP, Data Mining and Real Application Testing options
Starting &quot;SYS&quot;.&quot;SYS_EXPORT_TABLE_01&quot;:  '/******** AS SYSDBA' directory=XTTS tables=query.test dumpfile=query_test.dmp logfile=query_test.log 
Estimate in progress using BLOCKS method...
Processing object type TABLE_EXPORT/TABLE/TABLE_DATA
Total estimation using BLOCKS method: 8 MB
Processing object type TABLE_EXPORT/TABLE/TABLE
Processing object type TABLE_EXPORT/TABLE/STATISTICS/TABLE_STATISTICS
. . exported &quot;QUERY&quot;.&quot;TEST&quot;                              6.743 MB   72593 rows
Master table &quot;SYS&quot;.&quot;SYS_EXPORT_TABLE_01&quot; successfully loaded/unloaded
******************************************************************************
Dump file set for SYS.SYS_EXPORT_TABLE_01 is:
  /hxbak/xtts_exp/query_test.dmp
Job &quot;SYS&quot;.&quot;SYS_EXPORT_TABLE_01&quot; successfully completed at 16:03:57

SQL&amp;gt; select * from dba_datapump_jobs;

OWNER_NAME JOB_NAME                       OPERATION       JOB_MODE                       STATE               DEGREE ATTACHED_SESSIONS DATAPUMP_SESSIONS
---------- ------------------------------ --------------- ------------------------------ --------------- ---------- ----------------- -----------------
SYS        SYS_EXPORT_TABLE_01            EXPORT          TABLE                          EXECUTING                1                 1                 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次导出其他元数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#expdp_xtts.sh (about 5min)
nohup sh expdp_xtts.sh &amp;amp;
#expdp_xtts_other.sh(about 5min)
nohup sh expdp_xtts_other.sh &amp;amp;
#expdp_tmp_table
nohup sh expdp_tmp_table01.sh &amp;amp;
nohup sh expdp_tmp_table02.sh &amp;amp;
nohup sh expdp_tmp_table03.sh &amp;amp;
nohup sh expdp_tmp_table04.sh &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后将这些导出文件再移动到/xtts/dmp/下，供后续xtts测试目标端导入使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ pwd
/hxbak/xtts_exp
$ cp -rp * /xtts/dmp/ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目标端导入时只需要有读这些文件的权限，即可，实际测试恢复OK。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt;在自己的linux环境测试过是可以直接expdp到nfs文件系统的，AIX看来有区别，MOS的建议也只是一个workaround，但也能满足需求，毕竟元数据导出文件没多大。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 15:20:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>环境： AIX 6.1 + Oracle 10.2.0.4 现象： 在XTTS迁移测试阶段，遇到执行几个expdp的导出任务，迟迟没有返回任何信息，对应日志无任何输出，查看任务状态： 可以看到所有的e</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9893302.html</dc:identifier>
</item>
<item>
<title>见习三月有感 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/9893073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/9893073.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/417688/201811/417688-20181101223157905-838326513.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;七月中旬回来到现在已经见习了三个多月，上塔台也就个把月的时间，这段时间就像是一个瓶颈期，目前的状态自己还不够满意，师傅们也不满意。机场管制和程序员是截然不同的两个职业，程序员时间安排非常自由，只要任务按时完成，摸摸鱼很常见。管制员拿着话筒精力就要非常集中，这种集中不是关注一个点，而是关注飞机安全的方方面面，关注天上飞机的间隔、速度，关注地上跑道、航空器的滑行情况，关注天气，关注设备是否正常，以及如何处理接下来要面临的一波高峰，是否已经做好预案，等等。虽然行业相差大，但很多东西也是相通的。&lt;/p&gt;
&lt;h3&gt;心法与剑术&lt;/h3&gt;
&lt;p&gt;自己目前的状态就是发指令口误还比较多，预案做的不好，一些基本的指令还会发错，面对大流量还不能应对自如，甚至有些捉襟见肘。有时候你明明努力过，但结果就是没有到达预期。只能说是努力的还不够，说别的都是苍白。而师傅们觉得我们三个还没有入门，最主要的一点是安全意识不够。比如说着话就忘记了正在落地的飞机，比如给了飞机滑行指令却没有盯着它怎么滑过去的。机长也有走神的时候，可能他一不小心就从中间进了跑道，或者未经允许就进了跑道，这个在我见习的时候就遇到过，如果有飞机正在落地，这将可能造成飞机复飞，后果就比较严重。“安全”，是民航的生命线，安全意识就是每个管制员的心法，你指挥飞机技术再高超，同时能指挥给十几架飞机，但如果安全意识不到位造成严重事件，不单可能对别人的人生财产安全造成很大损失，自己的职业生涯基本上就报销了。现在民航局对人为造成重大差错处罚也比较大，起步就是停职6个月，再加罚款，这个代价是很大的。所以心法第一，剑术第二，没有心法，只练剑术可能会走火入魔。&lt;/p&gt;
&lt;p&gt;而程序员生涯里面很少有人会给你强调这方面，更多的是追求技术的方面提高，效率的提高。诸如像代码整洁，安全生产方面讲的比较少。我想这可能也是犯错成本决定的情况，犯错成本低，出出错无所谓，发布出了问题，再退回，大不了再熬一晚。程序员造bug，改bug是常态。但其实如果强调好心法，降低出错率可能会节省很多时间精力。&lt;/p&gt;
&lt;h3&gt;师徒传承&lt;/h3&gt;
&lt;p&gt; 管制行业是一个很需要经验的行业，天上风云变幻，什么情况都有，经验就是资本，师徒的传承就很重要，新人上去，只会一些基本的指令，一些还是死的知识，非常需要师傅指点，才能慢慢的灵活起来。见习这么久，很感谢每位师傅对我的纠错和培养习惯，虽然有指定的师傅，但每位“前辈”给我的感觉都很好，没有放任不顾，没有揶揄，该说该骂都很直接。其实我比好几位师傅年纪都要大一两岁，但入行早就是前辈。我的指定师傅俗称“炮哥”，是江苏人在张家界干了十几年管制，为人豪爽耿直，喜欢古典文学，对我也苦口婆心的说了很多次了。说实话这个师徒氛围真的很好，让我想起我刚开始做程序员时，那个师傅就丢给我一本书《C#入门经典》，再没怎么管我，期间我曾找他问问题，他说“你这都不会啊”，从此我再也没有问过他问题，就靠看书和自学。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/417688/201811/417688-20181101223433178-1868967892.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员自学门槛低，网上报个班学几个月也能出来写两年工作经验应聘工作，师徒关系比较淡化，彼此还有竞争关系遮遮掩掩的。一方面我觉得作为徒弟自己要感恩，一方面遇到好的师傅确实会让你少走很多弯路。程序虽然可以自学，其实很多行业经验也是很重要的，不懂行业如何写的出行业间应用的好程序，所以我觉得做好师徒传承是对企业有裨益的。对师傅个人而言，如果你觉得分享知识分享经验亏了，建议还是不要带徒弟了，免得误人子弟。作为徒弟要努力做到“青出于蓝而胜于蓝，冰水为之而寒于水”。新人就是做加法，不断的积累，专业知识、行业相关都要积累。曾经有个师傅问我，你知道飞机襟翼有几片，飞机落地构型有几种？我当时有些语塞，感到很惭愧。因为在张家界就发生过飞机襟翼打开有问题的特情。专业知识的积累在关键的时候就能体现一个人的职业素养。&lt;/p&gt;
&lt;h3&gt;职业规划&lt;/h3&gt;
&lt;p&gt; 在一次培训会上一位经理说，大家是想做好一名优秀的管制员呢还是要做推进民航业改革的人才，对自己有什么样的职业规划？这让我陷入了思考，虽然我属于转行过来的，但现在还是很适当前的工作和氛围，未来也很有可能把管制员作为一生的职业，为什么没有更高的目标？眼下是还有很多不足，还苟且着，每天打扫卫生，给师傅带饭，挨训，回头再复习，提醒自己注意，又顾此失彼，如此反复。但未来并不只是眼前一亩三分地，当初带着养家糊口的心态踏进这个行业，现在看来这样的心态是很不对的，这不是一个摸鱼敲钟的位置，要么优秀要么滚蛋，安全面前没有儿戏。总经理也对我说，“人要出彩，只靠基本工作是很难的”，可能我自己六年的程序员是一个点，这方面还要多想想。&lt;/p&gt;
&lt;p&gt;感觉上民航对信息化的推进比较慢，不如高铁系统，一方面旅客候机要检查、等待很长的时间，一方面内部的一些工作其实可以自动化的，很多是完全没有多大意义的重复，可能是在企业和人员的承受压力之内，就没有去做优化。&lt;/p&gt;
&lt;h3&gt;健康&lt;/h3&gt;
&lt;p&gt;管制是一个需要熬夜的岗位，旺季的时候航班一两点结束，早上五点多起来准备六点多的飞机，是比较伤身的。这个比程序员工作熬夜还要频繁，基本上大家都很注意健身，男生尝尝打篮球，游泳，加上上岗之前8小时不准饮酒，大家都比较注意。程序员主要是自己喜欢搞到十二点之后才睡觉，下班之后也很少呼朋引伴的去搞个球，吃饭也是天天外卖。身体是革命的本钱，没有好身体，再好的工作也是枉然。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/417688/201811/417688-20181101223518656-917256586.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;叨了这么多，谢谢观看，诸君有空可以到张家界来玩 ~ ~&lt;/p&gt;

</description>
<pubDate>Thu, 01 Nov 2018 14:37:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<og:description>七月中旬回来到现在已经见习了三个多月，上塔台也就个把月的时间，这段时间就像是一个瓶颈期，目前的状态自己还不够满意，师傅们也不满意。机场管制和程序员是截然不同的两个职业，程序员时间安排非常自由，只要任务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/9893073.html</dc:identifier>
</item>
<item>
<title>如果我是一线技术主管 - 谦行</title>
<link>http://www.cnblogs.com/dolphinX/p/9893056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dolphinX/p/9893056.html</guid>
<description>&lt;p&gt;如果我是一线技术主管，可能曾经是团队综合实力最强的，被时间支配不能再每天写代码，但团队各种挑战依旧在&lt;/p&gt;
&lt;p&gt;如果我是一线技术主管，每周也要写周报，每年也要写绩效，想晋升、加薪、人生巅峰云云&lt;/p&gt;
&lt;p&gt;如果我是一线技术主管，团队有五、六个人还好，十几个人的团队的话会希望有人可以站出来帮我&lt;/p&gt;
&lt;h2 id=&quot;不抱怨&quot;&gt;不抱怨&lt;/h2&gt;
&lt;p&gt;如果我是一线技术主管，我不会喜欢团队爱抱怨的同学&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我每天也很忙，听一个人抱怨会花时间&lt;/li&gt;
&lt;li&gt;一个人抱怨了，自然是有问题的，需要花一定的时间梳理出问题，需要及时给出解决方案，甚至要安抚对方情绪&lt;/li&gt;
&lt;li&gt;一个喜欢抱怨的人会影响整个团队的士气&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实大部分开发抱怨的工作内容很相似，无非是自己做的业务是一堆屎，谁谁谁就是不配合我做某事，PD 提了无理的需求&lt;/p&gt;
&lt;p&gt;大促中我们的后端主管说过句很好理解的话，看到大促这么多问题很激动，这很好，问题越多机会才越大，如果都是稳定健壮的系统、完善的流程、合作良好的团队，要大促 PM 干什么呢？&lt;/p&gt;
&lt;p&gt;如果是机会的话很多情况下没什么必要抱怨，那真的就是有问题还不能说了吗？&lt;/p&gt;
&lt;h2 id=&quot;向上管理&quot;&gt;向上管理&lt;/h2&gt;
&lt;p&gt;恰恰相反，如果我是一线主管，我会迫切希望团队有问题一定要说，甚至没有问题仅仅有想法也要说，但主要是反馈的方式&lt;/p&gt;
&lt;h3 id=&quot;高效&quot;&gt;高效&lt;/h3&gt;
&lt;p&gt;如果我是一线主管，我更希望团队和我交流的方式是让我做选择题、判断题，而不是问答题、思考题&lt;/p&gt;
&lt;h3 id=&quot;主动&quot;&gt;主动&lt;/h3&gt;
&lt;p&gt;一个十几人的团队主管很难有精力面面俱到，了解所有人每天的细节，给大家找出合适方向和机会，甚至认真读完每个人的周报都要用一个下午，很难做到你有一个不错想法的时候主管恰好找你聊聊，如果我是一线主管，我更希望团队同学主动找我聊&lt;/p&gt;
&lt;p&gt;废话这么多，其实看看向上管理的一些理论知识会有豁然开朗的感觉，抄一下知乎上&lt;a href=&quot;https://www.zhihu.com/question/39854128/answer/83504056&quot;&gt;很接地气的总结&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;作为领导他们既要有全局决策的能力，杰出的领导魅力，还要有大量一线数据、客户反馈、团队底层真实信息、行业趋势分析与总结。很多点不是他一个人能搞定的，除去那些工作上的support，有时候领导也会出现信息失察、决策失误的情况，所以向上管理的必要性就出现了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;及时定期&lt;/strong&gt;总结工作进展、数据、部门问题、行业关键信息，以清晰文档的方式递交上级，并同时附上下阶段计划及&lt;strong&gt;问题解决办法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;提身而出替上级解决困扰他已久的难题&lt;/li&gt;
&lt;li&gt;对于明显有错的重要决策，给出合理分析建议，反馈给领导&lt;/li&gt;
&lt;li&gt;以培训、分享、个人交流等不同方式，“教”领导一些东西&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;想顺便说一下高质量周报的必要性，很多同学的周报极其敷衍，就是一周的流水账，发送出来都是浪费自己和收件人的时间，团队不会有人&lt;strong&gt;认真&lt;/strong&gt;读完所有人的周报，取决于周报的质量&lt;/p&gt;
&lt;p&gt;个人习惯粗略浏览组内所有人周报（周报有 highlishts 多重要），然后会针对有些人的周报设置规则，必须认真看，遇到不理解的还要过去问，高质量的周报你不主动，主管都会主动&lt;/p&gt;
&lt;h2 id=&quot;每天忙不完的业务怎么办&quot;&gt;每天忙不完的业务怎么办&lt;/h2&gt;
&lt;p&gt;还有一种抱怨的声音是：自己每天很辛苦，想拼命忙完业务后做一些技术的东西，造个轮子什么的，但一个需求还没做完，另外一个需求就安排过来了&lt;/p&gt;
&lt;p&gt;如果我是一线主管，我会把团队面临的问题分一下级&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;重要&amp;amp;紧急，不能按时完成都是失败&lt;/li&gt;
&lt;li&gt;重要不紧急，是个很好的机会&lt;/li&gt;
&lt;li&gt;技术想法，很好撬动业务的点&lt;/li&gt;
&lt;li&gt;简单分析只是业务需求&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;团队的人可能也有几种特性&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;能力强，在某领域是专家&lt;/li&gt;
&lt;li&gt;能力一般，有潜力，但是非常有积极性&lt;/li&gt;
&lt;li&gt;能力一般，主动性一般&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实不用意义说明就知道大部分主管分配任务的思路&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;重要&amp;amp;紧急的事情只能交给能力强的认去做，意愿有问题也要说服去做，因人成事，能力强多重要&lt;/li&gt;
&lt;li&gt;重要不紧急的事情就可以借事修人，如果做得好这个人以后就有信心了，团队多了一员干将，做不好也有能力强的人给保底，不会造成业务问题&lt;/li&gt;
&lt;li&gt;技术想法也可以交给有积极性的人做，那么必然占用一些时间，那么这个人手头上无关痛痒的事情只好交给。。。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;实际上按照向上管理的思路，需要主管去分配任务的时候，就已经输了，甚至主管来找你问进度的时候也已经输了&lt;/p&gt;
&lt;p&gt;当然每个合格的主管都需要发现、解决团队人才培养的问题，不可能放任问题发生&lt;/p&gt;
&lt;h3 id=&quot;什么样的人有积极性&quot;&gt;什么样的人有积极性&lt;/h3&gt;
&lt;p&gt;能力强的人很好识别，那什么样的人才是有积极性的，看过一个 AE 快速升 P8 的同学写的文章，他有个很好的习惯&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;无论大小难易，永远不满足于做出来指定的事情，一定要给人惊喜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果我是一线主管，我不会凭空把一件重要的事情就给某个人去做，我会更期望&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;团队同学来教育我某件事情很重要，想去尝试&lt;/li&gt;
&lt;li&gt;在很多微不足道小事情上做出了惊喜，有理由相信这件更大的事情也可能做出惊喜&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;我被分配了纯业务事情怎么办&quot;&gt;我被分配了纯业务事情怎么办&lt;/h3&gt;
&lt;p&gt;上面也提到了&lt;code&gt;简单分析只是业务需求&lt;/code&gt;，简单分析，简单分析，简单分析，在阿里将近五年见了太多事在人为的案例，每个人身边肯定也有不少这样的案例&lt;/p&gt;
&lt;p&gt;我们以为自己在做业务，很多时候是因为两个误区&lt;/p&gt;
&lt;h4 id=&quot;这不是技术项目&quot;&gt;这不是技术项目&lt;/h4&gt;
&lt;p&gt;没有什么所谓的技术项目，所有的技术项目除非显而易见，否则肯定脱胎于业务，只有业务一线的同学才可以抽象出来，做业务需求不是坏事情，拿着完成任务的心态做业务才是最要命的&lt;/p&gt;
&lt;h4 id=&quot;没目标&quot;&gt;没目标&lt;/h4&gt;
&lt;p&gt;所有做的事情都要契合自己的目标，而自己的目标大部分时候应该和团队目标 match，今天让我开发一个前端组件，我要看到的是这个需求反应了我营销体系对某个分类能力的缺失，需求归纳到我营销可视化体系完善的目标中，在阿里这种人才济济的环境中目标不清晰的人和咸鱼没什么区别&lt;/p&gt;
&lt;h3 id=&quot;怎样才算业务负责人&quot;&gt;怎样才算业务负责人&lt;/h3&gt;
&lt;p&gt;很多小伙伴已经是实际的业务负责人，和三、四个小伙伴一块解决特定业务领域问题，但尴尬的是级别相同，在分配任务的时候会不好意思，觉得对方也有自己的&quot;技术项目&quot;要做，我得求他把这个业务需求做一下&lt;/p&gt;
&lt;p&gt;这种其实不算真正的业务负责人，如果业务负责人仅仅是分配任务，那么任何人辛苦一些都可以做。业务负责人的核心特质应该有一条是了解业务的发展、引导相关人个人目标&lt;/p&gt;
&lt;p&gt;这样可以把业务需求转换成每个人目标中的一环，和上面提到的自己做事情思路是一样的，无非写代码的那个人不自己。 其实即使主管也不可能命令团队成员去做某事，那样团队早晚散伙&lt;/p&gt;
&lt;p&gt;如果我是一线技术主管，我希望团队的业务负责人时刻在两个方面提醒自己&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可衡量&lt;/li&gt;
&lt;li&gt;体系化&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 01 Nov 2018 14:31:00 +0000</pubDate>
<dc:creator>谦行</dc:creator>
<og:description>如果我是一线技术主管，可能曾经是团队综合实力最强的，被时间支配不能再每天写代码，但团队各种挑战依旧在 如果我是一线技术主管，每周也要写周报，每年也要写绩效，想晋升、加薪、人生巅峰云云 如果我是一线技术</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dolphinX/p/9893056.html</dc:identifier>
</item>
<item>
<title>分布式系统监视zabbix讲解一技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9892708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9892708.html</guid>
<description>
&lt;h3 id=&quot;zabbix是什么&quot; class=&quot;sectionedit1&quot;&gt;Zabbix是什么&lt;/h3&gt;
&lt;p&gt;Zabbix 是由Alexei Vladishev创建，目前由Zabbix SIA在持续开发和支持。&lt;/p&gt;
&lt;p&gt;Zabbix 是一个企业级的分布式开源监控方案。&lt;/p&gt;
&lt;p&gt;Zabbix是一款能够监控各种网络参数以及服务器健康性和完整性的软件。Zabbix使用灵活的通知机制，允许用户为几乎任何事件配置基于邮件的告警。这样可以快速反馈服务器的问题。基于已存储的数据，Zabbix提供了出色的报告和数据可视化功能。这些功能使得Zabbix成为容量规划的理想方案。&lt;/p&gt;
&lt;p&gt;Zabbix支持主动轮询和被动捕获。Zabbix所有的报告、统计信息和配置参数都可以通过基于Web的前端页面进行访问。基于Web的前端页面可以确保您从任何方面评估您的网络状态和服务器的健康性。适当的配置后，Zabbix可以在IT基础架构监控方面扮演重要的角色。对于只有少量服务器的小型组织和拥有大量服务器的大型公司也同样如此。&lt;/p&gt;
&lt;p&gt;Zabbix是免费的。Zabbix是根据GPL通用公共许可证第2版编写和发行的。这意味着它的源代码都是免费发行的，可供公众任意使用。&lt;/p&gt;



&lt;div class=&quot;level4&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;在本节中，你可以了解一些Zabbix常用术语的含义。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;level4&quot; readability=&quot;62&quot;&gt;
&lt;p&gt;&lt;strong&gt;主机 (host)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一台你想监控的网络设备，用IP或域名表示&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主机组 (host group)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 主机的逻辑组；它包含主机和模板。一个主机组里的主机和模板之间并没有任何直接的关联。通常在给不同用户组的主机分配权限时候使用主机组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;监控项 (item)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 你想要接收的主机的特定数据，一个度量数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;触发器 (trigger)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个被用于定义问题阈值和“评估”监控项接收到的数据的逻辑表达式&lt;/p&gt;
&lt;p&gt;当接收到的数据高于阈值时，触发器从“OK”变成“Problem”状态。当接收到的数据低于阈值时，触发器保留/返回一个“OK”的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事件 (event)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 单次发生的需要注意的事情，例如触发器状态改变或发现有监控代理自动注册&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常 (problem)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个处在“异常”状态的触发器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动作 (action)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个对事件做出反应的预定义的操作。&lt;/p&gt;
&lt;p&gt;一个动作由操作(例如发出通知)和条件(当时操作正在发生)组成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;升级 (escalation)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个在动作内执行操作的自定义场景; 发送通知/执行远程命令的序列&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;媒介 (media)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 发送告警通知的手段；告警通知的途径&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通知 (notification)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 利用已选择的媒体途径把跟事件相关的信息发送给用户&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;远程命令 (remote command)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个预定义好的，满足一些条件的情况下，可以在被监控主机上自动执行的命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模版 (template)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一组可以被应用到一个或多个主机上的实体（监控项，触发器，图形，聚合图形，应用，LLD，Web场景）的集合&lt;/p&gt;
&lt;p&gt;模版的任务就是加快对主机监控任务的实施；也可以使监控任务的批量修改更简单。模版是直接关联到每台单独的主机上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用 (application)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一组监控项组成的逻辑分组&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;web 场景 (web scenario)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 利用一个或多个HTTP请求来检查网站的可用性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前端 (frontend)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- Zabbix提供的web界面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zabbix API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- Zabbix API允许你使用JSON RPC协议来创建、更新和获取Zabbix对象（如主机、监控项、图形和其他）信息或者执行任何其他的自定义的任务&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zabbix server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- Zabbix软件实现监控的核心程序，主要功能是与Zabbix proxies和Agents进行交互、触发器计算、发送告警通知；并将数据集中保存等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zabbix agent&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个部署在监控对象上的，能够主动监控本地资源和应用的程序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zabbix proxy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- 一个帮助Zabbix Server收集数据，分担Zabbix Server的负载的程序&lt;/p&gt;



&lt;h3&gt;1.安装源码库配置部署包&lt;/h3&gt;
&lt;div class=&quot;level4&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;安装源码库配置部署包。这个部署包包含了yum配置文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# rpm -ivh http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-1.el7.noarch.rpm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;安装zabbix部署包&quot; class=&quot;sectionedit6&quot;&gt;2.安装Zabbix部署包&lt;/h3&gt;
&lt;div class=&quot;level4&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;安装Zabbix部署包。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install zabbix-server-mysql zabbix-web-mysql -y
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.安装Zabbix Agent&lt;/h3&gt;
&lt;p&gt;agent客户端，你想要监控那台服务器就安装这个软件并启动，我这里演示就和服务器端安装在了一起，即服务器端自己监控自己。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install zabbix-agent -y
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;4.安装初始化数据库&lt;/h3&gt;
&lt;div class=&quot;level4&quot; readability=&quot;77&quot;&gt;
&lt;p&gt;在MySQL上安装Zabbix数据库和用户。在安装完zabbix-server-mysql已经自带了这个压缩包。&lt;/p&gt;
&lt;p&gt;只要解压，然后导入初始架构（Schema）和数据即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# rpm -ql zabbix-server-&lt;span&gt;mysql
&lt;/span&gt;/etc/logrotate.d/zabbix-&lt;span&gt;server
&lt;/span&gt;/etc/zabbix/&lt;span&gt;zabbix_server.conf
&lt;/span&gt;/usr/lib/systemd/system/zabbix-&lt;span&gt;server.service
&lt;/span&gt;/usr/lib/tmpfiles.d/zabbix-&lt;span&gt;server.conf
&lt;/span&gt;/usr/lib/zabbix/&lt;span&gt;alertscripts
&lt;/span&gt;/usr/lib/zabbix/&lt;span&gt;externalscripts
&lt;/span&gt;/usr/sbin/&lt;span&gt;zabbix_server_mysql
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;
/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;AUTHORS
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;COPYING
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;ChangeLog
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;NEWS
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;README
&lt;/span&gt;/usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/&lt;span&gt;create.sql.gz  ##解压这个yasuobao
&lt;/span&gt;/usr/share/man/man8/zabbix_server.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.gz
&lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/&lt;span&gt;zabbix
&lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/run/zabbix
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;复制到家目录下，解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# cp /usr/share/doc/zabbix-server-mysql-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;22&lt;/span&gt;/create.sql.gz ./&lt;span&gt;
[root@ken &lt;/span&gt;~&lt;span&gt;]# ls
anaconda&lt;/span&gt;-ks.cfg  create.sql.gz  ks-pre.log  original-&lt;span&gt;ks.cfg
[root@ken &lt;/span&gt;~]# gunzip create.sql.gz 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导入到数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
root@localhost:mysql3306.sock [zabbix]&amp;gt;&lt;span&gt;create database zabbix;
root@localhost:mysql3306.sock [zabbix]&lt;/span&gt;&amp;gt;&lt;span&gt;use zabbix;
root@localhost:mysql3306.sock [zabbix]&lt;/span&gt;&amp;gt;source /root/&lt;span&gt;create.sql
root@localhost:mysql3306.sock [zabbix]&lt;/span&gt;&amp;gt;grant all on *.* to zabbix@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; identified by &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
root@localhost:mysql3306.sock [zabbix]&lt;/span&gt;&amp;gt;flush privileges;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5.启动apache服务&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl restart httpd
[root@ken &lt;/span&gt;~]# ss -tnl | grep &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;         :::&lt;span&gt;80&lt;/span&gt;                      :::*      
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;6.通过浏览访问zabbix&lt;/h3&gt;
&lt;p&gt;输入ip/zabbix即可访问，访问前务必先关闭selinux以及防火墙&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# systemctl stop firewalld
[root@ken &lt;/span&gt;~]# setenforce &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101210803375-274602202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101210853330-1379257722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里报了时区的错误，需要修改一下配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/httpd/conf.d/&lt;span&gt;zabbix.conf
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; #
  &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; # Zabbix monitoring system php web frontend
  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt; #
  &lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
  &lt;span&gt;5&lt;/span&gt; Alias /zabbix /usr/share/&lt;span&gt;zabbix
  &lt;/span&gt;&lt;span&gt;6&lt;/span&gt; 
  &lt;span&gt;7&lt;/span&gt; &amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/share/zabbix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &lt;span&gt;8&lt;/span&gt;&lt;span&gt;     Options FollowSymLinks
  &lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;     AllowOverride None
 &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;     Require all granted
 &lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
 &lt;span&gt;12&lt;/span&gt;     &amp;lt;IfModule mod_php5.c&amp;gt;
 &lt;span&gt;13&lt;/span&gt;         php_value max_execution_time &lt;span&gt;300&lt;/span&gt;
 &lt;span&gt;14&lt;/span&gt;&lt;span&gt;         php_value memory_limit 128M
 &lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;         php_value post_max_size 16M
 &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;         php_value upload_max_filesize 2M
 &lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         php_value max_input_time &lt;span&gt;300&lt;/span&gt;
 &lt;span&gt;18&lt;/span&gt;         php_value max_input_vars &lt;span&gt;10000&lt;/span&gt;
 &lt;span&gt;19&lt;/span&gt;         php_value always_populate_raw_post_data -&lt;span&gt;1&lt;/span&gt;
 &lt;span&gt;20&lt;/span&gt;         php_value date.timezone Asia/&lt;span&gt;Shanghai   ##时区修改为亚洲/上海
 &lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &amp;lt;/IfModule&amp;gt;
 &lt;span&gt;22&lt;/span&gt; &amp;lt;/Directory&amp;gt;
 &lt;span&gt;23&lt;/span&gt; 
 &lt;span&gt;24&lt;/span&gt; &amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/share/zabbix/conf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
 &lt;span&gt;25&lt;/span&gt;&lt;span&gt;     Require all denied
 &lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &amp;lt;/Directory&amp;gt;
 &lt;span&gt;27&lt;/span&gt; 
 &lt;span&gt;28&lt;/span&gt; &amp;lt;Directory &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/usr/share/zabbix/app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
 &lt;span&gt;29&lt;/span&gt;&lt;span&gt;     Require all denied
...
[root@ken &lt;/span&gt;~]# systemctl restart httpd  ##重启APACHE服务
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次刷新页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101211209515-998591149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确认无误之后，点击下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101211254626-163921706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入刚才创建的数据库zabbix，以及创建的用户zabbix及密码，然后点击下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101211403364-1168058030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里又报了一个无法通过sock文件，连接到数据库的错误。&lt;/p&gt;
&lt;p&gt;这里补充一下造成这个错误的原因主要有如下几点：&lt;/p&gt;
&lt;p&gt;1.防火墙，selinux没有关&lt;/p&gt;
&lt;p&gt;2.配置文件的sock文件没有在/var/lib/mysql/下&lt;/p&gt;
&lt;p&gt;3.对于/var/lib/mysql/，没有权限读取，需要修改为chown -R mysql.mysql /var/lib/mysql&lt;/p&gt;
&lt;p&gt;4.zabbix用户授权错误，是查看是授予的localhost权限还是%权限，即可以在哪个主机上面登录&lt;/p&gt;
&lt;p&gt;5.mysql是否正常启动&lt;/p&gt;
&lt;p&gt;主要会有如上这些错误，大家在平时搭建的时候可以逐一进行排查。&lt;/p&gt;
&lt;p&gt;查看一下我的配置文件，sock文件是在/tmp下需要修改为/var/lib/mysql/mysql.sock.并重新启动mysql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/&lt;span&gt;my.cnf
#my.cnf
[client]
port            &lt;/span&gt;= &lt;span&gt;3306&lt;/span&gt;&lt;span&gt;
#socket          &lt;/span&gt;= /tmp/&lt;span&gt;mysql3306.sock
socket          &lt;/span&gt;= /&lt;span&gt;var&lt;/span&gt;/lib/mysql/&lt;span&gt;mysql.sock

[mysql]
prompt&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\u@\\h:\\p [\\d]&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#pager&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;less -i -n -S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#tee&lt;/span&gt;=/opt/mysql/&lt;span&gt;query.log
no&lt;/span&gt;-auto-&lt;span&gt;rehash

[mysqld]
#misc
user &lt;/span&gt;=&lt;span&gt; mysql
basedir &lt;/span&gt;= /usr/local/&lt;span&gt;mysql
datadir &lt;/span&gt;= /data/mysql/mysql3306/&lt;span&gt;data
port &lt;/span&gt;= &lt;span&gt;3306&lt;/span&gt;&lt;span&gt;
#socket &lt;/span&gt;= /tmp/&lt;span&gt;mysql3306.sock
socket          &lt;/span&gt;= /&lt;span&gt;var&lt;/span&gt;/lib/mysql/&lt;span&gt;mysql.sock
event_scheduler &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

tmpdir &lt;/span&gt;= /data/mysql/mysql3306/&lt;span&gt;tmp
#timeout
interactive_timeout &lt;/span&gt;= &lt;span&gt;300&lt;/span&gt;&lt;span&gt;
wait_timeout &lt;/span&gt;= &lt;span&gt;300&lt;/span&gt;&lt;span&gt;

#character &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
character&lt;/span&gt;-&lt;span&gt;set&lt;/span&gt;-server = utf8&lt;br/&gt;...&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;[root@ken ~]# mkdir /var/lib/mysql -p&lt;br/&gt;[root@ken ~]# chown -R mysql.mysql /var/lib/mysql&lt;/p&gt;
&lt;pre&gt;
[root@ken ~&lt;span&gt;]# pkill msyqld
[root@ken &lt;/span&gt;~]# mysqld &amp;amp;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] &lt;span&gt;2272&lt;/span&gt;&lt;span&gt;
[root@ken &lt;/span&gt;~]# ss -&lt;span&gt;tnl
State      Recv&lt;/span&gt;-Q Send-&lt;span&gt;Q Local Address:Port               Peer Address:Port              
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;           *:&lt;span&gt;111&lt;/span&gt;                       *:*&lt;span&gt;                  
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;           *:&lt;span&gt;22&lt;/span&gt;                        *:*&lt;span&gt;                  
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;70&lt;/span&gt;           :::&lt;span&gt;3306&lt;/span&gt;                     :::*&lt;span&gt;                  
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;          :::&lt;span&gt;111&lt;/span&gt;                      :::*&lt;span&gt;                  
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;          :::&lt;span&gt;80&lt;/span&gt;                       :::*&lt;span&gt;                  
LISTEN     &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;128&lt;/span&gt;          :::&lt;span&gt;22&lt;/span&gt;                       :::*   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次网站刷新页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101212405200-1490740330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101212439205-53256992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101212507209-919917377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101212545614-1793251253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入用户名Admin 密码zabbix&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101212647479-688029308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此就已经安装并启动成功了。&lt;/p&gt;



&lt;p&gt;zabbix已经安装完后，现在就可以来启动了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/zabbix/&lt;span&gt;zabbix_server.conf 
&lt;/span&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt; #
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;&lt;span&gt; # Mandatory: no
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;&lt;span&gt; # Default:
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; # DBUser=
&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; DBUser=&lt;span&gt;zabbix
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt;&lt;span&gt; ### Option: DBPassword
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; #       Database password. Ignored &lt;span&gt;for&lt;/span&gt;&lt;span&gt; SQLite.
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; #       Comment &lt;span&gt;this&lt;/span&gt; line &lt;span&gt;if&lt;/span&gt; no password &lt;span&gt;is&lt;/span&gt;&lt;span&gt; used.
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;&lt;span&gt; #
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;&lt;span&gt; # Mandatory: no
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;&lt;span&gt; # Default:
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; # DBPassword=
&lt;span&gt;116&lt;/span&gt; DBPassword=&lt;span&gt;123  ##输入你的数据库密码，仅仅修改这一处即可&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;&lt;span&gt; ### Option: DBSocket
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;&lt;span&gt; #       Path to MySQL socket.
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;&lt;span&gt; #
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;&lt;span&gt; # Mandatory: no
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;&lt;span&gt; # Default:
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; # DBSocket=/tmp/&lt;span&gt;mysql.sock
..
[root@ken &lt;/span&gt;~]# systemctl restart zabbix-server   ##启动zabbix服务器端
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在在页面查看zabbix启动状态，发现zabbix已经在运行状态了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101213003575-219498136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击configuretion--hosts-disabled启动被监控节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101213126024-1587336175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行如下命令启动被监控节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart zabbix-agent
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101213259892-1085302883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次刷新页面之后发现enable后面的ZBX已经变成绿色，表示已经启动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201811/1499615-20181101213425239-1008045242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击monitoring--latest data--hosts--select选择刚才的hosts即可看到下面监控输出的内容&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 01 Nov 2018 14:26:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>zabbix概述 Zabbix是什么 Zabbix 是由Alexei Vladishev创建，目前由Zabbix SIA在持续开发和支持。 Zabbix 是一个企业级的分布式开源监控方案。 Zabbi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9892708.html</dc:identifier>
</item>
<item>
<title>Lily_music 网页音乐播放器 -可搜索（附歌词联动播放效果解说） - 筱月</title>
<link>http://www.cnblogs.com/ainyi/p/9892932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ainyi/p/9892932.html</guid>
<description>&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/59&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/59&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;这是我今年（2018）年初的小项目，当时也是手贱，不想用别的播放器，想着做一个自己的网页播放器，有个歌曲列表、可关键词搜索、歌词滚动播放的效果，于是乎，就做了这一个 Lily_music&lt;/p&gt;
&lt;h3 id=&quot;当时的感慨&quot;&gt;当时的感慨&lt;/h3&gt;
&lt;p&gt;有好几天没有发表博客了，这也是因为一直开发音乐和完善我的博客项目，好不容易抽出时间总结一下这几天所做的东西，还这么多课，实则匆忙&lt;br/&gt;今天难得逃了一次课，就趁这时间，该写写就写写吧~~&lt;/p&gt;
&lt;h2 id=&quot;进入正题lily_music&quot;&gt;进入正题：Lily_music&lt;/h2&gt;
&lt;p&gt;本次开发，参照本人之前所做的 &lt;a href=&quot;https://www.ainyi.com/&quot;&gt;乐诗博客&lt;/a&gt;（文末会说到）的相关播放控制等功能，继续优化的结果&lt;/p&gt;
&lt;p&gt;前端模仿qq音乐界面，然后在此之上进行修改的界面，并使用了一点 es6 的语法&lt;/p&gt;
&lt;p&gt;话说个人挺喜欢qq音乐界面的，简洁，当然也少不了背景模糊插件以及滚动条美化相关插件&lt;/p&gt;
&lt;p&gt;也用到了弹窗、点击复制歌曲链接和歌词链接相关功能，但是目前歌曲分享功能暂未实现、后续....&lt;/p&gt;
&lt;p&gt;==致谢==：歌曲搜索参照某位大佬封装的 qq 音乐的 api，UI 界面参照另一位大神的一些解决方案，在此表示感谢&lt;/p&gt;
&lt;h2 id=&quot;相关插件&quot;&gt;相关插件&lt;/h2&gt;
&lt;p&gt;那么相关使用的开源插件有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;jQuery 官方类库：&lt;a href=&quot;https://jquery.com/&quot; class=&quot;uri&quot;&gt;https://jquery.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;layer 弹窗插件：&lt;a href=&quot;http://layer.layui.com/&quot; class=&quot;uri&quot;&gt;http://layer.layui.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;复制粘贴库插件：&lt;a href=&quot;https://www.npmjs.com/package/clipboard-js&quot; class=&quot;uri&quot;&gt;https://www.npmjs.com/package/clipboard-js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;mCustomScrollbar 滚动条美化插件：&lt;a href=&quot;http://manos.malihu.gr/jquery-custom-content-scroller&quot; class=&quot;uri&quot;&gt;http://manos.malihu.gr/jquery-custom-content-scroller&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;background-blur 背景图片模糊特效插件：&lt;a href=&quot;https://msurguy.github.io/background-blur&quot; class=&quot;uri&quot;&gt;https://msurguy.github.io/background-blur&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;还有播放、控制、歌词解析、搜索、加载动画sg类库等功能全部手写，爽的不行&lt;/p&gt;
&lt;h2 id=&quot;温馨提醒&quot;&gt;温馨提醒&lt;/h2&gt;
&lt;p&gt;本播放器并不需要什么特别的运行环境，直接下载打开就能用了 ^_^&lt;/p&gt;
&lt;p&gt;响应式优化，可在各种大小的设备运行打开&lt;/p&gt;
&lt;p&gt;音乐搜索的结果均来自 qq音乐 （后续会继续扩大到多个平台）&lt;/p&gt;
&lt;p&gt;本播放器还有一些 bug，需求就是不断满足的，虚心请教...&lt;/p&gt;
&lt;h2 id=&quot;谈谈开发&quot;&gt;谈谈开发&lt;/h2&gt;
&lt;p&gt;果断使用的是 H5 播放器，十分好用&lt;/p&gt;
&lt;p&gt;一般在做这种播放器的开发，要多多使用面向对象的开发思想&lt;/p&gt;
&lt;p&gt;定义一个播放器对象，相关参数、方法如下：&lt;/p&gt;
&lt;p&gt;播放器对象：krAudio&lt;br/&gt;参数：&lt;br/&gt;　　播放器：audioDom&lt;br/&gt;　　进度条锁定：locked:true&lt;br/&gt;　　进度条按下的锁：kdown&lt;br/&gt;　　静音的锁：flag_volume&lt;br/&gt;　　当前音量：curentVoice&lt;br/&gt;　　当前播放的列表序号：Currentplay&lt;br/&gt;　　当前播放列表歌曲总数：allItem&lt;br/&gt;　　播放模式，1 为列表循环：orderModes&lt;/p&gt;
&lt;p&gt;方法：&lt;br/&gt;　　播放器初始化：init&lt;br/&gt;　　设置播放的音乐地址：seturl&lt;br/&gt;　　播放：play&lt;br/&gt;　　暂停：stop&lt;br/&gt;　　播放时间监听及处理：time&lt;br/&gt;　　时间格式化：format&lt;br/&gt;　　下一首：next&lt;br/&gt;　　上一首：prev&lt;br/&gt;　　播放模式：ordermode&lt;br/&gt;　　拖动进度条：controlTime&lt;br/&gt;　　拖动音量条：controlVoice&lt;/p&gt;
&lt;p&gt;上面部分的参数及方法基本涵盖播放器该有的功能，定义好了整个播放器对象所需要的参数和方法，就可以进行具体开发了&lt;/p&gt;
&lt;h2 id=&quot;歌词联动播放&quot;&gt;歌词联动播放&lt;/h2&gt;
&lt;p&gt;具体谈谈这个功能的实现&lt;/p&gt;
&lt;p&gt;歌词解析，我之前做的==乐诗博客==采用的是自己写的一种歌词解析滚动播放的方法&lt;/p&gt;
&lt;p&gt;首先明白一般歌词的形式是：&lt;br/&gt;[00:13.80]期望飞上恬静月球遥望每家的窗&lt;br/&gt;[00:18.24]谁伴深爱细味露台玫瑰香&lt;/p&gt;
&lt;p&gt;这样子的形式，利用 ajax 异步请求到歌词文件内容，然后就可以进行字符串裁剪，单单取出时间和歌词，html5 播放器可以获取到当前播放时间，就可以实现==当前播放时间==和==当前歌词==一一对应，附上代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;loadLrc :function(){//加载歌词
  var vallrc = $(&quot;.hidetextlrc&quot;).text();
  //如果没有上传歌词或者删除了歌词
  if(!vallrc || $(&quot;.is_deleteLrc&quot;).text() == 1){
    $(&quot;.lrc_content_notext&quot;).text(&quot;暂无歌词&quot;);
    $(&quot;.lrc_content_notext&quot;).show();
    return;
  }
  var isHrefLrc = $(&quot;.is_href_lrc&quot;).text();
  //如果是上传的歌词，那就要拼接上服务器地址
  if(isHrefLrc == 0) vallrc = basePath + &quot;/&quot; + vallrc;
  $.ajax({  //异步请求获取本地歌词
    url:vallrc,
    type:&quot;post&quot;,
    success:function(data){
      //第一次分离歌词
      var lrcArr = data.split(&quot;[&quot;);
      //存放分离后的歌词
      var html = &quot;&quot;;
      var lrclast = null; //记录上一行的歌词
      var lrcmes = null; //记录当前行的歌词
      var bofo = -1; //记录上一行歌词的秒数
      var ms = -1; //当前这一行的秒数
      for(var i = 0;i &amp;lt; lrcArr.length;i++){
        //第二次分割歌词，变成[&quot;03:01.08&quot;,&quot;这个世界变得更加美丽&quot;],数组以逗号分隔
        var arr = lrcArr[i].split(&quot;]&quot;);
        //取到数组arr下标为1的歌词部分
        //将上一行的歌词赋值给lrclast
        lrclast = lrcmes; 
        //得到当前歌词
        lrcmes = arr[1];
       //取到时间
        var time = arr[0].split(&quot;.&quot;); //变成[&quot;03:01&quot;,&quot;08&quot;]
        //取到time下标为0的分钟和秒
        var ctime = time[0].split(&quot;:&quot;); //变成[&quot;03&quot;,&quot;01&quot;];
        //将上一行的秒数赋值给bofo
        bofo = ms;
        //转化成秒数
        ms = ctime[0]*60 + ctime[1]*1;
        //如果上一行和当前行秒数相同，则当前行秒数++ ,解决秒数相同的办法
        if(bofo == ms){
          ms++;
        } else if (ms &amp;gt;= 0){
          if(!isNaN(bofo)){ // 如果是数字
            var classeName = &quot;l_&quot;+bofo;
            var concon = bofo; // bofo会自增，所以下面for循环条件用这个变量来代替
            for(var j = 0;j &amp;lt; ms-concon-1;j++){
              classeName += &quot; l_&quot;+ ++bofo;
            }
            if(ms&amp;gt;=0 &amp;amp;&amp;amp; lrclast != null){
              html += &quot;&amp;lt;li class='&quot;+classeName+&quot;'&amp;gt;&quot;+lrclast+&quot;&amp;lt;/li&amp;gt;&quot;;
            }
          }
        }
      }
      //装载最后一行歌词的机制，先获取歌曲总时间
      setTimeout(function(){
        var allall = krAudio.audioDom.duration;
        var classlaName = &quot;l_&quot;+ms;
        var conben = ms; //ms会自增，所以下面for循环条件必须用这个变量来代替
        for(var j = 0;j &amp;lt; allall-conben-1;j++){
          classlaName += &quot; l_&quot;+ ++ms;
        }
        html += &quot;&amp;lt;li class='&quot;+classlaName+&quot;'&amp;gt;&quot;+lrcmes+&quot;&amp;lt;/li&amp;gt;&quot;;
        //把解析好的歌词放入歌词展示区中
        $(&quot;#lrcly&quot;).html(html);
        $(&quot;#lyrics&quot;).html(html);
      },200);
    }
  });
  // 联动音乐播放歌词
  krAudio.audioDom.addEventListener(&quot;timeupdate&quot;,function(){
    //获取当前播放时间,获得的是秒数
    var time = this.currentTime;
    //解析音乐对应的时间
    var m = parseInt(time / 60);//获取此时的分钟
    var s = parseInt(time); //转换int类型，获取此时的秒数
    $(&quot;.l_&quot;+s).addClass(&quot;lrcsel&quot;).siblings().removeClass(&quot;lrcsel&quot;);
    //歌词滚动条，使歌词在中间的计算公式：
    //第n行歌词*li的高度-歌词区域中间的li（就是包括这个li,取这个li的一半）以上的li的总高度
    //局部歌词的控制
    $(&quot;.lrc_content_box&quot;).stop().animate({
      scrollTop:(($(&quot;.lrcsel&quot;).index()+1)*29 - 145)//减去偏差，使当前歌词在中间
    },240);
    //全屏歌词的控制
    $(&quot;#lyrics&quot;).stop().animate({
      scrollTop:(($(&quot;.lrcsel&quot;).index()+1)*24 - 168)//减去偏差，使当前歌词在中间
    },240);
  });
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种==歌词解析==、==联动播放==的实现是我之前==乐诗博客==采用的一种方案，感觉也不错&lt;/p&gt;
&lt;h3 id=&quot;重点来了&quot;&gt;重点来了&lt;/h3&gt;
&lt;p&gt;此次采用的是另一种歌词解析方式，利用 js 正则表达式全部替换的方式&lt;/p&gt;
&lt;p&gt;替换方式&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var reg = /-/g;  // g表示全部替换 ，要替换的字符串是-
createTime = createTime.replace(reg,&quot;/&quot;); // 第二个参数表示替换成 /
 // 替换成2018/04/03&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;歌词解析&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//解析歌词
function parseLyric(lrc) {
 var lyrics = lrc.split(&quot;\n&quot;);
 var lrcText = {};
 for(var i=0;i&amp;lt;lyrics.length;i++){
   var lyric = decodeURIComponent(lyrics[i]);
   var timeReg = /\[\d*:\d*((\.|\:)\d*)*\]/g;
   var timeRegExpArr = lyric.match(timeReg);
   if(!timeRegExpArr)continue;
   var clause = lyric.replace(timeReg,'');
   for(var k = 0,h = timeRegExpArr.length;k &amp;lt; h;k++) {
     var t = timeRegExpArr[k];
     var min = Number(String(t.match(/\[\d*/i)).slice(1)),
     sec = Number(String(t.match(/\:\d*/i)).slice(1));
     var time = min * 60 + sec;
     lrcText[time] = clause;
   }
 }
 return lrcText;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样子解析出来的是一个对象，存放着键值对&lt;br/&gt;键：==时间（秒）==&lt;br/&gt;值：==歌词==&lt;/p&gt;
&lt;p&gt;就可以直接做一个 for in 循环将每句歌词添加到歌词区域，将时间添加到每句歌词的样式控制 class 名&lt;/p&gt;
&lt;p&gt;根据每句歌词的时间，就可以在播放器的 timeupdate 监听事件里实现滚动播放歌词了（代码上面有）&lt;/p&gt;
&lt;h2 id=&quot;拖动进度条&quot;&gt;拖动进度条&lt;/h2&gt;
&lt;p&gt;鼠标拖动进度条的时候，有三个监听事件&lt;/p&gt;
&lt;p&gt;按下：onmousedown&lt;br/&gt;移动：onmousemove&lt;br/&gt;弹起：onmouseup&lt;/p&gt;
&lt;p&gt;这里鼠标移动事件需要放在鼠标按下事件里面，当鼠标弹起时，在里面清除移动、弹起两个事件，以免弹起时还执行鼠标按下拖动事件（也可以定义一把锁来控制）&lt;/p&gt;
&lt;p&gt;还有很多细节点的问题，上一曲下一曲临界值、搜索后的播放控制、列表小菜单与主按钮之间的联动、三种播放模式（顺序播放、随机播放、单曲循环）等等等等... 有坑也有欢笑&lt;/p&gt;
&lt;h2 id=&quot;截图展示&quot;&gt;截图展示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/Lily_music/master/images/cutImg/1.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/Lily_music/master/images/cutImg/2.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Krryxa/Lily_music/master/images/cutImg/3.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目链接&quot;&gt;项目链接&lt;/h2&gt;
&lt;p&gt;在线演示：&lt;a href=&quot;https://www.ainyi.com/Lily_music&quot;&gt;Lily_music&lt;/a&gt;&lt;br/&gt;GitHub：&lt;a href=&quot;https://github.com/Krryxa/Lily_music&quot; class=&quot;uri&quot;&gt;https://github.com/Krryxa/Lily_music&lt;/a&gt;&lt;br/&gt;欢迎 start&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://ainyi.com/#/59&quot; class=&quot;uri&quot;&gt;https://ainyi.com/#/59&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 14:12:00 +0000</pubDate>
<dc:creator>筱月</dc:creator>
<og:description>博客地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ainyi/p/9892932.html</dc:identifier>
</item>
<item>
<title>Django - ORM操作 - JeromeLong</title>
<link>http://www.cnblogs.com/JeromeLong/p/9875171.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JeromeLong/p/9875171.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h3 id=&quot;orm介绍&quot;&gt;ORM介绍&lt;/h3&gt;
&lt;h4 id=&quot;orm的两种方式&quot;&gt;ORM的两种方式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;db first    先连接数据库    -&amp;gt; ...
code first  先创建类        -&amp;gt; sqlachemy、Django、大多数都是&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;django-orm&quot;&gt;Django ORM&lt;/h4&gt;
&lt;p&gt;ORM：Object Relational Mapping(关系对象映射)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;类名             -&amp;gt;&amp;gt;   数据库中的表名

类属性           -&amp;gt;&amp;gt;   数据库里的字段

类实例           -&amp;gt;&amp;gt;   数据库表里的一行数据

obj.name.....    -&amp;gt;&amp;gt;   类实例对象的属性&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Django orm的优势：Django的orm操作本质上会根据对接的数据库引擎，翻译成对应的sql语句；所有使用Django开发的项目无需关心程序底层使用的是MySQL、Oracle、sqlite....，如果数据库迁移，只需要更换Django的数据库引擎即可&lt;/p&gt;
&lt;h4 id=&quot;queryset数据类型介绍&quot;&gt;QuerySet数据类型介绍&lt;/h4&gt;
&lt;p&gt;QuerySet特点：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;可迭代的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可切片&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;惰性计算：等于一个生成器，.objects.all()或者.filter()等都只是返回了一个QuerySet的查询结果集对象，它并不会马上执行sql，而是当调用QuerySet的时候才执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;缓存机制：每一次数据库查询结果QuerySet都会对应一块缓存，再次使用该QuerySet时，不会发生新的SQL操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样减小了频繁操作数据库给数据库带来的压力&lt;/p&gt;
&lt;p&gt;但是有时候取出来的数据量太大会撑爆缓存，可以使用迭代器解决这个问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;models.Publish.objects.all().iterator()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建orm类&quot;&gt;创建ORM类&lt;/h3&gt;
&lt;h4 id=&quot;在models里创建表的类&quot;&gt;1. 在models里创建表的类&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/app/models.py

from django.db import models
# 表名为app01_userinfo
class UserInfo(models.Model):
    # 自动创建id列，自增，主键
    # 列名，字符串类型，指定长度
    username = models.CharField(max_length=32)
    password = models.CharField(max_length=64)
    email = models.EmailField(max_length=19)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类的字段和参数详见&lt;a href=&quot;http://www.cnblogs.com/JeromeLong/p/9875171.html#类的字段和参数&quot;&gt;字段和参数&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;注册app&quot;&gt;2. 注册APP&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/./settings.py

INSTALLED_APPS = [
    ...,
    'app01',
]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;执行命令每次更改表结构都要重复一遍&quot;&gt;3. 执行命令，每次更改表结构都要重复一遍&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py  makemigrations    -&amp;gt;  生成表结构的缓存
python manage.py  migrate           -&amp;gt;  创建表结构&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;默认使用sqlite3数据库可修改为mysql&quot;&gt;4. 默认使用sqlite3数据库，可修改为mysql&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/./settings.py      -&amp;gt;  DATABASES

********** 注意 ***********
Django默认使用MySQLdb模块链接MySQL
主动修改为pymysql，在project同名文件夹下的__init__文件中添加如下代码即可：
    import pymysql
    pymysql.install_as_MySQLdb()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;增删改查&quot;&gt;增删改查&lt;/h3&gt;
&lt;h4 id=&quot;增&quot;&gt;1.增&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/app/views.py
from app01 import models
def orm(request):
    # 直接传入参数
    models.UserInfo.objects.create(username='root',password='123')
    # 传入字典
    dic = {'username': 'eric', 'password': '666'}
    models.UserInfo.objects.create(**dic)
    # 另一种增加方式
    obj = models.UserInfo(username='alex',password='123')
    obj.save()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查&quot;&gt;2.查&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;result = models.UserInfo.objects.all()
result = models.UserInfo.objects.filter(user='root',psd='123') -&amp;gt; filter传入字典也可 **dic
        =&amp;gt; QuerySet, Django的一种列表, [], 内部元素是.obj =&amp;gt; [obj(id,username),obj]
    
# 转化为字典输出                
    .all().values('id','caption')       -&amp;gt; [{'id:1,'username':'alex'},{},{}]
# 转化为tuple输出            
    .all().values_list('id','caption')  -&amp;gt; [(1,'alex'),(),()]
# 取第一个obj
    .filter(xxx).first()                -&amp;gt; 不存在返回None
            =&amp;gt; 用get取单条数据，如果不存在，直接报错
            =&amp;gt; models.UserInfo.objects.get(id=nid)
# 计数
    .filter(name='seven').count()

# 切片
    .all()[10:20]
    .all()[::2]
    .all()[6]    # 索引

# 去重
    .distinct()

# 排序
    .filter(name='seven').order_by('id')    -&amp;gt;  asc
    .filter(name='seven').order_by('-id')   -&amp;gt;  desc&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删&quot;&gt;3.删&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;models.UserInfo.objects.filter(username=&quot;alex&quot;).delete()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;改&quot;&gt;4.改&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;models.UserInfo.objects.filter(id=3).update(password=&quot;69&quot;)  # 可添加**kwargs形式
# 或者先查找对象再修改保存
    obj = models.tb.objects.get(id=1)
    obj.c1 = '111'
    obj.save()                                              # 修改单条数据&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;特殊的判断语句神奇的双下划线1&quot;&gt;特殊的判断语句（神奇的双下划线1）&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# 大于小于
    .filter(id__gt=1)              -&amp;gt;      &amp;gt; 1
    .filter(id=1)                  -&amp;gt;      = 1
    .filter(id__lt=1)              -&amp;gt;      &amp;lt; 1
    .filter(id__lte=1)             -&amp;gt;      &amp;lt;= 1
    .filter(id__gte=1)             -&amp;gt;      &amp;gt;= 1
    .exclude(id__gt=1)             -&amp;gt;      != 1  exclude 除了...与filter相反
    .filter(id__gt=1, id__lt=10)   -&amp;gt;      1&amp;lt; x &amp;lt;10

# 范围range
    .filter(id__range=[1,3])       -&amp;gt;      [1~3]   bettwen + and

# 范围in
    .filter(id__in=[1,2,3])        -&amp;gt;      in [1,2,3]
    .exclude(id__in=[1,2,3])       -&amp;gt;      in [1,2,3]

# 是否为空
    .filter(name__isnull=True)

# 包含、开头、结尾 __startswith, istartswith, endswith, iendswith
    .filter(name__contains=&quot;ven&quot;)
    .filter(name__icontains=&quot;ven&quot;)    # i 忽略大小写

# regex正则匹配，iregex 不区分大小写
    .get(title__regex=r'^(An?|The) +')
    .get(title__iregex=r'^(an?|the) +')

# date
    .filter(pub_date__date=datetime.date(2005, 1, 1))
    .filter(pub_date__date__gt=datetime.date(2005, 1, 1))

# year、month、day、week_day
    .filter(pub_date__year=2005)
    .filter(pub_date__year__gte=2005)

# hour、minute、second
    .filter(timestamp__hour=23)
    .filter(time__hour=5)
    .filter(timestamp__hour__gte=12)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;进阶查询&quot;&gt;进阶查询&lt;/h3&gt;
&lt;ul readability=&quot;29.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;F模块，用于获取对象中的某一字段（列）的值，并且对其进行操作；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  from django.db.models import F      # 首先导入F模块
  models.Book.objects.all().update(price=F('price')+1)   # 每一本书的价格上调1块钱&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;Q模块，用于构造复杂的查询条件，使用逻辑关系（&amp;amp;与、|或、~非）组合进行多条件查询；&lt;/p&gt;
&lt;p&gt;虽然filter中可以使用 , 隔开表示关系与，但没法表示或非的关系&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  from django.db.models import Q      # 导入Q模块
  # 方式一：
      .filter( Q(id__gt=10) )                 -&amp;gt; 
      .filter( Q(id=8) | Q(id__gt=10) )       -&amp;gt; or
      .filter( Q( Q(id=8) | Q(id__gt=10) ) &amp;amp; Q(caption='root') )  -&amp;gt; and, or
  # 方式二：
  # 可以组合嵌套
      # q1里面的条件都是or的关系
      q1 = Q()
      q1.connector = 'OR'
      q1.children.append(('id', 1))
      q1.children.append(('id', 10))
      q1.children.append(('id', 9))
      # q2里面的条件都是or的关系
      q2 = Q()
      q2.connector = 'OR'
      q2.children.append(('c1', 1))
      q2.children.append(('c1', 10))
      q2.children.append(('c1', 9))
      # con通过and的条件把q1和q2联系到一块
      con  = Q()
      con.add(q1, 'AND')
      con.add(q2, 'AND')
      models.tb.objects.filter(con)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例：查询作者姓名中包含 方/少/伟/3字，书名不包含伟，并且出版社地址以山西开头的书&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  book=models.Book.objects.filter(
                                  Q(
                                      Q(author__name__contains='方') |
                                      Q(author__name__contains='少') |
                                      Q(author__name__contains='伟') |
                                      Q(title__icontains='伟')
                                  ) &amp;amp; 
                                  Q(publish__addr__contains='山西')
                              ).values('title')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：Q查询和非Q查询混合使用，非Q查询一定要放在Q查询后面&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;extra方法&lt;/p&gt;
&lt;p&gt;对不同的数据库引擎可能存在移植问题(因为你在显式的书写SQL语句),尽量避免使用extra&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  a.映射
      - select={'new_id':select count(1) from app01_usertype where id&amp;gt;%s'}
      - select_params=[1,]
      # 例：
          models.UserInfo.objects.all().extra(
              select={
                  'n':&quot;select count(1) from app01_utype WHERE id=%s or id=%s&quot;,
                  'm':&quot;select count(1) from app01_uinfo WHERE id=%s or id=%s&quot;,
              },
              select_params=[1,2,3,4]
          )

  b.条件
      - where=[&quot;foo='a' OR bar = 'a'&quot;, &quot;baz = '%s'&quot;],
      - params=['Lennon',]

  c.表
      - tables=[&quot;app01_usertype&quot;]

  d.排序
      - order_by = ['-id']

  # 例1：
      models.UserInfo.objects.extra(
          select={'new_id':select count(1) from app01_usertype where id&amp;gt;%s'},
          select_params=[1,],
          where=['age&amp;gt;%s'],
          params=[18,],
          order_by=['-age'],
          tables=[&quot;app01_usertype']
      )
      -&amp;gt; 相当于:
          '''
          select
              app01_userinfo.id,
              (select count(1) from app01_usertype where id&amp;gt;1) as new_id
          from
              app01_userinfo,
              app01_usertype
          where 
              app01_userinfo.age&amp;gt;18
          order by 
              app01_userinfo.age desc
          '''

  # 例2：
      current_user = models.UserInfo.objects.filter(username=username).first()   # 当前用户

      1、models.Article.objects.all()      # 查出每一篇文章
      2、models.Article.objects.all().filter(user=current_user)  # 查出当前用户的所有文章
      3、models.Article.objects.all().filter(user=current_user).extra(select={&quot;filter_create_date&quot;:&quot;strftime(‘%%Y/%%m‘,create_time)&quot;}).values_list(&quot;filter_create_date&quot;)
          # 查出当前用户的所有文章的create_time，并且只取出年份和月份&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行原生SQL的三种方式&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1.使用extra方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  结果集修改器，一种提供额外查询参数的机制  
  依赖model模型&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;2.使用raw方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  执行原始sql并返回模型  
  依赖model多用于查询

  book = Book.objects.raw(&quot;select * from hello_book&quot;)
  for item in book:
      print(item.title)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;3.使用cursor游标&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  不依赖model

  from django.db import connection, connections
  cursor = connection.cursor()  
  # 或cursor = connections['default'].cursor() 
  # 其中'default'是django数据库配置的default，也可取别的值
  cursor.execute(&quot;&quot;&quot;SELECT * from auth_user where id = %s&quot;&quot;&quot;, [1])
  row = cursor.fetchone()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类的字段和参数&quot;&gt;类的字段和参数&lt;/h3&gt;
&lt;h4 id=&quot;字段字符串数字时间二进制&quot;&gt;字段：字符串、数字、时间、二进制&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;AutoField(Field)        -&amp;gt;  自定义自增列（必须加primary_key=True）
IntegerField(Field)     -&amp;gt;  整数列
BooleanField(Field)     -&amp;gt;  布尔
GenericIPAddressField(Field)    -&amp;gt;  IP验证(仅限django admin)
URLField(CharField)     -&amp;gt;  url验证(仅限django admin)
# Django里有很多的字段类型在数据库中都是Char类型，只是用于django admin便于区分&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多详见：&lt;a href=&quot;http://www.cnblogs.com/wupeiqi/articles/5246483.html&quot;&gt;武沛齐的博客 - Django&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;字段的参数&quot;&gt;字段的参数：&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;null                -&amp;gt; db中是否可以为空
default=''          -&amp;gt; 默认值
primary_key         -&amp;gt; 是否主键
db_column           -&amp;gt; 列名

db_index            -&amp;gt; 是否可索引
unique              -&amp;gt; 是否可唯一索引
unique_for_date     -&amp;gt; 【日期】部分是否可索引
unique_for_month    -&amp;gt; 【月】部分是否可索引
unique_for_year     -&amp;gt; 【年】部分是否可索引

auto_now_add        -&amp;gt; 创建时，自动生成时间
auto_now            -&amp;gt; 更新时，自动更新为当前时间
        # update方式不生效，先获取再更改才生效
        ctime = models.DateTimeField(auto_now_add=True)
        UserGroup.objects.filter(id=1).update(caption='CEO')    -&amp;gt; 不生效
        obj = UserGroup.objects.filter(id=1).first()
        obj.caption = &quot;CEO&quot;             -&amp;gt; 生效，自动更新更改时间
        obj.save()

# django admin中才生效的字段
blank               -&amp;gt; django admin是否可以为空
verbose_name=''     -&amp;gt; django admin显示字段中文
editable            -&amp;gt; django admin是否可以被编辑
help_text           -&amp;gt; django admin帮助提示
choices=[]          -&amp;gt; django admin中显示下拉框
        # 可避免连表查询，提高效率，一般用于基本不变的选项
        user_type_choices = (
            (1, '超级用户'),
            (2, '普通用户'),
            (3, '普普通用户'),
        )
        user_type_id = models.IntegerField(choices=user_type_choices,default=1)

error_messages      -&amp;gt; 自定义错误信息（字典类型）
        # 字典的键：null, blank, invalid, invalid_choice, unique, unique_for_date
        # 例：error_messages = {'null': &quot;不能为空&quot;, 'invalid': '格式错误'}

validators          -&amp;gt; django form ,自定义错误信息（列表类型）
        # 例：
        from django.core.validators import RegexValidator
        from django.core.validators import EmailValidator,URLValidator,DecimalValidator,\
                MaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator
        error_messages={
            'c1': '优先错信息1',
            'c2': '优先错信息2',
            'c3': '优先错信息3',
        },
        validators=[
            RegexValidator(regex='root_\d+', message='错误了', code='c1'),
            RegexValidator(regex='root_112233\d+', message='又错误了', code='c2'),
            EmailValidator(message='又错误了', code='c3'), ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多错误信息的使用方法参考&lt;a href=&quot;http://www.cnblogs.com/wupeiqi/articles/6144178.html&quot;&gt;武沛齐 - FORM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建 Django admin用户：&lt;/strong&gt; &lt;code&gt;python manage.py createsuperuser&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;meta元信息&quot;&gt;Meta元信息&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class UserInfo(models.Model):
    ...
    class Meta:
        # 定义数据库中生成的表名称 默认 app名称 + 下划线 + 类名
        db_table = &quot;table_name&quot;

        # 联合索引
        index_together = [(&quot;pub_date&quot;, &quot;deadline&quot;),]

        # 联合唯一索引,一旦三者都相同，则会被Django拒绝创建。
        可以同时设置多组约束。为了方便，对于只有一组约束的情况下，可以简单地使用一维元素
        unique_together = ((&quot;driver&quot;, &quot;restaurant&quot;),)

        # admin后台中显示的表名称
        verbose_name = '用户信息'

        # verbose_name加s，复数形式，不指定自动加s
        verbose_name_plural = 

        # 默认排序
        ordering=['-order_date'] # 按订单降序排列，-表示降序，不加升序，加?表示随机
        ordering=['-pub_date','author'] # 以pub_date为降序，再以author升序排列&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多：&lt;a href=&quot;https://docs.djangoproject.com/en/1.10/ref/models/options/&quot; class=&quot;uri&quot;&gt;https://docs.djangoproject.com/en/1.10/ref/models/options/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;admin拓展知识&quot;&gt;Admin拓展知识&lt;/h4&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;触发Model中的验证和错误提示有两种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; a. Django Admin中的错误信息会优先根据Admin内部的ModelForm错误信息提示，如果都成功，才来检查Model的字段并显示指定错误信息
 b. 调用Model对象的 clean_fields 方法，如：
     # models.py
     class UserInfo(models.Model):
         username = models.CharField(max_length=32)
         email = models.EmailField(error_messages={'invalid': '格式错了.'})

     # views.py
     def index(request):
         obj = models.UserInfo(username='11234', email='uu')
         try:
             print(obj.clean_fields())
         except Exception as e:
             print(e)
         return HttpResponse('ok')

    # Model的clean方法是一个钩子，可用于定制操作，如：上述的异常处理。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;Admin中修改错误提示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; # admin.py
 from django.contrib import admin
 from model_club import models
 from django import forms

 class UserInfoForm(forms.ModelForm):
     username = forms.CharField(error_messages={'required': '用户名不能为空.'})
     email = forms.EmailField(error_messages={'invalid': '邮箱格式错误.'})
     age = forms.IntegerField(initial=1, error_messages={'required': '请输入数值.', 'invalid': '年龄必须为数值.'})

     class Meta:
         model = models.UserInfo
         # fields = ('username',)
         fields = &quot;__all__&quot;

 class UserInfoAdmin(admin.ModelAdmin):
     form = UserInfoForm

 admin.site.register(models.UserInfo, UserInfoAdmin)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;orm连表的几种类型&quot;&gt;ORM连表的几种类型&lt;/h3&gt;
&lt;h4 id=&quot;orm一对多&quot;&gt;ORM一对多&lt;/h4&gt;
&lt;p&gt;当一张表中创建一行数据时，有一个单选的下拉框（可以被重复选择）&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;创建表结构时关联外键&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  user_group = models.ForeignKey(&quot;UserGroup&quot;,to_field='uid')  -&amp;gt;&amp;gt;   obj(UserGroup)
  # 自动创建user_group_id列，存的是数字（关联主键）&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;添加数据时关联id或对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  方式一：创建数据时添加id关联
      models.UserInfo.object.create(name='root', user_group_id=1)

  方式二：查询obj对象进行关联
      user_group = models.UserGroup.objects.filter(id=1).first()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;一对多自关联&quot;&gt;一对多自关联&lt;/h4&gt;
&lt;p&gt;由原来的2张表，变成一张表！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例：回复评论
class Comment(models.Model):
    news_id = models.IntegerField()                 -&amp;gt; 新闻ID
    content = models.CharField(max_length=32)       -&amp;gt; 评论内容
    user = models.CharField(max_length=32)          -&amp;gt; 评论者
    reply = models.ForeignKey('Comment',null=True,blank=True,related_name='xxxx') -&amp;gt; 回复ID
# 注意：回复的id必须是已经存在的评论的id&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;orm多对多&quot;&gt;ORM多对多&lt;/h4&gt;
&lt;p&gt;在某表中创建一行数据是，有一个可以多选的下拉框&lt;/p&gt;
&lt;h4 id=&quot;多对多自关联&quot;&gt;多对多自关联&lt;/h4&gt;
&lt;p&gt;（由原来的3张表，变成只有2张表）&lt;br/&gt;把两张表通过 choices 字段合并为一张表&lt;br/&gt;使用ManyToManyField字段&lt;/p&gt;
&lt;p&gt;1、查询第三张关系表前面那一列：obj.m&lt;/p&gt;
&lt;p&gt;2、查询第三张关系表后面那一列：obj.userinfo_set&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Userinfo(models.Model):
    sex=((1,'男'),(2,'女'))
    gender=models.IntegerField(choices=sex)
    m=models.ManyToManyField('Userinfo')

# 通过男士查询女生
    boy_obj=models.Userinfo.objects.filter(id=4).first()
    res=boy_obj.m.all()
# 通过女士查询男生
    girl_obj=models.Userinfo.objects.filter(id=4).first()
    res=girl_obj.userinfo_set.all()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;orm一对一&quot;&gt;ORM一对一&lt;/h4&gt;
&lt;p&gt;在某表中创建一行数据时，有一个单选的下拉框（下拉框中的内容被用过一次就消失了）&lt;/p&gt;
&lt;p&gt;例如：原有含10列数据的一张表保存相关信息，经过一段时间之后，10列无法满足需求，需要为原来的表再添加5列数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;r = models.OneToOneField(...)

# 1. 一对一其实就是 一对多 + 唯一索引
# 2. 当两个类之间有继承关系时，默认会创建一个一对一字段
# 如下会在A表中额外增加一个 c_ptr_id 列且唯一：
    class C(models.Model):
        nid = models.AutoField(primary_key=True)
        part = models.CharField(max_length=12)
    class A(C):
        id = models.AutoField(primary_key=True)
        code = models.CharField(max_length=1)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;orm连表操作&quot;&gt;ORM连表操作&lt;/h3&gt;
&lt;h4 id=&quot;字段参数&quot;&gt;字段参数&lt;/h4&gt;
&lt;ul readability=&quot;14.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;一对多ForeignKey()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  to                          -&amp;gt;  要关联的表名
  to_field='uid',             -&amp;gt;  要关联的字段，不写默认关联主键
  on_delete=None,             -&amp;gt;  删除关联表中的数据时，当前表与其关联的行的行为
      - models.CASCADE        -&amp;gt;  与之关联的也删除
      - models.DO_NOTHING     -&amp;gt;  引发错误IntegrityError
      - models.PROTECT        -&amp;gt;  引发错误ProtectedError
      - models.SET_NULL       -&amp;gt;  与之关联的值设为null（前提FK字段可为空）
      - models.SET_DEFAULT    -&amp;gt;  与之关联的值设为默认值（前提FK字段有默认值）
      - models.SET            -&amp;gt;  与之关联的值设为指定值
              # 有两种指定方法
              a. 设置为指定值：models.SET(值)
              b. 设置为可执行对象的返回值，如：models.SET(func)
                  def func():
                      return 10
                  class MyModel(models.Model):
                      user = models.ForeignKey(...,on_delete=models.SET(func))

  related_name=None,          -&amp;gt;  反向操作时，使用的字段名，用于替换【表名_set】
                                  如： obj.表名_set.all()
  related_query_name=None,    -&amp;gt;  反向操作时，使用的连接前缀，用于替换【表名】
                      如: ...filter(表名__字段名=1).values('表名__字段名')
  limit_choices_to=None,      -&amp;gt;  在Admin或ModelForm中显示关联数据时，提供的条件：
      - limit_choices_to={'nid__gt': 5}
      - limit_choices_to=lambda : {'nid__gt': 5}

      from django.db.models import Q
      - limit_choices_to=Q(nid__gt=10)
      - limit_choices_to=Q(nid=8) | Q(nid__gt=10)
      - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) &amp;amp; Q(caption='root')

  db_constraint=True          -&amp;gt;  是否在数据库中创建外键约束
  parent_link=False           -&amp;gt;  在Admin中是否显示关联数据&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;多对多ManyToManyField()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  symmetrical=None,       -&amp;gt; 仅用于多对多自关联时，指定内部是否创建反向操作的字段
      =&amp;gt; 做如下操作时，不同的symmetrical会有不同的可选字段
          models.BB.objects.filter(...)

      =&amp;gt; 可选字段有：code, id, m1
          class BB(models.Model):
              code = models.CharField(max_length=12)
              m1 = models.ManyToManyField('self',symmetrical=True)

      =&amp;gt; 可选字段有: code, id, m1, bb
          class BB(models.Model):
              code = models.CharField(max_length=12)
              m1 = models.ManyToManyField('self',symmetrical=False)

  through=None,           -&amp;gt; 自定义第三张表时，用于指定关系表
  through_fields=None,    -&amp;gt; 自定义第三张表时，用于指定关系表中哪些字段做多对多关系表

  db_constraint=True,         -&amp;gt; 是否在数据库中创建外键约束
  db_table=None,              -&amp;gt; 默认创建第三张表时，数据库中表的名称&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;一对一OneToOneField()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  to                          -&amp;gt;  要关联的表名
  to_field='uid',             -&amp;gt;  要关联的字段，不写默认关联主键
  on_delete=None,             -&amp;gt;  删除关联表中的数据时，当前表与其关联的行的行为&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;跨表查询神奇的双下划线2&quot;&gt;跨表查询（神奇的双下划线2）&lt;/h4&gt;
&lt;ul readability=&quot;11&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;获取值时使用 . 连接&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  group_obj = models.UserGroup.objects.filter(id=1).first()   # orm连表必须取单个对象
  # 增
  group_obj.user_info.add(1)                -&amp;gt; 添加一个
  group_obj.user_info.add(2,3,4)            -&amp;gt; 添加多个
  group_obj.user_info.add(*[1,2,3,4])       -&amp;gt; 添加*列表
  # 删
  group_obj.user_info.remove(1)
  group_obj.user_info.remove(2,4)
  group_obj.user_info.remove(*[1,2,3])
  group_obj.user_info.clear()           -&amp;gt; 清除当前对象关联的多对多数据
  # 改
  group_obj.user_info.set([3,5,7])      -&amp;gt; （不加*）只保留1-3，1-5，1-7，其它删除
  # 查
  group_obj.user_info.all()             -&amp;gt; 获取所有相关的主机obj 的QuerySet
  group_obj.user_info.filter()
  ......&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;搜索条件使用 __ 连接 (value、value_list、fifter)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  obj = models.UserGroup.objects.filter(id=1).value('name','user_info__name').first()
  在html里也用obj.user_group__name&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;反查&lt;br/&gt;# . 操作，获取对象的QuerySet，表名小写_set&lt;br/&gt;user_info_obj.usergroup_set.add(group_obj)&lt;br/&gt;user_info_obj.usergroup_set.remove(group_obj)&lt;br/&gt;user_info_obj.usergroup_set.all()&lt;br/&gt;user_info_obj.usergroup_set.filter()&lt;br/&gt;......&lt;br/&gt;# __操作，搜索属性，表名小写__属性&lt;br/&gt;obj = models.UserInfo.objects.filter('usergruop__name').first()&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;设置反向查找别名&quot;&gt;设置反向查找别名&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;related_query_name      -&amp;gt; 反向查找时用 obj.别名_set.all()，保留了_set
relatedname             -&amp;gt; 反向查找时用 obj.别名.all()  


# 例如：
'''把男女表混合在一起，在代码层面控制第三张关系表的外键关系'''

    # models.py
    class UserInfo(models.Model):
        ...
        sex=((1,'男'),(2,'女'))
        gender=models.IntegerField(choices=sex)
    class U2U(models.Model):
        b=models.ForeignKey(Userinfo,related_name='boy')
        g=models.ForeignKey(Userinfo,related_name='girl')

       # 写到此处问题就来了，原来两个外键 对应2张表 2个主键，可以识别男女
       # 现在两个外键对应1张表，反向查找，无法区分男女了了
       # object对象女.U2U.Userinfo.set  object对象男.U2U.Userinfo.set
       # 所以要加related_name设置反向查找命名 对表中主键加以区分
       # 查找方法
       # 男：obj.a.all()
       # 女：obj.b.all()

    # views.py
    def index(request):
       #查找 ID为1男孩 相关的女孩
       boy_obj=models.UserInfo.objects.filter(id=1).first()
       res = boy_obj.boy.all()   # 得到U2U的对象再正向跨表           
       for obj in res:
           print(obj.girl.name)
       return HttpResponse('OK')&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分组和聚合查询&quot;&gt;分组和聚合查询&lt;/h4&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;aggregate() 聚合函数&lt;/p&gt;
&lt;p&gt;通过对QuerySet进行计算，返回一个聚合值的字典。&lt;br/&gt;aggregate()中每一个参数都指定一个包含在字典中的返回值。即在查询集上生成聚合。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; from django.db.models import Avg,Sum,Max,Min

 # 求书籍的平均价
 ret = models.Book.objects.all().aggregate(Avg('price'))
 # {'price__avg': 145.23076923076923}

 # 参与西游记著作的作者中最老的一位作者
 ret = models.Book.objects.filter(title__icontains='西游记').values('author__age').aggregate(Max('author__age'))
 # {'author__age__max': 518}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;annotate() 分组函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; # 查看每一位作者出过的书中最贵的一本  
 # （按作者名分组 values()，然后 annotate() 分别取每人出过的书价格最高的）
 ret=models.Book.objects.values('author__name').annotate(Max('price'))
 # &amp;lt; QuerySet[
 # {'author__name': '吴承恩', 'price__max': Decimal('234.000')},
 # {'author__name': '吕不韦','price__max': Decimal('234.000')},
 # {'author__name': '姜子牙', 'price__max': Decimal('123.000')},
 # ] &amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;浅谈orm查询性能&quot;&gt;浅谈ORM查询性能&lt;/h3&gt;
&lt;ol readability=&quot;20.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;普通跨表查询&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; obj_list=models.Love.objects.all() 
 for row in obj_list:           # for循环10次发送10次数据库查询请求
     print(row.b.name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理：第一次发送查询请求，每for循环一次也会发送查询请求&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;select_related&lt;/p&gt;
&lt;p&gt;结果为对象，query_set类型的对象都有该方法&lt;/p&gt;
&lt;p&gt;原理：select_related查询时主动完成连表形成一张大表，for循环时不用额外发请求&lt;/p&gt;
&lt;p&gt;试用场景：节省硬盘空间，数据量少的时候适用，相当于做了一次数据库查询；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; obj_list=models.Love.objects.all().select_related('b')      # 查询时关联b表
     for row in obj_list:
         print(row.b.name)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;prefetch_related：&lt;/p&gt;
&lt;p&gt;结果为对象&lt;/p&gt;
&lt;p&gt;原理：select_related虽好，但是做连表操作依然会影响查询性能，prefetch_related不做连表，多次单表查询外键表，去重之后显示，2次单表查询（有N个外键做1+N次单表查询）&lt;/p&gt;
&lt;p&gt;适用场景：效率高，数据量大的时候使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; obj_list=models.Love.objects.all().prefetch_related('b')
     for obj in obj_list:
         print(obj.b.name)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;update()和对象.save()修改方式的性能PK&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; # 方式1
     models.Book.objects.filter(id=1).update(price=3)
     # 执行结果
         (0.000) BEGIN; args=None
         (0.000) UPDATE &quot;app01_book&quot; SET &quot;price&quot; = '3.000' WHERE &quot;app01_book&quot;.&quot;id&quot; = 1; args=('3.000', 1)

 # 方式2
     book_obj=models.Book.objects.get(id=1)
     book_obj.price=5
     book_obj.save()
     # 执行结果
         (0.000) SELECT &quot;app01_book&quot;.&quot;id&quot;, &quot;app01_book&quot;.&quot;title&quot;, &quot;app01_book&quot;.&quot;price&quot;, &quot;app01_book&quot;.&quot;date&quot;, &quot;app01_book&quot;.&quot;publish_id&quot;, &quot;app01_book&quot;.&quot;classify_id&quot; FROM &quot;app01_book&quot; WHERE &quot;app01_book&quot;.&quot;id&quot; = 1; args=(1,)
         (0.000) BEGIN; args=None
         (0.000) UPDATE &quot;app01_book&quot; SET &quot;title&quot; = '我的奋斗', &quot;price&quot; = '5.000', &quot;date&quot; = '1370-09-09', &quot;publish_id&quot; = 4, &quot;classify_id&quot; = 3 WHERE &quot;app01_book&quot;.&quot;id&quot; = 1; args=('我的奋斗', '5.000', '1370-09-09', 4, 3, 1)

 # 结论：
     update() 比 obj.save()性能好&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;django自带contenttype表&quot;&gt;Django自带ContentType表&lt;/h3&gt;
&lt;p&gt;Django程序启动后自带的一张表，记录了Django程序的所有APP下model中的表名和所在app的名称&lt;/p&gt;
&lt;ol readability=&quot;14.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;通过ContentType中的app名和表名，查找到Django model中所有表；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; from django.contrib.contenttypes.models import ContentType
 def test(request):
     c = ContentType.objects.get(app_label='app01',model='boy')
     print(c)                    -&amp;gt; boy
     print(c.model_class())      -&amp;gt; app01.models.Boy&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;解决 1张表 同时与其他N张表建立外键，并且多个外键中只能选择1个的复杂问题&lt;/p&gt;
&lt;p&gt;场景1：现有N种优惠券，每1种优惠券分别对应N门课程中的一门课程，怎么设计表结构呢？&lt;br/&gt;场景2：学生的学习成绩如何奖惩、 作业如何奖惩、学习进度如何奖惩...&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; # 例：场景1
     from django.db import models
     from django.contrib.contenttypes.models import ContentType
     from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation

     class DegreeCourse(models.Model):
         name = models.CharField(max_length=128, unique=True)
         # GenericRelation 自动连表查询
         xxx = GenericRelation('Coupon')

     class Course(models.Model):
         name = models.CharField(max_length=128, unique=True)

     class Coupon(models.Model):
         &quot;&quot;&quot;优惠券生成规则
             ID     优惠券名称         content_type_id(表)         object_id（表中数据ID）
              1       通用                 null                    null
              2       满100-10               8                      1
              3       满200-30               8                      2
              4       满200-30               9                      1
         &quot;&quot;&quot;
         name = models.CharField(max_length=64, verbose_name=&quot;活动名称&quot;)
         # course_type 代指哪张表 注意该字段必须为 content_type
         content_type = models.ForeignKey(ContentType,blank=True,null=True)
         # 代指对象ID 该字段必须为 object_id
         object_id = models.PositiveIntegerField(blank=True, null=True, help_text=&quot;可以把优惠券跟课程绑定&quot;)
         # GenericForeignKey 通过 content_type 直接创建外键关系，不会生成额外的列
         content_object = GenericForeignKey('content_type','object_id')

 # 给学位课1，创建优惠券100
 # 方式1：
 # 1、在学位课表中 ，找到学位课1
     d1 = models.DegreeCourse.objects.get(id=1)
 # 2、在ContentType找到学位课表
     c1 = ContentType.objects.get(app_label='app01',model='degreecourse')
 # 3、给学位课1，创建优惠券100
     models.Coupon.objects.create(name='优惠券',brief='100',content_type=c1,object_id=d1.id)

 # 方式2：
     d1 = models.DegreeCourse.objects.get(id=1)
     models.Coupon.objects.create(name='优惠券',brief='100',content_object=d1)

 # 查询关联的所有优惠券
     d1 = models.DegreeCourse.objects.get(id=1)
     print(d1.xxx.all())
     v = models.DegreeCourse.objects.values('name','xxx__brief','xxx__name')
     print(v)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;其他小技巧&quot;&gt;其他小技巧&lt;/h3&gt;
&lt;h4 id=&quot;数据库表删除重建&quot;&gt;数据库表删除重建：&lt;/h4&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先到数据库把表删掉：&lt;code&gt;drop table&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;注释django中对应的Model&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;执行以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; python manage.py makemigrations   
 python manage.py migrate --fake     -&amp;gt;  只记录变化，不提交数据库操作&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;去掉注释重新迁移&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; python manage.py makemigrations   
 python manage.py migrate&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;字典key替换&quot;&gt;字典key替换&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# 把value传给新key并同时删除旧key
row['delivery'] = [row.pop('投递')]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;获取字段名和verbose_name&quot;&gt;获取字段名和verbose_name&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;fields_data = Group._meta.fields
for key in data:
    # 这里是将当前的数据转换成数据字典，方便后面修改后提交
    data_dict = Group.__dict__
    for field in fields_data:
        # 这样或输出这条记录的所有字段名，需要的话还可以输出verbose_name
        print(field.name)
        if field.name == key:
            #进行匹配，将前端传来的字段匹配到，然后修改数据库里面的数据
            data_dict[key] = data[key]
# 保存数据到数据库，这样的好处就是提高效率，避免过多重复操作&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;参考博客&quot;&gt;参考博客&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sss4/p/7070942.html&quot;&gt;ORM详细讲解&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/wupeiqi/articles/5246483.html&quot;&gt;武沛齐的博客 - Django&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 14:04:00 +0000</pubDate>
<dc:creator>JeromeLong</dc:creator>
<og:description>[TOC] ORM介绍 ORM的两种方式 db first 先连接数据库 ... code first 先创建类 sqlachemy、Django、大多数都是 Django ORM ORM：Objec</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JeromeLong/p/9875171.html</dc:identifier>
</item>
<item>
<title>apk 反编译 - 最新版图文教程 - 肖朋伟</title>
<link>http://www.cnblogs.com/xpwi/p/9892680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xpwi/p/9892680.html</guid>
<description>&lt;h3 id=&quot;apk-反编译---最新版图文教程&quot;&gt;apk 反编译 - 最新版图文教程&lt;/h3&gt;
&lt;p&gt;结合网上众多教程，整理一篇自己操作的，工具都是目前最新版 apk 反编译也就是将打包后的 apk 反编译为资源文件(图片)、layout、样式、相关的实现代码等。（注：反编译不是让各位开发者去对一个应用破解搞重装什么的，主要目的是为了促进开发者学习，学习）&lt;/p&gt;
&lt;p&gt;后续也会再整理一篇防止反编译的教程&lt;/p&gt;
&lt;p&gt;转载请注明出处&lt;/p&gt;
&lt;h3 id=&quot;一准备工具&quot;&gt;一、准备工具&lt;/h3&gt;
&lt;p&gt;提示：这些工具在官网都不好下载，偶也是废了好大力气呢，建议直接下载我提供的网盘链接&lt;/p&gt;
&lt;h4 id=&quot;使用工具介绍&quot;&gt;(1) 使用工具介绍：&lt;/h4&gt;
&lt;p&gt; &lt;strong&gt;1.apktool 最新版 jar 包&lt;/strong&gt;&lt;br/&gt;  作用：资源文件获取，可以提取出图片文件和布局文件进行使用查看&lt;br/&gt;  &lt;strong&gt;2.dex2 jar 的zip包&lt;/strong&gt;&lt;br/&gt;  作用：将apk反编译成java源码（classes.dex转化成jar文件）&lt;br/&gt;  &lt;strong&gt;3.jd-gui 工具&lt;/strong&gt;&lt;br/&gt;  作用：查看APK中classes.dex转化成出的jar文件，即源码文件&lt;/p&gt;
&lt;h4 id=&quot;使用工具下载与安装&quot;&gt;(2) 使用工具下载与安装：&lt;/h4&gt;
&lt;p&gt;  &lt;strong&gt;1.apktool_2.3.4 jar 包（2018.10.31 目前最新版）&lt;/strong&gt;&lt;br/&gt;   百度网盘地址：&lt;a href=&quot;https://pan.baidu.com/s/1Vp6PDUc9dfgN0QPtwFp4Zw&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1Vp6PDUc9dfgN0QPtwFp4Zw&lt;/a&gt; 密码：c8n3&lt;br/&gt;   官网下载地址：&lt;a href=&quot;https://bitbucket.org/iBotPeaches/apktool/downloads/&quot; class=&quot;uri&quot;&gt;https://bitbucket.org/iBotPeaches/apktool/downloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101212900787-424863520.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;2.dex2 2.0 jar 包（2018.10.31 目前最新版）&lt;/strong&gt;&lt;br/&gt;   百度网盘地址：&lt;a href=&quot;https://pan.baidu.com/s/1yk5bVAMPYov66u23kxYAJw&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1yk5bVAMPYov66u23kxYAJw&lt;/a&gt; 密码：irxv&lt;br/&gt;   官网下载地址：&lt;a href=&quot;http://sourceforge.net/projects/dex2jar/files/&quot; class=&quot;uri&quot;&gt;http://sourceforge.net/projects/dex2jar/files/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101212914656-383424119.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;3.jd-gui 1.4.0（2018.10.31 目前最新版）&lt;/strong&gt;&lt;br/&gt;   百度网盘地址：&lt;a href=&quot;https://pan.baidu.com/s/1ceirRfHzfiqcHFHGxj2fkA&quot; class=&quot;uri&quot;&gt;https://pan.baidu.com/s/1ceirRfHzfiqcHFHGxj2fkA&lt;/a&gt; 密码：mx14&lt;br/&gt;   官网下载地址：&lt;a href=&quot;http://jd.benow.ca/&quot; class=&quot;uri&quot;&gt;http://jd.benow.ca/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101212927958-1775262773.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二apk-反编译步骤&quot;&gt;二、Apk 反编译步骤&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;(1) 使用 apktool 反编译 apk 得到图片、XML配置、语言资源等文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 1.将上述下载好的 3 个工具统一放到一个文件夹中（目录最好不好有中文），并解压 zip 文件，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101212941008-561536257.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2.打开 cmd/终端，进入上述工具目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101212948265-1618542752.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3.运行apktool_2.3.4.jar这个jar文件来将 apk文件进行反编译，在java中，运行可执行jar包的命令是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;java -jar apktool_2.3.4.jar d -f apk文件绝对路径 -o 输出的目录&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt; 使用如下的命令运行apktool_2.0.1.jar反编译MMTS-release-1.0.2.apk&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;java -jar apktool_2.3.4.jar d -f D:\apkDecompile\ocrTest.apk -o source&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个命令是启动 apktool_2.3.4.jar 将位于 D:\apkDecompile\ocrTest.apk 文件执行反编译，然后将反编译生成的文件存放到 apk 文件同级的 source 目录下，截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213013117-549148029.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4.然后就会生成源文件的目录，有开发经验的大概能看出点什么&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213019286-1931168805.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5.重要的有【res】目录和【AndroidManifest.xml】&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213025913-1608018251.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是使用 apktool 这个工具将一个 apk 反编译得到图片、XML配置、语言资源等文件的过程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) 使用 dex2jar 反编译 apk 得到 Jar 包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  将要反编译的 APK 后缀名改为 .rar 或者 .zip，并解压，得到其中的classes.dex 文件（它就是java文件编译再通过dx工具打包而成的），如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213045374-1509358307.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　将获取到的classes.dex放到之前解压出来的工具【dex2jar-2.0】文件夹内，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213051563-280947961.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在命令行下进入到 dex2jar.bat 所在目录，输入&quot;d2j-dex2jar classes.dex&quot;，截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213058264-1568419686.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令执行完成之后，在当前目录下就可以看到生成的Jar文件了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213106711-714225496.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反编译 classes.dex 得到 classes-dex2jar.jar 文件之后，就可以使用【jd-gui】工具将 class 文件反编译成 java 源代码了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3) 使用 jd-gui.exe 工具将 class 文件反编译成 java 源代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 1.打开 jd-gui.exe 程序（不需要安装，之前 zip 包解压即可）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213113412-138495719.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2.打开 jar 文件，截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213120260-1814313456.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3.选择 class 文件就可以看到 java 源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1483449/201811/1483449-20181101213125160-2066442936.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三出错提示&quot;&gt;三、出错提示：&lt;/h3&gt;
&lt;p&gt;如果那不出错了，基本就是工具版本的问题，建议全部下载最新版或者全部使用我提供的版本&lt;/p&gt;
&lt;h3 id=&quot;四更多文章&quot;&gt;四、更多文章：&lt;/h3&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;转载请注明出处&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 01 Nov 2018 13:32:00 +0000</pubDate>
<dc:creator>肖朋伟</dc:creator>
<og:description>apk 反编译 最新版图文教程 结合网上众多教程，整理一篇自己操作的，工具都是目前最新版 apk 反编译也就是将打包后的 apk 反编译为资源文件(图片)、layout、样式、相关的实现代码等。（注：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xpwi/p/9892680.html</dc:identifier>
</item>
<item>
<title>Scala Try 与错误处理 - zzzzMing</title>
<link>http://www.cnblogs.com/listenfwind/p/9892614.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/listenfwind/p/9892614.html</guid>
<description>&lt;h3 id=&quot;一.概述&quot;&gt;一.概述&lt;/h3&gt;
&lt;p&gt;当你在尝试一门新的语言时，可能不会过于关注程序出错的问题， 但当真的去创造可用的代码时，就不能再忽视代码中的可能产生的错误和异常了。 鉴于各种各样的原因，人们往往低估了语言对错误处理支持程度的重要性。&lt;/p&gt;
&lt;p&gt;事实会表明，Scala 能够很优雅的处理此类问题， 这一部分，我会介绍 Scala 基于 Try 的错误处理机制，以及这背后的原因。 我将使用一个在 Scala 2.10 新引入的特性，该特性向 2.9.3 兼容， 因此，请确保你的 Scala 版本不低于 2.9.3。&lt;/p&gt;
&lt;h3 id=&quot;二.异常抛出与捕获&quot;&gt;二.异常抛出与捕获&lt;/h3&gt;
&lt;h4 id=&quot;其他语言的错误处理机制&quot;&gt;2.1 其他语言的错误处理机制&lt;/h4&gt;
&lt;p&gt;在介绍 Scala 错误处理的惯用法之前，我们先看看其他语言（如，Java，Ruby）的错误处理机制。 和这些语言类似，Scala 也允许你抛出异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;case class Customer(age: Int)
class Cigarettes
case class UnderAgeException(message: String) extends Exception(message)
def buyCigarettes(customer: Customer): Cigarettes =
  if (customer.age &amp;lt; 16)
    throw UnderAgeException(s&quot;Customer must be older than 16 but was ${customer.age}&quot;)
  else new Cigarettes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;被抛出的异常能够以类似 Java 中的方式被捕获，虽然是使用偏函数来指定要处理的异常类型。 此外，Scala 的 try/catch 是表达式（返回一个值），因此下面的代码会返回异常的消息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val youngCustomer = Customer(15)
try {
  buyCigarettes(youngCustomer)
  &quot;Yo, here are your cancer sticks! Happy smokin'!&quot;
} catch {
    case UnderAgeException(msg) =&amp;gt; msg
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;函数式的错误处理&quot;&gt;2.2 函数式的错误处理&lt;/h4&gt;
&lt;p&gt;现在，如果代码中到处是上面的异常处理代码，那它很快就会变得丑陋无比，和函数式程序设计非常不搭。 对于高并发应用来说，这也是一个很差劲的解决方式，比如， 假设需要处理在其他线程执行的 actor 所引发的异常，显然你不能用捕获异常这种处理方式， 你可能会想到其他解决方案，例如去接收一个表示错误情况的消息。&lt;/p&gt;
&lt;p&gt;一般来说，在 Scala 中，好的做法是通过从函数里返回一个合适的值来通知人们程序出错了。 别担心，我们不会回到 C 中那种需要使用按约定进行检查的错误编码的错误处理。 相反，Scala 使用一个特定的类型来表示可能会导致异常的计算，这个类型就是 Try。&lt;/p&gt;
&lt;h5 id=&quot;try-的语义&quot;&gt;Try 的语义&lt;/h5&gt;
&lt;p&gt;解释 Try 最好的方式是将它与 Option 作对比。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Option[A]&lt;/strong&gt; 是一个可能有值也可能没值的容器， &lt;strong&gt;Try[A]&lt;/strong&gt; 则表示一种计算： 这种计算在成功的情况下，返回类型为 A 的值，在出错的情况下，返回 Throwable 。 这种可以容纳错误的容器可以很轻易的在并发执行的程序之间传递。&lt;/p&gt;
&lt;p&gt;Try 有两个子类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Success[A]：代表成功的计算。&lt;/li&gt;
&lt;li&gt;封装了 Throwable 的 Failure[A]：代表出了错的计算。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果知道一个计算可能导致错误，我们可以简单的使用 Try[A] 作为函数的返回类型。 这使得出错的可能性变得很明确，而且强制客户端以某种方式处理出错的可能。&lt;/p&gt;
&lt;p&gt;假设，需要实现一个简单的网页爬取器：用户能够输入想爬取的网页 URL， 程序就需要去分析 URL 输入，并从中创建一个 java.net.URL ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import scala.util.Try
import java.net.URL
def parseURL(url: String): Try[URL] = Try(new URL(url))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如你所看到的，函数返回类型为 &lt;strong&gt;Try[URL]&lt;/strong&gt;： 如果给定的 url 语法正确，这将是 &lt;strong&gt;Success[URL]&lt;/strong&gt;， 否则， URL 构造器会引发 MalformedURLException ，从而返回值变成 &lt;strong&gt;Failure[URL]&lt;/strong&gt; 类型。&lt;/p&gt;
&lt;p&gt;上例中，我们还用了 &lt;strong&gt;Try&lt;/strong&gt; 伴生对象里的 &lt;strong&gt;apply&lt;/strong&gt; 工厂方法，这个方法接受一个类型为 A 的 传名参数， 这意味着， &lt;strong&gt;new URL(url)&lt;/strong&gt; 是在 &lt;strong&gt;Try&lt;/strong&gt; 的 &lt;strong&gt;apply&lt;/strong&gt; 方法里执行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;apply&lt;/strong&gt; 方法会捕获任何非致命的异常，返回一个包含相关异常的 &lt;strong&gt;Failure&lt;/strong&gt; 实例。&lt;/p&gt;
&lt;p&gt;因此， &lt;strong&gt;parseURL(&quot;&lt;a href=&quot;http://danielwestheide.com/&quot; class=&quot;uri&quot;&gt;http://danielwestheide.com&lt;/a&gt;&quot;)&lt;/strong&gt; 会返回一个 &lt;strong&gt;Success[URL]&lt;/strong&gt; ，包含了解析后的网址， 而 &lt;strong&gt;parseULR(&quot;garbage&quot;)&lt;/strong&gt; 将返回一个含有 &lt;strong&gt;MalformedURLException&lt;/strong&gt; 的 &lt;strong&gt;Failure[URL]&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;三.-使用-try&quot;&gt;三. 使用 Try&lt;/h3&gt;
&lt;h4 id=&quot;初步使用-try&quot;&gt;3.1 初步使用 Try&lt;/h4&gt;
&lt;p&gt;使用 &lt;strong&gt;Try&lt;/strong&gt; 与使用 &lt;strong&gt;Option&lt;/strong&gt; 非常相似，在这里你看不到太多新的东西。&lt;/p&gt;
&lt;p&gt;你可以调用 &lt;strong&gt;isSuccess&lt;/strong&gt; 方法来检查一个 &lt;strong&gt;Try&lt;/strong&gt; 是否成功，然后通过 &lt;strong&gt;get&lt;/strong&gt; 方法获取它的值， 但是，这种方式的使用并不多见，因为你可以用 &lt;strong&gt;getOrElse&lt;/strong&gt; 方法给 &lt;strong&gt;Try&lt;/strong&gt; 提供一个默认值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val url = parseURL(Console.readLine(&quot;URL: &quot;)) getOrElse new URL(&quot;http://duckduckgo.com&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果用户提供的 URL 格式不正确，我们就使用 DuckDuckGo 的 URL 作为备用。&lt;/p&gt;
&lt;h4 id=&quot;链式操作&quot;&gt;3.2 链式操作&lt;/h4&gt;
&lt;p&gt;Try 最重要的特征是，它也支持高阶函数，就像 Option 一样。 在下面的示例中，你将看到，在 Try 上也进行链式操作，捕获可能发生的异常，而且代码可读性不错。&lt;/p&gt;
&lt;h5 id=&quot;mapping-和-flat-mapping&quot;&gt;Mapping 和 Flat Mapping&lt;/h5&gt;
&lt;p&gt;将一个是 &lt;strong&gt;Success[A]&lt;/strong&gt; 的 &lt;strong&gt;Try[A]&lt;/strong&gt; 映射到 &lt;strong&gt;Try[B]&lt;/strong&gt; 会得到 &lt;strong&gt;Success[B]&lt;/strong&gt; 。 如果它是 &lt;strong&gt;Failure[A]&lt;/strong&gt; ，就会得到 &lt;strong&gt;Failure[B]&lt;/strong&gt; ，而且包含的异常和 &lt;strong&gt;Failure[A]&lt;/strong&gt; 一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;parseURL(&quot;http://danielwestheide.com&quot;).map(_.getProtocol)
// results in Success(&quot;http&quot;)
parseURL(&quot;garbage&quot;).map(_.getProtocol)
// results in Failure(java.net.MalformedURLException: no protocol: garbage)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果链接多个 &lt;strong&gt;map&lt;/strong&gt; 操作，会产生嵌套的 &lt;strong&gt;Try&lt;/strong&gt; 结构，这并不是我们想要的。 考虑下面这个返回输入流的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.io.InputStream
def inputStreamForURL(url: String): Try[Try[Try[InputStream]]] = parseURL(url).map { u =&amp;gt;
 Try(u.openConnection()).map(conn =&amp;gt; Try(conn.getInputStream))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于每个传递给 &lt;strong&gt;map&lt;/strong&gt; 的匿名函数都返回 &lt;strong&gt;Try&lt;/strong&gt;，因此返回类型就变成了 &lt;strong&gt;Try[Try[Try[InputStream]]]&lt;/strong&gt; 。&lt;br/&gt;这时候， &lt;strong&gt;flatMap&lt;/strong&gt; 就派上用场了。 &lt;strong&gt;Try[A]&lt;/strong&gt; 上的 &lt;strong&gt;flatMap&lt;/strong&gt; 方法接受一个映射函数，这个函数类型是 &lt;strong&gt;(A) =&amp;gt; Try[B]&lt;/strong&gt;。 如果我们的 &lt;strong&gt;Try[A]&lt;/strong&gt; 已经是 &lt;strong&gt;Failure[A]&lt;/strong&gt; 了，那么里面的异常就直接被封装成 &lt;strong&gt;Failure[B]&lt;/strong&gt; 返回， 否则， &lt;strong&gt;flatMap&lt;/strong&gt; 将 &lt;strong&gt;Success[A]&lt;/strong&gt; 里面的值解包出来，并通过映射函数将其映射到 &lt;strong&gt;Try[B]&lt;/strong&gt; 。&lt;br/&gt;这意味着，我们可以通过链接任意个 &lt;strong&gt;flatMap&lt;/strong&gt; 调用来创建一条操作管道，将值封装在 &lt;strong&gt;Success&lt;/strong&gt; 里一层层的传递。&lt;br/&gt;现在让我们用 &lt;strong&gt;flatMap&lt;/strong&gt; 来重写先前的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def inputStreamForURL(url: String): Try[InputStream] =
 parseURL(url).flatMap { u =&amp;gt;
   Try(u.openConnection()).flatMap(conn =&amp;gt; Try(conn.getInputStream))
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们就得到了一个 &lt;strong&gt;Try[InputStream]&lt;/strong&gt;， 它可以是一个 Failure，包含了在 &lt;strong&gt;flatMap&lt;/strong&gt; 过程中可能出现的异常； 也可以是一个 Success，包含了最后的结果。&lt;br/&gt;过滤器和 foreach&lt;/p&gt;
&lt;h5 id=&quot;过滤器和-foreach&quot;&gt;过滤器和 foreach&lt;/h5&gt;
&lt;p&gt;当然，你也可以对 Try 进行过滤，或者调用 &lt;strong&gt;foreach&lt;/strong&gt; ，如果你已经学过 &lt;strong&gt;Option&lt;/strong&gt;，对于这两个方法也不会陌生。&lt;/p&gt;
&lt;p&gt;当一个 Try 已经是 &lt;strong&gt;Failure&lt;/strong&gt; 了，或者传递给它的谓词函数返回假值，&lt;strong&gt;filter&lt;/strong&gt; 就返回 &lt;strong&gt;Failure&lt;/strong&gt; （如果是谓词函数返回假值，那 &lt;strong&gt;Failure&lt;/strong&gt; 里包含的异常是 &lt;strong&gt;NoSuchException&lt;/strong&gt; ）， 否则的话， &lt;strong&gt;filter&lt;/strong&gt; 就返回原本的那个 &lt;strong&gt;Success&lt;/strong&gt; ，什么都不会变：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def parseHttpURL(url: String) = parseURL(url).filter(_.getProtocol == &quot;http&quot;)
parseHttpURL(&quot;http://apache.openmirror.de&quot;) // results in a Success[URL]
parseHttpURL(&quot;ftp://mirror.netcologne.de/apache.org&quot;) // results in a Failure[URL]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当一个 &lt;strong&gt;Try&lt;/strong&gt; 是 &lt;strong&gt;Success&lt;/strong&gt; 时， &lt;strong&gt;foreach&lt;/strong&gt; 允许你在被包含的元素上执行副作用， 这种情况下，传递给 &lt;strong&gt;foreach&lt;/strong&gt; 的函数只会执行一次，毕竟 &lt;strong&gt;Try&lt;/strong&gt; 里面只有一个元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; parseHttpURL(&quot;http://danielwestheide.com&quot;).foreach(println)
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当 Try 是 Failure 时， foreach 不会执行，返回 Unit 类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;for-语句中的-try&quot;&gt;for 语句中的 Try&lt;/h5&gt;
&lt;p&gt;既然 &lt;strong&gt;Try&lt;/strong&gt; 支持 &lt;strong&gt;flatMap&lt;/strong&gt; 、 &lt;strong&gt;map&lt;/strong&gt; 、 &lt;strong&gt;filter&lt;/strong&gt; ，能够使用 for 语句也是理所当然的事情， 而且这种情况下的代码更可读。 为了证明这一点，我们来实现一个返回给定 URL 的网页内容的函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import scala.io.Source
def getURLContent(url: String): Try[Iterator[String]] =
  for {
   url &amp;lt;- parseURL(url)
   connection &amp;lt;- Try(url.openConnection())
   is &amp;lt;- Try(connection.getInputStream)
   source = Source.fromInputStream(is)
  } yield source.getLines()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法中，有三个可能会出错的地方，但都被 Try 给涵盖了。 第一个是我们已经实现的 &lt;strong&gt;parseURL&lt;/strong&gt; 方法， 只有当它是一个 &lt;strong&gt;Success[URL]&lt;/strong&gt; 时，我们才会尝试打开连接，从中创建一个新的 &lt;strong&gt;InputStream&lt;/strong&gt; 。 如果这两步都成功了，我们就 &lt;strong&gt;yield&lt;/strong&gt; 出网页内容，得到的结果是 &lt;strong&gt;Try[Iterator[String]]&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;当然，你可以使用 &lt;strong&gt;Source#fromURL&lt;/strong&gt; 简化这个代码，并且，这个代码最后没有关闭输入流， 这都是为了保持例子的简单性，专注于要讲述的主题。&lt;/p&gt;
&lt;p&gt;在这个例子中，&lt;strong&gt;Source#fromURL&lt;/strong&gt;可以这样用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import scala.io.Source
def getURLContent(url: String): Try[Iterator[String]] =
  for {
    url &amp;lt;- parseURL(url)
    source = Source.fromURL(url)
  } yield source.getLines()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用 is.close() 可以关闭输入流。&lt;/p&gt;
&lt;h5 id=&quot;模式匹配&quot;&gt;模式匹配&lt;/h5&gt;
&lt;p&gt;代码往往需要知道一个 Try 实例是 Success 还是 Failure，这时候，你应该想到模式匹配， 也幸好， &lt;strong&gt;Success&lt;/strong&gt; 和 &lt;strong&gt;Failure&lt;/strong&gt; 都是样例类。&lt;/p&gt;
&lt;p&gt;接着上面的例子，如果网页内容能顺利提取到，我们就展示它，否则，打印一个错误信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import scala.util.Success
import scala.util.Failure
getURLContent(&quot;http://danielwestheide.com/foobar&quot;) match {
  case Success(lines) =&amp;gt; lines.foreach(println)
  case Failure(ex) =&amp;gt; println(s&quot;Problem rendering URL content: ${ex.getMessage}&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;从故障中恢复&quot;&gt;从故障中恢复&lt;/h5&gt;
&lt;p&gt;如果想在失败的情况下执行某种动作，没必要去使用 &lt;strong&gt;getOrElse&lt;/strong&gt;， 一个更好的选择是 &lt;strong&gt;recover&lt;/strong&gt; ，它接受一个偏函数，并返回另一个 Try。 如果 &lt;strong&gt;recover&lt;/strong&gt; 是在 Success 实例上调用的，那么就直接返回这个实例，否则就调用偏函数。 如果偏函数为给定的 &lt;strong&gt;Failure&lt;/strong&gt; 定义了处理动作， &lt;strong&gt;recover&lt;/strong&gt; 会返回 &lt;strong&gt;Success&lt;/strong&gt; ，里面包含偏函数运行得出的结果。&lt;/p&gt;
&lt;p&gt;下面是应用了 recover 的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.net.MalformedURLException
import java.io.FileNotFoundException
val content = getURLContent(&quot;garbage&quot;) recover {
  case e: FileNotFoundException =&amp;gt; Iterator(&quot;Requested page does not exist&quot;)
  case e: MalformedURLException =&amp;gt; Iterator(&quot;Please make sure to enter a valid URL&quot;)
  case _ =&amp;gt; Iterator(&quot;An unexpected error has occurred. We are so sorry!&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，我们可以在返回值 &lt;strong&gt;content&lt;/strong&gt; 上安全的使用 &lt;strong&gt;get&lt;/strong&gt; 方法了，因为它一定是一个 &lt;strong&gt;Success&lt;/strong&gt;。 调用 &lt;strong&gt;content.get.foreach(println)&lt;/strong&gt; 会打印 Please make sure to enter a valid URL。&lt;/p&gt;
&lt;h3 id=&quot;四.-总结&quot;&gt;四. 总结&lt;/h3&gt;
&lt;p&gt;Scala 的错误处理和其他范式的编程语言有很大的不同。 Try 类型可以让你将可能会出错的计算封装在一个容器里，并优雅的去处理计算得到的值。 并且可以像操作集合和 Option 那样统一的去操作 Try。&lt;/p&gt;
&lt;p&gt;Try 还有其他很多重要的方法，鉴于篇幅限制，这一章并没有全部列出，比如 &lt;strong&gt;orElse&lt;/strong&gt; 方法， &lt;strong&gt;transform&lt;/strong&gt; 和 &lt;strong&gt;recoverWith&lt;/strong&gt; 也都值得去看。&lt;/p&gt;
&lt;p&gt;文章转自：&lt;a href=&quot;https://windor.gitbooks.io/beginners-guide-to-scala/content/chp6-error-handling-with-try.html&quot; class=&quot;uri&quot;&gt;https://windor.gitbooks.io/beginners-guide-to-scala/content/chp6-error-handling-with-try.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Nov 2018 13:20:00 +0000</pubDate>
<dc:creator>zzzzMing</dc:creator>
<og:description>一.概述 当你在尝试一门新的语言时，可能不会过于关注程序出错的问题， 但当真的去创造可用的代码时，就不能再忽视代码中的可能产生的错误和异常了。 鉴于各种各样的原因，人们往往低估了语言对错误处理支持程度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/listenfwind/p/9892614.html</dc:identifier>
</item>
<item>
<title>Raspberry Zero 上实现平滑视频图传 - Ray Liang</title>
<link>http://www.cnblogs.com/Ray-liang/p/9892334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ray-liang/p/9892334.html</guid>
<description>&lt;p&gt;在某些应用场合我们可能需要通过一个设备通过WIFI将图像传到其它的机器进行显示或者图形分析，那怎么可以低成本地实现呢？其实很简单，我们只需要一块 Raspberry Zero W 和一个RPI 摄像头就行了，两个加起来成本也只不过150左右。&lt;/p&gt;
&lt;p&gt;这个组合不单单只是实现一个图传，最重要的是Raspberry Zero上运行的是Linux，它几乎可以运行我们各种各样的代码。将它作为一个小型的编程平台也未尝不可。&lt;/p&gt;
&lt;p&gt;由于硬件部分太简单了没有必要浪费篇幅过多地讲述，那就直接进入软件部分。实现图传必然有两端：发送端与接收端。&lt;/p&gt;
&lt;p&gt;发送端 - 运行于Raspberry Zero通过OpenCV直接读取视频流，然后将数据写入到Socket中发送出去。如果实时传递的话可能会由于网络通信等的各种原因导致丢包，或者说由于失去有效的网络连接而引发程序的异常，为了防止这种情况出现我使用了pyzmq这个包，发送端也是消息的发布方，将Socket的处理放到消息队列中，当订阅方从消息队列中读取信息时就从Socket中拿出排队的数据，这样处理起来就平滑多了。&lt;/p&gt;
&lt;p&gt;接收端 - 可运行于所有能运行python环境的平台，它只负责从Socket中读取流数据然后通过OpenCV显示到窗口中，也是消息的订阅方。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Python 中的Socket使用可以说是在众多语言中最简单的，关于Socket的知识在此不多讲，不懂的朋友可以先去找些资料先学习一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;发布方与订阅方都需要安装pyzmq：&lt;/p&gt;
&lt;h2 id=&quot;安装-pyzmq&quot;&gt;安装 pyzmq&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;$ pip install pyzmq&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果在树莓上安装pyzmq会非常慢可能要等个10来20分钟的，不要以为你的树莓挂了只是Raspberry Zero性能实在太低要进行本机编译实在是一件非常痛苦之事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;发布方---streamer&quot;&gt;发布方 - Streamer&lt;/h2&gt;
&lt;p&gt;Raspberry Zero 端的发布方的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import base64
import cv2
import zmq

context = zmq.Context()
footage_socket = context.socket(zmq.PUB)
footage_socket.connect('tcp://*:5555')

camera = cv2.VideoCapture(0)  
while True:
    try:
        success, frame = camera.read() 
        if not success:
           break;
        frame = cv2.resize(frame, (640, 480))  # 将每一帧的画面大小设置为640x480
        encoded, buffer = cv2.imencode('.jpg', frame)
        jpg_as_text = base64.b64encode(buffer)
        footage_socket.send(jpg_as_text)

    except KeyboardInterrupt:
        camera.release()
        cv2.destroyAllWindows()
        break&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理非常简单就是将每一帧的画面先转成base64的编码格式以字符流的方式写入到socket中传出去。&lt;/p&gt;
&lt;p&gt;运行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pi $ python streamer.py &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;订阅方-viewer&quot;&gt;订阅方 Viewer&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import cv2
import zmq
import base64
import numpy as np

context = zmq.Context()
footage_socket = context.socket(zmq.SUB)
footage_socket.bind('tcp://10.0.0.25:5555') # 这里需要指定Steamer的发地址
footage_socket.setsockopt_string(zmq.SUBSCRIBE, np.unicode(''))

while True:
    try:
        source = footage_socket.recv_string()
        img = base64.b64decode(source)
        npimg = np.fromstring(img, dtype=np.uint8)
        frame = cv2.imdecode(npimg, 1)
        frame = cv2.flip(frame, flipCode=-1)
        cv2.imshow(&quot;Stream&quot;, frame)
        cv2.waitKey(1)

    except KeyboardInterrupt:
        cv2.destroyAllWindows()
        break&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 01 Nov 2018 12:38:00 +0000</pubDate>
<dc:creator>Ray Liang</dc:creator>
<og:description>在某些应用场合我们可能需要通过一个设备通过WIFI将图像传到其它的机器进行显示或者图形分析，那怎么可以低成本地实现呢？其实很简单，我们只需要一块 Raspberry Zero W 和一个RPI 摄像头</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ray-liang/p/9892334.html</dc:identifier>
</item>
</channel>
</rss>