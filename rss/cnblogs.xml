<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>DirectSound---简易Wav播放器 - lgxZJ</title>
<link>http://www.cnblogs.com/lgxZJ/p/8449442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lgxZJ/p/8449442.html</guid>
<description>&lt;p&gt;这篇文章主要给大家介绍下如何用DirectSound打造一个简易播放器，因为篇幅有限且代码逻辑较为复杂，我们只介绍下核心技术内容。该播放器主要包括以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;播放、暂停&lt;/li&gt;
&lt;li&gt;播放进度提示。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;directsound播放概念简介&quot;&gt;1. DirectSound播放概念简介&lt;/h2&gt;
&lt;h3 id=&quot;播放相关概念&quot;&gt;1.1 播放相关概念&lt;/h3&gt;
&lt;p&gt;首先要介绍下DirectSound的设计理念：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/02/14/5a8440af1d779.png&quot; alt=&quot;buffer-pic&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在DirectSound中，你需要播放的音频一般需要（也可以直接放入主缓冲区，但是操作上比较困难而且对其他DirectSound程序不太友好）放入一个被称为&lt;strong&gt;次缓冲区&lt;/strong&gt;（Secondary Buffer）的地址区域中，该缓冲区由开发者人为创建操控。由于DirectSound支持多个音频同时播放，所以我们可以创建多个缓冲区并同时播放。在播放时，放入次缓冲区的音频先会被送入一个叫做&lt;strong&gt;主缓冲区&lt;/strong&gt;（Primary Buffer）的地方进行混音，然后在送入硬件声卡中进行播放。在Windows driver model，即WDM模式下，DirectSound实际上不能直接操作声卡硬件，所有的混音操作不是送给主缓冲区而是被&lt;strong&gt;送往内核混音器&lt;/strong&gt;（Kernel Mixer）进行混音，然后由内核混音器送往硬件。在WDM模式下，内核混音器替代了主缓冲区的功能位置。&lt;/p&gt;
&lt;h3 id=&quot;缓冲区相关概念&quot;&gt;1.2 缓冲区相关概念&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/02/14/5a84440c5777b.png&quot; alt=&quot;circle-buffer&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DirectSound的缓冲区类别大体可以分为两种：1) &lt;strong&gt;静态缓冲区&lt;/strong&gt;，2) &lt;strong&gt;流缓冲区&lt;/strong&gt;。静态缓冲区就是一段较短的音频全部填充到一个缓冲区中，然后从头到尾播放；流缓冲区可以描述为音频流，实际上这种流也是通过单个有长度的缓冲区来抽象模拟的。在流缓冲区模式下，单个缓冲区会被&lt;strong&gt;重复填充和播放&lt;/strong&gt;，也就是说当DirectSound播放到缓冲区的最后一个尾部时，它会回到缓冲区的头部继续开始播放。因此，在播放较长的音频文件时需要开发者手动循环填充缓冲区。&lt;/p&gt;
&lt;p&gt;DirectSound中还有游标（cursor）的概念，游标分两种：1) &lt;strong&gt;播放游标&lt;/strong&gt;（play cusror），2) &lt;strong&gt;写入游标&lt;/strong&gt;（write cursor）。顾名思义，播放游标指向当前播放的地址，写入游标指向当前&lt;strong&gt;可以写入的开始地址&lt;/strong&gt;，写入游标总是在播放游标前面，且两者之间的数据块已经被DirectSound预定，不能被写入。其中，播放指针可以通过函数来更改，而写入指针由DirectSound自己控制，开发者不能操作它。一旦次缓冲区设定好音频格式，在播放中这两个游标会一直保持固定的间距：如果没记错，采样率44100Hz、2声道、8比特的音频数据，两者的位置间隔660字节，也就是&lt;code&gt;1/70&lt;/code&gt;秒的数据。&lt;/p&gt;
&lt;p&gt;为了在适当的时候填充下一块要播放的数据，DirectSound提供了&lt;strong&gt;notify&lt;/strong&gt;的功能：当播放到某一个缓冲区位置的时候，他会提醒你。该notify功能的实现通过Windows的事件对象（Event Object）实现，也就是说你需要等待这个事件被唤醒，在GUI程序中，这通常意味着你需要另起一个线程。&lt;/p&gt;
&lt;h2 id=&quot;播放器实现&quot;&gt;2. 播放器实现&lt;/h2&gt;
&lt;h3 id=&quot;创建缓冲区&quot;&gt;2.1 创建缓冲区&lt;/h3&gt;
&lt;p&gt;通过调用&lt;code&gt;IDirectSound8::CreateSoundBuffer(...)&lt;/code&gt;函数，我们创建一个能够容纳&lt;em&gt;seconds&lt;/em&gt;秒的次缓冲区。参数DSBUFFERDESC中需要指定&lt;code&gt;DSBCAPS_CTRLPOSITIONNOTIFY、DSBCAPS_GETCURRENTPOSITION2&lt;/code&gt;，前者允许我们设置notify，后者保证我们在调用&lt;code&gt;IDirectSoundBuffer8::GetCurrentPosition(...)&lt;/code&gt;时播放游标的位置比较准确。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void WavPlayer::createBufferOfSeconds(unsigned seconds)
{
    DSBUFFERDESC bufferDescription;
    bufferDescription.dwSize = sizeof(bufferDescription);
    bufferDescription.dwFlags = DSBCAPS_CTRLPOSITIONNOTIFY |
                                DSBCAPS_GLOBALFOCUS |
                                DSBCAPS_GETCURRENTPOSITION2 |
                                DSBCAPS_LOCDEFER ;
    bufferDescription.dwBufferBytes = m_secondaryBufferSize
                                    = m_wavFile.getWaveFormat().nAvgBytesPerSec * seconds;
    bufferDescription.dwReserved = 0;
    bufferDescription.lpwfxFormat = &amp;amp;m_wavFile.getWaveFormat();
    bufferDescription.guid3DAlgorithm = GUID_NULL;

    IDirectSoundBuffer* soundBuffer;
    if (m_directSound8-&amp;gt;CreateSoundBuffer(&amp;amp;bufferDescription, &amp;amp;soundBuffer, NULL) != DS_OK) {
        throw std::exception(&quot;create secondary buffer failed:CreateSoundBuffer&quot;);
    }

    if (soundBuffer-&amp;gt;QueryInterface(IID_IDirectSoundBuffer8, (LPVOID*)&amp;amp;m_soundBufferInterface)
            != S_OK) {
        throw std::exception(&quot;IDirectSoundBuffer8 interface not supported!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;预填充缓冲区&quot;&gt;2.2 预填充缓冲区&lt;/h3&gt;
&lt;p&gt;本人尝试过直接在缓冲区头部设置notify，使数据的填充比较自然。大多数情况下这样没有问题，但是在电脑cpu负载较高时会造成音频毛刺，效果不尽如人意。因此我选择预填充数据，防止这类情况出现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void WavPlayer::fillDataIntoBuffer()
{
    Q_ASSERT(m_bufferSliceCount &amp;gt; 1);

    //  fill half buffer to signal the notify event to do next data filling
    LPVOID firstAudioAddress;
    LPVOID secondAudioAddress;
    DWORD  firstAudioBytes;
    DWORD  secondAudioBytes;
    HRESULT result = m_soundBufferInterface-&amp;gt;Lock(0,
                                    m_secondaryBufferSize / m_bufferSliceCount,
                                    &amp;amp;firstAudioAddress, &amp;amp;firstAudioBytes,
                                    &amp;amp;secondAudioAddress, &amp;amp;secondAudioBytes,
                                    0);
    if (result == DSERR_BUFFERLOST) {
        result = m_soundBufferInterface-&amp;gt;Restore();
    }
    if (result != DS_OK) {
        throw std::exception(&quot;Cannot lock entire secondary buffer(restore tryed)&quot;);
    }

    Q_ASSERT(firstAudioBytes == m_secondaryBufferSize / m_bufferSliceCount &amp;amp;&amp;amp;
            secondAudioAddress == nullptr &amp;amp;&amp;amp;
            secondAudioBytes == 0);
    m_nextDataToPlay = static_cast&amp;lt;char*&amp;gt;(m_wavFile.getAudioData());
    CopyMemory(firstAudioAddress, m_nextDataToPlay, firstAudioBytes);
    if (m_soundBufferInterface-&amp;gt;Unlock(firstAudioAddress, firstAudioBytes,
                                    secondAudioAddress, secondAudioBytes)
            != DS_OK) {
        throw std::exception(&quot;Unlick failed when fill data into secondary buffer&quot;);
    }

    m_nextDataToPlay += firstAudioBytes;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设置缓冲区notify&quot;&gt;2.3 设置缓冲区notify&lt;/h3&gt;
&lt;p&gt;为了在运行时循环填充数据，我们先要设置notify，这里的notify比较复杂，包含了3种类别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据填充notify。&lt;/li&gt;
&lt;li&gt;音频播放终止notify。&lt;/li&gt;
&lt;li&gt;退出notify。（为了优雅的退出填充线程，我们选择在退出播放时唤醒线程）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，第二种notify可能会也可能不会与第一种notify重合，在不重合情况下我们才新分配一个notify：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;m_additionalNotifyIndex = 0;
if (m_additionalEndNotify)
    for (unsigned i = 1; i &amp;lt; m_bufferSliceCount; ++i)
        if (bufferEndOffset &amp;lt; (m_secondaryBufferSize / m_bufferSliceCount * i)) {
            m_additionalNotifyIndex = i;
            break;
        }

//  add a stop notify count at the end of entire notifies to make the data filling
//  thread exit gracefully
++m_notifyCount;
m_notifyHandles = static_cast&amp;lt;HANDLE*&amp;gt;(malloc(sizeof(HANDLE)* (m_notifyCount)));
if (m_notifyHandles == nullptr)
    throw std::exception(&quot;malloc error&quot;);
m_notifyOffsets = static_cast&amp;lt;DWORD*&amp;gt;(malloc(sizeof(DWORD)* (m_notifyCount)));
if (m_notifyHandles == nullptr)
    throw std::exception(&quot;malloc error&quot;);

for (unsigned i = 0; i &amp;lt; m_notifyCount; ++i) {
    m_notifyHandles[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_notifyHandles[i] == NULL)
        throw std::exception(&quot;CreateEvent error&quot;);

    if (m_additionalEndNotify &amp;amp;&amp;amp; i == m_additionalNotifyIndex) {
        //  set buffer end notify
        m_notifyOffsets[i] = bufferEndOffset;
        m_endNotifyHandle = m_notifyHandles[i];
    }
    else if (i == m_notifyCount - 1) {
        //  do nothing
    } else {
        //  NOTE:   the entire buffer size must can be devided by this `notifyCount`,
        //  or it will lost some bytes when filling data into the buffer. since the end
        //  notify is inside the notify count, we need to calculate the buffer slice index.
        unsigned bufferSliceIndex = getBufferIndexFromNotifyIndex(i);
        m_notifyOffsets[i] = m_secondaryBufferSize / m_bufferSliceCount * bufferSliceIndex;
        
        if (!m_additionalEndNotify &amp;amp;&amp;amp; m_notifyOffsets[i] == bufferEndOffset)
            m_endNotifyHandle = m_notifyHandles[i];
    }
}
//  skip the exit notify which we toggle explicitly
setNotifyEvent(m_notifyHandles, m_notifyOffsets, m_notifyCount - 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建数据填充线程播放进度更新&quot;&gt;2.4 创建数据填充线程、播放进度更新&lt;/h3&gt;
&lt;p&gt;该线程一直等待多个notify，并对不同情况进行不同的处理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;播放终止notify，则发出终止信号、退出线程。&lt;/li&gt;
&lt;li&gt;数据填充notify，则填充数据、更新播放进度。&lt;/li&gt;
&lt;li&gt;非终止非数据填充notify（发生在数据填充完成但播放未结束时），continue。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;DWORD WINAPI WavPlayer::dataFillingThread(LPVOID param)&lt;br/&gt;{&lt;br/&gt;WavPlayer* wavPlayer = reinterpret_cast&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while (!wavPlayer-&amp;gt;m_quitDataFillingThread) {
    try {
        DWORD notifyIndex = WaitForMultipleObjects(wavPlayer-&amp;gt;m_notifyCount, wavPlayer-&amp;gt;m_notifyHandles, FALSE, INFINITE);
        if (!(notifyIndex &amp;gt;= WAIT_OBJECT_0 &amp;amp;&amp;amp;
              notifyIndex &amp;lt;= WAIT_OBJECT_0 + wavPlayer-&amp;gt;m_notifyCount - 1))

            throw std::exception(&quot;WaitForSingleObject error&quot;);

        if (notifyIndex == wavPlayer-&amp;gt;m_notifyCount - 1)
            break;

        //  each notify represents one second(or approximately one second) except the exit notify
        if (!(wavPlayer-&amp;gt;m_additionalNotifyIndex == notifyIndex &amp;amp;&amp;amp; wavPlayer-&amp;gt;m_endNotifyLoopCount &amp;gt; 0)) {
            ++wavPlayer-&amp;gt;m_currentPlayingTime;
            wavPlayer-&amp;gt;sendProgressUpdatedSignal();
        }

        //  if return false, the audio ends
        if (tryToFillNextBuffer(wavPlayer, notifyIndex) == false) {
            wavPlayer-&amp;gt;stop();

            ++wavPlayer-&amp;gt;m_currentPlayingTime;
            wavPlayer-&amp;gt;sendProgressUpdatedSignal();

            wavPlayer-&amp;gt;sendAudioEndsSignal();
            //  not break the loop, we need to update the audio progress although data filling ends
        }
    }
    catch (std::exception&amp;amp; exception) {
        OutputDebugStringA(&quot;exception in data filling thread:&quot;);
        OutputDebugStringA(exception.what());
    }
}
return 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2 id=&quot;运行结果&quot;&gt;3. 运行结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/02/15/5a851af71dd92.png&quot; alt=&quot;result1&quot;/&gt;&lt;img src=&quot;https://i.loli.net/2018/02/15/5a851af70ddfa.png&quot; alt=&quot;result2&quot;/&gt;&lt;img src=&quot;https://i.loli.net/2018/02/15/5a851af71dd8f.png&quot; alt=&quot;result3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整代码见&lt;a href=&quot;https://github.com/lgxZJ/Miscellaneous/tree/master/Audio/DirectSoundPlay&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Thu, 15 Feb 2018 05:36:00 +0000</pubDate>
<dc:creator>lgxZJ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lgxZJ/p/8449442.html</dc:identifier>
</item>
<item>
<title>发放春节福利，ASP.NET Core断点续传 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/8449414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/8449414.html</guid>
<description>&lt;h2 id=&quot;asp.net-core断点续传&quot;&gt;ASP.NET Core断点续传&lt;/h2&gt;
&lt;p&gt;在ASP.NET WebAPi写过完整的断点续传文章，目前我对ASP.NET Core仅止于整体上会用，对于原理还未去深入学习，由于有园友想看断点续传在ASP.NET Core中的具体实现，于是借助在家中休息时间看了下ASP.NET Core是否支持断点续传以及支持后具体实现以及相关APi，花了一点时间，本文而由此而生。&lt;/p&gt;
&lt;h2 id=&quot;断点续传基础&quot;&gt;断点续传基础&lt;/h2&gt;
&lt;p&gt;此前在ASP.NET WebAPi中对于一些基础内容已经详细讲解过，同时也进行了封装，所以再处理ASP.NET Core不过是APi使用不同罢了，断点续传重点在于AcceptRange和ContentRange以及对应响应请求头设置，其余和ASP.NET WebAPi使用别无二致。&lt;/p&gt;
&lt;p&gt;在ASP.NET WebAPi中我们封装了对文件的操作接口IFileProvider和具体实现FileProvider，在控制器中我们是直接实例化，在ASP.NET Core中有了依赖注入，我们可直接借助控制器构造函数注入接口。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();

    services.AddScoped&amp;lt;IFileProvider, FileProvider&amp;gt;();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然前提是新建一个ASP.NET Core Web应用程序，然后我们新建一个DownLoadController控制器。在ASP.NET WebAPi中对于请求-响应机制对象是HttpRequestMessage和HttpResponseMessage，而在ASP.NET Core则是HttpRequest和HttpResponse对象。那么我们在控制器中如何获取这两个对象中呢？如果我们稍微有点经验的话就能明了请求和响应对象必然存储在上下文中，那么我们又如何获取上下文呢？通过IHttpContextAccessor接口获取。所以在控制器构造函数中获取文件接口和上下文以及对应的常量如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private const int BufferSize = 80 * 1024;

private const string MimeType = &quot;application/octet-stream&quot;;
public IFileProvider _fileProvider { get; set; }

private IHttpContextAccessor _contextAccessor;
private HttpContext _context { get { return _contextAccessor.HttpContext; } }
public FileDownloadController(
    IFileProvider fileProvider,
    IHttpContextAccessor contextAccessor)
{
    _fileProvider = fileProvider;
    _contextAccessor = contextAccessor;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ASP.NET WebAPi中获取请求头Range利用请求中的Headers属性获取，但在ASP.NET Core中则需要通过请求中的GetTypedHeaders()方法获取。&lt;/p&gt;
&lt;p&gt;ASP.NET Core对于请求头中参数的获取和值的设置更加友好，比如我们要获取请求头中的请求类型，在ASP.NET WebAPi中我们指定字符串Request.Headers[&quot;Content-Type&quot;]，而在ASP.NET Core中则对应的是Request.Headers[HeaderNames.ContentType]，直接通过枚举指定，如此一来则省事多了。最终在DownLoadController控制器中对于在ASP.NET Core中断点续传的整个逻辑如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class FileDownloadController
{
    private const int BufferSize = 80 * 1024;

    private const string MimeType = &quot;application/octet-stream&quot;;
    public IFileProvider _fileProvider { get; set; }

    private IHttpContextAccessor _contextAccessor;
    private HttpContext _context { get { return _contextAccessor.HttpContext; } }
    public FileDownloadController(
        IFileProvider fileProvider,
        IHttpContextAccessor contextAccessor)
    {
        _fileProvider = fileProvider;
        _contextAccessor = contextAccessor;
    }


    /// &amp;lt;summary&amp;gt;
    /// 下载文件
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    [HttpGet(&quot;api/download&quot;)]
    public IActionResult GetFile(string fileName)
    {
        fileName = &quot;cn_windows_8_1_x64_dvd_2707237.iso&quot;;

        if (!_fileProvider.Exists(fileName))
        {
            return new StatusCodeResult(StatusCodes.Status404NotFound);
        }

        //获取下载文件长度
        var fileLength = _fileProvider.GetLength(fileName);

        //初始化下载文件信息
        var fileInfo = GetFileInfoFromRequest(_context.Request, fileLength);

        //获取剩余部分文件流
        var stream = new PartialContentFileStream(_fileProvider.Open(fileName),
                                             fileInfo.From, fileInfo.To);
        //设置响应 请求头
        SetResponseHeaders(_context.Response, fileInfo, fileLength, fileName);

        return new FileStreamResult(stream, new MediaTypeHeaderValue(MimeType));
    }


    /// &amp;lt;summary&amp;gt;
    /// 根据请求信息赋予封装的文件信息类
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;request&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;entityLength&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private FileInfo GetFileInfoFromRequest(HttpRequest request, long entityLength)
    {
        var fileInfo = new FileInfo
        {
            From = 0,
            To = entityLength - 1,
            IsPartial = false,
            Length = entityLength
        };

        var requestHeaders = request.GetTypedHeaders();

        if (requestHeaders.Range != null &amp;amp;&amp;amp; requestHeaders.Range.Ranges.Count &amp;gt; 0)
        {
            var range = requestHeaders.Range.Ranges.FirstOrDefault();
            if (range.From.HasValue &amp;amp;&amp;amp; range.From &amp;lt; 0 || range.To.HasValue &amp;amp;&amp;amp; range.To &amp;gt; entityLength - 1)
            {
                return null;
            }

            var start = range.From;
            var end = range.To;

            if (start.HasValue)
            {
                if (start.Value &amp;gt;= entityLength)
                {
                    return null;
                }
                if (!end.HasValue || end.Value &amp;gt;= entityLength)
                {
                    end = entityLength - 1;
                }
            }
            else
            {
                if (end.Value == 0)
                {
                    return null;
                }

                var bytes = Math.Min(end.Value, entityLength);
                start = entityLength - bytes;
                end = start + bytes - 1;
            }

            fileInfo.IsPartial = true;
            fileInfo.Length = end.Value - start.Value + 1;
        }      
        return fileInfo;
    }

    /// &amp;lt;summary&amp;gt;
    /// 设置响应头信息
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;response&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;fileInfo&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;fileLength&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;fileName&quot;&amp;gt;&amp;lt;/param&amp;gt;
    private void SetResponseHeaders(HttpResponse response, FileInfo fileInfo,
                                  long fileLength, string fileName)
    {
        response.Headers[HeaderNames.AcceptRanges] = &quot;bytes&quot;;
        response.StatusCode = fileInfo.IsPartial ? StatusCodes.Status206PartialContent
                                  : StatusCodes.Status200OK;

        var contentDisposition = new ContentDispositionHeaderValue(&quot;attachment&quot;);
        contentDisposition.SetHttpFileName(fileName);
        response.Headers[HeaderNames.ContentDisposition] = contentDisposition.ToString();
        response.Headers[HeaderNames.ContentType] = MimeType;
        response.Headers[HeaderNames.ContentLength] = fileInfo.Length.ToString();
        if (fileInfo.IsPartial)
        {
            response.Headers[HeaderNames.ContentRange] = new ContentRangeHeaderValue(fileInfo.From, fileInfo.To, fileLength).ToString();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/589642/201802/589642-20180215130934077-1703033212.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;ASP.NET Core中FileResult、FileStreamResult、FilePhsicalResult都已支持断点续传，如果对于很小的文件直接下载即可，如果稍微大一点文件则可利用断点续传即可，如果对于非常大的文件则需要自定义流来下载这样更高效，比如对于获取视频流文件。上述我们依然是采取自定义流的形式来实现断点续传，若对其中封装的自定义流和接口有疑惑请移步右上角我的github参看ASP.NET WebAPi具体实现。无论是ASP.NET WebAPi和ASP.NET Core断点续传都实现了核心逻辑，对于一些细节未考虑其中，希望对想学习断点续传的您有所帮助，祝您阅读愉快，新年快乐！完整代码，我会上传到github！&lt;/p&gt;
</description>
<pubDate>Thu, 15 Feb 2018 05:17:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CreateMyself/p/8449414.html</dc:identifier>
</item>
<item>
<title>Java对象序列化 - zxzhang</title>
<link>http://www.cnblogs.com/zzy19961112/p/8447656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzy19961112/p/8447656.html</guid>
<description>&lt;h2&gt;&lt;span&gt;为什么需要序列化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  当我们创建对象时，只要需要，对象就会一直存在，但在程序终止的时候，无论如何它都不会继续存在。这么做有一定的意义，但是如果对象能够在程序不运行的情况下仍能存在并保存其信息，这样，在下次运行程序时，该对象将被重建并且拥有的信息与在程序上次运行时它所拥有的信息相同。为达到这目的，通常的做法可以写入文件或数据库，这样有其优点，但缺乏了某些便利性，在Java中，通过序列化技术，可以将对象声明为“持久性”的，为我们处理所有细节，显得十分方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  Java的对象序列化将那些实现了 Serializable 接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象，这一过程甚至可以通过网络进行，也意味着能自动弥补不同操作系统之间的差异，运行在 Windows 系统的计算机上创建一个对象并序列化，通过网络将其发送给一台运行 Unix 系统的计算机，不必担心数据在不同机器上表示不同从而在那里重新组装。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;序列化的用途&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  利用对象序列化可以实现轻量级持久性。”持久性“意味着一个对象的生存周期并不取决于程序是否正在执行，它可以生存于程序的调用之间。通过将一个序列化对象写入磁盘，然后重新调用程序时恢复该对象，就能够实现持久化的效果。对象序列化主要用于两个方面&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;远程方法调用（Remote Method Invocation，RMI），使存活于其他计算机上的对象使用起来就像是存活于本机上一样，当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Java Beans。使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置，这种状态信息必须保存下来，并在程序启动时进行后期恢复，这种具体工作就是由对象序列化完成的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;如何实现序列化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  要序列化一个对象，首先要创建某些OutputStream对象，然后将其封装在一个ObjectOutputStream对象内。这时，只需调用writeObject()即可将对象序列化，并将其发送个 OutputStream（对象化序列是基于字节的，因要使用 InputStream 和 OutputStream 继承层次结构）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  反向序列化（即将一个序列还原为一个对象），需要将一个 InputStream 封装在 ObjectInputStream 内，然后调用 readObject()。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.io.*&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;SerializableDemo&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; Serializable&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String&lt;span&gt;[]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
        User user &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; User&lt;span&gt;();&lt;/span&gt;
        user&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        user&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPasswd&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;world&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;

        &lt;span&gt;//write Obj to File&lt;/span&gt;
        ObjectOutputStream oos &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;user&lt;span&gt;);&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;

        &lt;span&gt;//read Obj from File&lt;/span&gt;
        File file &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; File&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        ObjectInputStream ois &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectInputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream&lt;span&gt;(&lt;/span&gt;file&lt;span&gt;));&lt;/span&gt;
        User newUser &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt;ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        System&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newUser&lt;span&gt;);&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; Serializable&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String passwd&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getUsername&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String username&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;username&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getPasswd&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; passwd&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setPasswd&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String passwd&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; passwd&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;username = &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; getUsername&lt;span&gt;()&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;
                &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;passwd = &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; getPasswd&lt;span&gt;();&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;Output:&lt;/span&gt;
&lt;span&gt;username = hello&lt;/span&gt;
&lt;span&gt;passwd = world&lt;/span&gt;
&lt;span&gt; */&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  此外，还可以通过实现 Externalizable 接口——代替实现Serializable接口——来对序列化进行控制。这个 Externalizable 接口继承了 Serialazable 接口，同时增添了两个方法： writeExternal() 和 readExternal()，这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊操作。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;transient（瞬时）关键字&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  当我们对序列化进行控制时，可能不想让 Java 的序列化机制自动保存与恢复某些敏感信息字段，比如密码，即使这些字段是私有属性，一经序列化处理，人们就可以通过读取文件或者拦截网络传输的方式来访问它。为了允以控制，可以用transient（瞬时）关键字逐个字段地关闭序列化。修改上述例子，将 passwd 字段设置为 transient：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.io.*&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;SerializableDemo&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; Serializable&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String&lt;span&gt;[]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
        User user &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; User&lt;span&gt;();&lt;/span&gt;
        user&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        user&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setPasswd&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;world&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;

        &lt;span&gt;//write Obj to File&lt;/span&gt;
        ObjectOutputStream oos &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;user&lt;span&gt;);&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;

        &lt;span&gt;//read Obj from File&lt;/span&gt;
        File file &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; File&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        ObjectInputStream ois &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectInputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream&lt;span&gt;(&lt;/span&gt;file&lt;span&gt;));&lt;/span&gt;
        User newUser &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;User&lt;span&gt;)&lt;/span&gt;ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        System&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newUser&lt;span&gt;);&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; Serializable&lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; String passwd&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getUsername&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setUsername&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String username&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;username&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; username&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getPasswd&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; passwd&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setPasswd&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String passwd&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; passwd&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;@Override&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;username = &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; getUsername&lt;span&gt;()&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;
                &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;passwd = &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; getPasswd&lt;span&gt;();&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;Output:&lt;/span&gt;
&lt;span&gt;username = hello&lt;/span&gt;
&lt;span&gt;passwd = null&lt;/span&gt;
&lt;span&gt; */&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，passwd输出的值由 world 变为 null，此外，虽然 toString() 经过重载，但是 null 引用会被自动转换成字符串 null。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;自定义序列化和反序列化策略&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  通过创建 ObjectOutputStream封装对象，然后调用writeObject()方法实现序列化，在调用ObjectOutputStream.writeObject()时，会检查所传递的 Serializable 对象，看看是否实现了它自己的 writeObject()。如果存在自己实现的 writeObject()方法，就跳过正常的序列化过程并调用它的writeObject()，同样，readObject()情形与此相同。此外，在自定义的 writeObject()内部，可以调用 defaultWriteObject() 来选择执行默认的 writeObject()；类似地，在 readObject() 内部，可以调用 defaultReadObject()。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//: io/SerialCtl.java&lt;/span&gt;
&lt;span&gt;// Controlling serialization by adding your own&lt;/span&gt;
&lt;span&gt;// writeObject() and readObject() methods.&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.io.*&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;SerialCtl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; Serializable &lt;span&gt;{&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; String a&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; String b&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;SerialCtl&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String aa&lt;span&gt;,&lt;/span&gt; String bb&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    a &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Not Transient: &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; aa&lt;span&gt;;&lt;/span&gt;
    b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;Transient: &quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; bb&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; a &lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;\n&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; b&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ObjectOutputStream stream&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;throws&lt;/span&gt; IOException &lt;span&gt;{&lt;/span&gt;
    stream&lt;span&gt;.&lt;/span&gt;&lt;span&gt;defaultWriteObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
    stream&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;);&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;ObjectInputStream stream&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;throws&lt;/span&gt; IOException&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
    stream&lt;span&gt;.&lt;/span&gt;&lt;span&gt;defaultReadObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
    b &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;String&lt;span&gt;)&lt;/span&gt;stream&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String&lt;span&gt;[]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;throws&lt;/span&gt; IOException&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
    SerialCtl sc &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SerialCtl&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Test1&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;Test2&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
    System&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;Before:\n&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; sc&lt;span&gt;);&lt;/span&gt;
    ByteArrayOutputStream buf&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ByteArrayOutputStream&lt;span&gt;();&lt;/span&gt;
    ObjectOutputStream o &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectOutputStream&lt;span&gt;(&lt;/span&gt;buf&lt;span&gt;);&lt;/span&gt;
    o&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;sc&lt;span&gt;);&lt;/span&gt;
    &lt;span&gt;// Now get it back:&lt;/span&gt;
    ObjectInputStream in &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectInputStream&lt;span&gt;(&lt;/span&gt;
      &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream&lt;span&gt;(&lt;/span&gt;buf&lt;span&gt;.&lt;/span&gt;&lt;span&gt;toByteArray&lt;/span&gt;&lt;span&gt;()));&lt;/span&gt;
    SerialCtl sc2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;SerialCtl&lt;span&gt;)&lt;/span&gt;in&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
    System&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;After:\n&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; sc2&lt;span&gt;);&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt; &lt;span&gt;/* Output:&lt;/span&gt;
&lt;span&gt;Before:&lt;/span&gt;
&lt;span&gt;Not Transient: Test1&lt;/span&gt;
&lt;span&gt;Transient: Test2&lt;/span&gt;
&lt;span&gt;After:&lt;/span&gt;
&lt;span&gt;Not Transient: Test1&lt;/span&gt;
&lt;span&gt;Transient: Test2&lt;/span&gt;
&lt;span&gt;*///:~&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;ArrayList的序列化&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;通过阅读源码，我们知道 ArrayList 的底层是数组实现的，其 elementData[] 就是用来保存元素的，其定义如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;transient&lt;/span&gt; Object&lt;span&gt;[]&lt;/span&gt; elementData&lt;span&gt;;&lt;/span&gt; &lt;span&gt;// non-private to simplify nested class access&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;elementData 通过 transient 声明，因此无法通过序列化技术保存下来，但是我们可以从一个实例中看出，其通过序列化和反序列化技术将 List 中的元素保存下来：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.io.*&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.util.ArrayList&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.util.List&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ListDemo&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;String&lt;span&gt;[]&lt;/span&gt; args&lt;span&gt;)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
        List&lt;span&gt;&amp;lt;&lt;/span&gt;String&lt;span&gt;&amp;gt;&lt;/span&gt;list &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&lt;span&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        list&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        list&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;world&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;

        &lt;span&gt;//write Obj to File&lt;/span&gt;
        ObjectOutputStream oos &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileOutputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;list&lt;span&gt;);&lt;/span&gt;
        oos&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;

        &lt;span&gt;//read Obj from File&lt;/span&gt;
        File file &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; File&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;file&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
        ObjectInputStream ois &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectInputStream&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileInputStream&lt;span&gt;(&lt;/span&gt;file&lt;span&gt;));&lt;/span&gt;
        List&lt;span&gt;&amp;lt;&lt;/span&gt;String&lt;span&gt;&amp;gt;&lt;/span&gt;newList &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;List&lt;span&gt;&amp;lt;&lt;/span&gt;String&lt;span&gt;&amp;gt;)&lt;/span&gt; ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        ois&lt;span&gt;.&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        System&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;newList&lt;span&gt;);&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;[hello, world]&lt;/span&gt;
&lt;span&gt; */&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 再通过源码可知，其添加了 writeObject() 和 readObject() 的方法来控制序列化和反序列化&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;java&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ObjectInputStream&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;throws&lt;/span&gt; java&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;IOException&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; ClassNotFoundException &lt;span&gt;{&lt;/span&gt;
    elementData &lt;span&gt;=&lt;/span&gt; EMPTY_ELEMENTDATA&lt;span&gt;;&lt;/span&gt;

    &lt;span&gt;// Read in size, and any hidden stuff&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;defaultReadObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;

    &lt;span&gt;// Read in capacity&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readInt&lt;/span&gt;&lt;span&gt;();&lt;/span&gt; &lt;span&gt;// ignored&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;size &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;// be like clone(), allocate array based upon size not capacity&lt;/span&gt;
        ensureCapacityInternal&lt;span&gt;(&lt;/span&gt;size&lt;span&gt;);&lt;/span&gt;

        Object&lt;span&gt;[]&lt;/span&gt; a &lt;span&gt;=&lt;/span&gt; elementData&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;// Read in all elements in the proper order.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; size&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
            a&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;readObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;


&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;java&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ObjectOutputStream&lt;/span&gt; s&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;throws&lt;/span&gt; java&lt;span&gt;.&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;IOException&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
    &lt;span&gt;// Write out element count, and any hidden stuff&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; expectedModCount &lt;span&gt;=&lt;/span&gt; modCount&lt;span&gt;;&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;defaultWriteObject&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;

    &lt;span&gt;// Write out size as capacity for behavioural compatibility with clone()&lt;/span&gt;
    s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeInt&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;size&lt;span&gt;);&lt;/span&gt;

    &lt;span&gt;// Write out all elements in the proper order.&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; size&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;writeObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;elementData&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]);&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;modCount &lt;span&gt;!=&lt;/span&gt; expectedModCount&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;
        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ConcurrentModificationException&lt;span&gt;();&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那到这里，不禁会思考为什么要这么转好几个弯来实现序列化和反序列化，一开始直接不将 elementData 声明为 transient 不就行了？实际上，ArrayList通过动态数组的技术，当数组放满后，自动扩容，而在扩容的这部分假设仅用了一小部分，那么就会序列化一大部分的 null 元素，为了保证在序列化的时候不会将这么多 null 进行序列化，因此设置为 transient。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;  因为在阅读 ArrayList 源码的时候，不知道 transient 关键字有何作用，因此在学习之后，以作记录，部分内容源于 《Thinking in Java》&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Feb 2018 03:52:00 +0000</pubDate>
<dc:creator>zxzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzy19961112/p/8447656.html</dc:identifier>
</item>
<item>
<title>浅析Numpy.genfromtxt及File I/O讲解 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/8449346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/8449346.html</guid>
<description>&lt;div readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Type: raw 
Points: &lt;/span&gt;16200&lt;span&gt; 
Count: &lt;/span&gt;1&lt;span&gt; 
... 
X Units: second 
Y Units: Volt 
XY Data: 
&lt;/span&gt;2.4000000E-008, 1.4349E-002 
2.4000123E-008, 1.6005E-002 
2.4000247E-008, 1.5455E-002 
2.4000370E-008, 1.5702E-002 
2.4000494E-008, 1.5147E-002&lt;span&gt; 
... &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;33&quot;&gt;
&lt;pre&gt;
2018-02-15 21:31:08.781 49.9492 
2018-02-15 21:31:09.296 49.9589 
2018-02-15 21:31:09.811 49.964 
2018-02-15 21:31:10.326 49.9741 
2018-02-15 21:31:10.841 49.983&lt;span&gt;
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;处理文本文件的第一步是&lt;strong&gt;通过 open 命令来获取一个文件对象&lt;/strong&gt;：&lt;/p&gt;&lt;div readability=&quot;37&quot;&gt;
&lt;pre&gt;
file_for_reading = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'r' 意味着只读 &lt;/span&gt;
file_for_writing = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'w' 是写入 &lt;/span&gt;
file_for_appending = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 'a' 是添加 &lt;/span&gt;
file_for_xxx.close() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 完成操作后要关闭文件 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为非常容易忘记关闭文件，所以应该在 with 程序块里操作文件，这样结尾处文件会被自动关闭：&lt;/p&gt;&lt;div readability=&quot;33&quot;&gt;
&lt;pre&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
     data &lt;/span&gt;= function_that_gets_data_form(f) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取数据函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此时，f 已经关闭了，就不能试图使用它啦，然后对数据执行相应的操作即可。&lt;/p&gt;&lt;div readability=&quot;32&quot;&gt;
&lt;pre&gt;
process(data) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处理数据函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;124.53804001529&quot;&gt;
&lt;p&gt;处理文本文件第二步是&lt;strong&gt;观察数据特征，选择合适的读取命令&lt;/strong&gt;：通过观察，可以发现，文件没有头部，每一行包括三种数据 (编号，时间，温度) 他们之间以空格键分开，每一列是同一类数据，这样我们就可以用 Python 中的 csv 模块中的 csv.reader 对其进行迭代处理，每一行都会被处理成恰当划分的列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; csv 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; with open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       reader = csv.reader(f,delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       number=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       time =&lt;span&gt; [] 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       data=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; reader: 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;           number.append(row[0]) 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;            time.append(row[1&lt;span&gt;])  
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;            data.append(float(row[2])) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;处理文本文件的第三步是&lt;strong&gt;检测数据读取格式是否正确&lt;/strong&gt;，我们可以用如下的方式检测：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt; number[0], time[0], data[0] 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; 2018-02-15 21:31:08.781 49.9492
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从输出的首个元素来看，以上的读取数据的方式是没有问题的，但是到这里我们并不能完全放心我们的数据格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt; number[0:3], time[0:3], data[0:3] 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xef\xbb\xbf1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:08.781&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:09.296&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:09.811&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] 
[&lt;/span&gt;49.9492, 49.9589, 49.964] 
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;当我们以列表的形式输出时，number 中的首个元素出现了我们没有预料到的“乱码”，这其实是 &lt;strong&gt;BOM&lt;/strong&gt; (byte order mark), 它是为 UTF-16 和 UTF-32 准备的，用以标记字节序。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码区别开，但这样的文件会给我们的数据读取带来问题。还好，我们可以用 Python 中的 &lt;strong&gt;codecs&lt;/strong&gt; 模块解决这个问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; csv 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; codecs 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; with codecs.open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thermistor.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8-sig&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     reader = csv.reader(f,delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     number=[] time=[] data=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; reader: 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        number.append(row[0]) 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         time.append(row[1&lt;span&gt;]) 
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         data.append(float(row[2])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，我们再以列表形式输出时，就会得到正确的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] 
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:08.781&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:09.296&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-02-15 21:31:09.811&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;] 
[&lt;/span&gt;49.9492, 49.9589, 49.964]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以用得到的数据进行处理分析啦~&lt;/p&gt;

&lt;p&gt;有了上面的经验，我们直接从处理文本文件第二步开始，示波器数据相对上面的数据，复杂的地方在于它包含了&lt;strong&gt;表头&lt;/strong&gt;信息，而这些信息大部分时间是处理数据中不太需要的，它的数据格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Type: raw 
Points: &lt;/span&gt;16200&lt;span&gt; 
Count: &lt;/span&gt;1&lt;span&gt; 
XInc: &lt;/span&gt;1.23457E-013&lt;span&gt; 
XOrg: &lt;/span&gt;2.4000000000E-008&lt;span&gt; 
YData range: &lt;/span&gt;1.48000E-001&lt;span&gt; 
YData center: &lt;/span&gt;5.00000E-004&lt;span&gt; 
Coupling: &lt;/span&gt;50&lt;span&gt; 
Ohms XRange: &lt;/span&gt;2.00000E-009&lt;span&gt; 
XOffset: &lt;/span&gt;2.4000000000E-008&lt;span&gt; 
YRange: &lt;/span&gt;1.44000E-001&lt;span&gt; 
YOffset: &lt;/span&gt;5.00000E-004&lt;span&gt; 
Date: &lt;/span&gt;15 APR 2018&lt;span&gt; 
Time: &lt;/span&gt;16:00:54:74&lt;span&gt; 
Frame: 86100C:MY46520443 
X Units: second 
Y Units: Volt 
XY Data: 
&lt;/span&gt;2.4000000E-008, 1.4349E-002 
2.4000123E-008, 1.6005E-002 
2.4000247E-008, 1.5455E-002 
2.4000370E-008, 1.5702E-002 
2.4000494E-008, 1.5147E-002&lt;span&gt; 
... &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，“表头”是一些参数信息，真正有用的数据是从 “XY Data:” 下一行开始的，对于这样的数据有两种方法进行读取：(1) 直接跳过“表头”读取数据；(2) 利用正则表达式寻找“表头” 和数据的不同特征进行识别读取。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; with open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waveform.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     lines = f.readlines() x=[] y=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; lines[18&lt;span&gt;:]: 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         x.append(float(line.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[0])) 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         y.append(float(line.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[1]))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过观察我们发现有效数据是从第19行开始的，于是我们&lt;strong&gt;直接从19行开始读取数据&lt;/strong&gt;，跳过“表头”，以列表形式输出 x 和 y 前3个元素如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; [2.4e-08, 2.4000123e-08, 2.4000247e-08&lt;span&gt;] 
[&lt;/span&gt;0.014349, 0.016005, 0.015455] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据读取正确&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运用正则表达式读取数据的关键在于&lt;strong&gt;找到有效数据行的独有特征&lt;/strong&gt;，这里以 “&lt;strong&gt;E-002&lt;/strong&gt;” 作为有效数据行区别于“表头”的特征，对数据的读取方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; with open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waveform.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     lines =&lt;span&gt; f.readlines() 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     x=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     y=&lt;span&gt;[] 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lines: 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; re.search(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E-002&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,line): 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;             x.append(float(line.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)[0])) 
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;             y.append(float(line.replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;).split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)[1]))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样，以列表形式输出 x 和 y 前3个元素用于检验：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; [2.4e-08, 2.4000123e-08, 2.4000247e-08&lt;span&gt;] 
[&lt;/span&gt;0.014349, 0.016005, 0.015455] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据读取正确&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：具体的数据读取方式要根据具体文本文件的特征决定，运用合适的方法才能得到更好的结果。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多时候，经过 process( ) 后的数据，需要备份留用或者供其他程序调用，因此，将处理后的数据&lt;strong&gt;写入文本文件&lt;/strong&gt;也将是关键的一步。根据数据读入的经验，被读入的数据经常存储在 list 中，那么处理后数据也通常存储在 list 中，因此，以 list 的写入作为例子：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
x = [1, 2, 3, 4&lt;span&gt;]
y &lt;/span&gt;= [2.0, 4.0, 6.0, 8.0] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参考数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来就要考虑的是要&lt;strong&gt;以什么样的格式保存数据&lt;/strong&gt;，为了更加直观的表现数据的关系，我们将 x，y 分别保存为一列，中间以空格键隔开，那么 &lt;strong&gt;csv.writer( )&lt;/strong&gt; 将是很好的工具：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; xy =&lt;span&gt; {} 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(x)): 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     xy[x[i]] =&lt;span&gt; y[i] 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; with open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     writer = csv.writer(f,delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; x, y &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xy.items(): 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         writer.writerow([x, y]) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了同时保存 x 和 y 的对应值，这里把 x 和 y 写入字典，x 为键 (key), y 为 值 (value) ，xy 就是 x 和 y 构成的字典。保存后的数据格式如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
1   2.0
2   4.0
3   6.0
4   8.0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;由于字典的键 (key) 和值 (value) 对应的特殊数据结构，写入二维数据较为方便，对于多维数据，我们就需要构建&lt;strong&gt;多维矩阵&lt;/strong&gt;，或者&lt;strong&gt;列表与元组结合&lt;/strong&gt;的方式录入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
x = [1, 2, 3, 4&lt;span&gt;]
y &lt;/span&gt;= [2.0, 4.0, 6.0, 8.0&lt;span&gt;]
z &lt;/span&gt;= [3.0, 6.0, 9.0, 12.0]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里以三维数据为例子。同样，需要将 x，y，z 各一列写入到txt中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; xyz =&lt;span&gt; [] 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(x)): 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    xyz.append([x[i],y[i],z[i]]) 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; with open(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f: 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     writer = csv.writer(f,delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; x, y, z &lt;span&gt;in&lt;/span&gt;&lt;span&gt; xyz: 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         writer.writerow([x, y, z]) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，就可以很容易地得到需要的数据格式的文本文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1   2.0 3.0
2   4.0 6.0
3   6.0 9.0
4   8.0 12.0
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;我们已经提到了两种方法读取上述的数据，它们共同点是将数据存储在列表中，正如开头所说，列表在处理大量数据时是非常缓慢的。那么，我们就来看一看 &lt;strong&gt;numpy.genfromtxt&lt;/strong&gt; 如何大显身手。&lt;/p&gt;

&lt;p&gt;为了得到我们需要的有用数据，我们有两个硬的要求： (1) &lt;strong&gt;跳过表头信息&lt;/strong&gt;；(2) &lt;strong&gt;区分横纵坐标&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
data &lt;/span&gt;= np.genfromtxt(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;waveform.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,delimiter=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,skip_header=18)
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;28.793559042114&quot;&gt;
&lt;p&gt;**delimiter: &lt;strong&gt;the str used to separate data. 横纵坐标以 ',' 分割，因此给 &lt;strong&gt;delimiter&lt;/strong&gt; 传入 ','。&lt;/strong&gt;skip_header: ** the number of lines to skip at the beginning of the file. 有用数据是从19行开始的，因此给 &lt;strong&gt;skip_header&lt;/strong&gt; 传入 18。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt; data[0:3,0], data[0:3,1]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为读入的是二维数据，因此利用 numpy &lt;strong&gt;二维数据的切片方式&lt;/strong&gt; (Index slicing) 输出各自的前三个数据验证是否读取正确：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[  2.40000000e-08   2.40001230e-08   2.40002470e-08&lt;span&gt;]
[ &lt;/span&gt;0.014349  0.016005  0.015455]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对数据进行归一化处理后，调用 &lt;strong&gt;Matplotlib&lt;/strong&gt; 画图命令，就可得到图像如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; fig, axes = plt.subplots(figsize=(8,6&lt;span&gt;)) 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; axes.plot(x, y, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, linewidth=3&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; axes.set_xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Time(ps)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; axes.set_ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Amplitude[a.u.]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; fig.savefig(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;triangular.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, dpi=600)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;4800&quot; data-height=&quot;3600&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2526000-bddc79b58cc79e36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/2526000-bddc79b58cc79e36.png&quot; data-original-width=&quot;4800&quot; data-original-height=&quot;3600&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;344353&quot;/&gt;&lt;/div&gt;
&lt;p&gt;                                                                          triangular waveform&lt;/p&gt;
&lt;div class=&quot;image-caption&quot; readability=&quot;7.956&quot;&gt;

&lt;p&gt;&lt;strong&gt;numpy.genformtxt( )&lt;/strong&gt; 函数提供了众多的入参，实现不同格式数据的读取，详情可参考：&lt;a href=&quot;https://link.jianshu.com/?t=http://docs.scipy.org/doc/numpy/reference/generated/numpy.genfromtxt.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;numpy.genfromtxt&lt;/a&gt;&lt;br/&gt;此外，numpy 中还提供了将数据存储为 &lt;strong&gt;CSV&lt;/strong&gt; 格式的函数 &lt;strong&gt;numpy.savetxt( )&lt;/strong&gt;，详情可参考：&lt;a href=&quot;https://link.jianshu.com/?t=http://docs.scipy.org/doc/numpy/reference/generated/numpy.savetxt.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;numpy.savetxt&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 15 Feb 2018 03:31:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/8449346.html</dc:identifier>
</item>
<item>
<title>深入浅出Hadoop之mapreduce - 卿哥聊技术</title>
<link>http://www.cnblogs.com/huashao1985/p/8444198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huashao1985/p/8444198.html</guid>
<description>&lt;p&gt;卿哥原创，转载请注明出处，谢谢&lt;/p&gt;
&lt;p&gt;之前已经作出预告，那么今天就聊聊mapreduce，起源于Google的map reduce paper, 而后经历了mapreduce 1，和构建于yarn上的mapreduce 2，mapreduce1 除了提供一定的历史演变价值和了解一下mapreduce最初的设计之外就没有必要学了哈，毕竟现在意义上的mapreduce2,spark都是在yarn上。当然mapreduce这项技术本身可能现在也是逐年衰落，不是我说的，是michael stonebraker3年前就说了(stonebraker认为程序员只需要了解sql就行了，nosql啥的都应该直接或间接支持用sql来查询交互)，而且google自己也早就不用了，不过mapreduce还是有自身一定的学习价值，比如map, combiner, shuffle/sort, practiioner, reducer，消息传递, data locality(即把运算移动到数据旁，而不是传输数据来节省网络带宽提高运算效率)都是分布式系统运算框架的一个里程碑。很多分布式系统设计课程比如MIT研究生著名的分布式系统设计的前几章必然要讲mapreduce。&lt;/p&gt;
&lt;h2&gt;分布式系统前言&lt;/h2&gt;
&lt;p&gt;分布式系统由于包括很多node，所以它的根基是unreliable component包括node，network和clock，上层的设计必然需要考虑到这一点。Unreliable node有如下三种表现形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fail-stop, 比如电力供应中断了（比如data center停电了，或者地震了发水灾了啥的），fail了就完了，无法恢复。&lt;/li&gt;
&lt;li&gt;fail-recovery，比如node升级kernel，os，software，需要重启&lt;/li&gt;
&lt;li&gt;拜占庭 failure，这个比较狠，就是这个node看似正常，但是你说城门楼子它说胯骨轴子，你说往东，它往西走。相当于一个神经错乱的node或者说是被入侵了的node。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时分布式系统涉及大量的网络传输，不管是RPC还是RESTFUL都是走网络，网络也是unreliable的，有如下三种表现形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;完美传输，即%0 loss, 100% in order，俗称happy home，这个资源成本比较高，适用于特别重要的服务&lt;/li&gt;
&lt;li&gt;fair-loss， 这个最为常见，就是正常丢包，不已传输内容为转移。TCP/IP就是为了解决这个事儿而设计了3 way handshake，retry，sliding window，congestion control啥的&lt;/li&gt;
&lt;li&gt;拜占庭 failure，这个就基本相当于被man in the middle 了，anything is possible，good luck ：）思考题：SSL/TLS 能有效解决man in the middle吗？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还没完，分布式系统还有一个问题就是clock，一方面每台机器的时间都可能不一样，俗称clock skew，另一方面，每台机器对每一秒的感知也不一样，俗称clock drift。所以伟大的lamport（2013图灵奖得主，分布式大神，latex，vector clock，paxos，etc）发明了logical clock，其中最著名的是vector clock。相当于让每个event有了自己的先后顺序。这个可以单独聊一次它的具体原理。插一句嘴，我觉得分布式系统这么多年敢称大神的只有两个，理论大师lamport和实战天王Jeff Dean（Jeff Dean当年在MIT淡定的给我们介绍谷歌分布式系统设计经验，然后说自己一个周末现学maching learning，搞出了个猫图片识别，当时我就在想他学machine learning干啥，然后tensor flow这个项目就横空出世了。。。orz）&lt;/p&gt;
&lt;p&gt;还有就是分布式系统实现分为synchronous和asynchronous两种model，synchronous就是blocking callback with optional timeout，asynchronous就是event call back with optional timeout。&lt;/p&gt;
&lt;p&gt;下面我们把以上几种情形组合一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;fail-stop + 完美传输 + synchronous，比如超级计算机每个processor由local high speed bus相连，user case是OpenMP 和 MPI&lt;/li&gt;
&lt;li&gt;fail-recovery + fair-loss + asynchronous，就是我们最近一直聊的hadoop eco system了&lt;/li&gt;
&lt;li&gt;拜占庭 node + 拜占庭网络+asynchronous，这就是分布于untrusted computer和untrusted network之中的grid computing了&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;map&lt;/h2&gt;
&lt;p&gt;先看一下python的map function，接下来会聊hadoop streaming&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; map(&lt;span&gt;lambda&lt;/span&gt; x: x*x, [1,2,3,4,5&lt;span&gt;])
[&lt;/span&gt;1, 4, 9, 16, 25&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; items = (1,2,3,4,5&lt;span&gt;)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;def&lt;/span&gt; sqr(x): &lt;span&gt;return&lt;/span&gt; x**2&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; map(sqr,items)

[&lt;/span&gt;1, 4, 9, 16, 25]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1321773/201802/1321773-20180213121837249-1097413346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;reduce&lt;/h2&gt;
&lt;p&gt;先看一下python的reduce function&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; reduce(operator.iadd, [1,4,9,16,25&lt;span&gt;])
&lt;/span&gt;55

&lt;span&gt;or&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt; reduce(&lt;span&gt;lambda&lt;/span&gt; x,y: x+y, [1,4,9,16,25&lt;span&gt;])
&lt;/span&gt;55
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1321773/201802/1321773-20180213121907593-417725471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;data flow&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1321773/201802/1321773-20180213121949046-200523279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1321773/201802/1321773-20180213122026093-2014903548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; map 和 reduce的input／output都是key／value pair。注意map或者reduce不一定都需要，比如grep，map=grep，reduce=None&lt;/p&gt;
&lt;p&gt;在sort和shuffling阶段，sorting用的是external sorting，所以不用担心内存爆了。&lt;/p&gt;
&lt;h2&gt;实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1321773/201802/1321773-20180213123027124-1408757386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，intermidiate result是存放在local disk中而不是HDFS，因为就算丢了，也可以通过map重新得到，所以不用使用HDFS做multiple copy。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1321773/201802/1321773-20180213123934234-2047291459.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1321773/201802/1321773-20180213124336593-785186105.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1321773/201802/1321773-20180213124841046-449167839.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1321773/201802/1321773-20180213131038452-2139242765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图可以看出yarn分为resource manager和node manager，resource manager会launch application master，application master会请求resource根据resource富余程度launch application process。&lt;/p&gt;
&lt;p&gt;下面这张图也是这个意思：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1321773/201802/1321773-20180213131235531-1267878909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体来说，input data会被Hadoop切割为固定大小的input splits，Hadoop 会为每个split creates一个map task，map task会对split中的每一个record运行user-defined map function. 对于大部分job来说，a good split size是一个HDFS block，128MB。Hadoop尽量通过data locality optimization来让map task运行在存有input data的节点上。如果不行，就选择同一个rack上的其它node，如果还不行，就选择旁边rack上的node。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1321773/201802/1321773-20180213132145171-713086697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;reduce就没有data locality一说了，input都是通过网络传过去的。这中间还会有一个shuffle&amp;amp;&amp;amp;sort的过程，通常就是通过一个hash function来把相同的key放在一起，保证对于每一个given key来说，所有的records都在一个partition里。所以当reducer处理的时候可以保证input data都是按照key sorting好的了。&lt;/p&gt;
&lt;h2&gt;Hadoop Streaming&lt;/h2&gt;
&lt;p&gt;首先，说说distributed cache, 比如你有个文件需要在运算的时候用到如何传给map／reduce task呢？答，是通过-files／-archives／-libjars 传过去的，比如-files mapper.py, reducer.py, some_file.txt, 此时some_file.txt会被传到需要的node上，每个node只需要一个copy，注意some_files.txt是read only的，所以可以被tasks共享。 archives是打包传输，libjars是传jar格式。&lt;/p&gt;
&lt;p&gt;following method 可以创建archive文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -cf pack.tar a.txt b.txt c.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;读的时候就用如下path：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
pack.tar/a.txt，pack.tar/b.txt, pack.tar/c.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其次，说说environment variable, hadoop streaming可以通过-D some_var=&quot;some value&quot;的方式把变量传给nodes。&lt;/p&gt;
&lt;p&gt;第三，从task的角度可以通过reporter:status: 的方式把report传回去。&lt;/p&gt;
&lt;p&gt;下面举个word count的实际例子，比如统计wikipedia的word count：&lt;/p&gt;
&lt;p&gt;mapper.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/python&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re

reload(sys)
sys.setdefaultencoding(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; required to convert to unicode&lt;/span&gt;

&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sys.stdin:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        article_id, text &lt;/span&gt;= unicode(line.strip()).split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError as e:
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;
    words &lt;/span&gt;= re.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\W*\s+\W*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, text, flags=&lt;span&gt;re.UNICODE)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; words:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\t%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (word.lower(), 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reducer.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/python&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys

current_key &lt;/span&gt;=&lt;span&gt; None
word_sum &lt;/span&gt;=&lt;span&gt; 0

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sys.stdin:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        key, count &lt;/span&gt;= line.strip().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 1&lt;span&gt;)
        count &lt;/span&gt;=&lt;span&gt; int(count)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError as e:
        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; current_key !=&lt;span&gt; key:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; current_key:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\t%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (current_key, word_sum)
        word_sum &lt;/span&gt;=&lt;span&gt; 0
        current_key &lt;/span&gt;=&lt;span&gt; key
    word_sum &lt;/span&gt;+=&lt;span&gt; count

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; current_key:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s\t%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (current_key, word_sum)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本机运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cat wiki.txt | ./mapper.py | sort | ./reducer.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Hadoop streaming:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
OUT_DIR=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wiki_wordcount_result_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;$(&lt;span&gt;date&lt;/span&gt; +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s%6N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
NUM_REDUCERS&lt;/span&gt;=&lt;span&gt;8&lt;/span&gt;&lt;span&gt;

hdfs dfs &lt;/span&gt;-&lt;span&gt;rm&lt;/span&gt; -r -skipTrash ${OUT_DIR} &amp;gt; /dev/&lt;span&gt;null&lt;/span&gt;&lt;span&gt;

yarn jar &lt;/span&gt;/opt/cloudera/parcels/CDH/lib/hadoop-mapreduce/hadoop-&lt;span&gt;streaming.jar \
    &lt;/span&gt;-D mapred.jab.name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Streaming wordCount&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
    &lt;/span&gt;-D mapreduce.job.reduces=&lt;span&gt;${NUM_REDUCERS} \
    &lt;/span&gt;-&lt;span&gt;files mapper.py,reducer.py \
    &lt;/span&gt;-mapper &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python mapper.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
    &lt;/span&gt;-combiner &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python reducer.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
    &lt;/span&gt;-reducer &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python reducer.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; \
    &lt;/span&gt;-input /wiki/&lt;span&gt;en_articles_part \
    &lt;/span&gt;-output ${OUT_DIR} &amp;gt; /dev/&lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，今天就写到这，happy mapreduce！&lt;/p&gt;

</description>
<pubDate>Thu, 15 Feb 2018 03:22:00 +0000</pubDate>
<dc:creator>卿哥聊技术</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huashao1985/p/8444198.html</dc:identifier>
</item>
<item>
<title>redux简明学习 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8447826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8447826.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　这几天被redux折腾的够呛，看了很多视频，也看了很多资料。很多时候，感觉好像顿悟了，但实际上只是理解了其中的一个小概念而已。真正去做项目的时候，还是会卡壳。可能是学CSS和Javascript时花的时间太久了，学redux的时候有点浮躁。还有就是redux内容实在是不少，全部都看都理解，好像没什么必要。不看吧，用的时候总是有点力不从心。于是，决定把这些资料按自己的理解写成博客，方便自己回忆思路，也希望能帮助到需要的人&lt;/p&gt;

&lt;h3&gt;核心概念&lt;/h3&gt;
&lt;p&gt;　　redux专注于状态管理，把所有的状态都存在一个对象中。核心概念包括：store、state、action、reducer&lt;/p&gt;
&lt;p&gt;【store】&lt;/p&gt;
&lt;p&gt;　　store是保存数据的地方，redux提供createStore函数来生成 Store。函数参数是后面要介绍的reducer&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import { createStore } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; store = createStore(reducer)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【state】&lt;/p&gt;
&lt;p&gt;　　state是store的某个时刻的快照，可以通过store.getState()取得当前时刻的state&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; state = store.getState()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【action】&lt;/p&gt;
&lt;p&gt;　　action用来改变state。action是一个对象，其中的type属性是必须的，其他的属性一般用来设置改变state需要的数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; action =&lt;span&gt; {
  type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ADD_ONE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  num: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　store.dispatch()是发出action的唯一方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; action =&lt;span&gt; {
  type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ADD_ONE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  num: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
}
store.dispatch(action)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【reducer】&lt;/p&gt;
&lt;p&gt;　　reducer 是一个函数，它接受action和当前state作为参数，返回一个新的state&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import { createStore } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; store = createStore(reducer)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; reducer = (state = &lt;span&gt;10&lt;/span&gt;, action) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ADD_ONE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state +&lt;span&gt; action.num;
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;: 
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当store.dispatch发送过来一个新的action，store就会自动调用reducer，得到新的state&lt;/p&gt;

&lt;h3&gt;简单实例&lt;/h3&gt;
&lt;p&gt;　　多余的概念不再介绍，下面用上面介绍的这四个核心概念实现一个简单的实例，将create-react-app中index.js文件内容更改如下，即可运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一步，创建action&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; addOne =&lt;span&gt; {
  type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  num: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; addTwo =&lt;span&gt; {
  type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  num: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; square =&lt;span&gt; {
  type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SQUARE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二步，创建reducer&lt;/span&gt;
let math = (state = &lt;span&gt;10&lt;/span&gt;, action) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ADD:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state +&lt;span&gt; action.num
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SQUARE:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state *&lt;span&gt; state
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state
  }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三步，创建store&lt;/span&gt;
import { createStore } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; store =&lt;span&gt; createStore(math)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第四步，测试，通过dispatch发出action，并通过getState()取得当前state值&lt;/span&gt;
console.log(store.getState()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认值为10&lt;/span&gt;
&lt;span&gt;
store.dispatch(addOne) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发起'+1'的action&lt;/span&gt;
console.log(store.getState()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前值为10+1=11&lt;/span&gt;
&lt;span&gt;
store.dispatch(square) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发起'乘方'的action&lt;/span&gt;
console.log(store.getState()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前值为11*11=121&lt;/span&gt;
&lt;span&gt;
store.dispatch(addTwo) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发起'+2'的action&lt;/span&gt;
console.log(store.getState()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前值为121+2=123&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果如下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201802/740839-20180214012627984-539093292.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;目录结构&lt;/h3&gt;
&lt;p&gt;　　下面对目录结构进行划分&lt;/p&gt;
&lt;p&gt;　　1、一般地，将action.type设置为常量，这样在书写错误时，会得到报错提示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// &lt;/span&gt;&lt;span&gt;constants/ActionTypes.js&lt;/span&gt;
&lt;span&gt;export const&lt;/span&gt; ADD = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;export const&lt;/span&gt; SQUARE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SQUARE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、可以将addOne对象和addTwo对象整合成add函数的形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; action/math.js&lt;/span&gt;
import { ADD, SQUARE } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; add = num =&amp;gt; ({ type: &lt;span&gt;ADD&lt;/span&gt;&lt;span&gt;, num })
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; square = { type: &lt;span&gt;SQUARE&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、根据action.type的分类来拆分reducer，最终通过combineReducers方法将拆分的reducer合并起来。上例中的action类型都是数字运算，无需拆分，只需进行如下变化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// &lt;/span&gt;&lt;span&gt;reducer/math.js&lt;/span&gt;
import { ADD, SQUARE } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
const math &lt;/span&gt;= (state = &lt;span&gt;10&lt;/span&gt;, action) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ADD:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state +&lt;span&gt; action.num
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SQUARE:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state *&lt;span&gt; state
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state
  }
}&lt;br/&gt;export default math&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reducer/index.js&lt;/span&gt;
import { combineReducers } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import math &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./math&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; rootReducer =&lt;span&gt; combineReducers({
  math
})
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; rootReducer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、将store存储到store/index.js文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; store/index.js&lt;/span&gt;
import { createStore } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import rootReducer &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../reducer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; createStore(rootReducer)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5、最终，根路径下的index.js内容如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
import store &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./store&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import {add, square} &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./action/math&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

console.log(store.getState()) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认值为10&lt;/span&gt;
&lt;span&gt;
store.dispatch(add(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发起'+1'的action&lt;/span&gt;
console.log(store.getState()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前值为10+1=11&lt;/span&gt;
&lt;span&gt;
store.dispatch(square) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发起'乘方'的action&lt;/span&gt;
console.log(store.getState()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前值为11*11=121&lt;/span&gt;
&lt;span&gt;
store.dispatch(add(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发起'+2'的action&lt;/span&gt;
console.log(store.getState()) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前值为121+2=123&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最终目录路径如下所示&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201802/740839-20180214021023140-1762408461.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　最终结果如下所示&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201802/740839-20180214022610702-2005279136.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;UI层&lt;/h3&gt;
&lt;p&gt;　　前面的示例中，只是redux的状态改变，下面利用UI层来建立view和state的联系，将根目录下的index.js的内容更改如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import store &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./store&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import React &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import ReactDOM &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-dom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { add, square } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./action/math&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

ReactDOM.render(
  &lt;/span&gt;&amp;lt;div store={store}&amp;gt;
    &amp;lt;p&amp;gt;{store.getState().math}&amp;lt;/p&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(add(&lt;span&gt;1&lt;/span&gt;))} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(add(&lt;span&gt;2&lt;/span&gt;))} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(square)} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乘方&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/div&amp;gt;&lt;span&gt;,
  document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然可以显示数字，但是点击按钮时，却不能重新渲染页面&lt;/p&gt;

&lt;p&gt;【store.subscribe()】&lt;/p&gt;
&lt;p&gt;　　接下来介绍store.subscribe()方法了，该方法用来设置监听函数，一旦state发生变化，就自动执行这个函数。该方法的返回值是一个函数，调用这个函数可以解除监听&lt;/p&gt;
&lt;p&gt;　　下面将示例代码更改如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import store &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./store&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import React &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import ReactDOM &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-dom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { add, square } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./action/math&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;const&lt;/span&gt; render = () =&amp;gt;&lt;span&gt; ReactDOM.render(
  &lt;/span&gt;&amp;lt;div store={store}&amp;gt;
    &amp;lt;p&amp;gt;{store.getState().math}&amp;lt;/p&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(add(&lt;span&gt;1&lt;/span&gt;))} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(add(&lt;span&gt;2&lt;/span&gt;))} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(square)} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乘方&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/div&amp;gt;&lt;span&gt;,
  document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
)

render()
store.subscribe(render)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代码终于可以正常运行了&lt;/p&gt;


&lt;h3&gt;异步&lt;/h3&gt;
&lt;p&gt;　　redux默认只处理同步，对于API请求这样的异步任务则无能为力&lt;/p&gt;
&lt;p&gt;　　接下来尝试使用axios的get方法来请求下面这个API&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jsonplaceholder.typicode.com/posts/2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　获取的数据如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;qui est esse&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;est rerum tempore vitae\nsequi sint nihil reprehenderit dolor beatae ea dolores neque\nfugiat blanditiis voluptate porro vel nihil molestiae ut reiciendis\nqui aperiam non debitis possimus qui neque nisi nulla&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，将其id值设置为state.math的值&lt;/p&gt;
&lt;p&gt;　　代码修改如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; constants/ActionTypes.js&lt;/span&gt;
export &lt;span&gt;const&lt;/span&gt; ADD = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; SQUARE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SQUARE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; SET = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; action/math.js&lt;/span&gt;
import { ADD, SQUARE, SET } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; add = num =&amp;gt;&lt;span&gt; ({ type: ADD, num })
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; square =&lt;span&gt; { type: SQUARE }
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; setNum = num =&amp;gt;&lt;span&gt; ({type: SET,num})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reduce/math.js&lt;/span&gt;
import { ADD, SQUARE,SET } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; math = (state = &lt;span&gt;10&lt;/span&gt;, action) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ADD:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state +&lt;span&gt; action.num
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SQUARE:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state *&lt;span&gt; state
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SET:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; action.num
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; math

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; index.js&lt;/span&gt;
import store &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./store&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import React &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import ReactDOM &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-dom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { add, square, setNum } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./action/math&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import axios &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;axios&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
let uri &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://jsonplaceholder.typicode.com/posts/2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; render = () =&amp;gt;&lt;span&gt; ReactDOM.render(
  &lt;/span&gt;&amp;lt;div store={store}&amp;gt;
    &amp;lt;p&amp;gt;{store.getState().math}&amp;lt;/p&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; {axios.&lt;span&gt;get&lt;/span&gt;(uri).then(res =&amp;gt; {store.dispatch(store.dispatch(setNum(res.data.id)))})}} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;设置Num&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(add(&lt;span&gt;1&lt;/span&gt;))} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(add(&lt;span&gt;2&lt;/span&gt;))} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(square)} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乘方&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/div&amp;gt;&lt;span&gt;,
  document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
)
render()
store.subscribe(render)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　效果如下&lt;/p&gt;

&lt;p&gt;　　但是，虽然API是异步操作，但store.dispatch并不是异步，而axios通过get方法请求回来数据后，store.dispatch在axios中的then方法中同步取得数据&lt;/p&gt;
&lt;p&gt;【redux-thunk】&lt;/p&gt;
&lt;p&gt;　　如果要使用真正的异步操作，即把axios方法封装到store.dispatch中，需要使用redux-thunk中间件&lt;/p&gt;
&lt;p&gt;　　首先，使用npm进行安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save redux-thunk
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，使用applyMiddleware来使用thunk中间件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import { createStore, applyMiddleware } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import thunk &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redux-thunk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import rootReducer &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../reducer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; createStore(rootReducer,applyMiddleware(thunk))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着来定义setNum这个action creator，然后在index.js文件的DOM加载完成后就发出setNum&lt;/p&gt;
&lt;p&gt;　　[注意]如果action是一个对象，则它就是一个action，如果action是一个函数，则它是一个action creator，即action制造器&lt;/p&gt;
&lt;p&gt;　　修改的代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; action/math.js&lt;/span&gt;
import { ADD, SQUARE, SET } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import axios &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;axios&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; uri = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://jsonplaceholder.typicode.com/posts/2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; add = num =&amp;gt;&lt;span&gt; ({ type: ADD, num })
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; square =&lt;span&gt; { type: SQUARE }
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; setNum = () =&amp;gt; (dispatch, getState) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; axios.&lt;span&gt;get&lt;/span&gt;(uri).then(res =&amp;gt;&lt;span&gt; {
    dispatch({
      type: SET,
      num: res.data.id
    })
  })
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; index.js&lt;/span&gt;
import store &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./store&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import React &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import ReactDOM &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-dom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { add, square, setNum } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./action/math&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; render = () =&amp;gt;&lt;span&gt; ReactDOM.render(
  &lt;/span&gt;&amp;lt;div store={store}&amp;gt;
    &amp;lt;p&amp;gt;{store.getState().math}&amp;lt;/p&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(setNum())} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;设置Num&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(add(&lt;span&gt;1&lt;/span&gt;))} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(add(&lt;span&gt;2&lt;/span&gt;))} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(square)} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乘方&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/div&amp;gt;&lt;span&gt;,
  document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
)
render()
store.subscribe(render)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　效果如下&lt;/p&gt;

&lt;p&gt;【提示信息】&lt;/p&gt;
&lt;p&gt;　　如果做的更完备一点，应该把异步请求时的提示信息也加上。增加一个fetch的action，用于控制fetch过程的提示信息及显示隐藏情况&lt;/p&gt;
&lt;p&gt;　　代码更改如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; action/fetch.js&lt;/span&gt;
import { SET_FETCH_MESSAGE, HIDE_FETCH_MESSAGE } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; startFetch = { type: SET_FETCH_MESSAGE,message: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开始发送异步请求&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; successFetch = { type: SET_FETCH_MESSAGE, message: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功接收数据&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; failFetch = { type: SET_FETCH_MESSAGE, message: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;接收数据失败&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; hideFetchMessage = { type: HIDE_FETCH_MESSAGE }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; action/math.js&lt;/span&gt;
import { ADD, SQUARE, SET } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { startFetch, successFetch, failFetch, hideFetchMessage } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./fetch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import axios &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;axios&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; uri = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://jsonplaceholder.typicode.com/posts/2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; add = num =&amp;gt;&lt;span&gt; ({ type: ADD, num })
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; square =&lt;span&gt; { type: SQUARE }
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; setNum = () =&amp;gt; (dispatch, getState) =&amp;gt;&lt;span&gt; {
  dispatch(startFetch)
  setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    dispatch(hideFetchMessage)
  }, &lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; axios
    .&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(uri)
    .then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        dispatch(successFetch)
        setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
          dispatch(hideFetchMessage)
        }, &lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)
        dispatch({ type: SET, num: res.data.id })
      }, &lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
    })
    .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
      dispatch(failFetch)
      setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        dispatch(hideFetchMessage)
      }, &lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;)
    })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; constants/ActionTypes.js&lt;/span&gt;
export &lt;span&gt;const&lt;/span&gt; ADD = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; SQUARE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SQUARE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; SET = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; SET_FETCH_MESSAGE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SET_FETCH_MESSAGE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; HIDE_FETCH_MESSAGE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HIDE_FETCH_MESSAGE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reduce/fetch.js&lt;/span&gt;
import { SET_FETCH_MESSAGE,HIDE_FETCH_MESSAGE } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; initState =&lt;span&gt; {
  message:&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
  isShow:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; fetch = (state = initState, action) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SET_FETCH_MESSAGE:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; {isShow: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, message: action.message}
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; HIDE_FETCH_MESSAGE:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; { isShow: &lt;span&gt;false&lt;/span&gt;, message: &lt;span&gt;''&lt;/span&gt;&lt;span&gt; }
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; fetch
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; index.js&lt;/span&gt;
import store &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./store&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import React &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import ReactDOM &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-dom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { add, square, setNum } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./action/math&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; render = () =&amp;gt;&lt;span&gt; ReactDOM.render(
  &lt;/span&gt;&amp;lt;div store={store}&amp;gt;
    &amp;lt;p&amp;gt;{store.getState().math}&amp;lt;/p&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(setNum())} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;设置Num&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(add(&lt;span&gt;1&lt;/span&gt;))} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(add(&lt;span&gt;2&lt;/span&gt;))} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={() =&amp;gt; store.dispatch(square)} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乘方&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;
    {store.getState().fetch.isShow &lt;/span&gt;&amp;amp;&amp;amp; &amp;lt;p&amp;gt;{store.getState().fetch.message}&amp;lt;/p&amp;gt;&lt;span&gt;}
  &lt;/span&gt;&amp;lt;/div&amp;gt;&lt;span&gt;,
  document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
)
render()
store.subscribe(render)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　效果如下&lt;/p&gt;


&lt;h3&gt;展示和容器&lt;/h3&gt;
&lt;p&gt;　　下面来介绍react-redux。前面的代码中，我们是通过store.subscribe()方法监控state状态的变化来更新UI层的。而使用react-redux，可以让组件动态订阅状态树。状态树一旦被修改，组件能自动刷新显示最新数据&lt;/p&gt;
&lt;p&gt;　　react-redux将所有组件分成两大类：展示组件和容器组件。展示组件只负责UI呈现，所有数据由参数props提供；容器组件则负责管理数据和业务逻辑，带有内部状态，可使用redux的API。要使用react-redux，就要遵守它的组件拆分规范&lt;/p&gt;
&lt;p&gt;【provider】&lt;/p&gt;
&lt;p&gt;　　react-redux提供Provider组件，可以让容器组件默认可以拿到state，而不用当容器组件层级很深时，一级级将state传下去&lt;/p&gt;
&lt;p&gt;　　将index.js文件更改如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; index.js&lt;/span&gt;
import React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import ReactDOM &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-dom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import store &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./store&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import MathContainer &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./container/MathContainer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { Provider } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
ReactDOM.render(
  &lt;/span&gt;&amp;lt;Provider store={store}&amp;gt;
    &amp;lt;MathContainer /&amp;gt;
  &amp;lt;/Provider&amp;gt;&lt;span&gt;,
  document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　按照组件拆分规范，将原来index.js中相关代码，分拆到container/MathContainer和component/Math这两个组件中&lt;/p&gt;
&lt;p&gt;【connect】&lt;/p&gt;
&lt;p&gt;　　react-redux提供connect方法，用于从展示组件生成容器组件。connect的意思就是将这两种组件连接起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import { connect } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; MathContainer = connect()(Math);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Math是展示组件，MathContainer就是由React-redux通过connect方法自动生成的容器组件&lt;/p&gt;
&lt;p&gt;　　为了定义业务逻辑，需要给出下面两方面的信息&lt;/p&gt;
&lt;p&gt;　　1、输入逻辑：外部的数据(即state对象)如何转换为展示组件的参数&lt;/p&gt;
&lt;p&gt;　　2、输出逻辑：用户发出的动作如何变为Action对象，从展示组件传出去&lt;/p&gt;
&lt;p&gt;　　因此，connect方法的完整API如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import {connect} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; MathContainer=&lt;span&gt; connect(
    mapStateToProps,
    mapDispatchToProps
)(Math)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面代码中，connect方法接受两个参数：mapStateToProps和mapDispatchToProps。它们定义了展示组件的业务逻辑。前者负责输入逻辑，即将state映射到UI组件的参数(props)，后者负责输出逻辑，即将用户对展示组件的操作映射成Action&lt;/p&gt;
&lt;p&gt;【mapStateToProps()】&lt;/p&gt;
&lt;p&gt;　　mapStateToProps建立一个从外部的state对象到展示组件的props对象的映射关系。作为参数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; mapStateToProps = (state) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    num: getNum(state)                  
  }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象。使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发展示组件重新渲染&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; mapStateToProps = (state,ownProps) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    num: getNum(state)                  
  }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　mapStateToProps会订阅Store，每当state更新的时候，就会自动执行，重新计算展示组件的参数，从而触发展示组件的重新渲染。connect方法可以省略mapStateToProps参数，那样，展示组件就不会订阅Store，就是说Store的更新不会引起展示组件的更新&lt;/p&gt;
&lt;p&gt;【mapDispatchToProps】&lt;/p&gt;
&lt;p&gt;　　mapDispatchToProps是connect函数的第二个参数，用来建立展示组件的参数到store.dispatch方法的映射。也就是说，它定义了用户的哪些操作应该当作action，传给Store。它可以是一个函数，也可以是一个对象&lt;/p&gt;
&lt;p&gt;　　如果mapDispatchToProps是一个函数，会得到dispatch和ownProps(容器组件的props对象)两个参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; mapDispatchToProps = (dispatch,ownProps) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    onSetNumClick: () &lt;/span&gt;=&amp;gt;&lt;span&gt; dispatch(setNum())&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了展示组件的参数怎样发出action&lt;/p&gt;
&lt;p&gt;　　如果mapDispatchToProps是一个对象，它的每个键名也是对应展示组件的同名参数，键值应该是一个函数，会被当作action creator，返回的action会由redux自动发出&lt;/p&gt;
&lt;p&gt;　　因此，上面的写法简写如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; mapDispatchToProps =&lt;span&gt; {
  onsetNumClick: () &lt;/span&gt;=&amp;gt;&lt;span&gt; setNum()&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;最终结构&lt;/h3&gt;
&lt;p&gt;　　由于store目录中，只能一个index.js文件，且不会有内容扩展，将其更改为根目录下的store.js文件&lt;/p&gt;
&lt;p&gt;　　将其他的目录都变成复数形式，最终的目录结构如下所示&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/740839/201802/740839-20180214235831609-606254668.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　效果如下&lt;/p&gt;

&lt;p&gt;　　详细代码如下所示，且可访问&lt;a href=&quot;https://github.com/littlematch0123/redux-demo&quot; target=&quot;_blank&quot;&gt;github线上地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;【components】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; components/Math.js&lt;/span&gt;
import React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; Math =&lt;span&gt; ({
  num,
  isShow,
  fetchMessage,
  onSetNumClick,
  onAddOneClick,
  onAddTwoClick,
  onSqureClick
}) &lt;/span&gt;=&amp;gt;&lt;span&gt; (
  &lt;/span&gt;&amp;lt;section&amp;gt;
    &amp;lt;p&amp;gt;{num}&amp;lt;/p&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={onSetNumClick} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;设置Num&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={onAddOneClick} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={onAddTwoClick} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onClick={onSqureClick} value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;乘方&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&lt;span&gt;
    {isShow &lt;/span&gt;&amp;amp;&amp;amp; &amp;lt;p&amp;gt;{fetchMessage}&amp;lt;/p&amp;gt;&lt;span&gt;}
  &lt;/span&gt;&amp;lt;/section&amp;gt;&lt;span&gt;
)

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Math
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【containers】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; containers/MathContainer.js&lt;/span&gt;
import { connect } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import Math &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../components/Math&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { getNum } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../selectors/math&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { getFetchMessage, getFetchIsShow } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../selectors/fetch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { setNum, add, square } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../actions/math&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; mapStateToProps = state =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    num: getNum(state),
    fetchMessage: getFetchMessage(state),
    isShow: getFetchIsShow(state)
  }
}
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; mapDispatchToProps =&lt;span&gt; {
  onSetNumClick: () &lt;/span&gt;=&amp;gt;&lt;span&gt; setNum(),
  onAddOneClick: () &lt;/span&gt;=&amp;gt; add(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
  onAddTwoClick: () &lt;/span&gt;=&amp;gt; add(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;),
  onSqureClick: () &lt;/span&gt;=&amp;gt;&lt;span&gt; square
}
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; MathContainer =&lt;span&gt; connect(mapStateToProps, mapDispatchToProps)(Math)
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; MathContainer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【actions】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; actions/fetch.js&lt;/span&gt;
import { SET_FETCH_MESSAGE, HIDE_FETCH_MESSAGE } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; startFetch = { type: SET_FETCH_MESSAGE,message: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开始发送异步请求&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; successFetch = { type: SET_FETCH_MESSAGE, message: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功接收数据&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; failFetch = { type: SET_FETCH_MESSAGE, message: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;接收数据失败&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; hideFetchMessage = { type: HIDE_FETCH_MESSAGE }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; actions/math.js&lt;/span&gt;
import { ADD, SQUARE, SET } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { startFetch, successFetch, failFetch, hideFetchMessage } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./fetch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import axios &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;axios&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; uri = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://jsonplaceholder.typicode.com/posts/2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; add = num =&amp;gt;&lt;span&gt; ({ type: ADD, num })
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; square =&lt;span&gt; { type: SQUARE }
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; setNum = () =&amp;gt; (dispatch, getState) =&amp;gt;&lt;span&gt; {
  dispatch(startFetch)
  setTimeout(() &lt;/span&gt;=&amp;gt; {dispatch(hideFetchMessage)}, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; axios
    .&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(uri)
    .then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      dispatch(successFetch)
      setTimeout(() &lt;/span&gt;=&amp;gt; {dispatch(hideFetchMessage)}, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;)
      dispatch({ type: SET, num: res.data.id })
    })
    .&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt;&lt;span&gt; {
      dispatch(failFetch)
      setTimeout(() &lt;/span&gt;=&amp;gt; {dispatch(hideFetchMessage)}, &lt;span&gt;300&lt;/span&gt;&lt;span&gt;)
    })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【constants】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; constants/ActionTypes.js&lt;/span&gt;
export &lt;span&gt;const&lt;/span&gt; ADD = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ADD&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; SQUARE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SQUARE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; SET = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; SET_FETCH_MESSAGE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SET_FETCH_MESSAGE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; HIDE_FETCH_MESSAGE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;HIDE_FETCH_MESSAGE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【reducers】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reducers/fetch.js&lt;/span&gt;
import { SET_FETCH_MESSAGE,HIDE_FETCH_MESSAGE } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; initState =&lt;span&gt; {
  message:&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
  isShow:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; fetch = (state = initState, action) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SET_FETCH_MESSAGE:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; {isShow: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, message: action.message}
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; HIDE_FETCH_MESSAGE:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; { isShow: &lt;span&gt;false&lt;/span&gt;, message: &lt;span&gt;''&lt;/span&gt;&lt;span&gt; }
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; fetch
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reducers/index.js&lt;/span&gt;
import { combineReducers } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import math &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./math&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import fetch &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./fetch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; rootReducer =&lt;span&gt; combineReducers({
  math,
  fetch
})

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; rootReducer
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reduces/math.js&lt;/span&gt;
import { ADD, SQUARE,SET } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../constants/ActionTypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; math = (state = &lt;span&gt;10&lt;/span&gt;, action) =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (action.type) {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ADD:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state +&lt;span&gt; action.num
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SQUARE:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; state *&lt;span&gt; state
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SET:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; action.num
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state
  }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; math
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【selectors】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; selectors/fetch.js&lt;/span&gt;
export &lt;span&gt;const&lt;/span&gt; getFetchMessage = state =&amp;gt;&lt;span&gt; state.fetch.message
export &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; getFetchIsShow = state =&amp;gt; state.fetch.isShow
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; selectors/math.js&lt;/span&gt;
export &lt;span&gt;const&lt;/span&gt; getNum = state =&amp;gt; state.math
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【根目录】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; index.js&lt;/span&gt;
import React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import ReactDOM &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-dom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import store &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./store&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import MathContainer &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./containers/MathContainer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import { Provider } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
ReactDOM.render(
  &lt;/span&gt;&amp;lt;Provider store={store}&amp;gt;
    &amp;lt;MathContainer /&amp;gt;
  &amp;lt;/Provider&amp;gt;&lt;span&gt;,
  document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; store.js&lt;/span&gt;
import { createStore, applyMiddleware } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redux&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import thunk &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;redux-thunk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
import rootReducer &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./reducers&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; createStore(rootReducer,applyMiddleware(thunk))
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 14 Feb 2018 16:22:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8447826.html</dc:identifier>
</item>
<item>
<title>读论文系列：Object Detection SPP-net - 梦里风林</title>
<link>http://www.cnblogs.com/hellocwh/p/8449133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellocwh/p/8449133.html</guid>
<description>&lt;p&gt;本文为您解读SPP-net:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;motivation&quot;&gt;Motivation&lt;/h2&gt;
&lt;p&gt;神经网络在计算机视觉方面的成功得益于卷积神经网络，然而，现有的许多成功的神经网络结构都要求输入为一个固定的尺寸（比如224x224,299x299），传入一张图像，需要对它做拉伸或者裁剪，再输入到网络中进行运算。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1828517-cd7d289a0d97c9b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而，裁剪可能会丢失信息，拉伸会使得图像变形，这些因素都提高了视觉任务的门槛，因此，如果能有一种模型能够接收各种尺度的输入，应当能够让视觉任务更加容易完成。&lt;/p&gt;
&lt;h2 id=&quot;什么限制了输入的尺寸&quot;&gt;什么限制了输入的尺寸&lt;/h2&gt;
&lt;p&gt;深度卷积神经网络中的核心组件有两个，一个是CNN，一个是全连接层，卷积是用filter在图像上平移与图像的局部进行逐位乘法，多个filter则产生多个feature map（特征/特征图），然后可以用pooling操作进一步采样，得到更小的feature map；实际上，我们并不在意feature map有多大，不同图像的feature map完全可以有不同的尺寸；但是在后边的具体任务中，比如分类任务，为了输出softmax对应的one-hot层，需要输出固定的尺寸，为了让不同的输入能共用一套权重参数，要求全连接层的输入尺寸是一致的，逆推回去也就限制了feature map的大小必须一致；而不同尺寸的输入图片在使用同一套卷积核（filter）的时候，会产生不同尺寸的feature map，因此才需要将不同尺寸的输入图片通过裁剪、拉伸调整为相同的尺寸。&lt;/p&gt;
&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;因此突破口有两个，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;让卷积层能为不同尺寸的输入产生相同尺寸的输出（SPP）&lt;/li&gt;
&lt;li&gt;让全连接层能为不同尺寸的输入产生相同尺寸的输出（全卷积）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;全卷积和卷积的区别在于最后不是用全连接层进行分类， 而是用卷积层，假设我们要将一个16x16的feature map转为10x1的one-hot分类，则可以使用10个1x1卷积核，每个卷积核对应一个分类，参数数量少了很多，但是…实验结果表明还挺有效的，并且，全卷积+反卷积开辟了图像分割的新思路，可以说是一个开创新的工作了，感兴趣的同学可以看&lt;a href=&quot;http://blog.csdn.net/taigw/article/details/51401448&quot;&gt;这篇博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里我们详细讲一下SPP&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1828517-331144212396ac49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;SPP-net&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SPP中SP（Spatial Pyramid）的思想来源于SPM（Spatial Pyramid Matching），可以参考&lt;a href=&quot;http://blog.csdn.net/jwh_bupt/article/details/9625469&quot;&gt;这篇文章&lt;/a&gt;，正如论文Conclusion中说的， Our studies also show that many time-proven techniques/insights in computer vision can still play important roles in deep-networks-based recognition.&lt;/p&gt;
&lt;p&gt;SPM是在不同的分辨率（尺度）下，对图片进行分割，然后对每个局部提取特征，将这些特征整合成一个最终的特征，这个特征有宏观有微观（多尺度金字塔），保留了区域特性（不同的区域特征不同），然后用特征之间的相似度进行图片间的匹配（matching）。先前我们提到过，每个filter会得到一个feature map，SPP的输入则是卷积后的这些feature map，每次将一个feature map在不同尺度下进行分割，尺度L将图片分割为2^L^个小格子（其实格子数也可以自己定，不一定要分成2^L^个），L为0代表全图；对每个小格子的做pooling，论文中是max pooling, 实际中也可以用其他，这里不像SPM需要做SIFT之类的特征提取，因为feature map已经是卷积层提取过的特征了，将pooling得到的结果拼接起来，就可以得到固定尺寸的feature map。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1828517-f2287a903cc156a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Spatial Pyramid&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个例子，一个具有256个filter的卷积层，输出了256个feature map，对于一个640x320的图片，输出的feature map可能是32x16的，对于一个640x640的图片，输出的feature map可能是32x32的，对256个feature map中的每个feature map，我们在4个尺度下对它们做切割，在最粗糙的尺度下切为1个图，次之切为2个子图，接下来是4个子图，8个, 对每个子图做max pooling，得到其中最大的数，放到最终的特征里，可以得到一个1+2+4+8=15这么长的特征，256个feature则可以得到最终256*15这么长的特征，可以看到，最终的特征尺寸只跟卷积层结构和SP尺度L有关，跟输入图片无关，从而保证了对不同尺寸的图片都输出一样大小的特征。&lt;/p&gt;
&lt;p&gt;其实看到这里，你可能发现了，对不同尺寸输出相同尺寸特征这个特性，是由pooling操作决定的，像max pooling，sum pooling这些，就是将多个输入聚合为一个值的运算；而Spatial Pyramid只是让特征有更好的组织形式而已。当然，能找到这种有效的特征组织形式也是很值得肯定的。但这里有东西仍然值得商榷，max pooling实际上还是丢了一些信息，虽然通过多层的特征可以将这些信息弥补回来。&lt;/p&gt;
&lt;h2 id=&quot;实验&quot;&gt;实验&lt;/h2&gt;
&lt;p&gt;然后作者就将这个结构应用到各种网络结构和各种任务里了，并且都取得了很好的效果（说的轻巧，复现一堆论文，改源码，跑大量实验，一定超级累）；特别是在检测任务对RCNN的改进上，这个地方比较有意思。在RCNN中，需要将每个Region Proposal输入卷积层判断属于哪个分类，而region proposal是方形的，这就导致有很多区域做了重复的卷积运算。&lt;/p&gt;
&lt;p&gt;在SPP-net的实验中，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整张图只过一遍卷积层，从conv5得到整张图对应的feature map；&lt;/li&gt;
&lt;li&gt;然后将feature map中每个region proposal对应的部分提取出来，这个位置计算量也不小，但比算卷积本身还是要快很多，原图中的一个区域唯一对应于feature map中的一个区域，不过feature map中的一个区域实际上对应原图的范围（所谓感受野）要大于region proposal所在区域，从这个意义上来讲，依然是接收了更多不相关信息，但是好在没有裁剪或变形；&lt;/li&gt;
&lt;li&gt;由于region proposal形状不一，对应的feature map尺寸也不一致，这时SPP就能充分发挥其特性，将不同尺寸的feature map转为尺寸一致的feature，传给全连接层进行分类&lt;/li&gt;
&lt;li&gt;原图实际上可以保持原图的宽高比缩放到多种尺度（文中将宽或高缩放到{480, 576, 688, 864, 1200}这五个尺寸，），分别算一个特征，将不同尺度的特征拼接起来进行分类，这种combination的方式能一定程度上提高精度&lt;/li&gt;
&lt;li&gt;这里还有一个小trick，可以将原图缩放到面积接近的范围（文中是224x224），再输入到网络中，进一步提升精度，至于原因…文中没有提，玄学解释是，输入的尺度更接近，模型训练更容易吧。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于整张图只过了一遍卷积，所以比原来的RCNN快了很多，准确率也不差&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1828517-45f9e0e2be0c4482.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Detection results (mAP) on Pascal VOC 2007&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;严格来讲SPP-net不是为detection而生的模型，但是SPP-net为RCNN进化到Fast-RCNN起了很大的借鉴作用，值得一读。SPP-net的想法很有意思，SPP（Spatial Pyramid Pooling）是对网络结构的一种改进，可能因为是华人写的论文，感觉很好读，含金量个人感觉没有RCNN或者DPM的论文高，但是实验很丰富，从分类任务和检测任务上的各种网络结构证明SPP的有效性&lt;/p&gt;
</description>
<pubDate>Wed, 14 Feb 2018 16:09:00 +0000</pubDate>
<dc:creator>梦里风林</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellocwh/p/8449133.html</dc:identifier>
</item>
<item>
<title>瀑布流知识的延伸 - 决起而飞</title>
<link>http://www.cnblogs.com/iDouble/p/8449072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iDouble/p/8449072.html</guid>
<description>&lt;p&gt;瀑布流，很常见了，淘宝，网易云音乐等等都有，实现原理，咱先放着一遍，先将涉及到的知识点拓展开来&lt;/p&gt;
&lt;h2&gt;一、Math的方法&lt;/h2&gt;
&lt;p&gt;Math求最小值、最大值，&lt;/p&gt;
&lt;p&gt;对于一般的数字直接求，Math.min  Math.max &lt;/p&gt;
&lt;p&gt;但是求数组呢，一个方法，三种形式，js高程书中利用apply的回调函数，将this指向window，直接将所求的数组作为参数传入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装函数的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;封装一个getMin的函数直接调用获得&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; numbers=[23,435,45,34&lt;span&gt;]
          &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; getMin(arr){               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装一个方法&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; min=Math.min.apply(&lt;span&gt;null&lt;/span&gt;,arr)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用apply的回调函数,将作用域this指向window，将数组作为参数传入&lt;/span&gt;
&lt;span&gt;          }
          console.log(getMin(numbers))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;原型对象的方法一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学过原型对象，直接在Array的原型上添加min方法，让Array拥有min的方法，不推荐，产品化的程序不推荐在基本包装类型添加多余的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
          Array.prototype.min=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(array){     //直接在原型上添加，传递参数
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.min.apply(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,array)
          }
          alert(numbers.min(numbers))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;原型对象的方法二&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用Object.defineProperty方法，这个具体说说&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
          Object.defineProperty(Array.prototype,'max'&lt;span&gt;,{
                   writable:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                   enumerable:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                   configurable:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                   value:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.max.apply(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,numbers)  
                   }
          })
          console.log(numbers.max())&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;拓展之Object.defineProperty方法&lt;/h3&gt;
&lt;p&gt;object.defineProperty()方法直接在对象上定义个新属性或者修改一个对象的现有属性，并返回这个对象&lt;/p&gt;
&lt;p&gt;接受三个参数&lt;/p&gt;
&lt;p&gt;obj：要在其上定义属性的对象，可以是引用类型Math，也可以是自定义的，或者原型对象&lt;/p&gt;
&lt;p&gt;prop：要定义或修改属性的名称(方法名)&lt;/p&gt;
&lt;p&gt;descriptor：将被定义或修改属性的描述符&lt;/p&gt;
&lt;p&gt;默认情况下使用此方法添加的属性是不可改变的，但是可以设置一些特性使其可以改变，for in 遍历的到等等&lt;/p&gt;
&lt;p&gt;对属性添加特性描述有数据描述和存取器描述两种&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;writable：值是否可以重写&lt;/p&gt;
&lt;p&gt;enumerable:目标属性是否可以被枚举&lt;/p&gt;
&lt;p&gt;value：设置属性的值，可以为任意的数据类型或函数&lt;/p&gt;
&lt;p&gt;configurable：目标属性是否可以被删除或修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在String原型对象上添加方法&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; str='hello'&lt;span&gt;
          Object.defineProperty(String.prototype,&lt;/span&gt;'newword'&lt;span&gt;,{
                 value:&lt;/span&gt;'world'&lt;span&gt;
          })
          alert(str.newword)
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单独给某个对象添加方法&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{}
          Object.defineProperty(obj,&lt;/span&gt;'newword'&lt;span&gt;,{
                   value:&lt;/span&gt;'world'&lt;span&gt;
          })
          alert(obj.newword)
          
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完整的特性例子&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{}
          Object.defineProperty(obj,&lt;/span&gt;'newword'&lt;span&gt;,{
                    value:&lt;/span&gt;'world'&lt;span&gt;,      
                    writable:&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否重写&lt;/span&gt;
                    enumerable:&lt;span&gt;true&lt;/span&gt;,     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for in 遍历&lt;/span&gt;
                  configurable:&lt;span&gt;true&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否可以删除属性  是否可以再次修改特性&lt;/span&gt;
&lt;span&gt;          })
          alert(obj.newword)      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;
          obj.newword='hello'     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;writable为false 所以无效&lt;/span&gt;
          alert(obj.newword)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;word&lt;/span&gt;
          &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj){
               console.log(i)       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;newword enumerable是true可以遍历 &lt;/span&gt;
&lt;span&gt;          }
          &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; obj.newword
          alert(obj.newword)      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined 因为删除了&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;存取器描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;/p&gt;
&lt;p&gt;getter方法 获得属性值&lt;/p&gt;
&lt;p&gt;setter方法 设置属性值&lt;/p&gt;
&lt;p&gt;当使用getter或setter就不允许使用writable和value这两个属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{}
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; initValue='hello'&lt;span&gt;
          Object.defineProperty(obj,&lt;/span&gt;'newword'&lt;span&gt;,{
                  get:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){             
                      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; initValue     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到属性值&lt;/span&gt;
&lt;span&gt;                  },
                  set:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(value){     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置属性值&lt;/span&gt;
                      initValue=&lt;span&gt;value
                  }
          })
          console.log(obj.newword)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IE8只能在DOM对象上使用的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有趣的东西&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Math.min 和 Math.max 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; max=&lt;span&gt;Math.max()
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; min=&lt;span&gt;Math.min()
          console.log(max&lt;/span&gt;&amp;gt;min)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里min反而是大于max呢？&lt;/p&gt;
&lt;p&gt;MDN里解释对于&lt;/p&gt;
&lt;p&gt;Math.min()如果没有参数，则返回Infinity&lt;/p&gt;
&lt;p&gt;Math.max()如果没有参数，则返回-Infinity&lt;/p&gt;
&lt;p&gt;任意参数不能转换为数值，则返回NaN&lt;/p&gt;
&lt;h2&gt;二、获取指定class的元素&lt;/h2&gt;
&lt;p&gt;早期的浏览器中不兼容getElementsByClassName 为了获取指定的class元素集合，常常封装一个方法，返回数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得指定class的元素&lt;/span&gt;
          &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getByClass(parent,name){
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lists=parent.getElementsByTagName('*'&lt;span&gt;)
                 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr=&lt;span&gt;[]
                 &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;lists.length;i++&lt;span&gt;){
                           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(lists[i].className==&lt;span&gt;name){
                                  arr.push(lists[i])
                           }
                 }
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、访问元素的样式&lt;/h2&gt;
&lt;p&gt;普通的访问简单，直接，DOM2级为style设置一些属性和方法，比如CSSText，可以直接访问到css元素属性，为元素应用多项变化最快捷的方式，一次性应用所有的&lt;/p&gt;
&lt;p&gt;下面的代码，分别是设置CSSText   移除removeProperty   length属性帮忙遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;访问元素的样式&lt;/span&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DOM2级中规定 CSSText访问style里的代码&lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; myDiv=document.getElementById('myDiv'&lt;span&gt;)
          myDiv.style.cssText&lt;/span&gt;='width:200px;height:200px;background:#fee;color:red;'
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除某个css属性&lt;/span&gt;
          myDiv.style.removeProperty('color'&lt;span&gt;)
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历css属性  length和item的结合  getPropertyValue方法返回的是css属性值的字符串&lt;/span&gt;
          &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;myDiv.style.length;i++&lt;span&gt;){
                   console.log(myDiv.style[i])
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里补充个非行间样式的获取方法，直接获取非行间样式是不可读的，返回“” &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取非行间样式&lt;/span&gt;
          &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getStyle(obj,attr){
                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(obj.currentStyle){
                         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj.currentStyle[attr]         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IE是属性&lt;/span&gt;
                 }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getComputedStyle(obj,&lt;span&gt;false&lt;/span&gt;)[attr]  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他为方法&lt;/span&gt;
&lt;span&gt;                 }
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：如果是CSSText设置的，普通访问还是访问的到的，否则还是用封装函数的方法&lt;/p&gt;
&lt;h2&gt;四、json的遍历问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;json是一种轻量级的文本数据交换格式，是一种数据格式，支持多种编程语言，具有自我描述性，容易理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JSON: &lt;strong&gt;J&lt;/strong&gt;ava&lt;strong&gt;S&lt;/strong&gt;cript &lt;strong&gt;O&lt;/strong&gt;bject &lt;strong&gt;N&lt;/strong&gt;otation(JavaScript 对象表示法)&lt;/p&gt;
&lt;p&gt;JSON 是存储和交换文本信息的语法。类似 XML。&lt;/p&gt;
&lt;p&gt;JSON 比 XML 更小、更快，更易解析。&lt;/p&gt;
&lt;p&gt;下面是简单的json格式和遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; json=&lt;span&gt;{
                 &lt;/span&gt;'name':'double'&lt;span&gt;,
                 &lt;/span&gt;'age':34&lt;span&gt;,
                 &lt;/span&gt;'sex':'man'&lt;span&gt;
          }
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于json格式，一般用for in 遍历其中的元素&lt;/span&gt;
          &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; json){
                console.log(i)     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到name age sex  获得的是属性&lt;/span&gt;
&lt;span&gt;          }
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; json){
                  console.log(json[j])  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到double 34 man  获得的是属性值&lt;/span&gt;
          }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嵌套的json遍历，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;嵌套的json格式  &lt;/span&gt;
          &lt;span&gt;var&lt;/span&gt; json=&lt;span&gt;{
                 &lt;/span&gt;'name':'double'&lt;span&gt;,
                 &lt;/span&gt;'age':34&lt;span&gt;,
                 &lt;/span&gt;'sex'&lt;span&gt;:{
                           &lt;/span&gt;'man':'one'&lt;span&gt;,
                           &lt;/span&gt;'woman':'two'&lt;span&gt;
                 }
          }

          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; json['sex']){         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历嵌套的json格式&lt;/span&gt;
                  console.log(i)               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性&lt;/span&gt;
                  console.log(json['sex'][i])  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性值&lt;/span&gt;
          }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、关于offsetWidth clientHeight scrollTop相关的总结&lt;/h2&gt;
&lt;p&gt;明天再续写&lt;/p&gt;
&lt;h2&gt;六、瀑布流的思路&lt;/h2&gt;
&lt;p&gt;好吧，现在正式说一说瀑布流的问题，前面都是我在瀑布流中遇到的重要的知识点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面总结一下思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;瀑布流，两步走&lt;/p&gt;
&lt;p&gt;第一步，图片大大小小都对齐，不要溢出，不要塌陷&lt;/p&gt;
&lt;p&gt;第二部，滚动鼠标，图片源源不断的来，永远滚不到底&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决第一步&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;计算页面中的列数，利用列数求出container的宽度&lt;/p&gt;
&lt;p&gt;计算最小图片的高度和索引，让次行的第一张图片到达最小图片的下面，且使得那一行的高度增加&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决第二步&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;计算鼠标滚动的距离，相比较最后一张图片的scrollHeight&lt;/p&gt;
&lt;p&gt;为新加载的图片创建节点，添加到页面上&lt;/p&gt;

&lt;p&gt;附上源码，注释标的挺清楚的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
window.onload=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      waterFall(&lt;/span&gt;'container','wrap')              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里获取的是整个的wrap,box则不对,因为padding&lt;/span&gt;

      &lt;span&gt;var&lt;/span&gt; dataInt={'data':[{'src':'50.jpg'},{'src':'51.jpg'},{'src':'52.jpg'}]} &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库中的图片,以json的格式传入&lt;/span&gt;
      window.onscroll=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(checkScrollSlide()){
                  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oParent=document.getElementById('container'&lt;span&gt;)
                     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;dataInt.data.length;i++){            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历数据库中的图片&lt;/span&gt;
                             &lt;span&gt;var&lt;/span&gt; oWrap=document.createElement('div')    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加新节点到原来的HTML中&lt;/span&gt;
                        oWrap.className='wrap'&lt;span&gt;
                        oParent.appendChild(oWrap)
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oBox=document.createElement('div'&lt;span&gt;)
                        oBox.className&lt;/span&gt;='box'&lt;span&gt;
                        oWrap.appendChild(oBox)
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oImg=document.createElement('img'&lt;span&gt;)
                        oImg.src&lt;/span&gt;='images/'+&lt;span&gt;dataInt.data[i].src
                        oBox.appendChild(oImg)
                     }
                     waterFall(&lt;/span&gt;'container','wrap')                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次的排序&lt;/span&gt;
&lt;span&gt;             }
      }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;排序,让图片大小一致的排序&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; waterFall(parent,child){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iParent=&lt;span&gt;document.getElementById(parent)
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; aLists=getByClass(iParent,child)       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得class为wrap的图片块&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得列数&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; pageWidth=document.documentElement.clientWidth||&lt;span&gt;document.body.clientWidth
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; boxWidth=aLists[0&lt;span&gt;].offsetWidth
      cols&lt;/span&gt;=Math.floor(pageWidth/boxWidth)       //整个页面/&lt;span&gt;单个宽
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据列数计算contianer宽度&lt;/span&gt;
      iParent.style.cssText='width:'+cols*boxWidth+'px;margin:0 auto;'
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放每一行的高度&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; colHeight=&lt;span&gt;[]
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;aLists.length;i++&lt;span&gt;){
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;&lt;span&gt;cols){
                     colHeight.push(aLists[i].offsetHeight)     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将第一行高度纳入&lt;/span&gt;
             }&lt;span&gt;else&lt;/span&gt;{                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其余行  &lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; minH=Math.min.apply(&lt;span&gt;null&lt;/span&gt;,colHeight)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用Math.min查找数组高度最小&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; index=colHeight.indexOf(minH)          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得最小的索引&lt;/span&gt;
                aLists[i].style.position='absolute'        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为移动,所以设置position/top/left&lt;/span&gt;
                aLists[i].style.top=minH+'px'&lt;span&gt;
                aLists[i].style.left&lt;/span&gt;=boxWidth*index+'px'&lt;span&gt;
                colHeight[index]&lt;/span&gt;+=aLists[i].offsetHeight   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小的高度+接下来的高度,使第二小成为最小,然后依次&lt;/span&gt;
&lt;span&gt;             }
      }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取class为box的元素 传递两个参数parent className&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getByClass(parent,name){
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list=parent.getElementsByTagName('*'&lt;span&gt;)
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr=&lt;span&gt;[]
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;list.length;i++&lt;span&gt;){
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(list[i].className==&lt;span&gt;name){
                  arr.push(list[i])
           }
     }
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  arr
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测浏览器是否scroll&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkScrollSlide(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oParent=document.getElementById('container'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; aWrap=getByClass(oParent,'wrap'&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lastWrap=aWrap[aWrap.length-1].offsetTop+Math.floor(aWrap[aWrap.length-1].offsetHeight/2)  //获得最后一张图片的距离的高度
    &lt;span&gt;var&lt;/span&gt; scrollTop=document.documentElement.scrollTop||document.body.scrollTop             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;scrollTop&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; clientHeight=document.documentElement.clientHeight||document.body.clientHeight    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;clientHeight&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(lastWrap&amp;lt;scrollTop+clientHeight){                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断&lt;/span&gt;
             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;  
      }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但凡有错，直接指出，相互进步，就马上也过年了，祝大家新年大吉吧！&lt;/p&gt;
</description>
<pubDate>Wed, 14 Feb 2018 15:15:00 +0000</pubDate>
<dc:creator>决起而飞</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iDouble/p/8449072.html</dc:identifier>
</item>
<item>
<title>cmd 与 bash 基础命令入门 - 卷柏的花期</title>
<link>http://www.cnblogs.com/HCJJ/p/8448964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HCJJ/p/8448964.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;身为一个程序员会用命令行来进行一些简单的操作，不是显得很装逼嘛！？嘿嘿~ ヾ(&lt;em&gt;&amp;gt;∀＜&lt;/em&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;cmd 与 bash 基础命令入门&lt;/strong&gt;&lt;br/&gt;      简介&lt;br/&gt;      CMD 基础命令&lt;br/&gt;            目录操作&lt;br/&gt;                  切换目录&lt;br/&gt;                  列出文件与子目录&lt;br/&gt;                  创建目录&lt;br/&gt;                  删除目录&lt;br/&gt;                  复制目录&lt;br/&gt;                  移动目录&lt;br/&gt;                  重命名目录&lt;br/&gt;                  显示树形目录&lt;br/&gt;            文件操作&lt;br/&gt;                  新建文件&lt;br/&gt;                  删除文件&lt;br/&gt;                  复制文件&lt;br/&gt;                  移动文件&lt;br/&gt;                  重命名文件&lt;br/&gt;                  文件内容比较&lt;br/&gt;                  打印文件&lt;br/&gt;                  查找文件&lt;br/&gt;                  根据内容查找文件&lt;br/&gt;            环境变量&lt;br/&gt;                  设置环境变量&lt;br/&gt;                  使用环境变量&lt;br/&gt;            辅助命令&lt;br/&gt;      BASH 基础命令&lt;br/&gt;            目录操作&lt;br/&gt;                  切换目录&lt;br/&gt;                  列出文件与子目录&lt;br/&gt;                  创建目录&lt;br/&gt;                  删除目录&lt;br/&gt;                  复制目录&lt;br/&gt;                  移动目录&lt;br/&gt;                  重命名目录&lt;br/&gt;                  显示树形目录&lt;br/&gt;            常用目录说明&lt;br/&gt;            文件操作&lt;br/&gt;                  新建文件&lt;br/&gt;                  删除文件&lt;br/&gt;                  复制文件&lt;br/&gt;                  移动文件&lt;br/&gt;                  重命名文件&lt;br/&gt;                  文件内容比较&lt;br/&gt;                  打印文件&lt;br/&gt;                  查找文件&lt;br/&gt;                  根据内容查找文件&lt;br/&gt;                  压缩与解压&lt;br/&gt;                  打包与解包&lt;br/&gt;            vi编辑器初探&lt;br/&gt;            常用快捷键&lt;br/&gt;            环境变量&lt;br/&gt;                  设置环境变量&lt;br/&gt;                  使用环境变量&lt;br/&gt;            其它常用命令&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;在学习 &lt;code&gt;cmd&lt;/code&gt; 与 &lt;code&gt;bash&lt;/code&gt; 之前，让我们先了解它们的相关背景，从而更好的认识以及学习它们。&lt;/p&gt;
&lt;p&gt;首先，在说 &lt;code&gt;cmd&lt;/code&gt; 之前，我们要先说一个操作系统 “DOS(Disk Operating System)”即“磁盘操作系统”。 &lt;code&gt;DOS&lt;/code&gt;是基于命令方式来进行工作的，从 1981年到 1995年这15年多的时间内在个人计算机操作系统中，可谓风靡一时，并占据着非常大的市场空间，也衍生了很多其它种类的 &lt;code&gt;DOS&lt;/code&gt;系统，但由于其基于命令的工作模式，对于使用者往往有着很高的专业要求，当 &lt;code&gt;window&lt;/code&gt;,&lt;code&gt;Macos&lt;/code&gt; 等基于图形化界面的操作系统开始普及后，以其简单易用的操作模式， &lt;code&gt;DOS&lt;/code&gt; 开始被迅速淘汰，虽然 &lt;code&gt;DOS&lt;/code&gt; 已经被淘汰，但也并未完全消失，至今哪怕最新版的“window 10” 在其内部都依然保留着 &lt;code&gt;DOS&lt;/code&gt; 。 只是这种被保留的&lt;code&gt;DOS&lt;/code&gt; 是以一种独立的应用程序形式存在着，并且在功能上也被进行了精简，而这个应用程序也就是我们要学习的 “cmd”（命令提示符）,在 &lt;code&gt;cmd&lt;/code&gt; 中，通过执行特定的 &lt;code&gt;DOS&lt;/code&gt; 命令，便可以让我们在 &lt;code&gt;window&lt;/code&gt; 简单的使用场景中减少对鼠标以及图形化窗口的依赖。&lt;/p&gt;
&lt;p&gt;而说到 &lt;code&gt;bash&lt;/code&gt; ，则不得不提 &lt;code&gt;shell&lt;/code&gt; ，shell是使用C语言编写的一个应用程序，它是用户使用 Unix/Linux 的桥梁，负责把用户的指令传递给内核并且把执行结果回显给用户。 &lt;code&gt;shell&lt;/code&gt; 定义了一套自己的“命令集”，这些命令既可以在交互式的场景下等待用户输入命令然后解释执行，也可以在批处理的场景下，用户事先写一个“Shell脚本”(shell Script，通过很多的 shell命令组合成需要的功能)然后让 Shell一次性把这些命令执行完，而不必一条一条地敲命令。&lt;/p&gt;
&lt;p&gt;说到这里，让我们重新梳理对 &lt;code&gt;shell&lt;/code&gt; 认识的三个重点，首先 shell是一种应用程序，其次 shell中定义了一套 “shell命令集”，最后 shell命令是通过“shell解释器”解释执行，而重点中的重点就在于“shell解释器”，我们知道 shell 的种类有很多，比如 bash、csh、ksh 等等，那么是什么造成了如此多的种类差异呢？其根本原因就在于使用的解释器不同。而解释器的不同，则源于对功能的需要求不同，有的需求场景中需要很轻的解释器，而有的场景则需要更复杂的解释器。通常而言，在 Unix中默认的 shell是 &lt;code&gt;sh&lt;/code&gt;，在 linux中默认的 shell是 &lt;code&gt;bash&lt;/code&gt;，&lt;code&gt;bash&lt;/code&gt; 是基于 Bourne shell，并吸收了 C shell和 K shell的一些特性。&lt;code&gt;bash&lt;/code&gt; 完全兼容 &lt;code&gt;sh&lt;/code&gt;，也就是说，用 &lt;code&gt;sh&lt;/code&gt; 写的脚本可以不加修改的在 &lt;code&gt;bash&lt;/code&gt; 中执行。如果想知道你当前的 shell是哪一种的？可以在你的控制台执行这条命令 &lt;code&gt;echo $SHELL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不论是 &lt;code&gt;bash&lt;/code&gt; 还是 &lt;code&gt;cmd&lt;/code&gt; ，我们也通常称它们为“命令行工具”或者是“命令行界面(CLI)”。&lt;/p&gt;
&lt;p&gt;最后，为什么我们要学习它们？因为学习它们，(cmd)可以让我们可以在 &lt;code&gt;windows&lt;/code&gt; 或者 (bash)&lt;code&gt;linux&lt;/code&gt; 等简单使用场景中，脱离对鼠标与用户界面的依赖，从而提高编码效率。&lt;/p&gt;
&lt;p&gt;当然！“装逼”也是根本原因嘛~&lt;/p&gt;
&lt;h2 id=&quot;cmd-基础命令&quot;&gt;CMD 基础命令&lt;/h2&gt;
&lt;h3 id=&quot;目录操作&quot;&gt;目录操作&lt;/h3&gt;
&lt;h4 id=&quot;切换目录&quot;&gt;切换目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;cd ：进入指定的目录或者是显示当前的目录。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd             #C:\Users\gt\Desktop
cd dir/sub-dir # 进入到dir中的sub-dir目录。
d:             # 直接进入d盘
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;列出文件与子目录&quot;&gt;列出文件与子目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;dir ：列出当前目录中的文件以及子目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dir&lt;/code&gt; 除了能默认显示当前目录的文件以及子目录，还可以显示指定目录下的文件以及子目录，同时也会统计目录下的文件以及目录的数量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir d:\fornt    #显示D盘font目录中的资源&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dir&lt;/code&gt; 默认不显示一些特殊属性的文件(例如被隐藏了的文件)，如果想显示所有文件,可以使用 &lt;code&gt;/a&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir /a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果只是想显示具有特定属性的文件，可以为 &lt;code&gt;/a&lt;/code&gt; 参数附加对应的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir /a [d|r|h|s] #显示具有指定属性的文件
dir /ad          #只显示目录
dir /ar          #只显示只读文件
dir /ah          #只显示隐藏文件
dir /as          #只显示系统文件
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dir&lt;/code&gt; 还有一个 &lt;code&gt;/o&lt;/code&gt; 的参数也会比较常用，使用它可以分类显示文件以及目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir /o [n | s | e | d]
dir /on   #按名称(字母)显示
dir /os   #按大小(从小到大)
dir /oe   #按扩展名(字母顺序)
dir /od   #按日期/时间(从先到后)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建目录&quot;&gt;创建目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;mkdir | md ：新建目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir dir               # 新建一个dir目录
mkdir dir1\dir2\dir3    # 连续新建三个目录。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除目录&quot;&gt;删除目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;rmdir | rd ：删除指定目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;md dirname
rd dirname
md dir1\dir2\dir3
rd dir1\dir2\&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*如果目录中含有其它目录或者是文件，单纯使用 &lt;code&gt;rd&lt;/code&gt; 将无法删除，必须要结合一些特殊的参数，例如 &lt;code&gt;/s&lt;/code&gt; 强制删除&lt;code&gt;/q&lt;/code&gt; 安静模式（不会询问）。&lt;/p&gt;
&lt;h4 id=&quot;复制目录&quot;&gt;复制目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;xcopy ：将目录复制到指定的位置。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xcopy dir e:dir1 #将dir目录复制到 E盘，并重命名为dir1。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*使用这种方式复制目录，只能将目录以及目录中的文件复制到新的位置，但是并不能将目录中的子目录以及子目录中的所有文件也复制过去。&lt;br/&gt;但可以通过附加一个参数 &lt;code&gt;/e&lt;/code&gt; 从而实现将整个目录（所有的子目录以及文件）都复制到新的位置中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xcopy dir e:dir1 /e&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;移动目录&quot;&gt;移动目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;move ：将指定的目录移动到新的目录中&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;move C:\Users\gt\Desktop\test distDir #将指定的目录移动到新的目录中
move dir1 dir2                        #将dir1目录移动到dir2目录中&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重命名目录&quot;&gt;重命名目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;rename | ren ：重命名文件或目录名。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ren dirName newDirName &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;显示树形目录&quot;&gt;显示树形目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;tree ： 显示目录的树形图。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tree                          #当前目录的树形图
tree C:\Users\gt\Desktop\     #指定目录的树形图&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：感觉此命令在我们写项目文档时很有用，使用它可以帮我们生成项目目录的树形结构。&lt;/p&gt;
&lt;h3 id=&quot;文件操作&quot;&gt;文件操作&lt;/h3&gt;
&lt;h4 id=&quot;新建文件&quot;&gt;新建文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;notepad : 打开window的记事本程序新建文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;notepad filename.ext
notepad 1.txt
notepad index.js&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*notepad 是调用window中的记事本程序来新建文件。&lt;/p&gt;
&lt;h4 id=&quot;删除文件&quot;&gt;删除文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;del ：删除指定的文件或者是清空指定目录中的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;del filename #删除指定的文件
del file1 file2 .. #删除多个文件
del dir #清空指定目录下的所有文件
del dir1 dir2 dir3 .. #清空多个目录下的文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用 &lt;code&gt;del&lt;/code&gt; 清空指定目录下的所有文件时，默认会有一个询问，如果想忽略询问，只需要加一个参数&lt;code&gt;/q&lt;/code&gt;即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;del dir /q&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出此之外，使用 &lt;code&gt;del&lt;/code&gt; 还可以删除特定属性的文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;del /AR #可以删除只读文件
del /AH #可以删除隐藏文件
del /AS #可以删除系统文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，&lt;code&gt;del&lt;/code&gt; 还可以结合通配符来删除匹配到文件。&lt;/p&gt;
&lt;h4 id=&quot;复制文件&quot;&gt;复制文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;copy ：复制一个或者是多个文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;copy file.txt file_copy.txt    #在当前目录由file.txt 复制为一个名为file_copy.txt的新文件。
copy C:\Users\Admin\Desktop\index.js index_copy.js #将桌面上的index.js文件复制到当前目录，并命名为index_copy.js
copy file1 dir\file2 #相对目录进行复制。
copy file1+file2 dir\file3 #将当前目录的file1与file2文件复制到dir目录中并合成一个新的file3文件。
copy C:\Users\Admin\Desktop\ #将桌面上的所有文件复制到当前目录。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;copy&lt;/code&gt; 命令还具有两个不是太常用的参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;copy file /A #复制一个ASCII文件。
copy file /B #复制一个二进制文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;copy&lt;/code&gt; 命令只能复制指定目录中的文件，而不能复制指定目录中的子目录和文件。&lt;br/&gt;如果想复制目标目录下的所有文件和文件夹，可以使用 &lt;code&gt;xcopy&lt;/code&gt; 命令，它相当于 &lt;code&gt;copy&lt;/code&gt; 命令的扩展版。&lt;/p&gt;
&lt;h4 id=&quot;移动文件&quot;&gt;移动文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;move ：将指定的文件移动到新的位置。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;move file.txt dir/file.txt    #将指定的文件移动到指定的目录中。
move file.txt dir/newfile.txt #移动的同时，重新命名。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重命名文件&quot;&gt;重命名文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ren ：重命名文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ren oldfilename newfilename&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;文件内容比较&quot;&gt;文件内容比较&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;fc ：在指定的文件集中比较文件的内容&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fc file1 file2 file3&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;打印文件&quot;&gt;打印文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;type ：在命令行工具中打印文件内容。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type file      #打印文件file的内容。
type dir\file  #打印指定目录中file文件的内容。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 命令还可以结合通配符一起使用，打印多个文件的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type dir\*     #打印指定目录dir中所有文件的内容。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;查找文件&quot;&gt;查找文件&lt;/h4&gt;
&lt;p&gt;我们知道 &lt;code&gt;dir&lt;/code&gt; 是用于列出指定目录中所有的文件或子目录，实际上 &lt;code&gt;dir&lt;/code&gt; 后面还可以跟上文件名目录名或者是通配符来设置只列出匹配到的文件以及目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir index.js    #列出该目录下的index.js
dir *.js        #列出该目录下扩展名为js的所有文件。
dir *           #列出所有文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与查找文件相同，&lt;code&gt;dir&lt;/code&gt; 也可以查找指定的目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dir dirname&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;根据内容查找文件&quot;&gt;根据内容查找文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;find ：根据文件内容查找文件，不确定文件名称或者是扩展名时可结合通配符使用。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find &quot;function handle&quot; index.js #确定文件查找
find &quot;function handle&quot; *.js     #根据文件名模糊查找
find &quot;function handle&quot; ?.js     #查找文件名只有一个字符的js文件。
find &quot;function handle&quot; /*       #查找所有文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;find&lt;/code&gt; 命令还具有一些其它有用的参数：&lt;code&gt;/i&lt;/code&gt; 忽略大小写 , &lt;code&gt;/v&lt;/code&gt; 只显示匹配到的文件，&lt;code&gt;/n&lt;/code&gt; 显示行号。&lt;/p&gt;
&lt;h3 id=&quot;环境变量&quot;&gt;环境变量&lt;/h3&gt;
&lt;p&gt;注意，如果想在window中设置永久的环境变量，只能通过 “我的电脑” - “属性” - “高级” - “环境变量”。&lt;br/&gt;使用命令行来设置环境变量只对当前窗口有效，窗口关闭时，将会自动失效。&lt;/p&gt;
&lt;h4 id=&quot;设置环境变量&quot;&gt;设置环境变量&lt;/h4&gt;
&lt;p&gt;set : 通过&lt;code&gt;set&lt;/code&gt;命令我们即可以查看指定的环境变量，也可以设置一个新的环境变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set               #查看当前的所有环境变量
set PATH          #查看环境变量PATH的值。
set key = value   #设置一个新的环境变量并赋值。
set key = value2  #重新对指定的环境变量赋值。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*path这个环境变量是用于设置可执行文件（程序）的搜索路径，是非常常用的一个环境变量。&lt;/p&gt;
&lt;h4 id=&quot;使用环境变量&quot;&gt;使用环境变量&lt;/h4&gt;
&lt;p&gt;在CMD中，如果想引用某个环境变量，则使用 &lt;code&gt;%env%&lt;/code&gt; 的格式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo %PATH%

set name=usrname
echo %name%&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们通过一个非常小的例子来理解通过命令设置环境变量 &lt;code&gt;PATH&lt;/code&gt; 值的作用。&lt;br/&gt;假设我们有一个可执行的程序，名字叫做 &lt;code&gt;main.exe&lt;/code&gt; 保存在 &lt;code&gt;D:\install\main&lt;/code&gt;目录中。 一般，我们想执行某个程序的方法有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为可执行文件建立快捷方式到桌面&lt;/li&gt;
&lt;li&gt;进入目录，双击执行可执行程序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而上面的方法，不论哪一种，都无法解决在命令行窗口中，输入 &lt;code&gt;main&lt;/code&gt; 便可以执行 &lt;code&gt;main.exe&lt;/code&gt;的需求。&lt;br/&gt;然而通过设置环境变量 &lt;code&gt;PATH&lt;/code&gt; 的值便可以做到这一点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set main_exc=D:\install\main
set PATH=%PATH%;%main_exc%
main                           #执行main&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实设置环境变量&lt;code&gt;PATH&lt;/code&gt;的值，可以直接使用 &lt;code&gt;path&lt;/code&gt;命令，而无需通过 &lt;code&gt;set&lt;/code&gt; 来声明要修改的环境变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;path %PATH%;%main_exc%&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，在环境变量 &lt;code&gt;PATH&lt;/code&gt; 中如果设置多个值，每个值之间使用 &lt;code&gt;;&lt;/code&gt; 分号隔开。&lt;/p&gt;
&lt;h3 id=&quot;辅助命令&quot;&gt;辅助命令&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cls        #清除屏幕。
cmd        #进入MS-DOS
echo       #显示消息，或将命令回显打开或关闭。
exit       #退出 CMD.EXE 程序(命令解释程序)。
start      #启动单独的窗口以运行指定的程序或命令。
calc       #启动计算器
explorer   #打开资源管理器
notepad    #打开记事本
dxdiag     #检查DirectX信息
regedt32   #注册表编辑器
Msconfig   #系统配置实用程序
taskmgr    #打开任务管理器
help       #查看MS-DOS命令帮助。
command /? #查看指定命令详细帮助文档。
wmic       #进入wmic（Windows Management Instrumentation），它是windows管理工具命令行版，使用wmic我们可以对整个系统进行管理，例如远程连接、硬件管理、进程管理、账号管理、服务管理、目录管理、共享管理等等，可说它是一个增强版的CMD。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bash-基础命令&quot;&gt;BASH 基础命令&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;bash&lt;/code&gt; 有些命令与 &lt;code&gt;cmd&lt;/code&gt;中非常相像，比如 &lt;code&gt;cd&lt;/code&gt;，再比如 &lt;code&gt;mkdir&lt;/code&gt;等。因此学会了 &lt;code&gt;cmd&lt;/code&gt; 对于学习 &lt;code&gt;bash&lt;/code&gt; 也非常有帮助。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;bash&lt;/code&gt;与&lt;code&gt;cmd&lt;/code&gt;的区别，我个人认为最大的不同有两点，一是目录路径的表示上， &lt;code&gt;bash&lt;/code&gt;使用我们常见的斜杠 &lt;code&gt;cd dir1/dir2/dir3&lt;/code&gt;，而 &lt;code&gt;cmd&lt;/code&gt;则使用反斜杠 &lt;code&gt;cd dir1\dir2\dir3&lt;/code&gt;，虽然 &lt;code&gt;cmd&lt;/code&gt; 也可以使用斜杠，但是在某些情况下使用斜杠将会行不通，例如 &lt;code&gt;copy&lt;/code&gt; 命令，所以我们建议对 &lt;code&gt;cmd&lt;/code&gt; 保持统一的目录风格，即“反斜杠”。最后一点则在于命令的附加参数，&lt;code&gt;cmd&lt;/code&gt;中是通过斜杠来附加参数 &lt;code&gt;/params&lt;/code&gt; 而 &lt;code&gt;bash&lt;/code&gt;则是通过横杠 &lt;code&gt;-params&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;目录操作-1&quot;&gt;目录操作&lt;/h3&gt;
&lt;h4 id=&quot;切换目录-1&quot;&gt;切换目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;cd ：进入指定的目录。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd   #进入个人目录
cd / #进入根目录
cd - #返回上次的目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不确定自己当前的目录位置，可以结合 &lt;code&gt;pwd&lt;/code&gt; 命令，便会在命令行中打印出当前目录路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pwd &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;列出文件与子目录-1&quot;&gt;列出文件与子目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ls ：列出当前目录中的文件以及子目录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 除了能默认显示当前目录的资源以及子目录，还可以显示指定目录下的文件以及子目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls ../   #列出上级目录下的资源和子目录
ls /     #列出根目录下的资源和子目录。
ls /home #列出home目录下的资源和子目录。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ls&lt;/code&gt; 默认不显示具有特殊属性的文件(例如被隐藏了的文件)，如果想显示所有文件,可以使用 &lt;code&gt;-a&lt;/code&gt; 参数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要查看资源或目录更详细的信息，可以附加 &lt;code&gt;-l&lt;/code&gt;属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls -l&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建目录-1&quot;&gt;创建目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;mkdir ：创建目录。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir dir                 #创建一个目录dir
mkdir dir1 dir2 dir3..    #同时创建多个同级目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想创建一个目录树，可以附加一个 &lt;code&gt;-p&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p a/b/c/d&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除目录-1&quot;&gt;删除目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;rmdir ：删除空目录&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;rm -rf ：强制删除目录(包括非空目录)。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rmdir emptyDir #删除一个空目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想删除一个非空目录，则需要使用 &lt;code&gt;rm&lt;/code&gt; 命令，并使用 &lt;code&gt;-rf&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rm -rf dir                  #删除一个非空目录。
rm -rf dir1 dir2 dir3       #同时删除多个非空目录。
rm -rf pattern              #删除按照特定模式匹配到的目录。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;复制目录-1&quot;&gt;复制目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;cp -a ：复制目录到指定的位置。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp -a dir ../dir  #将当期目录复制一份到上级目录中。
cp -a dir dir2    #复制目录并重命名。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;移动目录-1&quot;&gt;移动目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;mv ：移动目录到指定位置。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv file file2                         #同级移动，相当于重命名目录file为file2
mv file ../file2                      #将目录移动到上级目录中并重命名。
sudo mv /home/user/file /home/        #将指定位置的目录移动到指定位置中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，&lt;code&gt;mv&lt;/code&gt; 也可以结合通配符进行使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv * ../   #将所有的目录与文件都复制到上级目录中。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重命名目录-1&quot;&gt;重命名目录&lt;/h4&gt;
&lt;p&gt;利用 &lt;code&gt;mv&lt;/code&gt; 命令同级移动功能，并结合重命名的特点，就可以做到目录的重命名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv file newfile2                         #同级移动，相当于重命名目录file为newfile2&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;显示树形目录-1&quot;&gt;显示树形目录&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;tree ：显示目录的树形图。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tree       #当前目录的树形图
tree /     #根目录下的树形图&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：感觉此命令在我们写项目文档时很有用，使用它可以帮我们生成项目目录的树形图。&lt;/p&gt;
&lt;h4 id=&quot;常用目录说明&quot;&gt;常用目录说明&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/     #根目录
/bin  #命令保存目录
/boot #启动目录
/dev  #设备文件命令
/etc  #配置文件保存目录
/home #家目录
/lib  #系统库保存命令
/mnt  #系统挂载目录&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;文件操作-1&quot;&gt;文件操作&lt;/h3&gt;
&lt;h4 id=&quot;新建文件-1&quot;&gt;新建文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;touch ：新建文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;touch filename             #新建一个文件。
touch file1 file2 file3... #同时新建多个文件。
touch dir/file             #在指定的位置中新建一个文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果终端已经附加了 &lt;code&gt;vi&lt;/code&gt; 编辑器，也可以使用 &lt;code&gt;vi filename&lt;/code&gt; 的形式来创建文件，与 &lt;code&gt;cmd&lt;/code&gt; 中的 &lt;code&gt;notepad&lt;/code&gt; 命令功能类似。&lt;/p&gt;
&lt;h4 id=&quot;删除文件-1&quot;&gt;删除文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;rm ：删除文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rm file      #删除文件
rm dir/file  #删除指定目录中的文件
rm dir/*     #删除指定目录中的所有文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;复制文件-1&quot;&gt;复制文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;cp ：复制文件到指定的位置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp file file1    #将文件复制一份并重新命名。
cp file ../      #将文件复制一份到上级目录中。
sudo cp file /   #将文件复制到根目录中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cp&lt;/code&gt; 还可以结合通配符一起使用，将匹配到的文件复制到指定的位置中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp dir/*  ./  #指定目录中的所有文件复制到当前目录中。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;移动文件-1&quot;&gt;移动文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;mv ：移动文件到指定的位置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv file ../       #将文件移动到上级目录中。
mv ../file ./     #将上级的文件移动到当前目录中。
sudo mv file /    #将文件移动到根目录中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mv&lt;/code&gt; 不仅可以移动文件，还可以在移动后重命名文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv filename1 ../filename2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mv&lt;/code&gt;还可以结合通配符使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv na?.txt ../nbc.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重命名文件-1&quot;&gt;重命名文件&lt;/h4&gt;
&lt;p&gt;利用 &lt;code&gt;mv&lt;/code&gt; 命令同级移动的功能再结合其可以重命名的特点，从而实现文件的重命名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv file file2                         #同级移动，相当于重命名文件file为file2&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;文件内容比较-1&quot;&gt;文件内容比较&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;diff ：比较多个文件内容的不同&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;diff file1 file2 ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;打印文件-1&quot;&gt;打印文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;cat ：在命令行工具中打印文件的内容&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat filename    #打印指定文件的内容
cat file1 file2 #同时打印多个文件的内容&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 命令除了能打印文件的内容，还可以合并多个文件的内容保存到一个新的文件中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat file1 file2 &amp;gt; newfile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，还可以结合通配符来打印匹配到的所有文件内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat a*
cat *.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果查看的文件内容很多，还可以使用 &lt;code&gt;less&lt;/code&gt; 命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;less file&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用 &lt;code&gt;space&lt;/code&gt; 便可以向下一页一页的翻动，或者 &lt;code&gt;pgup&lt;/code&gt; 向上翻页 , &lt;code&gt;pgdn&lt;/code&gt; 向下翻页，&lt;code&gt;q&lt;/code&gt; 则可以退出 &lt;code&gt;less&lt;/code&gt;命令。&lt;/p&gt;
&lt;h4 id=&quot;查找文件-1&quot;&gt;查找文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;find ：可以根绝名称、大小、修改时间来查找指定的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find -name httpd.conf #在当前目录下查找httpd.conf文件。
find -name *.js       #在当前目录下查找所有js文件。
find -empty           #查找所有为空的目录。
find -size -1000      #查找小于1000KB的文件。
find -size +1000      #查找大于1000KB的文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;find&lt;/code&gt;命令默认在当前目录进行查找，你也可以指定一个目录进行查找。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find / -name *.txt          #在根目录下查找所有的txt文件。
find /etc -name httpd.conf  #在etc目录下查找httpd.conf文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与根据文件名查找文件相同，也可以使用 &lt;code&gt;find&lt;/code&gt; 按照目录名来查找目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find -name dirname&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;根据内容查找文件-1&quot;&gt;根据内容查找文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;grep ：可以根据指定的内容来查找含有这些内容的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grep pattern *  #查找当前目录含有指定匹配模式的文件。pattren可以是一个正则表达式。
grep c *        #查找当前目录含有单词c的文件。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想忽略内容的大小写可以附加一个 &lt;code&gt;-i&lt;/code&gt;的参数。&lt;br/&gt;显示匹配行及行号附加 &lt;code&gt;-n&lt;/code&gt;&lt;br/&gt;如果只显示文件名，不显示具体匹配到的内容，则附加 &lt;code&gt;-l&lt;/code&gt; 参数&lt;/p&gt;
&lt;h4 id=&quot;压缩与解压&quot;&gt;压缩与解压&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;gzip ：单独压缩指定的文件，压缩后删除被压缩文件，只保留压缩后的文件，并且不能压缩目录。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gzip file                   #压缩指定的文件
gzip file1 file2 file3...   #同时压缩多个文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;gzip&lt;/code&gt; 还可以与通配符结合使用，压缩匹配到的文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gzip *.*
gzip ?.?.*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若想列出某个 &lt;code&gt;.gz&lt;/code&gt; 压缩文件中的内容，可以附加一个 &lt;code&gt;-l&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gzip -l file.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压某个&lt;code&gt;.gz&lt;/code&gt; 文件，则使用 &lt;code&gt;gunzip&lt;/code&gt; 命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gunzip file.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;zip ：与 &lt;code&gt;gzip&lt;/code&gt; 相比 &lt;code&gt;zip&lt;/code&gt; 可以压缩目录还可以将多个文件压缩在一起，并保留被压缩的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zip filename.zip file1 file2 ...   #将指定的文件压缩到一个新创建的压缩文件中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;zip&lt;/code&gt; 也可以结合通配符使用，压缩匹配到的文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zip filename.zip *.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更强的是 &lt;code&gt;zip&lt;/code&gt; 还可以一次性压缩一个目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zip filename.zip dir&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，若想列出某个 &lt;code&gt;.zip&lt;/code&gt; 压缩文件中的内容，可以附加一个 &lt;code&gt;-l&lt;/code&gt; 参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unzip -l filename.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压某个&lt;code&gt;.zip&lt;/code&gt; 文件，则使用 &lt;code&gt;unzip&lt;/code&gt; 命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unzip file.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;打包与解包&quot;&gt;打包与解包&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;tar ：它是linux下的一个打包命令，它可以将一大堆松散的文件或者是目录打包在一起，从而保证资源的完整性。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -cvf package.tar file1 file2 file3 ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要打包一个目录，则指定目录名：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -cvf package.tar dirname&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想解包，则附加 &lt;code&gt;-xvf&lt;/code&gt; 的参数即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -xvf package.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果只是想列出某个包中含有的文件或目录,则附加 &lt;code&gt;-tvf&lt;/code&gt; 参数即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar tvf package.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tar&lt;/code&gt; 命令只能打包，而不能压缩，而 &lt;code&gt;gzip&lt;/code&gt; 虽然可以压缩但是只能对文件进行单独压缩，并且只保留压缩后的文件，而不保留被压缩的文件，所以将 &lt;code&gt;tar&lt;/code&gt; + &lt;code&gt;gzip&lt;/code&gt; 结合使用，将会互补其短，产生更大的功效。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar package.tar file1 file2 file3 ... #将多个文件打包在package.tar包文件中。
gzip package.tar.gz package.tar       #将通过tar打包的文件再进行压缩。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解压缩解包也要依次进行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gunzip package.tar.gz #解压缩
tar -xvf package.tar  #解包&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你也可以通过附加参数的方式一次性的打包压缩。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zcvf package.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后一次性的解压缩解包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf package.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;vi编辑器初探&quot;&gt;vi编辑器初探&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;vi&lt;/code&gt; 是 Unix及 Linux系统下标准的文本编辑器，由美国加州大学伯克利分校的 Bill Joy所创立。&lt;br/&gt;我们可以在支持 vi 编辑器的命令行工具中，直接调用“vi编辑器”来编辑文件。&lt;br/&gt;&lt;code&gt;vi&lt;/code&gt; 有三种模式，分别是“命令模式(Comand Mode)”、“插入模式(Inset Mode)””、“底行模式(last line mode)”。默认的模式则是“命令模式”。&lt;br/&gt;在“命令模式”下我们可以移动光标，删除字符，单词，行，复制字符，单词，行等。通过按字母 &lt;code&gt;a&lt;/code&gt; 便可以进入到“插入模式”，而通过 &lt;code&gt;shift+;&lt;/code&gt;组合键(目的是输入冒号:)则进入到“底行模式”。&lt;br/&gt;在“插入模式”下才可以编辑文字，按 &lt;code&gt;esc&lt;/code&gt; 键则可以返回“命令模式”。&lt;br/&gt;在“底行模式”则可以执行一些命令动作，例如保存文件，设置编辑器环境，查找字符等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令模式(Command Mode)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;i、a、o&lt;/code&gt; 进入到“插入模式”。&lt;code&gt;i&lt;/code&gt;会在光标的当前位置输入，&lt;code&gt;a&lt;/code&gt; 则会在光标所在的下一个位置输入，&lt;code&gt;o&lt;/code&gt;会插入新的一行，并从行首开始输入文字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shift+;&lt;/code&gt; 进入到“底行模式”&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | h&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向左移动一个字符，如果结合数字键，则向左移动指定数量的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | l&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向右移动一个字符，如果结合数字键，则向右移动指定数量的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | j&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向上移动一行，如果结合数字键，则向上移动指定数量的行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | k&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向下移动一行，如果结合数字键，则向下移动指定数量的行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | x&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向后删除当前光标所在的字符，类似于DEL键，结合数字键则向后删除指定数量的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;[num] | X&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向前删除当前光标所在的字符，类似于BackSpace键，结合数字键则向前删除指定数量的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;0&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;移动到行首&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;$&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;移动到行尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;dd&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;删除光标所在行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;yy&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;复制当前行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;J&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;合并行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;p&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;将已复制的数据在光标下一行贴上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;P&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;将已复制的数据在光标上一行贴上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;yyp&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;复制光标所在的行再插入到下一行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;H&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;光标移至屏幕顶行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;L&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;光标移至屏幕最后行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;num + G&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;跳转到指定的行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[ctrl] + f&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;屏幕『向下』移动一页，相当于 [Page Down]按键&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;[ctrl] + b&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;屏幕『向上』移动一页，相当于 [Page Up] 按键&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;r[w]&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;将当前光标所在的字符替换为指定的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;~&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;该表当前光标所在字符的大小写转换&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;/word&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;?word&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;向光标之上寻找一个字符串名称为 word 的字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;n&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;根据搜索结果继续向下查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;N&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;根据搜索结果继续向上查询&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;插入模式(Inset Mode)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;esc&lt;/code&gt; 进入到“命令模式”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该模式下用于输入以及编辑内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;底行模式(Last Line Mode)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;esc&lt;/code&gt; 进入到“命令模式”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;底行模式又可以称之为“指令模式”，在这个模式下，可以通过输入制定来让“vi编辑器”完成特定的功能。&lt;br/&gt;| 命令 | 功能 |&lt;br/&gt;|:---|:---:|&lt;br/&gt;|:w|保存文件|&lt;br/&gt;|:q|退出vi编辑器|&lt;br/&gt;|:wq|退出并保存|&lt;br/&gt;|:q!|退出vi编辑器，并不保存内容|&lt;br/&gt;|:set nu|显示行号|&lt;br/&gt;|:set nonu|隐藏行号|&lt;/p&gt;
&lt;h3 id=&quot;常用快捷键&quot;&gt;常用快捷键&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ctr+c  #终止当前命令
ctr+l  ##清屏  相当于 clear
ctr+a  #光标移到行首
ctr+e  #光标移到行尾
ctr+u  #把光标所在位置删除到行首
ctr+d  #删除光标前面的字符，一旦内容全部删除再按则会退出窗口。
ctr+h  #删除光标后面的字符，&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;环境变量-1&quot;&gt;环境变量&lt;/h3&gt;
&lt;p&gt;与 &lt;code&gt;window&lt;/code&gt; 相同 &lt;code&gt;linux&lt;/code&gt; 中通过命令行修改或者是创建的环境变量只对当前的命令窗口有效，关闭窗口则会消失。&lt;br/&gt;如果想在 &lt;code&gt;linux&lt;/code&gt; 设置永久的环境变量，如果是系统级的环境变量请使用“vi编辑器”编辑 &lt;code&gt;/etc/profile&lt;/code&gt; 文件，如果是用户级别的环境变量，则进入到对应的用户目录修改 &lt;code&gt;.profile&lt;/code&gt; 文件。&lt;/p&gt;
&lt;h4 id=&quot;设置环境变量-1&quot;&gt;设置环境变量&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;linux&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;命令可以查看系统级以及用户级的所有环境变量，使用 &lt;code&gt;env&lt;/code&gt;则查看当前用户的环境变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set #查看所有环境变量
env #查看与当前用户有关的环境变量&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想设置一个环境变量，则使用 &lt;code&gt;export&lt;/code&gt; 命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export key=value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，如果想修改某个环境变量的值，再次执行上面的命令即可。&lt;/p&gt;
&lt;h4 id=&quot;使用环境变量-1&quot;&gt;使用环境变量&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;linux&lt;/code&gt;中引用一个环境变量，则为环境变量附加 &lt;code&gt;$&lt;/code&gt;符，其形式如：&lt;code&gt;$env&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$PATH   #引用环境变量PATH。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;环境变量如果存在多个值，则通过使用 &lt;code&gt;:&lt;/code&gt; 冒号进行分割。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export app=/home/app
export PATH=$PATH:%app&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其它常用命令&quot;&gt;其它常用命令&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;clear&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;#清除屏幕。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;#显示消息，或将命令回显打开或关闭。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;whoami&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;#返回当前登录用户名。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;passwd&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;#允许当前登录的用户更改其密码。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;file&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;#尝试判断指定文件的类型。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;exit&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;#退出命令行工具&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;users&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;#显示当前登录系统地用户&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;last&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;#查看用户的登录日志&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;cammand&lt;/span&gt; --help  &lt;span class=&quot;co&quot;&gt;#查看相关命令的帮助文档。&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;ping&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;#查看网络状态&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;如果觉得本文对您有帮助或者您心情好~可以支付宝(左)或微信(右)支持一下，就当给作者赞助杯咖啡钱了&lt;img src=&quot;https://images2015.cnblogs.com/blog/735756/201612/735756-20161203191659177-1498594594.png&quot; alt=&quot;&quot;/&gt; ~~：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/735756/201612/735756-20161203191025865-224171467.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/735756/201612/735756-20161203191032912-1350098481.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 14 Feb 2018 14:19:00 +0000</pubDate>
<dc:creator>卷柏的花期</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HCJJ/p/8448964.html</dc:identifier>
</item>
<item>
<title>MessagePack简析 - 孙振超</title>
<link>http://www.cnblogs.com/sunzhenchao/p/8448929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunzhenchao/p/8448929.html</guid>
<description>&lt;p data-type=&quot;p&quot;&gt;先看官方的定义：MessagePack是一种高效的二进制序列化格式。它允许您像JSON一样在多个语言之间交换数据。但是，它更快并且更小。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;从官方定义中，可以有如下的结论：&lt;/p&gt;
&lt;ol start=&quot;1&quot; data-type=&quot;unordered-list&quot; readability=&quot;0.5&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p data-type=&quot;p&quot;&gt;MessagePack是一个二进制序列化格式，因而它序列化的结果可以在多个语言间进行数据的交换。&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p data-type=&quot;p&quot;&gt;从性能上讲，它要比json的序列化格式要好。&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p data-type=&quot;p&quot;&gt;从结果大小上讲，它要比json的序列化结果要小。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt;但是官方并没有提MessagePack和google pb的对比，实际上从空间和时间两个方面对比，pb均要优于MessagePack，但pb相对MessagePack 的缺点是支持的语言种类比较少，需要编写专门的 .proto文件，使用上没有MessagePack方便。&lt;/p&gt;
&lt;p data-type=&quot;p&quot;&gt; &lt;/p&gt;


&lt;h2 id=&quot;2.1-type-system&quot; data-type=&quot;h&quot;&gt;2.1 type system&lt;/h2&gt;
&lt;p&gt;类型体系是MessagePack的基础，也是MessagePack在序列化后比json占用空间小的关键。当前包含的type有如下几类：&lt;/p&gt;
&lt;ul data-type=&quot;unordered-list&quot; readability=&quot;3.5&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;Integer represents an integer&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;
&lt;p&gt;Nil represents nil&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;Boolean represents true or false&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;Float represents a IEEE 754 double precision floating point number including NaN and Infinity&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;
&lt;p&gt;Raw&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;Array represents a sequence of objects&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;Map represents key-value pairs of objects&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;Extension represents a tuple of type information and a byte array where type information is an integer whose meaning is defined by applications or MessagePack specification&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个类型体系将我们在代码开发中用到的数据格式进行了映射，并且通过Extension这个类型给使用者留出了自由扩充的空间，但由于表示形式的限制，当前Extension最多有127个。&lt;/p&gt;

&lt;p&gt;每一种类型能够表示的范围可以查看MessagePack规范中的Limitation部分和Extension types部分。&lt;/p&gt;

&lt;h2 id=&quot;2.2-formats&quot; data-type=&quot;h&quot;&gt;2.2 formats&lt;/h2&gt;
&lt;p&gt;在MessagePack中一个value的组成格式是这样的：类型[长度][data]。下面列出几个示例，详细完整的描述请看附录中的MessagePack规范。&lt;/p&gt;

&lt;h3 id=&quot;2.2.1常量型&quot; data-type=&quot;h&quot;&gt;2.2.1常量型&lt;/h3&gt;
&lt;p&gt;比如对于null、true、false这三个值，在MessagePack会被固定的映射为如下的值。&lt;/p&gt;
&lt;div id=&quot;doc-sheets-0&quot; class=&quot;lark-table&quot;&gt;
&lt;div class=&quot;bi-table&quot;&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;format name&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;first byte (in binary)&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;first byte (in hex)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;nil&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;11000000&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;0xc0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;false&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;11000010&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;0xc2&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;true&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;11000011&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;0xc3&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 id=&quot;2.2.2-int型（包含有符号整数和无符号整数）&quot; data-type=&quot;h&quot;&gt;2.2.2 int型（包含有符号整数和无符号整数）&lt;/h3&gt;

&lt;p&gt;示例如下&lt;/p&gt;

&lt;ul data-type=&quot;unordered-list&quot; readability=&quot;3&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;0xcc表示当前的值的类型是无符号整数并且长度不超过8个bit，具体的值内容需要通过后续8个bit位的内容来计算&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;0xcd表示当前的值的类型是无符号整数并且长度不超过16个bit，具体的值内容需要通过后续16个bit位的内容来计算&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;0xd0表示当前的值的类型是有符号整数并且长度不超过8个bit，具体的值内容需要通过后续8个bit位的内容来计算&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;0xd1表示当前的值的类型是有符号整数并且长度不超过16个bit，具体的值内容需要通过后续16个bit位的内容来计算&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div data-type=&quot;p&quot; readability=&quot;7.5&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
uint 8 stores a 8-bit unsigned integer  
+--------+--------+
|  0xcc  |ZZZZZZZZ|
+--------+--------+

uint 16 stores a 16-bit big-endian unsigned integer
+--------+--------+--------+
|  0xcd  |ZZZZZZZZ|ZZZZZZZZ|
+--------+--------+--------+

int 8 stores a 8-bit signed integer
+--------+--------+
|  0xd0  |ZZZZZZZZ|
+--------+--------+

int 16 stores a 16-bit big-endian signed integer
+--------+--------+--------+
|  0xd1  |ZZZZZZZZ|ZZZZZZZZ|
+--------+--------+--------+
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3 id=&quot;2.2.3-字符串&quot; data-type=&quot;h&quot;&gt;2.2.3 字符串&lt;/h3&gt;

&lt;ul data-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;0xd9表示当前的值的类型是字符串并且长度不超过(2^8)-1个bytes ，具体的长度需要通过后续8个bit位的内容来计算，字符串的具体内容是后续长度的byte所表示的内容&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;0xda表示当前的值的类型是字符串并且长度不超过(2^16)-1个bytes ，具体的长度需要通过后续16个bit位的内容来计算，字符串的具体内容是后续长度的byte所表示的内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
str 8 stores a byte array whose length is upto (2^8)-1 bytes:
+--------+--------+========+
|  0xd9  |YYYYYYYY|  data  |
+--------+--------+========+

str 16 stores a byte array whose length is upto (2^16)-1 bytes:
+--------+--------+--------+========+
|  0xda  |ZZZZZZZZ|ZZZZZZZZ|  data  |
+--------+--------+--------+========+
 
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;2.2.4-数组&quot; data-type=&quot;h&quot;&gt;2.2.4 数组&lt;/h3&gt;

&lt;ul data-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;0xdc表示当前的值的类型是数组并且长度不超过(2^16)-1个元素 ，具体的长度需要通过后续16个bit位（两个byte）的内容来计算，计算出来的值就是数组元素的个数&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;0xdd表示当前的值的类型是数组并且长度不超过(2^32)-1个元素 ，具体的长度需要通过后续32个bit位（4个byte）的内容来计算，计算出来的值就是数组元素的个数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
array 16 stores an array whose length is upto (2^16)-1 elements:
+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdc  |YYYYYYYY|YYYYYYYY|    N objects    |
+--------+--------+--------+~~~~~~~~~~~~~~~~~+

array 32 stores an array whose length is upto (2^32)-1 elements:
+--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
|  0xdd  |ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|ZZZZZZZZ|    N objects    |
+--------+--------+--------+--------+--------+~~~~~~~~~~~~~~~~~+
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&quot;2.2.5-小结&quot; data-type=&quot;h&quot;&gt;2.2.5 小结&lt;/h3&gt;

&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;https://gw.alipayobjects.com/zos/skylark/41821ead-faea-4a48-8adf-77a9178f7ff3/2018/png/ee3e9ba0-2d43-4c21-853e-dc9beebc03c7.png&quot; data-width=&quot;750&quot;&gt;&lt;img src=&quot;https://gw.alipayobjects.com/zos/skylark/41821ead-faea-4a48-8adf-77a9178f7ff3/2018/png/ee3e9ba0-2d43-4c21-853e-dc9beebc03c7.png&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/div&gt;

&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;https://gw.alipayobjects.com/zos/skylark/a95fb844-4e4d-410b-843f-6c8098539d65/2018/png/1976f29a-b8db-4d8e-b620-ccfc823e643d.png&quot; data-width=&quot;750&quot;&gt;&lt;img src=&quot;https://gw.alipayobjects.com/zos/skylark/a95fb844-4e4d-410b-843f-6c8098539d65/2018/png/1976f29a-b8db-4d8e-b620-ccfc823e643d.png&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/div&gt;

&lt;h2 id=&quot;2.3-serialization：type-to-format-conversion&quot; data-type=&quot;h&quot;&gt;2.3 Serialization：type to format conversion&lt;/h2&gt;

&lt;div id=&quot;doc-sheets-1&quot; class=&quot;lark-table&quot;&gt;
&lt;div class=&quot;bi-table&quot;&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;source types&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;output format&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;Integer&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;int format family (positive fixint, negative fixint, int 8/16/32/64 or uint 8/16/32/64)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;Nil&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;nil&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Boolean&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;bool format family (false or true)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Float&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;float format family (float 32/64)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;String&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;str format family (fixstr or str 8/16/32)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Binary&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;bin format family (bin 8/16/32)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Array&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;array format family (fixarray or array 16/32)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Map&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;map format family (fixmap or map 16/32)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Extension&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;ext format family (fixext or ext 8/16/32)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;If an object can be represented in multiple possible output formats, serializers SHOULD use the format which represents the data in the smallest number of bytes.&lt;/p&gt;

&lt;h2 id=&quot;2.4-deserialization:-format-to-type-conversion&quot; data-type=&quot;h&quot;&gt;2.4 Deserialization: format to type conversion&lt;/h2&gt;
&lt;div id=&quot;doc-sheets-2&quot; class=&quot;lark-table&quot;&gt;
&lt;div class=&quot;bi-table&quot;&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;col width=&quot;90px&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;source formats&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;output type&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;positive fixint, negative fixint, int 8/16/32/64 and uint 8/16/32/64&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Integer&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;nil&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Nil&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;false and true&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Boolean&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;float 32/64&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Float&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;fixstr and str 8/16/32&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;String&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;bin 8/16/32&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Binary&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;fixarray and array 16/32&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Array&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;fixmap map 16/32&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Map&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;fixext and ext 8/16/32&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;Extension&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;h2 id=&quot;3.1-直观对比&quot; data-type=&quot;h&quot;&gt;3.1 直观对比&lt;/h2&gt;
&lt;p&gt;可以通过下图的两张图简单进行下对比，第一张图是同一个数据类型的内容用json和messagepack序列化的结果。&lt;/p&gt;

&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;https://gw.alipayobjects.com/zos/skylark/29a613cd-22c3-4df1-858f-abbc8aee78e0/2018/png/9feb3876-44ec-491b-8046-0240cdc7b08b.png&quot; data-width=&quot;750&quot;&gt;&lt;img src=&quot;https://gw.alipayobjects.com/zos/skylark/29a613cd-22c3-4df1-858f-abbc8aee78e0/2018/png/9feb3876-44ec-491b-8046-0240cdc7b08b.png&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/div&gt;


&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;https://gw.alipayobjects.com/zos/skylark/a9d71806-1cfe-49da-885f-a320ca76e235/2018/png/a9a38832-393e-467e-8561-56c015e2655b.png&quot; data-width=&quot;750&quot;&gt;&lt;img src=&quot;https://gw.alipayobjects.com/zos/skylark/a9d71806-1cfe-49da-885f-a320ca76e235/2018/png/a9a38832-393e-467e-8561-56c015e2655b.png&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/div&gt;
&lt;p&gt;从第二张图可以明显看到messagepack要比json占用的空间更少。&lt;/p&gt;

&lt;h2 id=&quot;3.2-序列化结果只有value且value进行了专属映射&quot; data-type=&quot;h&quot;&gt;3.2 序列化结果只有value且value进行了专属映射&lt;/h2&gt;

&lt;div data-type=&quot;image&quot; data-display=&quot;block&quot; data-align=&quot;center&quot; data-src=&quot;https://gw.alipayobjects.com/zos/skylark/a67881d3-38db-4ff7-8472-4354150fffd7/2018/png/a31f7b74-5ae2-4417-88d2-de9eb458b9f1.png&quot; data-width=&quot;615&quot;&gt;&lt;img src=&quot;https://gw.alipayobjects.com/zos/skylark/a67881d3-38db-4ff7-8472-4354150fffd7/2018/png/a31f7b74-5ae2-4417-88d2-de9eb458b9f1.png&quot; alt=&quot;&quot; width=&quot;615&quot;/&gt;&lt;/div&gt;
&lt;p&gt;这张图是MessagePack官网上的，用来进行json和MessagePack序列化结果的对比，实际情况是否确实如此呢？&lt;/p&gt;
&lt;p&gt;我本地使用的msgpack-0.6.12版本。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class MessagePackSerializationCompareJson {

    @Message // Annotation
    public static class MyMessage {
        // public fields are serialized.
        public boolean compact;
        public int schema;
        
        public  String toString() {
            return &quot;compact:&quot;+compact+&quot;;schema:&quot;+schema;
        }

    }
    /**
     * 
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
      //初始化一个对象
        MyMessage src = new MyMessage();
        src.compact = true;
        src.schema=0;
        
      //利用MessagePack进行序列化
        MessagePack msgpack = new MessagePack();
        // Serialize
        byte[] bytes = msgpack.write(src);
        System.out.println(&quot;msgpack result length:&quot;+bytes.length);
        
        //利用json进行序列化
        String jsonResult = JSONObject.toJSON(src).toString();
        System.out.println(&quot;json result length:&quot;+jsonResult.getBytes().length);
        
    }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
json result length:27
msgpack result length:3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;json序列化的结果是27，和官网图片中的结果相同。但MessagePack的序列化结果是3，要比官网中的数字小很多。&lt;/p&gt;
&lt;p&gt;按照上面图片的解释应当是：&lt;/p&gt;
&lt;ul data-type=&quot;unordered-list&quot; readability=&quot;0&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;第一个byte是82，表示序列化后的结果有两个元素&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;第二个byte是c3，表示第一个元素的值是true&lt;/p&gt;
&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;第三个byte是00，表示第二个元素的值是0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了验证我们的推测，我们可以在MyMessage类中再添加一个boolean类型的属性，但不给这个属性赋值，按照java的规范，这个属性的值就是false，按照MessagePack的规范，就会被转为一个byte的c2，这样msgpack序列化后的长度值就是4.  而json序列化的增加值要增加不少，是属性名称的长度+5（false的长度）+4（要增加两个双引号，一个逗号，一个冒号），如果属性名称长度是4，则一共会增加13个byte，总长度就是40.&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class MessagePackSerializationCompareJson {

    @Message // Annotation
    public static class MyMessage {
        // public fields are serialized.
        public boolean compact;
        public int schema;
        public boolean link;
        
        
        public  String toString() {
            return &quot;compact:&quot;+compact+&quot;;schema:&quot;+schema+&quot;;link:&quot;+link;
        }

    }
    /**
     * 
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {
      //初始化一个对象
        MyMessage src = new MyMessage();
        src.compact = true;
        src.schema=0;
        
      //利用json进行序列化
        String jsonResult = JSONObject.toJSON(src).toString();
        System.out.println(&quot;json result length:&quot;+jsonResult.getBytes().length);
        
      //利用MessagePack进行序列化
        MessagePack msgpack = new MessagePack();
        // Serialize
        byte[] bytes = msgpack.write(src);
        System.out.println(&quot;msgpack result length:&quot;+bytes.length);
        
        
        
    }

}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot; language-java&quot; data-syntax=&quot;java&quot;&gt;
 
&lt;/pre&gt;
&lt;p&gt;上面代码的执行的结果也符合猜测：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
json result length:40
msgpack result length:4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从这个数字上看，MessagePack明显优于json，特别是在属性多的情况下差距会更大。即使json中把key去掉，序列化后的结果也要比MessagePack占用的空间大。&lt;/p&gt;

&lt;h2 id=&quot;3.2-序列化对象的属性顺序不能变动&quot; data-type=&quot;h&quot;&gt;3.2 序列化对象的属性顺序不能变动&lt;/h2&gt;
&lt;p&gt;3.1分析了MessagePack序列化的结果中只包含了value，而不包含key。因而在进行反序列化需要保证类中属性的顺序必须保证完全一致，否则就会出错：&lt;/p&gt;
&lt;p&gt;如果两个属性的类型一致，可以反序列化，但是值发生错乱。&lt;/p&gt;
&lt;p&gt;如果两个属性的类型不一致，会抛出类型不匹配异常。&lt;/p&gt;

&lt;h3 id=&quot;3.2.1-顺序不同，类型相同&quot; data-type=&quot;h&quot;&gt;3.2.1 顺序不同，类型相同&lt;/h3&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class SimpleMessagePackPractice {

    @Message // Annotation
    public static class MyMessage {
        // public fields are serialized.
        public boolean compact;
        public boolean link;

        public String toString() {
            return &quot;link:&quot; + link + &quot;;compact:&quot; + compact;
        }
    }

    @Message // Annotation
    public static class MyMessage2 {
        // public fields are serialized.
        public boolean link;
        public boolean compact;

        public String toString() {
            return &quot;link:&quot; + link + &quot;;compact:&quot; + compact;
        }
    }

    /**
     * 
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {

        //初始化一个对象
        MyMessage src = new MyMessage();
        src.compact = true;
        src.link = false;

        //利用MessagePack进行序列化
        MessagePack msgpack = new MessagePack();
        // Serialize
        byte[] bytes = msgpack.write(src);

        //利用MessagePack进行反序列化
        MyMessage2 dst = msgpack.read(bytes, MyMessage2.class);
        System.out.println(&quot;msgpack 原始数据:&quot; + src);
        System.out.println(&quot;msgpack 反序列化:&quot; + dst);
        
        
    }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码的执行结果如下：&lt;/p&gt;
&lt;pre class=&quot; language-plain&quot; data-syntax=&quot;plain&quot;&gt;
&lt;code class=&quot; language-plain&quot;&gt;msgpack 原始数据:link:false;compact:true
msgpack 反序列化:link:true;compact:false&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;3.2.1-顺序不同，类型不同&quot; data-type=&quot;h&quot;&gt;3.2.1 顺序不同，类型不同&lt;/h3&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class SimpleMessagePackPractice {

    @Message // Annotation
    public static class MyMessage {
        // public fields are serialized.
        public boolean compact;
        public String link;

        public String toString() {
            return &quot;link:&quot; + link + &quot;;compact:&quot; + compact;
        }
    }

    @Message // Annotation
    public static class MyMessage2 {
        // public fields are serialized.
        public String link;
        public boolean compact;

        public String toString() {
            return &quot;link:&quot; + link + &quot;;compact:&quot; + compact;
        }
    }

    /**
     * 
     * @param args
     * @throws IOException 
     */
    public static void main(String[] args) throws IOException {

        //初始化一个对象
        MyMessage src = new MyMessage();
        src.compact = true;
        src.link = &quot;www.baidu.com&quot;;

        //利用MessagePack进行序列化
        MessagePack msgpack = new MessagePack();
        // Serialize
        byte[] bytes = msgpack.write(src);

        //利用MessagePack进行反序列化
        MyMessage2 dst = msgpack.read(bytes, MyMessage2.class);
        System.out.println(&quot;msgpack 原始数据:&quot; + src);
        System.out.println(&quot;msgpack 反序列化:&quot; + dst);
        
        
    }

}
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot; language-java&quot; data-syntax=&quot;java&quot;&gt;
 
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
Exception in thread &quot;main&quot; org.msgpack.MessageTypeException: Expected raw value, but got boolean
        at org.msgpack.unpacker.Accept.acceptBoolean(Accept.java:33)
        at org.msgpack.unpacker.MessagePackUnpacker.readOneWithoutStackLarge(MessagePackUnpacker.java:154)
        at org.msgpack.unpacker.MessagePackUnpacker.readOneWithoutStack(MessagePackUnpacker.java:139)
        at org.msgpack.unpacker.MessagePackUnpacker.readOne(MessagePackUnpacker.java:73)
        at org.msgpack.unpacker.MessagePackUnpacker.readString(MessagePackUnpacker.java:502)
        at org.msgpack.template.StringTemplate.read(StringTemplate.java:46)
        at org.msgpack.template.StringTemplate.read(StringTemplate.java:25)
        at org.msgpack.template.AbstractTemplate.read(AbstractTemplate.java:31)
        at com.my.msgpack.SimpleMessagePackPractice$MyMessage2_$$_Template_1305193908_1.read(SimpleMessagePackPractice$MyMessage2_$$_Template_1305193908_1.java)
        at org.msgpack.template.AbstractTemplate.read(AbstractTemplate.java:31)
        at org.msgpack.MessagePack.read(MessagePack.java:388)
        at org.msgpack.MessagePack.read(MessagePack.java:371)
        at com.my.msgpack.SimpleMessagePackPractice.main(SimpleMessagePackPractice.java:61)
&lt;/pre&gt;&lt;/div&gt;



&lt;ol start=&quot;1&quot; data-type=&quot;unordered-list&quot;&gt;&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot; readability=&quot;-0.56521739130435&quot;&gt;

&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;

&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;

&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;

&lt;/li&gt;
&lt;li data-type=&quot;list-item&quot; data-list-type=&quot;unordered-list&quot;&gt;

&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Wed, 14 Feb 2018 13:31:00 +0000</pubDate>
<dc:creator>孙振超</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunzhenchao/p/8448929.html</dc:identifier>
</item>
</channel>
</rss>