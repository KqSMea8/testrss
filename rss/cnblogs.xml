<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>灵活应对流量压力，定期压测服务器，鹿晗结婚都不怕 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/7656384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/7656384.html</guid>
<description>&lt;p&gt;热点来的太快就像龙卷风，明星的八卦总能作为事件引发热点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201710/992994-20171012153515668-2022125927.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;10月8日，鹿晗与关晓彤恋情公布，瞬间上了热搜，粉丝炸了，微博的服务器也跟着瘫痪了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201710/992994-20171012153528215-783054498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;微博瘫痪，让一位微博工程师在结婚的当口放下酒杯，开始扩容服务器，真是哭笑不得。更有网友吐槽，鹿晗其实是个老黑客，让众码农汗颜。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201710/992994-20171012153541090-1466781356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;虽然微博这次瘫痪防不胜防，毕竟明星公布恋情如何预警？然而服务器准备不足也是一点。看看这条微博：顶级流量，可怕的传播层级，如下图所示...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201710/992994-20171012153552012-1954829305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;聊完八卦，回归主题：服务器压力。&lt;/strong&gt;所以你家的服务器还好么？虽不是所有产品都能像微博拥有亿万量级，但在产品预期范围内出现问题，那即便再精美的产品也无法留住用户的心。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201710/992994-20171012153604230-331424727.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot; __bg_gif&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_gif/MDcf9yruyu0icBl12dI9GLwIMovRKRicsGHzLZQaVlbFD6oaIKJC6icicbvEtiaUaDQ7qMicEOn3PyRJFGcfIVSXkoDw/0?wx_fmt=gif&quot; data-ratio=&quot;0.04375&quot; data-w=&quot;640&quot; data-type=&quot;gif&quot; data-order=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、先谈谈服务器相关的性能指标，有很多，但不可能全看，那么有哪些核心呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、90%响应时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是指所有用户的响应时间由小到大进行排序，第90%的响应时间，是用来评估系统容量的重要指标之一。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、TPS性能，关注服务器的服务能力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每秒系统处理事务（通过、失败以及停止）的数量。通过它可以确定系统在任何给定时刻的时间事务负载。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、支持的最大在线人数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指同时登录站点的最大人数或者服务器同时接收下载的最大数量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、服务器自身压测过程总CPU、内存等的变化情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CPU利用率是指：CPU执行非系统空闲进程的时间/CPU总的执行时间；内存占用率指的是此进程所开销的内存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、事务成功率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务成功率=成功处理的事务/所有事务*100%，是检测服务器处理事务成功几率的重要指标。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、市面上有哪些服务器压测方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了能够帮助用户更快捷的获得服务器的核心数据，市场产生了诸多各式各样的压测方法，但也存在各式各样的问题：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、现网数据预估&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据压力测试过程中的部分数据，对未来大量用户访问的情况机型预估。&lt;/p&gt;

&lt;p&gt;存在问题：只适合简单的服务器拟合，复杂服务器数据就不太准确。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、真人压测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过邀请一定数量的真实用户来玩游戏，从而对服务器达到一个测试效果。&lt;/p&gt;

&lt;p&gt;存在问题：&lt;strong&gt;暴露出的性能问题有限&lt;/strong&gt;，封测人数通常还是太少，虽然有几百或者几千用户在玩，但是并发并不够，不足以暴露服务端性能问题；另外&lt;strong&gt;不适合调优&lt;/strong&gt;，真人无法完全重复相同行为，服务器就难以进行回归调优。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、接口测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选择一些具有代表性的功能，通过以小见大的方式，来评估整套服务器性能。&lt;/p&gt;

&lt;p&gt;存在问题：无法遍历整个服务器的接口，难以避免一些微小的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、录制回放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过抓取数据包的方式，来获取游戏时的协议，再把这些捕获的协议重新发送给服务端，通过工具放大协议量级达到性能测试的目的。&lt;/p&gt;

&lt;p&gt;存在问题：面对复杂的协议交互，单纯的放大数据包，无法产生足够压力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、机器人模拟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 通过高还原真实玩家的用户行为，模拟高并发场景，从而得到类似很多人同时游戏的测试效果。&lt;/p&gt;

&lt;p&gt;这些方法各有优劣，腾讯内部普遍使用“机器人模拟”的方法进行压测，而“机器人模拟”的压测方法需要充足的测试时间和很大的人力投入，为此腾讯制定了一个较为通用的测试流程，用以提升压测效率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、腾讯内部服务器性能的测试流程介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据腾讯内部游戏和产品的使用需求，腾讯WeTest团队首先针对http与https协议的页面，梳理了一个通用的压测流程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201710/992994-20171012153646215-1859543637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、 确定压测场景，比如登录，获取信息列表等&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试人员第一步要做的就是测试方案的确认，主要就是提前模拟实际业务中涉及的场景以及场景中用户的使用行为，&lt;strong&gt;通常需要确认这样几点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1） 确认用户的登录状态，用户的登录态是否会不断变化&lt;/p&gt;
&lt;p&gt;2） 用户登录后的访问路径之间的上下文关系&lt;/p&gt;
&lt;p&gt;3） 访问路径之间的参数传递关系&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、 测试人员编写测试用例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编写测试用例就是将上述模拟场景具体化的过程，包括确认压测的人数，人数递增逻辑，具体需要压的接口，接口之间的参数传递等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、 启动机器人进行测试，渐进增加机器人数量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在确认了测试方案后，这一步就是执行的过程，根据测试方案中预估的压力人数，渐进的增加压力的人数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、 记录分析数据及事务处理情况，查看服务器负载的变化以及服务器的当前承载能力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上一步提到了要渐进增加机器人，那么为什么要渐进增加机器人？因为在服务器并发增加的过程中需要不断监控上文服务器的核心数据，不断挑战服务器处理能力的极限，避免上来就使用一个过高的并发数直接超过了服务器处理能力的极限，从而无法起到性能优化的目的。&lt;/p&gt;

&lt;p&gt;一般来说，在机器人增加的过程中，CPU的突然跑满以及响应时间瞬间变长，都可能是服务器产生了瓶颈。因此压测人员需要实时监控压测上升过程中的服务器情况变化，从而定位问题所在。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、 调整配置，迭代测试，预估服务器的承载能力以及可能存在的性能瓶颈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在发现基本的测试问题后，测试人员需要通过不断的调试来定位问题，然后重新发起压测，知道实现最终的测试目的。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;根据这个测试流程，腾讯内部也总结了一些压测产品所需要具备的特点。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1)    简单易上手&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;产品的业务场景是多变的，但是好的压测产品应该让这个场景配置过程变得简单易用，用户在简单输入需要压测的URL即可进行各个接口的测试，大部分测试配置建议提供一个默认值，用户对功能更加了解之后可以自由配置这些参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2)    进阶功能完善&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了简单易用之外，也要给用户提供一些进阶的功能，在简单输入URL的基础上，可以支持用户自定义变量，从文件读取变量，甚至从其他URL的返回值获取变量的值，可以比较真实模拟真实场景，避免请求变量单一。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3)    提供分布式压力机进行压测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于单机的局限性，压测产品可以使用分布式压测的框架，根据用户配置的机器人数量动态分配多个压测机，极大提升压力上限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4)    详细的测试数据统计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;压测大师会记录测试过程中的多项数据，包括在线人数变化、TPS变化、响应时间、收发包流量、服务器CPU内存状态、压力机硬件负载、测试结果统计等，可以快速定位服务器的容量以及瓶颈。&lt;/p&gt;

&lt;p&gt;基于这些需求，腾讯WeTest团队开发了专注服务器压测的产品“压测大师”，简化了压测配置过程，用户可以在线上部署，线上调试，线上查看报告，帮助用户成为最高效的“压测大师”。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;strong&gt;WeTest压测大师&lt;/strong&gt;旨在降低开发者在服务器性能测试方面的门槛，迅速发现服务器端的性能瓶颈，进行针对性的性能调优，降低服务器采购和维护成本，提高用户留存和转化率。&lt;strong&gt;目前主要优势如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ø  一分钟发起测试，无需编写脚本&lt;/p&gt;
&lt;p&gt;Ø  无需配置压力机，随开随用，轻松发起十万压力&lt;/p&gt;
&lt;p&gt;Ø  支持HTTP、HTTPS等协议，覆盖Web，H5，APP，游戏等主流场景&lt;/p&gt;
&lt;p&gt;Ø  实时查看测试报告，多维度报告对比，迅速定位性能瓶&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目前WeTest压测大师已经正式对外开放，&lt;/strong&gt;&lt;strong&gt;点击链接：&lt;a href=&quot;http://wetest.qq.com/gaps?from=content_cnblogs&quot; target=&quot;_blank&quot;&gt;http://wetest.qq.com/gaps/  &lt;/a&gt;即可使用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果对使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：800024531&lt;/p&gt;
</description>
<pubDate>Thu, 12 Oct 2017 07:39:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/7656384.html</dc:identifier>
</item>
<item>
<title>vue2组件之select2调用 - ensleep</title>
<link>http://www.cnblogs.com/ensleep/p/vue-select2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ensleep/p/vue-select2.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;目前，项目中使用了纯前端的静态项目+RESTFul接口的模式。为了更好的对数据进行操作，前端使用了vue2的mvvm功能，但是由于不是单页面应用，所以，并没有涉及到其它的如&lt;code&gt;vue-route&lt;/code&gt;等功能，也未使用&lt;code&gt;webpack&lt;/code&gt;等编译功能，所以，也没有使用&lt;code&gt;.vue&lt;/code&gt;文件功能。这时候，如果用到控件，则多数从原jquery的组件中选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;select下拉搜索选择&quot;&gt;select下拉搜索选择&lt;/h2&gt;
&lt;p&gt;这次的需求调研与设计是原来做winform开发的同事，由于用惯了&lt;code&gt;devexpress&lt;/code&gt;这个控件库，所以，对于&lt;code&gt;searchlookupeditor&lt;/code&gt;这个控件情有独钟，所以，在设计的时候，许多地方都用到。&lt;/p&gt;
&lt;h2 id=&quot;最初实现&quot;&gt;最初实现&lt;/h2&gt;
&lt;p&gt;最初，我使用了select2绑定&lt;code&gt;select&lt;/code&gt;标签，设定其change事件 ，在事件中修改对应的vue的data值，同时，在vue中设定&lt;code&gt;watch``data&lt;/code&gt;中被绑定的属性，属性值发生变化，则修改对应的&lt;code&gt;dom&lt;/code&gt;的val，然后再触发select2的change事件。当然，这种对应关系，我在&lt;code&gt;select&lt;/code&gt;标签上放了一个data-vuep来保存其与vue属性的对应关系，并放在全局的&lt;code&gt;select2vue&lt;/code&gt;和&lt;code&gt;dom2vue&lt;/code&gt;中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//mounted中的部分代码
                        select2vue = {};
                    $(&quot;select&quot;).each(function (index, item) {
                        var s2 = $(item).select2({
                            language: &quot;zh-CN&quot;,  //设置 提示语言
                            width: &quot;100%&quot;, //设置下拉框的宽度
                            theme: &quot;classic&quot;,
                            placeholder: &quot;请选择&quot;
                        }).on(&quot;change&quot;, function (e) {
                            console.log(e);
                            var v = $(e.target).val();
                            var p = $(e.target).attr(&quot;data-vuep&quot;);
                            eval(&quot;vue_cust_busi.&quot; + p + &quot;='&quot; + v + &quot;';&quot;);
                            //$(e.target).find(&quot;option&quot;).attr(&quot;selected&quot;,false);
                            //$(e.target).find(&quot;option[value='&quot;+v+&quot;']&quot;).attr(&quot;selected&quot;,true);
                        });

                        var p = $(item).attr(&quot;data-vuep&quot;);
                        select2vue[p] = s2;
                        dom2vue[p] = item;
                    });
                    setTimeout(function(){
                        vue_cust_busi.editor.ID_CUST=&quot;3&quot;;
                        vue_cust_busi.editor.NAME_CUST=&quot;*有限责任公司&quot;;
                        console.log(&quot;修改&quot;);
                    },10,null);


//watch中的部分代码
                    &quot;temp.P1&quot;: function (val) {
                        fire(arguments.callee.name.toString(), val);

                    },
//通用函数

        function fire(p, val) {
            $(dom2vue[p]).val(val);
            select2vue[p].trigger(&quot;change&quot;);
        }

//html

                                                &amp;lt;select data-vuep=&quot;editor.P1&quot; class=&quot;form-control &quot;&amp;gt; 
                                                        &amp;lt;option value=&quot;&quot; &amp;gt;&amp;lt;/option&amp;gt;    
                                                        &amp;lt;option v-for=&quot;yearOpt in yearOpts&quot; v-bind:value=&quot;yearOpt&quot;&amp;gt;{{yearOpt}}&amp;lt;/option&amp;gt; 
                                                &amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么要用一个&lt;code&gt;data-vuep&lt;/code&gt;来将数据与vue的属性关联呢，因为我发现，&lt;code&gt;select2&lt;/code&gt;初始化了这个&lt;code&gt;select&lt;/code&gt;标签之后，修改这个标签的值无法触发修改vue对应的v-model的属性。所以，只能用这个方法。&lt;br/&gt;最终形成的结果是：&lt;/p&gt;
&lt;h3 id=&quot;select2到vue.editor.p1&quot;&gt;select2到vue.editor.P1：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;select2被选择某一项，触发其change事件。&lt;/li&gt;
&lt;li&gt;select2的change事件修改vue.editor.P1的值。&lt;/li&gt;
&lt;li&gt;vue.editor.P1的值被修改，触发watch，watch又引发select2的change事件，但是，select2内部监控到选择和之前的一致，所以，不再执行change事件的委托。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面这种流程一定程度是实现了数据的双向绑定，但是，非常复杂。在后续的使用中发现，在mounted中无法为select2默认值，必须在mounted中调用setTimeout生成一个定时执行的事件来执行数据绑定操作，才会触发上述流程，达到设定触始值的效果。&lt;/p&gt;
&lt;h2 id=&quot;使用vue指令&quot;&gt;使用vue指令&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;经过一番挣扎，觉得上面这种方式还是不行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述方案不好的原因如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;vue事件中的代码操作了dom，这样，在生命周期上可能会出现问题，特别是后来使用了setTimeout之后，生命周期变得更加不可控制。&lt;/li&gt;
&lt;li&gt;每增加一个select组件，都需要增加 html标签、watch，而且，html 标签和watch既不是传统的写法，也不是vue的写法，而是发明了一种新的东西，这破坏了开发体验。&lt;/li&gt;
&lt;li&gt;维护性比较差，当想删除一个select的时候，必须要去watch里面去找与html中data-vuep相等的属性监控方法，并将其删除掉。&lt;/li&gt;
&lt;li&gt;兼容性不好，本方案选择将页面所有的select全部用select2初始化了一次，使得不论是否需要的，都会被影响；其次，如果不统一初始化，那么又多出了在mounted中为每一个select写初始化代码的工作，同时，也要为每个select取一个id。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.5322580645161&quot;&gt;
&lt;p&gt;为了解决这个问题，我又找到了最初看到的那个vue使用指令和select2的整合的例子。网上有好多，我不知道版权是谁的，姑且上我最先看到的那个吧。&lt;a href=&quot;http://blog.csdn.net/amohan/article/details/58651100&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/amohan/article/details/58651100&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原文中的代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;vue select2 封装&amp;lt;/title&amp;gt;
    &amp;lt;link href=&quot;https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.3/css/select2.min.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
    &amp;lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;https://cdn.bootcss.com/jquery/2.2.4/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.3/js/select2.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        .content{
            text-align: center;
            padding:50px;
        }
        .content *{
            text-align: left;
        }
        .select{
            width: 350px;
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;content&quot; id=&quot;vue-example&quot;&amp;gt;
        &amp;lt;select class=&quot;select&quot; v-select2='options' v-model=&quot;selectValue&quot;&amp;gt;&amp;lt;/select&amp;gt;
        &amp;lt;br/&amp;gt;
        &amp;lt;span&amp;gt;结果：{{ selectValue }}&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    Vue.directive('select2', {
      inserted: function (el, binding, vnode) {
         let options = binding.value || {};
 
        $(el).select2(options).on(&quot;select2:select&quot;, (e) =&amp;gt; {
          // v-model looks for
          //  - an event named &quot;change&quot;
          //  - a value with property path &quot;$event.target.value&quot;
              el.dispatchEvent(new Event('change', { target: e.target })); //说好的双向绑定，竟然不安套路
        });
      },
      update: function(el, binding, vnode) {
        $(el).trigger(&quot;change&quot;);
      }
    });
 
    var vueApp = new Vue({
      el: &quot;#vue-example&quot;,
      data: {
        selectValue: '你还没有选值',
        options: {
            data: [
                    { id: 0, text: 'enhancement' },
                { id: 1, text: 'bug' },
                { id: 2, text: 'duplicate' },
                { id: 3, text: 'invalid' },
                { id: 4, text: 'wontfix' }
            ]
        }
      }
    });
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作者也说了，对vue2.x的双向绑定机制不了解，希望路过的大神帮帮忙。&lt;br/&gt;我不是vue2的大神，甚至连新手都不算，只能说是初学者。我对代码进行了调整，当然，也是操作了dom，但是由于封装在指令里面了，使用人员不需要再次操作，不涉及到开发人员操作dom的情况，我还是可以接受的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
        Vue.directive('select2', {
            inserted: function (el, binding, vnode) {
                let options = binding.value || {};

                $(el).select2(options).on(&quot;select2:select&quot;, (e) =&amp;gt; {
                    // v-model looks for
                    //  - an event named &quot;change&quot;
                    //  - a value with property path &quot;$event.target.value&quot;
                    el.dispatchEvent(new Event('change', { target: e.target })); //说好的双向绑定，竟然不安套路
                    console.log(&quot;fire change in insert&quot;);
                });
            },
            update: function (el, binding, vnode) {
                for (var i = 0; i &amp;lt; vnode.data.directives.length; i++) {
                    if (vnode.data.directives[i].name == &quot;model&quot;) {
                        $(el).val(vnode.data.directives[i].value);
                        console.log(&quot;new value in update:&quot;+vnode.data.directives[i].value);
                    }
                }
                $(el).trigger(&quot;change&quot;);
                console.log(&quot;fire change in update&quot;);
            }
        });

//html代码

&amp;lt;select v-select2=&quot;&quot; v-model=&quot;editor.P1&quot; required=&quot;required&quot; class=&quot;form-control &quot;&amp;gt;
  &amp;lt;option value=&quot;&quot;&amp;gt;&amp;lt;/option&amp;gt;
  &amp;lt;option v-for=&quot;item in codes&quot; v-bind:value=&quot;item.NAME&quot;&amp;gt;{{item.NAME}}&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过好几天的研究，终于我发现在作者原来的代码的update中，加入修改&lt;code&gt;el&lt;/code&gt;的val值，然后再触发&lt;code&gt;select2&lt;/code&gt;的&lt;code&gt;change&lt;/code&gt;事件，就可以了。而在使用方面，只需要给加一个v-select2即可，v-model以及option的配置都依照vue2的推荐方式，原封不动。之所以加了一个空的&lt;code&gt;option&lt;/code&gt;是因为如果不加，默认&lt;code&gt;select2&lt;/code&gt;是选择第一个选项的，但是，由于未知原因，与vue.editor.P1并不同步。&lt;/p&gt;
</description>
<pubDate>Thu, 12 Oct 2017 07:31:00 +0000</pubDate>
<dc:creator>ensleep</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ensleep/p/vue-select2.html</dc:identifier>
</item>
<item>
<title>Revit二次开发初体验 - where_are_you</title>
<link>http://www.cnblogs.com/yankun1991/p/7656207.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yankun1991/p/7656207.html</guid>
<description>&lt;p&gt;       最近换了下工作，由之前的互联网企业转入了BIM软件开发行列。具体原因不多说，作为一个程序员来说学习永无止境。下面来一个Hello World体验下Revit的二次开发&lt;/p&gt;

&lt;h2&gt;事前准备&lt;/h2&gt;
&lt;p&gt;VS&lt;/p&gt;
&lt;p&gt;Revit 2017&lt;/p&gt;

&lt;p&gt;Revit二次开发中会使用到两个dll文件，由这两个文件来提供对Revit中项目数据的访问，两个dll文件的名称为RevitAPI.dll和RevitAPIUI.dll。获取方式在Revit的安装目录中，我本机Revit安装在E盘，E:\Autodesk\2017\Revit 2017，这个路径下会存在这两个文件，拷贝到自己的项目中并将其添加为项目引用即可或者通过Nuget下载。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151412746-684991403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;HelloWorld入门&lt;/h2&gt;

&lt;p&gt;1.创建一个类库项目，并以RevitHelloWorld命名，创建DLL文件夹并将上面提到的两个DLL文件拷贝其中，最后将这两个文件引入到项目中，最终效果如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151429402-940550499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.创建HelloCommand文件，并实现IExternalCommand此接口&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151440512-1059104242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;红色方框中的就是需要实现你需要的功能的地方。&lt;/p&gt;
&lt;p&gt;本例中只简单介绍，所以，代码实现如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151457043-1630955685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中上面的两个特性需要注意必须加上，具体作用可以自己看下。如果不加后期再将这个放入Revit中的时候会提示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151553793-1376939475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;项目编译在bin目录下获得&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151625137-556365046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.打开Revit，创建一个项目&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151635715-2030713895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;4.在Revit中添加刚才写好的功能&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151652309-753151071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击进去下面的界面：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151717465-450712935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择Load将刚才生成的dll文件引入进来&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151733418-494549101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151811215-697820661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击run按钮即可看到刚才代码的效果&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151842543-1281727432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到这第一个HelloWorld的功能就完成了。&lt;/p&gt;

&lt;h2&gt;Revit插件启动模式&lt;/h2&gt;
&lt;p&gt;配置addin文件启动&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151905105-525295984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个目录下创建一个addin文件类型的文件，文件内容如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151918090-1333449164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;唯一标识码的生成可以利用VS,工具菜单下创建GUID功能，将生成的数据粘贴即可：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012151932309-359590625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这之后启动Revit在附件功能中就可以看到：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012152010262-1358976856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;项目调试&lt;/h2&gt;

&lt;p&gt;很多情况下功能的开发总是需要调试的，这样可以跟踪程序的执行步骤，从而发现代码中可能存在的缺陷。这里我们借助VS进行调试。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012152024887-659381547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;选择Revit.exe，将当前程序附加到Revit中。并在代码中加入断点。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012152046277-410932962.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012152124012-426553507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此时在按一节讲的运行程序即可看到如下效果：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/929632/201710/929632-20171012152057496-1243782972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;附件模块下的外部工具和Revit Lookup的安装需要自己完成。&lt;/p&gt;
&lt;p&gt;其中外部工具是用来调试程序的，Revit Lookup则是帮助开发人员查找属性用的。&lt;/p&gt;
</description>
<pubDate>Thu, 12 Oct 2017 07:24:00 +0000</pubDate>
<dc:creator>where_are_you</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yankun1991/p/7656207.html</dc:identifier>
</item>
<item>
<title>初识Hibernate之关联映射（二） - Single_Yam</title>
<link>http://www.cnblogs.com/yangming1996/p/7656132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangming1996/p/7656132.html</guid>
<description>&lt;p&gt;     上篇我们介绍了关联映射的几种形式，有单向多对一，单向一对多，还有双向一对多。本篇接着介绍有关关联映射的其他几种映射方式，主要有以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于外键的单向一对一关联映射&lt;/li&gt;
&lt;li&gt;基于主键的单向一对一关联映射&lt;/li&gt;
&lt;li&gt;单向多对多关联映射&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一、基于外键的单向一对一关联映射&lt;/strong&gt;&lt;br/&gt;     具有一对一关联的表结构也是很常见的，比如：一个人对应于一张身份证。于是我们的person表会有一个外键关联到 idcard表的主键，只要这个外键列唯一即可保证person到idcard表的关系由多对一变为一对一，也就是说单向的一对一关联映射其实上也就是外键列唯一的多对一的关联映射。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Person {
    private int id;
    private String name;
    private IdCard idcard;
    //省略get，set方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class IdCard {
    private int id;
    private String code;
    //省略get，set方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;class name=&quot;Person&quot; table=&quot;person&quot;&amp;gt;
    &amp;lt;id name=&quot;id&quot;&amp;gt;
        &amp;lt;generator class=&quot;native&quot;/&amp;gt;
    &amp;lt;/id&amp;gt;
    &amp;lt;property name=&quot;name&quot;/&amp;gt;
    &amp;lt;many-to-one name=&quot;idcard&quot; column=&quot;idcard_id&quot; unique=&quot;true&quot;/&amp;gt;
&amp;lt;/class&amp;gt;

&amp;lt;class name=&quot;IdCard&quot; table=&quot;idcard&quot;&amp;gt;
    &amp;lt;id name=&quot;id&quot;&amp;gt;
        &amp;lt;generator class=&quot;native&quot;/&amp;gt;
    &amp;lt;/id&amp;gt;
    &amp;lt;property name=&quot;code&quot;/&amp;gt;
&amp;lt;/class&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，几乎所有的代码和多对一关联映射都是差不多的，只不过在 many-to-one 元素中指定 unique=&quot;true&quot;，原来可以有多个具有相同外键值的记录映射到一的一端，现在指定外键值唯一之后，产生了唯一的一对一的关联映射。下面看看我们的测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//main 方法
Person p1 = new Person();
p1.setName(&quot;single&quot;);

IdCard idCard = new IdCard();
idCard.setCode(&quot;2345&quot;);

p1.setIdcard(idCard);

session.save(p1);
session.save(idCard);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们分别创建两端的一个实例对象，然后由person端维护这种关联关系并将数据插入到数据库。看一眼结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171010174531690?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是基于外键的单向一对一关联映射，与多对一的映射的唯一区别就在于，通过指定外键列唯一来让多的一端唯一，从而形成这种一对一的映射关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、基于主键的单向一对一关联映射&lt;/strong&gt;&lt;br/&gt;     所谓基于主键的映射就是指，其中的一张表的主键值依赖于另一张表的主键值。还是我们的人和身份证模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171011200732758?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;像这种IDCard表完全可以作为属性字段追加到person表的后面的情况（主键重复可覆盖），我们叫这种关联映射为基于主键的一对一关联映射。看看配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*person实体类的映射文件的配置*/
&amp;lt;class name=&quot;Person&quot; table=&quot;person&quot;&amp;gt;
    &amp;lt;id name=&quot;id&quot; column=&quot;pId&quot;&amp;gt;
        &amp;lt;generator class=&quot;foreign&quot;&amp;gt;
            &amp;lt;param name=&quot;property&quot;&amp;gt;idCard&amp;lt;/param&amp;gt;
        &amp;lt;/generator&amp;gt;
    &amp;lt;/id&amp;gt;
    &amp;lt;property name=&quot;name&quot;/&amp;gt;
    &amp;lt;one-to-one name=&quot;idCard&quot; constrained=&quot;true&quot;/&amp;gt;
&amp;lt;/class&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/*IDCard实体类的映射文件的配置*/
&amp;lt;class name=&quot;IdCard&quot; table=&quot;idCard&quot;&amp;gt;
    &amp;lt;id name=&quot;id&quot;&amp;gt;
        &amp;lt;generator class=&quot;native&quot;/&amp;gt;
    &amp;lt;/id&amp;gt;
    &amp;lt;property name=&quot;code&quot;/&amp;gt;
&amp;lt;/class&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，主要的变化还是在于实体类person。首先我们指定他的主键不再自增，而是由外键约束到其他表，对应的其他表的类型则是自己实体类的idCard属性对应的表。one-to-one标签则配置了person类中的IdCard属性，便于我们在取数据的时候Hibernate填充数据到该属性中。下面我们添加数据到数据库中，通过查看输出的Sql语句了解Hibernate是如何为我们创建关联的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Person person = new Person();
person.setName(&quot;single&quot;);

IdCard idCard = new IdCard();
idCard.setCode(&quot;23456789&quot;);
        
person.setIdCard(idCard);

session.save(idCard);
session.save(person);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171011222547893?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，我们对于idcard表的主键指定了native自增，而对于person表的主键并没有指定自增，person表的主键依赖于idcard的主键。我们并不用指定person表的主键值，因为person会根据和自己关联的idcard表的主键来为自己的主键赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、单向多对多关联映射&lt;/strong&gt;&lt;br/&gt;     多对多的表关联类型也是非常常见的，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171011225407017?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很常见的一个例子，一个学生可以有多个老师，同时一个老师也可以有多个学生，那么这就是很明显的多对多的关联映射。针对这种情况，一般来说数据库的表可以设计如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171012125500853?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是这种的表结构设计将会直接导致student表大量冗余，虽然解决了这种多对多的表级关联，但是存在大量冗余。Hibernate中处理这种多对多的关联关系是通过引入另一张表来实现对两个表主键的关联进而关联了两张表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171012130405949?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Student表和teacher表之间的多对多关联完全由connect表进行体现，各自表中数据不再大量冗余，这才是一种比较清晰的表结构设计。下面我们看代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Student {
    private int id;
    private String sName;
    private Set&amp;lt;Teacher&amp;gt; teachers = new HashSet&amp;lt;Teacher&amp;gt;(0);
    //省略get，set方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class Teacher {
    private int id;
    private String tName;
    //省略get，set方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是两张表对应的实体类，下面我们主要看映射文件的配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*配置实体类Student*/
&amp;lt;class name=&quot;Student&quot; table=&quot;student&quot;&amp;gt;
     &amp;lt;id name=&quot;id&quot;&amp;gt;
        &amp;lt;generator class=&quot;native&quot;/&amp;gt;
     &amp;lt;/id&amp;gt;
    &amp;lt;property name=&quot;sName&quot;/&amp;gt;
    &amp;lt;set name=&quot;teachers&quot; table=&quot;connect&quot; cascade=&quot;save-update&quot;&amp;gt;
        &amp;lt;key column=&quot;stuId&quot;&amp;gt;&amp;lt;/key&amp;gt;
        &amp;lt;many-to-many class=&quot;Teacher&quot; column=&quot;tId&quot;/&amp;gt;
    &amp;lt;/set&amp;gt;
&amp;lt;/class&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/*配置实体类Teacher*/
&amp;lt;class name=&quot;Teacher&quot; table=&quot;teacher&quot;&amp;gt;
    &amp;lt;id name=&quot;id&quot;&amp;gt;
       &amp;lt;generator class=&quot;native&quot;/&amp;gt;
    &amp;lt;/id&amp;gt;
    &amp;lt;property name=&quot;tName&quot;/&amp;gt;
&amp;lt;/class&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Teacher实体类的配置并没有什么特殊需要解释的地方，而对于Student实体类的配置却稍有变化。其中的set标签就负责创建一张新表并负责关联两张表，table属性就是用于连接两张表主键值的表名（connect）。对于用于连接的表，有两个字段，一个是Student表的id，一个是teacher表的id，那么key标签就用于指定Student表id对应connect表中的名称，teacher表的id对应到connect表的名称则由many-to-many标签的column属性指定。下面我们插入多条数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171012144015071?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzUzMjY3MTg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，通过抽出connect表连关联两张表，对于Student和teacher表的表结构来说是更加简洁清晰的。&lt;/p&gt;
&lt;p&gt;至此，有关Hibernate中关联映射的内容已经简单介绍完毕，虽然以后会更多的使用注解来配置这些映射关联，但是都是基于XML的，对于新手来说，学习XML配置关联映射是有助于理解注解配置。总结不到之处，望指出，下篇我们学习集合的映射。&lt;/p&gt;
</description>
<pubDate>Thu, 12 Oct 2017 07:01:00 +0000</pubDate>
<dc:creator>Single_Yam</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangming1996/p/7656132.html</dc:identifier>
</item>
<item>
<title>SQLserver学习（四）——T-SQL编程之事务、索引和视图 - 温一壶清酒</title>
<link>http://www.cnblogs.com/hong-fithing/p/7656137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hong-fithing/p/7656137.html</guid>
<description>&lt;p&gt;今天来分享下T-SQL高级编程中的事务、索引、视图，可以和之前的SQL server系列文章结合起来。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;一、事务&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么&lt;strong&gt;都执行&lt;/strong&gt;、要么&lt;strong&gt;都不执行，&lt;/strong&gt;事务是一个不可分割的工作逻辑单元&lt;/p&gt;
&lt;p&gt;这样说可能太笼统，看个实例就会清晰很多，比如银行转账业务，相信大家都办理过。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; bank
(
    customerName &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;),  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;顾客姓名&lt;/span&gt;
    currentMoney &lt;span&gt;money&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt;当前余额&lt;/span&gt;
&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;
&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; bank
   &lt;/span&gt;&lt;span&gt;add&lt;/span&gt; &lt;span&gt;constraint&lt;/span&gt;&lt;span&gt; CK_currentMoney   
       &lt;/span&gt;&lt;span&gt;check&lt;/span&gt;(currentMoney&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;go&lt;/span&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;&lt;span&gt; bank(customerName,currentMoney)
        &lt;/span&gt;&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;&lt;span&gt; bank(customerName,currentMoney)
        &lt;/span&gt;&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

--模拟银行转账：
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--转账测试：张三转账1000元给李四--&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;我们可能会这样这样编写语句&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt;张三的账户少1000元，李四的账户多1000元&lt;/span&gt;
&lt;span&gt;UPDATE&lt;/span&gt; bank &lt;span&gt;SET&lt;/span&gt; currentMoney&lt;span&gt;=&lt;/span&gt;currentMoney&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;
     &lt;span&gt;WHERE&lt;/span&gt; customerName&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;UPDATE&lt;/span&gt; bank &lt;span&gt;SET&lt;/span&gt; currentMoney&lt;span&gt;=&lt;/span&gt;currentMoney&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;
     &lt;span&gt;WHERE&lt;/span&gt; customerName&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;再次查看转账后的结果。&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; bank
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样写的SQL代码，实际结果会出现，张三的钱没少，而李四的钱多了1000，是因为添加的约束条件，&lt;strong&gt;money要&amp;gt;=1&lt;/strong&gt;，才导致这样结果。&lt;/p&gt;
&lt;p&gt;转账那个人的钱没少，而另一方却收到了钱，这样的话，银行岂不亏死，所以，这样的代码明显是不合理的。根据事务概念，是要么执行成功，要是失败，只有这两种结果，而且是同步的。&lt;/p&gt;
&lt;p&gt;代码改进为如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;使用事务解决：
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--定义变量，用于累计事务执行过程中的错误--&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@errorSum&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;初始化为0，即无错误&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt;--转账：张三的账户少1000元，李四的账户多1000元&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;UPDATE&lt;/span&gt; bank &lt;span&gt;SET&lt;/span&gt; currentMoney&lt;span&gt;=&lt;/span&gt;currentMoney&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;
   &lt;span&gt;WHERE&lt;/span&gt; customerName&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;@@error&lt;/span&gt;
&lt;span&gt;UPDATE&lt;/span&gt; bank &lt;span&gt;SET&lt;/span&gt; currentMoney&lt;span&gt;=&lt;/span&gt;currentMoney&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;
   &lt;span&gt;WHERE&lt;/span&gt; customerName&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;@@error&lt;/span&gt;  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;累计是否有错误&lt;/span&gt;

&lt;span&gt;IF&lt;/span&gt; &lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;如果有错误&amp;lt;&amp;gt;表示不等于与！=的效果一样&lt;/span&gt;
  &lt;span&gt;BEGIN&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;交易失败，回滚事务&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;ROLLBACK&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt;
  &lt;span&gt;END&lt;/span&gt; 
&lt;span&gt;ELSE&lt;/span&gt;
  &lt;span&gt;BEGIN&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;交易成功，提交事务，写入硬盘，永久的保存&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt;  
  &lt;span&gt;END&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;查看转账事务后的余额&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; bank 
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加事务后，就会保证数据的正确性了，到这，我想大家已经明白事务的好处了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;事务的四大属性，简称ACID属性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　原子性（Atomicity）：事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　一致性（Consistency）：当事务完成时，数据必须处于一致状态&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　隔离性（Isolation）：对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务&lt;/p&gt;
&lt;p&gt;　　永久性（Durability）：事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创建事务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
开始事务：&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt;&lt;span&gt;
提交事务：&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt;&lt;span&gt;
回滚（撤销）事务：&lt;/span&gt;&lt;span&gt;ROLLBACK&lt;/span&gt; &lt;span&gt;TRANSACTION&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦事务提交或回滚，则事务结束。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;判断某条语句执行是否出错：@@ERROR的返回值为0表示没错&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;使用全局变量@@ERROR；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;@@ERROR只能判断当前一条T-SQL语句执行是否有错，为了判断事务中所有T-SQL语句是否有错，我们需要对错误进行累计；&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            如： SET @errorSum=@errorSum+@@error&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;事务分类：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;显示事务:用BEGIN TRANSACTION明确指定事务的开始，这是最常用的事务类型&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;隐性事务：通过设置SET IMPLICIT_TRANSACTIONS ON 语句，将隐性事务模式设置为打开，下一个语句自动启动一个新事务。当该事务完成时，再下一个 T-SQL 语句又将启动一个新事务&lt;/p&gt;
&lt;p&gt;自动提交事务：这是 SQL Server 的默认模式，它将每条单独的 T-SQL 语句视为一个事务，如果成功执行，则自动提交；如果错误，则自动回滚&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、索引&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;索引根据索引键查找定位数据行&lt;/p&gt;
&lt;p&gt;索引：是SQL Server编排数据的内部方法。它为SQL Server提供一种方法来编排查询数据 。&lt;/p&gt;
&lt;p&gt;索引页：数据库中存储索引的数据页；索引页类似于汉语字（词）典中按拼音或笔画排序的目录页。&lt;/p&gt;
&lt;p&gt;索引的作用：通过使用索引，可以大大提高数据库的检索速度，改善数据库性能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;索引类型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　唯一索引：唯一索引不允许两行具有相同的索引值&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　主键索引：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引要求主键中的每个值是唯一的，并且不能为空&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　聚集索引(Clustered)：表中各行的物理顺序与键值的逻辑（索引）顺序相同，每个表只能有一个，比如：拼音&lt;/p&gt;
&lt;p&gt;　　非聚集索引(Non-clustered)：非聚集索引指定表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于249个，比如：偏旁&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创建索引&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;UNIQUE&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;CLUSTERED|NONCLUSTERED&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;唯一索引，聚集索引或非聚集索引&lt;/span&gt;
&lt;span&gt;INDEX&lt;/span&gt;&lt;span&gt;   index_name
&lt;/span&gt;&lt;span&gt;ON&lt;/span&gt;&lt;span&gt; table_name (column_name…)
&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;WITH FILLFACTOR=x&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;UNIQUE表示唯一索引，可选&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;CLUSTERED、NONCLUSTERED表示聚集索引还是非聚集索引，可选&lt;/p&gt;
&lt;p&gt;FILLFACTOR表示填充因子，指定一个0到100之间的值，该值指示索引页填满的空间所占的百分比&lt;/p&gt;
&lt;p&gt;创建索引举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;USE&lt;/span&gt;&lt;span&gt; stuDB
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; name &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; sysindexes 
          &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;IX_writtenExam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
   &lt;/span&gt;&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt;&lt;span&gt; stuMarks.IX_writtenExam  
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--笔试列创建非聚集索引：填充因子为30％--&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;NONCLUSTERED&lt;/span&gt; &lt;span&gt;INDEX&lt;/span&gt;&lt;span&gt; IX_writtenExam
     &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt;&lt;span&gt; stuMarks(writtenExam)
       &lt;/span&gt;&lt;span&gt;WITH&lt;/span&gt; &lt;span&gt;FILLFACTOR&lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;30&lt;/span&gt;
&lt;span&gt;GO&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;-----指定按索引 IX_writtenExam 查询----&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; stuMarks   &lt;span&gt;with&lt;/span&gt;(&lt;span&gt;INDEX&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;IX_writtenExam)
    &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; writtenExam &lt;span&gt;BETWEEN&lt;/span&gt; &lt;span&gt;60&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; &lt;span&gt;90&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创建索引的指导原则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;请按照下列标准选择建立索引的列。&lt;/p&gt;
&lt;p&gt;　　该列用于频繁搜索&lt;/p&gt;
&lt;p&gt;　　该列用于对数据进行排序&lt;/p&gt;
&lt;p&gt;请不要使用下面的列创建索引：&lt;/p&gt;
&lt;p&gt;　　列中仅包含几个不同的值。&lt;/p&gt;
&lt;p&gt;　　表中仅包含几行。为小型表创建索引可能不太划算，因为SQL Server在索引中搜索数据所花的时间比在表中逐行搜索所花的时间更长&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、视图&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;视图是一张虚拟表，它表示一张表的部分数据或多张表的综合数据，其结构和数据是建立在对表的查询基础上，视图中并不存放数据，而是存放在视图所引用的原始表（基表）中，同一张原始表，根据不同用户的不同需求，可以创建不同的视图&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;视图的用途：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　筛选表中的行&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　防止未经许可的用户访问敏感数据&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　降低数据库的复杂程度&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　将多个物理数据库抽象为一个逻辑数据库&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;SQL Server中允许用户创建视图，在同一原始数据表的基础上，为不同的用户选择不同的列，从而达到不同用户的需求。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;创建视图语法：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;VIEW&lt;/span&gt;&lt;span&gt; view_name 
   &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;select语句&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;IF&lt;/span&gt; &lt;span&gt;EXISTS&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; sysobjects &lt;span&gt;WHERE&lt;/span&gt; name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;view_stuInfo_stuMarks&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 检查视图是否存在
&lt;/span&gt;&lt;span&gt;DROP&lt;/span&gt; &lt;span&gt;VIEW&lt;/span&gt;&lt;span&gt; view_stuInfo_stuMarks 删除视图
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;VIEW&lt;/span&gt;&lt;span&gt; view_stuInfo_stuMarks 创建视图
  &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;
  &lt;span&gt;SELECT&lt;/span&gt; 姓名&lt;span&gt;=&lt;/span&gt;stuName,学号&lt;span&gt;=&lt;/span&gt;stuInfo.stuNo,笔试成绩 &lt;span&gt;=&lt;/span&gt;writtenExam,机试成绩&lt;span&gt;=&lt;/span&gt;labExam,平均分&lt;span&gt;=&lt;/span&gt;(writtenExam&lt;span&gt;+&lt;/span&gt;labExam)&lt;span&gt;/&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
  &lt;span&gt;FROM&lt;/span&gt; stuInfo &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; stuMarks &lt;span&gt;ON&lt;/span&gt; stuInfo.stuNo&lt;span&gt;=&lt;/span&gt;&lt;span&gt;stuMarks.stuNo
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; view_stuInfo_stuMarks 使用视图
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;29.483394833948&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;本文仅代表作者观点，系作者@温一壶清酒发表。&lt;br/&gt;欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;br/&gt;文章出处：&lt;a href=&quot;http://www.cnblogs.com/hong-fithing/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hong-fithing/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 12 Oct 2017 07:01:00 +0000</pubDate>
<dc:creator>温一壶清酒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hong-fithing/p/7656137.html</dc:identifier>
</item>
<item>
<title>干货,比较全面的c#.net公共帮助类 - 安于生</title>
<link>http://www.cnblogs.com/anyushengcms/p/7656090.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anyushengcms/p/7656090.html</guid>
<description>

&lt;p&gt;       比较全面的c#帮助类，日常工作收集，包括前面几家公司用到的，各式各样的几乎都能找到,所有功能性代码都是独立的类，类与类之间没有联系，可以单独引用至项目，分享出来，方便大家，几乎都有注释，喜欢的请点赞，不断完善收集中... &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1202772/201710/1202772-20171012144433902-941262006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;     比较详细，这里是重点，花了一些时间&lt;/p&gt;


&lt;p&gt;       在平时的工作中，或多或少会涉及到帮助类，最常见的上传下载文件，excel，sqlhelper,等等，我相信很多对大家来说都不难， 但是如果什么都重头去写的话，确实很浪费时间，如果有比较全面的帮助类，我需要什么就能找到该多好，我现在做的就是收集尽量多的帮助类，方便日后用到。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1202772/201710/1202772-20171012144723074-1452402643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    里面包含一下操作文档，这个是用工具生成的。还在研究中...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1202772/201710/1202772-20171012144840902-1345877814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;1. cookie操作 --------- CookieHelper.cs&lt;br/&gt;2. session操作 ------- SessionHelper.cs&lt;br/&gt;3. cache操作&lt;br/&gt;4. ftp操作&lt;br/&gt;5. http操作 ------------ HttpHelper.cs&lt;br/&gt;6. json操作 ------------ JsonHelper.cs&lt;br/&gt;7. xml操作 ------------- XmlHelper.cs&lt;br/&gt;8. Excel操作&lt;br/&gt;9. Sql操作 ------------- SqlHelper.cs&lt;br/&gt;10. 类型转换 ------------ Converter.cs&lt;br/&gt;11. 加密解密 ------------ EncryptHelper.cs&lt;br/&gt;12. 邮件发送 ------------ MailHelper.cs&lt;br/&gt;13. 二维码&lt;br/&gt;14. 汉字转拼音&lt;br/&gt;15. 计划任务 ------------ IntervalTask.cs&lt;br/&gt;16. 信息配置 ------------ Setting.cs&lt;br/&gt;17. 上传下载配置文件操作类&lt;br/&gt;18. 视频转换&lt;br/&gt;19. 图片操作&lt;br/&gt;20. 验证码生成&lt;br/&gt;21. String拓展 ---------- StringExtension.cs&lt;br/&gt;22. 正则表达式 --------- RegexHelper.cs&lt;br/&gt;23. 分页操作&lt;br/&gt;24. UBB编码&lt;br/&gt;25. Url重写&lt;br/&gt;26. Object拓展 --------- ObjectExtension.cs&lt;br/&gt;27. Stream的拓展 ------ StreamExtension.cs&lt;br/&gt;28. CSV文件转换&lt;br/&gt;29. Chart图形&lt;br/&gt;30. H5-微信&lt;br/&gt;31. PDF&lt;br/&gt;32. 分词辅助类&lt;br/&gt;33. 序列化&lt;br/&gt;34. 异步线程&lt;br/&gt;35. 弹出消息类&lt;br/&gt;36. 文件操作类&lt;br/&gt;37. 日历&lt;br/&gt;38. 日志&lt;br/&gt;39. 时间操作类&lt;br/&gt;40. 时间戳&lt;br/&gt;41. 条形码&lt;br/&gt;42. 正则表达式&lt;br/&gt;43. 汉字转拼音&lt;br/&gt;44. 网站安全&lt;br/&gt;45. 网络&lt;br/&gt;46. 视频转换类&lt;br/&gt;47. 计划任务&lt;br/&gt;48. 配置文件操作类&lt;br/&gt;49. 阿里云&lt;br/&gt;50. 随机数类&lt;br/&gt;51. 页面辅助类&lt;br/&gt;52. 验证码&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;h2&gt;github地址&lt;/h2&gt;
&lt;p&gt;最后老规矩，github地址：&lt;a href=&quot;https://github.com/Jimmey-Jiang/Common.Utility.git&quot; target=&quot;_blank&quot;&gt;https://github.com/Jimmey-Jiang/Common.Utility.git&lt;/a&gt; 求star,喜欢点赞&lt;/p&gt;
&lt;h2&gt;里面的操作类都很详细，基本都有注释&lt;/h2&gt;
&lt;p&gt;比如这里展示一下 字符串操作帮助类就有下面这个方法：&lt;br/&gt;1、GetStrArray(string str, char speater, bool toLower) 把字符串按照分隔符转换成 List&lt;br/&gt;2、GetStrArray(string str) 把字符串转 按照, 分割 换为数据&lt;br/&gt;3、GetArrayStr(List list, string speater) 把 List 按照分隔符组装成 string&lt;br/&gt;4、GetArrayStr(List list) 得到数组列表以逗号分隔的字符串&lt;br/&gt;5、GetArrayValueStr(Dictionary&amp;lt;int, int&amp;gt; list)得到数组列表以逗号分隔的字符串&lt;br/&gt;6、DelLastComma(string str)删除最后结尾的一个逗号&lt;br/&gt;7、DelLastChar(string str, string strchar)删除最后结尾的指定字符后的字符&lt;br/&gt;8、ToSBC(string input)转全角的函数(SBC case)&lt;br/&gt;9、ToDBC(string input)转半角的函数(SBC case)&lt;br/&gt;10、GetSubStringList(string o_str, char sepeater)把字符串按照指定分隔符装成 List 去除重复&lt;br/&gt;11、GetCleanStyle(string StrList, string SplitString)将字符串样式转换为纯字符串&lt;br/&gt;12、GetNewStyle(string StrList, string NewStyle, string SplitString, out string Error)将字符串转换为新样式&lt;br/&gt;13、SplitMulti(string str, string splitstr)分割字符串&lt;br/&gt;14、SqlSafeString(string String, bool IsDel)&lt;/p&gt;
</description>
<pubDate>Thu, 12 Oct 2017 06:53:00 +0000</pubDate>
<dc:creator>安于生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anyushengcms/p/7656090.html</dc:identifier>
</item>
<item>
<title>程序员的自我修养十内存 - 目不识丁</title>
<link>http://www.cnblogs.com/Tan-sir/p/7652149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tan-sir/p/7652149.html</guid>
<description>&lt;p&gt;内存是承载程序运行的介质，也是程序进行各种运算和表达的场所。&lt;/p&gt;
&lt;h2&gt;10.1 程序的内存布局&lt;/h2&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;现代的应用程序都运行在一个内存空间里，在32位系统里，这个内存空间拥有4GB（2的32次方）的寻址能力。现在的应用程序可以直接使用32位地址进行寻址，这被称为平坦的内存模型。在平坦的内存模型中，整个内存是一个统一的地址空间，用户可以使用一个32位的指针访问任意的内存位置。&lt;/p&gt;
&lt;p&gt;大多数操作系统都会将4GB内存空间中的一部分挪给内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为内核空间。&lt;/p&gt;
&lt;p&gt;应用程序使用内存空间有如下”默认”的区域：&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;栈：用于维护函数调用的上下文，离开了栈函数调用就没办法实现&lt;/li&gt;
&lt;li&gt;堆：堆是用来容纳应用程序动态分配内存区域，当程序使用malloc或new分配内存时，得到的内存来自堆里。&lt;/li&gt;
&lt;li&gt;可执行文件映像：这里存储着可执行文件在内存里的映像，有装载器在装载时将可执行文件的内存读取或映射到这里。&lt;/li&gt;
&lt;li&gt;保留区：不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域总称。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;10.2 栈与调用惯例&lt;/h2&gt;
&lt;h3&gt;10.2.1 什么是栈&lt;/h3&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;栈被定义为一个特殊的容器，用户可以将数据压入栈中(入栈，push)，也可以将已经压入栈中的数据弹出(出栈，pop)，但栈这个容器必须遵守一条规格：先入栈的数据后出栈。&lt;/p&gt;
&lt;p&gt;栈是一个具有上面属性的动态内存区域。压栈操作使得栈增大，而弹出操作使栈减小。&lt;/p&gt;
&lt;p&gt;在经典操作系统中，栈总使向下增长的。&lt;/p&gt;
&lt;p&gt;栈保存一个函数调用所需要的维护信息，这常常被称为堆栈帧或活动记录。&lt;/p&gt;
&lt;p&gt;堆栈帧一般包括如下几方面：&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;函数返回地址和参数&lt;/li&gt;
&lt;li&gt;临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。&lt;/li&gt;
&lt;li&gt;保存的上下文：包括在函数调用前后需要保持不变的寄存器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在一个i386下的函数总是这样调用的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存器传递。&lt;/li&gt;
&lt;li&gt;把当前指令的下一条指令的地址压入栈中。&lt;/li&gt;
&lt;li&gt;跳转到函数体执行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个函数的活动记录用ebp和esp这两个寄存器划定范围。esp寄存器始终指向栈的顶部，同时也就是指向当前函数的活动记录的顶部。ebp寄存器指向了函数活动记录的一个固定位置，ebp寄存器又被称为帧指针。&lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/725789/201710/725789-20171011183500262-212887781.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;ebp固定在图中所示的位置，不随这个函数的执行而变化。esp始终指向栈顶，因此随这函数的执行，esp会不断变化。固定不变的ebp可以用来定位函数活动记录中的各个数据。&lt;/p&gt;
&lt;h3&gt;10.2.2 调用惯例&lt;/h3&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;函数的调用方和被调用方对于函数如何调用须要有一个明确的约定，这样的约定就是调用惯例。&lt;/p&gt;
&lt;p&gt;一个调用惯例有如下几方面：&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;函数参数的传递顺序和方式：最常见的一种是通过栈传递。对于有多个参数的函数，调用惯例要规定函数调用方将参数压栈的顺序：是从左至右，还是从右至左。&lt;/li&gt;
&lt;li&gt;栈的维护方式：在函数将参数压栈之后，函数体会被调用，此后需要将压入栈中的参数全部弹出，以使得栈在函数调用前后保持一致。&lt;/li&gt;
&lt;li&gt;名字修饰：为了链接的时候堆调用惯例进行区分，调用管理要对函数本身的名字进行修饰。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;多级调用栈布局：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/725789/201710/725789-20171011183549449-274461460.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;div readability=&quot;25&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/725789/201710/725789-20171011183558559-1757693758.png&quot; alt=&quot;&quot;/&gt;&lt;h3&gt;10.2.3 函数返回值传递&lt;/h3&gt;
&lt;p&gt;除了参数传递之外，函数与调用方的交互好友一个渠道就是返回值。eax是传递返回值的通道。函数将返回值存储在eax中，返回后函数的调用方在读取eax。对于大于4字节的返回值，采用eax和edx联合返回的方式进行。&lt;/p&gt;
&lt;p&gt;如果返回值太大，C语言在函数返回时会使用一个临时的栈上内存区域作为中转，结果返回值对象会被拷贝两次。&lt;/p&gt;
&lt;h2&gt;10.3 堆和内存管理&lt;/h2&gt;
&lt;p&gt;堆这片内存面临一个复杂的行为模式：在任意时刻程序可能发出请求，申请一段内存或者释放一段已经申请了的内存，而且申请的大小从几个字节到数GB都可能，我们不能假设程序会一次申请多少空间，所以，堆的管理比较复杂&lt;/p&gt;
&lt;h3&gt;10.3.1 什么是堆&lt;/h3&gt;
&lt;p&gt;栈上的数据在函数返回的时候就会被释放掉，所以无法将数据传递至函数外部。全局变量没有办法动态产生数据，只能在编译器的时候定义。这这种情况下，堆是唯一选择。&lt;/p&gt;
&lt;p&gt;堆是一块巨大的内存空间，常常占据了整个虚拟空间的绝大部分。&lt;/p&gt;
&lt;h3&gt;10.3.2 Linux进程堆管理&lt;/h3&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;p&gt;Linux下进程堆管理有两种分配方式，即两个系统调用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;brk()系统调用：实际上就是设置进程数据段的结束地址，它可以扩大或者缩小数据段。&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;mmap()系统调用：作用和windows下的VirtualAlloc相似，作用是向操作系统申请一段虚拟地址空间，这块虚拟地址空间可以映射到某个文件，当它不将地址空间映射到某个文件时，我们称做为匿名空间，它可以拿来作为堆空间。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;10.3.3 Windows进程堆管理&lt;/h3&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;Windows的进程将地址分配给了各种EXE、DLL、堆、栈。&lt;/p&gt;
&lt;p&gt;每个线程默认栈的大小是1MB，在线程启动时，系统就会为它的进程地址空间中分配相应的地址空间作为栈，线程栈的大小可以由创建时CreatThread的参数指定。&lt;/p&gt;
&lt;p&gt;Windows提供一个API叫做VirtualAlloc()，用来向系统申请空间，它要求空间大小必须为页的整数倍。&lt;/p&gt;
&lt;p&gt;堆分配算法在的实现位于堆管理器，堆管理器提供了一套与堆相关的API用来创建、分配、释放和销毁堆空间&lt;/p&gt;
&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;HeapCreate：创建一个堆&lt;/li&gt;
&lt;li&gt;HeapAlloc：在一个堆中分配内存&lt;/li&gt;
&lt;li&gt;HeapFree：释放已经分配的内存&lt;/li&gt;
&lt;li&gt;HeapDestroy：摧毁一个堆&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个进程在创建时都会有一个默认堆，这个堆在进程启动时创建，并且直到进程结束都一直存在。默认堆大小为1MB。一个进程中一次性能够分配的最大堆空间取决于最大的那个堆。&lt;/p&gt;
&lt;h3&gt;10.3.4 堆分配算法&lt;/h3&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;如何管理一大块连续的内存空间，能够按照需求分配、释放其中的空间，这就是堆算法。&lt;/p&gt;
&lt;h5&gt;空间链表&lt;/h5&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;空闲链表实际上就是把堆中各个空闲的块按照链表的方式连接起来，当用户请求一块空间时，可以遍历整个列表，直到找到合适大小的块并且将它拆分，当用户释放空间时将它合并到空闲链表中。&lt;/p&gt;
&lt;p&gt;空闲链表时这样一种结构，在堆里的每个空闲空间的大小（或结尾）有一个头(Header)，头结构里记录了上一个（prev）和下一个(next)空闲块的地址。所有的空闲块形成一个链表。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/725789/201710/725789-20171011183848605-401427678.png&quot; alt=&quot;&quot;/&gt;&lt;h5&gt;位图&lt;/h5&gt;
&lt;p&gt;核心思想：将整个堆划分为大量的块，每个块的大小相同。当用户请求内存的时候，总时分配整数个块给用户，第一个块我们称为已分配区域的头，其余的称为已分配区域的主体。而我们可以使用一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三种状态，所以仅仅需要2为即可表示一个块，所以称为位图。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt; 
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;速度快：由于整个堆的空闲信息存储在一个数组内，所以访问数组时cache容易命中。&lt;/li&gt;
&lt;li&gt;稳定性好：为了避免用户越界读写破坏数据，我们只需简单的备份一下位图即可，而且即使部分数据被破坏，也不会导致整个堆无法工作。&lt;/li&gt;
&lt;li&gt;块不需要额外信息，易于管理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分配内存时容易产生碎片。&lt;/li&gt;
&lt;li&gt;如果堆很大，或者设定的一个块很小，那么位图将会很大，可能失去cache命中率高的优势，也会浪费一定的空间。&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;对象池&lt;/h5&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;思路：如果每次分配的空间大小都一样，那么就可以按照这个每次请求分配的大小作为一个单位，把整个堆空间划分为大量的小块，每次请求的时候，只需要找到一个小块就可以了。&lt;/p&gt;
&lt;p&gt;对象池的管理方法可以采用空闲链表，也可以采用位图，与它们的区别仅仅在于它假定了每次请求的都是一个固定大小，因此实现起来很容易。由于每次总是只请求一个单位内存，因此请求得到满足的速度非常块，无须查找一个足够大的空间&lt;/p&gt;
&lt;/div&gt;
&lt;img src=&quot;http://images2017.cnblogs.com/blog/725789/201710/725789-20171011183907590-1115857894.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 12 Oct 2017 06:42:00 +0000</pubDate>
<dc:creator>目不识丁</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tan-sir/p/7652149.html</dc:identifier>
</item>
<item>
<title>【vue系列之二】详解vue-cli 2.0配置文件 - TJYoung</title>
<link>http://www.cnblogs.com/tjyoung/p/7652930.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tjyoung/p/7652930.html</guid>
<description>&lt;p&gt;&lt;span&gt;上次给大家分享的是用&lt;a href=&quot;http://www.cnblogs.com/tjyoung/p/6832234.html&quot; target=&quot;_blank&quot;&gt;vue-cli快速搭建vue项目&lt;/a&gt;，虽然很省时间和精力，但想要真正搞明白，我们还需要对其原理一探究竟。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家拿到一个项目，要快速上手，正确的思路是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，如果在项目有readme.md的情况下，大家要先读readme，项目的一些基本介绍，包括项目信息、运行的脚本、采用何种框架，以及项目维护者等信息通常都会有。一般在git上维护的项目都会有readme.md，不熟悉markdown语法的同学可以先了解下&lt;a href=&quot;http://www.jianshu.com/p/1e402922ee32/&quot; target=&quot;_blank&quot;&gt;markdown入门&lt;/a&gt;。&lt;a title=&quot;markdown入门&quot; href=&quot;http://www.jianshu.com/p/1e402922ee32/&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步，要看package.json。现代的前端项目中通常都会有package.json文件。在package.json里，会介绍项目名称、版本、描述、作者、脚本、依赖包，对环境的要求，以及对浏览器要求。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;90&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &quot;name&quot;: &quot;uccn&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &quot;version&quot;: &quot;1.0.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &quot;description&quot;: &quot;uccn3.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &quot;author&quot;: &quot;v_yangtianjiao &amp;lt;v_yangtianjiao@baidu.com&amp;gt;&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &quot;private&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,&lt;br/&gt;　　　&lt;span&gt;// 这里的脚本是分析项目的主要入口
&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &quot;scripts&quot;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &quot;dev&quot;: &quot;node build/dev-server.js&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &quot;start&quot;: &quot;node build/dev-server.js&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &quot;build&quot;: &quot;node build/build.js&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &quot;jsonp&quot;: &quot;node build/jsonp-server.js&quot;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  },&lt;br/&gt;　　　&lt;span&gt;// 项目依赖
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   &quot;dependencies&quot;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &quot;fetch-jsonp&quot;: &quot;^1.1.3&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &quot;less&quot;: &quot;^2.7.2&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &quot;less-loader&quot;: &quot;^4.0.4&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &quot;stylus&quot;: &quot;^0.54.5&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &quot;stylus-loader&quot;: &quot;^3.0.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &quot;vue&quot;: &quot;^2.4.2&quot;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;  },
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   &quot;devDependencies&quot;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &quot;autoprefixer&quot;: &quot;^7.1.2&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &quot;babel-core&quot;: &quot;^6.22.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &quot;babel-loader&quot;: &quot;^7.1.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &quot;babel-plugin-component&quot;: &quot;^0.10.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &quot;babel-plugin-transform-runtime&quot;: &quot;^6.22.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &quot;babel-preset-env&quot;: &quot;^1.3.2&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &quot;babel-preset-stage-2&quot;: &quot;^6.22.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &quot;babel-register&quot;: &quot;^6.22.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &quot;chalk&quot;: &quot;^2.0.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &quot;connect-history-api-fallback&quot;: &quot;^1.3.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &quot;copy-webpack-plugin&quot;: &quot;^4.0.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &quot;css-loader&quot;: &quot;^0.28.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &quot;cssnano&quot;: &quot;^3.10.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &quot;eventsource-polyfill&quot;: &quot;^0.9.6&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &quot;express&quot;: &quot;^4.14.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &quot;extract-text-webpack-plugin&quot;: &quot;^2.0.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     &quot;file-loader&quot;: &quot;^0.11.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &quot;friendly-errors-webpack-plugin&quot;: &quot;^1.1.3&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &quot;html-webpack-plugin&quot;: &quot;^2.28.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &quot;http-proxy-middleware&quot;: &quot;^0.17.3&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &quot;opn&quot;: &quot;^5.1.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &quot;optimize-css-assets-webpack-plugin&quot;: &quot;^2.0.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &quot;ora&quot;: &quot;^1.2.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &quot;rimraf&quot;: &quot;^2.6.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &quot;semver&quot;: &quot;^5.3.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &quot;shelljs&quot;: &quot;^0.7.6&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &quot;url-loader&quot;: &quot;^0.5.8&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     &quot;vue-loader&quot;: &quot;^13.0.4&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &quot;vue-style-loader&quot;: &quot;^3.0.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     &quot;vue-template-compiler&quot;: &quot;^2.4.2&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &quot;webpack&quot;: &quot;^2.6.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &quot;webpack-bundle-analyzer&quot;: &quot;^2.2.1&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     &quot;webpack-dev-middleware&quot;: &quot;^1.10.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &quot;webpack-hot-middleware&quot;: &quot;^2.18.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &quot;webpack-merge&quot;: &quot;^4.1.0&quot;
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;  },&lt;br/&gt;&lt;span&gt;// 对node版本的以及npm版本的要求
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;   &quot;engines&quot;&lt;span&gt;: {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &quot;node&quot;: &quot;&amp;gt;= 4.0.0&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     &quot;npm&quot;: &quot;&amp;gt;= 3.0.0&quot;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;  },&lt;br/&gt;　　　&lt;span&gt;// 浏览器要求，vue项目不支持ie8，因为ie8是es3，尚没有Object.defineProperty属性
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;   &quot;browserslist&quot;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     &quot;&amp;gt; 1%&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;     &quot;last 2 versions&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;     &quot;not ie &amp;lt;= 8&quot;
&lt;span&gt;67&lt;/span&gt; &lt;span&gt;  ]
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面的package.json是从实际vue项目中摘出来的，大家从package.json中就会对项目有一个大概的了解，最主要的是脚本部分。通过npm的自动化任务，可以很方便的执行配置文件中的脚本。通过配置  &quot;jsonp&quot;: &quot;node build/jsonp-server.js&quot;，可以方便的使用npm run jsonp命令，代替node build/jsonp-server.js或者更复杂的一系列命令。详细的npm自动化命令可以移步&lt;a href=&quot;https://segmentfault.com/a/1190000000344102&quot; target=&quot;_blank&quot;&gt;npm 自动化&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/908144/201710/908144-20171011165137980-405265441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 现在的项目目录结构如上，我们从刚才的脚本入手。首先是启服务的脚本npm run dev，实际上是执行node build/dev-server.js，我们在build文件夹中找到dev-server.js,一步步分析。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; eslint-disable &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;&lt;span&gt;// 首先检查node和npm的版本&lt;/span&gt;
require(&lt;/span&gt;'./check-versions'&lt;span&gt;)()&lt;br/&gt;&lt;span&gt;// 获取配置文件中默认的配置
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config = require('../config'&lt;span&gt;)&lt;br/&gt;&lt;span&gt;// 如果node无法判断当前是开发环境还是生产环境，则使用config.dev.env.NODE_ENV作为当前的环境
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;process.env.NODE_ENV) {
  process.env.NODE_ENV &lt;/span&gt;=&lt;span&gt; JSON.parse(config.dev.env.NODE_ENV)
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; opn = require('opn'&lt;span&gt;)&lt;span&gt;// 用来在起来服务之后，打开浏览器并跳转指定URL
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; path = require('path'&lt;span&gt;)&lt;span&gt;// node自带文件路径工具
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; express = require('express'&lt;span&gt;)&lt;span&gt;// node框架express（本地开发的核心，起服务）
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webpack = require('webpack'&lt;span&gt;)&lt;span&gt;// webpack,压缩打包
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; proxyMiddleware = require('http-proxy-middleware'&lt;span&gt;)&lt;span&gt;// 中间件
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webpackConfig = require('./webpack.dev.conf'&lt;span&gt;)&lt;span&gt;// 开发环境的webpack配置
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mockMiddleware = require('../config/dev.mock'&lt;span&gt;)&lt;span&gt;// 开发环境本地mock数据中间件
&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; port = process.env.PORT ||&lt;span&gt; config.dev.port&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; autoOpenBrowser = !!&lt;span&gt;config.dev.autoOpenBrowser&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; proxyTable =&lt;span&gt; config.dev.proxyTable

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express()&lt;span&gt;// 起服务
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; compiler =&lt;span&gt; webpack(webpackConfig)&lt;span&gt;// webpack进行编译&lt;/span&gt;
&lt;br/&gt;&lt;span&gt;// webpack-dev-middleware将编译的文件放在内存中，后续注入
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; devMiddleware = require('webpack-dev-middleware'&lt;span&gt;)(compiler, {
  publicPath: webpackConfig.output.publicPath,
  quiet: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
})
&lt;span&gt;// 热加载
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hotMiddleware = require('webpack-hot-middleware'&lt;span&gt;)(compiler, {
  log: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
  heartbeat: &lt;/span&gt;2000&lt;span&gt;
})&lt;/span&gt;
compiler.plugin('compilation', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (compilation) {
  compilation.plugin(&lt;/span&gt;'html-webpack-plugin-after-emit', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data, cb) {
    hotMiddleware.publish({ action: &lt;/span&gt;'reload'&lt;span&gt; })
    cb()
  })
})

&lt;/span&gt;&lt;span&gt;// proxy api requests&lt;br/&gt;// proxyTable中的配置挂载到express中&lt;/span&gt;
Object.keys(proxyTable).forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (context) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options =&lt;span&gt; proxyTable[context]
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; options === 'string'&lt;span&gt;) {
    options &lt;/span&gt;=&lt;span&gt; { target: options }
  }
  app.use(proxyMiddleware(options.filter &lt;/span&gt;||&lt;span&gt; context, options))
})

&lt;/span&gt;&lt;span&gt;// 处理后退的时候匹配资源&lt;/span&gt;
app.use(require('connect-history-api-fallback'&lt;span&gt;)())

&lt;/span&gt;&lt;span&gt;// 暂存在内存的webpack编译后的文件挂载到express上&lt;/span&gt;
&lt;span&gt;app.use(devMiddleware)
&lt;br/&gt;&lt;span&gt;// 将本地mock中间件挂载到express上&lt;/span&gt;
app.use(mockMiddleware);
&lt;/span&gt;&lt;span&gt;
// 热加载挂载到express上&lt;/span&gt;
&lt;span&gt;app.use(hotMiddleware)

&lt;/span&gt;&lt;span&gt;// 拼static静态资源文件路径&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; staticPath =&lt;span&gt; path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)&lt;br/&gt;&lt;span&gt;// express为静态资源提供服务&lt;/span&gt;
app.use(staticPath, express.static(&lt;/span&gt;'./static'&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; uri = 'http://localhost:' +&lt;span&gt; port

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; _resolve
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; readyPromise = &lt;span&gt;new&lt;/span&gt; Promise(resolve =&amp;gt;&lt;span&gt; {
  _resolve &lt;/span&gt;=&lt;span&gt; resolve
})

console.log(&lt;/span&gt;'&amp;gt; Starting dev server...'&lt;span&gt;)
devMiddleware.waitUntilValid(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'&amp;gt; Listening at ' + uri + '\n'&lt;span&gt;)&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (autoOpenBrowser &amp;amp;&amp;amp; process.env.NODE_ENV !== 'testing'&lt;span&gt;) {
    opn(uri)
  }
  _resolve()
})
&lt;span&gt;// 通过配置的端口，自动打开浏览器，并跳转拼好的URL，至此，发开环境已经跑起来了
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server =&lt;span&gt; app.listen(port)

module.exports &lt;/span&gt;=&lt;span&gt; {
  ready: readyPromise,
  close: () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    server.close()
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在上面的dev-server中，有很多变量来自于./config/index.js和webpack.dev.conf.js，我们一个个看上述配置文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先看./config/index.js,这里是整个项目主要的配置入口，我们在代码中一步步分析：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// node自带路径工具.&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; path = require('path'&lt;span&gt;)
&lt;span&gt;// 分为两种环境，dev和production&lt;/span&gt;
module.exports &lt;/span&gt;=&lt;span&gt; {
  build: {
    env: require(&lt;/span&gt;'./prod.env'&lt;span&gt;),&lt;span&gt;// 使用config/prod.env.js中定义的编译环境&lt;/span&gt;
    index: path.resolve(__dirname, &lt;/span&gt;'../dist/index.html'&lt;span&gt;),&lt;span&gt;// 编译输入的index.html文件。node.js中，在任何模块文件内部，可以使用__filename变量获取当前模块文件的带有完整绝对路径的文件名&lt;/span&gt;,
    assetsRoot: path.resolve(__dirname, &lt;/span&gt;'../dist'&lt;span&gt;),&lt;span&gt;// 编译输出的静态资源路径&lt;/span&gt;
    assetsSubDirectory: &lt;/span&gt;'static'&lt;span&gt;,&lt;span&gt;// 编译输出的二级目录&lt;/span&gt;
    assetsPublicPath: &lt;/span&gt;'./'&lt;span&gt;, &lt;span&gt;// 编译发布的根目录，可配置为资源服务器或者cdn域名&lt;/span&gt;
    productionSourceMap: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,&lt;span&gt;//是否开启cssSource&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/span&gt;
    productionGzip: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,&lt;span&gt;// 是否开启gzip&lt;/span&gt;
    productionGzipExtensions: [&lt;/span&gt;'js', 'css'&lt;span&gt;],&lt;span&gt;// 需要用gzip压缩的文件扩展名&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;    bundleAnalyzerReport: process.env.npm_config_report
  },
  dev: {
    env: require(&lt;/span&gt;'./dev.env'&lt;span&gt;),
    port: &lt;/span&gt;8989&lt;span&gt;,&lt;span&gt;// 起服务的端口&lt;/span&gt;
    autoOpenBrowser: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    assetsSubDirectory: &lt;/span&gt;'static'&lt;span&gt;,
    assetsPublicPath: &lt;/span&gt;'/'&lt;span&gt;,
    proxyTable: {},&lt;span&gt;// 需要代理的接口，可以跨域&lt;/span&gt;&lt;/span&gt;
    cssSourceMap: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接着我们分析webpack.dev.conf.js：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; utils = require('./utils'&lt;span&gt;)&lt;span&gt;// 工具类
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webpack = require('webpack'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config = require('../config'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; merge = require('webpack-merge'&lt;span&gt;)&lt;span&gt;// 使用webpack配置合并插件
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; baseWebpackConfig = require('./webpack.base.conf'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; HtmlWebpackPlugin = require('html-webpack-plugin'&lt;span&gt;)&lt;span&gt;// 这个插件自动生成HTML，并注入到.html文件中
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;// 将hot-reload相对路径添加到webpack.base.conf的对应的entry前面&lt;/span&gt;
Object.keys(baseWebpackConfig.entry).forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (name) {
  baseWebpackConfig.entry[name] &lt;/span&gt;= ['./build/dev-client'&lt;span&gt;].concat(baseWebpackConfig.entry[name])
})
&lt;br/&gt;&lt;span&gt;// webpack.dev.conf.js与webpack.base.conf.js中的配置合并&lt;/span&gt;
module.exports &lt;/span&gt;=&lt;span&gt; merge(baseWebpackConfig, {
  module: {
    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap })
  },
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&lt;span&gt; webpack-devtool有7种模式，cheap-module-eval-source-map模式是比较快的开发模式&lt;/span&gt;&lt;br/&gt;　&lt;img src=&quot;http://images2017.cnblogs.com/blog/908144/201710/908144-20171011204846793-903055658.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
  devtool: '#cheap-module-eval-source-map'&lt;span&gt;,
  plugins: [&lt;br/&gt;　　&lt;span&gt;// 你可以理解为，通过配置了DefinePlugin，那么这里面的标识就相当于全局变量，你的业务代码可以直接使用配置的标识。
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DefinePlugin({
      &lt;/span&gt;'process.env'&lt;span&gt;: config.dev.env
    }),
    &lt;/span&gt;&lt;span&gt;// hotModule插件让页面变动时，只重绘对应的模块，不会重绘整个HTML文件&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.HotModuleReplacementPlugin(),&lt;br/&gt;　　&lt;span&gt;// 在编译出现错误时，使用 &lt;code&gt;NoEmitOnErrorsPlugin&lt;/code&gt; 来跳过输出阶段。这样可以确保输出资源不会包含错误
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.NoEmitOnErrorsPlugin(),
    &lt;/span&gt;&lt;span&gt;// 将生成的HTML代码注入index.html文件&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlWebpackPlugin({
      filename: &lt;/span&gt;'index.html'&lt;span&gt;,
      template: &lt;/span&gt;'index.html'&lt;span&gt;,
      inject: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    }),&lt;br/&gt;　　&lt;span&gt;// friendly-errors-webpack-plugin用于更友好地输出webpack的警告、错误等信息
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FriendlyErrorsPlugin()
  ]
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;刚才的webpack.dev.conf.js中有引到webpack.base.conf.js,我们就把他们一网打尽，继续看webpack.base.conf.js!&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; eslint-disable &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; path = require('path'&lt;span&gt;)&lt;span&gt;// node自带的文件路径插件
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; utils = require('./utils'&lt;span&gt;)&lt;span&gt;// 工具类
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config = require('../config'&lt;span&gt;)&lt;span&gt;// 上面说过的config/index
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vueLoaderConfig = require('./vue-loader.conf'&lt;span&gt;)&lt;span&gt;// vue-loader.conf配置文件是用来解决各种css文件的，定义了诸如css,less,sass之类的和样式有关的loader
// 此函数是用来返回当前目录的平行目录的路径，
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; resolve (dir) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; path.join(__dirname, '..'&lt;span&gt;, dir)
}

module.exports &lt;/span&gt;=&lt;span&gt; {
  entry: {
    uccn: &lt;/span&gt;'./src/main.js'&lt;span&gt;// 入口&lt;/span&gt;&lt;span&gt;
  },
  output: {&lt;br/&gt;　　&lt;span&gt;// 路径是config目录下的index.js中的build配置中的assetsRoot，也就是dist目录&lt;/span&gt;
    path: config.build.assetsRoot,
    filename: &lt;/span&gt;'[name].js'&lt;span&gt;,&lt;br/&gt;　　&lt;span&gt;// 上线地址，也就是真正的文件引用路径，如果是production生产环境，其实这里都是 '/'&lt;/span&gt;
    publicPath: process.env.NODE_ENV &lt;/span&gt;=== 'production'
      ?&lt;span&gt; config.build.assetsPublicPath
      : config.dev.assetsPublicPath
  },&lt;br/&gt;　  resolve: {&lt;br/&gt;　　&lt;span&gt;// 省略扩展名，比方说import index form '../js/index', 会默认去找index文件，然后找index.js,.vue,.josn.&lt;/span&gt;
    extensions: [&lt;/span&gt;'.js', '.vue', '.json'&lt;span&gt;],
    alias: {
      &lt;/span&gt;'vue$': 'vue/dist/vue.esm.js'&lt;span&gt;,&lt;br/&gt;　　　　&lt;span&gt;// 使用上面的resolve函数，意思是用@代替src的绝对路径
      &lt;/span&gt;&lt;/span&gt;'@': resolve('src'&lt;span&gt;),
    }
  },&lt;br/&gt;　&lt;span&gt;// 不同的模块使用不同的loader&lt;/span&gt;
  module: {
    rules: [
      {&lt;br/&gt;　　　　　&lt;span&gt;// 对vue文件，使用vue-loader解析&lt;/span&gt;
        test: &lt;/span&gt;/\.vue$/&lt;span&gt;,
        loader: &lt;/span&gt;'vue-loader'&lt;span&gt;,
        options: vueLoaderConfig
      },
      {&lt;br/&gt;　　　　　&lt;span&gt;// babel-loader把es6解析成es5&lt;/span&gt;
        test: &lt;/span&gt;/\.js$/&lt;span&gt;,
        loader: &lt;/span&gt;'babel-loader'&lt;span&gt;,
        include: [resolve(&lt;/span&gt;'src'), resolve('test'&lt;span&gt;)]
      },
      {&lt;br/&gt;　　　　　&lt;span&gt;// url-loader将文件大小低于下面option中limit的图片，转化为一个64位的DataURL，这样会省去很多请求，大于limit的，按[name].[hash:7].[ext]的命名方式放到了static/img下面，方便做cache&lt;/span&gt;
        test: &lt;/span&gt;/\.(png|jpe?g|gif|svg)(\?.*)?$/&lt;span&gt;,
        loader: &lt;/span&gt;'url-loader'&lt;span&gt;,
        options: {
          limit: &lt;/span&gt;20000&lt;span&gt;,
          name: utils.assetsPath(&lt;/span&gt;'img/[name].[hash:7].[ext]'&lt;span&gt;)
        }
      },
      {&lt;br/&gt;　　　　　&lt;span&gt;// 音频和视频文件处理，同上&lt;/span&gt;
        test: &lt;/span&gt;/\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/&lt;span&gt;,
        loader: &lt;/span&gt;'url-loader'&lt;span&gt;,
        options: {
          limit: &lt;/span&gt;10000&lt;span&gt;,
          name: utils.assetsPath(&lt;/span&gt;'media/[name].[hash:7].[ext]'&lt;span&gt;)
        }
      },
      {&lt;br/&gt;　　　　　&lt;span&gt;// 字体处理，同上&lt;/span&gt;　
        test: &lt;/span&gt;/\.(woff2?|eot|ttf|otf)(\?.*)?$/&lt;span&gt;,
        loader: &lt;/span&gt;'url-loader'&lt;span&gt;,
        options: {
          limit: &lt;/span&gt;10000&lt;span&gt;,
          name: utils.assetsPath(&lt;/span&gt;'fonts/[name].[hash:7].[ext]'&lt;span&gt;)
        }
      }
    ]
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 至此，&lt;span&gt;npm run dev&lt;/span&gt;起本地开发环境相关的配置文件基本说完了，接着说一下上面都用到的util工具类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; path = require('path'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config = require('../config'&lt;span&gt;)&lt;br/&gt;&lt;span&gt;// extract-text-webpack-plugin该插件的主要是为了抽离css样式,防止将样式打包在js中引起页面样式加载错乱的现象
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ExtractTextPlugin = require('extract-text-webpack-plugin'&lt;span&gt;)
&lt;br/&gt;&lt;span&gt;// 返回资源文件路径，path.posix以posix兼容的方式交互，是跨平台的，如果是path.win32的话，只能在win上&lt;/span&gt;
exports.assetsPath &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (_path) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; assetsSubDirectory = process.env.NODE_ENV === 'production'
    ?&lt;span&gt; config.build.assetsSubDirectory
    : config.dev.assetsSubDirectory
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; path.posix.join(assetsSubDirectory, _path)
}
&lt;br/&gt;&lt;span&gt;// 通过判断是否是生产环境，配置不同的样式语言的loader配置&lt;/span&gt;
exports.cssLoaders &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (options) {
  options &lt;/span&gt;= options ||&lt;span&gt; {}

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cssLoader =&lt;span&gt; {
    loader: &lt;/span&gt;'css-loader'&lt;span&gt;,
    options: {
      minimize: process.env.NODE_ENV &lt;/span&gt;=== 'production'&lt;span&gt;,
      sourceMap: options.sourceMap
    }
  }

  &lt;/span&gt;&lt;span&gt;// 生成各种loader配置，通过传入不同的loader和option，将不同样式文件语言的loader拼好，push到loader配置中。&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; generateLoaders (loader, loaderOptions) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loaders =&lt;span&gt; [cssLoader]
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (loader) {
      loaders.push({
        loader: loader &lt;/span&gt;+ '-loader'&lt;span&gt;,
        options: Object.assign({}, loaderOptions, {
          sourceMap: options.sourceMap
        })
      })
    }

    &lt;/span&gt;&lt;span&gt;// extract-text-webpack-plugin有三个参数，use指需要用什么loader去编译文件；fallback指编译后用什么loader去提取文件；还有一个publicfile用来覆盖项目路径&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (options.extract) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ExtractTextPlugin.extract({
        use: loaders,
        fallback: &lt;/span&gt;'vue-style-loader'&lt;span&gt;
      })
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ['vue-style-loader'&lt;span&gt;].concat(loaders)
    }
  }

  &lt;/span&gt;&lt;span&gt;// 对不同的样式语言，返回相应的loader&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    css: generateLoaders(),
    postcss: generateLoaders(),
    less: generateLoaders(&lt;/span&gt;'less'&lt;span&gt;),
    sass: generateLoaders(&lt;/span&gt;'sass', { indentedSyntax: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; }),
    scss: generateLoaders(&lt;/span&gt;'sass'&lt;span&gt;),
    stylus: generateLoaders(&lt;/span&gt;'stylus'&lt;span&gt;),
    styl: generateLoaders(&lt;/span&gt;'stylus'&lt;span&gt;)
  }
}

&lt;/span&gt;&lt;span&gt;// 生成处理不同的样式文件处理规则&lt;/span&gt;
exports.styleLoaders = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (options) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; output =&lt;span&gt; []
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loaders =&lt;span&gt; exports.cssLoaders(options)
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; extension &lt;span&gt;in&lt;/span&gt;&lt;span&gt; loaders) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loader =&lt;span&gt; loaders[extension]
    output.push({
      test: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; RegExp('\\.' + extension + '$'&lt;span&gt;),
      use: loader
    })
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; output
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;———————————————— 华丽的分隔符 —————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们继续说npm run build，打包编译的一系列操作~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从package.json 中可以看出，npm run build，其实是执行了 node build/build.js，我们在build文件夹中找到build.js，build主要的工作是：&lt;span&gt;检测node和npm版本，删除dist包，webpack构建打包，在终端输出构建信息并结束，如果报错，则输出报错信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
require('./check-versions'&lt;span&gt;)()

process.env.NODE_ENV &lt;/span&gt;= 'production'
&lt;br/&gt;&lt;span&gt;// 在终端显示的旋转器插件&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ora = require('ora'&lt;span&gt;)&lt;br/&gt;&lt;span&gt;// 用于删除文件夹
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rm = require('rimraf'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; path = require('path'&lt;span&gt;)&lt;br/&gt;&lt;span&gt;// 终端文字颜色插件
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; chalk = require('chalk'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webpack = require('webpack'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config = require('../config'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webpackConfig = require('./webpack.prod.conf'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; spinner = ora('building for production...'&lt;span&gt;)
spinner.start()
&lt;br/&gt;&lt;span&gt;// 删除dist文件夹，之后webpack打包&lt;/span&gt;
rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err
  webpack(webpackConfig, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err, stats) {
    spinner.stop()
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (err) &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err
    process.stdout.write(stats.toString({
      colors: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      modules: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      children: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      chunks: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      chunkModules: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    }) &lt;/span&gt;+ '\n\n'&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stats.hasErrors()) {
      console.log(chalk.red(&lt;/span&gt;'  Build failed with errors.\n'&lt;span&gt;))
      process.exit(&lt;/span&gt;1&lt;span&gt;)
    }

    console.log(chalk.cyan(&lt;/span&gt;'  Build complete.\n'&lt;span&gt;))
    console.log(chalk.yellow(
      &lt;/span&gt;'  Tip: built files are meant to be served over an HTTP server.\n' +
      '  Opening index.html over file:// won\'t work.\n'&lt;span&gt;
    ))
  })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;build.js用到了webpack.prod.conf.js,他与webpack.base.conf.js merge之后，作为webpack配置文件，我们再看看webpack.prod.conf.js,主要做的工作是：&lt;br/&gt;1.提取webpack生成的bundle中的文本，到特定的文件，使得css，js文件与webpack输出的bundle分离。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.合并基本的webpack配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.配置webpack的输出，包括输出路径，文件名格式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.配置webpack插件，包括丑化代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.gzip下引入compression插件进行压缩。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; eslint-disable &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; path = require('path'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; utils = require('./utils'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webpack = require('webpack'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config = require('../config'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; merge = require('webpack-merge'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; baseWebpackConfig = require('./webpack.base.conf'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; CopyWebpackPlugin = require('copy-webpack-plugin'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; HtmlWebpackPlugin = require('html-webpack-plugin'&lt;span&gt;)&lt;br/&gt;&lt;span&gt;// 用于从webpack生成的bundle中提取文本到特定文件中的插件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 可以抽取出css，js文件将其与webpack输出的bundle分离
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ExtractTextPlugin = require('extract-text-webpack-plugin'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; env =&lt;span&gt; config.build.env
&lt;span&gt;// 合并基础的webpack配置
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webpackConfig =&lt;span&gt; merge(baseWebpackConfig, {
  module: {
    rules: utils.styleLoaders({
      sourceMap: config.build.productionSourceMap,
      extract: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    })
  },&lt;br/&gt;　&lt;span&gt;// 7中sourceMap上面有讲过&lt;/span&gt;
  devtool: config.build.productionSourceMap &lt;/span&gt;? '#source-map' : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,&lt;br/&gt;　&lt;span&gt;// 配置webpack输出的目录，及文件命名规则&lt;/span&gt;
  output: {
    path: config.build.assetsRoot,
    filename: utils.assetsPath(&lt;/span&gt;'js/[name].min.js'&lt;span&gt;),
    chunkFilename: utils.assetsPath(&lt;/span&gt;'js/[id].[chunkhash].js'&lt;span&gt;)
  },&lt;br/&gt;　&lt;span&gt;// webpack插件配置&lt;/span&gt;
  plugins: [
    &lt;/span&gt;&lt;span&gt;// 同webpack.dev.conf.js&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DefinePlugin({
      &lt;/span&gt;'process.env'&lt;span&gt;: env
    }),&lt;br/&gt;　　&lt;span&gt;// 丑化代码
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      },
      sourceMap: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    }),
    &lt;/span&gt;&lt;span&gt;// 抽离css文件到单独的文件&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExtractTextPlugin({
      filename: utils.assetsPath(&lt;/span&gt;'css/[name].min.css'&lt;span&gt;)
    }),&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OptimizeCSSPlugin({
      cssProcessorOptions: {
        safe: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      }
    }),
    &lt;/span&gt;&lt;span&gt;// 生成并注入index.html&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlWebpackPlugin({
      filename: config.build.index,
      template: &lt;/span&gt;'index.html'&lt;span&gt;,
      inject: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      minify: {
        removeComments: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        collapseWhitespace: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        removeAttributeQuotes: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;      },&lt;/span&gt;
      chunksSortMode: 'dependency'&lt;span&gt;
    }),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; keep module.id stable when vender modules does not change&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.HashedModuleIdsPlugin(),
    split vendor js into its own file
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.CommonsChunkPlugin({
      name: &lt;/span&gt;'vendor'&lt;span&gt;,
      minChunks: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (module, count) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; any required modules inside node_modules are extracted to vendor&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
          module.resource &lt;/span&gt;&amp;amp;&amp;amp;
          /\.js$/.test(module.resource) &amp;amp;&amp;amp;&lt;span&gt;
          module.resource.indexOf(
            path.join(__dirname, &lt;/span&gt;'../node_modules'&lt;span&gt;)
          ) &lt;/span&gt;=== 0&lt;span&gt;
        )
      }
    }),
    extract webpack runtime and module manifest to its own file &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; order to
    prevent vendor hash from being updated whenever app bundle is updated
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.CommonsChunkPlugin({
      name: &lt;/span&gt;'manifest'&lt;span&gt;,
      chunks: [&lt;/span&gt;'vendor'&lt;span&gt;]
    }),
    copy custom static assets
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CopyWebpackPlugin([
      {
        from: path.resolve(__dirname, &lt;/span&gt;'../static'&lt;span&gt;),
        to: config.build.assetsSubDirectory,
        ignore: [&lt;/span&gt;'.*'&lt;span&gt;]
      }
    ])
  ]
})
&lt;span&gt;// gzip模式下需要引入compression插件进行压缩
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (config.build.productionGzip) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; CompressionWebpackPlugin = require('compression-webpack-plugin'&lt;span&gt;)

  webpackConfig.plugins.push(
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompressionWebpackPlugin({
      asset: &lt;/span&gt;'[path].gz[query]'&lt;span&gt;,
      algorithm: &lt;/span&gt;'gzip'&lt;span&gt;,
      test: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RegExp(
        &lt;/span&gt;'\\.(' +&lt;span&gt;
        config.build.productionGzipExtensions.join(&lt;/span&gt;'|') +
        ')$'&lt;span&gt;
      ),
      threshold: &lt;/span&gt;10240&lt;span&gt;,
      minRatio: &lt;/span&gt;0.8&lt;span&gt;
    })
  )
}

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (config.build.bundleAnalyzerReport) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; BundleAnalyzerPlugin = require('webpack-bundle-analyzer'&lt;span&gt;).BundleAnalyzerPlugin
  webpackConfig.plugins.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BundleAnalyzerPlugin())
}

module.exports &lt;/span&gt;= webpackConfig
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;到此为止，vue官方脚手架工具vue-cli 2.0的所有配置文件都已介绍完毕，从头到尾再梳理一遍：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行npm run dev或者npm run start，实际是在node环境执行build/dev-server.js, dev-server.js会去拿到config中的端口等配置，通过express起一个服务，通过插件自动打开浏览器，加载webpack编译后放在内存的bundle。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行npm run build，实际上执行了build/build.js,通过webpack的一系列配置及插件，将文件打包合并丑化，并创建dist目录，放置编译打包后的文件，这将是未来用在生产环境的包。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;写这篇文章我自身的收获也挺多，第一是对vue-cli整体的认知更加清晰条理，第二是对webpack的一些插件有了新的认识。以前对一些插件模棱两可，直接越过，这是不对的，要一步一个脚印儿，遇坑填坑，这样才会有收获。虽然过程可能是艰辛的，但收获将会是巨大的~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文章中不足之处希望大家多多指正！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考文献：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/dyx-wx/p/6529447.html&quot;&gt;extract-text-webpack-plugin 的使用及安装&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://blog.csdn.net/hongchh/article/details/55113751&quot;&gt;vue-cli的webpack模板项目配置文件分析&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;singleposttitle&quot; href=&quot;http://www.cnblogs.com/wangyingblog/p/7027540.html&quot;&gt;webpack——devtool里的7种SourceMap模式&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;PostIndex-title av-paddingSide av-titleFont&quot;&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24322005&quot; target=&quot;_blank&quot;&gt;vue-cli#2.0 webpack 配置分析&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;csdn_top&quot;&gt;&lt;a href=&quot;http://blog.csdn.net/u014473112/article/details/51967364&quot; target=&quot;_blank&quot;&gt;__dirname与__filename&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 12 Oct 2017 05:19:00 +0000</pubDate>
<dc:creator>TJYoung</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tjyoung/p/7652930.html</dc:identifier>
</item>
<item>
<title>通过npm写一个cli命令行工具 - 不止前端</title>
<link>http://www.cnblogs.com/buzhiqianduan/p/7655612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buzhiqianduan/p/7655612.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;如果你想写一个npm插件，如果你想通过命令行来简化自己的操作，如果你也是个懒惰的人，那么这篇文章值得一看。&lt;/p&gt;
&lt;p&gt;po主的上一篇文章介绍了定制自己的模版，但这样po主还是不满足啊，项目中我们频繁的需要新建一些页面，逻辑样式等文件，每次都手动new一个，然后复制一些基本代码进去非常的麻烦，所以就有了这篇文章。接下来就让po主为大家一步一步演示怎么做一个npm命令行插件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3765249-2bfa55fce0a1f1e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;实例插件&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;注册npm账户&quot;&gt;注册npm账户&lt;/h2&gt;
&lt;p&gt;发布npm插件，首先肯定要有个npm帐号了，过程就不啰嗦了，走你。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有了账号后，我们通过npm init 生成一个package配置文件，填写一些你的信息，然后就可以开始写逻辑代码了。&lt;/p&gt;
&lt;h2 id=&quot;编写命令入口&quot;&gt;编写命令入口&lt;/h2&gt;
&lt;p&gt;首先看一下项目结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.
├── bin           //命令配置
├── README.md     //说明文档
├── index.js      //主入口
├── src           //功能文件
├── package.json  //包信息
└── test          //测试用例&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例命令代码都是写在bin目录下，我们现在配置文件package文件中启用命令,添加一个配置项bin&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &quot;bin&quot;: {
        &quot;xu&quot;: &quot;./bin/xu.js&quot;
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后安装一个依赖，TJ大神写的commander插件，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm i commander --save&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这个工具我们可以很方便的编写命令代码&lt;/p&gt;
&lt;h4 id=&quot;xu.js&quot;&gt;xu.js&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env node

process.title = 'xu';

require('commander')
.version(require('../package').version)
.usage('&amp;lt;command&amp;gt; [options]')
.command('generate', 'generate file from a template (short-cut alias: &quot;g&quot;)')
.parse(process.argv)


require('./xu-generate');   &amp;gt;&amp;gt;引入
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个文件可以看作是入口文件，第一行代码是必须添加的，脚本用env启动的原因，是因为脚本解释器在linux中可能被安装于不同的目录，env可以在系统的PATH目录中查找。同时，env还规定一些系统环境变量。 这种写法主要是为了让你的程序在不同的系统上都能适用。&lt;/p&gt;
&lt;p&gt;在这一步，你可以简单测试你自己的npm插件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ node ./bin/xu.js

&amp;gt;&amp;gt;&amp;gt;  输出一些插件usage。help信息
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关于commander，大家可以去作者的Github先学习了解，这里不对参数讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;xu-generate.js&quot;&gt;xu-generate.js&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env node

const program = require('commander');
const chalk = require('chalk')
const xu = require('../src/generate');


/**
 * Usage.
 */

program
.command('generate')
.description('quick generate your file')
.alias('g')
.action(function(type, name){
    xu.run(type, name);
});
program.parse(process.argv);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是功能命令，定义了一个generate命令，.alias('g')是该命令的缩写，然后.action(function(type, name){&lt;br/&gt;xu.run(type, name);&lt;br/&gt;});返回一个函数，这个函数就是我们定义这个命令需要做什么事。&lt;/p&gt;
&lt;h2 id=&quot;编写功能函数&quot;&gt;编写功能函数&lt;/h2&gt;
&lt;h4 id=&quot;srcgenerate.js&quot;&gt;./src/generate.js&lt;/h4&gt;
&lt;p&gt;这个文件就定义了当我们输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ xu g&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所做的操作了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Created by xushaoping on 17/10/11.
 */

const fs = require('fs-extra')
const chalk = require('chalk')
exports.run = function(type, name) {
    switch (type) {
        case 'page':
            const pageFile = './src/page/' + name + '/' + name + '.vue'
            const styleFile = './src/page/' + name + '/' + name + '.less'
            fs.pathExists(pageFile, (err, exists) =&amp;gt; {
                if (exists) {
                    console.log('this file has created')
                } else {
                    fs.copy('/usr/local/lib/node_modules/vue-xu-generate/src/template/page.vue', pageFile, err =&amp;gt; {
                        if (err) return console.error(err)
                
                        console.log(pageFile + '  has created')
                    })
                    fs.copy('/usr/local/lib/node_modules/vue-xu-generate/src/template/page.less', styleFile, err =&amp;gt; {
                        if (err) return console.error(err)
                
                        console.log(styleFile + '  has created')
                    })
                }
            })
            break;
        case 'component':
            const componentFile = './src/components/' + name + '.vue'
            fs.pathExists(componentFile, (err, exists) =&amp;gt; {
                if (exists) {
                    console.log('this file has created')
                } else {
                    fs.copy('/usr/local/lib/node_modules/vue-xu-generate/src/template/component.vue', componentFile, err =&amp;gt; {
                        if (err) return console.error(err)
                    
                        console.log(componentFile + '  has created')
                    })
                }
            })
            break;
        case 'store':
            const storeFile = './src/store/modules' + name + '.js'
            fs.pathExists(storeFile, (err, exists) =&amp;gt; {
                if (exists) {
                    console.log('this file has created')
                } else {
                    fs.copy('/usr/local/lib/node_modules/vue-xu-generate/src/template/store.js', storeFile, err =&amp;gt; {
                        if (err) return console.error(err)
                    
                        console.log(storeFile + '  has created')
                    })
                }
            })
            break;
        default:
            console.log(chalk.red(`ERROR: uncaught type , you should input like $ xu g page demo` ))
            console.log()
            console.log('  Examples:')
            console.log()
            console.log(chalk.gray('    # create a new page'))
            console.log('    $ xu g page product')
            console.log()
            console.log(chalk.gray('    # create a new component'))
            console.log('    $ xu g component  product')
            console.log()
            console.log(chalk.gray('    # create a new store'))
            console.log('    $ xu g store  product')
            console.log()
            break;
    }
};

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有2个新的依赖，分别是命令输出颜色和一个文件操作的插件,通过npm安装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ npm i fs-extra --save

$ npm i chalk --save
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个js文件导出了一个run函数给 xu-generate.js调用，我们通过参数拿到了用户输入的type，name，然后就可以根据type通过node fs模块（这里用了一个依赖，不过原理还是fs）操作把template文件复制了一份到你的项目中。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;到这，我们就已经完成了一个命令的开发，这个命令可以快速生成项目的模版文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本地测试&quot;&gt;本地测试&lt;/h2&gt;
&lt;p&gt;npm包开发不像web开发，可以直接在浏览器看，实例目录下建立一个test文件，再 node test 就可以测试我们的逻辑。如果有一些功能需要在发布后才能测，npm 有个 link命令 可以连接你本地的模块，当然你也可以发布后 自己安装插件测试，就跟平时引入一个插件一样。&lt;/p&gt;
&lt;h2 id=&quot;发布npm包&quot;&gt;发布npm包&lt;/h2&gt;
&lt;p&gt;首先在项目根目录执行npm登陆&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ npm login 

$ npm publish
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果这里有个报错，可能是你使用了cnpm地址，需要把npm仓库设置回来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; $ npm config set registry https://registry.npmjs.org/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，更新更新npm包，版本号需要大于上一次&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;至此，一个入门级的npm包就制作完成了。万分感慨，记得刚入门前端的时候看到别人的插件做的真牛，自己只要简单安装一下就能搞得那么漂亮，想搞～但是看到一堆陌生的东西，立刻怂了（node环境，东西非常非常多，直接拷个vue-cli看到一对代码，一头雾水。。。大牛请无视）&lt;/p&gt;
&lt;p&gt;学习是一个循序渐进的过程，大牛写出来的东西，没有一定的基础，和长时间的积累经验，源码是很难学习。非要啃，也行，只是效率感觉不如循序渐进来的好。&lt;/p&gt;
&lt;p&gt;插件已经发布，Github也有完整源码，想学习的同学可以fork一个自己玩玩，干这一行～随心所动 ，跟着兴趣走，准没错&lt;/p&gt;
&lt;p&gt;传送门： &lt;a href=&quot;https://www.npmjs.com/package/vue-xu-generate&quot;&gt;npm地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;传送门： &lt;a href=&quot;https://github.com/xu455255849/vue-xu-generate&quot;&gt;github源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果觉得本文对你有所帮助，就star一下吧～大传送之术！ &lt;a href=&quot;https://github.com/xu455255849/myBlog&quot;&gt;我的博客Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前端❤️～越学越感觉自己的无知哎～&lt;/p&gt;
</description>
<pubDate>Thu, 12 Oct 2017 05:02:00 +0000</pubDate>
<dc:creator>不止前端</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/buzhiqianduan/p/7655612.html</dc:identifier>
</item>
<item>
<title>【小程序】调用wx.request接口时需要注意的几个问题 - OkayChen</title>
<link>http://www.cnblogs.com/okaychen/p/7655601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okaychen/p/7655601.html</guid>
<description>&lt;p&gt;之前写了一篇&lt;strong&gt;&lt;span&gt;&lt;a title=&quot;点击跳转吧！&quot; href=&quot;http://www.cnblogs.com/okaychen/p/7616581.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;《微信小程序实现各种特效实例》&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;，上次的小程序的项目我负责大部分前端后台接口的对接，然后学长帮我改了一些问题。总的来说，收获了不少吧！&lt;/p&gt;
&lt;p&gt;现在项目已经完成，还是要陆陆续续总结一下的，总结的过程也是对知识梳理和清晰的过程！&lt;/p&gt;
&lt;p&gt;这次主要聊一下小程序前后端接口对接的一些事，&lt;/p&gt;

&lt;p&gt;对于&lt;span&gt;&lt;strong&gt;客户端与服务端接口的对接&lt;/strong&gt;&lt;/span&gt;，微信小程序提供了wx.request()的API接口，完美的实现&lt;span&gt;&lt;strong&gt;前端后台的对接&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;一个简单的&lt;strong&gt;&lt;span&gt;栗&lt;/span&gt;&lt;/strong&gt;子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; wx.request({
     url: API_URL + '/api/category/categoryList'&lt;span&gt;,
     data: {
           applet_id: app.globalData.applet_id
      },
      method: 'POST'&lt;span&gt;,
      success: function&lt;span&gt; (res) {
      wx.hideLoading();
      console.log(res.data.data, 'category data acquisition success');&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
            that.setData({category: res.data.data});
       }
  });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在控制台中也得到了我想要的接口中的数据：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171011130151684-1534935555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但期间也遇到了几个问题，总结下来；&lt;/p&gt;

&lt;p&gt;微信小程序包括四种类型的网络请求：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;普通HTTPS请求(wx.request)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;上传文件(wx.uploadFile)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;下载文件(wx.downloadFile)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;WebSocket通信(wx.connectSocket)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于“&lt;span&gt;&lt;strong&gt;URL 域名不合法，请在后台配置后重试&lt;/strong&gt;&lt;/span&gt;”的错误&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171011184932012-1926871764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小程序只允许与&lt;span&gt;&lt;strong&gt;合法配置的域名进行数据交互&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;进入微信公共平台=&amp;gt;设置=&amp;gt;开发设置：设置需要交互的域名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201710/1140602-20171011190502621-1772459677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对于这一个问题，&lt;span&gt;&lt;strong&gt;在之前来说&lt;/strong&gt;&lt;/span&gt;，微信公共平台支持使用http测试项目，但是正式发布需要使用https的域名，&lt;/p&gt;
&lt;p&gt;但是前几天看到了微信公众平台发的一则公告：&lt;/p&gt;
&lt;p&gt;应该是要封杀http方式调用了，公告链接：&lt;span&gt;&lt;strong&gt;&lt;a title=&quot;okaychen&quot; href=&quot;https://mp.weixin.qq.com/cgi-bin/announce?action=getannouncement&amp;amp;key=1505983913&amp;amp;version=5&amp;amp;lang=zh_CN&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;为保证数据传输安全，提高业务安全性，公众平台将不再支持HTTP方式调用（时间2017年9月21日）&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;微信小程序多地方都严格区分大小写，所以要注意method的value&lt;span&gt;&lt;strong&gt;需要&lt;/strong&gt;&lt;/span&gt;为大写，request的默认的超时时间都是60s；&lt;/p&gt;
&lt;p&gt;对于data数据，上次我们从接口中拿到的数据是json格式的，最终发送给服务器的数据是String类型，如果传入的 data 不是 String 类型，会被转换成 String 。&lt;/p&gt;
&lt;p&gt;文档中提供的转换规则如下：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;对于 &lt;code&gt;header['content-type']&lt;/code&gt; 为 &lt;code&gt;application/json&lt;/code&gt; 的数据，会对数据进行 JSON 序列化&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;对于 &lt;code&gt;header['content-type']&lt;/code&gt; 为 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 的数据，会将数据转换成 query string；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;（encodeURIComponent(k)=encodeURIComponent(v)&amp;amp;encodeURIComponent(k)=encodeURIComponent(v)...）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个工作在我们设置header头为&lt;span&gt;&lt;strong&gt;application/x-www-form-urlencoded&lt;/strong&gt;&lt;/span&gt;后，在后面为我们进行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;根据&lt;span&gt;HTTP的规范&lt;/span&gt;&lt;/strong&gt;，get是用于信息获取，post表示可能修改服务器的资源的请求&lt;/p&gt;
&lt;p&gt;对于小程序post请求：'application/json'用在get请求中没有问题，但是用&lt;strong&gt;在&lt;span&gt;POST请求中不好使了&lt;/span&gt;&lt;/strong&gt;，content-type 默认为 'application/json'; &lt;/p&gt;
&lt;p&gt;所以使用post请求时，将content-type设置为 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;总结了以上四个问题，应该是比较常见也是容易遇到的，欢迎补充和指正，另外&lt;strong&gt;&lt;span&gt;&lt;a title=&quot;okaychen&quot; href=&quot;https://mp.weixin.qq.com/debug/wxadoc/dev/api/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;文档中api模块&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;还有一些需要注意的问题，&lt;/p&gt;
&lt;p&gt;项目我们在github已同步：&lt;span&gt;&lt;a title=&quot;okaychen&quot; href=&quot;https://github.com/StackOverflowChen&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;StackOverflowChen&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;；欢迎来访哟；&lt;/p&gt;

&lt;p&gt;参考资料&lt;/p&gt;
&lt;p&gt;[1] https://mp.weixin.qq.com/debug/wxadoc/dev/api/&lt;/p&gt;
&lt;p&gt;[2] http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html&lt;/p&gt;

</description>
<pubDate>Thu, 12 Oct 2017 04:58:00 +0000</pubDate>
<dc:creator>OkayChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okaychen/p/7655601.html</dc:identifier>
</item>
</channel>
</rss>