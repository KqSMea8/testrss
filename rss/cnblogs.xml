<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>在asp.net core2.1中添加中间件以扩展Swashbuckle.AspNetCore3.0支持简单的文档访问权限控制 - 易墨</title>
<link>http://www.cnblogs.com/morang/p/9741511.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/morang/p/9741511.html</guid>
<description>&lt;h2 id=&quot;swashbuckle.aspnetcore3.0-介绍&quot;&gt;Swashbuckle.AspNetCore3.0 介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;6.9050279329609&quot;&gt;
&lt;p&gt;一个使用 ASP.NET Core 构建的 API 的 Swagger 工具。直接从您的路由，控制器和模型生成漂亮的 API 文档，包括用于探索和测试操作的 UI。&lt;br/&gt;项目主页：&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&quot; class=&quot;uri&quot;&gt;https://github.com/domaindrivendev/Swashbuckle.AspNetCore&lt;/a&gt;&lt;br/&gt;划重点，使用多看看 Readme,然后看下&lt;a href=&quot;https://github.com/domaindrivendev/Swashbuckle.AspNetCore/tree/master/test/WebSites&quot;&gt;项目官方示例&lt;/a&gt;，遇到问题找找 issues&lt;br/&gt;继上篇&lt;a href=&quot;https://www.cnblogs.com/morang/p/9740190.html&quot;&gt;Swashbuckle.AspNetCore3.0 的二次封装与使用&lt;/a&gt;分享了二次封装的代码，本篇将分享如何给文档添加一个登录页，控制文档的访问权限(文末附完整 Demo)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于生产环境接口文档的显示&quot;&gt;关于生产环境接口文档的显示&lt;/h2&gt;
&lt;p&gt;在此之前的接口项目中，若使用了 Swashbuckle.AspNetCore，都是控制其只在开发环境使用，不会就这样将其发布到生产环境(安全第一) 。&lt;br/&gt;那么，怎么安全的发布 swagger 呢？我有两种想法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将路由前缀改得超级复杂&lt;/li&gt;
&lt;li&gt;添加一个拦截器控制 swagger 文档的访问必须获得授权(登录)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大佬若有更好的想法，还望指点一二&lt;/p&gt;
&lt;p&gt;下面我将介绍基于 asp.net core2.1 且使用了 Swashbuckle.AspNetCore3.0 的项目种是怎么去实现安全校验的&lt;br/&gt;通过本篇文章之后，可以放心的将项目中的 swagger 文档发布到生产环境，并使其可通过用户名密码去登录访问,得以安全且方便的测试接口。&lt;/p&gt;
&lt;h2 id=&quot;实现思路&quot;&gt;实现思路&lt;/h2&gt;
&lt;p&gt;前面已经说到，需要一个拦截器，而这个拦截器还需要是全局的，在 asp.net core 中，自然就需要用到的是&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.1&quot;&gt;中间件&lt;/a&gt;了&lt;/p&gt;
&lt;p&gt;步骤如下，在 UseSwagger 之前使用自定义的中间件&lt;br/&gt;拦截所有 swagger 相关请求，判断是否授权登录&lt;br/&gt;若未登录则跳转到授权登录页，登录后即可访问 swagger 的资源&lt;/p&gt;
&lt;p&gt;如果项目本身有登录系统，可在自定义中间件中使用项目中的登录，&lt;br/&gt;没有的话，我会分享一个简单的用户密码登录的方案&lt;/p&gt;
&lt;p&gt;Demo 如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-coding-net-production-pp.qbox.me/b05ad408-74b6-48c1-9cbc-73f1a529d272.gif&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为使用-swashbuckle.aspnetcore3-的项目添加接口文档登录功能&quot;&gt;为使用 Swashbuckle.AspNetCore3 的项目添加接口文档登录功能&lt;/h2&gt;
&lt;p&gt;在写此功能之前，已经&lt;a href=&quot;https://www.cnblogs.com/morang/p/9740190.html&quot;&gt;封装了一部分代码&lt;/a&gt;，此功能算是在此之前的代码封装的一部分，不过是后面完成的。文中代码删除了耦合，和 demo 中会有一点差异。&lt;/p&gt;
&lt;h3 id=&quot;定义模型存放用户密码&quot;&gt;定义模型存放用户密码&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    public class CustomSwaggerAuth
    {
        public CustomSwaggerAuth() { }
        public CustomSwaggerAuth(string userName,string userPwd)
        {
            UserName = userName;
            UserPwd = userPwd;
        }
        public string UserName { get; set; }
        public string UserPwd { get; set; }
        //加密字符串
        public string AuthStr
        {
            get
            {
                return SecurityHelper.HMACSHA256(UserName + UserPwd);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;加密方法hmacsha256&quot;&gt;加密方法(HMACSHA256)&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    public static string HMACSHA256(string srcString, string key=&quot;abc123&quot;)
    {
        byte[] secrectKey = Encoding.UTF8.GetBytes(key);
        using (HMACSHA256 hmac = new HMACSHA256(secrectKey))
        {
            hmac.Initialize();

            byte[] bytes_hmac_in = Encoding.UTF8.GetBytes(srcString);
            byte[] bytes_hamc_out = hmac.ComputeHash(bytes_hmac_in);

            string str_hamc_out = BitConverter.ToString(bytes_hamc_out);
            str_hamc_out = str_hamc_out.Replace(&quot;-&quot;, &quot;&quot;);

            return str_hamc_out;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义中间件&quot;&gt;自定义中间件&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;此中间件中有使用的 login.html，其属性均为内嵌资源，故事用 GetManifestResourceStream 读取文件流并输出，这样可以方便的将其进行封装到独立的类库中，而不与输出项目耦合&lt;br/&gt;关于退出按钮，可以参考前文自定义 index.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    private const string SWAGGER_ATUH_COOKIE = nameof(SWAGGER_ATUH_COOKIE);
    public void Configure(IApplicationBuilder app)
    {
        var options=new {
            RoutePrefix=&quot;swagger&quot;,
            SwaggerAuthList = new List&amp;lt;CustomSwaggerAuth&amp;gt;()
            {
                new CustomSwaggerAuth(&quot;swaggerloginer&quot;,&quot;123456&quot;)
            },
        }
        var currentAssembly = typeof(CustomSwaggerAuth).GetTypeInfo().Assembly;
        app.Use(async (context, next) =&amp;gt;
        {
            var _method = context.Request.Method.ToLower();
            var _path = context.Request.Path.Value;
            // 非swagger相关请求直接跳过
            if (_path.IndexOf($&quot;/{options.RoutePrefix}&quot;) != 0)
            {
                await next();
                return;
            }
            else if (_path == $&quot;/{options.RoutePrefix}/login.html&quot;)
            {
                //登录
                if (_method == &quot;get&quot;)
                {
                    //读取CustomSwaggerAuth所在程序集内嵌的login.html并输出
                    var stream = currentAssembly.GetManifestResourceStream($&quot;{currentAssembly.GetName().Name}.login.html&quot;);
                    byte[] buffer = new byte[stream.Length];
                    stream.Read(buffer, 0, buffer.Length);
                    context.Response.ContentType = &quot;text/html;charset=utf-8&quot;;
                    context.Response.StatusCode = StatusCodes.Status200OK;
                    context.Response.Body.Write(buffer, 0, buffer.Length);
                    return;
                }
                else if (_method == &quot;post&quot;)
                {
                    var userModel = new CustomSwaggerAuth(context.Request.Form[&quot;userName&quot;], context.Request.Form[&quot;userPwd&quot;]);
                    if (!options.SwaggerAuthList.Any(e =&amp;gt; e.UserName == userModel.UserName &amp;amp;&amp;amp; e.UserPwd == userModel.UserPwd))
                    {
                        await context.Response.WriteAsync(&quot;login error!&quot;);
                        return;
                    }
                    //context.Response.Cookies.Append(&quot;swagger_auth_name&quot;, userModel.UserName);
                    context.Response.Cookies.Append(SWAGGER_ATUH_COOKIE, userModel.AuthStr);
                    context.Response.Redirect($&quot;/{options.RoutePrefix}&quot;);
                    return;
                }
            }
            else if (_path == $&quot;/{options.RoutePrefix}/logout&quot;)
            {
                //退出
                context.Response.Cookies.Delete(SWAGGER_ATUH_COOKIE);
                context.Response.Redirect($&quot;/{options.RoutePrefix}/login.html&quot;);
                return;
            }
            else
            {
                //若未登录则跳转登录
                if (!options.SwaggerAuthList.Any(s =&amp;gt; !string.IsNullOrEmpty(s.AuthStr) &amp;amp;&amp;amp; s.AuthStr == context.Request.Cookies[SWAGGER_ATUH_COOKIE]))
                {
                    context.Response.Redirect($&quot;/{options.RoutePrefix}/login.html&quot;);
                    return;
                }
            }
            await next();
        });
        app.UseSwagger();
        app.UseSwaggerUI(c=&amp;gt;{
            if (options.SwaggerAuthList.Count &amp;gt; 0)
            {
                //index.html中添加ConfigObject属性
                c.ConfigObject[&quot;customAuth&quot;] = true;
                c.ConfigObject[&quot;loginUrl&quot;] = $&quot;/{options.RoutePrefix}/login.html&quot;;
                c.ConfigObject[&quot;logoutUrl&quot;] = $&quot;/{options.RoutePrefix}/logout&quot;;
            }
        });
        app.UseMvc();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;index.html-添加退出按钮&quot;&gt;index.html 添加退出按钮&lt;/h3&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;if (configObject.customAuth) {
  var logOutEle = document.createElement('button')
  logOutEle.className = 'btn '
  logOutEle.innerText = '退出'
  logOutEle.onclick = function() {
    location.href = configObject.logoutUrl
  }
  document.getElementsByClassName('topbar-wrapper')[0].appendChild(logOutEle)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义的-index.htmllogin.html&quot;&gt;自定义的 index.html，login.html&lt;/h3&gt;
&lt;p&gt;注意：需要将其改为内嵌资源(属性-&amp;gt;生成操作-&amp;gt;嵌入的资源)&lt;/p&gt;
&lt;h2 id=&quot;完整-demo-下载&quot;&gt;完整 Demo 下载&lt;/h2&gt;
</description>
<pubDate>Wed, 03 Oct 2018 23:48:00 +0000</pubDate>
<dc:creator>易墨</dc:creator>
<og:description>Swashbuckle.AspNetCore3.0 介绍 一个使用 ASP.NET Core 构建的 API 的 Swagger 工具。直接从您的路由，控制器和模型生成漂亮的 API 文档，包括用于探</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/morang/p/9741511.html</dc:identifier>
</item>
<item>
<title>CSS魔法堂：改变单选框颜色就这么吹毛求疵！ - ^_^肥仔John</title>
<link>http://www.cnblogs.com/fsjohnhuang/p/9741345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fsjohnhuang/p/9741345.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt; 是否曾经被业务提出&quot;能改改这个单选框的颜色吧！让它和主题颜色搭配一下吧！&quot;，然后苦于原生不支持换颜色，最后被迫自己手撸一个凑合使用。若抛开&lt;code&gt;input[type=radio]&lt;/code&gt;重新开发一个，发现要模拟选中、未选中、不可用等状态很繁琐，而涉及单选框组就更烦人了，其实我们可以通过&lt;code&gt;label&lt;/code&gt;、&lt;code&gt;::before&lt;/code&gt;、&lt;code&gt;:checked&lt;/code&gt;和&lt;code&gt;tabindex&lt;/code&gt;，然后外加少量JavaScript脚本就能很好地模拟出一个样式更丰富的“原生”单选框。下面我们一起来尝试吧！&lt;/p&gt;
&lt;h2 id=&quot;单选框了解一下&quot;&gt;单选框了解一下&lt;/h2&gt;
&lt;p&gt; 由于我们的目标是改变单选框颜色，其他外观特征和行为与原来的单选框一致，那么我们就必须先了解单选框原来的外观特征和行为主要有哪些。&lt;br/&gt;1.外观特征&lt;br/&gt;1.1.常态样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;margin: 3px 3px 0px 5px;
border: none 0;
padding: 0;
box-sizing: border-box;
display: inline-block;
line-height: normal;
position: static;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：外观上我们必须要保证布局特性和原生的一致，否则采用自定义单选框替换后很大机会会影响整体的布局，最后导致被迫调整其他元素的布局特性来达到整体的协调，从而扩大了修改范围。&lt;/p&gt;
&lt;p&gt;1.2.获得焦点的样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;outline-offset: 0px;
outline: -webkit-focu-ring-color auto 5px;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：这里的获取焦点的样式仅通过键盘&lt;code&gt;Tab&lt;/code&gt;键才生效，若通过鼠标点击虽然单选框已获得焦点，但上述样式并不会生效。&lt;/p&gt;
&lt;p&gt;1.3.设置为&lt;code&gt;disabled&lt;/code&gt;的样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;color: rgb(84, 84, 84);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.行为特征&lt;br/&gt; 单选框的行为特征，明显就是选中与否，及选中状态的改变事件，因此我们必须保持对外提供&lt;code&gt;change&lt;/code&gt;事件。&lt;br/&gt; 另外值得注意的是，当通过键盘的&lt;code&gt;Tab&lt;/code&gt;键让单选框获得焦点后，再按下&lt;code&gt;Space&lt;/code&gt;键则会选中该单选框。&lt;/p&gt;
&lt;p&gt; 有了上述的了解，我们可以开始着手撸代码了！&lt;/p&gt;
&lt;h2 id=&quot;少废话撸代码&quot;&gt;少废话，撸代码&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/347002/201810/347002-20181003235455237-2000911162.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中左侧就是原生单选框，右侧为我们自定义的单选框。从上到下依次为&lt;em&gt;未选中&lt;/em&gt;、&lt;em&gt;选中&lt;/em&gt;、&lt;em&gt;获得焦点&lt;/em&gt;和&lt;em&gt;disabled&lt;/em&gt;状态的样式。&lt;/p&gt;
&lt;p&gt;CSS部分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;label.radio {
  /* 保证布局特性保持一致 */
  margin: 3px 3px 0px 5px;
  display: inline-block;
  box-sizing: border-box;

  width: 12px;
  height: 12px;
}

.radio__appearance{
  display: block; /* 设置为block则不受vertical-align影响，从而不会意外影响到.radio的linebox高度 */
  position: relative;
  box-shadow: 0 0 0 1px tomato; /* box-shadow不像border那样会影响盒子的框高 */
  border-radius: 50%;
  height: 90%;
  width: 90%;
  text-align: center;
}
label.radio [type=radio] + .radio__appearance::before{
  content: &quot;&quot;;
  display: block;
  border-radius: 50%;
  width: 85%;
  height: 85%;

  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

  transition: background .3s;
}
label.radio [type=radio]:checked + .radio__appearance::before{
  background: tomato;
}
label.radio [type=radio][disabled] + .radio__appearance{
  opacity: .5;
}
label.radio:focus{
  outline-offset: 0px;
  outline: #999 auto 5px;
}
/* 通过鼠标单击获得焦点时，outline效果不生效 */
label.radio.clicked{
  outline: none 0;
}
/* 自定义单选框的行为主要是基于原生单选框的，因此先将原生单选框隐藏 */
label.radio input {
  display: none;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HTML部分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 未选中状态 --&amp;gt;
&amp;lt;label class=&quot;radio&quot; tabindex=&quot;0&quot;&amp;gt;
  &amp;lt;input type=&quot;radio&quot; name=&quot;a&quot;&amp;gt;
  &amp;lt;i class=&quot;radio__appearance&quot;&amp;gt;&amp;lt;/i&amp;gt;
&amp;lt;/label&amp;gt;

&amp;lt;br&amp;gt;

&amp;lt;!-- 选中状态 --&amp;gt;
&amp;lt;label class=&quot;radio&quot; tabindex=&quot;0&quot;&amp;gt;
  &amp;lt;input type=&quot;radio&quot; name=&quot;a&quot; checked&amp;gt;
  &amp;lt;i class=&quot;radio__appearance&quot;&amp;gt;&amp;lt;/i&amp;gt;
&amp;lt;/label&amp;gt;

&amp;lt;br&amp;gt;

&amp;lt;!-- disabled状态 --&amp;gt;
&amp;lt;label class=&quot;radio&quot;&amp;gt;
  &amp;lt;input type=&quot;radio&quot; name=&quot;a&quot; disabled&amp;gt;
  &amp;lt;i class=&quot;radio__appearance&quot;&amp;gt;&amp;lt;/i&amp;gt;
&amp;lt;/label&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JavaScript部分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var radios = document.querySelectorAll(&quot;.radio&quot;)
radios.forEach(radio =&amp;gt; {
  // 模拟鼠标点击后:focus样式无效
  radio.addEventListener(&quot;mousedown&quot;, e =&amp;gt; {
    var tar = e.currentTarget
    tar.classList.add(&quot;clicked&quot;)
    var fp = setInterval(function(){
      if (document.activeElement != tar){
        tar.classList.remove(&quot;clicked&quot;)
        clearInterval(fp)
      }
    }, 400)
  })
  // 模拟通过键盘获得焦点后，按`Space`键执行选中操作
  radio.addEventListener(&quot;keydown&quot;, e =&amp;gt; {
    if (e.keyCode === 32){
      e.target.click()
    }
  })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个实现有3个注意点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过&lt;code&gt;label&lt;/code&gt;传递鼠标点击事件到关联的&lt;code&gt;input[type=radio]&lt;/code&gt;，因此可以安心隐藏单选框又可以利用单选框自身特性。但由于&lt;code&gt;label&lt;/code&gt;控件自身的限制，如默认不是可获得焦点元素，因此无法传递键盘按键事件到单选框，即使添加&lt;code&gt;tabindex&lt;/code&gt;特性也需手写JS来实现；&lt;/li&gt;
&lt;li&gt;当tabindex大于等于0时表示该元素可以获得焦点，为0时表示根据元素所在位置安排获得焦点的顺序，而大于0则表示越小越先获得焦点；&lt;/li&gt;
&lt;li&gt;由于单选框的&lt;code&gt;display&lt;/code&gt;为&lt;code&gt;inline-block&lt;/code&gt;，因此单选框将影响line box高度。当自定义单选框内元素采用&lt;code&gt;inline-block&lt;/code&gt;时，若&lt;code&gt;vertical-align&lt;/code&gt;设置稍有不慎就会导致内部元素所在的line box被撑高，从而导致自定义单选框所在的line box高度变大。因此这里采用将内部元素的&lt;code&gt;display&lt;/code&gt;均设置为&lt;code&gt;block&lt;/code&gt;的做法，直接让&lt;code&gt;vertical-align&lt;/code&gt;失效，提高可控性。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt; 对于复选框我们可以稍加修改就可以了，然后通过VUE、React等框架稍微封装一下提供更简约的API，使用起来就更方便了。&lt;br/&gt; 尊重原创，转载请注明来自：&lt;a href=&quot;https://www.cnblogs.com/fsjohnhuang/p/9741345.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/fsjohnhuang/p/9741345.html&lt;/a&gt; ^_^肥仔John&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 23:16:00 +0000</pubDate>
<dc:creator>^_^肥仔John</dc:creator>
<og:description>前言  是否曾经被业务提出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fsjohnhuang/p/9741345.html</dc:identifier>
</item>
<item>
<title>Linux 桌面玩家指南：06. 优雅地使用命令行及 Bash 脚本编程语言中的美学与哲学 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop006.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop006.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;虽然我们玩的是 Linux 桌面系统，但是很多时候我们仍然离不开命令行。有时候，是因为某些工具只有命令行版本，要解决某些问题必须使用命令行，特别是对于我们程序猿和系统管理员来说更是这样。有时候，是因为使用命令行解决问题确实比使用图形界面更加高效。还有些时候，为了自动化、批量化运行程序，我们也不得不使用命令行。得益于 Unix 系统的传统，在命令行中使用管道和文件重定向以及 Shell 脚本语言作为粘合剂，可以将许多简单的工具组合到一起完成更加复杂的任务。总之，Linux 系统中的命令行是相当舒服和优雅的。&lt;/p&gt;
&lt;p&gt;我这里使用的终端程序就是 Gnome 3 桌面自带的 gnome-terminal，而我使用的 Shell 就是 Bash。网上有很多人推崇 Z Shell，但是我并没有改弦易辙，而是坚持使用 Bash。我认为，Bash 的功能也是很强大的，只是我自己水平有限，不能发挥出它全部的威力而已。关于高效使用命令行这个话题，在网上已经是老生常谈了。我这里主要的参考资料是 Bash 的官方文档，使用&lt;code&gt;man bash&lt;/code&gt;即可以阅读，当然也可以&lt;a href=&quot;http://www.gnu.org/software/bash/manual/bash.pdf&quot;&gt;到 Bash 的官网上下载 pdf 版的文档&lt;/a&gt;，放到手机上有空的时候慢慢看。在本文中，也有不少我自己的观点和体会，我会提到有些快捷键要熟记，有些则完全不需要记，毕竟我们的记忆力也是有限的，我还会提到一些助记的方法。所以，本文绝对不是照本宣科，值得大家拥有，请大家一定记得点赞。&lt;/p&gt;
&lt;p&gt;四年前，我脑子一抽，写了一篇 &lt;a href=&quot;https://www.cnblogs.com/youxia/p/linux010.html&quot;&gt;Bash 脚本编程语言中的美学与哲学&lt;/a&gt;，还非常洋洋得意。现在回看起来，觉得还是幼稚了一些。但是我觉得我写的这些也不是完全没有帮助，相比于长达 171 页的详细的 &lt;a href=&quot;http://www.gnu.org/software/bash/manual/bash.pdf&quot;&gt;Bash 官方文档&lt;/a&gt;，也许我对 Bash 脚本编程语言的定位——面向字符串的编程语言——更能让大家理解记住并熟练使用命令行呢。&lt;/p&gt;
&lt;h2 id=&quot;使用-tmux-复用控制台窗口&quot;&gt;使用 tmux 复用控制台窗口&lt;/h2&gt;
&lt;p&gt;高效使用命令行的首要原则就是要尽量避免干扰，什么意思呢？就是说一但开启了一个控制台窗口，就尽量不要再在桌面上切换来切换去了，不要一会儿被别的窗口挡住控制台，一会儿又让别的窗口破坏了控制台的背景，最好是把控制台最大化或全屏，甚至连鼠标都不要用。但是在实际工作中，我们又经常需要同时在多个控制台窗口中进行工作，例如：在一个控制台窗口中运行录制屏幕的命令，在另外一个控制台窗口中工作；或者在一个控制台窗口中工作，在另外一个控制台窗口中阅读文档。如果既想在多个控制台窗口中工作，又不想一大堆窗口挡来挡去、换来换去的话，就可以考虑试试 tmux 了。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201608/16576-20160810160336168-1326564124.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;tmux 的功能很多，什么 Session 啊、Atach 啊、Detach 啊等功能都非常强大。但是我们暂时不用去关心这些，只把重点放在它的控制台窗口复用功能上就行了。tmux 中有 window 和 pane 的概念，tmux 可以创建多个 window，这些 window 是不会互相遮挡的，每次只显示一个 window，其它的 window 会自动隐藏，可以使用快捷键在 window 之间切换。同时，可以把一个 window 切分成多个 pane，这些 pane 同时显示在屏幕上，可以使用快捷键在 pane 之间切换。&lt;/p&gt;
&lt;p&gt;tmux 的快捷键很多，要想全面了解 tmux 的最好办法当然是使用&lt;code&gt;man tmux&lt;/code&gt;命令阅读 tmux 的文档。但是我们只需要记住少数几个重要的快捷键就可以了，如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Ctrl+B c&lt;/td&gt;
&lt;td&gt;创建一个 window&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl+B　[n][p]&lt;/td&gt;
&lt;td&gt;切换到下一个窗口或上一个窗口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Ctrl+B　&amp;amp;&lt;/td&gt;
&lt;td&gt;关闭当前窗口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl+B　&quot;&lt;/td&gt;
&lt;td&gt;将当前 window 或 pane 切分成两个 pane，上下排列&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl+B　%&lt;/td&gt;
&lt;td&gt;将当前 window 或 pane 切分成两个 pane，左右排列&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Ctrl+B　x&lt;/td&gt;
&lt;td&gt;关闭当前 pane&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl+B　[↑][↓][←][→]&lt;/td&gt;
&lt;td&gt;在 pane 之间移动&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Ctrl+[↑][↓][←][→]&lt;/td&gt;
&lt;td&gt;调整当前 pane 的大小，一次调整一格&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Alt+[↑][↓][←][→]&lt;/td&gt;
&lt;td&gt;调整当前 pane 的大小，一次调整五格&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;tmux 的快捷键比较特殊，除了调整 pane 大小的快捷键之外，其它的都是先按 Ctrl+B，再按一个字符。先按 Ctrl+B，再按 c，就会创建一个 window，这里 c 就是 create window。先按 Ctrl+B，再按 n 或者 p，就可以在窗口之间切换，它们是 next window 和 previous window 的意思。关闭窗口是先按 Ctrl+B，再按 &amp;amp;，这个只能死记。先按 Ctrl+B，再按 &quot; ，表示上下拆分窗口，可以想象成单引号和双引号在键盘上是上下铺关系。先按 Ctrl+B，再按 % 表示左右拆分窗口，大概是因为百分数都是左右书写的吧。至于在 pane 之间移动和调整 pane 大小的方向键，就不用多说了吧。&lt;/p&gt;
&lt;h2 id=&quot;在命令行中快速移动光标&quot;&gt;在命令行中快速移动光标&lt;/h2&gt;
&lt;p&gt;在命令行中输入命令时，经常要在命令行中移动光标。这个很简单嘛，使用左右方向键就可以了，但是有时候我们输入了很长一串命令，却突然要修改这个命令最开头的内容，如果使用向左的方向键一个字符一个字符地把光标移到命令的开头，是否太慢了呢？有时我们需要直接在命令的开头和结尾之间切换，有时又需要能够一个单词一个单词地移动光标，在命令行中，其实这都不是事儿。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181001195415464-1553942298.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这几种移动方式都是有快捷键的。其实一个字符一个字符地移动光标也有快捷键 Ctrl+B 和 Ctrl+F，但是这两个快捷键我们不需要记，有什么能比左右方向键更方便的呢？我们真正要记的是下面这几个：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl + A&lt;/td&gt;
&lt;td&gt;将光标移动到命令行的开头&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl + E&lt;/td&gt;
&lt;td&gt;将光标移动到命令行的结尾&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Alt + B&lt;/td&gt;
&lt;td&gt;将光标向左移动一个单词&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Alt + F&lt;/td&gt;
&lt;td&gt;将光标向右移动一个单词&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这几个快捷键太好记了，A 代表 ahead，E 代表 end，B 代表 back，F 代表 forward。为什么按单词移动光标的快捷键都是以 Alt 开头呢？那是因为按字符移动光标的快捷键把 Ctrl 占用了。但是按字符移动光标的快捷键我们用不到啊，因为我们有左右方向键啊。&lt;/p&gt;
&lt;h2 id=&quot;在命令行中快速删除文本&quot;&gt;在命令行中快速删除文本&lt;/h2&gt;
&lt;p&gt;对输入的内容进行修改也是我们经常要干的事情，对命令行进行修改就涉及到先删除一部分内容，再输入新内容。我们碰到的情况是有时候只需要修改个别字符，有时候需要修改个别单词，而有时候，输入了半天的很长的一段命令，我们说不要就全都不要了，要整行删除。常用的删除键当然是 BackSpace 和 Delete 啦，不过一次删除一个字符，还是太慢了些。要在命令行中快速删除文本，请熟记以下几个快捷键吧：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl + U&lt;/td&gt;
&lt;td&gt;删除从光标到行首的所有内容，如果光标在行尾，自然就整行都删除了啊&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl + K&lt;/td&gt;
&lt;td&gt;删除从光标到行尾的所有内容，如果光标在行首，自然也是整行都删除了啊&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl + W&lt;/td&gt;
&lt;td&gt;删除光标前的一个单词&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Alt + D&lt;/td&gt;
&lt;td&gt;删除光标后的一个单词&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Ctrl + Y&lt;/td&gt;
&lt;td&gt;将刚删除的内容粘贴到光标处，有时候删错了可以用这个快捷键恢复删除的内容&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;效果请看下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181001200043896-1772486592.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这几个快捷键也是蛮好记的，U 代表 undo，K 代表 kill，W 代表 word，D 代表 delete， Y 代表 yank。其中比较奇怪的是 Alt+D 又是以 Alt 开头的，那是因为 Ctrl+D 又被占用了。Ctrl+D 有两个意思，一是在编辑命令行的时候它代表删除一个字符，当然，这个快捷键其实我们用不到，因为 BackSpace 和 Delete 方便多了；二是在某些程序从 stdin 读取数据的时候，Ctrl+D 代表 EOF，这个我们偶尔会用到。&lt;/p&gt;
&lt;h2 id=&quot;快速查看和搜索历史命令&quot;&gt;快速查看和搜索历史命令&lt;/h2&gt;
&lt;p&gt;对于曾经运行过的命令，除非特别短，我们一般不会重复输入，从历史记录中找出来用自然要快得多。我们用得最多的就是 ↑ 和 ↓，特别是不久前才刚刚输入过的命令，使用 ↑ 向上翻几行就找到了，按一下 Enter 就执行，多舒服。但是有时候，明明记得是不久前才用过的命令，但是向上翻了半天也没找到，怎么办？那只好使用&lt;code&gt;history&lt;/code&gt;命令来查看所有的历史记录了。历史记录又特别长，怎么办？可以使用 &lt;code&gt;history | less&lt;/code&gt;和&lt;code&gt;history | grep '...'&lt;/code&gt;。除此之外，还有终极大杀招，那就是按 Ctrl+R 从历史记录中进行搜索。按了 Ctrl+R 之后，每输入一个字符，都会和历史记录中进行增量匹配，输入得越多，匹配越精确。当然，有时候含有相同搜索字符串的命令特别多，怎么办？继续按 Ctrl+R，就会继续搜索下一条匹配的历史记录。如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201608/16576-20160810160504246-1565497989.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里，需要记住的命令和快捷键如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;history&lt;/td&gt;
&lt;td&gt;查看历史记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;history | less&lt;/td&gt;
&lt;td&gt;分页查看历史记录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;history | grep '...'&lt;/td&gt;
&lt;td&gt;在历史记录中搜索匹配的命令，并显示&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl + R&lt;/td&gt;
&lt;td&gt;逆向搜索历史记录，和输入的字符进行增量匹配&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Esc&lt;/td&gt;
&lt;td&gt;停止搜索历史记录，并将当前匹配的结果放到当前输入的命令行上&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Enter&lt;/td&gt;
&lt;td&gt;停止搜索历史记录，并将当前匹配的结果立即执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Ctrl + G&lt;/td&gt;
&lt;td&gt;停止搜索历史记录，并放弃当前匹配的结果&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Alt + &amp;gt;&lt;/td&gt;
&lt;td&gt;将历史记录中的位置标记移动到历史记录的尾部&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里需要注意的是，当我们在历史记录中搜索的时候，是有位置标记的，Ctrl+R 是指从当前位置开始，逆向搜索，R 代表的是 reverse，每搜索一条记录，位置标记都会向历史记录的头部移动，下次搜索又从这里开始继续向头部搜索。所以，我们一定要记住快捷键 Alt+&amp;gt;，它可以把历史记录的位置标记还原。另外需要注意的是停止搜索历史记录的快捷键有三个，如果按 Enter 键，匹配的命令就立即执行了，如果你还想有修改这条命令的机会的话，一定不要按 Enter，而要按 Esc。如果什么都不想要，就按 Ctrl+G，它会还你一个空白的命令行。&lt;/p&gt;
&lt;h2 id=&quot;快速引用和修饰历史命令&quot;&gt;快速引用和修饰历史命令&lt;/h2&gt;
&lt;p&gt;除了查看和搜索历史记录，我们还可以以更灵活的方式引用历史记录中的命令。常见的简单的例子有&lt;code&gt;!!&lt;/code&gt;代表引用上一条命令，&lt;code&gt;!$&lt;/code&gt;代表引用上一条命令的最后一个参数，&lt;code&gt;^oldstring^newstring^&lt;/code&gt;代表将上一条命令中的 oldstring 替换成 newstring。这些操作是我们平时使用命令行的时候的一些常用技巧，其实它们的本质，是由 history 库提供的 history expansion 功能。Bash 使用了 history 库，所以也能使用这些功能。其完整的文档可以查看&lt;code&gt;man history&lt;/code&gt;手册页。知道了 history expansion 的理论，我们还可以做一些更加复杂的操作，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/16576/201608/16576-20160810160529746-102762218.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引用和修饰历史命令的完整格式是这样的：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;![!|[?]string|[-]number]:[n|x-y|^|$|*|n*|%]:[h|t|r|e|p|s|g]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，一个对历史命令的引用被 : 分为了三个部分，第一个部分决定了引用哪一条历史命令；第二部分决定了选取该历史命令中的第几个单词，单词是从0开始编号的，也就是说第0个单词代表命令本身，第1个到最后一个单词代表命令的参数；第三部分决定了对选取的单词如何修饰。下面我列出完整表格：&lt;/p&gt;
&lt;p&gt;表格一、引用哪一条历史命令：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;所有对历史命令的引用都以 ! 开始，除了 ^oldstring^newstring^ 形式的快速替换&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;!n&lt;/td&gt;
&lt;td&gt;引用第 n 条历史命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;!-n&lt;/td&gt;
&lt;td&gt;引用倒数第 n 条历史命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;!!&lt;/td&gt;
&lt;td&gt;引用上一条命令，等于 !-1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;!string&lt;/td&gt;
&lt;td&gt;逆向搜索历史记录，第一条以 string 开头的命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;!?string[?]&lt;/td&gt;
&lt;td&gt;逆向搜索历史记录，第一条包含 string 的命令&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;^oldstring^newstring^&lt;/td&gt;
&lt;td&gt;对上一条命令进行快速替换，将 oldstring 替换为 newstring&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;!#&lt;/td&gt;
&lt;td&gt;引用当前输入的命令&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;表格二、选取哪一个单词：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;第0个单词，在 shell 中就是命令本身&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;n&lt;/td&gt;
&lt;td&gt;第n个单词&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;第1个单词，使用 ^ 时可以省略前面的冒号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;最后一个单词，使用 $ 时可以省略前面的冒号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;和 ?string? 匹配的单词，可以省略前面的冒号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;x-y&lt;/td&gt;
&lt;td&gt;从第 x 个单词到第 y 个单词，-y 代表 0-y&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;除第 0 个单词外的所有单词，等于 1-$&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;x*&lt;/td&gt;
&lt;td&gt;从第 x 个单词到最后一个单词，等于 x-$，可以省略前面的冒号&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;x-&lt;/td&gt;
&lt;td&gt;从第 x 个单词到倒数第二个单词&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;表格三、对选取的单词做什么修饰：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;h&lt;/td&gt;
&lt;td&gt;选取路径开头，不要文件名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;t&lt;/td&gt;
&lt;td&gt;选取路径结尾，只要文件名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;选取文件名，不要扩展名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;选取扩展名，不要文件名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;s/oldstring/newstring/&lt;/td&gt;
&lt;td&gt;将 oldstring 替换为 newstring&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;全局替换，和 s 配合使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;只打印修饰后的命令，不执行&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这几个命令其实挺好记的，h 代表 head，只要路径开头不要文件名，t 代表 tail，只要路径结尾的文件名，r 代表 realname，只要文件名不要扩展名，e 代表 extension，只要扩展名不要文件名，s 代表 substitute，执行替换功能，g 代表 global，全局替换，p 代表 print，只打印不执行。有时候光使用 :p 还不够，我们还可以把这个经过引用修饰后的命令直接在当前命令行上展开而不立即执行，它的快捷键是：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Ctrl + Alt + E&lt;/td&gt;
&lt;td&gt;在当前命令行上展开历史命令引用，展开后不立即执行，可以修改，按 Enter 后才会执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Alt + ^&lt;/td&gt;
&lt;td&gt;和上面的功能一样&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这两个快捷键，记住一个就行。这样，当我们对历史命令的引用修饰完成后，可以先展开来看一看，如果正确再执行。眼见为实嘛，反正我是每次都展开看看才放心。&lt;/p&gt;
&lt;h2 id=&quot;使用-tab-键进行补全&quot;&gt;使用 Tab 键进行补全&lt;/h2&gt;
&lt;p&gt;在使用命令行的时候，可以使用 Tab 键对命令和文件名进行补全。一般如果你输入一条命令的前面几个字符后，按 Tab 键两次，将会提示所有可用的命令。输入命令后，在输入参数的位置，如果输入了一个文件名的前几个字符，按 Tab 键，Shell 会查找当前目录下的文件，对文件名进行补全。或者在输入参数的位置直接按两次 Tab 键，将提示所有可用的文件名。效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181001203512415-44335216.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;快速切换当前目录&quot;&gt;快速切换当前目录&lt;/h2&gt;
&lt;p&gt;在使用命令行时，可以使用&lt;code&gt;cd&lt;/code&gt;命令切换当前目录，但是，如果每次都输入一个超长的目录名，则会严重影响效率，特别是在多个目录之间快速切换的时候。例如，在我前面几篇中，经常需要进入&lt;code&gt;/usr/share/backgrounds/contest&lt;/code&gt;目录和&lt;code&gt;/etc/fonts/conf.d&lt;/code&gt;目录查看配置文件，也会进入&lt;code&gt;/usr/src/linux-source-4.15.0&lt;/code&gt;目录查看内核源代码，这些目录名都比较长，如果每次都自己输入，效率低不说，还容易出错。这时，可以通过 Bash 提供的&lt;code&gt;pushd&lt;/code&gt;命令和&lt;code&gt;popd&lt;/code&gt;命令维护一个目录堆栈，并使用&lt;code&gt;dirs&lt;/code&gt;命令查看目录堆栈，使用&lt;code&gt;pushd&lt;/code&gt;命令在目录之间切换。效果如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181001205443850-579448965.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这三个命令的具体参数如下：&lt;/p&gt;
&lt;p&gt;1、dirs——显示当前目录栈中的所有记录（不带参数的dirs命令显示当前目录栈中的记录）&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;格式：dirs  [-clpv]  [+n]  [-n]
选项
-c    删除目录栈中的所有记录
-l     以完整格式显示
-p    一个目录一行的方式显示
-v    每行一个目录来显示目录栈的内容，每个目录前加上的编号
+N  显示从左到右的第n个目录，数字从0开始
-N   显示从右到左的第n个日录，数字从0开始&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、pushd——pushd命令常用于将目录加入到栈中，加入记录到目录栈顶部，并切换到该目录；若pushd命令不加任何参数，则会将位于记录栈最上面的2个目录对换位置&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;格式：pushd  [目录 | -N | +N]   [-n]
选项
目录   将该目录加入到栈顶，并执行&quot;cd 目录&quot;，切换到该目录
+N   将第N个目录移至栈顶（从左边数起，数字从0开始）
-N    将第N个目录移至栈顶（从右边数起，数字从0开始）
-n    将目录入栈时，不切换目录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、popd——popd用于删除目录栈中的记录；如果popd命令不加任何参数，则会先删除目录栈最上面的记录，然后切换到删除过后的目录栈中的最上面的目录&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;格式：popd  [-N | +N]   [-n]
选项
+N   将第N个目录删除（从左边数起，数字从0开始）
-N    将第N个目录删除（从右边数起，数字从0开始）
-n    将目录出栈时，不切换目录&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bash-脚本编程语言的本质一切都是字符串&quot;&gt;Bash 脚本编程语言的本质：一切都是字符串&lt;/h2&gt;
&lt;p&gt;下面，我将探讨 Bash 脚本语言中的美学与哲学。 这不是一篇 Bash 脚本编程的教程，但是却能让人更加深入地了解 Bash 脚本编程，更加快速地学习 Bash 脚本编程。 阅读以下内容，不需要你有 Bash 编程的经验，但一定要和我一样热衷于探索各种编程语言的本质，感悟它们的魅力。&lt;/p&gt;
&lt;p&gt;我们平时喜欢对编程语言进行分类，把编程语言分为面向过程的编程语言、面向对象的编程语言、函数式编程语言等等。在我心中，我认为 Bash 就是一个面向字符串的编程语言。Bash 脚本语言的本质：一切皆是字符串。 Bash 脚本语言的一切哲学都围绕着字符串：它们从哪里来？到哪里去？使命是什么？ Bash 脚本语言的一切美学都源自字符串： 由键盘上几乎所有的符号 “$ ~ ! # &amp;amp; ( ) [ ] { } | &amp;gt; &amp;lt; - . , ; * @ ' &quot; ` \ ^” 排列组合而成的极富视觉冲击力的、功能极其复杂的字符串。&lt;/p&gt;
&lt;p&gt;Bash 是一个 Shell，Shell 出现的初衷是为了将系统中的各种工具粘合在一起，所以它最根本的功能是调用各种命令。而命令以及命令的参数都是由字符串组成的，所以 Bash 脚本语言最终进化成一个面向字符串的语言。 Bash 语言的本质就是：一切都是字符串。 看看下图中的这些变量：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181002211704670-748266758.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是我在交互式的 Bash 命令行中做的一些演示。在上图中，我对变量分别赋值，不管等号右边是一个不带引号的字符串，还是带有引号的字符串，甚至数字，或者数学表达式，最终的结果，变量里面存储的都是字符串。我使用一个 for 循环显示所有的变量，可以看到数学表达式也只是以字符串的形式储存，没有被求值。&lt;/p&gt;
&lt;h2 id=&quot;bash-脚本编程语言中的引号元字符和反斜杠&quot;&gt;Bash 脚本编程语言中的引号、元字符和反斜杠&lt;/h2&gt;
&lt;p&gt;如果一切都是没有特殊功能的平凡的字符串，那就无法构成一门编程语言。在 Bash 中，有很多符号具有特殊含义，如&lt;code&gt;$&lt;/code&gt;符号被用于字符串展开，&lt;code&gt;&amp;amp;&lt;/code&gt;符号用于让命令在后台执行， &lt;code&gt;|&lt;/code&gt;用作管道，&lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt;用于输入输出重定向等等。所以在 Bash 中，虽然同样是字符串，但是被引号包围的字符串和不被引号包围的字符串使用起来是不一样的，被单引号包围的字符串和被双引号包围起来的字符串也是不一样的。&lt;/p&gt;
&lt;p&gt;究竟带引号的字符串和不带引号的字符串使用起来有什么不一样呢？下图是我构建的一些比较典型的例子：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181002214815389-1686713103.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，我展示了 Bash 中生成字符串的 7 种方法：大括号展开、波浪符展开、参数展开、命令替换、算术展开、单词分割和文件路径展开。还有历史命令展开没有在上图展示，但是历史命令展开在前面快速引用和修饰历史命名那一节有展示，可以看到历史命令展开都是使用&lt;code&gt;!&lt;/code&gt;开头的。在使用 Bash 脚本编程的时候，了解以上 7 种字符串生成的方式就够了。在交互式使用 Bash 命令行的时候，才需要了解历史命令展开，熟练使用历史命令展开可以让人事半功倍。&lt;/p&gt;
&lt;p&gt;在上面的图片中可以看到，有一些展开方式在被双引号包围的字符串中是不起作用的，如大括号展开、波浪符展开、单词分割、文件路径展开，而只有参数展开、命令替换和算术展开是起作用的。从图片中还可以看出，字符串中的参数展开、命令替换和算术展开都是由&lt;code&gt;$&lt;/code&gt;符号引导，命令替换还可以由&lt;code&gt;`&lt;/code&gt; 引导。所以，可以进一步总结为，在双引号包围的字符串中，只有&lt;code&gt;$ \ `&lt;/code&gt;这三个字符具有特殊含义。&lt;/p&gt;
&lt;p&gt;如果想让任何一个字符都不具有特殊含义，可以使用单引号将字符串包围，例如使用正则表达式的时候。还有就是在使用 sed、awk 等工具的时候，由于 sed 和 awk 自己执行的命令中往往包含有很多特殊字符，所以它们的命令最好用单引号包围。 例如使用 awk 命令显示&lt;code&gt;/etc/passwd&lt;/code&gt;文件中的每个用户的用户名和全名，可以使用这个命令&lt;code&gt;awk -e '{print $1,$5}'&lt;/code&gt;，其中，传递给 awk 的命令用单引号包围，说明 bash 不执行其中的任何替换或展开。&lt;/p&gt;
&lt;p&gt;另外一个特殊的字符是&lt;code&gt;\&lt;/code&gt;，它也是引用的一种。它可以解除紧跟在它后面的一个特殊字符的特殊含义（引用）。之所以需要&lt;code&gt;\&lt;/code&gt;的存在，是因为在 Bash 中，有些字符称为元字符，这些字符一旦出现，就会将一个字符串分割为多个子串。如果需要在一个字符串中包含这些元字符本身，就必须对它们进行引用。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181003094919920-1121899522.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最常见的元字符就是空格。 从上面几张图片可以看出，如果要将一个含有空格的字符串赋值给一个变量，要么把这个字符串用双引号包围，要么使用&lt;code&gt;\&lt;/code&gt;对空格进行引用。 从上图中可以看出，Bash 中只有9个元字符，它们分别是&lt;code&gt;| &amp;amp; ( ) ; &amp;lt; &amp;gt; space tab&lt;/code&gt;，而在其它编程语言中经常出现的元字符&lt;code&gt;. { } [ ]&lt;/code&gt;以及作为数学运算的加减乘除，在 Bash 中都不是元字符。&lt;/p&gt;
&lt;h2 id=&quot;字符串从哪里来到哪里去&quot;&gt;字符串从哪里来，到哪里去&lt;/h2&gt;
&lt;p&gt;介绍完字符串、介绍完引用和元字符，下一个目标就是来探讨这一个哲学问题：字符串从哪里来、到哪里去？通过该哲学问题的探讨，可以推导出 Bash 脚本语言的整个语法。字符串从哪里来？很显然，其中一个很直接的来源就是我们从键盘上敲上去的。除此之外，就是我前面提到的七八九种字符串展开的方法了。&lt;/p&gt;
&lt;p&gt;字符串展开的流程如下：&lt;/p&gt;
&lt;p&gt;1.先用元字符将一个字符串分割为多个子串；&lt;/p&gt;
&lt;p&gt;2.如果字符串是用来给变量赋值，则不管它是否被双引号包围，都认为它被双引号包围；&lt;/p&gt;
&lt;p&gt;3.如果字符串不被单引号和双引号包围，则进行大括号展开，即将 {a,b}c 展开为 ab ac；&lt;/p&gt;
&lt;p&gt;以上三个流程可以通过下图证明：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181003095601229-1542468681.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.如果字符串不被单引号或双引号包围，则进行波浪符展开，即将 &lt;code&gt;~/&lt;/code&gt; 展开为用户的主目录，将 &lt;code&gt;~+/&lt;/code&gt; 展开为当前工作目录（PWD），将 &lt;code&gt;~-/&lt;/code&gt; 展开为上一个工作目录（OLDPWD）；&lt;/p&gt;
&lt;p&gt;5.如果字符串不被单引号包围，则进行参数和变量展开；这一类的展开全都以&lt;code&gt;$&lt;/code&gt;开头，这是整个 Bash 字符串展开中最复杂的，其中包括用户定义的变量，包括所有的环境变量，以上两种展开方式都是&lt;code&gt;$&lt;/code&gt;后跟变量名，还包括位置变量&lt;code&gt;$1 $2 ... $9&lt;/code&gt;，其它特殊变量：&lt;code&gt;$@&lt;/code&gt; &lt;code&gt;$*&lt;/code&gt; &lt;code&gt;$#&lt;/code&gt; &lt;code&gt;$-&lt;/code&gt; &lt;code&gt;$!&lt;/code&gt; &lt;code&gt;$0&lt;/code&gt; &lt;code&gt;$?&lt;/code&gt; &lt;code&gt;$_&lt;/code&gt;，甚至还有数组：&lt;code&gt;${var[i]}&lt;/code&gt;， 还可以在展开的过程中对字符串进行各种复杂的操作，如：&lt;code&gt;${parameter:-word}&lt;/code&gt; &lt;code&gt;${parameter:=word}&lt;/code&gt; &lt;code&gt;${parameter:+word}&lt;/code&gt; &lt;code&gt;${parameter:?word}&lt;/code&gt; &lt;code&gt;${parameter:offset}&lt;/code&gt; &lt;code&gt;${parameter:offset:length}&lt;/code&gt; &lt;code&gt;${!prefix*}&lt;/code&gt; &lt;code&gt;${!prefix@}&lt;/code&gt; &lt;code&gt;${name[@]}&lt;/code&gt; &lt;code&gt;${!name[*]}&lt;/code&gt; &lt;code&gt;${#parameter}&lt;/code&gt; &lt;code&gt;${parameter#word}&lt;/code&gt; &lt;code&gt;${parameter##word}&lt;/code&gt; &lt;code&gt;${parameter%word}&lt;/code&gt; &lt;code&gt;${parameter%%word}&lt;/code&gt; &lt;code&gt;${parameter/pattern/string}&lt;/code&gt; &lt;code&gt;${parameter^pattern}&lt;/code&gt; &lt;code&gt;${parameter^^pattern}&lt;/code&gt; &lt;code&gt;${parameter,pattern}&lt;/code&gt; &lt;code&gt;${parameter,,pattern}&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;6.如果字符串不被单引号包围，则进行命令替换；命令替换有两种格式，一种是 &lt;code&gt;$(...)&lt;/code&gt;，一种是 &lt;code&gt;`...`&lt;/code&gt;；也就是将命令的输出作为字符串的内容；&lt;/p&gt;
&lt;p&gt;7.如果字符串不被单引号包围，则进行算术展开；算术展开的格式为 &lt;code&gt;$((...))&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;8.如果字符串不被单引号或双引号包围，则进行单词分割；&lt;/p&gt;
&lt;p&gt;9.如果字符串不被单引号或双引号包围，则进行文件路径展开；&lt;/p&gt;
&lt;p&gt;10.以上流程全部完成后，最后去掉字符串外面的引号（如果有的话）。以上流程只按以上顺序进行一遍。不会在变量展开后再进行大括号展开，更不会在第 10 步去除引用后执行前面的任何一步。如果需要将流程再走一遍，请使用 eval。&lt;/p&gt;
&lt;p&gt;探讨完了字符串从哪里来，下面来看看字符串到哪里去。也就是怎么使用这些字符串。使用字符串有以下几种方式：&lt;/p&gt;
&lt;p&gt;1.把它当命令执行；这是 Bash 中的最根本的用法，毕竟 Shell 的存在就是为了粘合各种命令。如果一个字符串出现在本该命令出现的地方（一行的开头，或者关键字 then、do 等的后面），它将会被当成命令执行，如果它不是个合法的命令，就会报错；&lt;/p&gt;
&lt;p&gt;2.把它当成表达式；Bash 中本没有表达式，但是有了 &lt;code&gt;((...))&lt;/code&gt; 和 &lt;code&gt;[[...]]&lt;/code&gt;，就有了表达式；&lt;code&gt;((...))&lt;/code&gt; 可以把它里面的字符串当成算术表达式，而 &lt;code&gt;[[...]]&lt;/code&gt; 会把它里面的字符串当逻辑表达式，仅此两个特例；&lt;/p&gt;
&lt;p&gt;3.给变量赋值；这也是一个特例，有点破坏 Bash 编程语言语法哲学的完整性。为什么这么说呢？因为&lt;code&gt;=&lt;/code&gt;即不是一个元字符，也不允许两边有空格，而且只有第 1 个等号会被当成赋值运算符。&lt;/p&gt;
&lt;p&gt;下面图片为以上观点给出证据：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181003101634967-224384257.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;再加上一点点的定义就可以推导出整个-bash-脚本语言的语法了&quot;&gt;再加上一点点的定义，就可以推导出整个 Bash 脚本语言的语法了&lt;/h2&gt;
&lt;p&gt;前面我已经展示了我对字符串从哪里来、到哪里去这个问题的理解。关于字符串的去向，除了两个表达式和一个为变量赋值这三个特例，剩下的就只有当命令来执行了。在前面，我提到了元字符和引用的概念，这里，还得再增加一点点定义：&lt;/p&gt;
&lt;p&gt;定义1：控制操作符（Control Operator）　前面提到元字符是为了把一个字符串分割为多个子串，而控制操作符就是为了把一系列的字符串分割成多个命令。举例说明，在 Bash中，一个字符串 &lt;code&gt;cat /etc/passwd&lt;/code&gt; 就是一个命令，第一个单词 &lt;code&gt;cat&lt;/code&gt; 是命令，第 2 个单词 &lt;code&gt;/etc/passwd&lt;/code&gt; 是命令的参数，而字符串 &lt;code&gt;cat /etc/passwd | grep youxia&lt;/code&gt; 就是两个命令，这两个命令分别是 &lt;code&gt;cat&lt;/code&gt; 和 &lt;code&gt;grep&lt;/code&gt;，它们之间通过&lt;code&gt;|&lt;/code&gt;分割，所以这里的&lt;code&gt;|&lt;/code&gt;是控制操作符。熟悉 Shell 的朋友肯定知道&lt;code&gt;|&lt;/code&gt;代表的是管道，所以它的作用是：1.把一个字符串分割为两个命令，2.将第一个命令的输出作为第二个命令的输入。在 Bash 中，总共只有 10 个控制操作符，它们分别是&lt;code&gt;||&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;;&lt;/code&gt; &lt;code&gt;;;&lt;/code&gt; &lt;code&gt;()&lt;/code&gt; &lt;code&gt;|&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;lt;newline&amp;gt;&lt;/code&gt;。只要看到这些控制操作符，就可以认为它前面的字符串是一个完整的命令。&lt;/p&gt;
&lt;p&gt;定义2：关键字（Reserved Words）　我没有将其翻译成保留字，很显然，作为编程语言来说，它们应该叫做关键字。一门编程语言肯定必须得提供选择、循环等流程控制语句，还得提供定义函数的功能。这些功能只能通过关键字实现。在 Bash 中，只有 22 个关键字，它们是“! case coproc do done elif else esac fi for function if in select then until while { } time [[ ]]”。这其中有不少的特别之处，比如“! { } [[ ]]”等符号都是关键字，也就是说它们当关键字使用时相当于一个单词，也就是说它们和别的单词必须以元字符分开（否则无法成为独立的单词）。这也是为什么在 Bash 中使用“! { } [[ ]]”时经常要在它们周围留空格的原因。（再一次证明&lt;code&gt;=&lt;/code&gt;是一个很变态的特例，因为它既不是元字符，也不是控制操作符，更加不是关键字，它到底是什么？）&lt;/p&gt;
&lt;p&gt;下面开始推导 Bash 脚本语言的语法：&lt;/p&gt;
&lt;p&gt;推导1：简单命令（Simple command）　就是一条简单的命令，它可以是一个以上述控制操作符结尾的字符串。比如单独放在一行的 &lt;code&gt;uname -r&lt;/code&gt; 命令（单独放在一行的命令其实是以&amp;lt;newline&amp;gt;结尾，&amp;lt;newline&amp;gt;是控制操作符），或者虽然不单独放在一行，但是以&lt;code&gt;;&lt;/code&gt;或&lt;code&gt;&amp;amp;&lt;/code&gt;结尾，比如 &lt;code&gt;uname -r; who; pwd; gvim&amp;amp;&lt;/code&gt; 其中每一个命令都是一个简单命令（当然，这四个命令放在一起的这行代码不叫简单命令），&lt;code&gt;;&lt;/code&gt;就是简单地分割命令，而&lt;code&gt;&amp;amp;&lt;/code&gt;还有让命令在后台执行的功能。这里比较特殊的是双分号&lt;code&gt;;;&lt;/code&gt;，它只用在 case 语句中。&lt;/p&gt;
&lt;p&gt;推导2：管道（Pipe Line）　管道是 Shell 中的精髓，就是让前一个命令的输出成为后一个命令的输入。管道的完整语法是这样 &lt;code&gt;[time [-p]] [ ! ] command1 | command2&lt;/code&gt; 或这样 &lt;code&gt;[time [-p]] [ ! ] command1 |&amp;amp; command2&lt;/code&gt; 的。其中 time 关键字和 ! 关键字都是可选的（使用[...]指出哪些部分是可选的），&lt;code&gt;time&lt;/code&gt; 关键字可以计算命令运行的时间，而 &lt;code&gt;!&lt;/code&gt; 关键字是将命令的返回状态取反。看清楚 &lt;code&gt;!&lt;/code&gt; 关键字周围的空格哦。如果使用&lt;code&gt;|&lt;/code&gt;，就是把第一个命令的标准输出作为第二个命令的标准输入，如果使用&lt;code&gt;|&amp;amp;&lt;/code&gt;，则将第一个命令的标准输出和标准错误输出都当成第二个命令的输入。&lt;/p&gt;
&lt;p&gt;推导3：命令序列（List）　如果多个简单命令或多个管道放在一起，它们之间以&lt;code&gt;;&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;&amp;lt;newline&amp;gt;&lt;/code&gt; &lt;code&gt;||&lt;/code&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;等控制操作符分开，就称之为一个命令序列。关于&lt;code&gt;||&lt;/code&gt;和&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;，熟悉 C、C++、Java 等编程语言的朋友们肯定也不会陌生，它们遵循同样的短路求值的思想。比如 &lt;code&gt;command1 || command2&lt;/code&gt; 只有当 command1 执行不成功的时候才执行 command2，而 &lt;code&gt;command1 &amp;amp;&amp;amp; command2&lt;/code&gt; 只有当 command1 执行成功的时候才执行 command2。&lt;/p&gt;
&lt;p&gt;推导4：复合命令（Compound Commands）　如果将前面的简单命令、管道或者命令序列以更复杂的方式组合在一起，就可以构成复合命令。在 Bash 中，有 4 种形式的复合命令，它们分别是 &lt;code&gt;(list)&lt;/code&gt; 、 &lt;code&gt;{ list; }&lt;/code&gt; 、 &lt;code&gt;((expression))&lt;/code&gt; 、 &lt;code&gt;[[ expression ]]&lt;/code&gt; 。请注意第 2 种形式和第 4 种形式大括号和中括号周围的空格，也请注意第 2 种形式中 &lt;code&gt;list&lt;/code&gt; 后面的&lt;code&gt;;&lt;/code&gt;，不过如果&lt;code&gt;}&lt;/code&gt;另起一行，则不需要&lt;code&gt;;&lt;/code&gt;，因为&lt;code&gt;&amp;lt;newline&amp;gt;&lt;/code&gt;和&lt;code&gt;;&lt;/code&gt;是起同样作用的。在以上4种复合命令中， &lt;code&gt;(list)&lt;/code&gt; 是在一个新的Shell中执行命令序列，这些命令的执行不会影响当前Shell的环境变量，而 &lt;code&gt;{ list; }&lt;/code&gt; 只是简单地将命令序列分组。后面两种表达式求值前面已经讲过，这里就不讲了。后面可能会详细列出逻辑表达式求值的选项。&lt;/p&gt;
&lt;p&gt;上面的4步推导是一步更进一步的，是由简单逐渐到复杂的，最简单的命令可以组合成稍复杂的管道，再组合成更复杂的命令序列，最后组成最复杂的复合命令。&lt;/p&gt;
&lt;p&gt;下面是 Bash 脚本语言的流程控制语句，如下：&lt;/p&gt;
&lt;p&gt;　　1. &lt;code&gt;for name [ [ in [ word ... ] ] ; ] do list ; done&lt;/code&gt; ；&lt;/p&gt;
&lt;p&gt;　　2. &lt;code&gt;for (( expr1 ; expr2 ; expr3 )) ; do list ; done&lt;/code&gt; ；&lt;/p&gt;
&lt;p&gt;　　3. &lt;code&gt;select name [ in word ] ; do list ; done&lt;/code&gt; ；&lt;/p&gt;
&lt;p&gt;　　4. &lt;code&gt;case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac&lt;/code&gt; ；&lt;/p&gt;
&lt;p&gt;　　5. &lt;code&gt;if list; then list; [ elif list; then list; ] ... [ else list; ] fi&lt;/code&gt; ；&lt;/p&gt;
&lt;p&gt;　　6. &lt;code&gt;while list-1; do list-2; done&lt;/code&gt; ；&lt;/p&gt;
&lt;p&gt;　　7. &lt;code&gt;until list-1; do list-2; done&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;上面的公式大家看得懂吧，我相信大家肯定看得懂。其中的 [...] 代表的是可以有也可以真没有的部分。在以上公式中，请注意第 2 个公式 for 循环中的双括号，它执行的是其中的表达式的算术运算，这是和其它高级语言的 for 循环最像的，但是很遗憾，Bash 中的算术表达式目前只能计算整数。再请注意第 3 个公式，select 语法，和 for...in... 循环的语法比较类似，但是它可以在屏幕上显示一个菜单。如果我没有记错的话，Basic 语言中应该有这个功能。其它的控制结构在别的高级语言中都很常见，就不需要我在这里啰嗦了。&lt;/p&gt;
&lt;p&gt;最后，再来展示一下如何定义函数：&lt;/p&gt;
&lt;p&gt;　　 &lt;code&gt;name () compound-command [redirection]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　或者&lt;/p&gt;
&lt;p&gt;　　 &lt;code&gt;function name [()] compound-command [redirection]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以看出，如果有 &lt;code&gt;function&lt;/code&gt; 关键字，则&lt;code&gt;()&lt;/code&gt;是可选的，如果没有 &lt;code&gt;function&lt;/code&gt; 关键字，则&lt;code&gt;()&lt;/code&gt;是必须的。这里需要特别指出的是：函数体只要求是 compound-command，我前面总结过 compound-command 有四种形式，所以有时候定义一个函数并不会出现&lt;code&gt;{ }&lt;/code&gt;哦。如下图，这样的函数也是合法的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181003103425479-386152724.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;That's all。这就是 Bash 脚本语言的全部语法。就这么简单。&lt;/p&gt;
&lt;p&gt;好像忘了点什么？对了，还有输入输出重定向没有讲。输入输出重定向是 Shell 中又一个伟大的发明，它的存在有着它独特的哲学意义。这个请看下一节。&lt;/p&gt;
&lt;h2 id=&quot;输入输出重定向&quot;&gt;输入输出重定向&lt;/h2&gt;
&lt;p&gt;Unix 世界有一个伟大的哲学：一切皆是文件。（这个扯得有点远。） Unix 世界还有一个伟大的哲学：创建进程比较方便。（这个扯得也有点远。）而且，每一个进程一创建，就会自动打开三个文件，它们分别是标准输入、标准输出、标准错误输出，普通情况下，它们连接到用户的控制台。在 Shell 中，使用数字来标识一个打开的文件，称为文件描述符，而且数字 0、 1、 2 分别代表标准输入、标准输出和标准错误输出。在 Shell 中，可以通过&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt;将命令的输入、输出进行重定向。结合 &lt;code&gt;exec&lt;/code&gt; 命令，可以非常方便地打开和关闭文件。需要注意的是，当文件描述符出现在&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt;右边的时候，前面要使用&lt;code&gt;&amp;amp;&lt;/code&gt;符号，这可能是为了和数学表达式中的大于和小于进行区别吧。使用&lt;code&gt;&amp;amp;-&lt;/code&gt;可以关闭文件描述符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt; &amp;lt; &amp;amp; 数字 exec -&lt;/code&gt;，这就是输入输出重定向的全部。下面的公式中，我使用 n 代表数字，如果是两个不同的数字，则使用 n1、n2，使用 [...] 代表可选参数。输入输出重定向的语法如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[n]&amp;gt; file        #重定向标准输出(或 n)到file。
[n]&amp;gt;&amp;gt; file       #重定向标准输出(或 n)到file，追加到file末尾。
[n]&amp;lt; file        #将file重定向到标准输入（或 n）。
[n1]&amp;gt;&amp;amp;n2         #重定向标准输出(或 n1)到n2。
2&amp;gt; file &amp;gt;&amp;amp;2      #重定向标准输出和错误输出到file。
| command        #将标准输出通过管道传递给command。
2&amp;gt;&amp;amp;1 | command   #将标准输出和错误输出一起通过管道传递给command，等同于|&amp;amp;。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，数字和&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt;符号之间是没有空格的。结合 exec，可以非常方便地使用一个文件描述符来打开、关闭文件，如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;echo Hello &amp;gt;file1
exec 3&amp;lt;file1 4&amp;gt;file2  #打开文件
cat &amp;lt;&amp;amp;3 &amp;gt;&amp;amp;4           #重定向标准输入到 3,标准输出到 4，相当于读取file1的内容然后写入file2
exec 3&amp;lt;&amp;amp;- 4&amp;gt;&amp;amp;-        #关闭文件
cat file2
#显示结果为 Hello
 
#还可以暂存和恢复文件描述符，如下：
exec 5&amp;gt;&amp;amp;2            #把原来的标准错误输出保存到文件描述符5上
exec 2&amp;gt; /tmp/$0.log  #重定向标准错误输出
...
exec 2&amp;gt;&amp;amp;5            #恢复标准错误输出
exec 5&amp;gt;&amp;amp;-            #关闭文件描述符5，因为不需要了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以将&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;一起使用，表示打开一个文件进行读写。&lt;/p&gt;
&lt;p&gt;除了 exec，输入输出重定向和 read 命令配合也很好用，read 命令每次读取文件的一行。但是要注意的是，输入输出重定向放到 for、while 等循环的循环体和循环外，效果是不一样的。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181003105128857-1806168710.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181003105146809-1254155416.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，输入输出重定向符号&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt;还可以和&lt;code&gt;()&lt;/code&gt;一起使用，表示进程替换（Process substitution），如&lt;code&gt;&amp;gt;(list)&lt;/code&gt;、&lt;code&gt;&amp;lt;(list)&lt;/code&gt;。结合前面提到的&lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;(list)&lt;/code&gt;的含义，进程替换的作用是很容易猜到的哦。&lt;/p&gt;
&lt;h2 id=&quot;bash-脚本语言的美学大道至简&quot;&gt;Bash 脚本语言的美学：大道至简&lt;/h2&gt;
&lt;p&gt;如果你问我 Bash 脚本语言哪里美？我会回答：简洁就是美。请看下面逐条论述：&lt;/p&gt;
&lt;p&gt;1.使用了简洁的抽象的符号。Bash 脚本语言几乎使用到了键盘上能够找到的所有符号，&lt;code&gt;$&lt;/code&gt;用作字符串展开，&lt;code&gt;|&lt;/code&gt;用作管道，&lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;gt;&lt;/code&gt;用作输入输出重定向，一点都不浪费；&lt;/p&gt;
&lt;p&gt;2.只使用了 9 个元字符、10 个控制操作符和 22 个关键字，就构建了一个完整的、面向字符串编程的语言；&lt;/p&gt;
&lt;p&gt;3.概念上具有很好的一致性；例如 &lt;code&gt;(list)&lt;/code&gt; 复合命令的功能是执行括号内的命令序列，而&lt;code&gt;$&lt;/code&gt;用于引导字符串展开，所以 &lt;code&gt;$(list)&lt;/code&gt; 用于命令替换（所以我前面说&lt;code&gt;$()&lt;/code&gt;形式的命令替换比&lt;code&gt;`...`&lt;/code&gt;形式的命令替换更加具有一致性）。再例如 &lt;code&gt;((expresion))&lt;/code&gt; 用于数学表达式求值，所以 &lt;code&gt;$((expression))&lt;/code&gt; 代表算术展开。再例如&lt;code&gt;{}&lt;/code&gt;和&lt;code&gt;,&lt;/code&gt;配合使用，且中间没有空格时，代表大括号展开，但是当需要使用&lt;code&gt;{ }&lt;/code&gt;来定义复合命令时，必须把&lt;code&gt;{ }&lt;/code&gt;当关键字，它们和它里面的内容必须以空格隔开，而且&lt;code&gt;}&lt;/code&gt;和它前面的一条命令之间必须有一个&lt;code&gt;;&lt;/code&gt;或者&lt;code&gt;&amp;lt;newline&amp;gt;&lt;/code&gt;。这些概念上的一致性设计得非常精妙，使用起来自然而然可以让人体会到一种美感；&lt;/p&gt;
&lt;p&gt;4.完美解决了一个命令执行时的输出和运行状态的分离。有其它编程语言经历的人也经常会遇到这样的问题：当我们调用一个函数的时候，函数可能会产生两个结果，一个是函数的返回值，一个是函数调用是否成功。在 C# 和 Java 等高级语言中，往往使用 try...catch 等捕获异常的方式来判断函数调用是否成功，但仍然有程序员让函数返回 null 代表失败，而 C 语言这种没有异常机制的语言，实在是难以判断一个函数的返回值究竟如何表示该函数调用是否成功（比如就有很多 API 让函数返回 -1 代表失败，而有的函数运行失败是会设置 errno 全局变量）。在 Bash 中，命令运行的状态和命令的标准输出区分很明确，如果你需要命令的标准输出，使用命令替换来生成字符串，如果你只需要命令的运行状态，直接将命令写在 if 语句之中即可，或者使用 &lt;code&gt;$?&lt;/code&gt; 特殊变量来检查上一条命令的运行状态。如果不想在检查命令运行状态的时候让命令的标准输出影响用户，可以把它重定向到 &lt;code&gt;/dev/null&lt;/code&gt;，像这样：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;if cat /etc/passwd | grep youxia &amp;gt; /dev/null; then echo 'youxia is exist'; fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.使用管道和输入输出重定向让文件的读写变得简单。想一想在 C 语言中怎么读文件吧，除了麻烦的 open、close 不说，每读一个字符串还得先准备一个 buffer，准备长了怕浪费空间，准备短了怕缓冲区溢出，虐心啦。使用 Bash，那真的是太方便了。&lt;/p&gt;
&lt;p&gt;6.它还有邪恶的 eval 哦，eval 命令实在是太强大了，请看下图，模拟指针进行查表：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201810/16576-20181003105832803-1722874679.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，自从 Bash 3 之后，Bash 本身就提供了间接引用的功能（使用“${!var}”）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例外：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Bash 语言也并不是在所有的方面都是完美的，还存在几个特别的例外，像前面说的&lt;code&gt;=&lt;/code&gt;。除了&lt;code&gt;=&lt;/code&gt;之外，&lt;code&gt;()&lt;/code&gt;也有一个使用不一致的地方，那就是对数组的初始化，例如 &lt;code&gt;array=(a b c d e f)&lt;/code&gt; ，这和前面讲的&lt;code&gt;()&lt;/code&gt;用于在子 Shell 中执行命令序列还真的是不一致。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;以上内容是我的胡言乱语，因为以上内容即无法教会大家完整的 Bash 语法，也无法教会大家用 Bash 做任何一点有意义的工作。如果想用 Bash 干点实事，建议大家阅读 O'Reilly 出的《Shell脚本学习指南》。&lt;/p&gt;
&lt;h2 id=&quot;求打赏&quot;&gt;求打赏&lt;/h2&gt;
&lt;p&gt;我对这次写的这个系列要求是非常高的：首先内容要有意义、够充实，信息量要足够丰富；其次是每一个知识点要讲透彻，不能模棱两可含糊不清；最后是包含丰富的截图，让那些不想装 Linux 系统的朋友们也可以领略到 Linux 桌面的风采。如果我的努力得到大家的认可，可以扫下面的二维码打赏一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180831154735325-1276475036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2018年10月04日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 21:27:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop006.html</dc:identifier>
</item>
<item>
<title>mybatis源码-解析配置文件（四）之配置文件Mapper解析 - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9741404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9741404.html</guid>
<description>&lt;p&gt;在 &lt;a href=&quot;https://www.cnblogs.com/homejim/p/9672224.html&quot;&gt;mybatis源码-解析配置文件（三）之配置文件Configuration解析&lt;/a&gt; 中， 讲解了 &lt;code&gt;Configuration&lt;/code&gt; 是如何解析的。&lt;/p&gt;
&lt;p&gt;其中， &lt;code&gt;mappers&lt;/code&gt;作为&lt;code&gt;configuration&lt;/code&gt;节点的一部分配置， 在本文章中， 我们讲解解析&lt;code&gt;mappers&lt;/code&gt;节点， 即 &lt;strong&gt;xxxMapper.xml&lt;/strong&gt; 文件的解析。&lt;/p&gt;
&lt;h2 id=&quot;解析入口&quot;&gt;1 解析入口&lt;/h2&gt;
&lt;p&gt;在解析 &lt;strong&gt;mybatis-config.xml&lt;/strong&gt; 时， 会进行解析 xxxMapper.xml 的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181004003305693?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;解析的入口&quot;/&gt;&lt;br/&gt;在图示流程的 &lt;code&gt;XMLConfigBuilder.parse()&lt;/code&gt; 函数中, 该函数内部， 在解析 &lt;code&gt;mappers&lt;/code&gt; 节点时， 会调用 &lt;code&gt;mapperElement(root.evalNode(&quot;mappers&quot;))&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void mapperElement(XNode parent) throws Exception {
    if (parent != null) {
      // 遍历其子节点
      for (XNode child : parent.getChildren()) {
        // 如果配置的是包(packege)
        if (&quot;package&quot;.equals(child.getName())) {
          String mapperPackage = child.getStringAttribute(&quot;name&quot;);
          configuration.addMappers(mapperPackage);
        } else {
          // 如果配置的是类（有三种情况 resource / class / url）
          String resource = child.getStringAttribute(&quot;resource&quot;);
          String url = child.getStringAttribute(&quot;url&quot;);
          String mapperClass = child.getStringAttribute(&quot;class&quot;);
          // 配置一：使用 resource 类路径
          if (resource != null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass == null) {
            ErrorContext.instance().resource(resource);
            InputStream inputStream = Resources.getResourceAsStream(resource);
            // 创建 XMLMapperBuilder 对象
            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
            // 解析 xxxMapper.xml 
            mapperParser.parse();
            // 配置二： 使用 url 绝对路径
          } else if (resource == null &amp;amp;&amp;amp; url != null &amp;amp;&amp;amp; mapperClass == null) {
            ErrorContext.instance().resource(url);
            InputStream inputStream = Resources.getUrlAsStream(url);
            // 创建 XMLMapperBuilder 对象
            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
            // 解析 xxxMapper.xml 
            mapperParser.parse();
            // 配置三： 使用 class 类名
          } else if (resource == null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass != null) {
            // 通过反射创建对象
            Class&amp;lt;?&amp;gt; mapperInterface = Resources.classForName(mapperClass);
            // 添加
            configuration.addMapper(mapperInterface);
          } else {
            throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
          }
        }
      }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上源码中可以发现， 配置时， 一种是通过包的方式， 一种是通过指定文件的方式。&lt;/p&gt;
&lt;p&gt;但不管是怎么配置， 最后的找落点都是 &lt;strong&gt;xxxMapper.xml&lt;/strong&gt; 文件的解析。&lt;/p&gt;
&lt;h2 id=&quot;解析&quot;&gt;2 解析&lt;/h2&gt;
&lt;p&gt;包扫描时， 会加载指定包下的文件， 最终会调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void loadXmlResource() {
    // 判断是否已经加载过
    if (!configuration.isResourceLoaded(&quot;namespace:&quot; + type.getName())) {
      String xmlResource = type.getName().replace('.', '/') + &quot;.xml&quot;;
      InputStream inputStream = null;
      try {
        inputStream = Resources.getResourceAsStream(type.getClassLoader(), xmlResource);
      } catch (IOException e) {
        // ignore, resource is not required
      }
      if (inputStream != null) {
        XMLMapperBuilder xmlParser = new XMLMapperBuilder(inputStream, assistant.getConfiguration(), xmlResource, configuration.getSqlFragments(), type.getName());
        // 解析
        xmlParser.parse();
      }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此， 不管是包扫描还是文件扫描， 最终都经历一下 &lt;code&gt;xmlParser.parse()&lt;/code&gt; 解析过程。&lt;/p&gt;
&lt;h3 id=&quot;解析流程&quot;&gt;2.1 解析流程&lt;/h3&gt;
&lt;p&gt;解析 &lt;strong&gt;xxxMapper.xml&lt;/strong&gt; 文件的是下面这个函数，解析 &lt;strong&gt;mapper&lt;/strong&gt; 节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public void parse() {
    // 判断是否已经加载过
    if (!configuration.isResourceLoaded(resource)) {
      // 解析 &amp;lt;mapper&amp;gt; 节点
      configurationElement(parser.evalNode(&quot;/mapper&quot;));
      // 标记一下，已经加载过了
      configuration.addLoadedResource(resource);
      // 绑定映射器到namespace
      bindMapperForNamespace();
    }
    // 处理 configurationElement 中解析失败的&amp;lt;resultMap&amp;gt;
    parsePendingResultMaps();
    // 处理configurationElement 中解析失败的&amp;lt;cache-ref&amp;gt;
    parsePendingCacheRefs();
    // 处理 configurationElement 中解析失败的 SQL 语句
    parsePendingStatements();
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;大致流程&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解析调用 &lt;code&gt;configurationElement()&lt;/code&gt; 函数来解析各个节点&lt;/li&gt;
&lt;li&gt;标记传入的文件已经解析了&lt;/li&gt;
&lt;li&gt;绑定文件到相应的 namespace， 所以 namespace 需要是唯一的&lt;/li&gt;
&lt;li&gt;处理解析失败的节点&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;解析各个节点&quot;&gt;2.2 解析各个节点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;  private void configurationElement(XNode context) {
    try {
      // 获取namespace属性， 其代表者这个文档的标识
      String namespace = context.getStringAttribute(&quot;namespace&quot;);
      if (namespace == null || namespace.equals(&quot;&quot;)) {
        throw new BuilderException(&quot;Mapper's namespace cannot be empty&quot;);
      }
      builderAssistant.setCurrentNamespace(namespace);
      // 解析 &amp;lt;cache-ref&amp;gt; 节点
      cacheRefElement(context.evalNode(&quot;cache-ref&quot;));
      // 解析 &amp;lt;cache&amp;gt; 节点
      cacheElement(context.evalNode(&quot;cache&quot;));
      // 解析 &amp;lt;/mapper/parameterMap&amp;gt; 节点
      parameterMapElement(context.evalNodes(&quot;/mapper/parameterMap&quot;));
      // 解析 &amp;lt;/mapper/resultMap&amp;gt; 节点
      resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));
      // 解析 &amp;lt;/mapper/sql&amp;gt; 节点
      sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));
      // 解析 select|insert|update|delet 节点
      buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));
    } catch (Exception e) {
      throw new BuilderException(&quot;Error parsing Mapper XML. Cause: &quot; + e, e);
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了避免篇幅太长， 在此就不深入讲解各个解析过程， 后续会开专门的章节。&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 16:37:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9741404.html</dc:identifier>
</item>
<item>
<title>MyBatis(4)动态SQL - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/9741325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/9741325.html</guid>
<description>&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。&lt;/p&gt;
     
&lt;p&gt;虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。&lt;/p&gt;
     
&lt;p&gt;动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;---&amp;gt;if&lt;/p&gt;
&lt;p&gt;---&amp;gt;choose(when,otherwise)&lt;/p&gt;
&lt;p&gt;---&amp;gt;trim(where,set)&lt;/p&gt;
&lt;p&gt;---&amp;gt;foreach&lt;/p&gt;

&lt;div readability=&quot;25&quot;&gt;

&lt;p&gt;&lt;span&gt;此文章及以后不带结果的截图，影响整体文章的布局美感！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其他的一些可以简单看一下之前的博文！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先来看看本次工程的目录吧：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201810/1488757-20181003232314519-67576586.png&quot; alt=&quot;&quot; width=&quot;113&quot; height=&quot;172&quot;/&gt;&lt;p&gt;mybatis-config.xml:&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!&lt;span&gt;DOCTYPE configuration
 PUBLIC &lt;/span&gt;&quot;-//mybatis.org//DTD Config 3.0//EN&quot;
 &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
     &amp;lt;properties resource=&quot;db.properties&quot; &amp;gt;&amp;lt;/properties&amp;gt;
     &amp;lt;environments &lt;span&gt;default&lt;/span&gt;=&quot;development&quot;&amp;gt;
           &amp;lt;environment id=&quot;development&quot;&amp;gt;
                &amp;lt;transactionManager type=&quot;JDBC&quot; /&amp;gt;
                &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                     &amp;lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&amp;gt;
                     &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&amp;gt;
                &amp;lt;/dataSource&amp;gt;
           &amp;lt;/environment&amp;gt;
     &amp;lt;/environments&amp;gt;
     &amp;lt;mappers&amp;gt;
           &amp;lt;mapper resource=&quot;DynamicSQL.xml&quot;/&amp;gt;
     &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Employee.java(getter&amp;amp;setter&amp;amp;toString)&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Employee {
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String gender;
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String email;
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Department dept;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 现在基本的布局已经完成！！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1）if&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A.在DynamicMapper.java接口中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;携带了哪个字段的查询条件就携带这个字段的值&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpByIf(Employee emp);
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; 在Dynamic'SQl.xml文件&lt;/p&gt;
&lt;div readability=&quot;13.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- &lt;span&gt;if&lt;/span&gt; --&amp;gt;
 &amp;lt;!-- 查询员工，要求，携带了那个字段查询条件就带上那个字段的字段值 --&amp;gt;
 &amp;lt;!--      &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpByIf(Employee emp); --&amp;gt;
 &amp;lt;select id=&quot;getEmpByIf&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
     select &lt;/span&gt;*&lt;span&gt; from test
     where
          &lt;/span&gt;&amp;lt;!-- test:判断表达式（OGNL） --&amp;gt;
          &amp;lt;!-- OGNL:apache官方文档有明确的解释说明 --&amp;gt;
          &amp;lt;!-- 从参数中取值进行判断不是数据库中取值 --&amp;gt;
          &amp;lt;!-- 特殊字符应该写转义字符 --&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;id!=null&quot;&amp;gt;&lt;span&gt;
           id&lt;/span&gt;=&lt;span&gt;#{id}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
           and name like #{name}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
           and email like #{email}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个文件的内容简要的进行说明一下：&lt;/p&gt;
&lt;p&gt; and &lt;span&gt;name&lt;/span&gt; like #{name}&lt;/p&gt;
&lt;p&gt;这里的&lt;span&gt;红色&lt;/span&gt;的name是我们查询的name值，不是数据库中的name&lt;/p&gt;
&lt;p&gt;#{name}是把我们手动输入的&lt;span&gt;红色name&lt;/span&gt;传递过去，进行数据库的查询&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt; 测试类：&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; SqlSessionFactory getSqlSessionFactory() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
           String resource &lt;/span&gt;= &quot;mybatis-config.xml&quot;&lt;span&gt;;
           InputStream inputStream &lt;/span&gt;=&lt;span&gt; Resources.getResourceAsStream(resource);   
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder().build(inputStream);
     }
     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; test() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入的红色name值进行数据库的查询&lt;/span&gt;
                Employee emp = &lt;span&gt;new&lt;/span&gt; Employee(5, &quot;%Mr%&quot;, &quot;boy&quot;, &quot;%1287%&quot;&lt;span&gt;);
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps =&lt;span&gt; mapper.getEmpByIf(emp);
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 查询之后的显示代码&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
DEBUG 10-02 12:13:49,806 ==&amp;gt;  Preparing: select * from test &lt;span&gt;where id=? and name like ? and email like ?&lt;/span&gt;   (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 12:13:49,843 ==&amp;gt; Parameters: 5(Integer), %Mr%(String), %1287%(String)  (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 12:13:49,873 &amp;lt;==      Total: 1  (BaseJdbcLogger.java:159&lt;span&gt;)
[Employee [id&lt;/span&gt;=5, name=MrChengs, gender=boy, email=1287xxxxxx@xx.com, dept=&lt;span&gt;null&lt;/span&gt;]]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; B.在查询的时候，如果某些时候某些条件没带可能导致sql拼装有问题&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;select id=&quot;getEmpByIf&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
     select &lt;/span&gt;*&lt;span&gt; from test
     where
          &lt;/span&gt;&amp;lt;!-- test:判断表达式（OGNL） --&amp;gt;
          &amp;lt;!-- OGNL:apache官方文档有明确的解释说明 --&amp;gt;
          &amp;lt;!-- 从参数中取值进行判断不是数据库中取值 --&amp;gt;
          &amp;lt;!-- 特殊字符应该写转义字符 --&amp;gt;
     &amp;lt;!--此时我们假设忘记把id传进来 --&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
           and name like #{name}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
           and email like #{email}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; look：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
show message:DEBUG 10-02 12:18:30,831 ==&amp;gt;  Preparing: select * from test where and name like ? and email like ? &lt;br/&gt;(BaseJdbcLogger.java:159)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div readability=&quot;36.5&quot;&gt;
&lt;p&gt;solution ①：&lt;span&gt;  where 1=1&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;select id=&quot;getEmpByIf&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
     select &lt;/span&gt;*&lt;span&gt; from test
    &lt;/span&gt;&amp;lt;!-- 加入固定的条件，怎么拼装都行 --&amp;gt;&lt;span&gt;
     where &lt;/span&gt;&lt;span&gt;1=1&lt;/span&gt;
          &amp;lt;!-- test:判断表达式（OGNL） --&amp;gt;
          &amp;lt;!-- OGNL:apache官方文档有明确的解释说明 --&amp;gt;
          &amp;lt;!-- 从参数中取值进行判断不是数据库中取值 --&amp;gt;
          &amp;lt;!-- 特殊字符应该写转义字符 --&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
           and name like #{name}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
           and email like #{email}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;solution ②：使用&amp;lt;where&amp;gt;&amp;lt;/where&amp;gt;  只会去掉一个and  或者or&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;select id=&quot;getEmpByIf&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
     select &lt;/span&gt;*&lt;span&gt; from test
     &lt;/span&gt;&lt;span&gt;&amp;lt;where&amp;gt;&lt;/span&gt;
                &amp;lt;!-- test:判断表达式（OGNL） --&amp;gt;
                &amp;lt;!-- OGNL:apache官方文档有明确的解释说明 --&amp;gt;
                &amp;lt;!-- 从参数中取值进行判断不是数据库中取值 --&amp;gt;
                &amp;lt;!-- 特殊字符应该写转义字符 --&amp;gt;
          &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
                and name like #{name}
          &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
          &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
                and email like #{email}
          &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
  &lt;span&gt;   &amp;lt;/where&amp;gt;&lt;/span&gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 注意使用and&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.使用trim标签进行，字符串截取&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;先看一个案例的错误代码展示：&lt;/p&gt;

&lt;p&gt;DynamicSQLMapper.java&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试Trim&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpByIfTrim(Employee emp);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在DynamicSQL.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 测试Trim（） --&amp;gt;
 &amp;lt;!-- &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpByIfTrim(Employee emp); --&amp;gt;
 &amp;lt;select id=&quot;getEmpByIfTrim&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
    select &lt;/span&gt;*&lt;span&gt; from test
    where
     &lt;/span&gt;&amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;id!=null&quot;&amp;gt;&lt;span&gt;
           id&lt;/span&gt;=&lt;span&gt;#{id} and
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
           name like #{name}    and
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
           email like #{email}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;假设我们此时传参为name属性一个&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpByIfTrim() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
              &lt;span&gt;  Employee emp &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new Employee(&quot;%Mr%&quot;, null, null&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps =&lt;span&gt; mapper.getEmpByIfTrim(emp);
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 拼串结果&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
DEBUG 10-02 13:31:59,995 ==&amp;gt;  Preparing: select * from test where id=? and name like ? and
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;开始使用trim标签：（一些用法都在注释中，请注意看注释）&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- 测试Trim（） --&amp;gt;
 &amp;lt;!-- &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpByIfTrim(Employee emp); --&amp;gt;
 &amp;lt;select id=&quot;getEmpByIfTrim&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
    select &lt;/span&gt;*&lt;span&gt; from test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!-- prefix:前缀， trim标签体中是整个字符串拼串后的结果     给拼串后的整体字符串加一个前缀--&amp;gt;
    &amp;lt;!-- prefixOverrides:前缀覆盖，    去点整个前缀前面多余的字符串 --&amp;gt;
    &amp;lt;!-- suffix:后缀，  给拼串后的整个字符串加一个后缀 --&amp;gt;
    &amp;lt;!-- suffixOverrides:后缀覆盖，去掉整个字符串后面多余的字符串 --&amp;gt;&lt;/span&gt;
    &amp;lt;trim prefix=&quot;where&quot;  suffixOverrides=&quot;and&quot;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null and name!=''&quot;&amp;gt;&lt;span&gt;
           name like #{name}    and
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null and email.trim()!=''&quot;&amp;gt;&lt;span&gt;
           email like #{email} and
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;gender!=null&quot;&amp;gt;&lt;span&gt;
           gender&lt;/span&gt;=&lt;span&gt;#{gender}
     &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;/trim&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpByIfTrim() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                Employee emp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Employee(&quot;%Mr%&quot;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps =&lt;span&gt; mapper.getEmpByIfTrim(emp);
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果拼串：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
DEBUG 10-02 13:43:25,216 ==&amp;gt; &lt;span&gt; Preparing: select * from test where name like ?&lt;/span&gt;   (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 13:43:25,266 ==&amp;gt; Parameters: %Mr%(String)  (BaseJdbcLogger.java:159)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注意：在测试id的时候，不写则默认为零，博主自己测试的时候遇到的，所以把id的查询条件拿掉了！&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span&gt;3.choose分支选择&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;如果带了id使用id进行查询，带了name就是用name进行查询&lt;/p&gt;
&lt;p&gt;只能使用一个进行查询&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;接口类的代码：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试choose&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpBychoose(Employee emp);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; DynamicSQL.xml:&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- choose --&amp;gt;
 &amp;lt;!-- 如果带了id使用id进行查询，带了name就是用name进行查询,只能使用一个进行查询 --&amp;gt;
 &amp;lt;!-- &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpBychoose(Employee emp); --&amp;gt;
 &amp;lt;select id=&quot;getEmpBychoose&quot; resultType=&quot;com.MrChengs.bean.Employee&quot;&amp;gt;&lt;span&gt;
     select &lt;/span&gt;*&lt;span&gt; from test
     &lt;/span&gt;&amp;lt;where&amp;gt;
           &amp;lt;choose&amp;gt;
                &amp;lt;when test=&quot;name!=null&quot;&amp;gt;&lt;span&gt;
                     name like #{name}
                &lt;/span&gt;&amp;lt;/when&amp;gt;    
                &amp;lt;when test=&quot;email!=null&quot;&amp;gt;&lt;span&gt;
                     email &lt;/span&gt;=&lt;span&gt; #{email}
                &lt;/span&gt;&amp;lt;/when&amp;gt;
                &amp;lt;when test=&quot;id!=null&quot;&amp;gt;&lt;span&gt;
                     id&lt;/span&gt;=&lt;span&gt;#{id}
                &lt;/span&gt;&amp;lt;/when&amp;gt;    
                &amp;lt;otherwise&amp;gt;&lt;span&gt;
                     d_id&lt;/span&gt;=1
                &amp;lt;/otherwise&amp;gt;
           &amp;lt;/choose&amp;gt;
     &amp;lt;/where&amp;gt;
 &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试代码：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试choose&lt;/span&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpBychoose() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
 &lt;span&gt;               Employee emp &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new Employee(&quot;%Mr%&quot;, null, null);
                emp.setId(5&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps =&lt;span&gt; mapper.getEmpBychoose(emp);
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
DEBUG 10-02 14:07:35,311 ==&amp;gt;  Preparing: select * from test WHERE name like ?   (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 14:07:35,363 ==&amp;gt; Parameters: %Mr%(String)  (BaseJdbcLogger.java:159)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 此时我们不仅传入了name同时还传入了id，但是拼串之后是使用name进行查询的&lt;/p&gt;


&lt;p&gt;&lt;span&gt;3.更新&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A.&amp;lt;set&amp;gt;&amp;lt;/set&amp;gt;版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在接口中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新方法&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updataEmp(Employee emp);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 在DynamicSQl.xml文件：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- update更新 --&amp;gt;
  &amp;lt;!-- 更新 --&amp;gt;
 &amp;lt;!-- &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updataEmp(Employee emp); --&amp;gt;
 &amp;lt;update id=&quot;updataEmp&quot;&amp;gt;&lt;span&gt;
  update test
  &lt;/span&gt;&amp;lt;set&amp;gt;
  &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null&quot;&amp;gt;name=#{name},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null&quot;&amp;gt;  email=#{email},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;gender!=null&quot;&amp;gt;gender=#{gender},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
  &amp;lt;/set&amp;gt;&lt;span&gt;
  where  id&lt;/span&gt;=&lt;span&gt;#{id}
 &lt;/span&gt;&amp;lt;/update&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 使用&amp;lt;set&amp;gt;标签，可以自动为我们解决存在的    ”,“   问题&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt; 测试：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新upddate&lt;/span&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpupdate() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
         &lt;span&gt;       Employee emp &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new Employee(&quot;MrChengsR&quot;, &quot;gril&quot;, null);
                emp.setId(7&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
                mapper.updataEmp(emp);
                System.out.println(emp);
                session.commit();
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 此时修改数据成功&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;15&quot;&gt;

&lt;p&gt;B.&amp;lt;trim&amp;gt;&amp;lt;trim&amp;gt; version&lt;/p&gt;
&lt;p&gt;仅仅是修改xml文件，其余的都不变&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;update id=&quot;updataEmp&quot;&amp;gt;&lt;span&gt;
       update test
           &lt;/span&gt;&amp;lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&amp;gt;
                &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;name!=null&quot;&amp;gt;name=#{name},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
                &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;email!=null&quot;&amp;gt;  email=#{email},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
                &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;gender!=null&quot;&amp;gt;gender=#{gender},&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
           &amp;lt;/trim&amp;gt;&lt;span&gt;
       where  id&lt;/span&gt;=&lt;span&gt;#{id}
      &lt;/span&gt;&amp;lt;/update&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;4.foreach&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;p&gt; A)foreach：&lt;/p&gt;
&lt;p&gt;DynamicSQLMapper.java&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpsByCollection(List&amp;lt;Integer&amp;gt; list);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; DynamicSQL.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
     &amp;lt;!-- foreach: --&amp;gt;
      &amp;lt;!--      &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpsByCollection(Employee emp); --&amp;gt;
     &amp;lt;select id=&quot;getEmpsByCollection&quot; resultType=&quot;com.MrChengs.bean.Employee&quot; &amp;gt;&lt;span&gt;
           select &lt;/span&gt;*&lt;span&gt; from test where id in(
           &lt;/span&gt;&lt;span&gt;&amp;lt;!-- collection:指定遍历的集合 --&amp;gt;
           &amp;lt;!-- list类型的参数会做特殊的处理封装在map中，map的key叫list --&amp;gt;
           &amp;lt;!-- item:将当前遍历出的元素赋值给指定的变量 --&amp;gt;
           &amp;lt;!-- #{变量名} 就能取出当前遍历的元素 --&amp;gt;
           &amp;lt;!-- separator:每个元素之间的分隔符    此时是in(a,b,c,d)这里面的   ， --&amp;gt;
           &amp;lt;!-- open:遍历出所有结果拼接一个开始的字符 --&amp;gt;
           &amp;lt;!-- close:便利的所有结果拼出结尾 --&amp;gt;
           &amp;lt;!-- index:遍历list是索引，遍历map就是map的key --&amp;gt;&lt;/span&gt;
           &amp;lt;foreach collection=&quot;list&quot; item=&quot;item_id&quot; separator=&quot;,&quot;&amp;gt;&lt;span&gt;
                #{item_id}
           &lt;/span&gt;&amp;lt;/foreach&amp;gt;&lt;span&gt;
           )
     &lt;/span&gt;&amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;div readability=&quot;35&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpForeach() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps = mapper.getEmpsByCollection(Arrays.asList(5,7,8&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Employee emp : emps){
                     System.out.println(emp);
                }
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 得到结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
DEBUG 10-02 19:16:01,838 ==&amp;gt;  Preparing: select * from test where id in( ? , ? , ? )   (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 19:16:01,887 ==&amp;gt; Parameters: 5(Integer), 7(Integer), 8(Integer)  (BaseJdbcLogger.java:159&lt;span&gt;)
DEBUG &lt;/span&gt;10-02 19:16:01,909 &amp;lt;==      Total: 3  (BaseJdbcLogger.java:159&lt;span&gt;)
Employee [id&lt;/span&gt;=5, name=MrChengs, gender=boy, email=xxxxxxxx@qq.com, dept=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;]
Employee [id&lt;/span&gt;=7, name=MrChengs, gender=gril, email=zhangsan@qq.com, dept=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;]
Employee [id&lt;/span&gt;=8, name=MrChen, gender=gril, email=xxxxxx@xx.xxx, dept=&lt;span&gt;null&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;B.批量保存&lt;/p&gt;
&lt;p&gt;方法1：&lt;/p&gt;
&lt;p&gt;接口类中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;批量存取&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addEmps(@Param(&quot;emps&quot;)List&amp;lt;Employee&amp;gt; employee);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; xml文件：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
     &amp;lt;!-- &lt;span&gt;//&lt;/span&gt;&lt;span&gt;批量存取--&amp;gt;&lt;/span&gt;
     &amp;lt;!--  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addEmps(@Param(&quot;emps&quot;)Employee employee); --&amp;gt;
     &amp;lt;insert id=&quot;addEmps&quot;&amp;gt;&lt;span&gt;
           insert into test(name,gender,email,d_id)
           values
           &lt;/span&gt;&amp;lt;foreach collection=&quot;emps&quot; separator=&quot;,&quot; item=&quot;emp&quot;&amp;gt;
           &lt;span&gt; &amp;lt;!-- 传参数之前是我们new的一个对象，传参数之后是插入数据库的数据 --&amp;gt;&lt;/span&gt;&lt;span&gt;
           (#{emp.name},#{emp.gender},#{emp.email},#{emp.dept.id})
           &lt;/span&gt;&amp;lt;/foreach&amp;gt;
     &amp;lt;/insert&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 实现类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;批量存取&lt;/span&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpaddEmps() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; employee = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Employee&amp;gt;&lt;span&gt;();
                employee.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Employee(&quot;Ma&quot;, &quot;gril&quot;, &quot;Ma@Ma&quot;, &lt;span&gt;new&lt;/span&gt; Department(1&lt;span&gt;)));
                employee.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Employee(&quot;Mb&quot;, &quot;boy&quot;, &quot;Mb@Mb&quot;, &lt;span&gt;new&lt;/span&gt; Department(2&lt;span&gt;)));
                mapper.addEmps(employee);
                session.commit();
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时是成功插入数据&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;方法二：&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 方法二 --&amp;gt;
     &amp;lt;!-- 需要加上 --&amp;gt;
    &lt;span&gt; &amp;lt;!-- jdbc.url=jdbc:mysql://localhost:3306/mybatis?allowMultiQueries=true --&amp;gt;&lt;/span&gt;
     &amp;lt;insert id=&quot;addEmps&quot;&amp;gt;
           &amp;lt;foreach collection=&quot;emps&quot; separator=&quot;;&quot; item=&quot;emp&quot;&amp;gt;&lt;span&gt;
           insert into test(name,gender,email,d_id)
           values
           (#{emp.name},#{emp.gender},#{emp.email},#{emp.dept.id})
           &lt;/span&gt;&amp;lt;/foreach&amp;gt;
     
     &amp;lt;/insert&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 其余不变可以进行测试&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;c.两个重要的参数&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;     &amp;lt;!-- 两个重要的参数 --&amp;gt;&lt;/p&gt;
&lt;p&gt;     &amp;lt;!-- _parameter:代表整个参数，单个参数就是这个参数，多个参数就是封装成的map --&amp;gt;&lt;/p&gt;
&lt;p&gt;     &amp;lt;!-- _databaseId:配置了databaseIdProvider标签，就是代表当前数据库的别名 --&amp;gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;_databaseId：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;mybatis-config.xml&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;databaseIdProvider type=&quot;DB_VENDOR&quot;&amp;gt;
           &amp;lt;property name=&quot;MySQL&quot; value=&quot;mysql&quot;/&amp;gt;
           &amp;lt;property name=&quot;Oracle&quot; value=&quot;oracle&quot;/&amp;gt;
     &amp;lt;/databaseIdProvider&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 接口类中&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试两个属性&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpselect();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; DynamicMapper.xml&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 两个重要的参数 --&amp;gt;
     &amp;lt;!-- _parameter:代表整个参数，单个参数就是这个参数，多个参数就是封装成的map --&amp;gt;
     &amp;lt;!-- _databaseId:配置了databaseIdProvider标签，就是代表当前数据库的别名 --&amp;gt;
     
     &amp;lt;!-- &lt;span&gt;public&lt;/span&gt; Employee getEmpselect(&lt;span&gt;int&lt;/span&gt; id); --&amp;gt;

    &amp;lt;!-- 修改if中的test条件即可实现不同数据库之间的查询 --&amp;gt;
     &amp;lt;select id=&quot;getEmpselect&quot; resultType=&quot;com.MrChengs.bean.Employee&quot; &lt;span&gt;databaseId=&quot;mysql&quot;&lt;/span&gt;&amp;gt;
           &lt;span&gt;&amp;lt;if test=&quot;_databaseId=='mysql'&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;
                select &lt;/span&gt;*&lt;span&gt; from test
           &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
           &lt;span&gt;&amp;lt;if test=&quot;_databaseId=='oracle'&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;
                select &lt;/span&gt;*&lt;span&gt; from test
           &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个重要的参数&lt;/span&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpselect() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps=&lt;span&gt; mapper.getEmpselect();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Employee emp : emps){
                     System.out.println();
                }
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; 此时可以成功查询数据！！&lt;/p&gt;


&lt;p&gt;&lt;span&gt;_parameter&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;在接口类中：把刚刚测试代码加上id&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试两个属性&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpselect(&lt;span&gt;int&lt;/span&gt; id);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在xnl文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- &lt;span&gt;public&lt;/span&gt; Employee getEmpselect(&lt;span&gt;int&lt;/span&gt; id); --&amp;gt;
     &amp;lt;select id=&quot;getEmpselect&quot; resultType=&quot;com.MrChengs.bean.Employee&quot; databaseId=&quot;mysql&quot;&amp;gt;
           &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;_databaseId=='mysql'&quot;&amp;gt;&lt;span&gt;
                select &lt;/span&gt;*&lt;span&gt; from test
                &lt;/span&gt;&lt;span&gt;&amp;lt;if test=&quot;_parameter!=null&quot;&amp;gt;
                     where id=#{id}
                &amp;lt;/if&amp;gt;&lt;/span&gt;
           &amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
           &amp;lt;&lt;span&gt;if&lt;/span&gt; test=&quot;_databaseId=='oracle'&quot;&amp;gt;&lt;span&gt;
                select &lt;/span&gt;*&lt;span&gt; from test
           &lt;/span&gt;&amp;lt;/&lt;span&gt;if&lt;/span&gt;&amp;gt;
     &amp;lt;/select&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; 测试类：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpselect() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
               &lt;span&gt; DynamicSQLMapper mapper &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= session.getMapper(DynamicSQLMapper.class);
                List&amp;lt;Employee&amp;gt; emps= mapper.getEmpselect(5&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;此时的查询成功！！！&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;D.bind标签的使用&lt;/p&gt;
&lt;p&gt;接口类中：&lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试两个属性
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public List&amp;lt;Employee&amp;gt; getEmpselect();
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public List&amp;lt;Employee&amp;gt; getEmpselect(int id);&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Employee&amp;gt; getEmpselect(Employee em);
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
xml文件：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;select id=&quot;getEmpselect&quot; resultType=&quot;com.MrChengs.bean.Employee&quot; databaseId=&quot;mysql&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &lt;span&gt;&amp;lt;!-- bind：可以将OGNL表达式的值绑定到一个变量中，方便引用这个变量的值 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          &lt;span&gt; &lt;/span&gt;&lt;span&gt;&amp;lt;!-- name ：是我们指定的绑定参数--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;!-- value ：指定参数的值 --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;bind name=&quot;_name&quot; value=&quot;'%'+name+'%'&quot;/&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;if test=&quot;_databaseId=='mysql'&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                select * from test&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;if test=&quot;_parameter!=null&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                     where name like #{_name}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;/if&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;/if&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;if test=&quot;_databaseId=='oracle'&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                select * from test&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;/if&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &amp;lt;/select&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 测试类:&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;     @Test
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testgetEmpselect() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
           SqlSessionFactory sessionFactory &lt;/span&gt;=&lt;span&gt; getSqlSessionFactory();
           SqlSession session &lt;/span&gt;=&lt;span&gt; sessionFactory.openSession();
           &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                DynamicSQLMapper mapper &lt;/span&gt;= session.getMapper(DynamicSQLMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;List&amp;lt;Employee&amp;gt; emps= mapper.getEmpselect();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;List&amp;lt;Employee&amp;gt; emps= mapper.getEmpselect(5);&lt;/span&gt;
                Employee emp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Employee();
                emp.setName(&lt;/span&gt;&quot;M&quot;&lt;span&gt;);
                List&lt;/span&gt;&amp;lt;Employee&amp;gt; emps=&lt;span&gt; mapper.getEmpselect(emp);
                System.out.println(emps);
           }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{
                session.close();
           }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;E.SQL标签&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;27&quot;&gt; 
&lt;p&gt;     &amp;lt;!-- &amp;lt;include refid=&quot;&quot;&amp;gt;&amp;lt;/include&amp;gt; --&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &amp;lt;!-- SQL:抽取可重用的sql字段，方便后面引用 --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &amp;lt;!-- include:就是引用外部标签 --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &amp;lt;!--&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;   1.sql抽取：经常要查询的列名，或者插入用的列名抽取出来方便引用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           2.include来引用已经抽取的sql&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           3.include还可以自定义一些property，sql标签内部只能使用自定义的属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                 include-property:取值正确方式  ${prop}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                 #{不可以使用这种方式}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      --&amp;gt;&lt;/p&gt;
&lt;p&gt;     &amp;lt;sql id=&quot;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           &amp;lt;!-- 同时这里面还可以使用   if进行判断 --&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;           &amp;lt;if test=&quot;&quot;&amp;gt;&amp;lt;/if&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &amp;lt;/sql&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;










&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 03 Oct 2018 15:46:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/9741325.html</dc:identifier>
</item>
<item>
<title>CDN使用心得：加速双刃剑 - GodBMW</title>
<link>http://www.cnblogs.com/geyouneihan/p/9741021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geyouneihan/p/9741021.html</guid>
<description>&lt;p&gt;&lt;strong&gt;文章图片存储在&lt;code&gt;GitHub&lt;/code&gt;，网速不佳的朋友，请看&lt;a href=&quot;https://godbmw.com/passage/60&quot;&gt;《CDN 使用心得：加速双刃剑》&lt;/a&gt; 或者 来我的技术小站 &lt;a href=&quot;https://godbmw.com/&quot;&gt;godbmw.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文以腾讯云平台的 CDN 服务为例，记录下在个人网站开发和公司项目实战中的对 CDN 使用的心得：便宜没好货。&lt;/p&gt;
&lt;h2 id=&quot;什么是-cdn&quot;&gt;1. 什么是 CDN？&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;CDN 的全称是 Content Delivery Network，即内容分发网络。其目的是通过在现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络“边缘”，使用户可以就近取得所需的内容，提高用户访问网站的响应速度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;可以简单理解成：CDN 就是一个能让用户以最快速度访问到相应资源的网盘。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何访问-cdn-资源&quot;&gt;2. 如何访问 CDN 资源？&lt;/h2&gt;
&lt;p&gt;在云平台的控制台开启“对象存储”服务后，开启对应的“加速域名”，此时，针对这个存储桶，就开启了 CDN 加速。&lt;/p&gt;
&lt;p&gt;如下图所示，“加速域名”就是 CDN 域名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/CDN%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%EF%BC%9A%E5%8A%A0%E9%80%9F%E5%8F%8C%E5%88%83%E5%89%91/1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在存储桶下可以进行各种文件操作，比如我将友链的图片都放在了&lt;code&gt;/friend&lt;/code&gt;文件夹下面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/CDN%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%EF%BC%9A%E5%8A%A0%E9%80%9F%E5%8F%8C%E5%88%83%E5%89%91/2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，&lt;code&gt;birdteam.png&lt;/code&gt;的 URL 是：&lt;code&gt;https://blog-1255463368.cos.ap-guangzhou.myqcloud.com/friend/birdteam.png&lt;/code&gt;；CDN 对应的 URL：&lt;code&gt;https://blog-1255463368.file.myqcloud.com/friend/birdteam.png&lt;/code&gt;。&lt;strong&gt;任何资源都可以用文件路径拼接的方式来获得 URL，进而获得资源&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;如何在-spa-应用中使用-cdn&quot;&gt;3. 如何在 SPA 应用中使用 CDN？&lt;/h2&gt;
&lt;p&gt;时下火热的&lt;code&gt;vuejs&lt;/code&gt;,&lt;code&gt;reactjs&lt;/code&gt;等 SPA 框架以及衍生出来的脚手架，均有利用&lt;code&gt;webpack&lt;/code&gt;进行打包操作。&lt;strong&gt;最无脑的操作就是将打包后的文件直接扔到服务器上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后，用户访问网站的时候，从服务器拉取资源，速度慢到另人发指。除此之外，还得考虑做后端缓存，更是出力不讨好:)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是，借助 CDN 可以极大缩小用户等待时间，提高访问体验。同时，云平台 CDN 还自带前端缓存，简单方便。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;vue-cli&lt;/code&gt;搭建的&lt;code&gt;vuejs&lt;/code&gt;应用中，可以通过修改&lt;code&gt;/config/index.js&lt;/code&gt;中的配置来更改打包后&lt;code&gt;index.html&lt;/code&gt;文件中资源的地址。如下图所示，更改&lt;code&gt;build.assetsSubDirectory&lt;/code&gt;为存储桶的文件名称，更改 &lt;code&gt;build.assetsPublicPath&lt;/code&gt;为 CDN 的域名：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/CDN%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%EF%BC%9A%E5%8A%A0%E9%80%9F%E5%8F%8C%E5%88%83%E5%89%91/3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;命令行执行&lt;code&gt;npm run build&lt;/code&gt;后，打包后的项目文件都放在了&lt;code&gt;/dist/&lt;/code&gt;文件下。根据前面的配置，将&lt;code&gt;/dist/static/&lt;/code&gt;文件夹直接上传到云平台的对应存储桶的跟目录下即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/CDN%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%EF%BC%9A%E5%8A%A0%E9%80%9F%E5%8F%8C%E5%88%83%E5%89%91/4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看网站&lt;a href=&quot;https://godbmw.com/&quot;&gt;&lt;code&gt;godbmw.com&lt;/code&gt;&lt;/a&gt;的源码，可以看到资源都是从 CDN 上获取了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/CDN%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97%EF%BC%9A%E5%8A%A0%E9%80%9F%E5%8F%8C%E5%88%83%E5%89%91/5.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;不要乱用第三方-cdn&quot;&gt;4. 不要乱用第三方 CDN&lt;/h2&gt;
&lt;p&gt;在搭建博客之初，因为想节省一些 CDN 资源，所以，一些第三方 JS 库并没有利用&lt;code&gt;npm&lt;/code&gt;来进行管理，而是通过第三方 CDN 来引入的。比如博客下方的播放组件&lt;code&gt;Aplayer&lt;/code&gt;，评论系统&lt;code&gt;Valine&lt;/code&gt;等等。&lt;/p&gt;
&lt;p&gt;这样做的好处就是打包体积小了很多（从&lt;code&gt;800+kb&lt;/code&gt;降低到了&lt;code&gt;500+kb&lt;/code&gt;）。本来以为可以提高用户访问速度，&lt;strong&gt;但事实是：免费的 CDN 是不稳定的。&lt;/strong&gt;&lt;code&gt;Valine&lt;/code&gt;CDN 资源的获取，有时候会阻塞 3s，在网络不稳定的移动端，浏览体验非常差。&lt;/p&gt;
&lt;p&gt;除了速度不稳定，不通过&lt;code&gt;npm&lt;/code&gt;管理的项目难以维护。隔了 2 个月，就忘记用了什么库，只能通过翻代码和查看&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签中 CDN 的资源地址来确定。&lt;/p&gt;
&lt;p&gt;因此，尽量在项目中使用&lt;code&gt;npm&lt;/code&gt;安装第三方库，而不是通过第三方平台的 CDN 服务加载对应的库代码。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;5. 写在最后&lt;/h2&gt;
&lt;p&gt;CDN 的理解和应用都非常简单，没什么深度，只是经验之谈（所以文章结构有点散，请谅解）。&lt;/p&gt;
&lt;p&gt;目前，各大平台的 CDN 免费额度对于个人项目甚至是小型商业项目是够用的。例如我的博客打包后才&lt;code&gt;800+kb&lt;/code&gt;，而免费额度是&lt;code&gt;10G/月&lt;/code&gt;，如果能用光免费额度，那么也说明网站可以盈利了。此时，更应该使用 CDN 来提速。这是一个良性循环。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;完&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 13:59:00 +0000</pubDate>
<dc:creator>GodBMW</dc:creator>
<og:description>文章图片存储在 ，网速不佳的朋友，请看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geyouneihan/p/9741021.html</dc:identifier>
</item>
<item>
<title>python线程池ThreadPoolExecutor与进程池ProcessPoolExecutor - Harvard_Fly</title>
<link>http://www.cnblogs.com/FG123/p/9704233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FG123/p/9704233.html</guid>
<description>&lt;p&gt; &lt;span&gt;python中ThreadPoolExecutor(线程池)与ProcessPoolExecutor(进程池)&lt;/span&gt;&lt;span&gt;都是concurrent.futures模块下的，&lt;/span&gt;&lt;span&gt;主线程(或进程)中可以获取某一个线程(进程)执行的状态或者某一个任务执行的状态及返回值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过submit返回的是一个future对象，它是一个未来可期的对象，通过它可以获悉线程的状态&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;ThreadPoolExecutor(线程池)&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;通过submit函数提交执行的函数到线程池中，done()判断线程执行的状态：&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_thread_time(times):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    time.sleep(times)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; times
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建线程池  指定最大容纳数量为4&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; executor = ThreadPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过submit提交执行的函数到线程池中&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; task1 = executor.submit(get_thread_time, (1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; task2 = executor.submit(get_thread_time, (2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; task3 = executor.submit(get_thread_time, (3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; task4 = executor.submit(get_thread_time, (4&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1:{} &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(task1.done()))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(task2.done()))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task3:{} &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(task3.done()))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task4:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(task4.done()))
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; time.sleep(2.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;after 3s {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;*20&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; done_map =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:task1.done(),
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:task2.done(),
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:task3.done(),
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:task4.done()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.5秒之后，线程的执行状态&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; task_name,done &lt;span&gt;in&lt;/span&gt;&lt;span&gt; done_map.items():
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; done:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}:completed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(task_name))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;result：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;task1:False 
task2:False
task3:False 
task4:False
after 3s &lt;/span&gt;--------------------&lt;span&gt;
task1:completed
task2:completed&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;初始状态4个task都是未完成状态，2.5秒后task1和task2执行完成，task3和task由于是sleep(3) sleep(4)所以仍然是未完成的sleep状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过wait()判断线程执行的状态：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;wait(fs, timeout=None, return_when=ALL_COMPLETED)，wait接受3个参数，fs表示执行的task序列；timeout表示等待的最长时间，超过这个时间即使线程未执行完成也将返回；return_when表示wait返回结果的条件，默认为ALL_COMPLETED全部执行完成再返回：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    ThreadPoolExecutor, wait
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_thread_time(times):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    time.sleep(times)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; times
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; start =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; executor = ThreadPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; task_list = [executor.submit(get_thread_time, times) &lt;span&gt;for&lt;/span&gt; times &lt;span&gt;in&lt;/span&gt; [1, 2, 3, 4&lt;span&gt;]]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; i = 1
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; task &lt;span&gt;in&lt;/span&gt;&lt;span&gt; task_list:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task{}:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(i, task))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     i += 1
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(wait(task_list, timeout=2.5))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;wait在2.5秒后返回线程的状态，result：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;task1:&amp;lt;Future at 0x7ff3c885f208 state=running&amp;gt;&lt;span&gt;
task2:&lt;/span&gt;&amp;lt;Future at 0x7ff3c885fb00 state=running&amp;gt;&lt;span&gt;
task3:&lt;/span&gt;&amp;lt;Future at 0x7ff3c764b2b0 state=running&amp;gt;&lt;span&gt;
task4:&lt;/span&gt;&amp;lt;Future at 0x7ff3c764b9b0 state=running&amp;gt;&lt;span&gt;
DoneAndNotDoneFutures(&lt;br/&gt;done&lt;/span&gt;={&amp;lt;Future at 0x7ff3c885f208 state=finished returned int&amp;gt;, &amp;lt;Future at 0x7ff3c885fb00 state=finished returned int&amp;gt;}, &lt;/span&gt;&lt;br/&gt;&lt;span&gt;not_done={&amp;lt;Future at 0x7ff3c764b2b0 state=running&amp;gt;, &amp;lt;Future at 0x7ff3c764b9b0 state=running&amp;gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到在timeout 2.5时，task1和task2执行完毕，task3和task4仍在执行中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过map返回线程的执行结果：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_thread_time(times):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    time.sleep(times)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; times
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; start =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; executor = ThreadPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; i = 1
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt; executor.map(get_thread_time,[2,3,1,4&lt;span&gt;]):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task{}:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(i, result))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     i += 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;map(fn, *iterables, timeout=None)，第一个参数fn是线程执行的函数；第二个参数接受一个可迭代对象；第三个参数timeout跟wait()的timeout一样，但由于map是返回线程执行的结果，如果timeout小于线程执行时间会抛异常TimeoutError。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_thread_time(times):
    time.sleep(times)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; times


start &lt;/span&gt;=&lt;span&gt; time.time()
executor &lt;/span&gt;= ThreadPoolExecutor(max_workers=4&lt;span&gt;)

i &lt;/span&gt;= 1
&lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt; executor.map(get_thread_time,[2,3,1,4&lt;span&gt;]):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task{}:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(i, result))
    i &lt;/span&gt;+= 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;map的返回是有序的，它会根据第二个参数的顺序返回执行的结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;task1:2&lt;span&gt;
task2:&lt;/span&gt;3&lt;span&gt;
task3:&lt;/span&gt;1&lt;span&gt;
task4:&lt;/span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;as_completed返回线程执行结果：&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; OrderedDict
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    ThreadPoolExecutor, as_completed
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_thread_time(times):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    time.sleep(times)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; times
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; start =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; executor = ThreadPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; task_list = [executor.submit(get_thread_time, times) &lt;span&gt;for&lt;/span&gt; times &lt;span&gt;in&lt;/span&gt; [2, 3, 1, 4&lt;span&gt;]]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; task_to_time = OrderedDict(zip([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],[2, 3, 1, 4&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; task_map = OrderedDict(zip(task_list, [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt;&lt;span&gt; as_completed(task_list):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     task_name =&lt;span&gt; task_map.get(result)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(task_name,task_to_time.get(task_name)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;task1、task2、task3、task4的等待时间分别为2s、3s、1s、4s，通过as_completed返回执行完的线程结果，as_completed(fs, timeout=None)接受2个参数，第一个是执行的线程列表，第二个参数timeout与map的timeout一样，当timeout小于线程执行时间会抛异常TimeoutError。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;task3:1&lt;span&gt;
task1:&lt;/span&gt;2&lt;span&gt;
task2:&lt;/span&gt;3&lt;span&gt;
task4:&lt;/span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过执行结果可以看出，as_completed返回的顺序是线程执行结束的顺序，最先执行结束的线程最早返回。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;ProcessPoolExecutor&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于频繁的cpu操作，由于GIL锁的原因，多个线程只能用一个cpu，这时多进程的执行效率要比多线程高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程池操作斐波拉切：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 1
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; fib(n - 1) + fib(n - 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; start_time =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; executor = ThreadPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; task_list = [executor.submit(fib, n) &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; range(3, 35&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; thread_results = [task.result() &lt;span&gt;for&lt;/span&gt; task &lt;span&gt;in&lt;/span&gt;&lt;span&gt; as_completed(task_list)]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(thread_results)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThreadPoolExecutor time is: {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(time.time() - start_time))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;result：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[8, 5, 3, 2, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 10946, 46368, 6765, 28657, 17711, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887&lt;span&gt;]
ThreadPoolExecutor time &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;: 4.998981237411499&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;进程池操作斐波拉切：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent.futures &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ProcessPoolExecutor
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fib(n):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; n &amp;lt; 3&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 1
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; fib(n - 1) + fib(n - 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; start_time =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; executor = ProcessPoolExecutor(max_workers=4&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; task_list = [executor.submit(fib, n) &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; range(3, 35&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; process_results = [task.result() &lt;span&gt;for&lt;/span&gt; task &lt;span&gt;in&lt;/span&gt;&lt;span&gt; as_completed(task_list)]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(process_results)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProcessPoolExecutor time is: {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(time.time() - start_time))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;result:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 75025, 28657, 46368, 196418, 121393, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887&lt;span&gt;]
ProcessPoolExecutor time &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;: 3.3585257530212402&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看出，对于频繁cpu操作进程是优于线程的，3.3s&amp;lt;4.9s&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ProcessPoolExecutor在使用上和ThreadPoolExecutor大致是一样的，它们在futures中的方法也是相同的，但是对于map()方法ProcessPoolExecutor会多一个参数&lt;/span&gt;&lt;span&gt;chunksize(&lt;/span&gt;&lt;span&gt;ThreadPoolExecutor中这个参数没有任何作用&lt;/span&gt;&lt;span&gt;)，&lt;/span&gt;&lt;span&gt;chunksize将迭代对象切成块，将其作为分开的任务提交给pool，对于很大的iterables，设置较大chunksize可以提高性能。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 13:55:00 +0000</pubDate>
<dc:creator>Harvard_Fly</dc:creator>
<og:description>python中ThreadPoolExecutor(线程池)与ProcessPoolExecutor(进程池)都是concurrent.futures模块下的，主线程(或进程)中可以获取某一个线程(进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FG123/p/9704233.html</dc:identifier>
</item>
<item>
<title>nginx实现反向代理、负载均衡-技术流ken - 技术流ken</title>
<link>http://www.cnblogs.com/kenken2018/p/9740406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenken2018/p/9740406.html</guid>
<description>&lt;p&gt;本篇博文是《&lt;a id=&quot;post_title_link_9738901&quot; href=&quot;https://www.cnblogs.com/kenken2018/p/9738901.html&quot;&gt;nginx实现动态/静态文件缓存-技术流ken&lt;/a&gt;》的二部曲。将详细介绍nginx如何实现反向代理以及负载均衡技术，并辅以实战案例。&lt;/p&gt;
&lt;p&gt;反向代理--“反向代理(Reverse Proxy)方式是指以&lt;a href=&quot;https://baike.so.com/doc/5335927-5571366.html&quot; target=&quot;_blank&quot;&gt;代理服务器&lt;/a&gt;来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的&lt;a href=&quot;https://baike.so.com/doc/4889711-5107810.html&quot; target=&quot;_blank&quot;&gt;客户端&lt;/a&gt;，此时代理服务器对外就表现为一个反向代理服务器。”&lt;/p&gt;
&lt;p&gt;负载均衡--“网络专用术语，负载均衡建立在现有网络结构之上，它提供了一种&lt;a href=&quot;https://baike.so.com/doc/6467569.html&quot; target=&quot;_blank&quot;&gt;廉价&lt;/a&gt;有效&lt;a href=&quot;https://baike.so.com/doc/6781847.html&quot; target=&quot;_blank&quot;&gt;透明&lt;/a&gt;的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的&lt;a href=&quot;https://baike.so.com/doc/1281694.html&quot; target=&quot;_blank&quot;&gt;灵活性&lt;/a&gt;和可用性。”&lt;/p&gt;

&lt;h2&gt;1.几个概念&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;反向代理：在收到客户端请求之后，会修目标&lt;/span&gt;IP&lt;span&gt;地址和端口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正向代理：在收到客户端请求之后，会修源&lt;/span&gt;IP&lt;span&gt;地址和端口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上游服务器：代理服务器后端的哪些真正给客户端提供服务的节点，这样的服务器称之为上游服务器&lt;/p&gt;
&lt;p&gt;下游服务器：客户端就是下游节点&lt;/p&gt;
&lt;h2&gt;2.反向代理指令&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;模块：nginx_http_proxy_module
    指令
    proxy_pass：指定上游服务器的ip和端口
    proxy_set_header：指定在重新封装请求报文的时候，添加一个新的首部


    Syntax:     proxy_pass URL;
    Default:     —
    Context:     location, &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; location, limit_except
    例子：proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.220.5.200:80;&lt;/span&gt;
&lt;span&gt;

    Syntax:     proxy_set_header field value;
    Default:     proxy_set_header Host $proxy_host;
    Context:     http, server, location&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.反向代理简单示例&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
location /&lt;span&gt; {
        proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10.220.5.180;&lt;/span&gt;
        proxy_set_header X-Real-&lt;span&gt;IP $remote_addr  
        proxy_set_header Host $proxy_host;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.反向代理实战案例&lt;/h2&gt;
&lt;h3&gt;1.环境准备&lt;/h3&gt;
&lt;p&gt;centos7.5&lt;/p&gt;
&lt;p&gt;反向代理服务器IP：172.20.10.7/28&lt;/p&gt;
&lt;p&gt;web1服务器IP：172.20.10.8/28&lt;/p&gt;
&lt;p&gt;web2服务器IP:172.20.10.9/28&lt;/p&gt;
&lt;h3&gt;2.配置反向代理服务器端&lt;/h3&gt;
&lt;p&gt;yum安装nignx需要配置网络源，复制下面的代码到你的yum仓库中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[ken]
name&lt;/span&gt;=&lt;span&gt;ken
enabled&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgcheck&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
baseurl&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.aliyun.com/epel/7Server/x86_64/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install nginx -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置nginx文件，我们实现这样一个效果，静态文件都被代理到172.20.10.8，动态文件都被调度到172.20.10.9，实现动静分离。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/nginx/&lt;span&gt;nginx.conf
# For more information on configuration, see:
#   &lt;/span&gt;* Official English Documentation: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/en/docs/&lt;/span&gt;
#   * Official Russian Documentation: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/ru/docs/&lt;/span&gt;
&lt;span&gt;
user nginx;
worker_processes auto;
error_log &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/nginx/&lt;span&gt;error.log;
pid &lt;/span&gt;/run/&lt;span&gt;nginx.pid;

# Load &lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt; modules. See /usr/share/nginx/README.&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt;.
include &lt;/span&gt;/usr/share/nginx/modules&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;
       # include /etc/nginx/conf.d/*.conf;

    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /var/www/html;
        index index.html index.php;
        # Load configuration files for the default server block.
   location / {
        proxy_pass &lt;/span&gt;&lt;span&gt;http://172.20.10.8&lt;/span&gt;&lt;span&gt;;
        proxy_set_header host $proxy_host;
        proxy_set_header realip $remote_addr;
        }
        location ~^/.*(\.php)$ {
        proxy_pass &lt;/span&gt;&lt;span&gt;http://172.20.10.9&lt;/span&gt;&lt;span&gt;;
        proxy_set_header host $proxy_host;
        proxy_set_header realip $remote_addr;
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
}
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进行语法检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# nginx -&lt;span&gt;t
nginx: the configuration file &lt;/span&gt;/etc/nginx/nginx.conf syntax &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ok
nginx: configuration file &lt;/span&gt;/etc/nginx/nginx.conf test &lt;span&gt;is&lt;/span&gt; successful
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查没有问题之后进行重启&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl start nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.配置web服务器端&lt;/h2&gt;
&lt;p&gt;安装apache&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# yum install httpd -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;准备测试文件，172.20.10.8准备静态文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is 172.20.10.8 for static test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;/&lt;span&gt;var&lt;/span&gt;/www/html/index.html 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;172.20.10.9需要下载php以便支持动态文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken html]# yum install php -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;172.20.10.9准备动态文件，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# cd /&lt;span&gt;var&lt;/span&gt;/www/html/&lt;span&gt;
[root@ken html]# vim index.php
&lt;/span&gt;&amp;lt;?&lt;span&gt;php
phpinfo();
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.web服务器重启&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken html]# systemctl restart httpd
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.关闭安全服务&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# iptables -F
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.浏览器测试&lt;/h2&gt;
&lt;p&gt;请求静态文件测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201810/1499615-20181003183921585-755015413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;静态文件请求已经成功转发至172.20.10.8。&lt;/p&gt;
&lt;p&gt;测试成功！&lt;/p&gt;
&lt;p&gt;请求动态文件测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201810/1499615-20181003184043666-1960280722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;动态文件请求已经成功转发至172.20.10.9.&lt;/p&gt;
&lt;p&gt;测试成功！&lt;/p&gt;
&lt;h2&gt;7.补充&lt;/h2&gt;
&lt;h3&gt;补充一&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;补充1：
    location如下
        location &lt;/span&gt;/&lt;span&gt;admin {
            proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/; &lt;/span&gt;
            proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com;    &lt;/span&gt;
&lt;span&gt;        }

    请求的url 是http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/admin/a.html&lt;/span&gt;
&lt;span&gt;
    如果代理方式是 proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/; 那么去www.ken.com的跟目录下找a.html,/代表完全代理。&lt;/span&gt;
    如果代理方式是 proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com; 那么去www.ken.com的跟目录下的admin找a.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;补充二&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;补充2：
    如果location中使用了模式匹配（正则），那么，location中的url会直接补充到代理节点的后面.

    此时，上游服务器的的后面不能有任何内容，包括 &lt;/span&gt;/&lt;span&gt;

        location &lt;/span&gt;~&lt;span&gt; \.php$ {
            proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com; [正则表达式proxy_pass转发的地址后面什么都不能加]       &amp;lt;&amp;lt;&amp;lt; 正确写法&lt;/span&gt;
            proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com:80;     &amp;lt;&amp;lt;&amp;lt; 正确写法&lt;/span&gt;
            proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/;       &amp;lt;&amp;lt;&amp;lt; 错误写法&lt;/span&gt;
            proxy_pass http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/img;    &amp;lt;&amp;lt;&amp;lt; 错误写法&lt;/span&gt;
&lt;span&gt;        }

    此时，如果请求的url是 http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.baidu.com/book/stu/a.php ，就会代理成 &lt;/span&gt;&lt;span&gt;http://www.ken.com/book/stu/a.php&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;补充三&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;补充3：
    在location中如果有重定向的话，那么就用重定向后的uri替换掉代理节点中的uri
        location &lt;/span&gt;/&lt;span&gt; {
            rewrite &lt;/span&gt;/(.*)$ /index.php?name=$&lt;span&gt;1&lt;/span&gt; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            proxy_pass http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.baidu.com:80/img;&lt;/span&gt;
&lt;span&gt;        }

    此时，如果请求的url是 http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.ken.com/bajie ，就会代理成 www.baidu.com/index.php?name=bajie&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;1.几个概念&lt;/h2&gt;
&lt;p&gt;调度器：分发用户的请求到一个后端节点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上游服务器&lt;/span&gt;(&lt;span&gt;真实服务器&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;：每个真正用来处理用户请求的节点都是一个上游服务器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CIP&lt;span&gt;：客户端的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;RIP&lt;span&gt;：真实服务器的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;VIP&lt;span&gt;：虚拟&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;，用户所看到的是也是虚拟&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.指令&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;指令：upstream
    作用：定义一个上游服务器组
    格式
        upstream name ｛
            server  上游服务器1  参数 参数;
            server  上游服务器1  参数 参数;
            server  上游服务器1  参数 参数;
        ｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.重要参数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    weight=&lt;span&gt;#：设置服务器的权重（数字越大，权重越高）
    backup: 设置服务器处于备用状态（其他节点出现故障，备用节点才开始工作）
    down：设置让一个节点处于离线状态（经常用在维护一个节点的情况下）
    max_fails&lt;/span&gt;=&lt;span&gt;number：设置连续几次转发失败就认为该节点出现故障，然后就不再向该节点转发用户请求了
    fail_timeout&lt;/span&gt;=time: 和上个参数组合使用，作用是设置等待上游服务器响应超时时间
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.nginx实现负载均衡实战案例&lt;/h2&gt;
&lt;h3&gt;1.环境准备&lt;/h3&gt;
&lt;p&gt;centos7.5&lt;/p&gt;
&lt;p&gt;nginx服务器IP:172.20.10.7/28&lt;/p&gt;
&lt;p&gt;web1服务器端IP：172.20.10.8/28&lt;/p&gt;
&lt;p&gt;web2服务器端IP：172.20.10.9/28&lt;/p&gt;
&lt;h3&gt;2.配置nginx服务器端&lt;/h3&gt;
&lt;p&gt;安装nginx略&lt;/p&gt;
&lt;p&gt;配置nginx文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@ken ~]# vim /etc/nginx/&lt;span&gt;nginx.conf
# For more information on configuration, see:
#   &lt;/span&gt;* Official English Documentation: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/en/docs/&lt;/span&gt;
#   * Official Russian Documentation: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/ru/docs/&lt;/span&gt;
&lt;span&gt;
user nginx;
worker_processes auto;
error_log &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/nginx/&lt;span&gt;error.log;
pid &lt;/span&gt;/run/&lt;span&gt;nginx.pid;

# Load &lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt; modules. See /usr/share/nginx/README.&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt;.
include &lt;/span&gt;/usr/share/nginx/modules&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.conf;

events {
    worker_connections 1024;
}

http {
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
 access_log  /var/log/nginx/access.log  main;

    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;

    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;
       # include /etc/nginx/conf.d/*.conf;
    upstream ken {
        server 172.20.10.8 weight=1 max_fails=3 fail_timeout=5;
        server 172.20.10.9 weight=2 max_fails=3 fail_timeout=5;
    }
    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /var/www/html;
  index index.php index.html;

        # Load configuration files for the default server block.
        # include /etc/nginx/default.d/*.conf;

        location / {
        proxy_pass &lt;/span&gt;&lt;span&gt;http://ken/&lt;/span&gt;&lt;span&gt;;
        proxy_set_header host $proxy_host;
        proxy_set_header realip $remote_addr;
        }

        error_page 404 /404.html;
            location = /40x.html {
        }

        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
}
            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;语法检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ken ~]# nginx -&lt;span&gt;t
nginx: the configuration file &lt;/span&gt;/etc/nginx/nginx.conf syntax &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ok
nginx: configuration file &lt;/span&gt;/etc/nginx/nginx.conf test &lt;span&gt;is&lt;/span&gt; successful
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ken ~]# systemctl restart nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.配置web服务器端&lt;/h3&gt;
&lt;p&gt;略.和上面反向代理配置一样。&lt;/p&gt;
&lt;h3&gt;4.浏览器测试&lt;/h3&gt;
&lt;p&gt;输入nginx服务器端的IP地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201810/1499615-20181003214438610-511728507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为172.20.10.9的权重为2，即出现两次172.20.10.9才会出现一次172.20.10.8.进行刷新测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1499615/201810/1499615-20181003214624313-2055024697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试成功！&lt;/p&gt;
&lt;p&gt;nginx的三大功能，缓存，反向代理，负载均衡，已经全部讲解完毕，是否对nginx有了全新的认识那？马上自己动手实验一下吧&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 13:53:00 +0000</pubDate>
<dc:creator>技术流ken</dc:creator>
<og:description>1.简介 本篇博文是《nginx实现动态/静态文件缓存-技术流ken》的二部曲。将详细介绍nginx如何实现反向代理以及负载均衡技术，并辅以实战案例。 反向代理--“反向代理(Reverse Prox</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenken2018/p/9740406.html</dc:identifier>
</item>
<item>
<title>【持续更新】一个简洁、易用的美赛LaTeX模板:easyMCM - 黑山雁</title>
<link>http://www.cnblogs.com/xjtu-blacksmith/p/9737960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjtu-blacksmith/p/9737960.html</guid>
<description>&lt;blockquote readability=&quot;4.6666666666667&quot;&gt;
&lt;p&gt;若您无意阅读下面的这番引入性介绍，想直接下载模板，请点&lt;a href=&quot;http://www.cnblogs.com/xjtu-blacksmith/p/9737960.html#download&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;当前美赛模板通行情况的概述&quot;&gt;1 当前美赛模板通行情况的概述&lt;/h2&gt;
&lt;p&gt;美赛是许多大学生第一次接触&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;的机会，但是由于时间安排上的原因，很多人都是在赛前几天匆匆拾起&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;编译器决定用其排版论文。花了一下午安装编译器，又花了一晚上琢磨命令行里弹出来的各种莫名其妙的警告和错误……最终，一些队伍把美赛的时间浪费在对付“难用”的&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;系统上，失去了许多宝贵的时间。除此以外，网上流传的各种参差不齐的美赛&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;模板、&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;入门教程，也常常弄得为美赛做准备的初学者们晕头转向，无所适从。&lt;/p&gt;
&lt;p&gt;目前互联网上最通行的美赛&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;模板是&lt;code&gt;mcmthesis&lt;/code&gt;，由&lt;strong&gt;王昭礼&lt;/strong&gt;（&lt;code&gt;343083553@qq.com&lt;/code&gt;）和&lt;strong&gt;黄晨成&lt;/strong&gt;（&lt;code&gt;liamhuang0205+mcmthesis@gmail.com&lt;/code&gt;）先后开发，并上传到&lt;strong&gt;CTAN&lt;/strong&gt;而成为一个标准的宏包/文档类，可直接在&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;中下载使用。这是一个比较专业、精良的模板，结构完整，接口也很完备。作者之一的黄晨成也非常耐心的撰写了一份优质的模板使用指南：&lt;a href=&quot;https://liam0205.me/2016/01/27/how-to-use-mcmthesis/&quot;&gt;如何使用美赛模板 mcmthesis&lt;/a&gt;。但是，该模板对于新手而言还有一定的问题（&lt;em&gt;以下仅仅是我自己的观点，可能有所偏颇&lt;/em&gt;）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该宏包已经有三年以上没有更新；最新的发布版本是&lt;code&gt;v6.2&lt;/code&gt;，时间为2016年1月29号。当然，可以说，这几年来美赛组委会要求的摘要页和正文格式都没有太大的调整，但是从&lt;code&gt;mcmthesis&lt;/code&gt;文档类提供的样例文档就可以看出其中有若干多余的成分——标题、作者名、定理证明、代码附录等。这些部分在目前绝大多数的美赛论文中是不需要——甚至是不应该出现的。由此导致的结果是：初学者接触到的&lt;strong&gt;第一份&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;排出来的美赛论文，并不是&lt;strong&gt;标准格式&lt;/strong&gt;的美赛论文。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mcmthesis&lt;/code&gt;文档类提供了完备的接口（&lt;code&gt;setup&lt;/code&gt;命令）来修改具体的参数，例如在该宏包下的控制序列&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;\mcmsetup{tcn = 12345, problem = B, titlepage = true, abstract = true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就能够将该份论文的队伍控制号设定为&lt;code&gt;12345&lt;/code&gt;、选题设置为&lt;code&gt;B&lt;/code&gt;、标题页单独显示、多显示一次摘要，等等。但是，对于一般的参赛队伍而言，许多接口可能是非必需的，因为似乎目前所有的美赛论文都有着&lt;strong&gt;一致&lt;/strong&gt;的页面设置要求，不太允许个性化的调整。这可能是由于&lt;code&gt;mcmthesis&lt;/code&gt;的作者不太熟悉近几年来的一般美赛论文格式，也有可能是原作者认为应当将宏包的功能设置的更加完备一些。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;就我去年以来接触到的一些参赛队伍来看，许多打算使用&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;撰写论文的队伍实际上还没有弄清楚&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;中的一些基本概念。例如，很多队伍可能就不清楚文档类和宏包有何差异，或者以为&lt;code&gt;\maketitle&lt;/code&gt;命令是所有&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;文档中都必须的（但在诸如&lt;code&gt;mcmthesis&lt;/code&gt;这样的模板中，就并不需要这个系统预定的命令，文档中将自动实现标题的显示）。而对于宏包的设计者而言，这些问题显然不在考虑之列——宏包作者已经明确表明，&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;的学习需要一定时间，因此“&lt;strong&gt;不推荐&lt;/strong&gt;毫无 LaTeX 使用经验的参赛者使用”。事实上，前面所提到的很多问题，不是由于参赛者“毫无经验”造成的，而是由于他们没能接触到比较好的&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;入门教材，因此对于这个工具只是一知半解，遇到问题毫无手段。这个问题，主要是由于国内&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;教材相对“&lt;em&gt;匮乏&lt;/em&gt;”、&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;使用者较少所造成的。这是一个客观存在的问题，短期之内似乎难以解决。美赛的参赛人数还在逐年增加，但似乎无法指望大部分参赛者都能较早的开始学习&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;，并且还能用对教材（以免于片面的理解）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总体而言，我的观点是：由于当前国内的&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;&lt;strong&gt;文化&lt;/strong&gt;仍不深厚，导致许多初学者无法以&lt;strong&gt;正确&lt;/strong&gt;的方式入门&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;，由此导致的结果便是参赛者的&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;平均水准不够，即使是使用&lt;code&gt;mcmthesis&lt;/code&gt;这样相当完备的宏包仍然感到困难、错误频出（且还不论&lt;code&gt;mcmthesis&lt;/code&gt;宏包在功能上的一些冗余）。这不仅是我去年参赛时的亲身体会，也是我浏览网上各种关于&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;美赛模板使用中之问题时的一个总体观感。至于网上流传的其他各种修改自该宏包的模板，或爱好者自制的模板，就更不值得一提了——至少在最近两年，我没有搜到比较合用的其他模板文件。&lt;/p&gt;
&lt;h2 id=&quot;easymcm宏包说明&quot;&gt;2 easymcm宏包说明&lt;/h2&gt;
&lt;h3 id=&quot;与mcmthesis的关系之说明&quot;&gt;2.1 与mcmthesis的关系之说明&lt;/h3&gt;
&lt;p&gt;我本人是去年国庆期间开始学习&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;的。到2018年赛前时，我仍感自己的&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;水准不足，为此开始寻找合适的美赛&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;模板。当时我搜到的是&lt;code&gt;mcmthesis&lt;/code&gt;的&lt;code&gt;v5.0&lt;/code&gt;版本，在&lt;a href=&quot;http://www.latexstudio.net/wp-content/uploads/2017/01/mcmthesis-20170116.zip&quot;&gt;LaTeXStudio&lt;/a&gt;网站上（该网站的维护者就是宏包作者之一的王昭礼）。下载下来后，发现其许多设置不完全符合当年组委会的要求，为此做了大量修改，同时也将模板中的&lt;code&gt;mcmthesis.sty&lt;/code&gt;宏包文件进行了细致的检查和修改。最后，我将这个经过修改的文件随手丢在自己的&lt;a href=&quot;https://www.cnblogs.com/xjtu-blacksmith/p/8310107.html&quot;&gt;博客页面&lt;/a&gt;上，起初也并没有预料到会有许多人下载使用。这就是之前那个所谓&lt;code&gt;5.0y&lt;/code&gt;版本的宏包的来历。&lt;/p&gt;
&lt;p&gt;比赛结束几个月后，我才在互联网上搜到&lt;code&gt;mcmthesis&lt;/code&gt;原来是一个已经持续维护到&lt;code&gt;v6.2&lt;/code&gt;版本的文档类，而我下载到和用于改进的那个&lt;code&gt;v5.0&lt;/code&gt;版本只是2013年的一个比较原始的宏包。因此，我的博客上所给出的模板，事实上是从&lt;code&gt;mcmthesis&lt;/code&gt;的老版本上偶然修改出来的一个比较粗糙的宏包文件。&lt;/p&gt;
&lt;h3 id=&quot;easymcm宏包的简介&quot;&gt;2.2 easymcm宏包的简介&lt;/h3&gt;
&lt;p&gt;2019年美赛又即将到来。本人作为一个曾经的美赛参赛者，希望自己博客上所发布的美赛模板能够继续帮助到新一年（乃至以后）的参赛者；为此，重新检查了&lt;code&gt;v5.0y&lt;/code&gt;版本的宏包文件，加以完善和改进，并最终制成了一个新的宏包文件&lt;code&gt;easymcm.sty&lt;/code&gt;（不是文档类）。该宏包相对于前面所介绍的&lt;code&gt;mcmthesis&lt;/code&gt;有以下的独特之处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;easymcm&lt;/code&gt;是由&lt;code&gt;mcmthesis&lt;/code&gt;的老版本直接改进过来的，没有做标准化的处理，总体比较简单——因此，其没有太多的接口，基本功能都已具备，不需要用户做个性化的调整。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;easymcm&lt;/code&gt;经改进后同时支持&lt;code&gt;pdflatex&lt;/code&gt;和&lt;code&gt;xelatex&lt;/code&gt;等多种编译方式。考虑到目前许多参赛队伍仍然习惯于使用&lt;span class=&quot;math inline&quot;&gt;\(\mathbb{C}\TeX\)&lt;/span&gt;套装下的&lt;code&gt;pdfTexify&lt;/code&gt;模式（本质就是&lt;code&gt;pdflatex&lt;/code&gt;）进行编译，这一改进是有一定意义的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;easymcm.sty&lt;/code&gt;文件中有完备详细的中文注释。对于&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;宏包的设计而言，这一做法是不必要的（甚至可能是愚蠢的，因为这显得不专业），但我认为美赛恰是许多大学生学习&lt;span class=&quot;math inline&quot;&gt;\(\LaTeX\)&lt;/span&gt;的最佳机会——因此，这一安排使得初学者自己&lt;strong&gt;查看&lt;/strong&gt;和&lt;strong&gt;修改&lt;/strong&gt;宏包内的若干参数成为可能。&lt;/li&gt;
&lt;li&gt;由于作者我本人参加了2018年的美赛，因此可以保证&lt;code&gt;easymcm&lt;/code&gt;宏包提供的页面设计是符合近几年来美赛组委会的规范要求的。同时，我也会持续关注之后几年美赛的情况，及时的改进页面设计以符合组委会的规范。&lt;/li&gt;
&lt;li&gt;宏包文件的结构非常简单，实现的功能也并不繁复，因此容错率较高（&lt;em&gt;经得起各位初学者以乱七八糟的命令来折腾&lt;/em&gt;）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本人制作和改进&lt;code&gt;easymcm&lt;/code&gt;这个美赛模板文件，并无任何功利企图，纯粹是为了分享给需要的人。我的想法仅仅是：目前中文互联网上的相关内容仍显缺乏，倘我的这一点点工作能够起到一定帮助，则其意义便已达成。（&lt;code&gt;mcmthesis&lt;/code&gt;作者之一黄晨成在博客中提到将宏包分享出来提供了一定的成就感，而对于我这个业余的学生而言甚至连这一点也提不上了。我仅认为是举手之劳。）同时，鉴于本模板文件的性质比较特殊（&lt;em&gt;偶然的二次开发&lt;/em&gt;），因此我将和原来一样，仅将这个模板文件扔在网上，供大家自行取用（而没有更多打算）。仅此。&lt;/p&gt;

&lt;h3 id=&quot;美赛模板下载地址&quot;&gt;2.3 美赛模板下载地址&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：发布版中附带有一篇&lt;strong&gt;样例论文&lt;/strong&gt;，是我们队赛前做的2017年MCM的A题论文，排版样式、代码结构仅供参考和学习。（&lt;em&gt;论文内容就别在意了……&lt;/em&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最新版本：&lt;code&gt;v5.01&lt;/code&gt;（2018.10.3发布）&lt;/p&gt;
&lt;p&gt;作者将持续关注比赛动态，若出现问题将及时更新。也欢迎各位读者直接联系我反映问题！&lt;/p&gt;
&lt;h2 id=&quot;常见问题-qa&quot;&gt;3 常见问题 Q&amp;amp;A&lt;/h2&gt;
&lt;p&gt;原则上我似乎应该把这些内容集成为一个说明文档，但是由于时间和精力有限，所以暂时无法做到。希望在有余力时可以把这件事情做好。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Q1: 如何将页眉顶部的MCM改成ICM？或者，如何修改\删除顶部的那两句话？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Answer: 这两部分内容在&lt;code&gt;easymcm&lt;/code&gt;宏包中分别有两个&lt;strong&gt;简易接口&lt;/strong&gt;来修改：&lt;code&gt;\content&lt;/code&gt;和&lt;code&gt;\notes&lt;/code&gt;。若要将MCM的题头改为ICM的题头，请在主代码文件&lt;code&gt;PAPER.tex&lt;/code&gt;中的导言区（具体是&lt;code&gt;\begin{document}&lt;/code&gt;命令之前）加入以下命令：&lt;/p&gt;
&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;\renewcommand{\contest}{Interdisciplinary Contest in Modeling (ICM) Summary Sheet}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就能够将上面的MCM题头改为ICM的题头。类似地，如果需要将其改为其他类似的内容，替换上面的参数即可。下方的括号说明则可由&lt;code&gt;\notes&lt;/code&gt;参数修改，例如在导言区加入命令&lt;/p&gt;
&lt;pre class=&quot;latex&quot;&gt;
&lt;code&gt;\renewcommand{\notes}{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就能够将summary sheet顶部的说明&lt;em&gt;(Attach a copy of this page to each copy of your solution paper.)&lt;/em&gt;去掉。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Q2: 如何缩小summary sheet顶部的空白？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Answer: 原来我是建议使用者去把宏包里面的间距参数修改一下。现在，我的建议是：&lt;strong&gt;没必要改，用宏包就不要关注这种细枝末节，内容比格式更重要。&lt;/strong&gt;Summary sheet上的字体大小和行距我都已经设置的很小了，如果还嫌顶部空大，估计是摘要写太多了。自己再删减一下。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Q3: 我在&lt;code&gt;PAPER.tex&lt;/code&gt;文件中应用了&lt;code&gt;geometry&lt;/code&gt;宏包修改页边距，结果页面上的布局出现了混乱。这是怎么一会事？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Answer: 因为&lt;code&gt;easymcm&lt;/code&gt;宏包中已经应用&lt;code&gt;geometry&lt;/code&gt;宏包设置过页边距了，再用一次当然会出错。一般情况下，这个参数没有必要再改了，这对论文的评审&lt;strong&gt;没有任何影响&lt;/strong&gt;；实在需要修改，请到&lt;code&gt;easymcm.sty&lt;/code&gt;宏包文件中修改（&lt;em&gt;不推荐&lt;/em&gt;）。其他宏包类似，我个人认为&lt;code&gt;easymcm&lt;/code&gt;中已经集成了绝大多数的基础常用宏包，请使用者不要在源码中再增加宏包了。&lt;/p&gt;
&lt;p&gt;其他问题将陆续更新。最后，祝各位美赛大捷，保M冲O~&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 13:44:00 +0000</pubDate>
<dc:creator>黑山雁</dc:creator>
<og:description>若您无意阅读下面的这番引入性介绍，想直接下载模板，请点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjtu-blacksmith/p/9737960.html</dc:identifier>
</item>
<item>
<title>Java网络编程-URI和URL - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9740425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9740425.html</guid>
<description>&lt;p&gt;前面的一篇文章《Java中的Internet查询》分析完了如何通过IP地址或者主机名确定主机在因特网中的地址。任意给定主机上可能会有任意多个资源，这些资源需要有标识符方便主机之间访问对方的资源，因此这篇文章深入分析一下URL和URI。&lt;/p&gt;

&lt;p&gt;URI全称是Uniform Resource Identifier，也就是统一资源标识符，它是一种采用特定的语法标识一个资源的字符串表示。URI所标识的资源可能是服务器上的一个文件，也可能是一个邮件地址、图书、主机名等。简单记为：URI是标识一个资源的字符串(这里先不必纠结标识的目标资源到底是什么，因为使用者一般不会见到资源的实体)，从服务器接收到的只是资源的一种字节表示(二进制序列，从网络流中读取)。URI的语法构成是：一个模式和一个模式特定部分。表示形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;模式:模式特定部分

scheme:scheme specific part &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：模式特定部分的表示形式取决于所使用的模式&lt;/strong&gt;。URI当前的常用模式包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;data：链接中直接包含经过BASE64编码的数据。&lt;/li&gt;
&lt;li&gt;file：本地磁盘上的文件。&lt;/li&gt;
&lt;li&gt;ftp：FTP服务器。&lt;/li&gt;
&lt;li&gt;http：使用超文本传输协议。&lt;/li&gt;
&lt;li&gt;mailto：电子邮件的地址。&lt;/li&gt;
&lt;li&gt;magnet：可以通过对等网络(端对端P2P，如BitTorrent)下载的资源。&lt;/li&gt;
&lt;li&gt;telnet：基于Telnet的服务的连接。&lt;/li&gt;
&lt;li&gt;urn：统一资源名(Uniform Resource Name)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除此之外，Java中还大量使用了一些非标准的定制模式，如rmi、jar、jndi、doc、jdbc等，这些非标准的模式分别用于实现各种不同的用途。&lt;/p&gt;
&lt;p&gt;URI中的模式特定部分没有固定的语法，不过，很多时候都是采用一种层次结构形式，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//授权机构/路径?查询参数

//authority/path?query&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;URI的authority部分指定了负责解析该URI其他部分的授权机构(authority)，很多时候，URI都是使用Internet主机作为授权机构。例如http://www.baidu.com/s?ie=utf-8，授权机构是www.baidu.com(在URL角度来看，主机名是www.baidu.com)。&lt;/p&gt;
&lt;p&gt;URI的路径(path)是授权机构用来确定所标识资源的字符串。不同的授权机构可能会把相同的路径解析后指向不同的资源。其实这一点很明显，试下你写两个不同的项目，主页的路径都是/index.html，它们一定是完全相同的html文档。另外，路径是可以分层的，分层的各个部分使用斜线&quot;/&quot;进行分隔，而&quot;.&quot;和&quot;..&quot;操作符用于在分层层次结构中的导航(后面这两个操作符可能很少见到，了解即可)。&lt;/p&gt;
&lt;h2 id=&quot;uri的语法&quot;&gt;URI的语法&lt;/h2&gt;
&lt;p&gt;URI的模式的组成部分可以是小写字母、数字、加号、点(.)和连号(-)。典型的URI的其他三个部分(模式特定部分，也就是授权机构、路径和查询参数)分别由ASCII字母组成(也就是字母A-Z、a-z和数字0-9)，此外，还可以使用标点符号&lt;code&gt;-、_、.、!和~&lt;/code&gt;，而定界符(如/、?、&amp;amp;和=)有其预定义的用途。所有的其他字符，包括ASCII中拉丁字母，都需要使用百分号(%)转义，转义后的格式是：%+字符按照UTF-8编码再转成16进制的字符串表示。注意一点，如果前面提到的定界符没有作为定界符使用，也需要进行转义。举个简单的例子，如URI中存在中文字符&quot;木&quot;，木字的UTF-8编码为0xE6 0x9C 0xA8，那么它在URI中应该转义为%E6%9C%A8。Jdk中的URLEncoder或者apache-codec中的相关类库提供URI(URL)编码的功能。&lt;/p&gt;
&lt;p&gt;URI中还可以携带用户的口令，因为会有安全漏洞，所以并不常见，这里也不展开分析。&lt;/p&gt;
&lt;h2 id=&quot;uri类&quot;&gt;URI类&lt;/h2&gt;
&lt;p&gt;URI在Java中抽象为java.net.URI类。&lt;/p&gt;
&lt;h3 id=&quot;构造uri实例&quot;&gt;构造URI实例&lt;/h3&gt;
&lt;p&gt;URI实例构造方法有很多个：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public URI(String str) throws URISyntaxException

public URI(String scheme,String userInfo, String host, int port,
        String path, String query, String fragment) throws URISyntaxException

public URI(String scheme, String authority,
       String path, String query, String fragment)throws URISyntaxException

public URI(String scheme, String host, String path, String fragment) throws URISyntaxException

public URI(String scheme, String ssp, String fragment) throws URISyntaxException

//静态工厂方法，最终调用的是URI(String str)
public static URI create(String str)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意的是构造URI实例的时候会检查是否符合URI的语法，否则会抛出URISyntaxException异常。以上的所有方法都是基于URI的模式+模式特定部分或者URI的各个部分构造URI实例，而静态工厂方法&lt;code&gt;public static URI create(String str)&lt;/code&gt;主要是屏蔽了非检查型异常URISyntaxException，转化为检查型异常IllegalArgumentException，这样就不需要显式捕获异常。&lt;/p&gt;
&lt;h3 id=&quot;获取uri的属性&quot;&gt;获取URI的属性&lt;/h3&gt;
&lt;p&gt;前面也提到，URI引用包括最多三个部分：模式、模式特定部分和片段标识符，一般格式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;模式:模式特定片段:片段标识符&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于这种语法规范，URI类提供了下面几个方法获取这些属性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String getScheme()

public String getRawSchemeSpecificPart()

public String getSchemeSpecificPart()

public String getFragment()

public String getRawFragment()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：之所以没有&lt;code&gt;getRawScheme()&lt;/code&gt;方法，是因为URI规范中强制规定，所有的模式名称必须由URI规范中合法的ASCII字符组成，也就是模式名称中不允许存在百分号转义。上面的&lt;code&gt;getRawSchemeSpecificPart()&lt;/code&gt;是返回原始的模式特定部分，&lt;code&gt;getSchemeSpecificPart()&lt;/code&gt;返回了经过解码(decode)的模式特定部分。同理，&lt;code&gt;getRawFragment()&lt;/code&gt;返回原始的片段标识符，而&lt;code&gt;getFragment()&lt;/code&gt;返回经过解码(decode)的片段标识符。当然，还有其他方法获取URI的基础属性：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//是否绝对URI
public boolean isAbsolute()

//是否不透明的URI，如果isOpaque()返回true，URI是不透明的
//只能获取到模式、模式特定部分和片段标识符，获取不了host、port等
public boolean isOpaque()

public String getAuthority()

public String getRawAuthority()

public String getRawUserInfo()

public String getUserInfo()

public String getHost()

public int getPort()

public String getRawPath()

public String getPath()

public String getRawQuery()

public String getQuery()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：&lt;code&gt;isOpaque()&lt;/code&gt;方法为true的时候，说明URI是不透明的，不透明的URI无法获取授权机构、路径、端口和查询参数等。另外，上面的获取属性的方法有些方法存在&lt;code&gt;getRawFoo()&lt;/code&gt;的对应方法，这些&lt;code&gt;getRawFoo()&lt;/code&gt;方法就是获取原始属性的值，如果没有&lt;code&gt;Raw&lt;/code&gt;关键字，则返回解码后的字符串值。&lt;/p&gt;
&lt;h3 id=&quot;解析相对uri&quot;&gt;解析相对URI&lt;/h3&gt;
&lt;p&gt;URI中提供了三个方法用于绝对URI和相对URI之间的转换：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public URI resolve(URI uri)

public URI resolve(String str)

public URI relativize(URI uri)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;resolve&lt;/code&gt;方法是基于绝对URI和相对URI把相对URI补全为绝对URI，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception{
    URI absolute = URI.create(&quot;http://localhost:8080/index.html&quot;);
    URI relative = URI.create(&quot;/hello.html&quot;);
    URI resolve = absolute.resolve(relative);
    System.out.println(resolve);
}
//控制台输出
http://localhost:8080/hello.html&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;relativize&lt;/code&gt;方法是基于绝对URI和相对URI反解出绝对URI中的相对URI部分，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception{
    URI absolute = URI.create(&quot;http://localhost:8080/index.html&quot;);
    URI relative = URI.create(&quot;http://localhost:8080/&quot;);
    URI resolve = relative.relativize(absolute);
    System.out.println(resolve);
}

//控制台输出
index.html&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;uri的比较&quot;&gt;URI的比较&lt;/h3&gt;
&lt;p&gt;URI类实现了Comparable接口，因此URI可以排序。URI的相等性不是基于字符串直接比较，相等的URI在透明性上必须是一致的，例如都是不透明的，其他部分才可以进行比较。URI比较的时候，模式和授权机构是忽略大小写的，其他部分必须区分大小写，用于转义无效字符串的十六进制数字除外。需要转义的字符在转义前和转义之后进行比较，会认为是不同的URI。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//1.
URI uri1 = URI.create(&quot;http://localhost:8000/index.html&quot;);
URI uri2 = URI.create(&quot;http://LOCALHOST:8000/index.html&quot;);
System.out.println(uri1.equals(uri2));
//输出:true

//2.
URI uri3 = URI.create(&quot;http://localhost:8000/index/A&quot;);
URI uri4 = URI.create(&quot;http://LOCALHOST:8000/index/%41&quot;);
System.out.println(uri3.equals(uri4));
//输出:false&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;uri的字符串表示&quot;&gt;URI的字符串表示&lt;/h3&gt;
&lt;p&gt;URI中有两个方法返回其字符串表示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String toString()

public String toASCIIString()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;toString()&lt;/code&gt;方法返回未编码的字符串形式，也就是特殊的字符不使用百分号转义，因此这个方法的返回值不能保证符合URI的语法，尽管它的各个部分是遵循URI的语法规范的。&lt;code&gt;toASCIIString()&lt;/code&gt;方法返回经过编码的字符串形式(US-ACSII编码)，也就是特殊的字符一定经过了百分号转义。&lt;code&gt;toString()&lt;/code&gt;存在的意义是提高URI的可读性，&lt;code&gt;toASCIIString()&lt;/code&gt;方法存在的意义是提高URI的可用性。&lt;/p&gt;

&lt;p&gt;URL全称是Uniform Resource Location，也就是统一资源位置。实际上，URL就是一种特殊的URI，它除了标识一个资源，还会为资源提供一个特定的网络位置，客户端可以通过它来获取URL对应的资源。&lt;/p&gt;
&lt;p&gt;URL所表示的网络资源位置通常包括用于访问服务器的协议(如http、ftp等)、服务器的主机名或者IP地址、以及资源文件在该服务器上的路径。典型的URL例如http://localhost/myProject/index.html，它指示本地服务器的myProject目录下有一个名为index.html的文档，这个文档可以通过http协议访问(实际上，URL不一定是指服务器中的真实的物理路径，因为我们一般在服务器中部署应用，如Servlet应用，URL访问的很可能是应用的接口，至于最终映射到什么资源可以由应用自身决定)。&lt;/p&gt;
&lt;h2 id=&quot;url的语法&quot;&gt;URL的语法&lt;/h2&gt;
&lt;p&gt;URL的语法表示形式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protocol://userInfo@host:port/path?query#fragment

协议://用户信息@主机名:端口/路径?查询#片段&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;protocol&lt;/strong&gt;：URL中的协议(protocol)是相应于URI中的模式(schema)的另一个叫法。URL中，协议部分可以是file、ftp、http、https、magnet、telnet或者其他定制协议字符串(但是不包括urn)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;userInfo&lt;/strong&gt;：URL中的用户信息(userInfo)是服务器的登录信息，这部分信息是可选的。如果这部分信息存在，一般会包含一个用户名，极少情况下会包含一个口令。实际上URL携带用户信息是不安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;port&lt;/strong&gt;：URL中的端口号(port)是指服务器中应用的运行端口，默认端口为80，此部分信息是可选的(也就如果不指定端口号就使用默认端口80)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;path&lt;/strong&gt;：URL中的路径(path)用于表示服务器上的一个特定的目录(其实说一个特定的文件也可以)，这个特定的目录不一定是物理目录，也有可能是逻辑目录。这一点很容易说明，一般不可能把服务器上面的目录直接公开让所有人访问，服务器上面跑的一般是Web(Java的话一般是Servlet)应用，路径指向的实际数据来源甚至很大可能是在其他服务器上的MySQL中的查询结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;query&lt;/strong&gt;：查询参数(query)一般是一个字符串，它表示URL中向服务器提供的附加参数，一般只使用在http协议的URL中，其中包含了表单数据，来源于用户的输入，表示形式是key1=value1&amp;amp;key2=value2&amp;amp;keyn=valuen。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fragment&lt;/strong&gt;：片段(fragment)表示远程服务器资源的某个特定的部分。假如服务器资源是一个HTML文档，此片段标识符将制定为该HTML文档的一个锚(Anchor)。如果远程资源是一个XML文档，那么这个片段标识符是一个XPointer。(如果用Markdown写过博客就知道，添加了导航目录之后，片段就是目录将要导航到的目的章节)&lt;/p&gt;
&lt;h2 id=&quot;相对url&quot;&gt;相对URL&lt;/h2&gt;
&lt;p&gt;URL可以告知浏览器一个文档(Document，假设URL对应服务器上的资源统一叫做文档)的大量信息：获取文档所使用的协议、文档所在的主机、文档在该主机中的路径等。文档中可能也存在引用和当前URL相同的URL，因此，在该文档中使用URL的时候并不要求完整地指定每一个URL，URL可以继承其父文档的协议、主机名和路径。继承了父文档URL的部分信息的这类不完整的URL称为相对URL(Reletive URL)，相反，完整指定所有部分的URL称为绝对URL(Absolute URL)。在相对URL中，缺少的各个部分与请求该文档的URL对应的部分相同。举个例子，我们访问本地服务器的一个HTML文档，URL为http://localhost:8080/myProject/index.html，index.html文档中存在一个超链接&lt;code&gt;&amp;lt;a href=&quot;login.html&quot;&amp;gt;&lt;/code&gt;，当我们点击此超链接的时候，浏览器会从原始URL(http://localhost:8080/myProject/index.html)中截去index.html然后拼接login.html，最后访问http://localhost:8080/myProject/login.html。&lt;/p&gt;
&lt;p&gt;如果相对URL以&quot;/&quot;开头，那么它是相对于文档的根目录，而不是当前的文档。举个例子，我们访问本地服务器的一个HTML文档，URL为http://localhost:8080/myProject/index.html，index.html文档中存在一个超链接&lt;code&gt;&amp;lt;a href=&quot;/login.html&quot;&amp;gt;&lt;/code&gt;，当我们点击此超链接的时候，浏览器会跳转到http://localhost:8080/login.html。&lt;/p&gt;
&lt;p&gt;相对URL有两个显著的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、减少文档编写量，毕竟可以省略一部分URL内容，不过这个不是重要的优点。&lt;/li&gt;
&lt;li&gt;2、重要的优点是：相对URL允许使用多协议来提供一个文档树，例如http和ftp，使用相对URL编写的文档可以从一个网站直接复制或者迁移到另一个网站而不会破坏文档内部URL链接。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;url类&quot;&gt;URL类&lt;/h2&gt;
&lt;p&gt;java.net.URL类(后面直接叫URL)是JDK对URL的统一抽象，它是一个final修饰的类，也就是不允许派生子类。实际上，URL设计的时候采用了策略模式，不同的协议的处理器就是不同的策略，而URL类构成了上下文，通过它决定选用何种策略。URL的核心属性包括协议(或者叫模式)、主机名、端口、查询参数字符串和片段标识符(在JDK中被命名为ref)等，每个属性都可以单独设置。一旦一个URL对象被构造之后，它的所有属性都不能改变，也就是它的实例是线程安全的。&lt;/p&gt;
&lt;h3 id=&quot;构造url实例&quot;&gt;构造URL实例&lt;/h3&gt;
&lt;p&gt;URL实例的主要构造方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//基于URL的各个部分构造URL实例，其中file相当于path、query和fragment三个部分组成
public URL(String protocol, String host, int port, String file) throws MalformedURLException

//基于URL的各个部分构造URL实例，其中file相当于path、query和fragment三个部分组成，使用默认端口80
public URL(String protocol, String host, String file) throws MalformedURLException

//基于URL模式构造URL实例
public URL(String spec) throws MalformedURLException

//基于上下文(父)URL和URL模式构造相对URL实例
public URL(URL context, String spec) throws MalformedURLException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面基于上面几个构造URL实例的方法举几个简单的编码例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//1.
//注意file要带斜杆前缀/
URL url = new URL(&quot;http&quot;, &quot;127.0.0.1&quot;, 8080, &quot;/index&quot;);
//输出http://127.0.0.1:8080/index
System.out.println(url.toString());

//2.
URL url = new URL(&quot;http://127.0.0.1:8080/index&quot;);
//输出http://127.0.0.1:8080/index
System.out.println(url.toString());

//3.
URL url = new URL(&quot;http&quot;, &quot;127.0.0.1&quot;, &quot;/index&quot;);
//输出http://127.0.0.1/index
System.out.println(url.toString());

//4.
URL context = new URL(&quot;http&quot;, &quot;127.0.0.1&quot;, &quot;/index&quot;);
//构造相对URL，保留协议、host、port部分
URL url = new URL(context, &quot;/login&quot;);
//输出http://127.0.0.1/login
System.out.println(url);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面只说到通过URL类去构造对象，其实还有其他方法获取URL实例，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;URL systemResource = ClassLoader.getSystemResource(String name)

Enumeration&amp;lt;URL&amp;gt; systemResources = ClassLoader.getSystemResources(String name)

URL resource = UrlMain.class.getResource(String name)

URL resource = UrlMain.class.getClassLoader().getResource(String name)

Enumeration&amp;lt;URL&amp;gt; resources = UrlMain.class.getClassLoader().getResources(String name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;ClassLoader.getSystemResource(String name)&lt;/code&gt;和&lt;code&gt;ClassLoader.getSystemResources(String name)&lt;/code&gt;都是先判断是否存在SystemClassLoader，若存在则使用SystemClassLoader加载资源，否则使用BootstrapClassLoader(BootstrapClassPath)进行资源加载，简单来说，这两个方法就是使用系统类加载器加载资源，加载资源时候，从类路径中加载资源，例如使用IDEA，则从编译后的/target目录中加载资源，这一点可以使用&lt;code&gt;ClassLoader.getSystemResource(&quot;&quot;)&lt;/code&gt;进行验证。其他三个方法&lt;code&gt;Class#getResource(String name)&lt;/code&gt;、&lt;code&gt;Class#getClassLoader()#getResource(String name)&lt;/code&gt;和&lt;code&gt;Class#getClassLoader()#getResources(String name)&lt;/code&gt;本质上都是基于AppClassLoader进行资源加载，它们加载资源的时候是从当前的Class所在的类路径(包括类的包路径，如果使用IDEA一般也是/target/类所在的包目录)进行加载，例如有一个类&lt;code&gt;club.throwable.Main.class&lt;/code&gt;，如果目录club.throwable存在一张图片doge.jpg，则加载图片的时候可以这样子&lt;code&gt;club.throwable.Main.class.getResource(&quot;doge.jpg&quot;)&lt;/code&gt;。值得注意的一点是，如果需要加载的资源是在一个特定目录中，那么&lt;code&gt;Class#getResource(String name)&lt;/code&gt;中的name必须以文件路径分隔符开头，例如Window系统中用'/'，其他两个基于通过ClassLoader实例直接加载的不需要使用文件路径分隔符开头，这一点可以看&lt;code&gt;Class#getResource(String name)&lt;/code&gt;方法中的&lt;code&gt;resolveName(name)&lt;/code&gt;方法。&lt;/p&gt;
&lt;h3 id=&quot;获取url的属性&quot;&gt;获取URL的属性&lt;/h3&gt;
&lt;p&gt;URL实例提供几个方法用于获取数据：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final InputStream openStream() throws java.io.IOException

public URLConnection openConnection() throws java.io.IOException

public URLConnection openConnection(Proxy proxy) throws java.io.IOException

public final Object getContent() throws java.io.IOException

public final Object getContent(Class[] classes) throws java.io.IOException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;InputStream openStream()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;openStream()&lt;/code&gt;方法连接到URL所引用的资源，在客户端和服务器之间完成必要的握手之后，返回一个InputStream实例，用于读取网络流数据。此方法返回的InputStream实例读取到的内容是Http请求体的原始报文(如果使用Http协议的话)，因此有可能是一个原始文本片段或者是一个二进制的序列(例如图片)。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) throws Exception{
        URL url = new URL(&quot;https://www.baidu.com&quot;);
        InputStream inputStream = url.openStream();
        int c;
        while ((c= inputStream.read()) != -1){
            System.out.print(c);
        }
        inputStream.close();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;URLConnection openConnection()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;openConnection()&lt;/code&gt;和&lt;code&gt;openConnection(Proxy proxy)&lt;/code&gt;是相似的，只是后者可以使用代理。&lt;code&gt;openConnection()&lt;/code&gt;方法为指定的URL新建一个socket，并且返回一个URLConnection实例，它表示一个网络资源打开的连接，我们可以从这个打开的连接获取一个InputStream实例，用于读取网络流数据。如果上面的过程出现调用失败，会抛出一个IOException。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Object getContent()&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;Object getContent()&lt;/code&gt;和&lt;code&gt;Object getContent(Class[] classes)&lt;/code&gt;是相似的，后者可以通过Class数组指定获取到的URL中的请求体内容转化为对应的类型的实体。&lt;code&gt;Object getContent()&lt;/code&gt;实际上是调用了URLConnection实例中的getContent方法，一般来说，不建议使用这两个方法，因为转换的逻辑执行后的结果一般是不合符我们预想的结果。&lt;/p&gt;
&lt;h3 id=&quot;获取url属性&quot;&gt;获取URL属性&lt;/h3&gt;
&lt;p&gt;URL的属性获取可以理解为分解URL成URL组成的各个部分，这些部分的信息可以单独获取。前面提到过URL的各个组成部分，这里重复一下，URL分别由下面的几个部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模式(schema)，也称协议(protocol)。&lt;/li&gt;
&lt;li&gt;用户信息(UserInfo)，这个并不常用。&lt;/li&gt;
&lt;li&gt;授权机构，一般是&quot;主机名(Host):port&quot;的格式。&lt;/li&gt;
&lt;li&gt;路径。&lt;/li&gt;
&lt;li&gt;片段标识符，在Java中称为段或者ref。&lt;/li&gt;
&lt;li&gt;查询字符串。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;URL类中提供对应的方法分别是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
//获取模式(协议)
public String getProtocol()

//获取主机名
public String getHost()

//获取授权机构,一般是host:port的形式
public String getAuthority()

//获取端口号port
public int getPort()

//返回协议的默认端口，如http协议的默认端口号为80，如果没有指定协议的默认端口则返回-1
public int getDefaultPort()

//返回URL字符串中从主机名后的第一个斜杆/一直到片段标识符的#字符之前的所有字符
public String getFile()

//返回的值和getFile()相似，但是不包含查询字符串
public String getPath()

//返回URL的片段标识符部分
public String getRef()

//返回URL的查询字符串
public String getQuery()

//返回URL中的用户信息,不常用
public String getUserInfo()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中需要注意的是&lt;code&gt;getFile()&lt;/code&gt;和&lt;code&gt;getPath()&lt;/code&gt;，举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;URL url = new URL(&quot;https://localhost:8080/search?name=doge#anchor-1&quot;);
System.out.println(String.format(&quot;path=%s&quot;, url.getPath()));
System.out.println(String.format(&quot;file=%s&quot;, url.getFile()));
//控制台输出
path=/search
file=/search?name=doge&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;比较&quot;&gt;比较&lt;/h3&gt;
&lt;p&gt;URL实例的比较通常是使用&lt;code&gt;equals()&lt;/code&gt;和&lt;code&gt;hashCode()&lt;/code&gt;方法，当且仅当两个URL指向相同的主机、端口和路径上的资源，并且两者的片段标识符和查询字符串都相同的时候，才会认为两个URL是相等的。&lt;code&gt;equals()&lt;/code&gt;调用的时候会尝试使用DNS解析主机，此方法有可能是一个阻塞的IO操作，会造成比较大的性能消耗，这个时候需要考虑使用缓存，或者把URL转化为URI进行比较。&lt;/p&gt;
&lt;h3 id=&quot;转换&quot;&gt;转换&lt;/h3&gt;
&lt;p&gt;URL类中有三个常用的实例方法用于转换为另一种形式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String toString()

public String toExternalForm()

public URI toURI()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，&lt;code&gt;toString()&lt;/code&gt;最终调用的是&lt;code&gt;toExternalForm()&lt;/code&gt;，而&lt;code&gt;toExternalForm()&lt;/code&gt;方法是使用StringBuilder把URL的各个组成部分拼接，返回的字符串可以方便直接使用在浏览器中。&lt;code&gt;toURI()&lt;/code&gt;方法就是把URL实例转化为URI实例。&lt;/p&gt;

&lt;p&gt;我们在做Web项目或者使用POSTMAN的时候经常会看到x-www-form-urlencoded，它是常用的媒体类型或者说内容类型(ContentType)，使用这种类型的时候，URL中的字符需要进行编码，那么为什么需要进行编码呢?这个是历史遗留原因，因为发明Web或者说Http(s)协议的时候，Unicode编码并未完全普及，URL中使用的字符必须来自ASCII的一个固定子集，这个固定子集是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;大写字母A-Z。&lt;/li&gt;
&lt;li&gt;小写字母a-z。&lt;/li&gt;
&lt;li&gt;数字0-9。&lt;/li&gt;
&lt;li&gt;标点符号字符&lt;code&gt;-_.!~*'(和,)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他字符如：&lt;code&gt;/&amp;amp;?@#;$+=%&lt;/code&gt;也可以使用，但是它们限定于使用在特定的用途，如果这些字符串出现在URL路径或者查询字符串，它们以及路径和查询字符串的内容必须进行编码。&lt;/p&gt;
&lt;p&gt;这里有个需要注意的地方：URL编码只针对URL路径和URL路径之后的部分，因为URL规范中规定，路径之前的部分必须满足ASCII固定子集的内容。&lt;/p&gt;
&lt;p&gt;URL编码的方法很简单：除了ASCII数字、字母和部分指定的标点符号之外，所有的其他字符都要转化为字节表示，每个字节要转化为百分号(%)后面加2位十六进制数字。空格是一种特殊的字符，它使用得比较普遍，一般空格可以编码为%20或者加号(+)，但是加号本身的编码为%2B。而&lt;code&gt;/#=&amp;amp;和?&lt;/code&gt;不作为分隔符的时候，必须进行编码。&lt;/p&gt;
&lt;p&gt;解码过程就是上面编码过程的逆向操作，这里不具体展开。&lt;/p&gt;
&lt;p&gt;Java中提供两个类java.net.URLEncoder和java.net.URLDecoder分别用于URL的编码和解码，注意需要使用两个参数的静态方法&lt;code&gt;encode(String value,String charset)&lt;/code&gt;和&lt;code&gt;decode(String value,String charset)&lt;/code&gt;，单参数的方法已经过期，不建议使用。注意在使用java.net.URLEncoder和java.net.URLDecoder的时候，它们的API不会判断URL的什么部分需要编码和解码，什么部分不需要编码和解码，直接整个URL字符串丢进去编码一定会出现意料之外的结果。举个反面列子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String url = &quot;http://localhost:9090/index?name=张大doge&quot;;
String encode = URLEncoder.encode(url, &quot;UTF-8&quot;);
System.out.println(encode);
//输出:http%3A%2F%2Flocalhost%3A9090%2Findex%3Fname%3D%E5%BC%A0%E5%A4%A7doge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，我们只需要对Path和Path之后的字符进行编码和解码，例如对于URL&lt;code&gt;http://localhost:9090/index?name=张大doge&lt;/code&gt;，我们需要编码和解码的部分只有index、name和张大doge这三个部分，其他部分应该保持原样。正确的例子如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws Exception {
    String raw= &quot;http://localhost:9090/index?name=张大doge&quot;;
    String base = raw.substring(raw.lastIndexOf(&quot;//&quot;));
    String pathLeft = base.substring(base.lastIndexOf(&quot;/&quot;) + 1);
    String[] array = pathLeft.split(&quot;\\?&quot;);
    String path = array[0];
    String query = array[1];
    base = raw.substring(0,raw.lastIndexOf(path));
    path = URLEncoder.encode(path, &quot;UTF-8&quot;);
    String[] queryResult = query.split(&quot;=&quot;);
    String queryKey = URLEncoder.encode(queryResult[0], &quot;UTF-8&quot;);
    String queryValue = URLEncoder.encode(queryResult[1], &quot;UTF-8&quot;);
    System.out.println(base + path + &quot;?&quot; + queryKey + &quot;=&quot; + queryValue);
}
//输出结果：http://localhost:9090/index?name=%E5%BC%A0%E5%A4%A7doge
//其中UTF-8编码中张的十六进制表示为E5 BC A0，大的十六进制编码为E5 A4 A7&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;许多系统会通过代理服务器访问Web应用或者其他服务器中的资源，代理服务器接收从本地客户端发出的请求再转发请求到远程服务器，然后远程服务器返回请求的结果到代理服务器，代理服务器接收到结果之后会把结果回传到本地服务器。这样做有两个比较重要的原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、安全原因，防止远端的主机了解关于本地网络配置的细节。&lt;/li&gt;
&lt;li&gt;2、过滤出站请求，限制浏览一些禁用的网站。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在Java中除了TCP连接使用传输层的SOCKET代理，其他应用层代理都不支持。Java对于SOCKET没有提供禁用代理的选项，但是可以通过下面三个系统属性配置来开启和限制代理：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;http.proxyHost：代理服务器的主机名，默认不设置此系统属性。
http.proxyPort:代理服务器的端口号，默认不设置此系统属性。
http.noneProxyHosts:不需要代理访问的主机名，多个用竖线|分隔，默认不设置此系统属性。

举个例子：
System.setProperty(&quot;http.proxyHost&quot;, &quot;localhost&quot;);
System.setProperty(&quot;http.proxyPort&quot;, 1080);
System.setProperty(&quot;http.noneProxyHosts&quot;, &quot;www.baidu.com|github.com&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;proxy类&quot;&gt;Proxy类&lt;/h2&gt;
&lt;p&gt;java.net.Proxy类提供了对代理服务器更细粒度的控制，也就是说这个类允许在编程的使用使用不同的远程服务器作为代理服务器，而不是通过系统属性全局配置代理。Proxy目前支持三种代理类型，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Proxy.Type.DIRECT：直连，也就是不使用代理。&lt;/li&gt;
&lt;li&gt;Proxy.Type.HTTP：HTTP代理。&lt;/li&gt;
&lt;li&gt;Proxy.Type.SOCKS：socket的V4或者V5版本的代理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用的时候如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SocketAddress socketAddress = new InetSocketAddress(&quot;localhost&quot;, 80);
Proxy proxy = new Proxy(Proxy.Type.HTTP, socketAddress);
Socket socket = new Socket(proxy);
//...&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;proxyselector类&quot;&gt;ProxySelector类&lt;/h3&gt;
&lt;p&gt;每个运行中的Java虚拟机都会存在一个&lt;code&gt;java.net.ProxySelector&lt;/code&gt;实例对象，用来确定不同连接使用的代理服务器。默认的&lt;code&gt;java.net.ProxySelector&lt;/code&gt;的实现是&lt;code&gt;sun.net.spi.DefaultProxySelector&lt;/code&gt;的实例，它会检查各种系统属性和URL的协议，再决定如果连接到不同的远程代理服务器，当然，开发者也可以继承和实现自定义的&lt;code&gt;java.net.ProxySelector&lt;/code&gt;，从而可以根据协议、主机、路径日期等其他标准来选择不同的代理服务器。&lt;code&gt;java.net.ProxySelector&lt;/code&gt;的几个核心的抽象方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//获取默认的ProxySelector实例
public static ProxySelector getDefault()

//设置默认的ProxySelector实例
public static void setDefault(ProxySelector ps)

//通过URI获取可用的代理列表
public abstract List&amp;lt;Proxy&amp;gt; select(URI uri)

//告知ProxySelector不可用的代理和出现的异常
public abstract void connectFailed(URI uri, SocketAddress sa, IOException ioe)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要扩展的话，最好加入缓存的功能，缓存可用的Proxy列表，一旦出现Proxy不可用，通过&lt;code&gt;connectFailed&lt;/code&gt;进行清理和剔除不可用的代理节点即可。&lt;/p&gt;

&lt;p&gt;URL和URI是当前的网络世界或者系统中资源的重要标识符，了解它们的基础知识才能更好地进行网络编程。URI是统一资源标识符，它可以表示任何介质中的资源。而URL是统一资源位置，一般特指因特网中的网络资源位置，使用于Http或者Https协议中。很显然，URI可以表示的范围更大，URI实际上是包含了URL。而两者的区别可以参看上面的几个小节。&lt;/p&gt;
&lt;p&gt;(c-5-d e-20181003)&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 10:51:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 前面的一篇文章《Java中的Internet查询》分析完了如何通过IP地址或者主机名确定主机在因特网中的地址。任意给定主机上可能会有任意多个资源，这些资源需要有标识符方便主机之间访问对方的资源，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9740425.html</dc:identifier>
</item>
</channel>
</rss>