<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>点分治略解 - WR_Eternity</title>
<link>http://www.cnblogs.com/WR-Eternity/p/10003895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WR-Eternity/p/10003895.html</guid>
<description>&lt;p&gt;　　给你一棵TREE,以及这棵树上边的距离。问有多少对点它们两者间的距离小于等于K。&lt;/p&gt;

&lt;p&gt;先想想暴力做法吧，n&lt;sup&gt;3&lt;/sup&gt;的，都会吧，暴力枚举两点，再暴力求出他们间的距离，判断是否小于k，统计答案。&lt;/p&gt;
&lt;p&gt;n&lt;sup&gt;2 &lt;/sup&gt;log呢？很简单吧，就是把暴力求距离那一步改成LCA嘛。&lt;/p&gt;
&lt;p&gt;那么我们的点分治就更加牛逼了，它可以在n log&lt;sup&gt;2&lt;/sup&gt; 的时间内求解。&lt;/p&gt;
&lt;p&gt;那么它是如何做到这么优秀的呢？我们来看看他的算法流程吧。&lt;/p&gt;
&lt;p&gt;点分治主要是通过统计&lt;strong&gt;&lt;span&gt;路径经过u&lt;/span&gt;&lt;/strong&gt;的两个点（包括以u为路径的端点，其中这两个点是要在以u为根的子树中的），长度小于等于k的有多少，递归来求出最终的答案。&lt;/p&gt;
&lt;p&gt;我们先讲讲如何统计路径经过u的两个点，长度小于等于k的有多少吧。&lt;/p&gt;
&lt;p&gt;这应该很容易想的。&lt;/p&gt;
&lt;p&gt;先一遍dfs求出从点u到&lt;strong&gt;&lt;span&gt;以u为根的子树&lt;/span&gt;&lt;/strong&gt;中各个点的距离。&lt;/p&gt;
&lt;p&gt;那么我们把以u为根的子树中各个点到u的距离&lt;strong&gt;&lt;span&gt;排序&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;排序之后，对于每一个点都&lt;strong&gt;&lt;span&gt;二分匹配&lt;/span&gt;&lt;/strong&gt;一个最大的和它相加小于等于k的另一个点，再统计答案。&lt;/p&gt;
&lt;p&gt;但是我们发现，这么做会锅。&lt;/p&gt;
&lt;p&gt;会遇到下图情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1487382/201811/1487382-20181122205913623-428823660.png&quot; alt=&quot;&quot; width=&quot;407&quot; height=&quot;239&quot;/&gt;（手画的，有点难看，讲究一下下吧。。。）&lt;/p&gt;
&lt;p&gt;假设k=8，当我们在做1号点时，我们会发现d[4]=4,d[5]=4，然后他俩就会牵手成功，然而这是错的，因为1-2的边被计算了两次。&lt;/p&gt;
&lt;p&gt;这个时候呢，我们有两种解决方法：&lt;/p&gt;
&lt;p&gt;1、注意到当这两个点不在u的同一个儿子时，便不会产生重复的路径，所以我们把各个点进行染色，把在u的同一个儿子中的点染成同一种颜色，然后不去匹配颜色相同的点就OK了。&lt;/p&gt;
&lt;p&gt;2、利用融斥的思想，做以v（v为u的儿子）为根的子树，并把u中的各个节点到u的距离通通加上dist[u,v]，在这种情况下依然能够牵手成功的两个点，就说明它是我们在上一次统计中出锅的情况，只要把这些情况减掉就可以了。&lt;/p&gt;
&lt;p&gt;代码中我是用了第二种方法（毕竟比较简单嘛，代码也短）。&lt;/p&gt;
&lt;p&gt;另一个问题——为什么一定要是在以u为根的子树中的点呢？还是直接看图吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1487382/201811/1487382-20181123150814469-1020776994.png&quot; alt=&quot;&quot; width=&quot;347&quot; height=&quot;330&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说此时的v2不在以u为根的子树中，那么就说明v1和v2被u到v2这段路径，辈分最高的那个点统计过了（就是图中从u连到骚粉矩形的边的另一个端点），不需要再次重复统计。&lt;/p&gt;

&lt;p&gt;看了上述的算法流程，相比大家都会算时间复杂度吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;T(n)=∑&lt;sub&gt;v∈u's sons &lt;/sub&gt;[T(siz[v])+Θ(n log n)]&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很显然，时间复杂度和我们递归的层数是有关系的，那么我们选择点的顺序就很清楚了：&lt;/p&gt;
&lt;p&gt;　　为了让递归的层数尽可能的小，所以我们要每次选子树的重心开始做。&lt;/p&gt;
&lt;p&gt;那么理论上时间复杂度最大的时候，就恰恰是一条链的时候，因为它会递归log n层，那么理论时间复杂度便是O(n log&lt;sup&gt;2&lt;/sup&gt;)的了。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn=&lt;span&gt;40005&lt;/span&gt;,inf=&lt;span&gt;100000000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; d[maxn],siz[maxn],f[maxn],head[maxn],nxt[maxn&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;],vet[maxn&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;],dist[maxn&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; vis[maxn];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,k,x,y,z,root,Siz,tot,cnt,ans;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; z){
    nxt[&lt;/span&gt;++tot]=&lt;span&gt;head[x];
    vet[tot]&lt;/span&gt;=&lt;span&gt;y;
    head[x]&lt;/span&gt;=&lt;span&gt;tot;
    dist[tot]&lt;/span&gt;=&lt;span&gt;z;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; getroot(&lt;span&gt;int&lt;/span&gt; u,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; father){           //找重心
    siz[u]&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;; f[u]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=head[u];i;i=&lt;span&gt;nxt[i]){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v=&lt;span&gt;vet[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vis[v]||v==father) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        getroot(v,u);
        f[u]&lt;/span&gt;=&lt;span&gt;max(f[u],siz[v]);
        siz[u]&lt;/span&gt;+=&lt;span&gt;siz[v];
    }
    f[u]&lt;/span&gt;=max(f[u],Siz-&lt;span&gt;siz[u]);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (f[u]&amp;lt;f[root]) root=&lt;span&gt;u;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; getdis(&lt;span&gt;int&lt;/span&gt; u,&lt;span&gt;int&lt;/span&gt; father,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dis){    //求距离
    d[&lt;/span&gt;++cnt]=&lt;span&gt;dis;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=head[u];i;i=&lt;span&gt;nxt[i]){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v=&lt;span&gt;vet[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vis[v]||v==father) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        getdis(v,u,dis&lt;/span&gt;+&lt;span&gt;dist[i]);
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; find_right(&lt;span&gt;int&lt;/span&gt; k,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; left){           //求最大的能与now牵手成功的右端点
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; l=left,r=cnt,ans=&lt;span&gt;left;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (l&amp;lt;=&lt;span&gt;r){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid=l+r&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (d[mid]&amp;lt;=k) ans=mid,l=mid+&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;else&lt;/span&gt; r=mid-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ans;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; getans(&lt;span&gt;int&lt;/span&gt; u,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dis){                //求答案
    cnt&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; res=&lt;span&gt;0&lt;/span&gt;,now=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    getdis(u,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,dis);
    sort(d&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;,d+&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;cnt);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (now&amp;lt;cnt&amp;amp;&amp;amp;d[now]+d[cnt]&amp;lt;k) res+=cnt-now,now++&lt;span&gt;;      //说明全部都可以牵手成功
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (now&amp;lt;cnt&amp;amp;&amp;amp;d[now]+d[now+&lt;span&gt;1&lt;/span&gt;]&amp;lt;=k&lt;span&gt;){  
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; right=find_right(k-d[now],now+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        res&lt;/span&gt;+=right-now; now++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dfs(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; u){
    vis[u]&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;; ans+=getans(u,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=head[u];i;i=&lt;span&gt;nxt[i]){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v=&lt;span&gt;vet[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vis[v]) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        ans&lt;/span&gt;-=&lt;span&gt;getans(v,dist[i]);         //去掉上述在同一儿子中的情况
        Siz&lt;/span&gt;=siz[v]; root=&lt;span&gt;v;
        getroot(v,u);                   //确定下一个点
        dfs(root);
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;n);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;){
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;x,&amp;amp;y,&amp;amp;&lt;span&gt;z);
        add(x,y,z); add(y,x,z);
    }
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;k);
    root&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;; Siz=&lt;span&gt;n;
    getroot(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    dfs(root);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ans);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 23 Nov 2018 07:16:00 +0000</pubDate>
<dc:creator>WR_Eternity</dc:creator>
<og:description>点分治被用来解决的问题： 给你一棵TREE,以及这棵树上边的距离。问有多少对点它们两者间的距离小于等于K。 算法实现： 先想想暴力做法吧，n3的，都会吧，暴力枚举两点，再暴力求出他们间的距离，判断是否</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WR-Eternity/p/10003895.html</dc:identifier>
</item>
<item>
<title>公司来了个“奇葩”的程序员 - 锋哥程序十年</title>
<link>http://www.cnblogs.com/bianchengniuren/p/10007460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengniuren/p/10007460.html</guid>
<description>&lt;p&gt;光阴飞逝，眨眼间，明仔在公司呆了快一年了。&lt;/p&gt;
&lt;p&gt;这一年，受外围经济的影响，公司业绩不大好。大家的加班积极性也都普遍不高。基本上都是下班时间过后不久，就都陆续打卡告辞下班了。日子平淡无奇，大家都相安无事。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;来了名校毕业生&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;小李毕业于国内知名学府，在校招的时候被老板选中，任软件工程师一职。小李学习能力很强，待人态度也不错，开始的时候普遍给大家良好的印象，大家都很喜欢他。小李自己要求也很严格，公司的业务上手很快，写代码也进步很快。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;喜欢往老板的办公室跑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 过了一段时间，大家发现小李喜欢经常往老板的办公室跑。小李一天要跑老板的办公室两三趟，及时汇报项目进度，确认开发需求。和他一起开发的工程师，一般三天左右才会去找老板确认项目进度。一次开周会，老板在会上重点表扬了小李，说小李做事情细心，对公司负责。大家听了都没有说话，默默的鼓掌。带小李的师傅更是一句话也说不上来。大家隐隐觉得哪里不对劲。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;微信群一个不和谐的声音&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;渐渐地，大家发现小李经常在半夜的时候找公司其他员工“请教” 问题。而且经常附带上传一些在公司现场拍的产品照片。原来，小李经常独自一人在公司加班到很晚，偶尔还会在公司睡一宿。刚毕业，孤身一人，精力无限，在公司加班本来属于个人自由。但是其他员工慢慢的有点坐不住了。小李半夜在公司的微信群提问题，大家虽然心里一万个不愿意，但是也不得不回答他的问题。有时为了回答好问题，不得不在家里打开电脑加一会班。因为谁也不想给群主老板留下一个不负责任的印象。小李的努力表现，给大家增加了很大压力。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;公司捡钱，矛盾堆积&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一天周末，小李独自一人到公司加班。在公司门口的过道，小李捡到了一张五毛钱。小李觉得这张五毛钱是公司的人丢的，于是很认真的拍了一张照片，发到微信群。问这是谁丢的钱，欢迎找他认领。老板在群里表扬小李周末加班的精神。大家也纷纷在群里赞扬小李拾金不昧，然后转头就发消息问带小李入门的师傅怎么回事。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;树立典型，队友被开&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和小李一起做项目的工程师陈工，是一个能力不错的工程师，有比较丰富的工作经验。但是陈工每天下班都要去幼儿园接他儿子放学，所以加班比较少，这一点让老板不痛快。一天，老板找小李谈话，问小李自己能不能把项目搞定。没有社会经验的小李，不加思索的说：“可以”。然后，晚上快下班的时候，陈工就被公司开除了。陈工晚上请大家喝酒吃饭告别，酒喝得差不多的时候，大家看到陈工哭了。人到中年，谁都不容易。这不是陈工的错，又要照顾好家庭，又要忙工作，两头不是人。这件事之后，大家都对小李刮目相看。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;被加班，谁都是狠角色&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从此，很少有员工敢按时下班了。加班不是什么大问题，能加班解决的问题都不是问题。谁又害怕加班呢，不服那就比一比咯？大家在被加班的重压之下又恢复了往日的和谐。&lt;/p&gt;

</description>
<pubDate>Fri, 23 Nov 2018 06:55:00 +0000</pubDate>
<dc:creator>锋哥程序十年</dc:creator>
<og:description>光阴飞逝，眨眼间，明仔在公司呆了快一年了。 这一年，受外围经济的影响，公司业绩不大好。大家的加班积极性也都普遍不高。基本上都是下班时间过后不久，就都陆续打卡告辞下班了。日子平淡无奇，大家都相安无事。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengniuren/p/10007460.html</dc:identifier>
</item>
<item>
<title>Python You-Get (送你一个免广告的视频和音乐网站 VIP) - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/10007590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/10007590.html</guid>
<description>
&lt;p&gt;You-get可以在仅仅提供URL情况下就可以实现下载视频、图片、音乐等信息。也可以通过播放器在线观看视频或听音乐，重要的是再也不用烦恼弹出的广告了,如果你想观看视频，但又不想观看广告，并且你还想把视频保存下来，它是一个很好的选择。You-get是一个基于命令行运行的python第三方库。&lt;/p&gt;

&lt;p&gt;下面两段是you-get的作者对它的介绍：&lt;/p&gt;

&lt;p&gt;为什么你要好好的用you-get：&lt;/p&gt;
&lt;p&gt;你欢喜于互联网上的富媒体内容，并为个人寻欢而储存&lt;/p&gt;
&lt;p&gt;你喜悦观看的视频，然而不得保存;对个人设备无从控制，此乃违背开放互联网之行为&lt;/p&gt;
&lt;p&gt;你寻求解脱于闭源软件或JavaScript的代码，并禁止闪光运行&lt;/p&gt;
&lt;p&gt;你为黑客精神与自由软件而欣喜&lt;/p&gt;

&lt;p&gt;you-get之功用：&lt;/p&gt;
&lt;p&gt;下载流行网站之音视频，例如YouTube，优酷，Niconico，以及更多。（查看完整请立即获取iTunes列表）&lt;/p&gt;
&lt;p&gt;于您心仪的媒体播放器中观看在线视频，脱离浏览器与广告&lt;/p&gt;
&lt;p&gt;下载您喜欢的网页上的图片&lt;/p&gt;
&lt;p&gt;下载任何非HTML内容，例如二进制文件&lt;/p&gt;

&lt;p&gt;安装：pip3 install you-get&lt;/p&gt;

&lt;p&gt;本章使用的视频网址（笔者推荐）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av34818622&quot;&gt;https://www.bilibili.com/video/av34818622&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Windows在想要保存的文件夹内使用快捷键打开命令行：shift+鼠标右键&lt;/p&gt;

&lt;p&gt;播放flv格式视频推荐使用：暴风影音&lt;/p&gt;

&lt;p&gt;Ctrl+C可暂停下载，再次输入下载命令可继续下载&lt;/p&gt;

&lt;p&gt;&lt;span&gt;直接按默认方式下载视频：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;视频保存的地址为你终端所运行的地址&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
you-get https://www.bilibili.com/video/av34818622
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181123142806182-1068903932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;查看视频的详细信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
you-get -i https://www.bilibili.com/video/av34818622
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181123142959066-721237444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;带参数下载视频：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参数：-o 文件绝对路径&lt;/p&gt;
&lt;p&gt;参数：-O 文件重命名&lt;/p&gt;
&lt;p&gt;参数：--format=flv 需要下载的版本号，如上视频的详细信息绿色框&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181123143021590-1763659810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载后内容显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181123143052106-1966424927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载一张图片：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
you-get http://p0.so.qhimgs1.com/bdr/_240_/t01b2d9773266dc30ec.png
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181123143125470-1845591390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;下载一首音乐：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
you-get http://www.kuwo.cn/yinyue/9857007/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取音乐URL方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181123143212469-1552086079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;获取RUL的json信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
you-get --json  http://www.kuwo.cn/yinyue/9857007/
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在线观看视频（稳定性较差）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Windows 下载播放器：PotPlayer&lt;/p&gt;
&lt;p&gt;添加PotPlayerMini.exe的文件夹路径到系统环境变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181123143315136-566684798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
you-get -p PotPlayerMini https://www.iqiyi.com/v_19rrlcgb4w.html?vfm=2008_aldbd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;电影《一念天堂》&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181123143400939-1960582092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;使用树莓派测试（待测试）：&lt;/p&gt;
&lt;p&gt;安装：sudo apt install vlc&lt;/p&gt;
&lt;p&gt;使用--player/-p将视频喂进播放器，例如mplayer或者vlc，而不是下载：&lt;/p&gt;

&lt;p&gt;you-get -p vlc &lt;a href=&quot;https://www.bilibili.com/video/av34818622&quot;&gt;https://www.bilibili.com/video/av34818622&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$ you-get -p vlc 'https://www.youtube.com/watch?v=jNQXAC9IVRw'&lt;/p&gt;

&lt;p&gt;或者你想在浏览器中观看而不希望看广告或评论区：&lt;/p&gt;

&lt;p&gt;$ you-get -p chromium 'https://www.youtube.com/watch?v=jNQXAC9IVRw'&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;https://jingyan.baidu.com/article/ceb9fb10944f9b8cad2ba0ae.html&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get&quot;&gt;https://github.com/soimort/you-get&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E&quot;&gt;https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看支持网站：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E#%E6%94%AF%E6%8C%81%E7%BD%91%E7%AB%99&quot;&gt;https://github.com/soimort/you-get/wiki/%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E#%E6%94%AF%E6%8C%81%E7%BD%91%E7%AB%99&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 23 Nov 2018 06:50:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>You-get可以在仅仅提供URL情况下就可以实现下载视频、图片、音乐等信息。也可以通过播放器在线观看视频或听音乐，重要的是再也不用烦恼弹出的广告了,如果你想观看视频，但又不想观看广告，并且你还想把视</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/10007590.html</dc:identifier>
</item>
<item>
<title>新流程的搭建 - 远航の小鸟</title>
<link>http://www.cnblogs.com/uniquefrog/p/10007504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/uniquefrog/p/10007504.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　新建一个流程，怎么建？如果这个问题你心中不能有个逻辑框架，那还是要看完的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们做流程管理的，自己做的事情怎么可能没有逻辑呢？这是不可能的。我这里要整理的就是要把我们搭建新流程要做的事情一件一件整理出来，将我们的工作顺序统筹好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一步，明确需求（权重50%）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一定要先了解你要新建的这条流程的目的是什么！这个很重要，这是你要建的这条流程的灵魂，所以你要静下心来与这个流程的需求方进行沟通，要明确的知晓要达到的目的是什么，要解决的问题是什么。比如新员工转正流程，目的就是为了让新员工通过试用期内的成果展示，让领导审批，达到同意转正或者暂时无法转正的效果。其实如果作为流程的发起者，要提出一条流程需求，必须要了解公司或组织的战略目标，制定出符合公司、组织战略目标的需求是非常关键的一步，这也是我把这一步设置成50%权重的意义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二步，熟悉业务（权重15%）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　流程是一些活动，但是这一系列活动什么时候发生才是正确的，这个是流程管理者要重视的，正所谓合适的时间做正确的事。有了这种想法，自然就要去了解该流程触发的场景是什么，而场景用在公司或组织的用语就叫做业务。就拿质量检测流程举例吧，要搭建该流程，自然要熟悉生产线上产品生产过程发生的先后顺序，产品到哪一步应该进行质检，不能太早也不能太晚，否则都达不到质检的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第三步，逐个沟通（权重25%）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　流程的背景前面都了解，下面要做的就是了解流程怎么走，就是确定流程的输入资源、流程活动、活动的相互作用、输出结果这四个要素，说的简单点，就是要确定流程要经过谁、每个人都要做什么、做这些事的先后顺序应该怎么排，流程要产生什么服务或者产品。这么多东西？不要怕，不要慌张，其实我们就做一件事就可以了——顺藤摸瓜！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　顺藤摸瓜，藤：在确定了该业务流程的参与人员后，我们需要一个一个的沟通，需要了解的是他们在流程中都要做什么（what），怎么做的（how），在他们印象中该流程的其他人应该是怎么做的（other how）；了解完这三个问题，闪人！毕竟沟通是要花时间，肯定是要讲究效率的，带着问题去问，效率自然非常高。一个人问完了，别着急，我们要消化一下嘛，毕竟吃多了可能会撑的，怎么消化呢？将问到的内容整理成一个流程图的雏形，可以用任何工具记录该流程第一步做什么、怎么做；第二部做什么、怎么做；第三步做什么、怎么做.....当然，时间允许的情况下，可以用画图工具将流程图的雏形画出来，比如viso、xmind等，若时间紧张，用笔记录一下也是可以的，至少流程逻辑在脑子里要形成链条。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　该部分的主题是逐个沟通！不错，流程管理者需要去逐个与该流程的参与人沟通，问清楚上面那三个问题（what、how、other how），然后每问完一个人就完善一下自己的流程雏形，直到问完最后一个人。这时候的流程是经过了多次的完善和补充的，如果有熟悉项目管理的，可以很容易想到迭代型生命周期，不错，这里就是采用迭代的方式不断的完善流程。有人说我找一两个关键人员问一下不就好了吗？千万别偷懒哦，流程中的每个人都有自己的看法，所谓屁股决定脑袋，立场不同自然想法不同，逐个沟通的必要性肯定是需要的；当然，这里的“逐个”是逐个节点的意思，不需要每个节点的每个人都沟通一遍，没有必要，也没有那么多时间，比如费用报销，会计可能有很多人，我们找业务最熟的会计问就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第四步，流程呈现（权重5%）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前面的刀都磨好了，剩下的就是砍木头了。按照之前收集的资料用软件系统呈现出来就好了，可以用viso+word+excel，画流程图，写节点说明，整理流程表单，也可以用xmind+excel等等，方式很多，哪个顺手用哪个。然后再将文件交给信息部设置完成即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　到此，一个新的流程就算设计完了，其实也很简单，就是需要耐心的去做就好了。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 06:41:00 +0000</pubDate>
<dc:creator>远航の小鸟</dc:creator>
<og:description>新建一个流程，怎么建？如果这个问题你心中不能有个逻辑框架，那还是要看完的。 我们做流程管理的，自己做的事情怎么可能没有逻辑呢？这是不可能的。我这里要整理的就是要把我们搭建新流程要做的事情一件一件整理出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/uniquefrog/p/10007504.html</dc:identifier>
</item>
<item>
<title>Django连接Oracle数据库配置 - 周资源</title>
<link>http://www.cnblogs.com/zhouziyuan/p/10007463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouziyuan/p/10007463.html</guid>
<description>&lt;p&gt;&lt;span&gt;Django项目中，settings.py文件中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;service_name&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　DATABASES = {&lt;/p&gt;
&lt;p&gt;　　　　'default': {&lt;/p&gt;
&lt;p&gt;　　　　　　'ENGINE': 'django.db.backends.oracle',&lt;/p&gt;
&lt;p&gt;　　　　　　'NAME': 'IP:端口号/service_name',&lt;/p&gt;
&lt;p&gt;　　　　　　'USER': '用户名',&lt;/p&gt;
&lt;p&gt;　　　　　　'PASSWORD': '密码',&lt;/p&gt;
&lt;p&gt;　　　　}&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;SID&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;22&quot;&gt;
&lt;p&gt;　　DATABASES = {&lt;/p&gt;
&lt;p&gt;　　　　'default': {&lt;/p&gt;
&lt;p&gt;　　　　　　'ENGINE': 'django.db.backends.oracle',&lt;/p&gt;
&lt;p&gt;　　　　　　'NAME': '数据库SID',&lt;/p&gt;
&lt;p&gt;　　　　　　'USER': '用户名',&lt;/p&gt;
&lt;p&gt;　　　　　　'PASSWORD': '密码',&lt;/p&gt;
&lt;p&gt;　　　　　　'HOST':'IP',&lt;/p&gt;
&lt;p&gt;　　　　　　'PORT':'端口号'&lt;/p&gt;
&lt;p&gt;　　　　}&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 23 Nov 2018 06:36:00 +0000</pubDate>
<dc:creator>周资源</dc:creator>
<og:description>Django连接Oracle得两种方式：service_name和SID</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouziyuan/p/10007463.html</dc:identifier>
</item>
<item>
<title>系统学习 Java IO (一)----InputStream &amp; OutputStream - czwbig</title>
<link>http://www.cnblogs.com/czwbig/p/10007289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/czwbig/p/10007289.html</guid>
<description>&lt;p&gt;目录：&lt;a href=&quot;https://www.cnblogs.com/czwbig/p/10007201.html&quot;&gt;系统学习 Java IO ---- 目录，概览&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;inputstream&quot;&gt;InputStream&lt;/h3&gt;
&lt;p&gt;是Java IO API中所有输入流的父类。&lt;br/&gt;表示有序的字节流，换句话说，可以将 InputStream 中的数据作为有序的字节序列读取。&lt;br/&gt;这在从文件读取数据或通过网络接收时非常有用。&lt;br/&gt;InputStream 通常连接到某些数据源，如文件，网络连接，管道等&lt;br/&gt;看如下代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InputStreamExample {
    public static void main(String[] args) throws IOException {
        InputStream inputStream = new FileInputStream(&quot;D:\\out.txt&quot;);
        //do something with data...
        int data = inputStream.read();
        while (data != -1) {
            System.out.print((char) data);
            data = inputStream.read();
        }
        inputStream.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：为了代码清晰，这里并没有考虑处理异常的情况，IO 异常处理有专门的介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;read&quot;&gt;read()&lt;/h5&gt;
&lt;p&gt;此方法返回的是 int 值，其中包含&lt;strong&gt;读取的字节的字节值&lt;/strong&gt;,可以将返回的 int 强制转换为 char 输出。&lt;br/&gt;如果 read() 方法返回 -1 ，则表示已到达流的末尾，这意味着在 InputStream 中不再有要读取的数据。&lt;br/&gt;也就是说，-1 作为 int 值，而不是 -1 作为字节或短值，这里有区别！&lt;/p&gt;
&lt;p&gt;InputStream 类还包含两个 read() 方法，这些方法可以将 InputStream 源中的数据读入字节数组。&lt;br/&gt;这些方法是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;int read(byte[]);&lt;/li&gt;
&lt;li&gt;int read(byte[], int offset, int length);&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一次读取一个字节数比一次读取一个字节要快得多，所以在可以的时候，使用这些读取方法而不是 read() 方法。&lt;/p&gt;
&lt;p&gt;read（byte []）方法将尝试将尽可能多的字节读入作为参数给出的字节数组，因为数组具有空间。&lt;br/&gt;该方法返回一个 int ，其值是&lt;strong&gt;实际读取了多少字节&lt;/strong&gt;，这点和 read() 方法不一样。&lt;br/&gt;如果可以从 InputStream 读取的字节少于字节数组的空间，则字节数组的其余部分将包含与读取开始之前相同的数据。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InputStream input = new ByteArrayInputStream(&quot;123456789&quot;.getBytes());
byte[] bytes = new byte[4]; // 每次只读取 4 个字节
int data = input.read(bytes);
while (data != -1) {
      System.out.print(new String(bytes));
      data = input.read(bytes);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将输出 123456789&lt;strong&gt;678&lt;/strong&gt; ，而不是预期的 123456789 ！&lt;/p&gt;
&lt;p&gt;因为第一次读取进 bytes 是 &lt;strong&gt;1234&lt;/strong&gt; ，第二次将是 &lt;strong&gt;5678&lt;/strong&gt; ，现在只剩下 &lt;strong&gt;9&lt;/strong&gt; 一个数字了，注意此时 bytes 的值是 &lt;strong&gt;5678&lt;/strong&gt; ，然后再读取剩下 1个 &lt;strong&gt;9&lt;/strong&gt;，不能装满 bytes 了，只能覆盖 bytes的第一个字节，最后返回的bytes 是 &lt;strong&gt;9678&lt;/strong&gt;。&lt;br/&gt;所以记住检查返回的 int 以查看实际读入字节数组的字节数。&lt;/p&gt;
&lt;p&gt;int read(byte[], int offset, int length);方法和 read（byte []）方法差不多，只是增加了偏移量和指定长度。&lt;br/&gt;和 read() 一样，都是返回 -1 表示数据读取结束。&lt;br/&gt;使用实例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InputStream inputstream = new FileInputStream(&quot;D://out.txt&quot;);
byte[] data = new byte[1024];
int bytesRead = inputstream.read(data);
while(bytesRead != -1) {
  doSomethingWithData(data, bytesRead);
  bytesRead = inputstream.read(data);
}
inputstream.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，此示例创建一个字节数组。&lt;br/&gt;然后它创建一个名为 bytesRead 的 int 变量来保存每次读取 byte [] 调用时读取的字节数，&lt;br/&gt;并立即分配 bytesRead 从第一次读取 byte [] 调用返回的值。&lt;/p&gt;
&lt;h5 id=&quot;mark-and-reset&quot;&gt;mark() and reset()&lt;/h5&gt;
&lt;p&gt;InputStream 类有两个名为 mark() 和 reset() 的方法，InputStream 的子类可能支持也可能不支持：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;该子类覆盖 markSupported() 并返回true，则支持 mark( )和 reset() 方法。&lt;/li&gt;
&lt;li&gt;该子类覆盖 markSupported() 并返回 false ，则不支持 mark() 和 reset() 。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;该子类不重写 markSupported() 方法 ，则是父类的默认实现 &lt;code&gt;public boolean markSupported() { return false; }&lt;/code&gt; 也是不支持 mark( )和 reset() 方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;mark() 在 InputStream 内部设置一个标记，默认值在位置 0 处。&lt;br/&gt;可以手动标记到目前为止已读取数据的流中的点，然后，代码可以继续从 InputStream 中读取数据。&lt;br/&gt;如果想要返回到设置标记的流中的点，在 InputStream 上调用 reset() ，然后 InputStream “倒退”并返回标记，&lt;br/&gt;如此，便可再次从该mark点开始返回（读取）数据。很明显这可能会导致一些数据从 InputStream 返回多次。我来举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public static void testMarkAndReset() throws IOException {
        InputStream input = new ByteArrayInputStream(&quot;123456789&quot;.getBytes());
        System.out.println(&quot;第一次打印：&quot;);

        int count = 0;// 计算是第几次读取，将在第二次读取时做标记；
        byte[] bytes = new byte[3]; // 每次只读取 3 个字节
        int data = input.read(bytes);
        while (data != -1) {
            System.out.print(new String(bytes));
            if (++count == 2) { // 在第二轮读取，即读到数字 4 的时候，做标记
                input.mark(16); // 从 mark 点开始再过 readlimit 个字节，mark 将失效
            }
            data = input.read(bytes);
        }

        input.reset();
        System.out.println(&quot;\n在经过 mark 和 reset 之后从 mark 位置开始打印：&quot;);
        data = input.read(bytes);
        while (data != -1) {
            System.out.print(new String(bytes));
            data = input.read(bytes);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将会输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第一次打印：
123456789
在经过 mark 和 reset 之后从 mark 位置开始打印：
789  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外要说明一下 mark(int readlimit) 参数，readlimit 是告诉系统，过了这个 mark 点之后，给本宫记住往后的 readlimit 个字节，因为到时候 reset 之后，要从 mark 点开始读取的；但实际情况和 jdk 文档有出入,很多情况下调用 mark(int readlimit) 方法后，即使读取超过 readlimit 字节的数据，mark 标记仍有效,这又是为什么呢？网上有人解答，但我还是决定亲自探索一番。&lt;/p&gt;
&lt;p&gt;我们这个实例引用的实际对象是 &lt;code&gt;ByteArrayInputStream&lt;/code&gt; 先看一下它的源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* Note: The readAheadLimit for this class has no meaning.*/
    public void mark(int readAheadLimit) {
        mark = pos;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好家伙，它说这个参数对于这个类没有任何作用。&lt;/p&gt;
&lt;h5 id=&quot;注意这段是源码分析可看可不看跳过不影响阅读&quot;&gt;注意：这段是源码分析可看可不看，跳过不影响阅读&lt;/h5&gt;
&lt;hr/&gt;&lt;p&gt;那我们在看看其他的 InputStream 子类，经验证，FileInputStream 和一些实现类不支持 mark() 方法，我们看看 &lt;code&gt;BufferedInputStream&lt;/code&gt;类源码：&lt;br/&gt;我先把一些字段的含义说明一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;count&lt;/code&gt;&lt;/strong&gt; 索引1大于缓冲区中最后一个有效字节的索引。 该值始终在0到buf.length的范围内; 元素buf [0]到buf [count-1]包含从底层输入流获得的缓冲输入数据。在 read() 方法中读完数据返回 -1 就是因为&lt;code&gt;if (pos &amp;gt;= count) return -1;&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;pos&lt;/code&gt;&lt;/strong&gt; 指缓冲区中的当前位置。 这是要从 buf 数组中读取的下一个字符的索引。&lt;br/&gt;该值始终在 0 到 count 范围内。 如果它小于 count，则 buf [pos] 是要作为输入提供的下一个字节; 如果它等于 count ，则下一个读取或跳过操作将需要从包含的输入流中读取更多字节。（这句话不理解没关系）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;markpos&lt;/code&gt;&lt;/strong&gt;是调用最后一个 mark() 方法时 pos 字段的值。该值始终在-1到pos的范围内。 如果输入流中没有标记位置，则此字段为-1。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;BufferedInputStream 是每次读取一定量的数据到 buf 数组中的，设置了 readlimit 肯定是想让数组从 mark 索引开始至少记录 mark + readlimit 索引。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public synchronized void mark(int readlimit) {
        marklimit = readlimit;
        markpos = pos;
    }

public synchronized void reset() throws IOException {
        getBufIfOpen(); // Cause exception if closed
        if (markpos &amp;lt; 0)
            throw new IOException(&quot;Resetting to invalid mark&quot;);
        pos = markpos;
    }

 private void fill() throws IOException {
        byte[] buffer = getBufIfOpen();
        if (markpos &amp;lt; 0)
            pos = 0;            /* 没有标记就直接丢掉缓存，使用buffer取新数据 */
        else if (pos &amp;gt;= buffer.length)  /* 缓冲区中当前位置比buffer数组大，才执行下面代码 */
            if (markpos &amp;gt; 0) {  /* 可以把 markpos 左边的数据丢掉 */
                int sz = pos - markpos; // 需要缓存的字节长度，从 markpos 开始
                System.arraycopy(buffer, markpos, buffer, 0, sz); // 复用内存空间
                pos = sz;
                markpos = 0;
            } else if (buffer.length &amp;gt;= marklimit) { // 如果 buffer 的长度已经大于 marklimit
                markpos = -1;   /* 那 mark 就失效了*/
                pos = 0;        /* 删除buffer内容，取新数据 */
            } else if (buffer.length &amp;gt;= MAX_BUFFER_SIZE) { // 如果buffer过长就抛错
                throw new OutOfMemoryError(&quot;Required array size too large&quot;);
            } else {            /* buffer 还没 marklimit 大，扩容到 pos 的2倍或者最大值 */
                int nsz = (pos &amp;lt;= MAX_BUFFER_SIZE - pos) ?
                        pos * 2 : MAX_BUFFER_SIZE;
                if (nsz &amp;gt; marklimit)
                    nsz = marklimit;
                byte nbuf[] = new byte[nsz];
                System.arraycopy(buffer, 0, nbuf, 0, pos);
                if (!bufUpdater.compareAndSet(this, buffer, nbuf)) {
                    throw new IOException(&quot;Stream closed&quot;);
                }
                buffer = nbuf;
            }
        count = pos;
        int n = getInIfOpen().read(buffer, pos, buffer.length - pos);
        if (n &amp;gt; 0)
            count = n + pos;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以得出：设置标记后，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果缓冲区中当前位置比 buffer 数组小，也就是还没读完 buffer 数组，那 mark 标记不会失效；&lt;/li&gt;
&lt;li&gt;下次继续读取，超过 buffer 大小字节后，判断 markpos 是否大于0，如果 markpos 大于0，即还在 buffer 数组内，则把 markpos 左边的数据清除，markpos 指向 0 , 复用内存空间，并设置 buffer 的大小为 (pos - markpos) 的值；&lt;/li&gt;
&lt;li&gt;再继续读取，此时 markpos 肯定不在 buffer 数组包含范围了，此时判断 buffer 的长度是否大于等于&lt;br/&gt;marklimit ，如果小于 marklimit ，那说明设置 mark 后读取的数据长度还没达到要求的 marklimit 了，给我继续，保持从 mark 点开始缓存, mark 标记不会失效。然后 buffer 就扩容到Math.min(2倍 pos 或最大值 ，marklimit)；&lt;/li&gt;
&lt;li&gt;再继续读取，同上，buffer 这么努力扩容，总有大于 marklimit 的时候，这时说明设置 mark 后继续读取的数据长度已经超过要求的 marklimit 了，仁尽义至，标记失效；&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;我们就只分析了 ByteArrayInputStream 和 BufferedInputSteam 类的算法，其它输入流不知道。因此 mark() 方法标记时，务必考虑好 readlimit 的值。&lt;/p&gt;
&lt;h3 id=&quot;outputstream&quot;&gt;OutputStream&lt;/h3&gt;
&lt;p&gt;OutputStream通常始终连接到某个数据目标，如文件，网络连接，管道等。 OutputStream的数据目标是写入OutputStream的所有数据最终结束的地方。&lt;/p&gt;
&lt;h5 id=&quot;writebyte&quot;&gt;write(byte)&lt;/h5&gt;
&lt;p&gt;write(byte)方法用于将单个字节写入 OutputStream。 OutputStream 的 write() 方法接受一个 int ，其中包含要写入的字节的字节值。 只写入 int 值的第一个字节。 其余的被忽略了。&lt;br/&gt;OutputStream 的子类可以有替代的 write() 方法。 例如，DataOutputStream允许您使用相应的方法writeBoolean()，writeDouble() 等编写诸如 int，long，float，double，boolean 等 Java 类型。&lt;/p&gt;
&lt;h5 id=&quot;writebyte-bytes-writebyte-bytes-int-offset-int-length&quot;&gt;write(byte[] bytes) ， write(byte[] bytes, int offset, int length)&lt;/h5&gt;
&lt;p&gt;和 InputStream 一样，它们也可以将一个数组或一部分字节写入 OutputStream 。&lt;/p&gt;
&lt;h5 id=&quot;flush&quot;&gt;flush()&lt;/h5&gt;
&lt;p&gt;OutputStream 的flush() 方法将写入 OutputStream 的所有数据刷新到底层数据目标。 例如，如果 OutputStream 是 FileOutputStream ，则写入 FileOutputStream 的字节可能尚未完全写入磁盘。 即使您的Java代码已将其写入 FileOutputStream ，数据也可能在某处缓存在内存中。 通过调用 flush() ，您可以确保将任何缓冲的数据刷新（写入）到磁盘（或网络，或 OutputStream 的目标所具有的任何其他内容）。&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 06:18:00 +0000</pubDate>
<dc:creator>czwbig</dc:creator>
<og:description>目录：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/czwbig/p/10007289.html</dc:identifier>
</item>
<item>
<title>CentOS下Docker与.netcore(四）之 三剑客之一Docker-machine+jenkins简单自动化部署 - 老六代码</title>
<link>http://www.cnblogs.com/chenyishi/p/10007125.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyishi/p/10007125.html</guid>
<description>&lt;h2&gt;&lt;span&gt;1.什么是Docker-machine&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;docker-compsoe&quot; href=&quot;https://www.cnblogs.com/chenyishi/p/10000693.html&quot; target=&quot;_blank&quot;&gt;上一章&lt;/a&gt;讲了Docker-compose，主要是在一台服务器上编排镜像与容器。假如现在要求在两台服务器上部署容器，一般的做法是登陆到两台服务器分别部署，听起来也没问题。但如果从两台服务器增加到10台，就特别麻烦，这种情况下，Docker-machine出现了。有了Docker-machine之后，就可以很方便的在多台服务器上部署。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.安装&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;现在有两台服务器，我们要实现通过服务器A把镜像部署到服务器B&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务器A安装docker-machine，执行命令&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
base=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/docker/machine/releases/download/v0.16.0 &amp;amp;&amp;amp;&lt;/span&gt;
  curl -L $base/docker-machine-$(&lt;span&gt;uname&lt;/span&gt; -s)-$(&lt;span&gt;uname&lt;/span&gt; -m) &amp;gt;/tmp/docker-machine &amp;amp;&amp;amp;
  &lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; /tmp/docker-machine /usr/local/bin/docker-machine
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;验证安装成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123131246557-463804766.png&quot; alt=&quot;&quot; width=&quot;405&quot; height=&quot;36&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.服务器A创建SSH密钥对，并发到服务器B上&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@cys-test-centos ~]# &lt;span&gt;ssh-keygen&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所有选项都直接回车&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@cys-test-centos ~]# &lt;span&gt;ssh&lt;/span&gt;-copy-&lt;span&gt;id&lt;/span&gt; xx.x.x.x    #xx.x.x.x为服务器B的ip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此，实现了服务器A到B的免密登陆&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.docker-machine创建主机&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在服务器A上输入&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker-machine create  -d  generic  --generic-ip-address=XX.X.X.X  host1      #XX.X.X.X为服务器B的ip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个过程会花费一些时间，等着就是了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装完成，通过docker-machine ls查看列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123134247990-996529239.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;53&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可以登陆到服务器B上，查看docker是否安装完成（docker-machine会给远程服务器B安装docker）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123134526723-1293398857.png&quot; alt=&quot;&quot; width=&quot;444&quot; height=&quot;372&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;5.变更服务器A的环境变量&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123134912845-1029715290.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;148&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变更之后，接下来的操作都将应用与服务器B&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;6.安装一个测试镜像&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123135205643-1206781350.png&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;133&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  并去服务器B上校验&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123135314440-1509972233.png&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;至此，docker-machine安装完毕，这样我们就可以通过一台服务器，创建多个主机，快速部署docker。但还是有点不方便，我们每次都要执行docker命令，为了解决这个问题，我们可以结合jinkins，实现自动部署。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; 7.设计jenkins+docker自动化部署&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123143628920-1692076435.png&quot; alt=&quot;&quot; width=&quot;1236&quot; height=&quot;337&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面开始实现这个想法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;1）在docker hub上新建一个账号（docker hub是一个可以上传自己的镜像的云端网站，作用与github相对于代码一样），测试账号登陆，并推送镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123140839558-1679246135.png&quot; alt=&quot;&quot; width=&quot;1061&quot; height=&quot;169&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;这样我们就可以把本地的镜像上传到docker hub，别人就可以拉取然后运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  上一章，我们新建了两个镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123141214997-820952015.png&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  我们把webdocker_s_provider推送到docker hub&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  首先要进行tag打标签，格式如下 docker   tag   镜像名   dockerhub用户名/镜像名，然后push，格式 docker   push  新的镜像名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123141701251-1317127214.png&quot; alt=&quot;&quot; width=&quot;841&quot; height=&quot;269&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;推送成功，我们登陆到dockerhub 查看一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123142803798-868107118.png&quot; alt=&quot;&quot; width=&quot;952&quot; height=&quot;424&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;我们可以登陆到服务器b，拉取一下，验证成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123142005910-1374552379.png&quot; alt=&quot;&quot; width=&quot;798&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  &lt;span&gt;2）创建项目，并创建Dockerfile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123140058446-1975716515.png&quot; alt=&quot;&quot; width=&quot;822&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;dockerfile内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; microsoft/dotnet:2.1&lt;span&gt;-aspnetcore-runtime
&lt;/span&gt;&lt;span&gt;MAINTAINER&lt;/span&gt;&lt;span&gt; yishi.chen

&lt;/span&gt;&lt;span&gt;LABEL&lt;/span&gt; description=&quot;microservice&quot;
&lt;span&gt;LABEL&lt;/span&gt; version=&quot;1.0&quot;

&lt;span&gt;ARG&lt;/span&gt;&lt;span&gt; microport

&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt; bin/Release/netcoreapp2.0&lt;span&gt;/publish/ .
&lt;/span&gt;&lt;span&gt;EXPOSE&lt;/span&gt;&lt;span&gt; $microport
&lt;/span&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&quot;dotnet&quot;,&quot;MicroService.dll&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;3）我们将.netcore代码上传到github（或私有git库，svn私有库）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;4）安装jenkins  &lt;a href=&quot;https://www.cnblogs.com/stulzq/p/9291237.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/stulzq/p/9291237.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  5）jenkins中新建一个freestyle project&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123140440202-2142294092.png&quot; alt=&quot;&quot; width=&quot;1060&quot; height=&quot;446&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 6.jenkins中配置新建的freestyle project &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123142304124-969629171.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123142352950-530435895.png&quot; alt=&quot;&quot; width=&quot;792&quot; height=&quot;429&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123143235559-390526749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;详细配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
dotnet publish -&lt;span&gt;c Release

docker build &lt;/span&gt;-t microtest:&lt;span&gt;1.0&lt;/span&gt; --build-arg microport=&lt;span&gt;1000&lt;/span&gt; -f &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$WORKSPACE/MicroService/Dockerfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$WORKSPACE/MicroService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

docker &lt;/span&gt;&lt;span&gt;login&lt;/span&gt; -u *** -p ****&lt;span&gt;

docker tag microtest:&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt; chenyishi/microtest:&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;

docker push chenyishi&lt;/span&gt;/microtest:&lt;span&gt;1.0&lt;/span&gt;

/usr/local/bin/docker-machine &lt;span&gt;env&lt;/span&gt;&lt;span&gt; host1

eval $(&lt;/span&gt;/usr/local/bin/docker-machine &lt;span&gt;env&lt;/span&gt;&lt;span&gt; host1)

docker pull chenyishi&lt;/span&gt;/microtest:&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;
docker run &lt;/span&gt;-d -p &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1000:1000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -e microport=&lt;span&gt;1000&lt;/span&gt; chenyishi/microtest:&lt;span&gt;1.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;保存后，点击buildnow&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123143338116-309849792.png&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;等待build成功，去dockhub上验证时候推送成功，去服务器B查看是否拉取成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201811/1033233-20181123143514727-1114705170.png&quot; alt=&quot;&quot; width=&quot;902&quot; height=&quot;88&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，实现了一个简单的跨主机的简单部署&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Fri, 23 Nov 2018 05:54:00 +0000</pubDate>
<dc:creator>老六代码</dc:creator>
<og:description>1.什么是Docker-machine 上一章讲了Docker-compose，主要是在一台服务器上编排镜像与容器。假如现在要求在两台服务器上部署容器，一般的做法是登陆到两台服务器分别部署，听起来也没</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenyishi/p/10007125.html</dc:identifier>
</item>
<item>
<title>带着萌新看springboot源码13（手写一个自己的starter） - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10006312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10006312.html</guid>
<description>&lt;p&gt;　　springboot的最强大的就是那些xxxAutoconfiguration，但是这些xxxAutoConfiguration又依赖那些starter，只有导入了这些场景启动器（starter），我们很多自动配置类才能有用，并且还会新增一些功能，&lt;/p&gt;
&lt;p&gt;　　这次就来一起写个简单的starter，来看看内部到底是什么原理！&lt;/p&gt;
&lt;p&gt;　　脑中大概有个印象：我们要用一个场景（比如web），直接导入下图所示的依赖，但是在jar包里面去看这个，你会发现里面只有一些基本的配置文件，什么类都没有，就能够想到这个一类就类似一个公司前台的作用，通过这个公司前台，能够联系到公司内部。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123111744526-612770809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123111925046-1590871588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;提前准备：必须要有IDEA模块化创建项目的基本操作，其他的随意&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　温馨提醒：对于会用模块的小伙伴，其实这里就是创建一个空项目，里面新建一个maven模块，一个springboot模块，springboot坐标丢到maven的pom里面，再删除一些多余的文件和依赖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.创建一个空的项目&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123112334765-1220501325.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　然后就会跳出下图这个页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123112820602-167968595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123112937099-54932011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123113121849-326043955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123113347393-197127017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　上面相当于前台创建好了，下面开始创建真正的东西了，继续创建模块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123113451754-258615620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123113646270-832995673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123114005002-1489875728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123114119274-28321636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123114357487-2012856495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　两个模块创建好了之后，将这两个模块联系起来（废话，公司前台肯定要有和上级的的通话方式啊）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123114759525-141115393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　导入依赖之后就是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123115104868-1829400210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　下一步就是在xxxautoconfiguration模块，删除一些没用的东西和依赖，但是一定要保留一个最基本的starter&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123115725856-586965633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123120004097-1358967144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;-----------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;　　到这里，基本的准备工作已经完成（其实会用模块式的直接能跳到这里来）&lt;/p&gt;
&lt;p&gt;　　记住：xxxstarter是前台，只是起到一个联系作用（所以我们基本不配置这个），没有什么其他功能，但是那个xxxautoconfiguration才是内部有实权的老板&lt;/p&gt;
&lt;p&gt;　　现在我们来做个老板出来，嘿嘿嘿！&lt;/p&gt;
&lt;p&gt;　　下面看我的目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123122434376-977962025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　从头到尾看一下这些类里面有什么&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第一个：HelloProperties&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123122648495-1912745909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　&lt;span&gt;&lt;strong&gt;　第二个：HelloWorld&lt;/strong&gt;&lt;/span&gt;（记住，此时这个类和properties类还没什么关系，必须要让第三方传入properties）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123134826537-200701203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　  &lt;strong&gt;&lt;span&gt;第三个HelloWorldAutoconfiguration&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123125915404-1456301179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;第四个.spring.factories文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123130157096-1097288228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;最后一步：把这两个安装到maven本地仓库&lt;/span&gt;&lt;/strong&gt;（&lt;strong&gt;&lt;span&gt;记得，先是xxautoconfiguration，然后再starter&lt;/span&gt;&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123130548786-1227782613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　另外一个starter一样的操作&lt;/p&gt;

&lt;p&gt;　　到此为止，一个简单的HelloWorid的starter就做出来了，我们只需要在我们的项目中导入那个starter（也就是前台唯一的作用）的依赖，就可以了，看看我的starter的坐标（还要记住，properties文件配置的@ConfigurationProperties(prefix = &quot;wyq.hello&quot;)，这个prefix是可以在我们项目里面配置文件配置属性的哦~~）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123131119930-1567545609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;&lt;strong&gt;　测试：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;file------&amp;gt;new-------&amp;gt;project,和以前用springboot一样，随便新建一个springboot应用（记住，一定要选择web模块，不然自动配置类作用，因为配置了@ConditionalOnWebApplication），导入上图的依赖&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123134045525-562958927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123140641104-895351499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123134139156-1328998315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　随便写个controller测试一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123134447880-2026973656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;测试成功&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;------------------------------------------------------------------------------------------------ &lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181123134530221-1308762776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;--------------------------------------------------------------------------------------------------&lt;/p&gt;

&lt;p&gt;　　到此结束，是不是觉得starter也就这样啊，挺好玩的一个东西，而且最重要的是这种设计的模式有点厉害！通过这样的设计，居然能够实现自动配置，果然是学海无涯啊，要不断的学习别人前辈造就出来的成果，站在巨人的肩膀上学习，我们才能走得更远啊！&lt;/p&gt;

</description>
<pubDate>Fri, 23 Nov 2018 05:52:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>springboot的最强大的就是那些xxxAutoconfiguration，但是这些xxxAutoConfiguration又依赖那些starter，只有导入了这些场景启动器（starter），我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10006312.html</dc:identifier>
</item>
<item>
<title>我用Python实现了一个小说网站雏形 - 小柒2012</title>
<link>http://www.cnblogs.com/smallSevens/p/10006986.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smallSevens/p/10006986.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201811/109211-20181123132507816-1171714258.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前段时间做了一个爬取妹子套图的小功能，小伙伴们似乎很有兴趣，为了还特意组建了一个Python兴趣学习小组，来一起学习。十个python九个爬，在大家的印象中好像Python只能做爬虫。然而并非如此，Python 也可以做Web开发，接下来给大家展示一下如何做一个小说站点。&lt;/p&gt;
&lt;h2 id=&quot;相关软件&quot;&gt;相关软件&lt;/h2&gt;
&lt;p&gt;环境搭建说明：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.runoob.com/python3/python3-install.html&quot; class=&quot;uri&quot;&gt;http://www.runoob.com/python3/python3-install.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;爬取数据&quot;&gt;爬取数据&lt;/h2&gt;
&lt;p&gt;做一个小说网站，内容是必须的，首先我们爬取一本小说《星辰变》到数据库。&lt;/p&gt;
&lt;p&gt;创建一个简单的数据库表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE `novel` (
   `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '自增主键',
   `title` varchar(100) NOT NULL COMMENT '标题',
   `content` text NOT NULL COMMENT '内容',
   PRIMARY KEY (`id`)
 ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装数据库驱动以及连接池：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 数据库驱动
pip install pymysql
# 数据库连接池
pip install DBUtils&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding: UTF-8 -*-
# 导入requests库
import requests
# 导入文件操作库

import codecs
from bs4 import BeautifulSoup
import sys
import mysql_DBUtils
from mysql_DBUtils import MyPymysqlPool
import importlib
importlib.reload(sys)


# 给请求指定一个请求头来模拟chrome浏览器
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36'}
server = 'http://www.biquge.cm'
# 星辰变地址
book = 'http://www.biquge.cm/2/2042/'
# 定义DB
mysql = MyPymysqlPool(&quot;dbMysql&quot;)


# 获取章节内容
def get_contents(chapter):
    req = requests.get(url=chapter)
    html = req.content
    html_doc = str(html, 'gbk')
    bf = BeautifulSoup(html_doc, 'html.parser')
    texts = bf.find_all('div', id=&quot;content&quot;)
    # 获取div标签id属性content的内容 \xa0 是不间断空白符 &amp;amp;nbsp;
    content = texts[0].text.replace('\xa0' * 4, '\n')
    return content


# 写入数据库
def write_db(chapter, content):
    sql = &quot;INSERT INTO novel (title, content) VALUES(%(title)s, %(content)s);&quot;
    param = {&quot;title&quot;: chapter, &quot;content&quot;: content}
    mysql.insert(sql, param)


# 主方法
def main():
    res = requests.get(book, headers=headers)
    html = res.content
    html_doc = str(html, 'gbk')
    # 使用自带的html.parser解析
    soup = BeautifulSoup(html_doc, 'html.parser')
    # 获取所有的章节
    a = soup.find('div', id='list').find_all('a')
    print('总章节数: %d ' % len(a))
    for each in a:
        try:
            chapter = server + each.get('href')
            content = get_contents(chapter)
            chapter = each.string
            write_db(chapter, content)
        except Exception as e:
            print(e)
    mysql.dispose()


if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多代码详见：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/52itstyle/Python/tree/master/Day04&quot; class=&quot;uri&quot;&gt;https://gitee.com/52itstyle/Python/tree/master/Day04&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;web实现&quot;&gt;Web实现&lt;/h2&gt;
&lt;p&gt;Django 是一个开放源代码的Web应用框架，由 Python 写成。采用了 MVC 的框架模式，即模型M，视图V和控制器C。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。&lt;/p&gt;
&lt;p&gt;Django 框架的核心组件有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用于创建模型的对象关系映射&lt;/li&gt;
&lt;li&gt;为最终用户设计的完美管理界面&lt;/li&gt;
&lt;li&gt;一流的 URL 设计&lt;/li&gt;
&lt;li&gt;设计者友好的模板语言&lt;/li&gt;
&lt;li&gt;缓存系统&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;创建项目&quot;&gt;创建项目&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;pip install Django
# 创建一个项目
python  django-admin.py startproject itstyle
# 切换目录
cd itstyle
# 创建App
python manage.py startapp novel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般一个项目有多个app, 当然通用的app也可以在多个项目中使用，然后启动服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 默认端口是8000
python manage.py runserver&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果提示端口被占用，可以用其它端口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py runserver 8001&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目结构&quot;&gt;项目结构&lt;/h2&gt;
&lt;p&gt;最终代码，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;│  manage.py
│  
├─novel

│  │  settings.py  # 基础配置
│  │  urls.py     # URL映射
│  │  wsgi.py
│  │  __init__.py
│  │  
│          
├─templates             # 相关页面
│      novel.html        # 章节
│      novel_list.html    # 小说首页
├─utils
│  │  dbMysqlConfig.cnf     # 数据库配置参数
│  │  encoder.py          # 编码类
│  │  mysql_DBUtils.py      # 数据库连接池
└─view
    │  index.py   # 后台业务&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;要点备注&quot;&gt;要点备注&lt;/h2&gt;
&lt;h3 id=&quot;restful-风格&quot;&gt;RESTful 风格&lt;/h3&gt;
&lt;p&gt;控制器 urls.py&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf.urls import url
from django.urls import path
from view import index

urlpatterns = [
    # 《星辰变》首页List
    path('', index.main),  # new
    # 章节页面 正则匹配 
    path('chapter/&amp;lt;int:novel_id&amp;gt;/', index.chapter),    # new
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.http import HttpResponse
from django.shortcuts import render
from utils.mysql_DBUtils import mysql


# 《星辰变》章节列表
def main(request):
    sql = &quot;SELECT id,title FROM novel LIMIT 10;&quot;
    result = mysql.getAll(sql)
    # result = json.dumps(result, cls=MyEncoder, ensure_ascii=False, indent=4)
    # result = json.loads(result)
    context = {'novel_list': result}
    return render(request, 'novel_list.html',  context)


# def chapter(request):
#     id = request.GET['id']
#     sql = &quot;SELECT content FROM novel where id = %(id)s;&quot;
#     param = {&quot;id&quot;: id}
#     result = mysql.getOne(sql, param)
#     context = {'novel': result}
#     return render(request, 'novel.html', context)

'''
单个章节
此处 novel_id 对应 urls.py 中的 &amp;lt;int:novel_id&amp;gt;
你可以访问：http://localhost:8000/chapter/1/
'''
def chapter(request, novel_id):
    sql = &quot;SELECT title,content FROM novel where id = %(id)s;&quot;
    param = {&quot;id&quot;: novel_id}
    result = mysql.getOne(sql, param)
    context = {'novel': result}
    return render(request, 'novel.html', context)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;列表展示&quot;&gt;列表展示&lt;/h3&gt;
&lt;p&gt;基于后端返回的数据，在前台进行展示，这里你可以把它想象成Java中的Struts2标签或者JSTL标签，当然也有点Vue的意思：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% for novel in novel_list %}
    &amp;lt;a href=&quot;/chapter/{{novel.id}} &quot;&amp;gt;&amp;lt;li&amp;gt;{{ novel.title }}&amp;lt;/li&amp;gt;&amp;lt;/a&amp;gt;
{% endfor %}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;至此，一个简单的Web项目雏形已经完成，当然还有很多需要优化的地方，小伙伴们可以关注从零学 Python，持续更新。&lt;/p&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://gitee.com/52itstyle/Python/tree/master/Day06/novel&quot; class=&quot;uri&quot; title=&quot;https://gitee.com/52itstyle/Python/tree/master/Day06/novel&quot;&gt;https://gitee.com/52itstyle/Python/tree/master/Day06/novel&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 05:25:00 +0000</pubDate>
<dc:creator>小柒2012</dc:creator>
<og:description>前言 前段时间做了一个爬取妹子套图的小功能，小伙伴们似乎很有兴趣，为了还特意组建了一个Python兴趣学习小组，来一起学习。十个python九个爬，在大家的印象中好像Python只能做爬虫。然而并非如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smallSevens/p/10006986.html</dc:identifier>
</item>
<item>
<title>【干货】基于Owin WebApi 使用OAuth2进行客户端授权服务 - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10006968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10006968.html</guid>
<description>&lt;p&gt;前言：采用Client Credentials方式，即密钥key/password,场景一般是分为客户端限制必须有权限才能使用的模块，这和微信公众号开放平台很类似。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181123093147305-1633952751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让用户通过客户端去获取自己的token，在根据这个token去获取资源。&lt;/p&gt;
&lt;h2&gt;本地登录凭据流&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;用户输入名称和密码到客户端。&lt;/li&gt;
&lt;li&gt;客户端将这些凭据发送到授权服务器。&lt;/li&gt;
&lt;li&gt;授权服务器验证凭据并返回访问令牌。&lt;/li&gt;
&lt;li&gt;要访问受保护资源，客户端在HTTP请求的Authorization标头中包含访问令牌。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;服务实现：&lt;/h2&gt;
&lt;p&gt;使用WebApi基于&lt;a href=&quot;https://www.nuget.org/packages/Microsoft.Owin.Security.OAuth&quot; target=&quot;_blank&quot;&gt;Microsoft.Owin.Security.OAuth&lt;/a&gt;实现，新建一个空为WebApi项目。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
using Microsoft.Owin.Security;
using Microsoft.Owin.Security.OAuth;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;
using System.Web;

namespace ApiThrottleDemo
{
    public class ApplicationOAuthProvider : OAuthAuthorizationServerProvider
    {

        /// &amp;lt;summary&amp;gt;
        /// 验证客户[client_id与client_secret验证]
        /// &amp;lt;/summary&amp;gt;
        public override Task ValidateClientAuthentication(OAuthValidateClientAuthenticationContext context)
        {
            //http://localhost:48339/token
            string client_id;
            string client_secret;
            context.TryGetFormCredentials(out client_id, out client_secret);
            if (client_id == &quot;zara&quot; &amp;amp;&amp;amp; client_secret == &quot;123456&quot;)
            {
                context.Validated(client_id);
            }
            else
            {
                //context.Response.StatusCode = Convert.ToInt32(HttpStatusCode.OK);
                context.SetError(&quot;invalid_client&quot;, &quot;client is not valid&quot;);
            }
            return base.ValidateClientAuthentication(context);
        }

        /// &amp;lt;summary&amp;gt;
        /// 客户端授权[生成access token]
        /// &amp;lt;/summary&amp;gt;
        public override Task GrantClientCredentials(OAuthGrantClientCredentialsContext context)
        {

            var oAuthIdentity = new ClaimsIdentity(context.Options.AuthenticationType);
            oAuthIdentity.AddClaim(new Claim(ClaimTypes.Name, &quot;iphone&quot;));
            var ticket = new AuthenticationTicket(oAuthIdentity, new AuthenticationProperties() { AllowRefresh = true });
            context.Validated(ticket);
            return base.GrantClientCredentials(context);
        }

        /// &amp;lt;summary&amp;gt;
        /// 刷新Token[刷新refresh_token]
        /// &amp;lt;/summary&amp;gt;
        public override Task GrantRefreshToken(OAuthGrantRefreshTokenContext context)
        {
            //enforce client binding of refresh token
            if (context.Ticket == null || context.Ticket.Identity == null || !context.Ticket.Identity.IsAuthenticated)
            {
                context.SetError(&quot;invalid_grant&quot;, &quot;Refresh token is not valid&quot;);
            }
            return base.GrantRefreshToken(context);
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在此其中呢，需要继承OAuthAuthorizationServerProvider,并重写自己想重写的方法，其内部定义下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181123094836043-1168795952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当然这还没完，我们还需要去配置应用程序。在Startup.cs，我们要开启BearerToken认证模式；该&lt;code&gt;Provider&lt;/code&gt;属性指定了一个插入OWIN中间件的提供程序，并处理由中间件引发的事件。&lt;/p&gt;
&lt;p&gt;以下是应用想要获取令牌时的基本流程：&lt;/p&gt;
&lt;p&gt;要获取访问令牌，应用程序会向〜/ Token发送请求。&lt;br/&gt;OAuth中间件调用GrantResourceOwnerCredentials提供程序。&lt;br/&gt;提供程序调用ApplicationUserManager以验证凭据并创建声明标识。&lt;br/&gt;如果成功，则提供程序会创建一个身份验证票证，用于生成令牌。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
app.UseOAuthBearerTokens(new OAuthAuthorizationServerOptions
            {
                TokenEndpointPath = new PathString(&quot;/token&quot;),
                Provider = new ApplicationOAuthProvider(),
                AccessTokenExpireTimeSpan = TimeSpan.FromHours(2),
                AuthenticationMode = AuthenticationMode.Active,
                AllowInsecureHttp = true
            });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中AccessTokenExpireTimeSpan参数是token过期时间，AllowInsecureHttp 是否开启安全验证，TokenEndpointPath就是你获取token对于服务器的相对路径,那我们都知道用户只能访问我们的Api,那如何在api上去走Oauth呢？&lt;/p&gt;
&lt;h3&gt;客户端获取票据&lt;/h3&gt;
&lt;p&gt;在控制器种创建一个控制器，命名为：OAuth2Controller。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 [RoutePrefix(&quot;api/v1/oauth2&quot;)]
    public class OAuth2Controller : ApiController
    {
        [Authorize]
        [Route(&quot;news&quot;)]
        public async Task&amp;lt;IHttpActionResult&amp;gt; GetNewsAsync()
        {
            var authentication = HttpContext.Current.GetOwinContext().Authentication;
            var ticket = authentication.AuthenticateAsync(&quot;Bearer&quot;).Result;

            var claimsIdentity = User.Identity as ClaimsIdentity;
            var data = claimsIdentity.Claims.Where(c =&amp;gt; c.Type == &quot;urn:oauth:scope&quot;).ToList();
            var claims = ((ClaimsIdentity)Thread.CurrentPrincipal.Identity).Claims;
            return Ok(new { IsError = true, Msg = string.Empty, Data = Thread.CurrentPrincipal.Identity.Name + &quot; It's about news !!! token expires: &quot; + ticket.Properties.Dictionary.ToString() });
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;启用授权验证[WebApiConfig]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在ASP.NET Web API中启用Token验证，需要加上[Authorize]标记，并且配置默认启用验证不记名授权方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
            config.SuppressDefaultHostAuthentication();
            config.Filters.Add(new HostAuthenticationFilter(OAuthDefaults.AuthenticationType));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;服务端[/token]获取token需要三个参数，我们使用大家熟悉的PostMan去试一试吧，启动项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181123101943017-2028929399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 那我们不难看到，已经成功获取了access_token，至于这个token的值，只要你的client_id不同它就一定是不会相同的(实在不行你可以搞个GUID)，那么我们再构建一个ajax去模拟的获取token吧。&lt;/p&gt;
&lt;p&gt; 做个简单的页面：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;http://libs.baidu.com/jquery/2.1.1/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;input type=&quot;text&quot; placeholder=&quot;client_id&quot;/&amp;gt;&amp;lt;br /&amp;gt;
    &amp;lt;input type=&quot;text&quot; placeholder=&quot;client_secret&quot;/&amp;gt;&amp;lt;br /&amp;gt;
    &amp;lt;input type=&quot;text&quot; placeholder=&quot;your_token&quot;/&amp;gt;&amp;lt;br /&amp;gt;
    &amp;lt;button&amp;gt;获取token&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
    $(function () {
        $(&quot;button&quot;).click(function () {
            $.ajax({
                url: &quot;http://localhost:58560/token&quot;,
                type: &quot;post&quot;,
                data: &quot;grant_type=client_credentials&amp;amp;client_id=zara&amp;amp;client_secret=123456&quot;,
                success: function (res) {
                    console.log(res);
                }
            })
        })
    })
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是生成的token。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181123112235054-1388908649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后总结，你可以在ValidateClientAuthentication中进行身份判断，如果有这个身份，那么我就存储DB中，这样的话，类似于一个微信身份授权的功能基本上就是这样了。&lt;/p&gt;
</description>
<pubDate>Fri, 23 Nov 2018 05:19:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>前言：采用Client Credentials方式，即密钥key/password,场景一般是分为客户端限制必须有权限才能使用的模块，这和微信公众号开放平台很类似。 让用户通过客户端去获取自己的tok</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10006968.html</dc:identifier>
</item>
</channel>
</rss>