<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>我的那些年(7)~第一份互联网工作 - 张占岭</title>
<link>http://www.cnblogs.com/lori/p/9505867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lori/p/9505867.html</guid>
<description>&lt;h3 id=&quot;我的那些年7第一份互联网工作&quot;&gt;&lt;span&gt;我的那些年(7)~第一份互联网工作&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;开始求职&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;面试asp，手动数据库curd操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;开始做项目&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;加班平常饭&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;拿到100元奖金&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;女友朋友的公司面试&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;公司老板卷钱跑路&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;开始求职&quot;&gt;&lt;span&gt;开始求职&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;2006年10月后，我和我女友都开始找新的工作了，我面试了几个公司都没有成功，一般都是觉得我学历太低了，虽然有两年多工作经验了，但都是当老师，没有在一线开发中工作过，所以这是我的不足，我继续找，利用早晚班空闲的时间去面试。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;面试asp手动数据库curd操作&quot;&gt;&lt;span&gt;面试asp，手动数据库curd操作&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;2006年11月，我去建外soho面试，面试官简单的问了几个问题后，直接上电脑上让我写代码，使用asp操作sqlserver数据库，手写驱动conn.inc，手写curd操作，这对于我这个当老师的人来说是没有任何难度的，当然面试的也是普通的开发人员，没有太多的要求，能写代码就OK了，很快我被直接录用了，这个好消息也第一时间告诉了女友，我拿3000块了！&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;那时对自己的编码能力比较自信，记得是用记事 本写的代码，简单的做了几个curd文件，一个conn.inc文件&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;开始做项目&quot;&gt;&lt;span&gt;开始做项目&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;和老公司辞行后，就去了新公司，老公司的校长也是进行了挽留，我也是委婉的拒绝了，新公司是个创业型小公司，没什么三险，五险之类的，大家基本也是扁平管理，按项目分组，项目经理带头，一个小组由后端开发，前端UI，测试组成，其中UI只设计PSD文件，后端开发负责切图，编写HTML，做asp后台等，每个项目都不大，平时加班不是很多，但项目上线时也要加到9点10点，然后坐公交回家，那时没有打车报销的说法。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;拿到100元奖金&quot;&gt;&lt;span&gt;拿到100元奖金&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;公司每周都会有头脑风暴，大家坐在一起对一个项目进行集思广义，有一次我还得了100元，我的主题是给应届毕业生一个工作的机会，这个主题与我的人生经历很有关系，自己那时毕业，找不到对口的工作，希望以后大学生，大专生，中专生毕业后，企业多给他们一些机会！&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;女友朋友的公司面试&quot;&gt;&lt;span&gt;女友朋友的公司面试&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;2007年5月，我来新公司半年多了，也成功转正了，我和女友合租一个平房，在一个院子里有个小女孩，她和我老婆玩的挺好的，平常总一起去买东西，吃吃饭，这个小女孩有个男友，他也经常过来，我们在一起时间长了就熟悉了，他知道我的做网站开发的，然后问我愿不愿意去他们公司，说是正在招这方面的人才，事实上也在建外soho，两个公司离的不远，我说可以去试试，下班后就直接去他们公司了，直接和老总谈，老总是河北人，为人爽快，对员工也非常好，我面试就是简单的聊了聊天，因为是内推的，同时他们公司也没有人懂这个，我就直接录用了，公司也是没有保险，谈的是4300的月薪，我挺开心的，第一次突破自我了！&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;能够找到最高薪的工作是好事 ，但是否选择正确就只能看以后的，事实证明我的选择是错误的&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;公司老板卷钱跑路&quot;&gt;&lt;span&gt;公司老板卷钱跑路&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在我向公司辞职时，经理也是挽留了我，但在我拿到薪水时，我很失望，财物说因为是我主动辞职的，所以只能合我半个月薪水，这事要是放在现在，早到劳动局告他们了，这个公司在之后的几年我也关注过，在百度上查时，说是他们老总卷钱跑路了，这种贼人老板真是可恶，看来当处少给我开钱肯定是他的意思，挺歹毒的，现在是全球通缉的对象！&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;这种害人的老板抓到后应该枪毙1万次，估计有更多的人上当受骗了&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;总结&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在这个公司里，我的技术得到了真正的应用，同时也出现了很多问题，不过最后也都解决了，那时使用了这些技术：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;IIS缓存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;HTML静态缓存&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据库连接对象解耦&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据库索引&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;curd操作语句的拼接&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 20 Aug 2018 07:40:00 +0000</pubDate>
<dc:creator>张占岭</dc:creator>
<og:description>我的那些年(7)~第一份互联网工作 开始求职 面试asp，手动数据库curd操作 开始做项目 加班平常饭 拿到100元奖金 女友朋友的公司面试 公司老板卷钱跑路 总结 开始求职 2006年10月后，我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lori/p/9505867.html</dc:identifier>
</item>
<item>
<title>react-native使用redux 存在的坑 - 大禹不治水</title>
<link>http://www.cnblogs.com/rion1234567/p/9505859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rion1234567/p/9505859.html</guid>
<description>&lt;p&gt;前几天安卓真机测试的时候，突然发现一个严重的问题。&lt;/p&gt;
&lt;p&gt;后退两次退出应用，再开启白屏。而杀掉进程后再开启就是好的。&lt;/p&gt;
&lt;p&gt;这个重大bug我跟了好久，以为是splash-screen的问题。&lt;/p&gt;
&lt;p&gt;后来一点一点打console，才找出问题————redux在后退两次退出时，未重置，而保留了退出前的状态值。&lt;/p&gt;
&lt;p&gt;我不知道为什么。&lt;/p&gt;
&lt;p&gt;我的页面一开始进入需要判断用户是否登录和其他属性来决定第一个页面的展示。&lt;/p&gt;
&lt;p&gt;当我两次退出时，登录状态没有改变，而接口也没有去掉，导致回调函数也不执行，也就不会显示跳转页面。&lt;/p&gt;
&lt;p&gt;我的解决办法就是两次退出的时候，手动将登录状态管理的逻辑重置。。。。。。（很low，嗯）&lt;/p&gt;
</description>
<pubDate>Mon, 20 Aug 2018 07:39:00 +0000</pubDate>
<dc:creator>大禹不治水</dc:creator>
<og:description>前几天安卓真机测试的时候，突然发现一个严重的问题。 后退两次退出应用，再开启白屏。而杀掉进程后再开启就是好的。 这个重大bug我跟了好久，以为是splash-screen的问题。 后来一点一点打con</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rion1234567/p/9505859.html</dc:identifier>
</item>
<item>
<title>ES6的小知识（后半部分） - cher。</title>
<link>http://www.cnblogs.com/ninefrom/p/9505759.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ninefrom/p/9505759.html</guid>
<description>&lt;p&gt;&lt;span&gt;一、iterator和for-of循环&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在js里有数组和对象，es6又新出现了set和map这样js就有了四种数据集合，这样可以组合使用他们，比如数组里拥有对象，set等，这样就需要一个统一的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接口机制来处理不同的数据结构，iterator就是这样的接口，它为不同的数据结构提供统一的访问机制，任何数据结构只要部署iterator接口就可以遍历操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他们，并且iterator接口主要供for...of遍历&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;iterator接口&lt;/span&gt;

&lt;span&gt;const&lt;/span&gt; arr = [1,2&lt;span&gt;];

function iterator(arr){
  let index &lt;/span&gt;= 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
   next:function(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; index &amp;lt;  arr.length ? {value:arr[index++],done:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;}:
    {value:undefined,done:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;}  
  }      
 }  
}

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; it =&lt;span&gt; iterator(arr);
console.log(it.next());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{value:1,done:false}&lt;/span&gt;
console.log(it.next());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{value:2,done:false}&lt;/span&gt;
console.log(it.next());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{value:undefined,done:true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;二、class类的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;es6添加了class，使ECMAScript语法更偏向于后台语言&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Cher{
 constructor(a,b){
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a =&lt;span&gt; a;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.b =&lt;span&gt; b;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
 }
 chun(){
  console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a +'===='+ &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.b);
 }
}

const cher &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Cher('111','222'&lt;span&gt;);
cher.chun(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;111====222&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里面，constructor方法是构造方法，一个类里必须要有constructor，如果没有，它会默认添加一个空的constructor，this代表着实例对象，里面还有一个chun方法，前面是不需要加function关键字的，方法之间是不需要逗号隔开，否则会报错，创建实例对象的时候是和es5一样的，必须要加new，否则也是会报错的&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三、内置对象的扩展&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、字符串的扩展&lt;/p&gt;
&lt;p&gt;字符串添加了一个模板字符串（超级字符串），那就是反引号，并且换行的时候不在需要繁琐的加号连接，而且在字符串里有变量的时候也不需要加号连接，只需要使用&lt;/p&gt;
&lt;p&gt;${}操作就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;html代码&lt;/span&gt;
&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;js代码&lt;/span&gt;
let str = 'o'&lt;span&gt;;

document.getElementsByTagName(&lt;/span&gt;'p')[0].innerHTML = `hell${str},world!!!`  //hello,world!!!
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;并且还添加了一些字符串的方法：&lt;/p&gt;
&lt;p&gt;repeat：对字符串进行重复的操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let str1 = '1'&lt;span&gt;;
let str2 &lt;/span&gt;= str1.repeat(5&lt;span&gt;);
console.log(str2);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;11111&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;includes()、startWith()、endWith()分别是查看是否含有某个字符串，字符串里的开始部分是否含有某个字符串，字符串的结尾部分是否含有某个字符串，他们返回的是一个布尔值&lt;/p&gt;

&lt;p&gt;2、数组的扩展&lt;/p&gt;
&lt;p&gt;Array.from()：把类数组变成数组&lt;/p&gt;
&lt;p&gt;类数组最常见的就是js选择一组元素标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let aP = document.getElementsByTagName('p'&lt;span&gt;);
console.log(Array.isArray(aP));  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
let ap =&lt;span&gt; Array.from(aP);
console.log(Array.isArray(ap));  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Array.of()：创造一个数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const arr =&lt;span&gt; Array.of(a);
console.log(arr)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[a]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;fill():数组填充，第一个参数是填充的字符串，也可以有第二个参数是从什么位置开始填充（可以没有第二个参数）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const arr = ['a','b','c'&lt;span&gt;];
arr.fill(&lt;/span&gt;'abc'&lt;span&gt;); 
console.log(arr) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;['abc','abc','abc']&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;find()、findIndex() ： 对数组进行赛选&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const arr = [1,2,3,4,5&lt;span&gt;];

let arr1 &lt;/span&gt;= arr.find(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a){
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a &amp;gt; 3&lt;span&gt;;
})
console.log(arr1); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4,5如果没有找到符合条件的值就返回-1&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;findIndex()他返回的是下标,没有找到的话返回undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、对象的扩展&lt;/p&gt;
&lt;p&gt;对象的简洁表示法&lt;/p&gt;
&lt;p&gt;如果对象的属性和值一样的话可以写成let obj = {a}；函数的话可以写成handler(){...};&lt;/p&gt;

&lt;p&gt;Object.assign()：对象的合并。将一个对象里的所有可以枚举的属性，复制到另一个对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let obj1 = {x:1&lt;span&gt;};
let obj2 &lt;/span&gt;= {y:1&lt;span&gt;};
Object.assign(obj1,obj2);
console.log(obj1); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{x:1,y:1}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Object.is()看俩个值是否一样，返回布尔值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
console.log(Object.is(1,1));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
console.log(Object.is(Infinity,-Infinity)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
console.log(Object.is(NaN,NaN));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
console.log(Object.is(-0,+0));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;四、函数的扩展&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、函数的参数指定默认值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; handler(x,y = 1){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;y设置了一个默认值1&lt;/span&gt;
  console.log(x +&lt;span&gt; y);  
}
handler(&lt;/span&gt;3);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、rest参数&lt;/p&gt;
&lt;p&gt;rest参数的形式是&quot;...变量名&quot;，获取函数多余的参数，这样就不需要arguments对象了，rest参数搭配的变量是一个数组，该变量将多余的参数放入数组里&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; hander(...arr) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以在arr前面加参数，但是后面不可以加参数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; sum = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;arr.length;i++&lt;span&gt;){
        sum &lt;/span&gt;+=&lt;span&gt; arr[i];
    }
    console.log(sum);
}

hander(&lt;/span&gt;1,2,3)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、箭头函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const hander2 = &lt;span&gt;function&lt;/span&gt; (x) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通函数&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
}

const hander1 &lt;/span&gt;= x =&amp;gt; x; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;箭头函数&lt;/span&gt;
&lt;span&gt;
console.log(hander1(&lt;/span&gt;1&lt;span&gt;))
console.log(hander2(&lt;/span&gt;1&lt;span&gt;)) 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;俩函数是一样的&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;箭头函数里没有自己的this对象，使用的时候，里面的this就是定义环境的对象，而不是使用时的对象&lt;/p&gt;
&lt;p&gt;箭头函数里没有arguments对象，可以有rest&lt;/p&gt;
&lt;p&gt;箭头函数不可以用作构造函数，不可以使用new操作，否则会报错&lt;/p&gt;
&lt;p&gt;箭头函数不能用作Generator函数&lt;/p&gt;

</description>
<pubDate>Mon, 20 Aug 2018 07:25:00 +0000</pubDate>
<dc:creator>cher。</dc:creator>
<og:description>一、iterator和for-of循环 在js里有数组和对象，es6又新出现了set和map这样js就有了四种数据集合，这样可以组合使用他们，比如数组里拥有对象，set等，这样就需要一个统一的 接口机</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ninefrom/p/9505759.html</dc:identifier>
</item>
<item>
<title>KVO原理解析 - 国孩</title>
<link>http://www.cnblogs.com/guohai-stronger/p/9473551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guohai-stronger/p/9473551.html</guid>
<description>&lt;p&gt;KVO在我们项目开发中，经常被用到，但很少会被人关注，但如果面试一些大公司，针对KVO的面试题可能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;知道KVO嘛，底层是怎么实现的？&lt;/li&gt;
&lt;li&gt;如何动态的生成一个类？&lt;/li&gt;
&lt;li&gt;可不可以自己写一个KVO？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;今天我们围绕上面几个问题，我们先看KVO底层实现原理，以及怎么自己写一个KVO？&lt;/p&gt;

&lt;h2&gt;一、KVO&lt;/h2&gt;
&lt;h3&gt;1. KVO定义&lt;/h3&gt;
&lt;p&gt;KVO：可以监听一个对象的某个属性是否发生了改变，或者通知其他对象的指定属性发生了改变。&lt;/p&gt;

&lt;h3&gt;2.KVO实现&lt;/h3&gt;
&lt;h4&gt;2.1 监听某个对象的属性&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable &lt;span&gt;void&lt;/span&gt; *)context;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.2 实现协议&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable &lt;span&gt;id&lt;/span&gt;)&lt;span&gt;object&lt;/span&gt; change:(nullable NSDictionary *)change context:(nullable &lt;span&gt;void&lt;/span&gt; *)context;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.3 移除监听&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是一个简单的演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidLoad {
    [super viewDidLoad];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do any additional setup after loading the view, typically from a nib.&lt;/span&gt;
&lt;span&gt;     
    self.person &lt;/span&gt;=&lt;span&gt; [[ZJPerson alloc] init];
   
    [self.person setName:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;zhangsan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
   
    [self.person addObserver:self forKeyPath:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; options:NSKeyValueObservingOptionNew |&lt;span&gt; NSKeyValueObservingOptionOld context:nil];
     
}
 
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)&lt;span&gt;event&lt;/span&gt;&lt;span&gt;{
    [self.person setName:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;lisi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
}
 
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)observeValueForKeyPath:(NSString *)keyPath ofObject:(&lt;span&gt;id&lt;/span&gt;)&lt;span&gt;object&lt;/span&gt; change:(NSDictionary *)change context:(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)context{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, change);
}
 
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)dealloc{
    [self.person removeObserver:self forKeyPath:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1305302/201808/1305302-20180820112738045-1593698505.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过以上demo，我们来思考KVO为什么能监听到属性变化，底层又是怎么样实现的呢？&lt;/p&gt;

&lt;h3&gt;3. KVO底层实现&lt;/h3&gt;
&lt;p&gt;在查看KVO底层实现，我们首先用runtime在添加监听之前以及之后的类对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; NSLog(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, object_getClass(self.person));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; [self.person addObserver:self forKeyPath:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; options:NSKeyValueObservingOptionNew |&lt;span&gt; NSKeyValueObservingOptionOld context:nil];
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; NSLog(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, object_getClass(self.person));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以查看结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;:&lt;span&gt;18.726028&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; KVO[&lt;span&gt;33804&lt;/span&gt;:&lt;span&gt;3059947&lt;/span&gt;&lt;span&gt;] ZJPerson
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt;:&lt;span&gt;18.726535&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; KVO[&lt;span&gt;33804&lt;/span&gt;:&lt;span&gt;3059947&lt;/span&gt;] NSKVONotifying_ZJPerson
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面发现，添加监听之后，实例对象的类对象发生了改变，系统自动为我们动态添加了一个NSKVONotifying_+类名的类，改变属性的值是通过setter方法进行实现，很明显是系统已经动态生成了NSKVONotifying_ZJPerson类，并重写了setter方法，所以不可以创建NSKVONotifying_ZJPerson类了，如果创建了NSKVONotifying_ZJPerson类，会报以下错误：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;19&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt;:&lt;span&gt;32.223288&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; KVO[&lt;span&gt;33919&lt;/span&gt;:&lt;span&gt;3068985&lt;/span&gt;] [general] KVO failed to allocate &lt;span&gt;class&lt;/span&gt; pair &lt;span&gt;for&lt;/span&gt; name NSKVONotifying_ZJPerson, automatic key-value observing will not work &lt;span&gt;for&lt;/span&gt; &lt;span&gt;this&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;错误提示的是：创建NSKVONotifying_ZJPerson失败。&lt;/p&gt;

&lt;p&gt;那么问题又来了，重写的setter方法内部又做了什么？我们再次利用runtime打印下面方法的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1305302/201808/1305302-20180820141525691-339666821.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面发现，发现内部调用了Foundation框架的_NSSetObjectValueAndNotify方法，我们再次看看_NSSetObjectValueAndNotify内部的实现过程如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;. `-&lt;span&gt;[NSObject(NSKeyValueObservingPrivate) _changeValueForKey:key:key:usingBlock:]:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;. -&lt;span&gt;[NSObject(NSKeyValueObservingPrivate) _changeValueForKeys:count:maybeOldValuesDict:usingBlock:]:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;. [ZJPerson setName:];
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;. `NSKeyValueDidChange:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;. `NSKeyValueNotifyObserver:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;. - (&lt;span&gt;void&lt;/span&gt;)observeValueForKeyPath:ofObject:change:context
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简化成伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;)setName:(NSString *&lt;span&gt;)name{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    _NSSetObjectValueAndNotify();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; _NSSetObjectValueAndNotify {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     [self willChangeValueForKey:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    [super setName:name];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     [self didChangeValueForKey:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;  
&lt;span&gt;11&lt;/span&gt; - (&lt;span&gt;void&lt;/span&gt;)didChangeValueForKey:(NSString *&lt;span&gt;)key{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    [observe observeValueForKeyPath:key ofObject:self change:nil context:nil];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;拓展》〉》NSKVONotifying_ZJPerson内部重写了方法？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;利用runtime打印方法列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; Method *methods = class_copyMethodList(object_getClass(self.person), &amp;amp;&lt;span&gt;count);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (NSInteger index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; count; index++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    Method method =&lt;span&gt; methods[index];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    
&lt;span&gt; 7&lt;/span&gt;    NSString *methodStr =&lt;span&gt; NSStringFromSelector(method_getName(method));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    
&lt;span&gt; 9&lt;/span&gt;    NSLog(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, methodStr);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;08&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt;:&lt;span&gt;07.883400&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; KVO[&lt;span&gt;35888&lt;/span&gt;:&lt;span&gt;3218908&lt;/span&gt;&lt;span&gt;] setName:
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;08&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt;:&lt;span&gt;07.883571&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; KVO[&lt;span&gt;35888&lt;/span&gt;:&lt;span&gt;3218908&lt;/span&gt;] &lt;span&gt;class&lt;/span&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;08&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt;:&lt;span&gt;07.883676&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; KVO[&lt;span&gt;35888&lt;/span&gt;:&lt;span&gt;3218908&lt;/span&gt;&lt;span&gt;] dealloc
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;08&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt;:&lt;span&gt;07.883793&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; KVO[&lt;span&gt;35888&lt;/span&gt;:&lt;span&gt;3218908&lt;/span&gt;] _isKVOA
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;二、如何动态生成类&lt;/h2&gt;
&lt;p&gt;说到动态生成一个类，也就是利用了苹果的runtime机制，下面我们来动态创建生成类。&lt;/p&gt;
&lt;h3&gt;2.1 创建类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Class customClass = objc_allocateClassPair([NSObject &lt;span&gt;class&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZJCustomClass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.2 添加实例变量&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加实例变量&lt;/span&gt;
    class_addIvar(customClass, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;2.3 添加方法，V@:表示方法的参数和返回值&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    class_addMethod(customClass, @selector(hahahha), (IMP)hahahha, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;V@:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;需要实现的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; hahahha(&lt;span&gt;id&lt;/span&gt;&lt;span&gt; self, SEL _cmd)
{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;hahahha====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}
 
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)hahahha{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后注册到运行时环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
objc_registerClassPair(customClass);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面是打印方法列表以及成员变量列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; mark - Util
&lt;span&gt; 2&lt;/span&gt;  
&lt;span&gt; 3&lt;/span&gt; - (NSString *&lt;span&gt;)copyMethodsByClass:(Class)cls{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     Method *methods = class_copyMethodList(cls, &amp;amp;&lt;span&gt;count);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     NSString *methodStrs = &lt;span&gt;@&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (NSInteger index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; count; index++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Method method =&lt;span&gt; methods[index];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         
&lt;span&gt;12&lt;/span&gt;         NSString *methodStr =&lt;span&gt; NSStringFromSelector(method_getName(method));
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 
&lt;span&gt;14&lt;/span&gt;         methodStrs = [NSString stringWithFormat:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, methodStr];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    free(methods);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;      
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodStrs;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  
&lt;span&gt;22&lt;/span&gt; - (NSString *&lt;span&gt;)copyIvarsByClass:(Class)cls{
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     Ivar *ivars = class_copyIvarList(cls, &amp;amp;&lt;span&gt;count);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     
&lt;span&gt;26&lt;/span&gt;     NSMutableString *ivarStrs = [NSMutableString &lt;span&gt;string&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;      
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (NSInteger index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; count; index++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         Ivar ivar =&lt;span&gt; ivars[index];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         
&lt;span&gt;31&lt;/span&gt;         NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取成员变量的名字&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         
&lt;span&gt;33&lt;/span&gt;         NSString *ivarType = [NSString stringWithUTF8String:ivar_getTypeEncoding(ivar)]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取成员变量的数据类型&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         
&lt;span&gt;35&lt;/span&gt;         [ivarStrs appendString:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        [ivarStrs appendString:ivarName];
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         [ivarStrs appendString:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        [ivarStrs appendString:ivarType];
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;          
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;      
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    free(ivars);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;    
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ivarStrs;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、自己动手写一个KVO&lt;/h2&gt;
&lt;p&gt;给NSObject添加一个Category，NSObject+KVO监听方法&lt;/p&gt;
&lt;h3&gt;3.1 .h文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;Foundation/Foundation.h&amp;gt;

&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; NSObject (MY_KVO)

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)My_addObserver:(NSObject *_Nonnull)observer forKeyPath:(NSString *_Nonnull)keyPath options:(NSKeyValueObservingOptions)options context:(nullable &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)context;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.2  .m实现文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NSObject+MY_KVO.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MY_KVONotifying_Person.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;objc/runtime.h&amp;gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; NSObject (MY_KVO)

&lt;/span&gt;-(&lt;span&gt;void&lt;/span&gt;)My_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)context{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改isa指针(runtime) 系统的MY_KVONotifying_Person这个类是动态生成的,我们直接手动创建&lt;/span&gt;
&lt;span&gt;
    object_setClass(self, [MY_KVONotifying_Person &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;]);

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给对象动态添加属性,之前文章介绍过了.目的是保存observer,好在set方法里面拿到,调用&lt;/span&gt;
&lt;span&gt;
My_addObserver:forKeyPath:options:context:这个方法

    objc_setAssociatedObject(self, (__bridge &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)(keyPath), observer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);

}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.3 重写MY_KVONotifying_Person set方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MY_KVONotifying_Person.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NSObject+MY_KVO.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;objc/runtime.h&amp;gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; MY_KVONotifying_Person
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)setAge:(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)age{

   &lt;/span&gt;&lt;span&gt;id&lt;/span&gt; observer = objc_getAssociatedObject(self, &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (observer &amp;amp;&amp;amp;&lt;span&gt; [observer respondsToSelector:@selector(My_addObserver:forKeyPath:options:context:)]) {

        [observer My_addObserver:observer forKeyPath:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; options:NSKeyValueObservingOptionNew context:nil];

    }
    [super setAge:age];
}

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3.4 使用&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ViewController.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Person.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NSObject+MY_KVO.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; ViewController ()
@property (nonatomic,strong)Person &lt;/span&gt;*&lt;span&gt; p;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; ViewController
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)viewDidLoad {
    [super viewDidLoad];
    Person &lt;/span&gt;* p =&lt;span&gt;[[Person alloc] init];
    [p My_addObserver:self forKeyPath:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; options:NSKeyValueObservingOptionNew context:nil];
    _p&lt;/span&gt;=&lt;span&gt; p;
}

&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)My_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;)context{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;age++ 自己的KVO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

}
&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)touchesBegan:(NSSet&amp;lt;UITouch *&amp;gt; *)touches withEvent:(UIEvent *)&lt;span&gt;event&lt;/span&gt;&lt;span&gt;{
     _p.age &lt;/span&gt;++&lt;span&gt; ;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意点：修改Xcode 的一个配置，设为NO&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1305302/201808/1305302-20180820145743369-9077427.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上就是KVO的基本内容，希望通过本篇博客，大家对KVO原理以及基本使用有更深的了解！！！&lt;/p&gt;
</description>
<pubDate>Mon, 20 Aug 2018 07:02:00 +0000</pubDate>
<dc:creator>国孩</dc:creator>
<og:description>KVO在我们项目开发中，经常被用到，但很少会被人关注，但如果面试一些大公司，针对KVO的面试题可能如下： 知道KVO嘛，底层是怎么实现的？ 如何动态的生成一个类？ 可不可以自己写一个KVO？ 今天我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guohai-stronger/p/9473551.html</dc:identifier>
</item>
<item>
<title>Android项目刮刮奖详解（二） - Stars-one</title>
<link>http://www.cnblogs.com/kexing/p/9502029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kexing/p/9502029.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kexing/p/9501933.html&quot;&gt;Android项目刮刮奖详解（一）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上期我们简单地实现了一个画板的功能，用户可以在上面乱写乱画，其实，刮刮奖也是如此，用户刮奖的时候也是乱写乱画的。&lt;/p&gt;
&lt;h2 id=&quot;刮刮奖原理&quot;&gt;刮刮奖原理&lt;/h2&gt;
&lt;p&gt;一共有两层画布，底层画布存放中奖信息的图片，上层画布则是一个遮盖层，我们将底层画布成为信息层，上层画布称作为遮盖层。&lt;br/&gt;用户再遮盖层涂画，我们将用户涂画的痕迹从遮盖层擦除，显示出信息层的内容，则就实现了一个简单的刮刮奖。&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;基于上期的代码，我们来讲解一下。&lt;br/&gt;上一期中在注释中我也有提示到哪些代码是今天的内容，我们拿来看看吧。&lt;/p&gt;
&lt;ol readability=&quot;18&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;设置背景图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，我们需要设置信息层的背景图，背景图随意，记得把图片放在drawable文件夹中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  //背景图
 BitmapDrawable bitmap = (BitmapDrawable) getResources().getDrawable(R.drawable.rewrite6);//从drawable文件夹中获得指定名称的该图片，并转型为bitmapdrawable，R.drawable.xxx
 background = bitmap.getBitmap();//bitmapdrawable通过getBItmap方法得到bitmap
 background = Bitmap.createScaledBitmap(background,width,height,true);//利用Bitmap的静态方法创建一个合适的bitmap（宽高都是之前onMeasure方法中获取的，不太清楚的同学请去上期回顾一下）&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;35&quot;&gt;
&lt;p&gt;&lt;strong&gt;使用canvas画出背景图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充 xfermode&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Xfermode国外有大神称之为过渡模式，这种翻译比较贴切但恐怕不易理解，大家也可以直接称之为图像混合模式，因为所谓的“过渡”其实就是图像混合的一种，这个方法跟我们上面讲到的setColorFilter蛮相似的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;查看API文档发现其果然有三个子类：AvoidXfermode, PixelXorXfermode和PorterDuffXfermode，这三个子类实现的功能要比setColorFilter的三个子类复杂得多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;由于AvoidXfermode, PixelXorXfermode都已经被标注为过时了，所以这次主要研究的是仍然在使用的PorterDuffXfermode：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;该类同样有且只有一个含参的构造方法PorterDuffXfermode(PorterDuff.Mode mode)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其中的mode有十八种模式，后面谷歌又添加了Add和Overlayl两种模式，下面是十六种模式的图解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201808/1210268-20180819212538692-439373127.png&quot; alt=&quot;xfermode16种模式图解&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们怎么去理解这张图呢？我们只要记住一点，先画dst，再画src,有同学说不好记啊，简单，教你个口诀，先画底（dst），再画上（src）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个模式clear是清除&lt;/li&gt;
&lt;li&gt;第二个src则是只显示上层图片&lt;/li&gt;
&lt;li&gt;第三个dst则是只显示底层图片&lt;/li&gt;
&lt;li&gt;第四个srcOver如图所示，显示出dst图片的四分之三，显示src的全部&lt;/li&gt;
&lt;li&gt;其他的不多说了，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们即将用到的是dsc_out,讲解一下&lt;/p&gt;
&lt;p&gt;先画dst，再画src，src消失，只剩下dst，这其实就是橡皮擦的原理，我们利用这个擦除遮盖层就可以显示出信息层中的图片了&lt;/p&gt;
&lt;p&gt;明白了原理之后，我们来看onDraw方法，在onDraw方法中，使用canvas将背景图画出，这里顺序是先画信息层，之后再到遮盖层，遮盖层将mBitmap直接画出来，回顾一下，这里是使用到了双缓冲技术，canvas直接复制了mBitmap，在View中显示出来，mBitmap其实是mCanvas在上面画出了用户手指的移动痕迹&lt;br/&gt;canvas.drawBitmap(background,0,0,null);//画出信息层&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; canvas.drawBitmap(mBitmap, 0,0, null);//画出遮盖层
 mOutterPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_OUT));//设置xfermode dst\_out
 mCanvas.drawPath(mPath, mOutterPaint);//mCanvas在mBitmap中画出用户的手指的移动痕迹&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;测试图片&quot;&gt;测试图片&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1210268/201808/1210268-20180819215537404-1605346281.gif&quot; alt=&quot;测试图片&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Aug 2018 06:58:00 +0000</pubDate>
<dc:creator>Stars-one</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kexing/p/9502029.html</dc:identifier>
</item>
<item>
<title>入门系列之在Ubuntu上安装Drone持续集成环境 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/9504266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/9504266.html</guid>
<description>&lt;p&gt;&lt;strong&gt;欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.7592592592593&quot;&gt;
&lt;p&gt;本文由&lt;a href=&quot;https://cloud.tencent.com/developer/user/1221462?fromSource=waitui&quot;&gt;小铁匠米兰的v&lt;/a&gt; 发表于&lt;a href=&quot;https://cloud.tencent.com/developer/column/1417?fromSource=waitui&quot;&gt;云+社区专栏&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://drone.io/&quot;&gt;Drone&lt;/a&gt;是一个流行的持续集成和交付平台。它集成了许多流行的版本控制存储库服务，如GitHub，GitLab和Bitbucket，以监视代码更改并在提交时自动构建和测试更改。&lt;/p&gt;
&lt;p&gt;在本教程中，我们将演示如何为您的设置完整的Drone持续集成环境。我们将配置受&lt;a href=&quot;https://cloud.tencent.com/product/ssl&quot;&gt;腾讯云SSL&lt;/a&gt;保护的Nginx作为Drone的前端。加密对Drone Web界面的请求，并允许CI服务器与源代码服务器安全地集成。&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;strong&gt;准备&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;要完成本教程，您需要一台已经设置好可以使用&lt;code&gt;sudo&lt;/code&gt;命令的非root账号的CentOS&lt;strong&gt;服务器&lt;/strong&gt;，并且已开启防火墙。没有服务器的同学可以在&lt;a href=&quot;https://cloud.tencent.com/product/cvm&quot;&gt;这里购买&lt;/a&gt;，不过我个人更推荐您使用&lt;strong&gt;免费&lt;/strong&gt;的腾讯云&lt;a href=&quot;https://cloud.tencent.com/developer/labs&quot;&gt;开发者实验室&lt;/a&gt;进行试验，学会安装后在&lt;a href=&quot;https://cloud.tencent.com/product/cvm&quot;&gt;购买服务器&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;为了加密传输的内容，您还需要SSL证书，&lt;strong&gt;如何设置此&lt;/strong&gt;证书**取决于你是否拥有可解析该服务器的域名。&lt;/p&gt;
&lt;p&gt;同时，您还需要提前安装好Docker、学会使用Docker Compose，并在你的服务器上安装好Nginx，学会配置SSL证书，具体教程如下：&lt;/p&gt;
&lt;p&gt;完成上述教程后，您的Drone服务器应具有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sudo为管理任务配置的用户&lt;/li&gt;
&lt;li&gt;启用了UFW防火墙，阻止除端口22,80和443上的SSH，HTTP和HTTPS请求之外的所有连接。&lt;/li&gt;
&lt;li&gt;已安装Docker和Docker Compose。&lt;/li&gt;
&lt;li&gt;Nginx服务器配置了由腾讯云提供的SSL证书&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来我们继续安装教程。&lt;/p&gt;
&lt;h2 id=&quot;将程序添加到源码存储库&quot;&gt;&lt;strong&gt;将程序添加到源码存储库&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;为了监视代码更改以触发构建和测试阶段，Drone将需要访问您的源代码存储库。Drone可以与&lt;em&gt;GitHub&lt;/em&gt;，&lt;em&gt;GitLab&lt;/em&gt;，&lt;em&gt;Gogs&lt;/em&gt;，&lt;em&gt;Bitbucket Cloud&lt;/em&gt;和&lt;em&gt;Bitbucket Server&lt;/em&gt;集成。&lt;/p&gt;
&lt;p&gt;在本教程中，我们将重点关注与GitHub存储库的集成，其他系统应该与本教程类似。如果您使用的是其他源代码存储库，请按照上面的相应链接了解您需要的软件特定配置。&lt;/p&gt;
&lt;p&gt;首先访问您的&lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt;帐户。点击右上角的用户图标，然后从下拉菜单中选择&lt;strong&gt;设置&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1221462/a30zaq7xoe.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，在屏幕左侧的“ &lt;strong&gt;开发人员设置”&lt;/strong&gt;部分中找到&lt;strong&gt;OAuth应用程序&lt;/strong&gt;项：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1221462/nlrxi3usvi.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在随后的页面上，单击“ &lt;strong&gt;注册新应用程序”&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1221462/2aij8uy30j.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，您将看到OAuth申请注册表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1221462/su7u30354z.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填写以下字段（这些字段存在于GitHub上。其他存储库提供程序可能有不同的提示）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;应用程序名称&lt;/strong&gt;：您选择用于标识集成的名称。如果您没有特殊需求，“Drone”是一个不错的选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主页URL&lt;/strong&gt;：您的Drone服务器的域名。在这里使用&lt;code&gt;https://&lt;/code&gt;，因为我们使用的是安全域。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用程序描述&lt;/strong&gt;：Drone的简单描述及其目的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;授权回调URL&lt;/strong&gt;：这必须是&lt;code&gt;https://&lt;/code&gt;，后跟Drone服务器的域名，后跟&lt;code&gt;/authorize&lt;/code&gt;。如果我们的域名是&lt;code&gt;example.com&lt;/code&gt;，这个文件将是。&lt;code&gt;https://example.com/authorize&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;准备好后，单击“ &lt;strong&gt;注册应用程序”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在下一页中，您将看到新应用程序的详细信息。我们需要的两个项目是&lt;strong&gt;客户端ID&lt;/strong&gt;和&lt;strong&gt;客户端密钥&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;复制这两个值。我们需要这些将Drone连接到我们的GitHub帐户。&lt;/p&gt;
&lt;h2 id=&quot;拉取drone-docker镜像并准备配置&quot;&gt;&lt;strong&gt;拉取Drone Docker镜像并准备配置&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;可以在服务器上安装和配置Drone。Drone作为Docker容器分发，因此如果我们在&lt;code&gt;Docker Compose&lt;/code&gt;文件中使用它，它将自动下载。为了略微加快这个过程，我们可以提前下拉镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker pull drone/drone:0.7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Drone Docker镜像是一个统一的容器，可以通过几种不同的方式运行。我们将运行一个作为Drone服务器运行的容器，该服务器协调存储库访问，托管Web UI并提供API。使用具有不同设置的相同镜像，我们将另一个容器作为Drone代理运行，该代理负责从配置的存储库构建和测试软件。&lt;/p&gt;
&lt;p&gt;我们将使用Docker Compose在Drone主机上运行这两个容器。首先创建一个配置目录来存储我们需要的文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo mkdir /etc/drone&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们将在其中创建一些文件来配置我们的服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为Drone创建Docker Compose文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，在配置目录中创建一个Docker Compose文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo nano /etc/drone/docker-compose.yml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将Docker Compose文件格式标记为版本“3”。之后，我们将为上述两种服务定义服务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;drone-server&lt;/code&gt;服务将启动侦听&lt;code&gt;8000&lt;/code&gt;端口的主Drone服务器容器。我们将主机的&lt;code&gt;/var/lib/drone&lt;/code&gt;目录安装在容器内，以便Drone可以保留其数据。我们将服务配置其自动重启，并以我们将在&lt;code&gt;/etc/drone/server.env&lt;/code&gt;创建的文件中定义的环境变量的形式读取更详细的配置说明。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;drone-agent&lt;/code&gt;服务使用相同的镜像，从&lt;code&gt;agent&lt;/code&gt;命令开始。它接收来自主Drone服务器实例的指令，因此虽然它不需要一般的网络访问，但它确实需要在Drone服务之后启动。它还需要访问Docker的套接字文件来启动容器以运行实际的构建和测试步骤。与&lt;code&gt;drone-server&lt;/code&gt;服务一样，此服务也将自动重启并读取&lt;code&gt;/etc/drone/agent.env&lt;/code&gt;文件中的环境以进行其他配置。&lt;/p&gt;
&lt;p&gt;使用以下Docker Compose文件配置这两个服务。注意文件的YAML格式，因为缩进或格式化中的错误可能导致错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: '3'

services:
  drone-server:
    image: drone/drone:0.7
    ports:
      - 127.0.0.1:8000:8000
    volumes:
      - /var/lib/drone:/var/lib/drone
    restart: always
    env_file:
      - /etc/drone/server.env

  drone-agent:
    image: drone/drone:0.7
    command: agent
    depends_on:
      - drone-server
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
    restart: always
    env_file:
      - /etc/drone/agent.env&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成后，保存并关闭Docker Compose文件。&lt;/p&gt;
&lt;h2 id=&quot;配置drone服务器的环境变量文件&quot;&gt;&lt;strong&gt;配置Drone服务器的环境变量文件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;接下来，我们需要为的Docker Compose文件中引用的Drone服务器的环境变量文件。&lt;/p&gt;
&lt;p&gt;在打开文件之前，我们应该生成一个强密钥来验证代理和服务器组件。虽然我们的设置将在同一台服务器上同时拥有这两个组件，但随着测试基础架构的扩展，强大的密钥至关重要。在命令行上，输入以下命令生成密钥：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LC_ALL=C &amp;lt;/dev/urandom tr -dc A-Za-z0-9 | head -c 65 &amp;amp;&amp;amp; echo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此命令临时将shell中的语言设置为有限的字符范围。 然后它从&lt;code&gt;/dev/urandom&lt;/code&gt;获取一个随机字节流，并进一步过滤掉任何非字母数字字符。我们将前65个字符作为关键字。&lt;/p&gt;
&lt;p&gt;输出看起来与此类似（&lt;strong&gt;不要复制下面的值！生成自己的！&lt;/strong&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ERmA7xubDvTa8i0wYBlljc9yjT1NJPG7xOlZBwAdMAmBYL4RZE4QngxWcCLowk9KN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复制生成的密钥以在服务器环境文件中使用。创建一个新文件&lt;code&gt;/etc/drone/server.env&lt;/code&gt;并在文本编辑器中打开它：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo nano /etc/drone/server.env&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件内，我们定义Drone用于连接的环境变量以启动服务，连接到存储库提供程序以及设置帐户授权策略。您需要先从存储库提供程序复制的值才能正确填写值。&lt;/p&gt;
&lt;p&gt;首先，设置&lt;code&gt;DRONE_HOST&lt;/code&gt;和&lt;code&gt;DRONE_SECRET&lt;/code&gt;值。将&lt;code&gt;DRONE_SECRET&lt;/code&gt;设置为您在命令行上生成的密钥。&lt;code&gt;DRONE_HOST&lt;/code&gt;设置通知Drone其可公开访问的地址。 这应该是您的受腾讯云保护的域名，前面是&lt;code&gt;https://&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Service settings
DRONE_SECRET=secret_generated_on_command_line
DRONE_HOST=https://example.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们将配置与VCS提供程序的集成，在我们的示例中为GitHub。适合您项目的设置可能会有所不同，具体取决于您的需求以及GitHub资产的组织方式。&lt;/p&gt;
&lt;p&gt;我们将锁定我们的Drone安装并通过将&lt;code&gt;DRONE_OPEN&lt;/code&gt;设置为&lt;code&gt;false&lt;/code&gt;来禁用注册。这意味着只有&lt;code&gt;DRONE_ADMIN&lt;/code&gt;中指定的GitHub帐户名才能登录。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果您将协作者作为GitHub组织使用，最好将&lt;code&gt;DRONE_OPEN&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;并将&lt;code&gt;DRONE_ADMIN&lt;/code&gt;替换为&lt;code&gt;DRONE_ORGS&lt;/code&gt;。&lt;code&gt;DRONE_ORGS&lt;/code&gt;设置允许您指定一个或多个允许其成员。Drone将限制注册属于这些组的用户。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;确保&lt;code&gt;DRONE_ADMIN&lt;/code&gt;包含您的GitHub帐户名称。&lt;/p&gt;
&lt;p&gt;然后，通过将&lt;code&gt;DRONE_GITHUB&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;来激活GitHub集成插件。当我们注册Drone应用程序时，我们将&lt;code&gt;DRONE_GITHUB_CLIENT&lt;/code&gt;和&lt;code&gt;DRONE_GITHUB_SECRET&lt;/code&gt;设置为我们从GitHub OAuth应用程序页面复制的密钥：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Service settings
DRONE_SECRET=secret_generated_on_command_line
DRONE_HOST=https://example.com

# Registration settings
DRONE_OPEN=false
DRONE_ADMIN=sammytheshark

# GitHub Settings
DRONE_GITHUB=true
DRONE_GITHUB_CLIENT=Client_ID_from_GitHub
DRONE_GITHUB_SECRET=Client_Secret_from_GitHub&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们已完成配置服务器组件。在离开之前，复制&lt;code&gt;DRONE_SECRET&lt;/code&gt;文件中的值。配置代理时，我们需要在下一节中设置相同的密钥。完成后保存并关闭文件。&lt;/p&gt;
&lt;h2 id=&quot;配置drone-agent的环境变量文件&quot;&gt;&lt;strong&gt;配置Drone Agent的环境变量文件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;接下来，我们将为Drone代理组件创建一个环境文件。打开新文件以设置代理环境变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo nano /etc/drone/agent.env&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只需要定义两个值。 &lt;code&gt;DRONE_SECRET&lt;/code&gt;将匹配&lt;code&gt;sever.env&lt;/code&gt;文件中的配置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DRONE_SERVER&lt;/code&gt;设置将配置代理连接到Drone服务器组件的方式。它将以&lt;code&gt;wss://&lt;/code&gt;协议前缀开头，表示连接将使用加密的Web套接字，后跟Drone服务器的域名，并在末尾附加&lt;code&gt;/ws/broker&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DRONE_SECRET=secret_generated_on_command_line
DRONE_SERVER=wss://example.com/ws/broker&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成后保存并关闭文件。&lt;/p&gt;
&lt;h2 id=&quot;配置drone系统单元文件&quot;&gt;&lt;strong&gt;配置DRONE系统单元文件&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;现在我们的配置文件就位，我们可以定义一个&lt;code&gt;systemd&lt;/code&gt;单元文件来管理Drone服务。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;/etc/systemd/system&lt;/code&gt;目录中打开一个新的&lt;code&gt;.service&lt;/code&gt;文件来配置服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo nano /etc/systemd/system/drone.service&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内部粘贴以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Unit]
Description=Drone server
After=docker.service nginx.service

[Service]
Restart=always
ExecStart=/usr/local/bin/docker-compose -f /etc/drone/docker-compose.yml up
ExecStop=/usr/local/bin/docker-compose -f /etc/drone/docker-compose.yml stop

[Install]
WantedBy=multi-user.target&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一部分告诉systemd在Docker和Nginx可用后启动此服务。第二部分告诉系统在发生故障时自动重启服务。 然后，它使用Docker Compose和我们之前创建的配置文件定义启动和停止Drone服务的命令。最后，最后一节定义了如何使服务在引导时启动。&lt;/p&gt;
&lt;p&gt;完成后保存并关闭文件。&lt;/p&gt;
&lt;p&gt;在我们启动Drone服务之前，我们必须配置Nginx。Drone代理需要能够连接到Drone服务器，并且连接依赖于Nginx代理。&lt;/p&gt;
&lt;h2 id=&quot;配置nginx到代理请求到drone&quot;&gt;&lt;strong&gt;配置Nginx到代理请求到Drone&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;接下来，我们需要修改Nginx的配置以代理对Drone服务器的请求。首先找到处理腾讯云SSL的Nginx配置。通过输入以下内容在所有已启用的服务器块中搜索&lt;code&gt;server_name&lt;/code&gt;属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grep -R server_name /etc/nginx/sites-enabled&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/etc/nginx/sites-enabled/default:   server_name example.com;
/etc/nginx/sites-enabled/default:   return 301 https://$server_name$request_uri;
/etc/nginx/sites-enabled/default:   server_name example.com;
/etc/nginx/sites-enabled/default:#  server_name example.com;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的输出中，域名（在此实例中为&lt;code&gt;example.com&lt;/code&gt;）正在&lt;code&gt;/etc/nginx/sites-enabled/default&lt;/code&gt;文件中定义。 您需要编辑与您的域名关联的文件。&lt;/p&gt;
&lt;p&gt;您可能也会看到类似这样的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/etc/nginx/sites-enabled/default:   server_name _;
/etc/nginx/sites-enabled/default:   return 301 https://$server_name$request_uri;
/etc/nginx/sites-enabled/default:   server_name _;
/etc/nginx/sites-enabled/default:#  server_name example.com;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的输出中，&lt;code&gt;server_name _&lt;/code&gt;; 表示用作后备机制的服务器块。“&lt;code&gt;_&lt;/code&gt;”主机说明符是无效的主机，因此它永远不会匹配。&lt;/p&gt;
&lt;p&gt;在配置中，这些配置与&lt;code&gt;listen&lt;/code&gt;指令配对，后者设置&lt;code&gt;default_server&lt;/code&gt;选项，以便当请求的主机与其他的服务器块不匹配时，将充当默认值。如果找不到与您的域名匹配的&lt;code&gt;server_name&lt;/code&gt;定义，则应使用定义这些回退块的文件。&lt;/p&gt;
&lt;p&gt;在文本编辑器中打开与您的域最相关的文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo nano /etc/nginx/sites-enabled/default &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在内部，我们将首先在现有server块之外添加两个部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;upstream drone {
    server 127.0.0.1:8000;
}

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    . . .&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个块配置一个名为&lt;code&gt;drone&lt;/code&gt;的上游请求，我们可以在其中代理请求。&lt;code&gt;server&lt;/code&gt;指令定义了如何连接到我们的Drone服务，该服务将在端口8000上运行。&lt;/p&gt;
&lt;p&gt;第二个块根据&lt;code&gt;$connection_upgrade&lt;/code&gt;变量的值设置一个名为&lt;code&gt;$http_upgrade&lt;/code&gt;的用户定义变量，Nginx在收到“Upgrade”HTTP标头时设置该变量。如果收到Upgrade头，Nginx将设置&lt;code&gt;$connection_upgrade&lt;/code&gt;变量进行升级。如果没有，它将设置为关闭。 这些变量允许我们在代理WebSocket请求时设置正确的标头。&lt;/p&gt;
&lt;p&gt;接下来，找到包含&lt;code&gt;listen 443&lt;/code&gt;指令的服务器块。 使用以下指令替换内容。确保注释掉或删除该块中的任何现有配置以避免冲突：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;. . .
server {
    listen 443 ssl;
    . . .
    location / {
        # try_files $uri $uri/ =404;
        proxy_pass http://drone;

        include proxy_params;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection $connection_upgrade;

        proxy_redirect off;
        proxy_http_version 1.1;
        proxy_buffering off;
        chunked_transfer_encoding off;
        proxy_read_timeout 86400;
    }
    . . .
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;proxy_pass&lt;/code&gt;行告诉Nginx将此块之外的所有流量传递给我们之前定义的上游。接下来，我们在&lt;code&gt;proxy_params&lt;/code&gt;文件中包含一些代理头定义，并根据之前的地图设置添加其他头。然后，我们调整一些其他特定于代理的设置，以确保WebSocket代理正常工作，并确保我们的组件可以有效地进行通信。&lt;/p&gt;
&lt;p&gt;完成保存并关闭文件后。&lt;/p&gt;
&lt;h2 id=&quot;测试并重新启动nginx和drone&quot;&gt;&lt;strong&gt;测试并重新启动Nginx和Drone&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我们的配置现已完成。我们只需启动或重启我们的服务即可实现配置。&lt;/p&gt;
&lt;p&gt;首先，检查Nginx配置是否存在语法错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo nginx -t&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
nginx: configuration file /etc/nginx/nginx.conf test is successful&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果输出指示存在配置问题，请返回并再次检查Nginx配置。重新启动Nginx：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo systemctl restart nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在Nginx可用于代理和服务器之间的代理请求，我们可以启动Drone：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo systemctl start drone&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查以确保服务能够成功启动：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo systemctl status drone&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;● drone.service - Drone server
   Loaded: loaded (/etc/systemd/system/drone.service; disabled; vendor preset: enabled)
   Active: active (running) since Fri 2017-06-09 21:56:33 UTC; 2min 58s ago
 Main PID: 15225 (docker-compose)
    Tasks: 5
   Memory: 37.7M
      CPU: 1.544s
   CGroup: /system.slice/drone.service
           ├─15225 /usr/local/bin/docker-compose -f /etc/drone/docker-compose.yml up
           └─15228 /usr/local/bin/docker-compose -f /etc/drone/docker-compose.yml up

. . .
Jun 09 21:56:35 drone docker-compose[15225]: drone-agent_1   | pipeline: request next execution&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果服务被标记为&lt;code&gt;active (running)&lt;/code&gt;并且日志中没有错误，则Drone已启动并正在运行。&lt;/p&gt;
&lt;p&gt;如果遇到问题，可以输入以下命令检查Nginx日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo less /var/log/nginx/error.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您可以通过输入以下内容来检查Drone日志：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo journalctl -u drone&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一切正常运行，请通过输入以下内容启用Drone：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo systemctl enable drone&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Docker和Nginx服务可用后，Drone服务将启动。&lt;/p&gt;
&lt;h2 id=&quot;登录drone以授权访问您的存储库&quot;&gt;&lt;strong&gt;登录Drone以授权访问您的存储库&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;现在Drone已启动并运行，我们可以登录Web界面并授权应用程序使用我们的GitHub帐户。&lt;/p&gt;
&lt;p&gt;在Web浏览器中访问服务器的域名以查看Drone Web界面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://example.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在您第一次访问时，系统将提示您登录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1221462/o79vumsndb.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击&lt;strong&gt;登录&lt;/strong&gt;使用您的GitHub帐户向Drone进行身份验证。如果您当前未登录GitHub，将首先指示您登录GitHub。&lt;/p&gt;
&lt;p&gt;之后，系统将提示您允许Drone访问您的GitHub帐户：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1221462/uaj24nmuhs.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看请求的权限并进行任何调整后，单击&lt;strong&gt;授权用户名&lt;/strong&gt;按钮以授权Drone。&lt;/p&gt;
&lt;p&gt;您将被重定向回您的Drone服务器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1221462/sq2ve95h6a.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，您可以激活和配置存储库以自动测试代码。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在本教程中，我们将Drone设置为GitHub项目的持续集成和交付服务器。我们将Drone设为处理身份验证并侦听来自我们的存储库的更改。我们还配置了一个可以运行测试和管理容器的Drone代理。我们还将Nginx配置为安全的反向代理。如果觉得自建太麻烦，不要着急，&lt;a href=&quot;https://cloud.tencent.com/product/cci&quot;&gt;腾讯云CCI持续集成&lt;/a&gt;服务即将开放，云持续集成（Cloud Continuous Integration，CCI）为开发者提供支持多语言，多终端的持续集成服务，包含定时/手动启动构建、查看构建结果及日志、支持快速分发交付、可扩展的自动化测试等功能，为项目的持续集成体系提供上游基础服务，提升项目研发效率。 更多Linux教程请前往&lt;a href=&quot;https://cloud.tencent.com/developer&quot;&gt;腾讯云+社区&lt;/a&gt;学习更多知识。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参考文献：《How To Install and Configure Drone on Ubuntu 16.04》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.2283464566929&quot;&gt;
&lt;h2 id=&quot;问答&quot;&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/99546?fromSource=waitui&quot;&gt;Angular2如何处理http响应？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关阅读&quot;&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1159626?fromSource=waitui&quot;&gt;HTTP/2之服务器推送(Server Push)最佳实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1159813?fromSource=waitui&quot;&gt;如何备份你的MySQL数据库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1158503?fromSource=waitui&quot;&gt;MySQL 8.0 版本功能变更介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/edu/course-1154?fromSource=waitui&quot;&gt;云学院 · 课程推荐 | 腾讯高级工程师，带你快速入门机器学习&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，原文链接：&lt;a href=&quot;https://cloud.tencent.com/developer/article/1180481?fromSource=waitui&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/article/1180481?fromSource=waitui&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搜索关注公众号「云加社区」，第一时间获取技术干货，关注后回复1024 送你一份技术课程大礼包！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;海量技术实践经验，尽在&lt;a href=&quot;https://cloud.tencent.com/developer?fromSource=waitui&quot;&gt;云加社区&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Mon, 20 Aug 2018 06:46:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>欢迎大家前往腾讯云+社区，获取更多腾讯海量技术实践干货哦~ 本文由</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/9504266.html</dc:identifier>
</item>
<item>
<title>窄带高清转码技术实践——技术沙龙分享实录 - 又拍云</title>
<link>http://www.cnblogs.com/upyun/p/9505410.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upyun/p/9505410.html</guid>
<description>&lt;p&gt;“转码”对于各家来说做法可能都不太一样，但是逻辑是一样的，我今天分享的是又拍云关于窄带高清的转码，贴近“转码”，更为底层，理论知识会相对较多一些。分享的内容主要分为两块，第一是介绍什么是窄带高清转码，第二是介绍又拍云窄带高清转码的实现方式。&lt;/p&gt;
&lt;p&gt;首先说一下又拍云对“窄带高清”的定义：在编码标准不变，文件的封装格式不变的情况下，通过对画面场景复杂度进行智能分析、智能码率分配，节省 30% 的码流。&lt;/p&gt;

&lt;h2&gt;一、什么是窄带高清转码&lt;/h2&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-9f2a526556edee459ad4cf0fb677a03b_hd.jpg&quot; alt=&quot;&quot; width=&quot;835&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;835&quot; data-rawheight=&quot;281&quot; data-original=&quot;https://pic3.zhimg.com/v2-9f2a526556edee459ad4cf0fb677a03b_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9f2a526556edee459ad4cf0fb677a03b_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;△ 转码架构图&lt;/p&gt;

&lt;p&gt;上图是传统的转码架构图，不管是本地文件还是流媒体文件，先通过解封装，使音频和视频分离，然后分别解码，示意图中间的 Option 是可选的。这个环节可以对音视频进行处理，比如回声去噪音，视频做画中画、视频图像的处理等。做好处理或者直接跳过这一步，再到转码，这时候就要经过编码，我们可以用各种不同的视频编码标准，音频也可以用不同的音频编码标准做一个编码压缩，最后封装起来成一个输出文件，这个文件可以是本地的，也可以是网络的流。&lt;/p&gt;
&lt;p&gt;基于以上转码的架构，我们如果想通过转码，使转码后的文件变小，可以从三个方向做减少尺寸的操作（因为音频对尺寸的贡献量比较小，这里讨论以视频为主，音频暂不考虑）。首先可以采用新的视频编码标准，比如现在在研究的 H.266 ，可以降低大约 30% 到 50 % 的码率；其次是文件的封装格式，比如 FLV 和 MP4 ，受他们自身的封装格式影响，虽然封装的音频流或者视频流源头都是一样的，但是通过不同的封装格式，大小也不一样；第三点是窄带高清转码。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-c89c11a9dbc778f7eb9fb99c99dfe4f3_hd.jpg&quot; alt=&quot;&quot; width=&quot;658&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;658&quot; data-rawheight=&quot;415&quot; data-original=&quot;https://pic1.zhimg.com/v2-c89c11a9dbc778f7eb9fb99c99dfe4f3_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c89c11a9dbc778f7eb9fb99c99dfe4f3_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、视频编码标准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;视频编码的标准，目前主流的是 H.264，2003 年 H.264 的标准就已经制定完成，H.265 是 2013 年定稿的，但是由于专利费用太高，所以应用还是以 H.264 为主。关于 H.266 的标准定稿时间确定在 2020 年底，届时会推出新的编码标准。此外以谷歌为代表的 AOM ，从 2008 年到 2013 年的 VP8、VP9，当时是以谷歌为主推，因为在芯片这块的推广效果不佳，所以也只是在谷歌自家应用。 AV1 在今年年初定了标准，大家对此寄予厚望，认为它是可以和 H.265 抗衡的。另外，还有中国的标准 AVx，目前只在国内使用。&lt;/p&gt;
&lt;p&gt;我们考虑以 H.264、H.265 和 AV1 作为主要的参考标准，当然后面一代对于前一代来说，号称码流节省都是在 30% 到 50% ，这其实是非常可观的数据。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-c89c11a9dbc778f7eb9fb99c99dfe4f3_hd.jpg&quot; alt=&quot;&quot; width=&quot;658&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;658&quot; data-rawheight=&quot;415&quot; data-original=&quot;https://pic1.zhimg.com/v2-c89c11a9dbc778f7eb9fb99c99dfe4f3_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c89c11a9dbc778f7eb9fb99c99dfe4f3_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;△ 编码标准的演变&lt;/p&gt;
&lt;p&gt;以上对比图显示，在相同码率下，AV1 比 H.264 和 H.265 质量都好；在相同质量下，它的码率更节省。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、文件封装格式选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-48ed9b258f82c0122927acca014f5a55_hd.jpg&quot; alt=&quot;&quot; width=&quot;719&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;719&quot; data-rawheight=&quot;407&quot; data-original=&quot;https://pic2.zhimg.com/v2-48ed9b258f82c0122927acca014f5a55_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-48ed9b258f82c0122927acca014f5a55_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;△ 文件封装格式&lt;/p&gt;
&lt;p&gt;上面是一个 YUV 文件的尺寸，包括分辨率和帧数的统计，YUV 文件原始 834 M，下面 H.264 裸码流编出来 4 M ，然后这个尺寸封装成 MP4 格式文件，MP4 格式的文件主要包含 moov 头和 MDAT（音视频数据）。moov 头内封装的是关于音视频每一帧的信息，包括大小、时间戳等，它只增加了 7K ；如果相同的码流封装成 FLV 格式的文件则增加了 12 K，因为这里帧数比较少，如果帧数比较多，还是很可观的。FLV 文件每一帧都有一个头，包括音频和视频，所以当它的文件增加一个尺寸，随着帧数越来越多，尺寸也会越来越大；TS 就更不用说了，它是188字节一个包，封装信息会更多，包括了一些媒体的信息等。&lt;/p&gt;
&lt;p&gt;总的来说，对于实时性不强的场景，大部分都会选择采用 MP4 格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、窄带高清&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-032659be21316b7d5306ed838a674adc_hd.jpg&quot; alt=&quot;&quot; width=&quot;533&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;533&quot; data-rawheight=&quot;411&quot; data-original=&quot;https://pic4.zhimg.com/v2-032659be21316b7d5306ed838a674adc_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-032659be21316b7d5306ed838a674adc_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;窄带高清是基于以上的曲线图考虑的：这里有蓝色和红色两个视频序列，蓝色表示运动比较缓慢的视频，比如我现在演讲，只是个人在动，背景都是静止的，相对来说内容的运动是比较缓慢的；红色表示运动比较剧烈的，比如《变形金刚》的电影。&lt;/p&gt;
&lt;p&gt;以上两个视频序列的曲线可以这么来解释：PSNR 表示视频的质量，当在 40 dB 的时候，蓝色所需要的码率跟红色所需要的码率，一个是不到 1M ，一个是大于 2M 多，运动程度不一样的情况下，达到相同的质量，需要的码率是不一样的；而在相同码率下，比如 2M 的情况下，运动剧烈的可以达到 40 dB ，而静止的可以达到 45 dB，由此可见相同码率下，运动剧烈和不剧烈的视频质量不一样。&lt;/p&gt;
&lt;p&gt;因此这里留给了我们一个操作的空间，我们在相同编码标准和封装格式不变的情况下，基于这两个结论，在人眼感知不到它质量失真的情况下，减少视频的码率。测试结果显示，码流的节省是非常可观的，一般可以达到30%之多；当然不同场景复杂度的码流节省效果不一样。&lt;/p&gt;

&lt;h2&gt;二、又拍云窄带高清转码实现&lt;/h2&gt;
&lt;p&gt;&lt;img class=&quot;content_image lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-45435bd644870b9999b90b38952231ad_hd.jpg&quot; alt=&quot;&quot; width=&quot;296&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;296&quot; data-rawheight=&quot;445&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-45435bd644870b9999b90b38952231ad_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面介绍又拍云“窄带高清”是如何实现的。首先输入一个视频转码的分片，接着进行复杂度分析，然后分场景转码参数，比如运动缓慢还是剧烈，当然这其中还会有码率控制的算法来调整编码器的输出，最终得到编码后的视频。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、复杂度分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于复杂度分析，我们是借鉴了标准里面的 BT1788 关于空间感知信息和时间感知信息。空间感知信息是每一帧图像做一个 Sobel 值，然后分析它的纹理的多少作为参考标准；时间感知信息是帧与帧之间的帧差做标准差，作为时间上的变化情况。&lt;/p&gt;
&lt;p&gt;又拍云根据用户的应用场景不同一共分了四类场景：手机自拍、动画、运动缓慢和运动剧烈。auto 是用户不用选择，我们会根据复杂度的分析自动选择上面四个最合适的方法。为什么需要进行场景分类呢？因为我们有的客户的视频源比较单一，比如一个客户只有手机自拍的视频，他就可以选择视频自拍。后面随着业务越来越复杂，我们还会有更细的一些场景分类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、编码器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a、H. 264 codec&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-798554942fffe8808b784613b28d07fb_hd.jpg&quot; alt=&quot;&quot; width=&quot;889&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;889&quot; data-rawheight=&quot;388&quot; data-original=&quot;https://pic4.zhimg.com/v2-798554942fffe8808b784613b28d07fb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-798554942fffe8808b784613b28d07fb_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优化编码器参数——H.264 codec&lt;/p&gt;
&lt;p&gt;上图是 H.264 编码器的框架， 其实 H.264 和 H.265 的编码框架差不多，都是关于空间域和时间域的冗余压缩。H.264 的框架流程包括了帧间、帧内的预测、变换、量化、反变换反量化、熵编码和去方块滤波，因为目前编码标准都是基于“块”的编码，所以会出现“块效应”，所以需要去方块的滤波来提升人眼的主观质量。&lt;/p&gt;
&lt;p&gt;b、H.265编码 codec&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-a8c059dfbb8768e63d62511f92108fc1_hd.jpg&quot; alt=&quot;&quot; width=&quot;674&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;674&quot; data-rawheight=&quot;422&quot; data-original=&quot;https://pic2.zhimg.com/v2-a8c059dfbb8768e63d62511f92108fc1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a8c059dfbb8768e63d62511f92108fc1_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优化编码器参数——H.265 codec&lt;/p&gt;
&lt;p&gt;这个是 H.265 的编码框架，与 H.264 一样的混合编码框架。比如包括了帧间、帧内的预测、熵编码等，Deblocking 为了去除“块效应&quot;，增加了一个新的 SAO 的滤波来消除振铃效应。&lt;/p&gt;
&lt;p&gt;c、H.264 与 H.265 参数对比&lt;/p&gt;
&lt;p&gt;关于 H.264 和 H.265 框架，虽然说他们的流程基本一样，框架也没有变化，但是他们“处处相同又处处不同”，在每个技术上都做了优化。&lt;/p&gt;
&lt;p&gt;第一，H.264 块的尺寸是从 16x16 扩展到 H.265 的 64x64，这是一个指数级的块的复杂度的提升；&lt;/p&gt;
&lt;p&gt;第二，关于预测，H.265 帧内的预测方向提升到了 35 种。因为 H.265 是针对高清的，包括 1080P、2K、4K，最高到 8K，这种图片的尺寸会比较大，所以它可以分大块，对于那些变化不明显的大块图像区域，可以用更大的块尺寸，可以在预测环节减少分块带来的复杂计算。对运动矢量也做了优化，并且对亮度和色度差值算法变的更复杂；&lt;/p&gt;
&lt;p&gt;第三，加入并行计算，因为复杂度提升了很多，而且目前计算机行业的并行技术发展的也很好，所以在视频编码标准制定的时候加入了并行的优化，来节省编码时间。&lt;/p&gt;
&lt;p&gt;d、H.265 编参数优化&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-162dacedd5fc70706c0ad784114b3a31_hd.jpg&quot; alt=&quot;&quot; width=&quot;819&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;819&quot; data-rawheight=&quot;530&quot; data-original=&quot;https://pic3.zhimg.com/v2-162dacedd5fc70706c0ad784114b3a31_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-162dacedd5fc70706c0ad784114b3a31_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;H.265 编码参数优化&lt;/p&gt;
&lt;p&gt;不管是 H.264 还是 H.265，他们的编码参数有几十甚至上百个，那么该如何设置呢？我们需要理论上去分析它在哪些环节花费时间比较长，然后在这些环节上做参数优化。&lt;/p&gt;
&lt;p&gt;首先是帧间，因为现在都是基于块的，如果块预测准确，前后帧可能是完全一样的，这时候编码的比特就是 0 ；但是如果预测的不准确，它们做差异的时候可能会是一个很大的值，这样编码后的码率就会大，所以帧间预测的准确程度也决定了码率能节省多少。但是如果穷尽搜索或者全搜索的情况下，计算量会非常庞大。所以帧间预测的因素包括了运动搜索的算法、运动搜索的范围等。&lt;/p&gt;
&lt;p&gt;目前我们的编码帧类型有 I 帧，P 帧，B 帧。B 帧包括被参考的 B 帧和无参考的 B 帧，I 帧理论说应该占比较多的比特，这样对于视频质量影响比较好一点，P 帧是前向参考，所以是其次大小，然后是有参考的 B 帧，无参考的B帧最小，是可有可无的存在。这种在做实时流的时候比较明显，你如果丢了 I 帧，相当于一个 GOP 的帧都无法解出来，全部都要丢掉，会出现错误扩散。&lt;/p&gt;
&lt;p&gt;视频后处理，包括了去方块滤波、样点自适应补偿（SAO），会比较好的提升视频图像质量。并行计算的技术影响会比较大，此外还有码率控制和汇编优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、码率控制算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;码率控制是在视频编码标准规定之外的，作用于编码器，是基于反馈机制来调节编码器的码流输出。比如当输出的时候，带宽突然变小，但是你还是按照现在码流的输出质量，它肯定会丢，这样会反馈到编码器，可以减少码流输出；如果带宽变好了，也会反馈到编码器上，输出更高质量的码流。&lt;/p&gt;
&lt;p&gt;码率控制在学术上分为两类，一种是 CBR ，恒定的码率，另一种叫 VBR ，可变的码率，但是在实际应用的时候会有一些变化。码率控制会根据不同的应用场景会有一些变化，比如本地文件或者针对流，码率控制的策略都不一样。针对流肯定是用 CBR ，但是它会存在浪费带宽的情况，质量不会是最好的。&lt;/p&gt;
&lt;p&gt;关于具体的码率控制的模式，比如恒定的 CQP 量化参数来进行编码，这个基本是用来做学术研究，验证编码器质量的好坏，它的好处是比较快，可以更好的鉴定编码器的情况； 平均的 ABR 的码率是 vbr 的一种；CBR ，它会设置一个固定码率大小，因为在流媒体应用领域，一个带宽的多少会有固定的值，比如最高不能突破 2 M ，所以这种方式会用；N-pass ，比如 2-pass 码率控制方式，因为需要两遍编码，只能应用在实时性不强的情形，他会码率控制的更准确，但是因为需要两遍所以时间消耗比较多；CRF 的原理和 CQP 类似， 但是这种考虑了运动缓慢或者运动剧烈的情况下所需要的码率不一样，做了一些码率的优化分配的方式；VBV 这个是一个缓冲池，因为码流控制是基于一个反馈机制的，所以也是需要缓冲池的机制来保证。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-41f564d67674ca2e939324421f501715_hd.jpg&quot; alt=&quot;&quot; width=&quot;959&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;959&quot; data-rawheight=&quot;454&quot; data-original=&quot;https://pic4.zhimg.com/v2-41f564d67674ca2e939324421f501715_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-41f564d67674ca2e939324421f501715_b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;窄带高清码率上限限制&lt;/p&gt;
&lt;p&gt;窄带高清有码率上限限制，在不同分辨率的情况下，又拍云保证在这个码率下可以获得最好的视频质量。详情参考：&lt;a class=&quot; external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//docs.upyun.com/cloud/av/%23_18&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;docs.upyun.com/cloud/av&lt;span class=&quot;invisible&quot;&gt;/#_18&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 20 Aug 2018 06:41:00 +0000</pubDate>
<dc:creator>又拍云</dc:creator>
<og:description>“转码”对于各家来说做法可能都不太一样，但是逻辑是一样的，我今天分享的是又拍云关于窄带高清的转码，贴近“转码”，更为底层，理论知识会相对较多一些。分享的内容主要分为两块，第一是介绍什么是窄带高清转码，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upyun/p/9505410.html</dc:identifier>
</item>
<item>
<title>SpringCloud教程 | 第五篇: 路由网关(zuul)(Finchley版本) - 华丽D转身</title>
<link>http://www.cnblogs.com/snake23/p/9505396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snake23/p/9505396.html</guid>
<description>&lt;p&gt;在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统。一个简答的微服务系统如下图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://upload-images.jianshu.io/upload_images/2279594-6b7c148110ebc56e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot; alt=&quot;Azure (1).png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;注意：A服务和B服务是可以相互调用的，作图的时候忘记了。并且配置服务也是注册到服务注册中心的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理（下一篇文章讲述），配置服务的配置文件放在git仓库，方便开发人员随时改配置。&lt;/p&gt;
&lt;h3 id=&quot;一zuul简介&quot;&gt;一、Zuul简介&lt;/h3&gt;
&lt;p&gt;Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。&lt;/p&gt;
&lt;p&gt;zuul有以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Authentication&lt;/li&gt;
&lt;li&gt;Insights&lt;/li&gt;
&lt;li&gt;Stress Testing&lt;/li&gt;
&lt;li&gt;Canary Testing&lt;/li&gt;
&lt;li&gt;Dynamic Routing&lt;/li&gt;
&lt;li&gt;Service Migration&lt;/li&gt;
&lt;li&gt;Load Shedding&lt;/li&gt;
&lt;li&gt;Security&lt;/li&gt;
&lt;li&gt;Static Response handling&lt;/li&gt;
&lt;li&gt;Active/Active traffic management&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;二准备工作&quot;&gt;二、准备工作&lt;/h3&gt;
&lt;p&gt;继续使用上一节的工程。在原有的工程上，创建一个新的工程。&lt;/p&gt;
&lt;h3 id=&quot;三创建service-zuul工程&quot;&gt;三、创建service-zuul工程&lt;/h3&gt;
&lt;p&gt;其pom.xml文件如下：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs xml has-numbering&quot;&gt;&lt;span class=&quot;hljs-pi&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;project &lt;span class=&quot;hljs-attribute&quot;&gt;xmlns=&lt;span class=&quot;hljs-value&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot; &lt;span class=&quot;hljs-attribute&quot;&gt;xmlns:xsi=&lt;span class=&quot;hljs-value&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         &lt;span class=&quot;hljs-attribute&quot;&gt;xsi:schemaLocation=&lt;span class=&quot;hljs-value&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;modelVersion&amp;gt;4.0.0&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;modelVersion&amp;gt;

    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&amp;gt;com.forezp&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&amp;gt;service-zuul&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;version&amp;gt;0.0.1-SNAPSHOT&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;packaging&amp;gt;jar&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;packaging&amp;gt;

    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;name&amp;gt;service-zuul&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;name&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;description&amp;gt;Demo project for Spring Boot&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;description&amp;gt;

    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;parent&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&amp;gt;com.forezp&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&amp;gt;sc-f-chapter5&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;version&amp;gt;0.0.1-SNAPSHOT&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;version&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;parent&amp;gt;

    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;dependencies&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&amp;gt;
            &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&amp;gt;org.springframework.cloud&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&amp;gt;
            &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&amp;gt;
            &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&amp;gt;org.springframework.boot&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&amp;gt;
            &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&amp;gt;spring-boot-starter-web&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;dependency&amp;gt;
            &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;groupId&amp;gt;org.springframework.cloud&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;groupId&amp;gt;
            &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;artifactId&amp;gt;spring-cloud-starter-netflix-zuul&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;artifactId&amp;gt;
        &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependency&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;dependencies&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;project&amp;gt;

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在其入口applicaton类加上注解@EnableZuulProxy，开启zuul的功能：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs java has-numbering&quot;&gt;&lt;span class=&quot;hljs-annotation&quot;&gt;@SpringBootApplication
&lt;span class=&quot;hljs-annotation&quot;&gt;@EnableZuulProxy
&lt;span class=&quot;hljs-annotation&quot;&gt;@EnableEurekaClient
&lt;span class=&quot;hljs-annotation&quot;&gt;@EnableDiscoveryClient
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;ServiceZuulApplication {

    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;main(String[] args) {
        SpringApplication.run( ServiceZuulApplication.class, args );
    }
}

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上配置文件application.yml加上以下的配置代码：&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs avrasm has-numbering&quot;&gt;&lt;span class=&quot;hljs-label&quot;&gt;eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:&lt;span class=&quot;hljs-number&quot;&gt;8761/eureka/
&lt;span class=&quot;hljs-label&quot;&gt;server:
  port: &lt;span class=&quot;hljs-number&quot;&gt;8769
&lt;span class=&quot;hljs-label&quot;&gt;spring:
  application:
    name: service-zuul
&lt;span class=&quot;hljs-label&quot;&gt;zuul:
  routes:
    api-a:
      path: /api-a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先指定服务注册中心的地址为&lt;a href=&quot;http://localhost:8761/eureka/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://localhost:8761/eureka/&lt;/a&gt;，服务的端口为8769，服务名为service-zuul；以/api-a/ 开头的请求都转发给service-ribbon服务；以/api-b/开头的请求都转发给service-feign服务；&lt;/p&gt;
&lt;p&gt;依次运行这五个工程;打开浏览器访问：&lt;a href=&quot;http://localhost:8769/api-a/hi?name=forezp&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://localhost:8769/api-a/hi?name=forezp&lt;/a&gt; ;浏览器显示：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;hi forezp,i am from port:8762&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;打开浏览器访问：&lt;a href=&quot;http://localhost:8769/api-b/hi?name=forezp&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://localhost:8769/api-b/hi?name=forezp&lt;/a&gt; ;浏览器显示：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;hi forezp,i am from port:8762&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这说明zuul起到了路由的作用&lt;/p&gt;
&lt;h3 id=&quot;四服务过滤&quot;&gt;四、服务过滤&lt;/h3&gt;
&lt;p&gt;zuul不仅只是路由，并且还能过滤，做一些安全验证。继续改造工程；&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;code class=&quot;hljs java has-numbering&quot;&gt;&lt;span class=&quot;hljs-annotation&quot;&gt;@Component
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;MyFilter &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;ZuulFilter {

    &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static Logger log = LoggerFactory.getLogger(MyFilter.class);
    &lt;span class=&quot;hljs-annotation&quot;&gt;@Override
    &lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;filterType() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-string&quot;&gt;&quot;pre&quot;;
    }

    &lt;span class=&quot;hljs-annotation&quot;&gt;@Override
    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;filterOrder() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-number&quot;&gt;0;
    }

    &lt;span class=&quot;hljs-annotation&quot;&gt;@Override
    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;shouldFilter() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;true;
    }

    &lt;span class=&quot;hljs-annotation&quot;&gt;@Override
    &lt;span class=&quot;hljs-keyword&quot;&gt;public Object &lt;span class=&quot;hljs-title&quot;&gt;run() {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();
        log.info(String.format(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%s &amp;gt;&amp;gt;&amp;gt; %s&quot;, request.getMethod(), request.getRequestURL().toString()));
        Object accessToken = request.getParameter(&lt;span class=&quot;hljs-string&quot;&gt;&quot;token&quot;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;if(accessToken == &lt;span class=&quot;hljs-keyword&quot;&gt;null) {
            log.warn(&lt;span class=&quot;hljs-string&quot;&gt;&quot;token is empty&quot;);
            ctx.setSendZuulResponse(&lt;span class=&quot;hljs-keyword&quot;&gt;false);
            ctx.setResponseStatusCode(&lt;span class=&quot;hljs-number&quot;&gt;401);
            &lt;span class=&quot;hljs-keyword&quot;&gt;try {
                ctx.getResponse().getWriter().write(&lt;span class=&quot;hljs-string&quot;&gt;&quot;token is empty&quot;);
            }&lt;span class=&quot;hljs-keyword&quot;&gt;catch (Exception e){}

            &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;null;
        }
        log.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;ok&quot;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;null;
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：&lt;br/&gt;&lt;ul&gt;&lt;li&gt;pre：路由之前&lt;/li&gt;
&lt;li&gt;routing：路由之时&lt;/li&gt;
&lt;li&gt;post： 路由之后&lt;/li&gt;
&lt;li&gt;error：发送错误调用&lt;/li&gt;
&lt;li&gt;filterOrder：过滤的顺序&lt;/li&gt;
&lt;li&gt;shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。&lt;/li&gt;
&lt;li&gt;run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这时访问：&lt;a href=&quot;http://localhost:8769/api-a/hi?name=forezp&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://localhost:8769/api-a/hi?name=forezp&lt;/a&gt; ；网页显示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;token is empty&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;访问 &lt;a href=&quot;http://localhost:8769/api-a/hi?name=forezp&amp;amp;token=22&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://localhost:8769/api-a/hi?name=forezp&amp;amp;token=22&lt;/a&gt; ；&lt;br/&gt;网页显示：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;hi forezp,i am from port:8762&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文源码下载：&lt;br/&gt;&lt;a href=&quot;https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter5&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/forezp/SpringCloudLearning/tree/master/sc-f-chapter5&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;五参考资料&quot;&gt;五、参考资料：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/forezp/article/details/69939114&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/forezp/article/details/69939114&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：http://blog.csdn.net/forezp。 https://blog.csdn.net/forezp/article/details/81041012&lt;/p&gt;
</description>
<pubDate>Mon, 20 Aug 2018 06:39:00 +0000</pubDate>
<dc:creator>华丽D转身</dc:creator>
<og:description>在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统。一个简答的微服务系统如下图：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snake23/p/9505396.html</dc:identifier>
</item>
<item>
<title>打造RecyclerView的n级列表 - WelliJohn</title>
<link>http://www.cnblogs.com/WellJohn/p/9505385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WellJohn/p/9505385.html</guid>
<description>&lt;p&gt;先上效果图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/20/165560462c7326fe?w=282&amp;amp;h=500&amp;amp;f=gif&amp;amp;s=549336&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;该多级列表的优势&quot;&gt;1.该多级列表的优势：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;支持无限级列表展开&lt;/li&gt;
&lt;li&gt;基于一个recyclerView实现&lt;/li&gt;
&lt;li&gt;可以自定义每一级item的样式，定制化更强&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;设计的思路&quot;&gt;2.设计的思路&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;数据结构List&lt;/li&gt;
&lt;li&gt;因为RecyclerView.Adapter本来就支持多个type的item布局，不清楚的可以看下getItemViewType这个方法，所以我们可以利用这个类，来区分不同级用不同的Item。&lt;/li&gt;
&lt;li&gt;将Item必须具备的方法放在一个Tree接口里面，以后自定义的类只需要继承Tree接口就好了。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;代码分析&quot;&gt;3.代码分析&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class BaseTreeRVAdapter&amp;lt;T extends RecyclerView.ViewHolder, M extends Tree&amp;gt; extends BaseRVAdapterV2&amp;lt;T, M&amp;gt; {

    @Override
    public void onBindViewHolder(T holder, final int position) {
        try {
            getLevel(position, mDatas, new PosBean());
        } catch (StopMsgException ex) {
            int type = Integer.parseInt(ex.getMessage());
            M tree = ex.getTree();
            onBindViewHolder(type, tree, holder);
        }
    }


    @Override
    public int getItemViewType(int position) {
        try {
            getLevel(position, mDatas, new PosBean());
        } catch (StopMsgException ex) {
            return Integer.parseInt(ex.getMessage());
        }
        return 0;
    }

    @Override
    public int getItemCount() {
        return getTotal(mDatas);
    }

    protected abstract void onBindViewHolder(int type, M tree, T holder);

    public List&amp;lt;M&amp;gt; getDatas() {
        return mDatas;
    }

    public void setDatas(List&amp;lt;M&amp;gt; info) {
        if (info != null) {
            mDatas = info;
        } else {
            mDatas.clear();
        }
        notifyDataSetChanged();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注释1：主要是计算当前给的数据他的item个数，会根据是否展开的状态来统总个数&lt;br/&gt;注释2：计算当前的postion对应的item层级，来显示对应的item布局&lt;/p&gt;
&lt;h2 id=&quot;对于自己需要实现的地方&quot;&gt;4.对于自己需要实现的地方&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class TreeListAdapter extends BaseTreeRVAdapter&amp;lt;RecyclerView.ViewHolder, T extends Tree&amp;gt; {

    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view;
        RecyclerView.ViewHolder vh;
        switch (viewType) {
            case 0:
                ......    
                break;
            case 1:
                ......
                break;
            case 2:
                ......
                break;
            case 3:
            case 4:
            ......
        }
        return vh;
    }


    @Override
    protected void onBindViewHolder(int type, final DiscountItem itemCategoryListBean, RecyclerView.ViewHolder holder) {
        switch (type) {
            case 0:
                ......
                break;
            case 1:
                ......
                break;
            case 2:
                ......
                break;
            case 3:
            case 4:
            ......
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;上面的泛型T就是我们的Item的class类型，所以自定义的class要想用这个adapter的话，都需要实现Tree接口&lt;/li&gt;
&lt;li&gt;onBindViewHolder方法中形参的的type就是层级，比如说第一级type就是0，第二级是1，以此类推&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;另外自定义的类如果不需要extends的话那么需要继承wellijohn.org.treerecyclerview.vo.treeitem如果已经写了的话那么就需要自己实现tree接口&quot;&gt;5.另外自定义的类如果不需要extends的话，那么需要继承wellijohn.org.treerecyclerview.vo.TreeItem，如果已经写了的话，那么就需要自己实现Tree接口。&lt;/h2&gt;
&lt;p&gt;必须实现的几个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    int getLevel();//每个item的层级，比如一级就是0，二级就返回1，这里的0和1可以自己定义，后面就是根据这个来选择哪种样式的item

    List&amp;lt;T&amp;gt; getChilds();//返回的子列表，比如当前类是一级的话，那么这个方法返回的是二级的列表数据

    boolean isExpand();//是否展开，true展开，false不展开，一般就是点击下去修改这个值刷新adapter，就能达到展开还是折叠的目的了&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;引入方式&quot;&gt;6.引入方式&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;step 1.
Add it in your root build.gradle at the end of repositories:

    allprojects {
        repositories {
            ...
            maven { url 'https://jitpack.io' }
        }
    }
Step 2. Add the dependency

    dependencies {
            implementation 'com.github.WelliJohn:MultiLevelRecyclerView:0.0.1'
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;demo示例&quot;&gt;7.demo示例&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/WelliJohn/MultiLevelRecyclerView&quot;&gt;多级列表示例&lt;/a&gt;,如果觉得有用，还请点个赞。&lt;/p&gt;
</description>
<pubDate>Mon, 20 Aug 2018 06:37:00 +0000</pubDate>
<dc:creator>WelliJohn</dc:creator>
<og:description>先上效果图： 1.该多级列表的优势： 1. 支持无限级列表展开 2. 基于一个recyclerView实现 3. 可以自定义每一级item的样式，定制化更强 2.设计的思路 1. 数据结构List,I</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WellJohn/p/9505385.html</dc:identifier>
</item>
<item>
<title>30分钟，让你彻底明白Promise原理 - 网易云</title>
<link>http://www.cnblogs.com/163yun/p/9505378.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/163yun/p/9505378.html</guid>
<description>&lt;p&gt;本文来自&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//sq.163yun.com/blog&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;网易云社区&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;前一阵子记录了promise的一些常规用法，这篇文章再深入一个层次，来分析分析promise的这种规则机制是如何实现的。ps:本文适合已经对promise的用法有所了解的人阅读,如果对其用法还不是太了解，可以移步我的上一篇&lt;span&gt;&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//mengera88.github.io/2017/05/15/promise%25E5%25AD%25A6%25E4%25B9%25A0%25E7%25AC%2594%25E8%25AE%25B0/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;博文&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;本文的promise源码是按照&lt;span&gt;&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//promisesaplus.com/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;Promise/A+规范&lt;/a&gt;&lt;/span&gt;来编写的（不想看英文版的移步&lt;span&gt;&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=http%3A//www.ituring.com.cn/article/66566&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;Promise/A+规范中文翻译&lt;/a&gt;&lt;/span&gt;）&lt;/p&gt;

&lt;h2&gt;引子&lt;/h2&gt;

&lt;p&gt;为了让大家更容易理解，我们从一个场景开始讲解，让大家一步一步跟着思路思考，相信你一定会更容易看懂。&lt;/p&gt;

&lt;p&gt;考虑下面一种获取用户id的请求处理&lt;/p&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;//例1
function getUserId() {
    return new Promise(function(resolve) {
        //异步请求
        http.get(url, function(results) {
            resolve(results.id)
        })
    })
}

getUserId().then(function(id) {
    //一些处理
})
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;getUserId&lt;/code&gt;方法返回一个&lt;code&gt;promise&lt;/code&gt;，可以通过它的&lt;code&gt;then&lt;/code&gt;方法注册(注意&lt;code&gt;注册&lt;/code&gt;这个词)在&lt;code&gt;promise&lt;/code&gt;异步操作成功时执行的回调。这种执行方式，使得异步调用变得十分顺手。&lt;/p&gt;
&lt;h2&gt;&lt;br/&gt;原理剖析&lt;/h2&gt;

&lt;p&gt;那么类似这种功能的&lt;code&gt;Promise&lt;/code&gt;怎么实现呢？其实按照上面一句话，实现一个最基础的雏形还是很easy的。&lt;/p&gt;

&lt;h2&gt;极简promise雏形&lt;/h2&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;function Promise(fn) {
    var value = null,
        callbacks = [];  //callbacks为数组，因为可能同时有很多个回调

    this.then = function (onFulfilled) {
        callbacks.push(onFulfilled);
    };

    function resolve(value) {
        callbacks.forEach(function (callback) {
            callback(value);
        });
    }

    fn(resolve);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码很简单，大致的逻辑是这样的：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;调用&lt;code&gt;then&lt;/code&gt;方法，将想要在&lt;code&gt;Promise&lt;/code&gt;异步操作成功时执行的回调放入&lt;code&gt;callbacks&lt;/code&gt;队列，其实也就是注册回调函数，可以向观察者模式方向思考；&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;Promise&lt;/code&gt;实例时传入的函数会被赋予一个函数类型的参数，即&lt;code&gt;resolve&lt;/code&gt;，它接收一个参数value，代表异步操作返回的结果，当一步操作执行成功后，用户会调用&lt;code&gt;resolve&lt;/code&gt;方法，这时候其实真正执行的操作是将&lt;code&gt;callbacks&lt;/code&gt;队列中的回调一一执行；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以结合&lt;code&gt;例1&lt;/code&gt;中的代码来看，首先&lt;code&gt;new Promise&lt;/code&gt;时，传给&lt;code&gt;promise&lt;/code&gt;的函数发送异步请求，接着调用&lt;code&gt;promise&lt;/code&gt;对象的&lt;code&gt;then&lt;/code&gt;属性，注册请求成功的回调函数，然后当异步请求发送成功时，调用&lt;code&gt;resolve(results.id)&lt;/code&gt;方法, 该方法执行&lt;code&gt;then&lt;/code&gt;方法注册的回调数组。&lt;/p&gt;

&lt;p&gt;相信仔细的人应该可以看出来，&lt;code&gt;then&lt;/code&gt;方法应该能够链式调用，但是上面的最基础简单的版本显然无法支持链式调用。想让&lt;code&gt;then&lt;/code&gt;方法支持链式调用，其实也是很简单的：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;this.then = function (onFulfilled) {
    callbacks.push(onFulfilled);
    return this;
};
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;see?只要简单一句话就可以实现类似下面的链式调用：&lt;/p&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;// 例2
getUserId().then(function (id) {
    // 一些处理
}).then(function (id) {
    // 一些处理
});
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;br/&gt;加入延时机制&lt;/h2&gt;

&lt;p&gt;细心的同学应该发现，上述代码可能还存在一个问题：如果在&lt;code&gt;then&lt;/code&gt;方法注册回调之前，&lt;code&gt;resolve&lt;/code&gt;函数就执行了，怎么办？比如&lt;code&gt;promise&lt;/code&gt;内部的函数是同步函数：&lt;/p&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;// 例3
function getUserId() {
    return new Promise(function (resolve) {
        resolve(9876);
    });
}
getUserId().then(function (id) {
    // 一些处理
});
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这显然是不允许的，&lt;code&gt;Promises/A+&lt;/code&gt;规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此我们要加入一些处理，保证在&lt;code&gt;resolve&lt;/code&gt;执行之前，&lt;code&gt;then&lt;/code&gt;方法已经注册完所有的回调。我们可以这样改造下&lt;code&gt;resolve&lt;/code&gt;函数:&lt;/p&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;function resolve(value) {
    setTimeout(function() {
        callbacks.forEach(function (callback) {
            callback(value);
        });
    }, 0)
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码的思路也很简单，就是通过&lt;code&gt;setTimeout&lt;/code&gt;机制，将&lt;code&gt;resolve&lt;/code&gt;中执行回调的逻辑放置到&lt;code&gt;JS&lt;/code&gt;任务队列末尾，以保证在&lt;code&gt;resolve&lt;/code&gt;执行时，&lt;code&gt;then&lt;/code&gt;方法的回调函数已经注册完成.&lt;/p&gt;

&lt;p&gt;但是，这样好像还存在一个问题，可以细想一下：如果&lt;code&gt;Promise&lt;/code&gt;异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在&lt;code&gt;Promise&lt;/code&gt;异步操作成功这之后调用的&lt;code&gt;then&lt;/code&gt;注册的回调就再也不会执行了，这显然不是我们想要的。&lt;/p&gt;
&lt;h2&gt;&lt;br/&gt;加入状态&lt;/h2&gt;

&lt;p&gt;恩，为了解决上一节抛出的问题，我们必须加入状态机制，也就是大家熟知的&lt;code&gt;pending&lt;/code&gt;、&lt;code&gt;fulfilled&lt;/code&gt;、&lt;code&gt;rejected&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Promises/A+&lt;/code&gt;规范中的2.1&lt;code&gt;Promise States&lt;/code&gt;中明确规定了，&lt;code&gt;pending&lt;/code&gt;可以转化为&lt;code&gt;fulfilled&lt;/code&gt;或&lt;code&gt;rejected&lt;/code&gt;并且只能转化一次，也就是说如果&lt;code&gt;pending&lt;/code&gt;转化到&lt;code&gt;fulfilled&lt;/code&gt;状态，那么就不能再转化到&lt;code&gt;rejected&lt;/code&gt;。并且&lt;code&gt;fulfilled&lt;/code&gt;和&lt;code&gt;rejected&lt;/code&gt;状态只能由&lt;code&gt;pending&lt;/code&gt;转化而来，两者之间不能互相转换。一图胜千言：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;content_image lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-a90a6c703c051370aee8311ec00ef4a5_hd.jpg&quot; alt=&quot;&quot; width=&quot;353&quot; data-caption=&quot;&quot; data-rawwidth=&quot;353&quot; data-rawheight=&quot;260&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a90a6c703c051370aee8311ec00ef4a5_b.jpg&quot; data-size=&quot;normal&quot;/&gt;&lt;/p&gt;

&lt;p&gt;改进后的代码是这样的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;function Promise(fn) {
    var state = 'pending',
        value = null,
        callbacks = [];

    this.then = function (onFulfilled) {
        if (state === 'pending') {
            callbacks.push(onFulfilled);
            return this;
        }
        onFulfilled(value);
        return this;
    };

    function resolve(newValue) {
        value = newValue;
        state = 'fulfilled';
        setTimeout(function () {
            callbacks.forEach(function (callback) {
                callback(value);
            });
        }, 0);
    }

    fn(resolve);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码的思路是这样的：&lt;code&gt;resolve&lt;/code&gt;执行时，会将状态设置为&lt;code&gt;fulfilled&lt;/code&gt;，在此之后调用&lt;code&gt;then&lt;/code&gt;添加的新回调，都会立即执行。&lt;/p&gt;

&lt;p&gt;这里没有任何地方将&lt;code&gt;state&lt;/code&gt;设为&lt;code&gt;rejected&lt;/code&gt;，为了让大家聚焦在核心代码上，这个问题后面会有一小节专门加入。&lt;/p&gt;
&lt;h2&gt;&lt;br/&gt;链式Promise&lt;/h2&gt;

&lt;p&gt;那么这里问题又来了，如果用户再then函数里面注册的仍然是一个&lt;code&gt;Promise&lt;/code&gt;，该如何解决？比如下面的&lt;code&gt;例4&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;// 例4
getUserId()
    .then(getUserJobById)
    .then(function (job) {
        // 对job的处理
    });

function getUserJobById(id) {
    return new Promise(function (resolve) {
        http.get(baseUrl + id, function(job) {
            resolve(job);
        });
    });
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种场景相信用过&lt;code&gt;promise&lt;/code&gt;的人都知道会有很多，那么类似这种就是所谓的链式&lt;code&gt;Promise&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;链式&lt;code&gt;Promise&lt;/code&gt;是指在当前&lt;code&gt;promise&lt;/code&gt;达到&lt;code&gt;fulfilled&lt;/code&gt;状态后，即开始进行下一个&lt;code&gt;promise&lt;/code&gt;（后邻&lt;code&gt;promise&lt;/code&gt;）。那么我们如何衔接当前&lt;code&gt;promise&lt;/code&gt;和后邻&lt;code&gt;promise&lt;/code&gt;呢？（这是这里的难点）。&lt;/p&gt;

&lt;p&gt;其实也不是辣么难，只要在&lt;code&gt;then&lt;/code&gt;方法里面&lt;code&gt;return&lt;/code&gt;一个&lt;code&gt;promise&lt;/code&gt;就好啦。&lt;code&gt;Promises/A+&lt;/code&gt;规范中的2.2.7就是这么说哒(微笑脸)~&lt;/p&gt;

&lt;p&gt;下面来看看这段暗藏玄机的&lt;code&gt;then&lt;/code&gt;方法和&lt;code&gt;resolve&lt;/code&gt;方法改造代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;function Promise(fn) {
    var state = 'pending',
        value = null,
        callbacks = [];

    this.then = function (onFulfilled) {
        return new Promise(function (resolve) {
            handle({
                onFulfilled: onFulfilled || null,
                resolve: resolve
            });
        });
    };

    function handle(callback) {
        if (state === 'pending') {
            callbacks.push(callback);
            return;
        }
        //如果then中没有传递任何东西
        if(!callback.onFulfilled) {
            callback.resolve(value);
            return;
        }

        var ret = callback.onFulfilled(value);
        callback.resolve(ret);
    }


    function resolve(newValue) {
        if (newValue &amp;amp;&amp;amp; (typeof newValue === 'object' || typeof newValue === 'function')) {
            var then = newValue.then;
            if (typeof then === 'function') {
                then.call(newValue, resolve);
                return;
            }
        }
        state = 'fulfilled';
        value = newValue;
        setTimeout(function () {
            callbacks.forEach(function (callback) {
                handle(callback);
            });
        }, 0);
    }

    fn(resolve);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们结合&lt;code&gt;例4&lt;/code&gt;的代码，分析下上面的代码逻辑，为了方便阅读，我把&lt;code&gt;例4&lt;/code&gt;的代码贴在这里：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;// 例4
getUserId()
    .then(getUserJobById)
    .then(function (job) {
        // 对job的处理
    });

function getUserJobById(id) {
    return new Promise(function (resolve) {
        http.get(baseUrl + id, function(job) {
            resolve(job);
        });
    });
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;&lt;code&gt;then&lt;/code&gt;方法中，创建并返回了新的&lt;code&gt;Promise&lt;/code&gt;实例，这是串行&lt;code&gt;Promise&lt;/code&gt;的基础，并且支持链式调用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;handle&lt;/code&gt;方法是&lt;code&gt;promise&lt;/code&gt;内部的方法。&lt;code&gt;then&lt;/code&gt;方法传入的形参&lt;code&gt;onFulfilled&lt;/code&gt;以及创建新&lt;code&gt;Promise&lt;/code&gt;实例时传入的&lt;code&gt;resolve&lt;/code&gt;均被&lt;code&gt;push&lt;/code&gt;到当前&lt;code&gt;promise&lt;/code&gt;的&lt;code&gt;callbacks&lt;/code&gt;队列中，这是衔接当前&lt;code&gt;promise&lt;/code&gt;和后邻&lt;code&gt;promise&lt;/code&gt;的关键所在（这里一定要好好的分析下handle的作用）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getUserId&lt;/code&gt;生成的&lt;code&gt;promise&lt;/code&gt;（简称&lt;code&gt;getUserId promise&lt;/code&gt;）异步操作成功，执行其内部方法&lt;code&gt;resolve&lt;/code&gt;，传入的参数正是异步操作的结果&lt;code&gt;id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;handle&lt;/code&gt;方法处理&lt;code&gt;callbacks&lt;/code&gt;队列中的回调：&lt;code&gt;getUserJobById&lt;/code&gt;方法，生成新的&lt;code&gt;promise&lt;/code&gt;（&lt;code&gt;getUserJobById promise&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;执行之前由&lt;code&gt;getUserId promise&lt;/code&gt;的&lt;code&gt;then&lt;/code&gt;方法生成的新&lt;code&gt;promise&lt;/code&gt;(称为&lt;code&gt;bridge promise&lt;/code&gt;)的&lt;code&gt;resolve&lt;/code&gt;方法，传入参数为&lt;code&gt;getUserJobById promise&lt;/code&gt;。这种情况下，会将该&lt;code&gt;resolve&lt;/code&gt;方法传入&lt;code&gt;getUserJobById promise&lt;/code&gt;的&lt;code&gt;then&lt;/code&gt;方法中，并直接返回。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;getUserJobById promise&lt;/code&gt;异步操作成功时，执行其&lt;code&gt;callbacks&lt;/code&gt;中的回调：&lt;code&gt;getUserId bridge promise&lt;/code&gt;中的&lt;code&gt;resolve&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;最后执行&lt;code&gt;getUserId bridge promise&lt;/code&gt;的后邻&lt;code&gt;promise&lt;/code&gt;的&lt;code&gt;callbacks&lt;/code&gt;中的回调。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更直白的可以看下面的图，一图胜千言（都是根据自己的理解画出来的，如有不对欢迎指正）：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-73684d65d37e4179096f60b004785263_hd.jpg&quot; alt=&quot;&quot; width=&quot;2137&quot; data-caption=&quot;&quot; data-rawwidth=&quot;2137&quot; data-rawheight=&quot;1262&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-73684d65d37e4179096f60b004785263_b.jpg&quot; data-size=&quot;normal&quot; data-original=&quot;https://pic3.zhimg.com/v2-73684d65d37e4179096f60b004785263_r.jpg&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;失败处理&lt;/h2&gt;

&lt;p&gt;在异步操作失败时，标记其状态为&lt;code&gt;rejected&lt;/code&gt;，并执行注册的失败回调:&lt;/p&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;//例5
function getUserId() {
    return new Promise(function(resolve) {
        //异步请求
        http.get(url, function(error, results) {
            if (error) {
                reject(error);
            }
            resolve(results.id)
        })
    })
}

getUserId().then(function(id) {
    //一些处理
}, function(error) {
    console.log(error)
})
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有了之前处理&lt;code&gt;fulfilled&lt;/code&gt;状态的经验，支持错误处理变得很容易,只需要在注册回调、处理状态变更上都要加入新的逻辑：&lt;/p&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;22&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;function Promise(fn) {
    var state = 'pending',
        value = null,
        callbacks = [];

    this.then = function (onFulfilled, onRejected) {
        return new Promise(function (resolve, reject) {
            handle({
                onFulfilled: onFulfilled || null,
                onRejected: onRejected || null,
                resolve: resolve,
                reject: reject
            });
        });
    };

    function handle(callback) {
        if (state === 'pending') {
            callbacks.push(callback);
            return;
        }

        var cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected,
            ret;
        if (cb === null) {
            cb = state === 'fulfilled' ? callback.resolve : callback.reject;
            cb(value);
            return;
        }
        ret = cb(value);
        callback.resolve(ret);
    }

    function resolve(newValue) {
        if (newValue &amp;amp;&amp;amp; (typeof newValue === 'object' || typeof newValue === 'function')) {
            var then = newValue.then;
            if (typeof then === 'function') {
                then.call(newValue, resolve, reject);
                return;
            }
        }
        state = 'fulfilled';
        value = newValue;
        execute();
    }

    function reject(reason) {
        state = 'rejected';
        value = reason;
        execute();
    }

    function execute() {
        setTimeout(function () {
            callbacks.forEach(function (callback) {
                handle(callback);
            });
        }, 0);
    }

    fn(resolve, reject);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述代码增加了新的&lt;code&gt;reject&lt;/code&gt;方法，供异步操作失败时调用，同时抽出了&lt;code&gt;resolve&lt;/code&gt;和&lt;code&gt;reject&lt;/code&gt;共用的部分，形成&lt;code&gt;execute&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;错误冒泡是上述代码已经支持，且非常实用的一个特性。在&lt;code&gt;handle&lt;/code&gt;中发现没有指定异步操作失败的回调时，会直接将&lt;code&gt;bridge promise&lt;/code&gt;(&lt;code&gt;then&lt;/code&gt;函数返回的&lt;code&gt;promise&lt;/code&gt;，后同)设为&lt;code&gt;rejected&lt;/code&gt;状态，如此达成执行后续失败回调的效果。这有利于简化串行&lt;code&gt;Promise&lt;/code&gt;的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的：&lt;/p&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;//例6
getUserId()
    .then(getUserJobById)
    .then(function (job) {
        // 处理job
    }, function (error) {
        // getUserId或者getUerJobById时出现的错误
        console.log(error);
    });
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;异常处理&lt;/h2&gt;

&lt;p&gt;细心的同学会想到：如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用&lt;code&gt;try-catch&lt;/code&gt;捕获错误，并将&lt;code&gt;bridge promise&lt;/code&gt;设为&lt;code&gt;rejected&lt;/code&gt;状态。&lt;code&gt;handle&lt;/code&gt;方法改造如下：&lt;/p&gt;

&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;function handle(callback) {
    if (state === 'pending') {
        callbacks.push(callback);
        return;
    }

    var cb = state === 'fulfilled' ? callback.onFulfilled : callback.onRejected,
        ret;
    if (cb === null) {
        cb = state === 'fulfilled' ? callback.resolve : callback.reject;
        cb(value);
        return;
    }
    try {
        ret = cb(value);
        callback.resolve(ret);
    } catch (e) {
        callback.reject(e);
    } 
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果在异步操作中，多次执行&lt;code&gt;resolve&lt;/code&gt;或者&lt;code&gt;reject&lt;/code&gt;会重复处理后续回调，可以通过内置一个标志位解决。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;刚开始看promise源码的时候总不能很好的理解then和resolve函数的运行机理，但是如果你静下心来，反过来根据执行promise时的逻辑来推演，就不难理解了。这里一定要注意的点是：promise里面的then函数仅仅是注册了后续需要执行的代码，真正的执行是在resolve方法里面执行的，理清了这层，再来分析源码会省力的多。&lt;/p&gt;

&lt;p&gt;现在回顾下Promise的实现过程，其主要使用了设计模式中的观察者模式：&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;通过Promise.prototype.then和Promise.prototype.catch方法将观察者方法注册到被观察者Promise对象中，同时返回一个新的Promise对象，以便可以链式调用。&lt;/li&gt;
&lt;li&gt;被观察者管理内部pending、fulfilled和rejected的状态转变，同时通过构造函数中传递的resolve和reject方法以主动触发状态转变和通知观察者。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=http%3A//coderlt.coding.me/2016/12/04/promise-in-depth-an-introduction-2/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;深入理解 Promise&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=http%3A//www.mattgreer.org/articles/promises-in-wicked-detail/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;JavaScript Promises ... In Wicked Detail&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;本文来自网易云社区，经作者顾静授权发布。&lt;/p&gt;

</description>
<pubDate>Mon, 20 Aug 2018 06:36:00 +0000</pubDate>
<dc:creator>网易云</dc:creator>
<og:description>本文来自网易云社区。 前一阵子记录了promise的一些常规用法，这篇文章再深入一个层次，来分析分析promise的这种规则机制是如何实现的。ps:本文适合已经对promise的用法有所了解的人阅读,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/163yun/p/9505378.html</dc:identifier>
</item>
</channel>
</rss>