<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Nordic nRF51/nRF52开发环境搭建 - iini</title>
<link>http://www.cnblogs.com/iini/p/9043565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iini/p/9043565.html</guid>
<description>&lt;p&gt;本文将详述Nordic nRF51系列（包括nRF51822/nRF51802/nRF51422等）和nRF52系列（包括nRF52832/nRF52810/nRF52840）开发环境搭建。&lt;/p&gt;

&lt;p&gt;如下工具必须安装，否则无法开发Nordic nRF51/52产品&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;strong&gt;IDE&lt;/strong&gt;。Nordic nRF51/52支持Keil，GCC，IAR和SES（Segger Embedded Studio）四种IDE，大家随便选择&lt;strong&gt;其中一种&lt;/strong&gt;安装即可。
&lt;ul&gt;&lt;li&gt;Keil。大家自行下载安装，这里不再赘述。&lt;/li&gt;
&lt;li&gt;IAR。大家自行下载安装，这里不再赘述。&lt;/li&gt;
&lt;li&gt;SES（推荐）。SES跟Keil非常像，是Segger公司为Nordic芯片量身打造的，对Nordic用户来说，永久免费。SES支持Windows/MacOS/Linux三种平台，下载链接为：&lt;a href=&quot;https://www.segger.com/downloads/embedded-studio&quot;&gt;https://www.segger.com/downloads/embedded-studio&lt;/a&gt;。下载成功后，你将得到“Setup_EmbeddedStudio_v330_win_x64.exe”之类的安装包（Windows 64bit版本），成功安装后，SES软件界面如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225227611-1638399837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;em&gt;如果你是硬件工程师，IDE&lt;/em&gt;&lt;em&gt;不是必须安装的，因为Nordic SDK&lt;/em&gt;&lt;em&gt;所有例子都有已经编译好的hex&lt;/em&gt;&lt;em&gt;文件供你使用。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;         下完之后，你将得到 “nRF5_SDK_15.0.0_a53641a.zip”之类的压缩包，解压缩该压缩包，SDK即安装完成，如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225252288-1951246423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;安装与本&lt;/strong&gt;&lt;strong&gt;SDK&lt;/strong&gt;&lt;strong&gt;版本配套的&lt;/strong&gt;&lt;strong&gt;ARM CMSIS&lt;/strong&gt;&lt;strong&gt;软件包和&lt;/strong&gt;&lt;strong&gt;IDE&lt;/strong&gt;&lt;strong&gt;插件&lt;/strong&gt;。&lt;strong&gt;如果你是&lt;/strong&gt;&lt;strong&gt;Keil5&lt;/strong&gt;&lt;strong&gt;用户，&lt;/strong&gt;一般可以通过如下界面，把相应的CMSIS和Device family pack安装好&lt;strong&gt;。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225426866-617556650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于某些原因，很多用户在上述界面无法安装，因此可以将CMSIS和IDE插件从网上下载下来，单独安装。&lt;/p&gt;
&lt;p&gt;ARM CMSIS安装包下载地址：&lt;a href=&quot;https://github.com/ARM-software/CMSIS/releases&quot;&gt;https://github.com/ARM-software/CMSIS/releases&lt;/a&gt;。从如下界面选择你需要的CMSIS版本。那具体选择哪个CMSIS版本呢？你可以随便打开SDK中一个例子，Keil或者其他IDE就会报错告诉你缺少那个版本的CMSIS（一般来说，缺少的都是CMSIS4.5.0），你再把它下下来即可。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225459529-1496495135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;ARM CMSIS4.5.0 Windows/Keil5安装界面如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225520170-1633436188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;所有IDE插件都可以到如下网址下载：&lt;a href=&quot;https://www.nordicsemi.com/eng/Products/nRF52840#Downloads&quot;&gt;https://www.nordicsemi.com/eng/Products/nRF52840#Downloads&lt;/a&gt;。根据自己的IDE，选择相应的插件：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225538447-1028370593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：上述所有插件都有2&lt;/strong&gt;&lt;strong&gt;个版本，2&lt;/strong&gt;&lt;strong&gt;个版本的功能是一模一样的，只是版权会有点不同。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以Keil5插件为例，Keil5的插件是Device family pack（其实上文已经提到它了），其安装界面如下所示（安装过程中有可能会报错，不要管它！）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225648458-207165702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225728281-639623051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt; 以Windows系统为例，下载上图中的红圈中的win32版本，得到“nRF5x-Command-Line-Tools_9_7_2_Installer.exe”之类的可执行文件，双击安装，界面如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225825275-2081613229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;安装过程中，不要去更改默认选项，直接按照默认选项去安装即可。不过如下界面，一定要选择“select all”&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225837709-1529640434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2. 推荐安装项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;安卓版&lt;/strong&gt;&lt;strong&gt;nRF connect&lt;/strong&gt;&lt;strong&gt;或者&lt;/strong&gt;&lt;strong&gt;iOS&lt;/strong&gt;&lt;strong&gt;版&lt;/strong&gt;&lt;strong&gt;nRF connect&lt;/strong&gt;。nRF connect是Nordic开发的一个通用性BLE app，以支持BLE扫描，BLE连接，BLE广播，BLE监视，BLE服务发现，BLE连接后交互等功能。iOS版nRF connect请到苹果app store下载，搜索“nRF”即可以找到。安卓版nRF connect是放在Google play里面的，如果你无法访问Google play，那么可以到Nordic Github官网上下载，下载链接为：&lt;a href=&quot;https://github.com/NordicSemiconductor/Android-nRF-Connect/releases&quot;&gt;https://github.com/NordicSemiconductor/Android-nRF-Connect/releases&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          安装成功后，你将看到如下所示的nRF connect：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225903557-1699494374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225920979-1497263013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;           桌面版nRF connect安装成功后，将如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225932035-380338978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;确切地说，桌面版nRF connect更像一个容器，它可以装载各种不同的应用，前面提到的手机版nRF connect只是桌面版nRF connect的一个“Bluetooth Low Energy”应用。点击“Add/remove apps”，可以安装或者卸载Nordic其他的应用。另外，你也可以基于桌面版nRF connect（使用HTML5或者Javascript）来开发自己的应用，比如量产测试程序。&lt;/p&gt;

&lt;p&gt;注：&lt;strong&gt;桌面版&lt;/strong&gt;&lt;strong&gt;nRF connect&lt;/strong&gt;&lt;strong&gt;前身是Master Control Panel&lt;/strong&gt;&lt;strong&gt;（MCP&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;，Nordic现已正式停止对MCP的支持，MCP所有功能都可以通过桌面版nRF connect来取代和实现。&lt;/p&gt;

&lt;h2&gt;3. 可选安装项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;安卓版或者&lt;/strong&gt;&lt;strong&gt;iOS&lt;/strong&gt;&lt;strong&gt;版&lt;/strong&gt;&lt;strong&gt;nRF toolbox&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;nRF toolbox是Nordic开发的一系列BLE应用集，包括心率应用，蓝牙透传应用，DFU等。iOS版nRF toolbox请到苹果app store下载，搜索“nRF”即可以找到。安卓版nRF toolbox是放在Google play里面的，如果你无法访问Google play，那么可以到Nordic Github官网上下载，下载链接为：&lt;a href=&quot;https://github.com/NordicSemiconductor/Android-nRF-Toolbox/releases&quot;&gt;https://github.com/NordicSemiconductor/Android-nRF-Toolbox/releases&lt;/a&gt;。nRF Toolbox代码（包括iOS版和安卓版）是开源的，可以直接到上述Nordic Github上下载。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;          安装成功后，你将看到如下所示的nRF toolbox：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515225959394-556387113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;strong&gt;nRFgo studio&lt;/strong&gt;。图形化的Flash烧写工具，以及nRF24系列开发工具，而且还集成有DTM，DFU升级等功能，不过随着桌面版nRF connect功能越来越多，nRFgo studio越来越被边缘化，因为大部分nRFgo studio的功能都可以被桌面版nRF connect取代，比如Flash烧写，DFU等。nRFgo studio下载链接为：&lt;a href=&quot;https://www.nordicsemi.com/eng/Products/2.4GHz-RF/nRFgo-Studio/(language)/eng-GB#Downloads&quot;&gt;https://www.nordicsemi.com/eng/Products/2.4GHz-RF/nRFgo-Studio/(language)/eng-GB#Downloads&lt;/a&gt;。安装nRFgo studio的时候，请按照默认选项来安装（&lt;strong&gt;不要去更改默认的安装目录&lt;/strong&gt;！），安装成功后，界面如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230015488-1860139169.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注：nRFgo studio&lt;/strong&gt;&lt;strong&gt;安装包也自带Jlink&lt;/strong&gt;&lt;strong&gt;驱动安装包，如果你前面通过nRF5x command line tools&lt;/strong&gt;&lt;strong&gt;已经把jlink&lt;/strong&gt;&lt;strong&gt;驱动装好了，那么安装nRFgo studio&lt;/strong&gt;&lt;strong&gt;的时候就不要再安装Jlink&lt;/strong&gt;&lt;strong&gt;驱动了。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;nrfjprog&lt;/strong&gt;&lt;strong&gt;（必选）&lt;/strong&gt;。nrfjprog用于代码擦除烧写读取，芯片复位，存储器访问等，其使用界面（Windows命令行或者Linux命令行或者MacOS命令行）如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230039627-844344989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于在安装nRF5x command line tools的时候，系统就会自动安装nrfjprog，因此你不需要再额外安装nrfjprog。对于Windows系统，nrfjprog将位于如下目录“C:\Program Files (x86)\Nordic Semiconductor\nrf5x\bin” 你只需在Windows path变量（环境变量）中包含此目录，就可以直接在Windows‘Command Prompt’中执行nrfjprog命令了。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230100455-1038825601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;nrfjprog详细说明请参考：&lt;a href=&quot;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrf5x_command_line_tools%2Fnrf5x_nrfjprogexe.html&amp;amp;cp=5_1_3&quot;&gt;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrf5x_command_line_tools%2Fnrf5x_nrfjprogexe.html&amp;amp;cp=5_1_3&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Sniffer&lt;/strong&gt;。Sniffer用于抓取空中蓝牙包以debug通信问题，sniffer包括硬件和软件两部分，硬件就是一个nRF51的dongle或者PCA10028开发板或者PCA10040开发板（将来还会支持PCA10056开发板以及PCA10059 dongle），硬件连接图如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230113482-318584895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;软件就是Wireshark，界面如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230124589-1202823407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Sniffer详细使用说明请参考：&lt;a href=&quot;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fsniffer%2Fsniffer_intro.html&amp;amp;cp=5_4&quot;&gt;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fsniffer%2Fsniffer_intro.html&amp;amp;cp=5_4&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;低版本（&lt;/strong&gt;&lt;strong&gt;0.x.x&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;strong&gt;nrfutil&lt;/strong&gt;。低版本nrfutil主要用于&lt;strong&gt;明文&lt;/strong&gt;&lt;strong&gt;OTA/DFU&lt;/strong&gt;时生成手机端新固件zip包，安装nRFgo studio的时候，会自动安装nrfutil，nrfutil所在目录为“C:\Program Files (x86)\Nordic Semiconductor\nRFgo Studio”。 你只需在Windows path变量（环境变量）中包含此目录，就可以直接在Windows‘Command Prompt’中执行nrfutil命令了&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230143188-1255298707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;低版本nrfutil工作界面如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230216670-78836960.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;&lt;strong&gt;高版本&lt;/strong&gt;&lt;strong&gt;nrfutil&lt;/strong&gt;&lt;strong&gt;（&lt;/strong&gt;&lt;strong&gt;&amp;gt;1.5.0&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;。高版本nrfutil用于&lt;strong&gt;签名&lt;/strong&gt;&lt;strong&gt;OTA/DFU&lt;/strong&gt;时生成手机端新固件 zip包，以及生成公私钥对，生成settings page，执行DFU操作等，&lt;strong&gt;高版本&lt;/strong&gt;&lt;strong&gt;nrfutil&lt;/strong&gt;&lt;strong&gt;和低版本nrfutil&lt;/strong&gt;&lt;strong&gt;是两个完全不兼容的软件，使用的时候，一定要“&lt;/strong&gt;&lt;strong&gt;二选一”&lt;/strong&gt;，一般来说只有在早期的SDK9/10/11进行明文DFU的时候，才会用到低版本nrfutil，除此之外，都是要使用高版本nrfutil的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;高版本nrfutil&lt;/strong&gt;&lt;strong&gt;安装说明及使用说明请参考链接：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrfutil%2Fnrfutil_intro.html&amp;amp;cp=5_5&quot;&gt;http://infocenter.nordicsemi.com/index.jsp?topic=%2Fcom.nordic.infocenter.tools%2Fdita%2Ftools%2Fnrfutil%2Fnrfutil_intro.html&amp;amp;cp=5_5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可通过“nrfutil version”来得知当前nrfutil是高版本还是低版本，如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180515230245354-1507762851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;低版本nrfutil版本号一般为0.x.x，而高版本nrfutil版本号大于1.5.0。如果发现nrfutil版本弄错了，&lt;strong&gt;请通过修改&lt;/strong&gt;&lt;strong&gt;Windows path&lt;/strong&gt;&lt;strong&gt;变量（环境变量）来指向正确的nrfutil&lt;/strong&gt;&lt;strong&gt;版本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 15 May 2018 15:22:00 +0000</pubDate>
<dc:creator>iini</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iini/p/9043565.html</dc:identifier>
</item>
<item>
<title>goroutine和线程区别 - yanghuahui</title>
<link>http://www.cnblogs.com/yanghuahui/p/9043631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanghuahui/p/9043631.html</guid>
<description>&lt;p&gt;从调度上看，goroutine的调度开销远远小于线程调度开销。&lt;/p&gt;
&lt;p&gt;OS的线程由OS内核调度，每隔几毫秒，一个硬件时钟中断发到CPU，CPU调用一个调度器内核函数。这个函数暂停当前正在运行的线程，把他的寄存器信息保存到内存中，查看线程列表并决定接下来运行哪一个线程，再从内存中恢复线程的注册表信息，最后继续执行选中的线程。这种线程切换需要一个完整的上下文切换：即保存一个线程的状态到内存，再恢复另外一个线程的状态，最后更新调度器的数据结构。某种意义上，这种操作还是很慢的。&lt;/p&gt;
&lt;p&gt;Go运行的时候包涵一个自己的调度器，这个调度器使用一个称为一个M:N调度技术，m个goroutine到n个os线程（可以用GOMAXPROCS来控制n的数量），Go的调度器不是由硬件时钟来定期触发的，而是由特定的go语言结构来触发的，他不需要切换到内核语境，所以调度一个goroutine比调度一个线程的成本低很多。&lt;/p&gt;

&lt;p&gt;从栈空间上，goroutine的栈空间更加动态灵活。&lt;/p&gt;
&lt;p&gt;每个OS的线程都有一个固定大小的栈内存，通常是2MB，栈内存用于保存在其他函数调用期间哪些正在执行或者临时暂停的函数的局部变量。这个固定的栈大小，如果对于goroutine来说，可能是一种巨大的浪费。作为对比goroutine在生命周期开始只有一个很小的栈，典型情况是2KB, 在go程序中，一次创建十万左右的goroutine也不罕见（2KB*100,000=200MB）。而且goroutine的栈不是固定大小，它可以按需增大和缩小，最大限制可以到1GB。&lt;/p&gt;

&lt;p&gt;goroutine没有一个特定的标识。&lt;/p&gt;
&lt;p&gt;在大部分支持多线程的操作系统和编程语言中，线程有一个独特的标识，通常是一个整数或者指针，这个特性可以让我们构建一个线程的局部存储，本质是一个全局的map，以线程的标识作为键，这样每个线程可以独立使用这个map存储和获取值，不受其他线程干扰。&lt;/p&gt;
&lt;p&gt;goroutine中没有可供程序员访问的标识，原因是一种纯函数的理念，不希望滥用线程局部存储导致一个不健康的超距作用，即函数的行为不仅取决于它的参数，还取决于运行它的线程标识。&lt;/p&gt;

&lt;p&gt;reference: 《Go程序设计语言》&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 15:12:00 +0000</pubDate>
<dc:creator>yanghuahui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanghuahui/p/9043631.html</dc:identifier>
</item>
<item>
<title>MongoDB学习--安装与管理 - 伯乐钟情</title>
<link>http://www.cnblogs.com/lbole/p/8902337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lbole/p/8902337.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        MongoDB是一种强大、灵活，且易于扩展的通用型数据库。他能扩展出非常多的功能。如二级索引（secondary index）、范围查询（range query）、排序、聚合（aggregation），以及地理空间索引（geospatial index）。&lt;/p&gt;
&lt;p&gt;        1、易于使用&lt;/p&gt;
&lt;p&gt;        MongoDB是一个面向文档（document-oriented）的数据库，而不是关系型数据库。面向文档的数据库不在有“行（row）”的概念，取而代之的是更为灵活的“文档（document）”模型。通过在文档中嵌入文档和数组，面向文档的方法能够仅适用一条记录来表现复杂的层次关系。&lt;/p&gt;
&lt;p&gt;        不在有预定义模式（predefined schema），文档的键（key）和值（value）不在是固定的类型和大小。由于没有固定的模式，根据需要添加或删除字段变得更容易了。&lt;/p&gt;
&lt;p&gt;        2、易于扩展&lt;/p&gt;
&lt;p&gt;        MongoDB的设计采用横向扩展。面向文档的数据模型使它很容易地在多台服务器之间进行数据切割。MongoDB能自动处理跨集群的数据和负载，自动重新分配文档，以及将用户的路由到正确机器上。&lt;/p&gt;
&lt;p&gt;        3、丰富的功能&lt;/p&gt;
&lt;p&gt;        MongoDB作为一款通用型数据库，除了能够创建、读取、更新和删除数据之外，还提供一系列不断扩展的独特功能。&lt;/p&gt;
&lt;p&gt;        &lt;em&gt;索引（indexing）：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        MongoDB支持通用二级索引，允许多种快速查找，且提供唯一索引、符合索引、地理空间索引，以及全文索引。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        聚合（aggregation）：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        MongoDB支持“聚合管道（aggregation pipeline）”。用户能够通过简单的片段创建复杂的聚合，并通过数据库自动优化。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        特殊的集合类型：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        MongoDB支持存在时间有限的集合，适用于那些将在某个时刻过期的数据，如会话（session）。类似的，MongoDB也支持固定大小的集合，用于保存近期数据，如日志。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        文件存储（file storage）：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;        MongoDB支持一种非常易用的协议，用于存储大文件和文件元数据。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;        MongoDB并不具备一些在关系型数据库中很普遍的功能，如连接（join）和复杂的多事务（multirow transcation）。省略这些功能是出于架构上的考虑（为了得到更好的扩展性），因为在分布式系统中这两个功能难以高效地实现。&lt;/p&gt;
&lt;p&gt;        4、卓越的性能&lt;/p&gt;
&lt;p&gt;        MongoDB能对文档尽心动态填充（dynamic padding），也能预分配数据文件以利用额外的空间来换取稳定的新能。MongoDB把尽可能多的内存用作缓存（cache），一般会用尽服务器的可用内存，试图为每次查询自动选择正确的索引。  所以MongoDB会非常占用服务器内存，目前并没有什么办法可以限制MongoDB占用内存的方法，所以一般不建议在MongoDB服务器上启用其他进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、下载安装包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下载地址为：&lt;a href=&quot;https://www.mongodb.com/download-center?jmp=nav#community&quot; target=&quot;_blank&quot;&gt;https://www.mongodb.com/download-center?jmp=nav#community&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows: mongodb-win32-x86_64-2008plus-ssl-3.6.4.zip&lt;/p&gt;
&lt;p&gt;Linux（CentOS 7）: mongodb-linux-x86_64-rhel70-3.6.4.tgz&lt;/p&gt;
&lt;p&gt;注意：这里下载的都是压缩包，本文不提供rpm和msi等可执行程序的安装方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、Windows下的MongoDB单节点安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们将下载完的包解压：C:/context/mongodb&lt;/p&gt;
&lt;p&gt;在工作目录下创建MongoDB数据存放目录：D:/workspaces/mongodbspaces/data&lt;/p&gt;
&lt;p&gt;在工作目录下创建MongoDB日志文件：D:/workspaces/mongodbspaces/logs/mongodb.log&lt;/p&gt;
&lt;p&gt;在安装目录下创建config目录：C:/context/mongodb/config&lt;/p&gt;
&lt;p&gt;在配置目录下创建配置文件：C:/context/mongodb/config/config.conf&lt;/p&gt;
&lt;p&gt;修改配置文件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemLog:
    # 日志级别，&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;：包含“&lt;span&gt;info&lt;/span&gt;”信息，&lt;span&gt;1&lt;/span&gt;~&lt;span&gt;5&lt;/span&gt;，即大于0的值均会包含debug信息。类型: integer，默认: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    verbosity: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    # 发送所有的诊断信息日志文件的路径。systemLog.destination为file时有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。
    path: D:&lt;/span&gt;/workspaces/mongodbspaces/logs/&lt;span&gt;mongodb.log
    # 如果是true，则mongod服务重启时会将日志追加到日志末尾，否则每次重启会备份已有的日志并创建新日志。
    # 类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    logAppend: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 日志输出目的地，可以指定为“&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;”或者“syslog”，如果指定“&lt;span&gt;file&lt;/span&gt;&lt;span&gt;”则必须要设置systemLog.path。
    # 如果不指定，则会输出到标准输出中（standard output）。
    destination: &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
processManagement:
    # Windows特有配置选项
    windowsService:
        # mongos&lt;/span&gt;/mongod作为Windows服务时的服务名称，在net start &amp;lt;name&amp;gt;和net stop &amp;lt;name&amp;gt;&lt;span&gt;时使用。
        # 类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。默认: MongoDB
        # 必须与&lt;/span&gt;--&lt;span&gt;install&lt;/span&gt; 安装服务或者--&lt;span&gt;remove删除服务结合使用。
        serviceName: MongoDB
        # 在服务管理应用程序中MongoDB服务应用程序的名称。默认: MongoDB
        displayName: MongoDB
        # 设置MongoDB服务的描述，默认为MongoDB Server，在&lt;/span&gt;--&lt;span&gt;install安装服务时使用。
        description: MongoDB Server
net:
    # mongod&lt;/span&gt;/mongos服务侦听客户端连接的端口。类型: &lt;span&gt;int&lt;/span&gt;。默认: &lt;span&gt;27017&lt;/span&gt;&lt;span&gt;。
    port: &lt;/span&gt;&lt;span&gt;27017&lt;/span&gt;&lt;span&gt;
    # mongod&lt;/span&gt;/&lt;span&gt;monogs应用侦听客户端的IP地址或者完整UNIX域套接字路径，如果想要绑定多个地址使用逗号分隔。
    # 若要绑定到所有IPv4地址，请输入0.&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;。与net.bindIpAll配置互斥，不能同时配置两个。
    # 类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。默认: localhost
    bindIp: &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
security:
    # 打开访问数据库和进行操作的用户角色认证，仅mongod有效。disabled: 关闭; enabled: 开启（默认开启）
    authorization: enabled
    # 启用或禁用服务器端JavaScript执行，仅mongod有效。
    # 如果为false，那么任何与javascript相关的功能都不能使用。类型: boolean。默认: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    javascriptEnabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
setParameter:
    # 如果开启，则允许本机（localhost&lt;/span&gt;/&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;）第一次访问时不需要密码认证，以便于创建第一个admin数据库的用户
    # &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;/1或者false/&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，默认为true。mongods和mongod有效，建议mongod关闭该功能。
    enableLocalhostAuthBypass: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 认证机制，可选值为“SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;”、“MONGODB-CR”、“PLAN”等，建议为“SCRAM-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;”
    authenticationMechanisms: SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
storage:
    # mongod实例存储数据库文件路径，仅mongod有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    dbPath: D:&lt;/span&gt;/workspaces/mongodbspaces/&lt;span&gt;data
    journal:
        # 是否开启journal日志持久存储，journal日志用来数据恢复，
        # 是mongod最基础的特性，通常用于故障恢复，仅mongod有效。
        # 类型: boolean。64bit默认为true，32bit默认为false
        enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 是否将不同DB的数据存储在不同的目录中，dbPath的子目录，目录名为db的名称，仅mongod有效。
    # 类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    directoryPerDB: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置mongodb环境变量这里就不赘述了。我们执行命令将MongoDB安装成服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mongod.exe --config C:/context/mongodb/config/config.conf --&lt;span&gt;install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要删除MongoDB服务，则需要执行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mongod.exe --config C:/context/mongodb/config/config.conf --remove
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要重新安装MongoDB（先卸载再安装）,则需要执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mongod.exe --config C:/context/mongodb/config/config.conf --reinstall
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，这里的--config选项的值必须是绝对路径，也可以使用-f参数后面跟配置文件路径，这些操作都必须是在管理员CMD命令窗口里面完成。至此MongoDB的安装已经完成，我们需要先启动MongoDB服务，然后创建admin数据库下的管理员账号和密码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
C:\Users\Administrator&amp;gt;&lt;span&gt; mongo
...
&lt;/span&gt;&amp;gt;&lt;span&gt; use admin
...
&lt;/span&gt;&amp;gt; db.createUser({user: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;pwd&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, roles: [{role: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, db: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}]})
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，由于我们第一次启动之前就已经打开了角色认证功能: security.authorization: enabled，但是初始是没有用户和密码的。MongoDB中 &lt;span class=&quot;cnblogs_code&quot;&gt;setParameter.enableLocalhostAuthBypass: &lt;span&gt;true&lt;/span&gt;&lt;/span&gt; 这个配置是默认开启的，使用localhost/127.0.0.1第一次登录的时候可以免去角色认证，但是也仅有一次机会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、Linux下的MongoDB单节点安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们将下载完的包解压：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] &lt;span&gt;tar&lt;/span&gt; -zxvf mongodb-linux-x86_64-rhel70-&lt;span&gt;3.6&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;.tgz -C /use/local/mongodb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在工作目录下创建MongoDB数据存放目录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] &lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/data -p
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在工作目录下创建MongoDB日志文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] &lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/logs/ -&lt;span&gt;p
[root@abc] &lt;/span&gt;&lt;span&gt;touch&lt;/span&gt; /data/mongodb/logs/mongodb.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在安装目录下创建config配置文件，并编辑配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] &lt;span&gt;mkdir&lt;/span&gt; /usr/local/mongodb/config -&lt;span&gt;p
[root@abc] vim &lt;/span&gt;/usr/local/mongodb/config/config.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemLog:
    # 日志级别，&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;：包含“&lt;span&gt;info&lt;/span&gt;”信息，&lt;span&gt;1&lt;/span&gt;~&lt;span&gt;5&lt;/span&gt;，即大于0的值均会包含debug信息。类型: integer，默认: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    verbosity: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    # 发送所有的诊断信息日志文件的路径。systemLog.destination为file时有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。
    path: &lt;/span&gt;/data/mongodb/logs/&lt;span&gt;mongodb.log
    # 如果是true，则mongod服务重启时会将日志追加到日志末尾，否则每次重启会备份已有的日志并创建新日志。
    # 类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    logAppend: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 日志输出目的地，可以指定为“&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;”或者“syslog”，如果指定“&lt;span&gt;file&lt;/span&gt;&lt;span&gt;”则必须要设置systemLog.path。
    # 如果不指定，则会输出到标准输出中（standard output）。
    destination: &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
processManagement:
    # 是否以守护进程（后台进程）的方式运行mongod&lt;/span&gt;/mongos进程。类型: boolean。默认: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    fork: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    # 配合&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork:true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;参数，将mongod/mongos进程ID写入指定的文件，如果不指定，将不会创建PID文件。类型: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    pidFilePath: &lt;/span&gt;/data/mongodb/logs/&lt;span&gt;mongodb.pid
net:
    # MongoDB服务监听端口
    port: &lt;/span&gt;&lt;span&gt;27017&lt;/span&gt;&lt;span&gt;
    # 指定MongoDB绑定的IP，多个IP使用逗号分隔。如果是0.&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;.0则可是使用机器上的任何IP访问，否则只能使用指定IP访问
    bindIp: &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
storage:
    # 指定数据文件的路径
    dbPath: &lt;/span&gt;/data/mongodb/&lt;span&gt;data
    # 默认关闭
    directoryPerDB: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    journal:
        # 记录操作日志，防止数据丢失。64bit默认为true，32bit默认为false
        enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
security:
    # 打开访问数据库和进行操作的用户角色认证，仅mongod有效。disabled: 关闭; enabled: 开启（默认开启）
    authorization: enabled
setParameter:
    # 如果开启，则允许本机（localhost&lt;/span&gt;/&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;）第一次访问时不需要密码认证，以便于创建第一个admin数据库的用户
    # &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;/1或者false/&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，默认为true。mongods和mongod有效，建议mongod关闭该功能。
    enableLocalhostAuthBypass: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 认证机制，可选值为“SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;”、“MONGODB-CR”、“PLAN”等，建议为“SCRAM-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;”
    authenticationMechanisms: SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建mongodb.service文件，将mongodb配置成Linux服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] vim /lib/systemd/system/mongodb.service
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Unit]

Description&lt;/span&gt;=&lt;span&gt;mongodb 
After&lt;/span&gt;=network.target remote-fs.target nss-&lt;span&gt;lookup.target

[Service]
Type&lt;/span&gt;=&lt;span&gt;forking
ExecStart&lt;/span&gt;=/usr/local/mongodb/bin/mongod --config /usr/local/mongodb/config/&lt;span&gt;config.conf
ExecReload&lt;/span&gt;=/bin/&lt;span&gt;kill&lt;/span&gt; -&lt;span&gt;s HUP $MAINPID
ExecStop&lt;/span&gt;=/usr/local/mongodb/bin/mongod --shutdown --config /usr/local/mongodb/config/&lt;span&gt;config.conf
PrivateTmp&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;

[Install]
WantedBy&lt;/span&gt;=multi-user.target
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置MongoDB服务开机启动:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] systemctl enable mongodb.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要取消开机启动则执行:  systemctl disable mongodb.service&lt;/p&gt;
&lt;p&gt;第一次启动MongoDB服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] systemctl start mongodb.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要停止服务则执行: systemctl stop mongodb.service&lt;/p&gt;
&lt;p&gt;配置mongodb环境变量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] vim /etc/profile
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;...
...
export PATH&lt;/span&gt;=$PATH:/usr/local/mongodb/&lt;span&gt;bin

:wq&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] source /etc/profile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后开始创建admin数据库的root角色用户。记住，这里只有一次机会免密码登入创建用户：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@abc] mongo
...
&lt;/span&gt;&amp;gt;&lt;span&gt; use admin
...
&lt;/span&gt;&amp;gt; db.createUser({user: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;pwd&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, roles: [{role: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, db: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}]})
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;五、Linux下的MongoDB集群安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在安装之前，我们得先要了解一下MongoDB集群的集群类型，以及集群中的一些角色和它们的作用。mongodb有传统的主从集群（未来可能会被废弃）、副本集集群和分片集群三种模式的集群，传统的主从集群这里不做介绍。副本集和分片两种集群模式并不对立，既可以单独部署也可以组合部署。&lt;/p&gt;
&lt;p&gt;1、副本集&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1382225/201805/1382225-20180515225034285-1769057630.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　在副本集集群中有两种类型的角色：主节点（primary）和备用节点（secondary）。客户端只会与主节点进行数据交互（只有主节点允许写操作），备用节点通过oplog日志异步复制主节点数据，oplog包含了主节点的每一次写操作，是主节点中local数据库中的一个固定集合，备用节点通过这个集合复制主节点数据，每个备用节点都维护着自己的oplog，记录者每一次从主节点复制数据的操作，备用节点不对外提供服务。&lt;/p&gt;
&lt;p&gt;        集群中每个成员会每隔2秒向其他成员发送一条心跳请求，确认集群中成员的状态（那个是主节点，那个可以作为同步源、  那个节点下线了），心跳信息量非常小，用于检查每个成员状态。心跳的功能之一就是让主节点知道自己是否满足集合“大多数”的条件，如果主节点不在得到“大多数”服务器的支持，他就会退位，变成备用节点。&lt;/p&gt;
&lt;p&gt;        如果主节点宕机或者由于网络原因，备用节点无法连接到主节点，那么所有得到这个消息的备用节点都会申请被选举成为主节点，希望被选举成为主节点的成员会向它能到达的所有成员发送通知。如果这个申请选举的成员不符合候选主节点要求（这个成员的数据落后于副本集，或者只是由于网络原因备用节点无法到达主节点而申请的选举），其他成员不会进行选举。&lt;/p&gt;
&lt;p&gt;        如果没有反对理由，那么其他成员就会对这个成员进行选举投票。如果这个成员得到副本集中“大多数”赞成票，那么它就会被选举成为主节点。如果达不到“大多数”的要求，那么选举失败，它仍然助于备用节点状态，它之后还可以在此申请。主节点会一直处于主节点状态，除非它由于不在满足“大多数”的要求而退位。副本集节点数据必须是奇数个，否则在选举时可能会出现平局的选举结果导致无法出现主节点而集群不能工作。如果一定要使用偶数个节点，那么就必须再加一个仲裁节点，仲裁节点只会在选举平局的时候出来仲裁，并不会提供其他任何服务，所以占用资源非常少，但官方建议使用奇数个节点。&lt;/p&gt;
&lt;p&gt;2、分片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1382225/201805/1382225-20180515225159791-1009795662.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分片是指将数据拆分，将其分散存放到不同的机器上的过程。在分片集群中有配置服务（Config Server）、路由服务（Router Server）、和分片服务（Shard Server）等角色。mongodb本身有两种组件：mongod和mongos，Shard Server和Config Server服务是以mongod类型的进程运行的，Router Server是以mongos类型的进程运行的。&lt;/p&gt;
&lt;p&gt;        Config Server：配置服务相当于集群大脑，保存着集群和分片的元数据，即各分片包含着那些数据的信息。MongDB 3.4  之后要求配置服务必须是奇数个节点的副本集，否则集群不能正常启动。鉴于配置服务所包含的数据极端重要，所以必须启用日志功能，并确保其数据保存在非易失性驱动器上。&lt;/p&gt;
&lt;p&gt;        Router Server：前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。mongos能够根据给定的片键找到文档的存放位置，但当集群中存在成千上万个文档时，就会难以操作。因此将文档分组为块（chunk），每个块由给定片键特定范围内的文档组成。一个块只存在一个分片上，所以可以使用一个比较小的空间就能够维护块和分片间的映射。数据块大小是固定的，均衡器（balancer）会周期性地检查快的大小，当块超过这个大小之后，会有均衡器将其拆分为多个块，以保证数据均衡。&lt;/p&gt;
&lt;p&gt;        Shard Server：用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个副本集承担，防止主机单点故障。当需要对集合分片时，就必须得指定一个片键，片键必须有索引，如果集合已存储了大量数据，那么基本就不可能再修改片键了，因此选择片键时需要慎重。&lt;/p&gt;
&lt;p&gt;3、分片+副本集集群安装&lt;/p&gt;
&lt;p&gt;        通过上面的描述，我们大概已经了解了分片+副本集集群的相关概念，可以开始安装了。这里我们提供三台机器供安装，服务规划为：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;172.23.102.56&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;172.23.102.57&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;172.23.102.58&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;mongos port:27017&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;mongos port:27017&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;mongos port:27017&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;config server port:27018&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;config server port:27018&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;config server port:27018&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;shard1 server port:27019&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;shard1 server port:27019&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;shard1 server port:27019&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;shard2 server port:27020&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;shard2 server port:27020&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;shard2 server port:27020&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;shard3 server port:28021&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;shard3 server port:28021&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;shard3 server port:28021&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;将安装包解压到/use/local/mongodb目录下（三个机器相同操作）:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] &lt;span&gt;tar&lt;/span&gt; -zxvf mongodb-linux-x86_64-rhel70-&lt;span&gt;3.6&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;.tgz -C /use/local/mongodb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在安装目录下创建配置文件存放目录和配置文件（三个机器相同操作）:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@abc] &lt;span&gt;mkdir&lt;/span&gt; /usr/local/mongodb/&lt;span&gt;config
[root@abc] cd &lt;/span&gt;/usr/local/mongodb/&lt;span&gt;config
[root@abc] &lt;/span&gt;&lt;span&gt;touch&lt;/span&gt; mongos.conf config.conf shard1.conf shard2.conf shard3.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件目录和配置文件都已经创建好了，其中 mongos.conf 为路由服务配置文件， config.conf 为配置服务配置文件， shard1.conf shard2.conf shard3.conf 为三个分片服务配置文件。我们开始创建数据存储目录（三个机器相同操作）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@abc] &lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/mongos/logs -&lt;span&gt;p ## mongos日志文件存储目录，由于mongos不存储数据，所以不需要数据存储目录
[root@abc] &lt;/span&gt;&lt;span&gt;touch&lt;/span&gt; /data/mongodb/mongos/logs/&lt;span&gt;mongos.log ## mongos日志文件
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/config/logs -&lt;span&gt;p         ## config日志文件存储目录
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/config/logs/&lt;span&gt;config.log ## config日志文件
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/config/data -&lt;span&gt;p         ## config数据文件存储目录
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/shard1/logs -&lt;span&gt;p         ## 第一个分片日志文件存储目录
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/shard1/logs/&lt;span&gt;shard1.log ## 第一个分片日志文件
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/shard1/data -&lt;span&gt;p         ## 第一个分片数据文件存储目录
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/shard2/logs -&lt;span&gt;p         ## 第二个分片日志文件存储目录
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/shard2/logs/&lt;span&gt;shard2.log ## 第二个分片日志文件
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/shard2/data -&lt;span&gt;p         ## 第二个分片数据文件存储目录
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/shard3/logs -&lt;span&gt;p         ## 第三个分片日志文件存储目录
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/shard3/logs/&lt;span&gt;shard3.log ## 第三个分片日志文件
[root@abc] &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /data/mongodb/shard3/data -p         ## 第三个分片数据文件存储目录
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我们使用keyFile的方式作为集群成员之间的安全校验，所以需要先生成keyFile文件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@abc] openssl rand -base64 &lt;span&gt;756&lt;/span&gt; &amp;gt; /usr/local/mongodb/keyFile.&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
[root@abc] &lt;/span&gt;&lt;span&gt;chmod&lt;/span&gt; &lt;span&gt;400&lt;/span&gt; /usr/local/mongodb/keyFile.&lt;span&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编写config server配置文件，在三个机器中除 net.bindIp 配置需要对应到不同的机器之外，其他配置都一样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemLog:
    # 日志级别，&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;：包含“&lt;span&gt;info&lt;/span&gt;”信息，&lt;span&gt;1&lt;/span&gt;~&lt;span&gt;5&lt;/span&gt;，即大于0的值均会包含debug信息。类型: integer，默认: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    verbosity: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    # 发送所有的诊断信息日志文件的路径。systemLog.destination为file时有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。
    path: &lt;/span&gt;/data/mongodb/config/logs/&lt;span&gt;config.log
    # 如果是true，则mongod服务重启时会将日志追加到日志末尾，否则每次重启会备份已有的日志并创建新日志。
    # 类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    logAppend: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 日志输出目的地，可以指定为“&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;”或者“syslog”，如果指定“&lt;span&gt;file&lt;/span&gt;&lt;span&gt;”则必须要设置systemLog.path。
    # 如果不指定，则会输出到标准输出中（standard output）。
    destination: &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
processManagement:
    # 是否以守护进程（后台进程）的方式运行mongod&lt;/span&gt;/mongos进程。类型: boolean。默认: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    # 在Linux下如果是使用npm包的方式安装，并使用自带的init script脚本，则不推荐修改默认值。
    # 否则需要禁用默认的init script，而使用自己的init script。
    fork: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    # 配合&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork:true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;参数，将mongod/mongos进程ID写入指定的文件，如果不指定，将不会创建PID文件。类型: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    pidFilePath: &lt;/span&gt;/data/mongodb/config/logs/&lt;span&gt;config.pid
net:
    # mongod&lt;/span&gt;/mongos服务侦听客户端连接的端口。类型: &lt;span&gt;int&lt;/span&gt;。默认: &lt;span&gt;27017&lt;/span&gt;&lt;span&gt;。
    port: &lt;/span&gt;&lt;span&gt;27018&lt;/span&gt;&lt;span&gt;
    # mongod&lt;/span&gt;/&lt;span&gt;monogs应用侦听客户端的IP地址或者完整UNIX域套接字路径，如果想要绑定多个地址使用逗号分隔。
    # 若要绑定到所有IPv4地址，请输入0.&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;。与net.bindIpAll配置互斥，不能同时配置两个。
    # 类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。默认: localhost
    bindIp: &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.56&lt;/span&gt; / &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.57&lt;/span&gt; / &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.58&lt;/span&gt;&lt;span&gt; #这里三个设备分别对应
security:
    # 密钥文件的路径，它存储MongoDB实例在共享的集群或副本集中相互验证的共享密钥。
    # 必须设置security.authorization为enable。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    keyFile: &lt;/span&gt;/usr/local/mongodb/keyFile.&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
    # 集群成员之间的认证模式。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。可选: keyFile、sendKeyFile、sendX509、x509。默认: keyFile。
    clusterAuthMode: keyFile
    # 打开访问数据库和进行操作的用户角色认证，仅mongod有效。disabled: 关闭; enabled: 开启（默认开启）
    authorization: enabled
    # 启用或禁用服务器端JavaScript执行，仅mongod有效。
    # 如果为false，那么任何与javascript相关的功能都不能使用。类型: boolean。默认: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    javascriptEnabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
setParameter:
    # 如果开启，则允许本机（localhost&lt;/span&gt;/&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;）第一次访问时不需要密码认证，以便于创建第一个admin数据库的用户
    # &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;/1或者false/&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，默认为true。mongods和mongod有效，建议mongod关闭该功能。
    enableLocalhostAuthBypass: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 认证机制，可选值为“SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;”、“MONGODB-CR”、“PLAN”等，建议为“SCRAM-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;”
    authenticationMechanisms: SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
storage:
    # mongod实例存储数据库文件路径，仅mongod有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    dbPath: &lt;/span&gt;/data/mongodb/config/&lt;span&gt;data
    # 是否将不同DB的数据存储在不同的目录中，dbPath的子目录，目录名为db的名称，仅mongod有效。类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    directoryPerDB: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    journal:
        # 记录操作日志，防止数据丢失。64bit默认为true，32bit默认为false
        enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
replication:
    # 指定oplog的最大尺寸。对于已经建立过oplog.rs的数据库，指定无效。
    # 默认为磁盘的5&lt;/span&gt;%&lt;span&gt;。仅mongod有效
    # oplogSizeMB: 
    # 指定副本集的名称。仅mongod有效
    replSetName: config
    # 指定副本集成员在接受oplog之前是否加载索引到内存。默认会加载所有的索引到内存。
    # none，不加载;all，加载所有;_id_only，仅加载_id。仅mongod有效
    secondaryIndexPrefetch: all
sharding:
    # 指定分片集的mongodb角色。configsvr: 配置服务器。shardsvr: 分片实例。仅mongod有效
    clusterRole: configsvr
    # 在块移动过程中，该选项强制mongodb实例保存所有移动的文档到moveChunk目录。
    # 在版本3.2及以后版本中默认值为false。
    archiveMovedChunks: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分别启动三个机器上的config server：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] mongod --config /usr/local/mongodb/config/config.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当三个机器上的配置服务都启动之后，然后随便选择一个服务登入，将三个配置服务节点添加到一个副本集中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@abc] mongo --port &lt;span&gt;21018&lt;/span&gt;&lt;span&gt;  #连接
...
&lt;/span&gt;&amp;gt; config =&lt;span&gt; {
&lt;/span&gt;&amp;gt; ...     _id: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  # 配置文件中配置服务副本集的名称
&lt;/span&gt;&amp;gt;&lt;span&gt; ...     members: [
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;0&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.56:21018&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;1&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.57:21018&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;2&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.58:21018&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&amp;gt;&lt;span&gt; ...     ]
&lt;/span&gt;&amp;gt;&lt;span&gt; ... }  # 设置变量
...
rs.initiate(config)  # 初始化副本集
...
rs.status();  # 查看副本集状态&lt;br/&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这里使用的是偶数个节点的话，那么就需要多加一个参数 {_id : 2, host : &quot;172.23.102.58:21018&quot;, arbiterOnly: true } ，表示58这个机器为仲裁节点。需要注意的是，配置服务一定要在mongos路由服务之前启动并初始化完成，因为mongos服务需要依赖配置服务中的数据。&lt;/p&gt;
&lt;p&gt;编写shard1 server配置文件，在三个机器中除 net.bindIp 配置需要对应到不同的机器之外，其他配置都一样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemLog:
    # 日志级别，&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;：包含“&lt;span&gt;info&lt;/span&gt;”信息，&lt;span&gt;1&lt;/span&gt;~&lt;span&gt;5&lt;/span&gt;，即大于0的值均会包含debug信息。类型: integer，默认: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    verbosity: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    # 发送所有的诊断信息日志文件的路径。systemLog.destination为file时有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。
    path: &lt;/span&gt;/data/mongodb/shard1/logs/&lt;span&gt;shard1.log
    # 如果是true，则mongod服务重启时会将日志追加到日志末尾，否则每次重启会备份已有的日志并创建新日志。
    # 类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    logAppend: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 日志输出目的地，可以指定为“&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;”或者“syslog”，如果指定“&lt;span&gt;file&lt;/span&gt;&lt;span&gt;”则必须要设置systemLog.path。
    # 如果不指定，则会输出到标准输出中（standard output）。
    destination: &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
processManagement:
    # 是否以守护进程（后台进程）的方式运行mongod&lt;/span&gt;/mongos进程。类型: boolean。默认: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    # 在Linux下如果是使用npm包的方式安装，并使用自带的init script脚本，则不推荐修改默认值。
    # 否则需要禁用默认的init script，而使用自己的init script。
    fork: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    # 配合&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork:true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;参数，将mongod/mongos进程ID写入指定的文件，如果不指定，将不会创建PID文件。类型: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    pidFilePath: &lt;/span&gt;/data/mongodb/shard1/logs/&lt;span&gt;shard1.pid
net:
    # mongod&lt;/span&gt;/mongos服务侦听客户端连接的端口。类型: &lt;span&gt;int&lt;/span&gt;。默认: &lt;span&gt;27017&lt;/span&gt;&lt;span&gt;。
    port: &lt;/span&gt;&lt;span&gt;27019&lt;/span&gt;&lt;span&gt;
    # mongod&lt;/span&gt;/&lt;span&gt;monogs应用侦听客户端的IP地址或者完整UNIX域套接字路径，如果想要绑定多个地址使用逗号分隔。
    # 若要绑定到所有IPv4地址，请输入0.&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;。与net.bindIpAll配置互斥，不能同时配置两个。
    # 类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。默认: localhost
    bindIp: &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.56&lt;/span&gt; / &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.57&lt;/span&gt; / &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.58&lt;/span&gt;&lt;span&gt; #这里三个设备分别对应
security:
    # 密钥文件的路径，它存储MongoDB实例在共享的集群或副本集中相互验证的共享密钥。
    # 必须设置security.authorization为enable。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    keyFile: &lt;/span&gt;/usr/local/mongodb/keyFile.&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
    # 集群成员之间的认证模式。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。可选: keyFile、sendKeyFile、sendX509、x509。默认: keyFile。
    clusterAuthMode: keyFile
    # 打开访问数据库和进行操作的用户角色认证，仅mongod有效。disabled: 关闭; enabled: 开启（默认开启）
    authorization: enabled
    # 启用或禁用服务器端JavaScript执行，仅mongod有效。
    # 如果为false，那么任何与javascript相关的功能都不能使用。类型: boolean。默认: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    javascriptEnabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
setParameter:
    # 如果开启，则允许本机（localhost&lt;/span&gt;/&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;）第一次访问时不需要密码认证，以便于创建第一个admin数据库的用户
    # &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;/1或者false/&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，默认为true。mongods和mongod有效，建议mongod关闭该功能。
    enableLocalhostAuthBypass: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 认证机制，可选值为“SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;”、“MONGODB-CR”、“PLAN”等，建议为“SCRAM-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;”
    authenticationMechanisms: SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
storage:
    # mongod实例存储数据库文件路径，仅mongod有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    dbPath: &lt;/span&gt;/data/mongodb/shard1/&lt;span&gt;data
    # 是否将不同DB的数据存储在不同的目录中，dbPath的子目录，目录名为db的名称，仅mongod有效。类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    directoryPerDB: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    journal:
        # 记录操作日志，防止数据丢失。64bit默认为true，32bit默认为false
        enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
replication:
    # 指定oplog的最大尺寸。对于已经建立过oplog.rs的数据库，指定无效。
    # 默认为磁盘的5&lt;/span&gt;%&lt;span&gt;。仅mongod有效
    # oplogSizeMB: 
    # 指定副本集的名称。仅mongod有效
    replSetName: shard1
    # 指定副本集成员在接受oplog之前是否加载索引到内存。默认会加载所有的索引到内存。
    # none，不加载;all，加载所有;_id_only，仅加载_id。仅mongod有效
    secondaryIndexPrefetch: all
sharding:
    # 指定分片集的mongodb角色。configsvr: 配置服务器。shardsvr: 分片实例。仅mongod有效
    clusterRole: shardsvr
    # 在块移动过程中，该选项强制mongodb实例保存所有移动的文档到moveChunk目录。
    # 在版本3.2及以后版本中默认值为false。
    archiveMovedChunks: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分别启动三个机器上的shard1 server：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] mongod --config /usr/local/mongodb/config/shard1.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当三个机器上的第一个分片服务都启动之后，然后随便选择一个服务登入，将三个配置服务节点添加到一个副本集中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@abc] mongo --port &lt;span&gt;21019&lt;/span&gt;&lt;span&gt;  #连接
...
&lt;/span&gt;&amp;gt; config =&lt;span&gt; {
&lt;/span&gt;&amp;gt; ...     _id: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shard1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  # 配置文件中第一个分片副本集的名称
&lt;/span&gt;&amp;gt;&lt;span&gt; ...     members: [
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;0&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.56:21019&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;1&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.57:21019&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;2&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.58:21019&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&amp;gt;&lt;span&gt; ...     ]
&lt;/span&gt;&amp;gt;&lt;span&gt; ... }  # 设置变量
...
rs.initiate(config)  # 初始化副本集
...
rs.status();  # 查看副本集状态&lt;br/&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这里使用的是偶数个节点的话，那么就需要多加一个参数 {_id : 1, host : &quot;172.23.102.57:21019&quot;, arbiterOnly: true } ，表示57这个机器为仲裁节点。&lt;/p&gt;
&lt;p&gt;编写shard2 server配置文件，在三个机器中除 net.bindIp 配置需要对应到不同的机器之外，其他配置都一样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemLog:
    # 日志级别，&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;：包含“&lt;span&gt;info&lt;/span&gt;”信息，&lt;span&gt;1&lt;/span&gt;~&lt;span&gt;5&lt;/span&gt;，即大于0的值均会包含debug信息。类型: integer，默认: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    verbosity: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    # 发送所有的诊断信息日志文件的路径。systemLog.destination为file时有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。
    path: &lt;/span&gt;/data/mongodb/shard2/logs/&lt;span&gt;shard2.log
    # 如果是true，则mongod服务重启时会将日志追加到日志末尾，否则每次重启会备份已有的日志并创建新日志。
    # 类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    logAppend: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 日志输出目的地，可以指定为“&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;”或者“syslog”，如果指定“&lt;span&gt;file&lt;/span&gt;&lt;span&gt;”则必须要设置systemLog.path。
    # 如果不指定，则会输出到标准输出中（standard output）。
    destination: &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
processManagement:
    # 是否以守护进程（后台进程）的方式运行mongod&lt;/span&gt;/mongos进程。类型: boolean。默认: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    # 在Linux下如果是使用npm包的方式安装，并使用自带的init script脚本，则不推荐修改默认值。
    # 否则需要禁用默认的init script，而使用自己的init script。
    fork: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    # 配合&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork:true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;参数，将mongod/mongos进程ID写入指定的文件，如果不指定，将不会创建PID文件。类型: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    pidFilePath: &lt;/span&gt;/data/mongodb/shard2/logs/&lt;span&gt;shard2.pid
net:
    # mongod&lt;/span&gt;/mongos服务侦听客户端连接的端口。类型: &lt;span&gt;int&lt;/span&gt;。默认: &lt;span&gt;27017&lt;/span&gt;&lt;span&gt;。
    port: &lt;/span&gt;&lt;span&gt;27020&lt;/span&gt;&lt;span&gt;
    # mongod&lt;/span&gt;/&lt;span&gt;monogs应用侦听客户端的IP地址或者完整UNIX域套接字路径，如果想要绑定多个地址使用逗号分隔。
    # 若要绑定到所有IPv4地址，请输入0.&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;。与net.bindIpAll配置互斥，不能同时配置两个。
    # 类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。默认: localhost
    bindIp: &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.56&lt;/span&gt; / &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.57&lt;/span&gt; / &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.58&lt;/span&gt;&lt;span&gt; #这里三个设备分别对应
security:
    # 密钥文件的路径，它存储MongoDB实例在共享的集群或副本集中相互验证的共享密钥。
    # 必须设置security.authorization为enable。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    keyFile: &lt;/span&gt;/usr/local/mongodb/keyFile.&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
    # 集群成员之间的认证模式。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。可选: keyFile、sendKeyFile、sendX509、x509。默认: keyFile。
    clusterAuthMode: keyFile
    # 打开访问数据库和进行操作的用户角色认证，仅mongod有效。disabled: 关闭; enabled: 开启（默认开启）
    authorization: enabled
    # 启用或禁用服务器端JavaScript执行，仅mongod有效。
    # 如果为false，那么任何与javascript相关的功能都不能使用。类型: boolean。默认: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    javascriptEnabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
setParameter:
    # 如果开启，则允许本机（localhost&lt;/span&gt;/&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;）第一次访问时不需要密码认证，以便于创建第一个admin数据库的用户
    # &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;/1或者false/&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，默认为true。mongods和mongod有效，建议mongod关闭该功能。
    enableLocalhostAuthBypass: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 认证机制，可选值为“SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;”、“MONGODB-CR”、“PLAN”等，建议为“SCRAM-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;”
    authenticationMechanisms: SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
storage:
    # mongod实例存储数据库文件路径，仅mongod有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    dbPath: &lt;/span&gt;/data/mongodb/shard2/&lt;span&gt;data
    # 是否将不同DB的数据存储在不同的目录中，dbPath的子目录，目录名为db的名称，仅mongod有效。类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    directoryPerDB: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    journal:
        # 记录操作日志，防止数据丢失。64bit默认为true，32bit默认为false
        enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
replication:
    # 指定oplog的最大尺寸。对于已经建立过oplog.rs的数据库，指定无效。
    # 默认为磁盘的5&lt;/span&gt;%&lt;span&gt;。仅mongod有效
    # oplogSizeMB: 
    # 指定副本集的名称。仅mongod有效
    replSetName: shard1
    # 指定副本集成员在接受oplog之前是否加载索引到内存。默认会加载所有的索引到内存。
    # none，不加载;all，加载所有;_id_only，仅加载_id。仅mongod有效
    secondaryIndexPrefetch: all
sharding:
    # 指定分片集的mongodb角色。configsvr: 配置服务器。shardsvr: 分片实例。仅mongod有效
    clusterRole: shardsvr
    # 在块移动过程中，该选项强制mongodb实例保存所有移动的文档到moveChunk目录。
    # 在版本3.2及以后版本中默认值为false。
    archiveMovedChunks: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分别启动三个机器上的shard2 server：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] mongod --config /usr/local/mongodb/config/shard2.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当三个机器上的第二个分片服务都启动之后，然后随便选择一个服务登入，将三个配置服务节点添加到一个副本集中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@abc] mongo --port &lt;span&gt;21020&lt;/span&gt;&lt;span&gt;  #连接
...
&lt;/span&gt;&amp;gt; config =&lt;span&gt; {
&lt;/span&gt;&amp;gt; ...     _id: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shard2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  # 配置文件中第二个分片副本集的名称
&lt;/span&gt;&amp;gt;&lt;span&gt; ...     members: [
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;0&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.56:21020&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;1&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.57:21020&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;2&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.58:21020&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&amp;gt;&lt;span&gt; ...     ]
&lt;/span&gt;&amp;gt;&lt;span&gt; ... }  # 设置变量
...
rs.initiate(config)  # 初始化副本集
...
rs.status();  # 查看副本集状态&lt;br/&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这里使用的是偶数个节点的话，那么就需要多加一个参数 {_id : 0, host : &quot;172.23.102.56:21020&quot;, arbiterOnly: true } ，表示56这个机器为仲裁节点。&lt;/p&gt;
&lt;p&gt;编写shard3 server配置文件，在三个机器中除 net.bindIp 配置需要对应到不同的机器之外，其他配置都一样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemLog:
    # 日志级别，&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;：包含“&lt;span&gt;info&lt;/span&gt;”信息，&lt;span&gt;1&lt;/span&gt;~&lt;span&gt;5&lt;/span&gt;，即大于0的值均会包含debug信息。类型: integer，默认: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    verbosity: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    # 发送所有的诊断信息日志文件的路径。systemLog.destination为file时有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。
    path: &lt;/span&gt;/data/mongodb/shard3/logs/&lt;span&gt;shard3.log
    # 如果是true，则mongod服务重启时会将日志追加到日志末尾，否则每次重启会备份已有的日志并创建新日志。
    # 类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    logAppend: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 日志输出目的地，可以指定为“&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;”或者“syslog”，如果指定“&lt;span&gt;file&lt;/span&gt;&lt;span&gt;”则必须要设置systemLog.path。
    # 如果不指定，则会输出到标准输出中（standard output）。
    destination: &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
processManagement:
    # 是否以守护进程（后台进程）的方式运行mongod&lt;/span&gt;/mongos进程。类型: boolean。默认: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    # 在Linux下如果是使用npm包的方式安装，并使用自带的init script脚本，则不推荐修改默认值。
    # 否则需要禁用默认的init script，而使用自己的init script。
    fork: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    # 配合&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork:true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;参数，将mongod/mongos进程ID写入指定的文件，如果不指定，将不会创建PID文件。类型: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    pidFilePath: &lt;/span&gt;/data/mongodb/shard3/logs/&lt;span&gt;shard3.pid
net:
    # mongod&lt;/span&gt;/mongos服务侦听客户端连接的端口。类型: &lt;span&gt;int&lt;/span&gt;。默认: &lt;span&gt;27017&lt;/span&gt;&lt;span&gt;。
    port: &lt;/span&gt;&lt;span&gt;27021&lt;/span&gt;&lt;span&gt;
    # mongod&lt;/span&gt;/&lt;span&gt;monogs应用侦听客户端的IP地址或者完整UNIX域套接字路径，如果想要绑定多个地址使用逗号分隔。
    # 若要绑定到所有IPv4地址，请输入0.&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;。与net.bindIpAll配置互斥，不能同时配置两个。
    # 类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。默认: localhost
    bindIp: &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.56&lt;/span&gt; / &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.57&lt;/span&gt; / &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.58&lt;/span&gt;&lt;span&gt; #这里三个设备分别对应
security:
    # 密钥文件的路径，它存储MongoDB实例在共享的集群或副本集中相互验证的共享密钥。
    # 必须设置security.authorization为enable。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    keyFile: &lt;/span&gt;/usr/local/mongodb/keyFile.&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
    # 集群成员之间的认证模式。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。可选: keyFile、sendKeyFile、sendX509、x509。默认: keyFile。
    clusterAuthMode: keyFile
    # 打开访问数据库和进行操作的用户角色认证，仅mongod有效。disabled: 关闭; enabled: 开启（默认开启）
    authorization: enabled
    # 启用或禁用服务器端JavaScript执行，仅mongod有效。
    # 如果为false，那么任何与javascript相关的功能都不能使用。类型: boolean。默认: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    javascriptEnabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
setParameter:
    # 如果开启，则允许本机（localhost&lt;/span&gt;/&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;）第一次访问时不需要密码认证，以便于创建第一个admin数据库的用户
    # &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;/1或者false/&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，默认为true。mongods和mongod有效，建议mongod关闭该功能。
    enableLocalhostAuthBypass: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 认证机制，可选值为“SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;”、“MONGODB-CR”、“PLAN”等，建议为“SCRAM-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;”
    authenticationMechanisms: SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
storage:
    # mongod实例存储数据库文件路径，仅mongod有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    dbPath: &lt;/span&gt;/data/mongodb/shard3/&lt;span&gt;data
    # 是否将不同DB的数据存储在不同的目录中，dbPath的子目录，目录名为db的名称，仅mongod有效。类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    directoryPerDB: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    journal:
        # 记录操作日志，防止数据丢失。64bit默认为true，32bit默认为false
        enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
replication:
    # 指定oplog的最大尺寸。对于已经建立过oplog.rs的数据库，指定无效。
    # 默认为磁盘的5&lt;/span&gt;%&lt;span&gt;。仅mongod有效
    # oplogSizeMB: 
    # 指定副本集的名称。仅mongod有效
    replSetName: shard1
    # 指定副本集成员在接受oplog之前是否加载索引到内存。默认会加载所有的索引到内存。
    # none，不加载;all，加载所有;_id_only，仅加载_id。仅mongod有效
    secondaryIndexPrefetch: all
sharding:
    # 指定分片集的mongodb角色。configsvr: 配置服务器。shardsvr: 分片实例。仅mongod有效
    clusterRole: shardsvr
    # 在块移动过程中，该选项强制mongodb实例保存所有移动的文档到moveChunk目录。
    # 在版本3.2及以后版本中默认值为false。
    archiveMovedChunks: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分别启动三个机器上的shard3 server：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] mongod --config /usr/local/mongodb/config/shard3.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当三个机器上的第三个分片服务都启动之后，然后随便选择一个服务登入，将三个配置服务节点添加到一个副本集中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@abc] mongo --port &lt;span&gt;21021&lt;/span&gt;&lt;span&gt;  #连接
...
&lt;/span&gt;&amp;gt; config =&lt;span&gt; {
&lt;/span&gt;&amp;gt; ...     _id: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shard3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,  # 配置文件中第三个分片副本集的名称
&lt;/span&gt;&amp;gt;&lt;span&gt; ...     members: [
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;0&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.56:21021&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;1&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.57:21021&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&amp;gt; ...         { _id: &lt;span&gt;2&lt;/span&gt;, host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.23.102.58:21021&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
&lt;/span&gt;&amp;gt;&lt;span&gt; ...     ]
&lt;/span&gt;&amp;gt;&lt;span&gt; ... }  # 设置变量
...
rs.initiate(config)  # 初始化副本集
...
rs.status();  # 查看副本集状态&lt;br/&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这里使用的是偶数个节点的话，那么就需要多加一个参数 {_id : 2, host : &quot;172.23.102.58:21021&quot;, arbiterOnly: true } ，表示58这个机器为仲裁节点。&lt;/p&gt;
&lt;p&gt;编写mongos server配置文件，在三个机器中除 net.bindIp 配置需要对应到不同的机器之外，其他配置都一样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemLog:
    # 日志级别，&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;：包含“&lt;span&gt;info&lt;/span&gt;”信息，&lt;span&gt;1&lt;/span&gt;~&lt;span&gt;5&lt;/span&gt;，即大于0的值均会包含debug信息。类型: integer，默认: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    verbosity: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    # 发送所有的诊断信息日志文件的路径。systemLog.destination为file时有效。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。
    path: &lt;/span&gt;/data/mongodb/mongos/logs/&lt;span&gt;mongos.log
    # 如果是true，则mongod服务重启时会将日志追加到日志末尾，否则每次重启会备份已有的日志并创建新日志。
    # 类型: boolean。默认: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    logAppend: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 日志输出目的地，可以指定为“&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;”或者“syslog”，如果指定“&lt;span&gt;file&lt;/span&gt;&lt;span&gt;”则必须要设置systemLog.path。
    # 如果不指定，则会输出到标准输出中（standard output）。
    destination: &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
processManagement:
    # 是否以守护进程（后台进程）的方式运行mongod&lt;/span&gt;/mongos进程。类型: boolean。默认: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
    # 在Linux下如果是使用npm包的方式安装，并使用自带的init script脚本，则不推荐修改默认值。
    # 否则需要禁用默认的init script，而使用自己的init script。
    fork: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    # 配合&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fork:true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;参数，将mongod/mongos进程ID写入指定的文件，如果不指定，将不会创建PID文件。类型: &lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    pidFilePath: &lt;/span&gt;/data/mongodb/mongos/logs/&lt;span&gt;mongos.pid
net:
    # mongod&lt;/span&gt;/mongos服务侦听客户端连接的端口。类型: &lt;span&gt;int&lt;/span&gt;。默认: &lt;span&gt;27017&lt;/span&gt;&lt;span&gt;。
    port: &lt;/span&gt;&lt;span&gt;27017&lt;/span&gt;&lt;span&gt;
    # mongod&lt;/span&gt;/&lt;span&gt;monogs应用侦听客户端的IP地址或者完整UNIX域套接字路径，如果想要绑定多个地址使用逗号分隔。
    # 若要绑定到所有IPv4地址，请输入0.&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;。与net.bindIpAll配置互斥，不能同时配置两个。
    # 类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。默认: localhost
    bindIp: &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.56&lt;/span&gt; / &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.57&lt;/span&gt; / &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.58&lt;/span&gt;&lt;span&gt; #这里三个设备分别对应
security:
    # 密钥文件的路径，它存储MongoDB实例在共享的集群或副本集中相互验证的共享密钥。
    # 必须设置security.authorization为enable。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;
    keyFile: &lt;/span&gt;/usr/local/mongodb/keyFile.&lt;span&gt;file&lt;/span&gt;&lt;span&gt;
    # 集群成员之间的认证模式。类型: &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;。可选: keyFile、sendKeyFile、sendX509、x509。默认: keyFile。
    clusterAuthMode: keyFile
setParameter:
    # 如果开启，则允许本机（localhost&lt;/span&gt;/&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;）第一次访问时不需要密码认证，以便于创建第一个admin数据库的用户
    # &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;/1或者false/&lt;span&gt;0&lt;/span&gt;&lt;span&gt;，默认为true。mongods和mongod有效，建议mongod关闭该功能。
    enableLocalhostAuthBypass: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    # 认证机制，可选值为“SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;”、“MONGODB-CR”、“PLAN”等，建议为“SCRAM-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;”
    authenticationMechanisms: SCRAM&lt;/span&gt;-SHA-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
sharding:
    # 配置分片块大小，默认64(MB)。MongoDB &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.4已删除该配置。
    # chunkSize: &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;&lt;span&gt;
    # 配置服务器副本集地址。MongoDB &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.2必须将配置服务部署为副本集，
    # 配置服务副本必须以默认的WiredTiger存储引擎存储。
    configDB: config&lt;/span&gt;/&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.56&lt;/span&gt;:&lt;span&gt;21018&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.57&lt;/span&gt;:&lt;span&gt;21018&lt;/span&gt;,&lt;span&gt;172.23&lt;/span&gt;.&lt;span&gt;102.58&lt;/span&gt;:&lt;span&gt;21018&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分别启动三个机器上的mongos server，当然也可以只启动一个，一个客户端也只能连接一个mongos：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@abc] mongos --config /usr/local/mongodb/config/mongos.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当mongos服务都启动之后登入服务，将副本集添加到集群中（其实就是保存在配置服务中）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
[root@abc] mongo --port &lt;span&gt;27017&lt;/span&gt;&lt;span&gt;
...
&lt;/span&gt;&amp;gt;&lt;span&gt; use admin  #使用admin数据库
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;.addShard(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shard1/172.23.102.56:21019,172.23.102.57:21019,172.23.102.58:21019&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;.addShard(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shard2/172.23.102.56:21020,172.23.102.57:21020,172.23.102.58:21020&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;.addShard(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shard3/172.23.102.56:21021,172.23.102.57:21021,172.23.102.58:21021&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;.status()  #查看集群状态&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此MongoDB分片和副本集集群已搭建完成，接下来我们创建集群用户注意这里同样只有一次机会。mongos没有security.authorization配置，一般如果集群成员之间需要进行鉴权，那么mongos就会启用security相关配置，这样mongos就必须要进行用户名和密码认证了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@abc] mongo
...
&lt;/span&gt;&amp;gt;&lt;span&gt; use admin
...
&lt;/span&gt;&amp;gt; db.createUser({user: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;pwd&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, roles: [{role: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, db: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}]})
...
&lt;/span&gt;&amp;gt; db.auth(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MongoDB数据库默认会有一个主分片，如果没有指明数据库中的集合十分片集合，那么该数据库的所有集合和文档都默认会存储在这个主分片之上。接下来我们来启用分片集合，首先指明一个数据库是分片数据库：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@abc] mongo
...
&lt;/span&gt;&amp;gt;&lt;span&gt; use admin
...
&lt;/span&gt;&amp;gt; db.auth(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;.enableSharding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)  # 指明testdb库启用分片
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;.status()  # 查看分片情况&lt;br/&gt;...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，这里如果被启用分片的数据库不存在，那么MongoDB会自动创建该数据库。这里虽然启用了分片，但还得指明是哪个集合需要分片，使用集合里面的那一个字段作为片键，以什么方式进行分片：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@abc] mongo
...
&lt;/span&gt;&amp;gt;&lt;span&gt; use admin
...
&lt;/span&gt;&amp;gt; db.auth(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;.enableSharding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)  # 指明testdb库启用分片
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;&lt;span&gt;.status()  # 查看分片情况
...
# 指定testdb库下面的mycollection集合以username字段为片键进行hash分片
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;.shardCollection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testdb.mycollection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hashed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;&lt;span&gt;.status()  # 查看分片情况
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里使用的分片测是hash分片，适合大规模插入、高并发、数据能够平均分布可充分利用整个集群的性能。还可以进行范围分片和指定分片（指定拿一些片键存储在那个分片上）等策略进行分片，建议线上大规模读写情况下使用hash分片。接下来可以批量插入一些数据，然后查看集合情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@abc] mongo
...
&lt;/span&gt;&amp;gt;&lt;span&gt; use admin
...
&lt;/span&gt;&amp;gt; db.auth(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;.enableSharding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)  # 指明testdb库启用分片
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;&lt;span&gt;.status()  # 查看分片情况
...
# 指定testdb库下面的mycollection集合以username字段为片键进行hash分片
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;.shardCollection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testdb.mycollection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hashed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})
...
&lt;/span&gt;&amp;gt; &lt;span&gt;sh&lt;/span&gt;&lt;span&gt;.status()  # 查看分片情况
...
&lt;/span&gt;&amp;gt;&lt;span&gt; use testdb
...
&lt;/span&gt;&amp;gt;&lt;span&gt; db.mycollection.stats()
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，分片集合的片键必须有索引。在给集合分片的时候，如果集合不存则会自动创建集合，然后为片键创建索引。如果集合存在并且已经有了数据，那么就必须手动为片键创建索引，才能为集合分片成功。集合一旦分片成功，片键是不能够修改的，所以选择片键的时候需要谨慎。至此集合分片完成。&lt;/p&gt;
&lt;p&gt;如果后期需要直接访问testdb数据库，则必须在testdb数据库下创建用户。注意用户信息是全部存储在admin数据库下的，用户必须归属为某一个数据库，admin数据库下的用户可以操作所有数据库，但是直接在非admin数据库下对admin数据库的用户进行认证是不成功的，必须要先切换到admin下进行认证然后在切换到其他库才可，如果想直接认证则必须在需要认证的数据库下创建用户：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@abc] mongo
...
&lt;/span&gt;&amp;gt;&lt;span&gt; use admin
...
&lt;/span&gt;&amp;gt; db.auth(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
...
&lt;/span&gt;&amp;gt;&lt;span&gt; use testdb
...
# 注意只有admin数据库才有root角色，其他数据库的管理类角色可以选择：dbOwner、dbAdmin、userAdmin等
&lt;/span&gt;&amp;gt; db.createUser({user: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;pwd&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, roles: [{role: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dbOwner&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, db: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;testdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}]})
...
# 可以切换到admin数据库下查看用户信息
&lt;/span&gt;&amp;gt;&lt;span&gt; use admin
...
&lt;/span&gt;&amp;gt; db.system.users.&lt;span&gt;find&lt;/span&gt;&lt;span&gt;({})
...
# 也可以删除用户
&lt;/span&gt;&amp;gt; db.system.users.remove({ _id: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, user: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; })
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;六、配置说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 yaml配置中，缩进只能只用空格，不可以使用tab键。如果需要查阅跟多配置相关的信息，请翻阅MongoDB官方手册: &lt;a href=&quot;https://docs.mongodb.com/manual/reference/configuration-options/&quot; target=&quot;_blank&quot;&gt;https://docs.mongodb.com/manual/reference/configuration-options/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 15:07:00 +0000</pubDate>
<dc:creator>伯乐钟情</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lbole/p/8902337.html</dc:identifier>
</item>
<item>
<title>java多线程对CountDownLatch的使用实例 - jihite</title>
<link>http://www.cnblogs.com/kaituorensheng/p/9043494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaituorensheng/p/9043494.html</guid>
<description>&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;CountDownLatch是一个同步辅助类，它允许一个或多个线程一直等待直到其他线程执行完毕才开始执行。&lt;/p&gt;
&lt;p&gt;用给定的&lt;strong&gt;计数&lt;/strong&gt;初始化CountDownLatch，其含义是要被等待执行完的线程个数。&lt;/p&gt;
&lt;p&gt;每次调用CountDown()，&lt;strong&gt;计数&lt;/strong&gt;减1&lt;/p&gt;
&lt;p&gt;主程序执行到await()函数会阻塞等待线程的执行，直到计数为0&lt;/p&gt;
&lt;h3&gt;实现原理&lt;/h3&gt;
&lt;p&gt;计数器通过使用锁（共享锁、排它锁）实现&lt;/p&gt;
&lt;h3&gt;实例1&lt;/h3&gt;
&lt;p&gt;场景：模拟10人赛跑。10人跑完后才喊&quot;Game Over.&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jihite;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.CountDownLatch;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutorService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountDownLatchTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNER_COUNT = 10&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; CountDownLatch begin = &lt;span&gt;new&lt;/span&gt; CountDownLatch(1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; CountDownLatch end = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountDownLatch(RUNNER_COUNT);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ExecutorService exec = Executors.newFixedThreadPool(10&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; RUNNER_COUNT; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NO = i + 1&lt;span&gt;;
            Runnable run &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        begin.await();
                        Thread.sleep((&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;)(Math.random() * 10000&lt;span&gt;));
                        System.out.println(&lt;/span&gt;&quot;No.&quot; + NO + &quot; arrived&quot;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                        end.countDown();
                    }
                }
            };
            exec.submit(run);
        }

        System.out.println(&lt;/span&gt;&quot;Game Start ...&quot;&lt;span&gt;);
        begin.countDown();
        end.await();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        end.await(30, TimeUnit.SECONDS);&lt;/span&gt;
        System.out.println(&quot;Game Over.&quot;&lt;span&gt;);

        exec.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析：代码中定义了2个计数器，个数分别为1和10。&lt;/p&gt;
&lt;p&gt;如果不执行begin.countDown()，进程会一致阻塞在begin.await()&lt;/p&gt;
&lt;p&gt;主进程执行到end.awit()阻塞等待end计数器清0，进程中每执行一次CountDown()减1，所有执行完后主进程继续往下执行&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Game Start ...
No.&lt;/span&gt;6&lt;span&gt; arrived
No.&lt;/span&gt;4&lt;span&gt; arrived
No.&lt;/span&gt;10&lt;span&gt; arrived
No.&lt;/span&gt;3&lt;span&gt; arrived
No.&lt;/span&gt;9&lt;span&gt; arrived
No.&lt;/span&gt;5&lt;span&gt; arrived
No.&lt;/span&gt;8&lt;span&gt; arrived
No.&lt;/span&gt;7&lt;span&gt; arrived
No.&lt;/span&gt;1&lt;span&gt; arrived
No.&lt;/span&gt;2&lt;span&gt; arrived
Game Over.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;实例2（和join的相似处）&lt;/h3&gt;
&lt;p&gt;场景：流水线上有3个worker: worker1、worker2、worker3,只有当worker1和worker2执行完时才可以执行worker3&lt;/p&gt;
&lt;p&gt;WorkerCount.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jihite;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.CountDownLatch;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WorkerCount &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CountDownLatch countDownLatch;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; WorkerCount(String name, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time, CountDownLatch countDownLatch) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.time =&lt;span&gt; time;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.countDownLatch =&lt;span&gt; countDownLatch;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(name &lt;/span&gt;+ &quot;开始工作&quot;&lt;span&gt;);
            Thread.sleep(time);
            System.out.println(name &lt;/span&gt;+ &quot;工作完成, 耗时：&quot;+&lt;span&gt; time);
            countDownLatch.countDown();
            System.out.println(&lt;/span&gt;&quot;countDownLatch.getCount():&quot; +&lt;span&gt; countDownLatch.getCount());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CountDownLatch实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CountDownLatchTest() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; COUNT = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountDownLatch(COUNT);
        WorkerCount worker0 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WorkerCount(&quot;lilei-0&quot;, (&lt;span&gt;long&lt;/span&gt;)(Math.random() * 10000&lt;span&gt;), countDownLatch);
        WorkerCount worker1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WorkerCount(&quot;lilei-1&quot;, (&lt;span&gt;long&lt;/span&gt;)(Math.random() * 10000&lt;span&gt;), countDownLatch);
        worker0.start();
        worker1.start();
        countDownLatch.await();
        System.out.println(&lt;/span&gt;&quot;准备工作就绪&quot;&lt;span&gt;);

        WorkerCount worker2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WorkerCount(&quot;lilei-2&quot;, (&lt;span&gt;long&lt;/span&gt;)(Math.random() * 10000&lt;span&gt;), countDownLatch);
        worker2.start();
        Thread.sleep(&lt;/span&gt;10000&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
lilei-&lt;span&gt;0开始工作
lilei&lt;/span&gt;-&lt;span&gt;1开始工作
lilei&lt;/span&gt;-1工作完成, 耗时：4039&lt;span&gt;
countDownLatch.getCount():&lt;/span&gt;1&lt;span&gt;
lilei&lt;/span&gt;-0工作完成, 耗时：9933&lt;span&gt;
countDownLatch.getCount():&lt;/span&gt;0&lt;span&gt;
准备工作就绪
lilei&lt;/span&gt;-&lt;span&gt;2开始工作
lilei&lt;/span&gt;-2工作完成, 耗时：6402&lt;span&gt;
countDownLatch.getCount():&lt;/span&gt;0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;该场景join也可以完成&lt;/p&gt;
&lt;p&gt;Worker.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jihite;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Worker &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Worker(String name, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.time =&lt;span&gt; time;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(name &lt;/span&gt;+ &quot;开始工作&quot;&lt;span&gt;);
            Thread.sleep(time);
            System.out.println(name &lt;/span&gt;+ &quot;工作完成, 耗时：&quot;+&lt;span&gt; time);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;join实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; JoinTest() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        Worker worker0 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Worker(&quot;lilei-0&quot;, (&lt;span&gt;long&lt;/span&gt;)(Math.random() * 10000&lt;span&gt;));
        Worker worker1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Worker(&quot;lilei-1&quot;, (&lt;span&gt;long&lt;/span&gt;)(Math.random() * 10000&lt;span&gt;));
        Worker worker2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Worker(&quot;lilei-2&quot;, (&lt;span&gt;long&lt;/span&gt;)(Math.random() * 10000&lt;span&gt;));
        worker0.start();
        worker1.start();

        worker0.join();
        worker1.join();
        System.out.println(&lt;/span&gt;&quot;准备工作就绪&quot;&lt;span&gt;);

        worker2.start();
        Thread.sleep(&lt;/span&gt;10000&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
lilei-&lt;span&gt;0开始工作
lilei&lt;/span&gt;-&lt;span&gt;1开始工作
lilei&lt;/span&gt;-1工作完成, 耗时：4483&lt;span&gt;
lilei&lt;/span&gt;-0工作完成, 耗时：6301&lt;span&gt;
准备工作就绪
lilei&lt;/span&gt;-&lt;span&gt;2开始工作
lilei&lt;/span&gt;-2工作完成, 耗时：6126
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然这样，那CountDownLatch和join的区别在哪？通过下面的场景三就可以看出&lt;/p&gt;
&lt;h3&gt;实例3（和join的不同处）&lt;/h3&gt;
&lt;p&gt;场景：流水线上有3个worker: worker1、worker2、worker3,只有当worker1和worker2两者的阶段一都执行完后才可以执行worker3&lt;/p&gt;
&lt;p&gt;WorkerCount2.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jihite;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.CountDownLatch;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WorkerCount2 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CountDownLatch countDownLatch;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; WorkerCount2(String name, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; time, CountDownLatch countDownLatch) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.time =&lt;span&gt; time;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.countDownLatch =&lt;span&gt; countDownLatch;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(name &lt;/span&gt;+ &quot;开始阶段1工作&quot;&lt;span&gt;);
            Thread.sleep(time);
            System.out.println(name &lt;/span&gt;+ &quot;阶段1完成, 耗时：&quot;+&lt;span&gt; time);
            countDownLatch.countDown();

            System.out.println(name &lt;/span&gt;+ &quot;开始阶段2工作&quot;&lt;span&gt;);
            Thread.sleep(time);
            System.out.println(name &lt;/span&gt;+ &quot;阶段2完成, 耗时：&quot;+&lt;span&gt; time);

        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时用join无法实现，只能用CountDownLatch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CountDownLatchTest2() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; COUNT = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; CountDownLatch countDownLatch = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountDownLatch(COUNT);
        WorkerCount2 worker0 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WorkerCount2(&quot;lilei-0&quot;, (&lt;span&gt;long&lt;/span&gt;)(Math.random() * 10000&lt;span&gt;), countDownLatch);
        WorkerCount2 worker1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WorkerCount2(&quot;lilei-1&quot;, (&lt;span&gt;long&lt;/span&gt;)(Math.random() * 10000&lt;span&gt;), countDownLatch);
        worker0.start();
        worker1.start();
        countDownLatch.await();
        System.out.println(&lt;/span&gt;&quot;准备工作就绪&quot;&lt;span&gt;);

        WorkerCount2 worker2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WorkerCount2(&quot;lilei-2&quot;, (&lt;span&gt;long&lt;/span&gt;)(Math.random() * 10000&lt;span&gt;), countDownLatch);
        worker2.start();
        Thread.sleep(&lt;/span&gt;10000&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
lilei-&lt;span&gt;0开始阶段1工作
lilei&lt;/span&gt;-&lt;span&gt;1开始阶段1工作
lilei&lt;/span&gt;-0阶段1完成, 耗时：3938&lt;span&gt;
lilei&lt;/span&gt;-&lt;span&gt;0开始阶段2工作
lilei&lt;/span&gt;-1阶段1完成, 耗时：6259&lt;span&gt;
lilei&lt;/span&gt;-&lt;span&gt;1开始阶段2工作
准备工作就绪
lilei&lt;/span&gt;-&lt;span&gt;2开始阶段1工作
lilei&lt;/span&gt;-0阶段2完成, 耗时：3938&lt;span&gt;
lilei&lt;/span&gt;-1阶段2完成, 耗时：6259&lt;span&gt;
lilei&lt;/span&gt;-2阶段1完成, 耗时：7775&lt;span&gt;
lilei&lt;/span&gt;-2开始阶段2工作
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 15 May 2018 14:41:00 +0000</pubDate>
<dc:creator>jihite</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaituorensheng/p/9043494.html</dc:identifier>
</item>
<item>
<title>大厂们的 redis 集群方案 - 大CC</title>
<link>http://www.cnblogs.com/me115/p/9043420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/me115/p/9043420.html</guid>
<description>&lt;p&gt;redis 集群方案主要有两类，一是使用类 codis 的架构，按组划分，实例之间互相独立；&lt;br/&gt;另一套是基于官方的 redis cluster 的方案；下面分别聊聊这两种方案；&lt;/p&gt;
&lt;h2 id=&quot;类-codis-架构&quot;&gt;类 codis 架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/90573/201805/90573-20180515222110177-1033686810.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这套架构的特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分片算法：基于 slot hash桶；&lt;/li&gt;
&lt;li&gt;分片实例之间相互独立，每组 一个master 实例和多个slave；&lt;/li&gt;
&lt;li&gt;路由信息存放到第三方存储组件，如 zookeeper 或etcd&lt;/li&gt;
&lt;li&gt;旁路组件探活&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用这套方案的公司：&lt;br/&gt;阿里云： ApsaraCache, RedisLabs、京东、百度等&lt;/p&gt;
&lt;h3 id=&quot;codis&quot;&gt;codis&lt;/h3&gt;
&lt;p&gt;slots 方案：划分了 1024个slot， slots 信息在 proxy层感知； redis 进程中维护本实例上的所有key的一个slot map；&lt;/p&gt;
&lt;p&gt;迁移过程中的读写冲突处理：&lt;br/&gt;最小迁移单位为key；&lt;br/&gt;访问逻辑都是先访问 src 节点，再根据结果判断是否需要进一步访问 target 节点；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;访问的 key 还未被迁移：读写请求访问 src 节点，处理后访问：&lt;/li&gt;
&lt;li&gt;访问的 key 正在迁移：读请求访问 src 节点后直接返回；写请求无法处理，返回 retry&lt;/li&gt;
&lt;li&gt;访问的 key 已被迁移(或不存在）：读写请求访问 src 节点，收到 moved 回复，继续访问 target 节点处理&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;阿里云&quot;&gt;阿里云&lt;/h3&gt;
&lt;p&gt;AparaCache 的单机版已开源(开源版本中不包含slot等实现)，集群方案细节未知；&lt;a href=&quot;https://github.com/alibaba/ApsaraCache&quot;&gt;ApsaraCache&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;百度-bdrp-2.0&quot;&gt;百度 BDRP 2.0&lt;/h3&gt;
&lt;p&gt;主要组件：&lt;br/&gt;proxy，基于twemproxy 改造，实现了动态路由表；&lt;br/&gt;redis内核： 基于2.x 实现的slots 方案；&lt;br/&gt;metaserver：基于redis实现，包含的功能：拓扑信息的存储 &amp;amp; 探活；&lt;br/&gt;最多支持1000个节点；&lt;/p&gt;
&lt;p&gt;slot 方案：&lt;br/&gt;redis 内核中对db划分，做了16384个db； 每个请求到来，首先做db选择；&lt;/p&gt;
&lt;p&gt;数据迁移实现：&lt;br/&gt;数据迁移的时候，最小迁移单位是slot，迁移中整个slot 处于阻塞状态，只支持读请求，不支持写请求；&lt;br/&gt;对比 官方 redis cluster/ codis 的按key粒度进行迁移的方案：按key迁移对用户请求更为友好，但迁移速度较慢；这个按slot进行迁移的方案速度更快；&lt;/p&gt;
&lt;h3 id=&quot;京东&quot;&gt;京东&lt;/h3&gt;
&lt;p&gt;主要组件：&lt;br/&gt;proxy: 自主实现，基于 golang 开发；&lt;br/&gt;redis内核：基于 redis 2.8&lt;br/&gt;configServer(cfs)组件：配置信息存放；&lt;br/&gt;scala组件：用于触发部署、新建、扩容等请求；&lt;br/&gt;mysql：最终所有的元信息及配置的存储；&lt;br/&gt;sentinal（golang实现）：哨兵，用于监控proxy和redis实例，redis实例失败后触发切换；&lt;/p&gt;
&lt;p&gt;slot 方案实现：&lt;br/&gt;在内存中维护了slots的map映射表；&lt;/p&gt;
&lt;p&gt;数据迁移：&lt;br/&gt;基于 slots 粒度进行迁移；&lt;br/&gt;scala组件向dst实例发送命令告知会接受某个slot；&lt;br/&gt;dst 向 src 发送命令请求迁移，src开启一个线程来做数据的dump，将这个slot的数据整块dump发送到dst（未加锁，只读操作）&lt;br/&gt;写请求会开辟一块缓冲区，所有的写请求除了写原有数据区域，同时双写到缓冲区中。&lt;br/&gt;当一个slot迁移完成后，把这个缓冲区的数据都传到dst，当缓冲区为空时，更改本分片slot规则，不再拥有该slot，后续再请求这个slot的key返回moved；&lt;br/&gt;上层proxy会保存两份路由表，当该slot 请求目标实例得到 move 结果后，更新拓扑；&lt;/p&gt;
&lt;p&gt;跨机房：跨机房使用主从部署结构；没有多活，异地机房作为slave；&lt;/p&gt;
&lt;h2 id=&quot;基于官方-redis-cluster-的方案&quot;&gt;基于官方 redis cluster 的方案&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/90573/201805/90573-20180515222127730-567425490.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和上一套方案比，所有功能都集成在 redis cluster 中，路由分片、拓扑信息的存储、探活都在redis cluster中实现；各实例间通过 gossip 通信；这样的好处是简单，依赖的组件少，应对400个节点以内的场景没有问题（按单实例8w read qps来计算，能够支持 200 * 8 = 1600w 的读多写少的场景）；但当需要支持更大的规模时，由于使用 gossip协议导致协议之间的通信消耗太大，redis cluster 不再合适；&lt;/p&gt;
&lt;p&gt;使用这套方案的有：AWS, 百度贴吧&lt;/p&gt;
&lt;h3 id=&quot;官方-redis-cluster&quot;&gt;官方 redis cluster&lt;/h3&gt;
&lt;p&gt;数据迁移过程：&lt;br/&gt;基于 key粒度的数据迁移；&lt;br/&gt;迁移过程的读写冲突处理：&lt;br/&gt;从A 迁移到 B;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;访问的 key 所属slot 不在节点 A 上时，返回 MOVED 转向，client 再次请求B；&lt;/li&gt;
&lt;li&gt;访问的 key 所属 slot 在节点 A 上，但 key 不在 A上， 返回 ASK 转向，client再次请求B；&lt;/li&gt;
&lt;li&gt;访问的 key 所属slot 在A上，且key在 A上，直接处理；（同步迁移场景：该 key正在迁移，则阻塞）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;aws-elasticcache&quot;&gt;AWS ElasticCache&lt;/h3&gt;
&lt;p&gt;ElasticCache 支持主从和集群版、支持读写分离；&lt;br/&gt;集群版用的是开源的Redis Cluster，未做深度定制；&lt;/p&gt;
&lt;h3 id=&quot;百度贴吧的ksarch-saas&quot;&gt;百度贴吧的ksarch-saas：&lt;/h3&gt;
&lt;p&gt;基于redis cluster + twemproxy 实现；后被 BDRP 吞并；&lt;br/&gt;twemproxy 实现了 smart client 功能；使用 redis cluster后还加一层 proxy的好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对client友好，不需要client都升级为smart client；（否则，所有语言client 都需要支持一遍）&lt;/li&gt;
&lt;li&gt;加一层proxy可以做更多平台策略；比如在proxy可做 大key、热key的监控、慢查询的请求监控、以及接入控制、请求过滤等；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;即将发布的 redis 5.0 中有个 feature，作者计划给 redis cluster加一个proxy。&lt;/p&gt;
&lt;p&gt;ksarch-saas 对 twemproxy的改造已开源：&lt;br/&gt;&lt;a href=&quot;https://github.com/ksarch-saas/r3proxy&quot; class=&quot;uri&quot;&gt;https://github.com/ksarch-saas/r3proxy&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 14:23:00 +0000</pubDate>
<dc:creator>大CC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/me115/p/9043420.html</dc:identifier>
</item>
<item>
<title>基于ubuntu16.04部署IBM开源区块链项目-弹珠资产管理(Marbles) - Dmego</title>
<link>http://www.cnblogs.com/dmego/p/9043312.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dmego/p/9043312.html</guid>
<description>&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/cEFkbDKmj9.png?imageslim&quot; width=&quot;300px&quot;/&gt;&lt;br/&gt;&lt;/center&gt;

&lt;p&gt;本教程基本上是对&lt;code&gt;Marbles&lt;/code&gt;项目的翻译过程. 如果英文比较好的话，建议根据&lt;a href=&quot;https://github.com/IBM-Blockchain/marbles/blob/master/README.md&quot;&gt;官方操作说明&lt;/a&gt;,一步步进行环境部署。当然你也可以参考本教程在自己的主机上部署该项目。&lt;/p&gt;

&lt;h2 id=&quot;关于-marbles&quot;&gt;关于 Marbles&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;这个应用程序的基础网络是 &lt;a href=&quot;https://github.com/hyperledger/fabric/&quot;&gt;Hyperledger Fabric&lt;/a&gt;，后者是一个 &lt;code&gt;Linux Foundation&lt;/code&gt; 项目。 您可能想查阅以下操作说明来稍微了解一下 &lt;code&gt;Hyperledger Fabric&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;本演示旨在帮助开发人员了解链代码的基础知识以及如何使用 Fabric 网络开发应用程序&lt;/li&gt;
&lt;li&gt;这是一个非常简单的资产转移演示。多个用户可以创建并相互转移弹珠。&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/IHG6K7fdL4.gif&quot; alt=&quot;mark&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;版本&quot;&gt;版本&lt;/h2&gt;
&lt;p&gt;各种版本的 &lt;code&gt;marbles&lt;/code&gt; 同时存在。 本版本兼容 &lt;code&gt;Hyperledger Fabric v1.1x&lt;/code&gt;。 你可以通过检出别的分支来获取别的版本的 &lt;code&gt;marble&lt;/code&gt;,这里演示使用的是&lt;code&gt;ae4e37d&lt;/code&gt;分支&lt;/p&gt;
&lt;h2 id=&quot;应用程序背景&quot;&gt;应用程序背景&lt;/h2&gt;
&lt;p&gt;请大家集中注意力，这个应用程序将演示如何利用 &lt;code&gt;Hyperledger Fabric&lt;/code&gt; 在许多弹珠所有者之间转移弹珠。 我们将在 &lt;code&gt;Node.js&lt;/code&gt; 中使用一些 &lt;code&gt;GoLang&lt;/code&gt; 代码完成此任务。 该应用程序的后端将是在我们的区块链网络中运行的 &lt;code&gt;GoLang&lt;/code&gt; 代码。 从现在开始，这些 &lt;code&gt;GoLang&lt;/code&gt; 代码将称为“链代码”或“cc”。 该链代码本身会创建一颗弹珠，将它存储到链代码状态中。 该链代码本身可以将数据作为字符串存储在键/值对设置中。 因此，我们将字符串化 &lt;code&gt;JSON&lt;/code&gt;对象，以便存储更复杂的结构.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;弹珠的属性包括：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;ID（唯一字符串，将用作键）&lt;/li&gt;
&lt;li&gt;颜色（字符串，CSS 颜色名称）&lt;/li&gt;
&lt;li&gt;尺寸（int，以毫米为单位）&lt;/li&gt;
&lt;li&gt;所有者（字符串）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们将创建一个用户界面，它可以设置这些值并将它们存储在区块链的账本中。 弹珠实际上是一个键值对。 键为弹珠 ID，值为一个包含（上面列出的）弹珠属性的 &lt;code&gt;JSON&lt;/code&gt; 字符串。 与 &lt;code&gt;cc&lt;/code&gt; 的交互是通过对网络上的一个对等节点使用 &lt;code&gt;gRPC&lt;/code&gt; 协议来完成的。 &lt;code&gt;gRPC&lt;/code&gt; 协议的细节由一个名为 &lt;a href=&quot;https://www.npmjs.com/package/fabric-client&quot;&gt;Hyperledger Fabric Client SDK&lt;/a&gt; 的 SDK 处理。 请查看下图了解拓扑结构细节。&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/EEAimf54Dk.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;应用程序通信流&quot;&gt;应用程序通信流&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1.管理员将在他们的浏览器中与我们的 Node.js 应用程序 Marbles 进行交互&lt;/li&gt;
&lt;li&gt;2.此客户端 JS 代码将打开一个与后端 Node.js 应用程序的 Websocket 连接,管理员与该站点交互时,客户端 JS 将消息发送到后端&lt;/li&gt;
&lt;li&gt;3.读取或写入账本称为提案,这个提案由 Marbles (通过SDK)构建,然后发送到一个区块链对等节点.&lt;/li&gt;
&lt;li&gt;4.该对等节点将与它的 Marbles 链代码容器进行通信. 链代码容器将运行/模拟该交易. 如果没有问题, 它会对该交易进行背书,并将其发回我们的Marbles程序.&lt;/li&gt;
&lt;li&gt;5.然后, Marbles (通过SDK)将背书后的提案发送到订购服务.订购方将来自整个网络的许多提案打包到一个区块中. 然后它将新的区块广播到网络中的对等节点&lt;/li&gt;
&lt;li&gt;6.最后,对等节点会验证该区块并将它写入到自己的账本中,该交易现在已经生效,所有后续读取都会反映此更改.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里使用的是本地的 Hyperledger Fabric 网络来部署项目,如果想使用 IBM Cloud IBM Blockchain 服务来部署该项目,请参考前言中给的官方文档.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注意:本教程使用的系统环境是: &lt;code&gt;ubuntu16.04&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;设置-chaincode链码-开发环境&quot;&gt;设置 Chaincode(链码) 开发环境&lt;/h2&gt;
&lt;p&gt;如果您通过本人的上一篇博客&lt;a href=&quot;http://dmego.me/2018/05/14/quick-start-hyperledger-fabric.html&quot;&gt;基于ubuntu16.04快速构建Hyperledger Fabric网络&lt;/a&gt;已经搭建好了一个 Hyperledger Fabric 网络,那么这里只需要安装 Node.js 的环境并验证环境是否正确即可,如果您没有在本地搭建 Hyperledger Fabric 网络,建议您通过上述博客先在本地构建好网络环境.&lt;/p&gt;
&lt;h3 id=&quot;验证-git-环境&quot;&gt;验证 Git 环境&lt;/h3&gt;
&lt;p&gt;一般来说 linux 系统都是自带 Git ,如果系统里没有装,可以使用如下命令来进行安装&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get install git&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完成后验证一下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; --version
&lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; version 2.7.4&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;验证-go-环境&quot;&gt;验证 GO 环境&lt;/h3&gt;
&lt;p&gt;Go安装安装了一组Go CLI工具，这些工具在编写链接代码时非常有用。例如，该 go build 命令允许您在尝试将其部署到网络之前检查链代码是否实际编译.&lt;/p&gt;
&lt;ul readability=&quot;14.5&quot;&gt;&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;验证安装环境&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; version
&lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; version go1.10 linux/amd64
$ &lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;$GOPATH&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;/home/ubuntu/go&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的 ubuntu是我的用户名,表示我的 GOPATH 目录是我的主目录下的 go 文件夹,当然你的 GOPATH 不需要匹配上面的那个。它只是很重要的，但你必须把这个变量设置为文件系统上的有效目录.&lt;/p&gt;
&lt;h3 id=&quot;安装-node.js-环境&quot;&gt;安装 Node.js 环境&lt;/h3&gt;
&lt;p&gt;首先可以先使用 &lt;code&gt;node -v&lt;/code&gt; 和 &lt;code&gt;npm -v&lt;/code&gt; 命令来验证系统中是否有 Node.js 环境,如果没有安装则需要使用如下命令进行安装:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt-get install nodejs
$ &lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt install nodejs-legacy
$ &lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; apt install npm&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完成之后使用 &lt;code&gt;node -v&lt;/code&gt; 和 &lt;code&gt;npm -v&lt;/code&gt; 命令来查看版本信息:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;node&lt;/span&gt; -v
&lt;span class=&quot;kw&quot;&gt;v4.2.6&lt;/span&gt;
$ &lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; -v
&lt;span class=&quot;kw&quot;&gt;3.5.2&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
遗憾的是通过这种方式安装的 Node.js 版本都比较低,而且并不符合我们项目的环境要求&lt;code&gt;(官网文档中出现的版本为:node:v6.10.1;npm:3.10.10)&lt;/code&gt;,为了避免因软件版本不同而引起的问题,我们还需要对 Node 以及 npm 的版本进行升级操作&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;先配置 npm 仓库,因为国内的网络环境,直接从 npm 官方源安装软件包速度会特别慢&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; install -g nrm&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;安装完成之后，列出可用的软件源&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;nrm&lt;/span&gt; ls
  &lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; ---- https://registry.npmjs.org/
  &lt;span class=&quot;kw&quot;&gt;cnpm&lt;/span&gt; --- http://r.cnpmjs.org/
  &lt;span class=&quot;kw&quot;&gt;taobao&lt;/span&gt; - https://registry.npm.taobao.org/
  &lt;span class=&quot;kw&quot;&gt;nj&lt;/span&gt; ----- https://registry.nodejitsu.com/
  &lt;span class=&quot;kw&quot;&gt;rednpm&lt;/span&gt; - http://registry.mirror.cqupt.edu.cn/
  &lt;span class=&quot;kw&quot;&gt;npmMirror&lt;/span&gt;  https://skimdb.npmjs.com/registry/
  &lt;span class=&quot;kw&quot;&gt;edunpm&lt;/span&gt; - http://registry.enpmjs.org/&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;可以切换到淘宝的源,这个速度在国内还是很快的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;nrm&lt;/span&gt; use taobao
&lt;span class=&quot;kw&quot;&gt;Registry&lt;/span&gt; has been set to: https://registry.npm.taobao.org/&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装 node 版本管理工具 n&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; install -g n&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过 n 安装指定版本&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;n&lt;/span&gt; 6.10.1&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;再次使用 node -v 命令,查看当前版本&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;node&lt;/span&gt; -v
&lt;span class=&quot;kw&quot;&gt;v6.10.1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;升级 npm 的版本号&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; install -g npm@3.10.10&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;再次使用 npm -v 命令,查看当前版本&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; -v
&lt;span class=&quot;kw&quot;&gt;3.10.10&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此,Node.js的环境就算是搭建完成了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;hyperledger-fabric-版本切换&quot;&gt;Hyperledger Fabric 版本切换&lt;/h3&gt;
&lt;p&gt;官方文档中提供了三种选择,一种是不想对链码进行修改的,下面操作可以不必执行.而想要自己修改链码的而且想使用最新版本 Fabric 的可以切换到最新的分支,虽然说该项目兼容 &lt;code&gt;Hyperledger Fabric v1.1x&lt;/code&gt;,但是出于避免出现未知的错误,建议将分支切换到文档中使用的版本&lt;code&gt;ae4e37d&lt;/code&gt;.切换步骤命令如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将此版本与网络/ Fabric 的提交哈希匹配（前7个字符将起作用）&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/hyperledger/fabric
$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; checkout ae4e37d&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果按照我的上篇博客配置的,这里的 &lt;code&gt;$GOPATH&lt;/code&gt; 既用户主目录下的 go 文件夹,&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;使用git分支确认级别。它应该显示与您提供的相符的提交级别&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; branch
  &lt;span class=&quot;kw&quot;&gt;(HEAD&lt;/span&gt; detached at ae4e37d&lt;span class=&quot;kw&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;release-1.1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示已经切换到&lt;code&gt;ae4e37d&lt;/code&gt;分支,当前最新发布版本为&lt;code&gt;1.1&lt;/code&gt;. 当然,你如果想知道&lt;code&gt;ae4e37d&lt;/code&gt;分支的具体信息,可以通过如下命令查看:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; log -p
&lt;span class=&quot;kw&quot;&gt;commit&lt;/span&gt; ae4e37dbafe74997534ab317dec5c3f4f53b6a84
&lt;span class=&quot;kw&quot;&gt;Author&lt;/span&gt;: Gari Singh &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;gari.r.singh@gmail.com&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;Date&lt;/span&gt;: Mon Aug 7 17:50:39 2017 -0400

    &lt;span class=&quot;kw&quot;&gt;FAB-5652&lt;/span&gt; Prepare fabric for 1.0.2 release
    
    &lt;span class=&quot;kw&quot;&gt;-base&lt;/span&gt; version = 1.0.2
    &lt;span class=&quot;kw&quot;&gt;-prev&lt;/span&gt; version = 1.0.1
    &lt;span class=&quot;kw&quot;&gt;-is_release&lt;/span&gt; = false
    
    &lt;span class=&quot;kw&quot;&gt;Change-Id&lt;/span&gt;: Ibce2a81193b09015eef896391b0e8166d40e7102
    &lt;span class=&quot;kw&quot;&gt;Signed-off-by&lt;/span&gt;: Gari Singh &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;gari.r.singh@gmail.com&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;diff&lt;/span&gt; --git a/Makefile b/Makefile
&lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; d1febaa..ffe51f3 100755
&lt;span class=&quot;kw&quot;&gt;---&lt;/span&gt; a/Makefile
&lt;span class=&quot;kw&quot;&gt;+++&lt;/span&gt; b/Makefile
&lt;span class=&quot;kw&quot;&gt;@@&lt;/span&gt; -36,9 +36,9 @@
 &lt;span class=&quot;co&quot;&gt;#   - unit-test-clean - cleans unit test state (particularly from docker)&lt;/span&gt;
 
 &lt;span class=&quot;kw&quot;&gt;PROJECT_NAME&lt;/span&gt;   = hyperledger/fabric&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面的命令输出结果可以看到,该分支是基于&lt;code&gt;1.0.2&lt;/code&gt;版本的.切换到该分支后,还需要验证结构安装&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开命令提示符/终端输入一下命令&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;$GOPATH&lt;/span&gt;/src/github.com/hyperledger/fabric/examples/chaincode/go/chaincode_example02
$ &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; build --tags nopkcs11 ./&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它应该返回没有错误/警告。您还应该看到在该目录中创建了可执行文件。&lt;br/&gt;请注意，nopkcs11标签很重要。PKCS 11是您不太可能在您的系统上使用的公钥加密标准。 &lt;strong&gt;请记住在开发/构建链码时使用此标志&lt;/strong&gt;。&lt;br/&gt;对编写链码 IDE 的选择官方文档推荐了两个 &lt;a href=&quot;https://code.visualstudio.com/#alt-downloads&quot;&gt;Visual Studio Code&lt;/a&gt; 和 &lt;a href=&quot;https://atom.io/&quot;&gt;Atom&lt;/a&gt;,具体的 IDE 开发环境配置可以在网上搜索.&lt;/p&gt;
&lt;h2 id=&quot;搭建一个本地的hyperledger网络&quot;&gt;搭建一个本地的Hyperledger网络&lt;/h2&gt;
&lt;p&gt;这里是构建一个本地的Hyperledger网络,然后测试该网络步骤过程.&lt;/p&gt;
&lt;h3 id=&quot;先下载-marbles-项目&quot;&gt;先下载 Marbles 项目&lt;/h3&gt;
&lt;p&gt;我们需要将 Marbles 下载到本地系统。 让我们使用 Git 通过克隆此存储库来完成该任务。 即使您计划将 Marbles 托管在 IBM Cloud 中，也需要执行这一步,运行以下命令即可&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ~
$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; clone https://github.com/IBM-Blockchain/marbles.git --depth 1
$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; marbles&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:我这里将 Marbles 克隆到了用户主目录下,你可以选择任意合适的目录&lt;/p&gt;
&lt;h3 id=&quot;下载-hyperledger-fabric-官方例子&quot;&gt;下载 Hyperledger Fabric 官方例子&lt;/h3&gt;
&lt;p&gt;我们将使用 Hyperledger Fabric 例子运行本地网络。他们的代码具有 Fabric 网络的设置以及链接代码示例。我们只会使用网络设置部分。&lt;br/&gt;使用以下命令下载它们的节点示例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;git&lt;/span&gt; clone https://github.com/hyperledger/fabric-samples.git
$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; fabric-samples&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果之前没有下载各种结构组织的 Docker 镜像,那么可以使用下面的命令进行下载&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;curl&lt;/span&gt; -sSL https://raw.githubusercontent.com/hyperledger/fabric/release-1.1/scripts/bootstrap-1.1.0-preview.sh -o setup_script.sh
$ &lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; bash setup_script.sh&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请务必通过运行以下命令或将其粘贴到您的.profile文件中，将这些二进制文件添加到PATH变量中&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;运行命令&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;PATH=$PWD&lt;/span&gt;/bin:&lt;span class=&quot;ot&quot;&gt;$PATH&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;若想永久将这些二进制文件添加到PATH变量中,可以加入到系统环境变量中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;vim&lt;/span&gt; ~/.profile&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开后在最后一行插入插入&lt;code&gt;export PATH=/home/ubuntu/fabric-samples/bin:$PATH&lt;/code&gt;,这里可以先使用 &lt;code&gt;pwd&lt;/code&gt; 命令来获取您本地&lt;code&gt;fabric-samples&lt;/code&gt;的目录,然后将上面命令中的 &lt;code&gt;$PWD&lt;/code&gt; 换成该目录即可,最后使用 &lt;code&gt;:wq&lt;/code&gt; 保存退出,执行下面命令刷新一下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;source&lt;/span&gt;  ~/.profile&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;启动网络&quot;&gt;启动网络&lt;/h3&gt;
&lt;p&gt;接下来，我们需要启动Fabric。运行下面的脚本来让所有的事情都发生&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt; $ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ./fabcar
 $ &lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; ./startFabric.sh&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一两分钟后，命令提示符将返回,运行结果如下图所示&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/hGLmDfj1KH.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在运行该命令 &lt;code&gt;docker ps&lt;/code&gt; 查看当前正在运行的&lt;code&gt;Docker&lt;/code&gt;容器。您应该看到类似于以下内容的内容：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;CONTAINER&lt;/span&gt; ID        IMAGE                                   COMMAND                  CREATED             STATUS              PORTS                                            NAMES
&lt;span class=&quot;kw&quot;&gt;01cdf948b39c&lt;/span&gt;        dev-peer0.org1.example.com-fabcar-1.0   &lt;span class=&quot;st&quot;&gt;&quot;chaincode -peer.add…&quot;&lt;/span&gt;   2 minutes ago       Up 2 minutes                                                         dev-peer0.org1.example.com-fabcar-1.0
&lt;span class=&quot;kw&quot;&gt;2f79bac1371e&lt;/span&gt;        hyperledger/fabric-tools                &lt;span class=&quot;st&quot;&gt;&quot;/bin/bash&quot;&lt;/span&gt;              3 minutes ago       Up 3 minutes                                                         cli
&lt;span class=&quot;kw&quot;&gt;648da0074a8d&lt;/span&gt;        hyperledger/fabric-peer                 &lt;span class=&quot;st&quot;&gt;&quot;peer node start&quot;&lt;/span&gt;        3 minutes ago       Up 3 minutes        0.0.0.0:7051-&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;7051/tcp, 0.0.0.0:7053-&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;7053/tcp   peer0.org1.example.com
&lt;span class=&quot;kw&quot;&gt;868e0f78f80e&lt;/span&gt;        hyperledger/fabric-ca                   &lt;span class=&quot;st&quot;&gt;&quot;sh -c 'fabric-ca-se…&quot;&lt;/span&gt;   3 minutes ago       Up 3 minutes        0.0.0.0:7054-&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;7054/tcp                           ca.example.com
&lt;span class=&quot;kw&quot;&gt;4c385bb6aa9d&lt;/span&gt;        hyperledger/fabric-couchdb              &lt;span class=&quot;st&quot;&gt;&quot;tini -- /docker-ent…&quot;&lt;/span&gt;   3 minutes ago       Up 3 minutes        4369/tcp, 9100/tcp, 0.0.0.0:5984-&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;5984/tcp       couchdb
&lt;span class=&quot;kw&quot;&gt;4b9a2b2b0718&lt;/span&gt;        hyperledger/fabric-orderer              &lt;span class=&quot;st&quot;&gt;&quot;orderer&quot;&lt;/span&gt;                3 minutes ago       Up 3 minutes        0.0.0.0:7050-&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;7050/tcp                           orderer.example.com&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果你没有看到全部6个容器在运行，那么有些问题是错误的。在继续之前，您需要排除故障。我建议进入一个已停止的容器的日志&lt;code&gt;sudo docker logs peer0&lt;/code&gt;（替换名称为w / e的peer0已停止）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果您看到&lt;code&gt;containerID already exists&lt;/code&gt;正在运行的&lt;code&gt;Docker&lt;/code&gt;工具 - 组成，那么您需要删除现有的容器。该命令将删除所有容器&lt;code&gt;docker rm -f $(docker ps -aq)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装并实例化链代码&quot;&gt;安装并实例化链代码&lt;/h2&gt;
&lt;p&gt;很好，就快要完成了！现在，我们需要运行我们的 Marbles 链码。 请记住，链码是一个关键组件，它最终会在账本上创建我们的 Marbles 事务。 该链码是需要安装在对等节点上，然后在一个通道上实例化的 GoLang 代码。 已为您编写好该代码！ 我们只需要运行它&lt;/p&gt;
&lt;h3 id=&quot;准备&quot;&gt;准备&lt;/h3&gt;
&lt;p&gt;我们需要一些弹珠依赖来运行安装/实例化脚本。通过返回 Marbles 目录的根目录并输入这些命令来安装弹珠 npm 依赖关系:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ~/marbles
$ &lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; install&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重要的是安装没有错误返回（警告是好​​的）。如果你有 npm 安装错误，在继续之前你必须解决并修复这些错误&lt;/p&gt;
&lt;h3 id=&quot;生成证书与密钥文件&quot;&gt;生成证书与密钥文件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;这是一个非常重要步骤！&lt;/strong&gt; 安装和实例化操作需要管理员证书和私钥。如果找不到这些文件，您将无法运行任何操作。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第1步：在终端/命令提示符中更改路径到fabric-samples/fabcar目录：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ../fabric-samples/fabcar&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;第2步：运行命令：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;node&lt;/span&gt; enrollAdmin.js
 &lt;span class=&quot;kw&quot;&gt;Store&lt;/span&gt; path:/home/ubuntu/fabric-samples/fabcar/hfc-key-store
&lt;span class=&quot;kw&quot;&gt;Successfully&lt;/span&gt; enrolled admin user &lt;span class=&quot;st&quot;&gt;&quot;admin&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;Assigned&lt;/span&gt; the admin user to the fabric client ::{&lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;admin&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;mspid&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;Org1MSP&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;roles&quot;&lt;/span&gt;:null,&lt;span class=&quot;st&quot;&gt;&quot;affiliation&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;enrollmentSecret&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;enrollment&quot;&lt;/span&gt;:{&lt;span class=&quot;st&quot;&gt;&quot;signingIdentity&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;9b6f84a7672908c0629d9b3ad0bf23437d624089061e937af0b0476ec6dec81d&quot;&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;&quot;identity&quot;&lt;/span&gt;:{&lt;span class=&quot;st&quot;&gt;&quot;certificate&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;-----BEGIN CERTIFICATE-----\nMIIB8DCCAZegAwIBAgIUeQVhK98LQFSz5Dz0bt3bB9Baom8wCgYIKoZIzj0EAwIw\nczELMAkGA1UEBhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExFjAUBgNVBAcTDVNh\nbiBGcmFuY2lzY28xGTAXBgNVBAoTEG9yZzEuZXhhbXBsZS5jb20xHDAaBgNVBAMT\nE2NhLm9yZzEuZXhhbXBsZS5jb20wHhcNMTgwNTE1MTA1ODAwWhcNMTkwNTE1MTA1\nODAwWjAQMQ4wDAYDVQQDEwVhZG1pbjBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IA\nBPlS00VDvBQpsmMFUGnNzEAQd7lgpTNgEDpzJGk4/xfBuechE8cfNH6WuibJtXxh\nsEQ4uLAlDcOAP1nfXq9oEtWjbDBqMA4GA1UdDwEB/wQEAwIHgDAMBgNVHRMBAf8E\nAjAAMB0GA1UdDgQWBBShJWerMoKEE2u+dn08UBkGs4tWzjArBgNVHSMEJDAigCBC\nOaoNzXba7ri6DNpwGFHRRQTTGq0bLd3brGpXNl5JfDAKBggqhkjOPQQDAgNHADBE\nAiAmqy0J0M1aZlvuv6cDK8GjeMTMjN0V5dZIW/uBv+whtAIgCMbyQRtE+PDwsoSS\nG40hZ4UOoNS2tvIXHRglMMHvKjs=\n-----END CERTIFICATE-----\n&quot;&lt;/span&gt;}}}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;第3步：运行命令：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;node&lt;/span&gt; registerUser.js 
 &lt;span class=&quot;kw&quot;&gt;Store&lt;/span&gt; path:/home/ubuntu/fabric-samples/fabcar/hfc-key-store
&lt;span class=&quot;kw&quot;&gt;Successfully&lt;/span&gt; loaded admin from persistence
&lt;span class=&quot;kw&quot;&gt;Successfully&lt;/span&gt; registered user1 - secret:PfPGkGQmNgfw
&lt;span class=&quot;kw&quot;&gt;Successfully&lt;/span&gt; enrolled member user &lt;span class=&quot;st&quot;&gt;&quot;user1&quot;&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;User1&lt;/span&gt; was successfully registered and enrolled and is ready to intreact with the fabric network&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;第4步：仔细检查文件夹中是否创建了一些密钥和证书文件 &lt;code&gt;fabric-samples/fabcar/hfc-key-store&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第5步：接下来，我们需要验证连接配置文件中的文件路径是否与您的安装相匹配。
&lt;ul&gt;&lt;li&gt;打开你的连接配置文件&lt;code&gt;&amp;lt;marbles root&amp;gt;/config/connection_profile_local.json&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在这个JSON里找到这三个字段：
&lt;ul&gt;&lt;li&gt;organizations -&amp;gt; x-adminCert -&amp;gt; path&lt;/li&gt;
&lt;li&gt;organizations -&amp;gt; x-adminKeyStore -&amp;gt; path&lt;/li&gt;
&lt;li&gt;client -&amp;gt; credentialStore -&amp;gt; path&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每个字段中 path 的值需要反映您的环境（您的目录结构）。你可以浏览这些文件夹和文件以验证它们是否存在。&lt;/li&gt;
&lt;li&gt;您可能需要根据您放置&lt;code&gt;fabric-samples&lt;/code&gt;目录的位置以及密钥存储数据所在的位置来更改这些值。一旦路径有效，您可以继续。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第6步：你完成了！将路径更改回弹珠根目录：&lt;code&gt;cd ~/marbles&lt;/code&gt;并继续执行下面的安装链接代码说明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;安装链码&quot;&gt;安装链码&lt;/h3&gt;
&lt;p&gt;完成之后，我们需要将链代码放到 peer 节点的文件系统中。记住 chaincode 定义了什么弹珠（资产）是我们系统交易的业务逻辑。你可以在这个目录中找到弹珠链码&lt;code&gt;&amp;lt;marbles root&amp;gt;/chaincode/src/&lt;/code&gt;。这个目录下的文件就是链码文件。&lt;/p&gt;
&lt;p&gt;我们将使用位于scripts文件夹中的脚本&lt;code&gt;install_chaincode.js&lt;/code&gt;。它会读取我们的弹珠配置文件和连接配置文件数据。您可以通过编辑&lt;code&gt;install_chaincode.js&lt;/code&gt;文件来更改本项目链代码ID或版本。如果您想编辑这些文件并想要更多关于其内容的信息，请打开下面的配置和连接配置文件自述文件。如果您对默认设置没有问题，那么只需将这些文件单独保存并运行下面的命令即可。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ./scripts
$ &lt;span class=&quot;kw&quot;&gt;node&lt;/span&gt; install_chaincode.js

  &lt;span class=&quot;kw&quot;&gt;......&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;..........&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#这里省略了许多输出信息&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;..........&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;......&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;---------------------------------------&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: Now we install
&lt;span class=&quot;kw&quot;&gt;---------------------------------------&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Installing Chaincode
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Sending install req targets=[grpc.http2.keepalive_time=300, grpc.keepalive_time_ms=300000, grpc.http2.keepalive_timeout=35, grpc.keepalive_timeout_ms=3500, grpc.max_receive_message_length=-1, grpc.max_send_message_length=-1, grpc.primary_user_agent=grpc-node/1.10.1, _url=grpc://localhost:7051, addr=localhost:7051, , _request_timeout=90000, , _name=null], chaincodePath=marbles, chaincodeId=marbles, chaincodeVersion=v4
&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: [packager/Golang.js]: packaging GOLANG from marbles
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Successfully obtained transaction endorsement
&lt;span class=&quot;kw&quot;&gt;---------------------------------------&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: Install done. Errors: nope
&lt;span class=&quot;kw&quot;&gt;---------------------------------------&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出现上述输出结果,说明链码安装成功&lt;/p&gt;
&lt;h3 id=&quot;实例化链码&quot;&gt;实例化链码&lt;/h3&gt;
&lt;p&gt;接下来我们需要实例化链码。这会让您的 &lt;code&gt;channel(通道)&lt;/code&gt; 启动弹珠链码&lt;code&gt;mychannel&lt;/code&gt;。一旦完成，我们准备使用区块链网络来记录我们的系统(Marbels)活动。使用下面的命令完成实例化:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;61&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;node&lt;/span&gt; instantiate_chaincode.js  

  &lt;span class=&quot;kw&quot;&gt;......&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;..........&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#这里省略了许多输出信息&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;..........&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;......&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;---------------------------------------&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: Now we instantiate
&lt;span class=&quot;kw&quot;&gt;---------------------------------------&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Instantiating Chaincode peer_urls=[grpc://localhost:7051], channel_id=mychannel, chaincode_id=marbles, chaincode_version=v4, cc_args=[12345], ssl-target-name-override=null, pem=null, grpc.http2.keepalive_time=300, grpc.keepalive_time_ms=300000, grpc.http2.keepalive_timeout=35, grpc.keepalive_timeout_ms=3500
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Sending instantiate req targets=[grpc.http2.keepalive_time=300, grpc.keepalive_time_ms=300000, grpc.http2.keepalive_timeout=35, grpc.keepalive_timeout_ms=3500, grpc.max_receive_message_length=-1, grpc.max_send_message_length=-1, grpc.primary_user_agent=grpc-node/1.10.1, _url=grpc://localhost:7051, addr=localhost:7051, , _request_timeout=90000, , _name=null], chaincodeId=marbles, chaincodeVersion=v4, fcn=init, args=[12345], 0=214, 1=155, 2=127, 3=34, 4=197, 5=82, 6=208, 7=191, 8=141, 9=140, 10=57, 11=113, 12=46, 13=90, 14=76, 15=231, 16=170, 17=118, 18=197, 19=137, 20=186, 21=212, 22=64, 23=33, _transaction_id=d550ed194a2d798f2a6c2924c0302fdc6323fba2835e128f3dc541f1b6754525
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Successfully obtained transaction endorsement
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Successfully ordered instantiate endorsement.
&lt;span class=&quot;kw&quot;&gt;---------------------------------------&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: Instantiate done. Errors: nope
&lt;span class=&quot;kw&quot;&gt;---------------------------------------&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出现上述输出结果,说明实例化链码成功&lt;/p&gt;

&lt;p&gt;通过上述操作,我们所有的环境都已经配置完成了,接下来就是运行本项目&lt;/p&gt;
&lt;h2 id=&quot;安装依赖&quot;&gt;安装依赖&lt;/h2&gt;
&lt;p&gt;打开命令提示符/终端并导航到 Marbles 目录,并执行下面的几个命令:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ~/marbles
$ &lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; npm install gulp -g
$ &lt;span class=&quot;kw&quot;&gt;sudo&lt;/span&gt; npm install&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装依赖成功后,并且没有错误返回（警告是好​​的）.如果你有 npm 安装错误，在继续之前你必须解决并修复这些错误&lt;/p&gt;
&lt;h2 id=&quot;运行项目&quot;&gt;运行项目&lt;/h2&gt;
&lt;p&gt;使用如下命令运行项目:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;28&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;gulp&lt;/span&gt; marbles_local

  &lt;span class=&quot;kw&quot;&gt;......&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;..........&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#这里省略了许多输出信息&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;..........&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;......&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;-----------------------------------&lt;/span&gt; Server Up - localhost:3001 -----------------------------------
&lt;span class=&quot;kw&quot;&gt;Welcome&lt;/span&gt; aboard:  United Marbles
&lt;span class=&quot;kw&quot;&gt;Channel&lt;/span&gt;:     mychannel
&lt;span class=&quot;kw&quot;&gt;Org&lt;/span&gt;:         Org1MSP
&lt;span class=&quot;kw&quot;&gt;CA&lt;/span&gt;:      fabric-ca
&lt;span class=&quot;kw&quot;&gt;Orderer&lt;/span&gt;:     fabric-orderer
&lt;span class=&quot;kw&quot;&gt;Peer&lt;/span&gt;:        fabric-peer-org1
&lt;span class=&quot;kw&quot;&gt;Chaincode&lt;/span&gt; ID:    marbles
&lt;span class=&quot;kw&quot;&gt;Chaincode&lt;/span&gt; Version:  v4
&lt;span class=&quot;kw&quot;&gt;------------------------------------------&lt;/span&gt; Websocket Up ------------------------------------------


&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: [fcw] Going to enroll peer_urls=[grpc://localhost:7051], channel_id=mychannel, uuid=marblesDockerComposeNetworkmychannelOrg1MSPfabricpeerorg1, ca_url=http://localhost:7054, orderer_url=grpc://localhost:7050, enroll_id=admin, enroll_secret=adminpw, msp_id=Org1MSP, kvs_path=/home/ubuntu/.hfc-key-store
&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: [fcw] Successfully loaded enrollment from persistence
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: added peer grpc://localhost:7051
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Successfully got enrollment marblesDockerComposeNetworkmychannelOrg1MSPfabricpeerorg1
&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: Success enrolling admin
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: Checking if chaincode is already instantiated or not 1

&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: Checking for chaincode...
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Querying Chaincode: read()
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[selftest], txId=null
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Peer Query Response - len: 5 type: number
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Successful query transaction.

&lt;span class=&quot;kw&quot;&gt;-----------------------------&lt;/span&gt; Chaincode found on channel &lt;span class=&quot;st&quot;&gt;&quot;mychannel&quot;&lt;/span&gt; -----------------------------


&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: Checking chaincode and ui compatibility...
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Querying Chaincode: read()
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Sending query req: chaincodeId=marbles, fcn=read, args=[marbles_ui], txId=null
&lt;span class=&quot;kw&quot;&gt;warn&lt;/span&gt;: [fcw] warning - query resp is not json, might be okay: string 4.0.1
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Successful query transaction.
&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: Chaincode version is good
&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: Checking ledger for marble owners listed in the config file

&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: Fetching EVERYTHING...
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Querying Chaincode: read_everything()
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Sending query req: chaincodeId=marbles, fcn=read_everything, args=[], txId=null
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Peer Query Response - len: 30 type: object
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: [fcw] Successful query transaction.
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: This company has not registered marble owners
&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: We need to make marble owners


&lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
&lt;span class=&quot;kw&quot;&gt;info&lt;/span&gt;: Detected that we have NOT launched successfully yet
&lt;span class=&quot;kw&quot;&gt;debug&lt;/span&gt;: Open your browser to http://localhost:3001 and login as &lt;span class=&quot;st&quot;&gt;&quot;admin&quot;&lt;/span&gt; to initiate startup
&lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出现上述输出信息,则表示项目启动成功,现在你可以在浏览器中输入 &lt;code&gt;http://localhost:3001&lt;/code&gt;来访问本项目,并且您不需要输入密码或更改预先填写的用户名&lt;code&gt;admin&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 本人在使用&lt;code&gt;gulp marbles_local&lt;/code&gt;命令启动项目的过程中出现了如下图的错误,有可能你在运行时也会出现这个错误:&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/Ibhalhh6Hb.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;br/&gt;查看 &lt;a href=&quot;https://github.com/IBM-Blockchain/marbles/issues/208&quot;&gt;Issues:208&lt;/a&gt;可以发现有人已经遇到过这种问题, 阅读后发现这个&lt;code&gt;bug&lt;/code&gt;是由&lt;code&gt;fabric-sdk-node&lt;/code&gt; &lt;a href=&quot;https://jira.hyperledger.org/browse/FAB-2593&quot; class=&quot;uri&quot;&gt;https://jira.hyperledger.org/browse/FAB-2593&lt;/a&gt; 引起的， 需要将&lt;code&gt;hfc-key-store&lt;/code&gt;目录复制到您的主目录&lt;code&gt;$HOME / .hfc-key-store&lt;/code&gt;，然后重新配置&lt;code&gt;connection_profile_local.json&lt;/code&gt;的&lt;code&gt;client.credentialStore.path&lt;/code&gt;. 如果你也遇到了这个问题,可以参考如下步骤.&lt;/p&gt;
&lt;ul readability=&quot;7.4372384937238&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;先将&lt;code&gt;hfc-key-store&lt;/code&gt;目录复制到您的主目录&lt;code&gt;$HOME / .hfc-key-store&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ~/fabric-samples/fabcar
$ &lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; -r hfc-key-store  ~/.hfc-key-store&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;重新配置&lt;code&gt;connection_profile_local.json&lt;/code&gt;的&lt;code&gt;client.credentialStore.path&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ~/marbles/config
$ &lt;span class=&quot;kw&quot;&gt;vim&lt;/span&gt; connection_profile_local.json&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在文件中定位到下面的片段:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;client&quot;: {
    &quot;organization&quot;: &quot;Org1MSP&quot;,
    &quot;credentialStore&quot;: {
        &quot;path&quot;: &quot;/$HOME/.hfc-key-store&quot;
    }
 },&lt;/code&gt;
&lt;/pre&gt;
将&lt;code&gt;path&lt;/code&gt;改为上面的路径(&lt;code&gt;/$HOME/.hfc-key-store&lt;/code&gt;)即可.&lt;/li&gt;
&lt;li readability=&quot;8.7848605577689&quot;&gt;
&lt;p&gt;返回 Marbles 主目录,重新运行本项目&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;$ &lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; ~/marbles
$ &lt;span class=&quot;kw&quot;&gt;gulp&lt;/span&gt; marbles_local&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果这样,还不能运行,你可以在 &lt;a href=&quot;https://github.com/IBM-Blockchain/marbles/issues&quot;&gt;issues&lt;/a&gt; 里找找看有没有相同的错误, 如果有解答过程,可以按照解答的过程,自己试着解决这些问题.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;运行配置截图&quot;&gt;运行配置截图&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;开始&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/fDf4fKbgFK.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;br/&gt;点击选择右边的按钮&lt;code&gt;Guided&lt;/code&gt;, 通过这种方式即可以了解 Fabric 又能自定义一些设置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第一步：检查连接配置数据&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/2hhCaGKj8j.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一步是检查你的连接配置JSON文件。 检查的文件是：&lt;code&gt;marbles/config/marbles_local.json&lt;/code&gt;和`&lt;code&gt;marbles/config/connection_profile_local.json&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第二步：注册管理员&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/5ik2l3ECfl.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，我们尝试将您注册为贵公司的管理员。此步骤与您的证书颁发机构（CA）联系并从您的连接配置文件中提供了&lt;code&gt;enrollID&lt;/code&gt;和&lt;code&gt;enrollSecret&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第三步：查找 Chaincode&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/mcIhE0Ikig.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在我们需要在您的&lt;code&gt;channel(通道)&lt;/code&gt;上找到链码。检查或修改您的连接配置文件里配置的链码名为弹珠的通道&lt;code&gt;mychannel&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第四步：创建资产&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/bLlHc49aE9.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作为一个弹珠贸易公司，您可以携带新的弹珠业主。这些弹珠业主代表您的用户群。&lt;br/&gt;这一步将创建弹珠用户并且每个用户拥有3个弹珠。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;进行下一步前,请点击&lt;code&gt;Create&lt;/code&gt;进行创建&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第五步：配置完成,点击&lt;code&gt;Enter&lt;/code&gt;进入系统&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/3aKhFkg7ee.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;进入系统后,你可以按照本教程开头，或者下面的&lt;code&gt;Gif&lt;/code&gt;动画演示的那样为一个用户创建弹珠资产,或者将一个弹珠资产转移给另一个用户;也可以删除这个弹珠资产.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在每次点击创建,删除,交易资产时其实都是在进行调用链码操作,而且本项目还有动画进行调用链码的演示:&lt;br/&gt;&lt;img src=&quot;http://ovasw3yf9.bkt.clouddn.com/blog/180515/iAh9G7eF2m.gif&quot; alt=&quot;mark&quot;/&gt;&lt;br/&gt;当然,还有更多的功能, 你可以在部署后尽情体验!&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Tue, 15 May 2018 14:00:00 +0000</pubDate>
<dc:creator>Dmego</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dmego/p/9043312.html</dc:identifier>
</item>
<item>
<title>js算法初窥01（排序算法01-冒泡、选择、插入） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/9026887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/9026887.html</guid>
<description>&lt;p&gt;　　排序，我想大家一定经历过或者正在经历着。或许你不懂算法，对排序算法一无所知，但是你一定用过一些第三方库的api来一键排序，那么，在你享受便捷的同时，你是否想过它的底层是如何实现的？这样的算法实现方式是不是最好的？还有没有其它的可能性来实现更快速的排序？那么，希望这一篇文章过后。对于排序算法，你不会再觉得陌生和迷惑。&lt;/p&gt;
&lt;p&gt;　　这篇文章会介绍一些简单常用的排序算法，比如我们耳熟能详的冒泡排序，以及选择排序、插入排序、归并排序等等等等。当然，你一旦学会了这些算法在js中的实现方式，其实你也就弄懂了这种算法。就算以后要用其它语言来实现这些算法，也不过就是一些语言特性上的差别罢了。&lt;/p&gt;
&lt;p&gt;　　我们会专门写一个数组类，并在其中加入各种排序算法。那么，我们先开始搭一个简单的架子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ArrayList() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; array =&lt;span&gt; [];

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.insert = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item) {
        array.push(item);
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.toString = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array.join();
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们构建一个数组类，并且只有一个insert和toString方法，以便我们输入数组元素和打印数组元素。&lt;/p&gt;
&lt;p&gt;　　下面我们为这个数组类添加各种排序方法。我们先从最简单的开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、冒泡排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　冒泡排序十分简单，就是比较数组中任何两个相邻的元素，如果第一个比第二个大，那么就交换两个元素的位置。这样，较大值得元素就会一点一点移动到正确的位置，就像气泡升至表面一样。我们先来看一下代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60.535793357934&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换数组中两个相邻元素的方法，传入的是相邻的数组，以及相邻两个元素的下标。&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; swap = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (array,index1,index2) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里，是最“普通”的方式，通过一个中间量来存储index1元素，因为要把index1的值设置为index2，然后再把index2的值设置为刚才存储index1的aux变量。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 希望我上面说的足够清楚。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; aux =&lt;span&gt; array[index1];
    array[index1] &lt;/span&gt;=&lt;span&gt; array[index2];
    array[index2] &lt;/span&gt;=&lt;span&gt; aux;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 但是我们可以有更为简便的方式来做到替换两个数组元素位置的方式。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个是下面的ES6新增的方法。数组的解构赋值。不多说，大家可以自行去查看。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[array[inde1],array[index2]] = [array[index2],array[index1]];&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 另外一个方法是利用数组的splice方法，删除从index1开始的两个元素，并且在删除的位置插入index2，和index1已达到替换元素的目的。&lt;br/&gt;　　// 如果你对数组方法还不是很清楚，请看这里&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zaking/p/8711731.html&quot;&gt;用js来实现那些数据结构02（数组篇02-数组方法）&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;array.splice(index1,2,array[index2],array[index1]);&lt;/span&gt;
&lt;span&gt;};
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是最简单，当然也是最慢的排序方法，我们需要两层循环来判断值得大小，以此来一步一步确定每一个值得位置。&lt;/span&gt;&lt;span&gt;
　　//&lt;/span&gt;&lt;span&gt; 这里我要刨根问底一下，为什么外层循环（i）循环的是数组元素的长度，而内层（j）是比数组长度少1的循环次数？&lt;/span&gt;&lt;span&gt;
　　//&lt;/span&gt;&lt;span&gt; 因为这是可以保证每两个元素都进行过比较的最小的循环次数，不信你把两次循环的次数增加（length +100000）;来试一下，发现结果仍旧是我们想要的。（当然，这更耗费时间。）&lt;/span&gt;&lt;span&gt;
　　//&lt;/span&gt;&lt;span&gt; 但是你把次数减得更少就不行了，排序的结果就不对了（其实这里可以合理的减少内层循环的次数，后面说）。你还可以这么理解，外层循环控制我们有多少个数需要比较，内层循环去具体的操作两个数的比较。&lt;/span&gt;
 &lt;span&gt;this&lt;/span&gt;.bubbleSort = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; array.length;
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; length; i++) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i=0,1,2,3,4...length-1;&lt;/span&gt;
         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(i,&quot;i&quot;);&lt;/span&gt;
         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; length-1;j++) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;j = 0,1,2,3,4...length - 1 - 1;&lt;/span&gt;
             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(j,&quot;j&quot;);&lt;/span&gt;
             &lt;span&gt;if&lt;/span&gt;(array[j] &amp;gt; array[j+1&lt;span&gt;]){
                 swap(array,j,j&lt;/span&gt;+1&lt;span&gt;)
             }
         }
     }
 };


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们来写一个简单的方法生成一个未排序的arraylist。//这个方法是在构造函数外的。你不用也可以。只是为了方便生成一个数组罢了。&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; creatArrayList (size) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; array = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = size; i &amp;gt; 0; i--&lt;span&gt;) {
        array.insert(i);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arraylist = creatArrayList(5&lt;span&gt;);
console.log(arraylist.toString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5,4,3,2,1&lt;/span&gt;
&lt;span&gt;arraylist.bubbleSort();
console.log(arraylist.toString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1,2,3,4,5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的解释我相信已经够详细了，我们下面接着看看是否可以改进一下这垃圾的耗时间的效率低的冒泡排序，让我们在简单实现的基础上提高一点点性能？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　 //&lt;/span&gt;&lt;span&gt;咱们看看modifiedBubbleSort和bubbleSort的区别，唯一不同的地方就在于内层循环的时候在for循环的第二个条件中多减了一个i。这么做的用意是什么呢？&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们一点一点来捋一下这点点代码。假设我们的数组是【5，4，3，2，1】；当i = 0的时候(第一次外循环)，我们拿5去依次和4，3，2，1来比较，最后数组渐变成了【4，3，2，1，5】;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么此时，5就是最大的，当i=1的时候(第二次外循环)。此时我们的内循环就不再需要去拿当前的j去与5（也就是数组中确定了的最大的）比较。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 外层每循环一次，内层中的每个元素就相互交换了一下位置（如果符合条件的话），最终每一次内层循环完毕，都会确定一个当前轮数最大的值。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么既然我们已经知道最大的值是什么，就无需在后面的循环轮数中再去执行一次。这样就可以提高一点我们的执行效率。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里再多句嘴，当i = 0时，j = 0，j &amp;lt; length - 1 - 0;当i = 1时，j = 0，j &amp;lt; length - 1 - 1;(要理解这句话)&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.modifiedBubbleSort = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; array.length;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; length - 1 - i;j++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(array[j] &amp;gt; array[j+1&lt;span&gt;]) {
                    swap(array,j,j&lt;/span&gt;+1&lt;span&gt;);
                }
            }
        }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　改进后的冒泡排序我们也学会了，但是也就只能这样了。没办法再进一步的进行优化和效率的提升。冒泡排序，是最基础的，最不推荐的排序方式。因为它的时间复杂度是O(n&lt;sup&gt;2&lt;/sup&gt;)，大O表示法，我们会在后面的内容中详细的讲解什么是大O表示法。这里可以暂时的理解为，两层循环形成了i*j的计算结果，也就是length*length的循环总次数。也就是n&lt;sup&gt;2.&lt;/sup&gt;。（事实上就是这么回事）。如果是三层循环，那很有可能就是O(n&lt;sup&gt;3&lt;/sup&gt;)的复杂度了。&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;2、选择排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F&quot; target=&quot;_blank&quot;&gt;选择排序&lt;/a&gt;的思想是，找到数据结构中最小值并将其放在第一位，接着找到第二小的值，放到第二位，以此类推。（当然你也可以找最大的值放在最后一位）。我们还是来看代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实选择排序也并不复杂，我们来一起看一看。&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt;.selectionSort = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先，我们声明一个存储数组长度的变量，以及一个存储当前最小值的变量，哦不对，存储当前最小值的对应下标的变量。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; array.length,indexMin;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在外层循环，我们循环次数是整个数组的长度。&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; length - 1; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里，最开始的循环我们也不知道谁是最小的，所以我们就把第一个值得下标作为最小值得下标。&lt;/span&gt;
        indexMin =&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内层循环，我们会依次比较当前最小值（也就是indexMin对应的值）和数组中的其它值。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里，为什么是j=i呢？&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们每一次外层循环，都会确定一个最小值并把最小值放置在相应的位置（从下标0开始每次外循环都会往后加1）。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么我们就不需要再去比较开始循环过比较过的下标了，所以我们每次外层循环过后，内层循环都从i的位置开始就可以了。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有点类似于modifiedBubbleSort的j&amp;lt;length - 1 - i;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = i; j &amp;lt; length; j++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这样，我们就可以判断出最小值是什么，如果indexMin所对应的值比j所对应的值还要大，说明最小值对应的下标应该为j。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(array[indexMin] &amp;gt;&lt;span&gt; array[j]) {
                indexMin &lt;/span&gt;=&lt;span&gt; j;
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在外层循环一次结束后，如果i（最开始我们确定的最小值）不等于indexMin。这说明i并不是最小值。我们就交换两个值的位置。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果相等，说明当前的indexMin就是最小值，无需交换位置。&lt;/span&gt;
&lt;span&gt;        console.log(i,indexMin)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i !==&lt;span&gt; indexMin) {
            swap(array,i,indexMin)
        }
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　不过选择排序的复杂度也是O(n&lt;sup&gt;2&lt;/sup&gt;)，效率并不是很好。那么我们继续往下看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、插入排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F#%E8%A8%98%E8%BC%89&quot; target=&quot;_blank&quot;&gt;插入排序&lt;/a&gt;，怎么说呢....就是假设数组中的第一个元素是已经排序过的了（不假设不行，或者说它就是排过序的了，因为就一个元素嘛），那么我们和第二个元素比较，第二个元素是应该在第一个元素之前，还是在原位置不动呢？也就是说，第一个元素和第二个元素比较大小来确定这两个元素的位置。那么这样，单纯就数组元素的前两项来说，他们是排好序的了。那么我们再以第三个元素跟前两个元素进行比较，来确定第三个元素应该插入在前两项元素的什么位置。&lt;/p&gt;
&lt;p&gt;　　简单来说，我们可以认为在排序数组中有一个已排序的子数组，我们依次用后面的元素与子数组中的元素进行比较，以确定后面的元素应该插入到子数组的什么位置。最后，我们就会得到一个完全排序的数组了。&lt;/p&gt;
&lt;p&gt;　　我们继续来看代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.insertionSort = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;j和temp分别用来存储当前的下标和当前下标所对应的值。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; array.length,j,temp;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为什么i要从1开始呢？因为index为0的元素我们视为已经排序过的了。&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 1; i &amp;lt; length; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们用j来存储当前要比较的值的下标也就是i，因为0上的元素已经排序过了（我们默认这样做的）。&lt;/span&gt;
        j =&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同样，我们要比较当前索引的值得大小来确定是否需要换位，所以我们还要有一个临时存储当前下标所对应的值的变量。&lt;/span&gt;
        temp =&lt;span&gt; array[i];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果j&amp;gt;0说明是数组中的元素，&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并且，如果当前j(i)的前一个元素（j-1）比当前的变量大，那么就把j(i)的值设置为j-1的值，也就是把j(i)的位置往后挪了一个。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直到array[j - 1] &amp;gt; temp为false为止。为什么不说j&amp;gt;0这个条件呢？因为这是保证数组正确对比的一个防护层，当然，它是很重要的。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里有一个十分必要且需要注意的point，就是我们的变量j的值的问题。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们在循环直到条件不成立跳出循环的时候，此时的j就是需要把临时存储array[i]的值（也就是temp）插入的地方。&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为，我们在while循环中，每次循环都会用j--来使下标的位置一点点往前移动，直到条件不成立后，我们得到了一个应该插入temp的位置的j。&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (j &amp;gt; 0 &amp;amp;&amp;amp; array[j - 1] &amp;gt;&lt;span&gt; temp) {
            array[j] &lt;/span&gt;= array[j - 1&lt;span&gt;];
            j&lt;/span&gt;--&lt;span&gt;;
        }
        array[j] &lt;/span&gt;=&lt;span&gt; temp;
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的代码就是插入排序了，其中要注意的点就在while循环这一块，需要花费一点心思去理解一下。我在简单的啰嗦两句，其实在代码中，我们声明了j和temp变量用来存储当前的下标和其所对应的值。那么temp的作用是我们可以在找到该插入的位置的时候，可以知道应该插入的值是什么，而j的存在的意义是确定这个位置是哪里。所以，我们在while循环中会拿递减的j所对应的值的前一个去和temp比较，如果条件成立，那么我就往后挪，知道挪不动为止（while循环的条件不匹配），我们就找到了应该插入temp位置的j。这时候在该位置上插入temp就可以了。&lt;/p&gt;

&lt;p&gt;　　那么，简单的排序方法就介绍到这里了，下一章我们来看看复杂一点的，但是效率更高的排序算法。&lt;/p&gt;
&lt;p&gt;　　其实我在写这篇文章的时候，一直在纠结要不要去画画图，让大家可以更容易的去理解这些代码和这些排序算法的实现方式，但是，我在网上搜了一下。一大堆！！所以，我就觉得算了吧。不过文中我已经附上了相关的链接地址，其中有对该算法的概念的更为详细的解释。&lt;/p&gt;

&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 13:08:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/9026887.html</dc:identifier>
</item>
<item>
<title>Vue 实现网易云音乐 WebApp - AprilieJin</title>
<link>http://www.cnblogs.com/cccj/p/9043012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cccj/p/9043012.html</guid>
<description>&lt;p&gt;🎹 基于 Vue(2.5) + vuex + vue-router + vue-axios +better-scroll + Scss + ES6 等开发一款移动端音乐 WebApp，UI 界面参考了安卓版的网易云音乐、flex 布局适配常见移动端。&lt;/p&gt;
&lt;p&gt;😋 项目演示地址：&lt;a href=&quot;http://120.79.162.149:3002/&quot;&gt;移动端音乐 WebApp&lt;/a&gt;，或者可以扫描二维码访问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p87llnk7g.bkt.clouddn.com/18-5-15/34474412.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;电脑在 Chrome 调试模式下食用效果更佳，开启调试模式的手机模式后，如果不能滚动，刷新一下页面即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;😆 源码地址：&lt;a href=&quot;https://github.com/CaiJinyc/vue-music-webapp&quot;&gt;vue-music-webapp&lt;/a&gt;，欢迎 star 和 fork 哦~&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果你觉得我做的不错的话，我就厚着脸皮求个 &lt;strong&gt;star&lt;/strong&gt; ⭐️ 哈，&lt;strong&gt;star&lt;/strong&gt; 是对我最大的鼓励（老脸一红）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;预览&quot;&gt;预览&lt;/h2&gt;
&lt;p&gt;图片虽然压缩过了，但是几张加载一起还是有 3MB 左右，所以请耐心等待一下啦😂。感觉不错的可以去上面 ☝️的地址体验一下呦~&lt;/p&gt;
&lt;h4 id=&quot;推荐排行榜歌手&quot;&gt;推荐、排行榜、歌手&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://p87llnk7g.bkt.clouddn.com/18-5-15/21667995.jpg&quot; alt=&quot;推荐、排行、歌手&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;歌单详情个人中心&quot;&gt;歌单详情、个人中心&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://p87llnk7g.bkt.clouddn.com/18-5-15/4430556.jpg&quot; alt=&quot;详情页面&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;播放器播放列表&quot;&gt;播放器、播放列表&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://p87llnk7g.bkt.clouddn.com/18-5-15/81352770.jpg&quot; alt=&quot;播放器&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;搜索页面&quot;&gt;搜索页面&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://p87llnk7g.bkt.clouddn.com/18-5-15/77000462.jpg&quot; alt=&quot;搜索&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开发目的&quot;&gt;开发目的&lt;/h2&gt;
&lt;p&gt;通过学习开发一个 Vue 全家桶项目，让自己更熟练的使用 Vue 全家桶、模块化开发、ES6 等等知识，提高自己的技术能力。&lt;/p&gt;
&lt;h2 id=&quot;技术栈&quot;&gt;技术栈&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;前端&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Vue&lt;/code&gt;：用于构建用户界面的 MVVM 框架&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vue-router&lt;/code&gt;：为单页面应用提供的路由系统，使用了 &lt;code&gt;Lazy Loading Routes&lt;/code&gt; 技术来实现异步加载优化性能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vuex&lt;/code&gt;：Vue 集中状态管理，在多个组件共享某些状态时非常便捷&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vue-lazyload&lt;/code&gt;：实现图片懒加载，节省用户流量，优化页面加载速度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;better-scroll&lt;/code&gt;：解决移动端各种滚动场景需求的插件，使移动端滑动体验更加流畅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCSS&lt;/code&gt;：css 预编译处理器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ES6&lt;/code&gt;：ECMAScript 新一代语法，模块化、解构赋值、Promise、Class 等方法非常好用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;后端&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Node.js&lt;/code&gt;：利用 Express 搭建的本地测试服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vue-axios&lt;/code&gt;：用来请求后端 API 音乐数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NeteaseCloudMusicApi&lt;/code&gt;：网易云音乐 NodeJS 版 API，提供音乐数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;其他工具&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;vue-cli&lt;/code&gt;：Vue 脚手架工具，快速初始化项目代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eslint&lt;/code&gt;：代码风格检查工具，帮助我们规范代码书写（一定要养成良好的代码规范）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iconfont&lt;/code&gt; ：阿里巴巴图标库，谁用谁知道&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fastclick&lt;/code&gt; ：消除 click 移动游览器 300ms 的延&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实现功能&quot;&gt;实现功能&lt;/h2&gt;
&lt;p&gt;播放器内核、推荐页面、热榜页面、歌手页面、歌单详情、歌手详情、排行榜详情、搜索页面、播放列表、用户中心等等功能。&lt;/p&gt;
&lt;h3 id=&quot;推荐页面&quot;&gt;推荐页面&lt;/h3&gt;
&lt;p&gt;推荐页分成三个部分，分别是 banner 轮播图、推荐歌单、推荐歌曲，数据都是使用 &lt;code&gt;axios&lt;/code&gt; 请求 API 获取得到的，图片都使用 &lt;code&gt;vue-lazyload&lt;/code&gt; 实现懒加载。&lt;/p&gt;
&lt;p&gt;轮播图：使用 &lt;code&gt;better-scroll&lt;/code&gt; 实现，具体可以看这里 &lt;a href=&quot;https://ustbhuangyi.github.io/better-scroll/doc/zh-hans/options-advanced.html#%60%60%60snap%60%60%60&quot;&gt;Slide&lt;/a&gt; 。&lt;em&gt;点击跳转方面只实现歌曲和歌单的跳转，因为暂时只实现了这两个功能。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;推荐歌单，推荐歌曲：使用 &lt;code&gt;vuex&lt;/code&gt; 管理数据，方便组件之间的数据交互（播放器播放歌曲）。因为数据上还有播放数量，所以就顺便也加上去了。&lt;/p&gt;
&lt;h3 id=&quot;排行榜页面&quot;&gt;排行榜页面&lt;/h3&gt;
&lt;p&gt;同样是通过 API 获取到排行榜的数据，但是因为 API 获取到的是排行榜中所有歌曲的数据，所以难免在加载速度上有点慢，后期再看能不能优化一下，加载的慢毕竟太影响用户体验了，别的就没什么了。&lt;/p&gt;
&lt;h3 id=&quot;歌手页面&quot;&gt;歌手页面&lt;/h3&gt;
&lt;p&gt;实现歌手列表的左右联动（这个需要理解理解），因为之前已经写过和这个有关的博客，所以就不多写了，具体可以看我之前的这个笔记 ➡️ &lt;a href=&quot;http://caijin.tech/blog/2018/04/23/2018-4-23-list-view/&quot;&gt;移动端字母索引导航&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;歌曲列表组件&quot;&gt;歌曲列表组件&lt;/h3&gt;
&lt;p&gt;用来显示歌曲列表，在很多的地方都进行了复用，例如：歌单详情页、排行榜详情页、歌手详情页、搜索结果、用户中心等等。&lt;/p&gt;
&lt;h3 id=&quot;歌单详情页&quot;&gt;歌单详情页&lt;/h3&gt;
&lt;p&gt;通过歌单的 ID 来获取歌单中的歌曲数据，然后还做了一些体验上面的交互，比如上滑显示状态栏然后将状态栏标题变为歌单名，具体可以尝试一下就知道了。&lt;/p&gt;
&lt;p&gt;然后就是复用 歌曲列表组建 来显示歌曲。&lt;/p&gt;
&lt;h3 id=&quot;排行榜详情歌手详情&quot;&gt;排行榜详情、歌手详情&lt;/h3&gt;
&lt;p&gt;和歌单详情基本上没有什么区别，除了 UI 界面方面有细微的改动（根据不同的内容作出不同的优化）。&lt;/p&gt;
&lt;h3 id=&quot;播放器&quot;&gt;播放器&lt;/h3&gt;
&lt;p&gt;最最最重要的组件，毕竟是个音乐播放器，不能放歌那啥都是扯淡了。&lt;/p&gt;
&lt;p&gt;实现功能：顺序播放、单曲循环、随机播放、收藏等。&lt;/p&gt;
&lt;p&gt;播放、暂停使用 HTML5 的 audio 实现。&lt;/p&gt;
&lt;p&gt;数据、播放状态、播放历史、习惯歌曲等方面使用了 &lt;code&gt;vuex&lt;/code&gt; 来进行管理，因为数据太多，组件直接传递的话是会死人的，所以还是老老实实的用 &lt;code&gt;vuex&lt;/code&gt; 吧，数据之前的传递真的很方便。&lt;/p&gt;
&lt;p&gt;图标使用 &lt;code&gt;iconfont&lt;/code&gt; 阿里巴巴图标库，中间的唱片旋转动画使用了 &lt;code&gt;animation&lt;/code&gt; 实现。&lt;/p&gt;
&lt;p&gt;歌词部分获取到网易的歌词数据，然后使用 第三方库 &lt;a href=&quot;https://github.com/ustbhuangyi/lyric-parser&quot;&gt;&lt;code&gt;lyric-parser&lt;/code&gt;&lt;/a&gt; 进行处理。实现显示歌词、拖动进度条歌词同步滚动、歌词跟随歌曲进度高亮。&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;localstorage&lt;/code&gt; 存储喜欢歌曲、播放历史数据。&lt;/p&gt;
&lt;h4 id=&quot;audio-标签在移动端不能够自动播放的问题&quot;&gt;audio 标签在移动端不能够自动播放的问题&lt;/h4&gt;
&lt;p&gt;电脑端是没有这个问题的，这个问题真的是让我很头大，最后是用了很鬼畜的方法解决了（使用 &lt;code&gt;addEventListener&lt;/code&gt; 监听 touchend 事件，然后在回调函数中让 audio 播放一次，具体看 App.vue 文件，注释有写）。&lt;/p&gt;
&lt;h3 id=&quot;播放列表&quot;&gt;播放列表&lt;/h3&gt;
&lt;p&gt;显示和管理当前播放歌曲，可以用来删除列表中的歌曲、以及选择播放歌曲。&lt;/p&gt;
&lt;h3 id=&quot;搜索功能&quot;&gt;搜索功能&lt;/h3&gt;
&lt;p&gt;实现功能：搜索歌手、歌单、歌曲、热门搜索、数据节流、上拉刷新、保存搜索记录。&lt;/p&gt;
&lt;p&gt;通过关键字请求 API 获取搜索数据，显示歌手、歌单、歌曲。&lt;/p&gt;
&lt;p&gt;实现了上刷新，因为搜索可以设置请求数据的条数，所以可以用来实现上刷新的功能。&lt;/p&gt;
&lt;p&gt;通过节流函数实现数据节流，通过 &lt;code&gt;localstorage&lt;/code&gt; 存储搜索数据。&lt;/p&gt;
&lt;h3 id=&quot;用户中心&quot;&gt;用户中心&lt;/h3&gt;
&lt;p&gt;将在本地存储的数据显示出来，方便用户使用，后期准备添加更多功能。&lt;/p&gt;
&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;优化排行榜加载速度&lt;/li&gt;
&lt;li&gt;优化重复代码&lt;/li&gt;
&lt;li&gt;增加歌曲评论&lt;/li&gt;
&lt;li&gt;增加 MV、电台 功能&lt;/li&gt;
&lt;li&gt;emm，更多功能容我再想想哈&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;感谢&quot;&gt;感谢&lt;/h2&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;最后的最后当然是厚着脸皮的再求个 star 啦，如果觉得我的项目还不错的话 👏，就给个 star ⭐ 鼓励一下吧~&lt;/p&gt;
</description>
<pubDate>Tue, 15 May 2018 13:02:00 +0000</pubDate>
<dc:creator>AprilieJin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cccj/p/9043012.html</dc:identifier>
</item>
<item>
<title>vsts + XX云服务器构建netcore+docker持续集成交付部署 - 鱼东东</title>
<link>http://www.cnblogs.com/yudongdong/p/9042750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudongdong/p/9042750.html</guid>
<description>&lt;p&gt;&lt;span&gt;持续集成交付部署是什么意思,它给我们带来什么好处？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先贴一张图&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194858641-1101400086.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;877EF9AC56904A97A0C89F03D9C82A23&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;持续集成（Continuous Integration）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;持续集成强调开发人员提交了新代码之后，立刻进行构建、（单元）测试(这个要看情况了是否需要)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;持续交付（Continuous Delivery）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;持续交付在持续集成的基础上，将集成后的代码部署到更贴近真实运行环境的「类生产环境」（&lt;span&gt;production-like environments&lt;/span&gt;）中。比如，我们完成单元测试后，可以把代码部署到连接数据库的 Staging 环境中更多的测试。如果代码没有问题，可以继续&lt;span&gt;手动部署&lt;/span&gt;到生产环境中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;持续部署（Continuous Deployment）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;持续部署则是在持续交付的基础上，把部署到生产环境的过程自动化。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span&gt;减少重复劳动 提高效率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;jenkins大家都知道吧，但今天我们用微软的vsts来定制个性化定制持续集成交付(个人或者小团队我建议用vsts 也不用自己安装jenkins环境了 直接用vsts在线系统很方便)&lt;/p&gt;
&lt;p&gt;用到的资源有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;腾讯云服务器ubuntu一台(自己先安装好docker哈)&lt;/li&gt;
&lt;li&gt;vsts创建一个git(有微软账号就能免费创建,&amp;lt;=5人团队是免费使用的,对于敏捷团队绰绰有余啦) &lt;span&gt;&lt;a href=&quot;https://www.visualstudio.com/zh-hans/team-services/&quot;&gt;https://www.visualstudio.com/zh-hans/team-services/&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一步步看图&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步 在vsts创建一个工程&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194912620-1944809890.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;E9D23AA1F6804568BF3F06845058C6DB&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194915875-136119065.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;2C3BAFD686C94CA6BAC0F31FD1EC14F7&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194919042-1850032768.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;E4431ADBEE0E40BBA13104DEC01EA2A3&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194922288-1641157919.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;E9395C4BEE2D426E823DFB13A86C8182&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;创建git用户&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194925454-1154416545.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;800B6D32D6B04BB09CC9D1E43D5FBFA0&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;然后用git工具clone到本地 我习惯用Sourcetree 大家可以用自己习惯的方式&lt;/p&gt;
&lt;p&gt;如果提示输入密码就输入上面创建的用户名和密码&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194928608-1823747255.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;0112AB0D15E046A0B2C89A3012371AF8&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第二步创建一个实验工程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里我们创建一个非常简单的console webapplication&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194931870-496177007.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;C125DCB63F80412A85A4166F9D20AD74&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;安装nuget包&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194934997-88106078.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;3A117CA70A3C4605B7741D2BA80090C4&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194938116-207289788.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;FCB53D5C57BE4D16A7D6349BC2AA6596&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;file:///https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194941228-1077032597.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;4C47D3CDA7E547998DCE81B6084BBE22&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;这里注意一点：我这里写死了 用 5001端口 注意我用的是 *:5001 没有用 localhost:5001 如果用这个方式的话 部署docker上会访问不了&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194944333-32472973.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;29CC2F2FD3A94D13A4F8EE910DFC53FF&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;确认可以跑起来&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194947536-1506104396.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;892F8CC842D54D419D18D5D50E263322&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;然后git提交代码到master分支&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第三步我们来配置vsts&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194950770-1994390178.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;D2A571A473784ADE9798739B479936D5&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;先配置第一部分 一有代码提交到master分支 就自动编译 打包 【CI部分】&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194953999-172535538.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;FFCDF46A1C334F07916A3DAF41D3A717&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515194957131-1813171661.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;95DD7D24364941E8A447BCE0A5187FEF&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;选择 ASP.NET Core 会默认有以下Task&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195000304-569583079.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;D1876BBF2E634DABA8B63F7658B1B352&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;一定要注意选择linux环境编译&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195003549-865473891.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;FAE4F2101C934711AA8A4AC94AB9BD2A&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;Test我们暂时不需要就Remove掉&lt;/p&gt;
&lt;p&gt;由于我们不是web project&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195006804-804372562.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;4F912FBAA261418B919EEC13B75C240C&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;配置触发器 (意思就是一有代码提交打master分支[可以指定特定分支]就会触发CI)&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195010003-1000424454.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;158834191A594489859E00D94A450B6C&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;尝试跑一下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195013181-1211666813.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;351BA1A88C2449FAA4A0B557E6504306&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195016313-583271687.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;88D8C190D0C04BB6856DA365C8D09DB7&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;CI正常完成&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195019635-989132875.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;8178D2528C9C46F6A03811E0EDF19DEC&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;


&lt;p&gt;到此CI配置工作已完成&lt;/p&gt;
&lt;p&gt;接下来我想要完成自动 发布到我的腾讯云服务器 在服务器上把发布的文件打包并生成一个image 然后用这个image生成一个Container 并启动&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第四部我们配置Release&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195022763-896446546.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;D761955D93A047EAB5E9B9B79A593776&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195025928-1423578095.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;389919B55A13494BBF76428F522EB7B3&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195029220-286763369.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;98F20C6F2DEE43D4B7606F6FA176D300&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Sourece alias 这个大家可以修改成名字短一点&lt;/p&gt;
&lt;p&gt;执行Release发布的时候会把之前CI public的东西download然后放在命名为 Source alisa文件夹内&lt;/p&gt;
&lt;p&gt;我改成 _test_netcore-docker&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195032514-147289123.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;E9A78862233A482FAF64C65A710530C3&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;接下来来配置环境&lt;/p&gt;
&lt;p&gt;大家可以根据实际情况配置多个环境 比如 集成测试环境 和 prod环境&lt;/p&gt;
&lt;p&gt;我这里就只配置一个prod环境&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195035832-649762660.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;441D3741FFA8456CBBAD5FE10F4C2BE8&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;由于我们是发布到腾讯云服务器 所以在这里选择 Empt process 且命名为prod&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195039061-1257376143.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;CB599DB1FF84435EBA453AD658F47F00&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;接下来要配置 Release 操作的 Task&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195042260-783195512.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;AB4D2B38B8144B56952E17676C947B41&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;我们添加SSH 目的是用SSH 链接到 腾讯云服务器 然后 把发布的文件通过SSH传输到我的服务器&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195045570-596218276.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;698129EFB8BA47B7A42D27C391C11981&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;


&lt;p&gt;得先配置SSH无密码登录&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195048865-1100096097.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;0FD2D07A99E54A95ADE0AB639BB03742&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195052025-1332231142.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;8FFF64800E334E2FA24B896FAF820460&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;按照提示进行配置&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195055230-574541968.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;22D077986AD7453480C753A2F8A79CBE&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;配置好后&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195602986-863495318.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;Source folder 输入我们之前配置的别名 _test_netcore-docker&lt;/p&gt;
&lt;p&gt;最终如下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195111960-1772739373.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;3E447701C54247B181D792117CC17E63&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;然后再添加SSH执行命令工具&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195115271-1345044971.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;FFB0525FC7734667B8F7E0C386D59A20&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;


&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195118616-1030469406.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;B9B19559D22449A6BCF2BE233C80B327&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;unzip -q site/drop/&lt;span&gt;TestDotnetcore&lt;/span&gt;.zip -d site/drop/ 发布的文件是zip的 通过这个命令解压zip &amp;lt;&lt;span&gt;TestDotnetcore.zip是我查看发布的日志找到的这个名字目前我还没有找到变量可以代替&lt;/span&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;sudo rm -rf site/drop/*.zip 解压完成后删除掉&lt;/p&gt;
&lt;p&gt;touch site/drop/Dockerfile 生成一个dockerfile&lt;/p&gt;
&lt;p&gt;echo &quot;FROM microsoft/aspnetcore:2.0&quot; &amp;gt;&amp;gt; site/drop/Dockerfile echo命令是往创建的dockerfile里面写入内容&lt;/p&gt;
&lt;p&gt;echo &quot;COPY . /publish&quot; &amp;gt;&amp;gt; site/drop/Dockerfile&lt;/p&gt;
&lt;p&gt;echo &quot;WORKDIR /publish&quot; &amp;gt;&amp;gt; site/drop/Dockerfile&lt;/p&gt;
&lt;p&gt;echo &quot;EXPOSE 5001&quot; &amp;gt;&amp;gt; site/drop/Dockerfile&lt;/p&gt;
&lt;p&gt;echo &quot;CMD [\&quot;dotnet\&quot;, \&quot;TestDotnetcore.dll\&quot;]&quot; &amp;gt;&amp;gt; site/drop/Dockerfile&lt;/p&gt;
&lt;p&gt;sudo docker build --rm -t test_image -f site/drop/Dockerfile site/drop/ 创建一个image 名字叫 test_image&lt;/p&gt;
&lt;p&gt;sudo docker ps -q --filter &quot;name=test_netcore&quot; | grep -q . &amp;amp;&amp;amp; sudo docker rm -f test_netcore || true 查看是否有没有叫 test_netcore的容器有没有在runing 如果有就干掉它&lt;/p&gt;
&lt;p&gt;sudo docker run --name test_netcore -d -p 5001:5001 test_image:latest 根据test_image启动一个名字叫test_netcore的容器&lt;/p&gt;
&lt;p&gt;if sudo docker images -f &quot;dangling=true&quot; | grep ago --quiet; then sudo docker rmi -f $(sudo docker images -f &quot;dangling=true&quot; -q); fi 查看是否有&amp;lt;none&amp;gt;的image 把它删掉 因为我们创建image的时候每次都会覆盖所以会产生一些没有的image&lt;/p&gt;
&lt;p&gt;sudo rm -rf site/drop 都ok了就删掉drop目录&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以上一切准备好 提交一个commit到master试试&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;会自动触发CI 进行 编译 发布&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195121957-1162804331.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;73DD1A53E8E444F7820CD1DB8826DA3E&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接下来Release发布&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195125148-364316163.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;4B41797C4C8847E58719E357612EDC1D&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;发布打包的成果物在这里查看&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195128283-1967423586.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;8BAAD655F95B4E39956D42CA80957CBF&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195131528-1068323004.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;E5355EC2CEBE4ACBB73E0F14FDF56F7C&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195135015-1378217323.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;33F00B74990E4B7880735740B83F6EC0&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;发布成功 查看下docker image&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195138202-466030448.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;90E4C2F393994795BB5F5CD35C3F0099&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt;已经成功创建了test_image这个镜像&lt;/p&gt;

&lt;p&gt;容器是也跑成功了&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195141303-1479838888.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;899A8644B2854431BB3BCC26EEB112D8&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;

&lt;p&gt;验证一下&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201805/472365-20180515195245031-890718534.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;

&lt;p&gt;完美！！！不管你用的是腾讯云还是阿里云还是其他云都是可以的!&lt;/p&gt;

&lt;p&gt;遗留问题：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TestDotnetcore.zip是我查看发布的日志找到的这个名字目前我还没有找到变量可以代替&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有谁知道帮忙教育下！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 15 May 2018 11:54:00 +0000</pubDate>
<dc:creator>鱼东东</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudongdong/p/9042750.html</dc:identifier>
</item>
<item>
<title>用ECMAScript4 ( ActionScript3)  实现Unity的热更新 -- 使用FairyGUI (二) - 烙馅饼喽</title>
<link>http://www.cnblogs.com/ashei/p/9042742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashei/p/9042742.html</guid>
<description>&lt;p&gt;上次讲解了FairyGUI的最简单的热更新办法，并对其中一个Demo进行了修改并做成了热更新的方式。&lt;/p&gt;
&lt;p&gt;这次我们来一个更加复杂一些的情况：Emoji.&lt;/p&gt;
&lt;p&gt;FairyGUI的   &lt;strong&gt;Example 04 - Emoji&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;场景是一个聊天对话框。玩家可以输入文本和表情，对面的机器人还会回复一句话。回复的对话中还附带一个表情。&lt;/p&gt;
&lt;h2&gt;Demo分析&lt;/h2&gt;
&lt;p&gt;FairyGUI的这个Demo展示了如下技巧：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继承UBBParser ,在Demo中使用自定义的表情。&lt;/li&gt;
&lt;li&gt;编写了一个MonoBehaviour,管理所有的逻辑。
&lt;ol&gt;&lt;li&gt;动态添加UI项目的各按钮的点击事件&lt;/li&gt;
&lt;li&gt;保存对话内容&lt;/li&gt;
&lt;li&gt;根据对话的类型（发送方和接收方），可以给对话项提供不同的展示资源&lt;/li&gt;
&lt;li&gt;脚本中解析表情，并展示出来。&lt;/li&gt;
&lt;li&gt;当对话条数超过一定数目时，会自动从头部移除最早的对话。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;修改为热更新&lt;/h2&gt;
&lt;p&gt;本次热更新的尝试目标，所有逻辑全部移动到热更新代码中执行。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先我们将这个场景另存为F_Emoji。&lt;/li&gt;
&lt;li&gt;导入ActionScript3 虚拟机的unity插件包，并生成热更新项目。如果您不知道怎么操作，&lt;a href=&quot;http://www.cnblogs.com/ashei/p/8874618.html&quot; target=&quot;_blank&quot;&gt;可以查看这里&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ActionScript3插件包已更新，请下载最新的插件包  v0.96f6 &lt;a href=&quot;https://github.com/asheigithub/apple-juice-actionscript/releases&quot; target=&quot;_blank&quot;&gt;以及以后版本&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 现在准备工作已完成。&lt;/p&gt;
&lt;p&gt;我们将场景中的UIPanel&lt;strong&gt;直接删除&lt;/strong&gt;。我们全部使用脚本来创建这个Panel。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进入Assets-&amp;gt;ASRuntimePlayer,将 AS3Player预设和AS3StartupProgress预设拖到场景上。&lt;/li&gt;
&lt;li&gt;将AS3Player物件下的Action Script Start Up 脚本组件的Document Class 设置为EmojiTest。&lt;br/&gt;(这一步的作用表示指示脚本解释器启动时，具体创建一个哪种类型的实例)&lt;/li&gt;
&lt;li&gt;现在打开热更新项目，新建一个 EmojiTest 的类。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在我们首先来说明，如何使用热更新脚本来创建UIPanel。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据FairyGUI的说明，要从脚本创建UIPanel,则一定要先注册UI所在的包，否则会提示创建失败&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原C# Demo中，注册代码是在Awake事件中，并且设计时就拖动到场景上的，而我们这里需要热更新，我们可以选择在EmojiTest的构造函数中，或者直接在包外代码中写入注册代码，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;务必先加入package&lt;/span&gt;
UIPackage.addPackage______(&lt;span&gt;&quot;UI/Emoji&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; go:GameObject = &lt;span&gt;new&lt;/span&gt; GameObject(&lt;span&gt;&quot;uip&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; uip:UIPanel =&lt;span&gt; go.addComponent(UIPanel) as UIPanel;

uip.gameObject.layer &lt;/span&gt;= LayerMask.nameToLayer(&lt;span&gt;&quot;UI&quot;&lt;/span&gt;&lt;span&gt;);
uip.packageName &lt;/span&gt;= &lt;span&gt;&quot;Emoji&quot;&lt;/span&gt;&lt;span&gt;;
uip.componentName &lt;/span&gt;= &lt;span&gt;&quot;Main&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将上面的代码写到包外代码中。点击编译,然后在Unity中点击播放：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/46491/201805/46491-20180515190802958-421701317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，这里的uip物体就是通过热更新脚本创建的，然后FairyGUI根据我们配置的package和componet，创建了对话的UI。&lt;/p&gt;
&lt;h3&gt;编写热更新逻辑&lt;/h3&gt;
&lt;p&gt;现在我们来编写热更新逻辑。但是这次有些不同，我们需要对UBBParser这个类进行一些修改。&lt;/p&gt;
&lt;p&gt;FairyGUI的Demo中，为了解析UBB表情，定义了EmojiParser ,继承自UBBParser。并且EmojiParser中，访问了基类的受保护的对象handlers。&lt;/p&gt;
&lt;p&gt;然而，我们的ActionScript3脚本如果继承C#类库，是无非直接访问受保护的字段的。&lt;span&gt;&lt;strong&gt;因此，我们需要先在Unity工程中，将UBBParser的handlers改为public的成员.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;修改完成后,待Unity重新编译项目后，在热更新项目中，使用 bat/CreateUnityAPI.bat 这个批处理文件重新生成一下ActionScript3的API代码。&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;确保以上步骤完成后，我们着手将C#代码改写为ActionScript3代码.&lt;/p&gt;
&lt;p&gt;我们同样可以将逻辑继承自MonoBehaviour,并且也创建一个继承UBBParser的类，由于handlers字段已改为公开成员，因此可以在脚本中访问。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package 
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * ...
     * @author 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EmojiTest 
    {
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; EmojiTest() 
        {
            
        }
        
    }

}
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.Emoji;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.EventContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.FitScreen;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.GButton;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.GComponent;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.GList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.GObject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.GRichTextField;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.GRoot;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.GTextInput;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.ScrollBarDisplayType;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.UIConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.UIPackage;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.UIPanel;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; fairygui.utils.UBBParser;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; system.Char;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; system._Object_;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; system.collections.generic.Dictionary_Of_UInt32_Emoji;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unityengine.Application;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unityengine.GameObject;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unityengine.KeyCode;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unityengine.LayerMask;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unityengine.MonoBehaviour;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unityengine.Random;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在脚本中继承UBBParser。逻辑照搬C# Demo&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;给每个表情提供一个handler,这个handler处理此表情的资源。&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; EmojiParser &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; UBBParser
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt;  _instance:EmojiParser;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt; inst():EmojiParser
    {        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            _instance &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmojiParser();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _instance;
        
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; TAGS:Vector.&amp;lt;String&amp;gt; =Vector.&amp;lt;String&amp;gt;&lt;span&gt;([
         &lt;/span&gt;&lt;span&gt;&quot;88&quot;&lt;/span&gt;,&lt;span&gt;&quot;am&quot;&lt;/span&gt;,&lt;span&gt;&quot;bs&quot;&lt;/span&gt;,&lt;span&gt;&quot;bz&quot;&lt;/span&gt;,&lt;span&gt;&quot;ch&quot;&lt;/span&gt;,&lt;span&gt;&quot;cool&quot;&lt;/span&gt;,&lt;span&gt;&quot;dhq&quot;&lt;/span&gt;,&lt;span&gt;&quot;dn&quot;&lt;/span&gt;,&lt;span&gt;&quot;fd&quot;&lt;/span&gt;,&lt;span&gt;&quot;gz&quot;&lt;/span&gt;,&lt;span&gt;&quot;han&quot;&lt;/span&gt;,&lt;span&gt;&quot;hx&quot;&lt;/span&gt;,&lt;span&gt;&quot;hxiao&quot;&lt;/span&gt;,&lt;span&gt;&quot;hxiu&quot;&lt;/span&gt;&lt;span&gt; ]);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; EmojiParser ()
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; each (&lt;span&gt;var&lt;/span&gt; ss &lt;span&gt;in&lt;/span&gt;&lt;span&gt; TAGS)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handlers[&lt;span&gt;&quot;:&quot;&lt;/span&gt;+ss] =&lt;span&gt; OnTag_Emoji;
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; OnTag_Emoji( tagName:String,  end:&lt;span&gt;Boolean&lt;/span&gt;&lt;span&gt;,  attr:String):String
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&amp;lt;img src='&quot;&lt;/span&gt; + UIPackage.getItemURL(&lt;span&gt;&quot;Emoji&quot;&lt;/span&gt;, tagName.substr(1).toLowerCase()) + &lt;span&gt;&quot;'/&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 对话消息,不必多说
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Message
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; sender:String;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; senderIcon:String;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; msg:String;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; fromMe:&lt;span&gt;Boolean&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 将Demo中的逻辑用热更新脚本改写。
 * 我们同样可以继承自MonoBehaviour
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; EmojiMain &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MonoBehaviour
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; _mainView:GComponent;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; _list:GList;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; _input1:GTextInput;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; _input2:GTextInput;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; _emojiSelectUI1:GComponent;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; _emojiSelectUI2:GComponent;

    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _messages:Vector.&amp;lt;Message&amp;gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; _emojies:Dictionary_Of_UInt32_Emoji;

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Awake()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;UIPackage.AddPackage(&quot;UI/Emoji&quot;);&lt;/span&gt;
&lt;span&gt;
        UIConfig.verticalScrollBar &lt;/span&gt;= &lt;span&gt;&quot;ui://Emoji/ScrollBar_VT&quot;&lt;/span&gt;&lt;span&gt;;
        UIConfig.defaultScrollBarDisplay &lt;/span&gt;=&lt;span&gt; ScrollBarDisplayType.Auto;
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Start()
    {
        Application.targetFrameRate &lt;/span&gt;= 60&lt;span&gt;;
        
        _messages &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Vector.&amp;lt;Message&amp;gt;&lt;span&gt;();

        _mainView &lt;/span&gt;= UIPanel( &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getComponent(UIPanel)).ui;

        _list &lt;/span&gt;= _mainView.getChild(&lt;span&gt;&quot;list&quot;&lt;/span&gt;&lt;span&gt;).asList;
        _list.setVirtual();
        _list.itemProvider &lt;/span&gt;=&lt;span&gt; GetListItemResource;
        _list.itemRenderer &lt;/span&gt;=&lt;span&gt; RenderListItem;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给按钮添加处理事件。&lt;/span&gt;
        _input1 = _mainView.getChild(&lt;span&gt;&quot;input1&quot;&lt;/span&gt;&lt;span&gt;).asTextInput;
        _input1.onKeyDown.add(__inputKeyDown1);

        _input2 &lt;/span&gt;= _mainView.getChild(&lt;span&gt;&quot;input2&quot;&lt;/span&gt;&lt;span&gt;).asTextInput;
        _input2.onKeyDown.add(__inputKeyDown2);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;作为demo，这里只添加了部分表情素材&lt;/span&gt;
        _emojies = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dictionary_Of_UInt32_Emoji();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i:uint = 0x1f600; i &amp;lt; 0x1f637; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url:String = UIPackage.getItemURL(&lt;span&gt;&quot;Emoji&quot;&lt;/span&gt;, i.toString(16&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (url != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                _emojies.add(i,  Emoji.constructor_(url));
        }
        _input2.emojies &lt;/span&gt;=&lt;span&gt; _emojies;

        _mainView.getChild(&lt;/span&gt;&lt;span&gt;&quot;btnSend1&quot;&lt;/span&gt;&lt;span&gt;).onClick.add(__clickSendBtn1);
        _mainView.getChild(&lt;/span&gt;&lt;span&gt;&quot;btnSend2&quot;&lt;/span&gt;&lt;span&gt;).onClick.add(__clickSendBtn2);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加发送表情按钮的事件&lt;/span&gt;
        _mainView.getChild(&lt;span&gt;&quot;btnEmoji1&quot;&lt;/span&gt;&lt;span&gt;).onClick.add(__clickEmojiBtn1);
        _mainView.getChild(&lt;/span&gt;&lt;span&gt;&quot;btnEmoji2&quot;&lt;/span&gt;&lt;span&gt;).onClick.add(__clickEmojiBtn2);

        _emojiSelectUI1 &lt;/span&gt;= UIPackage.createObject(&lt;span&gt;&quot;Emoji&quot;&lt;/span&gt;, &lt;span&gt;&quot;EmojiSelectUI&quot;&lt;/span&gt;&lt;span&gt;).asCom;
        _emojiSelectUI1.fairyBatching &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        _emojiSelectUI1.getChild(&lt;/span&gt;&lt;span&gt;&quot;list&quot;&lt;/span&gt;&lt;span&gt;).asList.onClickItem.add(__clickEmoji1);

        _emojiSelectUI2 &lt;/span&gt;= UIPackage.createObject(&lt;span&gt;&quot;Emoji&quot;&lt;/span&gt;, &lt;span&gt;&quot;EmojiSelectUI_ios&quot;&lt;/span&gt;&lt;span&gt;).asCom;
        _emojiSelectUI2.fairyBatching &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        _emojiSelectUI2.getChild(&lt;/span&gt;&lt;span&gt;&quot;list&quot;&lt;/span&gt;&lt;span&gt;).asList.onClickItem.add(__clickEmoji2);
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; AddMsg(sender:String,  senderIcon:String,  msg:String,  fromMe:&lt;span&gt;Boolean&lt;/span&gt;):&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isScrollBottom:&lt;span&gt;Boolean&lt;/span&gt; =&lt;span&gt; _list.scrollPane.isBottomMost;

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newMessage:Message = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
        newMessage.sender &lt;/span&gt;=&lt;span&gt; sender;
        newMessage.senderIcon &lt;/span&gt;=&lt;span&gt; senderIcon;
        newMessage.msg &lt;/span&gt;=&lt;span&gt; msg;
        newMessage.fromMe &lt;/span&gt;=&lt;span&gt; fromMe;
        _messages.push(newMessage);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (newMessage.fromMe)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_messages.length == 1 || Random.range(0, 1) &amp;lt; 0.5&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; replyMessage:Message = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message();
                replyMessage.sender &lt;/span&gt;= &lt;span&gt;&quot;FairyGUI&quot;&lt;/span&gt;&lt;span&gt;;
                replyMessage.senderIcon &lt;/span&gt;= &lt;span&gt;&quot;r1&quot;&lt;/span&gt;&lt;span&gt;;
                replyMessage.msg &lt;/span&gt;= &lt;span&gt;&quot;Today is a good day. &quot;&lt;/span&gt; + Char.convertFromUtf32( 0x0001f600&lt;span&gt; ).toString();
                replyMessage.fromMe &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                _messages.push(replyMessage);
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_messages.length &amp;gt; 100&lt;span&gt;)
        {
            _messages.splice(&lt;/span&gt;0, _messages.length - 100&lt;span&gt;);
        }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_messages.RemoveRange(0, _messages.Count - 100);&lt;/span&gt;
&lt;span&gt;
        _list.numItems &lt;/span&gt;=&lt;span&gt; _messages.length;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isScrollBottom)
            _list.scrollPane.scrollBottom();
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetListItemResource( index:int):String
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; msg: Message=&lt;span&gt; _messages[index];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (msg.fromMe)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;ui://Emoji/chatRight&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;ui://Emoji/chatLeft&quot;&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; RenderListItem( index:int,  obj:GObject):&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item:GButton =&lt;span&gt; GButton(obj);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; msg:Message=&lt;span&gt; _messages[index];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;msg.fromMe)
            item.getChild(&lt;/span&gt;&lt;span&gt;&quot;name&quot;&lt;/span&gt;).text =&lt;span&gt; msg.sender;
        item.icon &lt;/span&gt;= UIPackage.getItemURL(&lt;span&gt;&quot;Emoji&quot;&lt;/span&gt;&lt;span&gt;, msg.senderIcon);


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Recaculate the text width&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; tf:GRichTextField = item.getChild(&lt;span&gt;&quot;msg&quot;&lt;/span&gt;&lt;span&gt;).asRichTextField;
        tf.emojies &lt;/span&gt;=&lt;span&gt; _emojies;
        tf.width &lt;/span&gt;=&lt;span&gt; tf.initWidth;
        tf.text &lt;/span&gt;=&lt;span&gt; EmojiParser.inst.parse(msg.msg);
        tf.width &lt;/span&gt;=&lt;span&gt; tf.textWidth;
        
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; __clickSendBtn1( context:EventContext):&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; msg:String =&lt;span&gt; _input1.text;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg.length == 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

        AddMsg(&lt;/span&gt;&lt;span&gt;&quot;Unity&quot;&lt;/span&gt;, &lt;span&gt;&quot;r0&quot;&lt;/span&gt;, msg, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        _input1.text &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; __clickSendBtn2( context:EventContext):&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; msg:String =&lt;span&gt; _input2.text;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg.length == 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

        AddMsg(&lt;/span&gt;&lt;span&gt;&quot;Unity&quot;&lt;/span&gt;, &lt;span&gt;&quot;r0&quot;&lt;/span&gt;, msg, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        _input2.text &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; __clickEmojiBtn1( context:EventContext):&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
    {
        GRoot.inst.showPopup__(_emojiSelectUI1, GObject(context.sender), _Object_( &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; __clickEmojiBtn2( context:EventContext):&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
    {
        GRoot.inst.showPopup__(_emojiSelectUI2, GObject(context.sender), _Object_( &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; __clickEmoji1( context:EventContext):&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item:GButton=&lt;span&gt; GButton(context.data);
        _input1.replaceSelection(&lt;/span&gt;&lt;span&gt;&quot;[:&quot;&lt;/span&gt; + item.text + &lt;span&gt;&quot;]&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; __clickEmoji2( context:EventContext):&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item:GButton =&lt;span&gt; GButton(context.data);
        _input2.replaceSelection(Char.convertFromUtf32( parseInt(UIPackage.getItemByURL(item.icon).name,&lt;/span&gt;16&lt;span&gt;) ));
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; __inputKeyDown1( context:EventContext):&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.inputEvent.keyCode ==&lt;span&gt; KeyCode.Return)
            _mainView.getChild(&lt;/span&gt;&lt;span&gt;&quot;btnSend1&quot;&lt;/span&gt;&lt;span&gt;).onClick.call();
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; __inputKeyDown2( context:EventContext):&lt;span&gt;void&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.inputEvent.keyCode ==&lt;span&gt; KeyCode.Return)
            _mainView.getChild(&lt;/span&gt;&lt;span&gt;&quot;btnSend2&quot;&lt;/span&gt;&lt;span&gt;).onClick.call();
    }

    
}



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;务必先加入package&lt;/span&gt;
UIPackage.addPackage______(&lt;span&gt;&quot;UI/Emoji&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; go:GameObject = &lt;span&gt;new&lt;/span&gt; GameObject(&lt;span&gt;&quot;uip&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; uip:UIPanel =&lt;span&gt; go.addComponent(UIPanel) as UIPanel;

uip.gameObject.layer &lt;/span&gt;= LayerMask.nameToLayer(&lt;span&gt;&quot;UI&quot;&lt;/span&gt;&lt;span&gt;);
uip.packageName &lt;/span&gt;= &lt;span&gt;&quot;Emoji&quot;&lt;/span&gt;&lt;span&gt;;
uip.componentName &lt;/span&gt;= &lt;span&gt;&quot;Main&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将逻辑代码挂载到UIPanel上。&lt;/span&gt;
go.addComponent(EmojiMain);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以将如上代码直接写到热更新脚本中，编译。&lt;/p&gt;
&lt;p&gt;然后在Unity中点击播放，我们看到我们的热更已经生效！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/46491/201805/46491-20180515192704720-551989697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如此，我们即可完全使用热更代码处理FairyGUI的对话聊天模块。&lt;/p&gt;
&lt;h2&gt;打包到安卓手机&lt;/h2&gt;
&lt;p&gt; 您可以将这个场景导出到手机上测试。&lt;/p&gt;
&lt;p&gt;当打包时，有可能会遇到脚本错误。这是因为FairyGUI的某些代码使用了宏编译，在windows状态下有这个类，而安卓状态下确没有。因此我们可以将这些类型配置到导出API的工具中，&lt;/p&gt;
&lt;p&gt;声明它不导出。以这个案例而言，则是将如下配置写入genapi.config.xml的&amp;lt;notcreatetypes&amp;gt;配置节中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;item &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;FairyGUI.CopyPastePatch&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后再次导出API,编译脚本，生成安卓包：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/46491/201805/46491-20180515194235619-1564142021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 如此我们就看到了手机上运行的效果。&lt;/p&gt;

</description>
<pubDate>Tue, 15 May 2018 11:53:00 +0000</pubDate>
<dc:creator>烙馅饼喽</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashei/p/9042742.html</dc:identifier>
</item>
</channel>
</rss>