<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>为什么要使用线程 - 熊猫猛男</title>
<link>http://www.cnblogs.com/XiongMaoMengNan/p/7699506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/XiongMaoMengNan/p/7699506.html</guid>
<description>&lt;h2 class=&quot;sub-title&quot;&gt;什么是线程&lt;/h2&gt;
&lt;p&gt;线程通常由线程ID、当前指令指针(PC）、寄存器集合和堆栈组成，是进程中的一个实体，是系统独立调度分派的基本单位；线程也有就绪、阻塞和运行三种基本状态。由于进程是系统资源分配的基本单位，创建、撤消、切换开销过大，进程间通信IPC(Inter-Process Communication)复杂，因此在对称多处理机（SMP）上同时运行多个线程并发执行才是更合适的选择。线程的实体包括程序、数据和线程控制块（Thread Control Block，TCB），TCB包括以下信息：&lt;/p&gt;
&lt;p&gt;（1）线程状态；&lt;/p&gt;
&lt;p&gt;（2）当线程不运行时，被保存的现场资源；&lt;/p&gt;
&lt;p&gt;（3）一组执行堆栈；&lt;/p&gt;
&lt;p&gt;（4）存放每个线程的局部变量主存；&lt;/p&gt;
&lt;p&gt;（5）访问同一个进程中的主存和其它资源。&lt;/p&gt;

&lt;h2 class=&quot;sub-title&quot;&gt;几种常见的线程模型&lt;/h2&gt;
&lt;p&gt;（1）&lt;strong&gt;内核级线程(Kernel-Level Thread)&lt;/strong&gt;：内核级线程将驻留在内核空间，由操作系统调度器管理、调度和分派；内核级线程在其生命期内都将被映射到一个内核线程，一旦终止，两个线程都将离开系统；不受用户态上下文的拖累，资源同步和数据共享比整个进程要低一些。如下图所示：&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1092022/201710/1092022-20171019153728443-554130814.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;（2）&lt;strong&gt;用户级线程(User-Level Thread)&lt;/strong&gt;：用户级线程的创建、调度、同步和销毁是通过库函数在用户空间完成的，对内核都是不可见的，因此无法被调度到处理器内核。在任意给定时刻进程都只能运行一个用户级线程，在整个程序执行过程中是进程而非其用户级线程与一个内核线程关联起来。用户级线程的创建和销毁以及线程切换代价比内核级线程小得多，允许每个进程定制自己的调度算法，线程管理比较灵活，还能在不支持线程的操作系统中实现。如下图所示：&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1092022/201710/1092022-20171019153912318-863969032.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;（3）&lt;strong&gt;轻量进程(Lightweight Process，LWP)&lt;/strong&gt;：每一个轻量进程都是与一个特定的内核线程关联的用户级线程，是内核级线程的高度抽象，即使在I/O中阻塞，也不会影响所属进程的其他线程的执行。轻量进程是介于用户级线程与内核级线程之间的线程模型，有自己的进程标识符、优先级、状态以及栈和局部存储区，并和其他进程有着父子关系，这和类Unix操作系统调用vfork()生成的进程类似。LWP由clone()系统调用创建，参数是CLONE_VM，与父进程是共享进程地址空间和系统资源的。在大多数系统中，LWP与普通进程的区别也在于它只有一个最小的执行上下文和调度所需的统计信息，这也是它被称为轻量级的原因。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;11.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;pre&gt;
a LWP runs in user space on top of a single kernel thread and &lt;br/&gt;shares its address space and system resources with other LWPs within the same process.
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1092022/201710/1092022-20171020101449334-416081426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Linux Thread 是通过用户空间的线程库(线程包)来提供支持的，所采用的是线程-进程1对1模型(即一个用户级线程对应一个轻量进程，而一个轻量进程对应一个特定的内核线程)，交由内核完成，而线程的创建、同步、销毁由核外线程库来实现。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;（4）&lt;strong&gt;混合模型&lt;/strong&gt;：在支持多线程的操作系统中，不同系统的实现方式并不相同，有的实现了用户级线程模型，有的实现了内核级线程模型，还有的二者兼具如下图：&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1092022/201710/1092022-20171020112918506-900137766.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div class=&quot;para&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;现代操作系统大都遵循POSIX(Portable Operating System Interface of UNIX)的相关接口标准定义，POSIX 引入了一个线程调度竞争范围(Thread-Scheduling Contention Scope)来控制线程的调度，PTHREAD_SCOPE_PROCESS属性值表示线程与它所在的进程中的其他线程竞争处理器资源，而PTHREAD_SCOPE_SYSTEM属性值表示线程在全系统范围内竞争处理器资源。&lt;/p&gt;

&lt;p&gt;下图从另一侧面展示了用户级线程与内核级线程之间的一些区别：&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1092022/201710/1092022-20171020115139771-1451953499.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2 class=&quot;sub-title&quot;&gt;最后的总结语&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在支持多线程的系统中，进程是系统资源分配的基本单位，线程是系统独立调度的基本单位；&lt;/li&gt;
&lt;li&gt;无论系统支持什么样的线程模型，操作系统调度器指派到处理器内核进行处理的对象是内核线程；&lt;/li&gt;
&lt;li&gt;用户级线程在用户空间调度灵活高效，内核级线程在内核空间调度成本更高；&lt;/li&gt;
&lt;li&gt;用户级线程在本进程内竞争CPU处理资源，内核级线程在全系统内竞争CPU处理资源，因此后者才能更好地利对称多处理机(SMP)进行并行处理；&lt;/li&gt;
&lt;li&gt;由于多线程共享进程资源，多进程应用程序在出现进程池内的进程崩溃或被攻击的情况下表现更加健壮，因此Chrome浏览器为每一个标签页运行一个进程。&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Fri, 20 Oct 2017 07:20:00 +0000</pubDate>
<dc:creator>熊猫猛男</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/XiongMaoMengNan/p/7699506.html</dc:identifier>
</item>
<item>
<title>使用机器学习算法打造一个简单的“微博指数” - 腾讯云技术社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/7699646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/7699646.html</guid>
<description>&lt;p&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/community&quot; target=&quot;_blank&quot;&gt;腾讯云技术社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作者：&lt;span class=&quot;info-item&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/community/user/1051678&quot; target=&quot;_blank&quot;&gt;林浩威 &lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;-&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;随着人工智能的大热，越来越多的小伙伴们开始投身到机器学习的大潮中。作为其中的一员，我对此也是极有兴趣的。当然我更感兴趣的，是怎么利用这些有趣的算法，来实现脑海里各种奇奇怪怪的点子。写这篇文章的契机，是我在某天看完腾讯指数的推送后，突发奇想，想自己实现类似这样的一个东西，感觉蛮好玩的。然后就在上周末，利用了一些空余时间，写了一个简单的舆情监控系统。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;基于机器学习的舆情监控，这样的一个想法，其实可以有很大的想象空间，可以做很多有意思的事情。比如可以关注你喜欢的明星或电影的口碑情况，或者了解你所关注股票的舆论变化，甚至预测其未来的走向等等。但我决定先从最简单的例子入手：就是从新浪微博中，识别出关于腾讯的正面或负面的新闻。本文的论述也将围绕这个场景展开，不会涉及太多复杂难懂的东西，可以说是很简单的一个东西，请放心阅读。&lt;/p&gt;
&lt;p&gt;技术上的实现，主要是用sklearn对采集到的微博文本做分类训练，关于sklearn就不需要介绍了，很有名的一个python机器学习工具，如果想详细地了解可以移步它的官网：&lt;a href=&quot;http://scikit-learn.org/&quot; target=&quot;_blank&quot;&gt;http://scikit-learn.org&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;下面是我们接下来需要做的所有工作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1507857257528_2384_1507857227542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;环境&lt;/h2&gt;
&lt;p&gt;机器：mac&lt;/p&gt;
&lt;p&gt;语言：python&lt;/p&gt;
&lt;p&gt;第三方库：sklearn、jieba、pyquery 等&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;数据采集&lt;/h2&gt;
&lt;p&gt;数据采集是对我来说是最好做的一步，其实就是写爬虫从各大网站收集大量的信息，存起来，以便我们后续分析处理。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1507857359245_8253_1507857329454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为这只是一个试验性的兴趣项目，没办法花太多时间投入，所以我这次只打算从微博的搜索结果中，取1000条数据来分析。当然如果有可能的话，数据越多越好，训练出来的模型就越准确。&lt;/p&gt;
&lt;p&gt;采集的页面是百度的微博搜索结果页：&lt;a href=&quot;https://www.baidu.com/s?wd=%E8%85%BE%E8%AE%AF&amp;amp;pn=0&amp;amp;tn=baiduwb&amp;amp;ie=utf-8&amp;amp;rtt=2&quot; target=&quot;_blank&quot;&gt;https://www.baidu.com/s?wd=腾讯&amp;amp;pn=0&amp;amp;tn=baiduwb&amp;amp;ie=utf-8&amp;amp;rtt=2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用python对该页面逐页抓取，然后用pyquery模块对抓取到的页面进行解析，得到一条条的微博文本。下面贴下这个页面的解析代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1507857516508_1225_1507857486049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;人工处理&lt;/h2&gt;
&lt;p&gt;这一步是最苦逼也是最花时间的一步，我们需要把采集到的数据，一条条精确地人工分类整理好，才能给后续的算法训练使用。如果你的场景在网上能找到现成的训练数据集，那么恭喜你已经节省了大把时间，但大多数情况还得自己来，所有脏活累活都在这了。而且人工分类的准确性，也决定了训练出来的模型的准确性，所以这一步的工作也是至关重要的。&lt;/p&gt;
&lt;p&gt;我们的目标是把消息分为“正面”、“负面”和“中性”三个类别。首先我们要先给这三个类别下一个明确的定义，这样在分类的时候才不会迷茫。我个人给它们下的定义是：&lt;/p&gt;
&lt;p&gt;正面：有利的新闻、积极正面的用户言论；&lt;/p&gt;
&lt;p&gt;负面：不利的新闻、消极反面的用户言论；&lt;/p&gt;
&lt;p&gt;中性：客观提及的新闻、不带感情色彩的用户言论。&lt;/p&gt;
&lt;p&gt;按照上面的标准，我们把采集到的1000条微博一一分类标记好。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;文本预处理&lt;/h2&gt;
&lt;p&gt;采集过来的微博文本，带有很多无效的信息，在开始训练之前，我们需要对这些文本做预处理，并保存为sklearn能接收的数据，主要工作包括：&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;去杂质&lt;/strong&gt;，包括表情符号、特殊符号、短链接等无效信息，这里用正则过滤掉即可，不再详细描述；&lt;br/&gt;2、&lt;strong&gt;保存为文本文件&lt;/strong&gt;，因为sklearn要求训练数据以特定的格式存放在本地目录，所以我们需要用脚本对原数据进行处理，目录格式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1507857584864_3993_1507857554381.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://mc.qcloudimg.com/static/img/66bbaa60ee8f4530e1a33f8712afe093/image.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;train：存放待训练的数据，子目录名称为分类名，子目录下存放训练文本文件，文件名随意，内容为单条微博文本；&lt;/p&gt;
&lt;p&gt;test：存放带测试的数据，子目录名称随意，在子目录下存放测试文本文件。&lt;/p&gt;
&lt;p&gt;建议训练集和测试集按8:2的比例划分，用python自动生成以上的本地文件。&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;分词&lt;/strong&gt;，因为微博的数据大部分都是中文，所以推荐用jieba分词，对中文的支持比较给力，效果也很好。支持自定义词典，支持返回指定词性的分词结果，可以去除一些停用词和语气助词等。使用起来也很简单，这里不详细介绍，有需要可以访问它的github地址：&lt;a href=&quot;https://github.com/fxsjy/jieba&quot; target=&quot;_blank&quot;&gt;https://github.com/fxsjy/jieba&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;算法选择&lt;/h2&gt;
&lt;p&gt;准备好训练数据之后，我们就可以开始训练了，为此我们需要选择一个合适的分类算法。但机器学习算法那么多，如果一个个去测试对比，将花费我们不少精力。幸好sklearn已经考虑到了这个问题，并提供了一个算法选择方案。通过把多个算法的运行结果进行图形化对比，可以很直观的看到哪个算法比较合适。&lt;/p&gt;
&lt;p&gt;这个是官方提供的测试代码：&lt;a href=&quot;http://scikit-learn.org/stable/auto_examples/text/document_classification_20newsgroups.html#example-text-document-classification-20newsgroups-py&quot; target=&quot;_blank&quot;&gt;http://scikit-learn.org/stable/auto_examples/text/document_classification_20newsgroups.html#example-text-document-classification-20newsgroups-py&lt;/a&gt;&lt;br/&gt;把这个官方案例的数据输入部分替换成自己的即可。结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1507857726300_147_1507857695830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;综合运算效率和得分情况，我选择了LinearSVC算法（SVM）来作为我的训练算法。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;训练&lt;/h2&gt;
&lt;p&gt;文本分类的训练主要有以下4个步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1507858653303_9451_1507858622776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这4个步骤 sklearn都已封装了相应的方法，所以使用起来极其方便。参考如下代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mc.qcloudimg.com/static/img/28d155fa0b49e2ad67624d764a2eb7fc/image.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：以上代码为了方便展示，把模块引入也放到方法内部了，仅作参考&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;应用&lt;/h2&gt;
&lt;p&gt;最后就是对训练好的模型进行测试和应用。&lt;/p&gt;
&lt;p&gt;通过已有的模型，对新的数据进行预测，代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1507858724035_6245_1507858694226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：本代码只是展示用，仅作参考&lt;/p&gt;
&lt;p&gt;打印出来的部分结果见下图：&lt;br/&gt;&lt;img src=&quot;https://mc.qcloudimg.com/static/img/e9b1b00d619f15dd67995a474110641c/image.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经统计，预测的准确率为95%，该模型算出的当天腾讯相关的舆情如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mc.qcloudimg.com/static/img/13656ebfc98392b57cc428f31527653e/image.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;本文只是记录下我这两天的一些想法和试验过程，没有涉及太多代码实现或者其他高深的算法，相信不难看懂。如果有人感兴趣的话，后面我可以把源码整理完发布出来。&lt;/p&gt;
&lt;p&gt;感谢阅读！&lt;/p&gt;

&lt;h3&gt;相关阅读&lt;/h3&gt;
&lt;p class=&quot;title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/community/article/682834&quot; target=&quot;_blank&quot;&gt;通过一个 kaggle 实例学习解决机器学习问题&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/community/article/686605&quot; target=&quot;_blank&quot;&gt;更快更准的异常检测？交给分布式的 Isolation Forest 吧&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/community/article/160232&quot; target=&quot;_blank&quot;&gt;机器学习之决策树与随机森林模型&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;此文已由作者授权腾讯云技术社区发布，转载请注明&lt;a href=&quot;https://cloud.tencent.com/community/article/515228&quot; target=&quot;_blank&quot;&gt;文章出处&lt;/a&gt;&lt;br/&gt;原文链接：https://cloud.tencent.com/community/article/515228&lt;/p&gt;
</description>
<pubDate>Fri, 20 Oct 2017 07:14:00 +0000</pubDate>
<dc:creator>腾讯云技术社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/7699646.html</dc:identifier>
</item>
<item>
<title>学习前端开发，一段心路历程，这个世界根本没有速成的方法 - 悟空前端</title>
<link>http://www.cnblogs.com/gongyue/p/7699639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gongyue/p/7699639.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本篇文章我就来给大家说一说我在学习前端开发过程中的一些经验，我把它们总结成了十条警言，希望能够对你的学习带来一些小的帮助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171020150725115-659074607.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;希望收藏了我写的文章的你同时可以关注一下“&lt;/strong&gt;web前端EDU”，因为这些文章都是连载的，并且是经过我系统的归纳过的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前端开发是当今社会上比较有发展潜力的一个行业，该行业主要以Web开发、移动端开发、全栈式开发等为主要内容。在社会上有较为广泛的应用领域，从业者有较为丰厚的薪资待遇。那么对于一个前端开发从业者来说，如何学习前端开发的相关知识，如何将自己打造为一个强大的前端开发设计师呢？小海老师从事多年的一线教学工作，深入挖掘学生在学习阶段的特点，总结了以下十条学习心得，愿意与大家一同分享。&lt;/p&gt;
&lt;p&gt;由于篇幅问题，本篇文章先为大家阐述前五条，下一篇文章会为大家分享后五条。&lt;/p&gt;

&lt;p&gt;前端开发的相关技术和知识非常多，每年还会有许多新的技术诞生并得到广泛的推广。IT行业本身就是一个技术更新非常快的行业。不过每门技术都有它最基本的知识内容和基础体系。无论学到多深的程度，扎实的基本功是必不可少的。&lt;/p&gt;
&lt;p&gt;初入职场，如果能够得到老板或技术总监一句“你的基础知识真扎实”的赏识，对于新入行的你一定是信心满满，也让领导对你有一个新层次的认识。&lt;/p&gt;
&lt;p&gt;我将前端开发的基础知识总结为以下几点，对于初学者来说，一定要认真学习这部分内容：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、HTML超文本标记性语言：尽量掌握尽可能多的标记或标记对。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)必须掌握的标记或标记对包括：&amp;lt;html&amp;gt;、&amp;lt;head&amp;gt;、&amp;lt;title&amp;gt;、&amp;lt;body&amp;gt;、&amp;lt;h1&amp;gt;、&amp;lt;p&amp;gt;、&amp;lt;a&amp;gt;、&amp;lt;img&amp;gt;、&amp;lt;table&amp;gt;、&amp;lt;tr&amp;gt;、&amp;lt;td&amp;gt;、&amp;lt;th&amp;gt;、&amp;lt;form&amp;gt;、&amp;lt;input&amp;gt;、&amp;lt;select&amp;gt;、&amp;lt;option&amp;gt;、&amp;lt;textarea&amp;gt;、&amp;lt;div&amp;gt;、&amp;lt;span&amp;gt;、&amp;lt;script&amp;gt;、&amp;lt;link&amp;gt;、&amp;lt;meta&amp;gt;、&amp;lt;style&amp;gt;、&amp;lt;hr&amp;gt;等。&lt;/p&gt;
&lt;p&gt;(2)同时，还有许多较为生僻的标记，大家看一看，你认识下列标记对吗？&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&amp;lt;label&amp;gt;&amp;lt;/label&amp;gt;：用于表单中盛放表单元素的文本提示，被称为“标签”标记对。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;/pre&amp;gt;：预格式化文本，在该标记对内部文本中的空格和换行都会在页面中起作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&amp;lt;address&amp;gt;&amp;lt;/address&amp;gt;：用于表示地址的语义标签。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&amp;lt;var&amp;gt;&amp;lt;/var&amp;gt;：用于表示变量的语义标签。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然还有许多较为生僻的标签，这些标签在日常的HTML开发中基本上已经不再使用了。但是当你学到Bootstrap框架的时候，你会发现，Bootstrap框架启用了这些标签，并为这些标签赋予了特定的功能和外观。&lt;/p&gt;
&lt;p&gt;(3)除此之外，HTML5技术也为HTML注入了新的活力，许多新标签和新属性加入其中，使得HTML语言更加丰富与强大。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&amp;lt;button&amp;gt;标记对：HTML5新加的具有数据提交功能的按钮。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&amp;lt;canvas&amp;gt;&amp;lt;/canvas&amp;gt;：HTML5的画布技术，该标记对结合脚本语言对应一套完整的API，可以实现页面矢量图的绘制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&amp;lt;audio&amp;gt;&amp;lt;/audio&amp;gt;：HTML5的音频技术，该标记对结合脚本语言对应一套完整的API，可以开发有关音频的项目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然还有许多HTML5新加的内容，需要广大初学者更多地接触并掌握。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、CSS层叠样式表：对于CSS的各个属性以及一些属性之间结合使用的技巧应该多钻研。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CSS技术作为对HTML标记对外观的扩展，在前端开发中体现出了强大的生命力。再结合CSS3技术，又扩展了大量的属性，使得CSS的功能更为全面，实现方法更为简洁。学好CSS，同时也是为页面布局打下坚实的基础。&lt;/p&gt;
&lt;p&gt;你会用CSS技术的使用技巧解决下列问题吗？&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何去掉容器中图片下方自动产生的距离。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当容器中具有浮动元素时，如何为容器设置边框或背景颜色？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;怎样让块级元素在容器中水平居中？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当多个连续块级元素的浮动布局影响了原本不想浮动的对象时该如何处理？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;容器内部的对象如何实现相对于容器的自由定位？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看来，CSS的属性及其取值只是CSS技术的第一层面，更多的使用技巧等待大家去挖掘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171020150952302-1704022209.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;web前端学习交流群：250777811&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rD7hD8KsI7UibLt0xYFesrLSxQDZdPTlUWqIw2RYkiaq1nFA1QuJibYqtqcI3LHgLdQEZ1EmoicWLPdUw/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、CSS+div布局模式：这是许多布局模式的基础，也是大部分前端开发人员接触到的第一种布局方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种布局模式对于PC端页面的设计是非常有帮助的，同时对于后面将会遇到的“圣杯布局”、“双飞翼布局”、“移动端布局”、“响应式布局”等，这种布局方式都具有一定的指导意义。&lt;/p&gt;
&lt;p&gt;上述就是小海老师认为的一定要非常扎实的掌握的前端开发的基础知识。基础知识是高阶知识的起步平台，没有基础知识，更深层次的内容是无法真正理解的。&lt;/p&gt;

&lt;p&gt;JavaScript已经发展成为了Web开发的唯一的脚本语言。它从早期的基于对象的语言变为了面向对象的语言，现代JavaScript为前端开发带来了不可替代的技术革新。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JavaScript可以轻松的实现HTML和CSS无法实现的流程控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;结合DOM技术，JavaScript可以访问HTML元素并操作它们。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HTML5中的许多API都是基于JavaScript进行开发和设计的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;强大的jQuery库、jQuery UI、jQuery Mobile等都是在JavaScript的基础上开发出来的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;全栈式开发所使用的node.js、AngularJS等第三方框架，也都是在JavaScript的基础上编写的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这门神一般的语言，我个人认为是务必要认真学习的，不仅要学习JavaScript的语法知识，还要学习利用它实现DOM元素的使用，学会面向对象的编程思想。甚至还要掌握该门语言的细节特点。&lt;/p&gt;
&lt;p&gt;系统学习过JavaScript的同学们，你看看下列问题你能准确的找到答案吗？&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过表达式来系统阐述“==”和“===”这两个运算符的区别。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过哪个函数可以判断从文本框中获取的内容是不是数字？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;会使用这两个属性吗：contentEditable、isContentEditable。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;知道window对象的两个方法：setTimeout()、setInterval()在计时器方面的使用区别吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;delete运算符都能删除哪些内容？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在脚本中，this有几种使用情况呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JavaScript语言虽然很重要，许多公司都需要从业人员掌握原生态的JavaScript代码。但是这门语言由于发展过程中的种种原因，存在许多繁冗且不好的代码模式。例如原型链、闭包、对象与类等概念，都给这门语言戴上了“难学”的帽子。同时，这些知识有时候也正是JavaScript放光彩的一面，所以对于这门脚本语言掌握不精的学习者来说，小海老师告诉大家，一定要把这门语言搞懂，达到精通的程度，对于后续的全栈式开发绝对有非常好的作用。&lt;/p&gt;

&lt;p&gt;前端开发本身就是需要实战经验非常强的一门学科。学习和工作过程中，不断地、反复地、大量地尝试和上机操作，是学好前端开发唯一不变的方法。&lt;/p&gt;
&lt;p&gt;这里拿Bootstrap框架为例，互联网上大部分教程和许多前端教师都提倡让学生从Bootstrap官网上复制粘贴代码，以更加快速的完成页面的搭建。&lt;/p&gt;
&lt;p&gt;小海老师尤为反对这种方式，特别是对于还处在学习阶段的同学们和初次使用Bootstrap框架的从业者。首先不可否认，Bootstrap为前端开发人员带来了大量的类名和属性之间的搭配关系，每一个组件和插件的使用都用脑子记下来，确实有很大的困难。但是在学习阶段，我非常提倡对官网的示例代码进行钻研和分析，阅读bootstrap.css文件和bootstrap.js文件，从原理上理解这个框架是如何利用简单的类名和属性名来实现复杂的脚本功能的。我在日常的教学过程中也是这么带领学生一起学习的。&lt;/p&gt;
&lt;p&gt;正所谓“知其然，还要知其所以然”，了解了内部的原理，一方面自己更加容易去记忆这些大量的名称，另一方面，对于样式类框架的开发，也会有一定的了解。时间久了，自己也能写出符合自身特点的小框架，使得知识达到循序渐进、熟能生巧的程度。&lt;/p&gt;

&lt;p&gt;“读书”永远是掌握技术的一种有效方法，无论什么技术。读书的过程不仅能够让我们了解作者的意图，更能训练我们的阅读速度，提高自身的自学能力。这正是一个合格的前端开发工程师应该具备的业务素质。&lt;/p&gt;
&lt;p&gt;这里，小编为大家推荐几本前端开发领域的经典著作，真的希望你也能拿起教材，从第一页读到最后一页，你一定会受益匪浅。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rD7hD8KsI7UibLt0xYFesrLSqdPzZvIe3iaZa3TIPx7gYpjMNHoQ4rp8BSJRYtAD8jfMxlxmt0UxDVw/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.2578125&quot; data-w=&quot;512&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171020150759881-1127827184.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;web前端+javascript学习交流群：250777811&lt;/p&gt;
&lt;p&gt;Bootstrap开发的经典教材&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rD7hD8KsI7UibLt0xYFesrLSQxWJOJDnqDmRdFfRMib5ibKZsUCUQ8h7lLqmYiarHyfT19BibcEBXI8MBw/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.2578125&quot; data-w=&quot;512&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171020150812802-1952078584.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;学习JavaScript脚本语言必不可少的好书&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rD7hD8KsI7UibLt0xYFesrLSmpPico2DDu0tdGng7DkVZkX3SaTCHqQIGnyvAiccraxzrsvxuEXgNMEA/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.400390625&quot; data-w=&quot;512&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171020150824302-1385112581.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;jQuery提高的优质教材&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rD7hD8KsI7UibLt0xYFesrLS4xa4puU7jVrj8hKiaSO9VHNaicgaiapzIfq0iaZW3jhx8YrweZ5lYq15TA/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.2578125&quot; data-w=&quot;512&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171020150837115-683486674.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;非常适合初学Node.js的学生阅读的书&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rD7hD8KsI7UibLt0xYFesrLSrvs30vc7KbfaJgY3ZxveZCEVqB5vNpERmOtFGiaOxgYfYaxRDa7OK2g/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.2813141683778233&quot; data-w=&quot;487&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171020150849443-1960979127.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一本讲述SVG实践的教材&lt;/p&gt;

&lt;p&gt;如今互联网渗入到了我们学习和工作的方方面面，与其天天拿着手机刷微博、聊微信，何不拿起互联网这个工具，多多学习一些有关前端开发的知识，积累一些前人总结出来的经验，丰富自己的羽翼。&lt;/p&gt;
&lt;p&gt;这里，为大家推荐几个学习前端开发的网站，希望大家可以多多浏览，利用好互联网资源。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;W3CSchool。这里列举了多门前端技术和后台技术的基础知识。内容较为基础，却是初学者好的帮手。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;菜鸟教程。一个类似于W3CSchool的基础知识学习网站。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;jQuery API中文文档（http://jquery.cuishifeng.cn/）。这里汇集了jQuery各个版本的API内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Bootstrap中文网。这里涵盖了Bootstrap框架全部的组件和插件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果大家也有好的学习网站，希望也推荐给我哦。&lt;/p&gt;
&lt;p&gt;由于篇幅问题，后面还有五条心得，我会在下一篇文章中，为大家展开阐述。如果你有什么学习前端开发的好方法和自己的感悟，也可以在下面留言。真心的希望能够与你得到更深入的交流！&lt;/p&gt;
&lt;p&gt;（未完待续）&lt;/p&gt;
&lt;p&gt;web前端学习交流群：250777811&lt;/p&gt;

&lt;p&gt;下一篇文章中，小编继续跟广大前端开发的爱好者谈一谈学习前端开发的心得。&lt;/p&gt;
&lt;p&gt;在后续的文章中，小编将为大家讲解浮动属性。浮动属性是流式定位的重要属性，承担了大部分传统布局的功能。希望广大前端学习者千万不要错过！&lt;/p&gt;

</description>
<pubDate>Fri, 20 Oct 2017 07:13:00 +0000</pubDate>
<dc:creator>悟空前端</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gongyue/p/7699639.html</dc:identifier>
</item>
<item>
<title>C#设计模式之八桥接模式（Bridge）【结构型】 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/7699301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/7699301.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   今天我们要讲【结构型】设计模式的第二个模式，该模式是【桥接模式】，也有叫【桥模式】的。大家第一次看到这个名称会想到什么呢？我第一次看到这个模式根据名称猜肯定是连接什么东西的。因为桥在我们现实生活中经常是连接着A地和B地，再往后来发展，桥引申为一种纽带，比如：丝绸之路是连接亚洲和欧洲的桥梁。有了桥，我们出行方便了，从一个地方到另一个地方在有桥的情况更方便了（此处不许抬杠，当然是需要桥的情况）。桥是针对桥的使用环境来说的，解决了跨越和衔接的问题。在设计模式中的【桥模式】也有类似的概念，是连接了两个不同维度的东西，而且这两个维度又有强烈的变化，什么叫强烈呢，经常变化，什么是经常呢？哈哈，自己理解吧。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、桥接模式的详细介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1、动机（Motivate）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   在很多游戏场景中，会有这样的情况：【装备】本身会有的自己固有的逻辑，比如枪支，会有型号的问题，同时现在很多的游戏又在不同的介质平台上运行和使用，这样就使得游戏的【装备】具有了两个变化的维度——一个变化的维度为“平台的变化”，另一个变化的维度为“型号的变化”。如果我们要写代码实现这款游戏，难道我们针对每种平台都实现一套独立的【装备】吗？复用在哪里？如何应对这种“多维度的变化”？如何利用面向对象技术来使得【装备】可以轻松地沿着“平台”和“型号”两个方向变化，而不引入额外的复杂度？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2、意图（Intent）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   将抽象部分与实现部分分离，使它们都可以独立地变化。&lt;/p&gt;&lt;p&gt;   &lt;span&gt;桥模式不能只是认为是抽象和实现的分离，它其实并不仅限于此。其实两个都是抽象的部分，更确切的理解，应该是将一个事物中多个维度的变化分离&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.3、结构图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/1048776/201710/1048776-20171020141809084-597852780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.4、模式的组成&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;      桥接模式的结构包括Abstraction、RefinedAbstraction、Implementor、ConcreteImplementorA和ConcreteImplementorB五个部分，其中：&lt;/p&gt;&lt;p&gt;　　. Abstraction：定义抽象类的接口，它维护了一个指向Implementor类型对象的指针。&lt;/p&gt;&lt;p&gt;　　. RefinedAbstraction：扩充由Abstraction定义的接口；&lt;/p&gt;&lt;p&gt;　　. Implementor：定义实现类的接口，该接口不一定要与Abstraction的接口完全一致，事实上两个接口可以完全不同。一般情况，Implementor接口仅为提供基本操作，而Abstraction则定义了基于基本操作的较高层次操作。&lt;/p&gt;&lt;p&gt;　　. ConcreteImplementorA和ConcreteImplementorB：实现Implementor接口并定义它的具体实现。&lt;/p&gt;&lt;p&gt;　　在桥接模式中，两个类Abstraction和Implementor分别定义了抽象与行为类型的接口，通过调用两接口的子类实现抽象与行为的动态组合。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.5 、桥接模式的具体实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   今天我们就以数据库为例来写该模式的实现。每种数据库都有自己的版本，但是每种数据库在不同的平台上实现又是不一样的。比如：微软的SqlServer数据库，该数据库它有2000版本、2005版本、2006版本、2008版本，后面还会有更新的版本。并且这些版本都是运行在Windows操作系统下的，如果要提供Lunix操作系统下的SqlServer怎么办呢？如果又要提供IOS操作系统下的SqlServer数据库该怎么办呢？这个情况就可以使用桥接模式，也就是Brige模式。我们就来看看具体的实现吧！&lt;br/&gt;   &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 桥接模式的实现
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 该抽象类就是抽象接口的定义，该类型就相当于是Abstraction类型
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Database
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过组合方式引用平台接口，此处就是桥梁，该类型相当于Implementor类型&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; PlatformImplementor _implementor;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过构造器注入，初始化平台实现&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Database(PlatformImplementor implementor)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;            &lt;span&gt;this&lt;/span&gt;.__implementor=&lt;span&gt;implementor;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建数据库--该操作相当于Abstraction类型的Operation方法&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Create();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 该抽象类就是实现接口的定义，该类型就相当于是Implementor类型
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PlatformImplementor
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法就相当于Implementor类型的OperationImpl方法&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;  
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; SqlServer2000版本的数据库，相当于RefinedAbstraction类型
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlServer2000:Database
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Create()
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._implementor.Process();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;  
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; SqlServer2005版本的数据库，相当于RefinedAbstraction类型
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlServer2005:Database
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Create()
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._implementor.Process();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; SqlServer2000版本的数据库针对Unix操作系统具体的实现，相当于ConcreteImplementorA类型
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlServer2000UnixImplementor:PlatformImplementor
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process()
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SqlServer2000针对Unix的具体实现;&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;  
&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; SqlServer2005版本的数据库针对Unix操作系统的具体实现，相当于ConcreteImplementorB类型
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SqlServer2005UnixImplementor:PlatformImplementor
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process()
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;SqlServer2005针对Unix的具体实现;&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;       &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;          PlatformImplementor SqlServer2000UnixImp=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlServer2000UnixImplementor();
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还可以针对不同平台进行扩展，也就是子类化，这个是独立变化的&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt;          Database SqlServer2000Unix=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlServer2000(SqlServer2000UnixImp);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库版本也可以进行扩展和升级，也进行独立的变化。&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt; 
&lt;span&gt;84&lt;/span&gt; &lt;span&gt;         以上就是两个维度的变化。
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; 
&lt;span&gt;86&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;就可以针对Unix执行操作了&lt;/span&gt;
&lt;span&gt;87&lt;/span&gt; &lt;span&gt;         SqlServer2000Unix.Create();
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    代码都很简单，也有详细的备注，就不多说了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三、桥接模式的实现要点：&lt;/strong&gt;&lt;br/&gt;    &lt;br/&gt;    1．Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。&lt;/p&gt;&lt;p&gt;    2．所谓抽象和实现沿着各自维度的变化，即“子类化”它们，得到各个子类之后，便可以任意组合它们，从而获得不同平台上的不同型号。&lt;/p&gt;&lt;p&gt;    3．Bridge模式有时候类似于多继承方案，但是多继承方案往往违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差。Bridge模式是比多继承方案更好的解决方法。&lt;/p&gt;&lt;p&gt;    4．Bridge模式的应用一般在“两个非常强的变化维度”，有时候即使有两个变化的维度，但是某个方向的变化维度并不剧烈——换言之两个变化不会导致纵横交错的结果，并不一定要使用Bridge模式。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;四、.NET 中桥接模式的实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    学习中。。。，如果谁有好的代码分享，也可以贴出来。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;  今天的文章就写到这里了，现在小结一下。桥接模式它是连接客户端代码和具体实现代码的一座桥梁，同时它也隔离了实现代码的改变对客户代码的影响。在【意图】中所说的抽象和实现，这两个部分其实都是高度抽象的，前面“抽象”是指定义的针对客户端的接口，客户端其实使用的是Abstract类型或者是RefinedAbstract类型，这两个类型只是接口，具体的实现委托给了Implementor类型了，Abstract类型子类化的扩展也演变成Implementor子类化的变化。我个人的理解，Abstract类型和其子类型在客户端代码和真正实现的代码之间起到了桥梁的作用，隔离了Implementor实现代码的变化，让客户端更稳定，所以【意图】才说是讲抽象部分和它的实现部分隔离。大家好好理解一下吧，刚开始有点绕。&lt;/p&gt;
</description>
<pubDate>Fri, 20 Oct 2017 06:22:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/7699301.html</dc:identifier>
</item>
<item>
<title>做一名「技术掮客」去变现自己的技术 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/7699267.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/7699267.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/672506/201710/672506-20171020141509240-1343693516.jpg&quot; alt=&quot;&quot; width=&quot;995&quot; height=&quot;663&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt; 原文首发于我的微信公众号：&lt;strong&gt;GeekArtT&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;1&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术人员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然 IT从业者的薪酬在各行业中算是处于领先地位，但内心的焦虑感并不会因为这些表面的高薪酬而得到缓解。时不时的，技术人员会因为看不懂自己付出的大量心血的意义而自我怀疑。就算不考虑是否有意义，这些花费的心血是否能够收到相匹配的报酬，或者是否能够得到相匹配的变现，也让技术人员心烦不已。明明付出了&lt;strong&gt;常人&lt;/strong&gt;难以想象的努力和心血，但这条路的结局依旧要等同于&lt;strong&gt;常人&lt;/strong&gt;么？&lt;/p&gt;
&lt;p&gt;技术做得久了，就会让人越来越迷糊。一直忙于解决细节的问题，会习惯性地忽略做这个事情的意义和动机。虽然你可能做了很多的工作，也投入了大量的时间与精力在你的工作上，但跳出来看，你的功夫仅仅是花费在了&lt;strong&gt;任务的执行&lt;/strong&gt;上。至于任务的内容、方向和动机，无一例外都是被动地由由公司分配、由老板指派。&lt;/p&gt;
&lt;p&gt;为什么这个方向值得一做，这个方向是不是符合你自己的性格特点和成长方式，你既不不清楚，也无权参与讨论。&lt;/p&gt;
&lt;p&gt;当这种方向性、意义、动机性的决策能力长期得不到训练，便会导致一个严重的问题：你无法看清楚承载你技术的大环境。你不知道技术市场的结构、优势以及“漏洞”在哪里。甚至，你根本就不知道还有一个叫做&lt;strong&gt;市场&lt;/strong&gt;的需要你去考虑，不知道它会对你产生极其重要的影响。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;商业套利者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;做商业的人，通常对技术都不是太懂，特别是那些白手起家没怎么念过书的民营企业家。他们通常没有太高的教育背景，自然也不太可能对技术有什么深入的了解和体会。&lt;/p&gt;
&lt;p&gt;但他们，恰好是另一个方向的高手——市场直觉的大师。他们依靠自己多年在市场上的残酷搏杀，锻造出了自己特有的思维方式：&lt;strong&gt;没有什么事情是不可以做的，我随时可以更换自己的从业领域，只要这个行业有利可图。而要做这个行业的事情，不必非要提供一款百分百匹配需求的产品，只要表面上差不多就可以了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;大部分看到这段话的技术人员，会把注意力放在最后一点上：不匹配需求的产品不就是粗制滥造么，这样的产品可以卖出去么？如果真能卖出去，那无非是建立在践踏道德底线之上，没什么可取之处。&lt;/p&gt;
&lt;p&gt;对于第一个问题，身边发生的大量制假售假的事件已经清晰明白地告诉了我们答案。就算是有着极高的教育背景，甚至是大学教授，也难逃劣质产品、诈骗团伙的陷阱。&lt;/p&gt;
&lt;p&gt;但如果你直接粗暴地把这些“盈利”的本质，归结为基于道德的践踏或是欺骗欺诈，我想你一定没有抓住商业的重点。如果真是这样你也可以流氓、无耻一把试试。就算你因世事的变故，被生活压迫到了极点，可以变得无耻无理、突破道德底线。相信我，挣钱的难度系数并不会因此而减少半点。相反，你很可能因为你的“无耻”而变得臭名昭著。不仅亲友反目遭人唾弃，更可能因为利益纠纷而走上亡命天涯的道路。&lt;/p&gt;
&lt;p&gt;另一方面，如果这些道德上的粗鄙、欺诈的内容，仅仅是为了让你买一张桌子或是一块砖头，我想，任他们吹得天花乱坠，你掉进到陷阱里的几率也会小很多。&lt;/p&gt;
&lt;p&gt;所以，从我的观点来看，“道德上的粗鄙”仅仅是为“盈利”做锦上添花的花，它不是本质。真正能够让这群商人、甚至是骗子“成功”的，是他们强大的市场需求的洞察能力。如果你仔细考察他们提供的粗制滥造的产品或者(欺诈)服务，你会发现， 他们一定是在解决被骗者们的一个强烈需求，也就是一个市场痛点。&lt;/p&gt;
&lt;p&gt;他们发现的这个市场需求(或者说是市场漏洞)，是如此得强烈但又不为大多数人所知，以至于一款粗糙的产品都足以让市场追捧。因为你几乎找不到市场上的其它产品，来满足这个需求，更别提产品的满意度。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互相的鄙视&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从事商业的人与从事技术的人，通常会相互鄙视，水火不容。双方都喜欢用攻击性的言辞互相指责，而看不到对方有启发性的真实诉求。&lt;/p&gt;
&lt;p&gt;商人认为技术人员呆板，不灵活。其真实意思是：技术人员不懂得“方向”的重要性，不懂如何洞察市场，根据市场的需求、痛点、漏洞来制定自己的事业。只是一味地埋头苦干，怎么可能放大自己劳动付出的影响力和收益率？！&lt;/p&gt;
&lt;p&gt;技术人员认为商人没有道德底线，十商九奸，没有为世界带来真正的价值。其真实意思是：你商人怎么就不能踏踏实实地把某个产品某个行业给做好呢？为什么就不能提供百分之百匹配你自己的说辞的产品呢？只知道到处坑蒙拐骗，怎么就不能够用实力创造一些东西，来让这个世界更好呢？！&lt;/p&gt;
&lt;p&gt;对于商人来讲，ta的目的是牟利。对于技术人来讲，ta的目的是提供对世界有价值的产品。&lt;/p&gt;
&lt;p&gt;而这两者，虽然彼此有关联，但却又彼此独立。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于“牟利”这个目标来说，它不必通过“提供有价值的产品”这条路径来实现。如果你能够在商业领域待一阵子，或者在&lt;strong&gt;金融领域&lt;/strong&gt;待一阵子，你会发现，在“赚钱”的领域，&lt;strong&gt;最核心最强大的武器不是“产品”，而是“信息差”&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于“做出有价值的产品”这个目标来说，它可能有价值但却完全不能盈利。试想，如果你夜以继日地去研究“如何改进相机胶片的感光性能，使它具备更好的拍摄效果”，我不能说这个研究没有“技术价值”，但它却一定没有“市场”。因为市场早就已经不关心这个问题了。那即便你有价值，也根本不能盈利。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;4&lt;/em&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;眼界的比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术人员有着商人所不具备的攻坚能力。从理论上讲，技术人员能够看到更多潜在的需求和层次，因为他能看到更多表层之下的东西。&lt;/p&gt;
&lt;p&gt;但是，技术人员性格的内向和行事作风的拘谨，又会限制自己视野的广度。ta们会热烈拥抱&lt;strong&gt;技术上的变化&lt;/strong&gt;，并把它当做一个正经事来处理，把控制技术复杂度当作一门科学去处理。但又极力逃避&lt;strong&gt;人世中的变化&lt;/strong&gt;，把“自己生活中的变故”、“生活习惯的改变”放到非常高的疼痛层次，以至于会完全无视“改变自己生活方式”的选项。所以就一门心思地往深里看，而不会眺望远方的不同行业。&lt;/p&gt;
&lt;p&gt;而商人，虽然不及技术人员看得深，但他对自己从属行业的变化从不设限。哪里有利可图，就去哪里。从来不会把自己固定在一个方向或是一个行业。因为对于套利者来说，一切事业的根基都是那个可以套利的市场漏洞，哪里有机会就去哪里。于是在广度上，商人具备更多的可能性和变化性，并随时准备让自己随着市场的流动而流动。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;5&lt;/em&gt;&lt;/strong&gt;   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;真正的追求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为一个技术人员，你当然希望你的事业能够为你赚取报酬，因为你毕竟是一个需要生存生活的人，需要为自己的家庭尽到相应的责任。&lt;/p&gt;
&lt;p&gt;但同时，你不希望只是通过“信息差”的方式来为自己赚钱。因为“信息差”的出现，可能不只是因为你发现了某个市场痛点，更可能来自“欺骗”的手段，被人为制造出来。你不希望通过这种道德上的粗鄙去放大信息差，从而放大自己的利润。你更希望通过自己的手艺，一些实实在在的技术活，通过创造有价值的产品，通过解决真实的社会问题来获取合理的报酬。&lt;/p&gt;
&lt;p&gt;所以根本来讲，你的追求其实不是简单的，它是一个期望的复合体。&lt;/p&gt;
&lt;p&gt;既然你的目标都是一个复杂的综合体，那么你怎么能够期望它的解决方案是简单的呢？！你不能幼稚地幻想，可以通过某一方面水平的提高，来完全弥补另一方面的缺失。事实上，你需要的是多重能力的复合。&lt;/p&gt;
&lt;p&gt;既然要赚钱，那一个逃避不了的能力或者工作便是了解市场、紧跟市场。你必须牢牢地把握住市场的结构、流向和趋势。你不能说，因为市场的这些东西和技术无关，不是所谓的干货，就不屑于关注。既然你的目标里面有一份“牟利”的成分，那你就必须要把关注市场的工作做到位。因为盈利与否，完全是由市场决定的，而不是技术。&lt;/p&gt;
&lt;p&gt;既然不想通过“欺骗”来放大盈利能力，那么，你就要通过“壁垒”（最好是你喜爱的技术壁垒）来放大解决方案的“稀缺性”。通过“稀缺性”来提高市场的议价权。&lt;/p&gt;
&lt;p&gt;这就需要你在正确的市场需求方向上，踏踏实实研究技术，并通过恰当的经营和分享，来放大你的影响力，进而放大你的市值。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;6&lt;/em&gt;&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三种人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;成为技术掮客，是满足以上要求的一条切实可行的道路。&lt;/p&gt;
&lt;p&gt;做一名技术掮客，意味着你并不是以一个固定不变的心态在某个公司、或者某个领域一直做下去。它的打底本色，是商人、是套利者，是市场当中的清道夫，蚕食一切市场漏洞。在做任何的技术投入之前，技术掮客要用自己的市场嗅觉和洞见，找到当前市场的隐形需求、又或是不太为人所知的高回报需求。&lt;/p&gt;
&lt;p&gt;极端的技术掮客，类似于灰产的从业者。他们所做的东西不会是技术的主流，但一定是市场需求的潜在主流。什么快递单、群控手机、虚拟币代充，各种羊毛党所从事的事情。而这些灰产的背后，都可以看到相应的商业洞见。&lt;/p&gt;
&lt;p&gt;但如果你在道德粗鄙的方向上不走那么远，如果你找到的漏洞并不伤及无辜或者无知的他人，那么，这正是技术掮客的业务范围。一个很好的例子，是陈皓老师在「极客时间」专栏分享的经历。因为撰写了当时市场上单独一份的关于Purify的文章《C/C++ 内存问题检查利器—Purify》，而被企业邀请去做培训，获得了不菲的报酬。&lt;/p&gt;
&lt;p&gt;这正是技术掮客要做的事情。不是对每一个领域每一个技术点都平均用力，都浅尝辄止。而是在开始把时间投入之前，先看清楚市场的需求，先弄明白你将要投入的方向的潜力、市场稀缺性、以及市场对其需求的紧迫程度。&lt;/p&gt;
&lt;p&gt;这就好比是一个贸易商，不会轻易地囤积各种货物，再考虑交易的问题。ta一定要事先做好竞品分析，找准市场的痛点和需求点，再来规划自己需要囤积的货品。&lt;/p&gt;
&lt;p&gt;而技术人员，应该以同样的思维方式看待自己的技术。你的技术便是你要贩卖的商品，而你是自己技术的贸易商。你不隶属于任何特定的机构或公司。你自己本身，就是一个贸易商，是整个贸易链的一环。你和公司的关系，不是不平等的上下级关系，而是平等的合作关系。这样的操作模式和思维意识，才能让技术人员在市场中占据主动。&lt;/p&gt;
&lt;p&gt;这里的重点是，&lt;strong&gt;是否具备正确的市场意识决定了你自己的贴现汇率&lt;/strong&gt;。同样是一行代码，放的位置不同，便会得到完全不同的现值回报。举个例子，很多科班出身的人都会用Python写爬虫，会通过正则表达式筛选信息。但几乎没有多少人会因为自己写的正则表达式或者爬虫脚本而获得相对优质的报酬。&lt;/p&gt;
&lt;p&gt;举一个2017年3月份的例子(https://goo.gl/Ejggmf)，一个叫Vlad Wetzel的程序员，通过分析在StackOverflow上提及的优秀书籍，运用自己的爬虫代码，将这些信息汇总成了一个技术人员推荐购书的网站，最终获利颇丰。从技术角度讲，它并不是什么高深莫测的前沿新东西。但因为加上了不同一般的商业思路和市场洞见，这份不怎么新奇的技术却获得了超额的回报。它再一次证明，挣钱这件事情，只和市场有关系。能否运用你的技术去挣钱，完全取决于你是否为你的技术匹配上了正确的市场头脑。&lt;/p&gt;
&lt;p&gt;技术掮客，就是这样一个复合的存在。它通过建立敏锐成熟的市场嗅觉，来指导自己的时间投资方向和精力投放领域。再通过扎实的技术实力，来满足这些隐藏的市场需求，又或是创造性地开辟出隐藏需求的新市场。这样具备产品意识、具备市场意识的技术人员，才是新时期需要的复合型人才。&lt;/p&gt;
&lt;p&gt;越是往后，纯粹的技术就越是会变成新世界里常识一般的存在。它是新世纪每一个人最基本的生产能力和生存方式。当时代跨越到写程序如同识字一样的世界时，人类社会当中那些最基本的“生产关系”“人际关系”“经济关系”将再一次发挥作用。&lt;/p&gt;
&lt;p&gt;从这个角度来讲，当作为第一生产力的科学技术足够普遍时，人文科学的规律将再一次在世界中主导一切。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247483998&amp;amp;idx=1&amp;amp;sn=acb416bb9f336d7cea1e66c7ba86d260&amp;amp;chksm=ec20e5e2db576cf4ddf72e51c295e562a1a0d62389c1ce157a60d093828fb32255a58a80cc0b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;「极客时间」带来的社区价值思考&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247483994&amp;amp;idx=1&amp;amp;sn=3bb217f3dda87943a4f147dd733bfa29&amp;amp;chksm=ec20e5e6db576cf013a538763810332f7ea374d1efbe5f97a002fb2df57671015e24e23ba9af&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;Neuralink的使命，新大航海时代的位置&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247483985&amp;amp;idx=1&amp;amp;sn=ebc81bbf6c993522135d5d2e1022a90b&amp;amp;chksm=ec20e5eddb576cfb3c01414d96903557fac8aff3f7e8ab351a2c77e8997ac750197af23c7a22&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;Elon Musk的魔法帽&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; width=&quot;auto&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxOVhFvSsJ3Cicus715kz85ebtbQ05qVpUOm8EzbBYibhXxPADEB42RqrynibZckNCdVfZHibA07ibAWvoQ/0?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/672506/201710/672506-20171020141407068-949845615.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;VIP赞赏专区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxOVhFvSsJ3Cicus715kz85ebichNuCgxKHTS1K5L9ibJr2EPPGpXafBr5IHMatJP9HwsGeQuAPRXof8A/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxOVhFvSsJ3Cicus715kz85ebichNuCgxKHTS1K5L9ibJr2EPPGpXafBr5IHMatJP9HwsGeQuAPRXof8A/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-w=&quot;1080&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Oct 2017 06:17:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/7699267.html</dc:identifier>
</item>
<item>
<title>Go语言备忘录（3）：net/http包的使用模式和源码解析 - SuriFuture</title>
<link>http://www.cnblogs.com/susufufu/p/7698900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/susufufu/p/7698900.html</guid>
<description>&lt;div readability=&quot;16.639255702281&quot;&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;&lt;strong&gt;本文是晚辈对net/http包的一点浅显的理解，文中如有错误的地方请前辈们指出，以免误导！&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;&lt;strong&gt;转摘本文也请注明出处：&lt;a href=&quot;http://www.cnblogs.com/susufufu/p/7698900.html%20&quot; target=&quot;_blank&quot;&gt;Go语言备忘录（3）：net/http包的使用模式和源码解析&lt;/a&gt;，多谢！ &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;一、http包的3个关键类型：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;Handler接口：&lt;/span&gt;所有请求的处理器、路由ServeMux都满足该接口；
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type Handler interface {
   ServeHTTP(ResponseWriter, *Request)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;span&gt;ServeMux结构体：&lt;/span&gt;HTTP请求的多路转接器（路由），它负责将每一个接收到的请求的URL与一个注册模式的列表进行匹配，并调用和URL最匹配的模式的处理器。它内部用一个map来保存所有处理器Handler&lt;br/&gt;&lt;ul&gt;&lt;li&gt;http包有一个包级别变量DefaultServeMux，表示默认路由：var DefaultServeMux = NewServeMux()，使用包级别的http.Handle()、http.HandleFunc()方法注册处理器时都是注册到该路由中；&lt;/li&gt;
&lt;li&gt;ServeMux结构体有ServeHTTP()方法（满足Handler接口），主要用于间接调用它所保存的处理器的ServeHTTP()方法&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;http.HandlerFunc函数类型：&lt;/span&gt;它满足Handler接口&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type HandlerFunc func(ResponseWriter, *Request)
//实现Handler接口的ServeHTTP方法
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r) //调用自身
}
&lt;/pre&gt;&lt;/div&gt;
&lt;br/&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;二、HTTP服务器的使用模式：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;处理函数：&lt;/span&gt;只要函数的签名为 func(w http.ResponseWriter, r *http.Request) ，均可作为处理函数，即它可以被转换为http.HandlerFunc函数类型；&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;模式一：使用默认的路由来注册处理函数：&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;7&quot;&gt;

&lt;p&gt;&lt;strong&gt;模式二：使用自定义的路由来注册处理函数：&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;7&quot;&gt;

&lt;p&gt;&lt;strong&gt;模式三：直接自定义一个Server实例：&lt;/strong&gt;该模式可以很方便的管理服务端的行为&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wiz_cm_1508473254663_9679&quot; class=&quot;wiz-code-container&quot; data-mode=&quot;JavaScript&quot; data-theme=&quot;default&quot; readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
 mux := http.NewServeMux()
 mux.Handle(&quot;/file&quot;,myHandler(&quot;somefile&quot;))
 mux.HandleFunc(&quot;/&quot;, serveHome) 

 s := &amp;amp;http.Server{
    Addr: &quot;:8080&quot;,
    Handler: mux, //指定路由或处理器，不指定时为nil，表示使用默认的路由DefaultServeMux
    ReadTimeout: 10 * time.Second,
    WriteTimeout: 10 * time.Second,
    MaxHeaderBytes: 1 &amp;lt;&amp;lt; 20,
    ConnState: //指定连接conn的状态改变时的处理函数
        //....
 }
 log.Fatal(s.ListenAndServe())
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来，我们就跟踪源码来仔细的分析下整个执行过程。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div readability=&quot;17.5&quot;&gt;&lt;br/&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;三、HTTP服务器的执行过程：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;1.使用http.ListenAndServe()方法启动服务，它根据给定参数构造Server类型，然后调用server.ListenAndServe()&lt;br/&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func ListenAndServe(addr string, handler Handler) error {
    server := &amp;amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;br/&gt;2.而server.ListenAndServe()方法内部调用net.Listen(&quot;tcp&quot;, addr)，该方法内部又调用net.ListenTCP()创建并返回一个监听器net.Listener，如下的ln；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func (srv *Server) ListenAndServe() error {
    addr := srv.Addr
    if addr == &quot;&quot; {
        addr = &quot;:http&quot;
    }
    ln, err := net.Listen(&quot;tcp&quot;, addr)
    if err != nil {
        return err
    }
    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;3.然后把监听器 ln 断言转换为 TCPListener 类型，并根据它构造一个 tcpKeepAliveListener 对象并传递给server.Serve()方法；&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;ul&gt;&lt;li&gt;因为TCPListener实现了Listener接口，所以tcpKeepAliveListener也实现了Listener接口，并且它重写了Accept()方法，目的是为了调用SetKeepAlive(true)，让操作系统为收到的每一个连接启动发送keepalive消息(心跳，为了保持连接不断开)。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type tcpKeepAliveListener struct {
    *net.TCPListener
}
func (ln tcpKeepAliveListener) Accept() (c net.Conn, err error) {
    tc, err := ln.AcceptTCP()
    if err != nil {
        return
    }
    tc.SetKeepAlive(true) //发送心跳
    tc.SetKeepAlivePeriod(3 * time.Minute) //发送周期
    return tc, nil
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;4.server.Serve()方法调用tcpKeepAliveListener 对象的 Accept() 方法返回一个连接conn（该连接启动了心跳），并为每一个conn创建一个新的go程执行conn.server()方法：具体见代码中我加的注释说明&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wiz_cm_1508473254663_4163&quot; class=&quot;wiz-code-container&quot; data-mode=&quot;JavaScript&quot; data-theme=&quot;default&quot; readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:go;collapse:true;;gutter:true;&quot;&gt;
func (srv *Server) Serve(l net.Listener) error {
    defer l.Close()
    if fn := testHookServerServe; fn != nil {
        fn(srv, l)
    }
    var tempDelay time.Duration //重试间隔

    if err := srv.setupHTTP2_Serve(); err != nil {
        return err
    }

    srv.trackListener(l, true) //缓存该监听器
    defer srv.trackListener(l, false) //从缓存中删除当前监听器

    baseCtx := context.Background() 
    ctx := context.WithValue(baseCtx, ServerContextKey, srv) //新建一个context用来管理每个连接conn的Go程
    for {
        rw, e := l.Accept() //调用tcpKeepAliveListener对象的 Accept() 方法
        if e != nil {
            select {
            case &amp;lt;-srv.getDoneChan():
                return ErrServerClosed //退出Serve方法，并执行延迟调用（从缓存中删除当前监听器）
            default:
            }
            //如果发生了net.Error错误，则隔一段时间就重试一次，间隔时间每次翻倍，最大为1秒
            if ne, ok := e.(net.Error); ok &amp;amp;&amp;amp; ne.Temporary() {
                if tempDelay == 0 {
                    tempDelay = 5 * time.Millisecond
                } else {
                    tempDelay *= 2
                }
                if max := 1 * time.Second; tempDelay &amp;gt; max {
                    tempDelay = max
                }
                srv.logf(&quot;http: Accept error: %v; retrying in %v&quot;, e, tempDelay)
                time.Sleep(tempDelay)
                continue
            }
            return e
        }
        tempDelay = 0
        c := srv.newConn(rw) //该方法根据net.Conn、srv构造了一个新的http.conn类型
        c.setState(c.rwc, StateNew) //缓存该连接的状态，如果方法：Server.ConnState(net.Conn, ConnState)不为nil，就根据当前连接的状态执行它
        go c.serve(ctx)
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;5.而conn.server(&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;)方法会读取请求，然后根据conn内保存的server来构造一个serverHandler类型，并调用它的ServeHTTP()方法：serverHandler{c.server}.ServeHTTP(w, w.req)，该方法的源码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {
   handler := sh.srv.Handler
   if handler == nil {
      handler = DefaultServeMux
   }
   if req.RequestURI == &quot;*&quot; &amp;amp;&amp;amp; req.Method == &quot;OPTIONS&quot; {
      handler = globalOptionsHandler{}
   }
   handler.ServeHTTP(rw, req)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;6.如上源码可以看到，当 handler == nil 时使用默认的DefaultServeMux路由，否则使用在第1步中为Serve指定了的Handler；然后调用该Handler&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;的ServeHTTP方法（该Handler一般被设置为路由ServeMux类型）；&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;

&lt;p&gt;7.而路由ServeMux的ServeHTTP方法则会根据当前请求提供的信息来查找最匹配的Handler（这里为）：&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
    if r.RequestURI == &quot;*&quot; {
        if r.ProtoAtLeast(1, 1) {
            w.Header().Set(&quot;Connection&quot;, &quot;close&quot;)
        }
        w.WriteHeader(StatusBadRequest)
        return
    }
    h, _ := mux.Handler(r) //规范化请求的路径格式，查找最匹配的Handler
    h.ServeHTTP(w, r)
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;8.以上查找到的Handler接口值h就是我们事先注册到路由中与请求匹配的Handler；而h的动态类型是HandlerFunc类型（它也满足Handler接口）；&lt;/p&gt;
&lt;p&gt;所以，以上 h.ServeHTTP(w, r) 实际上调用的是接口值h中持有的动态值（也就是我们定义的处理函数）&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type HandlerFunc func(ResponseWriter, *Request)
//实现Handler接口的ServeHTTP方法
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r) //调用自身
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;至此，整个调用过程讲解完毕，至于业务层的处理逻辑，则由各个处理函数实现&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;四、重定向：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;http包自带了几个创建常用处理器的函数：FileServer，NotFoundHandler、RedirectHandler、StripPrefix、TimeoutHandler。&lt;br/&gt;而&lt;span&gt;RedirectHandler&lt;/span&gt;函数就是用来重定向的：它返回一个请求处理器，该处理器会对每个请求都使用状态码code重定向到网址url&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wiz_cm_1508473254663_3496&quot; class=&quot;wiz-code-container&quot; data-mode=&quot;JavaScript&quot; data-theme=&quot;default&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func main() {
  mux := http.NewServeMux()
  mux.Handle(&quot;/to&quot;,http.RedirectHandler(&quot;http://example.org&quot;, 307))
  err := http.ListenAndServe(*addr,mux) //启动监听
   if err != nil {
      log.Fatalln(&quot;ListenAndServe: &quot;, err)
   }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;好了，本文就暂时讲关于http包关于HTTP服务端方面的东西，至于客户端方面的就简单引用一下官方文档说明吧，毕竟客户端很少用Go实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;五、客户端的实现：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;32.5&quot;&gt;
&lt;p&gt;Get、Head、Post和PostForm函数&lt;span&gt;发出HTTP/ HTTPS请求&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
resp, err := http.Get(&quot;http://example.com/&quot;)
...
resp, err := http.Post(&quot;http://example.com/upload&quot;, &quot;image/jpeg&quot;, &amp;amp;buf)
...
resp, err := http.PostForm(&quot;http://example.com/form&quot;,
        url.Values{&quot;key&quot;: {&quot;Value&quot;}, &quot;id&quot;: {&quot;123&quot;}})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;程序在使用完回复后必须&lt;span&gt;关闭回复的主体&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
resp, err := http.Get(&quot;http://example.com/&quot;)
if err != nil {
        // handle error
}
defer resp.Body.Close()
body, err := ioutil.ReadAll(resp.Body)
// ...
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;要&lt;span&gt;管理&lt;/span&gt;HTTP客户端的头域、重定向策略和其他设置，&lt;span&gt;创建一个Client&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
client := &amp;amp;http.Client{
        CheckRedirect: redirectPolicyFunc,
}
resp, err := client.Get(&quot;http://example.com&quot;)
// ...
req, err := http.NewRequest(&quot;GET&quot;, &quot;http://example.com&quot;, nil)
// ...
req.Header.Add(&quot;If-None-Match&quot;, `W/&quot;wyzzy&quot;`)
resp, err := client.Do(req)
// ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要&lt;span&gt;管理&lt;/span&gt;&lt;span&gt;代理、TLS配置、keep-alive、压缩和其他设置，&lt;/span&gt;&lt;span&gt;创建一个Transport&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
tr := &amp;amp;http.Transport{
        TLSClientConfig:    &amp;amp;tls.Config{RootCAs: pool},
        DisableCompression: true,
}
client := &amp;amp;http.Client{Transport: tr}
resp, err := client.Get(&quot;https://example.com&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Client和Transport类型都可以安全的被多个go程同时使用。出于效率考虑，应该一次建立、尽量重用&lt;/span&gt;。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;以上如有误导的地方，请前辈们务必指出！&lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Fri, 20 Oct 2017 04:39:00 +0000</pubDate>
<dc:creator>SuriFuture</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/susufufu/p/7698900.html</dc:identifier>
</item>
<item>
<title>Java 多线程 - 陈凯冰</title>
<link>http://www.cnblogs.com/ckb58/p/7698813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ckb58/p/7698813.html</guid>
<description>[unable to retrieve full-text content]一、概述 理解多线程先要理解线程，理解线程先要理解进程。 1. 进程 一个正在执行的程序。 每个进程的执行都有一个执行的顺序，顺序是一个执行路径，也叫一个控制单元。 2. 线程 进程中独立的控制单元称为线程。 线程控制进程的执行。 进程中只要有一个线程在执行，进程就不会结束。 一个进程中至少存在一个</description>
<pubDate>Fri, 20 Oct 2017 04:00:00 +0000</pubDate>
<dc:creator>陈凯冰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ckb58/p/7698813.html</dc:identifier>
</item>
<item>
<title>ASP.NET没有魔法——ASP.NET MVC IoC - 7m鱼</title>
<link>http://www.cnblogs.com/selimsong/p/7682808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/selimsong/p/7682808.html</guid>
<description>&lt;p&gt;　　之前的文章介绍了MVC如何通过ControllerFactory及ControllerActivator创建Controller，而Controller又是如何通过ControllerBase这个模板完成了功能的拓展及业务的执行。这一系列MVC类型的设计处处都体现了IoC的设计原则，所以本章将从以下几点对ASP.NET MVC中的IoC进行介绍：&lt;br/&gt;　　● 什么是IoC&lt;br/&gt;　　● ASP.NET MVC中的IoC&lt;br/&gt;　　● 什么是DI&lt;br/&gt;　　● IoC容器与依赖解析器（Dependency Resolver）&lt;br/&gt;　　● ASP.NET MVC中使用DI&lt;/p&gt;
&lt;h2&gt;什么是IoC&lt;/h2&gt;
&lt;p&gt;　　IoC（控制反转，Inversion of Control）它是软件开发中的一种&lt;span&gt;设计原则&lt;/span&gt;，意思就是把控制权从自身(这里的自身大部分指代的是业务代码)转给其它对象来控制。IoC的意图是将任务的执行&lt;span&gt;从实现中解耦&lt;/span&gt;，可以专注于模块任务的设计(如：操作数据库的组件，可以有操作SQL Server和My SQL的)，系统本身不会关注这个模块做了什么，同时当系统&lt;span&gt;替换了这个模块后不会对系统造成影响&lt;/span&gt;。在软件开发中有几种常见的基于IoC思想的实现：&lt;br/&gt;　　● 工厂模式&lt;br/&gt;　　● 模板模式&lt;br/&gt;　　● 策略模式&lt;br/&gt;　　● 依赖注入&lt;/p&gt;
&lt;p&gt;　　以上模式都是将实现解耦，便于拓展。特别是依赖注入（DI，Dependency Injection），看到IoC更多想到的就依赖注入。&lt;br/&gt;　　依赖倒置原则（DIP）：上面说了那么多的实现，但有一个根本的原则就是依赖倒置原则&lt;strong&gt;“高层模块不依赖于低层模块，它们都应该依赖于抽象，抽象不应该依赖于实现，实现应该依赖于抽象”&lt;/strong&gt;。在.Net中就是使用接口和抽象类对业务和对象进行抽象，抽象与实现分开，如果放弃了这一原则实现依赖于实现，那么就反转不了了(lll￢ω￢)。&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC中的IoC&lt;/h2&gt;
&lt;p&gt;　　之前的文章中分析了ASP.NET MVC中Controller的创建过程和执行中主要的参与对象分别有：&lt;br/&gt;　　● DefaultControllerFactory：工厂模式。&lt;br/&gt;　　● DefaultControllerActivator：依赖注入(注：创建Controller时首先从依赖解析器中获取Controller实例，无法获取才自己创建)。&lt;br/&gt;　　● ControllerBase：模板模式(注：ControllerBase定义了Execute模板方法调用抽象方法ExecuteCore，ExecuteCore的实现在子类中)。&lt;/p&gt;
&lt;p&gt;　　这些对象的设计思想就是IoC。&lt;/p&gt;
&lt;h2&gt;什么是DI&lt;/h2&gt;
&lt;p&gt;　　DI（Dependency Injection，依赖注入），它其实是两个部分，第一个是“依赖”，然后才是“注入”。&lt;br/&gt;　　1. 依赖：简单来说就是需要，在面向对象的一个类里面它&lt;span&gt;“需要”&lt;/span&gt;其它类型来完成工作。如在MyBlog中的逻辑类需要仓储类来操作数据库，这种情况下就是逻辑类依赖仓储类：&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171020112125990-225811125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2. 注入：其实就是对类的依赖赋值，常用的注入的方式是：构造注入、属性注入、方法注入，说白了就是通过构造方法、属性(Setter方法)以及方法将依赖的对象传入类的实例中并赋值。但要注意的是这个“注”字，为什么不直接用赋值？&lt;br/&gt;　　举个栗子：制作一个水球，要么留一个注水口，要么在制作的时候把水灌入然后封死。&lt;br/&gt;　　对于有注水口的水球，在使用时如果注入红色的水，就变成了红色的水球，注入黄色的就是黄色的，而被封死的水球在制作时灌了什么颜色的水就是什么颜色的。&lt;br/&gt;　　而在程序开发中更是如此，以MyBlog为例，业务逻辑类通过仓储类来获取数据，业务类可以“封死”只用SQL Server的操作类，也可以开放，在运行时将数据操作这个实例“注入”，那么注入SQL Server操作类就使用SQL Server，注入MySQL的就使用My SQL。&lt;br/&gt;　　对水球注水首先要有水，其次是水球要有注水口，那么在程序里的“水”和“注水口”是什么？&lt;/p&gt;
&lt;h2&gt;IoC容器与依赖解析器（DependencyResolver）&lt;/h2&gt;
&lt;p&gt;　　在程序中所谓的“水”应该是那些抽象的实现，或者说实现了抽象的类型。比如操作SQL Server的仓储类和操作MySQL的仓储操作类。那么这些“水”要放在哪里？“水”当然要放在容器里，所以就有了IoC容器。&lt;br/&gt;　　那IoC容器是什么？它可以简单到只是一个实例的数组或字典，通过实例的类型（或实现的父类型、接口等）从这个字典或数组中获取对应的实例，也可以是像Autofac、Ninject这些复杂成熟的IoC容器组件。&lt;br/&gt;　　以下代码分别是AutoFac和NinJect官方文档中为容器注“水”的过程：&lt;br/&gt;　　Ninject：&lt;a href=&quot;https://github.com/ninject/ninject&quot; target=&quot;_blank&quot;&gt;https://github.com/ninject/ninject&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171020112228943-1756438323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　AutoFac：&lt;a href=&quot;https://autofac.org/&quot; target=&quot;_blank&quot;&gt;https://autofac.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171020112255740-2145055117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有了装满“水”的容器，想要把“水”注入到程序中，那就需要“注水口”依赖解析器（Denpendency Resolver）的支持。&lt;br/&gt;　　以下代码就是DefaultControllerActivator创建Controller的代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171020112322162-14470524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　想象一下，把上面的“注水口”连接到装满“水”的容器中，不是就能够把需要的东西注入到需要的位置吗？&lt;/p&gt;
&lt;h2&gt;ASP.NET MVC中使用DI&lt;/h2&gt;
&lt;p&gt;　　DI的使用有两个必要条件就&lt;span&gt;依赖容器&lt;/span&gt;和&lt;span&gt;依赖解析器&lt;/span&gt;，ASP.NET中建议使用成熟的依赖容器，如Autofac等，它们提供了强大的功能并支持多种组件注册到容器以及注入方式。而关于依赖解析器在ASP.NET MVC中是有默认解析器的，以下是ASP.NET MVC的解析器定义：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171020112403459-1794032691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　它实际的作用是通过Current属性获取一个IDependencyResolver的对象。&lt;br/&gt;　　DependencyResolver中内置了一些实现该接口的对象，但是几乎是无用的如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/640251/201710/640251-20171020112430771-1915530026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以一般情况下如果在ASP.NET中都是实现IDependencyResolver接口然后&lt;span&gt;通过DependencyResolver.SetResolver方法修改默认的依赖解析器&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　在ASP.NET MVC中，使用依赖注入最频繁的就是Controller，Controller作为业务逻辑执行的入口，它依赖业务逻辑的组件，而业务逻辑组件又依赖数据操作组件等等。所以在ASP.NET MVC中使用依赖注入实际上就是把Controller及其依赖都放入容器里，然后创建Controller时从容器中获取即可。根据Controller的创建流程将使用方法分为以下几种：&lt;br/&gt;　　1. 实现IDependencyResolver接口然后通过DependencyResolver.SetResolver方法修改默认的依赖解析器(&lt;span&gt;替换默认的“注水口”&lt;/span&gt;)。&lt;br/&gt;　　2. 实现IControllerActivator接口，然后在创建DefaultControllerFactory时将其以参数的形式传入到DefaultControllerFactory中(在ControllerActivator中&lt;span&gt;添加自己的“注水口”&lt;/span&gt;，并替换掉原有的ControllerActivator)。&lt;br/&gt;　　3. 继承DefaultControllerFactory使用从容器中获取Controller的方法将原有的GetControllerInstance方法替换掉（添加&lt;span&gt;“注水口”放置在ControllerFactory中&lt;/span&gt;，放弃ControllerActivator的使用）。&lt;/p&gt;
&lt;p&gt;　　注：由于在Controller类型中包含一个IDependencyResolver属性，所以方法2和方法3没有替换默认依赖解析器会导致Controller中使用该属性无法访问到真实的容器，如果需要在其基础上使用方法1将默认的依赖解析器替换掉。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　IoC容器和依赖注入在软件开发中是一个非常中要的概念，现在主流的一些开发框架的核心都是基于依赖注入的，即框架中的所有组件如日志、缓存、队列等都会通过容器将其注入到使用的地方。本章主要以文字的形式介绍了IoC、DI的概念及其在ASP.NET MVC中的使用的三种方法，在下一篇文章中将会用代码的形式介绍如何使用这三种方法在ASP.NET MVC中实现依赖注入。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://en.wikipedia.org/wiki/Inversion_of_control&quot; target=&quot;_blank&quot;&gt;https://en.wikipedia.org/wiki/Inversion_of_control&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文连接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ASP.NET没有魔法——ASP.NET MVC Controller&amp;amp;amp;IoC&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7682808.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/selimsong/p/7682808.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_7641799&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7641799.html&quot;&gt;ASP.NET没有魔法——目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;post_title_link_7698663&quot; href=&quot;http://www.cnblogs.com/selimsong/p/7698663.html&quot;&gt;ASP.NET没有魔法——ASP.NET MVC IoC代码篇&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 20 Oct 2017 03:53:00 +0000</pubDate>
<dc:creator>7m鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/selimsong/p/7682808.html</dc:identifier>
</item>
<item>
<title>打造自己的图表控件3 - 长蘑菇星人</title>
<link>http://www.cnblogs.com/cuifeipeng/p/7698760.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cuifeipeng/p/7698760.html</guid>
<description>&lt;p&gt;上期实现了数据投影的功能，现在就可以来实现坐标轴了。&lt;/p&gt;
&lt;p&gt;以前只是整个画板范围内进行绘制，现在如果要进行坐标轴绘制，就要给画板分不同区域。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const ChartArea =&lt;span&gt; {
    plot: &lt;/span&gt;'plot'&lt;span&gt;,
    xAxis: &lt;/span&gt;'xAxis'&lt;span&gt;,
    yAxis: &lt;/span&gt;'yAxis'&lt;span&gt;,
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后给 ChartElement 添加一个 area 属性 默认绘制到 plot 上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class ChartElement {
    ...
    get area() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ChartArea.plot
    }
    ...  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后实现一个 Axis ,area 默认到 xAxis，ticks 是刻度值的列表，labels 是刻度值字符串形式的列表。&lt;/p&gt;
&lt;p&gt;range 获得现在视场内值的范围。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Axis extends ChartElement {
    constructor() {
        super()
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._ticks =&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._labels =&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ticksCount = 20
        &lt;span&gt;this&lt;/span&gt;.ticksLength = 10&lt;span&gt;
    }
    get area() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ChartArea.xAxis
    }
    get ticks() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._ticks
    }
    get labels() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._labels
    }
    get range() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; viewport = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.viewport
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.area ==&lt;span&gt; ChartArea.yAxis) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [viewport.visible[1], viewport.visible[3&lt;span&gt;]]
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [viewport.visible[0], viewport.visible[2&lt;span&gt;]]
        }
    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div&gt;
&lt;p&gt;      calcTicks() { }&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;由于坐标轴有不同的表示方法，有的用时间表示，有的用离散的点表示，有的用连续的值表示。&lt;/p&gt;
&lt;p&gt;这里只实现连续的值画刻线的方法。 &lt;/p&gt;
&lt;p&gt;创建一个FloatAxis 类，继承Axis，然后实现 calcTicks 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class FloatAxis extends Axis {
    constructor() {
        super()
    }
    calcTicks() {
        let range &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.range
        let delta &lt;/span&gt;= range[1] - range[0&lt;span&gt;]
        let log &lt;/span&gt;=&lt;span&gt; Math.round(Math.log10(delta))
        let min, max
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (log &amp;gt; 0&lt;span&gt;) {
            let pow &lt;/span&gt;= Math.pow(10, log - 1&lt;span&gt;)
            min &lt;/span&gt;= Math.round(range[0] / pow) *&lt;span&gt; pow
            max &lt;/span&gt;= Math.round(range[1] / pow) *&lt;span&gt; pow
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            min &lt;/span&gt;= Math.round(range[0] * Math.pow(10, -log)) / Math.pow(10, -&lt;span&gt;log)
            max &lt;/span&gt;= Math.round(range[1] * Math.pow(10, -log)) / Math.pow(10, -&lt;span&gt;log)
        }
        let calcStep &lt;/span&gt;= (max - min) / &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ticksCount
        let step
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (log &amp;gt; 0&lt;span&gt;) {
            let pow &lt;/span&gt;= Math.pow(10, log - 1&lt;span&gt;)
            step &lt;/span&gt;= Math.round(calcStep / pow) *&lt;span&gt; pow
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            step &lt;/span&gt;= Math.round(calcStep * Math.pow(10, -log)) / Math.pow(10, -&lt;span&gt;log)
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (step == 0) step =&lt;span&gt; calcStep
        let ticks &lt;/span&gt;=&lt;span&gt; []
        let labels &lt;/span&gt;=&lt;span&gt; []
        let end &lt;/span&gt;= max +&lt;span&gt; step
        let x &lt;/span&gt;=&lt;span&gt; min
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (x &amp;lt;&lt;span&gt; end) {
            ticks.push(x)
            labels.push(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.formatLabel(x, log - 2&lt;span&gt;))
            x &lt;/span&gt;+=&lt;span&gt; step
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._ticks =&lt;span&gt; ticks
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._labels =&lt;span&gt; labels
    }
    formatLabel(value, log) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (log &amp;lt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value.toFixed(-&lt;span&gt;log)
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ~~value + &quot;&quot;&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 到这里 刻度 已经可以被计算出来了。&lt;/p&gt;
&lt;p&gt; 一共有两个坐标轴 X轴 和 Y 轴，于是 创建两个类，表示这两个轴&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class FloatHorizontalAxis extends FloatAxis {
    constructor() {
        super()
    }
    get area() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ChartArea.xAxis
    }
}
class FloatVerticalAxis extends FloatAxis {
    constructor() {
        super()
    }
    get area() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ChartArea.yAxis
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;坐标转换在 Viewport 中实现，所以为&lt;em&gt;Viewport &lt;/em&gt;添加两个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Viewport {
    ...
    transformX(x, [left, top, width, height]) {

        let visibleLeft &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.visible[0&lt;span&gt;]
        let visibleWidth &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.visible[2] -&lt;span&gt; visibleLeft

        let screenLeft &lt;/span&gt;=&lt;span&gt; left
        let screenWidth &lt;/span&gt;=&lt;span&gt; width

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; screenLeft + (x - visibleLeft) / visibleWidth *&lt;span&gt; screenWidth
    }
    transformY(y, [left, top, width, height]) {

        let visibleBottom &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.visible[1&lt;span&gt;]
        let visibleHeight &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.visible[3] -&lt;span&gt; visibleBottom

        let screenTop &lt;/span&gt;=&lt;span&gt; top
        let screenHeight &lt;/span&gt;=&lt;span&gt; height
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; screenTop + screenHeight - (y - visibleBottom) / visibleHeight *&lt;span&gt; screenHeight
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里基础已经构建完毕，开始实现画图的部分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class VerticalAxisDrawing extends FloatVerticalAxis {
    constructor() {
        super()
    }
    render(context, [left, top, width, height]) {
        context.beginPath()
        context.moveTo(left &lt;/span&gt;+&lt;span&gt; width, top)
        context.lineTo(left &lt;/span&gt;+&lt;span&gt; width, height)
        context.stroke()

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.calcTicks()
        let ticks &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ticks
        let labels &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.labels
        let ticksLength &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ticksLength

        context.save()
        context.font &lt;/span&gt;= '14px sans-serif'&lt;span&gt;
        let x &lt;/span&gt;= left + width -&lt;span&gt; ticksLength
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0, length = ticks.length; i &amp;lt; length; i++&lt;span&gt;) {
            let y &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.viewport.transformY(ticks[i], [left, top, width, height])
            context.beginPath()
            context.moveTo(x, y)
            context.lineTo(x &lt;/span&gt;+&lt;span&gt; ticksLength, y)
            context.stroke()
            context.fillText(labels[i], x &lt;/span&gt;- ticksLength - labels[i].length * 5, y + 7&lt;span&gt;)
        }
        context.restore()
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class HorizontalAxisDrawing extends FloatHorizontalAxis {
    constructor() {
        super()
    }
    render(context, [left, top, width, height]) {
        context.beginPath()
        context.moveTo(left, top)
        context.lineTo(left &lt;/span&gt;+&lt;span&gt; width, top)
        context.stroke()

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.calcTicks()
        let ticks &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ticks
        let labels &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.labels
        let ticksLength &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ticksLength

        context.save()
        context.font &lt;/span&gt;= '14px sans-serif'&lt;span&gt;
        let y &lt;/span&gt;=&lt;span&gt; top
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0, length = ticks.length; i &amp;lt; length; i++&lt;span&gt;) {
            let x &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.viewport.transformX(ticks[i], [left, top, width, height])
            context.beginPath()
            context.moveTo(x, y)
            context.lineTo(x, y &lt;/span&gt;+&lt;span&gt; ticksLength)
            context.stroke()
            context.fillText(labels[i], x &lt;/span&gt;- labels[i].length * 4, y + ticksLength + 14&lt;span&gt;)
        }
        context.restore()
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;距离成功只有一步了，现在开始改造 CanvasDrawing&lt;/p&gt;
&lt;p&gt;现在整个图像被分成3个部分，plot,xAxis,yAxis，所以给 CanvasDrawing 添加一个screens属性，表示不同的区域&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class CanvasDrawing {
    constructor(width, height) {
        ...
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.screens =&lt;span&gt; {
            [ChartArea.plot]: [&lt;/span&gt;50, 0, width - 50, height - 50&lt;span&gt;],
            [ChartArea.xAxis]: [&lt;/span&gt;50, height - 50, width - 50, 50&lt;span&gt;],
            [ChartArea.yAxis]: [&lt;/span&gt;0, 0, 50, height - 50&lt;span&gt;],
        }
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再添加获取要绘制的区域和尺寸的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class CanvasDrawing {
    ...
    getScreen(area) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.screens[area]
    }
    &lt;/span&gt;*&lt;span&gt; getArea() {
        yield ChartArea.xAxis
        yield ChartArea.yAxis
        yield ChartArea.plot
    }
     ...  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后实现一个过滤的方法获取在某区域内要绘制的元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class CanvasDrawing {
    ...
    &lt;/span&gt;*&lt;span&gt; getElements(chart, area) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; elements = chart.elements ||&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let element of elements.filter(e =&amp;gt; e.area == area &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isDrawElement(e))) {
            yield element
        }
    }
    isDrawElement(element) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [CanvasDrawingElement, HorizontalAxisDrawing, VerticalAxisDrawing]
            .some(type &lt;/span&gt;=&amp;gt; element &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; type)
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了能提高一点点性能，创建一个背景画布，先画到背景画布上，然后在画到要显示的画布上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class CanvasDrawing {
    constructor(width, height) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; canvas = &lt;span&gt;this&lt;/span&gt;.canvas = document.createElement(&quot;canvas&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;var view = this.view = document.createElement(&quot;canvas&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;
        canvas.width &lt;/span&gt;=&lt;span&gt; width
        canvas.height &lt;/span&gt;=&lt;span&gt; height
        &lt;span&gt;view.width &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= width
        view.height = height

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width =&lt;span&gt; width
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.context = canvas.getContext(&quot;2d&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;this.viewContext = view.getContext(&quot;2d&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;
        ...
    }
    init(dom) {
        dom.appendChild(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.view&lt;/span&gt;)
    }   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后 实现 &lt;em id=&quot;__mceDel&quot;&gt;renderChart 方法&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class CanvasDrawing {
    ...
    renderChart(chart) {
        let context &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context
        context.save()
        context.fillStyle &lt;/span&gt;= &quot;#ffffff&quot;&lt;span&gt;
        context.fillRect(&lt;/span&gt;0, 0, &lt;span&gt;this&lt;/span&gt;.width, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.height)
        context.restore()
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let area of &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getArea()) {
            let screen &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getScreen(area)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let element of &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getElements(chart, area)) {
                context.save()
                element.render(context, screen)
                context.restore()
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.viewContext.drawImage(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.canvas, ...screen, ...screen)
        }
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; width = 800
&lt;span&gt;var&lt;/span&gt; height = 600
&lt;span&gt;var&lt;/span&gt; dataCount = 1000
&lt;span&gt;var&lt;/span&gt; chart = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Chart()
chart.viewport.setVisible(&lt;/span&gt;0, -2, dataCount, 2&lt;span&gt;)

chart.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; VerticalAxisDrawing())
chart.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HorizontalAxisDrawing())
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; chartDrawing = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CanvasDrawing(width, height)
chartDrawing.init(document.body)
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lines =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let index = 0; index &amp;lt; 50; index++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lineDrawing = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LineDrawing()
    chart.add(lineDrawing)
    lines.push(lineDrawing);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; step = 0
&lt;span&gt;var&lt;/span&gt; begintime = +&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count = 0
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; run() {
    requestAnimationFrame(run)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; now = +&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()
    count &lt;/span&gt;= ((count + 1) % 16&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count == 0&lt;span&gt;) {
       console.log(&lt;/span&gt; ~~(1000 / (now -&lt;span&gt; begintime)))
    }
    begintime &lt;/span&gt;=&lt;span&gt; now
    step &lt;/span&gt;+= 1&lt;span&gt;
    chart.viewport.setVisible(step, &lt;/span&gt;-1 * lines.length, dataCount + step, 1 *&lt;span&gt; lines.length)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let j = 0; j &amp;lt; lines.length; j++&lt;span&gt;) {
        let lineDrawing &lt;/span&gt;=&lt;span&gt; lines[j]
        lineDrawing.data &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; dataCount; i++&lt;span&gt;) {
            lineDrawing.data.push(i &lt;/span&gt;+&lt;span&gt; step)
            lineDrawing.data.push((j&lt;/span&gt;+1) * Math.sin((step + i) * (360 * 4 / width) * Math.PI / 180&lt;span&gt;))
        }
    }
    chartDrawing.renderChart(chart)
}
run()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/778070/201710/778070-20171020114522177-904768575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/cuifeipeng/chart.zip&quot;&gt;下载&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 20 Oct 2017 03:50:00 +0000</pubDate>
<dc:creator>长蘑菇星人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cuifeipeng/p/7698760.html</dc:identifier>
</item>
<item>
<title>tensorflow入门(1) - tongqingliu</title>
<link>http://www.cnblogs.com/liutongqing/p/7698550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liutongqing/p/7698550.html</guid>
<description>&lt;h2 id=&quot;关于-tensorflow&quot;&gt;关于 TensorFlow&lt;/h2&gt;
&lt;p&gt;TensorFlow™ 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。&lt;/p&gt;
&lt;h3 id=&quot;关于数据流图data-flow-graph&quot;&gt;关于数据流图（Data Flow Graph）&lt;/h3&gt;
&lt;p&gt;数据流图用“结点”（nodes）和“线”(edges)的有向图来描述数学计算。“节点” 一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点/输出（push out）的终点，或者是读取/写入持久变量（persistent variable）的终点。“线”表示“节点”之间的输入/输出关系。这些数据“线”可以输运“size可动态调整”的多维数据数组，即“张量”（tensor）。张量从图中流过的直观图像是这个工具取名为“Tensorflow”的原因。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.tensorfly.cn/images/tensors_flowing.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;windows下安装tensorflow&quot;&gt;windows下安装TensorFlow&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;python35&lt;/span&gt; -m pip install --upgrade tensorflow&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过&lt;code&gt;import tensorflow&lt;/code&gt;来查看是否安装成功，如果没有报错，则安装成功，否则安装失败。&lt;/p&gt;
&lt;p&gt;但是真正运行的时候，会出现这样一个问题，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;The TensorFlow library wasn't compiled to use AVX2 instructions, but these are available on your machine and could speed up CPU computations.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不知道为什么会这样，暂时没有找到更好的解决办法，只好通过以下方式把它屏蔽掉。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import os
os.environ['TF_CPP_MIN_LOG_LEVEL']='2'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;例子生成三维数据-然后用平面拟合它&quot;&gt;例子：生成三维数据, 然后用平面拟合它&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; tensorflow &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; tf
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; np

&lt;span class=&quot;co&quot;&gt;# 使用 NumPy 生成假数据(phony data), 总共 100 个点.&lt;/span&gt;
x_data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.float32(np.random.rand(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;))     &lt;span class=&quot;co&quot;&gt;# 随机输入，横坐标&lt;/span&gt;
y_data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.dot([&lt;span class=&quot;fl&quot;&gt;0.100&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.200&lt;/span&gt;], x_data) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.300&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;# 纵坐标&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 构造一个线性模型&lt;/span&gt;
b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable(tf.zeros([&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;])) &lt;span class=&quot;co&quot;&gt;# 变量&lt;/span&gt;
W &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable(tf.random_uniform([&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;], &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;))
y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.matmul(W, x_data) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; b   &lt;span class=&quot;co&quot;&gt;# 矩阵乘法&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 最小化方差&lt;/span&gt;
loss &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.reduce_mean(tf.square(y &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; y_data))
optimizer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.train.GradientDescentOptimizer(&lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 使用梯度下降法&lt;/span&gt;
train &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; optimizer.minimize(loss)

&lt;span class=&quot;co&quot;&gt;# 初始化变量&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# init = tf.initialize_all_variables()   # 旧式初始化变量方法&lt;/span&gt;
init &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.global_variables_initializer() &lt;span class=&quot;co&quot;&gt;# 新式初始化变量方法&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 启动图 (graph)&lt;/span&gt;
sess &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Session()
sess.run(init)

&lt;span class=&quot;co&quot;&gt;# 拟合平面&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; step &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;201&lt;/span&gt;):
    sess.run(train)
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; step &lt;span class=&quot;op&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;次数:&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(step) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot; W=&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(sess.run(W)) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot; b=&quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(sess.run(b)))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;次数:0 W=[[ 0.55211174 -0.32715654]] b=[ 0.62308812]
次数:20 W=[[ 0.16676502  0.045885  ]] b=[ 0.33775851]
次数:40 W=[[ 0.11121924  0.16110057]] b=[ 0.31255469]
次数:60 W=[[ 0.10111912  0.18986556]] b=[ 0.30423936]
次数:80 W=[[ 0.09974308  0.19725847]] b=[ 0.3014473]
次数:100 W=[[ 0.09976034  0.19922698]] b=[ 0.30049789]
次数:120 W=[[ 0.09988155  0.19977264]] b=[ 0.30017218]
次数:140 W=[[ 0.09995059  0.19993046]] b=[ 0.30005974]
次数:160 W=[[ 0.09998091  0.19997799]] b=[ 0.30002078]
次数:180 W=[[ 0.09999289  0.19999282]] b=[ 0.30000725]
次数:200 W=[[ 0.09999744  0.19999765]] b=[ 0.30000252]
[Finished in 1.7s]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;tensorflow中的session-加减乘除-类型转换&quot;&gt;tensorflow中的Session, 加减乘除, 类型转换&lt;/h2&gt;
&lt;h3 id=&quot;session&quot;&gt;Session&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; tensorflow &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; tf
&lt;span class=&quot;co&quot;&gt;# 并没有得到想要的结果&lt;/span&gt;
a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.add(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(a)

&lt;span class=&quot;co&quot;&gt;# Session写法一&lt;/span&gt;
sess &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Session()
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sess.run(a))
sess.close()
&lt;span class=&quot;co&quot;&gt;# Session写法二&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; sess:
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sess.run(a))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Tensor(&quot;Add:0&quot;, shape=(), dtype=int32)
8
8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tensorflow的每个session是相互独立的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;W &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
sess1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Session()
sess2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Session()
sess1.run(W.initializer)
sess2.run(W.initializer)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sess1.run(W.assign_add(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;))) &lt;span class=&quot;co&quot;&gt;# &amp;gt;&amp;gt; 20&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sess2.run(W.assign_sub(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;))) &lt;span class=&quot;co&quot;&gt;# &amp;gt;&amp;gt; 8&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sess1.run(W.assign_add(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;))) &lt;span class=&quot;co&quot;&gt;# &amp;gt;&amp;gt; 120&lt;/span&gt;
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sess2.run(W.assign_sub(&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;))) &lt;span class=&quot;co&quot;&gt;# &amp;gt;&amp;gt; -42&lt;/span&gt;
sess1.close()
sess2.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;加减乘除以及类型转换&quot;&gt;加减乘除以及类型转换&lt;/h3&gt;
&lt;p&gt;上面是一个加法的示例，下面看看加减乘除的示例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.add(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 加法：7&lt;/span&gt;
b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.subtract(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 减法：6&lt;/span&gt;
c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.multiply(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 乘法：10&lt;/span&gt;
d &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.div(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# 除法：2&lt;/span&gt;
e &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.subtract(tf.cast(tf.constant(&lt;span class=&quot;fl&quot;&gt;2.0&lt;/span&gt;), tf.int32), tf.constant(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))   &lt;span class=&quot;co&quot;&gt;# 类型转换：1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;常数类型constant-types&quot;&gt;常数类型(Constant types)&lt;/h2&gt;
&lt;p&gt;通过以下方式建立常数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;tf.constant(value, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, shape&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'Const'&lt;/span&gt;, verify_shape&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立一维向量和矩阵，然后将它们乘起来:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.constant([&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;], name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.constant([[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;], [&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]], name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.multiply(a, b, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'dot_production'&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; sess:
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sess.run(x))
[[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;]
    [&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;]]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特殊常量的创建：&lt;br/&gt;tensorflow的很多操作和numpy很像。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;tf.zeros(shape, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;tf.float32, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;)
tf.zeros_like(input_tensor, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, optimize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)
tf.ones(shape, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;tf.float32, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;)
tf.ones_like(input_tensor, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, optimize&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)
tf.fill(dims, value, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; sess = tf.Session()
&amp;gt;&amp;gt;&amp;gt; print(sess.run(tf.zeros(3)))
[ 0.  0.  0.]
&amp;gt;&amp;gt;&amp;gt; print(sess.run(tf.ones([2,3])))
[[ 1.  1.  1.]
 [ 1.  1.  1.]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建序列：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;tf.linspace(start, stop, num, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;)
tf.&lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(start, limit&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, delta&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'range'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上示例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; tf.linspace(&lt;span class=&quot;fl&quot;&gt;10.0&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;13.0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;)
[&lt;span class=&quot;fl&quot;&gt;10.0&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;11.0&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;12.0&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;13.0&lt;/span&gt;]
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; tf.&lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, limit&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt;, delta&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意这里的序列不能迭代：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; tf.&lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;): &lt;span class=&quot;co&quot;&gt;# TypeError&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;产生随机数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;tf.random_normal(shape, mean&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.0&lt;/span&gt;, stddev&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;tf.float32, seed&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;)
tf.truncated_normal(shape, mean&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.0&lt;/span&gt;, stddev&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;tf.float32, seed&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;,
name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;)
tf.random_uniform(shape, minval&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, maxval&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;tf.float32, seed&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;,
name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;)
tf.random_shuffle(value, seed&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;)
tf.random_crop(value, size, seed&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;)
tf.multinomial(logits, num_samples, seed&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;)
tf.random_gamma(shape, alpha, beta&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;tf.float32, seed&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tensorflow和numpy的数据类型可以通用，比如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; np
&lt;span class=&quot;op&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; tf.ones([&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;], np.float32)
[[&lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;], [&lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;1.0&lt;/span&gt;]]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;变量variable&quot;&gt;变量(Variable)&lt;/h2&gt;
&lt;p&gt;在计算图的定义当中，如果常量过多，会使得加载计算图变得非常慢，同时常量的值不可改变，所以需要引入变量。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'scalar'&lt;/span&gt;)
b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable([&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;], name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'vector'&lt;/span&gt;)
c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable([[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;], [&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]], name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'matrix'&lt;/span&gt;)
d &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable(tf.zeros([&lt;span class=&quot;dv&quot;&gt;784&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;]), name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'weight'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;变量的几个操作：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable()
x.initializer &lt;span class=&quot;co&quot;&gt;# 初始化&lt;/span&gt;
x.&lt;span class=&quot;bu&quot;&gt;eval&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;# 读取里面的值&lt;/span&gt;
x.assign() &lt;span class=&quot;co&quot;&gt;# 分配值给这个变量&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;变量初始化&quot;&gt;变量初始化&lt;/h3&gt;
&lt;p&gt;在使用变量之前必须对其进行初始化，初始化可以看作是一种变量的分配值操作。&lt;strong&gt;最简单的初始化方式是一次性初始化所有的变量&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;init &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.global_variables_initializer()
&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; sess:
    sess.run(init)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以对某一部分变量进行初始化:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;init_ab &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.variable_initializer([a, b], name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'init_ab'&lt;/span&gt;)
&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; sess:
    sess.run(init_ab)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者是对某一个变量进行初始化:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;w &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable(tf.zeros([&lt;span class=&quot;dv&quot;&gt;784&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;]))
&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; sess:
    sess.run(w.initializer)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;打印变量&quot;&gt;打印变量&lt;/h3&gt;
&lt;p&gt;打印变量值的两种方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;w &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable(tf.truncated_normal([&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;], name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'normal'&lt;/span&gt;))
&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; sess:
    sess.run(w.initializer)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(w.&lt;span class=&quot;bu&quot;&gt;eval&lt;/span&gt;()) &lt;span class=&quot;co&quot;&gt;# 方法一&lt;/span&gt;
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sess.run(w)) &lt;span class=&quot;co&quot;&gt;# 方法二&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;给变量分配值&quot;&gt;给变量分配值&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; tensorflow &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; tf

&lt;span class=&quot;co&quot;&gt;# 没有run assign&lt;/span&gt;
w &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
w.assign(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)
&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; sess:
    sess.run(w.initializer)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(w.&lt;span class=&quot;bu&quot;&gt;eval&lt;/span&gt;())

&lt;span class=&quot;co&quot;&gt;# run assign&lt;/span&gt;
w &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; tf.Variable(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
wa &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; w.assign(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)
&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; tf.Session() &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; sess:
    sess.run(w.initializer)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(w.&lt;span class=&quot;bu&quot;&gt;eval&lt;/span&gt;())
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(sess.run(wa))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码有三个print，程序运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;10
10
100
[Finished in 1.5s]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tensorfly.cn/&quot; class=&quot;uri&quot;&gt;http://www.tensorfly.cn/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://sherlockliao.github.io/2017/08/21/cs20si2/&quot; class=&quot;uri&quot;&gt;https://sherlockliao.github.io/2017/08/21/cs20si2/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 20 Oct 2017 03:20:00 +0000</pubDate>
<dc:creator>tongqingliu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liutongqing/p/7698550.html</dc:identifier>
</item>
</channel>
</rss>