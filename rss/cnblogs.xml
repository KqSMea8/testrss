<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C#控件基础 - Dream_saddle</title>
<link>http://www.cnblogs.com/dream-saddle/p/7704966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dream-saddle/p/7704966.html</guid>
<description>&lt;p&gt;　　在说控件之前，还是有必要说一下如何创建项目的。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;现在我们就不用创建控制台应用程序了，而是文件&amp;gt;新建&amp;gt;C#&amp;gt;Windows窗体应用程序。名称，位置自己选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021141757787-613654411.png&quot; alt=&quot;&quot; width=&quot;992&quot; height=&quot;598&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　创建好了大致就是这样了，可能因为VS版本不同或者个人设置不同，有的东西的位置不一样，但都是可以找到的。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021142215318-1481209534.png&quot; alt=&quot;&quot; width=&quot;941&quot; height=&quot;459&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里的Form1就是一个窗体应用了。我们可以在上面添加一些控件。不过，还是先说说它的一些基本属性吧！&lt;/p&gt;
&lt;p&gt;　　它的属性在这里：(如果没有直接显示属性这一栏，我们可以鼠标右边点击这个窗体，然后下面就有个属性)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021142649131-1587669432.png&quot; alt=&quot;&quot; width=&quot;782&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　&lt;strong&gt;属性：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　name:窗体名字&lt;/p&gt;
&lt;p&gt;　　　　Text：窗体标题(我这里是Form1，所以左上角显示的就是Form1)&lt;/p&gt;
&lt;p&gt;　　　　StartPosition:窗体最开始出现的位置（我们一般只用它里面的CenterScreen值，就是居于屏幕正中）&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021143152209-1905169953.png&quot; alt=&quot;&quot; width=&quot;752&quot; height=&quot;130&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　我们只需找到这个属性，然后点击对应后面的箭头就可以选值了，其他的属性也一样。&lt;/p&gt;
&lt;p&gt;　　　　MaxmizeBox:是否允许最大化，True代表允许，False代表不允许&lt;/p&gt;
&lt;p&gt;　　　　MinmizeBox:是否允许最小化，True代表允许，False代表不允许&lt;/p&gt;
&lt;p&gt;　　　　HelpButton:是否显示帮助按钮。注意：只有在最大化和最小化两个按钮都不存在的情况下才能使用帮助按钮。&lt;/p&gt;
&lt;p&gt;　　　　FormBorderStyle:值FixedSigle表示运行起来不能调整窗体大小。用过QQ的人都知道，QQ的登陆界面是不能自己调整大小的。&lt;/p&gt;
&lt;p&gt;　　　　另外就还有BackColor之类的，但是一般不会去用它，因为我们是可以还皮肤的。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;控件：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　控件在何处？在工具箱里面，选择公共控件，这里面就是一些控件。(如果没有看见工具箱，那就点击视图下面的工具箱，或者按快捷键Crtl+X)&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021144029881-1836835705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　如何添加控件：我们只需将要添加的控件选中，然后用鼠标拖到窗体上的合适位置就可以了。&lt;/p&gt;
&lt;p&gt;　　　　常用控件:(我们新建了一个控件之后，都会给他重新命名，所以，我们一般会为他加上一个前缀，方便后面使用)&lt;/p&gt;
&lt;p&gt;　　　　　　　　label:存放文本，命名前缀：lbl&lt;/p&gt;
&lt;p&gt;　　　　　　　　TextBox:文本框，命名前缀:txt&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　常用属性：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　maxlength:可输入的最大长度&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　passwordchar:设置为密码框&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　Text:文本框里的值(内容)&lt;/p&gt;
&lt;p&gt;　　　　　　　　RadioButton:单选按钮，命名前缀：rdo&lt;/p&gt;
&lt;p&gt;　　　　　　　　CheckBox:多选按钮，命名前缀：chk&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　常用属性：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　checked:是否默认选中&lt;/p&gt;
&lt;p&gt;　　　　　　　　ComboBox:下拉列表框，命名前缀：cbo&lt;/p&gt;
&lt;p&gt;　　　　　　　　Button:按钮，命名前缀:btn&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　常用属性：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　Text：按钮的文本，相当于就是按钮上面的提示文字&lt;/p&gt;
&lt;p&gt;　　　　更改控件的属性和更改窗体的属性的方法一样。&lt;/p&gt;
&lt;p&gt;　　　　事件&lt;/p&gt;
&lt;p&gt;　　　　　　有了控件，那就得有事件。什么是事件呢？比如我们点击一下一个按钮，就会出现某种效果，这个就叫一个事件。&lt;/p&gt;
&lt;p&gt;　　　　　　举个例子： 我们创建一个窗体，然后添加一个button控件，没点击一次，窗体的背景颜色就换一次。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　首先，我们要创建一个控件。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021145739302-236582057.png&quot; alt=&quot;&quot; width=&quot;877&quot; height=&quot;486&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　然后，我们就要写代码来实现这个功能。&lt;/p&gt;
&lt;p&gt;　　　　　　那么在哪里写代码呢？双击刚刚创建的控件就可以了。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021150402506-1325507183.png&quot; alt=&quot;&quot; width=&quot;888&quot; height=&quot;547&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　代码写好后运行起来就是：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021151223334-974351807.png&quot; alt=&quot;&quot; width=&quot;971&quot; height=&quot;402&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　点击一下：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021151301099-319630206.png&quot; alt=&quot;&quot; width=&quot;973&quot; height=&quot;352&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　再点一下：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021151336365-2044834168.png&quot; alt=&quot;&quot; width=&quot;975&quot; height=&quot;521&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　反正我每点击一下，就会变一种颜色。&lt;/p&gt;
&lt;p&gt;　　　　代码如下：（我相信这点代码有点基础的都看得懂的）&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Forms;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WindowsFormsApplication1
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Form1 : Form
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Form1()
        {
            InitializeComponent();
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) 
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.BackColor = Color.Red;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this指向一个属性&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.BackColor =&lt;span&gt; Color.Blue;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.BackColor =&lt;span&gt; Color.Yellow;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (i == &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.BackColor =&lt;span&gt; Color.Pink;
            }
                i&lt;/span&gt;++&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　对于控件这个东西，就是自己去多加联系。&lt;/p&gt;
&lt;p&gt;　　　　例子2：我们创建一个文本框，和一个按钮，在文本框中输入内容，然后弹出一个消息框显示输入的内容是什么。&lt;/p&gt;
&lt;p&gt;　　　　窗体设计：这里我把文本框的名字改为了txtEnter，按钮的名字改为了btnXianShi 。命名用驼峰命名法&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021152359677-1828476214.png&quot; alt=&quot;&quot; width=&quot;908&quot; height=&quot;508&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　写代码控制事件：我们只需添加一个点击事件就可以了，如果文本框为空，就提示输入内容，文本框不为空，就弹窗输出。所以就双击button控件添加事件。&lt;/p&gt;
&lt;p&gt;　　　　运行起来，当我不输入内容的时候就会提示我还没输入内容：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021153902021-1428538718.png&quot; alt=&quot;&quot; width=&quot;833&quot; height=&quot;478&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　当我输入内容后：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1226851/201710/1226851-20171021154023881-2079633921.png&quot; alt=&quot;&quot; width=&quot;847&quot; height=&quot;568&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Forms;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WindowsFormsApplication1
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Form2 : Form
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Form2()
        {
            InitializeComponent();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnXianShi_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先判断文本框是否有内容
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有内容&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.txtEnter.Text == &lt;span&gt;&quot;&quot;&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里括号里的意思就是：this.指向txtEnter这个文本框.Text就是指向文本框中的内容 == 空&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 *弹窗提示
                 *MessagesBox.Show();就是个方法
                 *它里面有四个值：第一个是输出的内容，第二个是左上角的标题，第三个是下面的按钮，第四个是图标
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你还没输入内容&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;温馨提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,MessageBoxButtons.OK,MessageBoxIcon.Information);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让光标回到文本框中，方便输入&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.txtEnter.Focus();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写上return的作用就是阻止代码往下执行，只有当文本框中有内容才可以往下执行&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有内容
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹窗显示
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这次弹窗输出的内容就是刚刚文本框中的内容，所以，写上this.txtEnter.Text即可&lt;/span&gt;
            MessageBox.Show(&lt;span&gt;this&lt;/span&gt;.txtEnter.Text,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内容&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,MessageBoxButtons.OK,MessageBoxIcon.Information);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　在上面这个例子中，我们还可以删除文本框中的内容。大致流程就是：添加一个按钮，然后在这个按钮里面写一个删除事件，就是当点击按钮时，文本框中的内容就变为空值，这里怎么变空值就可以借鉴一下上面代码中的判断空值处的代码。&lt;/p&gt;
&lt;p&gt;　　这个我就不做了，你来试试吧！&lt;/p&gt;
&lt;p&gt;　　　　如果有不懂得地方可以问我哟！QQ：1289747698，邮箱：taohankkkkl.outlook.com，留言也可以哦！&lt;/p&gt;
</description>
<pubDate>Sat, 21 Oct 2017 07:47:00 +0000</pubDate>
<dc:creator>Dream_saddle</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dream-saddle/p/7704966.html</dc:identifier>
</item>
<item>
<title>Spring高级装配 - 宇的季节</title>
<link>http://www.cnblogs.com/chenkeyu/p/7704940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenkeyu/p/7704940.html</guid>
<description>&lt;h3&gt;目录&lt;/h3&gt;
&lt;p&gt;一、&lt;strong&gt;Profile&lt;span&gt;（根据开发环境创建对应的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二、&lt;strong&gt;&lt;span&gt;条件化的创建&lt;/span&gt;bean&lt;span&gt;（根据条件创建&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三、&lt;strong&gt;&lt;span&gt;处理自动装配歧义性（指定首选&lt;/span&gt;bean&lt;span&gt;、限定符限制&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;四、&lt;strong&gt;Bean&lt;span&gt;的作用域（单例、原型、会话、请求）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;五、&lt;strong&gt;&lt;span&gt;配置文件信息注入（&lt;/span&gt;.properties&lt;span&gt;文件的使用，&lt;/span&gt;&lt;span&gt;SpEL&lt;/span&gt;&lt;span&gt;的使用）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;一、&lt;strong&gt;&lt;span&gt;根据开发环境创建对应的&lt;/span&gt;bean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在一个项目的开发过程中，一般要经过开发、测试、生产等三个阶段，分别对应三种环境。因为在各个环境可能数据库配置、加密算法等的不同，所以将应用从一个环境迁移到另一个环境就变成了一个很大的挑战。&lt;/p&gt;
&lt;p&gt;　　Spring&lt;span&gt;在&lt;/span&gt;&lt;span&gt;3.1&lt;/span&gt;&lt;span&gt;版本中引入&lt;/span&gt;&lt;span&gt;bean profile&lt;/span&gt;&lt;span&gt;的功能。在使用&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;时，可以将不同的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;整理到一个或多个&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;中，当应用部署到某个环境时，这个环境对应的&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;就会处于与激活（&lt;/span&gt;&lt;span&gt;active&lt;/span&gt;&lt;span&gt;）状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;span&gt;配置&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;Java&lt;span&gt;中使用&lt;/span&gt;&lt;span&gt;@Profile&lt;/span&gt;&lt;span&gt;注解指定某个&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;属于哪个&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果是&lt;/span&gt;JavaConfig&lt;span&gt;配置&lt;/span&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span&gt;。我们可以在配置类上添加&lt;/span&gt;&lt;span&gt;@Profile&lt;/span&gt;&lt;span&gt;，来指定当前的配置类中所有的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;Profile&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果是&lt;/span&gt;XML&lt;span&gt;配置&lt;/span&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span&gt;。可以在&lt;/span&gt;&lt;span&gt;&amp;lt;beans&amp;gt;&lt;/span&gt;&lt;span&gt;中添加&lt;/span&gt;&lt;span&gt;profile=&lt;/span&gt;”xx”&lt;span&gt;，来指定标签中的所有&lt;/span&gt;&amp;lt;bean&amp;gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;span&gt;激活&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　激活&lt;/span&gt;Profile&lt;span&gt;需要依赖两个属性&lt;/span&gt;&lt;span&gt;spring.profiles.active&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;spring.profiles.default&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果设置了&lt;/span&gt;active&lt;span&gt;属性，&lt;/span&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span&gt;会用此确定哪些&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;会被激活（&lt;/span&gt;&lt;span&gt;active&lt;/span&gt;&lt;span&gt;可以指定多个）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果没有设置&lt;/span&gt;active&lt;span&gt;属性，&lt;/span&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span&gt;会使用&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果都没有设置，&lt;/span&gt;Spring&lt;span&gt;只会创建没有指定&lt;/span&gt;&lt;span&gt;Profile&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以通过在&lt;/span&gt;&lt;span&gt;web.xml&lt;/span&gt;&lt;span&gt;设置这个两个值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&amp;lt;web-app xxx&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&amp;lt;!--在上下文中添加默认&lt;/span&gt;profile--&amp;gt;&lt;/p&gt;
&lt;p&gt;　　&amp;lt;context-param&amp;gt;&lt;/p&gt;
&lt;p&gt;　　&amp;lt;param-name&amp;gt;spring.profiles.default&amp;lt;/param-name&amp;gt;&lt;/p&gt;
&lt;p&gt;　　&amp;lt;param-name&amp;gt;dev&amp;lt;/param-value&amp;gt;&lt;/p&gt;
&lt;p&gt;　　&amp;lt;/context-param&amp;gt;&lt;/p&gt;
&lt;p&gt;　　&amp;lt;servlet&amp;gt;&lt;/p&gt;
&lt;p&gt;　　......&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&amp;lt;!--为&lt;/span&gt;servlet&lt;span&gt;设置默认&lt;/span&gt;&lt;span&gt;profile--&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&amp;lt;init-param&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　&amp;lt;param-name&amp;gt;spring.profiles.default&amp;lt;/param-name&amp;gt;&lt;/p&gt;
&lt;p&gt;　　　　&amp;lt;param-name&amp;gt;dev&amp;lt;/param-value&amp;gt;&lt;/p&gt;
&lt;p&gt;　　&amp;lt;/init-param&amp;gt;&lt;/p&gt;
&lt;p&gt;　　&amp;lt;/servlet&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/web-app&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当&lt;/span&gt;Spring&lt;span&gt;启动时，指定了对应的&lt;/span&gt;&lt;span&gt;Profile&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;会被创建,&lt;/span&gt;如果一个&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;没有指定&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;，则它总会被创建。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;二、&lt;strong&gt;&lt;span&gt;条件化的创建&lt;/span&gt;bean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Spring4.x&lt;span&gt;之后，引入&lt;/span&gt;&lt;span&gt;@Conditional&lt;/span&gt;&lt;span&gt;注解，来实现&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;只有满足某个条件才创建。如果给定条件计算为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;，就会创建这个&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　@Conditional&lt;span&gt;中需要传入一个类类型，而这个类需要实现&lt;/span&gt;&lt;span&gt;Condition&lt;/span&gt;&lt;span&gt;接口；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Public interface Condition{&lt;/p&gt;
&lt;p&gt;　　　　Boolean matches(ConditionContext ctxt,AnnotatedTypeMetadata metadata);&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　此接口只有一个&lt;/span&gt;matches&lt;span&gt;方法，两个形参&lt;/span&gt;&lt;span&gt;ConditionContext&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;AnnotatedTypeMetadata&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　ConditionContext&lt;span&gt;对象可以做如下的事&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　getRegistry()&lt;span&gt;返回的对象可以检查&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;的注册情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　getBeanFactory&lt;span&gt;返回的对象可以检查&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;是否存在，探查&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;的属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　getEnvironment&lt;span&gt;返回的对象可以检查环境变量是否存在和值是多少&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　getResourceLoader&lt;span&gt;返回的对象可以获取加载的资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　AnnotatedTypeMetadata&lt;span&gt;对象能检查带有&lt;/span&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;span&gt;注解的方法还有什么其他的注解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三、&lt;strong&gt;处理自动装配歧义性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Spring&lt;span&gt;的自动装配可以给应用开发带来很大的便利，但是&lt;a href=&quot;http://www.cnblogs.com/chenkeyu/p/7699946.html&quot; target=&quot;_blank&quot;&gt;上一章&lt;/a&gt;中可以知道，如果在注入时使用接口，变量名也是接口名，且实现该接口的&lt;/span&gt;&lt;span&gt;Bean&lt;/span&gt;&lt;span&gt;有多个时，注入会出现错误。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于这种情况，&lt;/span&gt;Spring&lt;span&gt;提供两种方案来解决问题。在可选的多个&lt;/span&gt;&lt;span&gt;Bean&lt;/span&gt;&lt;span&gt;中设置某一个为首选的&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;或者使用限定符来将&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;的选择范围缩小。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;设置首选&lt;/span&gt;Bean&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　　　在&lt;/span&gt;JavaConfig&lt;span&gt;中给生成&lt;/span&gt;&lt;span&gt;Bean&lt;/span&gt;&lt;span&gt;的函数添加&lt;/span&gt;&lt;span&gt;@Primary&lt;/span&gt;&lt;span&gt;注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在&lt;/span&gt;XML&lt;span&gt;中给&lt;/span&gt;&lt;span&gt;&amp;lt;bean&amp;gt;&lt;/span&gt;&lt;span&gt;中添加&lt;/span&gt; &lt;span&gt;primary=&lt;/span&gt;”true”属性&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　在&lt;/span&gt;@Component&lt;span&gt;注解后添加&lt;/span&gt;&lt;span&gt;@Primary&lt;/span&gt;&lt;span&gt;注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　设置首选&lt;/span&gt;Bean&lt;span&gt;是一个非常方便的方式，但是当我们标志了多个首选&lt;/span&gt;&lt;span&gt;Bean&lt;/span&gt;&lt;span&gt;时，就会无法工作。所以解决歧义问题更强大的方式是限定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;注：在使用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;@Primary&lt;span&gt;进行设置首选&lt;/span&gt;&lt;span&gt;Bean&lt;/span&gt;&lt;span&gt;时，发现会出现&lt;/span&gt;&lt;span&gt;@Primary&lt;/span&gt;&lt;span&gt;检测不到的情况，我将文件删除后重新写发现又可以检测到了，不知道是不是&lt;/span&gt;&lt;span&gt;IDE&lt;/span&gt;&lt;span&gt;缓存的问题，有待考证。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;2.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;限定自动装配&lt;/span&gt;bean&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;2.1在添加@Autowired注解实现自动注入时，我们可以再添加一个@Qualifier(“id”)注解，其中传入我们想注入的bean的id。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;2.2在添加@Component注解生成Bean时添加@Qualifier(“特征词”)注解，为这个Bean分配一个特征词，这时就可以在注入时根据特征词来限定装配。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;2.3当多个Bean有相同的特征词的时候，依然会出现问题，那么我们就可以自定义限定符注解来实现一个Bean有多个特征词：&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　　　&lt;span&gt;@Target({ElementType.CONSTRUCTOR,ElementType.FIELD,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　ElementType.METHODElementType.TYPE})&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Retention(RetentionPolicy.RUNTIME)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　@Qualifier&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　Public  @interface  此处填写特征词{}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这时就可以在生成&lt;/span&gt;Bean&lt;span&gt;时添加多个特征词注解，然后在注入时同时可以添加多个注解，直到将范围缩小到只有一个&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、Bean&lt;span&gt;的作用域&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Spring&lt;span&gt;应用上下文中生成的&lt;/span&gt;&lt;span&gt;Bean&lt;/span&gt;&lt;span&gt;默认都是单例形式的，然而在应用中有些类是易变的，&lt;/span&gt;&lt;span&gt;会保持一些状态，因此如果是单例的就会造成问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Spring&lt;span&gt;定义多个作用域，可以基于这些作用域来创建&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　单例（&lt;/span&gt;Singleton&lt;span&gt;）：在应用中只创建一个实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原型（&lt;/span&gt;Prototype&lt;span&gt;）：每次注入或通过&lt;/span&gt;&lt;span&gt;Spring&lt;/span&gt;&lt;span&gt;应用上下文获取时创建一个新实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　会话（&lt;/span&gt;Session&lt;span&gt;）：在&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;span&gt;应用中，为每个会话创建一个&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　请求（&lt;/span&gt;Request&lt;span&gt;）：在&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;span&gt;应用中，为每个请求创建一个&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;JavaConfig&lt;span&gt;中，添加注解&lt;/span&gt;&lt;span&gt;@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在&lt;/span&gt;XML&lt;span&gt;中，在&lt;/span&gt;&lt;span&gt;&amp;lt;bean&amp;gt;&lt;/span&gt;&lt;span&gt;中添加&lt;/span&gt;&lt;span&gt;scope=&lt;/span&gt;”prototype”属性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、配置文件信息注入&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　在应用开发过程中，我们可能需要使用配置文件来设置某些值，那么如何通过&lt;/span&gt;Spring&lt;span&gt;来将配置文件的值注入到程序中呢&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　Spring&lt;span&gt;提供两种方式实现，&lt;span&gt;属性占位符和&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;SpEL&lt;/span&gt;&lt;span&gt;表达式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　首先我们需要声明配置文件的源，在&lt;/span&gt;JavaConfig&lt;span&gt;中使用注解：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　@PropertySource(“classpath:/app.properties”)&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;　　1.&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;Environment&lt;/span&gt;&lt;span&gt;来检索属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　@Autowired&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　Environment env;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　可以通过&lt;/span&gt;Environmentget&lt;span&gt;的&lt;/span&gt;get&lt;span&gt;Property()&lt;/span&gt;&lt;span&gt;获取值；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;2.&lt;span&gt;通过占位符来检索属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　2.1&lt;span&gt;开启占位符功能&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　在&lt;/span&gt;spring&lt;span&gt;中如果想使用占位符，需要配置&lt;/span&gt;&lt;span&gt;PropertySourcesPlaceholderConfigurer&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　在&lt;/span&gt;JavaConfig&lt;span&gt;中，使用如下代码：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　　　&lt;span&gt;@Bean&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　Public static PropertySourcesPlaceholderConfigurer placeholderConfigurer(){&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　　　return new PropertySourcesPlaceholderConfigurer()&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　}&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;如果是使用&lt;/span&gt;XML&lt;span&gt;配置，可以使用&lt;/span&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;命名空间的&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　&lt;span&gt;&amp;lt;context:property-placeholder&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　2.2&lt;span&gt;如何使用占位符？&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　　　&lt;span&gt;如果在&lt;/span&gt;&lt;/span&gt;&lt;span&gt;XML&lt;span&gt;配置文件中，直接通过&lt;/span&gt;&lt;span&gt;${keyname}&lt;/span&gt;&lt;span&gt;就可以获取&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;span&gt;　　　　如果在&lt;/span&gt;JavaConfig&lt;span&gt;中，可以使用&lt;/span&gt;&lt;span&gt;@Value(&lt;/span&gt;“$(key)”)&lt;span&gt;注解，类型&lt;/span&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;3.&lt;span&gt;使用&lt;/span&gt;&lt;span&gt;SpEL&lt;/span&gt;&lt;span&gt;表达式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　使用&lt;/span&gt;SpEl&lt;span&gt;可以将值装配到&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;属性和构造器参数中。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　&lt;span&gt;注：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;SpEL&lt;span&gt;表达式要放到&lt;/span&gt;&lt;span&gt;#{...}&lt;/span&gt;&lt;span&gt;中，属性占位符放到&lt;/span&gt;&lt;span&gt;${...}&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　3.1 SpEL&lt;span&gt;可以获取&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;的引用、属性和调用方法。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　3.2 SpEL &lt;span&gt;可以调用类的静态方法或属性，如&lt;/span&gt;&lt;span&gt;T(java.lang.Math).PI&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;　　3.3 SpEL &lt;span&gt;可以进行计算，条件判断，正则匹配（&lt;/span&gt;&lt;span&gt;matches&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;等&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sat, 21 Oct 2017 07:41:00 +0000</pubDate>
<dc:creator>宇的季节</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenkeyu/p/7704940.html</dc:identifier>
</item>
<item>
<title>[解读REST] 6.REST的应用经验以及教训 - Blackheart</title>
<link>http://www.cnblogs.com/linianhui/p/rest_experience.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linianhui/p/rest_experience.html</guid>
<description>&lt;p&gt;衔接上文&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_web-and-rest.html&quot; target=&quot;_blank&quot;&gt;[解读REST] 5.Web的需求 &amp;amp; 推导REST&lt;/a&gt;，上文根据Web的需求推导出了REST架构风格，以及REST的详细描述和解释。自从1994年以来，REST架构风格被用于指导Web架构的设计和开发工作，最重要的两点体现是在设计HTTP和URI两个互联网规范协议中，以及实现这些规范的libwww-perl客户端库，Apache HTTP项目（httpd）以及其他的实现中，所得到的经验以及教训。&lt;/p&gt;
&lt;blockquote readability=&quot;6.7651006711409&quot;&gt;
&lt;p&gt;其实REST也用于指导约束超媒体的设计工作，比如HTML，但是Fielding并未在论文中详细解释这部分（很遗憾的一件事情）。所以也造成了如今大家普遍对REST的片面理解，这也造成了大家都i不把超媒体这部分作为REST的重要组成部分来考虑。为此Fielding博士在08年专门写过一篇文章来解释：&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot; target=&quot;_blank&quot;&gt;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&lt;/a&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本系列在一开始就提到，创造REST的目的就是为Web创建一个架构模型，使其来指导Web的架构设计以及相关的协议规范的开发。用REST来描述Web所期待的架构，识别出现的问题，对各种方案进行对比，并且保证新的协议不会违反使Web成功的那些个核心约束。这部分工作使IETF和W3C来负责的，它们定义了HTTP，URI，HTML这三个核心的规范。一开始这三个规范都使由IETF来负责的，后来Web之父Berners-Lee创建了W3C，使其作为Web架构的智库，并为Web编写规范以及实现相关所需的资源，随后HTML就由W3C来专职负责了（关于这部分的历史缘由就不解释了，感兴趣的朋友自行了解吧）。&lt;/p&gt;
&lt;p&gt;得益于Fielding博士在Web开发方面的经验，他被IETF旋转来创作URL规范，后来又和Henrik Frystyk Nielsen合作创作了HTTP/1,0，后来Fielding博士成了HTTP/1.1的主要架构师，并且最终创作了URI通用语法标准的URL规范的修订版。&lt;/p&gt;
&lt;p&gt;REST的第一版诞生于1994年10到1995年8月之间，起初使Fielding作为编写HTTP1.0的一种概念方法。在随后的5年中不断的迭代改进，并且用于各种Web协议标准的修行版和扩展之中。最初REST被称作“HTTP对象模型”，很容易被误解为它使一个HTTP服务器的实现模型。&lt;strong&gt;而REST（表述性状态移交）这个词使有意唤起人们对于一个设计良好的Web应用如何运转的印象：Web应用使一个由网页组成的网络（一个虚拟状态机），用户通过选择链接（状态迁移）在应用中前进，引导系统把下一个页面（代表应用的下一个状态）的数据移交给用户，并且呈现出来，以便用户使用&lt;/strong&gt;。&lt;strong&gt;其中承载包含应用状态的部分是有超媒体来负责的，这也是为什么REST强调HATEOAS（Hypermedia As The Engine Of Application Statue）的原因所在&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;REST并未想要捕获到Web协议规定所有可能的使用方法，现实中仍然会存在一些于REST不匹配的Web应用存在。但是REST捕获到了Web作为一个分布式超媒体系统中最重要的方面，然后对这方面进行优化，使得Web可以满足最核心的这部分需求。&lt;/p&gt;

&lt;p&gt; URI既是Web中最简单的元素，也是最重要的元素。其中URL和URN是常见的两种形式。URI的语法自从1992年以来都相对稳定。URI中也定义了&lt;strong&gt;“资源”&lt;/strong&gt;的概念以及其语义，但是这个概念以及发生了很大的变化。&lt;strong&gt;REST用来定义URI中“资源”这个术语，以及定义通过它们的表述操作资源的通用接口的全部语义&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;2.1 重新定义资源&lt;/h2&gt;
&lt;p&gt;早期Web把URI定义为文档的标识符。创作者使用网络上一个文档的位置来定义标识符，其他人然后通过Web协议来获取这个文档。但是这个定义并不合适，首先这暗示者创作者正在标识所移交的内容，也就是意味者如果文档的内容改变了，那么这个标识符也应该改变；其次，存在很多地址对应的一个服务，而不是一个文档；最后，可能有一段时间没有这个文档。&lt;/p&gt;
&lt;p&gt;REST对于“资源”的定义有一个前提：标识符应该尽可能的少改变。原因在于Web使用的是内嵌的标识符，而不是链接服务器。这个内嵌的标识符标识着特定的语义，允许保持对这个标识符的引用，即便是该标识符背后的资源发生了变化，但是其语义并未发生变化。也就是说REST把URI这个标识符定义为资源所要表达的语义，而不是语义背后对应的具体的值。&lt;/p&gt;
&lt;h2&gt;2.2 表述&lt;/h2&gt;
&lt;p&gt;把“资源”定义为URI标识的&lt;strong&gt;”一个概念“&lt;/strong&gt;，而不是一个具体的文档，这导致了另外的一个问题：用户如何访问操作&lt;strong&gt;“一个概念&quot;&lt;/strong&gt;呢？&lt;strong&gt;REST引入了”表述“这个中间层，即通过资源的表述来操作资源，而不是直接在资源本身上进行操作&lt;/strong&gt;（一个来源服务器维护者资源的标识符和其对应的表述的映射关系，因此可以通过由资源标识符定义的通用接口移交表述来操作一个资源）。&lt;/p&gt;
&lt;p&gt;REST对于资源的定义来自于Web的核心需求：独立创作跨越多个可信任的组织边界的互相链接的超文本。强制要求接口的定义和接口的需求相匹配，会使得协议看起来模糊不清，但这仅仅是因为被操作的仅仅是一个接口，而不是一个实现。&lt;strong&gt;所以资源和接口背后的实现细节都应该是被隐藏起来的，通过接口和表述这两个独立的概念来隔离接口和资源的这两者的具体实现，这也是REST的统一接口这个架构约束的动机。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;由HTTP和URI组成了接口，HTML作为资源的表述，使得来源服务器的对接口和资源的具体实现得以统一标准化。同时得益于客户端不再直接操作资源，使得客户端可以选择自己所能理解的表述来操作资源，比如如今的网站可以提供PC版的Web Site，同时提供基于JSON格式的API来操作同一个资源。再进一步，比如某一个网站的实现从.net升级为了net core，服务器从windows换成了centos，web服务器从iis换成了ngnix，数据库从sql server换成了mysql等等，只要其基于URI和HTTP提供的接口未发生变化，某一个API的语义未发生变化，这一切对于客户端来说，都是透明的。这就使得Web的各种组件的独立部署成为了可能。--笔者解读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2.3 把语义绑定到URI&lt;/h2&gt;
&lt;p&gt;如上面举得例子，一个资源可以由多个URL（PC网页版，基于JSON的API版）来操作，当访问这两个URL的时候，其语义是相同的。当然也可能由两个URL，访问的时候，服务器使用了相同的机制，但是这两个URL却是两个不同的资源。&lt;/p&gt;
&lt;p&gt;对于通过资源的标识符和表述来操作资源的行为而言，语义是一个副产品（&lt;em&gt;比如在网页上执行登录，付款这两个操作，对于Web的各部分组件来说，并不理解其中的差异，其背后的动作很可能都是post一个请求而已&lt;/em&gt;）。语义这部分是交由最终用户来解读的，关于语义这部分这里不细说了（其背后由协议语义，应用语义等具体的概念），后面专门写博客来解释。&lt;/p&gt;
&lt;h2&gt;2.4 URI中不匹配REST的情况&lt;/h2&gt;
&lt;p&gt;理想是丰满的，现实是残酷的。并非所有的已经部署的Web组件都遵循Web的设计要求，REST既可以用来定义Web的改进办法，也可以作为识别其中不匹配部分的方法，尽管无法避免这些不匹配，但是可以在其成为正式规范之前识别出来它们。&lt;/p&gt;
&lt;p&gt;尽管URI的设计和REST中标识符的概念相匹配，但是仅仅依靠URI的语法规则是不足以约束不匹配的行为的。其中的一种滥用就是在URL中包含当前用户的信息，这样的办法可以用于维护服务器会话的状态，但是也会降低共享缓存的效率，也会降低服务器的可伸缩性，并且如果一个用户把这个URL发给其他的用户时，会得到不希望看到的结果。这其实时违反了REST的无状态的约束。另外一个便是把Web看作是一个分布式的文件系统的时候，因为文件系统其实是暴露了其实现细节。&lt;/p&gt;

&lt;p&gt;HTTP在Web中是一个特殊的角色，它既是Web组件之间通信的的应用级协议，也是作为移交资源的表述而设计的唯一协议（&lt;strong&gt;注：Fielding发布REST的论文是在2000年，而在2014年又但是了一个COAP协议，所以以现在时间点来看，HTTP已经不是唯一的协议了&lt;/strong&gt;）。REST用来识别早期HTTP协议中的问题，并指定了一个可以和HTTP1.0互操作的协议自己，然后分析HTTP1.1的扩展提议，并最终诞生了HTTP1.1。&lt;/p&gt;
&lt;blockquote readability=&quot;7.1225806451613&quot;&gt;
&lt;p&gt;2014年IETF发布的的&lt;a href=&quot;http://coap.technology/&quot; target=&quot;_blank&quot;&gt;COAP（RFC 7252 Constrained Application Protocol）&lt;/a&gt;协议，也是遵循REST的指导来设计的，用于IOT的M2M环境下的应用层协议。COAP可以简单的理解为使HTTP的二进制精简版，此外其基于UDP协议，而不是HTTP所使用的TCP。不过目前应用并不广泛，IBM在1998开发的基于TCP的MQTT协议出现的比较早，相关资源丰富一些，因此目前在IOT领域MQTT应用的比较广泛一些。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;3.1 可扩展性&lt;/h2&gt;
&lt;p&gt;REST的主要目标之一就是对一个以及部署的架构进行片段式的升级部署。为此为HTTP添加了版本控制，通过主版本和次版本号来区分（1.0 1.1 2.0），其版本信息代表的是消息发送者对协议的支持能力。&lt;/p&gt;
&lt;p&gt;HTTP包含了很多的部分，比如URI模式，媒体类型，MIME等，这些部分是由单独协议来控制的。HTTP自身也管理了一些比如方法名称，响应状态码，HTTP中各种的Header信息。HTTP请求的语义由请求方法来表示，对于这个语义是在各个组件直接共享的。再比如响应状态码（1xx，2xx，3xx，4xx，5xx）分别表示一类信息，方便后续进行扩充。&lt;/p&gt;
&lt;p&gt;HTTP1.1也新增了Upgrade头，用来再通信双方进行协商协议版本。&lt;/p&gt;
&lt;h2&gt;3.2 自描述的消息&lt;/h2&gt;
&lt;p&gt;HTTP要求组件直接的消息是自描述的，以便支持中间件对交互进行处理。但是早期的HTTP协议在一些方面并不是自描述的。&lt;/p&gt;
&lt;p&gt;Host请求头：早期的HTTP请求中不会携带host头部信息，这导致了一个IP上只能部署一个服务。&lt;/p&gt;
&lt;p&gt;分层编码：HTTP为了描述表述的元数据，采用可MIME的语法，MIME没有定义分层的媒体类型。&lt;/p&gt;
&lt;p&gt;传输独立性：早期的HTTP协议，使用了底层的传输协议来表示响应结束，比如服务器通过关闭TCP连接来表明响应消息的结束。这导致一个严重的问题，就是客户端无法无法到底是网络故障导致的断开，还是服务器主动断开的。为此HTTP1.1加入了Content-Length，用来表示消息体的长度，并且加入了chunked这个编码格式，允许服务器在事先不知道Content-Lenth的情况下。&lt;/p&gt;
&lt;p&gt;缓存控制：新增的Cache-Control，Age，Etag等更精确的缓存控制。&lt;/p&gt;
&lt;p&gt;性能：早期的HTTP协议每个连接只允许发送单个请求和响应，这导致对TCP的使用非常低效。受限于已经部署的组件，HTTP1.1把默认的持久连接作为了默认的选项，如果要关闭连接，则需要发送close的指令。&lt;/p&gt;
&lt;h2&gt;3.3 HTTP中不匹配REST的情况&lt;/h2&gt;
&lt;p&gt;这些不匹配是由于部署的第三方扩展或者是为了保证和HTTP1.0的兼容所导致的。&lt;/p&gt;
&lt;p&gt;区分权威的响应：既无法区分一个响应是来自于源服务器还是中间的某一个组件，虽然HTTP1.1中定义了Warning消息头，但是并未广泛使用。&lt;/p&gt;
&lt;p&gt;cookie：cookie作为一个站点范围内的黑盒状态信息，会导致基于Cookie的交互于REST的应用状态的模型不匹配（比如上一个页面设置了一个cookie，但是下一个页面或许并不依赖cookie，然而cookie也会被发送出去）。其次其cookie并没有任何的语义信息，只是一段文本消息，这也会导致完全和隐私方便的问题，比如如今的各种的广告使用的第三方cookie，对用户的追踪，造成的隐私和安全问题。&lt;/p&gt;
&lt;p&gt;混合元数据：我记得HTTP权威指南中把Header分为请求，响应，实体，通用等部分。其实这部分Header按照其用途应该在HTTP本身进行分门别类一下，比如操作的元数据、资源的、表述的、协议控制的和认证的等等用途。如果得以分层和划分，则有助于对消息的处理。&lt;/p&gt;
&lt;p&gt;将响应和请求匹配：从HTTP的响应消息中，并不能知道其是由那个请求发出的，只能依赖底层的实现。比如如果每一个请求都会有一个Request-Id，然后在其响应中原样返回。&lt;/p&gt;

&lt;p&gt;尽管REST对于Web的标准规范又最直接的影响，但是把它作为架构设计模型，则是通过各种形式的实现来验证的。比如libwww-perl库，Apache的httpd，早期的IE，网景等。REST架构风格成功的指导了Web的架构设计和部署，到目前为止（从199年的http1.1发布到如今），Web并未出现严重的问题。而CDN网络（缓存）的出现也显著的改善了用户改制的性能。&lt;/p&gt;

&lt;p&gt;从Web架构和由REST识别出来的问题中，可以总结出来很多通用的架构上的教训。&lt;/p&gt;
&lt;h2&gt;5.1 基于网络的API的优势&lt;/h2&gt;
&lt;p&gt;把Web和其他的中间件区分的一个标志是它使用HTTP作为一个基于网络的API。但是并不是一项如此，早期的Web利用了一个程序库（CERN的libwww）作为所有客户端和服务器软件所使用的单个协议实现库，libwww提供了一个基于库的api来构造可互操作的Web组件。&lt;/p&gt;
&lt;h2&gt;5.2 HTTP不是RPC&lt;/h2&gt;
&lt;p&gt;人们通常错误的把HTTP视为一种RPC机制，仅仅因为它也是由请求和响应组成的。RPC从本质上来讲，是把一个函数调用放到了跨越网络的另一端，使其使用者看来就像是在调用本地函数一样，RMI也是类似的机制和目的。&lt;strong&gt;把HTTP和RPC分开的并不是其调用细节，而在于其对待网络的影响是怎样看待的，前者侧重于如何有效的利用网络，而后者则在于如何屏蔽网络带来的影响。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTTP是基于网络而专门设计的应用层协议：它的请求被定向到使用了一个标准的语义的通用接口的组件上，而这个组件可以采用几乎和最终的服务器完全相同的方式来解释这个请求以及其语义，并提供响应。这就可以基于HTTP构建起来一个支持分层转换的系统（比如缓存，代理，网关都属于其中的具体层级），这对于一个基于互联网规模的、跨域多个组织边界的、无法控制的可伸缩性的系统而已，意义是巨大的。&lt;/p&gt;
&lt;p&gt;而RPC，则是根据编程语言的API来定义的，虽然现在众多的RPC框架可以支持很多的语言平台，但是其本质还是在有描述一个方法的调用罢了，比如SOAP干的事情本质上就是描述要调用的方法是什么名字，传什么类型的参数，返回什么类型的数据等等这些事情。&lt;/p&gt;
&lt;h2&gt;5.3 HTTP不是传输协议&lt;/h2&gt;
&lt;p&gt;HTTP并不是被设计为一种传输协议。它是一种移交协议。在HTTP中，通过对资源的表述执行各种动作，其反应出来的是Web架构的语义。使用这个非常简单的接口来实现各种的功能是可能的，前提是必须要遵循这个接口，以便HTTP的协议语义对于中间件而已是可见的，这也是为何HTTP可以穿透防火墙的原因。重点在于Web的各各组件都理解HTTP的协议语义，从而可以独自的完成HTTP的响应，而不必一定到达最终的源服务器，这也是为什么它不是传输协议的原因。&lt;/p&gt;
&lt;h2&gt;5.4 媒体类型的设计&lt;/h2&gt;
&lt;p&gt;这是REST中最容易被忽视的一部分，也就是REST对于Web架构中的数据元素的影响程度。最频繁出现的问题在于违反应用状态和无状态交互的架构约束。比如前面提到的Cookie，以及HTML中的iframe，这导致用户代理无法管理和理解它们提供的间接应用状态。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;说点题外话，最近几年火热的前端框架（react，angular，vue），通常都会遇到SEO的问题，那么这个问题产生的根源是什么呢？原因在于HTML本来是承载着应用状态的超媒体语言，浏览器可以理解它，可以通过a，form这些超媒体控件来移交应用的状态，网络爬虫也可以理解这些信息，从而构造出一个网状的状态迁移图。但是呢，前端的框架则打破了这种形态，把HTML近作为了一种UI显示语言来用，应用的状态迁移全都交给了js（js是作为REST的按需代码这一可选的架构约束的具体实现来存在的），着就导致了Web浏览器和网络爬虫得到的只有一些作为UI模板用的HTML，而不知其应用状态在何处。目前这些前端框架做出来的网站，其实是把按需代码这一约束发挥到了机制，其本质上是一个本地应用，只是它的UI语言和业务语言分别是HTML和JS，而这两者可以通过网络来动态的部署罢了。Web APP，首先它具有的一个APP的特征，其次才是Web的特征。&lt;/p&gt;
&lt;p&gt;再比如electron，基于此开发的各种桌面应用（VS Code既是基于它），采用了HTML，CSS，JS来开发一个桌面应用，这其实已经和Web没有丝毫关系了。而是得益于可以解析HTML，CSS，JS背后的运行时可以方便的跨平台。&lt;/p&gt;
&lt;p&gt;当然说这些并不是批判，而是感叹HTML和JS的的生名力会越来越顽强。Web在蚕食能触及到的方方面面，同时能用JS重写的地方，最终都会被JS重写。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTML本身具有的增量处理的特性，使得浏览器可以在下载的同时进行页面的渲染，以及进来提供的预先加载的机制可以提前下载js，css，图片，甚至是另外一个HTML网页，从而提升用户感知的性能。迄今为止，HTML可以说是最为成功的一个超媒体的例子。&lt;/p&gt;

&lt;p&gt;本篇博客解释了REST在设计Web的标准协议以及实现具体的Web组件中所起到的作用，以及现实中那些并不匹配REST要求的部分和从中得到的经验以及教训。&lt;/p&gt;
&lt;p&gt;关于REST的论文的解读，本篇是最后一篇，绝大部分的内容来源于Fielding博士的论文，毕竟REST这个术语诞生于此，论文本身比较晦涩难懂（其实这也不怪Fielding博士，这篇论文是写给IETF和W3C的专家组看的，为此Fielding博士还专门解释过这件事情：&lt;a href=&quot;http://roy.gbiv.com/untangled/2008/specialization&quot; target=&quot;_blank&quot;&gt;http://roy.gbiv.com/untangled/2008/specialization&lt;/a&gt;。），这也从侧面说明论文中所包含的信息是非常具有价值的，比如关于架构风格和架构的解释，对于基于网络的应用的架构风格的总结和比较，以及REST本身，是非常值得花时间去读一读的。&lt;/p&gt;
&lt;p&gt;由于笔者本身理解能力也有限，难免有些地方会理解不周或者出现偏差，欢迎大家指正。这个系列的主要意义在于以正确的角度来看待和理解REST，而不要把REST和RESTful API混在一起，后续笔者关于RESTful API的理解会单独来写。&lt;/p&gt;

&lt;p&gt;世界上诞生的第一个网站：&lt;a href=&quot;http://info.cern.ch/&quot; target=&quot;_blank&quot;&gt;http://info.cern.ch/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;世界上诞生的第一个网站-模拟器：&lt;a href=&quot;http://line-mode.cern.ch/www/hypertext/WWW/TheProject.html&quot; target=&quot;_blank&quot;&gt;http://line-mode.cern.ch/www/hypertext/WWW/TheProject.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Web的生日：&lt;a href=&quot;http://home.cern/topics/birth-web&quot; target=&quot;_blank&quot;&gt;http://home.cern/topics/birth-web&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;理解本真的REST：&lt;a href=&quot;http://www.infoq.com/cn/articles/understanding-restful-style/&quot; target=&quot;_blank&quot;&gt;http://www.infoq.com/cn/articles/understanding-restful-style/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;架构风格与基于网络的软件架构设计-导读：&lt;a href=&quot;http://www.infoq.com/cn/articles/doctor-fielding-article-review&quot; target=&quot;_blank&quot;&gt;http://www.infoq.com/cn/articles/doctor-fielding-article-review&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;架构风格与基于网络的软件架构设计：&lt;a href=&quot;http://www.infoq.com/cn/minibooks/web-based-apps-archit-design&quot; target=&quot;_blank&quot;&gt;http://www.infoq.com/cn/minibooks/web-based-apps-archit-design&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Architectural Styles and the Design of Network-based Software Architectures：&lt;a href=&quot;https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot; target=&quot;_blank&quot;&gt;https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roy T. Fielding: Understanding the REST Style：&lt;a href=&quot;https://www.youtube.com/watch?v=w5j2KwzzB-0&quot; target=&quot;_blank&quot;&gt;https://www.youtube.com/watch?v=w5j2KwzzB-0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roy T. Fielding: REST APIs must be hypertext-driven： &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot; target=&quot;_blank&quot;&gt;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roy T. Fielding: It is ok to use http：&lt;a href=&quot;http://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post&quot; target=&quot;_blank&quot;&gt;http://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Evolution of HTTP：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;REST is not about APIs , Part 1：&lt;a href=&quot;https://www.nirmata.com/2013/10/01/rest-apis-part-1/&quot; target=&quot;_blank&quot;&gt;https://www.nirmata.com/2013/10/01/rest-apis-part-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;REST is not about APIs , Part 2：&lt;a href=&quot;https://www.nirmata.com/2013/11/12/rest-apis-part-2/&quot; target=&quot;_blank&quot;&gt;https://www.nirmata.com/2013/11/12/rest-apis-part-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;REST知识的阅读清单：&lt;a href=&quot;http://www.infoq.com/cn/articles/rest-reading-list&quot; target=&quot;_blank&quot;&gt;http://www.infoq.com/cn/articles/rest-reading-list&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;COAP （Constrained Application Protocol）：&lt;a href=&quot;http://coap.technology/&quot; target=&quot;_blank&quot;&gt;http://coap.technology/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Oct 2017 07:21:00 +0000</pubDate>
<dc:creator>Blackheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linianhui/p/rest_experience.html</dc:identifier>
</item>
<item>
<title>记忆网络（译） - 天文-HITer</title>
<link>http://www.cnblogs.com/jtianwen2014/p/7704778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jtianwen2014/p/7704778.html</guid>
<description>&lt;blockquote readability=&quot;6.4324324324324&quot;&gt;
&lt;p&gt;笔者：本文为英文论文的翻译文章，供机器学习、深度学习相关学者参考，如有错误理解之处请指出，不胜感激！（如需转载，请联系本人：&lt;a href=&quot;https://home.cnblogs.com/u/jtianwen2014/&quot;&gt;jtianwen2014&lt;/a&gt;，并注明&lt;a href=&quot;http://www.cnblogs.com/jtianwen2014/&quot;&gt;出处&lt;/a&gt;）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;13.214285714286&quot;&gt;
&lt;p&gt;&lt;strong&gt;Jason Weston, Sumit Chopra &amp;amp; Antoine Bordes&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Facebook AI Research, 770 Broadway, New York, USA.&lt;/p&gt;
&lt;p&gt;{jase,spchopra,&lt;a href=&quot;mailto:abordes%7D@fb.com&quot;&gt;abordes}@fb.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;本文将介绍一种新的学习模型，称为&lt;em&gt;记忆网络&lt;/em&gt;。记忆网络利用结合了长期记忆模块的推断组件进行推理；并学习如何联合地使用它们。长期记忆模块被用作预测，可以读出也可以写入。我们将记忆网络用于问答任务，长期记忆模块扮演着知识库的角色，记忆网络的输出是文本回复。我们在一个大规模的问答任务上，以及一个从仿真的世界里生成的小规模但是足够复杂的玩具任务（toy task）上进行评测。在本文的末尾，我们通过链乘支持语句到需要理解动词意图的问答来展示这写模型的推理能力。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;1 概述&lt;/h2&gt;
&lt;p&gt;大多数机器学习模型缺乏一种简单的方式从长期记忆模块中读取或写入，并无缝地结合到推理中。所以，这些方法并没有利用现代计算机的卓越的优势之一。举个例子，考虑一个任务，给定一些事实或者故事的集合，然后需要回答相关的问题。理论上这个任务可以通过语言模型来完成，比如循环神经网络（RNN）(Mikolov et al., 2010; Hochreiter &amp;amp; Schmidhuber, 1997) ，因为这些模型被训练得可以对于给定的单词流预测出下一个（或多个）可能的单词（或单词集合）。然而，它们的内存（编码在隐状态和权值）一般很小，并不能准确地记住过去的事实（致使被压缩到稠密的向量中）。众所周知，RNNs很难执行记忆操作，比如简单的拷贝任务即输出刚刚读到的输入(Zaremba &amp;amp; Sutskever, 2014)。同样的情形发生在其他的任务上，比如，在视频和音频领域，观看影片需要长期记忆以回答关于这个影片的问题。&lt;/p&gt;
&lt;p&gt;在本文的工作中，我们介绍一种叫做记忆网络的模型，尝试修复以上提到的问题。核心思想就是将在机器学习中用于推理的有效学习策略和可以读写的内存模块相结合。然后训练模型，使之可以高效的操作内存内存模块。我们在第2部分介绍整体的框架，在第3部分相大家展示在文本问答领域的具体实现。我们在第4部分讨论相关工作，然后再第5部分介绍实验部分，最后在第6部分作出总结。&lt;/p&gt;
&lt;h2 id=&quot;记忆网络&quot;&gt;2 记忆网络&lt;/h2&gt;
&lt;p&gt;一个记忆网络由1个内存模块&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}\)&lt;/span&gt;（用&lt;span class=&quot;math inline&quot;&gt;\(m_i\)&lt;/span&gt;索引的数组）和如下的4个（通过学习得到的）模块&lt;span class=&quot;math inline&quot;&gt;\(I,G,O,R\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{I}\)&lt;/span&gt;：（输入特征映射）—— 将输入转换为内部特征表示。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{G}\)&lt;/span&gt;：（泛化）—— 对于给定新的输入更新旧的内存。我们称之为泛化是因为在这个阶段网络有机会压缩并泛化其内存以供未来某些需要。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{O}\)&lt;/span&gt;：（输出特征映射）—— 给定新的输入与当前的内存状态，产生新的输出（在特征空间中）。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{R}\)&lt;/span&gt;：（回复）—— 将输出转换为特定格式的回复。比如，文本回复或者一个动作。&lt;/p&gt;
&lt;p&gt;给定输入&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;(比如，一个输入字符，单词或者句子，这依赖于粒度的选择，一幅图片或者一段音频信号)，模型执行如下的流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;转换为内部特征表示&lt;span class=&quot;math inline&quot;&gt;\(I(x)\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;对于给定的新的输入，更新内存&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_i\)&lt;/span&gt;：&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_i=G(\mathbf{m}_i,I(x),\mathbf{m}),\forall i\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;对于给定的新的输入和内存，计算输出特征&lt;span class=&quot;math inline&quot;&gt;\(o\)&lt;/span&gt;：&lt;span class=&quot;math inline&quot;&gt;\(o=O(I(x),\mathbf{m})\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;最后，将输出&lt;span class=&quot;math inline&quot;&gt;\(o\)&lt;/span&gt;解码为最后的回复：&lt;span class=&quot;math inline&quot;&gt;\(r=R(o)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;训练和测试阶段都需要这个过程，这两个阶段的差别在于测试阶段不更新&lt;span class=&quot;math inline&quot;&gt;\(I,G,O,R\)&lt;/span&gt;的参数。记忆网络可以用于很多任务。其组件&lt;span class=&quot;math inline&quot;&gt;\(I,G,O,R\)&lt;/span&gt;可以使用很多目前存在的机器学习策略，如，SVMs、决策树、等等。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt;组件：组件&lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt;可以利用一些通用的预处理过程，如，为文本输入进行句法分析、指代和实体消解。它也可以将输入编码到一个内部特征表示，比如，将文本转换到稀疏或稠密的特征向量。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;组件：&lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;最简单的形式是将&lt;span class=&quot;math inline&quot;&gt;\(I(x)\)&lt;/span&gt;存储在内存的‘槽’中：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{m}_H(x) = I(x) \tag{1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(H(.)\)&lt;/span&gt;是槽选择函数。也就是，&lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;只更新内存&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}\)&lt;/span&gt;中索引为&lt;span class=&quot;math inline&quot;&gt;\(H(x)\)&lt;/span&gt;的部分，而不去触碰其他部分。&lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;的更复杂的变种可以基于当前输入&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;所获的的信息来回退并更新早期存储的内存（或者全部内存）。如果输入是字符级别或者可以词级别，那么可以将其进行分组（也就是，将其分块化）并将每块存储到一个内存槽中。&lt;/p&gt;
&lt;p&gt;如果需要的内存巨大（比如，对于Freebase或者Wikidata），那么我们需要对其进行组织。这可以通过之前介绍的槽选择函数来实现：比如，可以对其设计或者训练使之可以按照实体或者主题存储记忆。因此，为了提高扩展的效率，&lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;（以及&lt;span class=&quot;math inline&quot;&gt;\(O\)&lt;/span&gt;）不需要在所有内存上进行操作：可以只对检索到的候选子集进行操作（只在相关主题的记忆上进行操作）。我们将在后续的实验中介绍一个简单的变种。&lt;/p&gt;
&lt;p&gt;如果内存满了，&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;可以通过选择替换哪个内存来进行“忘记”处理，比如，&lt;span class=&quot;math inline&quot;&gt;\(H\)&lt;/span&gt;可以对每个记忆的价值进行打分，覆盖掉最没有价值的部分。我们还未开展这个实验。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(O\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;组件：组件&lt;span class=&quot;math inline&quot;&gt;\(O\)&lt;/span&gt;通常负责从内存中读取并执行推理，比如，计算哪个是可以获得优质回复的相关内存。组件&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;对于给定的&lt;span class=&quot;math inline&quot;&gt;\(O\)&lt;/span&gt;产生最后的回复。举个例子，在问答任务上，阶段&lt;span class=&quot;math inline&quot;&gt;\(O\)&lt;/span&gt;找到相关的内存，然后由&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;产生实际的回答词语，比如&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;可能是个以&lt;span class=&quot;math inline&quot;&gt;\(O\)&lt;/span&gt;为输入的RNN。我们的假设是，如果没有这些记忆作为条件，这样的RNN无法很好执行。&lt;/p&gt;
&lt;h2 id=&quot;为文本实现记忆网络&quot;&gt;3 为文本实现记忆网络&lt;/h2&gt;
&lt;p&gt;有一种特别的记忆网络，其组件都是神经网络。我们称其为记忆神经网络。在本节中，我们描述具有文本输入和输出的记忆神经网络的一个相对简单实现。&lt;/p&gt;
&lt;h3 id=&quot;基础模型&quot;&gt;3.1 基础模型&lt;/h3&gt;
&lt;p&gt;在基础架构中，&lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt;模块以文本为输入。我们首先假设这是一个句子：也可以是一个事实的陈述，或者需要系统回答的问题（稍后我们基于单词的输入序列）。这个文本以原始的形式存储在下一个可用的内存槽中，也就是&lt;span class=&quot;math inline&quot;&gt;\(S(x)\)&lt;/span&gt;返回下一个空的内存槽&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;：&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_N=x,N=N+1\)&lt;/span&gt;。&lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;模块只用来存储这个新的记忆，旧的内存不被更新。更加复杂的模型将在后续的章节中叙述。&lt;/p&gt;
&lt;p&gt;推理的核心模块位于&lt;span class=&quot;math inline&quot;&gt;\(O\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;模块。对于给定&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，模块&lt;span class=&quot;math inline&quot;&gt;\(O\)&lt;/span&gt;通过查找&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个支持记忆来产生输出特征。我们将&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;设为2，但是这个过程适用于更大的&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;。对于&lt;span class=&quot;math inline&quot;&gt;\(k=1\)&lt;/span&gt;，通过如下方式检索出得分最高的支持记忆：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ o_1 = O_1(x,\mathbf{m})=\mathop{\arg\max}_{i=1,\cdots,N}s_O(x,\mathbf{m}_i) \tag{2} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(s_O\)&lt;/span&gt;对&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_i\)&lt;/span&gt;的匹配程度进行打分的函数。对于&lt;span class=&quot;math inline&quot;&gt;\(k=2\)&lt;/span&gt;，我们可以利用迭代的方式发现第二个支持记忆：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ o_2 = O_2(x,\mathbf{m})=\mathop{\arg\max}_{i=1,\cdots,N}s_O([x,\mathbf{m}_{o_1}],\mathbf{m}_i) \tag{3} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中候选支持记忆&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_i\)&lt;/span&gt;现在需要基于初始输入和第一个支持记忆通过打分，方括号代表列表。最终的输出&lt;span class=&quot;math inline&quot;&gt;\(o\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\([x,\mathbf{m}_{o_1},\mathbf{m}_{o_2}]\)&lt;/span&gt;，作为模块&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;的输入。&lt;/p&gt;
&lt;p&gt;最后，&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;需要产生一个文本回复&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;。最简单的回复就是返回&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_{o_k}\)&lt;/span&gt;，也就是输出刚刚检索到的句子。为了进行真实语句的生成，可以利用RNN来代替。在我们的实验中，我们也考虑使用一种简单的方式来评估方法，即我们通过排序的方式将文本回复限定为一个单词：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ r=\mathrm{argmax}_{w\in W}s_R([x,\mathbf{m}_{o_1},\mathbf{m}_{o_2}],w) \tag{4} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;是字典中所有单词的集合，&lt;span class=&quot;math inline&quot;&gt;\(s_R\)&lt;/span&gt;是对匹配进行打分的函数。&lt;/p&gt;
&lt;p&gt;图1给出了一个任务的例子。未来回答问题&lt;span class=&quot;math inline&quot;&gt;\(x=\)&lt;/span&gt;“Where is the milk now?”，模块&lt;span class=&quot;math inline&quot;&gt;\(O\)&lt;/span&gt;需要首先对所有内存进行打分，也就是所有之前见过的语句，以&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;为背景进行检索最相关的事实，在这个例子中&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_{o_1}=\)&lt;/span&gt;“Joe left the milk”。然后在给定&lt;span class=&quot;math inline&quot;&gt;\([x,\mathbf{m}_{o_1}]\)&lt;/span&gt;的情况下，再一次搜索第二个相关事实，也就是&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_{o_2}=\)&lt;/span&gt;“Joe travelled to the office”（在Joe放下牛奶之前去过的最后一个地方）。最后，模块&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;对给定的&lt;span class=&quot;math inline&quot;&gt;\([x,\mathbf{m}_{o_1},\mathbf{m}_{o_2}]\)&lt;/span&gt;利用公式（4）对单词进行打分，输出&lt;span class=&quot;math inline&quot;&gt;\(r=\)&lt;/span&gt;“office”。&lt;/p&gt;
&lt;p&gt;图 1：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/706575/201710/706575-20171021145400756-1174145993.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我们的实验中，打分函数&lt;span class=&quot;math inline&quot;&gt;\(s_O\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(s_R\)&lt;/span&gt;具有相同的形式，一个嵌入表示模型：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ s(x,y) = \Phi_x(x)^{\top}U^{\top}U\Phi_y(y) \tag{5} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;是一个&lt;span class=&quot;math inline&quot;&gt;\(n\times D\)&lt;/span&gt;矩阵，&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;是特征的数量以及&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;是嵌入表示的维度。&lt;span class=&quot;math inline&quot;&gt;\(\Phi_x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\Phi_y\)&lt;/span&gt;是用于将原始文本映射到&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;维的特征空间里。特征空间最简单的选择是词袋表示，对于&lt;span class=&quot;math inline&quot;&gt;\(s_O\)&lt;/span&gt;我们选择&lt;span class=&quot;math inline&quot;&gt;\(D=3|W|\)&lt;/span&gt;，也就是词典中的每个单词有三个不同的表示：一个用于&lt;span class=&quot;math inline&quot;&gt;\(\Phi_y(.)\)&lt;/span&gt;，另外两个用于&lt;span class=&quot;math inline&quot;&gt;\(\Phi_x(.)\)&lt;/span&gt;，依赖于输入的单词来自于实际输入&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;还是支持记忆，以使得它们可以不同建模。类似地，对于&lt;span class=&quot;math inline&quot;&gt;\(s_R\)&lt;/span&gt;也使用&lt;span class=&quot;math inline&quot;&gt;\(D=3|W|\)&lt;/span&gt;。这两个打分函数使用不同的矩阵&lt;span class=&quot;math inline&quot;&gt;\(U_O\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(U_R\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;训练&lt;/strong&gt; 我们在完全有监督的设置下训练，在训练数据中给定应有的输入和回答，以及被标记的支持这个回答的句子（但在测试集中只有输入）。也就是在训练时我们知道eq.(2)和eq.(3)的最佳选择。训练使用一个边际排序损失和随机梯度下降（SGD）来进行。更确切点说，对于给定真实回复&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;的问题&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，以及支持的语句&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_{o_1},\mathbf{m}_{o_2}\)&lt;/span&gt;（当&lt;span class=&quot;math inline&quot;&gt;\(k=2\)&lt;/span&gt;时），我们在参数&lt;span class=&quot;math inline&quot;&gt;\(U_O\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(U_R\)&lt;/span&gt;之上优化模型：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sum_{\overline{f}\ne \mathbf{m}_{o_1}}\mathrm{max}(0, \gamma-s_O(x,\mathbf{m}_{o_1})+s_O(x,\overline{f}))+ \tag{6} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sum_{\overline{f'}\ne \mathbf{m}_{o_2}}\mathrm{max}(0, \gamma-s_O([x,\mathbf{m}_{o_1}], \mathbf{m}_{o_2})+s_O([x,\mathbf{m}_{o_1}],\overline{f'}))+ \tag{7} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sum_{\overline{r}\ne r}\mathrm{max}(0, \gamma-s_R([x,\mathbf{m}_{o_1}, \mathbf{m}_{o_2}], r)+s_O([x,\mathbf{m}_{o_1}, \mathbf{m}_{o_2}], \overline{r}))+ \tag{8} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\overline{f},\overline{f'}\)&lt;/span&gt;以及&lt;span class=&quot;math inline&quot;&gt;\(\overline{r}\)&lt;/span&gt;都是非正确的标签选择，是&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;边际。在SGD的每一步，我们采样选取&lt;span class=&quot;math inline&quot;&gt;\(\overline{f},\overline{f'}，\overline{r}\)&lt;/span&gt;而不是为每个训练样例计算所有的总和，这和Weston et al.(2011)的做法相同。&lt;/p&gt;
&lt;p&gt;当我们使用RNN来实现记忆神经网络的&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;模块时（而不是像上面那样用单词回复），我们将最后一项替换为语言建模任务中使用的标准对数似然函数，其中RNN的输入是序列&lt;span class=&quot;math inline&quot;&gt;\([x,o_1,o_2,r]\)&lt;/span&gt;。在测试的时候，在给定&lt;span class=&quot;math inline&quot;&gt;\([x,o_1,o_2]\)&lt;/span&gt;的情况下输出&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;。对比最简单的模型，即使用&lt;span class=&quot;math inline&quot;&gt;\(k=1\)&lt;/span&gt;并且输出&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_{o_1}\)&lt;/span&gt;的记忆作为回复&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;，将只使用第一项用来训练。&lt;/p&gt;
&lt;p&gt;接下来的部分，我们将考察一些基于基础模型的扩展。&lt;/p&gt;
&lt;h3 id=&quot;词序列作为输入&quot;&gt;3.2 词序列作为输入&lt;/h3&gt;
&lt;p&gt;如果输入是词而非句子级别，即词以流的形式到达（就像RNN经常处理的那样）并且陈述和问题都没有进行词分割，我们需要修改下之前描述的方法。所以我们加入“分割”函数，将会通过学习得到，输入单词的最后没有分割的序列以寻找分割点。当分割器触发时（指示当前序列时分割段）我们将序列写入内存，然后就可以像以前一样处理。这个分割器的建模方式和我们其他的模块类似，以嵌入表示模型的形式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ seg(c) = W^{\top}_{seg}U_S\Phi_{seg}(c) \tag{9} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(W_{seg}\)&lt;/span&gt;是一个向量（实际上是嵌入空间里的线性分类器的参数），&lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;是用词袋表示的词序列。如果&lt;span class=&quot;math inline&quot;&gt;\(seg(c)&amp;gt;\gamma\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;是边际，那么这个序列被视为一个分割。通过这种方式，我们的记忆神经网络在写操作时拥有一个学习模块。我们将这个分割器视为第一个概念证明：当然，可以设计得更加复杂。训练时进一步的细节将在附录B中展现。&lt;/p&gt;
&lt;h3 id=&quot;利用散列表的高效记忆&quot;&gt;3.3 利用散列表的高效记忆&lt;/h3&gt;
&lt;p&gt;如果存储的记忆集合十分庞大，那么eq.2和eq.3中对所有记忆进行打分的代价将十分巨大。我们使用散列的技巧来加速查找：将输入&lt;span class=&quot;math inline&quot;&gt;\(I(x)\)&lt;/span&gt;散列到一个或多个桶中，然后只对相同桶里的记忆&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_i\)&lt;/span&gt;进行打分。我们考察两种散列的方式：（i）散列词语；以及（ii）对词嵌入表示进行聚类。对于方法（i）我们构造和词典中词语数量相同的桶，然后对于给定的语句我们将其散列到所包含词语的对应的桶中。（i）的问题在于记忆&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_i\)&lt;/span&gt;只有当和&lt;span class=&quot;math inline&quot;&gt;\(I(x)\)&lt;/span&gt;至少一个相同的词语时才被考虑。方法（ii）试图通过聚类解决这个问题。在训练嵌入式矩阵&lt;span class=&quot;math inline&quot;&gt;\(U_O\)&lt;/span&gt;之后，我们使用K-近邻进行聚类词向量&lt;span class=&quot;math inline&quot;&gt;\((U_O)_i\)&lt;/span&gt;，所以给出了K个桶。然后我们将语句散列到所有包含词语落入的桶中。因为词向量会和其同义词相接近从而彼此聚类到一起，所以我们将会对这些相似的记忆进行打分。输入和记忆之间匹配的词语都会按照定义被打分。选择&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;控制速度准确权衡。&lt;/p&gt;
&lt;h3 id=&quot;建模写入时间&quot;&gt;3.4 建模写入时间&lt;/h3&gt;
&lt;p&gt;我们可以将何时一个内存被写入加入到我们的模型中。这对于回答固定事实的问题（“What is the capital of France?”）并不重要，但当回答一个如图1的故事相关的问题时却是重要的。对于给定的&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_j\)&lt;/span&gt;，实现这个的一种明显方式就是向表示&lt;span class=&quot;math inline&quot;&gt;\(\Phi_x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\Phi_y\)&lt;/span&gt;中加入编码&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;的额外特征，假设&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;遵循写时间（也就是，没有内存槽被重写）。然而，需要处理的事绝对时间而非相对时间。我们对以下过程有着更多的成功经验：代替打分输入，候选对利用上述的&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;学习一个定义在三元组上的函数&lt;span class=&quot;math inline&quot;&gt;\(s_{O_t}(x,y,y')\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ s_{O_t}(x,y,y') = \Phi_x(x)^{\top}U_{O_t}^{\top}U_{O_t}(\Phi_y(y)-\Phi_y(y')+\Phi_t(x,y,y')) \tag{10} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Phi_t(x,y,y')\)&lt;/span&gt;使用三个新的特征，取值0或1:是否&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;比&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;更加久，&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;比&lt;span class=&quot;math inline&quot;&gt;\(y‘\)&lt;/span&gt;更加久，&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;比&lt;span class=&quot;math inline&quot;&gt;\(y’\)&lt;/span&gt;更加久。（也就是，我们将所有的&lt;span class=&quot;math inline&quot;&gt;\(\Phi\)&lt;/span&gt;维度扩展3位，如果不适用的时候都设置位0）现在，如果&lt;span class=&quot;math inline&quot;&gt;\(\Phi_t(x,y,y')&amp;gt;0\)&lt;/span&gt;，模型更偏于选择&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;，如果&lt;span class=&quot;math inline&quot;&gt;\(\Phi_t(x,y,y')&amp;lt;0\)&lt;/span&gt;，模型更偏于选择&lt;span class=&quot;math inline&quot;&gt;\(y'\)&lt;/span&gt;。eq.2和eq.3中的argmax替换为在&lt;span class=&quot;math inline&quot;&gt;\(i=1,\cdots,N\)&lt;/span&gt;的循环，在每步中持续赢取内存记忆（&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;或者&lt;span class=&quot;math inline&quot;&gt;\(y'\)&lt;/span&gt;），即总是比较当前赢得的内存和下一个内存&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{m}_i\)&lt;/span&gt;。如果把时间特征移走，这个过程等价于之前的argmax。更多的细节将在附录C中讨论。&lt;/p&gt;
&lt;h3 id=&quot;建模生词&quot;&gt;3.5 建模生词&lt;/h3&gt;
&lt;p&gt;即使对于阅读量很大的人类来说，生词也是经常遇到。比如指环王中的单词“Boromir”。一个机器学习模型如何来处理这个问题？一个可能的方式是使用语言模型：通过生词周围的词语，来预测可能的单词，并假设这个生词和预测的单词语义相似。我们提出的方法正是采用这个想法，但是我们将其融入到我们的网络&lt;span class=&quot;math inline&quot;&gt;\(s_O\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(s_R\)&lt;/span&gt;而不是作为一个单独的步骤。&lt;/p&gt;
&lt;p&gt;具体地，对于我们看到的单词，我们将其周围词保存在词袋中，一个词袋保存左侧的词语，另一个保存右侧的词语。任何未知的词语都可以这样表示。所以我们将特征表示&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;从&lt;span class=&quot;math inline&quot;&gt;\(3|W|\)&lt;/span&gt;扩展到&lt;span class=&quot;math inline&quot;&gt;\(5|W|\)&lt;/span&gt;来对这些上下文进行建模（每个词袋有&lt;span class=&quot;math inline&quot;&gt;\(|W|\)&lt;/span&gt;个特征）。我们的模型在训练阶段使用一种“dropout”技术来处理新的单词：&lt;span class=&quot;math inline&quot;&gt;\(d\%\)&lt;/span&gt;的时间我们装作从未读取过任何词语，不使用&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;维嵌入表示这个词语，而是用它的上下文来代替。&lt;/p&gt;
&lt;h3 id=&quot;精准匹配和生词&quot;&gt;3.6 精准匹配和生词&lt;/h3&gt;
&lt;p&gt;由于低维度&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;嵌入式模型无法进行精准的词汇匹配。一个解决方案是对词对&lt;span class=&quot;math inline&quot;&gt;\(x,y\)&lt;/span&gt;进行如下打分来替代之前的：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \Phi_x(x)^{\top}U^{\top}U\Phi_y(y) + \lambda\Phi_x(x)^{\top}\Phi_y(y) \tag{11} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就是，向学习到的嵌入式分数加入“词袋”的匹配（使用一个混合参数\lambda）。另一个，相关的方法还是在这个&lt;span class=&quot;math inline&quot;&gt;\(n-\)&lt;/span&gt;维的嵌入式空间里，但是为特征表示&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;扩展更多的匹配特征，比如，一个词汇。一个匹配的特征意味着这个词在&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;中都有出现。也就是，我们使用&lt;span class=&quot;math inline&quot;&gt;\(\Phi_x(x)^{\top}U^{\top}U\Phi_y(y,x)\)&lt;/span&gt;进行打分，其中&lt;span class=&quot;math inline&quot;&gt;\(\Phi_y\)&lt;/span&gt;实际建立在&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;基础上：如果&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;中的词语与&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;中的一次匹配，我们就将这些匹配特征设置为1。未登录词可以使用相似的方法建模，在上下文词汇中使用匹配特征。最后，&lt;span class=&quot;math inline&quot;&gt;\(D=8|W|\)&lt;/span&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 21 Oct 2017 07:02:00 +0000</pubDate>
<dc:creator>天文-HITer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jtianwen2014/p/7704778.html</dc:identifier>
</item>
<item>
<title>野生码农的架构实践 - 老坏猫</title>
<link>http://www.cnblogs.com/evilcat/p/7704749.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evilcat/p/7704749.html</guid>
<description>&lt;div&gt;
&lt;p class=&quot;PublishStatus&quot;&gt;&lt;span&gt;&lt;strong&gt;一、  &lt;/strong&gt; &lt;strong&gt;自传&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;        IT圈子重所谓“出身”。在B乎、各种码农圈子，经常看到晒学历、晒工作经历。不是BAT，就是麻省，北清。就如龙母见任何人都要报出一堆头衔，以证明自己血统的高贵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而本人，就是一个纯野生“双非”码农：非计算机科班出身、非IT名企出身。大学学的机电自动化，毕业也是一直跟机器、图纸打交道。没有自带光环、没有拜师学艺、没有群星荟萃，全凭个人兴趣，业余爱好而已。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而诸葛亮说过，不要妄自菲薄。兴趣是最好的老师。因为偶然机会，帮朋友设计一个进销存软件，一发不可收，经常熬夜研究，不但要理解需求，还要编写代码，从无到有，无师自通。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那时候，成功连接数据库、弹出来第一个窗体，都是极大的喜悦。虽然彼时水平极菜，自己却认为已经是“高手”了。现在想来虽然可笑，但也是这种良好的自我感觉，给了我持续的动力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对我这种野生码农而言，没有资历可晒，资本就只有一样：码力，写代码的能力。能证明自己的，就是代码和架构的水平，比如这个&lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171021143941959-105922437.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、  &lt;/strong&gt; &lt;strong&gt;起步：看山是山，看水是水&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;我的起点&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;起点就是零点。大学里也“学过”计算机，C,FORTRAN。甚至图书馆里借过几本计算机书啃。然而中国的教材，你懂的，最大特长是把简单问题复杂化。当时不喜欢英语，吃了大亏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后来逐渐明白，无论技术还是教材，还是国外原版的好。后来再没怎么研究过计算机，直到我搞那个进销存软件为止。所以开始，我就是一个软件盲。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感谢宽带，感谢百度，感谢微软。家里有了宽带，就可以百度：看博客园、看csdn、看MSDN。好在.NET门槛很低，帮助齐全，神器加持，如果是C++，陡峭的自学曲线，说不定就放弃了。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;摸索之路&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;也许正因为是从一张白纸起步，虽然走了些弯路，但也没有窠臼之见。既不知道什么设计模式，也没有编程套路和规范。一切都是自己摸索，也形成了自己的“风格”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最开始的进销存设计，我不懂代码，但是需求分析还是有的。只是彼时初生牛犊不怕虎，不知深浅。什么能实现，什么不能实现，实现的难度有多大，一概不知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个进销存系统虽是业余练笔之作，但最初拟定的需求，却是参照一款国内流行的管家婆软件。需求来自于管家婆的说明书。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没办法，发挥我国人民山寨的特长，管家婆有几个页面我也几个页面，管家婆有哪些功能我也来一套。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;VS神器+Winform，从拖控件开始。有些控件达不到管家婆的效果，就百度。涉及到的财务知识不懂，百度。如此也练就了一身功夫：搜商。现在想找什么资料，关键字往往一击命中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有人说C#、.NET坏就坏在拖控件上。把码农惯坏了，惯成不求甚解只会拖控件的傻瓜了。我只想说，只会拖控件的确说明你是傻瓜，但这不怪微软，只怪你自己没有追求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样经过若干昼夜的鏖战，总算出来几张基本的数据库表，几个还算齐整的页面。代码是吃百家饭，从百度上抠来的。比如数据库的连接啦，button的效果啦，等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在看那些代码，既不是面向对象，也不是面向过程，而是纯粹为实现功能拼凑的代码。前后台代码混在一起，一个类千行代码，一个函数洋洋洒洒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但有两个习惯让我能进入下一步，一个是&lt;strong&gt;追求完美主义&lt;/strong&gt;，一个是&lt;strong&gt;喜欢追根究底&lt;/strong&gt;。没有这两点，不可能进阶。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如ADO，里面有一系列对象，什么游标、什么DataTable、什么数据库连接池，这里涉及到大量概念，我这人不习惯死记硬背，为从无到有理解ADO、数据库的一系列概念，熬夜思考若干天，终于有所领悟，理出头绪。而之后，数据结构、套接字、网络协议，这些概念自然而然就会进入你的视野，务求深入理解，磨刀不误砍柴工。我个人的经验，软件行业包罗万象，最好的学习方法就是掌握基本概念之后，用什么学什么。道理一通百通。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而追求代码完美主义，使我看着过往零碎、丑陋的代码，内心感到不满，也开始接触到一些面向对象、多层架构、UML这些概念，感觉真理就在眼前，开始考虑重构代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、  &lt;/strong&gt; &lt;strong&gt;思变：看山不是山，看水不是水&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;从面向“过程”到面向对象&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;重构的第一步，提取出共性的东西，代之以函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原来大量的相同、相似代码合并，放到一个大的工具类，大家共享。这样做的好处显而易见，代码精简了，可读性强了，改起来容易了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是重构这个事，很容易矫枉过正。尤其是我接触到“面向对象”这个概念之后。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初识面向对象，总有一种发现真理的感觉。比如订单类，原来的风格是类大而全，保罗万象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学了面向对象，就将采购单、销售单、入库单、出库单等等继承一个总的Order类，每个Order还要分订单抬头（客户、账号、订单号、日期），明细，又各自有所继承。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那时候的代码，真是万物皆对象，为赋新词强说愁。至于这么分类有什么好处，却没有清醒的认知。所以结果就是把简单的问题复杂化了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如每个订单都有自己的增删改查方法，然而订单的参数不同，增删改查都要重载；人说三层架构好，就把界面逻辑中所有数据操作的部分，都塞到一个DAL层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171021143857365-575511041.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以说，这样做的结果还是有好处的，界面部分没有数据库操作的语句。修改界面的人（不一定是自己）只需要知道接口规范就可以。不用在意太多细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;坏处是，一旦对象发生变化，不但要改接口，还要改数据库，数据库操作的DAL层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一阶段，总体代码量甚至有所增加，性能甚至有所下降，但思路更加清晰了，对面向对象的理解深入了，包括它的利弊。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;设计模式的改造&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;学习了设计模式之后，对面向对象的理解深入了一层。实际上，经常发现自己不知不觉中已经是设计模式的践行者。因为这些模式都是前人对某一类问题总结出来的最佳设计方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计模式的目标，就是减少耦合性，提升扩展性。从哲学角度，编程并不简单的是写代码的问题。是对客观世界的抽象。牛逼的人能很快领悟到本质，用一个简洁的描述就能让人明白真相，比如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/43917/201710/43917-20171021143840427-1608303894.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;大部分人，对复杂的问题理不出头绪，而且越来越乱。所以编程能力除了逻辑思维之外，很重要的一点是抽象能力。不管是编程还是做其他事，都需要这种能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这之后，我并没有刻意去套设计模式，而是学会了一个简单的套路：分析核心业务对象，用接口提取某一类业务的共性，各业务对象之间用接口交互。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、  &lt;/strong&gt; &lt;strong&gt;破局：看山还是山，看水还是水&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;简单的就是好的&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;等面向过程、面向对象、设计模式一路走来，经历了从繁到简、由简入繁的过程，对架构的利弊也有了更多的思考。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时候，我最强的就是一个字，简。一切回到原点，风格倾向简洁。到后来，甚至变成极简主义，不想看到一行无用的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能很多码农都有体会，看某些网上的代码，痛苦不堪。因为千头万绪，本来几句话能说清楚的事情，绕很大一个弯。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当年我做组态设计，有用到一种DDE的技术。网上下载了一个库NETDDE，C#代码，为了追求所谓“普适性”做了几层封装，最后不但代码不忍卒读，性能还很差。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是花了点功夫做重构，删繁就简，代码清晰，性能提高了一个数量级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;越简单的东西，可读性越好，可维护性越好，可扩展性越好，往往性能也越好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而能用最简单的方式描述一个复杂的事物，我认为就是架构能力的体现。无论在我的组态软件设计，还是程序化交易软件，都遵循了最简化这一原则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说说个人的一些体会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;首先，对需求分析，提取出核心业务。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如在进销存，核心业务就是物流、钱流；而驱动物流、钱流周而复始的核心对象就是订单（采购单、销售单、入库单、出库单等等）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在组态软件，核心业务就是网关，核心对象就是变量（Tag）。无论HMI的动态显示，还是下位机的扫描轮询，承上启下的就是变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在程序化交易，核心业务就是行情、交易，核心对象就是Bar（K线）。驱动核心业务运转的就是订单(Order)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析出核心业务、核心对象之后，整体思路就清晰了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;第二步，根据业务特点做技术选型。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我认为，作为一个好码农，能够在多种方案中选择一种最佳或者次佳的方案，是基本能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在多年编程实践之后，应该对同一个问题已经有了多种方案。比如最基本的，用.NET还是JAVA还是Python?通讯是用Socket还是HTTP？是用字典还是列表？是用第三方还是自己造轮子？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每种方案各有利弊，最后你要善于抓住主要矛盾，比如你需要的是开发效率，就尽量利用.NET；做互联网项目，尤其是复杂业务、在Linux上运行，就要用JAVA；需要的是性能，就要Socket，字典；可能存在并发，那就要考虑高并发解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;第三步，架构设计。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对我最熟悉的桌面程序而言，一般都包括三部分：界面-服务-工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在组态项目里，后台服务提供网关功能，核心业务封装在服务；可以驱动多个客户端界面。因此服务要求稳健、高性能。服务这部分需求尽可能完善，尽可能稳定。设计服务部分的一般为架构师、资深码农。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;界面需要前后台分离协作，因此界面设计应尽可能简单、直观。最好就是傻瓜式的拖拽控件，复制模板，连连变量。界面设计人员不需要考虑后台怎么实现，只需考虑具体业务需求。甚至都不一定会编程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;工具如组态软件的变量管理器等，设计目的是减少界面人员和服务设计人员的交互工作。把两者共同用到的配置项、变化最多的数据分离出来，用简单的可视化工具管理。VS本身也是这样一种工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务-界面-工具，三者之间用不同的方式交互。服务与界面可以使用通讯协议、WCF交互；界面、工具之间可通过数据库、配置文件交互；工具和服务之间往往通过数据库交互。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;对性能的关注&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;数据结构是码农的基本功。很多人说.NETer因为框架的强大对数据结构一无所知。这是P话。因为我在代码追求完美主义，所以我对我程序的性能也追求的孜孜不倦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多人说.NET性能如何如何不行，博客园有老赵，xiaotie的文章为什么不去看？老赵和xiaotie的性能优化手段，我也用过。因为不同的数据结构、不同的索引都能带来巨大的性能差异。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如在组态软件里，如果要按变量名在一个几千变量的变量表搜索到一个变量（Tag），你可以用1.遍历2.二分法排序之后查找3.字典。三种方法的差异有如天壤之别，如果这种操作是频繁的，就一定要仔细考量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你仅仅写代码为交差，为糊口，就不会关注性能，更不可能去编译.NET的代码，或者去百度谷歌搜索最好的性能解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果这是一种习惯，日积月累，几年后，同为.NETer ，做出来的东西无论架构还是性能，就有巨大的差别，当然也会反映在个人收入上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;园子里有人发帖说学.NET的如何被PHPer,JAVAer歧视。我只能说，你被歧视怨不得.NET,怨不得微软。只是你自己水平太菜而已。我也接触过不少搞JAVA，PHP的，谁有资格搞语言歧视？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有一种语言能解决所有问题。各有所长。如果有搞JAVA，PHP或者任何其他语言的人，如果仅仅因为语言的偏见就想贬低我个人的话，可以到github下载我的程序，然后自己想出更好的解决方案来，我就服你。否则自己去打脸。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、  &lt;/strong&gt; &lt;strong&gt;下面的计划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写一系列帖子，把架构、原理讲清楚。大致如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;网关层接口概述&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;上下位机通讯原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何实现一个设备驱动&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何设计图元&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;VS插件模块及原理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;归档模块及文件格式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如何进行功能扩展&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;组态变量表达式实现&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;github地址：&lt;a href=&quot;https://github.com/GavinYellow/SharpSCADA&quot; target=&quot;_blank&quot;&gt;https://github.com/GavinYellow/SharpSCADA&lt;/a&gt;。QQ群：102486275。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Oct 2017 06:54:00 +0000</pubDate>
<dc:creator>老坏猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evilcat/p/7704749.html</dc:identifier>
</item>
<item>
<title>Spring4.0.1+Quartz2.2.1实现定时任务调度[亲测可用] - 不是植物</title>
<link>http://www.cnblogs.com/zhuziyu/p/7704661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuziyu/p/7704661.html</guid>
<description>&lt;p&gt;Spring4.0.1+Quartz2.2.1实现定时任务调度[亲测可用]&lt;/p&gt;
&lt;p&gt;tip：只需要配置xml文件即可&lt;/p&gt;
&lt;p&gt;1、第三方依赖包的引入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;properties&amp;gt;  
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;  
        &amp;lt;springframework.version&amp;gt;4.0.1.RELEASE&amp;lt;/springframework.version&amp;gt;  
        &amp;lt;quartz.version&amp;gt;2.2.2&amp;lt;/quartz.version&amp;gt;  
    &amp;lt;/properties&amp;gt;  
  
    &amp;lt;dependencies&amp;gt;  
        &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;${springframework.version}&amp;lt;/version&amp;gt;  
        &amp;lt;/dependency&amp;gt;  
        &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;${springframework.version}&amp;lt;/version&amp;gt;  
        &amp;lt;/dependency&amp;gt;  
        &amp;lt;!-- Transaction dependency is required with Quartz integration --&amp;gt;  
        &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;spring-tx&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;${springframework.version}&amp;lt;/version&amp;gt;  
        &amp;lt;/dependency&amp;gt;  
           
        &amp;lt;!-- Quartz framework --&amp;gt;  
        &amp;lt;dependency&amp;gt;  
            &amp;lt;groupId&amp;gt;org.quartz-scheduler&amp;lt;/groupId&amp;gt;  
            &amp;lt;artifactId&amp;gt;quartz&amp;lt;/artifactId&amp;gt;  
            &amp;lt;version&amp;gt;${quartz.version}&amp;lt;/version&amp;gt;  
        &amp;lt;/dependency&amp;gt;  
    &amp;lt;/dependencies&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、Spring配置文件[Spring.xml/applicationContext.xml]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- For times when you just need to invoke a method on a specific object --&amp;gt;  
    &amp;lt;bean id=&quot;myJobDetail&quot; class=&quot;org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean&quot;&amp;gt;  
        &amp;lt;property name=&quot;targetObject&quot; ref=&quot;syncService&quot; /&amp;gt;  &amp;lt;!-- 对应你要执行的方法类 --&amp;gt;
        &amp;lt;property name=&quot;targetMethod&quot; value=&quot;synctask&quot; /&amp;gt;   &amp;lt;!-- 对应你要执行的方法 --&amp;gt;
    &amp;lt;/bean&amp;gt;  
    
    &amp;lt;!-- Run the job every 5 seconds --&amp;gt;  
    &amp;lt;bean id=&quot;cronTrigger&quot;  class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&amp;gt;  
        &amp;lt;property name=&quot;jobDetail&quot; ref=&quot;myJobDetail&quot; /&amp;gt;              &amp;lt;!-- 你要调度的任务,即上面的bean id=myJobDetail --&amp;gt;
        &amp;lt;property name=&quot;cronExpression&quot; value=&quot;0/10 * * ? * *&quot; /&amp;gt;    &amp;lt;!-- 调度的时间设置，我这里是10秒一次 --&amp;gt;
    &amp;lt;/bean&amp;gt;  
    
    &amp;lt;!-- Scheduler factory bean to glue together jobDetails and triggers to Configure Quartz Scheduler --&amp;gt;  
    &amp;lt;!-- 将调度和触发器整合 --&amp;gt;
    &amp;lt;bean  class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&amp;gt;  
        &amp;lt;property name=&quot;jobDetails&quot;&amp;gt;  
            &amp;lt;list&amp;gt;
                &amp;lt;ref bean=&quot;myJobDetail&quot; /&amp;gt;  
            &amp;lt;/list&amp;gt;  
        &amp;lt;/property&amp;gt;  
        &amp;lt;property name=&quot;triggers&quot;&amp;gt;  
            &amp;lt;list&amp;gt;   
                &amp;lt;ref bean=&quot;cronTrigger&quot; /&amp;gt;  
            &amp;lt;/list&amp;gt;  
        &amp;lt;/property&amp;gt;  
    &amp;lt;/bean&amp;gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、编写你的任务类syncService及对应的方法synctask&lt;/p&gt;
&lt;p&gt;4、Quartz时间格式设置&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些星号由左到右按顺序代表 ：     *    *     *     *    *     *   *     &lt;/span&gt;&lt;br/&gt;&lt;span&gt;                              格式： [秒] [分] [小时] [日] [月] [周] [年] &lt;/span&gt;&lt;br/&gt;&lt;span&gt;序号 说明 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;  是否必填  允许填写的值 允许的通配符 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;1  秒  是  0-59    , - * / &lt;/span&gt;&lt;br/&gt;&lt;span&gt;2  分  是  0-59 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;   , - * / &lt;/span&gt;&lt;br/&gt;&lt;span&gt;3 小时  是  0-23   , - * / &lt;/span&gt;&lt;br/&gt;&lt;span&gt;4  日  是  1-31   , - * ? / L W &lt;/span&gt;&lt;br/&gt;&lt;span&gt;5  月  是  1-12 or JAN-DEC   , - * / &lt;/span&gt;&lt;br/&gt;&lt;span&gt;6  周  是  1-7 or SUN-SAT   , - * ? / L # &lt;/span&gt;&lt;br/&gt;&lt;span&gt;7  年  否  empty 或 1970-2099  , - * / &lt;/span&gt;&lt;br/&gt;&lt;span&gt;通配符说明: &lt;/span&gt;&lt;br/&gt;&lt;span&gt;* 表示所有值. 例如:在分的字段上设置 &quot;*&quot;,表示每一分钟都会触发。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为&quot;?&quot; 具体设置为 0 0 0 10 * ? &lt;/span&gt;&lt;br/&gt;&lt;span&gt;- 表示区间。例如 在小时上设置 &quot;10-12&quot;,表示 10,11,12点都会触发。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;, 表示指定多个值，例如在周字段上设置 &quot;MON,WED,FRI&quot; 表示周一，周三和周五触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;/ 用于递增触发。如在秒上面设置&quot;5/15&quot; 表示从5秒开始，每增15秒触发(5,20,35,50)。在月字段上设置'1/3'所示每月1号开始，每隔三天触发一次。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于&quot;7&quot;或&quot;SAT&quot;。如果在&quot;L&quot;前加上数字，则表示该数据的最后一个。例如在周字段上设置&quot;6L&quot;这样的格式,则表示“本月最后一个星期五&quot; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置&quot;15W&quot;，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 &quot;1W&quot;,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，&quot;W&quot;前只能设置具体的数字,不允许区间&quot;-&quot;). &lt;/span&gt;&lt;br/&gt;&lt;span&gt;小提示 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;'L'和 'W'可以一组合使用。如果在日字段上设置&quot;LW&quot;,则表示在本月的最后一个工作日触发(一般指发工资 ) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 序号(表示每月的第几个周几)，例如在周字段上设置&quot;6#3&quot;表示在每月的第三个周六.注意如果指定&quot;#5&quot;,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;小提示 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;周字段的设置，若使用英文字母是不区分大小写的 MON 与mon相同. &lt;/span&gt;&lt;br/&gt;&lt;span&gt;常用示例: &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 0 12 * * ? 每天12点触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 ? * * 每天10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 * * ? 每天10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 * * ? * 每天10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 * * ? 2005 2005年每天10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 * 14 * * ? 每天下午的 2点到2点59分每分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 0/5 14 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 0/5 14,18 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;每天下午的 18点到18点59分(整点开始，每隔5分触发) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 0-5 14 * * ? 每天下午的 2点到2点05分每分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 10,44 14 ? 3 WED     3月分每周三下午的 2点10分和2点44分触发 （特殊情况，在一个时间设置里，执行两次或                                                             两次以上的情况） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 59 2 ? * FRI    每周5凌晨2点59分触发； &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 ? * MON-FRI 从周一到周五每天上午的10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 15 * ? 每月15号上午10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 L * ? 每月最后一天的10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 ? * 6L 每月最后一周的星期五的10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 ? * 6L 2002-2005 从2002年到2005年每月最后一周的星期五的10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 ? * 6#3 每月的第三周的星期五开始触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 0 12 1/5 * ? 每月的第一个中午开始每隔5天触发一次 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 11 11 11 11 ? 每年的11月11号 11点11分触发(光棍节)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些星号由左到右按顺序代表 ：     *    *     *     *    *     *   *     &lt;/span&gt;&lt;br/&gt;&lt;span&gt;                              格式： [秒] [分] [小时] [日] [月] [周] [年] &lt;/span&gt;&lt;br/&gt;&lt;span&gt;序号 说明 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;  是否必填  允许填写的值 允许的通配符 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;1  秒  是  0-59    , - * / &lt;/span&gt;&lt;br/&gt;&lt;span&gt;2  分  是  0-59 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;   , - * / &lt;/span&gt;&lt;br/&gt;&lt;span&gt;3 小时  是  0-23   , - * / &lt;/span&gt;&lt;br/&gt;&lt;span&gt;4  日  是  1-31   , - * ? / L W &lt;/span&gt;&lt;br/&gt;&lt;span&gt;5  月  是  1-12 or JAN-DEC   , - * / &lt;/span&gt;&lt;br/&gt;&lt;span&gt;6  周  是  1-7 or SUN-SAT   , - * ? / L # &lt;/span&gt;&lt;br/&gt;&lt;span&gt;7  年  否  empty 或 1970-2099  , - * / &lt;/span&gt;&lt;br/&gt;&lt;span&gt;通配符说明: &lt;/span&gt;&lt;br/&gt;&lt;span&gt;* 表示所有值. 例如:在分的字段上设置 &quot;*&quot;,表示每一分钟都会触发。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为&quot;?&quot; 具体设置为 0 0 0 10 * ? &lt;/span&gt;&lt;br/&gt;&lt;span&gt;- 表示区间。例如 在小时上设置 &quot;10-12&quot;,表示 10,11,12点都会触发。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;, 表示指定多个值，例如在周字段上设置 &quot;MON,WED,FRI&quot; 表示周一，周三和周五触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;/ 用于递增触发。如在秒上面设置&quot;5/15&quot; 表示从5秒开始，每增15秒触发(5,20,35,50)。在月字段上设置'1/3'所示每月1号开始，每隔三天触发一次。 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于&quot;7&quot;或&quot;SAT&quot;。如果在&quot;L&quot;前加上数字，则表示该数据的最后一个。例如在周字段上设置&quot;6L&quot;这样的格式,则表示“本月最后一个星期五&quot; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置&quot;15W&quot;，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 &quot;1W&quot;,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，&quot;W&quot;前只能设置具体的数字,不允许区间&quot;-&quot;). &lt;/span&gt;&lt;br/&gt;&lt;span&gt;小提示 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;'L'和 'W'可以一组合使用。如果在日字段上设置&quot;LW&quot;,则表示在本月的最后一个工作日触发(一般指发工资 ) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 序号(表示每月的第几个周几)，例如在周字段上设置&quot;6#3&quot;表示在每月的第三个周六.注意如果指定&quot;#5&quot;,正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;小提示 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;周字段的设置，若使用英文字母是不区分大小写的 MON 与mon相同. &lt;/span&gt;&lt;br/&gt;&lt;span&gt;常用示例: &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 0 12 * * ? 每天12点触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 ? * * 每天10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 * * ? 每天10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 * * ? * 每天10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 * * ? 2005 2005年每天10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 * 14 * * ? 每天下午的 2点到2点59分每分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 0/5 14 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 0/5 14,18 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;每天下午的 18点到18点59分(整点开始，每隔5分触发) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 0-5 14 * * ? 每天下午的 2点到2点05分每分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 10,44 14 ? 3 WED     3月分每周三下午的 2点10分和2点44分触发 （特殊情况，在一个时间设置里，执行两次或                                                             两次以上的情况） &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 59 2 ? * FRI    每周5凌晨2点59分触发； &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 ? * MON-FRI 从周一到周五每天上午的10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 15 * ? 每月15号上午10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 L * ? 每月最后一天的10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 ? * 6L 每月最后一周的星期五的10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 ? * 6L 2002-2005 从2002年到2005年每月最后一周的星期五的10点15分触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 15 10 ? * 6#3 每月的第三周的星期五开始触发 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 0 12 1/5 * ? 每月的第一个中午开始每隔5天触发一次 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;0 11 11 11 11 ? 每年的11月11号 11点11分触发(光棍节)&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 21 Oct 2017 06:08:00 +0000</pubDate>
<dc:creator>不是植物</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuziyu/p/7704661.html</dc:identifier>
</item>
<item>
<title>数据结构与算法--从平衡二叉树(AVL)到红黑树 - sunhaiyu</title>
<link>http://www.cnblogs.com/sun-haiyu/p/7704654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sun-haiyu/p/7704654.html</guid>
<description>&lt;p&gt;上节学习了二叉查找树。算法的性能取决于树的形状，而树的形状取决于插入键的顺序。在最好的情况下，n个结点的树是完全平衡的，如下图“最好情况”所示，此时树的高度为&lt;code&gt;⌊log2 n⌋ + 1&lt;/code&gt;，所以时间复杂度为O(lg n)当我们将键以升序或者降序插入的时候，得到的是一棵斜树，如下图中的“最坏情况”，树的高度为n，时间复杂度也变成了O(n)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/bst_10.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在最坏情况下，二叉查找树的查找和插入效率很低。为了解决这个问题，引出了平衡二叉树(AVL)。&lt;/p&gt;
&lt;h2 id=&quot;平衡二叉树介绍&quot;&gt;平衡二叉树介绍&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;平衡二叉树，首先是一棵二叉查找树，但是它满足一点重要的特性：每一个结点的左子树和右子树的高度差最多为1。&lt;/strong&gt;这个高度差限制就完全规避了上述的最坏情况，因此查找、插入和删除的时间复杂度都变成了O(lg n)。&lt;/p&gt;
&lt;p&gt;为了反映每个结点的高度差，在二叉查找树的结点中应该增加一个新的域——被称为平衡因子(BF)，它的值是某个根结点的左子树深度减右子树深度的值。易知，&lt;strong&gt;对于一棵平衡二叉树，每个结点的平衡因子只可能是-1、0、1三种可能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/avl_1.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中图1和图4是平衡树。图2根本不是二叉查找树，因为59大于58却是58的左子结点；图3中结点58的左子树高度为3而右子树的高度为0，不满足平衡二叉树的定义。不过将图3稍作改变，得到图4，它就是一棵平衡二叉树了。&lt;/p&gt;
&lt;p&gt;将每个结点的平衡因子控制在-1、0、1三个值是靠一种称为&lt;strong&gt;旋转(Rolate)&lt;/strong&gt;的操作保证的，视情况分为&lt;strong&gt;左旋转&lt;/strong&gt;和&lt;strong&gt;右旋转&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/avl_2.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图插入1的时候，发现根结点3的平衡因子变成了2（正数），对结点3进行右旋转修正成上图2的样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/avl_3.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而当插入5时，发现结点3的平衡因子为-2（负数），所以需要对结点3进行左旋转修正成上图5的样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/avl_4.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看插入结点9的情况，结点7的平衡因子变成了-2，按理说应该对7进行左旋转（上图11），然而得到的确实图11虚线框中的子树，9位于10的右子结点这明显就是错的。究其原因，主要是因为&lt;strong&gt;不平衡结点7和它的子树10的平衡因子符号相反（一正一负），这种情况出现在新结点插入在根结点的左孩子的右子树、或者根结点的右孩子的左子树。&lt;/strong&gt;后者情况下（即上图情况），需要先对根结点7的子结点10先作右旋转处理再对根结点7进行左旋处理。再回头看前两种插入情况，都是在根结点的左孩子的的左子树或者根结点的右孩子的右子树上插入的，根结点的平衡因子符号和它子结点的平衡因子符号相同。&lt;/p&gt;
&lt;p&gt;接下来看看这个旋转处理是怎么用代码表示的，以下所说的“根结点”指的是任意子树的根。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;rotateLeft&lt;/span&gt;(Node h) {
    Node x = h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 根结点的右孩子保存为x&lt;/span&gt;
    h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = x.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 根结点右孩子的左孩子挂到根结点的右孩子上&lt;/span&gt;
    x.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; = h; &lt;span class=&quot;co&quot;&gt;// 根结点挂到根结点右孩子的左孩子上&lt;/span&gt;
    h = x; &lt;span class=&quot;co&quot;&gt;// 根结点的右孩子代替h称为新的根结点&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(Node h) {
    Node x = h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 根结点的左孩子保存为x&lt;/span&gt;
    h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; = x.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 根结点左孩子的右孩子挂到根结点的左孩子上&lt;/span&gt;
    x.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = h; &lt;span class=&quot;co&quot;&gt;// 根结点挂到根结点左孩子的右孩子上&lt;/span&gt;
    h = x; &lt;span class=&quot;co&quot;&gt;// 根结点的左孩子代替h称为新的根结点&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建议在纸上画画加深理解，其实旋转操作没那么难。&lt;/p&gt;
&lt;p&gt;插入的话就是以下四种情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在根结点的左孩子的左子树上插入，对根结点进行右旋转。调用&lt;code&gt;rotateRight&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在根结点的右孩子的右子树上插入，对根结点进行左旋转。调用&lt;code&gt;rotateLeft&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在根结点的左孩子的右子树上插入，先对根结点的左孩子进行左旋转，再对根结点进行右旋转。调用&lt;code&gt;rotateLeft(h.left);rotateRight(h);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在根结点的右孩子的左子树上插入，先对根结点的右孩子进行右旋转，再对根结点进行左旋转。调用&lt;code&gt;rotateRight(h.right);rotateLeft(h);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;插入之后还要调整每个结点的平衡因子，看起来比较麻烦，代码量不小。删除操作也是比较麻烦。由于我们的重点在于讲解红黑树，平衡查找树只是抛砖引玉。所以对于平衡二叉树的介绍就到此为止。&lt;/p&gt;
&lt;h2 id=&quot;树介绍&quot;&gt;2-3树介绍&lt;/h2&gt;
&lt;p&gt;为了保证查找树的平衡性，我们允许树中一个结点保存多个键 。标准二叉查找树中的结点只能保存一个键，拥有两条链接，这种结点被称为&lt;strong&gt;2-结点&lt;/strong&gt;；如果某个结点可以存储两个键，拥有3条链接。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2-结点，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。&lt;/li&gt;
&lt;li&gt;3-结点，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们规定，一个2-结点要么拥有两个子结点，要么没有子结点；一个3-结点要么拥有三个子结点，要么没有子结点。这样的保证使得2-3树的所有叶子结点位于同一层，也就是说所有叶子结点到根结点的路径长度是一样的，达到了所谓的完美平衡。如下是一棵2-3树&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/23_1.PNG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;树的查找&quot;&gt;2-3树的查找&lt;/h3&gt;
&lt;p&gt;2-3树的查找和标准的二叉查找树如出一辙，只是多了在中链接的递归查找。具体来说：先将要查找的key与2-3树的根结点比较，若和根结点中任意一个键相等则查找命中；否则，若key小于根结点中的较小键，在根结点的左子树中递归查找；若key大于根结点中的较大者，在根结点的右子树中递归查找；若key在根结点两个键的之间，则在根结点的中子树中递归查找...下面分别展示了查找成功和失败的轨迹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/23_2.PNG&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;树的插入&quot;&gt;2-3树的插入&lt;/h3&gt;
&lt;p&gt;插入操作，肯定是查找未命中时。如果未命中的查找结束于一个2-结点，直接插入到该结点中，使其变成3-结点就好了。可如果查找结束于一个3-结点该怎么办呢？2-3树中并不允许4-结点啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/23_3.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有几种情况，我们一一来看。&lt;/p&gt;
&lt;h4 id=&quot;向一棵只含有一个3-结点的树中插入新键&quot;&gt;向一棵只含有一个3-结点的树中插入新键&lt;/h4&gt;
&lt;p&gt;考虑一种最简单的情况，一棵2-3树中只有一个3-结点，此时插入一个新键。我们可以这样做：先让该键暂时存放于3-结点中，随即将3个键中排名中间的键向上移（因此树的高度增加了1），左边的键成为上移键的左子结点，右边的键成为上移键的右子树，最后这个临时的4-结点被分解成了3个2-结点。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/23_4.PNG&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;向一个父结点是2-结点的3-结点中插入新键&quot;&gt;向一个父结点是2-结点的3-结点中插入新键&lt;/h4&gt;
&lt;p&gt;如果树比较复杂，其实也没关系，和上面的简单情况是同样的处理方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/23_5.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，排名中间的键X上移和R合并称为了3-结点。&lt;/p&gt;
&lt;h4 id=&quot;向一个父结点是3-结点的3-结点插入新键&quot;&gt;向一个父结点是3-结点的3-结点插入新键&lt;/h4&gt;
&lt;p&gt;一样的处理方法，无非就是再向上移，如下左图所示，在树的底部插入D，将排名中间的C上移和EJ合并成4-结点，继续将排名中间的E上移，和根结点M合并成为3-结点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/23_6.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果到根结点还是4-结点呢，那就按照第一种情况处理——向一棵只含有3-结点的树中插入新键，只需将4-结点分解成3个2-结点即可，同时树的高度增加了1。&lt;/p&gt;
&lt;h4 id=&quot;局部变换与全局性质&quot;&gt;局部变换与全局性质&lt;/h4&gt;
&lt;p&gt;4-结点的分解是局部的：除了相关的结点和链接之外，树的其他所有结点的状态都不会被修改。即每次变换，不是整棵树都变化了。下图能比较直观理解这种变换的局部性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/23_7.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些局部变换不会影响树的全局有序性和平衡性：任意叶子结点到根结点的路径长度都是相等的。&lt;/p&gt;
&lt;h3 id=&quot;树的删除&quot;&gt;2-3树的删除&lt;/h3&gt;
&lt;p&gt;2-3树的插入分好几种情况，但还算不难理解。删除操作的话就更难了。这里只介绍简单的情况，删除最小最大键。删除任意键在红黑树中会有介绍。&lt;/p&gt;
&lt;p&gt;如果要删除的结点是一个3-结点，最简单，直接删除掉，因此3-结点变成了2结点。&lt;/p&gt;
&lt;p&gt;如果删除的是一个2-结点呢？&lt;/p&gt;
&lt;h4 id=&quot;删除最小键&quot;&gt;删除最小键&lt;/h4&gt;
&lt;p&gt;先看最小键的删除。如果当前要被删除的结点是一个2-结点，那就想办法把它变成一个3-结点或者4-结点，然后直接删除即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/23_10.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图中的5种变换：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前的结点左子结点和右子结点都是2-结点，见图中第1、4种变换，它们是将这三个结点合并成了一个4-结点。&lt;/li&gt;
&lt;li&gt;当前结点的左子结点是2-结点，但是右子结点不是2-结点。见图中第2、3种情况，它们的做法是从左子结点的兄弟结点中借一个最小的键到当前结点（它们的父结点），再将当前结点中最小的键移动到左子结点中。&lt;/li&gt;
&lt;li&gt;一旦要被删除结点不是2-结点就可以执行删除了，这保证了2-3树的有序性和平衡性。见图中第5种变换。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;删除最大键&quot;&gt;删除最大键&lt;/h4&gt;
&lt;p&gt;和删除最小键的处理方法类似。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/23_11.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也是当前结点的左右子结点都是2-结点就将这三个结点合并成4-结点，如图左边的combine siblings；当右子结点是2-结点，左子结点不是2-结点，那么从右子结点的兄弟结点中借一个最大结点到当前结点（它们的父结点），然后将当前结点中最大的键移动到右子结点，如图中borrow from siblings。&lt;/p&gt;
&lt;h2 id=&quot;红黑树&quot;&gt;红黑树&lt;/h2&gt;
&lt;p&gt;2-3树理解不难，而且和平衡二叉树比讨论情况有所减少。而接下来介绍的左倾&lt;strong&gt;红黑树（Left leaning Red-Black Tree）&lt;/strong&gt;就是为了用简单的方法实现2-3树，进一步减少讨论的情况和代码量。2-3树中2-结点就是标准二叉查找树中的结点，为了表达3-结点需要附加额外的信息。这里讲的红黑树可能有别于常规的定义方法。接下来你会看到，我们&lt;strong&gt;在结点与结点的链接上着色（而不是着色结点）。&lt;/strong&gt;左倾红黑树必须满足以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;红链接均是红链接，即不存在有某个右链接是红色的，这可以保证更少的讨论情况从而减少代码量。&lt;/li&gt;
&lt;li&gt;没有任何一个结点同时和两条红链接相连，也就是不允许连续的两条红链接、或者一个结点的左右链接都是红色。&lt;/li&gt;
&lt;li&gt;该树是&lt;strong&gt;完美黑色平衡&lt;/strong&gt;的，也就是说任意叶子结点到根结点的路径上黑色链接数量相同。&lt;/li&gt;
&lt;li&gt;根结点始终是黑色的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们将两个用红色链接相连的结点表示为一个3-结点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_2.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，加粗的黑线（没找到彩图...）是被着色为红色的链接，a和b被红链接相连，因此a、b其实是一个3-结点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_1.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是个彩图了...同样的我们可以定义4-结点：某结点的左右链接都是红的，和这两条红链接相连的三个结点就是一个4-结点，这里只是提一下，左倾红黑树不会用到4-结点。下面我们如果提到“红黑树”那它指代就是“左倾红黑树”。&lt;/p&gt;
&lt;p&gt;因此我们完全可以用附带了颜色信息的二叉查找树来表示2-3树。而且标准二叉查找树中的&lt;code&gt;get(Key key)&lt;/code&gt;方法无需修改直接就能用于左倾红黑树！容易知道，&lt;strong&gt;红黑树既是二叉查找树，又是2-3树。因此它结合了两者的优势：二叉查找树中高效的查找方法和2-3树中高效的平衡插入算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到一棵红黑树，如果将其直观地表示成2-3树呢？我们只需将所有左链接画平，并将与红链接相连的结点合并成一个3-结点即可。如下所示，加粗的黑色链接是红链接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_3.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前一直说链接的红黑，&lt;strong&gt;表达的是指向某个结点的链接的颜色。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_4.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如上图中C、E之间的链接是红色的，这条链接指向C，因此这条链接的颜色是属于结点C的，我们也可以简单地说“（指向）C结点（的链接）是红色的”；那么对于结点J，指向它的链接颜色是黑的。叶子结点也有左右链接，虽然它们都是空，&lt;strong&gt;约定（指向null的）空链接的颜色是黑色的。&lt;/strong&gt;如A的左子结点的链接颜色&lt;code&gt;A.left.color = BLACK&lt;/code&gt;。哦对了，还有指向根结点的链接（虽然这么说很奇怪，因为事实上并没有链接指向根结点，为了保持结点性质的一致性，我们还是这么叫了），上面左倾红黑树的定义中有说到其颜色必须是黑色的，因为根结点的左孩子有可能是红链接，如果根结点也是红链接，就违反了定义的第二条——没有任何一个结点同时和两条红链接相连。总之上面提到了一些约定，这些都是为了我们实现时更加方便，所以在代码中要时刻保证这些约定。&lt;/p&gt;
&lt;p&gt;说了这么多，来试着用代码实现吧。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package Chap8;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; LLRB&amp;lt;Key, Value&amp;gt; {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; RED = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; BLACK = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node root;

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Node {
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Key key;
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Value value;
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node left, right;
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; N; &lt;span class=&quot;co&quot;&gt;// 结点计数器，以该结点为根的子树结点总数&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; color; &lt;span class=&quot;co&quot;&gt;// 指向该结点的链接颜色&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Node(Key key, Value value, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; N, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; color) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt; = key;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; = value;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;N&lt;/span&gt; = N;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = color;
        }
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(Node x) {
        &lt;span class=&quot;co&quot;&gt;// 约定空链接为黑色&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (x == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; BLACK;
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; x.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; == RED;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先给出了左倾红黑树的基本实现，在标准二叉查找树中新增了&lt;code&gt;color&lt;/code&gt;域，表示指向该结点的链接颜色。对应的&lt;code&gt;isRed(Node x)&lt;/code&gt;判断指向该结点的链接是不是红色的，如果x == null表示这是条空链接，出于之前的约定，应该返回黑色。&lt;/p&gt;
&lt;h3 id=&quot;旋转&quot;&gt;旋转&lt;/h3&gt;
&lt;p&gt;为了保证红黑树的特性——不存在右链接是红色的、以及没有任何一个结点同时和两条红链接相连，在对红黑树进行操作时，比如插入或者删除，难免会出现红色右链接或者连续的两条红链接，应该确保每次操作完成之前这些情况已经被修正。这种对链接颜色的修正靠的是一种称为&lt;strong&gt;旋转&lt;/strong&gt;的操作完成的，和上述平衡树中的旋转操作基本类似，不过这里加入了对链接颜色信息的修正。&lt;/p&gt;
&lt;p&gt;旋转操作会改变红链接的指向，比如一条红色的右链接需要转换为红色的左链接，这个操作被称为&lt;strong&gt;左旋转&lt;/strong&gt;，右旋转和左旋转是对称的。如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_5.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_6.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面两张图，从红色右链接变到红色左链接，是&lt;strong&gt;左旋转&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_7.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_8.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面两张图，从红色左链接变到红色右链接，是&lt;strong&gt;右旋转&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;旋转操作也是局部的，只会影响旋转相关的结点，树中其他结点不受影响，而且旋转操作不会破坏整棵树的有序性和平衡性，如图中小于a、位于a和b之间、大于b这些大小关系在旋转前后没有改变！&lt;/p&gt;
&lt;p&gt;由图可写出旋转操作的实现&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;rotateLeft&lt;/span&gt;(Node h) {
    Node x = h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 根结点的右子结点保存为x&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 其实就是h和x互换位置&lt;/span&gt;
    h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = x.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 根结点的右子结点的左孩子挂到根结点的右子结点上&lt;/span&gt;
    x.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; = h; &lt;span class=&quot;co&quot;&gt;// 根结点挂到根结点右子结点的左子结点上&lt;/span&gt;
    x.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = h.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 原来h是什么颜色，换过去的x也应该是什么颜色&lt;/span&gt;
    h.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = RED;     &lt;span class=&quot;co&quot;&gt;// 将红色右链接变成红色左链接，因此x是红色的，h和x互换位置所以换过去的h也应该是RED&lt;/span&gt;
    x.&lt;span class=&quot;fu&quot;&gt;N&lt;/span&gt; = h.&lt;span class=&quot;fu&quot;&gt;N&lt;/span&gt;;  &lt;span class=&quot;co&quot;&gt;// x的结点数和h保持一致&lt;/span&gt;
    h.&lt;span class=&quot;fu&quot;&gt;N&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) + &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;) + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// 这里不能用原x.N赋值给h.N，因为旋转操作后原来x的子树和现在h的子树不一样&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 返回取代h位置的结点x，h = rotateLeft(Node h)就表示x取代了h&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; x;
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;retateRight&lt;/span&gt;(Node h) {
    Node x = h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;;
    h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; = x.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;;
    x.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = h;
    x.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = h.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt;;
    h.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = RED; &lt;span class=&quot;co&quot;&gt;// x原来是红色的&lt;/span&gt;
    x.&lt;span class=&quot;fu&quot;&gt;N&lt;/span&gt; = h.&lt;span class=&quot;fu&quot;&gt;N&lt;/span&gt;;
    h.&lt;span class=&quot;fu&quot;&gt;N&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) + &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;) + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; x;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;查找和插入&quot;&gt;查找和插入&lt;/h3&gt;
&lt;p&gt;查找操作直接使用标准二叉查找树的get方法，改都不用改的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 非递归get&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Value &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(Key key) {
    Node cur = root;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (cur != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; cmp = key.&lt;span class=&quot;fu&quot;&gt;compareTo&lt;/span&gt;(cur.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (cmp &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        cur = cur.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;;
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (cmp &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        cur = cur.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;;
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; cur.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;;
        }
    }
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入就稍微麻烦一点了。由于红黑树也是2-3树，所以插入情况请参考上述对2-3树插入的探讨。&lt;/p&gt;
&lt;h4 id=&quot;向2-结点中插入新键&quot;&gt;向2-结点中插入新键&lt;/h4&gt;
&lt;p&gt;这是最简单的情况了，按照2-3树插入的思路，直接使这个2-3结点变成3-结点。对应到红黑树中，如果新键小于父结点，只需将该键挂到父结点的左边且链接是红色；如果新键大于父结点，只需将该键挂到老键的右边且链接是红色，但这就违反了红黑树的特性（右链接不能是红色），因此上面的旋转操作就派上用场了，只需对其进行左旋转即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_9.PNG&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;向3-结点中插入一个新键&quot;&gt;向3-结点中插入一个新键&lt;/h4&gt;
&lt;p&gt;如果树只由一个3-结点构成。插入有三种情况，分别是新键最大插入到结点右边、新键最小插入到结点的左边、新键位于两者之间插入到中间。&lt;/p&gt;
&lt;p&gt;回忆2-3树中往3-结点中插入的情况，我们的做法是先将新键存在一个临时的4-结点中，然后将排名中间的键往上移，4-结点分解成了3个2-结点，同时树高增加1。这在红黑树中很好实现，4-结点也就是一个结点拥有两条红色链接，至于排名中间的键上移，只需将链接的颜色反转即可。如下是结点链接反色的示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_11.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左图是一个4-结点，&lt;strong&gt;通过将h的两个子结点的颜色变成BLACK、将h变成RED就达到了上移的目的，而且4-结点正确地被分解成了三个2-结点，h变红正好可以和上一层的2-结点合并成3-结点；或者和3-结点合并成4-结点后继续执行分解操作，如此这般一直到遇到一个2-结点为止。&lt;/strong&gt;这完全符合2-3树中的插入操作！反转结点链接颜色的代码非常简单，但是又相当重要，我们将看到，向3-结点中插入的种种情况最终都会转换成上面的情况。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;flipColors&lt;/span&gt;(Node h) {
    h.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = !h.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt;;
    h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = !h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt;;
    h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = !h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;向一棵只有3-结点的树中插入新键分以下三种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新键大于3-结点中的两个键，那么直接连接到3-结点较大键的右链接且颜色为红色。此时直接调用&lt;code&gt;flipColors&lt;/code&gt;方法即可；&lt;/li&gt;
&lt;li&gt;新键小于3-结点中的两个键，那么该键会连接到3-结点较小键的的左链接且颜色为红色，此时出现了连续两条的红链接，是不允许的，通过&lt;strong&gt;右旋转&lt;/strong&gt;变成了情况1，再调用&lt;code&gt;flipColors&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新键位于3-结点的两个键之间，那么该键会链接到3-结点较小键的右链接上且颜色为红色，此时出现红色右链接，是不允许的，通过&lt;strong&gt;左旋转&lt;/strong&gt;修正后变成了情况2，于是右旋转，变成情况1，最后调用&lt;code&gt;flipColors&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_10.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是在树底部的某个3-结点插入新键，有可能包含以上全部三种情况！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_14.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你回头看各种情况的插入操作，我们&lt;strong&gt;总是用红链接将新结点和它的父结点相连&lt;/strong&gt;。这么做是为了符合2-3树中各种插入情况。而且因为三种情况里有些情况会进行其他情况的处理，在实现时一定要注意处理的顺序。比如情况3里包含了情况2和情况1的处理，情况2中包含了情况1的处理，那么在处理时应该先判断情况3，再判断情况2，最后判断情况1。&lt;/p&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果右子结点是红色的而左子结点是黑色的，进行左旋转，目的是将红色右链接变成红色左链接。&lt;/li&gt;
&lt;li&gt;如果右子结点是红色的而左子结点是黑色的，进行左旋转。&lt;/li&gt;
&lt;li&gt;如果左右子结点均为红色，进行颜色反转。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的表述按顺序翻译成代码就可以实现put方法了。&lt;/p&gt;
&lt;p&gt;它们互相转换的关系如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_15.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对了还有一点，颜色反转有可能导致根结点的颜色也变成红色，但是我们&lt;strong&gt;约定根结点总是黑色的&lt;/strong&gt;。所以每次put操作后，记得手动将&lt;code&gt;root.color&lt;/code&gt;置为黑色。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(Key key, Value value) {
    root = &lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(root, key,value);
    &lt;span class=&quot;co&quot;&gt;// 保证根结点始终为黑色&lt;/span&gt;
    root.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = BLACK;
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(Node h, Key key, Value value) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (h == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node(key, value, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, RED);
    }
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; cmp = key.&lt;span class=&quot;fu&quot;&gt;compareTo&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (cmp &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;, key, value);
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (cmp &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;){
        h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;, key, value);
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        h.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; = value;
    }

    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     下面连续三个判断是和标准二叉查找树put方法不同的地方，目的是修正红链接&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 如果右子结点是红色的而左子结点是黑色的，进行左旋转&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 之后返回值赋给h是让x取代原h的位置，不可少&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;) &amp;amp;&amp;amp; !&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h = &lt;span class=&quot;fu&quot;&gt;rotateLeft&lt;/span&gt;(h);
    }
    &lt;span class=&quot;co&quot;&gt;// 如果右子结点是红色的而左子结点是黑色的，进行左旋转&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h = &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(h);
    }
    &lt;span class=&quot;co&quot;&gt;// 如果左右子结点均为红色，进行颜色反转&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;)) {
        &lt;span class=&quot;fu&quot;&gt;flipColors&lt;/span&gt;(h);
    }

    h.&lt;span class=&quot;fu&quot;&gt;N&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) + &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;) + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; h;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;删除&quot;&gt;删除&lt;/h3&gt;
&lt;p&gt;红黑树的删除和上面提到的2-3树的删除是一致的。对照着上述2-3树删除的各种情况来实现红黑树的删除，理解起来就不那么复杂了。&lt;/p&gt;
&lt;p&gt;还是先从简单的入手。&lt;/p&gt;
&lt;h4 id=&quot;删除最小键-1&quot;&gt;删除最小键&lt;/h4&gt;
&lt;p&gt;如果要删除的是一个3-结点，那么直接删除。如果要删除的是一个2-结点，说明&lt;code&gt;h.left == BLACK &amp;amp;&amp;amp; h.left.left ==BLACK&lt;/code&gt;，逆向思考我们保证&lt;code&gt;h.left&lt;/code&gt;或&lt;code&gt;h.left.left&lt;/code&gt;任意一个是RED就说明要删除的结点是一个3-结点，之后再删除就简单了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_a.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图当前结点B，&lt;code&gt;B.left = BLACK &amp;amp;&amp;amp; B.left.left = BLACK&lt;/code&gt;，此时只需flipColor将ABC合并成4-结点即可执行删除。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_c.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反转颜色后使得&lt;code&gt;h.left = RED&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还有种更难的情况，在满足上述两个结点链接都是黑色的情况下，如果&lt;code&gt;h.right.left = RED&lt;/code&gt;呢？如下，当前结点h = E&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_f.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照2-3树删除方法，应该从A的兄弟结点借一个最小键到当前结点，再将当前结点中最小键移到A中合并成一个3-结点，再执行删除。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_d.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过一系列的变换，从图中可看出先是&lt;code&gt;rotateRight(h.right)&lt;/code&gt;，再&lt;code&gt;rotateLeft(h)&lt;/code&gt;，然后&lt;code&gt;filpColors(h)&lt;/code&gt;最终使得&lt;code&gt;h.left.left = RED&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;其他情况如当前结点为D，&lt;code&gt;D.left.left = RED&lt;/code&gt;，BC中可以直接删除B。或者如果递归到了C是当前结点，&lt;code&gt;C.left = RED&lt;/code&gt;也能直接删除而无需其他操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbt_b.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在递归自顶而下的过程中，我们对若干结点都进行了颜色反转及旋转操作，这些操作都可能影响数的有序性和平衡性，所以在返回的自下而上的过程中，要对树进行修正，修正的方法和put方法中的修正方法完全一样，抽取出来作为一个方法，如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;fixUp&lt;/span&gt;(Node h) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;) &amp;amp;&amp;amp; !&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h = &lt;span class=&quot;fu&quot;&gt;rotateLeft&lt;/span&gt;(h);
    }
    &lt;span class=&quot;co&quot;&gt;// 如果右子结点是红色的而左子结点是黑色的，进行左旋转&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h = &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(h);
    }
    &lt;span class=&quot;co&quot;&gt;// 如果左右子结点均为红色，进行颜色反转&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;)) {
        &lt;span class=&quot;fu&quot;&gt;flipColors&lt;/span&gt;(h);
    }

    h.&lt;span class=&quot;fu&quot;&gt;N&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) + &lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;) + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; h;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了上面讲解的基础，实现deleteMin就不难了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;moveRedLeft&lt;/span&gt;(Node h) {
    &lt;span class=&quot;co&quot;&gt;// 当此方法被调用时，h是红色的，h.left和h.left.left都是黑色的&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 整个方法结束后h.left或者h.left.left其中之一被变成RED&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;flipColors&lt;/span&gt;(h);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;);
        h = &lt;span class=&quot;fu&quot;&gt;rotateLeft&lt;/span&gt;(h);
        &lt;span class=&quot;fu&quot;&gt;flipColors&lt;/span&gt;(h);
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; h;
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;deleteMin&lt;/span&gt;(Key key) {
    &lt;span class=&quot;co&quot;&gt;// 这里将root设置为红色是为了和moveRedLeft里的处理一致&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 即当前结点h是红色的，其两个子结点都是黑色的，在反色后，当前结点h变成黑色，而它的两个子结点变成红色&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(root.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) &amp;amp;&amp;amp; !&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(root.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;)) {
        root.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = RED;
    }
    root = &lt;span class=&quot;fu&quot;&gt;deleteMin&lt;/span&gt;(root, key);
    &lt;span class=&quot;co&quot;&gt;// 根结点只要不为空，删除操作后保持始终是黑色的&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;()) {
        root.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = BLACK;
    }
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;deleteMin&lt;/span&gt;(Node h, Key key) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
    &lt;span class=&quot;co&quot;&gt;// 不像标准二叉查找树那样返回h.right, 因为put方法就决定了h.left和h.right要么同时为空要么同时不为空&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }
    &lt;span class=&quot;co&quot;&gt;// 合并成4-结点或者从兄弟结点中借一个过来&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) &amp;amp;&amp;amp; !&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h = &lt;span class=&quot;fu&quot;&gt;moveRedLeft&lt;/span&gt;(h);
    }

    h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;deleteMin&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;, key);
    &lt;span class=&quot;co&quot;&gt;// 返回时，自下而上地修正路径上的结点&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;fixUp&lt;/span&gt;(h);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看个删除最小键的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbtdelete_g.PNG&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;删除最大键-1&quot;&gt;删除最大键&lt;/h4&gt;
&lt;p&gt;删除最大键和删除最小键是对称的，但有些不一样。删除最小键在自顶向下的过程中保证&lt;code&gt;h.left&lt;/code&gt;或者&lt;code&gt;h.left.left&lt;/code&gt;为红色，类似地&lt;strong&gt;删除最大键在自顶向下的过程中要保证&lt;code&gt;h.right&lt;/code&gt;或者&lt;code&gt;h.right.right&lt;/code&gt;为红色，但是我们定义红黑树是左倾的！这意味着红色链接默认就是左链接，因此要使用删除最小键的方法来达到删除最大键的目的，必须在处理之前将红色链接变成右链接（右旋转操作），之后就和删除最小键的处理对称了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前结点&lt;code&gt;h.right = BLACK &amp;amp;&amp;amp; h.right.left = BLACK&lt;/code&gt;，反转颜色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbtdelete_j.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;满足上述情况的同时如果&lt;code&gt;h.left.left = RED&lt;/code&gt;，说明需要从兄弟结点中借一个键过来，为此还要进行下面的变换，最后&lt;code&gt;h.right.right&lt;/code&gt;变成红色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbtdelete_k.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;moveRedRight&lt;/span&gt;(Node h) {
    &lt;span class=&quot;fu&quot;&gt;flipColors&lt;/span&gt;(h);
    &lt;span class=&quot;co&quot;&gt;// 从兄弟结点借一个键&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h =&lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(h);
        &lt;span class=&quot;fu&quot;&gt;flipColors&lt;/span&gt;(h);
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; h;
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;deleteMax&lt;/span&gt;(Key key) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(root.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) &amp;amp;&amp;amp; !&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(root.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;)) {
        root.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = RED;
    }
    root = &lt;span class=&quot;fu&quot;&gt;deleteMax&lt;/span&gt;(root, key);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;()) {
        root.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = BLACK;
    }
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;deleteMax&lt;/span&gt;(Node h, Key key) {
    &lt;span class=&quot;co&quot;&gt;// 为了和deleteMin对称处理，先将红色左链接转换成红色右链接&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 转换为红色右链接是最先处理的！&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h = &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(h);
    }
    &lt;span class=&quot;co&quot;&gt;// 这个判断不能再上句之前，因为可能旋转前h.right是null，旋转后可就不是null了&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }
    &lt;span class=&quot;co&quot;&gt;// 这里条件中不是h.right.right，因为3-结点是左链接表示的&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;) &amp;amp;&amp;amp; !&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h = &lt;span class=&quot;fu&quot;&gt;moveRedRight&lt;/span&gt;(h);
    }
    h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;deleteMax&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;, key);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;fixUp&lt;/span&gt;(h);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来看两个删除最大键的例子，其中第一个例子删除后就已经平衡，无需修正；第二个例子中在自下而上的过程中有修正。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbtdelete_h.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的例子无修正。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbtdelete_i.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的例子有修正。&lt;/p&gt;
&lt;h4 id=&quot;删除任意键&quot;&gt;删除任意键&lt;/h4&gt;
&lt;p&gt;最难的方法。我自己也没太明白就来介绍这个方法可能不太妥当，只好尽力说个大概。至于代码中的控制流程（if-else的顺序）为什么是那样，本人也不理解。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;(Key key) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;contains&lt;/span&gt;(key)) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(root.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) &amp;amp;&amp;amp; !&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(root.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;)) {
        root.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = RED;
    }

    root = &lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;(root, key);

    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;()) {
        root.&lt;span class=&quot;fu&quot;&gt;color&lt;/span&gt; = BLACK;
    }
}

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;(Node h, Key key) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (key.&lt;span class=&quot;fu&quot;&gt;compareTo&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;) &amp;amp;&amp;amp; !&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h = &lt;span class=&quot;fu&quot;&gt;moveRedLeft&lt;/span&gt;(h);
        }
        h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;, key);
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; { &lt;span class=&quot;co&quot;&gt;// 要么在根结点或者右子树，两种情况包含在一起了&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 要在右子树处理，所以确保是红色右链接&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h = &lt;span class=&quot;fu&quot;&gt;rotateRight&lt;/span&gt;(h);
        }
      
        &lt;span class=&quot;co&quot;&gt;// 要删除的结点在树底&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (key.&lt;span class=&quot;fu&quot;&gt;compareTo&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        }
        &lt;span class=&quot;co&quot;&gt;// 这个判断必须在上个判断之后，因为确保h.right不为空后才能调用h.right.left&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;) &amp;amp;&amp;amp; !&lt;span class=&quot;fu&quot;&gt;isRed&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;left&lt;/span&gt;)) {
        h = &lt;span class=&quot;fu&quot;&gt;moveRedRight&lt;/span&gt;(h);
        }
        &lt;span class=&quot;co&quot;&gt;// 要删除的键不在树底, 用它的后继结点替代它后，删除后继结点&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (key.&lt;span class=&quot;fu&quot;&gt;compareTo&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;) == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            Node x = &lt;span class=&quot;fu&quot;&gt;min&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;);
            h.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt; = x.&lt;span class=&quot;fu&quot;&gt;key&lt;/span&gt;;
            h.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt; = x.&lt;span class=&quot;fu&quot;&gt;value&lt;/span&gt;;
            h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;deleteMin&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// 没有相等的键，在右子树中递归&lt;/span&gt;
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;(h.&lt;span class=&quot;fu&quot;&gt;right&lt;/span&gt;, key);
        }
    }
    &lt;span class=&quot;co&quot;&gt;// 自下而上的结点修正&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;fixUp&lt;/span&gt;(h);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;公有&lt;code&gt;delete&lt;/code&gt;方法中还是延续了deleteMin/deleteMax那一套，只是增加了判断——如果key不在红黑树中，不进行任何操作直接返回。现在看私有方法：&lt;/p&gt;
&lt;p&gt;大概的思路是：从root开始查找，如果被删除的键比根结点小，递归地在左子树中查找；否则，被删除的键和根结点相同或者比根结点大，这个条件分支是最难的地方。&lt;strong&gt;进入else分支后，不管是不是和当前结点的键相同，首先就把红色左链接转换成红色右链接，这之后才判断当前结点的键是否和被删除结点的键相同。&lt;/strong&gt; 被删除的结点位置有两种情况，在树底和不在树底，不在树底时需要用它的后继结点替代更新被删除结点，之后再删除后继结点。两种情况下键都不相同的话，就递归地在右子树中查找。最后记得要自下而上地修正路径上各个结点，保证删除之后树的有序性和平衡性。&lt;/p&gt;
&lt;p&gt;看一个被删除的键不在树底的例子，如下图删除D。用D的后继结点E替代了D的位置，之后删除了E，最后修正结点颜色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://obvjfxxhr.bkt.clouddn.com/rbtdelete_aaa.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码中把“被删除键和当前键相同”、“比当前键大”这两种情况合并在一起讨论了，我尝试按照通常的思路，将这两种情况分开，即&lt;code&gt;else if (key.compareTo(h.key) == 0)&lt;/code&gt;和&lt;code&gt;else &amp;gt; 0&lt;/code&gt;；或者将&lt;code&gt;if (!isRed(h.right) &amp;amp;&amp;amp; !isRed(h.right.left))&lt;/code&gt;这个判断放到最后一个else里面，结果在进行了几次结点删除后都会出错。&lt;/p&gt;
&lt;p&gt;按照上面的控制流程，执行删除就不会出错，不过如果你稍微改变下if-else语句的顺序，在若干次删除操作后就可能出现错误——多半是树的平衡性被破坏了。&lt;/p&gt;
&lt;h3 id=&quot;其他api&quot;&gt;其他API&lt;/h3&gt;
&lt;p&gt;像min()/max()、select、rank、floor、ceiling和范围查找等相关方法，&lt;strong&gt;不作任何修改&lt;/strong&gt;，直接套用&lt;a href=&quot;http://www.cnblogs.com/sun-haiyu/p/7682618.html&quot;&gt;标准二叉查找树&lt;/a&gt;的对应方法即可。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;by @sunhaiyu&lt;/p&gt;
&lt;p&gt;2017.10.21&lt;/p&gt;
</description>
<pubDate>Sat, 21 Oct 2017 06:07:00 +0000</pubDate>
<dc:creator>sunhaiyu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sun-haiyu/p/7704654.html</dc:identifier>
</item>
<item>
<title>发挥个人的优势，踏踏实实的学习前端开发，为你传授学习心得 - 悟空前端</title>
<link>http://www.cnblogs.com/gongyue/p/7704617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gongyue/p/7704617.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;想跟每一位前端开发人员谈一谈学习前端开发的一些心得。本篇文章我就来给大家说一说我在学习前端开发过程中的一些经验，我把它们总结成了十条警言，希望能够对你的学习带来一些小的帮助。希望大家能为小编分享，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;文是《前端开发学习心得》的第二篇，为大家分享十条警言的后五条，承接上一篇文章的前五条。&lt;/p&gt;
&lt;p&gt;承接文章：&lt;strong&gt;学习前端开发，一段心路历程，这个世界根本没有速成的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171021134624615-216895305.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;web前端/html5学习群：250777811&lt;/p&gt;

&lt;p&gt;前端开发是当今社会上比较有发展潜力的一个行业，该行业主要以Web开发、移动端开发、全栈式开发等为主要内容。在社会上有较为广泛的应用领域，从业者有较为丰厚的薪资待遇。那么对于一个前端开发从业者来说，如何学习前端开发的相关知识，如何将自己打造为一个强大的前端开发设计师呢？小编从事多年的一线教学工作，深入挖掘学生在学习阶段的特点，总结了以下十条学习心得，愿意与大家一同分享。&lt;/p&gt;
&lt;p&gt;由于篇幅问题，我将《前端开发学习心得》分成了两篇文章，本篇文章为大家阐述后五条，前五条在文章开始的位置处有链接，大家可以点击阅读。&lt;/p&gt;

&lt;p&gt;前端开发需要学习的科目众多，知识点庞杂凌乱，非常难以记忆。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先我个人认为，在你的大脑中创建出整个前端开发的知识框架，才能说明你真的学会了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;其次，千万不要盲目地认为，到了工作中我就复制代码就可以了，常用的记住就行了。这种“代码可以在工作中复制”的思想从出发点上来说就是万万不能要的。表面看来确实是这样，但是本质上透露了一个学习者的学习态度和方法。带着这种思想去学习前端开发是学不到技术的。我个人认为，即使是复制粘贴，你也是要在理解原理的基础上来完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;再次，一种“我只学习工作中能够用到的，用不到的和我无关”的思想也在许多初学者身上暴露了出来。大家为了工作希望速成的心理可以理解，但是仔细想一想，学会了这门技术，可是大家一辈子的饭碗啊，你对它其他领域的应用就没有任何的兴趣吗？不想了解更多关于它的一些内容吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那可能有人就会说，这么多知识内容，如何记忆呢？这就需要大家多归纳总结。拿出一个小本子，把一些常用的代码写法总结出来，把学科之间有渗透的部分加以对比，慢慢地你就会拨开迷雾、豁然开朗。&lt;/p&gt;
&lt;p&gt;这里我给大家提出几个技术性的问题，看看是不是你需要总结你所学的知识点了呢？&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;jQuery所提供的所有选择器是不是需要总结一下。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在JavaScript中，如何为多个元素绑定相同的事件？这样的操作有几种方法？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;node.js中的文件模块所提供的读写文件的方法都有哪些？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;总结HTML5中canvas API中所有绘图的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于DOM节点的操作，jQuery和JavaScript各采用了哪些不同的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;利用JavaScript自定义类时，构造函数模式、原型模式、混合模式的各自优缺点都有哪些？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;想一想，闭包都用在哪些场合中？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大家看一看，我们需要总结的知识点是不是非常多。所以说，总结知识点也是大家每天学习的必备环节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171021134717224-1146487871.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rDcQOSiaLk3hdlY8fS0EAw9bqQaLLspgHyvfHkedYt85kHyBlEtIUya80pKYe3jUyrVY18goJgesCQ/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;450&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一门后台语言的掌握，对于一个前端开发人员来说有下列好处：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过对后台语言的学习，可以了解数据库技术的工作原理和应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更好的理解前后台数据传递的本质。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为学习全栈式开发打下一个基础。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在前端布局时，能够更好的配合后台开发人员。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当你自己接了一个私活时，可以前后台独立完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正所谓“技多不压身”。学的越多，站得越高，看得越远，越能够运筹帷幄。&lt;/p&gt;
&lt;p&gt;除此之外，有许多正在学习Ajax、AngularJS、VUE等技术的同学，由于没有接触过后台和数据库技术，根本不了解为什么要传递数据。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rDcQOSiaLk3hdlY8fS0EAw9bdORgmWsvhiaFraIXFbrK0gXggEoQvDZB5Uzxvj6zFzMZtOzIpdlhR5g/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;450&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171021134740802-519633537.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;web前端/javascript学习群：250777811&lt;/p&gt;
&lt;p&gt;那么，后台技术都有哪些呢？这里为大家简单的介绍一下。&lt;/p&gt;
&lt;p&gt;现在较为流行的后台技术主要有三种：&lt;strong&gt;ASP.net、JSP/Java、PHP&lt;/strong&gt;。首先这三门技术都可以实现后台所要求的所有功能，在对数据库的操作和原理上来说是没有区别的。区别在于用的哪种脚本语言，使用的哪种MVC框架以及一些自身独有的开发技巧。&lt;/p&gt;
&lt;p&gt;数据库方面主要包括&lt;strong&gt;MySQL、SQL Server、Oracle&lt;/strong&gt;。这三种数据库在基本操作上没有什么太大的区别，从前端开发的角度来看，学习者比较容易上手。&lt;/p&gt;
&lt;p&gt;在这里，建议多接触一下JSP/Java和ASP.net，学会使用&lt;strong&gt;Eclipse&lt;/strong&gt;和&lt;strong&gt;Visual Studio&lt;/strong&gt;工具，最基本的后台框架可以搭建起来，能够传递简单的数据，理解数据库在整个项目开发中的地位，能独立完成一个简单的项目。对于一个前端开发的学习者来说就足够了。如果有精力，系统的学习那就更好的。&lt;/p&gt;

&lt;p&gt;在今天这个日新月异的时代，IT技术的更新可谓是越来越快。任何企业都希望能够招到一名开发经验丰富、技术掌握扎实、懂得多会的多的设计师，但是事实是这类精英人才在社会上非常少，而且薪资要求也非常高。因此各个企业只能从刚刚入行两三年的人员队伍中寻求精英。&lt;/p&gt;
&lt;p&gt;这样，企业对于一个优秀的程序员就会提出一个非常基础的要求，那就是“学习能力”。&lt;/p&gt;
&lt;p&gt;说的再简单点就是：你不会，可以学啊！&lt;/p&gt;
&lt;p&gt;在工作中还像在学校时，一个学期学一门技术吗？不可能的，一个星期的时间有时候都不会给你留出来，三两天给我必须搞定。&lt;/p&gt;
&lt;p&gt;这种情况，我相信许多开发人员在参加工作的初期一定都遇到过。&lt;/p&gt;
&lt;p&gt;那么，如何提高自己的学习能力和自学速度呢？这里也提供几种简单的方法供大家参考。&lt;/p&gt;

&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;多读书。哪怕读一些与前端开发无关的书。读书可以锻炼我们的阅读速度，也能让我们的心智平静下来。如果说从事技术方面的工作，连一本完整的书都没有读完的毅力，真的会错过很多内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;看科技文章。关注一些科技类的公众号，多看这些公众号发布的科技类的小文章，这里面有许多长句子，可以锻炼我们大脑的理解能力，并提升我们的理解速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;自己讲。对于刚刚接触的技术或正在学习过程中的内容，可以自己讲给自己听。在自家讲的过程中，锻炼了大脑的反应能力和组织能力，对知识点的快速掌握也有很好地作用。正所谓教师掌握知识的速度一般都比较快也是这个道理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二十一世纪，学习能力对于各行各业都是非常的重要。你还有哪些适合自己的提升自学能力和学习的速度的方法，欢迎留言和大家一同分享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171021134806115-685823698.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KMM6ibady1rDcQOSiaLk3hdlY8fS0EAw9bzKggOo8AXVL3MiaNPRkoRpuejMIGUrAqMEFH3iahlpUUyW7Hicmg2gBRQ/0?wx_fmt=jpeg&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;450&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在许多公司的业务方向渐渐地从PC端过渡到了移动端。手机上的项目开发、微信开发等已经成为了当今开发的主流。这个方面一定不能忽略。&lt;/p&gt;
&lt;p&gt;这里，同样给大家介绍几款移动端框架，希望大家可以多多学习。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;jQuery Mobile，尽管这个框架使用的比较少，但是它与jQuery技术兼容的特点，以及简单的开发方法，可以作为第一门移动框架的学习首选。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Bootstrap，这个就不用说了，这是响应式开发的重要框架。一定要掌握。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Light 7，一个小型的模拟苹果手机UI的移动端框架，使用起来非常方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Framework 7，这个是比较常用的一款移动端框架。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，多了解一些有关微信公众号开发和微信小程序方面的知识就更好了。&lt;/p&gt;

&lt;p&gt;孔子说过：“学而不思则罔，思而不学则殆”。先秦圣贤在几千年前就为我们解释了“学习”与“思考”的辩证关系。&lt;/p&gt;
&lt;p&gt;学习任何技术，也需要大家不断地思考。思考一个小知识点在各个不同的领域是如何应用的。思考当今流行的效果是如何实现的。思考知识点之间是如何协同工作的。思考研发这些技术的人将技术设计成现在的样子当初是如何考虑的。&lt;/p&gt;
&lt;p&gt;你的大脑是你的财富，越用越灵活，越用越强大。一定要充分发挥我们大脑的潜质，让学习的过程不再是枯燥的接收，让知识的掌握不再是简单的速成。这样，才能循序渐进的养成为一个优秀的合格的设计师。&lt;/p&gt;
&lt;p&gt;（全文完）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1183589/201710/1183589-20171021134835927-691278665.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;web前端/html5学习群：250777811&lt;/p&gt;

&lt;p&gt;下一篇文章中，继续为大家讲解CSS属性。下一篇重点讲述浮动属性。浮动属性是流式定位的重要属性，承担了大部分传统布局的功能。希望广大前端学习者千万不要错过！&lt;/p&gt;
</description>
<pubDate>Sat, 21 Oct 2017 05:51:00 +0000</pubDate>
<dc:creator>悟空前端</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gongyue/p/7704617.html</dc:identifier>
</item>
<item>
<title>图形化控件开发 - 矩形控件 - 蓝建荣</title>
<link>http://www.cnblogs.com/lanxiaoke/p/7704352.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lanxiaoke/p/7704352.html</guid>
<description>&lt;p&gt;最近这段时间，公司需要做一个图形化配置工具。&lt;/p&gt;
&lt;p&gt;主要是有以下一些要求：&lt;/p&gt;
&lt;p&gt;1、针对一些底层的智能设备（智能楼宇的控制器），通过COM口连接上，并通过相关协议读取参数值&lt;/p&gt;
&lt;p&gt;2、支持一些基本的逻辑运算，以及公司业务的一些特性“点”，一种点可以看成一个图形化控件&lt;/p&gt;
&lt;p&gt;3、参数在图形化工具上显示出来，工程人员直接设置图形属性设置参数值、连线等&lt;/p&gt;
&lt;p&gt;4、支持在线和离线2种工作方式，设置好参数后直接在界面上下载到设备里&lt;/p&gt;
&lt;p&gt;5、工作太支持拖动，连线，放大缩小，保存设计文件等&lt;/p&gt;
&lt;p&gt;6、“点”的本身业务要求，略。。。&lt;/p&gt;

&lt;p&gt;经过一番调研，winfrom的图形化控件技术，并没有成熟的框架出来。&lt;/p&gt;
&lt;p&gt;只有一些零碎的demo，大体上的思路是通过重绘来实现具体的图形控件。&lt;/p&gt;
&lt;p&gt;在这里也提一下Netron框架，这个框架代码我看了很多遍，很多思路都从这里来，但是太繁琐了，改动起来非常吃力&lt;/p&gt;
&lt;p&gt;所以我自己重新写了一遍，大体思路没变，只是走精简路线，以下是我们的工具最终的界面样式，&lt;/p&gt;
&lt;p&gt;我打算把每一步都分拆贴出来，做成一个教程。给大家一个参考&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/254672/201710/254672-20171021113127756-1516445896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1、新建自定义控件抽象类&lt;/h2&gt;
&lt;p&gt;1.1 包含一些基本属性，如字体、是否悬停、是否选中、画布&lt;/p&gt;
&lt;p&gt;1.2 包含几个抽象方法，绘制控件皮肤、移动、悬停判断、重新绘制&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public abstract class AbstractShape
    {
        [Browsable(false)]
        public Font DefaultFont { get; private set; }

        [Browsable(false)]
        public Pen DefaultPen { get; private set; }

        [Browsable(false)]
        public bool IsHover { get; set; }

        [Browsable(false)]
        public bool IsSelected { get; set; }

        [Browsable(false)]
        public GraphControl Canvas { get; set; }

        public AbstractShape() { }
        public AbstractShape(GraphControl site)
        {
            DefaultFont = new Font(&quot;宋体&quot;, 10F);
            DefaultPen = new Pen(Brushes.Black, 1F);
            Canvas = site;
            IsHover = false;
            IsSelected = false;
        }

        public abstract void Paint(Graphics g);
        public abstract bool Hover(Point p);
        public abstract void Invalidate();
        public abstract void Move(Point p);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、绘制一个自定义控件基类&lt;/h2&gt;
&lt;p&gt;包含一些基本属性及一些共性方法实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class ShapeBase : AbstractShape
    {
        protected Rectangle RectangleBase;

        [Browsable(false)]
        public Brush ShapeBrush { get; protected set; }

        [Browsable(true), Description(&quot;Width&quot;), Category(&quot;Layout&quot;)]
        public int Width
        {
            get { return this.RectangleBase.Width; }
            set { Resize(value, this.Height); }
        }

        [Browsable(true), Description(&quot;Height&quot;), Category(&quot;Layout&quot;)]
        public int Height
        {
            get { return this.RectangleBase.Height; }
            set { Resize(this.Width, value); }
        }

        [Browsable(true), Description(&quot;X&quot;), Category(&quot;Layout&quot;)]
        public int X
        {
            get { return RectangleBase.X; }
            set
            {
                Point p = new Point(value - RectangleBase.X, RectangleBase.Y);
                this.Move(p);
                Canvas.Invalidate();
            }
        }

        [Browsable(true), Description(&quot;Y&quot;), Category(&quot;Layout&quot;)]
        public int Y
        {
            get { return RectangleBase.Y; }
            set
            {
                Point p = new Point(RectangleBase.X, value - RectangleBase.Y);
                this.Move(p);
                Canvas.Invalidate();
            }
        }

        [Browsable(true), Description(&quot;Text&quot;), Category(&quot;Layout&quot;)]
        public string Text { get;  set; }

        public ShapeBase(GraphControl site)
            : base(site)
        {
            Init();
        }

        private void Init()
        {
            RectangleBase = new Rectangle(0, 0, 100, 70);
            ShapeBrush = new SolidBrush(Color.SteelBlue);
        }

        public override void Paint(Graphics g)
        {
            return;
        }

        public override bool Hover(Point p)
        {
            return false;
        }

        public override void Invalidate()
        {
            Canvas.Invalidate(RectangleBase);
        }

        public override void Move(Point p)
        {
            this.RectangleBase.X += p.X;
            this.RectangleBase.Y += p.Y;
        }

        public virtual void Resize(int width, int height)
        {
            this.RectangleBase.Height = height;
            this.RectangleBase.Width = width;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、新建一个简单的矩形类&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class LjrRectangle : ShapeBase
    {
        public LjrRectangle(GraphControl s)
            : base(s)
        { }

        public override void Paint(Graphics g)
        {
            g.FillRectangle(base.ShapeBrush, base.RectangleBase);
            if (base.IsHover || base.IsSelected)
            {
                g.DrawRectangle(new Pen(Color.Red, 2F), base.RectangleBase);
            }
            else
            {
                g.DrawRectangle(base.DefaultPen, base.RectangleBase);
            }
        }
    }　
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4、新建画布GraphControl&lt;/h2&gt;
&lt;p&gt;所以自定义图形控件都将在这个画布里绘制、移动等操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class GraphControl : ScrollableControl
    {
        /// &amp;lt;summary&amp;gt;属性控件绑定事件&amp;lt;/summary&amp;gt;
        public delegate void ShowProperty(object ent);

        /// &amp;lt;summary&amp;gt;属性控件绑定事件&amp;lt;/summary&amp;gt;
        public event ShowProperty OnShowProperty;

        /// &amp;lt;summary&amp;gt;当前悬停在哪个对象上边&amp;lt;/summary&amp;gt;
        protected AbstractShape hoveredObject;

        /// &amp;lt;summary&amp;gt;当前选中的对象&amp;lt;/summary&amp;gt;
        protected AbstractShape selectedObject;

        /// &amp;lt;summary&amp;gt;是否正在拖动&amp;lt;/summary&amp;gt;
        protected bool draging = false;

        /// &amp;lt;summary&amp;gt;图形对象集合&amp;lt;/summary&amp;gt;
        public List&amp;lt;ShapeBase&amp;gt; Shapes { get; set; }

        public GraphControl()
        {
            Shapes = new List&amp;lt;ShapeBase&amp;gt;();
        }

        protected override void OnPaintBackground(PaintEventArgs e)
        {
            base.OnPaintBackground(e);

            Graphics g = e.Graphics;
            Size gridSize = new Size(10, 10);
            ControlPaint.DrawGrid(g, this.ClientRectangle, gridSize, this.BackColor);
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            Graphics g = e.Graphics;
            g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.AntiAlias;

            for (int k = 0; k &amp;lt; Shapes.Count; k++)
            {
                Shapes[k].Paint(g);
            }
        }

        public ShapeBase AddShape(ShapeBase shape)
        {
            Shapes.Add(shape);
            shape.Canvas = this;
            this.Invalidate();
            return shape;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5、新建测试项目&lt;/h2&gt;
&lt;p&gt;5.1 新建demo.cs把控件拖入界面左边&lt;/p&gt;
&lt;p&gt;5.2 再拖一个PropertyGrid用来显示属性值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/254672/201710/254672-20171021131914209-1566591807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.3 Demo.cs代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
        private void Demo_Load(object sender, EventArgs e)
        {
            var shape = new LjrRectangle(graphControl1);
            shape.Location = new Point(100, 300);
            shape.Text = &quot;图形化控件&quot;;
            this.graphControl1.AddShape(shape);
            this.graphControl1.OnShowProperty += graphControl1_OnShowProps;
        }

        private void graphControl1_OnShowProps(object ent)
        {
            this.propertyGrid1.SelectedObject = ent;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6、运行程序&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/254672/201710/254672-20171021132118552-1918431503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;阅读目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a title=&quot;图形化控件开发 - 矩形控件&quot; href=&quot;http://www.cnblogs.com/lanxiaoke/p/7704352.html%20&quot; target=&quot;_blank&quot;&gt;图形化控件开发 - 矩形控件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;图形化控件开发 - 控件移动&lt;/li&gt;
&lt;li&gt;图形化控件开发 - 直线连线&lt;/li&gt;
&lt;li&gt;图形化控件开发 - 折线连线&lt;/li&gt;
&lt;li&gt;图形化控件开发 - 放大缩小&lt;/li&gt;
&lt;li&gt;图形化控件开发 - 待定&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 21 Oct 2017 05:29:00 +0000</pubDate>
<dc:creator>蓝建荣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lanxiaoke/p/7704352.html</dc:identifier>
</item>
<item>
<title>mybatis逆向工程 - 小不点啊</title>
<link>http://www.cnblogs.com/leeSmall/p/7704406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leeSmall/p/7704406.html</guid>
<description>&lt;h2&gt;一、背景        &lt;/h2&gt;
&lt;p&gt;        在实际开发中我们会自己去写mapper映射文件，接口，数据库表对应的实体类，如果需求任务比较少，咱们还可以慢慢的一个一个去写，但是这是不现实的，因为在工作中我们的任务是很多的，这时mybatis逆向工程就能帮助我们节省这部分的时间了，因为mybatis逆向工程能根据数据库的表结构生成对应的mapper映射文件，接口，实体类&lt;/p&gt;
&lt;h2&gt;二、实践&lt;/h2&gt;
&lt;p&gt;1. 新建一个mybatis逆向工程测试的项目MybatisReverseProject和生成文件存放的项目MybatisTest，使用的mybatis-generator-core是借鉴githup上的一个兄弟改写源码的，他的已经能满足我的需求了，有需要的同学可以自己去改写，改写内容如下：&lt;/p&gt;
&lt;p&gt;            &lt;span&gt;&lt;strong&gt; 生成的*mapper.xml文件中使用4个空格来缩进&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;             生成的*mapper.xml文件中每个元素间增加一空行，如insert,update,delete等之间增加一空行&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;             去掉*mapper.xml文件中生成的注释&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;             根据数据库表名及字段的注释为Java类、属性增加注释，可以在源码org.mybatis.generator.internal.db.DatabaseIntrospector.java类中根据个人情况进行修改&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;             实现每次生成都覆盖生成文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;                                                                                                          &lt;img src=&quot;http://images2017.cnblogs.com/blog/1227483/201710/1227483-20171021120737631-1139951963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2.在数据库里面建立需要使用的表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `t_user` (
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   `id` &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   `username` &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   `birthday` date &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;生日&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;   `sex` &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;性别&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;   `address` &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;256&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;   &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; ) ENGINE&lt;span&gt;=&lt;/span&gt;MyISAM AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;utf8 COMMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户信息表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 在generatorConfig.xml文件中配置数据库连接的信息，配置生成实体类的位置、生成mapper映射文件生成的位置、生成mapper接口生成的位置，以上配置的3个路径为你项目的路径；指定要逆向生成代码的数据库的表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE generatorConfiguration
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;generatorConfiguration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;testTables&quot;&lt;/span&gt;&lt;span&gt; targetRuntime&lt;/span&gt;&lt;span&gt;=&quot;MyBatis3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;commentGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 是否去除自动生成的注释 true：是 ： false:否 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;suppressAllComments&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;commentGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;数据库连接的信息：驱动类、连接地址、用户名、密码 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;jdbcConnection &lt;/span&gt;&lt;span&gt;driverClass&lt;/span&gt;&lt;span&gt;=&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            connectionURL&lt;/span&gt;&lt;span&gt;=&quot;jdbc:mysql://localhost:3306/study&quot;&lt;/span&gt;&lt;span&gt; userId&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            password&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;jdbcConnection&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;jdbcConnection driverClass=&quot;oracle.jdbc.driver.OracleDriver&quot; connectionURL=&quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot; 
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            userId=&quot;scott&quot; password=&quot;wcy675600920&quot;&amp;gt; &amp;lt;/jdbcConnection&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            和 NUMERIC 类型解析为java.math.BigDecimal &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;javaTypeResolver&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;forceBigDecimals&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;javaTypeResolver&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; targetProject:生成实体类的位置 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;javaModelGenerator &lt;/span&gt;&lt;span&gt;targetPackage&lt;/span&gt;&lt;span&gt;=&quot;com.study.mybatis.entiy&quot;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            targetProject&lt;/span&gt;&lt;span&gt;=&quot;D:\workspace\MybatisTest\src\main\java&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; enableSubPackages:是否让schema作为包的后缀 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;enableSubPackages&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 从数据库返回的值被清理前后的空格 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;trimStrings&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;javaModelGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; targetProject:mapper映射文件生成的位置 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sqlMapGenerator &lt;/span&gt;&lt;span&gt;targetPackage&lt;/span&gt;&lt;span&gt;=&quot;com.study.mybatis.mapper&quot;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            targetProject&lt;/span&gt;&lt;span&gt;=&quot;D:\workspace\MybatisTest\src\main\java&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; enableSubPackages:是否让schema作为包的后缀 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;enableSubPackages&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sqlMapGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; targetPackage：mapper接口生成的位置 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;javaClientGenerator &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;XMLMAPPER&quot;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            targetPackage&lt;/span&gt;&lt;span&gt;=&quot;com.study.mybatis.dao&quot;&lt;/span&gt;&lt;span&gt; targetProject&lt;/span&gt;&lt;span&gt;=&quot;D:\workspace\MybatisTest\src\main\java&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; enableSubPackages:是否让schema作为包的后缀 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;enableSubPackages&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;javaClientGenerator&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 指定数据库表 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;tableName&lt;/span&gt;&lt;span&gt;=&quot;t_user&quot;&lt;/span&gt;&lt;span&gt; schema&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt; enableCountByExample&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            enableDeleteByExample&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; enableUpdateByExample&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            enableSelectByExample&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; selectByExampleQueryId&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 有些表的字段需要指定java类型 &amp;lt;table schema=&quot;&quot; tableName=&quot;&quot;&amp;gt; &amp;lt;columnOverride column=&quot;&quot; 
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            javaType=&quot;&quot; /&amp;gt; &amp;lt;/table&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;generatorConfiguration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. 启动主程序GeneratorSqlmap.java生成需要的文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lgs.reverse.start;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.generator.api.MyBatisGenerator;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.generator.config.Configuration;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.generator.config.xml.ConfigurationParser;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.mybatis.generator.internal.DefaultShellCallback;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * 根据数据库定义的表结构生成实体类、接口、mapper映射文件的主类
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * 使用的mybatis-generator-core是借鉴githup上的一个兄弟改写源码的， 他的已经能满足我的需求了有需要的同学可以自己去改写
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; lgs
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeneratorSqlmap {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; generator() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         List&amp;lt;String&amp;gt; warnings = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; overwrite = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定 逆向工程配置文件&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         File configFile = &lt;span&gt;new&lt;/span&gt; File(&quot;config/generatorConfig.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         ConfigurationParser cp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationParser(warnings);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         Configuration config =&lt;span&gt; cp.parseConfiguration(configFile);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         DefaultShellCallback callback = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultShellCallback(overwrite);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         MyBatisGenerator myBatisGenerator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyBatisGenerator(config, callback, warnings);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         myBatisGenerator.generate(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             GeneratorSqlmap generatorSqlmap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GeneratorSqlmap();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            generatorSqlmap.generator();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5. 需要完整项目的同学可以去我的githup上下载，下载地址https://github.com/leeSmall/MybatisReverseProject&lt;/p&gt;
</description>
<pubDate>Sat, 21 Oct 2017 04:22:00 +0000</pubDate>
<dc:creator>小不点啊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leeSmall/p/7704406.html</dc:identifier>
</item>
</channel>
</rss>