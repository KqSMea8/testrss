<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>写个.net开发者的Linux迁移指南 - hoyho</title>
<link>http://www.cnblogs.com/hoyho/p/9236709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hoyho/p/9236709.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;h3&gt;为什么要迁移到Linux&lt;/h3&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先我个人还是有点软件洁癖，以前是穷酸学生的时候也是用盗版的用户，后来在知乎被洗脑终于有了点版权意识.然后便有了能用开源软件的就用开源，实在不能就选社区版或者免费版。于是开始接触了Linux逐步摆脱盗版的Windows，以及所有的破解类软件相信国内很多用户也是用着盗版的而且并没意识到有什么不妥...讲真这不是装逼而是一个很严肃的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;自从微软开放dotnet core，终于可以用上docker等一些好玩的东西，但是docke这一套包括shell脚本等在Windows下并非原生适配，还不如在Linux使用舒服。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;还是因为工作中用了dotnet core，结果把项目部署到Linux下发现有些代码上的东西是有坑的，举个例子获取系统网卡IP的方式或者获取系统的时间有时区问题，或者时间默认值等等各方面的不同。正是这个原因是我不得不下定决心切换到Linux平台下开发以消除这些隐患&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;使用模式&lt;/h3&gt;
&lt;h4&gt;使用WSL&lt;/h4&gt;
&lt;p&gt;似乎也是最近两年才推出的东西，目前只可以在Windows 10上才可使用。 优点是不需要安装太多东西，资源占用低，发行版有Ubuntu，Debian，Kali等可以选。直接在应用商店搜索即可。 缺点就是非完全本地化的Linux，部分功能不支持比如原生docker等等，图形界面等，部分命令不可用等等奇怪问题。但可以肯定的是这玩意存在的意义是有的。只要它得到足够完善，配合宇宙IDE visual studio简直无敌&lt;/p&gt;
&lt;p&gt;具体开启步骤 1.管理员权限打开powershell&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后按照提示重启电脑&lt;/p&gt;
&lt;p&gt;再打开应用商店搜索Ubuntu安装，或者&lt;a href=&quot;https://www.microsoft.com/zh-cn/p/ubuntu/9nblggh4msv6?rtc=1&amp;amp;activetab=pivot%3aoverviewtab#&quot;&gt;点击这里直达&lt;/a&gt; 任意的命令行下输入bash即可启动WSL &lt;img src=&quot;https://docs.microsoft.com/en-us/windows/wsl/media/new-user.png&quot; alt=&quot;截图欣赏&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;虚拟机&lt;/h4&gt;
&lt;p&gt;vmware或者virtual box均可 好处就是完整的Linux环境支持，同时启动多个独立系统，且环境相互独立，玩坏了也不影响物理机。 完全虚拟化没有硬件驱动兼容这方面的烦恼 缺点 资源占用比较高，低配机器玩不起 推荐大多数新手或者想同时跑两个系统的用户使用此种方式&lt;/p&gt;
&lt;h4&gt;物理机安装&lt;/h4&gt;
&lt;p&gt;适合的人群，爱好折腾，喜欢原生体验 优点：性能最高，速度杠杠的。折腾一翻收获丰富 缺点：容易翻车，遇到很多问题需要自行查找解决方案，对于debian，使用Google+英语关键字基本能解决问题&lt;/p&gt;
&lt;h3&gt;关于发行版的选择&lt;/h3&gt;
&lt;p&gt;linux的发行版有很多redhat系的centos fedora，等等 debian系的debian，ubuntu，mint，deepin。 由于从大二就开始折腾linux桌面系统了 使用过的有Ubuntu，Debian，Ubuntu kylin，Mint，Lubantu，Xubantu，Fedora，Deepin 基本都是debian系的， 主要是桌面环境不同，无非就是unity，gnome3，xfce4,cinamon。&lt;/p&gt;
&lt;p&gt;最终体验下来得出以下结论&lt;/p&gt;
&lt;p&gt;低配置选择xfce4,比如Xubunu就是默认这个环境 喜欢传统型桌面的选择Cinamon，比如Mint 喜欢稳定+酷炫的使用Gnome3&lt;/p&gt;
&lt;p&gt;比起Ubuntu，debian大法好，和ubuntu相比简直稳如狗 不过新手还是老老实实使用ubuntu的unity，然而都2018了，Ubunut终于抛弃超级难用的unity桌面了，现在Ubuntu也是用gnome3, 以我多年是使用经历，最终决定首选是Debian（目前已经在我个人笔记本上跑了4年，稳定到怀疑人生）。新手可以考虑Ubuntu上手后再转，因为个人认为Ubuntu上手容易，但是稳定性完全比不上Debian&lt;/p&gt;
&lt;h3&gt;安装指南&lt;/h3&gt;
&lt;p&gt;具体安装就是略了，基本上就是切一个单独的分区，格式化为ext4,再 加一个swap分区，我用的是256g的固态，150g 已经被windows用了，剩下的100留给linux，记住，开发使用的电脑，大，是绝对没错的。&lt;/p&gt;
&lt;h3&gt;安装完成后可能需要的几件事&lt;/h3&gt;
&lt;h4&gt;换源&lt;/h4&gt;
&lt;p&gt;apt的源使用中国镜像源是很有必要的，经测试广州和深圳地区使用网易源速度十分理想 假设你已经会使用vi进行操作&lt;/p&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;su&lt;/span&gt;&lt;span&gt; root
&lt;/span&gt;&lt;span&gt;vi&lt;/span&gt; /etc/apt/sources.list
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;以下是我的配置可以粘贴使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
#163
deb http://mirrors.163.com/debian/ stretch non-free contrib main
deb http://mirrors.163.com/debian/ stretch-updates non-free contrib main

deb http://mirrors.163.com/debian/ stretch-backports contrib non-free main
# deb-src http://mirrors.163.com/debian/ stretch main non-free contrib
# deb-src http://mirrors.163.com/debian/ stretch-updates main non-free contrib
deb-src http://mirrors.163.com/debian/ stretch-backports main non-free contrib
deb http://mirrors.163.com/debian-security/ stretch/updates main non-free contrib
deb-src http://mirrors.163.com/debian-security/ stretch/updates main non-free contrib


#------------------------------------------------------------------------------#
#                   OFFICIAL DEBIAN REPOS
#------------------------------------------------------------------------------#

###### Debian Main Repos
# deb http://ftp.cn.debian.org/debian/ stretch contrib main
# deb-src http://ftp.cn.debian.org/debian/ stretch contrib main

###### Debian Update Repos
#deb http://security.debian.org/ stretch/updates contrib main
#deb http://ftp.cn.debian.org/debian/ stretch-proposed-updates contrib main
#deb-src http://security.debian.org/ stretch/updates contrib main



# deb http://ftp.de.debian.org/debian-ports/ sid main
deb http://mirrors.aliyun.com/debian/ stretch main non-free contrib
deb http://mirrors.aliyun.com/debian/ stretch-proposed-updates main non-free contrib
deb-src http://mirrors.aliyun.com/debian/ stretch main non-free contrib
deb-src http://mirrors.aliyun.com/debian/ stretch-proposed-updates main non-free contrib
            
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;codehilite&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;br/&gt;特别提示，如果是在基于debian的系统，并且显卡是NVIDIA的，可能出现以下情况
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;运行良好，但是突然屏幕卡住不动了，只剩下鼠标可以动，键盘也无相应，ctrl+ alt + F*都不能切换，只有强制重启和REISUB可用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过ssh远程登录无图形界面情况可以正常使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;显然这是图形界面的锅 而且这个问题网上搜索不到解决方案，我是无意中发现的解决方案 其实是需要显卡驱动支持&lt;/p&gt;
&lt;p&gt;首选我们检测下&lt;/p&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
nvidia-&lt;span&gt;detect
Detected NVIDIA GPUs: &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;00.0&lt;/span&gt; VGA compatible controller [&lt;span&gt;0300&lt;/span&gt;]: NVIDIA Corporation GF108 [GeForce GT &lt;span&gt;430&lt;/span&gt;] [10de:0de1] (rev a1) Your card is supported by the default drivers. It is recommended to &lt;span&gt;install&lt;/span&gt; the    nvidia-driver package.
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这里提供Debian9的安装 Debian 9 &quot;Stretch&quot;&lt;/p&gt;
&lt;p&gt;支持 Geforce 4xx 以及更高的GPUs&lt;/p&gt;
&lt;p&gt;首先添加源:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;deb http://httpredir.debian.org/debian stretch-backports main contrib non-free&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;gt;&amp;gt; /etc/apt/sources.list
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;codehilite&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
为内核安装合适的Linux headers 假设你的Debian Stretch使用的是4.9 Linux 内核:
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
apt-get &lt;span&gt;install&lt;/span&gt; linux-headers-$(&lt;span&gt;uname&lt;/span&gt; -r|&lt;span&gt;sed&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/[^-]*-[^-]*-//&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;如果你的分支是 stretch-backports则应该这样安装&lt;/p&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
apt-get &lt;span&gt;install&lt;/span&gt; -t stretch-backports linux-headers-$(&lt;span&gt;uname&lt;/span&gt; -r|&lt;span&gt;sed&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/[^-]*-[^-]*-//&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;现在就可以安装包nvidia-driver了&lt;/p&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
apt-&lt;span&gt;get update
apt&lt;/span&gt;-get &lt;span&gt;install&lt;/span&gt; -t stretch-backports nvidia-driver
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;DKMS会帮你的系统编译相应的nvidia模块然后重启你的电脑就可以开始狂欢了，图形驱动完美解决
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于其他的版本安装可以参考&lt;a href=&quot;https://wiki.debian.org/NvidiaGraphicsDrivers&quot;&gt;debian官方驱动安装指南&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;docker 权限问题&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;docker安装过程省略&lt;/em&gt;*&lt;/p&gt;
&lt;p&gt;如果非管理员权限执行docker的命令会提示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:as3;gutter:true;&quot;&gt;
docker: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;codehilite&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;sudo&lt;/span&gt; usermod -a -G docker $USER
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; addgroup --&lt;span&gt;system docker
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt; adduser $USER docker
newgrp docker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;br/&gt;安装oh my zsh以及配置超级好用的插件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为啥要特别提及这个?不就是一个普通辅助么&lt;/p&gt;
&lt;p&gt;因为zsh实在太好用了，有了它，bash简直弱爆了,正所谓磨刀不误砍柴功&lt;/p&gt;
&lt;p&gt;不多说直接开撸&lt;/p&gt;
&lt;p&gt;安装&lt;/p&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; apt &lt;span&gt;install&lt;/span&gt;&lt;span&gt; zsh
&lt;/span&gt;&lt;span&gt;sh&lt;/span&gt; -c &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;br/&gt;开启下插件
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;codehilite&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vim ~/.zshrc
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;找到plugin，我的是这样的&lt;/p&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
plugins=&lt;span&gt;(
  git
  adb
  debian
  django
  emoji
  pyenv
  &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt;
  tmux
  virtualenv
  vim&lt;/span&gt;-&lt;span&gt;interactio
  &lt;/span&gt;&lt;span&gt;vi&lt;/span&gt;-&lt;span&gt;mode
  zsh&lt;/span&gt;-syntax-&lt;span&gt;highlighting
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;br/&gt;效果图
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://here2say.me/media/article_images/2018/06/27/70f58fb6-ba03-11e4-82c9-c083bf9a6574.png&quot; alt=&quot;zsh&quot;/&gt;&lt;/p&gt;
&lt;p&gt;终端上有git的提示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://here2say.me/media/article_images/2018/06/27/zsh.png&quot; alt=&quot;zsh2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输命令会有颜色提示对错，需要安装zsh-syntax-highlighting插件&lt;/p&gt;
&lt;p&gt;当然还有各种各样的主题，比如我的远程主机使用的是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://here2say.me/media/article_images/2018/06/27/zshtheme.png&quot; alt=&quot;remote&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编辑刚才的配置文件，修改主题为ZSH_THEME=&quot;agnoster&quot;然后重启终端即可 觉的强大好用的话就设置为默认的shell&lt;/p&gt;
&lt;div class=&quot;codehilite&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
chsh -s /bin/zsh
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h4&gt;基础环境说了这么多就不继续了&lt;/h4&gt;
&lt;p&gt;下面说说和.net相关的。&lt;/p&gt;
&lt;p&gt;首先如果安装dotnet core的sdk就看官方介绍即可&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.microsoft.com/net/learn/get-started/linux/debian9&quot;&gt;官网介绍&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; -qO- https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/keys/microsoft.asc | gpg --dearmor &amp;gt; microsoft.asc.gpg&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;mv&lt;/span&gt; microsoft.asc.gpg /etc/apt/trusted.gpg.d/
&lt;span&gt;wget&lt;/span&gt; -q https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/config/debian/9/prod.list&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;mv&lt;/span&gt; prod.list /etc/apt/sources.list.d/microsoft-&lt;span&gt;prod.list
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chown&lt;/span&gt; root:root /etc/apt/trusted.gpg.d/&lt;span&gt;microsoft.asc.gpg
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;chown&lt;/span&gt; root:root /etc/apt/sources.list.d/microsoft-&lt;span&gt;prod.list

&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-&lt;span&gt;get update
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; apt-get &lt;span&gt;install&lt;/span&gt; dotnet-sdk-&lt;span&gt;2.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;br/&gt;输入&lt;code&gt;dotnet --info&lt;/code&gt;&lt;span&gt;验证完美&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://here2say.me/media/article_images/2018/06/27/dotnetinfo.png&quot; alt=&quot;dotnet&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;私有的nuget源怎么配置&lt;/h4&gt;
&lt;p&gt;我们公司会架设自己的nuget服务器，目前linux下不支持加密存储的配置，所以我都是配置明文密码到配置中&lt;/p&gt;
&lt;p&gt;具体可以参考我的另一篇文章&lt;a href=&quot;https://here2say.me/22/&quot;&gt;在linux下设置私有的nuget&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简而言之就是编辑~/.nuget/NuGet/NuGet.Config&lt;/p&gt;
&lt;p&gt;如下&lt;/p&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packageSources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;https://www.nuget.org/api/v2/&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;https://www.nuget.org/api/v2/&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;xxxyyy&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;https://nuget.xxxxxxx.com/nuget&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;nuget.org&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;https://api.nuget.org/v3/index.json&quot;&lt;/span&gt;&lt;span&gt; protocolVersion&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packageSources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packageSourceCredentials&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xxxyyy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;Username&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;xxx&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;ClearTextPassword&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;xxx&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xxxyyy&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packageSourceCredentials&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;现在再执行dotnet restort就完美还原了&lt;/p&gt;
&lt;h4&gt;dotnet core 开发工具推荐&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;主力Jetbrains的Rider&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;除了内存占用非常大点之外，基本可以胜任VS的工作，智能感知非常棒棒，调试非常方便&lt;/p&gt;
&lt;p&gt;如下图 &lt;img src=&quot;https://images2018.cnblogs.com/blog/896762/201806/896762-20180628014553952-491606821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;小刀Visual Studio Code&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在你看到的这篇文章就是在vscode中打出来的，借助强大的插件。简直是利器&lt;/p&gt;
&lt;p&gt;所以我现在写写小的dotnet core项目，Python，或者PHP等等我都会优选选择vscode，强推！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896762/201806/896762-20180628015535749-1336724602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;数据库管理工具&lt;/p&gt;
&lt;p&gt;我使用的是开源免费跨平台的Dbeaver&lt;/p&gt;
&lt;p&gt;支持MySQL, PostgreSQL, MariaDB, SQLite, Oracle, DB2, SQL Server, Sybase, MS Access 十分强大&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896762/201806/896762-20180628014732901-466685981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dbeaver.io/&quot;&gt;地址&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Redis管理工具 可以的话自己编译Redis Desktop Manager&lt;/p&gt;
&lt;p&gt;我使用的是开源跨平台的Medis，可以说地十分优雅了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/luin/medis&quot;&gt;直达github&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896762/201806/896762-20180628015001063-2095730448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提示下作者没有打linux包，所以自己编译 编译步骤&lt;/p&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/luin/medis&lt;/span&gt;
npm &lt;span&gt;install&lt;/span&gt;&lt;span&gt;
npm run build
npm run electron&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;然后写个启动脚本&lt;/p&gt;
&lt;div class=&quot;codehilite&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd your-&lt;span&gt;path
npm run electron&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;br/&gt;最后写个desktop配置添加到桌面，具体有兴趣的留言再补充吧
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;p&gt;Git 图形管理工具&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gitkraken.com/&quot;&gt;gitkraken&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896762/201806/896762-20180628015042154-2035891530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;IM工具&lt;/h3&gt;
&lt;p&gt;目前我们公司的工作流是基于谷歌的，基本可以使用Google全家桶，所以没有腾讯qq这种牵绊&lt;/p&gt;
&lt;p&gt;但是实在需要的，可以使用web版本&lt;/p&gt;
&lt;p&gt;我自己装了个&lt;a href=&quot;https://github.com/geeeeeeeeek/electronic-wechat&quot;&gt;github上一个基于electron的微信&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896762/201806/896762-20180628015126156-2038537051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;如果需要办公的可能要&lt;a href=&quot;https://github.com/nashaofu/dingtalk&quot;&gt;钉钉也是github上找的&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;dinbgding也有有人打包好了 &lt;img src=&quot;https://github.com/nashaofu/dingtalk/raw/master/screenshot/3.png&quot; alt=&quot;dingtalk&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我们公司内部还比较潮的使用了slack来协作&lt;/p&gt;
&lt;p&gt;也有&lt;a href=&quot;https://slack.com/downloads/linux&quot;&gt;slack的客户端&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896762/201806/896762-20180628015154075-1318296469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;邮件什么的跟不用说&lt;/p&gt;
&lt;p&gt;绝地妥妥的&lt;/p&gt;
&lt;p&gt;我推荐谷歌输入法，喜欢国产的可以使用sogou出的搜狗输入法linux&lt;/p&gt;
&lt;p&gt;都用过，值的入手，还没广告 &lt;a href=&quot;https://pinyin.sogou.com/linux/?r=pinyin&quot;&gt;官网deb包&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;顺带提下WPS这个办公套件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;linux下也可以使用，还是没广告，不过我看自带的libreoffice也是够我用的了&lt;/p&gt;
&lt;p&gt;毕竟开发的，编辑的东西也不多，实在不行我直接丢到Google在线编辑去或者使用石墨文档和腾讯文档&lt;/p&gt;
&lt;p&gt;已经很成熟了 &lt;a href=&quot;https://www.wps.com/linux&quot;&gt;WPS linux版本&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;音乐有网易云音乐linux版本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://music.163.com/#/download&quot;&gt;网易云音乐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其他的chrome和Firefox之类的都有就不说了&lt;/p&gt;
&lt;p&gt;最后全家福 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/896762/201806/896762-20180628015216517-1605667904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;其他&lt;/h4&gt;
&lt;p&gt;基本上要有的也差不多了&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其他方面的话补充下就是如果安装xrdp远程到这电脑之类的&lt;/li&gt;
&lt;li&gt;开启内网穿透远程连接&lt;/li&gt;
&lt;li&gt;使用好看的主题之类的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;挖个坑，暂时不想写，有必要再继续写&lt;/p&gt;
&lt;p&gt;以上 欢迎各位反馈问题，提出来研究研究&lt;/p&gt;
&lt;p&gt;&amp;gt;此文最初发布&lt;a title=&quot;here2say&quot; href=&quot;https://here2say.me/27/&quot; target=&quot;_blank&quot;&gt;here2say&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt;author:Hoyho&lt;/p&gt;
&lt;p&gt;&amp;gt;转载请保留此出处&lt;/p&gt;

</description>
<pubDate>Wed, 27 Jun 2018 16:55:00 +0000</pubDate>
<dc:creator>hoyho</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hoyho/p/9236709.html</dc:identifier>
</item>
<item>
<title>【java设计模式】（2）---六大原则（案例说明） - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9236604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9236604.html</guid>
<description>&lt;p&gt;这篇博客非常有意义，希望自己能够理解的基础上，在实际开发中融入这些思想，运用里面的精髓。&lt;/p&gt;
&lt;p&gt;先列出六大原则：&lt;span&gt;单一职责原则&lt;/span&gt;、&lt;span&gt;里氏替换原则&lt;/span&gt;、&lt;span&gt;接口隔离原则&lt;/span&gt;、&lt;span&gt;依赖倒置原则&lt;/span&gt;、&lt;span&gt;迪米特原则&lt;/span&gt;、&lt;span&gt;开闭原则&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、单一职责原则&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;1、单一职责定义&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;单一职责原则&lt;/strong&gt;：&lt;span&gt;一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单一职责原则告诉我们&lt;/strong&gt;：一个类不能太“累”！在软件系统中，一个类承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其&lt;/p&gt;
&lt;p&gt;他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、单一职责优点&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      1）&lt;strong&gt;降低了类的复杂度&lt;/strong&gt;。一个类只负责一项职责比负责多项职责要简单得多。&lt;/p&gt;
&lt;p&gt;      2)  &lt;strong&gt;提高了代码的可读性&lt;/strong&gt;。一个类简单了，可读性自然就提高了。&lt;/p&gt;
&lt;p&gt;      3)  &lt;strong&gt;提高了系统的可维护性&lt;/strong&gt;。代码的可读性高了，并且修改一项职责对其他职责影响降低了，可维护性自然就提高了。&lt;/p&gt;
&lt;p&gt;      4)  &lt;strong&gt;变更引起的风险变低了&lt;/strong&gt;。单一职责最大的优点就是修改一个功能，对其他功能的影响显著降低。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、案例说明&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在网上找了个比较好理解，也比较符合实际开发中用来思考的小案例。&lt;/p&gt;
&lt;p&gt;有一个用户类，我们先看它的接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180627222847081-874840327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      这个接口是可以优化的，&lt;strong&gt;用户的属性&lt;/strong&gt;（Property）和&lt;strong&gt;用户的行为&lt;/strong&gt;（Behavior）没有分开，这是一个严重的错误！非常正确，这个接口确实设计得一团糟，应该把用户的信息抽取成一个BO（Bussiness Object，业务对象），把行为抽取成一个BIZ(Business Logic，业务逻辑)，按照这个思路对类图进行修正，如图1-2所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180627223938079-1271454020.png&quot; alt=&quot;&quot;/&gt;                                                           图1-2 职责划分后的类图&lt;/p&gt;
&lt;p&gt;       重新拆封成两个接口，IUserBO负责用户的属性，简单地说，IUserBO的职责就是收集和反馈用户的属性信息；IUserBiz负责用户的行为，完成用户信息的维护和变更。&lt;/p&gt;
&lt;p&gt;然后IUserInfo来实现这两个接口，重写方法。&lt;/p&gt;
&lt;p&gt; 代码清单1-1 分清职责后的代码示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.......
 
IUserBiz userInfo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserInfo();
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我要赋值了，我就认为它是一个纯粹的BO&lt;/span&gt;
&lt;span&gt; 
IUserBO userBO &lt;/span&gt;=&lt;span&gt; (IUserBO)userInfo;
 
userBO.setPassword(&lt;/span&gt;&quot;abc&quot;&lt;span&gt;);
 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我要执行动作了，我就认为是一个业务逻辑类&lt;/span&gt;
&lt;span&gt; 
IUserBiz userBiz &lt;/span&gt;=&lt;span&gt; (IUserBiz)userInfo;
 
userBiz.deleteUser();
 
.......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;思考&lt;/span&gt;：上面这样是单一职责原则吗？当然不是了，你实现了两个接口，不还是把行为和属性写在一个类了，和最上面又有什么区别呢，这里只能说实现了接口隔离原则（下面会说）&lt;/p&gt;
&lt;p&gt;那如何来确保单一原则，在实际的使用中，我们更倾向于使用两个不同的类：一个是IUserBO， 一个是IUserBiz很简单如图所示：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img title=&quot;clip_image006&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/cbf4life/WindowsLiveWriter/0b52eff65f98_111AD/clip_image006_thumb.gif&quot; alt=&quot;clip_image006&quot; width=&quot;240&quot; height=&quot;149&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt; 4、自己理解&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;单一职责原则有两个难点：&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;1) 职责划分&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt; 一个职责一个接口，但问题是“职责”是一个没有量化的标准，一个类到底要负责那些职责？这些职责该怎么细化？细化后是否都要有一个接口或类？这些都需要从实际的项目去考虑。&lt;/p&gt;
&lt;p&gt;比如上面写成一个类他的单一职责就是修改用户信息，为什么一定要分修改行为和修改属性。那是不是又可以在细分修改密码和修改属性呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 2）类的冗余&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果可以追求单一职责也是没有必要的，本来一个类可以搞定的实现，如果非得修改用户名一个类，修改密码一个类来实现单一原则，这样也会让你的类变得非常多，反而不容易维护。&lt;/p&gt;
&lt;p&gt;我自己的感悟：&lt;/p&gt;
&lt;p&gt; 1）首先要培养单一职责的思想，特别是如果代码可以复用的情况下经常思考能不能用单一职责原则来划分类。&lt;/p&gt;
&lt;p&gt;  2) 类的单一职责实现在好多时候并不切实际，但是方法上一定要保持单一职责原则。比如你修改密码的方法就是用来修改密码。这样做有个很大的好处就是便于代码调试，容易将代码的Bug找出来，一个方法只完成&lt;/p&gt;
&lt;p&gt;一件事情，相对调试能简单很多，让其他人员能更快更好的读懂代码、理解这个类或者方法的功能。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; 二、里氏代换原则&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 这个和单一职责原则比起来，显然就好理解多了，而且也不那么模糊不清。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、定义&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; 官方定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象。&lt;/p&gt;
&lt;p&gt; 简单理解就是：&lt;span&gt;子类一般不该重写父类的方法，因为父类的方法一般都是对外公布的接口，是具有不可变性的，你不该将一些不该变化的东西给修改掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;是不是感觉这个原则不太招人喜欢，因为我们在写代码的时候经常会去重写父类的方法来满足我们的需求。而且在模板方法模式，缺省适配器，装饰器模式等一些设计模式都会采用重写父类的方法。&lt;/p&gt;
&lt;p&gt;怎么说呢，里氏代换原则的主要目的主要是防止继承所带来的弊端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承的弊端&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。&lt;/p&gt;
&lt;p&gt;继承会增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、案例说明&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SomeoneClass类&lt;/strong&gt;&lt;/span&gt;，其中有一个方法，调用了某一个父类的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;某一个类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SomeoneClass {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有某一个方法，使用了一个父类类型&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; someoneMethod(Parent parent){
        parent.method();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;父类代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method(){
        System.out.println(&lt;/span&gt;&quot;parent method&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;SubClass子类&lt;/strong&gt;把父类的方法给覆盖。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SubClass &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Parent{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果某一个子类重写了父类的方法，说不支持该操作了&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;这个异常是运行时才会产生的，也就是说，我的SomeoneClass并不知道会出现这种情况，结果就是我调用下面这段代码的时候，
 *本来我们的思维是Parent都可以传给someoneMethod完成我的功能，我的SubClass继承了Parent，当然也可以了，但是最终这个调用会抛出异常。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SomeoneClass someoneClass &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SomeoneClass();
        someoneClass.someoneMethod(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Parent());
        someoneClass.someoneMethod(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SubClass());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       这就相当于埋下了一个个陷阱，因为本来我们的原则是，父类可以完成的地方，我用子类替代是绝对没有问题的，但是这下反了，我每次使用一个子类替换一个父类的时候，我还要担心这个子类有没有给我埋下一&lt;/p&gt;
&lt;p&gt;个上面这种炸弹。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、自己理解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;    感觉自己在开发中不太会出现上面这么愚蠢的错误。理由：&lt;/p&gt;
&lt;p&gt;  1）自己水平有限，平时在开发中使用继承的时候都是基础API的类然后重写，很少继承自己写的类，一般都是实现接口比较多。&lt;/p&gt;
&lt;p&gt;  2）第二就算我用了继承，我在传参的时候我只要稍微注意下就应该知道这个方法的参数是&lt;span&gt;Parent，而如果我要放入&lt;/span&gt;&lt;span&gt;SubClass时，就应该考虑自己有没有重写这个方法，如果重写这样肯定不行。所以也不多发生上面的错误了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以总的来说，要知道继承的这个隐患，在开发中注意就是。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、&lt;span&gt;接口隔离原则&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、定义&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      &lt;/span&gt;&lt;/span&gt;&lt;span&gt;当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要这么做呢&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;       其实很好理解，因为你实现一个接口就是实现它所有的方法，但其实你并不需要它的所有方法，那就会产生：一个类实现了一个接口，里面很多方法都是空着的，只有个别几个方法实现了。    &lt;/p&gt;
&lt;p&gt; 这样做不仅会强制实现的人不得不实现本来不该实现的方法，最严重的是会给使用者造成假象，即这个实现类拥有接口中所有的行为，结果调用方法时却没收获到想要的结果。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、案例说明&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;       比如我们设计一个手机的接口时，就要手机哪些行为是必须的，要让这个接口尽量的小，或者通俗点讲，就是里面的行为应该都是这样一种行为，就是说只要是手机，你就必须可以做到的。&lt;/p&gt;
&lt;p&gt;下面是手机接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Mobile {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; call();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手机可以打电话&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sendMessage();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手机可以发短信&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; playBird();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手机可以玩愤怒的小鸟？&lt;/span&gt;
&lt;span&gt;    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       上面第三个行为明显就不是一个手机必须有的，那么上面这个手机的接口就不是最小接口，假设我现在的非智能手机去实现这个接口，那么playBird方法就只能空着了，因为它不能玩。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、自己理解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个没啥说的，很好理解，最上面我写单一职责原则的时候的那个案例，中间那部分就是接口隔离原则。这个思想自己要慢慢培养，然后更多的运用到实际开发中去。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;四、依赖倒置原则&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;1、定义&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;依赖倒置原则包含三个含义&lt;/p&gt;
&lt;p&gt;  1） 高层模块不应该依赖低层模块,两者都应该依赖其抽象&lt;/p&gt;
&lt;p&gt;  2） 抽象不应该依赖细节&lt;/p&gt;
&lt;p&gt;  3）细节应该依赖抽象&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2、案例说明&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;大家都喜欢阅读，阅读文学经典滋润自己的内心心灵，下面是小明同学阅读文学经典的一个类图&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180627234107367-25421743.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文学经典类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文学经典类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LiteraryClassic{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读文学经典&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read(){
       System.out.println(&lt;/span&gt;&quot;文学经典阅读，滋润自己的内心心灵&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;小明类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小明类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; XiaoMing{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读文学经典&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read(LiteraryClassic literaryClassic){
        literaryClassic.read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;场景类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client{
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(Strings[] args){
      XiaoMing xiaoming &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XiaoMing();
      LiteraryClassic literaryClassic &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LiteraryClassic();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小明阅读文学经典&lt;/span&gt;
&lt;span&gt;      xiaoming.read(literaryClassic);
   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看，我们的实现，小明同学可以阅读文学经典了。&lt;/p&gt;
&lt;p&gt;小明同学看了一段文学经典后，忽然他想看看看小说来放松一下自己,我们实现一个小说类：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小说类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小说类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Novel{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读小说&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read(){
       System.out.println(&lt;/span&gt;&quot;阅读小说，放松自己&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们再来看代码，发现XiaoMing类的read方法只与文学经典LiteraryClassic类是强依赖，紧耦合关系，小明同学竟然阅读不了小说类。这与现实明显的是不符合的，代码设计的是有问题的。那么问题在那里呢？&lt;/p&gt;
&lt;p&gt;       我们看小明类，此类是一个高层模块，并且是一个细节实现类，此类依赖的是一个文学经典LiteraryClassic类，而文学经典LiteraryClassic类也是一个细节实现类。这是不是就与我们说的依赖倒置原则相违背呢？&lt;/p&gt;
&lt;p&gt;依赖倒置原则是说我们的高层模块，实现类，细节类都应该是依赖与抽象，依赖与接口和抽象类。&lt;/p&gt;
&lt;p&gt;为了解决小明同学阅读小说的问题，我们根据依赖倒置原则先抽象一个阅读者接口,下面是完整的uml类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180627234510911-491338733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IReader接口&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IReader{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read(IRead read){
       read.read();
   }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;再定义一个被阅读的接口IRead&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IRead{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;被阅读&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 再定义文学经典类和小说类 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文学经典类&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文学经典类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LiteraryClassic &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IRead{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读文学经典&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read(){
       System.out.println(&lt;/span&gt;&quot;文学经典阅读，滋润自己的内心心灵&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;小说类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小说类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Novel &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IRead{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读小说&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read(){
       System.out.println(&lt;/span&gt;&quot;阅读小说，放松自己&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;再实现小明类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小明类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XiaoMing &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IReader{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read(IRead read){
        read.read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，我们再让小明分别阅读文学经典和小说&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client{
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(Strings[] args){
      XiaoMing xiaoming &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XiaoMing();
      IRead literaryClassic &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LiteraryClassic();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小明阅读文学经典&lt;/span&gt;
&lt;span&gt;      xiaoming.read(literaryClassic);

      IRead novel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Novel();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小明阅读小说&lt;/span&gt;
&lt;span&gt;      xiaoming.read(novel);
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，小明同学是可以阅读文学经典，又可以阅读小说了，目的达到了。&lt;/p&gt;
&lt;p&gt;        为什么依赖抽象的接口可以适应变化的需求？这就要从接口的本质来说，接口就是把一些公司的方法和属性声明，然后具体的业务逻辑是可以在实现接口的具体类中实现的。所以我们当依赖对象是接口时，就可&lt;/p&gt;
&lt;p&gt;以适应所有的实现此接口的具体类变化。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、依赖的三种方法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;依赖是可以传递，A对象依赖B对象，B又依赖C，C又依赖D，……，依赖不止。只要做到抽象依赖，即使是多层的依赖传递也无所谓惧。&lt;/p&gt;
&lt;p id=&quot;构造函数传递依赖对象&quot;&gt;&lt;strong&gt;1）构造函数传递依赖对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小明类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XiaoMing &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IReader{
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IRead read;
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数注入&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; XiaoMing(IRead read){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.read =&lt;span&gt; read;
     }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read(){
        read.read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）Setter方法传递依赖对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在类中通过Setter方法声明依赖关系，依照依赖注入的说法，这是Setter依赖注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小明类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XiaoMing &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IReader{
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IRead read;
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Setter依赖注入&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; setRead(IRead read){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.read =&lt;span&gt; read;
     }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阅读&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read(){
        read.read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p id=&quot;接口声明依赖&quot;&gt;&lt;strong&gt;3）接口声明依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在接口的方法中声明依赖对象，在为什么我们要符合依赖倒置原则的例子中，我们采用了接口声明依赖的方式，该方法也叫做接口注入。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;4、依赖倒置原则的经验&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;依赖倒置原则的本质就是通过抽象(接口或抽象类)使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。我们在项目中使用这个原则要遵循下面的规则：&lt;/p&gt;
&lt;p&gt;      1）每个类尽量都有接口或者抽象类，或者抽象类和接口两都具备&lt;/p&gt;
&lt;p&gt;      2）变量的表面类型尽量是接口或者抽象类&lt;/p&gt;
&lt;p&gt;      3）任何类都不应该从具体类派生&lt;/p&gt;
&lt;p&gt;      4）尽量不要覆写基类的方法 &lt;/p&gt;
&lt;p&gt;        如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响。&lt;/p&gt;
&lt;p&gt;      5）结合里氏替换原则使用 &lt;/p&gt;
&lt;p&gt;依赖倒置原则是6个设计原则中最难以实现的原则，它是实现开闭原则的重要方法，在项目中，大家只要记住是”面向接口编程”就基本上是抓住了依赖倒置原则的核心了。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;五、迪米特原则&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 这个原则在开发中还是非常有用的。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、定义&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;大致意思是：&lt;span&gt;即一个类应该尽量不要知道其他类太多的东西，不要和陌生的类有太多接触。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;迪米特原则还有一个解释：Only talk to your immediate friends（&lt;span&gt;只与直接朋友通信&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;什么叫直接朋友呢？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系类型有很多，例如：组合，聚合，依赖等。朋友类也可以这样定义：出现在成员变量，方法的输入输出参&lt;/p&gt;
&lt;p&gt;数中的类，称为朋友类。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;2、案例说明&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;上体育课，我们经常有这样一个场景：&lt;/p&gt;
&lt;p&gt;体育老师上课前要体育委员确认一下全班女生到了多少位，也就是体育委员清点女生的人数。如图：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180628000808973-1623086231.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;：这里其实体育老师和体育委员是朋友，因为他们是有业务来源，而女生人数是和体育委员有业务来源（它们是朋友），但是体育老师和女生人数是没有直接业务来源的所以体育老师类中不应该参杂女生相关信&lt;/p&gt;
&lt;p&gt;息，这就是迪米特原则&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(1)没有才有迪米特原则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;体育老师类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher{

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;老师对体育委员发一个命令，让其清点女生人数的方法&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; command(GroupLeader groupLeader){
     List&lt;/span&gt;&amp;lt;Girl&amp;gt; listGirls = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化女生，发现老师和女生有耦合&lt;/span&gt;
     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;20;i++&lt;span&gt;){
       listGirls.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Girl());
     }
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;告诉体育委员开始清点女生人数&lt;/span&gt;
&lt;span&gt;     groupLeader.countGirls(listGirls);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;体育委员类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GroupLeader{
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清点女生数量&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; countGirls(List&amp;lt;Girl&amp;gt;&lt;span&gt; listGirls){
     System.out.println(&lt;/span&gt;&quot;女生人数是：&quot;+&lt;span&gt;listGirls.size());
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;女生类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
publci &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Girl{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client{
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(Strings[] args){
      Teacher teacher &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Teacher();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;老师给体育委员发清点女生人数的命令&lt;/span&gt;
      teacher.command(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GroupLeader());
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;分析&lt;/span&gt;：我们再回头看Teacher类，Teacher类只有一个朋友类GroupLeader，Girl类不是朋友类，但是Teacher与Girl类通信了，这就破坏了Teacher类的健壮性，Teacher类的方法竟然与一个不是自己的朋友类Girl类通&lt;/p&gt;
&lt;p&gt;信，这是不允许的，严重违反了迪米特原则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; (2)采用迪米特原则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们对程序进行如下修改，将类图修改如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201806/1090617-20180628001000284-2102367199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改后的老师类：（注意这里面已经没有女生信息了）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Teacher{
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;老师对体育委员发一个命令，让其清点女生人数&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; command(GroupLeader groupLeader){
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;告诉体育委员开始清点女生人数&lt;/span&gt;
&lt;span&gt;     groupLeader.countGirls();
  }
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt; 修改后的体育委员类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GroupLeader{
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Girl&amp;gt;&lt;span&gt; listGirls;
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; GroupLeader(List&amp;lt;Girl&amp;gt;&lt;span&gt; listGirls){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listGirls =&lt;span&gt; listGirls;
   }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清点女生数量&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; countGirls(){
     System.out.println(&lt;/span&gt;&quot;女生人数是：&quot;+&lt;span&gt;listGirls.size());
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;修改后的测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client{
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(Strings[] args){
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;产生女生群体&lt;/span&gt;
     List&amp;lt;Girl&amp;gt; listGirls = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Girl&amp;gt;&lt;span&gt;();
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化女生&lt;/span&gt;
     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;20;i++&lt;span&gt;){
       listGirls.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Girl());
     }

      Teacher teacher &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Teacher();
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;老师给体育委员发清点女生人数的命令&lt;/span&gt;
      teacher.command(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GroupLeader(listGirls));
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       对程序修改，把Teacher中对Girl群体的初始化移动到场景类中，同时在GroupLeader中增加对Girl的注入，避开了Teacher类对陌生类Girl的访问，降低了系统间的耦合，提高了系统的健壮性。&lt;/p&gt;
&lt;p&gt;在实践中经常出现这样一个方法，放在本类中也可以，放到其它类中也可以。那怎么处理呢？你可以坚持一个原则：如果一个方法放在本类中，即不增加类间关系，也对本类不产生负面影响，那就放到本类中。&lt;/p&gt;
&lt;p&gt;迪米特原则的核心观念就是&lt;span&gt;类间解耦，弱耦合，只有弱耦合后，类的复用率才可以提高&lt;/span&gt;。其结果就是产生了大量的中转或跳转类，导致系统复杂，为维护带来了难度。所以，我们在实践时要反复权衡，即要让结构清&lt;/p&gt;
&lt;p&gt;晰，又做到高内聚低耦合。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、自己理解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;迪米特原则在自己开发中一定要培养这种思想，因为它没有那么模糊，而且这个原则没啥争议。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;六、&lt;strong&gt;开闭原则&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;      这个原则更像是前五个原则的总纲，前五个原则就是围着它转的，只要我们尽量的遵守前五个原则，那么设计出来的系统应该就比较符合开闭原则了，相反，如果你违背了太多，那么你的系统或许也不太遵循开闭原则。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;1、定义&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; 一句话，对修改关闭，对扩展开放。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      就是说我任何的改变都不需要修改原有的代码，而只需要加入一些新的实现，就可以达到我的目的，这是系统设计的理想境界，但是没有任何一个系统可以做到这一点，哪怕我一直最欣赏的spring框架也做不到，&lt;/p&gt;
&lt;p&gt;虽说它的扩展性已经强到变态。&lt;/p&gt;
&lt;p&gt; 这个就不说了，字面上也能理解个八九分，它对我来讲太抽象。虽然它很重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你理解会运用了这六大原则，那么你写出的代码一定是非常漂亮的，二不是那么臃肿，遍地第都是垃圾代码了。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;想太多，做太少，中间的落差就是烦恼。想没有烦恼，要么别想，要么多做。中校【4】&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 27 Jun 2018 16:34:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9236604.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务之基于Exceptionless实现分布式日志记录 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/exceptionless_foundation_and_quick_start.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/exceptionless_foundation_and_quick_start.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627223522167-1332709621.png&quot; alt=&quot;&quot; width=&quot;331&quot; height=&quot;86&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Exceptionless 是一个开源的实时的日志收集框架，它可以应用在基于 ASP.NET，ASP.NET Core，Web API，Web Forms，WPF，Console，ASP.NET MVC 等技术开发的应用程序中，并且提供了REST接口可以应用在 Javascript，Node.js 中。它将日志收集变得简单易用并且不需要了解太多的相关技术细节及配置，对于微服务架构的应用程序来说，统一的日志收集系统的建立更是有必要。&lt;/p&gt;

&lt;h2&gt;2.1 官方创建一个账号&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627223912175-1731294456.png&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2 创建项目&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627224032147-1917169964.png&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;248&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.3 得到ApiKey&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627224204565-795819607.png&quot; alt=&quot;&quot; width=&quot;663&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.4 安装Exceptionless.AspNetCore并进行配置&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;NuGet&amp;gt;Install-Package Exceptionless.AspNetCore　　&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;em&gt;*.目前最新版本是4.3.2004&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　在你要进行Logging的项目（MVC，WebAPI等）中注册APIKey，这里以ASP.NET Core WebAPI项目为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env, IApplicationLifetime lifetime)
    {
        ......
        app.UseMvc();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; exceptionless&lt;/span&gt;
        &lt;strong&gt;app.UseExceptionless(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exceptionless:ApiKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
        &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; swagger&lt;/span&gt;
&lt;span&gt;        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里我将ApiKey配置到了json配置文件中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exceptionless&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApiKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your Api Key from Exceptionless server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.5 简单地封装一个ExceptionlessLogger&lt;/h2&gt;
&lt;p&gt;　　（1）自定义一个ILogger接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ILogger
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Trace(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Debug(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Info(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Warn(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Error(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）实现ILogger接口：ExceptionlessLogger&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionLessLogger : ILogger
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Trace
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Trace(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] tags)
        {
            ExceptionlessClient.Default.CreateLog(message, LogLevel.Trace).AddTags(tags).Submit();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Debug
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Debug(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] tags)
        {
            ExceptionlessClient.Default.CreateLog(message, LogLevel.Debug).AddTags(tags).Submit();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Info
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Info(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] tags)
        {
            ExceptionlessClient.Default.CreateLog(message, LogLevel.Info).AddTags(tags).Submit();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Warn
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Warn(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] tags)
        {
            ExceptionlessClient.Default.CreateLog(message, LogLevel.Warn).AddTags(tags).Submit();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Error
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Error(&lt;span&gt;string&lt;/span&gt; message, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] tags)
        {
            ExceptionlessClient.Default.CreateLog(message, LogLevel.Error).AddTags(tags).Submit();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.6 注入ExceptionlessLogger&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IServiceProvider ConfigureServices(IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IoC - Logger&lt;/span&gt;
        services.AddSingleton&amp;lt;ILogger, ExceptionLessLogger&amp;gt;&lt;span&gt;();
        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.7 在你想要Logging的地方调用&lt;/h2&gt;
&lt;p&gt;　　比如我们要记录一个User登录的日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoginController : Controller
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ILogger Logger { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoginController(ILogger logger)
        {
            Logger &lt;/span&gt;=&lt;span&gt; logger;
        }

        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            Logger.Info($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User {id} Login Successfully. Time:{DateTime.Now.ToString()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tag1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tag2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Login Success.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627231348456-578171008.png&quot; alt=&quot;&quot; width=&quot;294&quot; height=&quot;88&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.8 记录你程序中的各种Exception&lt;/h2&gt;
&lt;p&gt;　　这里模拟一个空指针的异常，这里借助Exceptionless针对Exception类的扩展方法去进行写异常信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [HttpGet]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Get()
    {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            str.ToString();
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
        {
            ex.ToExceptionless().Submit();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown Error!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627233311031-524023313.png&quot; alt=&quot;&quot; width=&quot;316&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.9 Check你的日志与异常记录&lt;/h2&gt;
&lt;p&gt;　　（1）Check 日志&lt;/p&gt;
&lt;p&gt;　　在Log Messages 或 AllEvents菜单中选择Dashboard，即可看到当前项目所有的Log Message了。（如果选择的是AllEvents，可能还会包含其他类型的信息，比如Exception）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627231517098-1611283461.png&quot; alt=&quot;&quot; width=&quot;767&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在最近的Log中可以看到我们刚刚的测试中记录的一跳日志：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627231604665-1404548677.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;91&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　点击超链接，即可进入详细页面：&lt;/p&gt;
&lt;p&gt;　　Overview：可以看到一些项目和日志的基本信息，比如Event Type，Level以及标签Tags&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627231842726-1796705866.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Environment：可以看到记录日志所在的项目所处的一些软硬件环境信息&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627231916452-2022253636.png&quot; alt=&quot;&quot; width=&quot;622&quot; height=&quot;335&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面是一些额外的信息，比如Framework Version以及Runtime Framework&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627231936762-2092639573.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过对这些日志的查看和分析，我们可以方便地在一个地方对所有服务中的日志进行查看和分析。But，在线版本对项目和日志数量有限制，建议在生产环境使用本地部署版本，它是开源的。&lt;/p&gt;
&lt;p&gt;　　（2）Check 异常&lt;/p&gt;
&lt;p&gt;　　在Exception菜单下选择Dashboard：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627233440980-679554862.png&quot; alt=&quot;&quot; width=&quot;767&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在最近的异常信息中找到刚刚记录的：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627233550290-1257288320.png&quot; alt=&quot;&quot; width=&quot;665&quot; height=&quot;83&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　同样，通过超链接查看详细信息：&lt;/p&gt;
&lt;p&gt;　　Overview：可以看到这个异常的基本信息，比如Error Type以及Stack Trace，这些都是可以帮准我们快速定位错误的信息&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627233731226-203564129.png&quot; alt=&quot;&quot; width=&quot;592&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Exception：如果基本信息不够，那就查看详情，你可能需要看看加载了哪些Modules&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627233903549-1411628160.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后是Environment，跟Log的Environment差不多，这里就不再贴图了。&lt;/p&gt;

&lt;p&gt;　　我们说到Exceptionless是一款强大的开源框架，那么我们可以下载下来根据需要进行独立部署，可以不受一些用户、项目、Event数量的限制。这里我暂时不会去做其独立部署的实践，但是园子里已经有很多的独立部署实践的分享了，有兴趣的朋友可以看看下面几篇：&lt;/p&gt;
&lt;p&gt;　　罗曼缇克，《&lt;a href=&quot;https://www.cnblogs.com/aaaaq/p/9196123.html&quot;&gt;.Net 开源异常日志ExceptionLess搭建&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;　　平凡网客，《&lt;a href=&quot;https://www.cnblogs.com/uptothesky/p/5864863.html&quot;&gt;Exceptionless 本地部署&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;　　当然，官方的独立部署Wiki也是一个绝佳的参考资料：&lt;a href=&quot;https://github.com/exceptionless/Exceptionless/wiki/Self-Hosting&quot; target=&quot;_blank&quot;&gt;https://github.com/exceptionless/Exceptionless/wiki/Self-Hosting&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　以下是测试环境的要求：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627234507835-459859632.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以下是Production环境的要求，我们可以看到在Production环境中，强烈推荐使用&lt;em&gt;&lt;strong&gt;ELK&lt;/strong&gt;&lt;/em&gt;的ElasticSearch，如果有不知道ELK的朋友也可以百度/Google一下，ELK也是我后续的学习计划。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627234613304-582933482.png&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　本篇主要简单的介绍了一下开源的分布式日志框架Exceptionless，并通过两个小例子介绍了如何快速的在ASP.NET Core中进行使用，最后通过在Exceptionless平台中Check我们在程序中记录的日志/异常信息了解Exceptionless的强大。此外，通过引入园友和官方的Wiki文档介绍了Exceptionless的另一种使用模式：本地部署，有兴趣的朋友可以去看看，这里我就不再去实践了（对我现阶段而言，去做独立部署的优先级不高）。本篇没有过多的语言介绍，更多的是贴code以及贴图片，因此不能算是很好的介绍文章，不过结合列出的参考资料应该可以对Exceptionless做个快速入门。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180627235311865-1328563373.jpg&quot; alt=&quot;&quot; width=&quot;165&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一些朋友问我后续的分享计划，这里小小透漏一下：Ocelot+IdentityServer的结合做统一验证和授权，Ocelot+Butterfly的结合（目前Ocelot已集成Butterfly）做分布式追踪，基于AppMetrics+InfluxDB+Grafana的性能监控，数据一致性（可能会使用几个EventBus框架）初探，ASP.NET Core on Docker与K8S结合等等。等到POC初步研究后，可能还会去看看微软的微服务架构官方高级版大Demo-eShopOnContainers（微软有一本pdf大家可以去下载，&lt;a href=&quot;https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/docs/NET-Microservices-Architecture-for-Containerized-NET-Applications-(Microsoft-eBook)-zh-CN.pdf&quot; target=&quot;_blank&quot;&gt;点我下载&lt;/a&gt;）。这些计划可能需要花费我很多时间，不过我相信这样的学习和实践是值得的，也是值得分享的，如果你也有这样的计划，那就一起加油吧！&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/381412/201806/381412-20180628001326451-2034074258.png&quot; alt=&quot;&quot; width=&quot;190&quot; height=&quot;248&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Exceptionless Github：&lt;a href=&quot;https://github.com/exceptionless/Exceptionless&quot; target=&quot;_blank&quot;&gt;https://github.com/exceptionless/Exceptionless&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;savorboard（杨晓东），《&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/exceptionless.html&quot;&gt;免费开源分布式系统日志收集框架 Exceptionless&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;编程梦，《&lt;a href=&quot;https://www.cnblogs.com/LiangSW/p/6026817.html&quot;&gt;ExceptionLess新玩法 — 记日志&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;编程梦，《&lt;a href=&quot;https://www.cnblogs.com/LiangSW/p/6027026.html&quot;&gt;ExceptionLess新玩法 -- 审计日志&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;罗曼缇克，《&lt;a href=&quot;https://www.cnblogs.com/aaaaq/p/9196123.html&quot;&gt;.Net 开源异常日志ExceptionLess搭建&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;平凡网客，《&lt;a href=&quot;https://www.cnblogs.com/uptothesky/p/5864863.html&quot;&gt;Exceptionless 本地部署&lt;/a&gt;》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 27 Jun 2018 16:15:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/exceptionless_foundation_and_quick_start.html</dc:identifier>
</item>
<item>
<title>测试平台开发记录（一） - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/9236621.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/9236621.html</guid>
<description>&lt;p&gt;最近几个月最主要的工作就是测试平台开发，由于内容比较多，我计划分几期来讨论。&lt;/p&gt;
&lt;p&gt;提到“测试平台”测试会觉得比较高大上，其实就是“xx测试管理系统”，既然是一个管理系统，又是主要服务于测试的，所以，主要功能就是：管理接口、性能测试脚本、功能测试脚本，运行测试，生成报告、自动发邮件等。&lt;/p&gt;
&lt;p&gt;我在之前发的一篇文章中有探讨过，仅仅是做接口自动化测试，是否有必要做成测试平台，我们测试框架一样可以完成这些工作。不过，这就要求每位测试都有很强的开发能力。当然，我们测试平台不仅仅服务于测试，还服务于开发。这个是我稍微会详细介绍。&lt;/p&gt;

&lt;h3 id=&quot;项目背景&quot;&gt;项目背景：&lt;/h3&gt;
&lt;p&gt;这一次的平台开发并非从零开始的，在我和另一个妹子加入公司之前，已经有一位测试开发的同事开发了接口测试系统和性能测试系统。&lt;/p&gt;
&lt;p&gt;接口测试系统没怎么用起来，因为接口测试的创建和维护不太放方便的。这个会在后面的文章中详细探讨。 但是，性能测试系统一直用的还不错。&lt;/p&gt;
&lt;p&gt;当我们三个测试开发组成了一个小组后，老大希望做一个规范的测试平台出来。&lt;/p&gt;
&lt;p&gt;旧的系统由python + django框架完成后端的接口，由jQuery 来完成页面的开发。&lt;/p&gt;

&lt;h3 id=&quot;新的测试平台&quot;&gt;新的测试平台：&lt;/h3&gt;
&lt;p&gt;首先，是平台的技术选型，后端依然采用Python + Django框架完成接口的开发，前端使用Vue.js + element UI库。这种全完的前后端分离，使系统架构变得更加清晰，Django的模板语言本来就弱鸡，当然可以引用jQuery、bootstrap这样的前端库来完成页面开发。不过，考虑到后端接口数据会有更多应用。再加上前端框架的大热，于是选择Vue.js来做前端开发，element这类基于Vue.js 的UI库已经把大多功能组件化，现成的组件拿来用就好，很大的减少了工作量，否则完全自己调CSS样式是一个很大的工作量。&lt;/p&gt;
&lt;p&gt;老大的话是，你们要把自己当全栈工程师，为此我差点给Vue.js跪了。因为Vue.js的开发模式和传统的前端开发（HTML+JavaScript+CSS）完全不同。它以是组件化的方式开发页面。我看了三天都没完全理解Vue.js。不过，还是学会了，人被逼一下都进步的很快。我从三天写一个组件到现在一天写三个组件。&lt;/p&gt;
&lt;p&gt;其次，为平台定调，随便做做，把功能给实现了和从用户角度出发，考虑界面风格统一；从易性出发，考虑使用体验是两码事。所以，我们的测试平台是为了“方便”别人，“麻烦”自己，不然，它就失去了存在的价值。&lt;/p&gt;
&lt;p&gt;老大的话是，你们要知道做的东西是给别人用的，别人都觉得不好用，没人用，做它有什么用？为此，专门找到了设计的同事帮我们设计了一套原型图，整个系统按照原型图去开发。&lt;/p&gt;
&lt;p&gt;最后，是协作开发，一人开发和多人开发是不一样的，做过开发的才会有所体会。项目目录如何划分，文件、类、方法如何命名，开发功能模块如何划分。所以，我们每天早上开个小会汇报手上的进度，遇到困难也会拿出来讨论。下班前的一个小时要提交代码和合并代码。&lt;/p&gt;
&lt;p&gt;关于合并代码我也遇到一个抗，差一点写了一天半的代码找不回来了，幸好Git很强大。任何误操作都可以“反悔”。&lt;/p&gt;

&lt;h3 id=&quot;接口管理&quot;&gt;接口管理&lt;/h3&gt;
&lt;p&gt;首先，开发有自己的方式管理接口，而且也有他们自己习惯编写接口的方式。尤其是接口非常多了以后，他们并不愿意再重新跑到你的平台上按照提供的模板重新整理一遍接口。而且，每次接口变更后，都要在你的系统上更新。&lt;/p&gt;
&lt;p&gt;前面说过，要想你的平台给别人用，一定是为了方便“别人”，“麻烦”自己。&lt;/p&gt;
&lt;p&gt;经过分析，开发的接口由一个文档维护，里面通过Json格式编写接口文档，因此，经过沟通由开发提供一个接口，可以一次获取所有接口信息。然后，我们解析拆分出每一个接口，保存到自己的数据库中。当两边的接口信息发生变化时进行同步。也就是说，开发可以继续维护他们的接口文档，也可以登录测试平台维护。&lt;/p&gt;
&lt;p&gt;说了这么多！接下来show功能环节。测试平台可以直接使用公司邮箱登录。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201806/311516-20180627235505545-1255862658.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口的编辑，可以通过测试平台修改接口信息：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201806/311516-20180627235714401-1629863291.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口评论功能，主要给并前端开发使用，如果觉得后端的接口文档写得不规范。可以进行评价。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201806/311516-20180627235045257-1636859007.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当接口被修改后，你可以查看两个版本之间修改了什么。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/311516/201806/311516-20180627235232960-1503130696.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，你还可以关注该接口，当接口发生变化时，可以收到邮件。主要给测试和前端开发使用。&lt;/p&gt;
&lt;p&gt;PS： 本文首发于“测试圈TC” 公众号。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jun 2018 15:59:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/9236621.html</dc:identifier>
</item>
<item>
<title>设计模式(五)_工厂方法模式 - 阳光温暖</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9236539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9236539.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;今天主要讲解的是工厂方法模式。内容参考自java_my_life 博主的博客。但是拒绝粘贴复制，全部手打&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工厂方法模式是类的创建模式。工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作，推迟到子类中。&lt;/p&gt;
&lt;h4 id=&quot;案例说明&quot;&gt;案例说明&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;大家很多时候都做过导出功能，比如一个系统，需要导出的格式包括html、pdf等。但是财务系统导出的格式和其他普通的格式又不一样，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时如果用我们上篇学到的简单工厂模式，势必会让工厂类很繁琐，各种if判断。日后增加导出的格式，又会对工厂类进行增加逻辑编写。 此时我们采用 工厂方法模式进行实现。核心的工厂类不再负责所有对象的创建，它只是声明看一个工厂接口，具体的对象创建交给了子类。&lt;/p&gt;
&lt;p&gt;下面针对这个程序，我画的uml图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180627225739.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，一共有4个角色&lt;/p&gt;
&lt;p&gt;1.抽象导出角色&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface ExportFile {

    public boolean export(String data);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.具体导出角色&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ExportFinancialHtmlFile implements ExportFile {
    @Override
    public boolean export(String data) {

        System.out.println(&quot;导出财务版HTML文件&quot;);
        return true;
    }
}

public class ExportFinancialPdfFile implements ExportFile {
    @Override
    public boolean export(String data) {
        System.out.println(&quot;导出财务版PDF文件&quot;);
        return true;
    }
}

public class ExportStandardHtmlFile implements ExportFile {
    @Override
    public boolean export(String data) {
        System.out.println(&quot;导出标准版HTML文件&quot;);
        return true;
    }
}

public class ExportStandardPdfFile implements ExportFile {
    @Override
    public boolean export(String data) {
        System.out.println(&quot;导出财务版PDF文件&quot;);
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.抽象工厂角色&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface ExportFactory {

    public ExportFile factory(String type);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;具体工厂角色&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public class ExportHtmlFactory implements ExportFactory {
    @Override
    public ExportFile factory(String type) {
        if(&quot;standard&quot;.equals(type)){

            return new ExportStandardHtmlFile();
        }else if(&quot;financial&quot;.equals(type)){

            return new ExportFinancialHtmlFile();
        }else{
            throw new RuntimeException(&quot;没有找到对象&quot;);
        }
    }
}

public class ExportPdfFactory implements ExportFactory {
    @Override
    public ExportFile factory(String type) {
        if(&quot;standard&quot;.equals(type)){

            return new ExportStandardPdfFile();
        }else if(&quot;financial&quot;.equals(type)){

            return new ExportFinancialPdfFile();
        }else{
            throw new RuntimeException(&quot;没有找到对象&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public static void main(String[] args) {
        String data = &quot;&quot;;

        ExportFactory exportFactory = new ExportHtmlFactory();

        ExportFile exportFile = exportFactory.factory(&quot;financial&quot;);

        exportFile.export(data);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;导出财务版HTML文件&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;工厂方法模式和简单工厂模式明显的不同在结构上，工厂方法的核心是抽象工厂类，简单工厂模式的核心是一个具体的类&lt;/li&gt;
&lt;li&gt;如果系统新增一个导出类型，此时只需要增加一个导出类和对应的工厂类，客户端不需要改动，更符合开闭原则。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;需要注意一点，设计模式是一种设计思想，并不是一成不变的 ，不要为了套设计思想让代码变得复杂，反而是一种画蛇添足的做法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所有设计模式的代码已经放到&lt;a href=&quot;https://github.com/runzhenghengbin/DesignPattern.git&quot;&gt;github&lt;/a&gt;上。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jun 2018 15:20:00 +0000</pubDate>
<dc:creator>阳光温暖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9236539.html</dc:identifier>
</item>
<item>
<title>【Java】MyBatis与Spring框架整合（二） - 小铁Winner</title>
<link>http://www.cnblogs.com/xiaotie666/p/LiujinSpring_MyBatis2Summary.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaotie666/p/LiujinSpring_MyBatis2Summary.html</guid>
<description>&lt;p&gt;本文讲解 Spring 注入映射器及事务功能的实现。&lt;/p&gt;
&lt;h2&gt;注入映射器实现&lt;/h2&gt;
&lt;p&gt;MyBatis 可以使用 SqlSession 的 getMapper ( Class&amp;lt;T&amp;gt; type ) 方法，根据指定的映射器和映射文件直接生成实现类。这样不必自行编写映射器的实现类，就可以调用映射器的方法进行功能实现。&lt;/p&gt;
&lt;p&gt;SqlSessionTemplate 也有对应的 getMapper（）方法，利用 MyBatis-Spring 提供的组件，可以不必每次调用 getMapper（）方法，而是通过配置的方式直接为业务对象注入映射器实现。对于不包含其他非 MyBatis 的工作的数据访问操作，这是首选的做法。&lt;/p&gt;
&lt;h3&gt;使用 MapperScannerConfigurer 注入映射器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;SQL 映射文件中须遵循以下命名原则：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）映射的命名空间和映射器接口的名称相同。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）映射元素的 id 和映射器接口的方法相同。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，有关 DAO 接口的实现类可以删除了。&lt;/p&gt;
&lt;p&gt;配置注入映射器的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置 DAO &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;basePackage&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;cn.xxxx.mapper&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;basePackage 属性指定了扫描的基准包，MapperScannerConfigurer 将递归扫描基准包下所有接口。如果它们在 SQL 映射文件中定义过，则将它们动态注册为 MapperFactoryBean 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）basePackage 属性中可以包含多个包名。多个包名之间使用逗号或分号隔开。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）MapperScannerConfigurer 创建的所有映射器实现都会被自动注入 SqlSessionFactory 实例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）若环境中配置了多个 SqlSessionFactory 实例，自动装载将无法进行。此时应显式指定所依赖的 SqlSessionFactory 实例。下面是示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　 &amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sqlSessionFactoryBeanName&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;sqlSessionFactory&quot; /&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&lt;/span&gt;        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;basePackage&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;cn.bdqn.mapper&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;映射器被注册到 Spring 的容器时，Spring 会根据其接口名称为其命名，默认规则是首字母小写的非完全限定类名。如 UserMapper 类型组件会被默认命名为 userMapper。&lt;/p&gt;
&lt;p&gt;在业务逻辑实现类中使用 @Resource 或 @AutoWried 注解实现对业务组件的依赖注入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring 配置文件中需要引入 context 命名空间，并添加一行配置代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置扫描注解定义的业务 Bean &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;cn.xxxx.service&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;声明式事务&lt;/h2&gt;
&lt;p&gt;首先了解一下事务相关的理论知识&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原子性（Atomicity）：&lt;/strong&gt;事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一致性（Consistency）：&lt;/strong&gt;事务在完成时，必须是所有的数据都保持一致状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔离性（Isolation）：&lt;/strong&gt;并发事务执行之间无影响，在一个事务内部的操作对其他事务是不产生影响，这需要事务隔离级别来指定隔离性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持久性（Durability）：&lt;/strong&gt;一旦事务完成，数据库的改变必须是持久化的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;事务并发所可能存在的问题： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;脏读：&lt;/strong&gt;一个事务读到另一个事务未提交的更新数据。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;不可重复读：&lt;/strong&gt;一个事务两次读同一行数据，可是这两次读到的数据不一样。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;幻读：&lt;/strong&gt;一个事务执行两次查询，但第二次查询比第一次查询多出了一些数据行。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;丢失更新：&lt;/strong&gt;撤消一个事务时，把其它事务已提交的更新的数据覆盖了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;JDBC定制了五种事务隔离级别处理事务并发：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TRANSACTION_NONE JDBC ：驱动不支持事务&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;TRANSACTION_READ_UNCOMMITTED： 允许脏读、不可重复读和幻读。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;TRANSACTION_READ_COMMITTED： 禁止脏读，但允许不可重复读和幻读。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;TRANSACTION_REPEATABLE_READ： 禁止脏读和不可重复读，单运行幻读。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;TRANSACTION_SERIALIZABLE： 禁止脏读、不可重复读和幻读。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;隔离级别越高，意味着数据库事务并发执行性能越差，能处理的操作就越少。&lt;/p&gt;
&lt;p&gt;JDBC规范虽然定义了事务的以上支持行为，但是各个JDBC驱动，数据库厂商对事务的支持程度可能各不相同。&lt;br/&gt;出于性能的考虑我们一般设置 &lt;strong&gt;TRANSACTION_READ_COMMITTED&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通过Spring，我们无需处理获得连接、关闭连接、事务提交和回滚等这些操作，使得我们把更多的精力放在处理业务上。&lt;/p&gt;
&lt;p&gt;事实上Spring并不直接管理事务，而是提供了多种事务管理器。它们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。&lt;/p&gt;
&lt;p&gt;本文主要讲解 Spring 提供的声明式事务处理机制，它基于 AOP 实现，无须编写任何事务管理代码，所有的工作全在配置文件中完成。&lt;/p&gt;
&lt;h3&gt;配置&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;需要用到 tx 和 aop 两个命名空间，所以首先要导入这两个命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xmlns:p&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;
    xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt; xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
    xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans 
     http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
     &lt;strong&gt;http://www.springframework.org/schema/tx
     http://www.springframework.org/schema/tx/spring-tx.xsd
     http://www.springframework.org/schema/aop 
     http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
&lt;/strong&gt;     http://www.springframework.org/schema/context
     http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置一个事务管理器组件，这里使用 Spring 提供的事务管理器类 DataSourceTransactionManager&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义事务管理器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot; /&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这里的 dataSource 是上文中配置的数据源组件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过 &amp;lt;tx ：advice&amp;gt; 标签配置事务增强，设定事务的属性，为不同的业务方法指定具体的事务规则。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 为指定事务管理器设置事务属性 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:advice &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txAdvice&quot;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; transaction-manager&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义属性，声明事务规则 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:attributes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;add*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;REQUIRED&quot;&lt;/span&gt;&lt;span&gt; isolation&lt;/span&gt;&lt;span&gt;=&quot;DEFAULT&quot;&lt;/span&gt;&lt;span&gt;
                read-only&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;  &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;del*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;REQUIRED&quot;&lt;/span&gt;&lt;span&gt; isolation&lt;/span&gt;&lt;span&gt;=&quot;DEFAULT&quot;&lt;/span&gt;&lt;span&gt;
                read-only&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;update*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;REQUIRED&quot;&lt;/span&gt;&lt;span&gt; isolation&lt;/span&gt;&lt;span&gt;=&quot;DEFAULT&quot;&lt;/span&gt;&lt;span&gt;
                read-only&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;query*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;NEVER&quot;&lt;/span&gt;&lt;span&gt; read-only&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;get*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;NEVER&quot;&lt;/span&gt;&lt;span&gt; read-only&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:attributes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:advice&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;transaction-manager 属性引用一个事务管理器 Bean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;tx：attributes&amp;gt; 子标签用来定制事务属性。事务属性通过 &amp;lt;tx：method&amp;gt; 标签进行设置。&lt;/p&gt;
&lt;p&gt;&amp;lt;tx：method&amp;gt; 标签中 name 属性是必须的，用于指定匹配的方法，可以使用通配符（ * ）。其他属性均为可选，用于指定具体的事务规则。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Spring 事务的传播属性&lt;/span&gt;&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_REQUIRED&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 0&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是Spring默认的事务的传播。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_SUPPORTS&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　支持当前事务，如果当前没有事务，就以非事务方式执行。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_MANDATORY&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　支持当前事务，如果当前没有事务，就抛出异常。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_REQUIRES_NEW&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 3&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　新建事务，如果当前存在事务，把当前事务挂起。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_NOT_SUPPORTED&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 4&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_NEVER&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 5&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　以非事务方式执行，如果当前存在事务，则抛出异常。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; PROPAGATION_NESTED&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 6&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;Spring 事务的隔离级别&lt;/span&gt;&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; ISOLATION_DEFAULT&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; ISOLATION_READ_UNCOMMITTED&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻读。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; ISOLATION_READ_COMMITTED&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; ISOLATION_REPEATABLE_READ&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 4&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻读。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt; ISOLATION_SERIALIZABLE&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 8&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;　　这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻读。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;最后是定义切面&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义切面 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义切入点 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:pointcut &lt;/span&gt;&lt;span&gt;expression&lt;/span&gt;&lt;span&gt;=&quot;execution(* cn.xxxx.service..*.*(..))&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;pointcutTransaction&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 将事务增强与切入点组合 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:advisor &lt;/span&gt;&lt;span&gt;advice-ref&lt;/span&gt;&lt;span&gt;=&quot;txAdvice&quot;&lt;/span&gt;&lt;span&gt; pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;pointcutTransaction&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;使用注解实现声明式事务处理&lt;/h2&gt;
&lt;p&gt; Spring 支持使用注解配置声明式事务，所使用的注解是 &lt;strong&gt;&lt;span&gt;@Transactional&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;首先需要在 Spring 配置文件中添加对注解配置的事务的支持&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:annotation-driven &lt;/span&gt;&lt;span&gt;transaction-manager&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;在 Service 业务逻辑实现类中添加注解&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;strong&gt;@Transactional&lt;/strong&gt;&lt;/span&gt;
@Service(&lt;/span&gt;&quot;userSerivce&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserService &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IUserService{
    
    @Autowired
    @Qualifier(&lt;/span&gt;&quot;userMapper&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserMapper userMapper;

    @Override
    &lt;span&gt;&lt;strong&gt;@Transactional(propagation&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;=Propagation.SUPPORTS)
    &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;USER&amp;gt;&lt;span&gt; queryUsers() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userMapper.queryUsers();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）在类上添加 @Transactional 注解可为该类的所有业务方法统一添加事务处理。如果某一业务方法需要采用不同的事务规则，可以在该业务方法上添加 @Transactional 注解单独进行设置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）不建议在查询方法上使用事务，会影响查询的性能。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用注解配置事务时，所使用的属性与在 Spring 配置文件中使用的属性一致。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 27 Jun 2018 14:59:00 +0000</pubDate>
<dc:creator>小铁Winner</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaotie666/p/LiujinSpring_MyBatis2Summary.html</dc:identifier>
</item>
<item>
<title>山寨版计算器 - Roy-T</title>
<link>http://www.cnblogs.com/roy-t/p/calc01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/roy-t/p/calc01.html</guid>
<description>&lt;p&gt;今天小酌一杯，起了点点飞智，想用HTML/CSS/JS来山寨一个mac系统自带的计算器。先给自己立两个flag：&lt;/p&gt;
&lt;p&gt;【像众泰学习】外观、功能像素级拷贝为主，兼顾山寨气质。&lt;/p&gt;
&lt;p&gt;【像泽野螳螂学习】原曲不使用。（努力做到不借鉴任何现成的方案）&lt;/p&gt;
&lt;p&gt;废话不多说，现在开始。&lt;/p&gt;
&lt;p&gt;首先，以下是原软件的截图。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627220258391-604829482.png&quot; alt=&quot;&quot; width=&quot;194&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来分析一下颜色：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标题栏的三个按钮目前暂无用处，暂时先不考虑。&lt;/li&gt;
&lt;li&gt;不考虑毛玻璃效果，我无意中截到的单色背景是#292929，字符颜色#ffffff。姑且先用这个。&lt;/li&gt;
&lt;li&gt;功能键区（AC、+/-、%）背景色#d6d6d6，字符颜色#000000。&lt;/li&gt;
&lt;li&gt;数字键区（0-9和小数点）背景色#e0e0e0。字符颜色#000000。&lt;/li&gt;
&lt;li&gt;运算符（+、-、*、/、=）背景色#f5923e，字符颜色#ffffff。&lt;/li&gt;
&lt;li&gt;全界面框线颜色#181818。&lt;/li&gt;
&lt;li&gt;按键区框线颜色#8e8e8e。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以及动画效果：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于数字显示区是毛玻璃的，因此背景是随时变化的，这里放弃了。&lt;/li&gt;
&lt;li&gt;按下鼠标键时，功能键区背景色颜色变为#a9a9a9，字符不变色。&lt;/li&gt;
&lt;li&gt;按下鼠标键时，数字键区背景色颜色变为#b2b2b2，字符不变色。&lt;/li&gt;
&lt;li&gt;按下鼠标键时，运算符区背景色颜色变为#c2732f，字符颜色变为#555555。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后测量一下界面的大小：（我这个屏幕是Retina屏，计算出的像素数应用到实际界面要除以2。）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;整个界面（含框线）宽466像素，高642像素。&lt;/li&gt;
&lt;li&gt;整个界面的边框宽度均为1像素，表格四个圆角半径10像素。&lt;/li&gt;
&lt;li&gt;按键分割线宽度2像素。&lt;/li&gt;
&lt;li&gt;数字显示区和按键区之间分割线宽度为0。&lt;/li&gt;
&lt;li&gt;按键区4列不等宽，不含分割线的宽度分别为112、114、114、118像素，是不是有点诡异。&lt;/li&gt;
&lt;li&gt;按键区5行也不等高，不含分割线前4行的高度为94像素，最后一行高96像素。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来是界面字体。（字体我很难做到像素级匹配）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;整体采用了San Francisco字体。&lt;/li&gt;
&lt;li&gt;数字显示区字体是细字体，按钮区是常规字体。&lt;/li&gt;
&lt;li&gt;字号大小：功能键区&amp;lt;数字键区&amp;lt;运算符区。&lt;/li&gt;
&lt;li&gt;数字键区的字符太长放不下时会自动压缩大小。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面操练起来吧。&lt;/p&gt;
&lt;p&gt;首先，不考虑任何格式因素，先画一个结构相符的表格。在这个表格里实现这个计算器就可以。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;display&quot;&lt;/span&gt;&lt;span&gt; colspan&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;AC&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;+/-&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;%&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;➗&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
…
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;colspan&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;=&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以得到以下的界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627221049516-406699385.png&quot; alt=&quot;&quot; width=&quot;196&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是颜色匹配。在分析时我们已经按颜色把按键区分成了功能键区、运算符区和数字键区，所以这里就可以为每个按钮添加一个class来指定它所对应的按键区域。字符显示区与按键不同，单独提。比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; .digit &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;background-color=#e0e0e0&lt;/span&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
…
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;digit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加动画：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; .digit:active &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #a9a9a9&lt;/span&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时界面就上好色了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627221328467-1790818527.png&quot; alt=&quot;&quot; width=&quot;216&quot; height=&quot;320&quot;/&gt; &lt;/p&gt;
&lt;p&gt;下面考虑边框问题，如果简单处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;table &lt;/span&gt;{&lt;span&gt;
    border-radius&lt;/span&gt;:&lt;span&gt; 5px&lt;/span&gt;;&lt;span&gt;
    border&lt;/span&gt;:&lt;span&gt; 0.5px solid #181818&lt;/span&gt;;
}&lt;span&gt;
td &lt;/span&gt;{&lt;span&gt;
    border&lt;/span&gt;:&lt;span&gt; 1px solid #8e8e8e&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到的结果肯定不是所希望的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627221552933-1919903683.png&quot; alt=&quot;&quot; width=&quot;186&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是因为HTML管理元素的“margin-border-padding”机制，也就是盒子模型，使得单线表格的实现方式并不是那么直接，尝试一下&lt;span&gt;border:collapse: collapse&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627221732240-1750712973.png&quot; alt=&quot;&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;圆角被顶没了？很遗憾，&lt;span&gt;collapse&lt;/span&gt;与&lt;span&gt;border-radius&lt;/span&gt;是不能同时使用的。我又尝试了几种方案，找到了一条可行的思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为按键区域设置&lt;span&gt;border-spacing: 0&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;为左上和上部的按钮单独绘制所有边框；&lt;/li&gt;
&lt;li&gt;为其它按钮绘制右侧和底部的边框。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这乍看上去有点愚蠢，但似乎是唯一的思路。情况统一的按钮可以合并处理从而减少一定的工作量。比如按键区中间的按键（8、9、5、6、2、3）可以：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.center &lt;/span&gt;{&lt;span&gt;
    border-right&lt;/span&gt;:&lt;span&gt; 1px solid #8e8e8e&lt;/span&gt;;&lt;span&gt;
    border-bottom&lt;/span&gt;:&lt;span&gt; 1px solid #8e8e8e&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627222015927-339047922.png&quot; alt=&quot;&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;接下来设置界面的大小，需要注意的是，table中td的width包含内容的宽度和两次边框的宽度（高度也是），而我们在测量原版软件时的宽度值是除两侧边框之外的宽度，因此这里设置width时要减去边框的宽度，比如最左侧一列按钮，有左侧0.5像素和右侧1像素的边框，因此原宽度56要减去1.5。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.left &lt;/span&gt;{&lt;span&gt;
   border-left&lt;/span&gt;:&lt;span&gt; 0.5px solid #181818&lt;/span&gt;;&lt;span&gt;  
   border-right&lt;/span&gt;:&lt;span&gt; 1px solid #8e8e8e&lt;/span&gt;;&lt;span&gt;
   border-bottom&lt;/span&gt;:&lt;span&gt; 1px solid #8e8e8e&lt;/span&gt;;&lt;span&gt;
   width&lt;/span&gt;:&lt;span&gt; 54.5px&lt;/span&gt;;&lt;span&gt;
   height&lt;/span&gt;:&lt;span&gt; 46px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627230811667-1968234812.png&quot; alt=&quot;&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就快成功了，字体只说一点：用之前一定看看它是否免费许可。鉴于我只是写来玩玩出于对苹果的崇敬才用的这个字体，苹果大大是不会打我屁屁的，但是你要在你的网站里未经许可使用了付费字体，你会很受伤。还有界面里的字体我没有做到像素对齐，是懒了。（逃&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366973/201806/1366973-20180627223424567-1860819861.png&quot; alt=&quot;&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;p&gt;众泰Z700既视感有没有。就问你像不像〇〇〇〇 ？&lt;/p&gt;
&lt;p&gt;to be continued&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jun 2018 14:44:00 +0000</pubDate>
<dc:creator>Roy-T</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/roy-t/p/calc01.html</dc:identifier>
</item>
<item>
<title>Node.js 开发 Alfred workflow 初体验 - 韩子迟</title>
<link>http://www.cnblogs.com/zichi/p/9234866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zichi/p/9234866.html</guid>
<description>&lt;p&gt;本文简单记录下如何用 Node.js 开发一个 Alfred workflow 的过程。&lt;/p&gt;
&lt;p&gt;之前开发过自己用的小工具，这次打算开发 &lt;a href=&quot;https://github.com/hanzichi/CDNSearcher&quot;&gt;CDNSearcher&lt;/a&gt;，用了半天才回忆起来开发流程，我在想如果之前简单记录了下，或许这次就不用花那么长时间回顾了，遂写此文。&lt;/p&gt;
&lt;p&gt;该 workflow 使用方式如下：（使用请点击 &lt;a href=&quot;https://github.com/hanzichi/CDNSearcher&quot;&gt;这里&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170816949-1253305290.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于 Alfred 以及 Alfred workflow 的使用，这里不赘述，推荐看下这篇 &lt;a href=&quot;http://louiszhai.github.io/2018/05/31/alfred/&quot;&gt;Alfred 神器使用手册&lt;/a&gt;，很详细，里面涉及了一些我常用的功能。&lt;/p&gt;
&lt;p&gt;个人理解，workflow 是一种简单的 in-out 的形式，简化了中间过程重复的操作，能极大提高效率。&lt;strong&gt;许多 chrome 扩展以及命令行工具都可以做成 Alfred workflow 的形式&lt;/strong&gt;，使之更加通用（很常见的比如 chrome 翻译扩展，图床工具 等等，可以自己脑洞大开）。&lt;/p&gt;
&lt;p&gt;接着我们一步步来开发 &lt;a href=&quot;https://github.com/hanzichi/CDNSearcher&quot;&gt;CDNSearcher&lt;/a&gt; 这个 workflow。&lt;/p&gt;
&lt;p&gt;首先打开 [Alfred Preferences]，在左上角选择 [Workflows] 这个 tab。然后点击左下角的 [+]，选择 [Blank Workflow]，会出现如下一个弹窗，填写一些关于这个 workflow 的信息。这里注意下 [Bundle Id] 这个 key，这是代表 workflow 的唯一指定 id，需要填写一个唯一的字符串。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627165820225-1497275242.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着左侧的列表便会出现这个新建的 workflow，右键 -&amp;gt; Open In Finder，便可以看到这个 workflow 文件。此时只有一个 info.plist 文件，暂时不用关注它，&lt;strong&gt;也无需编辑它&lt;/strong&gt;，之后在 Alfred 中每一次图形化操作的过程中都会自动更新这个文件。&lt;/p&gt;
&lt;p&gt;我们直接看这个编辑好的流程图，操作非常简单，直接右键添加，并且可以自己拖拽，形象地演示了这个 workflow 的步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627203155624-2049854308.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看最左上角的这个，这是一个 [Script Filter]。常见的 workflow，需要自己输入关键字，脚本执行后出现列表，基本都是 [Script Filter] 了。双击打开它，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170134324-1928494735.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回顾一下使用这个 workflow 的步骤，比如要搜索 vue 相关的 cdn，呼出 Alfred 后键入 &lt;code&gt;cdn vue&lt;/code&gt;，然后会出现列表如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170226448-1937052419.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入的 &lt;code&gt;vue&lt;/code&gt;，其实就是 &lt;code&gt;{query}&lt;/code&gt;，然后会自动执行这行命令 &lt;code&gt;/usr/local/bin/node index.js &quot;{query}&quot;&lt;/code&gt;，&lt;code&gt;{query}&lt;/code&gt; 会自动被自己输入的字符串代替，这里就很熟悉了吧，执行一个 node 脚本，这个脚本非常简单，无非就是做一个 HTTP 请求，分析并得到一些数据。&lt;/p&gt;
&lt;p&gt;如何展示这些数据？如果用的是 js，&lt;strong&gt;代码中 &lt;code&gt;console.log()&lt;/code&gt; 的数据便会展示在 Alfred 前台&lt;/strong&gt;。具体看 &lt;a href=&quot;https://github.com/hanzichi/CDNSearcher/blob/master/index.js&quot;&gt;这个文件&lt;/a&gt;（&lt;strong&gt;所以用 js 开发的时候，debug 不能用 console.log，可以用 console.warn 等代替&lt;/strong&gt;）。最终的展示是一个数组，每个元素是一个对象，可以包括如下几个 key：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;title&lt;/li&gt;
&lt;li&gt;subtitle&lt;/li&gt;
&lt;li&gt;icon&lt;/li&gt;
&lt;li&gt;arg&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意一下 arg，按回车后，Alfred 会把这个变量传递给下一个步骤（比如进入粘贴板，或者在浏览器打开，或者继续传入下一个脚本去执行，等等）&lt;/p&gt;
&lt;p&gt;我们试了几次，可能会发现 query 的内容还没输入完，就已经显示结果了（即内容还没输入完，脚本就在执行了），我们希望 query 输入完整后再执行脚本，有点类似 js 中的函数节流去抖的意思。单击 [Run Behaviour] 进行调整即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170258432-1780321871.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时我们已经完成了第一步，我们需要完成第二步。还是以上面的 &lt;code&gt;cdn vue&lt;/code&gt; 为例，这个列表中，我选择了 vuex，是如何得到以下结果的？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627171407144-688313078.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这还是一个 [Script Filter]，只不过它的 &lt;code&gt;{query}&lt;/code&gt; 就是上个步骤的执行结果，而且不需要 [Keyword] 了。&lt;/p&gt;
&lt;p&gt;大概长这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627205304537-850993307.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这部分代码 &lt;a href=&quot;https://github.com/hanzichi/CDNSearcher/blob/master/detail.js&quot;&gt;在这里&lt;/a&gt;。最后在流程图上加上 [Copy to Clipboard]，enter 后便会复制到粘贴板。&lt;/p&gt;
&lt;p&gt;在实际开发的过程中，我希望 enter 后复制 CDN 的链接，cmd+enter 能够在浏览器中打开该 CDN 文件。因为这两步的内容是不一样的，所以需要分两步走。在第二个 [Script Filter] 中，我们可以得到 CDN 的链接，但是如果要引用，我希望能加上 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 或者 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 标签，这里我又用了一个 [Run Script]，继续拼接字符串，因为这个代码比较简单，所以直接用了 Alfred 提供的选项 &lt;code&gt;/usr/bin/osascript(JS)&lt;/code&gt;：（提醒下，我先用了 ES6 的模版字符串，报错了 ...）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627204251775-42665136.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里又出现了问题，[Run Script] 后返回的字符串，会自动多加一个回车，搜索引擎是个好东西，[Utilities → Transform → Trim Whitespace] 完美解决，详见 &lt;a href=&quot;https://www.alfredforum.com/topic/10098-newline-n-added-when-var-will-be-set/&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;另外一条流程主要是为了删除文件缓存，就不需要 [Script Filter] 了，直接在命令行执行就 ok 了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170338947-489223117.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/675542/201806/675542-20180627170347709-1203455930.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，这个简单的 workflow 算是完工了。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jun 2018 13:34:00 +0000</pubDate>
<dc:creator>韩子迟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zichi/p/9234866.html</dc:identifier>
</item>
<item>
<title>翻译 | 浅析算法复杂度分析 - 信号君</title>
<link>http://www.cnblogs.com/ncdxlxk/p/9235971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ncdxlxk/p/9235971.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/746315/201806/746315-20180627205426409-584841445.png&quot; alt=&quot;&quot; width=&quot;322&quot; height=&quot;322&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;原文：A Gentle Introduction to Algorithm Complexity Analysis—— By Dionyziz.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如今，很多编程人员都在制作一些最酷、最实用的软件，比如我们在互联网上看到的或者每天使用的很多东西。尽管他们很多都没有计算机科学理论的背景，他们仍然是非常棒的、有创意的程序员，感谢他们所做的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;尽管如此，计算机科学理论依然有它的用途和应用，且被证明是相当实用的。在本文中，针对那些了解编程艺术但是没有任何计算机科学理论背景的程序员，我将介绍计算机科学最实用的工具之一——大写O符号和算法复杂度分析。作为在计算机科学学术界工作过，并在工业界搭建产品级软件的人，这是我在实践中发现的真正有用的工具之一，所以我希望在阅读本文后，您可以将其应用于自己的代码中，以使其更好。读完本文，您可以理解计算机科学家使用的所有常见术语，如“大写O”、“渐近行为”和“最坏情况分析”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——略去部分——&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;许多行业程序员和初级学生都难以理解大写O符号和算法复杂度分析，他们为此感到恐惧并且尽量避免接触。但是，这些并不像看起来那么难以理解或理论化。算法复杂度只是一种正式测量程序或算法运行速度的方法，它确实非常实用。我们来简单介绍一下这个话题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;分析背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道，有一些称为分析器（profiler）的程序，以毫秒为单位来测量运行时间，协助我们发现运行瓶颈来优化代码。虽然这是一个有用的工具，但它与算法复杂度无关。&lt;span&gt;算法复杂度是为了在理念层面上比较两种算法而设计的——忽略低级细节&lt;/span&gt;（如实现所用编程语言、运行算法的硬件或者给定的CPU指令集）。我们想仅依据算法本身的内容来比较算法：关于某物如何计算的理念，而统计毫秒数对此没有帮助。使用低级编程语言（如汇编）编写的差算法很可能比使用高级编程语言（如Python或Ruby）编写的好算法快得多。所以，现在是时候确定一个“更好的算法”是什么了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;算法是只执行计算的程序，而不是计算机经常执行的其它任务如网络任务或用户输入和输出。&lt;/span&gt;复杂度分析使得我们能够衡量程序在计算时到底有多快。纯粹计算的例子有包括数值浮点运算（如加法和乘法）；在一个数据库内搜索一个给定值；确定人工智能角色在视频游戏中将要经历的路径，以便他们只需要在虚拟世界内走一小段距离（见图1）；或者在字符串上运行正则表达式进行模式匹配。显然，计算在计算机程序中无处不在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/746315/201806/746315-20180627205511853-985840684.jpg&quot; alt=&quot;&quot; width=&quot;588&quot; height=&quot;330&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1 视频游戏中人工智能使用算法来躲避虚拟世界的障碍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;复杂度分析也是一个工具，可以让我们了解一个算法如何随着输入变大而变化。如果我们给它一个不同的输入，算法将如何表现？&lt;/span&gt;如果我们的算法需要1秒钟能运行1000个输入，那么如果我将输入大小加倍，它将会如何工作？它的运行速度是快一倍，还是慢四倍？在实际编程中，这非常重要，因为它使我们能够预测当输入数据变大时我们的算法将如何表现。例如，如果我们做了一个适用于1000个用户的Web应用程序，并测量其运行时间，使用算法复杂度分析，我们就可以很好地了解一旦拥有2000个用户，程序会发生什么。对于算法竞赛，复杂度分析让我们了解运行测试程序正确性的最大测试用例时，我们的代码将运行多长时间。所以如果我们测试了程序在小输入量时的行为，就可以很好地了解它是如何处理更大的输入的。我们从一个简单的例子开始：查找数组中的最大元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;统计指令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这篇文章中，我将使用各种编程语言来举例。如果您不知道某种特定的编程语言，请不要失望，因为既然你懂编程，即使是你不熟悉的编程语言，你也应该可以毫无问题地阅读这些例子，因为它们很简单，我不会使用任何深奥的语言特性。如果你是一个参加算法比赛的学生，你很可能使用C++，所以你应该没有问题。对于这个例子，我建议使用C++进行练习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组中的最大元素可以用一段简单的代码来查找，比如这段JavaScript代码。给定一个大小为n的输入数组A：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;var M = A[ 0 ];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;for ( var i = 0; i &amp;lt; n; ++i ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if ( A[ i ] &amp;gt;= M ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        M = A[ i ];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;现在，要做的第一件事是计算这段代码执行多少个基本指令，这对进一步解释我们的理论并没有太大必要，这里只做一次，所以在我分析时请多一点耐心。分析这段代码时，我们想把它分解成简单的指令，那些CPU可以直接执行或者是接近底层的东西。假设处理器可以执行下面的操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设分支（在if条件被判定后if...else之间的代码部分）立即发生并且不计入这些指令。在上面的代码中，第一行代码是：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;var M = A[ 0 ];&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这需要2条指令：一条用于读取A[0]；一条用于给M赋值（假定n至少为1），无论n的值如何，这两条指令都是算法需要的。for循环初始化代码也必须始终运行，这带来了两条指令：一条赋值指令和一条比较指令：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;i = 0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;i &amp;lt; n;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这些将在for循环第一次迭代前运行，开始循环迭代后，我们需要运行另两条指令：i自增1和一条比较指令，用于检查是否保持循环：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;++i;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;i &amp;lt; n;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;所以，如果忽略循环体，这个算法需要的指令数是4 + 2n。也就是说，for循环开始处有4条指令，在n次迭代中，每次迭代结束时有2条指令。我们现在可以定义一个数学函数f（n），给定一个n时，就能知道算法需要的指令数量。对于一个空循环体，有f（n）= 4 + 2n。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;最坏情况分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，来看循环体：数组查找和比较必不可少：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;if ( A[ i ] &amp;gt;= M ) { ...&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这里有两条指令。但是if代码体可能运行，也可能不运行，这取决于数组的值究竟是什么。如果恰好是A [i]&amp;gt; = M，那么将运行这两条额外的指令——一条数组读取和一条赋值：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;M = A[ i ];&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;但是现在要定义f（n）并不容易，因为指令数量并不仅仅依赖于n，而且还取决于我们的输入。例如，对于A = [1,2,3,4]，算法将比A = [4,3,2,1]需要更多的指令。在分析算法时，我们经常考虑最坏的情况：什么是算法可能发生的最糟糕的情况？算法在什么情况下需要最多的指令来完成？在这个例子中，最坏情况就是当我们有一个按升序排列的数组时，例如A = [1,2,3,4]。在这种情况下，M需要每一次都被替换，因此产生最多的指令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算机科学家为此赋予一个奇特的名字，他们称之为最坏情况分析，无论如何情况都不会比这更坏的了！因此，在最坏的情况下，我们有4条指令在for循环体内运行，所以我们有f（n）= 4 + 2n + 4n = 6n + 4。函数f在给定一个问题的大小n时，能指示我们最坏情况下需要多少条指令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;渐近行为&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;给定f这样一个函数，使我们对算法运行有多快有了很好的概念。但是，正如我前面所说，我们不需要经历繁琐的计算指令的过程。此外，每个编程语言语句所需的实际CPU指令的数量取决于编译器和可用的CPU指令集（例如，您的PC上的处理器是AMD还是Intel Pentium，或者您的PS2上是MIPS处理器），我们希望忽略这些因素。现在通过一个“过滤器”来简化“f”函数，这将帮助我们摆脱那些计算机科学家们不愿意忽略的细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在函数6n + 4中，有两个因素项：6n和4。在复杂度分析中，我们只关心随着程序输入（n）的增长，指令计数函数将发生了什么。&lt;span&gt;这同上面“最坏情况分析”的思想一致：我们感兴趣的是算法如何面对坏的情况，它何时会遇到具有挑战性的艰难任务。&lt;/span&gt;请注意，这对比较算法非常有用！如果一个算法在大量输入上击败另一个算法，那么当给定一个更简单，更小的输入时，它也很可能是更快的。从正在考虑的条件来看，我们将丢弃所有增长缓慢的因素，只保留随着n变大而快速增长的因素。显然，随着n的增大，4仍然是4，但6n越来越大，它对于更大的输入问题越来越重要。因此，我们要做的第一件事就是丢弃4，并使函数f（n）= 6n。试想，4只是一个“初始化常量”， 不同的编程语言可能需要不同的时间来设置（例如，Java需要一些时间来初始化其虚拟机），忽略这个值使得我们不用考虑编程语言的差异，这是有意义的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将忽略的第二件事是n前面的常系数，如此一来函数将变成f（n）= n。正如你所看到的，这可以使事情变得非常简单。同样，&lt;span&gt;如果考虑到不同语言是如何被编译的，那么放弃这个乘法常量是有意义的。&lt;/span&gt;“数组访问”语句会在不同的编程语言下被编译成不同的指令，例如，在C中，做A[i]不包括检查i是否符合数组大小，而在Pascal中却需要这么做。下面是Pascal代码：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;M := A[ i ]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;其等价于C中的&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;if ( i &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;lt; n ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    M = A[ i ];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;因此，我们需要考虑到对于不同的编程语言来说，在统计指令时将会有不一样的结果。 在上面的例子中，Pascal使用了一个更“笨”的编译器，它忽略了可能的优化。Pascal需要3条指令来访问每个数组元素，而C只需要一条。&lt;span&gt;忽略常系数是忽略特定的编程语言和编译器之间的差异，将分析重点放在算法本身的思想上来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上所述的“忽略常系数”和“保留关键影响因子”的过滤器就是我们所说的渐近行为。所以f（n）= 2n + 8的渐近行为由函数f（n）= n描述。从数学上讲，渐进行为所说的是n趋于无穷大时，我们对函数f的极限感兴趣。但是如果你不明白这个词的正式含义，别担心，因为这些就是你所需要知道的（在严谨的数学问题中，我们不能将常量从极限内移除，但出于计算机科学的目的，我们需要这样做）。看几个例子来熟悉这个概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们通过忽略常系数和保留增长最快的因素项来找到以下示例函数的渐近行为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. f(n) = 5n + 12 得到 f(n) = n。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于以上分析的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. f(n) = 109 得到 f(n) = 1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;忽略乘数109 * 1，但依然需要放置1在这里，以表明函数不是一个非零值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. f(n) = n^2 + 3n + 112 得到 f(n) = n2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里, n^2 比 3n 随n增长的快，因此保留它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. f(n) = n^3 + 1999n + 1337 得到 f(n) = n^3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然前面有一个很大的常系数，但我们依然可以找到一个n使得 n^3 比 1999n大。由于我们只关心n为非常大的数时候后的情况，因此只保留n^3(如图 2)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. f(n) = n + sqrt(n) 得到 f(n) = n。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于n增长的比sqrt(n)快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/746315/201806/746315-20180627205637603-854302283.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;303&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2 蓝色绘制的n^3函数在n = 45之后比红色绘制的1999n函数大，之后一直保持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;复杂度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以这告诉我们的是，通过忽略所有这些修饰的常量，很容易就判断出程序的指令计数函数的渐近行为。实际上，没有任何循环的程序都会有f（n）= 1，因为它需要的指令数量只是一个常量（除非它使用递归；见下文）。任何具有从1到n的单循环程序都将有f（n）= n，因为它在循环之前执行恒定数量的指令，在循环之后执行恒定数量的指令，并在n次循环中每次运行恒定数量指令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在应该比计算独立的指令容易得多，也不那么繁琐，让我们来看几个例子来熟悉它。下面的PHP程序检查一个大小为n的数组A中是否存在一个特定的值：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;?php&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$exists = false;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;for ( $i = 0; $i &amp;lt; n; ++$i ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if ( $A[ $i ] == $value ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        $exists = true;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        break;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这种在数组内搜索值的方法称为线性搜索，因为这个程序的f（n）= n，所以这么说很合理（我们将在下一节中准确定义“线性”的含义）。您可能会注意到，这里有一个“break”语句，即使只迭代了一次，程序也可能会突然终止。但是请记住，我们对最坏的情况感兴趣，对于这个程序来说，最坏情况就是数组A不包含这个值。所以我们仍然有f（n）= n。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下的C++程序检查一个大小为n的向量A是否包含相同的两个值：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;bool duplicate = false;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;for ( int i = 0; i &amp;lt; n; ++i ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    for ( int j = 0; j &amp;lt; n; ++j ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        if ( i != j &amp;amp;&amp;amp; A[ i ] == A[ j ] )  {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            duplicate = true;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            break;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    if ( duplicate )  {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        break;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;因为这里有两个嵌套的循环，我们将其渐进行为描述为为f（n）= n^2。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;经验法则：简单的程序可以通过计算程序的嵌套循环来分析。n次的单层循环得到f（n）= n。双层嵌套循环得到f（n）= n^2。三层嵌套循环得到f（n）= n^3。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;如果我们有一个在循环中调用函数的程序，并且知道被调用函数执行的指令的数量，则很容易确定整个程序的指令数量。我们来看看这个C例子：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;int i;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;for ( i = 0; i &amp;lt; n; ++i ) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    f( n );&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;如果我们知道f（n）是一个正好执行n个指令的函数，那么我们就可以知道整个程序的指令数量是渐近n^2的，因为这个函数正好被调用n次。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;经验法则：给定一系列顺序执行的for循环，其中最慢的循环决定程序的渐近行为。两个嵌套循环后跟一个单层循环，其渐进行为与仅有嵌套循环时相同，因为嵌套循环支配简单循环。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;现在，让我们切换到计算机科学家使用的奇特符号。当找出了这样的渐进函数f，我们可以说程序是Θ（f（n））的,Θ（n）读作“theta of n”。有时候我们说包含常量的指令计数原始函数f（n）是Θ（某物）,例如，可以说f（n）= 2n是Θ（n），也可以写成2n∈Θ（n）。这里没有什么新的东西，不要对这个表示法感到困惑，所有的意思是：如果我们已经计算出一个程序需要的指令的数量为2n，通过忽略常量，那么这个算法的渐近行为就用n来描述。 解释了这种表示法，下面是一些真正的数学表述：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;n^6 + 3n ∈ Θ( n^6 )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2n + 12 ∈ Θ( 2n )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3n + 2n ∈ Θ( 3n )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;n^n + n ∈ Θ( n^n )&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;经验法则：具有较大Θ的程序比具有较小Θ的程序运行得慢。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;大O符号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特别是对于更复杂的例子，有时候我们很难正确地指出算法的行为，但是，我们可以知道算法的行为将永远不会超过一定的界限。这将使生活变得更加简单，因为不需要确切地指出算法的运行速度，我们所要做的就是找到一定的界限。这个例子很容易解释。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;排序问题是计算机科学家用于算法教学的著名问题。在排序问题中，给出一个大小为n的数组A（听起来很熟悉？），要求编写程序对这个数组排序。这个问题很有趣，因为这是现实系统中的一个实际问题。例如，文件资源管理器需要按名称对其显示的文件进行排序，以便用户可以轻松地导航它们。或者另一个例子，视频游戏可能需要根据玩家眼睛在虚拟世界中的距离，来分类显示虚拟世界中的3D对象，以便确定哪些是可见的，哪些是不可见的，称为可见性问题（见图3）。最接近玩家的物体是那些可见的，而那些更远的物体可能被它们前面的物体隐藏起来。排序也很有趣，因为有很多算法可以解决这个问题，且有优劣之分，它同时也是易于定义和解释的简单问题。就让我们来编写一个排序数组的代码吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/746315/201806/746315-20180627205724100-987557997.jpg&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;378&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3 位于黄点的玩家不会看到阴影区域。 把世界分成小片段，按距离排列，是解决可见性问题的一种方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是一个在Ruby中实现数组排序的低效方法（当然，Ruby支持使用你使用恰当的内置函数对数组进行排序，而这些函数肯定比我们在这里看到的要快，但这里仅仅是为了说明目的而设）。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;b = []&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;n.times do&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    m = a[ 0 ]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    mi = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    a.each_with_index do |element, i|&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        if element &amp;lt; m&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            m = element&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            mi = i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    a.delete_at( mi )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    b &amp;lt;&amp;lt; m&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;end&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这种方法被称为选择排序。它找出数组的最小值（数组表示为a，而最小值表示为m，mi是它的索引），将它放在新数组的末尾（例中的b），并将其从原始数组删除。然后接着找到原始数组剩余值之间的最小值，将其添加到新数组中，并将其从原始数组中删除，现在新数组已经有两个元素。它继续这个过程，直到所有的元素都被从原始数组中删除，并且被插入到新的数组中，这意味着数组已经被排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个例子中，我们可以看到我们有两个嵌套循环。外循环运行n次，内循环为数组a的每个元素运行一次。虽然数组a最初有n个元素，但在每次迭代中删除一个数组元素。因此，内循环在外循环的第一次迭代期间重复n次，然后是n-1次，然后是n-2次……，直到外循环的最后一次迭代为止，在该迭代期间它只运行一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;评估这个程序的复杂度有点困难，因为必须计算1 + 2 + ... +（n-1）+ n的总和，但我们一定能确定一个“上限”。因此，我们可以改变程序（你可以用你的想法代替实际写代码来这么做），使它变得更糟，然后找到新程序的复杂度。如果能够找到构建的更糟糕的程序的复杂度，就能知道原来的程序是最坏的，或者是更好的。 如果我们发现改造的程序复杂度很好，但却比我们原来的程序更糟糕，那么可以知道原来的程序也具有相当不错的复杂度——与改造的程序一样好或是更好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在让我们想想编辑这个示例程序的方法，以便更容易地找出它的复杂度。但请记住，只能让它变得更糟，也即多消耗一些指令，使得估计对我们原来的计划是有意义的。显然，我们可以使程序的内部循环总是重复n次，而不是可变的次数。其中一些重复将是无用的，但它将帮助我们分析所得算法的复杂度。如果这样做，新构造的算法复杂度显然是Θ（n^2），因为有两个嵌套的循环，每个循环重复n次。像这样，我们说原来的算法复杂度是O（n^2）。O（n^2）意思是我们的程序渐近地不比n^2差,甚至可能比这更好，也可能一样好。顺便说一下，如果程序确实是Θ（n^2），我们仍然可以说它是O（n^2）。为了帮助你认识到这一点，设想改变并没有使原来程序的方式有太大变化，但是还是会使程序变得更糟，比如在程序开始的时候增加一个无意义的指令。这样做会为指令的统计结果引来一个常量，并在描述渐近行为时将它忽略。&lt;span&gt;所以一个Θ（n^2）的程序也是O（n^2）的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但是一个O（n^2）的程序可能不是Θ（n^2）。&lt;/span&gt;例如，除了可以为O（n）之外，任何Θ（n）的程序也是O（n^2）的。我们试想一个Θ（n）程序是一个重复n次的简单循环，我们可以通过将它装进另一个重复n次的循环中而使其变得更糟，从而产生具有f（n）=n^2的程序。概括来说，当b比a更差时，任何Θ（a）的程序都是O（b）的。请注意，我们对程序的修改并不需要具有实际上的意义或是等同于我们原来的程序。对于给定的n，它只需要比原始程序具有更多的指令，我们仅用它来影响指令的统计，而不是解决实际的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，说程序是O（n^2）是没问题的：我们已经分析了我们的算法，发现它永远不会比n^2差，但实际上可能达到n^2，这让我们可以很好的估计程序运行速度。让我们通过几个例子来帮助你熟悉这个新的符号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——略去练习题部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.Cormen, Leiserson, Rivest, Stein. Introduction to Algorithms, MIT Press.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.Dasgupta, Papadimitriou, Vazirani. Algorithms, McGraw-Hill Press.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.Fotakis. Course of Discrete Mathematics at the National Technical University of Athens.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.Fotakis. Course of Algorithms and Complexity at the National Technical University of Athens.&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;·END·&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想进一步跟踪本博客动态，欢迎关注我的个人微信订阅号：&lt;strong&gt;信号君&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;信号君：寻求简单之道&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;技术成长 | 读书笔记 | 认知升级&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/746315/201806/746315-20180624104439302-493786623.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扫描二维码关注信号君&lt;/p&gt;


</description>
<pubDate>Wed, 27 Jun 2018 13:03:00 +0000</pubDate>
<dc:creator>信号君</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ncdxlxk/p/9235971.html</dc:identifier>
</item>
<item>
<title>记录一次批量插入的优化历程 - JMCui</title>
<link>http://www.cnblogs.com/jmcui/p/9233427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmcui/p/9233427.html</guid>
<description>&lt;pre&gt;
String sql = &quot;INSERT INTO &quot; +
        &quot; yy_marketing_coupon(uuid,no,name,type,money,status,instruction,astrict,total_number,&quot; +
        &quot;remain_number,send_mode,get_mode,use_mode,user_rank_lower,send_start_time,send_end_time,&quot; +
        &quot;use_start_time,use_end_time,use_expire_time,discount,user_mobiles,create_time,creater,&quot; +
        &quot;update_time,updater,appid,use_car_type,highest_money,term_type,coupon_template_uuid,gift_uuid,&quot; +
        &quot;city_uuids,city_names) &quot; +
        &quot; values (?,(select FN_CREATE_COUPON_NO(1)),?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)&quot;&lt;span&gt;;
List&lt;/span&gt;&amp;lt;Object[]&amp;gt; batchArgs = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; marketingCouponListDo.size();
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i++&lt;span&gt;) {
    MarketingCouponDto dto &lt;/span&gt;=&lt;span&gt; marketingCouponListDo.get(i);
    Object[] objects &lt;/span&gt;=&lt;span&gt; {
            dto.getUuid(),
            dto.getName(),
            dto.getType(),
            dto.getMoney(),
            dto.getStatus(),
            dto.getInstruction(),
            dto.getAstrict(),
            dto.getTotalNumber(),
            dto.getRemainNumber(),
            dto.getSendMode(),
            dto.getGetMode(),
            dto.getUseMode(),
            dto.getUserRankLower(),
            dto.getSendStartTime(),
            dto.getSendEndTime(),
            dto.getUseStartTime(),
            dto.getUseEndTime(),
            dto.getUseExpireTime(),
            dto.getDiscount(),
            dto.getUserMobiles(),
            dto.getCreateTime(),
            dto.getCreater(),
            dto.getUpdateTime(),
            dto.getUpdater(),
            dto.getAppid(),
            dto.getUseCarType(),
            dto.getHighestMoney(),
            dto.getTermType(),
            dto.getCouponTemplateUuid(),
            dto.getGiftUuid(),
            dto.getCityUuids(),
            dto.getCityNames()
    };
    batchArgs.add(objects);
}
jdbcTemplate.batchUpdate(sql, batchArgs);&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 27 Jun 2018 12:16:00 +0000</pubDate>
<dc:creator>JMCui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jmcui/p/9233427.html</dc:identifier>
</item>
</channel>
</rss>