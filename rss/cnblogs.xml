<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Struts2与Ajax数据交互 - 蚊蚊蚊蚊蚊170624</title>
<link>http://www.cnblogs.com/eleven258/p/8361536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eleven258/p/8361536.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;ajax请求在项目中常常使用,今天就平时掌握的总结一下，关于使用ajax请求到Struts2中的action时，前台页面与后台action之间的数据传递交互问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里我主要记录下自己所掌握的几种方式。可以根据自己平时项目的需求来进行选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   &lt;span&gt;&lt;strong&gt;1.使用stream类型的result&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　此种类型可以直接让Struts2中的action向客户端浏览器生成文本响应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　jsp页面：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/struts-tags&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html;charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ajax提交登录信息&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;导入js插件&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;${PageContext.request.contextPath}/demo/js/jquery-1.4.4.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;异步登录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:form &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;loginForm&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;POST&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:textfield &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:textfield &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;psw&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;loginBtn&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;s:form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;show&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;display:none;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#loginBtn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).hide();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送请求login 以各表单里歌空间作为请求参数&lt;/span&gt;
&lt;span&gt;        $.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,$(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#loginForm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).serializeArray(),
            &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(&lt;span&gt;data&lt;/span&gt;,statusText){

                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).height(&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;)
                    .width(&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1px solid black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border-radius&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;backgroud-color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#efef99&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ff0000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;padding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .empty();
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录结果:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).show(&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;);

        },&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);//指定服务器响应为html
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;处理逻辑的action:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Description:eleven.action
 * Author: Eleven
 * Date: 2018/1/26 18:09
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoginAction &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActionSupport{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String psw;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出结果的二进制流&lt;/span&gt;
    &lt;span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; InputStream inputStream;

&lt;/span&gt;&lt;/span&gt;&lt;span&gt;    public&lt;/span&gt; String login() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(username.equals(&quot;tom&quot;)&amp;amp;&amp;amp; psw.equals(&quot;123&quot;&lt;span&gt;)){
            inputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(&quot;恭喜您，登录成功&quot;.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            inputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(&quot;对不起，登录失败&quot;.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供get方法&lt;/span&gt;
   &lt;span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; InputStream getInputStream() {

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inputStream;
    }

&lt;/span&gt;&lt;/span&gt;&lt;span&gt;    public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPsw() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; psw;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPsw(String psw) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.psw =&lt;span&gt; psw;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;action中除了接收页面传递的用户名、密码外，还有一个InputStream类型的成员变量，并为它提供了对应的get方法。get方法中返回的二进制流将会直接输出给客户端浏览器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　struts.xml配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE struts PUBLIC
    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constant &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts.enable.DynamicMethodInvocation&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constant &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts.devMode&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt; namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;eleven.action.LoginAction&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;stream&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;指定stream流生成响应的数据类型&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;contentType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;text/html&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;指定action中由哪个方法去输出InputStream类型的变量&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;inputName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;inputStream&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　在浏览器中浏览该页面，并输入相关信息，然后提交，可以看到后台action直接将消息数据返回给页面，而同时页面也不需要进行刷新，而是直接在局部进行显示，这是利用了ajax的异步发送请求。注意，此种方式需要在struts.xml文件中要配置类型为stream的流，并设置inputName属性，并在action中提供InputStream对应的get方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　运行截图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1188460/201801/1188460-20180127094301647-1500533537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.使用json类型的result&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;有个jar包struts2-json-plugin-2.3.16.3.jar，可以为Struts2增加JSON插件，即当action中的result的类型设为json时，也可以在客户端js中异步调用action,并且action中返回的数据，可以直接被JSON插件序列化成json格式的字符串，并将该字符串返回给客户端浏览器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　示例:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　jsp页面：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/struts-tags&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html;charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ajax提交登录信息&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;导入js插件&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;${PageContext.request.contextPath}/demo/js/jquery-1.4.4.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;异步登录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:form &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;loginForm&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;POST&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:textfield &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:textfield &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;psw&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;loginBtn&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;s:form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;show&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;display:none;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#loginBtn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).hide();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送请求login 以各表单里歌空间作为请求参数&lt;/span&gt;
&lt;span&gt;        $.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,$(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#loginForm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).serializeArray(),
            &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data,statusText){
                &lt;/span&gt;&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时的data中包含username,psw,age&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).height(&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;)
                    .width(&lt;/span&gt;&lt;span&gt;300&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1px solid black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border-radius&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;backgroud-color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#efef99&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ff0000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;padding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .empty();
               &lt;/span&gt;
&lt;span&gt;                alert(data);
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).append(data&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).show(&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;);

        },&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;action代码:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoginAction &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActionSupport{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String psw;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String login() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        age &lt;/span&gt;= 18&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPsw() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; psw;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPsw(String psw) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.psw =&lt;span&gt; psw;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　struts.xml中配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE struts PUBLIC
    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constant &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts.enable.DynamicMethodInvocation&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constant &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts.devMode&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt; namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default,&lt;span&gt;json-default&lt;/span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;eleven.action.LoginAction&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;json&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;noCache&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;contentType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;text/html&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;在浏览器中浏览该页面，并输入相关信息，然后提交，可以看到后台action直接将消息数据返回给页面，而同时页面也不需要进行刷新，而是直接在局部进行显示，这是利用了ajax的异步发送请求。注意，此种方式需要在struts.xml文件中要配置package继承json-default,且配置result类型为json，并在action中提供需要传递数据的对应的get方法。当然了前提是添加了struts2-json-plugin-2.3.16.3.jar，不然struts2是不会自动将数据转为json格式的数据的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　效果截图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1188460/201801/1188460-20180127102523506-1696228024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　故我们可以总结一下result类型为json的步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;1.导入jar包：struts2-json-plugin-2.3.7.jar&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　2.配置struts返回的结果集视图 设置type=json&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　3.设置对应action所在的package继承自json-default&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　4.将要返回的数据提供get方法&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　5.在struts.xml中设置返回数据的格式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于第5步设置返回数据的格式,可以根据自己项目的需要，去具体设置，这里只是简单举例，并没有拿复杂的数据，如果是返回一个List集合，那么对于数据的格式可以进行如下设置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;json&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 设置数据的来源从某个数据得到 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       　&amp;lt;!-- 过滤数据从gtmList集合中得到，且只获取集合中对象的name，跟uuid属性 --&amp;gt;　&lt;span&gt;&lt;br/&gt;　　　　　&amp;lt;param name=&quot;root&quot;&amp;gt;gtmList&amp;lt;/param&amp;gt;
        &amp;lt;param name=&quot;includeProperties&quot;&amp;gt;
              \[\d+\]\.name,
              \[\d+\]\.uuid
        &amp;lt;/param&amp;gt; &lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　上面这种方式外，还有下面这种方式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ajaxGetBySm&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;json&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            
          &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 一般使用这种方式 先用来源过滤action默认从整个action中获取所有的（前提是此action中没有getAction()方法）
                但是为了方便  一般不写root:action这个
                然后再用包含设置进行过滤设置
          &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;                
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;action&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;includeProperties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                 gtmList\[\d+\]\.name,
                 gtmList\[\d+\]\.uuid
          &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;上面两种方式都是设置数据从gtmList集合中获取且，只获取对象的属性为name与uuid的。这里只做简单的举例，具体可自己下去深入研究。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　附上json类型的Result允许指定的常用参数:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1188460/201801/1188460-20180127152335365-232845018.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　另外，除了以上两种是struts2支持的ajax外，其实如果单纯的只是可以让服务器端可以跟客户端浏览器进行数据交互，可以使用response.getWrite()这种方式。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PrintWriter printWriter =&lt;span&gt;response.getWriter();
printWriter.print(&lt;/span&gt;&quot;success&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;选择哪种方式?&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于我，如果只是对增删改功能是否成功的一个flag判断的数据，则可优先选择response.getWriter().print(&quot;xxx&quot;)与设置result类型为stream的方式，但是如果是需要返回大量对象数据，在页面接收然后进行数据展示，例如页面通过ajax请求，需要后台action返回一个list集合，则就要选择配置result类型为json的方式了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 27 Jan 2018 07:31:00 +0000</pubDate>
<dc:creator>蚊蚊蚊蚊蚊170624</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eleven258/p/8361536.html</dc:identifier>
</item>
<item>
<title>粗略的物体碰撞预测及检测 - DHUtoBUAA</title>
<link>http://www.cnblogs.com/DHUtoBUAA/p/8366062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DHUtoBUAA/p/8366062.html</guid>
<description>&lt;p&gt;  该博客实时更新于&lt;a href=&quot;https://github.com/wylloong/TinyPrograms/blob/master/TechBlog/%E7%B2%97%E7%95%A5%E7%9A%84%E7%89%A9%E4%BD%93%E7%A2%B0%E6%92%9E%E9%A2%84%E6%B5%8B%E5%8F%8A%E6%A3%80%E6%B5%8B.md&quot;&gt;我的Github&lt;/a&gt;。&lt;br/&gt;  在机器人局部路径规划中，需要实时躲避运动或者静态的障碍物，这个过程涉及到碰撞检测这个问题，本文主要讨论这个问题。&lt;br/&gt;  碰撞检测问题也是游戏开发中经常遇到的问题，一个游戏场景中可能存在很多物体，它们之间大多属于较远位置或者相对无关的状态，那么一个物体的碰撞运算没必要遍历这些物体，我们可以使用一个包围一个或多个物体的多边形来讨论碰撞问题，这样子可以节省重要的计算量和时间。&lt;br/&gt;  在真实的物理系统中，一般需要在运算速度和精确性上做取舍。尽管非常精确的碰撞检测算法可以精确地表示和解决碰撞问题，但是在路径规划初期对碰撞只需要有一个初步的估计，比如是否会发生碰撞，碰撞的大概程度如何，以免把大量的精力浪费在碰撞检测问题上，从而降低了在其他方面的注意力。本文主要利用游戏中用到的碰撞检测方法，来解决碰撞检测的初步估计，或者对碰撞精确度要求不高的场合，将不规则的物体投影成较规则的物体进行碰撞预测及检测。&lt;/p&gt;

&lt;p&gt;  目前，成功的3D游戏普遍采用的碰撞检测是BSP树以及AABB(Axially Aligned Bounding Box)包装盒方式。BSP树是用来控制检测顺序和方向的数据描述。这里不再详细讨论。AABB检测方法采用一个描述用的立方体或者球形体包裹住3D物体对象的整体（或者主要部分），我们可以根据包装盒的距离、位置等信息来计算是否发生碰撞。注意：出于计算量和方便性考虑，AABB中常用的包装盒形状是球体和长方体，但是在其它特殊场合，其他形状也可以作为包装盒。&lt;br/&gt;  坐标轴平行（Axially-aligned）不仅指盒体与世界坐标轴平行，同时也指盒体的每个面都和一条坐标轴垂直，这样一个基本信息就能减少转换盒体时操作的次数。AABB技术在当今的许多游戏中都得到了应用，开发者经常用它们作为模型的检测模型。&lt;br/&gt;  二维场景中的AABB包围盒具备特点(下图中的所有坐标系均采用右手直角坐标系):&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;表现形式为四边形，即用四边形包围物体。&lt;/li&gt;
&lt;li&gt;四边形的每一条边，都会与坐标系的轴垂直。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/44012494.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  三维场景中的AABB包围盒特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;表现形式为六面体。&lt;/li&gt;
&lt;li&gt;六面体中的每条边都平行于一个坐标平。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/31070002.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  其中，为了更明显的展示AABB包围盒的特点，在最右侧展示了一个OBB（Oriented Bounding Box）包围盒，也称作有向包围盒。AABB包围盒与OBB包围盒的最直接的区别就是，AABB包围盒是不可以旋转的，而OBB包围盒是可以旋转的，也就是有向的。&lt;/p&gt;
&lt;p&gt;  三维场景中物体的AABB包围盒是一个六面体，虽然有8个顶点，但是对于规则的AABB立方体，我们仅需要知道两个顶点(x&lt;sub&gt;min&lt;/sub&gt;,y&lt;sub&gt;min&lt;/sub&gt;,z&lt;sub&gt;min&lt;/sub&gt;)和(x&lt;sub&gt;max&lt;/sub&gt;,y&lt;sub&gt;max&lt;/sub&gt;,z&lt;sub&gt;max&lt;/sub&gt;)就可以得到AABB的中心点、边长等属性,具体不再详述。&lt;em&gt;三维物体的AABB包围盒的八个顶点依旧可以用两个顶点来标识&lt;/em&gt;，如下图所示。&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/2161.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  球体是碰撞检测中最简单的数学模型，我们只需要直到两个球体的球心和半径就可以进行检测。&lt;br/&gt;  球体碰撞的优点是非常适用于需要快速检测的游戏，因为它不需要精确的碰撞检测算法,执行速度相对较快，不会给CPU带来过大的计算负担。球体碰撞的另一个劣势是只适用于近似球形物体，如果物体非常窄或者非常宽，该碰撞检测算法将会失效，因为会在物体实际发生碰撞之前，碰撞检测系统就发出碰撞信号。&lt;/p&gt;
&lt;h2 id=&quot;球体树&quot;&gt;球体树&lt;/h2&gt;
&lt;p&gt;  为了解决包容球精确度不高的问题，人们又提出了&lt;strong&gt;球体树&lt;/strong&gt;的方法。如下图所示，球体树实际上是一种表达3D物体的层次结构。对一个形状复杂的3D物体，先用一个大球体包容整个物体，然后对物体的各个主要部分用小一点的球体来表示，然后对更小的细节用更小的包容球体，这些球体和它们之间的层次关系就形成了一个球体树。&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/92221122.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  举例来说，对一个游戏中的人物角色，可以用一个大球来表示整个人，然后用中等大小的球体来表示四肢和躯干，然后用更小的球体来表示手脚等。这样在对两个物体进行碰撞检测时，先比较两个最大的球体。如果有重叠，则沿树结构向下遍历，对小一点的球体进行比较，直到没有任何球体重叠，或者到了最小的球体，这个最小的球体所包含的部分就是碰撞的部分。&lt;/p&gt;
&lt;h2 id=&quot;速度锥&quot;&gt;速度锥&lt;/h2&gt;
&lt;p&gt;  在实际碰撞检测中，我们需要提前预估碰撞的危险程度，通过将运动物体碰撞处理为两个球体，在已知球体的球心、半径、运动矢量后，就可以预估出沿着当前运动趋势的最近距离和对应时间。为方便理解，如下图所示，以二维平面上的两个圆形为例建立相对运动坐标系，讨论碰撞检测问题，可以扩展到3维空间的球体中。&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/66783426.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  在二维平面内，障碍物的碰撞预测如下，其中&lt;strong&gt;DCPA表示最近距离的值，TCPA表示在最近时刻的时间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/12448785.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  碰撞预测C#源代码:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// C# 代码
public static ARPA CPACalculation(double USVGeo_x, double USVGeo_y, double OBSGeo_x, double OBSGeo_y, double USV_Speed, double USV_Azimuth, double OBS_Speed, double OBS_Azimuth)
{
    // 计算距离
    double distance = GeographyBase.GeographyTransfer.CalLength(USVGeo_x,USVGeo_y,OBSGeo_x,OBSGeo_y);
    // 计算方位
    double UAV2OBSAzimuth = GeographyBase.GeographyTransfer.CalAzimuth(USVGeo_x, USVGeo_y, OBSGeo_x, OBSGeo_y);
    double interAngle = USV_Azimuth - OBS_Azimuth; //取值范围在[-180, 180]之间
    if (interAngle &amp;gt; 180)
        interAngle -= 360;
    if (interAngle &amp;lt; -180)
        interAngle += 360;
    // 相对速度
    double RelativSpeed = Math.Sqrt(Math.Pow(USV_Speed, 2) + Math.Pow(OBS_Speed, 2) - 2 * USV_Speed * OBS_Speed * Math.Cos(interAngle / 180.0 * Math.PI));
    // 相对航向
    double angleQ = Math.Acos((Math.Pow(RelativSpeed, 2) + Math.Pow(USV_Speed, 2) - Math.Pow(OBS_Speed, 2)) / (2 * RelativSpeed * USV_Speed)) * 180.0 / Math.PI;
    double RelativeAzimuth = 0;
    if (interAngle &amp;gt; 0)
        RelativeAzimuth = USV_Azimuth + angleQ;
    else
        RelativeAzimuth = USV_Azimuth - angleQ;
    // 相对舷角的计算 
    double bearing = UAV2OBSAzimuth - RelativeAzimuth;
    double DCPA = distance * Math.Sin(bearing * Math.PI / 180.0);
    double TCPA = distance * Math.Cos(bearing * Math.PI / 180.0) / RelativSpeed;
    ARPA arpa = new ARPA();
    arpa.DCPA = DCPA;
    arpa.TCPA = TCPA;
    arpa.SailSpeed = OBS_Speed;
    arpa.SailAngle = OBS_Azimuth;
    arpa.TargetDistance = distance;
    arpa.TargetAzimuth = UAV2OBSAzimuth;
    return arpa;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;  AABB对物体的方向很敏感，同一物体的不同方向，AABB也可能不同（由于球体只有一个自由度，所以检测球对物体方向不敏感）。&lt;br/&gt;  当物体在场景中移动时，它的AABB也需要随之移动，当物体发生旋转时，有两种选择：用变换后的物体来重新计算AABB，或者对AABB做和物体同样的变换。如果物体没有发生扭曲，可以通过“变换后AABB”重新计算，因为该方法要比通过“变换后的物体”计算快得多。可以利用矩阵变化加快新的AABB的计算速度，具体可以参考&lt;a href=&quot;http://www.docin.com/p-538256449.html&quot;&gt;适合新手的3d碰撞检测&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;aabb静态检测&quot;&gt;AABB静态检测&lt;/h3&gt;
&lt;p&gt;  AABB的静态检测比较简单，检测两个静止包装盒是否相交，它是一种布尔测试，测试结果只有相交或者不相交。这里我们还提供了获取相交范围信息的方法，一般来说，这种测试的目的是为了返回一个布尔值。&lt;br/&gt;  在一维坐标轴中，两线段A和B相交的条件是:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线段A在坐标轴上的最大值A&lt;sub&gt;max&lt;/sub&gt;不小于线段B在坐标轴上的最小值B&lt;sub&gt;min&lt;/sub&gt;;&lt;/li&gt;
&lt;li&gt;线段B坐标轴上的最大值B&lt;sub&gt;max&lt;/sub&gt;不小于线段A在坐标轴上的最小值A&lt;sub&gt;min&lt;/sub&gt;;&lt;br/&gt;即 (A&lt;sub&gt;max&lt;/sub&gt;-B&lt;sub&gt;min&lt;/sub&gt;)*(B&lt;sub&gt;max&lt;/sub&gt;-A&lt;sub&gt;min&lt;/sub&gt;)&amp;gt;0&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  基于上述事实，&lt;strong&gt;二维场景中AABB碰撞检测原理&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/70742987.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  在上图中，分别做物体A与物体B在X,Y轴方向的投影，物体A的Y轴方向最大点坐标为Y1，最小点坐标Y2，X轴方向最小点坐标X1，最大点坐标X2，物体B同理。图中红色区域为物体A与物体B投影的重叠部分。&lt;br/&gt;  &lt;em&gt;二维场景中AABB碰撞检测具有如下规则：物体A与物体B分别沿两个坐标轴做投影，只有在两个坐标轴都发生重叠的情况下，两个物体才意味着发生了碰撞&lt;/em&gt;。&lt;br/&gt;  即，若Y轴方向上(Y1-Y4)*(Y3-Y2)&amp;gt;0，X轴方向上(X4-X1)*(X2-X3)&amp;gt;0,那么证明物体A与物体B发生重合，否则证明物体A和B并未发生重合。&lt;br/&gt;  &lt;strong&gt;三维场景中AABB碰撞检测原理&lt;/strong&gt;:&lt;br/&gt;  三维场景中物体的AABB包围盒是一个六面体，其坐标系对于二维坐标系来讲只是多了一个Z轴，所以实际上在三维场景中物体的AABB碰撞检测依然可以采用四个点信息的判定来实现，即从物体A的八个顶点与物体B的八个顶点分别选出两个最大与最小的顶点进行对比。碰撞的示意如下图：&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/81364644.jpg&quot;/&gt;&lt;br/&gt;  &lt;em&gt;三维场景中AABB碰撞检测具有如下规则：物体A与物体B分别沿三个坐标轴做投影，只有在三个坐标轴都发生重叠的情况下，两个物体才意味着发生了碰撞&lt;/em&gt;。&lt;br/&gt;  实现代码如下，其中min和max数组是另一个AABB的最小点和最大点，最后返回碰撞检测结果和碰撞部分的AABB。&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/68475964.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/3866616.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/58966858.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;运动多面体&quot;&gt;运动多面体&lt;/h3&gt;
&lt;p&gt;  在使用单步碰撞检测时，存在时间步长较大时会发生两个物体完全穿透而算法却未检测出来的问题，如下图所示。通常的解决方法是产生一个4D空间，在单位时间步长内，在物体运动的开始和结束时间之间产生一个&lt;strong&gt;4D超多面体&lt;/strong&gt;，又称运动多面体，用于穿透测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/44640621.jpg&quot;/&gt;&lt;br/&gt;  对一个三维物体网格化处理后，需要对三维物体内的子网格做碰撞监测，子网格是规则的立方体。在单位时长内，连接开始和结束时刻物体的最大包络线得到的就是运动多面体。其中，通过求取垂直物体运动方向上的宽度就可以得到包络线的宽度，可以应用旋转的方法。&lt;br/&gt;  AABB碰撞检测算法虽然计算方法简单，速度快，但是仅适用于精度要求不高的场合中。相对于AABB碰撞检测，还有一种更逼近物体并更为精确的一种算法--OBB碰撞检测。&lt;/p&gt;

&lt;p&gt;  未完待续&lt;/p&gt;

&lt;p&gt;[1] Gottschalk, Stefan, Ming C. Lin, and Dinesh Manocha. &quot;OBBTree: A hierarchical structure for rapid interference detection.&quot; Proceedings of the 23rd annual conference on Computer graphics and interactive techniques. ACM, 1996.&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/u012945598/article/details/39524343&quot;&gt;三维物体AABB碰撞检测算法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.docin.com/p-538256449.html&quot;&gt;适合新手的3d碰撞检测&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://wenku.baidu.com/view/d90ca0c3bb4cf7ec4afed043.html&quot;&gt;船舶碰撞危险度的计算方法比较(非匿名)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jan 2018 06:51:00 +0000</pubDate>
<dc:creator>DHUtoBUAA</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DHUtoBUAA/p/8366062.html</dc:identifier>
</item>
<item>
<title>JavaScript基础：DOM操作详解 - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8366012.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8366012.html</guid>
<description>&lt;blockquote readability=&quot;5.375&quot;&gt;
&lt;p&gt;本文最初发表于&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8366012.html&quot;&gt;博客园&lt;/a&gt;，并在&lt;a href=&quot;https://github.com/smyhvae/Web&quot;&gt;GitHub&lt;/a&gt;上持续更新&lt;strong&gt;前端的系列文章&lt;/strong&gt;。欢迎在GitHub上关注我，一起入门和进阶前端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;h3 id=&quot;javascript的组成&quot;&gt;JavaScript的组成&lt;/h3&gt;
&lt;p&gt;JavaScript基础分为三个部分：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;DOM&lt;/strong&gt;：文档对象模型，操作&lt;strong&gt;网页上的元素&lt;/strong&gt;的API。比如让盒子移动、变色、轮播图等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;BOM&lt;/strong&gt;：浏览器对象模型，操作&lt;strong&gt;浏览器部分功能&lt;/strong&gt;的API。比如让浏览器自动滚动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;事件&quot;&gt;事件&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;JS是以&lt;strong&gt;事件驱动为核心&lt;/strong&gt;的一门语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;事件的三要素&quot;&gt;事件的三要素&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;事件的三要素：事件源、事件、事件驱动程序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如，我用手去按开关，灯亮了。这件事情里，事件源是：手。事件是：按开关。事件驱动程序是：灯的开和关。&lt;/p&gt;
&lt;p&gt;再比如，网页上弹出一个广告，我点击右上角的&lt;code&gt;X&lt;/code&gt;，广告就关闭了。这件事情里，事件源是：&lt;code&gt;X&lt;/code&gt;。事件是：onclick。事件驱动程序是：广告关闭了。&lt;/p&gt;
&lt;p&gt;于是我们可以总结出：谁引发的后续事件，谁就是事件源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事件源：引发后续事件的html标签。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事件：js已经定义好了（见下图）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事件驱动程序：对样式和html的操作。也就是DOM。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;代码书写步骤如下：&lt;/strong&gt;（重要）&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;（1）获取事件源：document.getElementById(“box”); // 类似于Android里面的findViewById&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;（2）绑定事件： 事件源box.事件onclick = function(){ 事件驱动程序 };&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;（3）书写事件驱动程序：关于DOM的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最简单的代码举例：（点击box1，然后弹框）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;box1&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 1、获取事件源&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; div &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;box1&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 2、绑定事件&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;div&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 3、书写事件驱动程序&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是弹出的内容&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;&amp;lt;/body&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常见的事件如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_1553.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面针对这事件的三要素，进行分别介绍。&lt;/p&gt;
&lt;h3 id=&quot;获取事件源的方式dom节点的获取&quot;&gt;1、获取事件源的方式（DOM节点的获取）&lt;/h3&gt;
&lt;p&gt;获取事件源的常见方式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; div1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;box1&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;//方式一：通过id获取单个标签&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;div1&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;//方式二：通过 标签名 获得 标签数组，所以有s&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByClassName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hehe&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//方式三：通过 类名 获得 标签数组，所以有s&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;绑定事件的方式&quot;&gt;2、绑定事件的方式&lt;/h3&gt;
&lt;p&gt;方式一：直接绑定匿名函数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;box1&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; div1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;box1&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//绑定事件的第一种方式&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;div1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是弹出的内容&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式二：先单独定义函数，再绑定&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;box1&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; div1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;box1&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//绑定事件的第二种方式&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;div1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; fn&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//注意，这里是fn，不是fn()。fn()指的是返回值。&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//单独定义函数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是弹出的内容&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意上方代码的注释。&lt;strong&gt;绑定的时候，是写fn，不是写fn()&lt;/strong&gt;。fn代表的是整个函数，而fn()代表的是返回值。&lt;/p&gt;
&lt;p&gt;方式三：行内绑定&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!--行内绑定--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;box1&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; onclick=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;fn()&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fn&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;我是弹出的内容&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意第一行代码，绑定时，是写的&lt;code&gt;&quot;fn()&quot;&lt;/code&gt;，不是写的&lt;code&gt;&quot;fn&quot;&lt;/code&gt;。因为绑定的这段代码不是写在js代码里的，而是被识别成了&lt;strong&gt;字符串&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;事件驱动程序&quot;&gt;3、事件驱动程序&lt;/h3&gt;
&lt;p&gt;我们在上面是拿alert举例，不仅如此，我们还可以操作标签的属性和样式。举例如下：&lt;/p&gt;
&lt;p&gt;点击鼠标时，原本粉色的div变大了，背景变红：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;#box1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;100px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; pink&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;cursor:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;pointer&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;box1&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; div1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;box1&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//点击鼠标时，原本粉色的div变大了，背景变红了&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;div1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;div1&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;200px&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//属性值要写引号&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;div1&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;200px&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;div1&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;style&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;backgroundColor&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;red&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//属性名是backgroundColor，不是background-Color&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上方代码的注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在js里写属性值时，要用引号&lt;/li&gt;
&lt;li&gt;在js里写属性名时，是&lt;code&gt;backgroundColor&lt;/code&gt;，不是CSS里面的&lt;code&gt;background-Color&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_1720.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;onload事件&quot;&gt;onload事件&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;onload事件比较特殊，这里单独讲一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;当页面加载（文本和图片）完毕的时候，触发onload事件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;smyhvae&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//等页面加载完毕时，打印字符串&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有一点我们要知道：&lt;strong&gt;js的加载是和html同步加载的&lt;/strong&gt;。因此，如果使用元素在定义元素之前，容易报错。这个时候，onload事件就能派上用场了，我们可以把使用元素的代码放在onload里，就能保证这段代码是最后执行。&lt;/p&gt;
&lt;p&gt;建议是：整个页面上所有元素加载完毕在执行js内容。所以，window.onload可以预防使用标签在定义标签之前。&lt;/p&gt;
&lt;h3 id=&quot;事件举例京东顶部广告栏&quot;&gt;事件举例：京东顶部广告栏&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180122_1020.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如上面这张图，当鼠标点击右上角的&lt;code&gt;X&lt;/code&gt;时，关掉整个广告栏，这就要用到事件。&lt;/p&gt;
&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
        * &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;padding:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.top-banner&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; pink&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;80px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.w&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1210px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;10px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        img &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1210px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;80px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        a &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;absolute&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;right:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#fff&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;background-color:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#000&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;text-decoration:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;width:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;20px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;height:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;20px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;font:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;700&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;14px&lt;/span&gt;/&lt;span class=&quot;dt&quot;&gt;20px&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;simsum&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;text-align:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;fl&quot;&gt;.hide&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;display:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;!important;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;top-banner&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;topBanner&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;w&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; alt=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;closeBanner&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;×&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//需求：点击案例，隐藏盒子。&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//思路：点击a链接，让top-banner这个盒子隐藏起来（加隐藏类名）。&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;//1.获取事件源和相关元素&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; closeBanner &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;closeBanner&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; topBanner &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;topBanner&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//2.绑定事件&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;closeBanner&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//3.书写事件驱动程序&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//类控制&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//        topBanner.className += &quot; hide&quot;; //保留原类名，添加新类名&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;topBanner&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;className&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;hide&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//替换旧类名&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//        topBanner.style.display = &quot;none&quot;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;/body&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意最后一行代码，这种方式会替换旧类名，意思是，不管之前的类名叫什么，都会被修改。&lt;/p&gt;
&lt;h3 id=&quot;事件举例&quot;&gt;事件举例：&lt;/h3&gt;
&lt;p&gt;要求实现效果：当鼠标悬停在img上时，更换为另外一张图片；鼠标离开时，还原为本来的图片。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//window.onload页面加载完毕以后再执行此代码&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onload&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//需求：鼠标放到img上，更换为另一张图片，也就是修改路径（src的值）。&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//步骤：&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//1.获取事件源&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//2.绑定事件&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//3.书写事件驱动程序&lt;/span&gt;

            &lt;span class=&quot;co&quot;&gt;//1.获取事件源&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; img &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;box&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//2.绑定事件(悬停事件：鼠标进入到事件源中立即出发事件)&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;img&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onmouseover&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;//3.书写事件驱动程序(修改src)&lt;/span&gt;
                &lt;span class=&quot;va&quot;&gt;img&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;image/jd2.png&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//                this.src = &quot;image/jd2.png&quot;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;co&quot;&gt;//1.获取事件源&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; img &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;box&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//2.绑定事件(悬停事件：鼠标进入到事件源中立即出发事件)&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;img&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onmouseout&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;//3.书写事件驱动程序(修改src)&lt;/span&gt;
                &lt;span class=&quot;va&quot;&gt;img&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;image/jd1.png&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;/head&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;body&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;img id&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;box&quot;&lt;/span&gt; src&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;image/jd1.png&quot;&lt;/span&gt; style&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;cursor: pointer;border: 1px solid #ccc;&quot;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ss&quot;&gt;&amp;lt;/body&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;dom的介绍&quot;&gt;DOM的介绍&lt;/h2&gt;
&lt;h3 id=&quot;什么是dom&quot;&gt;什么是DOM&lt;/h3&gt;
&lt;p&gt;DOM：文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。&lt;/p&gt;
&lt;p&gt;DOM就是由节点组成的。&lt;/p&gt;
&lt;h3 id=&quot;解析过程&quot;&gt;解析过程&lt;/h3&gt;
&lt;p&gt;HTML加载完毕，渲染引擎会在内存中把HTML文档，生成一个DOM树，getElementById是获取内中DOM上的元素节点。然后操作的时候修改的是该元素的&lt;strong&gt;属性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;dom树一切都是节点&quot;&gt;DOM树（一切都是节点）&lt;/h3&gt;
&lt;p&gt;DOM的数据结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_2105.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图可知，&lt;strong&gt;在HTML当中，一切都是节点&lt;/strong&gt;：（非常重要）&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;元素节点&lt;/strong&gt;：HMTL标签。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;文本节点&lt;/strong&gt;：标签中的文字（比如标签之间的空格、换行）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;属性节点&lt;/strong&gt;：：标签的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;整个html文档就是一个文档节点。所有的节点都是Object。&lt;/p&gt;
&lt;h3 id=&quot;dom可以做什么&quot;&gt;DOM可以做什么&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;找对象（元素节点）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置元素的属性值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置元素的样式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;动态创建和删除元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事件的触发响应：事件源、事件、事件的驱动程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;dom节点的获取&quot;&gt;DOM节点的获取&lt;/h2&gt;
&lt;p&gt;DOM节点的获取方式其实就是&lt;strong&gt;获取事件源的方式&lt;/strong&gt;，在上一段已经讲到。这里再重复一下。&lt;/p&gt;
&lt;p&gt;操作元素节点，必须首先找到该节点。有三种方式可以获取DOM节点：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; div1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementById&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;box1&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;//方式一：通过id获取单个标签&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;div1&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;co&quot;&gt;//方式二：通过 标签名 获得 标签数组，所以有s&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByClassName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hehe&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//方式三：通过 类名 获得 标签数组，所以有s&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;既然方式二、方式三获取的是标签数组，那么习惯性是&lt;strong&gt;先遍历之后再使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;特殊情况：数组中的值只有1个。即便如此，这一个值也是包在数组里的。这个值的获取方式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;div1&quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;//取数组中的第一个元素&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByClassName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;hehe&quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//取数组中的第一个元素&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;dom访问关系的获取&quot;&gt;DOM访问关系的获取&lt;/h2&gt;
&lt;p&gt;DOM的节点并不是孤立的，因此可以通过DOM节点之间的相对关系对它们进行访问。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_2140.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;节点的访问关系，是以&lt;strong&gt;属性&lt;/strong&gt;的方式存在的。&lt;/p&gt;
&lt;p&gt;JS中的&lt;strong&gt;父子兄&lt;/strong&gt;访问关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180126_2145.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们要重点知道&lt;strong&gt;parentNode&lt;/strong&gt;和&lt;strong&gt;children&lt;/strong&gt;这两个属性的用法。下面分别介绍。&lt;/p&gt;
&lt;h3 id=&quot;获取父节点&quot;&gt;获取父节点&lt;/h3&gt;
&lt;p&gt;调用者就是节点。一个节点只有一个父节点，调用方式就是&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    节点.&lt;span class=&quot;at&quot;&gt;parentNode&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;获取兄弟节点&quot;&gt;获取兄弟节点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、下一个节点 | 下一个元素节点&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Sibling的中文是&lt;strong&gt;兄弟&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（1）nextSibling：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;火狐、谷歌、IE9+版本：都指的是下一个节点（包括标签、空文档和换行节点）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IE678版本：指下一个元素节点（标签）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（2）nextElementSibling：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;火狐、谷歌、IE9+版本：都指的是下一个元素节点（标签）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：为了获取下一个&lt;strong&gt;元素节点&lt;/strong&gt;，我们可以这样做：在IE678中用nextSibling，在火狐谷歌IE9+以后用nextElementSibling，于是，综合这两个属性，可以这样写：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    下一个兄弟节点 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 节点.&lt;span class=&quot;at&quot;&gt;nextElementSibling&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; 节点.&lt;span class=&quot;at&quot;&gt;nextSibling&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、前一个节点 | 前一个元素节点&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;previous的中文是：前一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（1）previousSibling：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;火狐、谷歌、IE9+版本：都指的是前一个节点（包括标签、空文档和换行节点）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IE678版本：指前一个元素节点（标签）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（2）previousElementSibling：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;火狐、谷歌、IE9+版本：都指的是前一个元素节点（标签）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：为了获取前一个&lt;strong&gt;元素节点&lt;/strong&gt;，我们可以这样做：在IE678中用previousSibling，在火狐谷歌IE9+以后用previousElementSibling，于是，综合这两个属性，可以这样写：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    前一个兄弟节点 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 节点.&lt;span class=&quot;at&quot;&gt;previousElementSibling&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; 节点.&lt;span class=&quot;at&quot;&gt;previousSibling&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、补充：&lt;/strong&gt;获得任意一个兄弟节点：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    节点自己.&lt;span class=&quot;va&quot;&gt;parentNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;children&lt;/span&gt;[index]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//随意得到兄弟节点&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;获取单个的子节点&quot;&gt;获取单个的子节点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1、第一个子节点 | 第一个子元素节点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;（1）firstChild：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;火狐、谷歌、IE9+版本：都指的是第一个子节点（包括标签、空文档和换行节点）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IE678版本：指第一个子元素节点（标签）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（2）firstElementChild：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;火狐、谷歌、IE9+版本：都指的是第一个子元素节点（标签）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：为了获取第一个&lt;strong&gt;子元素节点&lt;/strong&gt;，我们可以这样做：在IE678中用firstChild，在火狐谷歌IE9+以后用firstElementChild，于是，综合这两个属性，可以这样写：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    第一个子元素节点 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 节点.&lt;span class=&quot;at&quot;&gt;firstElementChild&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; 节点.&lt;span class=&quot;at&quot;&gt;firstChild&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、最后一个子节点 | 最后一个子元素节点&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;（1）lastChild：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;火狐、谷歌、IE9+版本：都指的是最后一个子节点（包括标签、空文档和换行节点）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IE678版本：指最后一个子元素节点（标签）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（2）lastElementChild：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;火狐、谷歌、IE9+版本：都指的是最后一个子元素节点（标签）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：为了获取最后一个&lt;strong&gt;子元素节点&lt;/strong&gt;，我们可以这样做：在IE678中用lastChild，在火狐谷歌IE9+以后用lastElementChild，于是，综合这两个属性，可以这样写：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    最后一个子元素节点 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 节点.&lt;span class=&quot;at&quot;&gt;lastElementChild&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; 节点.&lt;span class=&quot;at&quot;&gt;lastChild&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;获取所有的子节点&quot;&gt;获取所有的子节点&lt;/h3&gt;
&lt;p&gt;（1）&lt;strong&gt;childNodes&lt;/strong&gt;：标准属性。返回的是指定元素的&lt;strong&gt;子节点&lt;/strong&gt;的集合（包括元素节点、所有属性、文本节点）。是W3C的亲儿子。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;火狐 谷歌等高本版会把换行也看做是子节点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    子节点数组 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 父节点.&lt;span class=&quot;at&quot;&gt;childNodes&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//获取所有节点。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）&lt;strong&gt;children&lt;/strong&gt;：非标准属性。返回的是指定元素的&lt;strong&gt;子元素节点&lt;/strong&gt;的集合。【重要】&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它只返回HTML节点，甚至不返回文本节点。&lt;/li&gt;
&lt;li&gt;在IE6/7/8中包含注释节点（在IE678中，注释节点不要写在里面）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然不是标准的DOM属性，但它和innerHTML方法一样，得到了几乎所有浏览器的支持。&lt;/p&gt;
&lt;p&gt;用法：（&lt;strong&gt;用的最多&lt;/strong&gt;）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    子节点数组 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 父节点.&lt;span class=&quot;at&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//获取所有节点。用的最多。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;nodetype&quot;&gt;nodeType&lt;/h3&gt;
&lt;p&gt;这里讲一下nodeType。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;nodeType == 1 表示的是元素节点&lt;/strong&gt;（标签） 。记住：元素就是标签。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;nodeType == 2 表示是属性节点 了解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;nodeType == 3 是文本节点 了解&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;dom节点操作重要&quot;&gt;DOM节点操作（重要）&lt;/h2&gt;
&lt;p&gt;上一段的内容：节点的&lt;strong&gt;访问关系&lt;/strong&gt;都是&lt;strong&gt;属性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本段的内容：节点的&lt;strong&gt;操作&lt;/strong&gt;都是&lt;strong&gt;函数&lt;/strong&gt;（方法）。&lt;/p&gt;
&lt;h3 id=&quot;创建节点&quot;&gt;创建节点&lt;/h3&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    新的标签(元素节点) &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;标签名&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如，如果我们想创建一个li标签，或者是创建一个不存在的adbc标签，可以这样做：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;li&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//创建一个li标签&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createElement&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;adbc&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//创建一个不存在的标签&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a1)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(a2)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; a1)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; a2)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180127_1135.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;插入节点&quot;&gt;插入节点&lt;/h3&gt;
&lt;p&gt;插入节点有两种方式，它们的含义是不同的。&lt;/p&gt;
&lt;p&gt;方式1：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    父节点.&lt;span class=&quot;at&quot;&gt;appendChild&lt;/span&gt;(新的子节点)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释：父节点的最后插入一个新的子节点。&lt;/p&gt;
&lt;p&gt;方式2：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    父节点.&lt;span class=&quot;at&quot;&gt;insertBefore&lt;/span&gt;(新的子节点&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;作为参考的子节点)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在参考节点前插入一个新的节点。&lt;/li&gt;
&lt;li&gt;如果参考节点为null，那么他将在父节点最后插入一个子节点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180127_1257.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，li标签确实被插入到了box1标签的里面，和box2并列了。&lt;/p&gt;
&lt;p&gt;方式2的举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180127_1302.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，b1标签被插入到了box1标签的里面，和a1标签并列，在a1标签的前面。&lt;/p&gt;
&lt;h3 id=&quot;删除节点&quot;&gt;删除节点&lt;/h3&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    父节点.&lt;span class=&quot;at&quot;&gt;removeChild&lt;/span&gt;(子节点)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释：&lt;strong&gt;用父节点删除子节点&lt;/strong&gt;。必须要指定是删除哪个子节点。&lt;/p&gt;
&lt;p&gt;如果我想删除自己这个节点，可以这么做：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;node1&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;parentNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;removeChild&lt;/span&gt;(node1)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;复制节点克隆节点&quot;&gt;复制节点（克隆节点）&lt;/h3&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    要复制的节点.&lt;span class=&quot;at&quot;&gt;cloneNode&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;co&quot;&gt;//括号里不带参数和带参数false，效果是一样的。&lt;/span&gt;

    要复制的节点.&lt;span class=&quot;at&quot;&gt;cloneNode&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;括号里带不带参数，效果是不同的。解释如下：&lt;/p&gt;
&lt;h2 id=&quot;设置节点的属性&quot;&gt;设置节点的属性&lt;/h2&gt;
&lt;p&gt;我们可以获取节点的属性值、设置节点的属性值、删除节点的属性。&lt;/p&gt;
&lt;p&gt;我们就统一拿下面这个标签来举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;images/1.jpg&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;image-box&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; title=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;美女图片&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; alt=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;地铁一瞥&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;a1&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面分别介绍。&lt;/p&gt;
&lt;h3 id=&quot;获取节点的属性值&quot;&gt;1、获取节点的属性值&lt;/h3&gt;
&lt;p&gt;方式1：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    元素节点.属性&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    元素节点[属性]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例：（获取节点的属性值）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;img&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; src=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;images/1.jpg&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;image-box&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; title=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;美女图片&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; alt=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;地铁一瞥&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;a1&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; myNode &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;img&quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;src&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;className&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;//注意，是className，不是class&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;title&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;------------&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(myNode[&lt;span class=&quot;st&quot;&gt;&quot;src&quot;&lt;/span&gt;])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(myNode[&lt;span class=&quot;st&quot;&gt;&quot;className&quot;&lt;/span&gt;])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//注意，是className，不是class&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(myNode[&lt;span class=&quot;st&quot;&gt;&quot;title&quot;&lt;/span&gt;])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;/body&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上方代码中的img标签，有各种属性，我们可以逐一获取，打印结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180127_1340.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方式2：（推荐）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    元素节点.&lt;span class=&quot;at&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;属性名称&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;src&quot;&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;class&quot;&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//注意是class，不是className&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;title&quot;&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180127_1345.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方式1和方式2的区别在于：前者是直接操作标签，后者是把标签作为DOM节点。推荐方式2。&lt;/p&gt;
&lt;h3 id=&quot;设置节点的属性值&quot;&gt;2、设置节点的属性值&lt;/h3&gt;
&lt;p&gt;方式1举例：（设置节点的属性值）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;images/2.jpg&quot;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//修改src的属性值&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;className&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;image2-box&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//修改class的name&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式2：（推荐）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    元素节点.&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(属性名&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; 新的属性值)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式2举例：（设置节点的属性值）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;images/3.jpg&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;class&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;image3-box&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;你好&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;删除节点的属性&quot;&gt;3、删除节点的属性&lt;/h3&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    元素节点.&lt;span class=&quot;at&quot;&gt;removeAttribute&lt;/span&gt;(属性名)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例：（删除节点的属性）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;removeAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;class&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;myNode&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;removeAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;我的公众号&quot;&gt;我的公众号&lt;/h2&gt;
&lt;p&gt;想学习&lt;span&gt;&lt;strong&gt;代码之外的软技能&lt;/strong&gt;&lt;/span&gt;？不妨关注我的微信公众号：&lt;strong&gt;生命团队&lt;/strong&gt;（id：&lt;code&gt;vitateam&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jan 2018 06:35:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8366012.html</dc:identifier>
</item>
<item>
<title>MySQL事务隔离级别的实现原理 - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/8365921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/8365921.html</guid>
<description>&lt;p&gt;&lt;span&gt;在MySQL的众多存储引擎中，只有InnoDB支持事务，所有这里说的事务隔离级别指的是InnoDB下的事务隔离级别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读未提交：一个事务可以读取到另一个事务未提交的修改。这会带来脏读、幻读、不可重复读问题。（基本没用）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读已提交：一个事务只能读取另一个事务已经提交的修改。其避免了脏读，但仍然存在不可重复读和幻读问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可重复读：同一个事务中多次读取相同的数据返回的结果是一样的。其避免了脏读和不可重复读问题，但幻读依然存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;串行化：事务串行执行。避免了以上所有问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上是SQL-92标准中定义的四种隔离级别。在MySQL中，默认的隔离级别是REPEATABLE-READ（可重复读），并且解决了幻读问题。简单的来说，mysql的默认隔离级别解决了脏读、幻读、不可重复读问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不可重复读重点在于update和delete，而幻读的重点在于insert。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里，我们只讨论可重复读。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;MVVC&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201801/874963-20180127111840881-1389813805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;译注：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　MVVC的全称是“多版本并发控制”。这项技术使得InnoDB的事务隔离级别下执行一致性读操作有了保证，换言之，就是为了查询一些正在被另一个事务更新的行，并且可以看到它们被更新之前的值。这是一个可以用来增强并发性的强大的技术，因为这样的一来的话查询就不用等待另一个事务释放锁。这项技术在数据库领域并不是普遍使用的。一些其它的数据库产品，以及mysql其它的存储引擎并不支持它。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;说明&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;网上看到大量的文章讲到MVVC都是说给没一行增加两个隐藏的字段分别表示行的创建时间以及过期时间，它们存储的并不是时间，而是事务版本号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上，这种说法并不准确，严格的来讲，InnoDB会给数据库中的每一行增加三个字段，它们分别是DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，为了理解的方便，我们可以这样去理解，索引接下来的讲解中也还是用这两个字段的方式去理解。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;增删查改&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在InnoDB中，给每行增加两个隐藏字段来实现MVVC，一个用来记录数据行的创建时间，另一个用来记录行的过期时间（删除时间）。在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是乎，默认的隔离级别（REPEATABLE READ）下，增删查改变成了这样：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;SELECT&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;读取创建版本小于或等于当前事务版本号，并且删除版本为空或大于当前事务版本号的记录。这样可以保证在读取之前记录是存在的。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;INSERT&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;将当前事务的版本号保存至行的创建版本号&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;UPDATE&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;新插入一行，并以当前事务的版本号作为新行的创建版本号，同时将原记录行的删除版本号设置为当前事务版本号&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;DELETE&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;将当前事务的版本号保存至行的删除版本号&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;快照读和当前读&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;快照读：读取的是快照版本，也就是历史版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前读：读取的是最新版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;普通的SELECT就是快照读，而UPDATE、DELETE、INSERT、SELECT ...  LOCK IN SHARE MODE、SELECT ... FOR UPDATE是当前读。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;一致性非锁定读和锁定读&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;锁定读&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　在一个事务中，标准的SELECT语句是不会加锁，但是有两种情况例外。SELECT ... LOCK IN SHARE MODE 和 SELECT ... FOR UPDATE。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SELECT ... LOCK IN SHARE MODE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　给记录假设共享锁，这样一来的话，其它事务只能读不能修改，直到当前事务提交&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SELECT ... FOR UPDATE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　给索引记录加锁，这种情况下跟UPDATE的加锁情况是一样的&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;一致性非锁定读&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a class=&quot;link&quot; title=&quot;consistent read&quot; href=&quot;https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read&quot;&gt;consistent read&lt;/a&gt; （一致性读），InnoDB用多版本来提供查询数据库在某个时间点的快照。如果隔离级别是REPEATABLE READ，那么在同一个事务中的所有一致性读都读的是事务中第一个这样的读读到的快照；如果是READ COMMITTED，那么一个事务中的每一个一致性读都会读到它自己刷新的快照版本。&lt;span&gt;Consistent read（一致性读）是READ COMMITTED和REPEATABLE READ隔离级别下普通SELECT语句默认的模式&lt;/span&gt;。一致性读不会给它所访问的表加任何形式的锁，因此其它事务可以同时并发的修改它们。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;悲观锁和乐观锁&lt;/h2&gt;
&lt;p&gt;悲观锁，正如它的名字那样，数据库总是认为别人会去修改它所要操作的数据，因此在数据库处理过程中将数据加锁。其实现依靠数据库底层。&lt;/p&gt;
&lt;p&gt;乐观锁，如它的名字那样，总是认为别人不会去修改，只有在提交更新的时候去检查数据的状态。通常是给数据增加一个字段来标识数据的版本。&lt;/p&gt;

&lt;h2&gt;锁&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有这样三种锁我们需要了解&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Record Locks（记录锁）：在索引记录上加锁。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Gap Locks（间隙锁）：在索引记录之间加锁，或者在第一个索引记录之前加锁，或者在最后一个索引记录之后加锁。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Next-Key Locks：在索引记录上加锁，并且在索引记录之前的间隙加锁。它相当于是Record Locks与Gap Locks的一个结合。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;假设一个索引包含以下几个值：10,11,13,20。那么这个索引的next-key锁将会覆盖以下区间：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(negative infinity, 10]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(10, 11]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(11, 13]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(13, 20]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(20, positive infinity)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;了解了以上概念之后，接下来具体就简单分析下REPEATABLE READ隔离级别是如何实现的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;之所以说是理论分析，是因为要是实际操作证明的话我也不知道怎么去证明，毕竟作者水平实在有限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，这并不意味着我在此胡说八道，有官方文档为证。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201801/874963-20180127125455475-243270916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这段话的大致意思是，在默认的隔离级别中，普通的SELECT用的是一致性读不加锁。而对于锁定读、UPDATE和DELETE，则需要加锁，至于加什么锁视情况而定。如果你对一个唯一索引使用了唯一的检索条件，那么只需锁定索引记录即可；如果你没有使用唯一索引作为检索条件，或者用到了索引范围扫描，那么将会使用间隙锁或者next-key锁以此来阻塞其它会话向这个范围内的间隙插入数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者曾经有一个误区，认为按照前面说MVVC下的增删查改的行为就不会出现任何问题，也不会出现不可重复读和幻读。但其实是大错特错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个很简单的例子，假设事务A更新表中id=1的记录，而事务B也更新这条记录，并且B先提交，如果按照前面MVVC说的，事务A读取id=1的快照版本，那么它看不到B所提交的修改，此时如果直接更新的话就会覆盖B之前的修改，这就不对了，可能B和A修改的不是一个字段，但是这样一来，B的修改就丢失了，这是不允许的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，在修改的时候一定不是快照读，而是当前读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且，前面也讲过只有普通的SELECT才是快照读，其它诸如UPDATE、删除都是当前读。修改的时候加锁这是必然的，同时为了防止幻读的出现还需要加间隙锁。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一致性读保证了可用重复读&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;间隙锁防止了幻读&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;回想一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、利用MVVC实现一致性非锁定读，这就有保证在同一个事务中多次读取相同的数据返回的结果是一样的，解决了不可重复读的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、利用Gap Locks和Next-Key可以阻止其它事务在锁定区间内插入数据，因此解决了幻读问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综上所述，默认隔离级别的实现依赖于MVVC和锁，再具体一点是一致性读和锁。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201801/874963-20180127135314397-2034948560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201801/874963-20180127135343990-1881737935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201801/874963-20180127135402490-341685126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201801/874963-20180127135409772-483747170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201801/874963-20180127135605662-884296452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201801/874963-20180127135624569-919659585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面四幅截图对比，可以看到由于id是主键，用id作为检索条件时只锁定那一个索引记录。接下来，看索引范围的例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201801/874963-20180127135703178-1116699474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/874963/201801/874963-20180127135712006-1165497465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这两幅截图，可以看出，由于没有使用唯一索引作为检索条件，导致不光锁定了索引记录，还锁定了索引之间的间隙，应该是是使用了next-key锁。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考 https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jan 2018 06:03:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/8365921.html</dc:identifier>
</item>
<item>
<title>因为我想在博客园长呆，所以给博客园提一些改进建议 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/8365709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/8365709.html</guid>
<description>&lt;p&gt;    一晃眼我来博客园已经有4个月了，我的排名从9万多上升到9千多，也有不少朋友关注了我，其实对我帮助更大的是博客园的管理团队，他们对我的文章提出了很多很好的改进建议，从而让我的文章水平有了很大的提升。&lt;/p&gt;
&lt;p&gt;    这里我从用户的角度，给博客园提些发展方面的建议。&lt;/p&gt;

&lt;p&gt;    建议一：能指定文章的发表时间。&lt;/p&gt;
&lt;p&gt;    比如我周六晚上写好一篇博文，但周六晚上的在线用户数并不多，如果我立即发表，可能点击量就会少，我就期望是周一早上发。相信其它朋友也有类似的感受。目前我的做法是，文章存草稿，到周一早上再上线点击发表，同时设置发表到首页。如果能增加这样个功能，能设置发表时间，到时候自动发表，就能省去不少麻烦。&lt;/p&gt;

&lt;p&gt;    建议二，增强搜索的功能。&lt;/p&gt;
&lt;p&gt;    1 去掉google搜索&lt;/p&gt;
&lt;p&gt;    2 增加自动补全功能，比如我输入spring,可以根据热搜度提示spring cloud和spring boot等。&lt;/p&gt;
&lt;p&gt;    3 每个文章有标签的，这也相当于关键字，搜索时，不仅可以根据全文搜索，还可以返回根据标签匹配的搜索结果。&lt;/p&gt;
&lt;p&gt;    4 在显著位置，增加排名前十的热搜关键字。&lt;/p&gt;

&lt;p&gt;     建议三，去掉些首页的点击量少的tab页签，比如“我评”和“我赞”，这些功能可以做到个人管理页面。&lt;/p&gt;

&lt;p&gt;     如果说上述建议是针对功能方面的，那么下面的建议就是针对流量方面的。我们知道，网站里有效流量最重要，和有效流量相关联的就是活跃的用户数。我观察了一阵，能发表一定质量（能留在首页的）博文，也就是一些老面孔，换句话说，可能访问者很多，但能发表文章的活跃用户数可以再提高.&lt;/p&gt;
&lt;p&gt;    这方面我给出如下的建议。&lt;/p&gt;
&lt;p&gt;    1 可以借鉴一些小说网站，设置个勤快奖，比如一个月能发表文章的总点击数在2万以上的用户是比较勤快的，可以给这些用户适当奖励。当然标准可以定，奖励未必要钱，可以是广告位，比如可以给这些用户在首页显著广告位置放n小时的文章。&lt;/p&gt;
&lt;p&gt;    这样一定会有作弊，对此博客园可以做些防作弊措施，这样就能显著提升点击量，点击来了，什么都好说。&lt;/p&gt;
&lt;p&gt;    2 我看博客园里有很多功能，比如小组，博问，班级等，但我的感觉是这些类别的点击量远不如博文的点击量多，对此博客园管理方可以做些适当引导，比如在首页的显著位置放些针对这些功能的说明，比如让人一看就知道该怎么参与 ，目前博文管理得很好，而且博文给博客园带来的流量也最多，所以可以借鉴这方面的经验，可以把管理博文的方法用在管理班级等类目上。&lt;/p&gt;
&lt;p&gt;    3 多举办些活动，比如给个征文主题让人发表文章，也可以找个赞助商提供些奖品，或者也可以多举办些线下活动，总之一句话，多鼓励大家发文章。或者可以学一些小说网站走出版路线，鼓励出书。&lt;/p&gt;
&lt;p&gt;    4 加强些站内点击的粘合度，比如一篇文章下方再多提供些同类点击数比较高的文章，这样我读了这篇文章后还能看其他的文章。又如，在博客园首页和具体的博文页里可以多放些推荐文章和其它热门内容，这样做的效果是，当用户进入一个页面时，能看到其它感兴趣的内容，这样用户的停留时间就很长，就不容易走了。我这只是举个例子，具体做法有很多，这方面可以借鉴在线电商网站的做法。&lt;/p&gt;

&lt;p&gt;    我想象中的博客园的远景。&lt;/p&gt;
&lt;p&gt;    1 技术分类齐全，而且每个类目里都有成系列的文章，这样比如我要学Spring cloud，在博客园里我就能学好，就不用到处去搜了，所谓提供一站式服务。&lt;/p&gt;
&lt;p&gt;    2 活跃用户数多，而且大牛也多，每天发的文章不仅数量多，而且质量好，这样在博客园里发文，不仅能扬名，更有实惠，比如得到奖品，或者干脆能被猎头挖走。这样一来，博客园，读者和发文者就做到三赢了。&lt;/p&gt;
&lt;p&gt;    3 用户进入博客园后，就不愿意走了，因为看了一篇文章后，还能看到其它相关的，这样博客园的点击数能大大提升。&lt;/p&gt;
&lt;p&gt;    4 最后当然是博客园得到的好处更多，由于点击量高了，不仅广告收益多，而且能吸引猎头出版商培训机构等等各路人马过来，这样平台的影响力就更大了。&lt;/p&gt;


</description>
<pubDate>Sat, 27 Jan 2018 05:58:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/8365709.html</dc:identifier>
</item>
<item>
<title>高并发情况利用锁机制处理缓存未命中 - Gonjian</title>
<link>http://www.cnblogs.com/gonjan-blog/p/8360528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gonjan-blog/p/8360528.html</guid>
<description>&lt;p&gt;    关于缓存的使用，个人经验还是比较欠缺，对于缓存在应用系统中的使用也只是前几个月在公司实习的时候，简单的使用过，且使用的都是人家把框架搭建好的，至于缓存在并发情况下会产生的一系列问题都已经被框架处理好了，我所做的只是set和get，至于使用时缓存在并发情况下到底会出现什么样的问题，该如何去解决和避免这些问题，没有去深究。&lt;/p&gt;
&lt;p&gt;　　秉着“学而时习之”的态度（T_T自己太懒，厚着脸皮），这两天在鼓捣redis，至于redis的基本使用还是挺简单的，今天要说的是我在这个过程中看到网上博客一直提的关于缓存使用的各种问题，看到好多前辈在高并发下使用缓存都踩了不少大坑，总结他人的经验也是给自己以后警醒。今天这篇博客只讲我对一个问题的理解与思路的想法，并不会去罗列缓存在各种场景下各种解决方案以及各种解决方案之间的优劣，我没有实际解决缓存问题的经验，不敢妄自下结论。以下是个人学习过程的记录，希望各路大侠交流学习。&lt;/p&gt;
&lt;p&gt;场景描述：高并发情况缓存未命中从而访问数据库造成压力陡增崩溃&lt;/p&gt;
&lt;p&gt;最终解决方案：java中利用读写锁处理并发并发情形&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1085268/201801/1085268-20180126144733303-1664120701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;业务场景假设：现有一张商品库存表，业务请求需要根据商品id查询相应商品的库存情况，服务端收到请求返回对应商品的库存。&lt;/p&gt;

&lt;h2&gt;一、少量请求下缓存的简单使用&lt;/h2&gt;
&lt;p&gt;　　首先，我们知道使用缓存的基本流程，首先根据key查询缓存，查询成功直接返回，查询失败(缓存未命中)，则查询数据库得到结果写入缓存再返回。根据前面的场景假设和缓存使用逻辑，请看下面的一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 根据商品id(也是主键)查询商品库存记录
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GoodsStock selectByPrimaryKey(Integer id) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        GoodsStock result;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存中查找&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         String goodsStockJsonStr =&lt;span&gt; RedisCache.get(id);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存中查找成功&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!StringUtils.isEmpty(goodsStockJsonStr) &amp;amp;&amp;amp; !&quot;null&quot;&lt;span&gt;.equals(goodsStockJsonStr)) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             logger.info(&quot;=====query from cache=====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; JSONObject.parseObject(goodsStockJsonStr,GoodsStock.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有命中缓存，数据库中查找，并将结果写入缓存&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         logger.info(&quot;=====query from DB=====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         result =&lt;span&gt; goodsStockMapper.selectByPrimaryKey(id);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询结果写入缓存&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        RedisCache.set(id, JSONArray.toJSONString(result));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　以上代码运行结果，第一次运行缓存中参照失败是从数据库中查找，后面每次运行查找相同的id，都是从缓存中得到（这里咱先不讨论缓存的失效时间之类），只查询了数据库一次，由于每次运行都是单个请求，这段代码没有任何问题，现在在多线程下测试这个查询服务，看看会出现什么情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 10个线程并发调用服务
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testMultiThreadQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryTask()).start();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             countDownLatch.countDown(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程达到10个时，10个线程同时执行查询&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Thread.sleep(5000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; QueryTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                countDownLatch.await();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             GoodsStock goodsStock =&lt;span&gt; goodsStockService.selectByPrimaryKey(GOODS_ID);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行前我们先将缓存清空，让服务请求缓存是出现缓存未命中的情况，正常情况是只要有一个请求查询出现缓存未命中，那么就回去查询数据库，查询成功后将结果写入缓存，这样后续的请求再查询统一记录时，就应该直接从缓存返回，而不再去查询数据库。我们来看看运行结果，运行结果也在预料之中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1918 [Thread-12] INFO  g.s.impl.GoodsStockServiceImpl - =====query from DB===== 
1918 [Thread-5] INFO  g.s.impl.GoodsStockServiceImpl - =====query from DB===== 
1918 [Thread-13] INFO  g.s.impl.GoodsStockServiceImpl - =====query from DB===== 
1918 [Thread-8] INFO  g.s.impl.GoodsStockServiceImpl - =====query from DB===== 
1918 [Thread-7] INFO  g.s.impl.GoodsStockServiceImpl - =====query from DB===== 
1918 [Thread-9] INFO  g.s.impl.GoodsStockServiceImpl - =====query from DB===== 
1918 [Thread-6] INFO  g.s.impl.GoodsStockServiceImpl - =====query from DB===== 
1918 [Thread-4] INFO  g.s.impl.GoodsStockServiceImpl - =====query from DB===== 
1918 [Thread-10] INFO  g.s.impl.GoodsStockServiceImpl - =====query from DB===== 
1918 [Thread-11] INFO  g.s.impl.GoodsStockServiceImpl - =====query from DB===== 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到，10个同时到达的请求基本上都是去查询的数据库，这点很好理解，因为10个请求同时到达，同时查询缓存，同时发现缓存没命中，同时去查数据库。在这种情况下，本来后面的请求应该读取缓存从而达到减轻数据库压力的效果，然而在前面这么多“同时”的情形下，缓存失去了它原有的效果。如果这里不只10个请求同时到达，而是在类似秒杀场景下同时有成千上万个请求到达，那么数据库肯定不能承受之重直至崩溃。这种场景就很类似于&lt;span&gt;高并发情况下的缓存击穿&lt;span&gt;(缓存击穿是指在高并发情况下，大量请求查询一个并不存在的数据，由于数据不存在，肯定会出现缓存不命中，然后去查询数据库，然后导致数据库崩溃。) &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;既然我们清楚得知道问题出现在同时查询数据库这里，那么很容易就想到利用锁机制，只让一个请求去查询数据库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二、高并发情况下缓存使用&lt;/h2&gt;
&lt;p&gt;　　利用java提供的锁机制，让所有请求到达查询服务时，若缓存没有命中，就去竞争一把锁，得到锁的请求才去查询数据库，并将查询结果写回缓存，后面的请求就直接从缓存中读取，并发情况下改进代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 根据商品id(也是主键)查询商品库存记录
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GoodsStock selectByPrimaryKey(Integer id) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        GoodsStock result;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存中查找&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         String goodsStockJsonStr =&lt;span&gt; RedisCache.get(id);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存中查找成功&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!StringUtils.isEmpty(goodsStockJsonStr) &amp;amp;&amp;amp; !&quot;null&quot;&lt;span&gt;.equals(goodsStockJsonStr)) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             logger.info(&quot;=====query from cache=====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; JSONObject.parseObject(goodsStockJsonStr,GoodsStock.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有命中缓存，这里加锁去数据库中查找，并将结果写入缓存
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;后续获得锁的线程会直接从缓存中读取，而不再是访问数据库&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             goodsStockJsonStr =&lt;span&gt; RedisCache.get(id);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(!StringUtils.isEmpty(goodsStockJsonStr) &amp;amp;&amp;amp; !&quot;null&quot;&lt;span&gt;.equals(goodsStockJsonStr)) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 logger.info(&quot;=====query from cache=====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; JSONObject.parseObject(goodsStockJsonStr,GoodsStock.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             logger.info(&quot;=====query from DB=====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             result =&lt;span&gt; goodsStockMapper.selectByPrimaryKey(id);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询结果写入缓存&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            RedisCache.set(id, JSONArray.toJSONString(result));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这里，我们对缓存未命中查询数据库的部分进行加锁进行同步处理，同步代码块中再查询了一次缓存，这样就保证了同时到达但未获得锁的线程后面会直接读取缓存中的数据而不再访问数据库。从而大量减少了同一时刻对数据库的访问量。&lt;/p&gt;
&lt;p&gt;　　我们看看运行结果，可以发现，只有第一次查询是从数据库中查询，后续查询全来自缓存：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; 1907 [Thread-11] INFO  g.s.impl.GoodsStockServiceImpl - =====query from DB===== 
&lt;span&gt; 2&lt;/span&gt; 2550 [Thread-12] INFO  g.s.impl.GoodsStockServiceImpl - =====query from cache===== 
&lt;span&gt; 3&lt;/span&gt; 2578 [Thread-8] INFO  g.s.impl.GoodsStockServiceImpl - =====query from cache===== 
&lt;span&gt; 4&lt;/span&gt; 2579 [Thread-7] INFO  g.s.impl.GoodsStockServiceImpl - =====query from cache===== 
&lt;span&gt; 5&lt;/span&gt; 2580 [Thread-10] INFO  g.s.impl.GoodsStockServiceImpl - =====query from cache===== 
&lt;span&gt; 6&lt;/span&gt; 2581 [Thread-13] INFO  g.s.impl.GoodsStockServiceImpl - =====query from cache===== 
&lt;span&gt; 7&lt;/span&gt; 2581 [Thread-5] INFO  g.s.impl.GoodsStockServiceImpl - =====query from cache===== 
&lt;span&gt; 8&lt;/span&gt; 2581 [Thread-4] INFO  g.s.impl.GoodsStockServiceImpl - =====query from cache===== 
&lt;span&gt; 9&lt;/span&gt; 2582 [Thread-6] INFO  g.s.impl.GoodsStockServiceImpl - =====query from cache===== 
&lt;span&gt;10&lt;/span&gt; 2582 [Thread-9] INFO  g.s.impl.GoodsStockServiceImpl - =====query from cache===== 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　至此，上面提到的在并发的情况查询缓存的问题基本上可以解决，但是我们都知道，在java中sychronized属于重量级锁，读写锁更适合这样的场景。&lt;/p&gt;
&lt;h2&gt;三、高并发情况下缓存使用，利用读写锁提高效率&lt;/h2&gt;
&lt;p&gt;　　这个地方为甚么加上读写锁的性能就更高些，这里涉及到java中的锁机制问题，就不展开写，待后面研究清楚再另外单独记录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 根据商品id(也是主键)查询商品库存记录
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GoodsStock selectByPrimaryKey(Integer id) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        GoodsStock result;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         readWriteLock.readLock().lock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加读锁&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存中查找&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             String goodsStockJsonStr =&lt;span&gt; RedisCache.get(id);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存中查找成功&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!StringUtils.isEmpty(goodsStockJsonStr) &amp;amp;&amp;amp; !&quot;null&quot;&lt;span&gt;.equals(goodsStockJsonStr)) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 logger.info(&quot;=====query from cache=====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 result = JSONObject.parseObject(goodsStockJsonStr, GoodsStock.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若缓存读取失败，则需要去数据库中查询&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 readWriteLock.readLock().unlock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放读锁&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 readWriteLock.writeLock().lock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加写锁&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     goodsStockJsonStr =&lt;span&gt; RedisCache.get(id);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!StringUtils.isEmpty(goodsStockJsonStr) &amp;amp;&amp;amp; !&quot;null&quot;&lt;span&gt;.equals(goodsStockJsonStr)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         logger.info(&quot;=====query from cache=====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; JSONObject.parseObject(goodsStockJsonStr, GoodsStock.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     logger.info(&quot;=====query from DB=====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     result =&lt;span&gt; goodsStockMapper.selectByPrimaryKey(id);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询结果写入缓存&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                    RedisCache.set(id, JSONArray.toJSONString(result));
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                    readWriteLock.writeLock().unlock();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    readWriteLock.readLock().lock();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            readWriteLock.readLock().unlock();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　这个地方补充一下，从上面的代码我们可以看到，其实整个查询方法，主要的业务代码只有一行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; result = goodsStockMapper.selectByPrimaryKey(id);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;剩余的其他代码都是无关于业务的其他处理，我们在业务中应该尽量将非业务的代码抽离出来包装，使真正的业务代码简单高效。对于类似以上这种场景，我们可以使用模板方法，在此简单补充一下：&lt;/p&gt;
&lt;p&gt;查询业务的模板方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * 并发处理的缓存查询模板方法
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; queryKey 查询键值
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expire 缓存过期时间
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; unit 时间单位
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; typeReference 传入泛型类型的类对象
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; cacheLoadable 业务回调类
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T queryByCache(String queryKey, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; expire, TimeUnit unit,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                               TypeReference&amp;lt;T&amp;gt; typeReference, CacheLoadable&amp;lt;T&amp;gt;&lt;span&gt; cacheLoadable) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        T result;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         readWriteLock.readLock().lock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加读锁&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存中查找&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             String goodsStockJsonStr =&lt;span&gt; RedisCache.get(queryKey);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存中查找成功&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!StringUtils.isEmpty(goodsStockJsonStr) &amp;amp;&amp;amp; !&quot;null&quot;&lt;span&gt;.equals(goodsStockJsonStr)) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 logger.info(&quot;=====query from cache=====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 result =&lt;span&gt; JSONObject.parseObject(goodsStockJsonStr, typeReference);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若缓存读取失败，则需要去数据库中查询&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 readWriteLock.readLock().unlock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放读锁&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 readWriteLock.writeLock().lock();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加写锁&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     goodsStockJsonStr =&lt;span&gt; RedisCache.get(queryKey);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!StringUtils.isEmpty(goodsStockJsonStr) &amp;amp;&amp;amp; !&quot;null&quot;&lt;span&gt;.equals(goodsStockJsonStr)) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                         logger.info(&quot;=====query from cache=====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; JSONObject.parseObject(goodsStockJsonStr, typeReference);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     logger.info(&quot;=====query from DB=====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里调用业务传入的回调方法，真正处理业务的地方只有这一行&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;result = cacheLoadable.load();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    RedisCache.set(queryKey, JSONArray.toJSONString(result));
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 } &lt;span&gt;finally&lt;/span&gt; {
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    readWriteLock.writeLock().unlock();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                    readWriteLock.readLock().lock();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            readWriteLock.readLock().unlock();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们再业务使用的时候，只需要像如下调用即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GoodsStock queryByTemplate(Integer id) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; cacheServiceTemplate.queryByCache(String.valueOf(id), 0, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; TypeReference&amp;lt;GoodsStock&amp;gt;() {}, &lt;span&gt;new&lt;/span&gt; CacheLoadable&amp;lt;GoodsStock&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; GoodsStock load() {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; goodsStockMapper.selectByPrimaryKey(id);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四、总结&lt;/h2&gt;
&lt;p&gt;文章中完整源码：https://github.com/Gonjan/javaPractice/tree/master/src&lt;/p&gt;
&lt;p&gt; 写到最后，这篇文章也没多少干货，其实就是将自己动手实践的一部分记录下来而已，看来毕竟是博客写得太少，没有啥章法，想到哪儿写到哪，比较乱，写着写着就跑偏了（T_T真是哭死）,还需多多练习才行。&lt;/p&gt;

</description>
<pubDate>Sat, 27 Jan 2018 05:36:00 +0000</pubDate>
<dc:creator>Gonjian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gonjan-blog/p/8360528.html</dc:identifier>
</item>
<item>
<title>【WebApi系列】浅谈HTTP在WebApi开发中的运用 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/8359181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/8359181.html</guid>
<description>&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180127123319100-346223328.png&quot; alt=&quot;&quot; width=&quot;347&quot; height=&quot;62&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180127123414725-579685317.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一  概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在Web开发中，HTTP是必不可少的环节，在之前的【ASP.NET MVC系列】中，我们并没有讲解HTTP，并不是因为ASP.NET MVC与http关系不大，而是笔者个人觉得http与WebApi结合起来讲解，&lt;/p&gt;
&lt;p&gt;效果可能会更好一些，因此，暂且就把“详解http”作为【WebApi系列】的开篇文章。&lt;/p&gt;
&lt;p&gt;1.http是什么？&lt;/p&gt;
&lt;p&gt;http是一种基于应用层的一种超文本传输协议(HyperText Transfer Protocol)&lt;/p&gt;
&lt;p&gt;2.本章主要讲解什么？&lt;/p&gt;
&lt;p&gt;本章目的就讲解：当我们在浏览器输入：http://www.google.com.hk/，浏览器给我们呈现Google界面，这个过程发生了什么，我暂且将发生的内容归于如下几点：&lt;/p&gt;
&lt;p&gt;(1).域名解析&lt;/p&gt;
&lt;p&gt;(2).TCP建立连接(三次握手)&lt;/p&gt;
&lt;p&gt;(3).TCP通信(传递数据)&lt;/p&gt;
&lt;p&gt;(4).断开连接(四次挥手)&lt;/p&gt;
&lt;p&gt;基于如上过程，我们将分系一下：&lt;/p&gt;
&lt;p&gt;(1)HTTP 请求&lt;/p&gt;
&lt;p&gt;(2)HTTP响应&lt;/p&gt;
&lt;p&gt;那么，我们先来看看。&lt;/p&gt;
&lt;p&gt;HTTP协议定义了浏览器怎样向万维网服务器请求万维网文档，以及服务器怎样把文档传送给浏览器，大致工作流程图如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180126185938006-1244099565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.一次TCP连接，需要三个过程：建立连接(三次握手)、传送数据和释放连接(四次挥手)；&lt;/p&gt;
&lt;p&gt;2.http是基于TCP/IP协议的，且在五层模型中的运用层协议；&lt;/p&gt;
&lt;p&gt;3.客户端请求URL，如上图的http://www.googl.com.hk;&lt;/p&gt;
&lt;p&gt;4.服务器会根据客户端的请求，给予相应的响应(Responce);&lt;/p&gt;

&lt;p&gt;下面，我们将简要列举涉及到的部分关键技术，分别如下：&lt;/p&gt;
&lt;p&gt;（一）基于TCP/IP&lt;/p&gt;
&lt;p&gt;关于网络传输模型，早期大致有四层模型结构和七层模型结构，经过演变，最终将四层模型结构和七层模型结构归结为五层结构模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180126140423506-1213782594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.五层结构模型：运用层、传输层、网络层、数据链路层和物理层；&lt;/p&gt;
&lt;p&gt;2.传输协议：基于TCP/IP&lt;/p&gt;
&lt;p&gt;3.http协议是基于运用层的协议；&lt;/p&gt;
&lt;p&gt;4.五层结构中，从纵向上来说，客户端是从上往下传输，服务端是从下往上接受；&lt;/p&gt;
&lt;p&gt;5.五层结构中，从横向上来说，每一层的协议必须是相同的，至少是相似(一般我们在分析层时，将会横向上虚拟抽象，屏蔽其他层)；&lt;/p&gt;
&lt;p&gt;6.运用层支持多种传输协议，如http协议，smtp协议，ftp协议等；&lt;/p&gt;
&lt;p&gt;7.区分几个概念：TCP/IP协议，TCP协议和UDP协议&lt;/p&gt;
&lt;p&gt;  (1)TCP/IP协议：TCP/IP是一组包括TCP协议和IP协议，UDP（User Datagram Protocol）协议、ICMP（Internet Control Message Protocol）协议和其他一些协议的协议组;&lt;/p&gt;
&lt;p&gt;  (2)TCP协议：传输层中的传输控制协议；&lt;/p&gt;
&lt;p&gt;  (3)UDP协议：传输层中的数据报问协议；&lt;/p&gt;
&lt;p&gt;（二）特点&lt;/p&gt;
&lt;p&gt;http协议具有很多优秀的特点，下图只是简要的列举其部分特点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180126183050584-430290008.png&quot; alt=&quot;&quot; width=&quot;1060&quot; height=&quot;603&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.简单快速：http协议简单，客户端向服务器发送请求时，只需传送请求方法和路径即可，传送的内容简单轻量级，减少传输带宽，速度快；&lt;/p&gt;
&lt;p&gt;2.B/S模式：B/S模式(Browse/Server模式)，也叫客户端(Google,firefox,ie)/服务器模式，在Web开发中，基本都是基于B/S模式；&lt;/p&gt;
&lt;p&gt;3.无连接：http协议本身是无连接的，虽然http使用了tcp连接，但通信双方在交换http保温之前不需要先建立http连接；&lt;/p&gt;
&lt;p&gt;4.无状态：无状态是指协议对于事务处理没有记忆能力，也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问的相同；&lt;/p&gt;
&lt;p&gt;（三）三次握手&lt;/p&gt;
&lt;p&gt;每一次TCP连接都需要三个阶段：建立连接、传送数据和释放连接。三次握手就发生在建立连接阶段，其大致流程如下图所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180126135855006-1555716432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.第一次握手：客户端请求连接。客户端向服务器发出请求连接(client向server发送sys=j的包)，进入发送请求状态(syn_sent状态)，并等待服务器确认。&lt;/p&gt;
&lt;p&gt;2.第二次握手：服务器接受请求并向客户端发出确认信息。当服务器收到syn包后，先确认客户的syn(ack=j+1),同时也需要发布一个syn包(syn=k),即syn+ack包，此时服务器进入syn_recv状态。&lt;/p&gt;
&lt;p&gt;3.第三次握手：建立连接。客户端收服务器的syn+ack包后，向服务器发棕确认包ack(ack=k+1),当此包发送完毕后，客户端和服务器就进入了连接状态(连接成功)，完成三次握手；&lt;/p&gt;
&lt;p&gt;如上似乎有些抽象，我们举个打电话的例子：&lt;/p&gt;
&lt;p&gt;我们打电话的目的是为了传递信息，在打电话前，我们需要先拨通对方的电话且对方应答之后，才能通电话(建立连接)，以A,B两人通电话为例子：&lt;/p&gt;
&lt;p&gt;A：拨打B的手机(拨号，拨通后等待B接电话,相当于第一次握手&lt;span&gt;，请求等待状态&lt;/span&gt;)；&lt;/p&gt;
&lt;p&gt;B：看到A打来的电话(&lt;span&gt;是A才接，确认&lt;/span&gt;)，接了电话，对A说：您好，老A(&lt;span&gt;向A表明自己是B，相当于第二次握手&lt;/span&gt;) ；&lt;/p&gt;
&lt;p&gt;A：您好啊，老B(&lt;span&gt;第三次握手&lt;/span&gt;)；&lt;/p&gt;
&lt;p&gt;双方都问候，表名自己身份后，就可以正式通话了(&lt;span&gt;三次握手结束&lt;/span&gt;)。&lt;/p&gt;
&lt;p&gt;（四）四次挥手&lt;/p&gt;
&lt;p&gt;    TCP连接是全双工的，因此每个方向都必须单独进行关闭。当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接，收到一个 FIN只意味着这一方向上没有数据流动，&lt;/p&gt;
&lt;p&gt;一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180126182824631-1686043029.png&quot; alt=&quot;&quot; width=&quot;1099&quot; height=&quot;626&quot;/&gt;&lt;/div&gt;
&lt;p&gt;1.TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。&lt;/p&gt;
&lt;p&gt;2. 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。&lt;/p&gt;
&lt;p&gt;3.服务器关闭客户端的连接，发送一个FIN给客户端。&lt;/p&gt;
&lt;p&gt;4.客户端发回ACK报文确认，并将确认序号设置为收到序号加1。&lt;/p&gt;
&lt;p&gt; （五）URI、URL与URN&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180126175155631-125061204.png&quot; alt=&quot;&quot; width=&quot;1096&quot; height=&quot;633&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.URI、URL和URN定义 &lt;/p&gt;
&lt;p&gt;     URI(Uniform Resource Identifier)代表统一资源标识符，标识资源的字符串；&lt;/p&gt;
&lt;p&gt;     URL (Uniform Resource Locator)代表统一资源定位符，互联网上标准资源的地址；&lt;/p&gt;
&lt;p&gt;     URN(Uniform Resources Name)代表统一资源名称，互联网上资源的名称；&lt;/p&gt;
&lt;p&gt;2. 对URI、URL和URN三者之间解析&lt;/p&gt;
&lt;p&gt;    (1)从命名角度，URI标识资源且唯一，URL标识资源地址 ，URN标识资源名称；&lt;/p&gt;
&lt;p&gt;    (2)从数学关系：URI=URL+URN+URL∩URN；很容易看出，URL一定是URI，但URI不一定是URL，同理，URN一定是URI，但URI不一定是URN；&lt;/p&gt;
&lt;p&gt;3. URL应具有特点&lt;/p&gt;
&lt;p&gt;     (1)  域名便于记忆和拼写；&lt;/p&gt;
&lt;p&gt;     (2)  简短；&lt;/p&gt;
&lt;p&gt;     (3)  便于输入；&lt;/p&gt;
&lt;p&gt;     (4)  可以反映出站点结构；&lt;/p&gt;
&lt;p&gt;     (5)  应该是“可破解的”，用户可以通过移除URL的末尾，进而到达更高层次的信息体系结构；&lt;/p&gt;
&lt;p&gt;     (6)  持久、不能改变&lt;/p&gt;
&lt;p&gt;4  小结&lt;/p&gt;
&lt;p&gt;       通常情况下，URI代表同意资源标识符(Uniform Resource Identifier)。URI是标识了一个资源的字符串。从技术角度看，所有URL都是URI。W3C认为“URL是一个非正式的概念，但它非常有用：&lt;/p&gt;
&lt;p&gt;URL是URI的一种类型，它通过表示自身的主要访问机制来标识资源”，换句话说，URI是某种资源的标识符，而URL则为获取该资源提供了具体的信息。&lt;/p&gt;
&lt;p&gt;       注释：资源是一个抽象概念，既可以指一个文件，也可以指方法调用的结果或服务器上的一些其他内容。&lt;/p&gt;
&lt;p&gt;（六）HTTP几个关键概念&lt;/p&gt;
&lt;p&gt;这个比较基础，学过计算网络的朋友，都应该知道，这里就不解释了，大致轮廓图如下所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180126191641569-1287393056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 二  HTTP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（一）http请求&lt;/p&gt;
&lt;p&gt;1.http请求一般由三部分构成：&amp;lt;请求行&amp;gt;&amp;lt;请求头&amp;gt;&amp;lt;请求体&amp;gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;(1)请求行：&amp;lt;Method&amp;gt;&amp;lt;Request-url&amp;gt;&amp;lt;version&amp;gt;&lt;span&gt;
(2)请求头：header
(3)请求体：Request-Body&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Get http://localhost:2172/api/Default/GetUserInfo?UserName=Alan_beijing  HTTP/1.1&lt;br/&gt;host:localhost&lt;br/&gt;Content-Type:application/json
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.http请求方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180127103440584-1112083161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.1Get&lt;/p&gt;
&lt;p&gt;(1)一般由于获取查询资源，对应DB中的Select操作，为http请求常用方法 ；(2)该操作对系统来说，是安全的，因为其只查询而不修改数据；&lt;/p&gt;
&lt;p&gt;(3)冥等的，对同一URL多次请求得到的结果应该是相同的；(4)参数在URL中传递，而非Rquest-Body中传递；&lt;/p&gt;
&lt;p&gt;(5)有长度限制，如IE : 2803 ；Firefox:65536 ；Chrome:8182  ； Safari:80000 ； Opera:190000 (6)不安全，因为参数暴露在url中&lt;/p&gt;
&lt;p&gt;2.2.Post&lt;/p&gt;
&lt;p&gt;(1)一般用于向系统中更新数据，对应DB中的Update操作，为http请求常用方法；(2)参数在Requet-Body中传递 ;&lt;/p&gt;
&lt;p&gt;(3)相比较Get，较为安全&lt;/p&gt;
&lt;p&gt;2.3.Put&lt;/p&gt;
&lt;p&gt;(1)一般用于向系统中插入数据(当然，其功能Post也能实现，与Post有很多相似之处),对应DB中的Insert操作；&lt;/p&gt;
&lt;p&gt;(2)传输内容放在Request-Body中；&lt;/p&gt;
&lt;p&gt;(3)不安全，不带验证机制，故一般不使用该方法；&lt;/p&gt;
&lt;p&gt;2.4.Delete&lt;/p&gt;
&lt;p&gt;(1)一般用于向系统中删除数据，对应DB中的Delete操作；&lt;/p&gt;
&lt;p&gt;(2)不带验证机制，故不安全；&lt;/p&gt;
&lt;p&gt;2.5.Head&lt;/p&gt;
&lt;p&gt;(1) 用法与Get一样，只不过Head只返回Http-Responce头部信息；&lt;/p&gt;
&lt;p&gt;(2)由于Head只返回头部信息(相对于Get，轻量级)，故一般被用于确认URI的有效性，资源更新的日期时间等；&lt;/p&gt;
&lt;p&gt;2.6.Patch&lt;/p&gt;
&lt;p&gt;(1)部分文档更改;&lt;/p&gt;
&lt;p&gt;2.7.Trace&lt;/p&gt;
&lt;p&gt;(1)追踪路径，如追踪一个资源请求中间所经过的代理；(2)回显服务器收到的请求，主要用于测试或诊断;&lt;/p&gt;
&lt;p&gt;2.8.Copy&lt;/p&gt;
&lt;p&gt;(1)拷贝指定资源到目标位置;&lt;/p&gt;
&lt;p&gt;2.9.Options&lt;/p&gt;
&lt;p&gt;(1)一般用来询问URI支持的方法；(2)查询服务器的性能&lt;/p&gt;
&lt;p&gt;2.10.Link&lt;/p&gt;
&lt;p&gt;(1)建立连接关系;&lt;/p&gt;
&lt;p&gt;2.11.UnLink&lt;/p&gt;
&lt;p&gt;(1)断开链接关系&lt;/p&gt;
&lt;p&gt;2.12.Purge&lt;/p&gt;
&lt;p&gt;(1)清除；&lt;/p&gt;
&lt;p&gt;2.13.PropFind&lt;/p&gt;
&lt;p&gt;(1)查看属性&lt;/p&gt;
&lt;p&gt;2.14.View&lt;/p&gt;
&lt;p&gt;(1)查看&lt;/p&gt;
&lt;p&gt;2.15.Connect&lt;/p&gt;
&lt;p&gt;(1)隧道协议连接代理&lt;/p&gt;
&lt;p&gt;2.16.Move&lt;/p&gt;
&lt;p&gt;(1)将服务器资源移动到目标位置；&lt;/p&gt;
&lt;p&gt;2.17.Wrapped&lt;/p&gt;
&lt;p&gt;(1)允许客户端发送封装过的请求；&lt;/p&gt;
&lt;p&gt;2.18.Extension-Method&lt;/p&gt;
&lt;p&gt;(1)基于不变协议的前提下，可增加其他方法;&lt;/p&gt;
&lt;p&gt;2.19.Lock&lt;/p&gt;
&lt;p&gt;(1)加锁;&lt;/p&gt;
&lt;p&gt;2.20.UnLock&lt;/p&gt;
&lt;p&gt;(1)解锁；&lt;/p&gt;

&lt;p&gt;3.请求头&lt;/p&gt;
&lt;p&gt;现将常用的http请求头域列于如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180127105544194-1164080359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（二）http响应&lt;/p&gt;
&lt;p&gt;1.http响应一般由三部分构成：&amp;lt;状态行&amp;gt;&amp;lt;响应头&amp;gt;&amp;lt;响应体&amp;gt;；&lt;/p&gt;
&lt;p&gt;2.状态行&lt;/p&gt;
&lt;p&gt;2.1 状态行构成&lt;/p&gt;
&lt;p&gt; 状态行一般由三个部分构成：&amp;lt;协议及其版本&amp;gt;&amp;lt;状态码&amp;gt;&amp;lt;描述&amp;gt;,如HTTP/1.1 200 OK；&lt;/p&gt;
&lt;p&gt;2.2 状态代码和常见状态码&lt;/p&gt;
&lt;p&gt;状态代码由 3 位数字组成， 表示响应的状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1066923/201801/1066923-20180127114453272-975214189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3.响应头&lt;/p&gt;
&lt;p&gt;关于响应头，与请求头原理差不多，这里就不讲解了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三   版权区&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢您的阅读，若有不足之处，欢迎指教，共同学习、共同进步。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;博主网址：http://www.cnblogs.com/wangjiming/。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;极少部分文章利用读书、参考、引用、抄袭、复制和粘贴等多种方式整合而成的，大部分为原创。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如您喜欢，麻烦推荐一下；如您有新想法，欢迎提出，邮箱：2098469527@qq.com。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以转载该博客，但必须著名博客来源。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 27 Jan 2018 04:31:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/8359181.html</dc:identifier>
</item>
<item>
<title>微信小程序版2048 - _wind</title>
<link>http://www.cnblogs.com/wind-lanyan/p/8365185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wind-lanyan/p/8365185.html</guid>
<description>&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;55il0-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;55il0-0-0&quot;&gt;最近流行微信“跳一跳”小游戏，我也心血来潮写了一个微信小程序版2048，本篇文章主要分享实现2048的算法以及注意的点，一起来学习吧！（源码地址见文章末尾）&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;bt6i9-0-0&quot;&gt;算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;297kj-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;297kj-0-0&quot;&gt;1、生成4*4棋盘视图&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;chbh6-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;chbh6-0-0&quot;&gt;2、随机生成2或4填充两个单元格&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;3c6an-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3c6an-0-0&quot;&gt;3、记录用户touch时的起始位置和结束位置，以此判断滑动方向&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;akfl2-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;akfl2-0-0&quot;&gt;4、根据滑动方向移动单元格，并进行相同值合并&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;ccgq2-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ccgq2-0-0&quot;&gt;5、用户一次滑动完成后重复执行步骤2&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;bl6vf-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bl6vf-0-0&quot;&gt;6、判断游戏是否结束，并根据游戏结果产生不同提示&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;b4h37-0-0&quot;&gt;难点&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;d1f3d-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;d1f3d-0-0&quot;&gt;1、确定滑动方向&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;fgl8h-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fgl8h-0-0&quot;&gt;2、用户滑动时相同格子合并，并移到滑动方向一侧&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4o3af-0-0&quot;&gt;实现&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;ebfe3-0-0&quot;&gt;视图实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;c3kq7-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c3kq7-0-0&quot;&gt;1、用wxml+wxss生成棋盘视图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c3kq7-0-0&quot;&gt;2、用wx:for将数据渲染到每个单元格&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/v2-7b4065d07097c912b22835a9c8e50500_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;317&quot; data-rawheight=&quot;451&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;bqbsk-0-0&quot;&gt;逻辑实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;4n7hj-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4n7hj-0-0&quot;&gt;1、页面加载完毕随机用数字2或4填充两个单元格&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;20c4c-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;20c4c-0-0&quot;&gt;2、判断用户滑动方向&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; disX = &lt;span&gt;this&lt;/span&gt;.touchStartX - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.touchEndX; 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; absdisX =&lt;span&gt; Math.abs(disX); 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; disY = &lt;span&gt;this&lt;/span&gt;.touchStartY - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.touchEndY; 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; absdisY =&lt;span&gt; Math.abs(disY); 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确定移动方向 &lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0:上, 1:右, 2:下, 3:左 &lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; direction = absdisX &amp;gt; absdisY ? (disX &amp;lt; 0 ? 1 : 3) : (disY &amp;lt; 0 ? 2 : 0);
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;dqck2-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dqck2-0-0&quot;&gt;3、根据滑动方向（假设向右滑动）移动表格以及相同项合并&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;8ncav-0-0&quot; readability=&quot;13.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比如棋盘数据如下 &lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; grid =&lt;span&gt; [
&lt;/span&gt;    [2, 2, 0, 0&lt;span&gt;], 
&lt;/span&gt;    [0, 0, 0, 0&lt;span&gt;], 
&lt;/span&gt;    [0, 8, 4, 0&lt;span&gt;], 
&lt;/span&gt;    [0, 0, 0, 0&lt;span&gt;] 
&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;1558o-0-0&quot; readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; list =&lt;span&gt; [ 
    [&lt;/span&gt;0, 0, 2, 2], &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意是0022不是2200，因为像右滑动所以从右边push入数组 &lt;/span&gt;
    [0, 0, 0, 0&lt;span&gt;], 
    [&lt;/span&gt;0, 4, 8, 0&lt;span&gt;], 
    [&lt;/span&gt;0, 0, 0, 0&lt;span&gt;] 
];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;31pdf-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;31pdf-0-0&quot;&gt;相应代码（代码中this.board.grid为上面的初始grid）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;31pdf-0-0&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; formList(dir) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据传入的滑动方向生成list的四个数组&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; list =&lt;span&gt; [[], [], [], []];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; &lt;span&gt;this&lt;/span&gt;.size; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(dir) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 0&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             list[i].push(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.board.grid[j][i]);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             list[i].push(&lt;span&gt;this&lt;/span&gt;.board.grid[i][&lt;span&gt;this&lt;/span&gt;.size-1-&lt;span&gt;j]);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 2&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             list[i].push(&lt;span&gt;this&lt;/span&gt;.board.grid[&lt;span&gt;this&lt;/span&gt;.size-1-&lt;span&gt;j][i]);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 3&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             list[i].push(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.board.grid[i][j]);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
list2 =&lt;span&gt; [ 
    [&lt;/span&gt;2, 2, 0, 0&lt;span&gt;], 
    [&lt;/span&gt;0, 0, 0, 0&lt;span&gt;], 
    [&lt;/span&gt;4, 8, 0, 0&lt;span&gt;], 
    [&lt;/span&gt;0, 0, 0, 0&lt;span&gt;] 
];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;a2dgj-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;a2dgj-0-0&quot;&gt;相应代码：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;btgr4-0-0&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; changeItem(item) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 [0, 2, 0, 2] 改为 [2, 2, 0, 0]&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; cnt = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; item.length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;(item[i] != 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         item[cnt++] =&lt;span&gt; item[i];
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = cnt; j &amp;lt; item.length; j++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;       item[j] = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;970o-0-0&quot; readability=&quot;13.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
list2 =&lt;span&gt; [ 
    [&lt;/span&gt;4, 0, 0, 0&lt;span&gt;], 
    [&lt;/span&gt;0, 0, 0, 0&lt;span&gt;], 
    [&lt;/span&gt;4, 8, 0, 0&lt;span&gt;], 
    [&lt;/span&gt;0, 0, 0, 0&lt;span&gt;] 
];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;26p59-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;26p59-0-0&quot;&gt;相应代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;26p59-0-0&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; combine(list) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 滑动时相同的合并&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; list.length; i++)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数字靠边&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;       list[i] = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.changeItem(list[i]);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;) { 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = 1; j &amp;lt; &lt;span&gt;this&lt;/span&gt;.size; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(list[i][j-1] == list[i][j] &amp;amp;&amp;amp; list[i][j]!=0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;           list[i][j-1] +=&lt;span&gt; list[i][j];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;           list[i][j] = 0&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; list.length; i++)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再次数字靠边，避免0220变成0400的情况发生&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;       list[i] = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.changeItem(list[i]);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;1qeiq-0-0&quot; readability=&quot;13.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
list =&lt;span&gt; [ 
    [&lt;/span&gt;0, 0, 0, 4&lt;span&gt;], 
    [&lt;/span&gt;0, 0, 0, 0&lt;span&gt;], 
    [&lt;/span&gt;0, 0, 8, 4&lt;span&gt;], 
    [&lt;/span&gt;0, 0, 0, 0&lt;span&gt;] 
];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;6v17o-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6v17o-0-0&quot;&gt;相应代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6v17o-0-0&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;move(dir) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0:上, 1:右, 2:下, 3:左&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; curList = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.formList(dir);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; list = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.combine(curList); 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; [[],[],[],[]];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; &lt;span&gt;this&lt;/span&gt;.size; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (dir) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 0&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             result[i][j] =&lt;span&gt; list[j][i];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             result[i][j] = list[i][&lt;span&gt;this&lt;/span&gt;.size-1-&lt;span&gt;j];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 2&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             result[i][j] = list[j][&lt;span&gt;this&lt;/span&gt;.size-1-&lt;span&gt;i];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;           &lt;span&gt;case&lt;/span&gt; 3&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             result[i][j] =&lt;span&gt; list[i][j];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;      } 
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.board.grid =&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.setDataRandom();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移动一次之后随机用2或4填充两个单元格&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;bg36p-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bg36p-0-0&quot;&gt;4、重复步骤1&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;e7l8l-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;e7l8l-0-0&quot;&gt;5、判断游戏是否结束&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; isOver() {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 游戏是否结束，结束条件：可用格子为空且所有格子上下左右值不等&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.size; i++) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左右不等&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 1; j &amp;lt; &lt;span&gt;this&lt;/span&gt;.size; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.board.grid[i][j] == &lt;span&gt;this&lt;/span&gt;.board.grid[i][j - 1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = 0; j &amp;lt; &lt;span&gt;this&lt;/span&gt;.size; j++)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上下不等&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 1; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.size; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.board.grid[i][j] == &lt;span&gt;this&lt;/span&gt;.board.grid[i - 1&lt;span&gt;][j])
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; } 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;f68e3-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f68e3-0-0&quot;&gt;6、根据游戏结果给出相应提示&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic7.zhimg.com/v2-da001e19343586ef5408c547ab03541a_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;325&quot; data-rawheight=&quot;478&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;5s23&quot; data-offset-key=&quot;q04k-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;q04k-0-0&quot;&gt;&lt;span data-offset-key=&quot;q04k-0-0&quot;&gt;po一个源码地址：&lt;a class=&quot;Link&quot; href=&quot;https://github.com/windlany/2048&quot; target=&quot;_blank&quot; data-offset-key=&quot;q04k-1-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;q04k-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;windlany/2048&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;q04k-2-0&quot;&gt;有兴趣的可以fork一下，求star~&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 27 Jan 2018 02:59:00 +0000</pubDate>
<dc:creator>_wind</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wind-lanyan/p/8365185.html</dc:identifier>
</item>
<item>
<title>小程序支持打开移动应用到底是怎么回事？ - zhanggui</title>
<link>http://www.cnblogs.com/zhanggui/p/8365169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggui/p/8365169.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;从苹果官方微信号&lt;strong&gt;微信公共平台&lt;/strong&gt;发布的文章&lt;a href=&quot;https://mp.weixin.qq.com/s/DkbDa2506-dJQ8HY6JFfBg&quot;&gt;《小程序支持打开移动应用》&lt;/a&gt;来看，小程序新增了两个功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;支持打开移动应用&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;标题栏区域开放自定义&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;针对第二个功能，就是开发者可以自定义小程序菜单栏的颜色风格，根据需求，对小程序菜单外的标题区域进行自定义，比如设置标题区域的颜色。这里主要介绍一下支持打开移动应用的功能。&lt;/p&gt;
&lt;h4 id=&quot;支持打开移动应用&quot;&gt;支持打开移动应用&lt;/h4&gt;
&lt;p&gt;乍一看其实有点标题党的行为，支持打开移动应用？&lt;br/&gt;让我想到的是我可以用小程序打开任何移动应用？（答案是不能）&lt;br/&gt;那我是不是可以打开自己的App？（答案是有限制性地打开）&lt;br/&gt;是不是可以打开系统自带的浏览器？（答案是不能）&lt;br/&gt;是不是可以打开第三方的移动应用呢？（答案也是不能）&lt;/p&gt;
&lt;p&gt;其实，小程序打开移动应用有一条硬性要求：&lt;strong&gt;从移动应用分享至小程序的页面，用户访问时支持打开来源应用。&lt;/strong&gt;接下来进一步解读一下这条要求。&lt;/p&gt;
&lt;p&gt;大部分程序都有微信分享功能，我们常做的就是将一个图片、一段文字亦或是一个URL链接进行分享，可以分享给好友（包括群）、朋友圈或者是添加到个人收藏，如下：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/wechatshare.png&quot; alt=&quot;微信分享&quot;/&gt;&lt;br/&gt;我们还可以分享小程序，如图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/shareminiprogram.png&quot; alt=&quot;小程序分享&quot;/&gt;&lt;br/&gt;上面是一个抢票软件（智行）分享到微信的一个小程序，好友可以点击小程序帮忙加速。按照官方文章的说法，分享到微信的小程序里面如果有一个按钮，实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;button&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; open-type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;launchApp&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; app-parameter=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;wechat&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; binderror=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;launchAppError&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;打开APP&lt;span class=&quot;kw&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么当点击此按钮时，就会打开源App。在其他情况下是无法打开的，这里给出了一张能否打开移动APP的图解：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/launch-app.png&quot; alt=&quot;launch-app&quot;/&gt;&lt;br/&gt;这里小程序给出一个场景值概念，只有场景值为1036（还有个状态值true或false，它决定是否能够打开APP。场景值为1036，状态值为true）的小程序，才能够打开源APP，即&lt;strong&gt;小程序不能打开任何App，只能跳回分享小程序卡片的APP&lt;/strong&gt;。官方文档也对这个标识做了解释：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在小程序的生命周期内，这个状态的初始值为 false，之后会随着小程序的每次打开（无论是启动还是切到前台）而改变：&lt;br/&gt;1.当小程序从 1036（App 分享消息卡片） 打开时，该状态置为 true。&lt;br/&gt;2.当小程序从 1089（微信聊天主界面下拉）或 1090（长按小程序右上角菜单唤出最近使用历史）的场景打开时，该状态不变，即保持上一次打开小程序时该状态的值。&lt;br/&gt;3.当小程序从非 1036/1089/1090 的场景打开，该状态置为 false。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;针对第二条，1089和1090那个，我的理解是小程序类似于移动APP，它并没有关闭，而是在后台，所以1089和1090打开小程序只是把小程序唤到前台，所以小程序状态不变。状态如果为true，也可以打开移动APP。&lt;br/&gt;以上便是对小程序打开移动应用的介绍，接下来看一下具体代码实现。&lt;/p&gt;
&lt;h4 id=&quot;代码实现分享小程序打开移动应用ios版本android类似&quot;&gt;代码实现分享小程序打开移动应用（iOS版本，Android类似）&lt;/h4&gt;
&lt;p&gt;首先要做的就是新建一个工程，然后集成微信分享，具体如何集成可以参见&lt;a href=&quot;https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;amp;t=resource/res_list&amp;amp;verify=1&amp;amp;id=1417694084&amp;amp;token=&amp;amp;lang=zh_CN&quot;&gt;官网集成文档&lt;/a&gt;，集成之后，在页面添加一个按钮，触发实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (IBAction)openSmallProgramAction:(id)sender {
    &lt;span class=&quot;co&quot;&gt;//分享小程序的实现&lt;/span&gt;
    WXMiniProgramObject *wxMiniObject = [WXMiniProgramObject object];
    wxMiniObject.userName = &lt;span class=&quot;st&quot;&gt;@&quot;gh_*************&quot;&lt;/span&gt;;
    wxMiniObject.path = &lt;span class=&quot;st&quot;&gt;@&quot;pages/index/index&quot;&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
    WXMediaMessage *message = [WXMediaMessage message];
    message.title = &lt;span class=&quot;st&quot;&gt;@&quot;我是小程序&quot;&lt;/span&gt;;
    message.description = &lt;span class=&quot;st&quot;&gt;@&quot;我是用来测试打开App的小程序&quot;&lt;/span&gt;;
    message.mediaObject = wxMiniObject;
    
    SendMessageToWXReq *req = [[SendMessageToWXReq alloc] init];
    req.message = message;
    req.scene = WXSceneSession;
    [WXApi sendReq:req];
   &lt;span class=&quot;co&quot;&gt;//原来做分享的实现&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//    SendMessageToWXReq *req = [[SendMessageToWXReq alloc] init];&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//    req.text = @&quot;分享的内容&quot;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//    req.bText = YES;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//    req.scene = WXSceneSession;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//    [WXApi sendReq:req];&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里是所有的App都可以用上面的实现方式分享小程序么吗？答案是否定的。看官方文档的说法：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;移动应用分享功能支持小程序类型分享，要求发起分享的APP与小程序属于同一微信开放平台帐号。支持分享小程序类型消息至好友会话，不支持“分享至朋友圈”及“收藏”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说小程序分享是有限制的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发起分享的App与小程序属于同一微信开放平台账号&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;只支持分享小程序类型消息至好友会话（SendMessageToWXReq的scence只支持WXSceneSession）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经过测试，一个账号不能同时注册&lt;a href=&quot;https://open.weixin.qq.com/&quot;&gt;微信开放平台&lt;/a&gt;和&lt;a href=&quot;https://mp.weixin.qq.com/&quot;&gt;微信公众平台&lt;/a&gt;。也就是说：如果你的账号注册了微信开放平台，那么该账号就不能再次注册微信公众平台。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;微信开放平台放的是移动APP。&lt;br/&gt;微信公众平台放的是小程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那官方所说的属于同一微信开放平台账号就不是一个账号下既有APP又有小程序（因为小程序是在微信公众平台开发的）。打开微信开放平台页面之后，第一条就好理解了：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/openwechat.png&quot; alt=&quot;移动应用&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/openwechatminiprogram.png&quot; alt=&quot;小程序&quot;/&gt;&lt;br/&gt;&lt;strong&gt;如果你想要在移动APP内分享小程序，你必须在该APP所在的微信开放平台账号下绑定微信小程序，这样才可以在APP中实现小程序分享。这就是官方所说的APP和小程序属于同一微信开放平台账号。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;那么APP怎么知道分享哪个小程序的？ 或者说APP是怎么和小程序关联的呢？&lt;/strong&gt;&lt;br/&gt;这就要看上面的那段代码（前提是你把小程序和APP放到了同一开放平台账号下），其中有一行：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;wxMiniObject.userName = &lt;span class=&quot;st&quot;&gt;@&quot;gh_*************&quot;&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该userName就是小程序的userName，你可以登录&lt;a href=&quot;https://mp.weixin.qq.com/&quot;&gt;微信公众号平台|小程序&lt;/a&gt;，然后在设置---&amp;gt;基本设置中查看，里面有个原始id，就是小程序的userName。&lt;br/&gt;这样你就将APP的分享和小程序关联起来了。&lt;br/&gt;还有一个问题：&lt;strong&gt;分享的小程序如何打开指定的页面呢？&lt;/strong&gt;&lt;br/&gt;这就要看另一行代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;wxMiniObject.path = &lt;span class=&quot;st&quot;&gt;@&quot;pages/index/index&quot;&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你需要设置一下小程序的path，这个path的页面就是你点击分享的小程序打开的页面。这里看一张小程序开发工具的图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/wechatopenapp/minicode.png&quot; alt=&quot;小程序代码段&quot;/&gt;&lt;br/&gt;pages所指的就是页面，例如上图的pages文件夹包含了detail和index和logs三个页面，其中：&lt;br/&gt;index：指代的是信用卡列表页。&lt;br/&gt;detail：指代的是点击列表某个item进入的详情页。&lt;br/&gt;logs：日志页面&lt;br/&gt;所以如果你想跳转到详情页，那么你在设置wxMiniObject的path时就应该写成“pages/detail/detail”。这样就实现了点击分享的小程序进入指定的页面了（如果页面需要参数你也要在分享时传过去）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;wxml：相当于html&lt;br/&gt;wxss：相当于css&lt;br/&gt;这里其实是微信小程序自己定义了后缀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个时候你分享的小程序场景值为1036，且状态为true，如果此时你小程序里面有open-type为“launchApp”的button，点击button你就会跳回你的移动APP啦。如果想给APP回传内容，可以设置app-parameter。就像这个小按钮：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;button&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; open-type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;launchApp&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; app-parameter=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;wechat&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; binderror=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;launchAppError&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;打开APP&lt;span class=&quot;kw&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，我想你应该大概了解小程序支持打开移动应用到底是怎么回事了。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;小程序并不是支持打开所有移动APP，就算是同一个微信开放平台账号下面的移动APP和小程序，小程序也不一定可以打开，具体还要看场景。&lt;/p&gt;
&lt;h4 id=&quot;展望&quot;&gt;展望&lt;/h4&gt;
&lt;p&gt;小程序支持跳转移动APP是很大的进步，在小程序以后的进一步完善中，它应该会朝着APP直接打开小程序方向迈进，而不仅仅是通过分享打开小程序。未来我们也许会实现点击移动APP里面的某个按钮直接打开某个小程序，然后在小程序操作完成之后再次返回到移动APP。（例如微信支付，可以从移动APP跳转到小程序进行微信支付，支付成功后直接返回移动APP）&lt;/p&gt;
&lt;h4 id=&quot;附参考&quot;&gt;附参考&lt;/h4&gt;
&lt;p&gt;1.&lt;a href=&quot;https://mp.weixin.qq.com/s/DkbDa2506-dJQ8HY6JFfBg&quot;&gt;小程序支持打开移动应用&lt;/a&gt;&lt;br/&gt;2.&lt;a href=&quot;https://mp.weixin.qq.com/debug/wxadoc/dev/api/launchApp.html&quot;&gt;launchApp(OBJECT)&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;注&quot;&gt;注&lt;/h4&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;http://www.cnblogs.com/zhanggui/p/8365169.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/zhanggui/p/8365169.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jan 2018 02:53:00 +0000</pubDate>
<dc:creator>zhanggui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggui/p/8365169.html</dc:identifier>
</item>
<item>
<title>Redis 数据结构与内存管理策略（下） - 王清培</title>
<link>http://www.cnblogs.com/wangiqngpei557/p/8364859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangiqngpei557/p/8364859.html</guid>
<description>&lt;p&gt;标签： Redis Redis数据结构 Redis内存管理策略 Redis数据类型 Redis类型映射&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;Redis 数据类型特点与使用场景
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;String&lt;/strong&gt;、&lt;strong&gt;List&lt;/strong&gt;、&lt;strong&gt;Hash&lt;/strong&gt;、&lt;strong&gt;Set&lt;/strong&gt;、&lt;strong&gt;Zset&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;案例：沪江团购系统大促 &lt;strong&gt;hot-top&lt;/strong&gt; 接口 &lt;strong&gt;cache&lt;/strong&gt; 设计&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redis 内存数据结构与编码
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;OBJECT&lt;/strong&gt; encoding key、&lt;strong&gt;DEBUG OBJECT&lt;/strong&gt; key&lt;/li&gt;
&lt;li&gt;简单动态字符串（simple dynamic string）&lt;/li&gt;
&lt;li&gt;链表（linked list）&lt;/li&gt;
&lt;li&gt;字典（dict）&lt;/li&gt;
&lt;li&gt;跳表（skip list）&lt;/li&gt;
&lt;li&gt;整数集合（int set）&lt;/li&gt;
&lt;li&gt;压缩表（zip list）&lt;/li&gt;
&lt;li&gt;Redis Object 类型与映射&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redis 内存管理策略
&lt;ul&gt;&lt;li&gt;键 过期时间、生存时间&lt;/li&gt;
&lt;li&gt;过期键删除策略&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AOF&lt;/strong&gt; 、&lt;strong&gt;RDB&lt;/strong&gt; 处理过期键策略&lt;/li&gt;
&lt;li&gt;Redis &lt;strong&gt;LRU&lt;/strong&gt; 算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redis 持久化方式
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;RDB&lt;/strong&gt; (Redis DataBase)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AOF&lt;/strong&gt; (Append-only file)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;字典dict&quot;&gt;字典（dict）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;dict&lt;/strong&gt; 字典是基于 &lt;strong&gt;&lt;em&gt;hash算法&lt;/em&gt;&lt;/strong&gt; 来实现，是 &lt;strong&gt;Hash&lt;/strong&gt; 数据类型的底层存储数据结构。我们来看下 &lt;strong&gt;redis 3.0.0&lt;/strong&gt; 版本的 &lt;strong&gt;dict.h&lt;/strong&gt; 头文件定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct dict {
    dictType *type;
    void *privdata;
    dictht ht[2];
    long rehashidx;
    int iterators; 
} dict;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct dictEntry {
    void *key;
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说到 &lt;strong&gt;&lt;em&gt;hash table&lt;/em&gt;&lt;/strong&gt; 有两个东西是我们经常会碰到的，首先就是 &lt;strong&gt;&lt;em&gt;hash 碰撞&lt;/em&gt;&lt;/strong&gt; 问题，&lt;strong&gt;redis dict&lt;/strong&gt; 是采用链地址法来解决，&lt;strong&gt;&lt;em&gt;dictEntry-&amp;gt;next&lt;/em&gt;&lt;/strong&gt; 就是指向下个冲突 &lt;strong&gt;key&lt;/strong&gt; 的节点。&lt;/p&gt;
&lt;p&gt;还有一个经常碰到的就是 &lt;strong&gt;rehash&lt;/strong&gt; 的问题，提到 &lt;strong&gt;rehash&lt;/strong&gt; 我们还是有点担心性能的。那么redis 实现是非常巧妙的，采用 &lt;strong&gt;&lt;em&gt;惰性渐进式 rehash 算法&lt;/em&gt;&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;dict struct&lt;/strong&gt; 里有一个 &lt;strong&gt;ht[2]&lt;/strong&gt; 组数，还有一个 &lt;strong&gt;rehashidx&lt;/strong&gt; 索引。&lt;strong&gt;redis&lt;/strong&gt; 进行 &lt;strong&gt;rehash&lt;/strong&gt; 的大致算法是这样的，首先会开辟一个新的 &lt;strong&gt;dictht&lt;/strong&gt; 空间，放在 &lt;strong&gt;ht[2]&lt;/strong&gt; 索引上，此时将 &lt;strong&gt;rehashidx&lt;/strong&gt; 设置为0，表示开始进入 &lt;strong&gt;rehash&lt;/strong&gt; 阶段，这个阶段可能会持续很长时间，&lt;strong&gt;rehashidx&lt;/strong&gt; 表示 &lt;strong&gt;dictEntry&lt;/strong&gt; 个数。&lt;/p&gt;
&lt;p&gt;每次当有对某个 &lt;strong&gt;ht[1]&lt;/strong&gt; 索引中的 &lt;strong&gt;key&lt;/strong&gt; 进行访问时，获取、删除、更新，&lt;strong&gt;redis&lt;/strong&gt; 都会将当前 &lt;strong&gt;dictEntry&lt;/strong&gt; 索引中的所有 &lt;strong&gt;key&lt;/strong&gt; &lt;strong&gt;rehash&lt;/strong&gt; 到 &lt;strong&gt;ht[2]&lt;/strong&gt; 字典中。一旦 &lt;strong&gt;rehashidx=-1&lt;/strong&gt; 表示 &lt;strong&gt;rehash&lt;/strong&gt; 结束。&lt;/p&gt;
&lt;h3 id=&quot;跳表skip-list&quot;&gt;跳表（skip list）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;skip list&lt;/strong&gt; 是 &lt;strong&gt;zset&lt;/strong&gt; 的底层数据结构，有着高性能的查找排序能力。&lt;/p&gt;
&lt;p&gt;我们都知道一般用来实现带有排序的查找都是用 &lt;strong&gt;Tree&lt;/strong&gt; 来实现，不管是各种变体的 &lt;strong&gt;B Tree&lt;/strong&gt; 还是 &lt;strong&gt;B+ Tree&lt;/strong&gt;，本质都是用来做顺序查找。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;skip list&lt;/strong&gt; 实现起来简单，性能也与 &lt;strong&gt;B Tree&lt;/strong&gt; 相接近。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct zskiplistNode {
    robj *obj;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned int span;
    } level[];
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;zskiplistNode-&amp;gt;zskiplistLevel-&amp;gt;span&lt;/em&gt;&lt;/strong&gt; 这个值记录了当前节点距离下个节点的跨度。每一个节点会有最大不超过 &lt;strong&gt;&lt;em&gt;zskiplist-&amp;gt;level&lt;/em&gt;&lt;/strong&gt; 节点个数，分别用来表示不同跨度与节点的距离。&lt;/p&gt;
&lt;p&gt;每个节点会有多个 &lt;strong&gt;forward&lt;/strong&gt; 向前指针，只有一个 &lt;strong&gt;backward&lt;/strong&gt; 指针。每个节点会有对象 __*obj__ 和 &lt;strong&gt;score&lt;/strong&gt; 分值，每个分值都会按照顺序排列。&lt;/p&gt;
&lt;h3 id=&quot;整数集合int-set&quot;&gt;整数集合（int set）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;int set&lt;/strong&gt; 整数集合是 &lt;strong&gt;set&lt;/strong&gt; 数据类型的底层实现数据结构，它的特点和使用场景很明显，只要我们使用的集合都是整数且在一定的范围之内都会使用整数集合编码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SADD set:userid 100 200 300
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;OBJECT encoding set:userid
&quot;intset&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;int set&lt;/strong&gt; 使用一块连续的内存来存储集合数据，它是数组结构不是链表结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct intset {
    uint32_t encoding;
    uint32_t length;
    int8_t contents[];
} intset;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;intset-&amp;gt;encoding&lt;/strong&gt; 用来确定 &lt;strong&gt;contents[]&lt;/strong&gt; 是什么类型的整数编码，以下三种值之一。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define INTSET_ENC_INT16 (sizeof(int16_t))
#define INTSET_ENC_INT32 (sizeof(int32_t))
#define INTSET_ENC_INT64 (sizeof(int64_t))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 会根据我们设置的值类型动态 &lt;strong&gt;sizeof&lt;/strong&gt; 出一个对应的空间大小。如果我们集合原来是 &lt;strong&gt;int16&lt;/strong&gt; ，然后往集合里添加了 &lt;strong&gt;int32&lt;/strong&gt; 整数将触发升级，一旦升级成功不会触发降级操作。&lt;/p&gt;
&lt;h3 id=&quot;压缩表zip-list&quot;&gt;压缩表（zip list）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;zip list&lt;/strong&gt; 压缩表是 &lt;strong&gt;list&lt;/strong&gt;、&lt;strong&gt;zset&lt;/strong&gt;、&lt;strong&gt;hash&lt;/strong&gt; 数据类型的底层数据结构之一。它是为了节省内存通过压缩数据存储在一块连续的内存空间中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct zlentry {
    unsigned int prevrawlensize, prevrawlen;
    unsigned int lensize, len;
    unsigned int headersize;
    unsigned char encoding;
    unsigned char *p;
} zlentry;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它最大的优点就是压缩空间，空间利用率很高。缺点就是一旦出现更新可能就是连锁更新，因为数据在内容空间中都是连续的，最极端情况下就是可能出现顺序连锁扩张。&lt;/p&gt;
&lt;p&gt;压缩列表会由多个 &lt;strong&gt;zlentry&lt;/strong&gt; 节点组成，每一个 &lt;strong&gt;zlentry&lt;/strong&gt; 记录上一个节点长度和大小，当前节点长度 &lt;strong&gt;lensize&lt;/strong&gt; 和大小 &lt;strong&gt;len&lt;/strong&gt; 包括编码 &lt;strong&gt;encoding&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这取决于业务场景，&lt;strong&gt;redis&lt;/strong&gt; 提供了一组配置，专门用来针对不同的场景进行阈值控制。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hash-max-ziplist-entries 512
hash-max-ziplist-value 64&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;list-max-ziplist-entries 512
list-max-ziplist-value 64&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;zset-max-ziplist-entries 128
zset-max-ziplist-value 64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述配置分别用来配置 &lt;strong&gt;ziplist&lt;/strong&gt; 作为 &lt;strong&gt;hash&lt;/strong&gt; 、&lt;strong&gt;list&lt;/strong&gt;、&lt;strong&gt;zset&lt;/strong&gt; 数据类型的底层压缩阈值控制。&lt;/p&gt;
&lt;h2 id=&quot;redis-object-类型与映射&quot;&gt;Redis Object 类型与映射&lt;/h2&gt;
&lt;p&gt;redis 内部每一种数据类型都是对象化的，也就是我们所说的5种数据类型其实内部都会对应到 redisObject 对象，然后在由 redisObject 来包装具体的存储数据结构和编码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:REDIS_LRU_BITS; 
    int refcount;
    void *ptr;
} robj;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个很 &lt;strong&gt;OO&lt;/strong&gt; 的设计，&lt;strong&gt;&lt;em&gt;redisObject-&amp;gt;type&lt;/em&gt;&lt;/strong&gt; 是 &lt;strong&gt;5&lt;/strong&gt; 种数据类型之一，&lt;strong&gt;&lt;em&gt;redisObject-&amp;gt;encoding&lt;/em&gt;&lt;/strong&gt; 是这个数据类型所使用的数据结构和编码。&lt;/p&gt;
&lt;p&gt;我们看下 &lt;strong&gt;redis&lt;/strong&gt; 提供的 &lt;strong&gt;5&lt;/strong&gt; 种数据类型与每一种数据类型对应的存储数据结构和编码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* Object types */
#define REDIS_STRING 0
#define REDIS_LIST 1
#define REDIS_SET 2
#define REDIS_ZSET 3
#define REDIS_HASH 4&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;#define REDIS_ENCODING_RAW 0     
#define REDIS_ENCODING_INT 1    
#define REDIS_ENCODING_HT 2
#define REDIS_ENCODING_ZIPMAP 3
#define REDIS_ENCODING_LINKEDLIST 4
#define REDIS_ENCODING_ZIPLIST 5 
#define REDIS_ENCODING_INTSET 6  
#define REDIS_ENCODING_SKIPLIST 7  
#define REDIS_ENCODING_EMBSTR 8 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;REDIS_ENCODING_ZIPMAP 3&lt;/strong&gt; 这个编码可以忽略了，在特定的情况下有性能问题，在 &lt;strong&gt;redis 2.6&lt;/strong&gt; 版本之后已经废弃，为了兼容性保留。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Plen-wang/blogsImage/master/githubimages/redis/8.png&quot; alt=&quot;Redis 数据结构与内存管理策略&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是 &lt;strong&gt;redis 5&lt;/strong&gt; 种数据类型与底层数据结构和编码的对应关系，但是这种对应关系在每一个版本中都会有可能发生变化，这也是 &lt;strong&gt;redisObject&lt;/strong&gt; 的灵活性所在，有着 &lt;strong&gt;OO&lt;/strong&gt; 的这种多态性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;redisObject-&amp;gt;refcount&lt;/em&gt;&lt;/strong&gt; 表示当前对象的引用计数，在 &lt;strong&gt;redis&lt;/strong&gt; 内部为了节省内存采用了共享对象的方法，当某个对象被引用的时候这个 &lt;strong&gt;refcount&lt;/strong&gt; 会加 &lt;em&gt;1&lt;/em&gt;，释放的时候会减 &lt;em&gt;1&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;redisObject-&amp;gt;lru&lt;/em&gt;&lt;/strong&gt; 表示当前对象的 &lt;strong&gt;&lt;em&gt;空转时长&lt;/em&gt;&lt;/strong&gt;，也就是 &lt;strong&gt;idle time&lt;/strong&gt; ，这个时间会是 &lt;strong&gt;redis lru&lt;/strong&gt; 算法用来释放对象的时间依据。可以通过 &lt;strong&gt;OBJECT idletime&lt;/strong&gt; 命令查看某个 &lt;strong&gt;key&lt;/strong&gt; 的空转时长 &lt;strong&gt;lru&lt;/strong&gt; 时间。&lt;/p&gt;
&lt;h2 id=&quot;redis-内存管理策略&quot;&gt;Redis 内存管理策略&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 在服务端分别为不同的 &lt;strong&gt;db index&lt;/strong&gt; 维护一个 &lt;strong&gt;dict&lt;/strong&gt; 这个 &lt;strong&gt;dict&lt;/strong&gt; 称为 &lt;strong&gt;key space&lt;/strong&gt; 键空间 。每一个 &lt;strong&gt;redis client&lt;/strong&gt; 只能属于一个 &lt;strong&gt;db index&lt;/strong&gt; ，在 &lt;strong&gt;redis&lt;/strong&gt; 服务端会维护每一个链接的 &lt;strong&gt;redisClient&lt;/strong&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct redisClient {
    uint64_t id;
    int fd;
    redisDb *db;
} redisClient;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在服务端每一个 &lt;strong&gt;redis&lt;/strong&gt; 客户端都会有一个指向 &lt;strong&gt;redisDb&lt;/strong&gt; 的指针。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct redisDb {
    dict *dict;
    dict *expires;
    dict *blocking_keys;
    dict *ready_keys;
    dict *watched_keys;
    struct evictionPoolEntry *eviction_pool;
    int id;
    long long avg_ttl;
} redisDb;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;key space&lt;/strong&gt; 键空间就是这里的 &lt;strong&gt;redisDb-&amp;gt;dict&lt;/strong&gt; 。&lt;strong&gt;redisDb-&amp;gt;expires&lt;/strong&gt; 是维护所有键空间的每一个 &lt;strong&gt;key&lt;/strong&gt; 的过期时间。&lt;/p&gt;
&lt;h3 id=&quot;键-过期时间生存时间&quot;&gt;键 过期时间、生存时间&lt;/h3&gt;
&lt;p&gt;对于一个 &lt;strong&gt;key&lt;/strong&gt; 我们可以设置它多少秒、毫秒之后过期，也可以设置它在某个具体的时间点过期，后者是一个时间戳。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;EXPIRE&lt;/em&gt;&lt;/strong&gt; 命令可以设置某个 &lt;strong&gt;key&lt;/strong&gt; 多少秒之后过期&lt;br/&gt;&lt;strong&gt;&lt;em&gt;PEXPIRE&lt;/em&gt;&lt;/strong&gt; 命令可以设置某个 &lt;strong&gt;key&lt;/strong&gt; 多少毫秒之后过期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;EXPIREAT&lt;/em&gt;&lt;/strong&gt; 命令可以设置某个 &lt;strong&gt;key&lt;/strong&gt; 在多少秒时间戳之后过期&lt;br/&gt;&lt;strong&gt;&lt;em&gt;PEXPIREAT&lt;/em&gt;&lt;/strong&gt; 命令可以设置某个 &lt;strong&gt;key&lt;/strong&gt; 在多少毫秒时间戳之后过期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;PERSIST&lt;/em&gt;&lt;/strong&gt; 命令可以移除键的过期时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实上述命令最终都会被转换成对 &lt;strong&gt;PEXPIREAT&lt;/strong&gt; 命令。在 &lt;strong&gt;&lt;em&gt;redisDb-&amp;gt;expires&lt;/em&gt;&lt;/strong&gt; 指向的 &lt;strong&gt;key&lt;/strong&gt; 字典中维护着一个到期的毫秒时间戳。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;TTL、PTTL&lt;/em&gt;&lt;/strong&gt; 可以通过这两个命令查看某个 &lt;strong&gt;key&lt;/strong&gt; 的过期秒、毫秒数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 内部有一个 &lt;strong&gt;&lt;em&gt;事件循环&lt;/em&gt;&lt;/strong&gt;，这个事件循环会检查键的过期时间是否小于当前时间，如果小于则会删除这个键。&lt;/p&gt;
&lt;h3 id=&quot;过期键删除策略&quot;&gt;过期键删除策略&lt;/h3&gt;
&lt;p&gt;在使用 &lt;strong&gt;redis&lt;/strong&gt; 的时候我们最关心的就是键是如何被删除的，如何高效的准时的删除某个键。其实 &lt;strong&gt;redis&lt;/strong&gt; 提供了两个方案来完成这件事情。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 采用 &lt;strong&gt;&lt;em&gt;惰性删除&lt;/em&gt;&lt;/strong&gt; 、 &lt;strong&gt;&lt;em&gt;定期删除&lt;/em&gt;&lt;/strong&gt; 双重删除策略。&lt;/p&gt;
&lt;p&gt;当我们访问某个 &lt;strong&gt;key&lt;/strong&gt; 的时候 &lt;strong&gt;redis&lt;/strong&gt; 会检查它是否过期，这是惰性删除。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;robj *lookupKeyRead(redisDb *db, robj *key) {
    robj *val;

    expireIfNeeded(db,key);
    val = lookupKey(db,key);
    if (val == NULL)
        server.stat_keyspace_misses++;
    else
        server.stat_keyspace_hits++;
    return val;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;int expireIfNeeded(redisDb *db, robj *key) {
    mstime_t when = getExpire(db,key);
    mstime_t now;

    if (when &amp;lt; 0) return 0; /* No expire for this key */
    
    if (server.loading) return 0;
    
    now = server.lua_caller ? server.lua_time_start : mstime();
    if (server.masterhost != NULL) return now &amp;gt; when;

    /* Return when this key has not expired */
    if (now &amp;lt;= when) return 0;

    /* Delete the key */
    server.stat_expiredkeys++;
    propagateExpire(db,key);
    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,&quot;expired&quot;,key,db-&amp;gt;id);
    return dbDelete(db,key);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 也会通过 &lt;strong&gt;&lt;em&gt;事件循环&lt;/em&gt;&lt;/strong&gt; 周期性的执行 &lt;strong&gt;key&lt;/strong&gt; 的过期删除动作，这是定期删除。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
    /* Handle background operations on Redis databases. */
    databasesCron();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;void databasesCron(void) {
    /* Expire keys by random sampling. Not required for slaves
     * as master will synthesize DELs for us. */
    if (server.active_expire_enabled &amp;amp;&amp;amp; server.masterhost == NULL)
        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;惰性删除&lt;/strong&gt; 是每次只要有读取、写入都会触发惰性删除代码。&lt;strong&gt;周期删除&lt;/strong&gt; 是由 &lt;strong&gt;redis EventLoop&lt;/strong&gt; 来触发的。&lt;strong&gt;redis&lt;/strong&gt; 内部很多维护性工作都是基于 &lt;strong&gt;EventLoop&lt;/strong&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;aof-rdb-处理过期键策略&quot;&gt;&lt;strong&gt;AOF&lt;/strong&gt; 、&lt;strong&gt;RDB&lt;/strong&gt; 处理过期键策略&lt;/h3&gt;
&lt;p&gt;既然键会随时存在过期问题，那么涉及到持久化 &lt;strong&gt;redis&lt;/strong&gt; 是如何帮我们处理的。&lt;/p&gt;
&lt;p&gt;当 &lt;strong&gt;redis&lt;/strong&gt; 使用 &lt;strong&gt;RDB&lt;/strong&gt; 方式持久化时，每次持久化的时候就会检查这些即将被持久化的 &lt;strong&gt;key&lt;/strong&gt; 是否已经过期，如果过期将直接忽略，持久化那些没有过期的键。当 &lt;strong&gt;redis&lt;/strong&gt; 作为 &lt;strong&gt;&lt;em&gt;master 主服务器&lt;/em&gt;&lt;/strong&gt; 启动的时候，在载入 &lt;strong&gt;rdb&lt;/strong&gt; 持久化键时也会检查这些键是否过期，将忽略过期的键，只载入没过期的键。&lt;/p&gt;
&lt;p&gt;当 &lt;strong&gt;redis&lt;/strong&gt; 使用 &lt;strong&gt;AOF&lt;/strong&gt; 方式持久化时，每次遇到过期的 &lt;strong&gt;key redis&lt;/strong&gt; 会追加一条 &lt;strong&gt;DEL&lt;/strong&gt; 命令 到 &lt;strong&gt;AOF&lt;/strong&gt; 文件，也就是说只要我们顺序载入执行 &lt;strong&gt;AOF&lt;/strong&gt; 命令文件就会删除过期的键。&lt;/p&gt;
&lt;p&gt;如果 &lt;strong&gt;redis&lt;/strong&gt; 作为从服务器启动的化，它一旦与 &lt;strong&gt;&lt;em&gt;master 主服务器&lt;/em&gt;&lt;/strong&gt; 建立链接就会清空所有数据进行完整同步，当然新版本的 &lt;strong&gt;redis&lt;/strong&gt; 支持 &lt;strong&gt;SYCN2&lt;/strong&gt; 的半同步。如果是已经建立了 &lt;strong&gt;&lt;em&gt;master/slave&lt;/em&gt;&lt;/strong&gt; 主从同步之后，主服务器会发送 &lt;strong&gt;DEL&lt;/strong&gt; 命令给所有从服务器执行删除操作。&lt;/p&gt;
&lt;h3 id=&quot;redis-lru-算法&quot;&gt;Redis &lt;strong&gt;LRU&lt;/strong&gt; 算法&lt;/h3&gt;
&lt;p&gt;在使用 &lt;strong&gt;redis&lt;/strong&gt; 的时候我们会设置 &lt;strong&gt;maxmemory&lt;/strong&gt; 选项，&lt;strong&gt;64&lt;/strong&gt; 位的默认是 &lt;strong&gt;0&lt;/strong&gt; 不限制。线上的服务器必须要设置的，要不然很有可能导致 &lt;strong&gt;redis&lt;/strong&gt; 宿主服务器直接内存耗尽最后链接都上不去。&lt;/p&gt;
&lt;p&gt;所以基本要设置两个配置：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;maxmemory 最大内存阈值&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;maxmemory-policy 到达阈值的执行策略&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以通过 &lt;strong&gt;&lt;em&gt;CONFIG GET maxmemory/maxmemory-policy&lt;/em&gt;&lt;/strong&gt; 分别查看这两个配置值，也可以通过 &lt;strong&gt;&lt;em&gt;CONFIG SET&lt;/em&gt;&lt;/strong&gt; 去分别配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;maxmemory-policy&lt;/strong&gt; 有一组配置，可以用在很多场景下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;noeviction：客户端尝试执行会让更多内存被使用的命令直接报错&lt;br/&gt;allkeys-lru： 在所有key里执行lru算法&lt;br/&gt;volatile-lru：在所有已经过期的key里执行lru算法&lt;br/&gt;allkeys-random：在所有key里随机回收&lt;br/&gt;volatile-random：在已经过期的key里随机回收&lt;br/&gt;volatile-ttl：回收已经过期的key，并且优先回收存活时间（TTL）较短的键&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于 &lt;strong&gt;cache&lt;/strong&gt; 的命中率可以通过 &lt;strong&gt;info&lt;/strong&gt; 命令查看 键空间的命中率和未命中率。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Stats
keyspace_hits:33
keyspace_misses:5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;maxmemory&lt;/strong&gt; 在到达阈值的时候会采用一定的策略去释放内存，这些策略我们可以根据自己的业务场景来选择，默认是 &lt;strong&gt;noeviction&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;redis LRU&lt;/strong&gt; 算法有一个取样的优化机制，可以通过一定的取样因子来加强回收的 &lt;strong&gt;key&lt;/strong&gt; 的准确度。&lt;strong&gt;&lt;em&gt;CONFIG GET maxmemory-samples&lt;/em&gt;&lt;/strong&gt; 查看取样配置，具体可以参考更加详细的文章。&lt;/p&gt;
&lt;h2 id=&quot;redis-持久化方式&quot;&gt;Redis 持久化方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 本身提供持久化功能，有两种持久化机制，一种是数据持久化 &lt;strong&gt;RDB&lt;/strong&gt; ，一种是命令持久化 &lt;strong&gt;AOF&lt;/strong&gt;，这两种持久化方式各有优缺点，也可以组合使用，一旦组合使用 &lt;strong&gt;redis&lt;/strong&gt; 在载入数据的时候会优先载入 &lt;strong&gt;aof&lt;/strong&gt; 文件，只有当 &lt;strong&gt;AOF&lt;/strong&gt; 持久化关闭的时候才会载入 &lt;strong&gt;rdb&lt;/strong&gt; 文件。&lt;/p&gt;
&lt;h3 id=&quot;rdb-redis-database&quot;&gt;&lt;strong&gt;RDB&lt;/strong&gt; (Redis DataBase)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;RDB&lt;/strong&gt; 是 &lt;strong&gt;redis&lt;/strong&gt; 数据库，&lt;strong&gt;redis&lt;/strong&gt; 会根据一个配置来触发持久化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;

save 900 1
save 300 10
save 60 10000&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;CONFIG GET save
1) &quot;save&quot;
2) &quot;3600 1 300 100 60 10000&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示在多少秒之类的变化次数，一旦达到这个触发条件 redis 将触发持久化动作。redis 在执行持久化的时候有两种模式 &lt;strong&gt;&lt;em&gt;BGSAVE、SAVE&lt;/em&gt;&lt;/strong&gt; 。&lt;strong&gt;BGSAVE&lt;/strong&gt; 是后台保存，&lt;strong&gt;redis&lt;/strong&gt; 会 &lt;strong&gt;fork&lt;/strong&gt; 出一个子进程来处理持久化，不会 &lt;strong&gt;block&lt;/strong&gt; 用户的执行请求。而 &lt;strong&gt;SAVE&lt;/strong&gt; 则会 &lt;strong&gt;block&lt;/strong&gt; 用户执行请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct redisServer {
long long dirty;/* Changes to DB from the last save */
time_t lastsave; /* Unix time of last successful save */
long long dirty_before_bgsave;
pid_t rdb_child_pid;/* PID of RDB saving child */
struct saveparam *saveparams; /* Save points array for RDB */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;struct saveparam {
    time_t seconds;
    int changes;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;redisServer&lt;/strong&gt; 包含的信息很多，其中就包含了有关于 &lt;strong&gt;RDB&lt;/strong&gt; 持久化的信息。&lt;strong&gt;&lt;em&gt;redisServer-&amp;gt;dirty&lt;/em&gt;&lt;/strong&gt; 至上次 &lt;strong&gt;save&lt;/strong&gt; 到目前为止的 &lt;strong&gt;change&lt;/strong&gt; 数。&lt;strong&gt;&lt;em&gt;redisServer-&amp;gt;lastsave&lt;/em&gt;&lt;/strong&gt; 上次 &lt;strong&gt;save&lt;/strong&gt; 时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;saveparam struct&lt;/strong&gt; 保存了我们通过 &lt;strong&gt;save&lt;/strong&gt; 命令设置的参数，&lt;strong&gt;time_t&lt;/strong&gt; 是个 &lt;strong&gt;long&lt;/strong&gt; 时间戳。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef __darwin_time_t     time_t; &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;typedef long    __darwin_time_t;    /* time() */&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {
         for (j = 0; j &amp;lt; server.saveparamslen; j++) {
            struct saveparam *sp = server.saveparams+j;
            if (server.dirty &amp;gt;= sp-&amp;gt;changes &amp;amp;&amp;amp;
                server.unixtime-server.lastsave &amp;gt; sp-&amp;gt;seconds &amp;amp;&amp;amp;
                (server.unixtime-server.lastbgsave_try &amp;gt;
                 REDIS_BGSAVE_RETRY_DELAY ||
                 server.lastbgsave_status == REDIS_OK))
            {
                redisLog(REDIS_NOTICE,&quot;%d changes in %d seconds. Saving...&quot;,
                    sp-&amp;gt;changes, (int)sp-&amp;gt;seconds);
                rdbSaveBackground(server.rdb_filename);
                break;
            }
         }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;redis&lt;/strong&gt; 事件循环会周期性的执行 &lt;strong&gt;serverCron&lt;/strong&gt; 方法，这段代码会循环遍历 &lt;strong&gt;server.saveparams&lt;/strong&gt; 参数链表。&lt;/p&gt;
&lt;p&gt;如果 &lt;strong&gt;server.dirty&lt;/strong&gt; 大于等于 我们参数里配置的变化并且 &lt;strong&gt;&lt;em&gt;server.unixtime-server.lastsave&lt;/em&gt;&lt;/strong&gt; 大于参数里配置的时间并且 &lt;strong&gt;server.unixtime-server.lastbgsave_try&lt;/strong&gt; 减去 &lt;strong&gt;bgsave&lt;/strong&gt; 重试延迟时间或者当前 &lt;strong&gt;server.lastbgsave_status==REDIS_OK&lt;/strong&gt; 则执行 &lt;strong&gt;rdbSaveBackground&lt;/strong&gt; 方法。&lt;/p&gt;
&lt;h3 id=&quot;aof-append-only-file&quot;&gt;&lt;strong&gt;AOF&lt;/strong&gt; (Append-only file)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;AOF&lt;/strong&gt; 持久化是采用对文件进行追加对方式进行，每次追加都是 &lt;strong&gt;redis&lt;/strong&gt; 处理的 命令。有点类似 &lt;strong&gt;&lt;em&gt;command sourcing 命令溯源&lt;/em&gt;&lt;/strong&gt; 的模式。&lt;/p&gt;
&lt;p&gt;只要我们可以将所有的命令按照执行顺序在重放一遍就可以还原最终的 &lt;strong&gt;redis&lt;/strong&gt; 内存状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOF&lt;/strong&gt; 持久化最大的优势是可以缩短数据丢失的间隔，可以做到秒级的丢失率。&lt;strong&gt;RDB&lt;/strong&gt; 会丢失上一个保存周期到目前的所有数据，只要没有触发 &lt;strong&gt;save&lt;/strong&gt; 命令设置的 &lt;strong&gt;&lt;em&gt;save seconds changes&lt;/em&gt;&lt;/strong&gt; 阈值数据就会一直不被持久化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct redisServer {
 /* AOF buffer, written before entering the event loop */
 sds aof_buf;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;struct sdshdr {
    unsigned int len;
    unsigned int free;
    char buf[];
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;aof_buf&lt;/strong&gt; 是命令缓存区，采用 &lt;strong&gt;sds&lt;/strong&gt; 结构缓存，每次当有命令被执行当时候都会写一次到 &lt;strong&gt;aof_buf&lt;/strong&gt; 中。有几个配置用来控制 &lt;strong&gt;AOF&lt;/strong&gt; 持久化的机制。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;appendonly no 
appendfilename &quot;appendonly.aof&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;appendonly&lt;/strong&gt; 用来控制是否开启 &lt;strong&gt;AOF&lt;/strong&gt; 持久化，&lt;strong&gt;appendfilename&lt;/strong&gt; 用来设置 &lt;strong&gt;aof&lt;/strong&gt; 文件名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;appendfsync always
appendfsync everysec
appendfsync no&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;appendfsync&lt;/strong&gt; 用来控制命令刷盘机制。现在操作系统都有文件 &lt;strong&gt;cache/buffer&lt;/strong&gt; 的概念，所有的写入和读取都会走 &lt;strong&gt;cache/buffer&lt;/strong&gt;，并不会每次都同步刷盘，因为这样性能一定会受影响。所以 &lt;strong&gt;redis&lt;/strong&gt; 也提供了这个选项让我们来自己根据业务场景控制。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;always&lt;/strong&gt; ：每次将 &lt;strong&gt;aof_buf&lt;/strong&gt; 命令写入 &lt;strong&gt;aof&lt;/strong&gt; 文件并且执行实时刷盘。&lt;br/&gt;&lt;strong&gt;everysec&lt;/strong&gt; ：每次将 &lt;strong&gt;aof_buf&lt;/strong&gt; 命令写入 &lt;strong&gt;aof&lt;/strong&gt; 文件，但是每隔一秒执行一次刷盘。&lt;br/&gt;&lt;strong&gt;no&lt;/strong&gt; ：每次将 &lt;strong&gt;aof_buf&lt;/strong&gt; 命令写入 &lt;strong&gt;aof&lt;/strong&gt; 文件不执行刷盘，由操作系统来自行控制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;AOF&lt;/strong&gt; 也是采用后台子进程的方式进行，与主进程共享数据空间也就是 &lt;strong&gt;aof_buf&lt;/strong&gt;，但是只要开始了 &lt;strong&gt;AOF&lt;/strong&gt; 子进程之后 &lt;strong&gt;&lt;em&gt;redis 事件循环文件事件处理器&lt;/em&gt;&lt;/strong&gt; 会将之后的命令写入另外一个 &lt;strong&gt;aof_buf&lt;/strong&gt; ，这样就可以做到平滑的切换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AOF&lt;/strong&gt; 会不断的追加命令进 &lt;strong&gt;aof&lt;/strong&gt; 文件，随着时间和并发量的加大 &lt;strong&gt;aof&lt;/strong&gt; 文件会极速膨胀，所以有必要对这个文件大小进行优化。&lt;strong&gt;redis&lt;/strong&gt; 基于 &lt;strong&gt;rewrite&lt;/strong&gt; 重写对文件进行压缩。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;no-appendfsync-on-rewrite no/yes
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;no-appendfsync-on-rewrite&lt;/strong&gt; 控制是否在 &lt;strong&gt;bgrewriteaof&lt;/strong&gt; 的时候还需要进行命令追加，如果追加可能会出现磁盘 &lt;strong&gt;IO&lt;/strong&gt; 跑高现象。&lt;/p&gt;
&lt;p&gt;上面说过，当 &lt;strong&gt;AOF&lt;/strong&gt; 进程在执行的时候原来的事件循环还会正常的追加命令进 &lt;strong&gt;aof&lt;/strong&gt; 文件，同时还会追加命令进另外一个 &lt;strong&gt;aof_buf&lt;/strong&gt; ，用来做新 &lt;strong&gt;aof&lt;/strong&gt; 文件的重写。这是两条并行的动作，如果我们设置成 &lt;strong&gt;yes&lt;/strong&gt; 就不追加原来的 &lt;strong&gt;aof_buf&lt;/strong&gt; 因为新的 &lt;strong&gt;aof&lt;/strong&gt; 文件已经包含了之后进来的命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;auto-aof-rewrite-percentage、auto-aof-rewrite-min-size 64mb&lt;/em&gt;&lt;/strong&gt; 这两个配置前者是文件增长百分比来进行 &lt;strong&gt;rewrite&lt;/strong&gt; ，后者是按照文件大小增长进行 &lt;strong&gt;rewrite&lt;/strong&gt; 。&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jan 2018 01:24:00 +0000</pubDate>
<dc:creator>王清培</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangiqngpei557/p/8364859.html</dc:identifier>
</item>
</channel>
</rss>