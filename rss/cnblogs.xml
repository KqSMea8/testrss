<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring Clould负载均衡重要组件：Ribbon中重要类的用法 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/8648420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/8648420.html</guid>
<description>&lt;p&gt;    Ribbon是Spring Cloud Netflix全家桶中负责负载均衡的组件，它是一组类库的集合。通过Ribbon，程序员能在不涉及到具体实现细节的基础上“透明”地用到负载均衡，而不必在项目里过多地编写实现负载均衡的代码。&lt;/p&gt;
&lt;p&gt;    比如，在某个包含Eureka和Ribbon的集群中，某个服务（可以理解成一个jar包）被部署在多台服务器上，当多个服务使用者同时调用该服务时，这些并发的请求能被用一种合理的策略转发到各台服务器上。&lt;/p&gt;
&lt;p&gt;    事实上，在使用Spring Cloud的其它各种组件时，我们都能看到Ribbon的痕迹，比如Eureka能和Ribbon整合，而在后文里将提到的提供网关功能Zuul组件在转发请求时，也可以整合Ribbon从而达到负载均衡的效果。&lt;/p&gt;
&lt;p&gt;    从代码层面来看，Ribbon有如下三个比较重要的接口。&lt;/p&gt;
&lt;p&gt;    第一，ILoadBalancer，这也叫负载均衡器，通过它，我们能在项目里根据特定的规则合理地转发请求，常见的实现类有BaseLoadBalancer。&lt;/p&gt;
&lt;p&gt;    第二，IRule，这个接口有多个实现类，比如RandomRule和RoundRobinRule，这些实现类具体地定义了诸如“随机“和”轮询“等的负载均衡策略，我们还能重写该接口里的方法来自定义负载均衡的策略。&lt;/p&gt;
&lt;p&gt;在BaseLoadBalancer类里，我们能通过IRule的实现类设置负载均衡的策略，这样该负载均衡器就能据此合理地转发请求。&lt;/p&gt;
&lt;p&gt;    第三，IPing接口，通过该接口，我们能获取到当前哪些服务器是可用的，我们也能通过重写该接口里的方法来自定义判断服务器是否可用的规则。在BaseLoadBalancer类里，我们同样能通过IPing的实现类设置判断服务器是否可用的策略。    &lt;/p&gt;
&lt;h4&gt;1 ILoadBalancer：负载均衡器接口&lt;/h4&gt;
&lt;p&gt;    在Ribbon里，我们还可以通过ILOadBalancer这个接口以基于特定的负载均衡策略来选择服务器。&lt;/p&gt;
&lt;p&gt;    通过下面的ILoadBalancerDemo.java，我们来看下这个接口的基本用法。这个类是放在4.2部分创建的RabbionBasicDemo项目里，代码如下。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import代码&lt;/span&gt;
2    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ILoadBalancerDemo {
&lt;/span&gt;3        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;4            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建ILoadBalancer的对象 &lt;/span&gt;
5             ILoadBalancer loadBalancer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseLoadBalancer();
&lt;/span&gt;6            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个服务器列表&lt;/span&gt;
7               List&amp;lt;Server&amp;gt; myServers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Server&amp;gt;&lt;span&gt;();
&lt;/span&gt;8            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建两个Server对象&lt;/span&gt;
9            Server s1 = &lt;span&gt;new&lt;/span&gt; Server(&quot;ekserver1&quot;,8080&lt;span&gt;);
&lt;/span&gt;10             Server s2 = &lt;span&gt;new&lt;/span&gt; Server(&quot;ekserver2&quot;,8080&lt;span&gt;);
&lt;/span&gt;11            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个server对象放入List类型的myServers对象里   &lt;/span&gt;
12&lt;span&gt;             myServers.add(s1);
&lt;/span&gt;13&lt;span&gt;             myServers.add(s2);
&lt;/span&gt;14            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把myServers放入负载均衡器&lt;/span&gt;
15&lt;span&gt;            loadBalancer.addServers(myServers);
&lt;/span&gt;16            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在for循环里发起10次调用&lt;/span&gt;
17            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;){
&lt;/span&gt;18             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用基于默认的负载均衡规则获得Server类型的对象&lt;/span&gt;
19                Server s = loadBalancer.chooseServer(&quot;default&quot;&lt;span&gt;);
&lt;/span&gt;20             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出IP地址和端口号&lt;/span&gt;
21                System.out.println(s.getHost() + &quot;:&quot; +&lt;span&gt; s.getPort());
&lt;/span&gt;22&lt;span&gt;            }        
&lt;/span&gt;23&lt;span&gt;       }
&lt;/span&gt;24    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     在第5行里，我们创建了BaseLoadBalancer类型的loadBalancer对象，而BaseLoadBalancer是负载均衡器ILoadBalancer接口的实现类。&lt;/p&gt;
&lt;p&gt;    在第6到第13行里，我们创建了两个Server类型的对象，并把它们放入了myServers里，在第15行里，我们把List类型的myServers对象放入了负载均衡器里。&lt;/p&gt;
&lt;p&gt;    在第17到22行的for循环里，我们通过负载均衡器模拟了10次选择服务器的动作，具体而言，是在第19行里，通过loadBalancer的chooseServer方法以默认的负载均衡规则选择服务器，在第21行里，我们是用“打印”这个动作来模拟实际的“使用Server对象处理请求”的动作。&lt;/p&gt;
&lt;p&gt;    上述代码的运行结果如下所示，其中我们能看到，loadBalancer这个负载均衡器把10次请求均摊到了2台服务器上，从中确实能看到 “负载均衡”的效果。&lt;/p&gt;
&lt;p&gt;    第二，IRule，这个接口有多个实现类，比如RandomRule和RoundRobinRule，这些实现类具体地定义了诸如“随机“和”轮询“等的负载均衡策略，我们还能重写该接口里的方法来自定义负载均衡的策略。&lt;/p&gt;
&lt;p&gt;    在BaseLoadBalancer类里，我们能通过IRule的实现类设置负载均衡的策略，这样该负载均衡器就能据此合理地转发请求。&lt;/p&gt;
&lt;p&gt;    第三，IPing接口，通过该接口，我们能获取到当前哪些服务器是可用的，我们也能通过重写该接口里的方法来自定义判断服务器是否可用的规则。在BaseLoadBalancer类里，我们同样能通过IPing的实现类设置判断服务器是否可用的策略。  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1    ekserver2:8080
2    ekserver1:8080
3    ekserver2:8080
4    ekserver1:8080
5    ekserver2:8080
6    ekserver1:8080
7    ekserver2:8080
8    ekserver1:8080
9    ekserver2:8080
10   ekserver1:8080
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2 IRule：定义负载均衡规则的接口&lt;/h4&gt;
&lt;p&gt;    在Ribbon里，我们可以通过定义IRule接口的实现类来给负载均衡器设置相应的规则。在下表里，我们能看到IRule接口的一些常用的实现类。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr&gt;&lt;td width=&quot;154&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;实现类的名字&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;282&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;负载均衡的规则&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;154&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;RandomRule&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;282&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;采用随机选择的策略&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;154&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;RoundRobinRule&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;282&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;采用轮询策略&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;154&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;RetryRule&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;282&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;采用该策略时，会包含重试动作&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;154&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;AvailabilityFilterRule&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;282&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;会过滤些多次连接失败和请求并发数过高的服务器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td width=&quot;154&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;WeightedResponseTimeRule&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;282&quot; readability=&quot;6&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;根据平均响应时间为每个服务器设置一个权重，根据该权重值优先选择平均响应时间较小的服务器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;154&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;ZoneAvoidanceRule&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;282&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;a0&quot; align=&quot;left&quot;&gt;优先把请求分配到和该请求具有相同区域（Zone）的服务器上&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;    在下面的IRuleDemo.java的程序里，我们来看下IRule的基本用法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import代码&lt;/span&gt;
2    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IRuleDemo {
&lt;/span&gt;3        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;4        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请注意这是用到的是BaseLoadBalancer，而不是ILoadBalancer接口&lt;/span&gt;
5        BaseLoadBalancer loadBalancer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseLoadBalancer();
&lt;/span&gt;6            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明基于轮询的负载均衡策略&lt;/span&gt;
7            IRule rule = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RoundRobinRule();
&lt;/span&gt;8        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在负载均衡器里设置策略 &lt;/span&gt;
9&lt;span&gt;            loadBalancer.setRule(rule);
&lt;/span&gt;10            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如下定义3个Server，并把它们放入List类型的集合中&lt;/span&gt;
11            List&amp;lt;Server&amp;gt; myServers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Server&amp;gt;&lt;span&gt;();
&lt;/span&gt;12            Server s1 = &lt;span&gt;new&lt;/span&gt; Server(&quot;ekserver1&quot;,8080&lt;span&gt;);
&lt;/span&gt;13            Server s2 = &lt;span&gt;new&lt;/span&gt; Server(&quot;ekserver2&quot;,8080&lt;span&gt;);
&lt;/span&gt;14            Server s3 = &lt;span&gt;new&lt;/span&gt; Server(&quot;ekserver3&quot;,8080&lt;span&gt;);
&lt;/span&gt;15&lt;span&gt;            myServers.add(s1);
&lt;/span&gt;16&lt;span&gt;            myServers.add(s2);
&lt;/span&gt;17&lt;span&gt;            myServers.add(s3);
&lt;/span&gt;18            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在负载均衡器里设置服务器的List&lt;/span&gt;
19&lt;span&gt;            loadBalancer.addServers(myServers);
&lt;/span&gt;20            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出负载均衡的结果&lt;/span&gt;
21            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;){
&lt;/span&gt;22                Server s = loadBalancer.chooseServer(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;23                System.out.println(s.getHost() + &quot;:&quot; +&lt;span&gt; s.getPort());    
&lt;/span&gt;24&lt;span&gt;          }        
&lt;/span&gt;25&lt;span&gt;        }
&lt;/span&gt;26    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    这段代码和上文里的ILoadBalancerDemo.java很相似，但有如下的差别点。&lt;/p&gt;
&lt;p&gt;    1 在第5行里，我们是通过BaseLoadBalancer这个类而不是接口来定义负载均衡器，原因是该类包含setRule方法。&lt;/p&gt;
&lt;p&gt;    2 在第7行定义了一个基于轮询规则的rule对象，并在第9行里把它设置进负载均衡器。&lt;/p&gt;
&lt;p&gt;    3 在第19行里，我们是把包含3个Server的List对象放入负载均衡器，而不是之前的两个。由于这里存粹是为了演示效果，所以我们就放入一个根本不存在的“ekserver3”服务器。&lt;/p&gt;
&lt;p&gt;    运行该程序后，我们可以看到有10次输出，而且确实是按“轮询”的规则有顺序地输出3个服务器的名字。如果我们把第7行的代码改成如下，那么就会看到 “随机”地输出服务器名。&lt;/p&gt;
&lt;p&gt;    IRule rule = new RandomRule();&lt;/p&gt;

&lt;h4&gt;3  IPing：判断服务器是否可用的接口&lt;/h4&gt;
&lt;p&gt;    在项目里，我们一般会让ILoadBalancer接口自动地判断服务器是否可用（这些业务都封装在Ribbon的底层代码里），此外，我们还可以用Ribbon组件里的IPing接口来实现这个功能。&lt;/p&gt;
&lt;p&gt;    在下面的IRuleDemo.java代码里，我们将演示IPing接口的一般用法。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import代码&lt;/span&gt;
2    &lt;span&gt;class&lt;/span&gt; MyPing &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IPing {
&lt;/span&gt;3        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isAlive(Server server) {
&lt;/span&gt;4             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果服务器名是ekserver2，则返回false&lt;/span&gt;
5            &lt;span&gt;if&lt;/span&gt; (server.getHost().equals(&quot;ekserver2&quot;&lt;span&gt;)) {
&lt;/span&gt;6                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;7&lt;span&gt;            }
&lt;/span&gt;8            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;9&lt;span&gt;        }
&lt;/span&gt;10    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    第2行定义的MyPing类实现了IPing接口，并在第3行重写了其中的isAlive方法。&lt;/p&gt;
&lt;p&gt;    在这个方法里，我们根据服务器名来判断，具体而言，如果名字是ekserver2，则返回false，表示该服务器不可用，否则返回true，表示当前服务器可用。     &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
11    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IRuleDemo {
&lt;/span&gt;12        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;13            BaseLoadBalancer loadBalancer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseLoadBalancer();
&lt;/span&gt;14            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义IPing类型的myPing对象&lt;/span&gt;
15            IPing myPing = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyPing(); 
&lt;/span&gt;16             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在负载均衡器里使用myPing对象&lt;/span&gt;
17&lt;span&gt;            loadBalancer.setPing(myPing);
&lt;/span&gt;18             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同样是创建三个Server对象并放入负载均衡器&lt;/span&gt;
19            List&amp;lt;Server&amp;gt; myServers = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Server&amp;gt;&lt;span&gt;();
&lt;/span&gt;20            Server s1 = &lt;span&gt;new&lt;/span&gt; Server(&quot;ekserver1&quot;, 8080&lt;span&gt;);
&lt;/span&gt;21            Server s2 = &lt;span&gt;new&lt;/span&gt; Server(&quot;ekserver2&quot;, 8080&lt;span&gt;);
&lt;/span&gt;22            Server s3 = &lt;span&gt;new&lt;/span&gt; Server(&quot;ekserver3&quot;, 8080&lt;span&gt;);
&lt;/span&gt;23&lt;span&gt;            myServers.add(s1);
&lt;/span&gt;24&lt;span&gt;            myServers.add(s2);
&lt;/span&gt;25&lt;span&gt;            myServers.add(s3);
&lt;/span&gt;26&lt;span&gt;            loadBalancer.addServers(myServers);
&lt;/span&gt;27             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过for循环多次请求服务器 &lt;/span&gt;
28            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;29                Server s = loadBalancer.chooseServer(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;30                System.out.println(s.getHost() + &quot;:&quot; +&lt;span&gt; s.getPort());
&lt;/span&gt;31&lt;span&gt;            }
&lt;/span&gt;32&lt;span&gt;        }
&lt;/span&gt;33    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在第12行的main函数里，我们在第15行创建了IPing类型的myPing对象，并在第17行把这个对象放入了负载均衡器。通过第18到第26行的代码，我们创建了三个服务器，并把它们也放入负载均衡器。&lt;/p&gt;
&lt;p&gt;    在第28行的for循环里，我们依然是请求并输出服务器名。由于这里的负载均衡器loadBalancer中包含了一个IPing类型的对象，所以在根据策略得到服务器后，会根据myPing里的isActive方法来判断该服务器是否可用。&lt;/p&gt;
&lt;p&gt;    由于在这个方法里，我们定义了ekServer2这台服务器不可用，所以负载均衡器loadBalancer对象始终不会把请求发送到该服务器上，也就是说，在输出结果中，我们不会看到“ekserver2:8080”的输出。&lt;/p&gt;
&lt;p&gt;    从中我们能看到IPing接口的一般用法，我们可以通过重写其中的isAlive方法来定义“判断服务器是否可用“的逻辑，在实际项目里，判断的依据无非是”服务器响应是否时间过长“或”发往该服务器的请求数是否过多“，而这些判断方法都封装在IRule接口以及它的实现类里，所以在一般的场景中我们用到IPing接口。&lt;/p&gt;
&lt;h4&gt;4  预告&amp;amp;版权申明&lt;/h4&gt;
&lt;p&gt;     在本周的后面时间里，我将继续给出用Eureka+Ribbon高可用负载均衡架构的搭建方法。&lt;/p&gt;
&lt;p&gt;     本文内容摘自本人写的专业书籍，转载时请同时引入该版权申明，请勿用于商业用途。&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 23:30:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/8648420.html</dc:identifier>
</item>
<item>
<title>WebGL 3D 工业隧道监控实战 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/8624630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/8624630.html</guid>
<description>&lt;p&gt;监控隧道内的车道堵塞情况、隧道内的车祸现场，在隧道中显示当前车祸位置并在隧道口给与提示等等功能都是非常有必要的。这个隧道 Demo 的主要内容包括：照明、风机、车道指示灯、交通信号灯、情报板、消防、火灾报警、车行横洞、风向仪、微波车检、隧道紧急逃生出口的控制以及事故模拟等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201803/591709-20180322115824909-201529258.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.hightopo.com/demo/tunnel2/index.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/demo/tunnel2/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上图中的各种设备都可以双击，此时 camera 的位置会从当前位置移动到双击的设备的正前方；隧道入口的展示牌会自动轮播，出现事故时会展示牌中的内容会由“限速80，请开车灯”变为“超车道两车追尾，请减速慢行”；两隧道中间的逃生通道上方的指示牌是可以点击的，点击切换为蓝绿色激活状态，两旁的逃生通道门也会打开，再单击指示牌变为灰色，门关闭；还有一个事故现场模拟，双击两旁变压器中其中一个，在隧道内会出现一个“事故现场图标”，单击此图标，出现弹出框显示事故等等等等。&lt;/p&gt;

&lt;h2&gt;场景搭建&lt;/h2&gt;
&lt;p&gt;整个隧道都是基于 3D 场景上绘制的，先来看看怎么搭建 3D 场景：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
dm = &lt;span&gt;new&lt;/span&gt; ht.DataModel();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据容器&lt;/span&gt;
g3d = &lt;span&gt;new&lt;/span&gt; ht.graph3d.Graph3dView(dm);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3d 场景&lt;/span&gt;
g3d.addToDOM();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将场景添加到 body 中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中的 addToDOM 函数，是一个将组件添加到 body 体中的函数的封装，定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
addToDOM = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
         view &lt;/span&gt;= self.getView(),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取组件的底层 div&lt;/span&gt;
         style =&lt;span&gt; view.style;
    document.body.appendChild(view);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将组件底层div添加进body中&lt;/span&gt;
    style.left = '0';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ht 默认将所有的组件的position都设置为absolute绝对定位&lt;/span&gt;
    style.right = '0'&lt;span&gt;;
    style.top &lt;/span&gt;= '0'&lt;span&gt;;
    style.bottom &lt;/span&gt;= '0'&lt;span&gt;;
    window.addEventListener(&lt;/span&gt;'resize', &lt;span&gt;function&lt;/span&gt; () { self.iv(); }, &lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口大小改变事件，调用刷新函数&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;JSON 反序列化&lt;/h2&gt;
&lt;p&gt;整个场景是由名为 隧道1.json 的文件导出而成的，我只需要用代码将 json 文件中的内容转换为我需要的部分即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ht.Default.xhrLoad('./scenes/隧道1.json', &lt;span&gt;function&lt;/span&gt;(text) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;xhrLoad 函数是一个异步加载文件的函数&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; json = ht.Default.parse(text);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将 json 文件中的文本转为我们需要的 json 格式的内容&lt;/span&gt;
    dm.deserialize(json);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反序列化数据容器，解析用于生成对应的Data对象并添加到数据容器 这里相当于把 json 文件中生成的 ht.Node 节点反序列化到数据容器中，这样数据容器中就有这个节点了&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于 xhrLoad 函数是一个异步加载函数，所以如果 dm 数据容器反序列化未完成就直接调用了其中的节点，那么会造成数据获取不到的结果，所以一般来说我是将一些逻辑代码写在这个函数内部，或者给逻辑代码设置 timeout 错开时间差。&lt;/p&gt;
&lt;p&gt;首先，由于数据都是存储在 dm 数据容器中的（通过 dm.add(node) 添加的），所以我们要获取数据除了可以通过 id、tag 等独立的方式，还可以通过遍历数据容器来获取多个元素。由于这个场景比较复杂，模型的面也比较多，鉴于设备配置，我将能 &lt;a href=&quot;http://hightopo.com/guide/guide/core/batch/ht-batch-guide.html&quot; target=&quot;_blank&quot;&gt;Batch&lt;/a&gt; 批量的元素都进行了批量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
dm.each(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.s('front.image') === 'assets/sos电话.png'){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对“电话”进行批量&lt;/span&gt;
        data.s('batch', 'sosBatch'&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.s('all.color') === 'rgba(222,222,222,0.18)') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;逃生通道批量（透明度也会影响性能）&lt;/span&gt;
        data.s('batch', 'emergencyBatch'&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.s('shape3d') === 'models/隧道/摄像头.json' || data.s('shape3d') === 'models/隧道/横洞.json' || data.s('shape3d') === 'models/隧道/卷帘门.json'&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!data.s('shape3d.blend'))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;个别摄像头染色了 不做批量&lt;/span&gt;
            data.s('batch', 'basicBatch');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基础批量什么也不做&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.s('shape3d') === 'models/大型变压器/变压器.json'&lt;span&gt;) {    
        data.s(&lt;/span&gt;'batch', 'tileBatch'&lt;span&gt;);
        data.setToolTip(&lt;/span&gt;'单击漫游，双击车祸地点出现图标'&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.getDisplayName() === '地面'&lt;span&gt;) {
        data.s(&lt;/span&gt;'3d.selectable', &lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置隧道“地面”不可选中&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.s('shape3d') === 'models/隧道/排风.json'&lt;span&gt;) {
        data.s(&lt;/span&gt;'batch', 'fanBatch');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;排风扇的模型比较复杂，所以做批量&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.getDisplayName() === 'arrow') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;隧道两旁的箭头路标&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (data.getTag() === 'arrowLeft') data.s('shape3d.image', 'displays/abc.png'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; data.s('shape3d.image', 'displays/abc2.png'&lt;span&gt;);
        data.s({
            &lt;/span&gt;'shape3d': 'billboard'&lt;span&gt;,
            &lt;/span&gt;'shape3d.image.cache': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存，设置了 cache 的代价是需要设置 invalidateShape3dCachedImage&lt;/span&gt;
            'shape3d.transparent': &lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置这个值，图片上的锯齿就不会太明显了（若图片类型为 json，则设置 shape3d.dynamic.transparent)&lt;/span&gt;
&lt;span&gt;        });
        g3d.invalidateShape3dCachedImage(data);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.getTag() === 'board' || data.getTag() === 'board1') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;隧道入口处的情报板&lt;/span&gt;
        data.a('textRect', [0, 2, 244, 46]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务属性，用来控制文本的位置[x,y,width,height]&lt;/span&gt;
        data.a('limitText', '限速80，请开车灯');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务属性，设置文本内容&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; min = -245&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name = 'board' +&lt;span&gt; data.getId();
        window[name] &lt;/span&gt;= setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            circleFunc(data, window[name], min)&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置情报板中的文字向左滚动，并且当文字全部显示时重复闪烁三次&lt;/span&gt;
        }, 100&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给逃生通道上方的指示板 动态设置颜色&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; infos = ['人行横洞1', '人行横洞2', '人行横洞3', '人行横洞4', '车行横洞1', '车行横洞2', '车行横洞3'&lt;span&gt;];
    infos.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(info) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data.getDisplayName() ===&lt;span&gt; info) {
            data.a(&lt;/span&gt;'emergencyColor', 'rgb(138, 138, 138)'&lt;span&gt;);
        }
    });

    infos &lt;/span&gt;= ['车道指示器', '车道指示器1', '车道指示器2', '车道指示器3'&lt;span&gt;];
    infos.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(info) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data.getDisplayName() ===&lt;span&gt; info) {
            createBillboard(data, &lt;/span&gt;'assets/车道信号-过.png', 'assets/车道信号-过.png', info)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;考虑到性能问题 将六面体变换为 billboard 类型元素&lt;/span&gt;
&lt;span&gt;        }
    });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面有一处设置了 tooltip 文字提示信息，在 3d 中，要显示这个文字提示信息，就需要设置 g3d.enableToolTip() 函数，默认 3d 组件是关闭这个功能的。&lt;/p&gt;
&lt;h2&gt;逻辑代码&lt;/h2&gt;
&lt;h3&gt;情报板滚动条&lt;/h3&gt;
&lt;p&gt;我就直接按照上面代码中提到的方法进行解释，首先是 circleFunc 情报板文字循环移动的函数，在这个函数中我们用到了业务属性 limitText 设置情报板中的文字属性以及 textRect 设置情报板中文字的移动位置属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; circleFunc(data, timer, min) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置情报板中的文字向左滚动，并且当文字全部显示时重复闪烁三次&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; text = data.a('limitText');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前业务属性 limitText 的内容&lt;/span&gt;
    data.a('textRect', [data.a('textRect')[0]-5, 2, 244, 46]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置业务属性 textRect 文本框的坐标和大小&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (parseInt(data.a('textRect')) &amp;lt;=&lt;span&gt; parseInt(min)) {
        data.a(&lt;/span&gt;'textRect', [255, 2, 244, 46&lt;span&gt;]);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.a('textRect')[0] === 0&lt;span&gt;) {
        clearInterval(timer);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testName = 'testTimer' + data.getId();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置多个 timer 是因为能够进入这个函数中的不止一个 data，如果在同一时间多个 data 设置同一个 timer，那肯定只会对最后一个节点进行动画。后面还有很多这种陷阱，要注意&lt;/span&gt;
        window[testName] = setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            index&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data.a('limitText') === '') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果情报板中文本内容为空&lt;/span&gt;
                setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                    data.a(&lt;/span&gt;'limitText', text);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为传入的 text 值&lt;/span&gt;
                }, 100&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                    data.a(&lt;/span&gt;'limitText', ''); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若情报板中的文本内容不为空，则设置为空&lt;/span&gt;
                }, 100&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(index === 11) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重复三次 &lt;/span&gt;
&lt;span&gt;                clearInterval(window[testName]);
                data.a(&lt;/span&gt;'limitText'&lt;span&gt;, text);
            }
        }, &lt;/span&gt;100&lt;span&gt;);

        setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            timer &lt;/span&gt;= setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                circleFunc(data, timer, min) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调函数&lt;/span&gt;
            }, 100&lt;span&gt;);
        }, &lt;/span&gt;1500&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于 WebGL 对浏览器的要求不低，为了能尽量多的适应各大浏览器，我们将所有的“道路指示器” ht.Node 类型的六面体全部换成 billboard 类型的节点，性能能提升不少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201803/591709-20180322180150108-1553868583.png&quot; alt=&quot;&quot; width=&quot;82&quot; height=&quot;80&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设置 billboard 的方法很简单，获取当前的六面体节点，然后给这些节点设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;node.s({
    &lt;/span&gt;'shape3d': 'billboard'&lt;span&gt;,
    &lt;/span&gt;'shape3d.image'&lt;span&gt;: imageUrl,
    &lt;/span&gt;'shape3d.image.cache': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
});
g3d.invalidateShape3dCachedImage(node); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还记得用 shape3d.image.cache 的代价么？&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，因为 billboard 不能双面显示不同的图片，只是一个“面”，所以我们还得在这个节点的位置创建另一个节点，在这个节点的“背面”显示图片，并且跟这个节点的配置一模一样，不过位置要稍稍偏移一点。&lt;/p&gt;
&lt;h3&gt;Camera 缓慢偏移&lt;/h3&gt;
&lt;p&gt;其他动画部分比较简单，我就不在这里多说了，这里有一个双击节点能将视线从当前 camera 位置移动到双击节点正前方的位置的动画我提一下。我封装了两个函数 setEye 和 setCenter，分别用来设置 camera 的位置和目标位置的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; setCenter(center, finish) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置“目标”位置&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; c = g3d.getCenter().slice(0), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前“目标”位置，为一个数组，而 getCenter 数组会在视线移动的过程中不断变化，所以我们先拷贝一份&lt;/span&gt;
        dx = center[0] - c[0], &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前x轴位置和目标位置的差值&lt;/span&gt;
        dy = center[1] - c[1&lt;span&gt;],
        dz &lt;/span&gt;= center[2] - c[2&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动 500 毫秒的动画过度&lt;/span&gt;
&lt;span&gt;    ht.Default.startAnim({
        duration: &lt;/span&gt;500&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(v, t) {
            g3d.setCenter([ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将“目标”位置缓慢从当前位置移动到设置的位置处&lt;/span&gt;
                c[0] + dx *&lt;span&gt; v,
                c[&lt;/span&gt;1] + dy *&lt;span&gt; v,
                c[&lt;/span&gt;2] + dz *&lt;span&gt; v
            ]);
        }
    });
};

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; setEye(eye, finish) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置“眼睛”位置&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; e = g3d.getEye().slice(0),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前“眼睛”位置，为一个数组，而 getEye 数组会在视线移动的过程中不断变化，所以我们先拷贝一份&lt;/span&gt;
        dx = eye[0] - e[0&lt;span&gt;],
        dy &lt;/span&gt;= eye[1] - e[1&lt;span&gt;],
        dz &lt;/span&gt;= eye[2] - e[2&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动 500 毫秒的动画过度&lt;/span&gt;
&lt;span&gt;    ht.Default.startAnim({
        duration: &lt;/span&gt;500&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(v, t) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将 Camera 位置缓慢地从当前位置移动到设置的位置&lt;/span&gt;
&lt;span&gt;            g3d.setEye([
                e[&lt;/span&gt;0] + dx *&lt;span&gt; v,
                e[&lt;/span&gt;1] + dy *&lt;span&gt; v,
                e[&lt;/span&gt;2] + dz *&lt;span&gt; v
            ]);
        }
    });
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后期我们要设置的时候就直接调用这两个函数，并设置参数为我们目标的位置即可。比如我这个场景中的各个模型，由于不同视角对应的各个模型的旋转角度也不同，我只能找几个比较有代表性的 0°，90°，180°以及360° 这四种比较典型的角度了。所以绘制 3D 场景的时候，我也尽量设置节点的旋转角度为这四个中的一种（而且对于我们这个场景来说，基本上只在 y 轴上旋转了）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; p3 = e.data.p3(), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事件对象的三维坐标&lt;/span&gt;
    s3 = e.data.s3(),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事件对象的三维尺寸&lt;/span&gt;
    r3 = e.data.r3();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取事件对象的三维旋转值&lt;/span&gt;
&lt;span&gt;
setCenter(p3);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置“目标”位置为当前事件对象的三维坐标值&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (r3[1] !== 0) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果节点的 y 轴旋转值 不为 0&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (parseFloat(r3[1].toFixed(5)) === parseFloat(-3.14159)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浮点负数得做转换才能进行比值&lt;/span&gt;
        setEye([p3[0], p3[1]+s3[1], p3[2] * Math.abs(r3[1]*2.3/6)]);//设置camera 的目标位置
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (parseFloat(r3[1].toFixed(4)) === parseFloat(-1.5708&lt;span&gt;)) {
        setEye([p3[&lt;/span&gt;0] * Math.abs(r3[1]/1.8), p3[1]+s3[1], p3[2]]);
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        setEye([p3[&lt;/span&gt;0] *r3[1], p3[1]+s3[1], p3[2&lt;span&gt;]]);
    }
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    setEye([p3[&lt;/span&gt;0], p3[1]+s3[1]*2, p3[2]+1000&lt;span&gt;]);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;事故模拟现场&lt;/h3&gt;
&lt;p&gt;最后来说说模拟的事故现场吧，这段还是比较接近实际项目的。操作流程如下：双击“变压器”--&amp;gt;隧道中间某个部分会出现一个“事故现场”图标--&amp;gt;单击图标，弹出对话框，显示当前事故信息--&amp;gt;点击确定，则事故现场之前的灯都显示为红色×，并且隧道入口的情报板上的文字显示为“超车道两车追尾，请减速慢行”--&amp;gt;再双击一次“变压器”，场景恢复事故之前的状态。&lt;/p&gt;
&lt;p&gt;在 HT 中，可通过 Graph3dView#addInteractorListener（简写为 mi）来监听交互过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
g3d.addInteractorListener(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e.kind === 'doubleClickData'&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.data.getTag() === 'jam') &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有“事故”图标节点存在&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (e.data.s('shape3d') === 'models/大型变压器/变压器.json') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果双击对象是变压器&lt;/span&gt;
            index++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jam = dm.getDataByTag('jam');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过唯一标识tag标签获取“事故”图标节点对象&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(index === 1&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jam = dm.getDataByTag('jam'&lt;span&gt;);
                jam.s({
                    &lt;/span&gt;'3d.visible': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点在 3d 上可见&lt;/span&gt;
                    'shape3d': 'billboard',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置节点为 billboard 类型&lt;/span&gt;
                    'shape3d.image': 'assets/车祸.png', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 billboard 的显示图片&lt;/span&gt;
                    'shape3d.image.cache': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 billboard 图片是否缓存&lt;/span&gt;
                    'shape3d.autorotate': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否始终面向镜头&lt;/span&gt;
                    'shape3d.fixSizeOnScreen': [30, 30],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认保持图片原本大小，设置为数组模式则可以设置图片显示在界面上的大小&lt;/span&gt;
&lt;span&gt;                });
                g3d.invalidateShape3dCachedImage(jam);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cache 的代价是节点需要设置这个函数&lt;/span&gt;
&lt;span&gt;             }
             &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                 jam.s({
                     &lt;/span&gt;'3d.visible': &lt;span&gt;false&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二次双击变压器就将所有一切恢复“事故”之前的状态&lt;/span&gt;
&lt;span&gt;                });
                dm.each(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p3 =&lt;span&gt; data.p3();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p3[2] &amp;lt; jam.p3()[2]) &amp;amp;&amp;amp; data.getDisplayName() === '车道指示器1'&lt;span&gt;) {
                        data.s(&lt;/span&gt;'shape3d.image', 'assets/车道信号-过.png'&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data.getTag() === 'board1'&lt;span&gt;) {
                        data.a(&lt;/span&gt;'limitText', '限速80，请开车灯'&lt;span&gt;);
                    }
                });
                index &lt;/span&gt;= 0&lt;span&gt;;
            }
                        
        }
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 既然“事故”节点图标出现了，接着点击图标出现“事故信息弹出框”，监听事件同样是在 mi（addInteractorListener）中，但是这次监听的是单击事件，我们知道，监听双击事件时会触发一次单击事件，为了避免这种情况，我在单击事件里面做了延时：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e.kind === 'clickData'){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击图元&lt;/span&gt;
    timer = setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        clearTimeout(timer);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.data.getTag() === 'jam') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是“事故”图标节点&lt;/span&gt;
            createDialog(e.data);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个对话框&lt;/span&gt;
&lt;span&gt;        }
    }, &lt;/span&gt;200&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的双击事件中我没有 clearTimeout，怕顺序问题给大家造成困扰，要记得加一下。&lt;/p&gt;
&lt;p&gt;弹出框如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201803/591709-20180322224048072-262159732.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个弹出框是由两个 ht.widget.FormPane 表单构成的，左边的表单只有一行，行高为 140，右边的表单是由 5 行构成的，点击确定，则“事故”图标节点之前的道路指示灯都换成红色×的图标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; createForm4(node, dialog) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹出框右边的表单&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; form = &lt;span&gt;new&lt;/span&gt; ht.widget.FormPane();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表单组件&lt;/span&gt;
    form.setWidth(200);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置表单组件的宽&lt;/span&gt;
    form.setHeight(200);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置表单组件的高&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; view = form.getView();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取表单组件的底层 div &lt;/span&gt;
    document.body.appendChild(view);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将表单组件添加到 body 中&lt;/span&gt;

    &lt;span&gt;var&lt;/span&gt; infos =&lt;span&gt; [
        &lt;/span&gt;'编辑框内容为：2辆'&lt;span&gt;,
        &lt;/span&gt;'编辑框内容为：客车-客车'&lt;span&gt;,
        &lt;/span&gt;'编辑框内容为：无起火'&lt;span&gt;,
        &lt;/span&gt;'编辑框内容为：超车道'&lt;span&gt;
    ];
    infos.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(info) {
        form.addRow([ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向表单中添加行&lt;/span&gt;
&lt;span&gt;            info
        ], [&lt;/span&gt;0.1]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个参数为行宽度，小于1的值为相对值&lt;/span&gt;
&lt;span&gt;    });
    
    form.addRow([
        {
            button: {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一行的“确认”按钮&lt;/span&gt;
                label: '确认'&lt;span&gt;,
                onClicked: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;() {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按钮点击事件触发&lt;/span&gt;
                    dialog.hide();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;隐藏对话框&lt;/span&gt;
                    dm.each(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p3 =&lt;span&gt; data.p3();
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p3[2] &amp;lt; node.p3()[2]) &amp;amp;&amp;amp; data.getDisplayName() === '车道指示器1') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变“车道指示器”的显示图片为红色×，这里我是根据“事故”图标节点的坐标来判断“车道显示器”是在前还是在后的&lt;/span&gt;
                            data.s('shape3d.image', 'assets/车道信号-禁止.png'&lt;span&gt;);
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data.getTag() === 'board1') {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将隧道口的情报板上的文字替换&lt;/span&gt;
                            data.a('limitText', '超车道两车追尾，请减速慢行'&lt;span&gt;);
                        }
                    });
                }
            }
        }
    ], [&lt;/span&gt;0.1&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; form;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个工业隧道的 Demo 是我通过几天不断地完善完善而成的，可能还是有不足的地方，但是总体来说我是挺满意的了，可能之后还会继续完善，也得靠大家不断地给我意见和建议，我只希望在自己努力的同时也可以帮助到别人。整个 Demo 中，我主要遇到了两个问题，一个是我在代码中提到过的设置 timer 的问题，多个节点如果同时用一个 timer，那就只有最后一个节点能够显示出 timer 的效果；另一个是 getEye 和 getCenter 的问题，这两个值都是在不断变化的，所以得先拷贝一份数据，再进行数据的变换。&lt;/p&gt;

</description>
<pubDate>Sun, 25 Mar 2018 23:30:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/8624630.html</dc:identifier>
</item>
<item>
<title>JDK1.8源码(四)——java.util.Arrays 类 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/8616122.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/8616122.html</guid>
<description>&lt;p&gt;　　java.util.Arrays 类是 JDK 提供的一个工具类，用来处理数组的各种方法，而且每个方法基本上都是静态方法，能直接通过类名Arrays调用。&lt;/p&gt;
&lt;h3&gt;1、asList&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt;&lt;span&gt; asList(T... a) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(a);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　作用是返回由指定数组支持的&lt;strong&gt;固定大小列表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　注意：这个方法返回的 ArrayList 不是我们常用的集合类 java.util.ArrayList。这里的 ArrayList 是 Arrays 的一个内部类 java.util.Arrays.ArrayList。这个内部类有如下属性和方法：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201803/1120165-20180321135927416-748309816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b41d4a85-f614-42ac-80f6-3dbe35200c27')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_b41d4a85-f614-42ac-80f6-3dbe35200c27&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b41d4a85-f614-42ac-80f6-3dbe35200c27&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('b41d4a85-f614-42ac-80f6-3dbe35200c27',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b41d4a85-f614-42ac-80f6-3dbe35200c27&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArrayList&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractList&amp;lt;E&amp;gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RandomAccess, java.io.Serializable
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = -2764017481108945198L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; E[] a;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        ArrayList(E[] array) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (array==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             a =&lt;span&gt; array;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.length;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object[] toArray() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a.clone();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T[] toArray(T[] a) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; size();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (a.length &amp;lt;&lt;span&gt; size)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; Arrays.copyOf(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.a, size,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                                      (Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; T[]&amp;gt;&lt;span&gt;) a.getClass());
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             System.arraycopy(&lt;span&gt;this&lt;/span&gt;.a, 0, a, 0&lt;span&gt;, size);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (a.length &amp;gt;&lt;span&gt; size)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 a[size] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; E get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; a[index];
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; E set(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             E oldValue =&lt;span&gt; a[index];
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             a[index] =&lt;span&gt; element;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(Object o) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (o==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;a.length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (a[i]==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;a.length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(a[i]))
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(Object o) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; indexOf(o) != -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;①、返回的 ArrayList 数组是一个定长列表，我们只能对其进行查看或者修改，但是不能进行添加或者删除操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过源码我们发现该类是没有add()或者remove() 这样的方法的，如果对其进行增加或者删除操作，都会调用其父类 AbstractList 对应的方法，而追溯父类的方法最终会抛出 UnsupportedOperationException 异常。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; String[] str = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; List&amp;lt;String&amp;gt; listStr =&lt;span&gt; Arrays.asList(str);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; listStr.set(1, &quot;e&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以进行修改&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; System.out.println(listStr.toString());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[a, e, c]&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; listStr.add(&quot;a&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加元素会报错 java.lang.UnsupportedOperationException &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201803/1120165-20180321142251208-1448605579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、引用类型的数组和基本类型的数组区别&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; String[] str = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; List listStr =&lt;span&gt; Arrays.asList(str);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; System.out.println(listStr.size());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] i = {1,2,3&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; List listI =&lt;span&gt; Arrays.asList(i);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; System.out.println(listI.size());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的结果第一个listStr.size()==3，而第二个 listI.size()==1。这是为什么呢？&lt;/p&gt;
&lt;p&gt;　　我们看源码，在 Arrays.asList 中，方法声明为  &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; asList(T... a)。该方法接收一个可变参数，并且这个可变参数类型是作为泛型的参数。我们知道基本数据类型是不能作为泛型的参数的，但是数组是引用类型，所以数组是可以泛型化的，于是 int[] 作为了整个参数类型，而不是 int 作为参数类型。&lt;/p&gt;
&lt;p&gt;　　所以将上面的方法泛型化补全应该是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; String[] str = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; List&amp;lt;String&amp;gt; listStr =&lt;span&gt; Arrays.asList(str);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; System.out.println(listStr.size());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] i = {1,2,3&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;[]&amp;gt; listI = Arrays.asList(i);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这里List参数为 int[] ，而不是 int&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; System.out.println(listI.size());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; Integer[] in = {1,2,3&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; List&amp;lt;Integer&amp;gt; listIn = Arrays.asList(in);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里参数为int的包装类Integer，所以集合长度为3&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; System.out.println(listIn.size());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;③、返回的列表ArrayList里面的元素都是引用，不是独立出来的对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; String[] str = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; List&amp;lt;String&amp;gt; listStr =&lt;span&gt; Arrays.asList(str);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行更新操作前&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; System.out.println(Arrays.toString(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[a, b, c]&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; listStr.set(0, &quot;d&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将第一个元素a改为d
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行更新操作后&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; System.out.println(Arrays.toString(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[d, b, c]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的Arrays.toString()方法就是打印数组的内容，后面会介绍。我们看修改集合的内容，原数组的内容也变化了，所以这里传入的是引用类型。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;④、已知数组数据，如何快速获取一个可进行增删改查的列表List？&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; String[] str = {&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; List&amp;lt;String&amp;gt; listStr = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;(Arrays.asList(str));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; listStr.add(&quot;d&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; System.out.println(listStr.size());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的ArrayList 集合类后面我们会详细讲解，大家目前只需要知道有这种用法即可。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;⑤、Arrays.asList() 方法使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Arrays工具类提供了一个方法asList, 使用该方法可以将一个变长参数或者数组转换成List 。但是，生成的List的长度是固定的；能够进行修改操作（比如，修改某个位置的元素）；不能执行影响长度的操作（如add、remove等操作），否则会抛出UnsupportedOperationException异常。&lt;/p&gt;
&lt;p&gt;　　所以&lt;strong&gt; Arrays.asList 比较适合那些已经有数组数据或者一些元素，而需要快速构建一个List，只用于读取操作，而不进行添加或删除操作的场景。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;2、sort&lt;/h3&gt;
&lt;p&gt;　　该方法是用于数组排序，在 Arrays 类中有该方法的一系列重载方法，能对7种基本数据类型，包括 byte,char,double,float,int,long,short 等都能进行排序，还有 Object 类型（实现了Comparable接口），以及比较器 Comparator 。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201803/1120165-20180321150243908-2093552626.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、基本类型的数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;这里我们以 int[ ] 为例看看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] num = {1,3,8,5,2,4,6,7&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;Arrays.sort(num);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; System.out.println(Arrays.toString(num));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1, 2, 3, 4, 5, 6, 7, 8]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过调用 sort(int[] a) 方法，将原数组按照升序的顺序排列。下面我们通过源码看看是如何实现排序的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a) {
        DualPivotQuicksort.sort(a, &lt;/span&gt;0, a.length - 1, &lt;span&gt;null&lt;/span&gt;, 0, 0&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在 Arrays.sort 方法内部调用 DualPivotQuicksort.sort 方法，这个方法的源码很长，分别对于数组的长度进行了各种算法的划分，包括快速排序，插入排序，冒泡排序都有使用。详细源码可以参考&lt;a href=&quot;https://www.cnblogs.com/yuxiaofei93/p/5722714.html&quot; target=&quot;_blank&quot;&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、对象类型数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　该类型的数组进行排序可以实现 Comparable 接口，重写 compareTo 方法进行排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; String[] str = {&quot;a&quot;,&quot;f&quot;,&quot;c&quot;,&quot;d&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;Arrays.sort(str);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; System.out.println(Arrays.toString(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[a, c, d, f]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　String 类型实现了 Comparable 接口，内部的 compareTo 方法是按照字典码进行比较的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;③、没有实现Comparable接口的，可以通过Comparator实现排序&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Person[] p = &lt;span&gt;new&lt;/span&gt; Person[]{&lt;span&gt;new&lt;/span&gt; Person(&quot;zhangsan&quot;,22),&lt;span&gt;new&lt;/span&gt; Person(&quot;wangwu&quot;,11),&lt;span&gt;new&lt;/span&gt; Person(&quot;lisi&quot;,33&lt;span&gt;)};
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; Arrays.sort(p,&lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Person&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Person o1, Person o2) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(o1 == &lt;span&gt;null&lt;/span&gt; || o2 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; o1.getPage()-&lt;span&gt;o2.getPage();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;});    
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; System.out.println(Arrays.toString(p));
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、binarySearch&lt;/h3&gt;
&lt;p&gt;　　用二分法查找数组中的某个元素。该方法和 sort 方法一样，适用于各种基本数据类型以及对象。&lt;/p&gt;
&lt;p&gt;　　注意：二分法是对以及&lt;strong&gt;有序的数组&lt;/strong&gt;进行查找（比如先用Arrays.sort()进行排序，然后调用此方法进行查找）。找到元素返回下标，没有则返回 -1&lt;/p&gt;
&lt;p&gt;　　实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] num = {1,3,8,5,2,4,6,7&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;Arrays.sort(num);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; System.out.println(Arrays.toString(num));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1, 2, 3, 4, 5, 6, 7, 8]&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; System.out.println(Arrays.binarySearch(num, 2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回元素的下标 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体源码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5840f288-b070-4437-9617-5d7f01358783')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_5840f288-b070-4437-9617-5d7f01358783&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5840f288-b070-4437-9617-5d7f01358783&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5840f288-b070-4437-9617-5d7f01358783',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5840f288-b070-4437-9617-5d7f01358783&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; binarySearch(&lt;span&gt;int&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; binarySearch0(a, 0&lt;span&gt;, a.length, key);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; binarySearch0(&lt;span&gt;int&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt; toIndex,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; low =&lt;span&gt; fromIndex;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; high = toIndex - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (low &amp;lt;=&lt;span&gt; high) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; mid = (low + high) &amp;gt;&amp;gt;&amp;gt; 1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取中间值下标&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; midVal = a[mid];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取中间值&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (midVal &amp;lt;&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             low = mid + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (midVal &amp;gt;&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             high = mid - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid; 
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -(low + 1&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;4、copyOf&lt;/h3&gt;
&lt;p&gt;　　拷贝数组元素。底层采用 System.arraycopy() 实现，这是一个native方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; arraycopy(Object src,  &lt;span&gt;int&lt;/span&gt;&lt;span&gt;  srcPos,
                                        Object dest, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; destPos,
                                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　src:源数组&lt;/p&gt;
&lt;p&gt;　　srcPos:源数组要复制的起始位置&lt;/p&gt;
&lt;p&gt;　　dest:目的数组&lt;/p&gt;
&lt;p&gt;　　destPos:目的数组放置的起始位置&lt;/p&gt;
&lt;p&gt;　　length:复制的长度&lt;/p&gt;
&lt;p&gt;　　注意：src 和 dest都必须是同类型或者可以进行转换类型的数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;[] num1 = {1,2,3&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] num2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[3&lt;span&gt;];
System.arraycopy(num1, &lt;/span&gt;0, num2, 0&lt;span&gt;, num1.length);
System.out.println(Arrays.toString(num2));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[1, 2, 3]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; original 源数组
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; newLength //返回新数组的长度
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] copyOf(&lt;span&gt;int&lt;/span&gt;[] original, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; newLength) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] copy = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[newLength];
        System.arraycopy(original, &lt;/span&gt;0, copy, 0&lt;span&gt;,
                         Math.min(original.length, newLength));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; copy;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5、equals 和 deepEquals&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;①、equals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　equals 用来比较两个数组中对应位置的每个元素是否相等。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1120165/201803/1120165-20180322101515906-4885028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　八种基本数据类型以及对象都能进行比较。&lt;/p&gt;
&lt;p&gt;　　我们先看看 int类型的数组比较源码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('1b4d9c31-8079-4010-af32-fb84414f76b5')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_1b4d9c31-8079-4010-af32-fb84414f76b5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1b4d9c31-8079-4010-af32-fb84414f76b5&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('1b4d9c31-8079-4010-af32-fb84414f76b5',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1b4d9c31-8079-4010-af32-fb84414f76b5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; equals(&lt;span&gt;int&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a2) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (a==a2)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组引用相等，则里面的元素一定相等&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (a==&lt;span&gt;null&lt;/span&gt; || a2==&lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个数组其中一个为null，都返回false&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; a.length;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (a2.length != length)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个数组长度不等，返回false&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;length; i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过for循环依次比较数组中每个元素是否相等&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (a[i] !=&lt;span&gt; a2[i])
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　在看对象数组的比较：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c881214b-dd31-4d91-878d-747ba8565cc3')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_c881214b-dd31-4d91-878d-747ba8565cc3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c881214b-dd31-4d91-878d-747ba8565cc3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c881214b-dd31-4d91-878d-747ba8565cc3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c881214b-dd31-4d91-878d-747ba8565cc3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object[] a, Object[] a2) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (a==&lt;span&gt;a2)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (a==&lt;span&gt;null&lt;/span&gt; || a2==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; a.length;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (a2.length !=&lt;span&gt; length)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             Object o1 =&lt;span&gt; a[i];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             Object o2 =&lt;span&gt; a2[i];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!(o1==&lt;span&gt;null&lt;/span&gt; ? o2==&lt;span&gt;null&lt;/span&gt;&lt;span&gt; : o1.equals(o2)))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　基本上也是通过 equals 来判断。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、deepEquals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;也是用来比较两个数组的元素是否相等，不过 deepEquals 能够进行比较多维数组，而且是任意层次的嵌套数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
         String[][] name1 = {{ &quot;G&quot;,&quot;a&quot;,&quot;o&quot; },{ &quot;H&quot;,&quot;u&quot;,&quot;a&quot;,&quot;n&quot;},{ &quot;j&quot;,&quot;i&quot;,&quot;e&quot;&lt;span&gt;}};  
         String[][] name2 &lt;/span&gt;= {{ &quot;G&quot;,&quot;a&quot;,&quot;o&quot; },{ &quot;H&quot;,&quot;u&quot;,&quot;a&quot;,&quot;n&quot;},{ &quot;j&quot;,&quot;i&quot;,&quot;e&quot;&lt;span&gt;}};
         System.out.println(Arrays.equals(name1,name2));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; false  &lt;/span&gt;
         System.out.println(Arrays.deepEquals(name1,name2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6、fill&lt;/h3&gt;
&lt;p&gt;　　该系列方法用于给数组赋值，并能指定某个范围赋值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;给a数组所有元素赋值 val&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fill(&lt;span&gt;int&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, len = a.length; i &amp;lt; len; i++&lt;span&gt;)
            a[i] &lt;/span&gt;=&lt;span&gt; val;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给从 fromIndex 开始的下标，toIndex-1结尾的下标都赋值 val,左闭右开&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fill(&lt;span&gt;int&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt; toIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
        rangeCheck(a.length, fromIndex, toIndex);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断范围是否合理&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = fromIndex; i &amp;lt; toIndex; i++&lt;span&gt;)
            a[i] &lt;/span&gt;=&lt;span&gt; val;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7、toString 和 deepToString&lt;/h3&gt;
&lt;p&gt;　　toString 用来打印一维数组的元素，而 deepToString 用来打印多层次嵌套的数组元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('56104f46-e2f2-49f3-81d1-993c8ec5ef2b')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_56104f46-e2f2-49f3-81d1-993c8ec5ef2b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_56104f46-e2f2-49f3-81d1-993c8ec5ef2b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('56104f46-e2f2-49f3-81d1-993c8ec5ef2b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_56104f46-e2f2-49f3-81d1-993c8ec5ef2b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String toString(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] a) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;null&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; iMax = a.length - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (iMax == -1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &quot;[]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         StringBuilder b = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         b.append('['&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; ; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            b.append(a[i]);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; iMax)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; b.append(']'&lt;span&gt;).toString();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             b.append(&quot;, &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;参考文档：https://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 23:21:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/8616122.html</dc:identifier>
</item>
<item>
<title>上周热点回顾（3.19-3.25） - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8648406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8648406.html</guid>
<description>[unable to retrieve full-text content]热点随笔： · 不谈面试题，谈谈招聘时我喜欢见到的特质（dino.c）· ASP.NET Core 2.0 : 七.一张图看透启动背后的秘密（FlyLolo）· 用Node.js写爬虫，撸羞羞的图片（阿尔卑斯de秘密）· 值得 .NET 开发者了解的15个特性（葡萄城控件技术团队）· Java VS</description>
<pubDate>Sun, 25 Mar 2018 22:48:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/8648406.html</dc:identifier>
</item>
<item>
<title>在 Rolling Update 中使用 Health Check - 每天5分钟玩转 Docker 容器技术（146） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8642831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8642831.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一节讨论了 Health Check 在 Scale Up 中的应用，Health Check 另一个重要的应用场景是 Rolling Update。试想一下下面的情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现有一个正常运行的多副本应用，接下来对应用进行更新（比如使用更高版本的 image），Kubernetes 会启动新副本，然后发生了如下事件：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;正常情况下新副本需要 10 秒钟完成准备工作，在此之前无法响应业务请求。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;但由于人为配置错误，副本始终无法完成准备工作（比如无法连接后端数据库）。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;先别继续往下看，现在请花一分钟思考这个问题：如果没有配置 Health Check，会出现怎样的情况？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为新副本本身没有异常退出，默认的 Health Check 机制会认为容器已经就绪，进而会逐步用新副本替换现有副本，其结果就是：当所有旧副本都被替换后，整个应用将无法处理请求，无法对外提供服务。如果这是发生在重要的生产系统上，后果会非常严重。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果正确配置了 Health Check，新副本只有通过了 Readiness 探测，才会被添加到 Service；如果没有通过探测，现有副本不会被全部替换，业务仍然正常进行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面通过例子来实践 Health Check 在 Rolling Update 中的应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;用如下配置文件 &lt;/span&gt;&lt;code&gt;&lt;span&gt;app.v1.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 模拟一个 10 副本的应用：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180325065500814-1844011313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10 秒后副本能够通过 Readiness 探测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180325065520043-1362266307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来滚动更新应用，配置文件 &lt;/span&gt;&lt;code&gt;&lt;span&gt;app.v2.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180325065551540-486985762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;很显然，由于新副本中不存在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/tmp/healthy&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，是无法通过 Readiness 探测的。验证如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180325065619370-1255227882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个截图包含了大量的信息，值得我们详细分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;先关注 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl get pod&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 输出：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从 Pod 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;AGE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 栏可判断，最后 5 个 Pod 是新副本，目前处于 NOT READY 状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;旧副本从最初 10 个减少到 8 个。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;再来看 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl get deployment app&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的输出：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;DESIRED&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 10 表示期望的状态是 10 个 READY 的副本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;CURRENT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 13 表示当前副本的总数：即 8 个旧副本 + 5 个新副本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;UP-TO-DATE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 5 表示当前已经完成更新的副本数：即 5 个新副本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;AVAILABLE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 8 表示当前处于 READY 状态的副本数：即 8个旧副本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;在我们的设定中，新副本始终都无法通过 Readiness 探测，所以这个状态会一直保持下去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面我们模拟了一个滚动更新失败的场景。不过幸运的是：Health Check 帮我们屏蔽了有缺陷的副本，同时保留了大部分旧副本，业务没有因更新失败受到影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们要回答：为什么新创建的副本数是 5 个，同时只销毁了 2 个旧副本？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;原因是：滚动更新通过参数 &lt;/span&gt;&lt;code&gt;&lt;span&gt;maxSurge&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;maxUnavailable&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来控制副本替换的数量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;maxSurge&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;此参数控制滚动更新过程中副本总数的超过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DESIRED&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的上限。&lt;/span&gt;&lt;code&gt;&lt;span&gt;maxSurge&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可以是具体的整数（比如 3），也可以是百分百，向上取整。&lt;/span&gt;&lt;code&gt;&lt;span&gt;maxSurge&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 默认值为 25%。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在上面的例子中，&lt;/span&gt;&lt;code&gt;&lt;span&gt;DESIRED&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为 10，那么副本总数的最大值为：&lt;br/&gt;roundUp(10 + 10 * 25%) = 13&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以我们看到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CURRENT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 就是 13。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;maxUnavailable&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;此参数控制滚动更新过程中，不可用的副本相占 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DESIRED&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的最大比例。 &lt;/span&gt;&lt;code&gt;&lt;span&gt;maxUnavailable&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可以是具体的整数（比如 3），也可以是百分百，向下取整。&lt;/span&gt;&lt;code&gt;&lt;span&gt;maxUnavailable&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 默认值为 25%。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在上面的例子中，&lt;/span&gt;&lt;code&gt;&lt;span&gt;DESIRED&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为 10，那么可用的副本数至少要为：&lt;br/&gt;10 - roundDown(10 * 25%) = 8&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以我们看到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;AVAILABLE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 就是 8。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;maxSurge&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 值越大，初始创建的新副本数量就越多；&lt;/span&gt;&lt;code&gt;&lt;span&gt;maxUnavailable&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 值越大，初始销毁的旧副本数量就越多。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;理想情况下，我们这个案例滚动更新的过程应该是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot; list-paddingleft-2&quot; readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;首先创建 3 个新副本使副本总数达到 13 个。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;然后销毁 2 个旧副本使可用的副本数降到 8 个。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;当这 2 个旧副本成功销毁后，可再创建 2 个新副本，使副本总数保持为 13 个。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;当新副本通过 Readiness 探测后，会使可用副本数增加，超过 8。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;进而可以继续销毁更多的旧副本，使可用副本数回到 8。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;旧副本的销毁使副本总数低于 13，这样就允许创建更多的新副本。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;这个过程会持续进行，最终所有的旧副本都会被新副本替换，滚动更新完成。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;而我们的实际情况是在第 4 步就卡住了，新副本无法通过 Readiness 探测。这个过程可以在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl describe deployment app&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的日志部分查看。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180325065645081-1130056504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果滚动更新失败，可以通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl rollout undo&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 回滚到上一个版本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180325065701205-1358354786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;如果要定制 &lt;/span&gt;&lt;code&gt;&lt;span&gt;maxSurge&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;maxUnavailable&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，可以如下配置：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201803/775365-20180325065714699-307085262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本章我们讨论了 Kubernetes 健康检查的两种机制：Liveness 探测和 Readiness 探测，并实践了健康检查在 Scale Up 和 Rolling Update 场景中的应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下节我们开始讨论 Kubernetes 如何管理数据。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;书籍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Kubernetes》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/26225745440.html&quot;&gt;https://item.jd.com/26225745440.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 21:50:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8642831.html</dc:identifier>
</item>
<item>
<title>18.C++-[ ]操作符使用 、函数对象与普通函数区别(详解) - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/8647921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/8647921.html</guid>
<description>&lt;p&gt;&lt;strong&gt;在上章&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/lifexy/p/8642163.html&quot;&gt;&lt;span&gt;17.C++-string字符串类(详解)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;学习了string类,发现可以&lt;span&gt;通过[ ]重载操作符&lt;/span&gt;来&lt;span&gt;访问每个字符&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;string&lt;/span&gt; s=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SAD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;,i&amp;lt; s.length();i++&lt;span&gt;)
cout&lt;/span&gt;&amp;lt;&amp;lt;s[i]&amp;lt;&amp;lt;endl;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;接下来,我们来自己写个&lt;span&gt;[ ]重载操作符&lt;/span&gt;,来模拟&lt;span&gt;string类&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;
{
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
   &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;str;
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; len;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *p=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(p!=&lt;span&gt;NULL)
      {
       len&lt;/span&gt;=&lt;span&gt;strlen(p);
       str &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt;[len];
       strcpy(str,p);
      }
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
      {
        len&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        str &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        str[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
      }  
    }
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&amp;amp; &lt;span&gt;operator&lt;/span&gt; [](&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i)
    {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str[i];
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; length()
    {
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; len;
    }
};

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
       &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; s=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SAD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt; s.length();i++&lt;span&gt;)
       std::cout &lt;/span&gt;&amp;lt;&amp;lt; s[i] &amp;lt;&amp;lt;&lt;span&gt; std::endl;

       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行打印:&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;函数对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;函数对象是指该对象&lt;span&gt;&lt;strong&gt;具备函数的行为&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;函数对象,是通过&lt;span&gt;&lt;strong&gt;&lt;span&gt;()调用操作符&lt;/span&gt;声明&lt;/strong&gt;&lt;/span&gt;得到的,然后便能通过&lt;span&gt;&lt;strong&gt;函数方式来调用该对象&lt;/strong&gt;&lt;/span&gt;了.&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;()调用操作符&lt;/strong&gt;&lt;/span&gt;可以定义不同参数的&lt;span&gt;&lt;strong&gt;多个重载函数&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;()调用操作符&lt;/strong&gt;&lt;/span&gt;只能通过&lt;span&gt;&lt;strong&gt;类的成员函数&lt;/strong&gt;&lt;/span&gt;重载(不能通过全局函数)&lt;/li&gt;
&lt;li&gt;函数对象用于在工程中&lt;span&gt;&lt;strong&gt;取代函数指针&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如,定义一个&lt;strong&gt;&lt;span&gt;函数对象t&lt;/span&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; () (&lt;span&gt;void&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过()重载操作符,来使对象具备函数的行为&lt;/span&gt;
&lt;span&gt;     {
              cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
     }
};

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
       Test t;
       t();          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印&quot;hello&quot;&lt;/span&gt;
}　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;函数对象与普通函数&lt;span&gt;区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;函数对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以封装自己的成员以及其它函数,所以能够&lt;span&gt;&lt;strong&gt;更好的面向对象.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;普通函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;往往&lt;span&gt;&lt;strong&gt;只具备逻辑关系&lt;/strong&gt;&lt;/span&gt;,并且没有固定的成员,因为普通函数一被调用完后,里面的内容便被摧毁了,除非使用&lt;span&gt;&lt;strong&gt;全局变量&lt;/strong&gt;&lt;/span&gt;,但是全局变量又不具备封装性.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接下来,我们来个&lt;span&gt;普通函数&lt;/span&gt;和&lt;span&gt;函数对象&lt;/span&gt;的示例,便知道两者的区别了.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;需求如下:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过一个函数,来获取&lt;span&gt;&lt;strong&gt;斐波那契数列&lt;/strong&gt;&lt;/span&gt;每项的值&lt;/li&gt;
&lt;li&gt;每调用一次函数,便&lt;span&gt;&lt;strong&gt;返回一个值&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;可以&lt;span&gt;&lt;strong&gt;重复使用&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;普通函数实例&lt;/strong&gt;&lt;strong&gt;:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;           
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cnt0=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cnt1=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; fib_set(&lt;span&gt;int&lt;/span&gt; n)          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置斐波那契数列为哪一项,使fib()能重复使用&lt;/span&gt;
&lt;span&gt;{
     cnt0&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
     cnt1&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
     {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tmp=&lt;span&gt;cnt1;
            cnt1&lt;/span&gt;=cnt0+&lt;span&gt;cnt1;
            cnt0&lt;/span&gt;=&lt;span&gt;tmp;
     }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fib()              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算出一项值&lt;/span&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tmp=&lt;span&gt;cnt1;
  cnt1&lt;/span&gt;=cnt0+&lt;span&gt;cnt1;
  cnt0&lt;/span&gt;=&lt;span&gt;tmp;

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;5&lt;/span&gt;;i++&lt;span&gt;)
  cout&lt;/span&gt;&amp;lt;&amp;lt;fib()&amp;lt;&amp;lt;endl;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印1~5项值&lt;/span&gt;
&lt;span&gt;
  fib_set(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;);                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从新设置项数位0&lt;/span&gt;

  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;5&lt;/span&gt;;i++&lt;span&gt;)
  cout&lt;/span&gt;&amp;lt;&amp;lt;fib()&amp;lt;&amp;lt;endl;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次打印1~5项值,使它能重复使用&lt;/span&gt;

  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;     
}　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行打印:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面代码可以看到,通过普通函数实现的需求,还需要&lt;span&gt;&lt;strong&gt;两个全局变量&lt;/strong&gt;&lt;/span&gt;才行,这在大项目里,完全不可取的,若项目里,像这样的模块多的话,那得有多少个全局变量啊？并且这些&lt;span&gt;&lt;strong&gt;全局变量能够随意被破坏&lt;/strong&gt;&lt;/span&gt;,没有一点封装性.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;接下来,&lt;/strong&gt;&lt;strong&gt;通过函数对象来完成这个需求:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;           
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Fib{
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cnt0;
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cnt1;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
       Fib(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
       {
          cnt0&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
          cnt1&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
       }

       &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt; =(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
       {
          cnt0&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
          cnt1&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;      
          &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
          {
             &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tmp=&lt;span&gt;cnt1;
             cnt1&lt;/span&gt;+=&lt;span&gt;cnt0;
             cnt0&lt;/span&gt;=&lt;span&gt;tmp;
          }
       }

       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;&lt;span&gt; () ()
       {
             &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tmp=&lt;span&gt;cnt1;
             cnt1&lt;/span&gt;+=&lt;span&gt;cnt0;
             cnt0&lt;/span&gt;=&lt;span&gt;tmp;

              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cnt0;
       }

};

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
  Fib  fib;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;5&lt;/span&gt;;i++&lt;span&gt;)
  cout&lt;/span&gt;&amp;lt;&amp;lt;fib()&amp;lt;&amp;lt;endl;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印1~5项值&lt;/span&gt;
&lt;span&gt;
  fib&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从新设置项数为0&lt;/span&gt;

  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;5&lt;/span&gt;;i++&lt;span&gt;)
  cout&lt;/span&gt;&amp;lt;&amp;lt;fib()&amp;lt;&amp;lt;endl;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印1~5项值&lt;/span&gt;

  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;     
}　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行打印:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面代码看到,使用函数对象后,便&lt;span&gt;&lt;strong&gt;不需要使用全局变量&lt;/strong&gt;&lt;/span&gt;了.&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 16:11:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/8647921.html</dc:identifier>
</item>
<item>
<title>Kotlin——从无到有系列之高级篇（一）：Lambda表达式 - Jetictors</title>
<link>http://www.cnblogs.com/Jetictors/p/8647888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jetictors/p/8647888.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1255627/201803/1255627-20180304230923361-401978309.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果您对&lt;code&gt;Kotlin&lt;/code&gt;很有兴趣，或者很想学好这门语言，可以关注我的掘金，或者进入我的QQ群大家一起学习、进步。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;欢迎各位大佬进群共同研究、探索&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;QQ群号：497071402&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;进入正题&quot;&gt;进入正题&lt;/h2&gt;
&lt;p&gt;经过前面一系列对&lt;code&gt;Kotlin&lt;/code&gt;讲解，相信大家已经能对&lt;code&gt;Kotlin&lt;/code&gt;有了一个基本的认识。如果你又&lt;code&gt;Java&lt;/code&gt;语言方面的编程经验，你可能已经不满足前面的基础语法了。从这篇文章起，就为大家讲解&lt;code&gt;Kotlin&lt;/code&gt;语言中的高级操作。&lt;br/&gt;&lt;code&gt;Lambda&lt;/code&gt;语法在&lt;code&gt;Java&lt;/code&gt;中已经被广泛的运用，我们在开发&lt;code&gt;Android&lt;/code&gt;中几乎上每一个项目也会在项目中接入&lt;code&gt;Lambda&lt;/code&gt;插件，因为&lt;code&gt;Lambda&lt;/code&gt;确实能简少很多的代码量。无独有偶，在&lt;code&gt;Kotlin&lt;/code&gt;中也是&lt;code&gt;Lambda&lt;/code&gt;语法的，在这篇文章中就详细的为大家讲解&lt;code&gt;Lambda&lt;/code&gt;语法的编写与使用，同时会后面的&lt;a href=&quot;http://www.cnblogs.com/Jetictors/p/8647888.html#&quot;&gt;Kotlin——高阶函数&lt;/a&gt;打下基础。&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1255627/201803/1255627-20180326000434336-2126139992.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一lambda介绍&quot;&gt;一、Lambda介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在上面已经提到了在&lt;code&gt;Java&lt;/code&gt;中已经被广泛的运用，但是也是在&lt;code&gt;Java8&lt;/code&gt;的时候才支持这种&lt;code&gt;Lambda&lt;/code&gt;表达式。在其他的编程语言中（例如：&lt;code&gt;Scala&lt;/code&gt;语言）。而这种表达式是&lt;em&gt;语法糖&lt;/em&gt;中的一种。值得庆幸的是，&lt;code&gt;Kotlin&lt;/code&gt;一经开源成熟就已经支持这种语法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Lambda&lt;/code&gt;表达式的本质其实是&lt;code&gt;匿名函数&lt;/code&gt;，因为在其底层实现中还是通过&lt;code&gt;匿名函数&lt;/code&gt;来实现的。但是我们在用的时候不必关心起底层实现。不过&lt;code&gt;Lambda&lt;/code&gt;的出现确实是减少了代码量的编写，同时也是代码变得更加简洁明了。&lt;br/&gt;&lt;code&gt;Lambda&lt;/code&gt;作为函数式编程的基础，其语法也是相当简单的。这里先通过一段简单的代码演示没让大家了解&lt;code&gt;Lambda&lt;/code&gt;表达式的简洁之处。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 这里举例一个Android中最常见的按钮点击事件的例子
mBtn.setOnClickListener(object : View.OnClickListener{
        override fun onClick(v: View?) {
            Toast.makeText(this,&quot;onClick&quot;,Toast.LENGTH_SHORT).show()
        }
    })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等价于&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 调用
mBtn.setOnClickListener { Toast.makeText(this,&quot;onClick&quot;,Toast.LENGTH_SHORT).show() }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二lambda使用&quot;&gt;二、Lambda使用&lt;/h2&gt;
&lt;p&gt;关于&lt;code&gt;Lambda&lt;/code&gt;的使用，我这里从从来哪个方面讲解，一是先介绍&lt;code&gt;Lambda&lt;/code&gt;表达式的特点，而是从&lt;code&gt;Lambda&lt;/code&gt;的语法使用讲解。&lt;/p&gt;
&lt;h3 id=&quot;lambda表达式的特点&quot;&gt;2.1、Lambda表达式的特点&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;古人云：欲取之，先与之。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要学习&lt;code&gt;Lambda&lt;/code&gt;表达式语法，必先了解其特点。我在这里先总结出&lt;code&gt;Lambda&lt;/code&gt;表达式的一些特征。在下面讲解到&lt;code&gt;Lambda&lt;/code&gt;语法与实践时大家就明白了。即：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Lambda&lt;/code&gt;表达式总是被大括号括着&lt;/li&gt;
&lt;li&gt;其参数(如果存在)在 &lt;code&gt;-&amp;gt;&lt;/code&gt; 之前声明(参数类型可以省略)&lt;/li&gt;
&lt;li&gt;函数体(如果存在)在 &lt;code&gt;-&amp;gt;&lt;/code&gt; 后面。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;lambda语法&quot;&gt;2.2、Lambda语法&lt;/h4&gt;
&lt;p&gt;为了让大家彻底的弄明白&lt;code&gt;Lambda&lt;/code&gt;语法，我这里用三种用法来讲解。并且举例为大家说明&lt;/p&gt;
&lt;p&gt;&lt;em&gt;语法如下：&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    1. 无参数的情况 ：
    val/var 变量名 = { 操作的代码 }

    2. 有参数的情况
    val/var 变量名 : (参数的类型，参数类型，...) -&amp;gt; 返回值类型 = {参数1，参数2，... -&amp;gt; 操作参数的代码 }

    可等价于
    // 此种写法：即表达式的返回值类型会根据操作的代码自推导出来。
    val/var 变量名 = { 参数1 ： 类型，参数2 : 类型, ... -&amp;gt; 操作参数的代码 }

    3. lambda表达式作为函数中的参数的时候，这里举一个例子：
    fun test(a : Int, 参数名 : (参数1 ： 类型，参数2 : 类型, ... ) -&amp;gt; 表达式返回类型){
        ...
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;实例讲解：&lt;/em&gt;&lt;/p&gt;
&lt;ul readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;无参数的情况&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // 源代码
 fun test(){ println(&quot;无参数&quot;) }

  // lambda代码
  val test = { println(&quot;无参数&quot;) }

  // 调用
  test()  =&amp;gt; 结果为：无参数&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;有参数的情况,这里举例一个两个参数的例子，目的只为大家演示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // 源代码
  fun test(a : Int , b : Int) : Int{
      return a + b
  }

  // lambda
  val test : (Int , Int) -&amp;gt; Int = {a , b -&amp;gt; a + b}
  // 或者
  val test = {a : Int , b : Int -&amp;gt; a + b}

  // 调用
  test(3,5) =&amp;gt; 结果为：8&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;lambda表达式作为函数中的参数的时候&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // 源代码
  fun test(a : Int , b : Int) : Int{
      return a + b
  }

  fun sum(num1 : Int , num2 : Int) : Int{
      return num1 + num2
  }

  // 调用
  test(10,sum(3,5)) // 结果为：18

  // lambda
  fun test(a : Int , b : (num1 : Int , num2 : Int) -&amp;gt; Int) : Int{
      return a + b.invoke(3,5)
  }

  // 调用
  test(10,{ num1: Int, num2: Int -&amp;gt;  num1 + num2 })  // 结果为：18&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后一个的实现可能大家难以理解，但请不要迷茫，你继续看下去，在下面的实践和高阶函数中会为大家介绍。&lt;/p&gt;
&lt;p&gt;经过上面的实例讲解与语法的介绍，我们对其作出一个总结：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;lambda&lt;/code&gt;表达式总是被大括号括着。&lt;/li&gt;
&lt;li&gt;定义完整的&lt;code&gt;Lambda&lt;/code&gt;表达式如上面实例中的语法2，它有其完整的参数类型标注，与表达式返回值。当我们把一些类型标注省略的情况下，就如上面实例中的语法2的另外一种类型。当它推断出的返回值类型不为'Unit'时，它的返回值即为&lt;code&gt;-&amp;gt;&lt;/code&gt;符号后面代码的最后一个（或只有一个）表达式的类型。&lt;/li&gt;
&lt;li&gt;在上面例子中语法3的情况表示为：&lt;code&gt;高阶函数&lt;/code&gt;，当&lt;code&gt;Lambda&lt;/code&gt;表达式作为其一个参数时，只为其表达式提供了参数类型与返回类型，所以，我们在调用此高阶函数的时候我们要为该&lt;code&gt;Lambda&lt;/code&gt;表达式写出它的具体实现。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;invoke()&lt;/code&gt;函数：表示为通过&lt;code&gt;函数变量&lt;/code&gt;调用自身，因为上面例子中的变量&lt;code&gt;b&lt;/code&gt;是一个匿名函数。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;lambda实践&quot;&gt;3、Lambda实践&lt;/h3&gt;
&lt;p&gt;学会了上面讲解的语法只是，相信您已能大致的编写且使用&lt;code&gt;lambda&lt;/code&gt;表达式了，不过只会上面简单的语法还不足以运用于实际项目中复杂的情况。下面从几个知识点讲解&lt;code&gt;Lambda&lt;/code&gt;实践的要点。&lt;/p&gt;
&lt;h3 id=&quot;it&quot;&gt;3.1、it&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;it&lt;/code&gt;并不是&lt;code&gt;Kotlin&lt;/code&gt;中的一个关键字(保留字)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;it&lt;/code&gt;是在当一个高阶函数中&lt;code&gt;Lambda&lt;/code&gt;表达式的参数只有一个的时候可以使用&lt;code&gt;it&lt;/code&gt;来使用此参数。&lt;code&gt;it&lt;/code&gt;可表示为&lt;strong&gt;单个参数的隐式名称&lt;/strong&gt;，是&lt;code&gt;Kotlin&lt;/code&gt;语言约定的。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;例1：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val it : Int = 0  // 即it不是`Kotlin`中的关键字。可用于变量名称&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例2：单个参数的隐式名称&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 这里举例一个语言自带的一个高阶函数filter,此函数的作用是过滤掉不满足条件的值。
val arr = arrayOf(1,3,5,7,9)
// 过滤掉数组中元素小于2的元素，取其第一个打印。这里的it就表示每一个元素。
println(arr.filter { it &amp;lt; 5 }.component1())   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例2这个列子只是给大家&lt;code&gt;it&lt;/code&gt;的使用，&lt;code&gt;filter&lt;/code&gt;高阶函数，在后面的&lt;a href=&quot;http://www.cnblogs.com/Jetictors/p/8647888.html#&quot;&gt;Kotlin——从无到有系列之高级篇（三）集合的详细使用&lt;/a&gt;章节中会为大家详细讲解，这里不多做介绍。下面为我们自己写一个高阶函数去讲解&lt;code&gt;it&lt;/code&gt;。关于高阶函数的定义与使用请参见&lt;a href=&quot;http://www.cnblogs.com/Jetictors/p/8647888.html#&quot;&gt;Kotlin——从无到有系列之高级篇（二）：高阶函数详解&lt;/a&gt;这篇文章。&lt;/p&gt;
&lt;p&gt;例3：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; fun test(num1 : Int, bool : (Int) -&amp;gt; Boolean) : Int{
   return if (bool(num1)){ num1 } else 0
}

println(test(10,{it &amp;gt; 5}))
println(test(4,{it &amp;gt; 5}))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;10
0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码讲解：上面的代码意思是，在高阶函数&lt;code&gt;test&lt;/code&gt;中，其返回值为&lt;code&gt;Int&lt;/code&gt;类型，&lt;code&gt;Lambda&lt;/code&gt;表达式以&lt;code&gt;num1&lt;/code&gt;位条件。其中如果&lt;code&gt;Lambda&lt;/code&gt;表达式的值为&lt;code&gt;false&lt;/code&gt;的时候返回0，反之返回&lt;code&gt;num1&lt;/code&gt;。故而当条件为&lt;code&gt;num1 &amp;gt; 5&lt;/code&gt;这个条件时，当调用&lt;code&gt;test&lt;/code&gt;函数，&lt;code&gt;num1 = 10&lt;/code&gt;返回值就是10，&lt;code&gt;num1 = 4&lt;/code&gt;返回值就是0。&lt;/p&gt;
&lt;h3 id=&quot;下划线_&quot;&gt;3.2、下划线（_）&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在使用&lt;code&gt;Lambda&lt;/code&gt;表达式的时候，可以用下划线(&lt;code&gt;_&lt;/code&gt;)表示未使用的参数，表示不处理这个参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同时在遍历一个&lt;code&gt;Map&lt;/code&gt;集合的时候，这当非常有用。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val map = mapOf(&quot;key1&quot; to &quot;value1&quot;,&quot;key2&quot; to &quot;value2&quot;,&quot;key3&quot; to &quot;value3&quot;)

map.forEach{
     key , value -&amp;gt; println(&quot;$key \t $value&quot;)
}

// 不需要key的时候
map.forEach{
    _ , value -&amp;gt; println(&quot;$value&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;key1     value1
key2     value2
key3     value3
value1
value2
value3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;匿名函数&quot;&gt;3.3 匿名函数&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;匿名函数的特点是可以明确指定其返回值类型。&lt;/li&gt;
&lt;li&gt;它和常规函数的定义几乎相似。他们的区别在于，匿名函数没有函数名。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            fun test(x : Int , y : Int) : Int{                  fun(x : Int , y : Int) : Int{
常规函数：      return x + y                        匿名函数：      return x + y
            }                                                   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在前面的&lt;a href=&quot;https://juejin.im/post/5a6377425188257329148665&quot;&gt;Kotlin——从无到有系列之初级篇（七）：基本的函数/方法使用&lt;/a&gt;我们讲解过单表达式函数。故而，可以简写成下面的方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;常规函数 ： fun test(x : Int , y : Int) : Int = x + y
匿名函数 ： fun(x : Int , y : Int) : Int = x + y&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的两个例子可以看出，匿名函数与常规函数的区别在于一个有函数名，一个没有。&lt;/p&gt;
&lt;p&gt;实例演练：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val test1 = fun(x : Int , y : Int) = x + y  // 当返回值可以自动推断出来的时候，可以省略，和函数一样
val test2 = fun(x : Int , y : Int) : Int = x + y
val test3 = fun(x : Int , y : Int) : Int{
    return x + y
}

println(test1(3,5))
println(test2(4,6))
println(test3(5,7))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;8
10
12&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码我们可以总结出&lt;code&gt;匿名函数&lt;/code&gt;与&lt;code&gt;Lambda&lt;/code&gt;表达式的几点区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;匿名函数的参数传值，总是在小括号内部传递。而&lt;code&gt;Lambda&lt;/code&gt;表达式传值，可以有省略小括号的简写写法。&lt;/li&gt;
&lt;li&gt;在一个不带&lt;code&gt;标签&lt;/code&gt;的&lt;code&gt;return&lt;/code&gt;语句中，匿名函数时返回值是返回自身函数的值，而&lt;code&gt;Lambda&lt;/code&gt;表达式的返回值是将包含它的函数中返回。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;带接收者的函数字面值&quot;&gt;3.4、带接收者的函数字面值&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在&lt;code&gt;kotlin&lt;/code&gt;中，提供了指定的&lt;em&gt;接受者对象&lt;/em&gt;调用&lt;code&gt;Lambda&lt;/code&gt;表达式的功能。在函数字面值的函数体中，可以调用该接收者对象上的方法而无需任何额外的限定符。它类似于&lt;code&gt;扩展函数&lt;/code&gt;，它允你在函数体内访问接收者对象的成员。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;匿名函数作为接收者类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;匿名函数语法允许你直接指定函数字面值的接收者类型，如果你需要使用带接收者的函数类型声明一个变量，并在之后使用它，这将非常有用。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;val iop = fun Int.( other : Int) : Int = this + other
println(2.iop(3))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例：这里用官方的一个例子做说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class HTML {
    fun body() { …… }
}

fun html(init: HTML.() -&amp;gt; Unit): HTML {
    val html = HTML()  // 创建接收者对象
    html.init()        // 将该接收者对象传给该 lambda
    return html
}


html {       // 带接收者的 lambda 由此开始
    body()   // 调用该接收者对象的一个方法
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;闭包&quot;&gt;3.5 闭包&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;所谓&lt;code&gt;闭包&lt;/code&gt;，即是函数中包含函数，这里的函数我们可以包含(&lt;code&gt;Lambda&lt;/code&gt;表达式，匿名函数，局部函数，对象表达式)。我们熟知，函数式编程是现在和未来良好的一种编程趋势。故而&lt;code&gt;Kotlin&lt;/code&gt;也有这一个特性。&lt;/li&gt;
&lt;li&gt;我们熟知，&lt;code&gt;Java&lt;/code&gt;是不支持闭包的，&lt;code&gt;Java&lt;/code&gt;是一种面向对象的编程语言，在&lt;code&gt;Java&lt;/code&gt;中，&lt;code&gt;对象&lt;/code&gt;是他的一等公民。&lt;code&gt;函数&lt;/code&gt;和&lt;code&gt;变量&lt;/code&gt;是二等公民。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Kotlin&lt;/code&gt;中支持闭包，&lt;code&gt;函数&lt;/code&gt;和&lt;code&gt;变量&lt;/code&gt;是它的一等公民，而&lt;code&gt;对象&lt;/code&gt;则是它的二等公民了。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;实例：看一段&lt;code&gt;Java&lt;/code&gt;代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TestJava{

    private void test(){
        private void test(){        // 错误，因为Java中不支持函数包含函数

        }
    }

    private void test1(){}          // 正确，Java中的函数只能包含在对象中+
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例：看一段&lt;code&gt;Kotlin&lt;/code&gt;代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fun test1(){
    fun test2(){   // 正确，因为Kotlin中可以函数嵌套函数
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们讲解&lt;code&gt;Kotlin&lt;/code&gt;中几种闭包的表现形式。&lt;/p&gt;
&lt;h4 id=&quot;携带状态&quot;&gt;3.5.1、携带状态&lt;/h4&gt;
&lt;p&gt;例：让函数返回一个函数，并携带状态值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fun test(b : Int): () -&amp;gt; Int{
    var a = 3
    return fun() : Int{
        a++
        return a + b
    }
}

val t = test(3)
println(t())
println(t())
println(t())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;7
8
9&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;引用外部变量并改变外部变量的值&quot;&gt;3.5.2、引用外部变量，并改变外部变量的值&lt;/h4&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var sum : Int = 0
val arr = arrayOf(1,3,5,7,9)
arr.filter { it &amp;lt; 7  }.forEach { sum += it }

println(sum)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;9&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在android开发中为recyclerview的适配器编写一个item点击事件&quot;&gt;3.6 在&lt;code&gt;Android&lt;/code&gt;开发中为&lt;code&gt;RecyclerView&lt;/code&gt;的适配器编写一个&lt;code&gt;Item&lt;/code&gt;点击事件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;class TestAdapter(val context : Context , val data: MutableList&amp;lt;String&amp;gt;)
    : RecyclerView.Adapter&amp;lt;TestAdapter.TestViewHolder&amp;gt;(){

    private var mListener : ((Int , String) -&amp;gt; Unit)? = null

    override fun onBindViewHolder(holder: TestViewHolder?, position: Int) {
        ...
        holder?.itemView?.setOnClickListener {
            mListener?.invoke(position, data[position])
        }

    }

    override fun onCreateViewHolder(parent: ViewGroup?, viewType: Int): TestViewHolder {
        return TestViewHolder(View.inflate(context,layoutId,parent))
    }

    override fun getItemCount(): Int {
        return data.size
    }

    fun setOnItemClickListener(mListener : (position : Int, item : String) -&amp;gt; Unit){
        this.mListener = mListener
    }

    inner class TestViewHolder(itemView : View) : RecyclerView.ViewHolder(itemView)
}

// 调用
TestAdapter(this,dataList).setOnItemClickListener { position, item -&amp;gt;
        Toast.makeText(this,&quot;$position \t $item&quot;,Toast.LENGTH_SHORT).show()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Lambda&lt;/code&gt;表达式是为我们减少了大量的代码，但是&lt;code&gt;Lambda&lt;/code&gt;表达式是为后面的高阶函数章节打下基础，虽然在这篇文章中也提到了高阶函数，但是都是最基础的，在下一节中会为大家介绍自定义高阶函数与&lt;code&gt;Kotlin&lt;/code&gt;自身中常用的高阶函数讲解。&lt;/p&gt;
&lt;p&gt;在这一章节中，讲述了&lt;code&gt;Lambda&lt;/code&gt;的语法、使用。以及&lt;code&gt;Lambda&lt;/code&gt;表达式的一些特性与实践操作。当然还包含了&lt;code&gt;匿名函数&lt;/code&gt;这一知识点。其中最重要的当属&lt;code&gt;Lambda&lt;/code&gt;的实践操作。如果你看完这篇文章还不甚理解，请在仔细的阅读一遍并实际代码演练，因为在后面的高阶函数章节还会遇到。&lt;/p&gt;
&lt;p&gt;在这最后希望您能给个关注，因为您的关注，是我继续写文章最好的动力。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我的个人博客&lt;/em&gt;：&lt;a href=&quot;https://jetictors.github.io/&quot;&gt;Jetictors&lt;/a&gt;&lt;br/&gt;&lt;em&gt;Github&lt;/em&gt;：&lt;a href=&quot;https://github.com/Jetictors&quot;&gt;Jteictors&lt;/a&gt;&lt;br/&gt;&lt;em&gt;我的掘金&lt;/em&gt;：&lt;a href=&quot;https://juejin.im/user/5709f5798ac247004c295d95&quot;&gt;Jetictors&lt;/a&gt;&lt;/p&gt;

&lt;h2 align=&quot;center&quot;&gt;欢迎各位大佬进群共同研究、探索&lt;br/&gt;&lt;/h2&gt;
&lt;h4 align=&quot;center&quot;&gt;QQ群号：497071402&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/12/30/160a5e3194215cdd?w=200&amp;amp;h=274&amp;amp;f=jpeg&amp;amp;s=68508&quot;/&gt;&lt;/h4&gt;
</description>
<pubDate>Sun, 25 Mar 2018 16:09:00 +0000</pubDate>
<dc:creator>Jetictors</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jetictors/p/8647888.html</dc:identifier>
</item>
<item>
<title>线性表 - song.yan</title>
<link>http://www.cnblogs.com/excellencesy/p/8647853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/excellencesy/p/8647853.html</guid>
<description>&lt;p&gt;1，线性表是数据结构的线性表现&lt;/p&gt;
&lt;p&gt;2，线性表的两种表现方式：顺序表，链表&lt;/p&gt;
&lt;p&gt;3，顺序表：开辟连续的空间，顺序存储&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1157942/201803/1157942-20180325225655947-1019374825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4，链表：每个存储单元包括存数据的地方，存指针的地方。离散的空间通过指针连接在一起。&lt;/p&gt;
&lt;p&gt;5，链表：单链表，循环链表，双向链表&lt;/p&gt;
&lt;p&gt;6，单链表：只有一套指针，指针单向&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1157942/201803/1157942-20180325230137327-456230171.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;7，循环链表：把尾元素的指针指向头节点&lt;/p&gt;
&lt;p&gt;优点：无需重新定位到头指针&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1157942/201803/1157942-20180325230157704-1545593011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8，双向链表：两套指针，正向，逆向两种&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1157942/201803/1157942-20180325230213249-768467225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9.链表的基本操作【操作步骤不可变！！！】&lt;/p&gt;
&lt;p&gt;点击下列链表查看详情&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/excellencesy/p/8646128.html&quot; target=&quot;_blank&quot;&gt;单链表的增加，删除节点操作&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/excellencesy/p/8647849.html&quot; target=&quot;_blank&quot;&gt;双向链表的增加，删除节点操作&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 15:54:00 +0000</pubDate>
<dc:creator>song.yan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/excellencesy/p/8647853.html</dc:identifier>
</item>
<item>
<title>JAVA实现双向链表的增删功能 - song.yan</title>
<link>http://www.cnblogs.com/excellencesy/p/8647849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/excellencesy/p/8647849.html</guid>
<description>&lt;p&gt;JAVA实现双向链表的增删功能，完整代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; linked;

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkedTable{
    
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkedTableTest {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造单链表&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; Node node1 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name1&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node2 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name2&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node3 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name3&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node4 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name4&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node5 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name5&quot;&lt;span&gt;);
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置指针&lt;/span&gt;
&lt;span&gt;        setPoint();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历&lt;/span&gt;
        System.out.println(&quot;*******初始链表*******&quot;&lt;span&gt;);
        out(node1,node5);
        System.out.println();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入节点在node2的后面&lt;/span&gt;
&lt;span&gt;        addNode(node2,node3);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环遍历&lt;/span&gt;
        System.out.println(&quot;*******插入node2.5*******&quot;&lt;span&gt;);
        out(node1, node5);
        System.out.println();
                
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除节点&lt;/span&gt;
&lt;span&gt;        node2.setNextNode(node3);
        node3.setNextNodeF(node2);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环遍历&lt;/span&gt;
        System.out.println(&quot;*******删除node2.5*******&quot;&lt;span&gt;);
        out(node1, node5);
        System.out.println();
        
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置指针&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPoint()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置正向指针&lt;/span&gt;
&lt;span&gt;        node1.setNextNode(node2);
        node2.setNextNode(node3);
        node3.setNextNode(node4);
        node4.setNextNode(node5);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置反向指针&lt;/span&gt;
&lt;span&gt;        node5.setNextNodeF(node4);
        node4.setNextNodeF(node3);
        node3.setNextNodeF(node2);
        node2.setNextNodeF(node1);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历单链表&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outLinked(Node startNode){
        Node node&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
        node.setNextNode(startNode);
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        {
            node&lt;/span&gt;=&lt;span&gt;node.getNextNode();
            System.out.print(node.getName()&lt;/span&gt;+&quot;----&quot;&lt;span&gt;);    
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(node.getNextNode()!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反向循环遍历单链表&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outLinkedF(Node endNode){
        Node node&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
        node.setNextNodeF(endNode);
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        {
            node&lt;/span&gt;=&lt;span&gt;node.getNextNodeF();
            System.out.print(node.getName()&lt;/span&gt;+&quot;----&quot;&lt;span&gt;);    
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(node.getNextNodeF()!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; out(Node startNode,Node endNode)
    {
        
        outLinked(startNode);
        System.out.println();
        outLinkedF(endNode);
        
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入节点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addNode(Node preNode,Node nextNode)
    {
        Node node_add &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;name2.5&quot;&lt;span&gt;);
        node_add.setNextNode(preNode.getNextNode());
        preNode.setNextNode(node_add);
        
        node_add.setNextNodeF(nextNode.getNextNodeF());
        nextNode.setNextNodeF(node_add);
    }
    
    

    
}


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node nextNode;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node nextNodeF;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNextNode(Node nextNode)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNode=&lt;span&gt;nextNode;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNextNodeF(Node nextNodeF)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNodeF=&lt;span&gt;nextNodeF;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getNextNode()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNode;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getNextNodeF()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNodeF;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNode=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node( )
    {
        
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1，构造node节点，需要两个指针，一个正向存储下一个元素的位置，一个反向存储下一个元素的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1157942/201803/1157942-20180325234027699-1840961168.png&quot; alt=&quot;&quot; width=&quot;365&quot; height=&quot;113&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;　　name:用于存储node自身的信息&lt;/p&gt;
&lt;p&gt;　　nextNode:用于存储正向指针&lt;/p&gt;
&lt;p&gt;　　nextNodeF:用于存储反向指针&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node nextNode;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node nextNodeF;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNextNode(Node nextNode)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNode=&lt;span&gt;nextNode;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNextNodeF(Node nextNodeF)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNodeF=&lt;span&gt;nextNodeF;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getNextNode()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNode;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getNextNodeF()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.nextNodeF;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(String name)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.nextNode=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node( )
    {
        
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2，创建节点，设置指针连接节点&lt;/p&gt;
&lt;p&gt;正向指针：指向下一个节点&lt;/p&gt;
&lt;p&gt;反向节点：指向上一个节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造单链表&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; Node node1 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name1&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node2 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name2&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node3 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name3&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node4 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name4&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; Node node5 = &lt;span&gt;new&lt;/span&gt; Node(&quot;name5&quot;&lt;span&gt;);
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPoint()
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置正向指针&lt;/span&gt;
&lt;span&gt;        node1.setNextNode(node2);
        node2.setNextNode(node3);
        node3.setNextNode(node4);
        node4.setNextNode(node5);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置反向指针&lt;/span&gt;
&lt;span&gt;        node5.setNextNodeF(node4);
        node4.setNextNodeF(node3);
        node3.setNextNodeF(node2);
        node2.setNextNodeF(node1);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3，将链表循环遍历输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outLinked(Node startNode){
        Node node&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
        node.setNextNode(startNode);
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        {
            node&lt;/span&gt;=&lt;span&gt;node.getNextNode();
            System.out.print(node.getName()&lt;/span&gt;+&quot;----&quot;&lt;span&gt;);    
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(node.getNextNode()!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; outLinkedF(Node endNode){
        Node node&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
        node.setNextNodeF(endNode);
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        {
            node&lt;/span&gt;=&lt;span&gt;node.getNextNodeF();
            System.out.print(node.getName()&lt;/span&gt;+&quot;----&quot;&lt;span&gt;);    
        }&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(node.getNextNodeF()!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4，添加节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addNode(Node preNode,Node nextNode)
    {
        Node node_add &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(&quot;name2.5&quot;&lt;span&gt;);
        node_add.setNextNode(preNode.getNextNode());
        preNode.setNextNode(node_add);
        
        node_add.setNextNodeF(nextNode.getNextNodeF());
        nextNode.setNextNodeF(node_add);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5，删除节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;node2.setNextNode(node3);
node3.setNextNodeF(node2);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;class Node {private String name;private Node nextNode;private Node nextNodeF;public void setName(String name){this.name=name;}public void setNextNode(Node nextNode){this.nextNode=nextNode;}public void setNextNodeF(Node nextNodeF){this.nextNodeF=nextNodeF;}public String getName(){return this.name;}public Node getNextNode(){return this.nextNode;}public Node getNextNodeF(){return this.nextNodeF;}public Node(String name){this.name=name;this.nextNode=null;}public Node( ){}}&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 15:52:00 +0000</pubDate>
<dc:creator>song.yan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/excellencesy/p/8647849.html</dc:identifier>
</item>
<item>
<title>Access第一周总结 - 小丑覃</title>
<link>http://www.cnblogs.com/suces/p/8647833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suces/p/8647833.html</guid>
<description>&lt;p&gt;数据库【DataBase】是存放数据的仓库，是长期存在计算机的，有组织的、大量的、可共享的数据集合；数据模型的概念有：实体【Entity】、属性【Attribute】、关键字【Key】、域【Domain】、实体型【Entity Type】、实体集【Entity Set】、联系【Relationship】；实体间有一对一，一对多，多对多的联系方式；结构模型只有一个父结点。&lt;/p&gt;
</description>
<pubDate>Sun, 25 Mar 2018 15:46:00 +0000</pubDate>
<dc:creator>小丑覃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suces/p/8647833.html</dc:identifier>
</item>
</channel>
</rss>