<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>K：平衡二叉树(AVL) - 林学徒</title>
<link>http://www.cnblogs.com/MyStringIsNotNull/p/8306848.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MyStringIsNotNull/p/8306848.html</guid>
<description>&lt;h3 id=&quot;相关介绍&quot;&gt;相关介绍：&lt;/h3&gt;
&lt;p&gt; 二叉查找树的查找效率与二叉树的形状有关，对于按给定序列建立的二叉排序树，若其左、右子树均匀分布，则查找过程类似于有序表的二分查找，时间复杂度变为O(log2n)。当若给定序列原来有序，则建立的二叉查找树就蜕化为单链表，其查找效率同顺序查找一样，时间复杂度为O（n）。因此，在构造二叉查找树的过程中，当出现左右子树分布不均匀时，若能对其进行调整，使其依然保持均匀，则就能有效的保证二叉查找树仍具有较高的查找效率。而平衡二叉树，正是这样的一棵树。&lt;/p&gt;
&lt;p&gt; 平衡二叉树，又称为AVL树，它或是一棵空树，或是一棵具有如下性质的二叉树:它的左子树和右子树均为平衡二叉树，且左子树和右子树深度之差的绝对值不超过1&lt;/p&gt;
&lt;p&gt; 在平衡二叉树上插入或删除节点后，可能使二叉树失去平衡。因此，需要对失去平衡的二叉树进行调整，以保持平衡二叉树的性质。以下，主要介绍如何动态地使一棵二叉查找树保持平衡，即对失去平衡的二叉查找树进行平衡化调整。这里引入了&lt;strong&gt;平衡因子&lt;/strong&gt;的概念。&lt;/p&gt;
&lt;p&gt; 所谓的平衡因子，指的是二叉树中某个节点的左子树深度与右子树深度之差，平衡因子也称为平衡度。平衡二叉树也就是树中任意节点的平衡因子的绝对值小于等于1的二叉树。在AVL树中的节点的平衡因子有3种取值情况：1(左子树深度大于右子树深度)，0(左子树深度等于右子树深度)，-1(左子树深度小于右子树深度)&lt;/p&gt;
&lt;p&gt;在以下给出的例子中，为了叙述方便，假设在AVL树上因插入新节点而失去平衡的最小子树的根节点为A，即A为距离插入节点最近的，平衡因子不是-1、0和1的节点。失去平衡后的操作可 &lt;strong&gt;依据失去平衡的原因(此处为便于记忆的诀窍的一个关键，如“LL型平衡旋转”，指的是，在A的左孩子节点(L)的左孩子节点（L）中插入一个新的节点所导致的不平衡问题)&lt;/strong&gt; 归纳为下列4种情况分别进行介绍：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LL型平衡旋转(单向右旋)：由于在A的左孩子的左子树上插入新节点，使得A的平衡度由1增加至2，致使以A为根的子树失去平衡。此时，应该进行一次向右的顺时针旋转操作，“提升”B（即为A的左孩子）为新子树的根节点，A下降为B的右孩子，同时将B原来的右子树B-R调整为A的左子树。其过程如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117233710459-2062736009.png&quot; alt=&quot;LL型平衡旋转&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RR型平衡旋转(单向左旋):由于在A的右孩子的右子树上插入新节点，使得A的平衡度由-1转变为-2，致使以A为根的子树失去平衡。此时，应该进行一次的向左的逆时针旋转操作，“提升”B(即A的右孩子)为新子树的根节点，A下降为B的左子树，同时将B原来的左子树B-L调整为A的右子树。其过程如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117233755631-1087190624.png&quot; alt=&quot;RR型平衡旋转&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LR型平衡旋转(先左旋后右旋)：由于在A的左孩子的右子树上插入新节点，使得A的平衡度由1变为2，致使以A为根的子树失去平衡。此时，应当进行两次选装操作（先逆时针，后顺时针）“提升”C（即A的左孩子的右孩子）为新子树的根节点；A下降为C的右孩子；B变为C的左孩子；C原来的左子树C-L调整为B现在的右子树；C原来的右子树C-R调整为A的左子树。其过程如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117233847334-1077663180.png&quot; alt=&quot;LR型平衡旋转,变为B的右子树&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117233922615-1948736469.png&quot; alt=&quot;LR型平衡旋转,变为A的左子树&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RL型平衡旋转（先右旋后左旋）：由于在A的右孩子的左子树上插入新节点，使A的平衡度由-1变为-2，致使以A为根的子树失去平衡，此时，应进行两次旋转操作（先顺时针，后逆时针），“提升”C（即A的右孩子的左孩子）为新子树的根节点；A下降为C的左孩子；B变为C的右孩子；C原来的左子树C-L调整为A现在的右子树；C原来的右子树C-R调整为B的左子树。其过程如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117234003349-1883853452.png&quot; alt=&quot;RL型平衡旋转，变为B的左子树&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117234038021-74697466.png&quot; alt=&quot;RL型平衡旋转，变为A的右子树&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综上所述&lt;/strong&gt;：在平衡二叉查找树T上插入一个新记录x的算法描述如下：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li&gt;若AVL树为空树，则插入一个记录为x的新节点作为T的根节点，树的深度增加1。&lt;/li&gt;
&lt;li&gt;若x的关键字值和AVL树T的根节点的关键字值相等，则不进行插入操作。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;若X的关键字值小于AVL树的根节点的关键字值，则将x插入在该树的左子树上，并且当插入之后的左子树深度增加1时，分别就下列不同情况进行处理：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;若AVL树的根节点的平衡因子为-1（右子树的深度大于左子树的深度），则将根节点的平衡因子调整为0，并且树的深度不变&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;若AVL树的根节点的平衡因子为0（左右子树的深度相等）。则将根节点的平衡因子调整为1，树的深度同时增加1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;若AVL树的根节点的平衡因子为1（左子树的深度大于右子树的深度），则当该树的左子树的根节点的平衡因子为1时需要进行LL型平衡旋转；当该树的左子树的根节点的平衡因子为-1时需进行LR型平衡旋转&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;若x的关键字值大于AVL树的根节点的关键字值，则将x插入在该树的右子树上，并且当插入之后的右子树深度增加1时，分别就下列不同情况进行处理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;若AVL树的根节点的平衡因子为-1时（右子树的深度大于左子树的深度），则当该树的右子树的根节点的平衡因子为-1时需进行RR型平衡旋转；当该树的右子树的根节点的平衡因子为1时需进行RL型平衡旋转&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;2.若AVL树的根节点的平衡因子为0时（左右子树的深度相等），则将根节点的平衡因子调整为-1，树的深度同时增加1&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;若AVL树的根节点的平衡因子为1时（左子树的深度大于右子树的深度），则将根节点的平衡因子调整为0，并且树的深度保持不变&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;平衡二叉树的优缺点分析&quot;&gt;平衡二叉树的优缺点分析：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：使二叉树的结构更好(即不会出现“偏拐”严重的情况)，从而提高了查找操作的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：使插入和删除操作复杂化，从而减低了插入和删除操作的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：平衡二叉树适用于二叉查找树一经建立就很少进行插入和删除操作，而主要进行查找操作的应用场合上。由于其在查找过程中和给定值进行比较的关键字个数不超过树的深度。因此，在平衡二叉树上进行查找的时间复杂度为O（log2n）&lt;/p&gt;
&lt;h4 id=&quot;相关操作示例代码&quot;&gt;相关操作示例代码：&lt;/h4&gt;
&lt;p&gt; 对于平衡二叉树，其常见的操作有插入、删除、查找操作。其中，插入和删除某个节点时，需要对失去平衡的平衡二叉查找树进行相应的旋转操作，以使平衡二叉树保持结构上的稳定。&lt;/p&gt;
&lt;p&gt;下面代码定义了平衡二叉查找树的节点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;相关代码：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 该类用于定义平衡二叉树的节点的相关数据
 * @author 学徒
 *
 */
class AVLTreeNode
{
    //节点的关键字
    Comparable key;
    //节点的数据
    Object data;
    //节点的左子树指针
    AVLTreeNode left;
    //节点的右子树指针
    AVLTreeNode right;
    
    public AVLTreeNode(Comparable key,Object data)
    {
        this(key,data,null,null);
    }
    public AVLTreeNode(Comparable key,Object data,AVLTreeNode left,AVLTreeNode right)
    {
        this.data=data;
        this.key=key;
        this.left=left;
        this.right=right;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 对于查找操作，其先与根节点的关键字的值进行比较，根据比较所得的结果，选择返回其相关的数据或者是递归的在该节点的左右子树中进行查找&lt;/p&gt;
&lt;p&gt;下面代码演示了查找的操作：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;相关代码：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 用于平衡二叉树中的查找操作，并返回相应节点的相关数据，当未查找到时，返回null
 * @param key 要进行查找的节点的关键字
 * @return 得到要进行查找节点的相关数据
 */
public Object search(Comparable key)
{
    if(key==null)
        return null;
    return getSearchResult(root,key);
}

/**
 * 用于辅助平衡二叉树的查找操作，并返回相应的相关节点的数据，当未查找到时，返回null
 * @param root 要进行查找的二叉查找树的根节点
 * @param key 要进行查找的节点的关键字
 * @return 得到要进行查找节点的相关数据
 */
private Object getSearchResult(AVLTreeNode root,Comparable key)
{
    if(root==null)
        return null;
    int compare=key.compareTo(root.key);
    if(compare==0)
        return root.data;
    else if(compare==1)
        return getSearchResult(root.right,key);
    else
        return getSearchResult(root.left,key);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 对于插入操作，先根据其关键字值的大小关系，在平衡二叉树中插入相应的节点。之后，遍历该新插入节点的路径中各个根节点的平衡因子的情况，根据其平衡因子的值，选择性的对其进行旋转操作，需要注意的是在该路径上最多只存在一次“失衡”的情况。为此，在对其路径上的节点进行过旋转操作之后，其平衡二叉树整体便是处于“平衡”的状态的&lt;/p&gt;
&lt;p&gt;下面代码演示了插入操作：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;相关代码：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 用于往二叉树中插入新的节点
 * @param key 二叉树中新节点的关键字
 * @param data 二叉树中新节点的数据
 * @return 插入新节点的结果，如果成功插入一个新节点则返回true，否则返回false，当新增的节点存在于树中时，返回false
 */
public boolean insert(Comparable key,Object data)
{
    if(key==null)
        return false;
    else if(root!=null)
    {
        return insertAVLTreeNode(root,null,key,data);
    }
    else
    {
        root=new AVLTreeNode(key,data);
        return true;
    }
}

/**
 * 辅助往二叉树中插入新的节点
 * @param node 要进行比较的二叉树的节点
 * @param parent 要进行比较的二叉树的节点的父节点
  * @param key 新增节点的关键字值
 * @param data 新增节点的数据
 * @return 新增的结果
 */
private boolean insertAVLTreeNode(AVLTreeNode node,AVLTreeNode parent,Comparable key,Object data)
{
    //当当前比较的节点不为空的时候，进行比较操作
    if(node!=null)
    {
        int compare=key.compareTo(node.key);
        if(compare==0)
            return false;
        else if(compare&amp;gt;0)
            return insertAVLTreeNode(node.right,node,key,data);
        else
            return insertAVLTreeNode(node.left,node,key,data);
    }
    //当前的节点为空的时候，进行从其父节点处插入节点的操作。同时，进行旋转判断和相应的操作
    else
    {
        Comparable parentKey=parent.key;
        AVLTreeNode newNode=new AVLTreeNode(key,data);
        int comparable=parentKey.compareTo(key);
        //插入新增节点
        if(comparable&amp;gt;0)
            parent.left=newNode;
        else
            parent.right=newNode;
        //对插入完后的节点进行判断，查看其是否需要进行旋转操作，当需要时，对其进行进行旋转调整平衡二叉树相应的节点情况
        rotate(root,null,newNode);
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 对于删除操作，其只需要在二叉树中找到要进行删除的节点的父节点。之后移动相应的指针即可对其进行删除操作，同时用其按照关键字有序的后继节点对其进行补充即可，之后从对到其进行删除节点的父节点的路径上的所有节点进行遍历，当存在因为删除节点而导致其失去平衡的情况，则对其进行相应的平衡旋转操作&lt;/p&gt;
&lt;p&gt;下面代码演示了删除操作：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;相关代码：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 用于进行删除操作
 * @param key 要进行删除操作的节点的关键字值
 * @return 返回所删除节点的数据值,当无相关的删除节点的时候，返回null
 */
public Object delete(Comparable key)
{
    if(key==null)
        return null;
    else
        return remove(root,key,null);
}
/**
 * 用于辅助进行删除操作的方法
 * @param node 当前比较节点
 * @param parent 当前比较节点的双亲节点
 * @param key 需要进行删除的节点的关键字值
 * @return 返回所删除节点的关键字
 */
public Object remove(AVLTreeNode node,Comparable key,AVLTreeNode parent)
{
    if (node != null)
    {
        int compare = key.compareTo(node.key);
        // 从左子树中进行删除
        if (compare &amp;lt; 0)
        {
            return remove(node.left, key, node);
        }
        // 从右子树中进行删除
        else if (compare &amp;gt; 0)
        {
            return remove(node.right, key, node);
        }
        // 当前节点即为要进行删除的节点
        else
        {
            // 当前要进行删除的节点的数据
            Object result = node.data;
            // 当前要进行删除的节点的左右子树均存在
            if (node.left != null &amp;amp;&amp;amp; node.right != null)
            {
                // 寻找要进行删除节点的替换节点
                AVLTreeNode innext = node.right;
                //要进行替换的节点的双亲节点
                AVLTreeNode innextParent=node;
                // 寻找右子树下的最左孩子节点
                while (innext.left != null)
                {
                    innextParent=innext;
                    innext = innext.left;
                }
                // 改变删除节点的相关数据
                node.data = innext.data;
                node.key = innext.key;
                //递归的删除其进行替换的节点  
                remove(node.right,innext.key,node);
                //对从当前被删除节点开始的到其相应的替换节点的父节点的路径上判断其是否“失衡”且进行相关的旋转操作
                rotate(node,null,innextParent);
            }
            // 以下考虑的情况均当前删除节点缺少左子树或者右子树的情况
            else
            {
                // 当前要进行删除的节点不为根节点的时候
                if (parent != null)
                {
                    // 当左子树不为空的时候
                    if (node.left != null &amp;amp;&amp;amp; node.right == null)
                    {
                        // 当前节点为其左子树节点的时候
                        if (node == parent.left)
                        {
                            parent.left = node.left;
                        }
                        // 当前节点为其右子树节点的时候
                        else
                        {
                            parent.right = node.left;
                        }
                        if(node.left!=null)
                        {
                            //由于其删除节点缺少左子树或者右子树。为此，其只需判断当前删除节点的父节点的失衡情况并进行相应的调整即可
                            rotate(parent,null,node.left);
                        }
                    }
                    // 当右子树不为空的时候或为叶子节点的时候
                    else
                    {
                        // 当前节点为其左子树节点的时候
                        if (node == parent.left)
                        {
                            parent.left = node.right;
                        }
                        // 当前节点为其右子树节点的时候
                        else
                        {
                            parent.right = node.right;
                        }
                        if(node.right!=null)
                        {
                            //由于其删除节点缺少左子树或者右子树。为此，其只需判断当前删除节点的父节点的失衡情况并进行相应的调整即可
                            rotate(parent,null,node.right);
                        }
                    }
                    
                }
                // 当前删除的节点为根节点的时候
                else
                {
                    if (node.left != null)
                        root = node.left;
                    else
                        root = node.right;
                }
            }
            // 返回其进行删除的节点的值
            return result;
        }
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整示例代码如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;相关代码：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package all_in_tree;
/**
 * 该类用于演示平衡二叉树的相关操作
 * @author 学徒
 *
 */
public class AVLTree
{
    //该平衡二叉树的根节点
    private AVLTreeNode root;
    
    /**
     * 对该平衡二叉树进行后续遍历操作(后序遍历的结果是按序排序的)，以便用于验证其测试的结果
     */
    public static void inTravel(AVLTreeNode root)
    {
        if(root!=null)
        {
            inTravel(root.left);
            System.out.print(root.key+&quot;-&quot;+root.data+&quot;\t&quot;);
            inTravel(root.right);
            
        }
    }
    
    /**
     * 用于获取该平衡二叉树
     * @return 该平衡二叉树的根节点指针
     */
    public AVLTreeNode getTree()
    {
        return this.root;
    }
    
    /**
     * 用于得到一棵以root为根节点的树的深度
     * @param root 需要获取的树的深度的根节点指针
     * @return 以root为根节点的树的深度
     */
    private int getDepth(AVLTreeNode root)
    {
        if(root==null)
            return 0;
        return Math.max(getDepth(root.left),getDepth(root.right))+1;
    }
    
    /**
     * 用于判断以root为根节点的二叉树的平衡情况，true为平衡的，false表示并不平衡
     * @param root 要判断其平衡因子的子树的根节点指针
     * @return 以root为根节点的平衡二叉树的平衡情况
     */
    private boolean isBalance(AVLTreeNode root)
    {
        return Math.abs(getDepth(root.left)-getDepth(root.right))&amp;lt;=1;
    }
    
    /**
     * 用于获取以root为根节点的二叉树的平衡因子
     * @param root为求取其平衡因子的子树的根节点的指针
     * @return 平衡因子
     */
    private int getBalance(AVLTreeNode root)
    {
        return getDepth(root.left)-getDepth(root.right);
    }
    
    /**
     * 用于平衡二叉树中的查找操作，并返回相应节点的相关数据，当未查找到时，返回null
     * @param key 要进行查找的节点的关键字
     * @return 得到要进行查找节点的相关数据
     */
    public Object search(Comparable key)
    {
        if(key==null)
            return null;
        return getSearchResult(root,key);
    }
    
    /**
     * 用于辅助平衡二叉树的查找操作，并返回相应的相关节点的数据，当未查找到时，返回null
     * @param root 要进行查找的二叉查找树的根节点
     * @param key 要进行查找的节点的关键字
     * @return 得到要进行查找节点的相关数据
     */
    private Object getSearchResult(AVLTreeNode root,Comparable key)
    {
        if(root==null)
            return null;
        int compare=key.compareTo(root.key);
        if(compare==0)
            return root.data;
        else if(compare==1)
            return getSearchResult(root.right,key);
        else
            return getSearchResult(root.left,key);
    }
    
    /**
     * 以所传入的节点的指针为根节点的二叉树，进行右旋的操作
     * @param node 要进行右旋的二叉树的根节点
     * @return 旋转后的二叉树的根节点的指针
     */
    private AVLTreeNode rightRotate(AVLTreeNode node)
    {
        //用于记录旋转后的结果
        AVLTreeNode result=node.left;
        node.left=result.right;
        result.right=node;
        return result;
    }
    
    /**
     * 以所传入的节点的指针为根节点的二叉树，进行左旋的操作
     * @param node 要进行左旋的二叉树的根节点
     * @return 旋转后的二叉树的根节点的指针
     */
    private AVLTreeNode leftRotate(AVLTreeNode node)
    {
        //用于记录旋转后的结果
        AVLTreeNode result=node.right;
        node.right=result.left;
        result.left=node;
        return result;
    }
    
    /**
     * 用于往二叉树中插入新的节点
     * @param key 二叉树中新节点的关键字
     * @param data 二叉树中新节点的数据
     * @return 插入新节点的结果，如果成功插入一个新节点则返回true，否则返回false，当新增的节点存在于树中时，返回false
     */
    public boolean insert(Comparable key,Object data)
    {
        if(key==null)
            return false;
        else if(root!=null)
        {
            return insertAVLTreeNode(root,null,key,data);
        }
        else
        {
            root=new AVLTreeNode(key,data);
            return true;
        }
    }
    
    /**
     * 辅助往二叉树中插入新的节点
     * @param node 要进行比较的二叉树的节点
     * @param parent 要进行比较的二叉树的节点的父节点
     * @param key 新增节点的关键字值
     * @param data 新增节点的数据
     * @return 新增的结果
     */
    private boolean insertAVLTreeNode(AVLTreeNode node,AVLTreeNode parent,Comparable key,Object data)
    {
        //当当前比较的节点不为空的时候，进行比较操作
        if(node!=null)
        {
            int compare=key.compareTo(node.key);
            if(compare==0)
                return false;
            else if(compare&amp;gt;0)
                return insertAVLTreeNode(node.right,node,key,data);
            else
                return insertAVLTreeNode(node.left,node,key,data);
        }
        //当前的节点为空的时候，进行从其父节点处插入节点的操作。同时，进行旋转判断和相应的操作
        else
        {
            Comparable parentKey=parent.key;
            AVLTreeNode newNode=new AVLTreeNode(key,data);
            int comparable=parentKey.compareTo(key);
            //插入新增节点
            if(comparable&amp;gt;0)
                parent.left=newNode;
            else
                parent.right=newNode;
            //对插入完后的节点进行判断，查看其是否需要进行旋转操作，当需要时，对其进行进行旋转调整平衡二叉树相应的节点情况
            rotate(root,null,newNode);
            return true;
        }
    }
    
    /**
     * 用于辅助新插入节点是否旋转的判断，并作出相应的操作
     * @param root 当前查找的节点的情况
     * @param parent 当前查找节点的双亲节点
     * @param node 进行旋转操作的路径的终止节点
     */
    private void rotate(AVLTreeNode root,AVLTreeNode parent,AVLTreeNode node)
    {
        //由此得出当前查找节点的查找方向
        int compare=root.key.compareTo(node.key);
        //当找到该新增节点的时候，其路径上的各个节点的平衡因子均不“失衡”则直接进行返回,不进行操作
        if(compare==0)
        {
            return;
        }
        //当平衡且当前节点的关键字值小于新增节点的关键字值的时候，往右边进行查找
        else if(compare&amp;lt;0&amp;amp;&amp;amp;isBalance(root))
        {
            //当其路径上的根节点平衡的时候，往右边查找
            rotate(root.right,root,node);
        }
        //当平衡且当前节点的关键字值大于新增节点的关键字值的时候，往左边进行查找
        else if(compare&amp;gt;0&amp;amp;&amp;amp;isBalance(root))
        {
            //当其路径上的子树的根节点平衡的时候，往左边进行查找
            rotate(root.left,root,node);
        }
        //当失衡的时候，对其进行旋转操作
        else 
        {
            //当其父节点为null的时候，不需要对其进行旋转操作，因为此时表示树中的节点数目不超过3个，所以一定不会有失衡的情况产生
            if(parent!=null)
            {
                //当其失衡的时候，对其进行旋转操作
                //用于判断是从其父节点的左边失衡的还是右边
                boolean isLeft=parent.left.key.compareTo(root.key)==0?true:false;
                //用于获取该失衡节点的平衡因子
                int balance=getBalance(root);
                //大于0的时候，要么进行LL型旋转，要么进行LR型旋转
                if(balance&amp;gt;0)
                {
                    //用于获取其孩子节点的平衡因子，根据其平衡因子的情况，进行相应的旋转操作
                    int childBalance=getBalance(root.left);
                    //对其相应的孩子节点为根节点的子树进行左旋
                    if(childBalance&amp;lt;0)
                    {
                        root.left=leftRotate(root.left);
                    }
                    //对以失衡的树的根节点为子树的树进行右旋操作
                    AVLTreeNode rotateNode=rightRotate(root);
                    if(isLeft)
                        parent.left=rotateNode;
                    else
                        parent.right=rotateNode;
                }
                //小于0的时候，要么进行RR型旋转，要么进行RL型旋转
                else
                {
                    //用于获取其孩子节点的平衡因子，根据其平衡因子的情况，进行相应的旋转操作
                    int childBalance=getBalance(root.right);
                    //对其相应的孩子节点为根的子树进行右旋
                    if(childBalance&amp;gt;0)
                    {
                        root.right=rightRotate(root.right);
                    }
                    //对以失衡的树的根节点为子树的树进行左旋操作
                    AVLTreeNode rotateNode=leftRotate(root);
                    if(isLeft)
                        parent.left=rotateNode;
                    else
                        parent.right=rotateNode;
                }
            }
        }
    }
    
    /**
     * 用于进行删除操作
     * @param key 要进行删除操作的节点的关键字值
     * @return 返回所删除节点的数据值,当无相关的删除节点的时候，返回null
     */
    public Object delete(Comparable key)
    {
        if(key==null)
            return null;
        else
            return remove(root,key,null);
    }
    /**
     * 用于辅助进行删除操作的方法
     * @param node 当前比较节点
     * @param parent 当前比较节点的双亲节点
     * @param key 需要进行删除的节点的关键字值
     * @return 返回所删除节点的关键字
     */
    public Object remove(AVLTreeNode node,Comparable key,AVLTreeNode parent)
    {
        if (node != null)
        {
            int compare = key.compareTo(node.key);
            // 从左子树中进行删除
            if (compare &amp;lt; 0)
            {
                return remove(node.left, key, node);
            }
            // 从右子树中进行删除
            else if (compare &amp;gt; 0)
            {
                return remove(node.right, key, node);
            }
            // 当前节点即为要进行删除的节点
            else
            {
                // 当前要进行删除的节点的数据
                Object result = node.data;
                // 当前要进行删除的节点的左右子树均存在
                if (node.left != null &amp;amp;&amp;amp; node.right != null)
                {
                    // 寻找要进行删除节点的替换节点
                    AVLTreeNode innext = node.right;
                    //要进行替换的节点的双亲节点
                    AVLTreeNode innextParent=node;
                    // 寻找右子树下的最左孩子节点
                    while (innext.left != null)
                    {
                        innextParent=innext;
                        innext = innext.left;
                    }
                    // 改变删除节点的相关数据
                    node.data = innext.data;
                    node.key = innext.key;
                    //递归的删除其进行替换的节点  
                    remove(node.right,innext.key,node);
                    //对从当前被删除节点开始的到其相应的替换节点的父节点的路径上判断其是否“失衡”且进行相关的旋转操作
                    rotate(node,null,innextParent);
                }
                // 以下考虑的情况均当前删除节点缺少左子树或者右子树的情况
                else
                {
                    // 当前要进行删除的节点不为根节点的时候
                    if (parent != null)
                    {
                        // 当左子树不为空的时候
                        if (node.left != null &amp;amp;&amp;amp; node.right == null)
                        {
                            // 当前节点为其左子树节点的时候
                            if (node == parent.left)
                            {
                                parent.left = node.left;
                            }
                            // 当前节点为其右子树节点的时候
                            else
                            {
                                parent.right = node.left;
                            }
                            if(node.left!=null)
                            {
                                //由于其删除节点缺少左子树或者右子树。为此，其只需判断当前删除节点的父节点的失衡情况并进行相应的调整即可
                                rotate(parent,null,node.left);
                            }
                        }
                        // 当右子树不为空的时候或为叶子节点的时候
                        else
                        {
                            // 当前节点为其左子树节点的时候
                            if (node == parent.left)
                            {
                                parent.left = node.right;
                            }
                            // 当前节点为其右子树节点的时候
                            else
                            {
                                parent.right = node.right;
                            }
                            if(node.right!=null)
                            {
                                //由于其删除节点缺少左子树或者右子树。为此，其只需判断当前删除节点的父节点的失衡情况并进行相应的调整即可
                                rotate(parent,null,node.right);
                            }
                        }
                        
                    }
                    // 当前删除的节点为根节点的时候
                    else
                    {
                        if (node.left != null)
                            root = node.left;
                        else
                            root = node.right;
                    }
                }
                // 返回其进行删除的节点的值
                return result;
            }
        }
        return null;
    }
    
    /**
     * 测试用例
     * @param args 初始化参数数组
     */
    public static void main(String[] args)
    {
        AVLTree tree=new AVLTree();
        tree.insert(5,&quot;A&quot;);
        tree.insert(2,&quot;B&quot;);
        tree.insert(6,&quot;D&quot;);
        tree.insert(1,&quot;E&quot;);
        tree.insert(3,&quot;C&quot;);
        tree.insert(4,&quot;F&quot;);
        AVLTree.inTravel(tree.getTree());
        System.out.println();
        System.out.println(tree.delete(1));
        AVLTree.inTravel(tree.getTree());
        System.out.println();
        System.out.println(tree.search(5));
    }
}


运行结果如下：

1-E 2-B 3-C 4-F 5-A 6-D 
E
2-B 3-C 4-F 5-A 6-D 
A
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其测试用例所用图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1095776/201801/1095776-20180117234123131-2064566707.png&quot; alt=&quot;完整代码测试用例图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/MyStringIsNotNull/p/8270433.html&quot;&gt;回到目录|·(工)·）&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 15:43:00 +0000</pubDate>
<dc:creator>林学徒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MyStringIsNotNull/p/8306848.html</dc:identifier>
</item>
<item>
<title>[linux] C语言Linux系统编程-TCP通信的11种状态 - 陶士涵</title>
<link>http://www.cnblogs.com/taoshihan/p/8306594.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taoshihan/p/8306594.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/726254/201801/726254-20180117224115615-2051273205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三次握手&lt;/strong&gt;&lt;br/&gt;由client主动发出SYN请求, 此时client处于SYN_SENT状态(第一次握手)&lt;br/&gt;当server收到之后会由LISTEN转变为SYN_REVD状态, 并回复client, client收到应答后处于ESTABLISHED状态, 这个状态就表示client已经准备好通信了(第二次握手)&lt;br/&gt;client收到二次握手应答后回复server, server收到应答之后也处于ESTABLISHED, 表示握手成功, 可以通信了(第三次握手)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据传输&lt;/strong&gt;&lt;br/&gt;然后client和server都处于通信状态, 不会改变&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四次挥手&lt;/strong&gt;&lt;br/&gt;client主动发送FIN请求关闭, 此时client处于FIN_WAIT_1状态(短暂)(第一次挥手)&lt;br/&gt;server收到之后处于CLOSE_WAIT状态(半关闭状态), 并做出应答(第二次挥手)&lt;br/&gt;client收到之后处于FIN_WAIT_2状态, 等待server发送关闭请求.&lt;br/&gt;server会紧接着发送FIN断开请求, 并处于LAST_ACK(第三次挥手)&lt;br/&gt;client收到之后并应答, 此时处于TIME_WAIT状态, 这是主动断开的一端的最后一个状态, 意思是会等待一定的时间(2MSL-1min), 等待之后会变成CLOSED状态(第四次挥手)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TCP的11种状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CLOSED最初状态&lt;br/&gt;1.建立连接三次握手&lt;br/&gt;client                                               server&lt;br/&gt;(1)SYN_SENT       ========&amp;gt;     (2)LISTEN&lt;br/&gt;(4)ESTABLISHED &amp;lt;========      (3)SYN_RCVD&lt;br/&gt;(5)                        =========&amp;gt;    (6)ESTABLISHED&lt;br/&gt;2.数据传输阶段&lt;br/&gt;3.断开连接四次挥手&lt;br/&gt;(1)FIN_WAIT_1  =========&amp;gt;      (2)CLOSE_WAIT&lt;br/&gt;(4)FIN_WAIT_2  &amp;lt;==========    (3)&lt;br/&gt;(6)TIME_WAIT  &amp;lt;==========     (5)LAST_ACK&lt;br/&gt;(7)                     ==========&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用netstat命令查看各种状态：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/726254/201801/726254-20180117230137318-1530903441.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/726254/201801/726254-20180117230152662-514360244.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/726254/201801/726254-20180117230634459-1693215450.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/726254/201801/726254-20180117230716412-1106790126.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务端监听本机1234端口，客户端进行连接,TIME_WAIT状态维持时间是两个MSL时间长度，也就是在1-4分钟,自动关掉&lt;/p&gt;
&lt;p&gt;参照代码：&lt;/p&gt;
&lt;p&gt;client.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/socket.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建套接字&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; sock = socket(AF_INET, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向服务器（特定的IP和端口）发起请求&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in serv_addr;
    memset(&lt;/span&gt;&amp;amp;serv_addr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(serv_addr));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个字节都用0填充&lt;/span&gt;
    serv_addr.sin_family = AF_INET;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用IPv4地址&lt;/span&gt;
    serv_addr.sin_addr.s_addr = inet_addr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体的IP地址&lt;/span&gt;
    serv_addr.sin_port = htons(&lt;span&gt;1234&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口&lt;/span&gt;
    connect(sock, (&lt;span&gt;struct&lt;/span&gt; sockaddr*)&amp;amp;serv_addr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(serv_addr));
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取服务器传回的数据&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; buffer[&lt;span&gt;40&lt;/span&gt;&lt;span&gt;];
    read(sock, buffer, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;(buffer)-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Message form server: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buffer);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sleep(60);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭套接字&lt;/span&gt;
&lt;span&gt;    close(sock);
    sleep(&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;server.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/socket.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;netinet/&lt;span&gt;in&lt;/span&gt;.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建套接字&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; serv_sock =&lt;span&gt; socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将套接字和IP、端口绑定&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in serv_addr;
    memset(&lt;/span&gt;&amp;amp;serv_addr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(serv_addr));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个字节都用0填充&lt;/span&gt;
    serv_addr.sin_family = AF_INET;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用IPv4地址&lt;/span&gt;
    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体的IP地址&lt;/span&gt;
    serv_addr.sin_port = htons(&lt;span&gt;1234&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口&lt;/span&gt;
    bind(serv_sock, (&lt;span&gt;struct&lt;/span&gt; sockaddr*)&amp;amp;serv_addr, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(serv_addr));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入监听状态，等待用户发起请求&lt;/span&gt;
    listen(serv_sock, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收客户端请求&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in clnt_addr;
    socklen_t clnt_addr_size &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(clnt_addr);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; clnt_sock = accept(serv_sock, (&lt;span&gt;struct&lt;/span&gt; sockaddr*)&amp;amp;clnt_addr, &amp;amp;&lt;span&gt;clnt_addr_size);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向客户端发送数据&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt; str[] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    write(clnt_sock, str, &lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(str));
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭套接字&lt;/span&gt;
&lt;span&gt;    close(clnt_sock);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    close(serv_sock);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5.c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;36L&lt;/span&gt;, 1183C                                                                                    &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;           Top
    close(serv_sock);
    sleep(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 17 Jan 2018 15:16:00 +0000</pubDate>
<dc:creator>陶士涵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taoshihan/p/8306594.html</dc:identifier>
</item>
<item>
<title>【jQuery】(7)---jQueryAjax同步异步区别 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/8306693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/8306693.html</guid>
<description>&lt;p&gt;   今天在项目开发过程中，要实现这么一个功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 当我点击就业的时候，触发onclick时间,check()方法里通过ajax请求返回数据，
  如果该用户已经毕业可以跳转到job.html如果没有毕业不能跳转页面同时弹框提示 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;job.html&quot;&lt;/span&gt;&lt;span&gt;  onclick&lt;/span&gt;&lt;span&gt;=&quot;return check()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;就业&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们都知道onclick是优先执行于href属性的，只有onclick返回true才会执行href。接下来看js怎么写的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; check(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fal=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        $.post(&lt;/span&gt;&quot;URL&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(date){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(date==&lt;span&gt;null&lt;/span&gt; || date==&quot;&quot;&lt;span&gt;){
                fal&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; fal;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实这个return也只是返回ajax中function的返回值。而不是check()的返回值&lt;/span&gt;
            }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                alert(&lt;/span&gt;&quot;请先毕业才能就业&quot;&lt;span&gt;)
            }
        })
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fal;
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;最终发现如果该用户已经毕业，a标签没有任何反应，
        如果还没有毕业，会提示：请先毕业才能就业。界面也是没有反应&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就很纳闷了，明明返回数据是空，fal变成了ture，怎么最终返回还是false。这就是同步和异步的区别了。&lt;/p&gt;
&lt;p&gt;首先，ajax默认情况下是异步的，那什么是异步呢&lt;/p&gt;
&lt;p&gt;async默认的设置值为true，这种情况为异步方式，就是说当ajax发送请求后，在等待server端返回的这个过程中，前台会继续 执行ajax块后面的脚本，直到server端返回正确的结果才会去执行success，也就是说这时候执行的是两个线程，ajax块发出请求后一个线程 和ajax块后面的脚本（另一个线程）&lt;/p&gt;
&lt;p&gt;js举例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    $(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {  
            $.ajax({  
                type : &lt;/span&gt;'post'&lt;span&gt;,  
               &lt;span&gt;&lt;strong&gt; async : &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;, &lt;/strong&gt; &lt;/span&gt;
                url : &lt;/span&gt;''&lt;span&gt;,  
                cache : &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,  
                data : {},  
                success : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){  
                    alert(&lt;/span&gt;&quot;1111&quot;&lt;span&gt;);  
                }  
            });  
            alert(&lt;/span&gt;&quot;22222&quot;&lt;span&gt;);  
        });  
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;在这里方法中，因为它是异步的，所以它在通过ajax向后端交互的同时，它还会向下执行js代码，就相当于有两个线程
        所以这里是会先弹出&quot;2222&quot;,才会弹出&quot;1111&quot;,到这个时候，才知道为什么上面js为什么总是返回false，因为异步的时候
        它先执行了下面的return fal,就已经返回flase了&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以我们只要把async的属性值改为false就变成同步了&lt;/p&gt;
&lt;p&gt;$.post没有这个同步异步设置 ，如果一定要设置异步，只能在执行$.post之前加$.ajaxSettings.async = false; (同步执 &lt;br/&gt;行) &lt;/p&gt;
&lt;p&gt;所以把最上面js改成同步，就可以实现相关功能了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; check(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fal=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
         $.ajax({  
                type: &lt;/span&gt;&quot;POST&quot;&lt;span&gt;,  
                url: &lt;/span&gt;&quot;url&quot;&lt;span&gt;,  
               &lt;strong&gt;&lt;span&gt; async:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;false, &lt;/span&gt; &lt;/strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同步方式   &lt;/span&gt;
                success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(re){  
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(re==&lt;span&gt;null&lt;/span&gt;||re==&quot;&quot;&lt;span&gt;){
                        fal&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;        
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        alert(&lt;/span&gt;&quot;请先毕业才能就业&quot;&lt;span&gt;);    
                  } 
                } 
            }); 
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fal; 
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步和异步的区别                                         &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;简单理解：&lt;/strong&gt;&lt;/span&gt;同步的意思是当JS代码加载到当前AJAX的时候会把页面里所有的代码停止加载，页面出去假死状态，当这个AJAX执行完毕后才会继续运行其他代码页面假死状态解除。 &lt;br/&gt;而异步则这个AJAX代码运行中的时候其他代码一样可以运行。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;异步：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在异步模式下，当我们使用AJAX发送完请求后，可能还有代码需要执行。这个时候可能由于种种原因导致服务器还没有响应我们的请求，但是因为我们采用了异步执行方式，所有包含AJAX请求代码的函数中的剩余代码将继续执行。如果我们是将请求结果交由另外一个JS函数去处理的，那么，这个时候就好比两条线程同时执行一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同步&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;在同步模式下，当我们使用AJAX发送完请求后，后续还有代码需要执行，我们同样将服务器响应交由另一个JS函数去处理，但是这时的代码执行情况是：在服务器没有响应或者处理响应结果的JS函数还没有处理完成return时，包含请求代码的函数的剩余代码是不能够执行的。就好比单线程一样，请求发出后就进入阻塞状态，知道接触阻塞余下的代码才会继续执行。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;如果哪里理解不到位，或者理解错了，欢迎指点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;想的太多，做的太少，中间的落差就是烦恼，要么去做，要么别想 &lt;/strong&gt;少尉【17】&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 17 Jan 2018 15:06:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/8306693.html</dc:identifier>
</item>
<item>
<title>别让自己跟着思维走 - skyflask</title>
<link>http://www.cnblogs.com/skyflask/p/8306590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyflask/p/8306590.html</guid>
<description>&lt;p&gt;今天和几个同事一边吃饭一边瞎聊，期间从《人民的名义》中高育良，谈到大学校长的级别，再谈到一个县长在现实中都了不得，随随便便都是手里流水几个亿。突然，禄总冒出一句，“你们是不是每次看小说时，都把自己都当主角？”，禄总接着说，“其实在现实中你只是个路人甲。上大学那会儿看《射雕英雄传》，看到江南七怪这么差的武功，都有些轻视。但是从学校毕业出来以后，发现自己连电影里江南七怪一个脚趾头都比不上，现实中自己连电影中的路人甲都不是。”&lt;/p&gt;
&lt;p&gt;回家的路上，在车上想着自己当初毕业的那会儿，和所有将要毕业的大学生一样。意气风发，想着年薪百万，当上CEO迎娶白富美的美梦。自从步入社会后，逐渐才知道梦想太丰满，现实太骨感。一切和自己毕业前想想的完全不一样，一路升级打怪，可谓举步维艰。&lt;/p&gt;
&lt;p&gt;我想每个人都应该有过类似的经历：时常在工作中生怕自己做得不够好而自责，心里抱怨自己还可以更做得更好；或者某次同学聚会后，发现同学们都混得那么好，每次聚会回家后都责怪自己不够努力。。。。。由此，人生也便有了烦恼，久而久之，就成了痛苦，一直伴随在你生活中。&lt;/p&gt;
&lt;p&gt;虽然我们生活慢慢变得好了起来，工资也越来越可观。但是，快乐似乎并没有和工资一样上涨，而是随着房子、车子、妻子、孩子.....，反而是痛苦增加。&lt;/p&gt;
&lt;p&gt;为什么会变得这样呢？很久之前我一直在苦苦思考这其中的原因。&lt;/p&gt;
&lt;p&gt;今天听到禄总这句话后，突然冒出一个想法：我是不是一直让自己跟着思维走，才会让自己无法从中脱离出来，而导致作茧自缚，将自己越绑越紧。那么，问题又来了，我让自己跟着思维走，这里是不是出现了三个对象：我、自己、思维。那么，谁才是真正的我呢？我？自己？思维？很奇特吧。&lt;/p&gt;
&lt;p&gt;经过一番分析，三个对象如下：&lt;/p&gt;
&lt;p&gt;&quot;我&quot;是真正的我，或者说是最真实的自己、最本质的自己；&lt;/p&gt;
&lt;p&gt;&quot;自己&quot;是一个虚我，也就是思维勾画出来的我，虚的。关于真我和虚我，后面我会继续思考并搞清楚，为什么会产生这两个对象以及他们是怎么产生的？&lt;/p&gt;
&lt;p&gt;“思维”是大脑通过后天在社会中形成自己的思维体系后，对所接触的事务进行分析、对比、归类、类比而形成的一些方式，也就是一些常规模式或套路。&lt;/p&gt;
&lt;p&gt;比如一个正常的成年男孩，看到一个成年女孩后，可能在大脑里会对女孩进行分析，是美是丑？是否有男友？是否可以做她的男友？这样，“自己”就会随着思维去思考，自己就会随着思维把自己当住主角去上演电影或者一些生活中的情景。其实，此时你已经被思维控制，你已然已经成为了思维的奴隶。其实，佛教里面的有一句比较经典的话：众生为了短暂的欲乐，终日作五欲的奴隶，不得出离三界。少欲知足，才是幸福安乐之道。&lt;/p&gt;
&lt;p&gt;如此一来，“虚我”不知不觉的成为了思维的奴隶。一旦在现实中和“虚我”所想的或所欲望得到的不一样时，痛苦变产生了。就像上面你看到一个美丽的女孩后，思维里面想着是否可以和她一起吃饭、一起玩啊，一旦你看到这个美丽女孩亲切的挽着她男朋友的手，步入了豪车中时，“虚我”就开始变得失望或者羡慕，如果心态或者三观不正，则会产生仇视或嫉妒的心里。正所谓没有希望就不会失望，正是因为你希望的太多，才会失望得越多。&lt;/p&gt;
&lt;p&gt;以上，你清清楚楚的看到了自己跟着思维走的后果了吧。它不但时你痛苦的来源，更是你产生欲望的原因。&lt;/p&gt;
&lt;p&gt;不要让自己跟着思维走，看到美好事物的时候，请不要心生邪念，静静地欣赏，默默地祝福就好；&lt;/p&gt;
&lt;p&gt;不要让自己跟着思维走，遇到难事的时候，请不要带有情绪，内心对自己说，事情已经发生，时间会帮我解决；&lt;/p&gt;
&lt;p&gt;不要让自己跟着思维走，不如意的时候，请不要抱怨，其实如意不如意都是思维的产物，和你没有任何关系。&lt;/p&gt;
&lt;p&gt;不要让自己跟着思维走，其实，思维只是让你觉得自己存在而已。&lt;/p&gt;

</description>
<pubDate>Wed, 17 Jan 2018 14:44:00 +0000</pubDate>
<dc:creator>skyflask</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyflask/p/8306590.html</dc:identifier>
</item>
<item>
<title>Video Target Tracking Based on Online Learning—TLD单目标跟踪算法详解 - 在海一方美猴王</title>
<link>http://www.cnblogs.com/liuyihai/p/8306419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyihai/p/8306419.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;视频目标跟踪问题分析&lt;/span&gt;        &lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;        视频跟踪技术的主要目的是从复杂多变的的背景环境中准确提取相关的目标特征，准确地识别出跟踪目标，并且对目标的位置和姿态等信息精确地定位，为后续目标物体行为分析提供足够的数据。但是目前的绝大部分目标跟踪算法或多或少存在不少缺点，如：1）对目标的实时跟踪时，跟踪时间过长，目标容易丢失；2）当目标发生形变时（目标伪装、摄像平台变化导致），无法进行目标跟踪；3）当视频中目标消失（遮挡等）以后重新出现时，不能重新跟踪捕获目标，或出现混批； 4）有一些给定很少特定目标特征先验知识时，也不能够迅速地跟踪目标。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;在线学习视频目标跟踪&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;算法&lt;/span&gt;&lt;/strong&gt;TLD&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;         对于长时间跟踪而言，一个关键的问题是：当目标重新出现在相机视野中时，系统应该能重新检测到它，并开始重新跟踪。但是，长时间跟踪过程中，被跟踪目标将不可避免的发生形状变化、光照条件变化、尺度变化、遮挡等情况。传统的跟踪算法，前端需要跟检测模块相互配合，当检测到被跟踪目标之后，就开始进入跟踪模块，而此后，检测模块就不会介入到跟踪过程中。但这种方法有一个致命的缺陷：即，当被跟踪目标存在形状变化或遮挡时，跟踪就很容易失败；因此，对于长时间跟踪，或者被跟踪目标存在形状变化情况下的跟踪，很多人采用检测的方法来代替跟踪。该方法虽然在某些情况下可以改进跟踪效果，但它需要一个离线的学习过程。即：在检测之前，需要挑选大量的被跟踪目标的样本来进行学习和训练。这也就意味着，训练样本要涵盖被跟踪目标可能发生的各种形变和各种尺度、姿态变化和光照变化的情况。换言之，利用检测的方法来达到长时间跟踪的目的，对于训练样本的选择至关重要，否则，跟踪的鲁棒性就难以保证。&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        TLD(Tracking-Learning-Detection)是英国萨里大学的一个捷克籍博士生Zdenek Kalal在其攻读博士学位期间提出的一种新的单目标长时间（long term tracking）跟踪算法。&lt;strong&gt;该算法与传统跟踪算法的显著区别在于将传统的跟踪算法和传统的检测算法相结合来解决被跟踪目标在被跟踪过程中发生的形变、部分遮挡等问题。同时，通过一种改进的在线学习机制不断更新跟踪模块的“显著特征点”和检测模块的目标模型及相关参数，从而使得跟踪效果更加稳定、鲁棒、可靠。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;        简单来说，TLD算法由三部分组成：跟踪模块、检测模块、学习模块；如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117203255396-758397019.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;TLD算法机理&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;        &lt;span&gt;上图中&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;， &lt;span class=&quot;fontstyle2&quot;&gt;TLD &lt;span class=&quot;fontstyle0&quot;&gt;算法由跟踪、检测和学习三大模块构成。首先跟踪模块对视频序列中要跟踪的目标采用跟踪器&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;跟踪，判断物体目标在下一帧中的位置， 若目标消失在视频或大量被遮挡，则跟踪失败；其次检测部分主要由分类器构成，分类器通过对视频序列中大量的特征值进行检测归类，找出其中最有可能出现跟踪物体目标的区域，然后综合跟踪部分共同输出决定下一帧中物体目标的方位，如果前面跟踪部分失败，检测成功，则检测部分就会重新初始化跟踪部分， 在下一帧的时候，跟踪模块重新跟踪成功目标。最后对于学习部分，跟踪产生的结果和检测产生的结果又会动态地影响到学习部分，反过来学习模块又会训练改善分类器影响检测的结果。总之检测模块与学习模块相互作用， 不断地动态改善相关过程，提高对跟踪目标的准确性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;strong&gt;TLD&lt;/strong&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;算法实现框图及原理分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;p0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;        TLD的详细实现框图如下图所示。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117204343959-2109923165.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;TLD实现框图&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;        &lt;span&gt;从此图中可以看出，首先在视频序列的初始位置，我们先对要跟踪的物体进行相关目标标定，然后此目标位置进入跟踪器中&lt;/span&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;进行跟踪，跟踪的结果会反馈到学习模块中，其次在学习模块中由于初始视频序列帧中存在要跟踪物体特征，就可以作为正样本，再通过相关方法选取些负样本训练检测器，这样在初始的时候检测器和跟踪器都有了相应的判决标准。接着就可以让视频序列流逐帧的通过检测器和跟踪器，当检测器和跟踪器得到跟踪结果后，一方面通过综合模块输出显示在相应位置，另一方面，他们又会作用学习模块，重新让学习模块训练检测器，始终保证检测器中跟踪目标的特征点在实时进行更新。在此过程中，学习模块中存在一个在线模型其作用是匹配每次通过跟踪器或检测器的图像片是否确实含有前景目标，其也是动态更新的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;        下面分解讲述TLD算法框图中跟踪、检测、学习和综合模块的实现原理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;-----------------------------------------------------&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;跟踪器&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;---------------------------------------------&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;  &lt;span&gt;      TLD使用Median-Flow追踪算法（光流跟踪器）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;假设一个“好”的追踪算法应该具有&lt;strong&gt;正反向连续性&lt;/strong&gt;（forward-backward consistency），即无论是按照时间上的正序追踪还是反序追踪，产生的轨迹应该是一样的。作者根据这个性质规定了任意一个追踪器的&lt;strong&gt;FB误差&lt;/strong&gt;（forward-backward error）：从时间t的初始位置x(t)开始追踪产生时间t+p的位置x(t+p)，再从位置x(t+p)反向追踪产生时间t的预测位置x`(t)，&lt;strong&gt;初始位置&lt;/strong&gt;和&lt;strong&gt;预测位置&lt;/strong&gt;之间的&lt;strong&gt;欧氏距离&lt;/strong&gt;就作为追踪器在t时间的FB误差。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117204940412-387406418.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;        在光流法中为了处理三维空间中的目标物体的问题，它先将运动目标从三维空间映射到二维平面上，计算像素运动的瞬时速度，然后根据图像序列相邻两帧中像素点值在时域上的强度变化和相关性来确定图像中物体目标运动到下一帧情况，最终发现目标运动信息。&lt;/span&gt;只需要知道给定若干追踪点，追踪器会根据像素的运动情况确定这些追踪点在下一帧的位置。&lt;strong&gt;追踪点的选择：&lt;/strong&gt;作者给出了一种依据FB误差绘制误差图（Error Map）筛选最佳追踪点的方法，但并不适用于实时追踪任务，就不详细介绍了。这里只介绍在TLD中确定追踪点的方法。首先在上一帧t的物体包围框里&lt;strong&gt;均匀地产生一些点&lt;/strong&gt;，然后用&lt;strong&gt;Lucas-Kanade追踪器正向追踪&lt;/strong&gt;这些点到t+1帧，再&lt;strong&gt;反向追踪&lt;/strong&gt;到t帧，计算FB误差，筛选出FB误差最小的&lt;strong&gt;一半点&lt;/strong&gt;作为最佳追踪点。最后根据这些点的&lt;strong&gt;坐标变化&lt;/strong&gt;和&lt;strong&gt;距离的变化&lt;/strong&gt;计算t+1帧包围框的&lt;strong&gt;位置&lt;/strong&gt;和&lt;strong&gt;大小&lt;/strong&gt;（平移的尺度取中值，缩放的尺度取中值。&lt;strong&gt;取中值的光流法&lt;/strong&gt;，估计这也是名称Median-Flow的由来吧）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117210131209-1467216980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;        还可以用&lt;strong&gt;NCC&lt;/strong&gt;（Normalized Cross Correlation，归一化互相关）和&lt;strong&gt;SSD&lt;/strong&gt;（Sum-of-Squared Differences，差值平方和）作为筛选追踪点的衡量标准。作者的代码中是把FB误差和NCC结合起来的，所以筛选出的追踪点比原来一半还要少。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;NCC：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117210223021-575336287.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SSD：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117210241131-2033160441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;-----------------------------------------------------&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;strong&gt;学习模块&lt;/strong&gt;---------------------------------------------&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　TLD使用的机器学习方法是作者提出的&lt;strong&gt;P-N学习&lt;/strong&gt;（P-N Learning）。P-N学习是一种&lt;strong&gt;半监督&lt;/strong&gt;的机器学习算法，它针对检测器对样本分类时产生的&lt;strong&gt;两种错误&lt;/strong&gt;提供了两种“专家”进行纠正：（&lt;span&gt;&lt;strong&gt;PN学习可参考&lt;/strong&gt;：&lt;a href=&quot;http://blog.csdn.net/carson2005/article/details/7647519&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/carson2005/article/details/7647519&lt;/a&gt;&lt;/span&gt;）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                P专家（P-expert）：检出漏检（false negative，正样本误分为负样本）的正样本；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                N专家（N-expert）：改正误检（false positive，负样本误分为正样本）的正样本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;样本的产生：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        用不同尺寸的&lt;strong&gt;扫描窗&lt;/strong&gt;（scanning grid）对图像进行逐行扫描，每在一个位置就形成一个包围框（bounding box），包围框所确定的图像区域称为一个图像元（patch），图像元进入机器学习的样本集就成为一个样本。扫描产生的样本是未标签样本，需要用分类器来分类，确定它的标签。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        如果算法已经确定物体在t+1帧的位置（实际上是确定了相应包围框的位置），从&lt;strong&gt;检测器产生的包围框&lt;/strong&gt;中筛选出10个与它距离最近的包围框（两个包围框的交的面积除以并的面积大于0.7），对每个包围框做微小的&lt;strong&gt;仿射变换&lt;/strong&gt;（平移10%、缩放10%、旋转10°以内），产生20个图像元，这样就产生&lt;strong&gt;200个正样本&lt;/strong&gt;。再选出若干距离较远的包围框（交的面积除以并的面积小于0.2），产生&lt;strong&gt;负样本&lt;/strong&gt;。这样产生的样本是已标签的样本，把这些样本放入训练集，用于更新分类器的参数。下图中的a图展示的是扫描窗的例子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117210541646-402255985.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;作者认为，算法的结果应该具有&lt;strong&gt;“结构性”&lt;/strong&gt;：每一帧图像内物体最多只出现在一个位置；相邻帧间物体的运动是连续的，连续帧的位置可以构成&lt;strong&gt;一条较平滑的轨迹&lt;/strong&gt;。比如像上图c图那样每帧只有一个正的结果，而且连续帧的结果构成了一条平滑的轨迹，而不是像b图那样有很多结果而且无法形成轨迹。还应该注意在整个追踪过程中，&lt;strong&gt;轨迹可能是分段&lt;/strong&gt;的，因为物体有可能中途消失，之后再度出现。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       &lt;strong&gt; P专家的作用&lt;/strong&gt;是寻找数据在&lt;strong&gt;时间&lt;/strong&gt;上的结构性，它利用&lt;strong&gt;追踪器&lt;/strong&gt;的结果预测物体在t+1帧的位置。如果这个位置（包围框）被检测器分类为负，P专家就把这个位置改为正。也就是说P专家要保证物体在连续帧上出现的位置可以&lt;strong&gt;构成连续的轨迹&lt;/strong&gt;；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;strong&gt;N专家的作用&lt;/strong&gt;是寻找数据在&lt;strong&gt;空间&lt;/strong&gt;上的结构性，它把&lt;strong&gt;检测器&lt;/strong&gt;产生的和P专家产生的所有正样本进行比较，选择出一个最可信的位置，保证物体最多只出现在一个位置上，&lt;strong&gt;把这个位置作为TLD算法的追踪结果&lt;/strong&gt;。同时这个位置也用来&lt;strong&gt;重新初始化追踪器&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117210728178-1969468952.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        比如在这个例子中，目标车辆是下面的深色车，每一帧中黑色框是检测器检测到的正样本，黄色框是追踪器产生的正样本，红星标记的是每一帧最后的追踪结果。在第t帧，检测器没有发现深色车，但P专家根据追踪器的结果认为深色车也是正样本，N专家经过比较，认为深色车的样本更可信，所以把浅色车输出为负样本。第t+1帧的过程与之类似。第t+2帧时，P专家产生了错误的结果，但经过N专家的比较，又把这个结果排除了，算法仍然可以追踪到正确的车辆。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-----------------------------------------------------检测&lt;/strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;strong&gt;模块&lt;/strong&gt;---------------------------------------------&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        检测模块使用一个&lt;strong&gt;级联分类器&lt;/strong&gt;，对从包围框获得的样本进行分类。级联分类器包含三个级别，如下图所示：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117222052646-1128652993.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;strong&gt;图像元方差分类器&lt;/strong&gt;&lt;span&gt;（Patch Variance Classifier）。计算图像元像素灰度值的方差，把方差小于原始图像元方差一半的样本标记为负。论文提到在这一步可以排除掉一半以上的样本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;strong&gt;集成分类器&lt;/strong&gt;（Ensemble Classifier）。实际上是一个随机蕨分类器（Random Ferns Classifier），类似于随机森林（Random Forest：参考：http://blog.sina.com.cn/s/blog_9dff1a7501015xm7.html），区别在于随机森林的树中每层节点判断准则不同，而随机蕨的“蕨”中每层只有一种判断准则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117211555412-815330350.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        如上图所示，把左面的树每层节点改成相同的判断条件，就变成了右面的蕨。所以蕨也不再是树状结构，而是线性结构。随机蕨分类器根据样本的特征值判断其分类。从图像元中任意选取两点A和B，比较这两点的亮度值，若A的亮度大于B，则特征值为1，否则为0。每选取一对新位置，就是一个新的特征值。蕨的每个节点就是对一对像素点进行比较。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        比如取&lt;strong&gt;5对点&lt;/strong&gt;，红色为A，蓝色为B，样本图像经过含有&lt;strong&gt;5个节点的蕨&lt;/strong&gt;，每个节点的结果按顺序排列起来，得到长度为5的二进制序列01011，转化成十进制数字11。这个11就是该样本经过这个蕨得到的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117211622974-1390947284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        同一类的很多个样本经过同一个蕨，得到了该类结果的分布直方图。高度代表类的先验概率p(F|C)，F代表蕨的结果（如果蕨有s个节点，则共有1+2^s种结果）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117211646974-659064961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不同类的样本经过同一个蕨，得到不同的先验概率分布。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117211713303-1853209140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;以上过程可以视为对分类器的训练。当有新的未标签样本加入时，假设它经过这个蕨的结果为00011（即3），然后从已知的分布中寻找后验概率最大的一个。由于样本集固定时，右下角公式的分母是相同的，所以只要找在F=3时高度最大的那一类，就是新样本的分类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117211836443-1944982396.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;只&lt;/strong&gt;用一个蕨进行分类会有较大的偶然性。另取5个新的特征值就可以构成新的蕨。用很&lt;strong&gt;多个蕨&lt;/strong&gt;对同一样本分类，投票数最大的类就作为新样本的分类，这样在很大程度上提高了分类器的准确度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;最近邻分类器&lt;/strong&gt;（Nearest Neighbor Classifier）。计算新样本的相对相似度，如大于0.6，则认为是正样本。相似度规定如下： 图像元pi和pj的相似度，公式里的N是规范化的相关系数，所以S的取值范围就在[0,1]之间，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117212015787-1458310239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正最近邻相似度，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117212041693-1212374600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;负最近邻相似度，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117212105818-1359344530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相对相似度，取值范围在[0,1]之间，值越大代表相似度越高，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117212129490-1839105079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，检测器是追踪器的监督者，因为检测器要改正追踪器的错误；而追踪器是训练检测器时的监督者，因为要用追踪器的结果对检测器的分类结果进行监督。用另一段程序对训练过程进行监督，而不是由人来监督，这也是称P-N学习为“半监督”机器学习的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;-----------------------------------------------------综合&lt;/strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;strong&gt;模块&lt;/strong&gt;---------------------------------------------&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;        综合模块是跟踪、检测结果汇总输出。检测模块会影响到跟踪模块的最终结果，没有跟踪到目标也有可能最终通过检测模块得到目标框，跟踪模块和检测模块共同定位输出的跟踪目标框位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117213029912-447207716.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;        &lt;span&gt;上图 &lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;是 &lt;span class=&quot;fontstyle2&quot;&gt;TLD &lt;span class=&quot;fontstyle0&quot;&gt;算法综合模块的处理框架。首先， 求得所有通过的检测模块（就是成功通过三大分类器后的）的矩形框两两之间的重叠度和其相似度， 然后&lt;span class=&quot;fontstyle0&quot;&gt;将重叠度和相似度进行聚类&lt;span class=&quot;fontstyle1&quot;&gt;[32]&lt;span class=&quot;fontstyle0&quot;&gt;得到聚类后的重叠度与相似度，将此结果保存；其次，求出跟踪模块的重叠度与相似度，将结果予以保存。最后对两个结果进行比对，综合相关条件进行判断，从而输出最后定位的目标框位置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;        综合模块将跟踪与检测模块的结果予以汇总判断， 完成定位跟踪目标的边界框。按照检测模块能否检测成功，跟踪模块是能否跟踪成功的原则， 两两进行组合。会有四种情况， 即就是跟踪成功检测成功； 跟踪成功检测失败； 跟踪失败检测成功；跟踪失败检测失败。 下面分别对四种情况一一分析：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        （&lt;/span&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span&gt;1&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;） 跟踪成功检测成功&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        检测成功指的是至少有一个滑动窗口通过检测模块，所以根据通过通过检测的滑动窗口数量，分为三种情况考虑。一是，如果通过后只有一个矩形框，不进行&lt;/span&gt;&lt;span&gt;聚类，直接计算相关相似度，得到的信息直接进入信息综合判定处。二是，如果通过后有两个矩形框，则首先计算两个矩形框的重叠度，再计算相似度，最后将&lt;/span&gt;&lt;span&gt;他们的结果聚类输出到信息综合判定处。三是， 如果通过后的矩形框多于两个，则分别计算窗口两两之间的重叠度，按照重叠度与阈值的关系将其分为多个等价&lt;/span&gt;&lt;span&gt;类。为了便于理解，特举一实例。如果此时通过检测模块后有七个矩形框，通过计算两两间的重叠度并与阈值相比较，发现&lt;/span&gt; &lt;span class=&quot;fontstyle2&quot;&gt;&lt;span&gt;1,2,3&lt;/span&gt; &lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;是一类计为&lt;/span&gt; &lt;span class=&quot;fontstyle2&quot;&gt;&lt;span&gt;A&lt;/span&gt; &lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;类，&lt;/span&gt; &lt;span class=&quot;fontstyle2&quot;&gt;&lt;span&gt;4,5&lt;/span&gt; &lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;是一类计&lt;/span&gt;&lt;span&gt;为&lt;/span&gt; &lt;span class=&quot;fontstyle2&quot;&gt;&lt;span&gt;B&lt;/span&gt; &lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;类，&lt;/span&gt; &lt;span class=&quot;fontstyle2&quot;&gt;&lt;span&gt;6,7&lt;/span&gt; &lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;是一类计为&lt;/span&gt; &lt;span class=&quot;fontstyle2&quot;&gt;&lt;span&gt;C&lt;/span&gt; &lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;类，这个过程就完成了聚类。然后统计出&lt;/span&gt; &lt;span class=&quot;fontstyle2&quot;&gt;&lt;span&gt;A&lt;/span&gt; &lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;类、&lt;/span&gt; &lt;span class=&quot;fontstyle2&quot;&gt;&lt;span&gt;B&lt;/span&gt; &lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;类、&lt;/span&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span&gt;C&lt;/span&gt; &lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;类的相关信息，如坐标信息，高度、宽度，保守相似度等。对于每一种类型信息&lt;/span&gt;&lt;span&gt;求其平均值作为最终的参数值保存输出到信息综合判定处。另一方面，跟踪模块也有通过的矩形框。计算通过检测模块的矩形框与通过跟踪模块的矩形框的重叠度。如果重叠度很小但是通过检测模块矩形框的保守相似&lt;/span&gt;&lt;span&gt;度大于通过检测模块矩形框的保守相似度，这时候认为寻找成功了一个聚类中心离跟踪模块得到的矩形框距离较远但是比跟踪模块更加可信。这时候重新用检测模块的那个矩形框的参数重新初始化跟踪器，并输出定位目标。如果重叠度很大则将通过检测模块的矩形框和通过跟踪模块的矩形的信息值按照权位值累加方式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;求其平均值，其中跟踪模块占据的比重大，检测模块占据的比重小，即就是检测模块辅助纠正跟踪模块定位的矩形框。总之，如果有跟踪到目标框并检测到目标框，那么对检测到的结果聚类得到相&lt;/span&gt;&lt;span&gt;关输出结果，判断聚类中心与跟踪器的重叠率和可信度，如果两者重叠度低且检测模块的可信度更高，那么用检测模块的结果修正跟踪模块的结果，也即用检测&lt;/span&gt;&lt;span&gt;器修正跟踪器；如果重叠率接近，那么用检测器和跟踪器结果加权平均得到结果作为最终输出结果，其中跟踪器的权重更大。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;        （&lt;/span&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span&gt;2&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;） 跟踪成功检测失败&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        如果特征矩形框通过模块跟踪后，跟踪成功。但是检测器分类后没有矩形框，这时候认为跟踪成功，直接将跟踪成功的矩形框输出作为最终的定位目标框的参&lt;/span&gt;&lt;span&gt;数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        （&lt;/span&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;） 跟踪失败检测成功&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        如果跟踪模块跟踪失败，但是通过检测模块有至少一个矩形框检测成功。 将检测模块的矩形框进行聚类，如果最终聚类的结果只有一个聚类中心，则用此聚&lt;/span&gt;&lt;span&gt;类的结果重新初始化跟踪模块，并将聚类的结果作为定位输出结果。如果聚类中心有多个，说明虽然通过了检测器，但是有多个不同的位置，也认为检测失败，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不输出结果。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        （&lt;/span&gt;&lt;span class=&quot;fontstyle1&quot;&gt;&lt;span&gt;4&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span&gt;）跟踪失败检测失败&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         如果跟踪和检测模块均失败了，则认为此次检测之间无效，丢弃。综上所述，对于综合模块，其实就是用跟踪模块和检测模块的结果进行综合&lt;/span&gt;&lt;span&gt;考虑，前提是检测器有检测到目标框的结果，对目标框进行聚类得到聚类结果，然后根据跟踪器的结果的情况来分析： 如果根据模块跟踪的结果存在存在，观察&lt;/span&gt;&lt;span&gt;跟踪模块与检测模块聚类后的重叠率，如果重叠率低但是检测模块的可信度高，用检测模块聚类后的结果去修正跟踪模块的参数；如果重叠率接近，将跟踪模块&lt;/span&gt;&lt;span&gt;的结果和检测模块聚类后加权平均得到当前帧跟踪结果的输出结果，但是跟踪器权重较大；如果跟踪模块没有跟踪到目标框，看检测模块中聚类结果是否只有一&lt;/span&gt;&lt;span&gt;个中心，是则以其为当前帧跟踪结果，如果不只一个中心则将聚类结果丢弃，当前帧没有跟踪到 。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;strong&gt;TLD&lt;/strong&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;算法单目标跟踪应用实例图&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117213841724-762398963.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;strong&gt;TLD&lt;/strong&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;算法单目标跟踪源代码汇总&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;1. 原作者 Zdenek Kalal&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 作者主页： http://info.ee.surrey.ac.uk/Personal/Z.Kalal/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 源代码页: https://github.com/zk00006/OpenTLD&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 编程语言：Matlab + C&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. Alan Torres版&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 源代码页：https://github.com/alantrrs/OpenTLD&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现语言：C++&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. arthurv版&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 源代码页：https://github.com/arthurv/OpenTLD&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 实现语言：C++&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 注：和上面的没有发现任何区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. jmfs版&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 源代码页：https://github.com/jmfs/OpenTLD&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 实现语言：C++&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 注：和上面两个没有区别，只不过加入了VS2010工程文件，理论上可以直接在Windows下编译通过。不过opencv检测不到作者的webcam（！！！），所以他用了另一个VideoInput类来handle摄像头输入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. Georg Nebehay版 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 源代码页：http://gnebehay.github.com/OpenTLD/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 注1：这个的好处是提供可执行文件下载（Ubuntu 10.04和Windows）。BUT, as you would expect，基本上到了你的机器上都跑不了。还是自己老老实实build吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 注2：这个版本需要安装Qt。不过好像作者关掉了Qt的选项（相关代码还在），所以可以编译，但无法显示结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 注3：CSDN下载上有个“openTLD Qt 版“，就是这个版本。不过加了VS的工程文件---在我的机器上还是不能PnP， don't bother&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; http://download.csdn.net/download/muzi198783/4111915&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. Paul Nader版（又一个Qt 版！）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; QOpenTLD: http://qopentld.sourceforge.net/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 源代码页： http://sourceforge.net/projects/qopentld/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 注1：需要OpenCV和Qt。 原系统要求Qt 4.3.7OpenCV 2.2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 注2：Windows和Linux下都提供了编译工程或makefile。估计也是唯一一个移植到Android平台下的TLD!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7. Ben Pryke版（又一个student project！）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 源代码页：https://github.com/Ninjakannon/BPTLD&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 注：依然是Matlab+C/C++的混合实现。亮点是有很详细的Documentation（8页），介绍了算法的理解和实现细节。可以帮助理解原算法&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;strong&gt;TLD&lt;/strong&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;算法参考文献&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1257606/201801/1257606-20180117214903412-1622236038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;TLD视频目标跟踪演示视频&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;     跟踪人脸演示： http://www.miaopai.com/show/-jjAqUFr2mGP5VKdDZtarPtQy2WGFb3ypx-WXA__.htm &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     跟踪熊猫：http://www.miaopai.com/show/Y0LaonMwB79BBH9w6xUyA2qa1FfHafpEUjzJKg__.htm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    跟踪无人机航拍小车：http://www.miaopai.com/show/Ty1j4VhViUuVDx7R5-JWGbmexh0cr6t-gTtf7A__.htm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    跟踪弱小目标：http://www.miaopai.com/show/CvDoyN2UFW-VXojMERQyE6MTkOY-0Cpa2vfkfQ__.htm&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;TLD算法安装及运行答疑&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      &lt;span&gt;联系：liuyihai@126.com       liuyihai@aliyun.com&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;博文预告&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 下一篇博文将详细讲述将TLD算法用于视频多目标跟踪情形-----欢迎阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 14:09:00 +0000</pubDate>
<dc:creator>在海一方美猴王</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyihai/p/8306419.html</dc:identifier>
</item>
<item>
<title>[搬运] 写给 C# 开发人员的函数式编程 - 张很水</title>
<link>http://www.cnblogs.com/chenug/p/8306354.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenug/p/8306354.html</guid>
<description>&lt;p&gt;摘要：作为一名 C# 开发人员，您可能已经在编写一些函数式代码而没有意识到这一点。本文将介绍一些您已经在C＃中使用的函数方法，以及 C# 7 中对函数式编程的一些改进。&lt;br/&gt;尽管 .NET 框架的函数式编程语言是F＃，同时，C# 是一个面向对象的语言，但它也有很多可以用于函数式编程技术的特性。你可能已经写了一些功能的代码而没有意识到它！&lt;/p&gt;
&lt;h2 id=&quot;函数式编程范例&quot;&gt;函数式编程范例&lt;/h2&gt;
&lt;p&gt;函数式编程是相对于目前比较流行和通用的&lt;a href=&quot;http://www.dotnetcurry.com/software-gardening/1125/object-oriented-programming-oops&quot;&gt;面向对象编程&lt;/a&gt;的另一种编程模式。&lt;br/&gt;有几个与其他编程范例不同的关键概念。我们首先为最常见的定义提供阐述，以便我们在整个文章中看清这些定义。&lt;br/&gt;函数式编程的基本组成是纯函数。它们由以下两个属性定义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;他们的结果完全取决于传递给它的参数。没有内部或外部的状态影响它。&lt;/li&gt;
&lt;li&gt;他们不会造成任何副作用。被调用的次数不会改变程序行为。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于这些属性，函数调用可以被安全地替换其结果，例如函数每次执行的结果都缓存到一个键值对(被称为memoization的技术）。&lt;br/&gt;纯函数很适合形成 &lt;strong&gt;组合函数&lt;/strong&gt;，将两个或多个函数组合成一个新函数的过程，该函数返回相同的结果，就好像其所有的构成函数都按顺序调用一样。如果ComposedFn是Fn1和Fn2的函数组合，那么下面的断言将永远正确：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Assert.That(ComposedFn(x), Is.EqualTo(Fn2(Fn1(x))));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;作为其他函数的参数可以进一步提高其可重用性。这样的高阶函数可以作为通用的 &lt;strong&gt;辅助者 (helper)&lt;/strong&gt; ，它应用多次作为参数传递的另一个函数，例如一个数组的所有项目：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Array.Exists(persons, IsMinor);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，IsMinor 是一个在别处定义的函数。使之有效，语言必须支持其为第一类对象，即允许函数像类型一样用作参数的语言结构。&lt;/p&gt;
&lt;p&gt;数据总是用&lt;strong&gt;不可变的对象&lt;/strong&gt;来表示的，也就是在初始创建后不能改变状态的对象。每当一个值发生变化，就必须创建一个新的对象，而不是修改现有的对象。因为所有对象都保证不会改变，所以它们本质上是线程安全的，也就是说，它们可以安全地用于&lt;a href=&quot;http://www.dotnetcurry.com/dotnet/1360/concurrent-programming-dotnet-core&quot;&gt;多线程程序中&lt;/a&gt;，而不会受到竞争条件的威胁。&lt;br/&gt;由于函数是纯粹的，对象是不可变的直接结果，在函数编程中&lt;strong&gt;没有共享状态&lt;/strong&gt;。&lt;br/&gt;函数只能根据参数进行操作，而参数不能改变，从而影响其他接收相同参数的函数。他们可以影响程序的其余部分的唯一方法是将返回的结果作为参数传递给其他函数。&lt;br/&gt;这样可以防止函数之间的任何隐藏的交叉交互，使得它们可以安全地以任何顺序甚至并行运行，除非一个函数直接依赖于另一个函数的结果。&lt;br/&gt;有了这些基本的模块，函数式编程最终会被比命令式更具声明，即用 &lt;em&gt;描述&lt;/em&gt; 代替 &lt;em&gt;如何计算&lt;/em&gt; 。&lt;br/&gt;以下两个将字符串数组转换为小写的函数清楚地表明了两种方法之间的区别：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;string[] Imperative(string[] words)
{
    var lowerCaseWords = new string[words.Length];
    for (int i = 0; i &amp;lt; words.Length; i++)
    {
        lowerCaseWords[i] = words[i].ToLower();
    }
    return lowerCaseWords;
}
 
string[] Declarative(string[] words)
{
    return words.Select(word =&amp;gt; word.ToLower()).ToArray();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然你会听到很多其他的函数式编程概念，比如 monads, functors, currying, referential transparency等，但是这些模块应该足以让你了解什么是函数式编程，以及它与面向对象编程有什么不同。&lt;/p&gt;
&lt;h2 id=&quot;在-c-中编写函数式代码&quot;&gt;在 C# 中编写函数式代码&lt;/h2&gt;
&lt;p&gt;由于语言主要是面向对象的，所以默认并不总是引导你使用这样的代码，但是有了意图和足够的自律，你的代码可以变得更加实用。&lt;/p&gt;
&lt;h3 id=&quot;不可变类型&quot;&gt;不可变类型&lt;/h3&gt;
&lt;p&gt;你很可能习惯于在C＃中编写可变类型，但只需很少的改变，就可以使它们不可变：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Person
{
    public string FirstName { get; private set; }
    public string LastName { get; private set; }
 
    public Person(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;私有属性构造器使对象初始创建后不可能为它们分配不同的值。为了使对象真正不可变，所有的属性也必须是不可变的类型。否则，它们的值将通过改变属性来改变，而不是为它们分配一个新的值。&lt;br/&gt;上面的 Person 类型是不可变的，因为 string 也是一个不可变的类型，也就是说它的值不能像其所有的实例方法一样被改变，所以返回一个新的字符串实例。但是这是规则的一个例外，大多数 .NET 框架中类型都是可变的。&lt;br/&gt;如果你希望你的类型是不可变的，你不应该使用除了原始类型以外的其他内建类型，而应该使用字符串作为公共属性。&lt;br/&gt;要更改对象的属性，例如更改人物的名字，需要创建一个新的对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Person Rename(Person person, string firstName)
{
    return new Person(firstName, person.LastName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当一个类型有很多属性时，编写这样的函数可能会变得非常繁琐。因此，对于不可变类型来说，为这样的场景实现 With helper 函数是一个好习惯：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Person With(string firstName = null, string lastName = null)
{
    return new Person(firstName ?? this.FirstName, lastName ?? this.LastName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个函数创建了修改了任意数量属性的对象的副本。我们的 Rename 函数现在可以简单地调用这个帮助器来创建修改后的 Person ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Person Rename(Person person, string firstName)
{
    return person.With(firstName: firstName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有两个属性的好处可能不是很明显，但不管这个类型有多少个属性，这个语法允许我们只列出我们想要修改的属性作为命名参数。&lt;/p&gt;
&lt;h3 id=&quot;纯函数&quot;&gt;纯函数&lt;/h3&gt;
&lt;p&gt;使函数变 &quot;纯&quot; 需要更多的训练，而不是使对象不可变。&lt;br/&gt;没有语言功能可以帮助程序员确保一个特定的功能是纯粹的。不要使用任何内部或外部的状态，不要引起副作用，不要调用任何不纯的函数。&lt;br/&gt;当然，也没有什么能阻止你使用函数参数和调用其他纯函数，从而使函数变得纯粹。上面的 Rename 函数是一个纯函数的例子：它不调用任何非纯函数，也不使用传递给它的参数以外的任何其他数据。&lt;/p&gt;
&lt;h3 id=&quot;组合函数&quot;&gt;组合函数&lt;/h3&gt;
&lt;p&gt;通过定义一个新的函数，可以将多个函数合并成一个函数，该函数调用其所有组合函数（让我们忽略不需要连续多次调用Rename的事实）:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Person MultiRename(Person person)
{
    return Rename(Rename(person, &quot;Jane&quot;), &quot;Jack&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重命名方法的签名迫使我们嵌套调用，随着函数调用次数的增加，这些调用会变得难以理解和理解。如果我们使用With方法，我们的意图变得更清晰：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Person MultiRename(Person person)
{
    return person.With(firstName: &quot;Jane&quot;).With(firstName: &quot;Jack&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了使代码更具可读性，我们可以将调用链分成多行，保持可管理性，无论我们将多少个函数组合成一个：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Person MultiRename(Person person)
{
    return person
        .With(firstName: &quot;Jane&quot;)
        .With(firstName: &quot;Jack&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没有好的方法来分割与重命名类似的嵌套调用函数。当然，With 方法允许链接语法，因为它是一个实例方法。但是，在函数式编程规范中，函数应该和它们所作用的数据分开声明，比如 Rename 函数。&lt;br/&gt;虽然在 函数式语言 &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/index#function-composition-and-pipelining&quot;&gt;F# 中&lt;/a&gt;有一个流水线操作符（&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/functions/index#function-composition-and-pipelining&quot;&gt;|&amp;gt;&lt;/a&gt;）来允许组合这些函数，但我们可以利用 C# 中的扩展方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class PersonExtensions
{
    public static Person Rename(this Person person, string firstName)
    {
        return person.With(firstName: firstName);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这允许我们组合非实例方法调用，就像实例方法调用一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Person MultiRename(Person person)
{
    return person.Rename(&quot;Jane&quot;).Rename(&quot;Jack&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;net-framework中的函数式-api-示例&quot;&gt;.NET Framework中的函数式 API 示例&lt;/h2&gt;
&lt;p&gt;为了体验C＃中的函数式编程，你不需要自己编写所有的对象和函数。&lt;br/&gt;在 .NET 框架中有一些可用的函数式 API 供您使用。&lt;/p&gt;
&lt;h3 id=&quot;不变集合&quot;&gt;不变集合&lt;/h3&gt;
&lt;p&gt;我们已经提到，在.NET框架中，字符串和原始类型是不可变的类型。&lt;br/&gt;但是，也有一些可选的 &lt;em&gt;不可变集合类型&lt;/em&gt; 。从技术上讲，它们并不是.NET框架的一部分，因为它们是作为独立的 NuGet 包 &lt;strong&gt;System.Collections.Immutable&lt;/strong&gt; 分发。&lt;br/&gt;另一方面，它们是新的开源跨平台 .NET 运行时 .NET Core 的一个组成部分。&lt;br/&gt;命名空间包括所有常用的集合类型：数组，列表，集合，字典，队列和堆栈。&lt;br/&gt;顾名思义，它们都是不可改变的，即它们在创建之后不能被改变。相反，每个更改都会创建一个新实例。这使得不可变集合以与.NET框架基类库中包含的并发集合不同的方式完全线程安全。&lt;br/&gt;使用并发集合，多个线程不能同时修改数据，但仍可以访问修改。对于不可变的集合，任何更改只对创建它们的线程可见，因为原始集合保持不变。&lt;br/&gt;尽管为每个可变操作创建了一个新的实例，为了保持集合的高性能，它们的实现利用了&lt;strong&gt;结构共享&lt;/strong&gt;。&lt;br/&gt;这意味着在集合的新修改实例中，来自先前实例的未修改的部分尽可能被重用，因此需要较少的内存分配并且导致垃圾收集器的工作较少。&lt;br/&gt;在函数式编程中这种常见的技术是可以实现的，即对象不能改变，因此可以安全地重用。&lt;/p&gt;
&lt;p&gt;使用不可变集合和常规集合最大的区别在于它们的创建。&lt;/p&gt;
&lt;p&gt;由于每次更改都创建一个新实例，因此您希望创建集合中已包含所有初始项目的集合。因此，不可变集合不具有公共构造函数，但提供了三种创建方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工厂方法创建接受 0个 或 更多的项目来初始化集合：&lt;code&gt;var list = ImmutableList.Create(1, 2, 3, 4);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Builder 是一个高效的可变集合，可以很容易地转换为不可变的集合：&lt;code&gt;var builder = ImmutableList.CreateBuilder&amp;lt;int&amp;gt;(); builder.Add(1); builder.AddRange(new[] { 2, 3, 4 }); var list = builder.ToImmutable();&amp;lt;/int&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以使用扩展方法从IEnumerable创建不可变集合：&lt;code&gt;var list = new[] { 1, 2, 3, 4 }.ToImmutableList();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不可变集合的可变操作与常规集合中的可变操作类似，但它们都返回集合的新实例，表示将操作应用于原始实例的结果。&lt;br/&gt;如果您不想丢失更改，则必须在此之后使用此新实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var modifiedList = list.Add(5);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行上述语句后，列表的值仍然是 {1,2,3,4} 。得到的 modifiedList 将具有 {1,2,3,4,5} 的值。&lt;br/&gt;无论对于一个非功能性程序员来说，不可变的集合看起来是多么的不寻常，它们是编写.NET框架功能代码的一个非常重要的基石。创建你自己的不可变集合类型将是一个重大的努力。&lt;/p&gt;
&lt;h2 id=&quot;linq---语言集成查询&quot;&gt;LINQ - 语言集成查询&lt;/h2&gt;
&lt;p&gt;.NET框架中一个更好的函数式的API是LINQ。&lt;br/&gt;虽然它从来没有被宣传为函数式，但它体现了许多以前引入的函数式性质。&lt;br/&gt;如果我们在 LINQ 扩展方法仔细一看，很明显几乎所有的都表明其函数式：他们允许我们&lt;strong&gt;声明&lt;/strong&gt;我们想要获得什么，而不是如何做。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var result = persons
    .Where(p =&amp;gt; p.FirstName == &quot;John&quot;)
    .Select(p =&amp;gt; p.LastName)
    .OrderBy(s =&amp;gt; s.ToLower())
    .ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上查询返回名为 John 的姓氏的有序列表。我们只提供了预期的结果，而不是提供详细的操作顺序。可用的扩展方法也很容易使用链式语法进行组合。&lt;br/&gt;尽管LINQ函数并不是作用于不可变的类型，但它们仍然是&lt;strong&gt;纯函数&lt;/strong&gt;，除非通过传递变异函数作为参数来滥用。&lt;br/&gt;它们被实现为对只读接口 IEnumerable 集合进行操作，而不修改集合中的项目。&lt;br/&gt;他们的结果只取决于输入参数，只要作为参数传递的函数也是纯的，它们不会产生任何全局副作用。在我们刚刚看到的例子中，人员集合以及其中的任何项目都不会被修改。&lt;br/&gt;许多 LINQ 函数是 &lt;strong&gt;高阶函数&lt;/strong&gt;：它们接受其他函数作为参数。在上面的示例代码中，lambda表达式作为函数参数传入，但是它们可以很容易地在其他地方定义并传入，而不是以内联的方式创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public bool FirstNameIsJohn(Person p)
{
    return p.FirstName == &quot;John&quot;;
}
 
public string PersonLastName(Person p)
{
    return p.LastName;
}
 
public string StringToLower(string s)
{
    return s.ToLower();
}
 
var result = persons
    .Where(FirstNameIsJohn)
    .Select(PersonLastName)
    .OrderBy(StringToLower)
    .ToList();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当函数参数和我们的情况一样简单时，代码通常会更容易理解内联 lambda 表达式而不是单独的函数。然而，随着实现的逻辑变得更加复杂和可重用，把它们定义为独立的函数，开始变得更有意义。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论：&lt;/h2&gt;
&lt;p&gt;函数式编程范式当然有一些优点，这也促成了它近来日益普及。&lt;br/&gt;在没有共享状态的情况下，并行和多线程变得更容易，因为我们不必处理同步问题和竞争条件。纯函数和不变性可以使代码更容易理解。&lt;br/&gt;由于函数只依赖于它们明确列出的参数，因此我们可以更容易地识别一个函数是否需要另一个函数的结果，以及何时这两个函数是独立的，因此可以并行运行。单个纯函数也更容易进行单元测试，因为所有的测试用例都可以通过传递不同的输入参数和验证返回值来覆盖。没有其他的外部依赖模拟和检查。&lt;/p&gt;
&lt;p&gt;如果所有这些都让你想为自己尝试函数式编程，那么首先在 C# 中执行它可能比在同一时间学习一种新语言更容易。您可以通过更多地利用现有的函数式 API 来缓慢起步，并以更具说明性的方式继续编写代码。&lt;br/&gt;如果你看到了足够的好处，那么你可以学习 F#，稍后再熟悉这些概念。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 13:53:00 +0000</pubDate>
<dc:creator>张很水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenug/p/8306354.html</dc:identifier>
</item>
<item>
<title>Modelsim独立仿真Vivado Clocking Wizard IP Core - NingHeChuan</title>
<link>http://www.cnblogs.com/ninghechuan/p/8305925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ninghechuan/p/8305925.html</guid>
<description>&lt;p&gt;　　工欲善其事，必先利其器。在使用Vivado自带的仿真软件仿真的时候，相对于更优秀的仿真工具Modelsim，效率低了很多，为了更高效的开发，我尝试着用Vivado级联Modelsim仿真，但是级联后还是有一些不方便，所以我便直接使用Modelsim独立仿真，但是对于IP Core的话，就需要添加Vivado IP Core的库文件，本人查阅了很多资料，最终实现了使用Modelsim仿真Vivado Clocking Wizard IP Core，软件版本，Vivado 2017.3、Modelsim SE10.4。具体流程如下，实测记录。&lt;/p&gt;
&lt;p&gt;首先，在 Modelsim 的安装目录下新建一个文件夹，我这里是D:\Modelsim_10_4_se\Vivado_2017.3_lib&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205018209-1482883418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，打开Vivado软件，主界面菜单栏点击Tools下的Compile Simulation Libraries编译Vivado仿真库&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205024396-412343804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;弹出如下窗口然后按如图所示选择，1处路径为刚才我们新建的文件夹中，2处为Modelsim的运行程序路径。设置好后点击compile。&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205029631-758583033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在编译的过程中窗口会打印出来如下信息。&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205034412-808228546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;等待一段时间，Vivado的库文件编译完成后我们可以看到文件夹下都是Vivado的库文件&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205039521-1478882636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后使用Vivado新建一个调用的Clocking Wized IP Core的工程，编写好测试文件，然后再用Modelsim新建一个仿真工程，将测试文件和顶层添加进来。这里省略掉这些步骤。这里需要将IP Core中生成的两个文件添加进来，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205051849-928826537.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;直接在work右键点击test bench文件进行仿真会出现如下错误，这是因为没有添加所仿IP Core的库文件&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205058178-2139128577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击标题栏simulator——start simulator，在work里选中test bench。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205103224-1563475887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击libraries，点击添加所需要的库，这里只需要simprims_ver&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205109162-1631305904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击这里后还是会出现错误，打印出来的信息如下，提示缺少glbl模块，&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205113974-1842858238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是Xilinx的全局复位模块，该模块的路径在你Vivado的安装路径里，比如我的是D:\Xilinx\Vivado2017.3\Vivado\2017.3\data\verilog\src中，把它添加到工程里面，在test bench中如图所示例化一下这个模块，然后重新仿真一次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205118912-1053858520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就可以看到波形了&lt;img src=&quot;https://images2017.cnblogs.com/blog/1057546/201801/1057546-20180117205123709-1875165581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里的测试工程师一个125Mhz分25Mhz的五分频。&lt;/p&gt;
&lt;p&gt;接下来本人会继续尝试使用Modelsim仿真FIFO、RAM/ROM、Shift_RAM等常用IP Core，如果你有什么更加高效的方法，欢迎提出，欢迎指点。如果需要Modelsim软件请关注我的微信订阅号：开源FPGA，后台回复“Modelsim”即可获得，欢迎加入开源FPGA-交流群-I进行讨论，群号码：677163633。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1057546/201706/1057546-20170611114905559-478053885.jpg&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;

&lt;p&gt;转载请注明出处：NingHeChuan（宁河川）&lt;/p&gt;
&lt;p&gt;个人微信订阅号：开源FPGA&lt;/p&gt;
&lt;p&gt;如果你想及时收到个人撰写的博文推送，可以扫描左边二维码（或者长按识别二维码）关注个人微信订阅号&lt;/p&gt;
&lt;p&gt;知乎ID：&lt;a href=&quot;https://www.zhihu.com/people/zhu-he-chuan/activities&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微博ID：&lt;a href=&quot;http://weibo.com/6059461073/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Modelsim独立仿真Vivado Clocking Wizard IP Core&quot; href=&quot;http://www.cnblogs.com/ninghechuan/p/8305925.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/ninghechuan/p/8305925.html&lt;/a&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 13:37:00 +0000</pubDate>
<dc:creator>NingHeChuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ninghechuan/p/8305925.html</dc:identifier>
</item>
<item>
<title>利用 html2canvas 做个简单的诗词卡片生成器 - yunser_blog</title>
<link>http://www.cnblogs.com/yunser/p/use-html2canvas-and-wangeditor-make-a-tool.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunser/p/use-html2canvas-and-wangeditor-make-a-tool.html</guid>
<description>&lt;h2 id=&quot;html2canvas-简介&quot;&gt;html2canvas 简介&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/niklasvh/html2canvas&quot;&gt;html2canvas&lt;/a&gt; 顾名思义，就是一个可以把 DOM 元素转换成图片的类库，常用于网页截图。网页截图常见的应用场景是，在意见反馈里对当前页面进行截图，方便反馈页面出现的问题，比如页面样式出错，举报网站上的违规行为等等。&lt;/p&gt;
&lt;p&gt;除了截图外，还可以用来制作一些在线生成图片的功能，比如这个&lt;a href=&quot;http://tool2.yunser.com/bar/&quot;&gt;在线生成条形图&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;做一个诗词卡片生成工具&quot;&gt;做一个诗词卡片生成工具&lt;/h2&gt;
&lt;p&gt;所谓诗词卡片生成工具，就是能把某一首诗词，生成一张精美的诗词卡片。当然对于不懂设计的我来说，想要做到精美有点困难。&lt;/p&gt;
&lt;p&gt;实现原理是，利用富文本编辑器，让用户输入诗词，生成 HTML，再通过 html2canvas 把 HTML 生成图片。&lt;/p&gt;
&lt;h2 id=&quot;大致实现&quot;&gt;大致实现&lt;/h2&gt;
&lt;p&gt;安装依赖。wangeditor 是一个比较不错的富文本编辑器，至少界面不会太丑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install html2canvas --save-dev
npm install wangeditor--save-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把 wangeditor 封装成 Vue 组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;div class=&quot;rich-editor&quot; id=&quot;editorElem&quot; style=&quot;text-align:left&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
    import E from 'wangeditor'

    export default {
        data() {
            return {
                editorContent: ''
            }
        },
        props: {
            value: {
                type: String,
                default: ''
            }
        },
        mounted() {
            this.editorContent = this.value

            this.editor = new E('#editorElem')
            this.editor.customConfig.onchange = html =&amp;gt; {
                this.editorContent = html
                this.$emit('input', this.editorContent)
            }
            this.editor.create()
            this.editor.txt.html(this.editorContent)
        },
        destroyed() {
//            this.editor.destroy()
        }
    }
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用富文本编辑器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;my-rich-editor v-model=&quot;content&quot;&amp;gt;&amp;lt;/my-rich-editor&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把用户输入的富文本，保存在一个 &lt;code&gt;div&lt;/code&gt; 里面。&lt;code&gt;captureStyle&lt;/code&gt; 是用户设置的卡片的样式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div id=&quot;capture&quot; v-html=&quot;content&quot; :style=&quot;captureStyle&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后利用 html2canvas 生成卡片，供用户下载。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;html2canvas(document.querySelector('#capture')).then(canvas =&amp;gt; {
    let img = canvas.toDataURL('image/png')
   // 显示图片
})                           &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/880436/201801/880436-20180117211227146-508244800.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目 &lt;a href=&quot;http://text.yunser.com/rich&quot;&gt;demo&lt;/a&gt;，&lt;a href=&quot;https://github.com/yunser/text-front/tree/dev&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 13:20:00 +0000</pubDate>
<dc:creator>yunser_blog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunser/p/use-html2canvas-and-wangeditor-make-a-tool.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——20. 接口优于抽象类 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8306024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8306024.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Java有两种机制来定义允许多个实现的类型：接口和抽象类。 由于在Java 8 [JLS 9.4.3]中引入了接口的默认方法（default methods ），因此这两种机制都允许为某些实例方法提供实现。 一个主要的区别是要实现由抽象类定义的类型，类必须是抽象类的子类。 因为Java只允许单一继承，所以对抽象类的这种限制严格限制了它们作为类型定义的使用。 任何定义所有必需方法并服从通用约定的类都可以实现一个接口，而不管类在类层次结构中的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现有的类可以很容易地进行改进来实现一个新的接口&lt;/strong&gt;。 你只需添加所需的方法（如果尚不存在的话），并向类声明中添加一个&lt;code&gt;implements&lt;/code&gt;子句。 例如，当&lt;code&gt;Comparable&lt;/code&gt;, &lt;code&gt;Iterable&lt;/code&gt;， 和&lt;code&gt;Autocloseable&lt;/code&gt;接口添加到Java平台时，很多现有类需要实现它们来加以改进。 一般来说，现有的类不能改进以继承一个新的抽象类。 如果你想让两个类继承相同的抽象类，你必须把它放在类型层级结构中的上面位置，它是两个类的祖先。 不幸的是，这会对类型层级结构造成很大的附带损害，迫使新的抽象类的所有后代对它进行子类化，无论这些后代类是否合适。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口是定义混合类型（mixin）的理想选择&lt;/strong&gt;。 一般来说，mixin是一个类，除了它的“主类型”之外，还可以声明它提供了一些可选的行为。 例如，&lt;code&gt;Comparable&lt;/code&gt;是一个类型接口，它允许一个类声明它的实例相对于其他可相互比较的对象是有序的。 这样的接口被称为类型，因为它允许可选功能被“混合”到类型的主要功能。 抽象类不能用于定义混合类，这是因为它们不能被加载到现有的类中：一个类不能有多个父类，并且在类层次结构中没有合理的位置来插入一个类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口允许构建非层级类型的框架&lt;/strong&gt;。 类型层级对于组织某些事物来说是很好的，但是其他的事物并不是整齐地落入严格的层级结构中。 例如，假设我们有一个代表歌手的接口，另一个代表作曲家的接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Singer {
    AudioClip sing(Song s);
}

public interface Songwriter {
    Song compose(int chartPosition);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在现实生活中，一些歌手也是作曲家。 因为我们使用接口而不是抽象类来定义这些类型，所以单个类实现歌手和作曲家两个接口是完全允许的。 事实上，我们可以定义一个继承歌手和作曲家的第三个接口，并添加适合于这个组合的新方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface SingerSongwriter extends Singer, Songwriter {
    AudioClip strum();

    void actSensitive();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你并不总是需要这种灵活性，但是当你这样做的时候，接口是一个救星。 另一种方法是对于每个受支持的属性组合，包含一个单独的类的臃肿类层级结构。 如果类型系统中有n个属性，则可能需要支持2n种可能的组合。 这就是所谓的组合爆炸（combinatorial explosion）。 臃肿的类层级结构可能会导致具有许多方法的臃肿类，这些方法仅在参数类型上有所不同，因为类层级结构中没有类型来捕获通用行为。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口通过包装类模式确保安全的，强大的功能增强成为可能（条目 18）&lt;/strong&gt;。 如果使用抽象类来定义类型，那么就让程序员想要添加功能，只能继承。 生成的类比包装类更弱，更脆弱。&lt;/p&gt;
&lt;p&gt;当其他接口方法有明显的接口方法实现时，可以考虑向程序员提供默认形式的方法实现帮助。 有关此技术的示例，请参阅第104页的&lt;code&gt;removeIf&lt;/code&gt;方法。如果提供默认方法，请确保使用&lt;code&gt;@implSpec&lt;/code&gt; Javadoc标记（条目19）将它们文档说明为继承。&lt;/p&gt;
&lt;p&gt;使用默认方法可以提供实现帮助多多少少是有些限制的。 尽管许多接口指定了&lt;code&gt;Object&lt;/code&gt;类中方法（如&lt;code&gt;equals&lt;/code&gt;和&lt;code&gt;hashCode&lt;/code&gt;）的行为，但不允许为它们提供默认方法。 此外，接口不允许包含实例属性或非公共静态成员（私有静态方法除外）。 最后，不能将默认方法添加到不受控制的接口中。&lt;/p&gt;
&lt;p&gt;但是，你可以通过提供一个抽象的骨架实现类（abstract skeletal implementation class）来与接口一起使用，将接口和抽象类的优点结合起来。 接口定义了类型，可能提供了一些默认的方法，而骨架实现类在原始接口方法的顶层实现了剩余的非原始接口方法。 继承骨架实现需要大部分的工作来实现一个接口。 这就是模板方法设计模式[Gamma95]。&lt;/p&gt;
&lt;p&gt;按照惯例，骨架实现类被称为AbstractInterface，其中Interface是它们实现的接口的名称。 例如，集合框架（ Collections Framework）提供了一个框架实现以配合每个主要集合接口：&lt;code&gt;AbstractCollection&lt;/code&gt;，&lt;code&gt;AbstractSet&lt;/code&gt;，&lt;code&gt;AbstractList&lt;/code&gt;和&lt;code&gt;AbstractMap&lt;/code&gt;。 可以说，将它们称为&lt;code&gt;SkeletalCollection&lt;/code&gt;，&lt;code&gt;SkeletalSet&lt;/code&gt;，&lt;code&gt;SkeletalList&lt;/code&gt;和&lt;code&gt;SkeletalMap&lt;/code&gt;是有道理的，但是现在已经确立了抽象约定。 如果设计得当，骨架实现（无论是单独的抽象类还是仅由接口上的默认方法组成）可以使程序员非常容易地提供他们自己的接口实现。 例如，下面是一个静态工厂方法，在&lt;code&gt;AbstractList&lt;/code&gt;的顶层包含一个完整的功能齐全的List实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Concrete implementation built atop skeletal implementation

static List&amp;lt;Integer&amp;gt; intArrayAsList(int[] a) {

    Objects.requireNonNull(a);

    // The diamond operator is only legal here in Java 9 and later

    // If you're using an earlier release, specify &amp;lt;Integer&amp;gt;

    return new AbstractList&amp;lt;&amp;gt;() {

        @Override public Integer get(int i) {

            return a[i];  // Autoboxing ([Item 6](https://www.safaribooksonline.com/library/view/effective-java-third/9780134686097/ch2.xhtml#lev6))

        }

        @Override public Integer set(int i, Integer val) {

            int oldVal = a[I];

            a[i] = val;     // Auto-unboxing

            return oldVal;  // Autoboxing

        }

        @Override public int size() {

            return a.length;

        }

    };

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你考虑一个List实现为你做的所有事情时，这个例子是一个骨架实现的强大的演示。 顺便说一句，这个例子是一个适配器（Adapter ）[Gamma95]，它允许一个int数组被看作&lt;code&gt;Integer&lt;/code&gt;实例列表。 由于int值和整数实例（装箱和拆箱）之间的来回转换，其性能并不是非常好。 请注意，实现采用匿名类的形式（条目 24）。&lt;/p&gt;
&lt;p&gt;骨架实现类的优点在于，它们提供抽象类的所有实现的帮助，而不会强加抽象类作为类型定义时的严格约束。对于具有骨架实现类的接口的大多数实现者来说，继承这个类是显而易见的选择，但它不是必需的。如果一个类不能继承骨架的实现，这个类可以直接实现接口。该类仍然受益于接口本身的任何默认方法。此外，骨架实现类仍然可以协助接口的实现。实现接口的类可以将接口方法的调用转发给继承骨架实现的私有内部类的包含实例。这种被称为模拟多重继承的技术与条目 18讨论的包装类模式密切相关。它提供了多重继承的许多好处，同时避免了缺陷。&lt;/p&gt;
&lt;p&gt;编写一个骨架的实现是一个相对简单的过程，虽然有些乏味。 首先，研究接口，并确定哪些方法是基本的，其他方法可以根据它们来实现。 这些基本方法是你的骨架实现类中的抽象方法。 接下来，为所有可以直接在基本方法之上实现的方法提供接口中的默认方法，回想一下，你可能不会为诸如&lt;code&gt;Object&lt;/code&gt;类中&lt;code&gt;equals&lt;/code&gt;和&lt;code&gt;hashCode&lt;/code&gt;等方法提供默认方法。 如果基本方法和默认方法涵盖了接口，那么就完成了，并且不需要骨架实现类。 否则，编写一个声明实现接口的类，并实现所有剩下的接口方法。 为了适合于该任务，此类可能包含任何的非公共属性和方法。&lt;/p&gt;
&lt;p&gt;作为一个简单的例子，考虑一下&lt;code&gt;Map.Entry接口。 显而易见的基本方法是&lt;/code&gt;getKey&lt;code&gt;，getValue&lt;/code&gt;和（可选的）&lt;code&gt;setValue&lt;/code&gt;。 接口指定了&lt;code&gt;equals&lt;/code&gt;和&lt;code&gt;hashCode&lt;/code&gt;的行为，并且在基本方面方面有一个&lt;code&gt;toString&lt;/code&gt;的明显的实现。 由于不允许为Object类方法提供默认实现，因此所有实现均放置在骨架实现类中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Skeletal implementation class

public abstract class AbstractMapEntry&amp;lt;K,V&amp;gt;

        implements Map.Entry&amp;lt;K,V&amp;gt; {

    // Entries in a modifiable map must override this method

    @Override public V setValue(V value) {

        throw new UnsupportedOperationException();

    }

    // Implements the general contract of Map.Entry.equals

    @Override public boolean equals(Object o) {

        if (o == this)

            return true;

        if (!(o instanceof Map.Entry))

            return false;

        Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry) o;

        return Objects.equals(e.getKey(),  getKey())

            &amp;amp;&amp;amp; Objects.equals(e.getValue(), getValue());

    }

    // Implements the general contract of Map.Entry.hashCode

    @Override public int hashCode() {

        return Objects.hashCode(getKey())

             ^ Objects.hashCode(getValue());

    }

    @Override public String toString() {

        return getKey() + &quot;=&quot; + getValue();

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，这个骨架实现不能在&lt;code&gt;Map.Entry&lt;/code&gt;接口中实现，也不能作为子接口实现，因为默认方法不允许重写诸如&lt;code&gt;equals&lt;/code&gt;，&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;toString&lt;/code&gt;等&lt;code&gt;Object&lt;/code&gt;类方法。&lt;/p&gt;
&lt;p&gt;由于骨架实现类是为了继承而设计的，所以你应该遵循条目 19中的所有设计和文档说明。为了简洁起见，前面的例子中省略了文档注释，但是&lt;strong&gt;好的文档在骨架实现中是绝对必要的&lt;/strong&gt;，无论它是否包含 一个接口或一个单独的抽象类的默认方法。&lt;/p&gt;
&lt;p&gt;与骨架实现有稍许不同的是简单实现，以&lt;code&gt;AbstractMap.SimpleEntry&lt;/code&gt;为例。 一个简单的实现就像一个骨架实现，它实现了一个接口，并且是为了继承而设计的，但是它的不同之处在于它不是抽象的：它是最简单的工作实现。 你可以按照情况使用它，也可以根据情况进行子类化。&lt;/p&gt;
&lt;p&gt;总而言之，一个接口通常是定义允许多个实现的类型的最佳方式。 如果你导出一个重要的接口，应该强烈考虑提供一个骨架的实现类。 在可能的情况下，应该通过接口上的默认方法提供骨架实现，以便接口的所有实现者都可以使用它。 也就是说，对接口的限制通常要求骨架实现类采用抽象类的形式。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Jan 2018 13:00:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8306024.html</dc:identifier>
</item>
<item>
<title>DeepLearning.ai学习笔记（四）卷积神经网络 -- week3 目标检测 - marsggbo</title>
<link>http://www.cnblogs.com/marsggbo/p/8305865.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/marsggbo/p/8305865.html</guid>
<description>&lt;p&gt;这一小节视频主要介绍了我们在实现目标定位时标签该如何定义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/td1bdswjt3.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;em&gt;上图左下角给出了损失函数的计算公式(这里使用的是平方差)&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如图示，加入我们需要定位出图像中是否有pedestrian，car，motorcycles。注意在这里我们假设图像中只肯呢个存在这三者中的一种或者都不存在，所以共有四种可能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(P_c=1\)&lt;/span&gt;表示有三者中的一种
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(C_1=1\)&lt;/span&gt;表示有pedestrian，反之没有&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(C_2=1\)&lt;/span&gt;表示有car&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(C_3=1\)&lt;/span&gt;表示有motorcycles&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(b_*\)&lt;/span&gt;用于标识所识别食物的位置
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(b_x,b_y\)&lt;/span&gt;：表示识别物体的中心坐标&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(b_w,b_h\)&lt;/span&gt;：表示识别物体的宽和高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/r0op76dxxh.png&quot;/&gt;&lt;/center&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：&lt;span class=&quot;math inline&quot;&gt;\(P_c=0\)&lt;/span&gt;表示三者都没有，所以此时&lt;span class=&quot;math inline&quot;&gt;\(C_*,b_*\)&lt;/span&gt;的值我们并不在乎了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这一节的内容和上一节感觉很类似，所有就没有记得很详细了&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/wjm5rxrciy.png&quot;/&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/n2jr1yu5af.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;目标检测常使用的是滑动窗口技术检测，即使用一定大小的窗口按照指定的步长对图像进行遍历&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/as19p7nyt2.png&quot;/&gt;&lt;strong&gt;→&lt;/strong&gt; &lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/mfl2bwi6a3.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;因为图像中车辆的大小我们是不知道的，所以可以更改窗口大小，从而识别并定位出车辆的位置。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/efj2bp43sx.png&quot;/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/tfuq0q5bwb.png&quot;/&gt;&lt;/center&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：该节视频的例子和上一节一样，都是识别图像中是否有pedestrian，car，motorcycles，background，所以最后输出y是4个节点&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;全连接层卷积层&quot;&gt;&lt;strong&gt;1.全连接层→卷积层&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在介绍卷积滑动窗口之前我们首先要知道如何把神经网络的全连接层转化成卷积层，下面是使用了全连接层的网络结构&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/6sxw0gezg5.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;那么如何将全连接层转化成卷积层呢？如下图示&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/bs2zhsecro.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;我们可以看到经过Max Pooling之后的数据大小是(5, 5, 16),第一个FC层是400个节点。我们可以使用400个5*5的过滤器进行卷积运算，随后我们就得到了(1, 1, 400)的矩阵。&lt;/p&gt;
&lt;p&gt;第二个FC层也是400个节点，由之前的1*1过滤器的特点，我们可以使用400个1*1的过滤器，也可以得到(1,1,400)的矩阵。至此，我们已经成功将全连接层转化成了卷积层。&lt;/p&gt;
&lt;h2 id=&quot;卷积滑动窗口实现&quot;&gt;&lt;strong&gt;2.卷积滑动窗口实现&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目标检测&lt;/strong&gt;一节中介绍了滑动窗口。要实现窗口遍历，那么就需要很大的计算量，看起来似乎可操作性不强。But！这怎么可能难倒哪些newB的大神们呢，他们自然有办法。&lt;/p&gt;
&lt;p&gt;首先我们先看下图，这个就是上面提到的将全连接层转化成卷积层的示意图，只不过画的看起来更正规一些了2333，但是有个需要提醒的是吴大大为了方便只花了平面图，就没有画出3D的效果了。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/8k2cdbnhyu.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;下面，假设我们的测试图大小是16*16，并令滑动窗口大小是14*14的(&lt;em&gt;为了方便理解，下图用蓝色清楚地表明了14*14窗口的大小&lt;/em&gt;),步长是2，所以这个测试图可以被窗口划分成4个部分。随后和上面执行一样的操作，最后可以得到(2,2,4)的矩阵，此时我们不难看出测试图被滑动窗口选取的左上角部分对应的结果也是输出矩阵的左上角部分，其他3个部分同理。&lt;/p&gt;
&lt;p&gt;所以这说明了什么？&lt;/p&gt;
&lt;p&gt;说明我们没有必要用滑动窗口截取一部分，然后带入卷积网络运算。相反我们可以整体进行运算，这样速度就快很多了。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/iz64bqzuoa.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;下图很清楚的展示了卷积滑动窗口的实现。我们可以看到图片被划分成了64块&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/wum025byqd.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/ivaibuabs9.png&quot;/&gt;&lt;/center&gt;

&lt;p&gt;上面介绍的滑动窗口方法存在一个问题就是很多情况下滑动窗口并不能很好的切割出车体，如下图示：&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/9n22blyanm.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;为了解决这个问题，就有了&lt;strong&gt;YOLO(you only look once)算法&lt;/strong&gt;，即只需要计算一次便可确定需要识别物体的位置的大小。&lt;/p&gt;
&lt;p&gt;原理如下：&lt;/p&gt;
&lt;p&gt;首先将图像划分成3*3(即9份)，每一份最后由一个向量表示，这个向量在本文最前面介绍过，即&lt;span class=&quot;math inline&quot;&gt;\(y=[P_c,b_x,b_y,b_h,b_w,c_1,c_2,c_3]\)&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/rwssv5aupd.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;因为有9份，所以最后输出矩阵大小是(3,3,8),如下图示：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/ss95y00m4g.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;那么如何构建卷积网络呢？&lt;/p&gt;
&lt;p&gt;输入矩阵是(100,100,3),然后是&lt;strong&gt;Conv，Maxpool层&lt;/strong&gt;，……，最后只要确保输出矩阵大小是(3,3,8)即可。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/za2evuseag.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;下图是以右边的车辆作为示例介绍该车辆所在框的输出矩阵&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;很显然&lt;span class=&quot;math inline&quot;&gt;\(P_c=1\)&lt;/span&gt;,&lt;/li&gt;
&lt;li&gt;然后&lt;span class=&quot;math inline&quot;&gt;\(b_x,b_y\)&lt;/span&gt;的值是右边车辆的中心点相对于该框的位置,所以它们的值是一定小于1的，我们可以很容易的得到近似值&lt;span class=&quot;math inline&quot;&gt;\(b_x=0.4,b_y=0.3\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(b_h,b_w\)&lt;/span&gt;的值同理也是车辆的宽高相对于其所在框的比例，但是要注意的是这两个值是可以大于1的，因为有可能部分车身在框外。但是也可以使用sigmoid函数将值控制在1以内。&lt;/li&gt;
&lt;/ul&gt;&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/rd8bzhnw2y.png&quot;/&gt;&lt;/center&gt;

&lt;p&gt;前面说到了实现目标定位时可能存在滑动窗口与真实边框存在出入，如下图示：&lt;br/&gt;红色框是车身边界，紫色框是滑动窗口，那么此窗口返回的值是有车还是无车呢？&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/br58bitruq.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;为了解决上面的问题引入了&lt;strong&gt;交并比(IoU)，也就是两个框之间的交集与并集之比&lt;/strong&gt;，依据这个值可以评价定位算法是否精准。&lt;/p&gt;
&lt;p&gt;示意图如下，黄色区域表示紫色框和红色框的交集，绿色区域表示紫色框和红色框的并集，交并比(IoU)就等于黄色区域大小比上绿色区域大小。&lt;/p&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(IoU\geq0.5\)&lt;/span&gt;，则表示紫色框中有车辆，反之没有。&lt;/p&gt;
&lt;p&gt;当然0.5这个阈值是人为设定的，没有深入的科学探究，所以如果希望结果更加精确，也可以用0.6或0.7设为阈值，但是不建议用小于0.5的阈值。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/r1qe9cxegg.png&quot;/&gt;&lt;/center&gt;

&lt;h2 id=&quot;算法大致思路&quot;&gt;&lt;strong&gt;1.算法大致思路&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;前面Bounding Box一节中介绍到将图片划分成若干等分，例如3*3，那么一共就有9块，如下图示，我们可以很清楚的看到第二行第一块和第三块都有车，所以可以标出一个中心点坐标(&lt;span class=&quot;math inline&quot;&gt;\(b_x,b_y\)&lt;/span&gt;)，这样我们就能通过最终的输出结果知道这两个框中有车。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/rwssv5aupd.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;但是如果我们划分的数量变多之后呢？如下图示划分成了19*19，图中标出的3个黄框和3个绿框最终结果都会都会返回[&lt;span class=&quot;math inline&quot;&gt;\(P_x=1,b_x=,b_y=……\)&lt;/span&gt;]，但是最后我们该信谁的呢？是这三个框真的有车，而且还不是同一辆车？还是只是同一辆车？所以就有了&lt;strong&gt;非极大值抑制&lt;/strong&gt;来解决这个问题。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/sbvcjpqzqf.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;其思路大致如下(为了方便说明和理解，我们不使用19*19的方框)：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先每个框会对是否有目标返回一个&lt;span class=&quot;math inline&quot;&gt;\(P_c\)&lt;/span&gt;的概率值(也可以是&lt;span class=&quot;math inline&quot;&gt;\(P_c*C_1*C_2*C_3\)&lt;/span&gt;的概率之积)，如下图示：&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/rll50qwtcr.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;然后找到&lt;span class=&quot;math inline&quot;&gt;\(P_c\)&lt;/span&gt;最大的一个框，显然0.9的框有车的概率最大，所以该边框颜色高亮&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/r7qkwtdrx7.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;然后算法遍历其他边框，找出与上一个边框的交并比大于0.5的边框&lt;/strong&gt;，很显然右边的剩余两个边框符合条件，所以这两个边框变暗&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/whf59gksk3.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;左边的车同理，不加赘述&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/0vcus1jzbv.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;下面结合一个例子总结一下&lt;strong&gt;非极大值抑制&lt;/strong&gt;算法的实现步骤：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;注：在这里假设只需要识别定位车辆即可，所以输出格式为[&lt;span class=&quot;math inline&quot;&gt;\(P_c,b_x,b_y,b_h,b_w\)&lt;/span&gt;]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个例子中将图像划分成19*19方格，假设每个方格都已经计算出&lt;span class=&quot;math inline&quot;&gt;\(P_c\)&lt;/span&gt;的概率值&lt;/p&gt;
&lt;p&gt;1.去掉所有满足&lt;span class=&quot;math inline&quot;&gt;\(P_c\leq0.6\)&lt;/span&gt;的方格 (0.6也可以进行人为修改)&lt;/p&gt;
&lt;p&gt;2.对剩下的方格进行如下&lt;strong&gt;循环操作&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从剩下的方格中选取&lt;span class=&quot;math inline&quot;&gt;\(P_c\)&lt;/span&gt;最大的一个作为预测值输出，假设这个方格为A&lt;/li&gt;
&lt;li&gt;将与A方格交并比大于0.5的剔除&lt;/li&gt;
&lt;/ul&gt;&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/ep1t359de1.png&quot;/&gt;&lt;/center&gt;

&lt;p&gt;前面介绍了那么多，都只是识别单个物体，如果要同时识别多个物体该怎么办呢？而且识别的不同物体的中心点在同一个框中又该怎么呢(如下图示，人和车的中心都在红点位置，处于同一个框中)？这时就需要使用&lt;strong&gt;Anchor Boxes&lt;/strong&gt;了。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/wmwz2qbres.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;Anchor Boxes的思路是对于不同的物体事先采用不同的框，例如人相对于车属于瘦高的，所以使用下图中的Anchor Box 1，相反车辆就使用Anchor Box 2.&lt;/p&gt;
&lt;p&gt;之前的输出值的格式都是&lt;span class=&quot;math inline&quot;&gt;\(y=[P_x,b_x,b_y,b_h,b_w,C_1,C_2,C_3]\)&lt;/span&gt;，最后输出的矩阵大小(以该图为例)是(3,3,8),但是这样只能确定一个物体。&lt;/p&gt;
&lt;p&gt;所以为了同时检测不同物体，很自然的我们可以重复输出这个上面的值即可，即&lt;span class=&quot;math inline&quot;&gt;\(y=[P_x,b_x,b_y,b_h,b_w,C_1,C_2,C_3,P_x,b_x,b_y,b_h,b_w,C_1,C_2,C_3]\)&lt;/span&gt;,所以输出矩阵是(3,3,16),也可以是(3,3,2,8)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要注意的是我们需要提前设定好输出值前面的值对应Anchor Box 1，后面的对应Anchor Box 2.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如我们得到了图中人的边框信息值，然后经过计算发现其边框与Anchor Box 1更为接近，所以最后将人的边框信息对应在前面，同理车辆边框信息对应在后面。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/h1kdcusx7r.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;总结起来Anchor Box算法和之前的算法区别如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;之前的算法：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于训练集图像中的每个对象，都根据那个对象的中点位置分配到对应的格子中,所以在上面的示例中输出y就是(3,3,8)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Anchor Boxes算法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在每个对象都和之前一样分配到同一个格子中,即对象中心所在的格子。不同的是也需要分配到和对象形状交并比最高的Anchor Box.&lt;/p&gt;
&lt;p&gt;例如下图中的红色框不仅要分配到其中心所在的图像上的格子中，而且还需要分配到与其交并比最大的Anchor Box中，即竖条的紫色方格&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/x5la9sd9v8.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;回到本小节最开始的例子，最后的输出值如下图示：&lt;/p&gt;
&lt;p&gt;图中人的对应Anchor Box 1， 输出值对应图中的黄色字体；车辆同理，对应绿色字体&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/1215004/zne3xo5v5c.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;

&lt;footer&gt;&lt;br/&gt;&lt;h3 id=&quot;autoid-2-0-0&quot;&gt;&lt;br/&gt;&lt;strong&gt;MARSGGBO&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;♥&lt;/span&gt;原创&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;2018-1-17&lt;/strong&gt;
&lt;/p&gt;
&lt;br/&gt;&lt;/footer&gt;</description>
<pubDate>Wed, 17 Jan 2018 12:41:00 +0000</pubDate>
<dc:creator>marsggbo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/marsggbo/p/8305865.html</dc:identifier>
</item>
</channel>
</rss>