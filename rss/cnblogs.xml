<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>UI自动化测试（二）浏览器操作及对元素的定位方法（xpath定位和css定位详解） - 温一壶清酒</title>
<link>http://www.cnblogs.com/hong-fithing/p/7623838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hong-fithing/p/7623838.html</guid>
<description>&lt;p&gt;Selenium下的Webdriver工具支持FireFox(geckodriver)、 IE(InternetExplorerDriver)、Chrome(ChromeDriver)、 Opera(OperaDriver)， 它还支持AndriodDriver和Iphone(IphoneDriver)的移动应用测试。&lt;/p&gt;
&lt;p&gt;而做测试的主流三款浏览器：Chrome、Firefox和IE，今天就介绍下，Selenium下配置这三款浏览器驱动的方法与用法。&lt;/p&gt;

&lt;h2&gt;1. FireFox&lt;/h2&gt;
&lt;p&gt;       Selenium在3.0以前中的火狐Webdriver， 是火狐浏览器自带的功能，但是3.0以后是实现geckodriver，要使用FireFox浏览器需要自己下载geckodriver.exe，这个程序是由FireFox团队提供的，可以看做它是链接WebDriver和FireFox浏览器的桥梁。&lt;/p&gt;
&lt;p&gt;优点：geckodriver对页面的自动化测试支持得比较好，很直观地模拟页面的操作，对JavaScript的支持也非常完善，基本上页面上做的所有操作geckodriver都可以模拟。&lt;/p&gt;
&lt;p&gt;缺点：启动很慢，运行也比较慢，不过，启动之后Webdriver的操作速度虽然不快但还是可以接受的，建议不要频繁启动停止geckodriver。&lt;/p&gt;
&lt;h3&gt;两种实现方式&lt;/h3&gt;
&lt;p&gt;geckodriver.exe下载地址：&lt;a href=&quot;https://github.com/mozilla/geckodriver/releases/&quot; target=&quot;_blank&quot;&gt;https://github.com/mozilla/geckodriver/releases/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;①.把geckodriver放入java安装的bin目录下，使用如下代码实现：&lt;/p&gt;
&lt;p&gt;WebDriver driver = new FirefoxDriver();&lt;/p&gt;
&lt;p&gt;②.把geckodriver放入火狐的根目录，写如下代码：&lt;/p&gt;
&lt;p&gt;System.setProperty(&quot;webdriver.gecko.driver&quot;,&quot;C:\\Program Files(x86)\\Mozilla Firefox\\geckodriver.exe&quot;);&lt;/p&gt;
&lt;p&gt;WebDriver driver = new FirefoxDriver();&lt;/p&gt;
&lt;h2&gt;2.chrome&lt;/h2&gt;
&lt;p&gt;       webdriver没有实现chromedriver， 要使用chrome浏览器需要自己下载chromedriver.exe， 这个程序是由Chrome团队提供的， 可以看做它是链接WebDriver和Chrome浏览器的桥梁。&lt;/p&gt;
&lt;p&gt;chromedriver下载地址：&lt;a href=&quot;http://chromedriver.storage.googleapis.com/index.html&quot; target=&quot;_blank&quot;&gt;http://chromedriver.storage.googleapis.com/index.html&lt;/a&gt;，chromedriver与chrome的对应关系表如下所示：&lt;a href=&quot;http://npm.taobao.org/mirrors/chromedriver&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;chromedriver版本&lt;/td&gt;
&lt;td&gt;支持的Chrome版本&lt;/td&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;v2.32&lt;/td&gt;
&lt;td&gt;v59-61&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.31&lt;/td&gt;
&lt;td&gt;v58-60&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.30&lt;/td&gt;
&lt;td&gt;v58-60&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.29&lt;/td&gt;
&lt;td&gt;v56-58&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.28&lt;/td&gt;
&lt;td&gt;v55-57&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.27&lt;/td&gt;
&lt;td&gt;v54-56&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.26&lt;/td&gt;
&lt;td&gt;v53-55&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.25&lt;/td&gt;
&lt;td&gt;v53-55&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.24&lt;/td&gt;
&lt;td&gt;v52-54&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.23&lt;/td&gt;
&lt;td&gt;v51-53&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.22&lt;/td&gt;
&lt;td&gt;v49-52&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.21&lt;/td&gt;
&lt;td&gt;v46-50&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.20&lt;/td&gt;
&lt;td&gt;v43-48&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.19&lt;/td&gt;
&lt;td&gt;v43-47&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.18&lt;/td&gt;
&lt;td&gt;v43-46&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.17&lt;/td&gt;
&lt;td&gt;v42-43&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.13&lt;/td&gt;
&lt;td&gt;v42-45&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.15&lt;/td&gt;
&lt;td&gt;v40-43&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.14&lt;/td&gt;
&lt;td&gt;v39-42&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.13&lt;/td&gt;
&lt;td&gt;v38-41&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.12&lt;/td&gt;
&lt;td&gt;v36-40&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.11&lt;/td&gt;
&lt;td&gt;v36-40&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.10&lt;/td&gt;
&lt;td&gt;v33-36&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.9&lt;/td&gt;
&lt;td&gt;v31-34&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.8&lt;/td&gt;
&lt;td&gt;v30-33&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.7&lt;/td&gt;
&lt;td&gt;v30-33&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.6&lt;/td&gt;
&lt;td&gt;v29-32&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.5&lt;/td&gt;
&lt;td&gt;v29-32&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v2.4&lt;/td&gt;
&lt;td&gt;v29-32&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;根据自己安装的chrome浏览器版本再去下载相对应的驱动，不然会出现版本不兼容的情况，而导致配置失败。&lt;/p&gt;
&lt;h3&gt;使用方法&lt;/h3&gt;
&lt;p&gt;①.把chromedriver.exe放入java安装的bin目录下，使用如下代码实现：&lt;/p&gt;
&lt;p&gt;WebDriver driver = new ChromeDriver();&lt;/p&gt;
&lt;p&gt;②.把chromedriver放入浏览器的根目录，写如下代码：&lt;/p&gt;
&lt;p&gt;System.setProperty(&quot;webdriver.chrome.driver&quot;,&quot;C:\\Program Files(x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;);&lt;/p&gt;
&lt;p&gt;WebDriver driver = new ChromeDriver();&lt;/p&gt;
&lt;h2&gt;3. IE&lt;/h2&gt;
&lt;p&gt;webdriver要使用IE浏览器需要下载InternetExplorerDriver.exe，根据浏览器的版本下载32位或者64位的driver。&lt;/p&gt;
&lt;p&gt;IEdriver下载地址：&lt;a href=&quot;http://selenium-release.storage.googleapis.com/index.html&quot; target=&quot;_blank&quot;&gt;http://selenium-release.storage.googleapis.com/index.html&lt;/a&gt;，X86为32位&lt;/p&gt;
&lt;p&gt;在使用IE浏览器的时候，需要注意的是，将IE浏览器各个区域的保护模式设置的一样，要么全设置为高级，要么全设置为低级，工具--Internet选项--安全，还需要将页面的缩放比例设置为100%。操作如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171003131327536-398948300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;使用方法&lt;/h3&gt;
&lt;p&gt;①.把IEDriverServer.exe放入java安装的bin目录下，使用如下代码实现：&lt;br/&gt;WebDriver driver = new InternetExplorerDriver();&lt;/p&gt;
&lt;p&gt;②. 把IEDriverServer.exe放置在IE的安装路径下，使用代码如下：&lt;br/&gt;System.setProperty(&quot;webdriver.ie.driver&quot;,&quot;C:\\Program Files\\InternetExplorer\\IEDriverServer.exe&quot;);&lt;/p&gt;
&lt;p&gt;WebDriver driver = new InternetExplorerDriver();&lt;/p&gt;
&lt;p&gt;优点：直观地模拟用户的实际操作，对JavaScript提供完善的支持。&lt;/p&gt;
&lt;p&gt;缺点： 是所有浏览器中运行速度最慢的， 并且只能在Windows下运行， 对css以及xpath的支持也不够好。&lt;/p&gt;

&lt;p&gt;备注：如果自动启动浏览器报错，请仔细检查是否如下地方&lt;/p&gt;
&lt;p&gt;1.selenium版本和浏览器版本不兼容&lt;/p&gt;
&lt;p&gt;2.driver版本与浏览器版本不兼容&lt;/p&gt;
&lt;p&gt;3.浏览器没有安装在默认路径&lt;/p&gt;

&lt;p&gt;通过鼠标在浏览器中做的操作，基本都可以使用代码来实现，首先来看如下十个基本的用法：　&lt;/p&gt;
&lt;p&gt;　　1.浏览器中加载URL： get() --首先要启动浏览器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
实例：driver.get(&quot;https://www.baidu.com&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.浏览器最大化： window().maximize()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
实例：driver.manage().window().maximize();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.刷新：refresh()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
实例：driver.navigate().refresh();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.返回上一页：back()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
实例：driver.navigate().back();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5.向前进一页：forward()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
实例：driver.navigate().back();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6.截图：getScreenshotAs()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
File screenfile=&lt;span&gt;((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE);
FileUtils.copyFile(screenfile,&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; File(&quot;D:/12306.png&quot;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7.获取当前页的URL：getCurrentUrl()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
String url =&lt;span&gt; driver.getCurrentUrl();
System.out.println(url);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8.关闭当前tab页面：close()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
实例：driver.close();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　9.退出当前driver：quit()&lt;/p&gt;
&lt;p&gt;　　10.获取当前页的title：getTitle()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
String title =&lt;span&gt; driver.getTitle();
System.out.println(title);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;整体代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; org.apache.commons.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.OutputType;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.TakesScreenshot;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebElement;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo1 {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器要加载的url&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         driver.get(&quot;https://www.baidu.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口最大化&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;kw是输入框的id，12306是在输入框中药输入的内容&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         driver.findElement(By.id(&quot;kw&quot;)).sendKeys(&quot;12306&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;su是搜索按钮的id&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         WebElement btn=driver.findElement(By.id(&quot;su&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击事件&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        btn.click();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        driver.navigate().refresh();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;后退一页&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        driver.navigate().back();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前进一页&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        driver.navigate().forward();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;截图&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         File screenfile=&lt;span&gt;((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         FileUtils.copyFile(screenfile,&lt;span&gt;new&lt;/span&gt; File(&quot;D:/12306.png&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取url&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         String url =&lt;span&gt; driver.getCurrentUrl();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        System.out.println(url);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取标题&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         String title =&lt;span&gt; driver.getTitle();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        System.out.println(title);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭当前页&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        driver.close();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们要明白，对象的定位和操作是自动化测试的核心部分，其中操作又是建立在定位的基础上的，比如说：一个对象就是一个人，我们可以通过身份证号、姓名或者他的住址找到这个人。那么一个web对象也是一样的，我们可以通过唯一区别于其它对象的属性来定位这个元素。&lt;/p&gt;
&lt;p&gt;首先来了解在元素定位中要使用到的工具：&lt;/p&gt;
&lt;h2&gt;Firebug&lt;/h2&gt;
&lt;p&gt;　　Firebug是网页浏览器 Mozilla Firefox下的一款开发类插件，它集HTML查看和编辑、 Javascript控制台、网络状况监视器于一体，是开发JavaScript、CSS、HTML和Ajax的得力助手。&lt;/p&gt;
&lt;p&gt;安装Firebug：&lt;/p&gt;
&lt;p&gt;方法①Mozilla Firefox菜单--附加组件--插件--搜索Firebug--安装--重启浏览器&lt;/p&gt;
&lt;p&gt;方法②可以把插件下载好后，在附件中，导入即可，需要重启浏览器&lt;/p&gt;
&lt;p&gt;firepath安装方法与firebug方法一样，需要注意的是，Firefox版本不能太高，不然插件是安装不成功的，我用的是42.0版本&lt;/p&gt;
&lt;h2&gt;Firepath&lt;/h2&gt;
&lt;p&gt;　　FirePath是Firebug的扩展插件，添加了开发工具，可以编辑，监测和生成XPath 1.0表达式、 CSS 3选择符和JQuery的选择符。可以快速度的帮助我们通过xPATH和css定义页面上的元素。&lt;/p&gt;
&lt;p&gt;这两款工具都是Firefox的插件，在火狐浏览器中添加或直接下载即可，安装好了在浏览器右上角会有一只虫子一样的图标，如下界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171003133443130-683985130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;chrome和IE的开发者工具&lt;/h2&gt;
&lt;p&gt;chrome 浏览器自带开发者工具，浏览器右上的小扳手，在下拉菜单中选择“工具”--“开发者工具” 即可打开，也可以使用快捷键Ctrl+Shift+I或者F12直接打开&lt;/p&gt;
&lt;p&gt;一般是使用谷歌浏览器运行自动化代码，火狐做元素定位，IE用的较少&lt;/p&gt;
&lt;h2&gt;定位元素的方法&lt;/h2&gt;
&lt;p&gt;有如下七种，分别是：&lt;/p&gt;
&lt;p&gt;　　1.通过id定位元素：findElement(By.id(&quot;id_vaule&quot;))&lt;/p&gt;
&lt;p&gt;　　2.通过name定位元素：findElement(By.name(&quot;name_vaule&quot;))&lt;/p&gt;
&lt;p&gt;　　3.通过class_name定位元素：findElement(By.className(&quot;class_name&quot;))&lt;/p&gt;
&lt;p&gt;　　4.通过tag_name定位元素：findElement(By.tagName(&quot;tag_name&quot;))&lt;/p&gt;
&lt;p&gt;　　5.通过link定位：findElement(By.linkText(&quot;text_vaule&quot;))或： findElement(By.partialLinkText(&quot;text_vaule&quot;))，前者是精确link中的文字，后者是在当前页面只有唯一link文字情况下，可只写一半或一个汉字&lt;/p&gt;
&lt;p&gt;　　6.通过css定位元素：findElement(By.cssSelector())&lt;/p&gt;
&lt;p&gt;　　7.通过xpath定位元素：findElement(By.xpath())&lt;/p&gt;
&lt;p&gt;前五种方法实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo1 {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器要加载的url&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         driver.get(&quot;https://www.baidu.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口最大化&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.通过id定位
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; driver.findElement(By.id(&quot;kw&quot;)).sendKeys(&quot;12306&quot;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.通过name定位
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; driver.findElement(By.name(&quot;wd&quot;)).sendKeys(&quot;12306&quot;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.通过classname定位
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; driver.findElement(By.className(&quot;s_ipt&quot;)).sendKeys(&quot;12306&quot;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.通过tagname定位    tagname:不能识别去操作，因为有很多重复标签 ，所以定位不到
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; driver.findElement(By.tagName(&quot;input&quot;)).sendKeys(&quot;12306&quot;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5.通过link定位
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; driver.findElement(By.linkText(&quot;新闻&quot;)).click();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过部分link文本定位&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         driver.findElement(By.partialLinkText(&quot;新&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭当前页&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        driver.close();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;xpath是一种在XML文档中定位元素的语言。因为HTML可以看作是XML的一种形式，selenium可使用这种强大语言在web应用中定位元素。&lt;/p&gt;
&lt;p&gt;xpath有6种定位元素的方式，分别是：&lt;/p&gt;
&lt;p&gt;　　1.通过绝对路径做定位&lt;/p&gt;
&lt;p&gt;　　　　xpath的开头是一个斜线（/）代表这是绝对路径。使用firebug等方式可以获取绝对路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
实例：driver.findElement(By.xpath(&quot;/html/body/div[2]/div[1]/div/div[3]/a[1]&quot;)).click();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绝对路径定位百度中的新闻&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　使用firebug等方式可以获取绝对路径：firebug找到元素，右击“复制xpath”，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171003150708849-1842717225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2．通过相对路径做定位&lt;/p&gt;
&lt;p&gt;　　　　如果开头是两个斜线（//）表示文件中所有符合模式的元素都会被选出来，即使是处于树中不同的层级也会被选出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
实例：driver.findElement(By.xpath(&quot;//div[2]/div[1]/div/div[3]/a[1]&quot;)).click();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3. 通过元素索引定位 ， 索引的初始值为1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
实例：driver.findElement(By.xpath(&quot;//div[3]/a[1]&quot;)).click();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位文件中第1个对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4. 使用属性定位　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性定位　　&lt;br/&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;input[@id='kw']&quot;)).sendKeys(&quot;12306&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;双属性定位一个元素    &lt;/span&gt;
driver.findElement(By.xpath(&quot;//a[@class='mnav' and @name='tj_trnews']&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多属性定位一个元素&lt;/span&gt;
driver.findElement(By.xpath(&quot;//input[@id='kw' or class='s_ipt']&quot;)).sendKeys(&quot;12306&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5. 使用部分属性值匹配　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用部分属性值定位,以某字符串开头&lt;/span&gt;
driver.findElement(By.xpath(&quot;//a[starts-with(@name,'tj_trh')]&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用部分属性值定位,以某字符串结尾
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a[ends-with(@name,'hao123')]&quot;)).click();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法只在selenium1.0中实现
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串截取name=tj_trhao123&lt;/span&gt;
driver.findElement(By.xpath(&quot;//a[substring(@name,string-length(@name)-5)='hao123']&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;包含&lt;/span&gt;
driver.findElement(By.xpath(&quot;//a[contains(@name,'123')]&quot;)).click();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6. 使用任意属性值匹配元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
实例：driver.findElement(By.xpath(&quot;//input[@*='kw']&quot;)).sendKeys(&quot;12306&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7. 使用xpath的text函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;实例：
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两种方式&lt;/span&gt;
　　　　driver.findElement(By.xpath(&quot;//a[text()='新闻']&quot;&lt;span&gt;)).click();
　　　　driver.findElement(By.xpath(&lt;/span&gt;&quot;//a[contains(text(),'新')]&quot;)).click();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo_xpath {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器要加载的url&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         driver.get(&quot;https://www.baidu.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口最大化&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绝对路径定位百度中的新闻
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;/html/body/div[2]/div[1]/div/div[3]/a[1]&quot;)).click();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对路径定位百度中的新闻
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;div[2]/div[1]/div/div[3]/a[1]&quot;)).click();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过元素索引定位
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;div[3]/a[1]&quot;)).click();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性定位
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;input[@id='kw']&quot;)).sendKeys(&quot;12306&quot;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;input[@*='kw']&quot;)).sendKeys(&quot;12306&quot;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;双属性定位一个元素    
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a[@class='mnav' and @name='tj_trnews']&quot;)).click();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;多属性定位一个元素
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;input[@id='kw' or class='s_ipt']&quot;)).sendKeys(&quot;12306&quot;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用部分属性值定位,以某字符串开头
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a[starts-with(@name,'tj_trh')]&quot;)).click();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用部分属性值定位,以某字符串结尾
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a[ends-with(@name,'hao123')]&quot;)).click();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法只在xpath2.0中实现,浏览器实现的都是xpath1.0
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串截取name=tj_trhao123
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a[substring(@name,string-length(@name)-5)='hao123']&quot;)).click();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;包含
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a[contains(@name,'123')]&quot;)).click();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;xpath的text函数
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.xpath(&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;a[text()='新闻']&quot;)).click();&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         driver.findElement(By.xpath(&quot;//a[contains(text(),'新')]&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         
&lt;span&gt;41&lt;/span&gt;         
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;常用CSS定位语法如下，class就用.代替再接class中的属性值，id用#代替再接id中的属性值，跟样式一样&lt;/p&gt;
&lt;p&gt;1.使用绝对路径来定位元素。&lt;/p&gt;
&lt;p&gt;　　CSS绝对路径指的是在DOM结构中具体的位置，使用绝对路径来定位用户名输入字段， 在使用绝对路径的时候，每个元素之间要有一个空格。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
实例：driver.findElement(By.cssSelector(&quot;html body div#wrapper div#head div.head_wrapper div#u1 a.mnav&quot;)).click();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以使用firebug工具复制css路径即可，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171003150621880-1423779479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.使用相对路径来定位元素&lt;/p&gt;
&lt;p&gt;　　当使用CSS选择器来查找元素的时候，我们可以使用class属性来定位元素，我们可以先指定一个HTML的标签，然后加上一个” .” 符合，跟上class属性的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
实例：driver.findElement(By.cssSelector(&quot;div#u1 a.mnav&quot;)).click();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　若是同一列表中，可使用下一节点方法实现，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
driver.findElement(By.cssSelector(&quot;div#u1 a.mnav + a +a&quot;)).click();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.使用相对ID选择器来定位元素&lt;/p&gt;
&lt;p&gt;　　可以使用元素的ID来定位元素， 先指定一个HTML标签， 然后加上一个” #”符号， 跟上id的属性值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
driver.findElement(By.cssSelector(&quot;input#kw&quot;)).sendKeys(&quot;12306&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.使用属性值选择器来定位元素&lt;/p&gt;
&lt;p&gt;　　通过指定元素中属性值来定位元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;单属性&lt;/span&gt;
driver.findElement(By.cssSelector(&quot;a[name='tj_trnews']&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多属性&lt;/span&gt;
driver.findElement(By.cssSelector(&quot;a[name='tj_trnews'][class='mnav']&quot;)).click();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.部分属性值的匹配&lt;/p&gt;
&lt;p&gt;　　CSS选择器提供了一个部分属性值匹配定位元素的方法，这为了测试那些页面上具有动态变化的属性的元素是非常有用的，例如界面技术EXTJS的id,className是动态变化的。&lt;/p&gt;
&lt;p&gt;　　匹配前缀： ^=   匹配后缀： $=    匹配字符串： *=&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以href属性值http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;news.开头&lt;/span&gt;
driver.findElement(By.cssSelector(&quot;a[href^='http://news.'][class='mnav']&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以href属性值preferences.html结尾&lt;/span&gt;
driver.findElement(By.cssSelector(&quot;a[href$='preferences.html'][class='pf']&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以href属性值包含hao123&lt;/span&gt;
driver.findElement(By.cssSelector(&quot;a[href*='hao123'][class='mnav']&quot;)).click();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.列表选择具体的匹配&lt;/p&gt;
&lt;p&gt;　　Selenium中的CSS选择器允许我们更细致的浏览列表下的元素，我想选择第三个链接，可以用nth-of-type或者nth-child&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
driver.findElement(By.cssSelector(&quot;div a[class='mnav']:nth-of-type(3)&quot;&lt;span&gt;)).click();
driver.findElement(By.cssSelector(&lt;/span&gt;&quot;div a[class='mnav']:nth-child(3)&quot;)).click();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ui.day1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.By;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.chrome.ChromeDriver;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; yihuqingjiu_test_demo_css {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.setProperty(&quot;webdriver.chrome.driver&quot;, &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         WebDriver driver=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChromeDriver();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;浏览器要加载的url&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         driver.get(&quot;https://www.baidu.com&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;窗口最大化&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        driver.manage().window().maximize();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绝对路径
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.cssSelector(&quot;html body div#wrapper div#head div.head_wrapper div#u1 a.mnav&quot;)).click();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相对路径
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.cssSelector(&quot;div#u1 a.mnav&quot;)).click();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;id定位
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.cssSelector(&quot;input#kw&quot;)).sendKeys(&quot;12306&quot;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单属性
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.cssSelector(&quot;a[name='tj_trnews']&quot;)).click();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;多属性
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.cssSelector(&quot;a[name='tj_trnews'][class='mnav']&quot;)).click();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以href属性值http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;news.开头
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.cssSelector(&quot;a[href^='&lt;/span&gt;&lt;span&gt;http://news&lt;/span&gt;&lt;span&gt;.'][class='mnav']&quot;)).click();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以href属性值preferences.html结尾
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.cssSelector(&quot;a[href$='preferences.html'][class='pf']&quot;)).click();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以href属性值包含hao123
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;driver.findElement(By.cssSelector(&quot;a[href*='hao123'][class='mnav']&quot;)).click();&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         driver.findElement(By.cssSelector(&quot;div a[class='mnav']:nth-of-type(3)&quot;&lt;span&gt;)).click();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用css定位语法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171003154255849-1853959616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;css定位与xpath定位的对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1242227/201710/1242227-20171003154751693-1358910515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进行元素定位，xpath与css普遍使用，从上述对比中，可看出css定位方法比xpath方法要简洁一些，css优于xpath。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;23.41935483871&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;本文仅代表作者观点，系作者@温一壶清酒发表。转载请注明出处：&lt;a href=&quot;http://www.cnblogs.com/hong-fithing/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/hong-fithing/&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 03 Oct 2017 07:55:00 +0000</pubDate>
<dc:creator>温一壶清酒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hong-fithing/p/7623838.html</dc:identifier>
</item>
<item>
<title>关于如何更好地使用Github的一些建议 - Wasdns</title>
<link>http://www.cnblogs.com/qq952693358/p/7623703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq952693358/p/7623703.html</guid>
<description>&lt;p&gt;原文(Github repository形式): &lt;a href=&quot;https://github.com/Wasdns/github-example-repo&quot; class=&quot;uri&quot;&gt;https://github.com/Wasdns/github-example-repo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文记录了我对于Github使用的一些技巧，并针对以下几个方面:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一、提交问题；&lt;/li&gt;
&lt;li&gt;二、提交(commit)的注释信息；&lt;/li&gt;
&lt;li&gt;三、README形式的Github文档撰写。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;给出了自己的一些建议，不足之处欢迎各位指出，欢迎补充和提问：）。&lt;/p&gt;
&lt;h2 id=&quot;一提交问题&quot;&gt;一、提交问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在提问之前，请确认你的问题是否能够通过以下方式解决：(1)百度；(2)bing；(3)Google；(4)Stackoverflow。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个参考的主要提问步骤分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1)标题：出现bug的概要，例：&quot;在根目录下，某某文件无法找到&quot;&lt;/li&gt;
&lt;li&gt;(2)背景介绍(可选)：介绍你大概的目的是什么；例：&quot;为了测试数独，我做了这个实验，遇到了这个问题。&quot;&lt;/li&gt;
&lt;li&gt;(3)实验环境：你的系统环境、安装的依赖，选择性给出；例：&quot;我的操作系统为Ubuntu 14.04，64位。&quot;&lt;/li&gt;
&lt;li&gt;(4)&lt;strong&gt;重要&lt;/strong&gt;：重现bug的步骤，尽量条理清晰、简明；&lt;/li&gt;
&lt;li&gt;(5)期待出现的行为(可选)：如果没有遇到这个bug，你希望得到的结果是什么；&lt;/li&gt;
&lt;li&gt;(6)结果出现的行为：较为全面的bug信息，或者错误日志，或者二者兼具；&lt;/li&gt;
&lt;li&gt;(7)额外信息：一些附加的信息，如代码(简短的骨架，或者以站外链接的形式贴出)，或者你对于该错误的认识；&lt;/li&gt;
&lt;li&gt;(8)礼貌用语。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;错误示范：&lt;a href=&quot;https://github.com/Wasdns/github-example-repo/issues/1&quot;&gt;WTF the bug is?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考样例：&lt;a href=&quot;https://github.com/Wasdns/github-example-repo/issues/2&quot;&gt;&quot;error: HashAlgorithm.csum16: Invalid enum tag&quot;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二提交commit的注释信息&quot;&gt;二、提交(commit)的注释信息&lt;/h2&gt;
&lt;p&gt;对于一个commit来说，一个完备的注释信息有助于让其他人了解你的这次提交做了什么工作。例如，项目管理员对PR进行code review时需要对于该PR的每一次提交进行审核，如果每次提交的注释信息都非常简单/杂乱，那么对于code reviewer来说是非常不友好的：他需要翻看你每一次文件的修改记录来判断你的这次提交做了什么工作。&lt;/p&gt;
&lt;p&gt;一个规范的commit有这样的几个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.注释信息的标题有一句清晰的概述，且主体内容简洁明了；&lt;/li&gt;
&lt;li&gt;2.注释信息的拓展描述中，对于每一处的修改都有清晰的记录；&lt;/li&gt;
&lt;li&gt;3.注释信息应保留必要的信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1.注释信息的标题有一句清晰的概述，且主体内容简洁明了：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标题至少需要有一句完整的句子(建议少于50字)来说明本次提交做了哪些工作。在大部分同学的github中，每次提交的注释信息通常只有&quot;更新&quot;、&quot;修改&quot;几个单词，其他开发者自然很困惑：到底你更新了什么、修改了什么？只能通过查阅详细信息来查看这次commit的具体修改。一个参考的规范注释信息标题的格式为&lt;code&gt;文件名：简述改动信息&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;错误示例：&lt;code&gt;fix bug&lt;/code&gt;，&lt;code&gt;更新&lt;/code&gt;，&lt;code&gt;发布&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;参考示例：&lt;code&gt;文件名：简述改动信息&lt;/code&gt;，如：&lt;code&gt;README.md: 更新第三章，加入了对commit注释信息的描述&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此外，要求注释信息的主体内容在能让别人看懂的情况下尽量简洁明了，不加入过多的不必要信息。&lt;/p&gt;
&lt;p&gt;错误示例1：&lt;code&gt;我把今天志玲女神写的代码给删除了。&lt;/code&gt; 其中&lt;code&gt;今天志玲女神写的代码&lt;/code&gt;是不明确且不必要的，而且没有体现出本次提交的目的。&lt;/p&gt;
&lt;p&gt;参考示例2：&lt;code&gt;修改&quot;你今天真好看&quot;功能的API：删除了文件hello.c中的函数模块printBeauty()，修改了函数hello()的返回参数类型。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;错误示例2：&lt;code&gt;今天客户A那货提出了一个需求叫做&quot;你今天真好看&quot;，后面的同学注意了，我把原来文件hello.c中的一些功能做了适配，来支持这个新功能。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参考示例2：&lt;code&gt;增加&quot;你今天真好看&quot;功能：修改hello.c中函数hello()的返回参数类型。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.注释信息的拓展描述中，对于每一处的修改都有清晰的记录：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个提交修改了项目中的多个文件/模块，可以将这些修改的共同点，如&lt;code&gt;加入新功能&quot;你今天真好看&quot;&lt;/code&gt;，作为提交注释信息的标题，并将这些修改的具体信息在注释信息的文本栏中分点列出。&lt;/p&gt;
&lt;p&gt;错误示例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Commit Title:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;按今天客户A的需求加了一个新功能&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Commit Content:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;修改了文件hello.c, beauty.c, stupidClient.c。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考示例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Commit Title:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;2017/10/1：加入新功能&quot;你今天真好看&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Commit Content:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;1.修改文件hello.c：hello函数返回参数类型(L101)；
2.修改文件beauty.c：将hello函数结果进行输出(L20)；
3.增加2017/10/1的客户需求到文件stupidClient.c中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.注释信息应保留必要的信息：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;倘若你认为这一次的commit是有必要的，那么请在注释说明中说明以下必要的信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.为什么这次修改是必要的，它解决了什么问题/它的目的是什么？&lt;/li&gt;
&lt;li&gt;2.这次commit是如何解决问题/达到上述目的的？&lt;/li&gt;
&lt;li&gt;3.影响的文件有哪些？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;错误示例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Commit Title:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Fix bug // 它解决了什么问题？&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Commit Content:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 这次commit是如何解决问题的？影响的文件有哪些？
&amp;lt;Empty&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考示例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Commit Title:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;Fix bug #1 // 它解决了issue#1，因此这次修改是必要的&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Commit Content:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;// 这次commit通过...解决了问题。影响了文件src/hello.c。
1.修改文件src/hello.c：修改hello_beauty()函数的返回参数类型(L30)；
2.在单元测试中增加测试test1，避免#1的重复发生。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，有一些commit完全没有必要，或者对于该项目毫无意义，比如：&lt;/p&gt;
&lt;p&gt;错误示例1：小陈为了刷KPI(Key Performance Indicator，关键绩效指标)，将文件A中所有的空行删除，做了一次提交，心里美滋滋的。&lt;/p&gt;
&lt;p&gt;错误示例2：负责在Github上进行某个项目开发的小李被开除了，被迫离开了现在的公司；在离开前，她将本地仓库中所有的内容删除，并将这些修改提交到了项目中，以此宣泄心中的愤恨。&lt;/p&gt;
&lt;p&gt;不提交没有必要、毫无意义的commit是每一个项目成员应该遵守的规范。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一些建议：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1)个人推荐以Github的客户端，如&lt;a href=&quot;https://desktop.github.com/&quot;&gt;Github Desktop&lt;/a&gt;为主、命令行为辅来进行commit提交，写提交信息时的效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/885822/201710/885822-20171003142858958-1606306441.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外，还可以在desktop上查看历史的提交记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/885822/201710/885822-20171003142909646-254088693.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(2)在使用命令行进行提交时，通常使用&lt;code&gt;git commit -m '注释信息'&lt;/code&gt;来填写commit注释信息，但是&lt;code&gt;-m&lt;/code&gt;参数适合单行注释，对于多行的commit注释来说是不合适的。这里推荐使用&lt;code&gt;git commit -v&lt;/code&gt;命令，会自动跳出文本栏以供commit注释信息的编辑，其中文本的首行将作为commit的标题，剩余部分将作为补充信息。&lt;/p&gt;
&lt;p&gt;(3)如果某次提交修改的范围非常大，即改动了非常多的文件，建议划分为多次commit，每次提交一个子模块并加以对应信息的说明；如果某次提交修改的范围较小，比如只修改了一个文件中某个变量的赋值操作，可以酌情与其他commit合并为一个commit，在注释信息中说明这一点即可。&lt;/p&gt;
&lt;p&gt;(4)阮一峰老师写了一篇关于Github commit注释信息的博客：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html&quot;&gt;Commit message 和 Change log 编写指南&lt;/a&gt;，介绍了AngularJS团队的commit注释信息格式，这里推荐给大家。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt;
// 空一行
&amp;lt;body&amp;gt;
// 空一行
&amp;lt;footer&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;拓展阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;三readme形式的github文档撰写&quot;&gt;三、README形式的Github文档撰写&lt;/h2&gt;
&lt;p&gt;一个规范化、详细的文档是一个优秀项目必不可少的内容。在Github上有两种撰写文档的方式，一种是&quot;README&quot;，另一种是wiki，本节主要介绍笔者在使用README进行文档记录的一些经验，主要包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.如何创建README文档；&lt;/li&gt;
&lt;li&gt;2.使用Markdown语法记录、修改文档；&lt;/li&gt;
&lt;li&gt;3.通用的README文档格式；&lt;/li&gt;
&lt;li&gt;4.实验室Github科研型项目，README文档的参考示例；&lt;/li&gt;
&lt;li&gt;5.现有大型商用项目README文档参考示例。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何创建readme文档&quot;&gt;1.如何创建README文档&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在创建一个新的项目时，有一个名为&quot;Initialize this repository with a README&quot;的选项，勾选即可为该项目创建一个README文档：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cloud.githubusercontent.com/assets/4122993/16925080/64863a10-4cd7-11e6-8da7-b31a29b769f2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在项目目录中，该文件是&quot;README.md&quot;，&lt;code&gt;.md&lt;/code&gt;后缀表明该文件是Markdown文件，使用Markdown文本编辑语言进行文件编辑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在项目主页中，有一个名为&quot;Create new file&quot;的按钮，如图红色阴影部分所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/885822/201710/885822-20171003142926318-474409395.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击进入创建界面，在&quot;Name your file&quot;一栏中，填入以&lt;code&gt;.md&lt;/code&gt;后缀名结尾的文件名，如&quot;README.md&quot;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/885822/201710/885822-20171003142937568-636511528.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Github默认在页面中显示使用&quot;README.md&quot;, &quot;readme.md&quot;, &quot;README&quot;, &quot;readme&quot;作为名字的文件内容；其中在显示&quot;README.md&quot;和&quot;readme.md&quot;文档时，Github基于Markdown语法对其进行显示，比如将文件的内容：&lt;code&gt;# [标题名称]&lt;/code&gt; 以一级标题的形式显示出来。&lt;/p&gt;
&lt;p&gt;紧接着就可以在下方的文本框中开始文档的撰写了。此外，Github支持在线的文档视图，点击如图红色方框 &quot;Preview&quot;(创建文件时显示)/&quot;Preview changes&quot;(修改文件时显示) 所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/885822/201710/885822-20171003142946990-698453310.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即可将刚才新增/修改的内容以可视化的形式呈现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/885822/201710/885822-20171003142959349-799343706.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，合理在commit中描述该文档，并将该文档提交到你的项目中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/885822/201710/885822-20171003143008427-1079934070.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法三：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在主机的仓库中创建README文档，并提交至Github上。该方法不再具体阐释。&lt;/p&gt;
&lt;p&gt;注：上文中创建的README文档即项目中的&lt;a href=&quot;https://github.com/Wasdns/github-example-repo/blob/master/simple-README.md&quot;&gt;simple-README.md&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;使用markdown语法记录修改文档&quot;&gt;2.使用Markdown语法记录、修改文档&lt;/h3&gt;
&lt;p&gt;这里为读者提供了一些用于掌握基本的Markdown语法的参考资料，包括：&lt;/p&gt;
&lt;p&gt;Github上README文档的记录、修改与普通的Markdown文档的记录、修改无异。&lt;/p&gt;
&lt;h3 id=&quot;通用的readme文档格式&quot;&gt;3.通用的README文档格式&lt;/h3&gt;
&lt;p&gt;Github官方给出了&lt;a href=&quot;https://guides.github.com/features/wikis/&quot;&gt;一种通用的README文档格式&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;项目名：在人们往下浏览你的仓库之前，首先会看到你的项目名称；项目名称应在README文件的首部。&lt;/li&gt;
&lt;li&gt;描述：对于接下来README内容的一个描述；一个好的描述是非常清晰、简洁、切合主题的；用于描述该项目的重要性以及作用。&lt;/li&gt;
&lt;li&gt;内容表格：可选；引入内容表格的目的在于为人们提供一个快捷的导航，尤其是在README文档内容多且详细的时候。&lt;/li&gt;
&lt;li&gt;安装：接着，安装教程告诉用户如何快速、正确安装你的项目；可以考虑的是，做一个gif描述安装过程，使其他人对整个过程更加清楚。&lt;/li&gt;
&lt;li&gt;使用说明：下一个阶段是使用说明，用于告诉已经安装好项目的用户如何使用你的项目；该处适合增加一些项目的截屏。&lt;/li&gt;
&lt;li&gt;贡献：一个大型商用项目通常有一个独立的章节，用于描述如何为这个项目作出贡献(如文件命名、编码规范等)，有时可能是一个独立的描述文件；如果你有特殊的要求，详细地解释你的要求有助于其他开发者更好地为你的项目做出贡献。深入阅读：&lt;a href=&quot;https://help.github.com/articles/setting-guidelines-for-repository-contributors/&quot;&gt;setting guidelines for repository contributors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;荣誉：增加一个章节用于列举出项目的作者和做出贡献的开发者们。&lt;/li&gt;
&lt;li&gt;许可证：加入一个章节用于描述该项目的许可证。如何选择一个合适的许可证：&lt;a href=&quot;https://choosealicense.com/&quot;&gt;licensing guide&lt;/a&gt;，也可以参考阮一峰老师的教程：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html&quot;&gt;如何选择开源许可证？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实验室github科研型项目readme文档的参考示例&quot;&gt;4.实验室Github科研型项目，README文档的参考示例&lt;/h3&gt;
&lt;p&gt;标准语言：English。&lt;/p&gt;
&lt;p&gt;一个实验室Github科研型项目，README文档参考示例由以下几个部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Chapter1: 项目名称(一级标题)+项目贡献描述(内容，以点列出)；&lt;/li&gt;
&lt;li&gt;Chapter2: 安装所需的软件依赖，贴上对应的Installation Guide链接；&lt;/li&gt;
&lt;li&gt;Chapter3: &quot;Getting Start&quot; 项目，即入门级项目，一个帮助用户快速上手的demo；&lt;/li&gt;
&lt;li&gt;Chapter4: README主体部分，以项目贡献点列章节，每个章节阐述项目中对应于该贡献点的文件和子模块；&lt;/li&gt;
&lt;li&gt;Chapter5: 相关工作，相关的论文或者Github项目，给出链接；&lt;/li&gt;
&lt;li&gt;Chapter6: 问题向导，当用户遇到问题时解决问题的方法，包括给出社区链接、相关issues、联系邮件地址等等；&lt;/li&gt;
&lt;li&gt;Chapter7: 引用的参考文献，作者信息。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;现有大型商用项目readme文档参考示例&quot;&gt;5.现有大型商用项目README文档参考示例&lt;/h3&gt;
&lt;h2 id=&quot;四参考资料&quot;&gt;四、参考资料&lt;/h2&gt;
</description>
<pubDate>Tue, 03 Oct 2017 06:26:00 +0000</pubDate>
<dc:creator>Wasdns</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qq952693358/p/7623703.html</dc:identifier>
</item>
<item>
<title>用canvas给自己的博客园加背景（一） - dkplus</title>
<link>http://www.cnblogs.com/dkplus/p/7623642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dkplus/p/7623642.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;最近在折腾canvas，写一点笔记。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;本文面向canvas入门的前端，写的如有纰漏请指出，不喜勿喷。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这一系列的文章最终结果是做出本人博客的动态背景，不过凡事都要循序渐进，我们先从最简单的绘制开始。&lt;/p&gt;
&lt;p&gt;本人接触电脑的第一个绘图工具就是windows自带的&lt;code&gt;画图&lt;/code&gt;。画图的流程很简单，选好填充颜色、线条颜色、粗细，用鼠标选好形状就可以画出来了，而且每次重新改变填充颜色、线条颜色、粗细只会对后面的绘制的形状起作用（听起来就是废话，但是我们绘制canvas的思路也是如此）。&lt;/p&gt;
&lt;h2 id=&quot;创建canvas画布&quot;&gt;创建canvas画布&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首先要有一块画布，我们才能往里面画东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们要在html里添加一个&lt;code&gt;canvas&lt;/code&gt;标签，在js里获取这个元素，而canvas的主要属性有&lt;code&gt;width&lt;/code&gt; &lt;code&gt;height&lt;/code&gt;，我们可以用js修改这两个属性让canvas布满整个屏幕，达到自适应，然后就是获取&lt;code&gt;2d&lt;/code&gt;上下文：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;canvas&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;canvas&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/canvas&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; canvas &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;querySelector&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;#canvas&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//宽高自适应&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;canvas&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;innerWidth&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;canvas&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;innerHeight&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//获取2d上下文&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; ctx &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;canvas&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getContext&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2d&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;co&quot;&gt;/*为了看清楚画布，我们可以描个边*/&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;#canvas&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/*有习惯做reset的可以做全一点，这里把body布满页面*/&lt;/span&gt;
body&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;padding:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;绘图的画布到这里就创建完了，目前canvas的背景是透明的（可以按&lt;code&gt;f12&lt;/code&gt;看一下）。&lt;/p&gt;
&lt;h2 id=&quot;绘制样式&quot;&gt;绘制样式&lt;/h2&gt;
&lt;p&gt;想要绘制形状，先要有绘制样式，当然canvas有默认的绘制样式，我主要介绍自己常用的，有兴趣的可以自己去深入了解。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;fillStyle&lt;/code&gt;填充属性，支持十六进制，rgb，rgba填充，颜色名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strokeStyle&lt;/code&gt;描边属性，支持十六进制，rgb，rgba填充，颜色名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lineWidth&lt;/code&gt;线条属性，数值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;修改这些属性要通过上下文对象ctx&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fillStyle&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;green&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;strokeStyle&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;black&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;lineWidth&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;绘制形状&quot;&gt;绘制形状&lt;/h2&gt;
&lt;p&gt;和画图一样，我们绘制的形状有线、矩形、弧和多边形，圆是包含在弧里面的，这些API也很容易看得懂。&lt;/p&gt;
&lt;h3 id=&quot;开始路径&quot;&gt;开始路径&lt;/h3&gt;
&lt;p&gt;这点非常重要，虽然没有这行代码也可以绘制图形，但是每次图形的绘制会在上一个图形的结束点开始绘制，这明显不是我们想要的结果，所以务必在每个形状绘制前加入这么一行代码。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;beginPath&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;矩形&quot;&gt;矩形&lt;/h3&gt;
&lt;p&gt;矩形是默认的形状，有自己的fillRect()和strokeRect()。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//填充矩形：ctx.fillRect(x坐标,y坐标,width宽度,height高度);&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fillRect&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//描边矩形：ctx.strokeRect(x坐标,y坐标,width宽度,height高度);&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;strokeRect&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;圆弧&quot;&gt;圆（弧）&lt;/h3&gt;
&lt;p&gt;弧只是路径，光靠arc()只能定义路径，需要用fill()和stroke()才能填充和绘制。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//圆路径：ctx.arc(x坐标,y坐标,r半径,开始弧度,结束弧度,布尔值);&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;arc&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;PI&lt;/span&gt;/&lt;span class=&quot;dv&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;Math&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;PI&lt;/span&gt;/&lt;span class=&quot;dv&quot;&gt;180&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;360&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//填充圆&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;fill&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//描边圆&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;stroke&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;线&quot;&gt;线&lt;/h3&gt;
&lt;p&gt;线是路径，两点成线，所以要定义开始点moveTo()，目标点lineTo()。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//定义线的起始点&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;moveTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;460&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;460&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//定义目标点&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;lineTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//折线&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;lineTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//折线&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;lineTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//绘制线条&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;stroke&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;多边形&quot;&gt;多边形&lt;/h3&gt;
&lt;p&gt;多边形其实也是线，一开始我们说要用beginPath()重新定义开始的点，而绘制多边形则要闭合路径closePath()。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//绘制等腰三角形&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;beginPath&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;moveTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;lineTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;150&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;300&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;lineTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;250&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;300&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//闭合路径&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;closePath&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;stroke&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本节先讲基础的绘制知识，下一节内容会介绍requestAnimationFrame()动画。&lt;/p&gt;
</description>
<pubDate>Tue, 03 Oct 2017 05:34:00 +0000</pubDate>
<dc:creator>dkplus</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dkplus/p/7623642.html</dc:identifier>
</item>
<item>
<title>作为程序员的你，一年看几本技术相关的书 - LevenYes</title>
<link>http://www.cnblogs.com/levenyes/p/7623577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/levenyes/p/7623577.html</guid>
<description>&lt;p&gt;&lt;span&gt;一个月前的一次面试，对方问我一年看几本书。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我一年看的书大概在50到70本之间，不过绝大部分都跟计算机技术无关。很不好意思地回答说：“跟技术有关的，很少。”&lt;/span&gt;&lt;span&gt;之所以不怎么看这方面的专业书，有两个主要的原因：一是因为负责的工作业务性强，不需要频繁更新技术栈；二是因为之前看过几本，都不是很感兴趣。&lt;/span&gt;&lt;span&gt;这一个月来，因为要跳槽的原因，我接触了大概三四十本左右的技术书。其中，买回来十几本，仔细读了其中七本书。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之所以能看得进去，首先是得益于这几年来把大量业余时间放在看书和写文章上面，阅读的耐性和理解的能力都有所增强。书作为一种信息的容器，虽然讲心理学的书、讲社会学的书跟讲编程的书、讲计算机技术的书很不一样，但都有着不少的共同点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写这篇博客，希望能跟大家分享一些阅读过程中的思考和感想。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1、烂书很多&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;很多程序员买了书不看，不是因为懒，而是因为有些书太烂。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好书有各种各样的好，而烂书的特征却几乎都是相同的。我这次在亚马逊退了将近十本书，它们的缺点基本上都是一模一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;阅读体验差&lt;/strong&gt;。&lt;/span&gt;不知道是不是因为想省钱，书的质地跟盗版书有的一拼。书页泛黄，字体难看，排版糟糕；作者的表达能力低下，连简洁和准确地讲述一个核心概念都做不到，让人很难有继续看下去的心情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;逻辑性弱。&lt;/strong&gt;&lt;/span&gt;一本好的书，应该做到章节与章节之间有连贯性，使得阅读坡度平缓，信息密度才会高。但是很多烂书是东讲一点，西谈一些，整本书看下来不知所云。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;思想层次低。&lt;/strong&gt;&lt;/span&gt;讲解各种著名开源框架、开源组件的书非常多，但是其中很多书都只是在讲怎么用，简直就像精简版的说明文档翻译。其实，把“为什么要用”和“这样用有什么好处”这两个问题讲清楚，更有价值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2、好书不少&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在所有书当中，好书所占的相对比例肯定不高。但是在绝对数量上，值得我们买回来看、花时间学习的好书却不少。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何判断一本书是不是好书呢？基本上只要花最多半个小时翻一遍，就能确定答案，准确率随着你阅读数量的增加而升高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;阅读体验好。&lt;/strong&gt;&lt;/span&gt;基本上看完前言和第一章就能知道好不好，就像我们用一个手机上的软件，只需要很短的时间就知道用户体验是不是及格。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;逻辑性强。&lt;/strong&gt;&lt;/span&gt;看完整本书，如果章节与章节之间联系紧密，读完前一个章节有助于读后一个章节，基本上可以判断这是一本有条理的书。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;思想层次高。&lt;/strong&gt;&lt;/span&gt;我们看的很多书都是讲某一项或某一类具体的技术，但是如果它们在讲解技术细节之余还能拔高到更高的层次，提取技术之间的共性，谈论技术的思想，则有助于我们更深入理解这些技术，而且在学习其他的新技术时也更为容易。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;3、看书的基本方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在这一个月看技术书的时间里，我经常会跟之前看非专业书时的阅读经历做对比。下面谈谈我自己认为在阅读技术书籍时可以借鉴的几个基本方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;一、浏览。&lt;/strong&gt;&lt;/span&gt;现在我们都基本是在网上买书，所以可以先看看别人的评论和网站给出的目录、书摘。在一轮筛选完之后，把买回来的书都快速看一遍。看第一遍的时候要快，不要看得太仔细。如果是烂书，立刻扔在一边或者申请退货。如果是好书，你就能有一个大概的印象，有助于进行下一个环节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;二、细读。&lt;/strong&gt;&lt;/span&gt;在把书浏览过一遍之后，我们可以开始认真地读，阅读速度也要相应地降下来。在阅读的过程中，我会习惯于把认为重要的句子和内容划线，也会把暂时看不明白的部分做上记号。这不仅可以强迫自己保证阅读的投入程度，还对进一步的学习有帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;三、研究。&lt;/strong&gt;&lt;/span&gt;能经过筛选进入到这个环节的书已经相对不多了，基本上能确定这是一本对你来说非常重要非常有用的书。我读书一般最多读三遍，在读第三遍的时候花时间是最多的，而且远比前两遍要多得多。这个时候要做笔记，把你认为重要的内容都摘抄下来，或者裁切下来。虽然现在笔记类应用很多，例如印象笔记、One Note和Bear等，但是我还是比较推荐大家考虑使用纸质笔记本来做读书笔记，记忆效果特别显著。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;结束语&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;程序员很多都有看技术博客的习惯，而且也有很多优秀的博客达人为我们提供优质的内容。但是，书籍作为另一种信息容器，跟博客这种形式的信息容器是有本质区别的，而且能发挥的作用也不一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面推荐几本我认为值得读的好书：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;《未来简史》 尤瓦尔·赫拉利&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;《暗时间》 刘未鹏&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;《深入理解Java虚拟机》 周志明&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;《架构探险-从零开始写Java Web框架》 黄勇&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;《架构探险-轻量级微服务架构》（上下册） 黄勇&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;《MyBatis从入门到精通》 刘增辉&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前两本不是专业书，但是我还是推荐程序员们都看一看，非常值得一读。剩下的都跟Java有关，因为我本身是Java开发方向的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;书单纯属抛砖引玉，希望你们可以在评论区说一说自己认为好的技术书有哪些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你喜欢我的文章，可以扫描关注我的个人公众号“李文业的思考笔记”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不定期地会推送我的原创思考文章。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/470341/201707/470341-20170704180534003-535825211.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Oct 2017 04:52:00 +0000</pubDate>
<dc:creator>LevenYes</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/levenyes/p/7623577.html</dc:identifier>
</item>
<item>
<title>你真的会阅读Java的异常信息吗？ - 工程师-搁浅</title>
<link>http://www.cnblogs.com/aishangJava/p/7623521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aishangJava/p/7623521.html</guid>
<description>&lt;p&gt;给出如下异常信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
java.lang.RuntimeException: level 2 exception
        at com.msh.demo.exceptionStack.Test.fun2(Test.java:17)
        at com.msh.demo.exceptionStack.Test.main(Test.java:24)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:498)
        at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147)
Caused by: java.io.IOException: level 1 exception
        at com.msh.demo.exceptionStack.Test.fun1(Test.java:10)
        at com.msh.demo.exceptionStack.Test.fun2(Test.java:15)
        ... 6 more
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;学这么多年Java，你真的会阅读Java的异常信息吗？你能说清楚异常抛出过程中的事件顺序吗？&lt;/p&gt;

&lt;h2 id=&quot;写一个demo测试&quot;&gt;写一个demo测试&lt;/h2&gt;
&lt;p&gt;上述异常信息在由一个demo产生：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.msh.demo.exceptionStack;
import java.io.IOException;
/**
 * Created by monkeysayhi on 2017/10/1.
 */
public class Test {
  private void fun1() throws IOException {
    throw new IOException(&quot;level 1 exception&quot;);
  }
  private void fun2() {
    try {
      fun1();
    } catch (IOException e) {
        throw new RuntimeException(&quot;level 2 exception&quot;, e);
    }
  }
  public static void main(String[] args) {
    try {
      new Test().fun2();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这次我复制了完整的文件内容，使文章中的代码行号和实际行号一一对应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据上述异常信息，异常抛出过程中的事件顺序是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在Test.java的第10行，抛出了一个IOExceotion(“level 1 exception”) e1&lt;/li&gt;
&lt;li&gt;异常e1被逐层向外抛出，直到在Test.java的第15行被捕获&lt;/li&gt;
&lt;li&gt;在Test.java的第17行，根据捕获的异常e1，抛出了一个RuntimeException(“level 2 exception”， e1) e2&lt;/li&gt;
&lt;li&gt;异常e2被逐层向外抛出，直到在Test.java的第24行被捕获&lt;/li&gt;
&lt;li&gt;后续没有其他异常信息，经过必要的框架后，由程序自动或用户主动调用了e2.printStackTrace()方法&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;如何阅读异常信息&quot;&gt;如何阅读异常信息&lt;/h2&gt;
&lt;p&gt;那么，如何阅读异常信息呢？有几点你需要认识清楚：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;异常栈以FILO的顺序打印，位于打印内容最下方的异常最早被抛出，逐渐导致上方异常被抛出。位于打印内容最上方的异常最晚被抛出，且没有再被捕获。从上到下数，第&lt;code&gt;i+1&lt;/code&gt;个异常是第&lt;code&gt;i&lt;/code&gt;个异常被抛出的原因&lt;code&gt;cause&lt;/code&gt;，以“Caused by”开头。&lt;/li&gt;
&lt;li&gt;异常栈中每个异常都由异常名+细节信息+路径组成。异常名从行首开始（或紧随”Caused by”），紧接着是细节信息（为增强可读性，需要提供恰当的细节信息），从下一行开始，跳过一个制表符，就是路径中的一个位置，一行一个位置。&lt;/li&gt;
&lt;li&gt;路径以FIFO的顺序打印，位于打印内容最上方的位置最早被该异常经过，逐层向外抛出。最早经过的位置即是异常被抛出的位置，逆向debug时可从此处开始；后续位置一般是方法调用的入口，JVM捕获异常时可以从方法栈中得到。对于cause，其可打印的路径截止到被包装进下一个异常之前，之后打印“… 6 more”，表示cause作为被包装异常，在这之后还逐层向外经过了6个位置，但这些位置与包装异常的路径重复，所以在此处省略，而在包装异常的路径中打印。“… 6 more”的信息不重要，可以忽略。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在，回过头再去阅读示例的异常信息，是不是相当简单？&lt;/p&gt;
&lt;p&gt;为了帮助理解，我尽可能通俗易懂的描述了异常信息的结构和组成元素，可能会引入一些纰漏。阅读异常信息是Java程序猿的基本技能，希望你能内化它，忘掉这些冗长的描述。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果还不理解，建议你亲自追踪一次异常的创建和打印过程，使用示例代码即可，它很简单但足够。难点在于异常是JVM提供的机制，你需要了解JVM的实现；且底层调用了很多native方法，而追踪native代码没有那么方便。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;为什么有时我在日志中只看到异常名”java-lang-NullPointerException”，却没有异常栈&quot;&gt;为什么有时我在日志中只看到异常名”java.lang.NullPointerException”，却没有异常栈&lt;/h2&gt;
&lt;p&gt;示例的异常信息中，异常名、细节信息、路径三个元素都有，但是，由于JVM的优化，细节信息和路径可能会被省略。&lt;/p&gt;
&lt;p&gt;这经常发生于服务器应用的日志中，由于相同异常已被打印多次，如果继续打印相同异常，JVM会省略掉细节信息和路径队列，向前翻阅即可找到完整的异常信息。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;猴哥之前使用Yarn的Timeline Server时遇到过该问题。你能体会那种感觉吗？卧槽，为什么只有异常名没有异常栈？没有异常栈怎么老子怎么知道哪里抛出的异常？线上服务老子又不能停，全靠日志了啊喂！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网上有不少相同的case，比如&lt;a href=&quot;http://blog.csdn.net/taotao4/article/details/43918131&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;NullPointerException丢失异常堆栈信息&lt;/a&gt;，读者可以参照这个链接实验一下。&lt;/p&gt;
&lt;h2 id=&quot;如何在异常类中添加成员变量&quot;&gt;如何在异常类中添加成员变量&lt;/h2&gt;
&lt;p&gt;为了恰当的表达一个异常，我们有时候需要自定义异常，并添加一些成员变量，打印异常栈时，自动补充打印必要的信息。&lt;/p&gt;
&lt;p&gt;追踪打印异常栈的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
...
    public void printStackTrace() {
        printStackTrace(System.err);
    }
...
    public void printStackTrace(PrintStream s) {
        printStackTrace(new WrappedPrintStream(s));
    }
...
    private void printStackTrace(PrintStreamOrWriter s) {
        // Guard against malicious overrides of Throwable.equals by
        // using a Set with identity equality semantics.
        Set&amp;lt;Throwable&amp;gt; dejaVu =
            Collections.newSetFromMap(new IdentityHashMap&amp;lt;Throwable, Boolean&amp;gt;());
        dejaVu.add(this);
        synchronized (s.lock()) {
            // Print our stack trace
            s.println(this);
            StackTraceElement[] trace = getOurStackTrace();
            for (StackTraceElement traceElement : trace)
                s.println(&quot;\tat &quot; + traceElement);
            // Print suppressed exceptions, if any
            for (Throwable se : getSuppressed())
                se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, &quot;\t&quot;, dejaVu);
            // Print cause, if any
            Throwable ourCause = getCause();
            if (ourCause != null)
                ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, &quot;&quot;, dejaVu);
        }
    }
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;暂不关心同步问题，可知，打印异常名和细节信息的代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
s.println(this);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JVM在运行期通过动态绑定实现this引用上的多态调用。继续追踪的话，最终会调用this实例的toString()方法。所有异常的最低公共祖先类是Throwable类，它提供了默认的toString()实现，大部分常见的异常类都没有覆写这个实现，我们自定义的异常也可以直接继承这个实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
...
    public String toString() {
        String s = getClass().getName();
        String message = getLocalizedMessage();
        return (message != null) ? (s + &quot;: &quot; + message) : s;
    }
...
    public String getLocalizedMessage() {
        return getMessage();
    }
...
    public String getMessage() {
        return detailMessage;
    }
...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然，默认实现的打印格式就是示例的异常信息格式：异常名（全限定名）+细节信息。detailMessage由用户创建异常时设置，因此，如果有自定义的成员变量，我们通常在toString()方法中插入这个变量。参考&lt;code&gt;com.sun.javaws.exceptions&lt;/code&gt;包中的&lt;code&gt;BadFieldException&lt;/code&gt;，看看它如何插入自定义的成员变量field和value：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public String toString() {
  return this.getValue().equals(&quot;https&quot;)?&quot;BadFieldException[ &quot; + this.getRealMessage() + &quot;]&quot;:&quot;BadFieldException[ &quot; + this.getField() + &quot;,&quot; + this.getValue() + &quot;]&quot;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;严格的说，&lt;code&gt;BadFieldException&lt;/code&gt;的toString中并没有直接插入field成员变量。不过这不影响我们理解，感兴趣的读者可自行翻阅源码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;根据异常信息debug是程序员的基本技能，这里围绕异常信息的阅读和打印过程作了初步探索，后续还会整理一下常用的异常类，更好的理解如何用异常帮助我们写出clean code。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Java相当完备的异常处理机制是一把双刃剑，用好它能增强代码的可读性和鲁棒性，用不好则会让代码变的更加不可控。例如，在空指针上调用成员方法，运行期会抛出异常，这是很自然的——但是，是不可控的等待它在某个时刻某个位置抛出异常（实际上还是“确定”的，但对于debug来说是“不确定”的），还是可控的在进入方法伊始就检查并主动抛出异常呢？进一步的，哪些异常应该被即刻处理，哪些应该继续抛到外层呢？抛往外层时，何时需要封装异常呢？看看String#toLowerCase()，看看ProcessBuilder#start()，体会一下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Java学习交流QQ群：589809992  禁止闲聊，非喜勿进！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Oct 2017 03:56:00 +0000</pubDate>
<dc:creator>工程师-搁浅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aishangJava/p/7623521.html</dc:identifier>
</item>
<item>
<title>实例说明MVC,MVP,MVVM架构 - 小东毛哥</title>
<link>http://www.cnblogs.com/maoscut/p/7623462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maoscut/p/7623462.html</guid>
<description>&lt;p&gt;很早就知道有这三个概念，但是一直都不清楚是怎么回事，在网上搜索，都是泛泛而谈，没有具体例子，新手是看不懂的，直到找到&lt;a href=&quot;http://www.cnblogs.com/zhouyangla/p/6936455.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;，我对这三个架构有了更清楚的了解。&lt;/p&gt;
&lt;p&gt;从一个简单的例子去研究这三个架构。&lt;/p&gt;
&lt;p&gt;注意，MVC，MVP，MVVM中的C，P，VM，下文都要controller指代。&lt;/p&gt;
&lt;p&gt;需求如下&lt;/p&gt;
&lt;p&gt;界面上显示100，以及两个按钮，其中一个点一下加1，另外一个点一下减1&lt;/p&gt;
&lt;p&gt;如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1233812/201710/1233812-20171003105420005-1788079506.png&quot; alt=&quot;&quot; width=&quot;665&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;诚然，这么简单的需求，并不需要用什么架构去完成，可是如果是复杂的需求，要长篇大论才能说完，所以只拿简单的来做例子，实际开发中，你在完成一个需求之前，是需要好好掂量是否要用架构，要的话，用什么架构（不局限于这三个），架构里面又要用什么设计模式等等。经过我的实践，发现，即使是架构改变了，view是可以完全不变的，所以先展现view层的代码。&lt;/p&gt;
&lt;p&gt;html部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;100&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;upBtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;up&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;downBtn&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;down&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;js部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; $(id) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; document.querySelector(`#${id}`);
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; View(controller) {
  const upBtn &lt;/span&gt;= $('upBtn'&lt;span&gt;);
  const downBtn &lt;/span&gt;= $('downBtn'&lt;span&gt;);
  const textSpan &lt;/span&gt;= $('text'&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.render = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(model) {
    textSpan.innerHTML &lt;/span&gt;=&lt;span&gt; model.getValue();
  }
  upBtn.onclick &lt;/span&gt;=&lt;span&gt; controller.up;
  downBtn.onclick &lt;/span&gt;=&lt;span&gt; controller.down;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;render方法是核心，方法名称不能改（后面要依赖这个render方法），其中要实现数据的展示逻辑，然后是一些点击事件的绑定&lt;/p&gt;

&lt;p&gt;model层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Model() {
  let value &lt;/span&gt;= 100&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.up = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    value &lt;/span&gt;+= 1&lt;span&gt;;
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.down = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    value &lt;/span&gt;-= 1&lt;span&gt;;
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getValue = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
  };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存数据，并提供访问，修改数据的方法，如果仅仅是这样，那么当model改变时，view是不知道的，所以需要让model去通知view，我数据改变了，你要更新了。怎么做呢？利用观察者模式。在model中，增加一个数组views，去保存这个model对应的视图，在修改数据的时候，遍历views数组，调用每个view的render方法，参数是自己。&lt;/p&gt;
&lt;p&gt;修改后的model&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Model() {
  let value &lt;/span&gt;= 100&lt;span&gt;;
  const self &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  const views &lt;/span&gt;=&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.up = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    value &lt;/span&gt;+= 1&lt;span&gt;;
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.down = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    value &lt;/span&gt;-= 1&lt;span&gt;;
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getValue = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.broadcast = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    views.forEach(view &lt;/span&gt;=&amp;gt;&lt;span&gt; view.render(self));
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subscribe = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(cb) {
    views.push(cb);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仔细看修改后的model，虽然增加了通知的方法（broadcast），但是在修改数据的方法（up和down）中并没有去通知视图。这个工作是由controller承担的，另外把view注册到model中，也是controller做的。&lt;/p&gt;
&lt;p&gt;controller层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Controller() {
  let view &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  let model &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.up = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改数据&lt;/span&gt;
&lt;span&gt;    model.up();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知视图&lt;/span&gt;
&lt;span&gt;    model.broadcast();
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.down = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    model.down();
    model.broadcast();
  }
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.init = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    view &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; View(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    model &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Model();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把视图注册到model中&lt;/span&gt;
&lt;span&gt;    model.subscribe(view);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，controller把自己传给了view去创建视图，同时保存引用，创建model后，把view注册到model中。同时实现了，改变数据，通知视图的工作。&lt;/p&gt;
&lt;p&gt;请一定要好好理解MVC，后面的MVP，MVVM都只是稍加修改而已。&lt;/p&gt;

&lt;p&gt;在MVC中，改变数据，通知视图，都是在controller做的，注册视图，以及通知视图，这两个方法的实现，都是model完成的，既然model负责数据处理，这两个工作实际上和改变数据是没关系的，把他们都转移到controller中，不仅可以让model层专注于数据处理，同时也方便多个视图共用一个controller&lt;/p&gt;
&lt;p&gt;model层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Model() {
  let value &lt;/span&gt;= 100&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.up = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    value &lt;/span&gt;+= 1&lt;span&gt;;
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.down = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    value &lt;/span&gt;-= 1&lt;span&gt;;
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getValue = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
  };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;model层更小了，删除了注册，通知方法，只保存数据和提供获取，修改数据的方法&lt;/p&gt;
&lt;p&gt;controller层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Controller() {
  let views &lt;/span&gt;=&lt;span&gt; [];
  let model &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; broadcast() {
    views.forEach(view &lt;/span&gt;=&amp;gt;&lt;span&gt; view.render(model));
  }
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.up = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    model.up();
    broadcast();
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.down = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    model.down();
    broadcast();
  }
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.init = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    views.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; View(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
    model &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Model();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;controller，增加了广播方法，该方法的实现和调用都在controller中，另外，如果想多个视图共用一个controller，如果这多个视图都是同一个model，上面代码能够胜任，如果是这多个视图是不同的model，那就要自己去实现好view和model的对应关系了（要用map来存储对应关系，一个数组做不到）。&lt;/p&gt;

&lt;p&gt;可以看到，在MVP中，model也有一个up方法，controller也有一个up方法，只是增加了一个广播方法的调用。是不是有些重复呢？把这两个类似的方法整合到controller，model只负责保存数据，不实现修改数据的逻辑，这就是MVVM了，极大地精简model&lt;/p&gt;
&lt;p&gt;model层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Model() {
  let value &lt;/span&gt;= 100&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getValue = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setValue = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(v) {
    value &lt;/span&gt;=&lt;span&gt; v;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实，不用函数，单纯地用一个变量，也是可以的，但是为了view层不变，view层中依赖model的getValue方法，所以这里还是用函数去实现model&lt;/p&gt;
&lt;p&gt;controller层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Controller() {
  let views &lt;/span&gt;=&lt;span&gt; [];
  let model &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; broadcast() {
    views.forEach(view &lt;/span&gt;=&amp;gt;&lt;span&gt; view.render(model));
  }
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.up = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    model.setValue(model.getValue() &lt;/span&gt;+ 1&lt;span&gt;);
    broadcast();
  };
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.down = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    model.setValue(model.getValue() &lt;/span&gt;- 1&lt;span&gt;);
    broadcast();
  }
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.init = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    views.push(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; View(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
    model &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Model();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;精简model的代价是controller要做更多的事情，实现修改数据的逻辑，通知视图。如果用框架，react或者vue，通知视图这部分框架会帮你实现，只要实现数据修改的逻辑就好了。&lt;/p&gt;
&lt;p&gt;至此，三个架构都讲完了，如果错误，欢迎讨论。&lt;/p&gt;
&lt;p&gt;代码可在&lt;a href=&quot;https://github.com/MaoScut/up-and-down&quot; target=&quot;_blank&quot;&gt;github&lt;/a&gt;上下载，需要node环境。&lt;/p&gt;
&lt;p&gt;参考资料：http://www.cnblogs.com/zhouyangla/p/6936455.html&lt;/p&gt;
</description>
<pubDate>Tue, 03 Oct 2017 03:46:00 +0000</pubDate>
<dc:creator>小东毛哥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maoscut/p/7623462.html</dc:identifier>
</item>
<item>
<title>数据分析之：ipython 使用技巧，命令行多好啊！ - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/7623347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/7623347.html</guid>
<description>&lt;h3&gt;&lt;span&gt;不一定非得使用Jupyter Notebook，试试ipython命令行&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;我只试过Windows 10环境下的。&lt;/p&gt;
&lt;p&gt;1.安装python安装包之后，应该就有ipython了。&lt;/p&gt;
&lt;p&gt;2.安装anaconda，这个做机器学习或数据分析要是需要的，这个装完之后，也会有ipython。（建议使用anaconda，国内镜像地址：&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/&quot; target=&quot;_blank&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;1.命令行输入ipython即可启动。&lt;/p&gt;
&lt;p&gt;2.或者找一下快捷方式，也可以启动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003100210052-1571477337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.help，python内置了help方法，相信大家都会这个。例如：help(len)，然后就会显示len方法的帮助文档：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003100416240-1593010456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.？，ipython独有的提供了一个快捷字符?，它也可以访问帮助文档，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003100651693-1720716083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用?? 来查看python的源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003100945161-766152347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，如果源码不适用python写的（有些内置的方法使用C等语言写的），就会出现如下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003101041255-934204167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Tab键在ipython中输入时可提供自动完成或浏览功能。&lt;/p&gt;
&lt;p&gt;有时候优点像python内置的dir()函数，但强大得多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003101414490-1862942185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是L.后边点击Tab的效果。下面是再输入一个字母c之后的智能提示的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003101527896-1049069423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;提示私有属性&lt;/h3&gt;
&lt;p&gt;使用Tab默认只显示public和external属性/方法，如果想显示私有属性，那么按约定，你要&lt;span&gt;先输入一个下划线_&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003101735490-1570222262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;import的时候也可以使用Tab&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003101840708-1889537741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有时候tab不够用，那就使用通配符 * 。&lt;/p&gt;
&lt;p&gt;例如：显示以Error结尾的对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003102327974-836873668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意后边还有个?。&lt;/p&gt;
&lt;p&gt;*可以匹配任何字符串包括空字符串。&lt;/p&gt;
&lt;p&gt;另一个例子，包含xxx字符串：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003102548943-2109721211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;导航类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ctrl+a，移动光标到行首&lt;/p&gt;
&lt;p&gt;Ctrl+e，移动光标到行尾&lt;/p&gt;
&lt;p&gt;Ctrl+b（或←），向左移动一个字符&lt;/p&gt;
&lt;p&gt;Ctrl+f（或→），向右移动一个字符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Backspace：删除行中前一个字符&lt;/p&gt;
&lt;p&gt;Ctrl+d，删除行中下一个字符&lt;/p&gt;
&lt;p&gt;Ctrl+k，从光标位置剪切到行尾。&lt;/p&gt;
&lt;p&gt;Ctrl+u，从行首剪切到光标位置。&lt;/p&gt;
&lt;p&gt;Ctrl+y，粘贴之前剪切的文字。&lt;/p&gt;
&lt;p&gt;Ctrl+t，调换前两个字符的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令历史类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ctrl+p，前一个命令，和↑好像一样。&lt;/p&gt;
&lt;p&gt;Ctrl+n，后一个命令，和↓好像一样。&lt;/p&gt;
&lt;p&gt;Ctrl+r，倒序搜索。&lt;/p&gt;
&lt;p&gt;其中Ctrl+r是挺有用的，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003103653693-710099469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按Ctrl+r后，输入a，就会倒序搜索之前的输入。&lt;/p&gt;
&lt;p&gt;如果有相同的历史搜索结果的话，你可以点击多次Ctrl+r继续往前翻。&lt;/p&gt;
&lt;p&gt;其它快捷键：&lt;/p&gt;
&lt;p&gt;Ctrl+l，清屏&lt;/p&gt;
&lt;p&gt;Ctrl+c，中断当前python命令&lt;/p&gt;
&lt;p&gt;Ctrl+d，退出ipython&lt;/p&gt;



&lt;p&gt;在ipython命令行中使用Ctrl+c复制多行代码经常会出现问题（缩进等问题），使用%paste命令，解决了这个问题。&lt;/p&gt;
&lt;p&gt;输入%paste，然后回车，就会把你剪切盘里面的内容完美的复制进来&lt;span&gt;并执行&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003104524411-28632308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;%cpaste&lt;/strong&gt;，和%paste类似，但是它会提供一个交互界面，以便输入多个代码块。&lt;/p&gt;

&lt;p&gt;直接举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003105313255-1932546880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003105323458-1731119301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对单行代码的执行计时：%timeit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003105719068-1648669016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对多行代码执行计时：%%timeit：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003105743974-597464935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用%maigc，可以查看所有魔法命令及其文档。&lt;/p&gt;
&lt;p&gt;使用%lsmagic，可以列出所有的魔法命令。&lt;/p&gt;

&lt;p&gt;使用ipython shell，您一定对左边这些&lt;strong&gt;&lt;span&gt;in，out&lt;/span&gt;&lt;/strong&gt;特别熟悉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003110436880-6750278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，它们不是装饰品，它们俩是&lt;span&gt;变量&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003110744927-870753823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In和Out是两个变量，并且随着命令的输入，实时更新。&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;p&gt;In是一个list，而Out是一个Dictionary。&lt;/p&gt;
&lt;p&gt;所以可以这样查看具体的In和Out：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003111338943-1814369595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中需要注意的是，并不是所有的In都有输出，例如[37]。&lt;/p&gt;

&lt;p&gt;使用一个下划线 &lt;span&gt;&lt;strong&gt;_&lt;/strong&gt;&lt;/span&gt; 来获取前一个输出结果，它是个变量，实时更新的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003111725052-59234554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用两个下划线 &lt;span&gt;__&lt;/span&gt; 可以获取倒数第二个输出，使用三个下划线 &lt;span&gt;___&lt;/span&gt; 获取倒数第三个输出。（没有输出的命令行不计入在内）&lt;/p&gt;
&lt;p&gt;最多也只能使用三个下划线，超过三的话可以使用&lt;span&gt;&lt;strong&gt;Out[X]&lt;/strong&gt;&lt;/span&gt;或者&lt;span&gt;&lt;strong&gt;_X&lt;/strong&gt;&lt;/span&gt;来获取之前的输出：其中X是命令行号，不是往前数的个数。&lt;/p&gt;

&lt;p&gt;有时候在输入命令后，我们不想让其输出结果，那就这样，在行的最后边加一个 &lt;span&gt;&lt;strong&gt;;&lt;/strong&gt;&lt;/span&gt; 分号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003112341521-284388258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的话，第76行也就没有输出了，Out[76]就不存在了。&lt;/p&gt;
&lt;p&gt;相关的魔法命令：&lt;span&gt;&lt;strong&gt;%history&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用%history可以一起获取前面多个命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003112729802-1339847776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意其参数-n后边跟的是 命令行号的区间。&lt;/p&gt;

&lt;p&gt;你可以在ipython中使用任何shell commands（暂时叫系统命令行的命令吧），只要在前边加一个叹号 &lt;span&gt;&lt;strong&gt;!&lt;/strong&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;（其实，对于常见的shell命令，直接输入就会好用。。因为automagic属性默认是on的，详见后边）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003123832130-192999272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;直接写个赋值表达式就可以，等号的右边是Shell命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003124019896-986071988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：传进来的值的类型不是list，而是：IPython.utils.text.SList。&lt;/p&gt;

&lt;p&gt;使用{变量名}的形式赋值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003124342849-705532604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：不可以使用 !cd 这个文件系统导航命令。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果想要在ipython中进行系统导航，那么应该使用%cd这个魔法命令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003124606490-459471420.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;如果把automagic属性设置为on，那么魔法命令前边就不需要%这个符号了。&lt;/p&gt;
&lt;p&gt;默认automagic是on的，你可以输入automagic，那么它就会在on/off之间切换。&lt;/p&gt;
&lt;p&gt;因为魔法命令包含了很多常见的shell命令，例如%cd，%pwd，%ls等等等等。所以默认情况下直接输入常见的shell命令就会好用。&lt;/p&gt;

&lt;p&gt;如果解释器击中异常的时候，可以在traceback中查看异常信息。&lt;/p&gt;
&lt;p&gt;使用&lt;span&gt;&lt;strong&gt;%xmode&lt;/strong&gt;&lt;/span&gt;可以控制异常信息的详细程度：&lt;/p&gt;
&lt;p&gt;%xmode 只有一个参数，后选项从简到繁是 Plain，Context，Verbose。我的电脑默认是Verbose。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003125810302-50207552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;%xdebug&lt;/span&gt;&lt;/strong&gt; 魔法命令。&lt;/p&gt;
&lt;p&gt;在发生异常后，输入%xdebug，会进入debug模式ipdb。在这里输入变量可以查看变量的值，也可以执行python命令!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003130203833-2056716312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你想在发生任何异常的时候就进入debug模式，那么可以把&lt;strong&gt;&lt;span&gt;pdb&lt;/span&gt;&lt;/strong&gt;设置为on：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003130427208-251590966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外，如果你想在运行外部脚本的时候直接进入debug模式，那么就应该输入这个命令：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;%run -d&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;部分Debug命令（ipdb模式下）：&lt;/p&gt;
&lt;p&gt;l(ist)，显示在文件中的当前位置。&lt;/p&gt;
&lt;p&gt;h(elp)，帮助&lt;/p&gt;
&lt;p&gt;q(uit)，退出Debugger和程序。&lt;/p&gt;
&lt;p&gt;c(ontinue)，退出Debugger，继续执行程序。&lt;/p&gt;
&lt;p&gt;n(ext)，执行程序的下一步&lt;/p&gt;
&lt;p&gt;&amp;lt;enter&amp;gt;，重复上一个命令&lt;/p&gt;
&lt;p&gt;p(rint)，打印变量&lt;/p&gt;
&lt;p&gt;s(tep)，进入子程序&lt;/p&gt;
&lt;p&gt;r(eturn)，从子程序跳出&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;%time&lt;/span&gt;&lt;/strong&gt;，适用于对单个长时间运行的表达式的程序计时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;%timeit&lt;/span&gt;&lt;/strong&gt;，适用于对循环类的单行程序计时，它更准确。&lt;/p&gt;
&lt;p&gt;注意：%timeit的结果通常比%time更快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;%prun&lt;/span&gt;&lt;/strong&gt;，使用分析器运行代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/986268/201710/986268-20171003131738115-2080724819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此外，还可以安装第三方分析工具，例如%lprun（逐行分析），%memit（单个表达式内存分析），%mprun（逐行内存分析）等等。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;下一篇文章，写一下Numpy的使用技巧&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Oct 2017 03:35:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/7623347.html</dc:identifier>
</item>
<item>
<title>ArrayList , Vector 数组集合 - romanjoy</title>
<link>http://www.cnblogs.com/romanjoy/p/7265691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/romanjoy/p/7265691.html</guid>
<description>&lt;p&gt;ArrayList 的一些认识：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;非线程安全的动态数组（Array升级版），支持动态扩容&lt;/li&gt;
&lt;li&gt;实现 List 接口、底层使用数组保存所有元素，其操作基本上是对数组的操作，允许null值&lt;/li&gt;
&lt;li&gt;实现了 RandmoAccess 接口，提供了随机访问功能&lt;/li&gt;
&lt;li&gt;线程安全可见Vector，实时同步&lt;/li&gt;
&lt;li&gt;适用于访问频繁场景，频繁插入或删除场景请选用linkedList&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;■ 类定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArrayList&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractList&amp;lt;E&amp;gt;
        &lt;span&gt;implements&lt;/span&gt; List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;继承 AbstractList，实现了 List，它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能&lt;/li&gt;
&lt;li&gt;实现 RandmoAccess 接口，实现快速随机访问：通过元素的序号快速获取元素对象&lt;/li&gt;
&lt;li&gt;实现 Cloneable 接口，重写 clone()，能被克隆（浅拷贝）&lt;/li&gt;
&lt;li&gt;实现 java.io.Serializable 接口，支持序列化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;■ 全局变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * The array buffer into which the elements of the ArrayList are stored.
  * The capacity of the ArrayList is the length of this array buffer. Any
  * empty ArrayList with elementData == EMPTY_ELEMENTDATA will be expanded to
  * DEFAULT_CAPACITY when the first element is added.
  * ArrayList底层实现为动态数组； 对象在存储时不需要维持，java的serialzation提供了持久化&lt;br/&gt;* 机制，我们不想此对象被序列化，所以使用 transient
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt;&lt;span&gt; Object[] elementData;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * The size of the ArrayList (the number of elements it contains).
  * 数组长度 ：注意区分长度（当前数组已有的元素数量）和容量（当前数组可以拥有的元素数量）的概念
  * &lt;/span&gt;&lt;span&gt;@serial&lt;/span&gt;
  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * The maximum size of array to allocate.Some VMs reserve some header words in an array.
  * Attempts to allocate larger arrays may result in OutOfMemoryError: 
  * Requested array size exceeds VM limit
  * 数组所能允许的最大长度；如果超出就会报`内存溢出异常` -- 可怕后果就是宕机
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;■ 构造器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * Constructs an empty list with the specified initial capacity.
  * 创建一个指定容量的空列表
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt;  initialCapacity  the initial capacity of the list
  * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException if the specified initial capacity is negative
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; ArrayList(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity) {
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; 0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal Capacity: &quot;+&lt;span&gt; initialCapacity);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elementData = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[initialCapacity];
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * Constructs an empty list with an initial capacity of ten.
  * 默认容量为10
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ArrayList() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(10&lt;span&gt;);
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * Constructs a list containing the elements of the specified collection,
  * in the order they are returned by the collection's iterator.
  * 接受一个Collection对象直接转换为ArrayList
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; c the collection whose elements are to be placed into this list
  * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException if the specified collection is null 万恶的空指针异常
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; ArrayList(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
    elementData &lt;/span&gt;= c.toArray();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取底层动态数组&lt;/span&gt;
    size = elementData.length;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取底层动态数组的长度
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; c.toArray might (incorrectly) not return Object[] (see 6260652)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (elementData.getClass() != Object[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
        elementData &lt;/span&gt;= Arrays.copyOf(elementData, size, Object[].&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;■主要方法&lt;/p&gt;
&lt;p&gt;　- add()&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从源码上看，ArrayList 一般在尾部插入元素，支持动态扩容&lt;/li&gt;
&lt;li&gt;不推荐使用频繁插入/删除是因为在执行add()/remove() 会调用非常耗时的 System.arraycopy()，频繁插入/删除场景请选用 LinkedList&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * Appends the specified element to the end of this list.
  * 使用尾插入法，新增元素插入到数组末尾
  *  由于错误检测机制使用的是抛异常，所以直接返回true
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; e element to be appended to this list
  * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; (as specified by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Collection#add})
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调整容量，修改elementData数组的指向; 当数组长度加1超过原容量时，会自动扩容&lt;/span&gt;
    ensureCapacityInternal(size + 1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increments modCount!! add属于结构性修改&lt;/span&gt;
    elementData[size++] = e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾部插入，长度+1&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * Inserts the specified element at the specified position in this list. 
  * Shifts the element currently at that position (if any) and any subsequent elements to
  * the right (adds one to their indices).
  * 支持插入一个新元素到指定下标
  * 该操作会造成该下标之后的元素全部后移（使用时请慎重，避免数组长度过大）
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index index at which the specified element is to be inserted
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; element element to be inserted
  * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下标边界校验，不符合规则 抛出 `IndexOutOfBoundsException` &lt;/span&gt;
&lt;span&gt;    rangeCheckForAdd(index);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调整容量，修改elementData数组的指向; 当数组长度加1超过原容量时，会自动扩容&lt;/span&gt;
    ensureCapacityInternal(size + 1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Increments modCount!!
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意是在原数组上进行位移操作，下标为 index+1 的元素统一往后移动一位&lt;/span&gt;
    System.arraycopy(elementData, index, elementData, index + 1,size -&lt;span&gt; index);
    elementData[index] &lt;/span&gt;= element;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前下标赋值&lt;/span&gt;
    size++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组长度+1&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- ensureCapacity() : 扩容，1.8 有个默认值的判断&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.8 有个默认值的判断&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ensureCapacity(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; minExpand = (elementData !=&lt;span&gt; DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; any size if not default element table&lt;/span&gt;
            ? 0
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; larger than default for default empty table. It's already
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; supposed to be at default size.&lt;/span&gt;
&lt;span&gt;            : DEFAULT_CAPACITY;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (minCapacity &amp;gt;&lt;span&gt; minExpand) {
            ensureExplicitCapacity(minCapacity);
        }
}


&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ensureExplicitCapacity(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; minCapacity) {
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow-conscious code&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (minCapacity - elementData.length &amp;gt; 0&lt;span&gt;)
            grow(minCapacity);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　- set() / get()： 直接操作下标指针&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Replaces the element at the specified position in this list with
     * the specified element.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index index of the element to replace
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; element element to be stored at the specified position
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the element previously at the specified position
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E set(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
        rangeCheck(index);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测插入的位置是否越界&lt;/span&gt;
&lt;span&gt;
        E oldValue &lt;/span&gt;=&lt;span&gt; elementData(index);
        elementData[index] &lt;/span&gt;=&lt;span&gt; element;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
    }&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * Returns the element at the specified position in this list.&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * &lt;/span&gt;&lt;br/&gt;&lt;span&gt; * @param  index index of the element to return&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * @return the element at the specified position in this list&lt;/span&gt;&lt;br/&gt;&lt;span&gt; * @throws IndexOutOfBoundsException {@inheritDoc}&lt;/span&gt;&lt;br/&gt;&lt;span&gt; */&lt;/span&gt;&lt;br/&gt;public E get(int index) {&lt;br/&gt;rangeCheck(index);&lt;p&gt;return elementData(index);&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　- remove()： 移除其实和add差不多，也是用的是 System.arrayCopy(...)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * Removes the element at the specified position in this list.
  * Shifts any subsequent elements to the left (subtracts one from their indices).
  * 
  * 移除指定下标元素，同时大于该下标的所有数组元素统一左移一位
  * 
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index the index of the element to be removed
  * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the element that was removed from the list 返回原数组元素
  * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; E remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
    rangeCheck(index);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下标边界校验&lt;/span&gt;
    E oldValue = elementData(index);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前坐标元素&lt;/span&gt;
    fastRemove(&lt;span&gt;int&lt;/span&gt; index);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里我修改了一下源码，改成直接用fastRemove方法，逻辑不变&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; oldValue;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回原数组元素&lt;/span&gt;
&lt;span&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * Removes the first occurrence of the specified element from this list,if it is present.
  * If the list does not contain the element, it is unchanged.
  * More formally, removes the element with the lowest index &amp;lt;tt&amp;gt;i&amp;lt;/tt&amp;gt; such that
  * &amp;lt;tt&amp;gt;(o==null?get(i)==null:o.equals(get(i)))&amp;lt;/tt&amp;gt; (if such an element exists).
  * Returns &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; if this list contained the specified element
  * (or equivalently, if this list changed as a result of the call).
  * 直接移除某个元素：
  *     当该元素不存在，不会发生任何变化
  *     当该元素存在且成功移除时，返回true，否则false
  *     当有重复元素时，只删除第一次出现的同名元素 ：
  *        例如只移除第一次出现的null（即下标最小时出现的null）
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; o element to be removed from this list, if present
  * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; &amp;lt;tt&amp;gt;true&amp;lt;/tt&amp;gt; if this list contained the specified element
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object o) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按元素移除时都需要按顺序遍历找到该值，当数组长度过长时，相当耗时&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ArrayList允许null，需要额外进行null的处理（只处理第一次出现的null）&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = 0; index &amp;lt; size; index++&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (elementData[index] == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                fastRemove(index);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = 0; index &amp;lt; size; index++&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(elementData[index])) {
                fastRemove(index);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　- 封装 fastRemove()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * Private remove method that skips bounds checking and does not return the value removed.
     * 私有方法，除去下标边界校验以及不返回移除操作的结果
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fastRemove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        modCount&lt;/span&gt;++;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;remove操作属于结构性改动，modCount计数+1&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; numMoved = size - index - 1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要左移的长度&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (numMoved &amp;gt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;大于该下标的所有数组元素统一左移一位&lt;/span&gt;
            System.arraycopy(elementData, index+1&lt;span&gt;, elementData, index,numMoved);
        elementData[&lt;/span&gt;--size] = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Let gc do its work 长度-1，同时加快gc&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;■ 遍历、排序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by meizi on 2017/7/31.
 * List&amp;lt;数据类型&amp;gt; 排序、遍历
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ListSortTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; nums = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;();
        nums.add(&lt;/span&gt;3&lt;span&gt;);
        nums.add(&lt;/span&gt;5&lt;span&gt;);
        nums.add(&lt;/span&gt;1&lt;span&gt;);
        nums.add(&lt;/span&gt;0&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历及删除的操作&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Iterator&amp;lt;Integer&amp;gt; iterator = nums.iterator();
        while (iterator.hasNext()) {
            Integer num = iterator.next();
            if(num.equals(5)) {
                System.out.println(&quot;被删除元素：&quot; + num);
                iterator.remove();  //可删除
            }
        }
        System.out.println(nums);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具类(Collections) 进行排序&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Collections.sort(nums);   //底层为数组对象的排序，再通过ListIterator进行遍历比较，取替
        System.out.println(nums);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;②自定义排序方式&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;nums.sort(new Comparator&amp;lt;Integer&amp;gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                if(o1 &amp;gt; o2) {
                    return 1;
                } else if (o1 &amp;lt; o2) {
                    return -1;
                } else {
                    return 0;
                }
            }
        });
        System.out.println(nums);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历 since 1.8&lt;/span&gt;
        Iterator&amp;lt;Integer&amp;gt; iterator =&lt;span&gt; nums.iterator();
        iterator.forEachRemaining(obj &lt;/span&gt;-&amp;gt; System.out.print(obj));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用lambda 表达式&lt;/span&gt;

        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * Objects 展示对象各种方法，equals, toString, hash, toString
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;default void forEachRemaining(Consumer&amp;lt;? super E&amp;gt; action) {
            Objects.requireNonNull(action);
            while (hasNext())
                action.accept(next());
        }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;■ list 与 Array 的转换问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Object[] toArray(); 可能会产生 ClassCastException&lt;/li&gt;
&lt;li&gt;&amp;lt;T&amp;gt; T[] toArray(T[] contents) -- 调用 toArray(T[] contents) 能正常返回 T[]&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ListAndArray {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        list.add(&lt;/span&gt;&quot;java&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;C++&quot;&lt;span&gt;);
        String[] strings &lt;/span&gt;= list.toArray(&lt;span&gt;new&lt;/span&gt; String[list.size()]);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用泛型可避免类型转换的异常，因为java不支持向下转换&lt;/span&gt;
        System.out.println(strings[0&lt;span&gt;]);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;■ 关于Vector 就不详细介绍了，因为官方也并不推荐使用： (JDK 1.0)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;矢量队列，作用等效于ArrayList，线程安全&lt;/li&gt;
&lt;li&gt;官方不推荐使用该类，非线程安全推荐 ArrayList，线程安全推荐 CopyOnWriteList&lt;/li&gt;
&lt;li&gt;区别于arraylist, 所有方法都是 synchronized 修饰的，所以是线程安全&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Tue, 03 Oct 2017 03:33:00 +0000</pubDate>
<dc:creator>romanjoy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/romanjoy/p/7265691.html</dc:identifier>
</item>
<item>
<title>分布式系统中生成全局ID的总结与思考 - xybaby</title>
<link>http://www.cnblogs.com/xybaby/p/7616272.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xybaby/p/7616272.html</guid>
<description>
&lt;p&gt;　　世间万物，都有自己唯一的标识，比如人，每个人都有自己的指纹（白夜追凶给我科普的，同卵双胞胎DNA一样，但指纹不一样）。又如中国人，每个中国人有自己的身份证。对于计算机，很多时候，也需要为每一份数据生成唯一的标识。在这里，数据的概念是非常宽泛的，比如数据量记录、文件、消息，而唯一的标识我们称之为id。&lt;/p&gt;
&lt;p&gt;　　本文地址：&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/7616272.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/xybaby/p/7616272.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　使用过mysql的同学应该都知道，经常用自增id（auto increment）作为主键，这是一个为long的整数类型，每插入一条记录，该值就会增加1，这样每条记录都有了唯一的id。自增id应该是使用最广泛的id生成方式，其优点在于非常简单、对数据库索引友好、而且也能透露出一些信息，比如当前有多少条记录（当然，用户也可能通过id猜出总共有多少用户，这就不太好）。但自增ID也有一些缺点：第一，id携带的信息太少，只能起到一个标识作用；第二，现在啥都是分布式的，如果多个mysql组成一个逻辑上的‘mysql’（比如水平分库这种情况），每个物理mysql都使用自增id，局部来说是唯一的，但总体来说就不唯一了。&lt;/p&gt;
&lt;p&gt;　　于是乎，我们需要为分布式系统生成全局唯一的id。最简单的办法，部署一个单点，比如单独的服务(mysql)专门负责生成id，所有需要id的应用都通过这个单点获取一个唯一的id，这样就能保证系统中id的全局唯一性。但是分布式系统中最怕的就是单点故障（single point of failure），单点故障是可靠性、可用性的头号天敌，因此即使是中心化服务（centralized service）也会搞成一个集群，比如zookeeper。按照这个思路，就有了Flicker的解决方案。&lt;/p&gt;
&lt;p&gt;　　Flicker的解决办法叫《&lt;a href=&quot;http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/&quot; target=&quot;_blank&quot;&gt;Ticket Servers: Distributed Unique Primary Keys on the Cheap&lt;/a&gt;》，文章篇幅不长，而且通俗易懂，&lt;a href=&quot;http://blog.csdn.net/wangzhen199009/article/details/38761575&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;也有中文翻译。简单来说，Flicker是用两组（多组）mysql来提供全局id的生成，多组mysql避免了单点，那么怎么保证多组mysql生成的id全局唯一呢，这就利用了mysql的自增id以及replace into语法。&lt;/p&gt;
&lt;p&gt;　　大家都知道mysql的自增id，但是不一定知道其实可以设置自增id的初始值以及自增步长， Flicker中的示例中，两个mysql(ticketserver）初始值分别是1和2，自增步长都是2（而不是默认值1），这样，&lt;span&gt;ticketserver1永远生成奇数的id，而ticketserver2永远生成偶数的id&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;TicketServer1:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto-increment-increment = 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto-increment-offset = 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TicketServer2:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto-increment-increment = 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto-increment-offset = 2&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　那么怎么获取这个id呢，不可能每需要一个id的时候都插入一条记录，这个时候就用到了replace into语法。 replace是insert、update的结合体，对于一条待插入的记录，如果其主键或者唯一索引的值已经存在表中的话，那么会删除旧的那条记录，然后插入新的记录；如果不存在，那么直接插入记录。这个非常类似mongodb中的&lt;a href=&quot;https://docs.mongodb.com/manual/reference/method/db.collection.findAndModify/&quot; target=&quot;_blank&quot;&gt;findandmodify&lt;/a&gt;语法。在Flicker中，是这么使用的，首先schema如下：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;CREATE TABLE `Tickets64` (&lt;/span&gt;&lt;br/&gt;&lt;span&gt;`id` bigint(20) unsigned NOT NULL auto_increment,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;`stub` char(1) NOT NULL default '',&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PRIMARY KEY (`id`),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;UNIQUE KEY `stub` (`stub`)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;) ENGINE=MyISAM&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　注意，id是主键，而stub是唯一索引，当需要产生一个id的时候，使用以下sql语句；&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;REPLACE INTO Tickets64 (stub) VALUES ('a');&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT LAST_INSERT_ID();&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　由于stub是唯一索引，当每次都插入‘a'的时候，会产生新的记录，而新记录的id是自增的（则增步长为2）&lt;/p&gt;

&lt;p&gt;　　Flicker的解决办法通俗易懂，但还是没有解决id信息过少的问题，而且还是依赖单独的一组服务（mysql）来生成全局id。如果全局id的生成不依赖额外的服务，而且包含丰富的信息那就最好了。&lt;/p&gt;

&lt;h2&gt;UUID　　&lt;/h2&gt;
&lt;div readability=&quot;12.565349544073&quot;&gt;　　提到全局id，首先想到的肯定是&lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot; target=&quot;_blank&quot;&gt;UUID&lt;/a&gt;（Universally unique identifier），从名字就能看出，这个是专门用来生成全局id的。而UUID又分为多个版本，不同的语言，厂家都有自己的实现。本文对uuid的介绍主要参考&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot; target=&quot;_blank&quot;&gt;rfc4122&lt;/a&gt;，如下图所示，一个uuid由一下部分组成：&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1089769/201709/1089769-20170930214819559-2102283851.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/42D36A1FECF840E2AD7C3221EF63658D&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10.72384219554&quot;&gt;　　可以看到，uuid包含128个bit、即16个字节，其中包含了时间信息、版本号信息、机器信息。uuid也不是说一定能保证不冲突，但其冲突的概率小到可以忽略不计。使用uuid就不用再使用额外的id生成服务了。但缺点也有明显：太长，16个字节！太长有什么问题呢，占用空间？问题不大。主要的问题，是太长且随机的id对索引的不友好。在《&lt;a href=&quot;https://medium.com/@varuntayal/re-design-primary-keys-and-ids-9b9776d442b&quot; target=&quot;_blank&quot;&gt;Are you designing Primary Keys and ID’s???Well think twice..&lt;/a&gt;》一文中，作者也许需要用uuid来代替自增id，作者指出：&lt;/div&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;　　So what do we do change ID’s to UUID as well. Well no, that’s not a good idea because we will simply increase work for our database server. It will now have to index a random string of 128 bit. The data &lt;strong&gt;will be more fragmented and bigger to fit in memory&lt;/strong&gt;. This will definitely bring down the performance of our system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　测试结果如下：&lt;/p&gt;
&lt;p&gt;　　     &lt;img src=&quot;http://images2017.cnblogs.com/blog/1089769/201709/1089769-20170930215513294-767430122.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;　　第一例是当前db中有多少条记录，第二列是使用uuid作为key时插入1 million条记录耗费的时间，第三列是使用64位的整形作为key时插入1 million条记录耗费的时间。从结果可以看出，随着数据规模增大，使用uuid时的插入速度远小于使用整形的情况。&lt;/p&gt;
&lt;div readability=&quot;8.4724137931034&quot;&gt;　　既然uuid太长了，那后来者都是在uuid的基础上尽量缩短id的长度，使之更加实用。我认为，如果使用时间信息、机器信息来生成id的话，那么应该就是借鉴了uuid的做法，包含但不限于：twitter的&lt;a href=&quot;https://github.com/twitter/snowflake&quot; target=&quot;_blank&quot;&gt;snowflake&lt;/a&gt;，mongodb的&lt;a href=&quot;https://docs.mongodb.org/manual/reference/glossary/#term-objectid&quot;&gt;ObjectId&lt;/a&gt;。&lt;/div&gt;
&lt;h2&gt;MongoDB ObjectId&lt;/h2&gt;
&lt;blockquote readability=&quot;4.2522935779817&quot;&gt;

&lt;ul&gt;&lt;li&gt;a 4-byte value representing the seconds since the Unix epoch,&lt;/li&gt;
&lt;li&gt;a 3-byte machine identifier,&lt;/li&gt;
&lt;li&gt;a 2-byte process id, and&lt;/li&gt;
&lt;li&gt;a 3-byte counter, starting with a random value.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;　　objectid有12个字节，包含时间信息、机器表示、进程id、计数器。在mongo.exe中，通过ObjectId.getTimestamp可以获取时间信息&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;mongos&amp;gt; x = ObjectId()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ObjectId(&quot;59cf6033858d9d5a85caac02&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mongos&amp;gt; x.getTimestamp()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ISODate(&quot;2017-09-30T09:13:23Z&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　MongoDb的各语言驱动都实现了ObjectId的生成算法，比如PyMongo，在bson.objectid.py里面。通过ObjectId的生成算法以及mongo shell、pymongo的例子，我们可以看到，objectid的生成是由驱动负责的，而不是MongoDB负责，这样减轻了MongoDB负担，也达到了去中心化服务的目的。&lt;/p&gt;

&lt;p&gt;　　这里的结构化ID，就是指按一定规则，用时间、空间（机器）信息生成的ID，上面介绍的UUID以及各种变种都属于结构化id。&lt;/p&gt;
&lt;p&gt;　　结构化ID的优点在于充足的信息，最有用的肯定是时间信息，通过ID就能直接拿到数据的创建时间了；另外，天然起到了冷热数据的分离。当然，有利必有弊，比如在ID作为分片键的分片环境中，如果ID包含时间信息，那么很可能在短时间内生成的数据会落在同一个分片。在《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/7076731.html&quot; target=&quot;_blank&quot;&gt;带着问题学习分布式系统之数据分片&lt;/a&gt;》一文中，介绍了MongoDB分片的两种方式：“hash partition”与“range partition“，如果使用ObjectId作为sharding key，且sharding方式为range partition，那么批量导入数据的时候就会导致数据落在同一个shard，结果就是大量chunk的split和migration，这是不太好的。&lt;/p&gt;

&lt;h2&gt;TFS文件名&lt;/h2&gt;
&lt;p&gt;　　如果结构化ID中包含分片信息，那就更好了，这样就不会再维护数据与分片的信息，而是直接通过id找出对应的分片。我们来看看&lt;a href=&quot;http://code.taobao.org/p/tfs/wiki/intro/&quot; target=&quot;_blank&quot;&gt;TFS&lt;/a&gt;的例子&lt;/p&gt;
&lt;p&gt;　　TFS是淘宝研发的分布式文件存储系，其的结构一定程度上参考了GFS（HDFS），元数据服务器称之为Nameserver，实际的数据存储服务器称之为Dataserver。TFS将多个小文件合并成一个大文件，称之为block，block是真实的物理存储单元。因此，DataServer负责存储Block，而NameServer维护block与DataServer的映射。那么小文件与block的映射关系在哪里维护呢？要知道小文件的量是很大的&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　&lt;strong&gt;TFS的文件名由块号和文件号通过某种对应关系组成&lt;/strong&gt;，最大长度为18字节。文件名固定以T开始，第二字节为该集群的编号(可以在配置项中指定，取值范围 1~9)。余下的字节由Block ID和File ID通过一定的编码方式得到。文件名由客户端程序进行编码和解码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　如图所示：&lt;/p&gt;
&lt;p&gt;　　　　   &lt;img src=&quot;http://images2017.cnblogs.com/blog/1089769/201710/1089769-20171001112638372-990461028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上图可以看到，最终的文件名是包含了block id信息的的，那么如何利用这个blockid信息呢，如下图所示：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1089769/201710/1089769-20171001113446419-89231190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当需要根据文件名获取文件内容的时候，TFS的客户端，首先通过文件名解析出Block id与File id，然后从NameServer上根据Block id查询block所在的DataServer。然后从DataServer上根据Block id拿到对应的block，在根据file id从block中找到对应的文件。&lt;/p&gt;

&lt;p&gt;　　TFS用于存储淘宝大量的小文件，比如商品的各种尺寸的小图片，这个数量是非常大的，如果用单独的元数据服务器维护文件名与文件信息的映射，这个量是非常大的。而使用携带block id信息的文件名，很好规避了这个问题。但使用这种携带分区信息的ID时，需要考虑数据在分区之间的迁移情况，ID一般来说使不能变的，因此ID映射的应该是一个逻辑分区，而不是真正的物理分区。&lt;/p&gt;


&lt;p&gt;　　 本文介绍了分布式系统中，全局唯一ID的生成方法。ID主要有两种类型，一种是数字自增ID，如flicker的解决方案；另一种是携带时间、机器信息的组合ID，如uuid。分布式系统中，好的全局ID生成算法首先是需要避免单点，如果不需要中心化服务的话更好；另外，携带时间信息、分片信息的ID更加实用。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/&quot; target=&quot;_blank&quot;&gt;Ticket Servers: Distributed Unique Primary Keys on the Cheap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot; target=&quot;_blank&quot;&gt;UUID（Universally unique identifier）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc4122.txt&quot; target=&quot;_blank&quot;&gt;rfc4122&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@varuntayal/re-design-primary-keys-and-ids-9b9776d442b&quot; target=&quot;_blank&quot;&gt;Are you designing Primary Keys and ID’s???Well think twice..&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://code.taobao.org/p/tfs/wiki/intro/&quot; target=&quot;_blank&quot;&gt;TFS&lt;/a&gt;&lt;/p&gt;



</description>
<pubDate>Tue, 03 Oct 2017 02:26:00 +0000</pubDate>
<dc:creator>xybaby</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xybaby/p/7616272.html</dc:identifier>
</item>
<item>
<title>Egg + Vue 服务端渲染工程化实现 - Blue Sky ......</title>
<link>http://www.cnblogs.com/hubcarl/p/7623325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hubcarl/p/7623325.html</guid>
<description>&lt;p&gt;在实现 egg + vue 服务端渲染工程化实现之前，我们先来看看前面两篇关于Webpack构建和Egg的文章：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;a class=&quot;internal&quot; href=&quot;https://zhuanlan.zhihu.com/p/28322014&quot;&gt;Webpack工程化解决方案easywebpack&lt;/a&gt; 文章中我们提到了基于 Vue 构建的解决方案 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/hubcarl/easywebpack-vue&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;easywebpack-vue&lt;/a&gt;. easywebpack-vue 支持纯前端模式和Node层构建，这为 Vue 服务端渲染提供了支持，我们只需要简单的配置关键的 entry 和 alias 就可以完成 Vue 前端渲染构建和 Node 层构建， 极大的简化了 Vue 服务端渲染构建的工作，可以让我们把中心放到 Vue 服务端渲染的实现上面。&lt;/li&gt;
&lt;li&gt;在 &lt;a class=&quot;internal&quot; href=&quot;https://zhuanlan.zhihu.com/p/29346081&quot;&gt;Egg + Webpack 热更新实现&lt;/a&gt; 文章中我们通过 Egg 框架的 Message 通信机制实现了 Webpack 内存编译热更新实现插件 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/hubcarl/egg-webpack&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;egg-webpack&lt;/a&gt;，保证 Node 层代码修改重启时，Webpack 编译实例依然存在， 为本地开发Node层代码修改和热更新提供了支持。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Vue 服务端(Node)渲染机制&lt;/h2&gt;
&lt;p&gt;从 Vue 的官方支持我们知道，Vue 是支持服务端渲染的，而且还提供了官方渲染插件 vue-server-renderer 提供了基于 JSBundle 或 JSON 文件渲染模式和流渲染模式。这里我们主要讲基于 JSBundle 的服务端渲染实现，流渲染模式目前在 Egg 框架里面与 Egg 部分插件有冲突(Header写入时机问题), 后续作为单独的研究课题。另外基于 Vue JSON 文件字符串构建渲染请移步 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/hubcarl/egg-vue-webpack-boilerplate/tree/feature/VueSSRPlugin&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;VueSSRPlugin&lt;/a&gt; 这种方案目前基于 Vue 官方的Plugin在构建上面只能构建单页面(生成一个json manfiest，多个会有冲突)，完善的解决方案需要继续研究。&lt;/p&gt;

&lt;p&gt;首先，我们来看看 vue-server-renderer 提供的 createBundleRenderer 和 renderToString 怎么把 JSBundle 编译成 HTML。&lt;/p&gt;
&lt;p&gt;基于 vue-server-renderer 实现 JSBundle 主要代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
const renderer = require('vue-server-renderer'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; filepath 为 Webpack 构建的服务端代码&lt;/span&gt;
const bundleRenderer =&lt;span&gt; renderer.createBundleRenderer(filepath, renderOptions);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; data 为 Node端获取到的数据&lt;/span&gt;
const context =&lt;span&gt; { state: data };
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
  bundleRenderer.renderToString(context, (err, html) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
    reject(err);
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    resolve(html);
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这里面仅仅简单考虑了编译，对于缓存，资源依赖都没有考虑。其实在做 Vue 服务端渲染时，关键的地方就在于这里，如何保证 Vue 渲染的速度，同时也要满足实际的项目需要。&lt;/p&gt;

&lt;p&gt;缓存&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;目前 createBundleRenderer 方法提供了 options 扩展参数，提供了 cache 的接口，支持组件级别缓存，我们这里再近一步支持页面缓存，也就是根据文件把 createBundleRenderer 缓存起来。&lt;/li&gt;
&lt;li&gt;runInNewContext：默认情况下，对于每次渲染，bundle renderer 将创建一个新的 V8 上下文并重新执行整个 bundle。这具有一些好处 - 例如，应用程序代码与服务器进程隔离，我们无需担心文档中提到的&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//ssr.vuejs.org/zh/structure.html%23avoid-stateful-singletons&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;状态单例问题&lt;/a&gt;。然而，这种模式有一些相当大的性能开销，因为重新创建上下文并执行整个 bundle 还是相当昂贵的，特别是当应用很大的时候。出于向后兼容的考虑，此选项默认为 true，但建议你尽可能使用 runInNewContext: false 或 runInNewContext: 'once'(这段信息来自 Vue 官网：&lt;a class=&quot; external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//ssr.vuejs.org/zh/api.html%23runinnewcontext&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;ssr.vuejs.org/zh/api.ht&lt;span class=&quot;invisible&quot;&gt;ml#runinnewcontext&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;)。从实际项目统计分析也印证了这里所说的性能开销问题：runInNewContext=false 能显著提高 render 速度，从线上实际统计来看，runInNewContext=false 能显著提高 render速度 3 倍以上(一个多模块的5屏的列表页面，runInNewContext = true 时的render时间平均在60－80ms，runInNewContext = false 时的render时间平均在20－30ms)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于以上两点， 我们实现了 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/eggjs/egg-view-vue&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;egg-view-vue&lt;/a&gt; 插件， 提供了 Vue 渲染引擎。在 Egg 项目里面，我们可以通过 this.app.vue 拿到 Vue 渲染引擎的实例，然后就可以根据提供的方法进行 Vue 编译成 HTML。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;egg-view-vue 暴露的 vue 实例&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const Engine = require('../../lib/engine'&lt;span&gt;);
const VUE_ENGINE &lt;/span&gt;= Symbol('Application#vue'&lt;span&gt;);

module.exports &lt;/span&gt;=&lt;span&gt; {

  get vue() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;[VUE_ENGINE]) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[VUE_ENGINE] = &lt;span&gt;new&lt;/span&gt; Engine(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;[VUE_ENGINE];
  },
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;Vue View Engine 设计实现&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight&quot; readability=&quot;17.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;

const Vue &lt;/span&gt;= require('vue'&lt;span&gt;);
const LRU &lt;/span&gt;= require('lru-cache'&lt;span&gt;);
const vueServerRenderer &lt;/span&gt;= require('vue-server-renderer'&lt;span&gt;);

class Engine {
  constructor(app) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.app =&lt;span&gt; app;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.config =&lt;span&gt; app.config.vue;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vueServerRenderer =&lt;span&gt; vueServerRenderer;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.renderer = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.vueServerRenderer.createRenderer();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.renderOptions = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.config.renderOptions;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.config.cache === &lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bundleCache =&lt;span&gt; LRU({
        max: &lt;/span&gt;1000&lt;span&gt;,
        maxAge: &lt;/span&gt;1000 * 3600 * 24 * 7&lt;span&gt;,
      });
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.config.cache === 'object'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.config.cache.set &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.config.cache.get) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bundleCache = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.config.cache;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bundleCache = LRU(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.config.cache);
      }
    }
  }

  createBundleRenderer(name, renderOptions) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bundleCache) {
      const bundleRenderer &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bundleCache.get(name);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (bundleRenderer) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bundleRenderer;
      }
    }
    const bundleRenderer &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.vueServerRenderer.createBundleRenderer(name, Object.assign({}, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.renderOptions, renderOptions));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bundleCache) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bundleCache.set(name, bundleRenderer);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bundleRenderer;
  }

  renderBundle(name, context, options) {
    context &lt;/span&gt;= context || &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; istanbul ignore next &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; {};
    options &lt;/span&gt;= options || &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; istanbul ignore next &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; {};

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.createBundleRenderer(name, options.renderOptions).renderToString(context, (err, html) =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
          reject(err);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          resolve(html);
        }
      });
    });
  }

  renderString(tpl, locals, options) {
    const vConfig &lt;/span&gt;=&lt;span&gt; Object.assign({ template: tpl, data: locals }, options);
    const vm &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue(vConfig);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.renderer.renderToString(vm, (err, html) =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
          reject(err);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          resolve(html);
        }
      });
    });
  }
}

module.exports &lt;/span&gt;=&lt;span&gt; Engine;
 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;资源依赖&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关于页面资源依赖我们可以结合 Webpack 的 webpack-manifest-plugin 插件 生成每个页面资源依赖表。 然后在 render 时， 我们根据文件名找到对应的资源依赖，然后掺入到HTML的指定位置。&lt;/li&gt;
&lt;li&gt;Vue 服务端渲染时，我们知道服务端渲染时，只是把Vue 编译成HTML文本，至于页面的事件绑定和一些浏览器端初始化工作还需要我们自己处理，而处理这些，我们还需要 Vue模板文件数据绑定的原始数据，所以我们这里还需要统一处理 INIT_STATE 数据问题。这里我们在 render 后，统一通过 script 标签把数据输出到页面。这里我们通过 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//www.npmjs.com/package/serialize-javascript&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;serialize-javascript&lt;/a&gt; 会进行统一的序列化。注意： 一些敏感数据请不要输出到页面，一般建议通过 API 拿到原始数据时，进行数据清洗，只把 Vue 模板文件需要的数据丢给 render 函数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于以上两点， 我们实现了 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/hubcarl/egg-view-vue-ssr&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;egg-view-vue-ssr&lt;/a&gt; 插件， 解决资源依赖和数据问题。该插件是基于 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/eggjs/egg-view-vue&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;egg-view-vue&lt;/a&gt; 扩展而来， 会覆盖 render 方法。 目前的实现方式会产生一个问题，具体请看 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/hubcarl/egg-view-vue-ssr/issues/2&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;多引擎问题&lt;/a&gt; 。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;inject(html, context, name, config, options) {
    const fileKey &lt;/span&gt;=&lt;span&gt; name;
    const fileManifest &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourceDeps[fileKey];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (fileManifest) {
      const headInject &lt;/span&gt;=&lt;span&gt; [];
      const bodyInject &lt;/span&gt;=&lt;span&gt; [];
      const publicPath &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.buildConfig.publicPath;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (config.injectCss &amp;amp;&amp;amp; (options.injectCss === undefined ||&lt;span&gt; options.injectCss)) {
        fileManifest.css.forEach(item &lt;/span&gt;=&amp;gt;&lt;span&gt; {
          headInject.push(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.createCssLinkTag(publicPath +&lt;span&gt; item));
        });
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        headInject.push(context.styles);
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (config.injectJs) {
        fileManifest.script.forEach(item &lt;/span&gt;=&amp;gt;&lt;span&gt; {
          bodyInject.push(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.createScriptSrcTag(publicPath +&lt;span&gt; item));
        });
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!/window.__INITIAL_STATE__/&lt;span&gt;.test(html)) {
          bodyInject.unshift(`&lt;/span&gt;&amp;lt;script&amp;gt; window.__INITIAL_STATE__= ${serialize(context.state, { isJSON: &lt;span&gt;true&lt;/span&gt; })};&amp;lt;/script&amp;gt;`);
&lt;span&gt;        }
      }
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.injectHead(headInject);
      html &lt;/span&gt;= html.replace(&lt;span&gt;this&lt;/span&gt;.headRegExp, match =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; headInject.join('') +&lt;span&gt; match;
      });

      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.injectBody(bodyInject);
      html &lt;/span&gt;= html.replace(&lt;span&gt;this&lt;/span&gt;.bodyRegExp, match =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; bodyInject.join('') +&lt;span&gt; match;
      });
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; config.afterRender(html, context);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Vue 服务端(Node) 构建&lt;/h2&gt;
&lt;p&gt;在开头我们提到了 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/hubcarl/easywebpack-vue&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;easywebpack-vue&lt;/a&gt; 构建方案，我们可以通过该解决方案完成 Webpack + Vue 的构建方案。具体实现请看 &lt;a class=&quot;internal&quot; href=&quot;https://zhuanlan.zhihu.com/p/28322014&quot;&gt;Webpack工程化解决方案easywebpack&lt;/a&gt; 和 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/hubcarl/easywebpack-vue&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;easywebpack-vue&lt;/a&gt;插件。 这里我们直接提供 webpack.config.js 配置，根据该配置即可完成 Vue 前端渲染构建和 Node 层构建。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;16&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;
const path &lt;/span&gt;= require('path'&lt;span&gt;);
module.exports &lt;/span&gt;=&lt;span&gt; {
  egg: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
  framework: &lt;/span&gt;'vue'&lt;span&gt;,
  entry: {
    include: [&lt;/span&gt;'app/web/page', { 'app/app': 'app/web/page/app/app.js?loader=false'&lt;span&gt; }],
    exclude: [&lt;/span&gt;'app/web/page/[a-z]+/component', 'app/web/page/test', 'app/web/page/html', 'app/web/page/app'&lt;span&gt;],
    loader: {
      client: &lt;/span&gt;'app/web/framework/vue/entry/client-loader.js'&lt;span&gt;,
      server: &lt;/span&gt;'app/web/framework/vue/entry/server-loader.js'&lt;span&gt;,
    }
  },
  alias: {
    server: &lt;/span&gt;'app/web/framework/vue/entry/server.js'&lt;span&gt;,
    client: &lt;/span&gt;'app/web/framework/vue/entry/client.js'&lt;span&gt;,
    app: &lt;/span&gt;'app/web/framework/vue/app.js'&lt;span&gt;,
    asset: &lt;/span&gt;'app/web/asset'&lt;span&gt;,
    component: &lt;/span&gt;'app/web/component'&lt;span&gt;,
    framework: &lt;/span&gt;'app/web/framework'&lt;span&gt;,
    store: &lt;/span&gt;'app/web/store'&lt;span&gt;
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;h2&gt;本地开发与线上解耦&lt;/h2&gt;
&lt;p&gt;我们知道，在本地开发时，大家都会用 Webpack 热更新功能. 而 Webpack 热更新实现是基于内存编译实现的。&lt;/p&gt;
&lt;p&gt;在线上运行时，我们可以直接读取构建好的JSBundle文件，那么在本地开发时，在 Egg 服务端渲染时，如何获取到 JSBundle文件 内容时， 同时又不耦合线上代码。&lt;/p&gt;
&lt;p&gt;这里我们结合 &lt;a class=&quot;internal&quot; href=&quot;https://zhuanlan.zhihu.com/p/29346081&quot;&gt;Egg + Webpack 热更新实现&lt;/a&gt; 里面提到插件 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/hubcarl/egg-webpack&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;egg-webpack&lt;/a&gt; ，该插件在 egg app上下文提供了 app.webpack.fileSystem 实例，我们可以根据文件名获取到 Webpack编译的内存文件内容。有了这一步，为我们本地开发从 Webpack 内存里面实时读取文件内容提供了支持。至于不耦合线上代码线上代码的问题我们可以单独编写一下插件，覆盖 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/eggjs/egg-view-vue&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;egg-view-vue&lt;/a&gt; 暴露的 engine renderBundle 方法。具体实现请看如下实现。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;nx&quot;&gt;app&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;vue&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;p&quot;&gt;{
    &lt;span class=&quot;kr&quot;&gt;const &lt;span class=&quot;nx&quot;&gt;renderBundle &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;nx&quot;&gt;app&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;vue&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;renderBundle&lt;span class=&quot;p&quot;&gt;;
    &lt;span class=&quot;nx&quot;&gt;app&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;vue&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;renderBundle &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;nx&quot;&gt;name&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;nx&quot;&gt;context&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;nx&quot;&gt;options&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;o&quot;&gt;=&amp;gt; &lt;span class=&quot;p&quot;&gt;{
      &lt;span class=&quot;kr&quot;&gt;const &lt;span class=&quot;nx&quot;&gt;filePath &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;nx&quot;&gt;path&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;isAbsolute&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;nx&quot;&gt;name&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;o&quot;&gt;? &lt;span class=&quot;nx&quot;&gt;name &lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;nx&quot;&gt;path&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;join&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;nx&quot;&gt;app&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;config&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;view&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;root&lt;span class=&quot;p&quot;&gt;[&lt;span class=&quot;mi&quot;&gt;0&lt;span class=&quot;p&quot;&gt;], &lt;span class=&quot;nx&quot;&gt;name&lt;span class=&quot;p&quot;&gt;);
      &lt;span class=&quot;kr&quot;&gt;const &lt;span class=&quot;nx&quot;&gt;promise &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;nx&quot;&gt;app&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;webpack&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;fileSystem&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;readWebpackMemoryFile&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;nx&quot;&gt;filePath&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;nx&quot;&gt;name&lt;span class=&quot;p&quot;&gt;);
      &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;nx&quot;&gt;co&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;kd&quot;&gt;function&lt;span class=&quot;o&quot;&gt;* &lt;span class=&quot;p&quot;&gt;() &lt;span class=&quot;p&quot;&gt;{
        &lt;span class=&quot;kr&quot;&gt;const &lt;span class=&quot;nx&quot;&gt;content &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;yield &lt;span class=&quot;nx&quot;&gt;promise&lt;span class=&quot;p&quot;&gt;;
        &lt;span class=&quot;k&quot;&gt;if &lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;o&quot;&gt;!&lt;span class=&quot;nx&quot;&gt;content&lt;span class=&quot;p&quot;&gt;) &lt;span class=&quot;p&quot;&gt;{
          &lt;span class=&quot;k&quot;&gt;throw &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nb&quot;&gt;Error&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;sb&quot;&gt;`read webpack memory file[&lt;span class=&quot;si&quot;&gt;${&lt;span class=&quot;nx&quot;&gt;filePath&lt;span class=&quot;si&quot;&gt;}&lt;span class=&quot;sb&quot;&gt;] content is empty, please check if the file exists`&lt;span class=&quot;p&quot;&gt;);
        &lt;span class=&quot;p&quot;&gt;}
        &lt;span class=&quot;k&quot;&gt;return &lt;span class=&quot;nx&quot;&gt;renderBundle&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;bind&lt;span class=&quot;p&quot;&gt;(&lt;span class=&quot;nx&quot;&gt;app&lt;span class=&quot;p&quot;&gt;.&lt;span class=&quot;nx&quot;&gt;vue&lt;span class=&quot;p&quot;&gt;)(&lt;span class=&quot;nx&quot;&gt;content&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;nx&quot;&gt;context&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;nx&quot;&gt;options&lt;span class=&quot;p&quot;&gt;);
      &lt;span class=&quot;p&quot;&gt;});
    &lt;span class=&quot;p&quot;&gt;};
  &lt;span class=&quot;p&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;基于以上实现，我们封装了 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/hubcarl/egg-webpack-vue&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;egg-webpack-vue&lt;/a&gt; 插件，用于 Egg + Webpack + Vue 本地开发模式。&lt;/p&gt;

&lt;h2&gt;项目搭建&lt;/h2&gt;
&lt;p&gt;有了上面的 3 个渲染相关的 Egg 插件和 easywepback-vue 构建插件， 该如何搭建一个基于 Egg + Webpack + Vue 的服务端渲染工程项目呢？&lt;/p&gt;
&lt;p&gt;项目你可以通过 &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/hubcarl/easywebpack-cli&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;easywebpack-cli&lt;/a&gt; 直接初始化即可完成或者clone &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/hubcarl/egg-vue-webpack-boilerplate&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;egg-vue-webpack-boilerplate&lt;/a&gt;。下面说明�&lt;/p&gt;
</description>
<pubDate>Tue, 03 Oct 2017 02:24:00 +0000</pubDate>
<dc:creator>Blue Sky ......</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hubcarl/p/7623325.html</dc:identifier>
</item>
</channel>
</rss>