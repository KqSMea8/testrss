<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>实现一个简单的行编辑器 - PyLearn</title>
<link>http://www.cnblogs.com/PyLearn/p/8033109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PyLearn/p/8033109.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;0.目录&lt;/h2&gt;
&lt;h4 id=&quot;要求&quot;&gt;1.&lt;a href=&quot;http://www.cnblogs.com/PyLearn/p/8033109.html#jump1&quot;&gt;要求&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;开启关闭回显和缓冲&quot;&gt;2.&lt;a href=&quot;http://www.cnblogs.com/PyLearn/p/8033109.html#jump2&quot;&gt;开启、关闭回显和缓冲&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;显示大小写字母和数字&quot;&gt;3.&lt;a href=&quot;http://www.cnblogs.com/PyLearn/p/8033109.html#jump3&quot;&gt;显示大小写字母和数字&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;实现退格键&quot;&gt;4.&lt;a href=&quot;http://www.cnblogs.com/PyLearn/p/8033109.html#jump4&quot;&gt;实现退格键&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;实现光标左右移动&quot;&gt;5.&lt;a href=&quot;http://www.cnblogs.com/PyLearn/p/8033109.html#jump5&quot;&gt;实现光标左右移动&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;实现del键删除整行&quot;&gt;6.&lt;a href=&quot;http://www.cnblogs.com/PyLearn/p/8033109.html#jump6&quot;&gt;实现Del键删除整行&lt;/a&gt;&lt;/h4&gt;
&lt;h4 id=&quot;总代码&quot;&gt;7.&lt;a href=&quot;http://www.cnblogs.com/PyLearn/p/8033109.html#jump7&quot;&gt;总代码&lt;/a&gt;&lt;/h4&gt;
&lt;h2 id=&quot;要求-1&quot;&gt;&lt;span id=&quot;jump1&quot;&gt;1.要求&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;设计完成一个行编辑器：能够接受用户输入，能倒退删除，插入，移动光标等。&lt;/p&gt;
&lt;h2 id=&quot;开启关闭回显和缓冲-1&quot;&gt;&lt;span id=&quot;jump2&quot;&gt;2.开启、关闭回显和缓冲&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;想要实现行编辑器的功能，就得解决两个问题：&lt;br/&gt;一是在Linux命令行的默认模式下，&lt;strong&gt;&lt;em&gt;输入一个字符就会回显在屏幕上&lt;/em&gt;&lt;/strong&gt;，但是行编辑器不能让每个字符都输出在屏幕上，有些键是要作为功能键来使用的，所以必须关闭回显设置，让我们自己来设计有选择的输出字符。&lt;br/&gt;二是在Linux命令行的默认模式下，&lt;strong&gt;&lt;em&gt;输入字符后必须按回车&lt;/em&gt;&lt;/strong&gt;才能把缓冲区字符送到程序那里去执行，所以必须开启立即响应模式，只要用户按下了键就立刻响应一个功能。&lt;br/&gt;以下是具体代码：&lt;br/&gt;我把开启、关闭回显和缓冲封装成为了一个函数void fun_set(struct termios *info, char set);&lt;br/&gt;set设置为0就是关闭，设置为1就是打开。&lt;br/&gt;在执行循环代码之前打开，循环代码之后关闭，这样就不会影响terminal的正常使用了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;27&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* 设计完成一个行编辑器&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 开启、关闭回显和缓冲&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include   &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include   &amp;lt;termios.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define oops(s, x) { perror(s); exit(x); }&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; fun_set(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; termios *info, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; set);&lt;span class=&quot;co&quot;&gt;//设置回显位,设置缓冲&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()
{
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c;

    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; termios info;
    fun_set( &amp;amp;info, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; );&lt;span class=&quot;co&quot;&gt;//关掉回显位,关掉缓冲&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( ( c=getchar() ) != EOF )
    {
        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    }

    fun_set( &amp;amp;info, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; );&lt;span class=&quot;co&quot;&gt;//打开回显位,打开缓冲&lt;/span&gt;
}

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; fun_set(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; termios *info, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; set)
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( tcgetattr(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, info) == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; )          &lt;span class=&quot;co&quot;&gt;/* get attribs   */&lt;/span&gt;
        oops(&lt;span class=&quot;st&quot;&gt;&quot;tcgettattr&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;co&quot;&gt;/*set为1,打开回显位,打开缓冲;set为0,关掉回显位,关掉缓冲*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( set )
    {
        (*info).c_lflag |= ECHO;    &lt;span class=&quot;co&quot;&gt;/* turn on bit   */&lt;/span&gt;
        (*info).c_lflag &amp;amp;= ICANON;  &lt;span class=&quot;co&quot;&gt;/* turn on bit   */&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
    {
        (*info).c_lflag &amp;amp;= ~ECHO;   &lt;span class=&quot;co&quot;&gt;/* turn off bit   */&lt;/span&gt;
        (*info).c_lflag &amp;amp;= ~ICANON; &lt;span class=&quot;co&quot;&gt;/* turn off bit   */&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( tcsetattr(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, TCSANOW, info) == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; ) &lt;span class=&quot;co&quot;&gt;/* set attribs    */&lt;/span&gt;
        oops(&lt;span class=&quot;st&quot;&gt;&quot;tcsetattr&quot;&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;显示大小写字母和数字-1&quot;&gt;&lt;span id=&quot;jump3&quot;&gt;3.显示大小写字母和数字&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;想要显示大小写字母和数字，只需要在while函数中判断一下是不是大小写字母和数字，是的话就输出在屏幕上，不是的话就跳过。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( ( c=getchar() ) != EOF )
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( isalnum(c) )
    {
        &lt;span class=&quot;co&quot;&gt;//isalnum()函数:如果c是一个数字或字母返回非0值，否则为0&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//user input a letter or a number&lt;/span&gt;
        putchar(c);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;isalnum()函数判断是不是一个数字或字母，然后通过putchar打印出字符即可。&lt;br/&gt;在这里可以通过一个数组来保存这些输出的字符，这样当你在之后想保存到文件中去的时候也会更方便。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; str[&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;];&lt;span class=&quot;co&quot;&gt;//保存输出的字符&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; p = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;//当前位置&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( ( c=getchar() ) != EOF )
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( isalnum(c) )
    {
        &lt;span class=&quot;co&quot;&gt;//isalnum()函数:如果c是一个数字或字母返回非0值，否则为0&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//user input a letter or a number&lt;/span&gt;
        putchar(c);
        str[p++] = c;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;实现退格键-1&quot;&gt;&lt;span id=&quot;jump4&quot;&gt;4.实现退格键&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;退格键的实现其实是非常简单的。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;当你按下退格键的时候，程序实际上执行了三条指令：&lt;br/&gt;1.putchar('\b');//将光标左移&lt;br/&gt;2.putchar(' ');//输出一个空字符&lt;br/&gt;3.putchar('\b');//将光标左移&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;什么意思呢？其实就是先将光标移动到左边，然后输出一个空字符将原来的字符覆盖掉，这样就相当于把左边的字符删掉了，但是此时光标还停留在空字符的右边。&lt;br/&gt;比如原来是输入了HelloWorld：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250397/201712/1250397-20171213140932816-1175869955.png&quot;/&gt;&lt;br/&gt;然后执行&lt;code&gt;putchar('\b');&lt;/code&gt;和&lt;code&gt;putchar(' ');&lt;/code&gt;就变成了：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250397/201712/1250397-20171213140944738-1560120638.png&quot;/&gt;&lt;br/&gt;这时候再执行一个&lt;code&gt;putchar('\b');&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250397/201712/1250397-20171213141223894-350047895.png&quot;/&gt;&lt;br/&gt;将退格键封装成一个函数void fun_backspace()：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; fun_backspace()
{
    &lt;span class=&quot;co&quot;&gt;//实现退格功能&lt;/span&gt;
    putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
    putchar(' ');
    putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为退格键的ASCII码为十六进制的0x7f，所以while循环里代码为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( ( c=getchar() ) != EOF )
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( isalnum(c) )
    {
        &lt;span class=&quot;co&quot;&gt;//isalnum()函数:如果c是一个数字或字母返回非0值，否则为0&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//user input a letter or a number&lt;/span&gt;
        putchar(c);
        str[p++] = c;
    }
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( c == &lt;span class=&quot;bn&quot;&gt;0x7f&lt;/span&gt; )
    {
        &lt;span class=&quot;co&quot;&gt;//退格键(user input a backspace)&lt;/span&gt;
        fun_backspace();
        str[p--] = '\&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;';
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就实现了退格键的功能，但是程序还有一个小bug：就是当所有字符都删完了之后，你还是可以按退格键。虽然这时候退格键已经没有删任何字符了，但是在之后还是会带来一些小的隐患。&lt;br/&gt;所以为了解决这个问题，我们&lt;strong&gt;&lt;em&gt;引入字符数组的长度len，让len记录字符数组的长度，当len大于0的时候，可以执行退格键&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; str[&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;];&lt;span class=&quot;co&quot;&gt;//保存输出的字符&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; p = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;//当前位置&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;//总长度&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( ( c=getchar() ) != EOF )
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( isalnum(c) )
    {
        &lt;span class=&quot;co&quot;&gt;//isalnum()函数:如果c是一个数字或字母返回非0值，否则为0&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//user input a letter or a number&lt;/span&gt;
        putchar(c);
        str[p++] = c;
        len++;
    }
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( c == &lt;span class=&quot;bn&quot;&gt;0x7f&lt;/span&gt; )
    {
        &lt;span class=&quot;co&quot;&gt;//退格键(user input a backspace)&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( len &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; )
        {
            fun_backspace();
            str[p--] = ' ';
            len--;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以简化为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( c == &lt;span class=&quot;bn&quot;&gt;0x7f&lt;/span&gt; &amp;amp;&amp;amp; len )
{
    &lt;span class=&quot;co&quot;&gt;//退格键(user input a backspace)&lt;/span&gt;
    fun_backspace();
    str[p--] = ' ';
    len--;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;实现光标左右移动-1&quot;&gt;&lt;span id=&quot;jump5&quot;&gt;5.实现光标左右移动&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;因为方向键上下左右在实际测试中发现，其实是由三个字符组成的，实现起来需要一些特殊的方法。所以在这里先用'[{'键来实现'←'（也就是左键），用'→'键来实现'-&amp;gt;'（也就是右键）。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;之前实现退格键的时候，发现可以使用&lt;code&gt;putchar('\b');&lt;/code&gt;来实现光标左移，这样也就直接实现了左键的功能。&lt;br/&gt;那么如何实现光标右移呢？我想到的办法是将当前所在位置的值重新输出一遍。比如说：Hello，此时光标在最左边的H上，那么我要右移，那就在这个位置上将H再输出一遍，这样也就间接实现了光标的右移。&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;上代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( c == '[' &amp;amp;&amp;amp; p )
{
    &lt;span class=&quot;co&quot;&gt;//使用'['进行左移光标&lt;/span&gt;
    putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
    p--;
}
&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( c == ']' &amp;amp;&amp;amp; p &amp;lt; len )
{
    &lt;span class=&quot;co&quot;&gt;//使用']'进行右移光标&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//将当前位置的值再输出一遍&lt;/span&gt;
    putchar(str[p++]);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里用p来代表当前光标所在的位置。&lt;br/&gt;同样，当光标已经移到最左边的时候，就不执行左移键了；当光标已经移到最右边的时候，也不执行右移键了。&lt;br/&gt;到这里，也就实现了左移右移光标的功能了。&lt;br/&gt;但是！如果就到这里结束了的话，那么程序会有很大的bug！比如说当你移动光标到HelloWorld的W上的时候：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250397/201712/1250397-20171213150136019-314005459.png&quot;/&gt;&lt;br/&gt;再执行退格键，那么就会发现是这样的：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1250397/201712/1250397-20171213150158426-1181635962.png&quot;/&gt;&lt;br/&gt;你会发现删除了一个字符后整个显示的字符数组都会乱掉。&lt;br/&gt;如果在这个时候还输入一些大小写字母或者数字，你就会发现情况会变得更乱。&lt;/p&gt;
&lt;p&gt;那么怎么解决这个问题呢？&lt;br/&gt;那就是分别在显示字符的地方和实现退格的地方加入一些代码来实现这些功能。&lt;br/&gt;首先在while循环外面定义&lt;code&gt;int i, j;&lt;/code&gt;来辅助我们工作。然后是处理输出大小写字母和数字的函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( isalnum(c) )
{
    &lt;span class=&quot;co&quot;&gt;//isalnum()函数:如果c是一个数字或字母返回非0值，否则为0&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//user input a letter or a number&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//1.将当前位置之后的值依次后移&lt;/span&gt;
    j = ++len;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( j-- &amp;gt; p )
        str[j] = str[j&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;];
    str[p] = c;
    j = len - p - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;//光标要移动的距离&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//2.从当前位置开始重新输出数组&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( p &amp;lt; len )
        putchar(str[p++]);
    &lt;span class=&quot;co&quot;&gt;//3.将光标移动到之前的位置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( j-- &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; p-- )
        putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是解决中间退格的问题：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( c == &lt;span class=&quot;bn&quot;&gt;0x7f&lt;/span&gt; &amp;amp;&amp;amp; p )
{
    &lt;span class=&quot;co&quot;&gt;//退格键(user input a backspace)&lt;/span&gt;
    j = len - p;&lt;span class=&quot;co&quot;&gt;//光标要移动的距离&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//1.将当前位置之后的值依次前移&lt;/span&gt;
    putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( p &amp;lt; len )
    {
        str[p&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;] = str[p];
        putchar(str[p]);
        p++;
    }
    &lt;span class=&quot;co&quot;&gt;//2.将最后一个元素删除&lt;/span&gt;
    putchar(' ');
    putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
    len--;
    p--;
    &lt;span class=&quot;co&quot;&gt;//3.将光标移动到之前的位置&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( j-- &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; p-- )
        putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;实现del键删除整行-1&quot;&gt;&lt;span id=&quot;jump6&quot;&gt;6.实现Del键删除整行&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;实现Del键删除整行的思路其实很简单：&lt;br/&gt;首先将光标移动到尾部，然后只要len大于0，就循环执行退格键。这样就能够将整行删除了。&lt;br/&gt;PS：Del键的ASCII码为十六进制的0x7e，所以while循环里代码为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( c == &lt;span class=&quot;bn&quot;&gt;0x7e&lt;/span&gt; &amp;amp;&amp;amp; len )
{
    &lt;span class=&quot;co&quot;&gt;//删除键(Del):删除整行(user input delete)&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//1.从光标处移动到结尾&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( ++p &amp;lt;= len )
        putchar(' ');
    &lt;span class=&quot;co&quot;&gt;//2.从结尾往前依次退格&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( --p )
        fun_backspace();
    &lt;span class=&quot;co&quot;&gt;//3.len置0&lt;/span&gt;
    len = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;总代码-1&quot;&gt;&lt;span id=&quot;jump7&quot;&gt;7.总代码&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;28&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* 设计完成一个行编辑器&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 能够接受用户输入，能倒退删除，插入，移动光标等&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include   &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include   &amp;lt;termios.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;ot&quot;&gt;#define oops(s, x) { perror(s); exit(x); }&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; fun_set(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; termios *info, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; set);&lt;span class=&quot;co&quot;&gt;//设置回显位,设置缓冲&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; fun_backspace();&lt;span class=&quot;co&quot;&gt;//实现退格功能&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main()
{
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i, j;

    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; termios info;
    fun_set( &amp;amp;info, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; );&lt;span class=&quot;co&quot;&gt;//关掉回显位,关掉缓冲&lt;/span&gt;
    
    &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; str[&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;];&lt;span class=&quot;co&quot;&gt;//保存输出的字符&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; p = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;//当前位置&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; len = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;//总长度&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( ( c=getchar() ) != EOF )
    {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( isalnum(c) )
        {
            &lt;span class=&quot;co&quot;&gt;//isalnum()函数:如果c是一个数字或字母返回非0值，否则为0&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//user input a letter or a number&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//1.将当前位置之后的值依次后移&lt;/span&gt;
            j = ++len;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( j-- &amp;gt; p )
                str[j] = str[j&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;];
            str[p] = c;
            j = len - p - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;&lt;span class=&quot;co&quot;&gt;//光标要移动的距离&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//2.从当前位置开始重新输出数组&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( p &amp;lt; len )
                putchar(str[p++]);
            &lt;span class=&quot;co&quot;&gt;//3.将光标移动到之前的位置&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( j-- &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; p-- )
                putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( c == &lt;span class=&quot;bn&quot;&gt;0x7f&lt;/span&gt; &amp;amp;&amp;amp; p )
        {
            &lt;span class=&quot;co&quot;&gt;//退格键(user input a backspace)&lt;/span&gt;
            j = len - p;&lt;span class=&quot;co&quot;&gt;//光标要移动的距离&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//1.将当前位置之后的值依次前移&lt;/span&gt;
            putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( p &amp;lt; len )
            {
                str[p&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;] = str[p];
                putchar(str[p]);
                p++;
            }
            &lt;span class=&quot;co&quot;&gt;//2.将最后一个元素删除&lt;/span&gt;
            putchar(' ');
            putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
            len--;
            p--;
            &lt;span class=&quot;co&quot;&gt;//3.将光标移动到之前的位置&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( j-- &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; p-- )
                putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( c == '[' &amp;amp;&amp;amp; p )
        {
            &lt;span class=&quot;co&quot;&gt;//使用'['进行左移光标&lt;/span&gt;
            putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
            p--;
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( c == ']' &amp;amp;&amp;amp; p &amp;lt; len )
        {
            &lt;span class=&quot;co&quot;&gt;//使用']'进行右移光标&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//将当前位置的值再输出一遍&lt;/span&gt;
            putchar(str[p++]);
        }
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( c == &lt;span class=&quot;bn&quot;&gt;0x7e&lt;/span&gt; &amp;amp;&amp;amp; len )
        {
            &lt;span class=&quot;co&quot;&gt;//删除键(Del):删除整行(user input delete)&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;//1.从光标处移动到结尾&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( ++p &amp;lt;= len )
                putchar(' ');
            &lt;span class=&quot;co&quot;&gt;//2.从结尾往前依次退格&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;( --p )
                fun_backspace();
            &lt;span class=&quot;co&quot;&gt;//3.len置0&lt;/span&gt;
            len = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        }
    }

    fun_set( &amp;amp;info, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; );&lt;span class=&quot;co&quot;&gt;//打开回显位,打开缓冲&lt;/span&gt;
}

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; fun_set(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; termios *info, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; set)
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( tcgetattr(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, info) == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; )          &lt;span class=&quot;co&quot;&gt;/* get attribs   */&lt;/span&gt;
        oops(&lt;span class=&quot;st&quot;&gt;&quot;tcgettattr&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
    &lt;span class=&quot;co&quot;&gt;/*set为1,打开回显位,打开缓冲;set为0,关掉回显位,关掉缓冲*/&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;( set )
    {
        (*info).c_lflag |= ECHO;    &lt;span class=&quot;co&quot;&gt;/* turn on bit   */&lt;/span&gt;
        (*info).c_lflag &amp;amp;= ICANON;  &lt;span class=&quot;co&quot;&gt;/* turn on bit   */&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
    {
        (*info).c_lflag &amp;amp;= ~ECHO;   &lt;span class=&quot;co&quot;&gt;/* turn off bit   */&lt;/span&gt;
        (*info).c_lflag &amp;amp;= ~ICANON; &lt;span class=&quot;co&quot;&gt;/* turn off bit   */&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( tcsetattr(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, TCSANOW, info) == -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; ) &lt;span class=&quot;co&quot;&gt;/* set attribs    */&lt;/span&gt;
        oops(&lt;span class=&quot;st&quot;&gt;&quot;tcsetattr&quot;&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;);
}

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; fun_backspace()
{
    putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
    putchar(' ');
    putchar(&lt;span class=&quot;ch&quot;&gt;'\b'&lt;/span&gt;);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 13 Dec 2017 07:29:00 +0000</pubDate>
<dc:creator>PyLearn</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PyLearn/p/8033109.html</dc:identifier>
</item>
<item>
<title>深入解析Java垃圾回收机制 - 六尺帐篷</title>
<link>http://www.cnblogs.com/desperate/p/8032867.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/desperate/p/8032867.html</guid>
<description>&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;引入垃圾回收&lt;/li&gt;
&lt;li&gt;哪些内存需要回收？&lt;/li&gt;
&lt;li&gt;引用计数法&lt;/li&gt;
&lt;li&gt;可达性分析&lt;/li&gt;
&lt;li&gt;如何回收&lt;/li&gt;
&lt;li&gt;Marking 标记&lt;/li&gt;
&lt;li&gt;Normal Deletion 清除&lt;/li&gt;
&lt;li&gt;Deletion with Compacting 压缩&lt;/li&gt;
&lt;li&gt;为什么需要分代收集？&lt;/li&gt;
&lt;li&gt;JVM的分代&lt;/li&gt;
&lt;li&gt;新生代&lt;/li&gt;
&lt;li&gt;老年代&lt;/li&gt;
&lt;li&gt;永久代&lt;/li&gt;
&lt;li&gt;分代垃圾收集过程详述&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;程序计数器、 虚拟机栈、 本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。 每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器&lt;br/&gt;进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。 而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存-----《深入理解Java虚拟机》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自动垃圾回收机制就是寻找Java堆中的对象，并对对象进行分类判别，寻找出正在使用的对象和已经不会使用的对象，然后把那些不会使用的对象从堆上清除。&lt;br/&gt;自动垃圾回收机制就是要解决三个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;哪些内存需要回收？&lt;/li&gt;
&lt;li&gt;什么时候回收？&lt;/li&gt;
&lt;li&gt;如何回收？&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;引用计数法&quot;&gt;引用计数法&lt;/h2&gt;
&lt;p&gt;对于第一个问题，也就是判断是否还需要使用，最简单的方法就是通过目前是否有引用指向这个对象，如果没有就说明这个对象不会再被使用了，如果有就说明这个对象可能还会继续被使用，这种通过引用是否存在的方法就叫做引用计数法，但这个方法存在一个问题就是无法解决对象循环引用的问题，因此又出现了可达性分析的方法来判断对象是否可以被会回收。&lt;/p&gt;
&lt;h2 id=&quot;可达性分析&quot;&gt;可达性分析&lt;/h2&gt;
&lt;p&gt;这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。&lt;br/&gt;在Java语言中，可作为GC Roots的对象包括下面几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟机栈（栈帧中的本地变量表）中引用的对象。&lt;/li&gt;
&lt;li&gt;方法区中类静态属性引用的对象。&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象。&lt;/li&gt;
&lt;li&gt;本地方法栈中JNI（即一般说的Native方法）引用的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;垃圾收集器通常会帮我们在后台自动进行垃圾回收。关于具体的回收过程只要有以下这些步骤&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Step 1: Marking 标记&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一步就是标记，也就是垃圾收集器会找出那些需要回收的对象所在的内存和不需要回收的对象所在的内存，并把它们标记出来，简单的说，也就是先找出垃圾在哪&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-420049faf427a7ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有堆中的对象都会被扫描一遍，以此来确定回收的对象，所以这通常会是一个相对比较耗时的过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Step 2: Normal Deletion&lt;br/&gt;垃圾收集器会清除掉上一步标记出来的那些需要回收的对象区域&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-8a00dad3f360aaae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;存在的问题就是碎片问题：&lt;br/&gt;标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程&lt;br/&gt;序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Step 2a: Deletion with Compacting 压缩&lt;br/&gt;由于简单的清除可能会存在碎片的问题，所以又出现了压缩清除的方法，也就是先清除需要回收的对象，然后再对内存进行压缩操作，将内存分成可用和不可用两大部分&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-9a5942233a60c0bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;就像前文所述，标记对象和压缩内存的过程在JVM中是不高效的，分配的对象越多，垃圾收集的时间就越长。但是，经过一些经验型性的统计分析表明，一个程序中大部分对象都是短命的！&lt;/p&gt;
&lt;p&gt;下图就是一个类似的统计数据，纵坐标表示分配对象所占用的内存大小，横坐标表示自分配对象过去的时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-32fa64dd7cfd57a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中我们看到，大部分对象没活多久就死了，存活较久的只是少类对象&lt;/p&gt;

&lt;p&gt;为了增大垃圾收集的效率，所以JVM将堆进行分代，分为不同的部分，一般有三部分，新生代，老年代和永久代&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-80d8ad7f6a126106.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新生代&quot;&gt;新生代&lt;/h2&gt;
&lt;p&gt;所有新new出来的对象都会最先出现在新生代中，当新生代这部分内存满了之后，就会发起一次垃圾收集事件，这种发生在新生代的垃圾收集称为Minor collections。这种收集通常比较快，因为新生代的大部分对象都是需要回收的，那些暂时无法回收的就会被移动到老年代。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stop the World&lt;/strong&gt;事件-所有minor garbage collections都是&lt;strong&gt;Stop the World&lt;/strong&gt;事件，也就是意味着所有的应用线程都需要停止，直到垃圾回收的操作全部完成。类似于&lt;br/&gt;“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”&lt;/p&gt;
&lt;h2 id=&quot;老年代&quot;&gt;老年代&lt;/h2&gt;
&lt;p&gt;老年代用来存储那些存活时间较长的对象。一般来说，我们会给新生代的对象限定一个存活的时间，当达到这个时间还没有被收集的时候就会被移动到老年代中。老年代区域的垃圾收集叫做major garbage collection&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-b08bf6069ee7366c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Major garbage collection也是一个&lt;strong&gt;Stop the World&lt;/strong&gt;事件。通常Major garbage collection都相对比较慢，因为老年代的收集包括了对所有对象的收集，也就是同时需要收集新生代和老年代的对象。&lt;/p&gt;
&lt;h2 id=&quot;永久代&quot;&gt;永久代&lt;/h2&gt;
&lt;p&gt;The Permanent generation contains metadata required by the JVM to describe the classes and methods used in the application. The permanent generation is populated by the JVM at runtime based on classes in use by the application. In addition, Java SE library classes and methods may be stored here.&lt;/p&gt;
&lt;p&gt;Classes may get collected (unloaded) if the JVM finds they are no longer needed and space may be needed for other classes. The permanent generation is included in a full garbage collection.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-f7f32e39af803854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们已经知道垃圾回收所需要的方法和堆内存的分代，那么接下来我们就来具体看一下垃圾回收的具体过程&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步 所有new出来的对象都会最先分配到新生代区域中，两个survivor区域初始化是为空的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-ed812d174ca6c8c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第二步，当eden区域满了之后，就引发一次 minor garbage collection&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-d3746363a41a7c3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第三步，当在minor garbage collection，存活下来的对象就会被移动到S0survivor区域&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-eb04dc5ddf426ba1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第四步，然后当eden区域又填满的时候，又会发生下一次的垃圾回收，存活的对象会被移动到survivor区域而未存活对象会被直接删除。但是，不同的是，在这次的垃圾回收中，存活对象和之前的survivor中的对象都会被移动到s1中。一旦所有对象都被移动到s1中，那么s2中的对象就会被清除，仔细观察图中的对象，数字表示经历的垃圾收集的次数。目前我们已经有不同的年龄对象了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-2ef7443435b7de67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第五步，下一次垃圾回收的时候，又会重复上次的步骤，清除需要回收的对象，并且又切换一次survivor区域，所有存活的对象都被移动至s0。eden和s1区域被清除。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-c4ca47aa891ffeb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第六步，重复以上步骤，并记录对象的年龄，当有对象的年龄到达一定的阈值的时候，就将新生代中的对象移动到老年代中。在本例中，这个阈值为8.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-3a5073d424ad3778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第七步，接下来垃圾收集器就会重复以上步骤，不断的进行对象的清除和年代的移动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-038cdad64f06b7a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最后，我们观察上述过程可以发现，大部分的垃圾收集过程都是在新生代进行的，直到老年代中的内存不够用了才会发起一次 major GC，会进行标记和整理压缩。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1234352-a4fee4707be5d7e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Dec 2017 06:54:00 +0000</pubDate>
<dc:creator>六尺帐篷</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/desperate/p/8032867.html</dc:identifier>
</item>
<item>
<title>开源：Sagit.Framework For IOS 开发框架 - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/8029864.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/8029864.html</guid>
<description>&lt;p&gt;记得IT连创业刚进行时，招了个IOS的女生做开发，然后：&lt;/p&gt;
&lt;p&gt;----------女生的事故就此开始了-----------&lt;/p&gt;
&lt;p&gt;1：面试时候：有作品，态度也不错，感觉应该能做点事。&lt;/p&gt;
&lt;p&gt;2：刚招进来：发现每天都在看文章，但迟迟不见有点东西。&lt;/p&gt;
&lt;p&gt;3：过程问答：现在在整些什么？回答在搭框架。&lt;/p&gt;
&lt;p&gt;4：发现危机：不小心看到她用单手指敲键盘，感觉不妙。&lt;/p&gt;
&lt;p&gt;5：处理危机：速学IOS，一个星期后，看完她代码，谈话Over！&lt;/p&gt;
&lt;p&gt;----------女生的事故就到此结束了----------&lt;/p&gt;
&lt;p&gt;在速学IOS时，快速扫了不少培训的视频教程，发现套路都是很原始。&lt;/p&gt;
&lt;p&gt;这些原始的套路了解可以，但若这些过来搬到项目来，就祸害无穷了。&lt;/p&gt;
&lt;p&gt;按照当时创业的成本考虑，很大概率招来的人是以下三种：&lt;/p&gt;
&lt;p&gt;1： 刚从培训班出来的；&lt;/p&gt;
&lt;p&gt;2：刚看完培训视频过来；&lt;/p&gt;
&lt;p&gt;3：刚用培训视频的套路祸害完一个项目后跳过来的。&lt;/p&gt;
&lt;p&gt;为了对下一个开发人员有所约束：&lt;/p&gt;
&lt;p&gt;让一个有3-4年开发经验的朋友帮忙整一下框架。&lt;/p&gt;
&lt;p&gt;看完他整的框架，发现只是常规性的工具类分文件夹。&lt;/p&gt;
&lt;p&gt;给他提了一个要求，把其中一个网络请求重新封装一下。&lt;/p&gt;
&lt;p&gt;回头再看，虽有所改进，但还是不尽我意。&lt;/p&gt;
&lt;p&gt;也许可以指导继续改进，但时不以我，也不以他。&lt;/p&gt;
&lt;p&gt;于是自己动手了：框架大体完成60%时，招了个男开发人员。&lt;/p&gt;
&lt;p&gt;----------男生的事故就此开始了-----------&lt;/p&gt;
&lt;p&gt;为了赶项目，让新人在框架的基础上动工了。&lt;/p&gt;
&lt;p&gt;鉴于新人开发人员能弄点东西，加上有框架的辅助，就撒手了。&lt;/p&gt;
&lt;p&gt;由于框架的不完善，以及对框架的不理解，遇到点小坑就吐槽。&lt;/p&gt;
&lt;p&gt;吐槽多了，也只能同意他混着其它的框架一起整了。&lt;/p&gt;
&lt;p&gt;再后来，多的数不清的坑和闪退事故。&lt;/p&gt;
&lt;p&gt;早期关注IT连及用IT连App的童学，就清楚了。&lt;/p&gt;
&lt;p&gt;或者在我之前的IT连创业系列文章里应该可以感知了。&lt;/p&gt;
&lt;p&gt;现在，他也Over了！&lt;/p&gt;
&lt;p&gt;----------男生的事故就到此结束了-----------&lt;/p&gt;
&lt;p&gt;重新接手回IOS后，发现代码逻辑也是一团槽，好在之前有一部份还是按框架走。&lt;/p&gt;
&lt;p&gt;最近花了一周多的时候，理解，并开始重构整个项目的代码。&lt;/p&gt;
&lt;p&gt;同时对框架之前已有的依赖关系也进行了抽离，并重新重构了一下框架。&lt;/p&gt;
&lt;p&gt;目前对框架的重构的工作已经进行了70%-80%，还有一些功能想了还没加上。&lt;/p&gt;
&lt;p&gt;但整体并不影响基础功能，所以是时候把Sagit的框架和大伙分享了！&lt;/p&gt;

&lt;p&gt;自从：CYQ.Data 框架这名字被大伙吐槽之后，后续的框架命名，就显的格外用心了。&lt;/p&gt;
&lt;p&gt;在研究了行星、星座、水果、植物、动物、颜色、形状等英文名称之后。&lt;/p&gt;
&lt;p&gt;终于有了：白羊（Areis.DevFramework For DotNet）、&lt;/p&gt;
&lt;p&gt;再也有了：金牛（Taurus.MVC For DotNet）&lt;/p&gt;
&lt;p&gt;之后没了：双子（Gemini.workflow For DotNet) 工作流引擎目前难产中（写了开头，后来没空折腾）。&lt;/p&gt;
&lt;p&gt;因此，凑齐黄金十二宫，召换雅典娜，就成了我来地球最神秘的任务了！&lt;/p&gt;
&lt;p&gt;这次越级选了：Sagittarius （射手）&lt;/p&gt;
&lt;p&gt;一来是ST的前缀简写刚好对应的现在创业公司的名字：随天。&lt;/p&gt;
&lt;p&gt;二来取前半部做框架名，简写：Sagit（发音：射日，很和谐发现有木有）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201712/17408-20171212213123644-406027394.jpg&quot; alt=&quot;&quot; width=&quot;641&quot; height=&quot;453&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1：研究学习：&lt;/h2&gt;
&lt;p&gt;A：工作几年之后，开发功能已不是问题，需要有点新思维来突破受限的瓶颈。&lt;/p&gt;
&lt;p&gt;看懂框架代码不难，主要是学习思维，多思考，并多训练自己怎么写。&lt;/p&gt;
&lt;p&gt;B：对于在培训行业的教师，可以在培训结束前用框架的思维引导一下新人，再放他们出来。&lt;/p&gt;
&lt;h2&gt;2：项目开发：&lt;/h2&gt;
&lt;p&gt;A：开发人员没有框架的概念。&lt;/p&gt;
&lt;p&gt;B：目前没有其它可选择的框架。&lt;/p&gt;
&lt;p&gt;一般的说，除了游戏，其它常规性的项目都适合。 &lt;/p&gt;

&lt;p&gt;下面对框架进行简单的介绍，也只能是简单介绍：&lt;/p&gt;

&lt;h2&gt;1：统一标准参数，自适配手机屏幕，实现AutoLayout。&lt;/h2&gt;
&lt;p&gt;A：框架默认以IPhone6的像素为标准参考体系：750*1334。&lt;/p&gt;
&lt;p&gt;B：开发时，都以标准的像素单位为参数。&lt;/p&gt;
&lt;p&gt;C：运行时，会自动适配成对应比例的参数。&lt;/p&gt;
&lt;p&gt;（PS ：如果需要修改标准，可在STDefineUI.h文件中修改定义）&lt;/p&gt;
&lt;p&gt;看着UI给的参数标注图，轻松布局：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201712/17408-20171212232120035-160733888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2： 简洁的相对布局语法，一行看尽&lt;/h2&gt;
&lt;p&gt;以上图片为例，做布局&lt;/p&gt;
&lt;p&gt;A：相对父元素的布局 Logo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[[[[self addImageView:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;login_logo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] width:&lt;span&gt;170&lt;/span&gt; height:&lt;span&gt;170&lt;/span&gt;] relate:Top v:&lt;span&gt;288&lt;/span&gt;] toCenter:X];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;B：相对固定元素的布局，下面这行代码是引用其它地方的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[[[[self addImageView:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;icon_verify&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] width:&lt;span&gt;48&lt;/span&gt; height:&lt;span&gt;48&lt;/span&gt;] onBottom:pwdIcon y:26] toCenter:X];
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3：可局部刷新的布局&lt;/h2&gt;
&lt;p&gt;以下这行代码，会对批定的视图的子视图重新进一次相对布局。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[self refleshLayout];
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;记得很早以前，我写过一篇文章：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/cyq1162/p/6843564.html&quot;&gt;Objective-C iOS纯代码布局 一堆代码可以放这里！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那时候只是研究的前奏，并没有实现完整分离，当然现在是解决了。&lt;/p&gt;
&lt;p&gt;举个例如：一个文本框一个按钮，点击按钮弹出文字框的内容。&lt;/p&gt;
&lt;p&gt;之前的做法，你都会在Controller里写一堆UI相关的创建方法，或者需要将某些UI定义为全局变量，以便后续再去获取UI的值。&lt;/p&gt;
&lt;p&gt;最差也是我之前未完成时留下的那点手尾：（下面红色的，在Controller中需要定义一个具体的LoginView变量）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201712/17408-20171213053436113-1676527774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;好了，现在这个问题已经被我彻底解决了，0入侵已经成为了事实，下面看示例代码：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;LoginView 的代码：创建了一个文本框和一个点击按钮&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@interface&lt;/span&gt; LoginView : STView &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是LoginView.h&lt;/span&gt;

&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;@implementation&lt;/span&gt; LoginView    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是LoginView.m&lt;/span&gt;

-(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)initUI
{
    [[self addTextField:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; placeholder:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;输入手机号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] x:&lt;span&gt;0&lt;/span&gt; y:&lt;span&gt;0&lt;/span&gt; width:&lt;span&gt;100&lt;/span&gt; height:&lt;span&gt;100&lt;/span&gt;&lt;span&gt;];
    [[self addButton:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;btnLogin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; title:&lt;span&gt;@&quot;登录&quot;&lt;/span&gt;] onRight:self.lastSubView.PreView x:&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
}
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LoginController 的代码：有一个按钮事件，获取手机号用户名然后弹出来提示&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
@interface LoginController : STController // 这是LoginController.h

@end

@implementation LoginController            //这是LoginController.m

-(void)btnLoginClick
{
    NSString* userName=[self uiValue:@&quot;userName&quot;];
    [self.box prompt:userName];
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;调用：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
self.window.rootViewController = [LoginController &lt;span&gt;new&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;效果：（为了截图，特意新建了个demo...）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/17408/201712/17408-20171213064104894-1961216972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;解析：&lt;/h3&gt;
&lt;p&gt;LoginView和LoginController两个文件代码里，并没有互相引用的地方。&lt;/p&gt;
&lt;p&gt;但是UI和事件却补神奇的关联起来了，这是怎么做到的呢？&lt;/p&gt;
&lt;p&gt;秘密就在STView和STController文件的源码中。&lt;/p&gt;

&lt;p&gt;如果你需要提交一个表单的数据，你只需要这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
-(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)btnLoginClick
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    NSString* userName=[self uiValue:@&quot;userName&quot;];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    [self.box prompt:userName];&lt;/span&gt;
&lt;span&gt;    
    [self.http post:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;/Login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; paras:self.formData success:^(STModel *&lt;span&gt;result) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(result.success)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果：提交成功&lt;/span&gt;
&lt;span&gt;        {
            [self.stView loadData:result.msg];&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将返回的数据回显到控件&lt;/span&gt;
&lt;span&gt;        }
    }];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解析：&lt;/p&gt;
&lt;p&gt;self.formData可以自动收集UI表单的内容。&lt;/p&gt;
&lt;p&gt;self.stView loadData 可以自动将字典的数据写回UI中。&lt;/p&gt;
&lt;p&gt;一切就是这么Easy，在这种常规的提交中，批量来批量去，不需要有Model的存在。&lt;/p&gt;
&lt;p&gt;这里暂就不提供Demo了，后续文章再跟进。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    UITextField *userName= [[[self addTextField:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; placeholder:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;手机号码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] width:&lt;span&gt;372&lt;/span&gt; height:&lt;span&gt;68&lt;/span&gt;] onRight:mobileIcon x:&lt;span&gt;30&lt;/span&gt; y:-&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];
    [[userName maxLength:&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;] keyboardType:UIKeyboardTypeNumberPad];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 不用再去这样写的憔碎了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 mobileTF.keyboardType                = UIKeyboardTypeNumberPad;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; UIKeyboardTypeNamePhonePad;&lt;/span&gt;
 mobileTF.MaxLength=&lt;span&gt;11&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                    = (id)self.Controller;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;OC的命名总是很长，做为了一名C#的大神，有义务把C#简洁的语法带过来。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; NSString(ST)

&lt;/span&gt;-(NSString*&lt;span&gt;)reverse;
&lt;/span&gt;-&lt;span&gt;(BOOL)isInt;
&lt;/span&gt;-&lt;span&gt;(BOOL)isFloat;
&lt;/span&gt;-(NSString*)append:(NSString*)&lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;-(NSString*)replace:(NSString*)a with:(NSString*&lt;span&gt;)b;
&lt;/span&gt;-(NSString *)replace:(NSString *)a with:(NSString *&lt;span&gt;)b isCase:(BOOL)isCase;
&lt;/span&gt;-(NSArray&amp;lt;NSString*&amp;gt;*)split:(NSString*&lt;span&gt;)separator;
&lt;/span&gt;-(NSString*&lt;span&gt;)toUpper;
&lt;/span&gt;-(NSString*&lt;span&gt;)toLower;
&lt;/span&gt;-(BOOL)startWith:(NSString*&lt;span&gt;)value;
&lt;/span&gt;-(BOOL)endWith:(NSString*&lt;span&gt;)value;
&lt;/span&gt;-(BOOL)contains:(NSString*&lt;span&gt;)value;
&lt;/span&gt;-(BOOL)contains:(NSString*&lt;span&gt;)value isCase:(BOOL)isCase;
&lt;/span&gt;-&lt;span&gt;(BOOL)isEmpty;
&lt;/span&gt;+(BOOL)isNilOrEmpty:(NSString*&lt;span&gt;)value;
&lt;/span&gt;+(NSString*)toString:(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)value;
&lt;/span&gt;-(NSString*)trim;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1：网络的请求只有三个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[self.http &lt;span&gt;get&lt;/span&gt;&lt;span&gt; ...]
[self.http post ...]
[self.http upload ...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2：消息提示框：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[self.box prompt...]
[self.box alert..]
[self.box confirm...]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其它等。。。就不在这里介绍了，后续会慢慢写文介绍。&lt;/p&gt;

&lt;p&gt;GitHub：&lt;a title=&quot;Sagit.Framework&quot; href=&quot;https://github.com/cyq1162/Sagit&quot; target=&quot;_blank&quot;&gt;https://github.com/cyq1162/Sagit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目前以源码方式提供，并未打包成类库。&lt;/p&gt;
&lt;p&gt;两个原因：&lt;/p&gt;
&lt;p&gt;一是还需要地方需要继续完善升级；&lt;/p&gt;
&lt;p&gt;二来方便有兴趣的同学一起完善。&lt;/p&gt;

&lt;p&gt;1 ：框架刚开源，预示着在未来的日子里，升级与变动是少不了的。&lt;/p&gt;
&lt;p&gt;2：框架只是个基础，完整的项目架构，还需要根据不同的业务搭配不同的第三方类库。&lt;/p&gt;
&lt;p&gt;3：后续会将IT连和IT恋两个App的源码，做为示例教程，和大伙分享。&lt;/p&gt;
&lt;p&gt;4：最后，依然感谢大伙关注我正在进行的IT连创业项目！&lt;/p&gt;
</description>
<pubDate>Wed, 13 Dec 2017 06:47:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/8029864.html</dc:identifier>
</item>
<item>
<title>深入理解ES6之—增强的数组功能 - 寻找石头鱼</title>
<link>http://www.cnblogs.com/xzsty/p/8032745.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xzsty/p/8032745.html</guid>
<description>&lt;h2 id=&quot;array.of方法&quot;&gt;Array.of()方法&lt;/h2&gt;
&lt;p&gt;ES6为数组新增创建方法的目的之一，是帮助开发者在使用Array构造器时避开js语言的一个怪异点。Array.of()方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let arr = Array.of(1, 2);
console.log(arr.length);//2

let arr1 = Array.of(3);
console.log(arr1.length);//1
console.log(arr1[0]);//3

let arr2 = Array.of('2');
console.log(arr2.length);//1
console.log(arr2[0]);//'2'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用Array.of()方法创建数组时，只需将想要包含在数组内的值作为参数传入。&lt;/p&gt;
&lt;h2 id=&quot;array.from方法&quot;&gt;Array.from()方法&lt;/h2&gt;
&lt;p&gt;在js中将非数组对象转换为真正的数组是非常麻烦的。在ES6中，将可迭代对象或者类数组对象作为第一个参数传入，Array.from()就能返回一个数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function arga(...args) {
    let arg = Array.from(arguments);
    console.log(arg);
}

arga('cc', 26, 'man');//['cc',26,'man']&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;映射转换&quot;&gt;映射转换&lt;/h3&gt;
&lt;p&gt;如果你想实行进一步的数组转换，你可以向Array.from()方法传递一个映射用的函数作为第二个参数。此函数会将数组对象的每一个值转换为目标形式，并将其存储在目标数组的对应位置上。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function arga(...args) {
    return Array.from(arguments, value =&amp;gt; value + 1);
}

let arr = arga('cc', 26, 'man');
console.log(arr);//['cc1',27,'man1']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果映射函数需要在对象上工作，你可以手动传递第三个参数给Array.from()方法，从而指定映射函数内部的this值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let helper = {
    diff: 1,
    add(value) {
        return value + this.diff;
    }
}

function translate() {
    return Array.from(arguments, helper.add, helper);
}

let arr = translate('cc', 26, 'man');
console.log(arr);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;可迭代对象上使用&quot;&gt;可迭代对象上使用&lt;/h3&gt;
&lt;p&gt;Array.from()方法不仅可以用于类数组对象，也可用于迭代对象。（Set，Map）&lt;/p&gt;

&lt;h2 id=&quot;find与findindex方法&quot;&gt;find()与findIndex()方法&lt;/h2&gt;
&lt;p&gt;find()与findIndex()方法均接受两个参数：一个回调函数，一个可选值用于指定回调函数内部的this。该回调函数可接受三个参数：数组的某个元素，该元素对应的索引位置，以及该数组本身。该回调函数应当在给定的元素满足你定义的条件时返回true，而find()和findIndex()方法均会在回调函数第一次返回true时停止查找。&lt;/p&gt;
&lt;p&gt;二者唯一的区别是：find()方法返回匹配的值，而findIndex()返回匹配位置的索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1, 2, 3, 'cc', 5, 1, 9];

console.log(arr.find((value, keys, arr) =&amp;gt; {
    return value &amp;gt; 2;
}))//3

console.log(arr.findIndex((value, keys, arr) =&amp;gt; {
    return value &amp;gt; 2;
}))//2&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;fill方法&quot;&gt;fill()方法&lt;/h2&gt;
&lt;p&gt;fill()方法能使用特定值填充数组中的一个或多个元素。当只是用一个参数时，该方法会用该参数的值填充整个数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1, 2, 3, 'cc', 5];
arr.fill(1);
console.log(arr);//[1,1,1,1,1];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不想改变数组中的所有元素，而只是想改变其中一部分，那么可以使用可选的起始位置参数与结束位置参数（不包括结束位置的那个元素）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1, 2, 3, 'cc', 5];

arr.fill(1, 2);
console.log(arr);//[1,2,1,1,1]

arr.fill(0, 1, 3);
console.log(arr);//[1,0,0,1,1];&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;copywithin方法&quot;&gt;copyWithin()方法&lt;/h2&gt;
&lt;p&gt;copyWithin()方法与fill()类似，可以一次性修改数组的多个元素。不过，与fill()使用单个值来填充数组不同，copyWithin()方法允许你在数组内部复制自身元素。为此你需要传递两个参数给copyWithin()方法：从什么位置开始填充，以及被用来复制的数据的起始位置索引。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//将数组的前两个元素复制到数组的最后两个位置
let arr = [1, 2, 3, 'cc', 5];

arr.copyWithin(3, 0);
console.log(arr);//[1,2,3,1,2]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，copyWithin()方法总是会一直复制到数组末尾，不过你还可以提供一个可选参数来限制到底有多少元素会被覆盖。这第三个参数指定了复制停止的位置（不包含该位置本身）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1, 2, 3, 'cc', 5, 9, 17];

//从索引3的位置开始粘贴
//从索引0的位置开始复制
//遇到索引3时停止复制
arr.copyWithin(3, 0, 3);
console.log(arr);//[1,2,3,1,2,3,17]&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;类型化数组是有特殊用途的数组，被设计用来处理数值类型数据。&lt;/p&gt;
&lt;h2 id=&quot;数值数据类型&quot;&gt;数值数据类型&lt;/h2&gt;
&lt;p&gt;类型化数组允许存储并操作八种不同的数值类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;8位有符号整数（int8）&lt;/li&gt;
&lt;li&gt;8位无符号整数（uint8）&lt;/li&gt;
&lt;li&gt;16位有符号整数（int16）&lt;/li&gt;
&lt;li&gt;16位无符号整数（uint16）&lt;/li&gt;
&lt;li&gt;32位有符号整数（int32）&lt;/li&gt;
&lt;li&gt;32位无符号整数（uint32）&lt;/li&gt;
&lt;li&gt;32位浮点数（float32）&lt;/li&gt;
&lt;li&gt;64位浮点数（float64）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所有与类型化数组相关的操作和对象都围绕着这八种数据类型。为了使用它们，你首先需要创建一个数组缓冲区用于存储数据。&lt;/p&gt;
&lt;h2 id=&quot;数组缓冲区&quot;&gt;数组缓冲区&lt;/h2&gt;
&lt;p&gt;数组缓冲区（array buffer）是内存中包含一定数量字节的区域，而所有的类型化数组都基于数组缓冲区。你可以使用下例这样使用ArrayBuffer构造器来创建一个数组缓冲区：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let buffer = new ArrayBuffer(10);//分配了10个字节&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用slice()方法来创建一个新的，包含已有缓冲区部分内容的数组缓冲区。该slice()方法 类似于数组上的同名方法，可以使用起始位置与结束位置参数，返回由原缓冲区元素组成的一个新的ArrayBuffer实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let buffer1 = buffer.slice(2, 5);
console.log(buffer1.byteLength);//3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅仅创建一个缓冲区而不能写入数据没有什么意义。为了写入数据，你需要创建一个视图。&lt;/p&gt;
&lt;h2 id=&quot;使用视图操作数组缓冲区&quot;&gt;使用视图操作数组缓冲区&lt;/h2&gt;
&lt;p&gt;数组缓冲区代表了一块内存区域，而视图则是你操作这块区域的接口。视图工作在数组缓冲区或者其子集上，可以读写某种数值数据类型的数据。DataView类型是数组缓冲区的通用视图，允许你对前述所有八种数值数据类型进行操作。&lt;/p&gt;
&lt;p&gt;使用DataView首先需要创建ArrayBuffer的一个实例，再在上面创建一个新的ArrayBuffer视图&lt;/p&gt;

&lt;p&gt;在我们的开发过程中都有遇到这样的问题：逐个取出数组中的元素。那么在js中有哪些方法可以完成这个工作呢？&lt;/p&gt;
&lt;h2 id=&quot;for循环&quot;&gt;for循环&lt;/h2&gt;
&lt;p&gt;可能我们最先能想到的是for循环了，这也是我们最常用的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1, 2, 3, 4, 5];

for (let i = 0; i &amp;lt; arr.length; i++) {
    console.log(arr[i]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;for-in&quot;&gt;for-in&lt;/h2&gt;
&lt;p&gt;通过键值（索引）来对数组进行遍历&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1, 2, 3, 4, 5];

for (let i in arr) {
    console.log(arr[i]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;foreach&quot;&gt;forEach()&lt;/h2&gt;
&lt;p&gt;forEach()方法是数组对象的原生方法，用于对数组进行遍历，传入的参数是一个回调函数，该回调函数接收三个参数元素值，元素索引和数组对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1, 2, 3, 4, 5];

arr.forEach((value, key, arr) =&amp;gt; console.log(`索引${key}的值是${value}`));&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;for-of&quot;&gt;for-of&lt;/h2&gt;
&lt;p&gt;for-of循环在循环每次执行时会调用可迭代对象的next()方法，并将结果对象的value储存在一个变量上。循环过程会持续到结果对象的done属性编程true为止。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let arr = [1, 2, 3, 4, 5];

for (let num of arr) {
    console.log(num);
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 13 Dec 2017 06:44:00 +0000</pubDate>
<dc:creator>寻找石头鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xzsty/p/8032745.html</dc:identifier>
</item>
<item>
<title>C#设计模式之十九状态模式（State Pattern）【行为型】 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/8032683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/8032683.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   今天我们开始讲“行为型”设计模式的第六个模式，该模式是【状态模式】，英文名称是：State Pattern。无论是现实世界，还是面向对象的OO世界，里面都有一个东西，那就是对象。有对象当然就有状态了。每个对象都有其对应的状态，而每个状态又有对应一些相应的行为，在不同状态下，行为的的方式也是不一样。如果某个对象有多个状态时，那么就会有很多对应的行为。那么对这些状态的判断和根据状态完成的行为，就会导致多重条件语句交织在一起，并且如果添加一种新的状态时，需要更改之前现有的代码。这样的设计显然违背了开闭原则，状态模式正是用来解决这样的问题的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、状态模式的详细介绍&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.1、动机（Motivate）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   在软件构建过程中，某些对象的状态如果改变，其行为也会随之而发生变化，比如文档处于只读状态，其支持的行为和读写状态支持的行为就可能完全不同。&lt;/p&gt;&lt;p&gt;   如何在运行时根据对象的状态来透明地更改对象的行为？而不会为对象操作和状态转化之间引入紧耦合？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2、意图（Intent）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   允许一个对象在其内部状态改变时改变它的行为。从而使对象看起来似乎修改了其行为。　　　　　　                                ——《设计模式》GoF&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.3、结构图（Structure）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;      &lt;img src=&quot;http://images2017.cnblogs.com/blog/1048776/201712/1048776-20171213142649316-954765387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.4、模式的组成&lt;/strong&gt;&lt;br/&gt;    &lt;br/&gt;    可以看出，在状态模式的结构图有以下角色：&lt;/p&gt;&lt;p&gt;    （1）、环境角色（Context）：也称上下文，定义客户端所感兴趣的接口，并且保留一个具体状态类的实例。这个具体状态类的实例给出此环境对象的现有状态。&lt;br/&gt; &lt;br/&gt;    （2）、抽象状态角色（State）：定义一个接口，用以封装环境对象的一个特定的状态所对应的行为。&lt;/p&gt;&lt;p&gt;    （3）、具体状态角色（ConcreteState）：每一个具体状态类都实现了环境（Context）的一个状态所对应的行为。&lt;/p&gt;&lt;p&gt;     &lt;span&gt;在状态模式结构中需要理解环境类与抽象状态类的作用：&lt;/span&gt;&lt;br/&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;     环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(State Manager)的角色，可以在环境类中对状态进行切换操作。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;span&gt;     抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件：这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.5、状态模式的代码实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    状态模式在显示生活中也有类似的例子，例如：我们上网购买商品的过程中，就可以查看订单的状态随时状态。对于商家来说，订单的状态不同，也会允许客户有不同的动作要求，比如：订单在已经处于发货状态，此订单是不能退货的。如果订单在备货阶段，客户是可以换货或者退货的。如果我们的订单已经发货了，您就等着接收货物吧，如果货物有质量问题，可以拒签，或者顺利完成交易，今天我们就以订单为例来说明状态模式的实现。实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; 状态模式的实现
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;环境角色---相当于Context类型&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Order
        {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; State current;

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Order()
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工作状态初始化为上午工作状态&lt;/span&gt;
                current = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitForAcceptance();
                IsCancel &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; minute;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; Minute
            {
                &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; minute; }
                &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { minute =&lt;span&gt; value; }
            }

            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsCancel { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; finish;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; TaskFinished
            {
                &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; finish; }
                &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { finish =&lt;span&gt; value; }
            }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetState(State s)
            {
                current &lt;/span&gt;=&lt;span&gt; s;
            }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Action()
            {
                current.Process(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抽象状态角色---相当于State类型&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; State
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理订单&lt;/span&gt;
            &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process(Order order);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待受理--相当于具体状态角色&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WaitForAcceptance : State
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process(Order order)
            {
                System.Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我们开始受理，准备备货！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (order.Minute &amp;lt; &lt;span&gt;30&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; order.IsCancel)
                {
                    System.Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接受半个小时之内，可以取消订单！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    order.SetState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancelOrder());
                    order.TaskFinished &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    order.Action();
                }
                order.SetState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AcceptAndDeliver());
                order.TaskFinished &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                order.Action();
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;受理发货---相当于具体状态角色&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AcceptAndDeliver : State
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process(Order order)
            {
                System.Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我们货物已经准备好，可以发货了，不可以撤销订单！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (order.Minute &amp;lt; &lt;span&gt;30&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; order.IsCancel)
                {
                    System.Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接受半个小时之内，可以取消订单！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    order.SetState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancelOrder());
                    order.TaskFinished &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    order.Action();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (order.TaskFinished==&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                {
                    order.SetState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Success());
                    order.Action();
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交易成功---相当于具体状态角色&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Success : State
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process(Order order)
            {
                System.Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;订单结算&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                order.SetState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfirmationReceipt());
                order.TaskFinished &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                order.Action();
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确认收货---相当于具体状态角色&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfirmationReceipt : State
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process(Order order)
            {
                System.Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;检查货物，没问题可以就可以签收！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                order.SetState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfirmationReceipt());
                order.TaskFinished &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                order.Action();
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消订单---相当于具体状态角色&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CancelOrder : State
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Process(Order order)
            {
                System.Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;检查货物，有问题，取消订单！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                order.SetState(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancelOrder());
                order.TaskFinished &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                order.Action();
            }
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main(String[] args)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;订单&lt;/span&gt;
                Order order = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Order();
                order.Minute &lt;/span&gt;= &lt;span&gt;9&lt;/span&gt;&lt;span&gt;;
                order.Action();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以取消订单&lt;/span&gt;
                order.IsCancel = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                order.Minute &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
                order.Action();
                order.Minute &lt;/span&gt;= &lt;span&gt;33&lt;/span&gt;&lt;span&gt;;
                order.Action();
                order.Minute &lt;/span&gt;= &lt;span&gt;43&lt;/span&gt;&lt;span&gt;;
                order.Action();

                Console.WriteLine();
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;br/&gt;&lt;strong&gt;三、状态模式的实现要点：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    State模式将所有与一个特定状态相关的行为都放入一个State的子类对象中，在对象状态切换时，切换相应的对象；但同时维持State的接口，这样实现了具体操作与状态转换之间的解耦。&lt;/p&gt;&lt;p&gt;为不同的状态引入不同的对象使得状态转换变得更加明确，而且可以保证不会出现状态不一致的情况，因为转换是原子性的——即要么彻底转换过来，要么不转换。&lt;/p&gt;&lt;p&gt;如果State对象没有实例变量，那么各个上下文可以共享同一个State对象，从而节省对象开销。&lt;/p&gt;&lt;p&gt;   &lt;strong&gt;（1）、状态模式的优点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;          封装了转换规则。&lt;/p&gt;&lt;p&gt;          枚举可能的状态，在枚举状态之前需要确定状态种类。&lt;/p&gt;&lt;p&gt;         将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。&lt;/p&gt;&lt;p&gt;          允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。&lt;/p&gt;&lt;p&gt;          可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。&lt;/p&gt;&lt;p&gt;   &lt;strong&gt;（2）、状态模式的缺点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         状态模式的使用必然会增加系统类和对象的个数。&lt;/p&gt;&lt;p&gt;         状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。&lt;/p&gt;&lt;p&gt;         状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。&lt;/p&gt;&lt;p&gt;    &lt;strong&gt;（3）、在以下情况下可以使用状态模式&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;           对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。&lt;/p&gt;&lt;p&gt;          代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态&lt;/p&gt;&lt;p&gt;&lt;strong&gt;四、.NET 状态模式的实现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     状态模式在Net里面的实现还没有研究透，如果以后有了新的学习内容，再补充进来。但是我感觉，这个模式可能在业务系统里面有更大的使用。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    好了，今天就写到这里了。由于最近感冒了，有几天没写东西了。今天写点东西，只是写的有点慢了。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Dec 2017 06:28:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/8032683.html</dc:identifier>
</item>
<item>
<title>Android开发之漫漫长途 Ⅶ——Android消息机制(Looper Handler MessageQueue Message) - 忘了12138</title>
<link>http://www.cnblogs.com/wangle12138/p/8032687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangle12138/p/8032687.html</guid>
<description>&lt;p&gt;&lt;em&gt;该文章是一个系列文章，是本人在Android开发的漫漫长途上的一点感想和记录，我会尽量按照先易后难的顺序进行编写该系列。该系列引用了《Android开发艺术探索》以及《深入理解Android 卷Ⅰ，Ⅱ，Ⅲ》中的相关知识，另外也借鉴了其他的优质博客，在此向各位大神表示感谢，膜拜！！！另外，本系列文章知识可能需要有一定Android开发基础和项目经验的同学才能更好理解，也就是说该系列文章面向的是Android中高级开发工程师。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上一篇我们介绍了LeakCanary工具用来分析内存泄漏以及谈了下几种常见内存泄漏的表现和解决方法。本篇内容我们来分析Android的消息机制。我们为什么要介绍Android的消息机制呢，因为&lt;strong&gt;Android系统本质上来说就是一个消息驱动的系统&lt;/strong&gt;。我们在开发中什么时候会用到Handler呢，工作年限较长的开发工程师应该对这个Handler很熟悉了，因为在早期的开发中，无论是网络请求刷新UI还是子线程耗时任务的通知的应用场景都能看到Handler的身影。现在Handler在我们的日常开发中少了一些，因为我们有了RxJava、Retrofit等对Handler进行了很精美的封装。但是理解Android的消息机制对于理解Android系统的运作包括那些开源框架的原理都有很大帮助。&lt;/p&gt;
&lt;p&gt;关于Android的消息机制网上也有好多文章，我本人也看了好多。但是不仅没有让我更清晰明了，反而让我陷入更深的迷惑。本篇的目的在于以一种相对更容易理解的方式来解释。&lt;/p&gt;
&lt;p&gt;我们先来模拟一个场景，在Activity中执行了耗时操作，耗时操作完成之后显示一个Toast。这种应用场景还是比较常见的。我们来模拟代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MessageActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_message);
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //模拟耗时操作
                    Thread.sleep(3* 60 * 1000);
                    //耗时操作完成之后显示一个通知
                    Toast.makeText(MessageActivity.this,&quot;test&quot;,Toast.LENGTH_SHORT).show();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来运行上面的代码。呦呵，崩溃了，我们查看日志得到以下信息。&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/7kDIZkw.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于上面的崩溃我们稍后分析。&lt;/p&gt;

&lt;p&gt;既然讨论Android 消息机制，如果我们所有的操作都能在一个线程中完成貌似就不需要这个消息处理机制了，，但这又是不现实的，正是因为我们不能在一个线程中把所有的工作（网络请求、耗时操作、更新UI）在一个线程中完成，我们才有了多线程，多线程的互相协作才造就了我们这个Android欣欣向荣的世界。由此我们不得不说到我们Android App中的&lt;strong&gt;主线程（UI）线程，关于这个线程的叫法有很多。读者只需要知道不能在这个线程之外的线程直接对UI进行操作就行了&lt;/strong&gt;。Android 4.0 以上甚至不能在主线程中（UI线程）中进行网络操作。否则的话会报&lt;strong&gt;android.os.NetworkOnMainThreadException&lt;/strong&gt;，这个错误大家应该都见过把。那我们就从这个&lt;strong&gt;主线程（UI线程说起）&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    ......
    //1 创建Looper 和 MessageQueue，本来该线程也是一个普通的线程，但是创建了Looper以及结合后文的Looper.loop()方法，使这个线程成为了Looper线程(读者可以简单的理解为拥有Looper的线程，而这个Looper就是Android消息处理机制的一部分)。
    Looper.prepareMainLooper();

    //2 建立与AMS的通信
    ActivityThread thread = new ActivityThread();
    thread.attach(false);


    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }


    ......
    //3 无限循环
    Looper.loop();
    //可以看出来主线程也是在无限的循环的，异常退出循环的时候会报错. 
    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建looper-和-messagequeue&quot;&gt;1 创建Looper 和 MessageQueue&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public final class Looper {
    
    ......
    public static void prepare() {
        prepare(true);
    }
    
    //prepare 函数 
    private static void prepare(boolean quitAllowed) {
        //判断sThreadLocal.get()是否为空，如果不为空说明已经为该线程设置了Looper，不能重复设置。
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
        }
        //如果sThreadLocal.get()为空，说明还没有为该线程设置Looper，那么创建Looper并设置
        sThreadLocal.set(new Looper(quitAllowed));
    }

    //ActivityThread 调用Looper.prepareMainLooper();该函数调用prepare(false);
    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
            }
            sMainLooper = myLooper();
        }
    }

 
    public static Looper getMainLooper() {
        synchronized (Looper.class) {
            return sMainLooper;
        }
    }




    ......
   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里呢有个静态变量&lt;strong&gt;sThreadLocal&lt;/strong&gt;,它的定义如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static final ThreadLocal&amp;lt;Looper&amp;gt; sThreadLocal = new ThreadLocal&amp;lt;Looper&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们就得来讲解ThreadLocal这个类：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。这里线程自己的本地存储区域存放是线程自己的Looper。&lt;/strong&gt;简单的来说就是通过ThreadLocal来进行Looper的统一存储和读取。那么接着来看被ThreadLocal存储的对象Looper的构造函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//Looper的构造函数
private Looper(boolean quitAllowed) {
    //这里创建了MessageQueue
    mQueue = new MessageQueue(quitAllowed);
    
    mThread = Thread.currentThread();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里创建了MessageQueue为后续的步骤做准备，MessageQueue可以简单理解为一个&lt;strong&gt;“队列”&lt;/strong&gt;（其底层实际上是一个单向链表），之所以是打上引号的&lt;strong&gt;“队列”&lt;/strong&gt;，是因为其并不是严格意义上的队列，而是一个单项链表，使用者可以根据节点的优先级等等插入该链表。链表上的节点就是Message。第①步 整个的结构图如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sLWPXLs.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;建立与ams的通信&quot;&gt;2 建立与AMS的通信&lt;/h2&gt;
&lt;p&gt;关于这一部分内容必须得对Android Binder知识有相关了解才能更好的理解。我们下一篇就会讲解Android Binder，到时候我们在回来这里。&lt;/p&gt;
&lt;h2 id=&quot;无限循环&quot;&gt;3 无限循环&lt;/h2&gt;
&lt;p&gt;在上面的工作中我们已经准备好Looper和MessageQueue，下面就有了两个问题，① Message从何而来，② Message如何处理。&lt;/p&gt;
&lt;h3 id=&quot;message&quot;&gt;Message&lt;/h3&gt;
&lt;p&gt;我们在讨论Message的来源以及如何处理之前，先来看一下Message类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Message{
    //消息码
    public int what;
    //handler
    Handler target;
    //下一级节点
    Message next;
    //消息发送的时间
    long when;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码也从侧面证明了我们的MessageQueue是一个由Message组成的单向链表&lt;/p&gt;
&lt;p&gt;我们先来看Message如何处理，至于为什么，当然是保证因为我们的思路不被打断，我们先分析ActivityThread的最后Looper.loop()函数做了什么。&lt;/p&gt;
&lt;h3 id=&quot;message如何处理&quot;&gt;② Message如何处理&lt;/h3&gt;
&lt;p&gt;我们来到了ActivityThread的最后一步Looper.loop()&lt;br/&gt;ActivityThread.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void loop() {
    //得到Looper
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn't called on this thread.&quot;);
    }
    //得到MessageQueue
    final MessageQueue queue = me.mQueue;

    ......
    for (;;) {//无限循环
        Message msg = queue.next(); // 取下一个Message 可能阻塞在这里
        if (msg == null) {
            //如果队列为空直接return直接结束了该方法，即循环结束
            return;
        }
        ......
       
        
        try {
            //分发message到指定的target handler
            msg.target.dispatchMessage(msg);
            ......
        } finally {
           
        }
        
        ......
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主线程由此进入无限循环等待消息，有人看到这里就由疑问了，执行到for循环时，不就“卡死”在这个无限循环内了吗？其他的操作无法得到CPU怎么执行呢？关键点就在于&lt;strong&gt;queue.next()&lt;/strong&gt;方法。&lt;br/&gt;为了更好的理解这个方法我们先来讲一下关于线程阻塞与唤醒的知识&lt;/p&gt;
&lt;h4 id=&quot;线程阻塞&quot;&gt;线程阻塞&lt;/h4&gt;
&lt;p&gt;什么是阻塞呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。结合我们上面的代码。我们的代码运行Message msg = queue.next();这一句时，主线程可能一直阻塞在这里等待消息的到来(它去睡觉去了，也就是说我们的主线程，居然是大部分时间都在睡觉，心真大啊)。&lt;/p&gt;
&lt;p&gt;注：&lt;strong&gt;线程阻塞跟线程忙循环轮询是有本质区别的，不要听到线程阻塞就以为是CPU一直在无限循环轮询状态啊。线程阻塞是不占用CPU资源的，但是线程忙循环轮询就不一样了，将几乎占满CPU资源。什么是CPU资源，简单的来说CPU资源就是分配给程序的执行时间。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;线程唤醒&quot;&gt;线程唤醒&lt;/h4&gt;
&lt;p&gt;要想把主线程活动起来一般有两种方式：一种是系统唤醒主线程，并且将点击事件传递给主线程；第二种是其他线程使用Handler向MessageQueue中存放了一条消息，导致loop被唤醒继续执行。在下面的&lt;strong&gt;Message从何而来&lt;/strong&gt;中我们这里使用了hander向MessageQueue中存放了一条消息，导致loop被唤醒继续执行。&lt;/p&gt;
&lt;h3 id=&quot;message从何而来&quot;&gt;① Message从何而来&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class MessageActivity extends AppCompatActivity {

    private Handler mHandler= new Handler(){
        //处理消息
        @Override
        public void handleMessage(Message msg) {
            handleMsg(msg);
        }

    };
    private void handleMsg(Message msg) {
        switch (msg.what){
            case 0:
                Toast.makeText(this,&quot;成功&quot;,Toast.LENGTH_SHORT).show();
                break;
        }
    }
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_message);
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //模拟耗时操作
                    Thread.sleep(3*1000);
                    //发送消息
                    mHandler.sendEmptyMessage(0);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们经常使用上面的代码来做耗时操作，那么这里这里我们的猪脚就出场了，mHandler是Handler的对象。我们来看一下Handler类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Handler { 
    //handler类有个Looper
    final Looper mLooper;
    //handler类有个MessageQueue
    final MessageQueue mQueue;
    //handler类有个Callback
    final Callback mCallback;
    

    public Handler() {//我们使用的是这一个
        this(null, false);
    }


    public Handler(Callback callback) {
        this(callback, false);
    }

   
    public Handler(Looper looper) {
        this(looper, null, false);
    }

  
    public Handler(Looper looper, Callback callback) {
        this(looper, callback, false);
    }

    public Handler(boolean async) {
        this(null, async);
    }

  
    public Handler(Callback callback, boolean async) {
        //这里获取主线程的Looper，Handler的mLooper指向ThreadLocal内的Looper对象
        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &quot;Can't create handler inside thread that has not called Looper.prepare()&quot;);
        }
        //这里获取主线程的Looper的MessageQueue，Handler的mQueue指向ThreadLocal内Looper对象内的MessageQueue对象
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }

  
    public Handler(Looper looper, Callback callback, boolean async) {
        mLooper = looper;
        mQueue = looper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }



}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建Handler 之后就调用 mHandler.sendEmptyMessage(0);发送消息（Handler的发送消息的方式有好多种，但这不是我们的重点），最终调用到Handler enqueueMessage 方法&lt;br/&gt;Handler.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    设置msg.target 为当前Handler对象
    msg.target = this;
    ......
    //调用MessageQueue的enqueueMessage()方法
    return queue.enqueueMessage(msg, uptimeMillis);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再来看一下MessageQueue的enqueueMessage()&lt;br/&gt;MessageQueue.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean enqueueMessage(Message msg, long when) {
    ......

    synchronized (this) {
       ......
        
        msg.when = when;
        Message p = mMessages;
        //检测当前头指针是否为空（队列为空）或者没有设置when 或者设置的when比头指针的when要前
        if (p == null || when == 0 || when &amp;lt; p.when) {
            //插入队列头部，并且唤醒线程处理msg
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
           // 几种情况要唤醒线程处理消息：1）队列是堵塞的 2)barrier，头部结点无target 3）当前msg是堵塞的
            needWake = mBlocked &amp;amp;&amp;amp; p.target == null &amp;amp;&amp;amp; msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when &amp;lt; p.when) {
                    break;
                }
                if (needWake &amp;amp;&amp;amp; p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p; // 将当前msg插入第一个比其when值大的结点前。
            prev.next = msg;
        }

        //调用Native方法进行底层操作，在这里把那个沉睡的主线程唤醒
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的Handler在发送消息的时候把自身设置给了msg.target,发送消息并唤醒Looper，Looper被唤醒后便使用&lt;strong&gt;queue.next()&lt;/strong&gt;取出Message,并根据msg.target进行派发。Handler整体过程如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/MPoIafm.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/c6BZq4e.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再稍微看下Handler的dispatchMessage方法&lt;br/&gt;Handler.java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void dispatchMessage(Message msg) {
    
    if (msg.callback != null) {//判断有没有为Message设置callback（这里的callback是个Runnable接口，我们在为Message设置callback的时候需要自己实现run方法）,如果设置了，那么调用Runnable实例的run方法
        handleCallback(msg);
    } else {
        if (mCallback != null) {//判断Handler的mCallback是否为空（这里的Handler是个Callback接口，我们在为Handler设置mCallback的时候需要自己实现handleMessage方法）,如果设置了，那么调用Callback实例的handleMessage方法
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        //调用handleMessage方法
        handleMessage(msg);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在创建Handler使用的是无法构造函数，并重写了handleMessage方法，所以我们的重写的handleMessage得到调用，弹出了Toast&lt;/p&gt;

&lt;p&gt;本篇比较详细的介绍了Android的消息机制，不过有一部分内容需要其他的知识作为基础才能更好的理解。不过这不影响我们分析Android的消息机制的整个流程。我们在这里再梳理一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 主线程准备Looper和MessageQueue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 创建一个线程（因为下面我们进入死循环了，所以在这之前创建一个线程用来处理，这是个Binder线程）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 主线程进入无限循环等待并处理消息。（这个消息可能是系统本身的消息，也有可能是我们自己的消息。在本例中分析的是我们自己创建的Handler发送的消息。）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们再上个整图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/DZwBUCG.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里呢我们呢是使用Activity的创建作为分析，因为这是Activity的起点。在注释第2步中的代码&lt;strong&gt;sendMessage(H.LAUNCH_ACTIVITY, r);&lt;/strong&gt;与我们例子中 &lt;strong&gt;mHandler.sendEmptyMessage(0);&lt;/strong&gt;并没有什么大的不同。&lt;/p&gt;
&lt;p&gt;现在也是揭晓我们文章开头的那个崩溃的秘密的时候了，相信读者也有答案了。没错，是&lt;strong&gt;因为我们在非UI线程中更新了UI,导致了异常。&lt;/strong&gt;原因是我们在子线程没有Looper啊。你可以做出如下更改就不会有异常了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MessageActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_message);
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    //模拟耗时操作
                    Thread.sleep(3* 60 * 1000);
                    
                    //在子线程中更新UI之前，先准备一个Looper，与主线程相同
                    if (Looper.myLooper() != null){
                        Looper.prepare();
                    }
                    //耗时操作完成之后显示一个通知
                    Toast.makeText(MessageActivity.this,&quot;test&quot;,Toast.LENGTH_SHORT).show();

                    //无限循环
                    Looper.loop();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;好了，我们下一篇介绍Android的Binder，Binder是个大工程哈。。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;此致，敬礼&lt;/p&gt;
</description>
<pubDate>Wed, 13 Dec 2017 06:28:00 +0000</pubDate>
<dc:creator>忘了12138</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangle12138/p/8032687.html</dc:identifier>
</item>
<item>
<title>Vue单页面骨架屏实践 - MonkeyWang</title>
<link>http://www.cnblogs.com/tiedaweishao/p/8032337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiedaweishao/p/8032337.html</guid>
<description>&lt;p&gt;github 地址： &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/VV-UI/VV-UI&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;VV-UI/VV-UI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;演示地址: &lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//vv-ui.github.io/VV-UI/%23/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;vv-ui&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档地址：&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//vv-ui.github.io/VV-UI/%23/skeleton&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;skeleton&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;关于骨架屏介绍&lt;/h2&gt;
&lt;p&gt;骨架屏的作用主要是在网络请求较慢时，提供基础占位，当数据加载完成，恢复数据展示。这样给用户一种很自然的过渡，不会造成页面长时间白屏或者闪烁等情况。 常见的骨架屏实现方案有&lt;code&gt;ssr&lt;/code&gt;服务端渲染和&lt;code&gt;prerender&lt;/code&gt;两种解决方案。这里主要通过代码为大家展示如何一步步做出这样一个骨架屏：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/578730/201712/578730-20171213130637285-312769608.png&quot; alt=&quot;&quot; width=&quot;288&quot; height=&quot;513&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;prerender 渲染骨架屏&lt;/h2&gt;
&lt;p&gt;本组件库骨架屏的实现也是基于预渲染去实现的，有关于预渲染更详细的介绍请参考这篇文章：&lt;a class=&quot;internal&quot; href=&quot;https://zhuanlan.zhihu.com/p/29148760&quot;&gt;处理 Vue 单页面 Meta SEO的另一种思路&lt;/a&gt; 下面我们主要介绍其实现步骤，首先我们也是需要配置webpack-plugin，不过已经有实现好的&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/chrisvfritz/prerender-spa-plugin&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;prerender-spa-plugin&lt;/a&gt;可用&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
var path = require('path')
var PrerenderSpaPlugin = require('prerender-spa-plugin')

module.exports = {
  // ...
  plugins: [
    new PrerenderSpaPlugin(
      // Absolute path to compiled SPA
      path.join(__dirname, '../dist'),
      // List of routes to prerender
      ['/']
    )
  ]
}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;然后写好我们的骨架屏文件&lt;code&gt;main.skeleton.vue&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;main-skeleton&quot;&amp;gt;
    &amp;lt;w-skeleton height=&quot;80px&quot;&amp;gt;&amp;lt;/w-skeleton&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;div class=&quot;skeleton-container&quot;&amp;gt;
        &amp;lt;div class=&quot;skeleton&quot;&amp;gt;
          &amp;lt;w-skeleton height=&quot;300px&quot;&amp;gt;&amp;lt;/w-skeleton&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;w-skeleton height=&quot;45px&quot;&amp;gt;&amp;lt;/w-skeleton&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;skeleton-bottom&quot;&amp;gt;
        &amp;lt;w-skeleton height=&quot;45px&quot;&amp;gt;&amp;lt;/w-skeleton&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;当初次进入页面的时候我们需要显示骨架屏，数据加载完，我们需要移除骨架屏：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;mainSkeleton v-if=&quot;!init&quot;&amp;gt;&amp;lt;/mainSkeleton&amp;gt;
    &amp;lt;div v-else&amp;gt;
      &amp;lt;div class=&quot;body&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
 import mainSkeleton from './main.skeleton.vue'

  export default {
    name: 'app',
    data () {
      return {
        init: false
      }
    },
    mounted () {
      //  这里模拟数据请求
      setTimeout(() =&amp;gt; {
        this.init = true
      }, 250)
    },
    components: {
      mainSkeleton
    }
  }
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;ssr 渲染骨架屏&lt;/h2&gt;
&lt;p&gt;下面我用我灵魂画师的笔法，画出了大致的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/578730/201712/578730-20171213130913410-515409301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;首先创建我们的&lt;code&gt;skeleton.entry.js&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
import Vue from 'vue';
import Skeleton from './skeleton.vue';

export default new Vue({
    components: {
        Skeleton
    },
    template: '&amp;lt;skeleton /&amp;gt;'
}); 
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;当然这里的&lt;code&gt;skeleton.vue&lt;/code&gt;使我们事先写好的骨架屏组件，看起来可能是这样：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
 &amp;lt;template&amp;gt;
    &amp;lt;div class=&quot;skeleton-wrapper&quot;&amp;gt;
        &amp;lt;header class=&quot;skeleton-header&quot;&amp;gt;&amp;lt;/header&amp;gt;
        &amp;lt;div class=&quot;skeleton-block&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;然后我们需要的是能把&lt;code&gt;skeleton.entry.js&lt;/code&gt;编译成服务端渲染可用的&lt;code&gt;bundle&lt;/code&gt;文件，所以我们需要有个编译骨架屏的&lt;code&gt;webpack.ssr.conf.js&lt;/code&gt;文件:&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const path = require('path');
const merge = require('webpack-merge');
const baseWebpackConfig = require('./webpack.base.conf');
const nodeExternals = require('webpack-node-externals');

function resolve(dir) {
    return path.join(__dirname, dir);
}

module.exports = merge(baseWebpackConfig, {
    target: 'node',
    devtool: false,
    entry: {
        app: resolve('./src/skeleton.entry.js')
    },
    output: Object.assign({}, baseWebpackConfig.output, {
        libraryTarget: 'commonjs2'
    }),
    externals: nodeExternals({
        whitelist: /\.css$/
    }),
    plugins: []
});
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;接下来最终的步骤，就是编写我们的webpackPlugin，我们期望我们的webpackPlugin可以帮我们把入口文件编译成bundle，然后再通过&lt;code&gt;vue-server-renderer&lt;/code&gt;来render bundle，最终产出响应的html片段和css片段，这里贴出核心代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
// webpack start to work
    var serverCompiler = webpack(serverWebpackConfig);
    var mfs = new MFS();
    // output to mfs
    serverCompiler.outputFileSystem = mfs;
    serverCompiler.watch({}, function (err, stats) {

        if (err) {
            reject(err);
            return;
        }

        stats = stats.toJson();
        stats.errors.forEach(function (err) {
            console.error(err);
        });
        stats.warnings.forEach(function (err) {
            console.warn(err);
        });

        var bundle = mfs.readFileSync(outputPath, 'utf-8');
        var skeletonCss = mfs.readFileSync(outputCssPath, 'utf-8');
        // create renderer with bundle
        var renderer = createBundleRenderer(bundle);
        // use vue ssr to render skeleton
        renderer.renderToString({}, function (err, skeletonHtml) {
            if (err) {
                reject(err);
            }
            else {
                resolve({skeletonHtml: skeletonHtml, skeletonCss: skeletonCss});
            }
        });
    });
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;最后一步，我们对产出的html片段, css片段进行组装，产出最终的html，所以我们需要监听webpack 的编译挂载之前的事件：&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
compiler.plugin('compilation', function (compilation) {

    // add listener for html-webpack-plugin
    compilation.plugin('html-webpack-plugin-before-html-processing', function (htmlPluginData, callback) {
        ssr(webpackConfig).then(function (ref) {
            var skeletonHtml = ref.skeletonHtml;
            var skeletonCss = ref.skeletonCss;

            // insert inlined styles into html
            var headTagEndPos = htmlPluginData.html.lastIndexOf('&amp;lt;/head&amp;gt;');
            htmlPluginData.html = insertAt(htmlPluginData.html, (&quot;&amp;lt;style&amp;gt;&quot; + skeletonCss + &quot;&amp;lt;/style&amp;gt;&quot;), headTagEndPos);

            // replace mounted point with ssr result in html
            var appPos = htmlPluginData.html.lastIndexOf(insertAfter) + insertAfter.length;
            htmlPluginData.html = insertAt(htmlPluginData.html, skeletonHtml, appPos);
            callback(null, htmlPluginData);
        });
    });
 });
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;关于：&lt;/h2&gt;
&lt;p&gt;作者：monkeyWang&lt;/p&gt;

&lt;p&gt;本文参考文章：&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//xiaoiver.github.io/coding/2017/07/30/%25E4%25B8%25BAvue%25E9%25A1%25B9%25E7%259B%25AE%25E6%25B7%25BB%25E5%258A%25A0%25E9%25AA%25A8%25E6%259E%25B6%25E5%25B1%258F.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;为vue项目添加骨架屏&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文源码详见：&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//github.com/VV-UI/VV-UI&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;VV-UI/VV-UI&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本人主页：&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//monkeywangs.github.io/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;monkeyWang&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;微信公众号：前端知识铺&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/578730/201712/578730-20171213131120847-1057625289.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会不定期推送前端技术文章，欢迎关注&lt;/p&gt;
</description>
<pubDate>Wed, 13 Dec 2017 05:12:00 +0000</pubDate>
<dc:creator>MonkeyWang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiedaweishao/p/8032337.html</dc:identifier>
</item>
<item>
<title>Require,js配置使用心得 - style'me</title>
<link>http://www.cnblogs.com/liningstyle/p/8032294.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liningstyle/p/8032294.html</guid>
<description>&lt;p&gt;首先大家要知道requirejs是干嘛用的，要解释，那就用一句话说下：RequireJS是一个JavaScript文件和模块加载器&lt;/p&gt;&lt;p&gt;接下来我们开始学会配置使用requireJs，当然在学习使用的过程中也遇到了很多坑，不管是百度还是什么方法最终解决了，所以分享给大家，也方便下次使用时忘掉！&lt;/p&gt;&lt;p&gt;1、首页看一下我自己建的项目目录结构，这对接下来配置requireJs有很大的作用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213125620738-12833348.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、下载requireJs及requireJs-text.js，将requirejs引入html文件中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213125653176-1993505298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置async=&quot;true&quot;的作用很明显和jq的ajax中async：true的目的是一样的，就是一边加载RequireJs一边执行它，如果设置为false的话则会等待ReuireJs完全加载完成采取执行它的方法，这会有很大可能导致页面刚开始一片空白，对于一个开发者来说，好像不是很友好。当然如果你script标签不在head里而在页面的最尾部，那你设不设置都是一样的，因为他最好才会加载，我并不建议大家这样做；data-main=&quot;scripts/main&quot;的作用是申明RequireJs会去scripts目录下去找main.js文件，通常main.js是项目目录以及全局配置文件，这里也不例外&lt;br/&gt;3、接下来我们该设置全局配置以及文件路劲了（main.js）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213125744863-298288884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;baseUrl    是设置你项目的路径，在接下来的路劲配置中都会以baseUrl设置的路劲作为相对路径去查找，请注意，这是我的文件目录下，我的require.js和全局配置文件（main.js）都是放在scripts目录下的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213125807504-995923140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;paths   是预加载js文件的配置项，一般情况都是不用写后缀名的，当然你的注意你的文件路劲，这里是我的文件路径，我的所有本地脚本都放在了js文件夹下，所以就是相对baseUrl的路径的上一目录的js目录下，&lt;br/&gt;你也可以引入html文件，在引入hrml文件是你的确保你已经有并且引入text.js文件了，当然我把text.js放在了scripts目录下，所以之间去找同级就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213125853879-753718015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;waitSeconds  设置的数值的作用的在这个时间段内如果没有加载成功或路径没有找到RequireJs会自己认为加载失败&lt;br/&gt;4、现在我们看看如何引入css全局文件以及按需加载响应文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213125919597-693718988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就像图片上看到的一样，必须设置map为全局（*）配置css的引入js，我的这个js文件显然是放在baseUrl的同级目录下的，文件名为：css.min，这个是引入css必须的文件&lt;br/&gt;加下来你会看到shim选项下有一个Btn数组配置了一堆css路劲，而这个Btn你也会发现在paths选项下我有配置，引入了自己的一个js，在这个js（Setting.js）是我项目必须要使用到的全局js文件，可以是我自己封装的方法以及第三方方法之类的，使用它做键值名的原因就是当我执行或者使用这个js文件是，下面数组里我配置的css文件就会全部引入到页面，好处很明显就是可以用作全局样式的引入&lt;br/&gt;下面的bootstrap以及swiper的就是按需加载方法的例子，前面的jquery说明bootstrap是要依赖于jquery的，使用css!的方法就是会去相对路径去找这个css，而你会发现bootstrap的对象名适合上面paths配置项下的bootstrap的配置名是一致的，特别需要注意的是你的文件的路径，这里是我的项目目录所对应的文件路径。&lt;br/&gt;当然你也可以使用这种方法去当个加载一个css样式，但是这是非常麻烦的&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
define([&quot;require&quot;], function(require) {
    var cssUrl = require.toUrl(&quot;./css/Style.css&quot;);
    var link = document.createElement(&quot;link&quot;);
    link.type = &quot;text/css&quot;;
    link.rel = &quot;stylesheet&quot;;
    link.href = cssUrl;
    document.getElementsByTagName(&quot;head&quot;)[0].appendChild(link);
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5、接下来就是你该如何使用刚才配置的js以及css了&lt;br/&gt;Requirejs提供的方法很简单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
require( ['jquery','bootstrap','Btn'],function($,bootstrap,Btn) {
    console.log(Btn)
    $('#Nav').html('style'me)
})  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　你会发现对象的参数都是你刚才配置文件路径起的名字，就是jquery,后面函数的参数适合对象里的参数一一对应的，像jquery使用的是$，那我们传$就代表着在方法内我们已经可以使用jquery方法了，Btn是我的全局本地js文件，不做任何操作只需要引进来就行了，这时候我们在Btn配置的js中也就是Setting.js直接可以使用jquery的方法了，也就是启动了RequireJs，看图，bootstrap已经可以用了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213130113926-1502647573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而且我Setting.js的方法生效啦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213130140629-1100355887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器显示点击黑色的盒子已经执行的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213130220176-460362421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、接下来就是如何引入以及使用html的模板了&lt;br/&gt;首先你会看到我已经在paths下配置过两个html页面了，名字分别为page1和page2，在这个基础上配置了text的选项，因为引入html文件是依赖text.js的&lt;br/&gt;用法也很简单，跟启动RequireJs一样的，需要传参到数组里，并且在函数里传入相应的参数就可以使用了&lt;br/&gt;这是text.html和test1.html两个文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213130326926-1509906077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213130339847-1762482356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数接收传入直接使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
require( ['jquery','bootstrap','Btn','text!page1','text!page2'],function($,bootstrap,Btn,template,template1) {
    $('#Btn').bind('click',function(){
        $('#Nav').html(template)
    })
    $('#Btn1').bind('click',function(){
        $('#Nav').html(template1)
    })
}) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　点击两个按钮可以分别加载不同的html模板到页面来也是不错的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213130441097-463731699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1137381/201712/1137381-20171213130449988-679276076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，就先说这些，当然还有很多，比如说r.js打包，build.js配置，欢迎留言交流！&lt;/p&gt;

&lt;p&gt;//想一起学习交流的欢迎来qq群：565996731&lt;br/&gt;（申请注明来自博客园）&lt;/p&gt;
</description>
<pubDate>Wed, 13 Dec 2017 04:55:00 +0000</pubDate>
<dc:creator>style&amp;#39;me</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liningstyle/p/8032294.html</dc:identifier>
</item>
<item>
<title>继webpack后又一打包神器Parcel - PC.aaron</title>
<link>http://www.cnblogs.com/aaron-pan/p/8032226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aaron-pan/p/8032226.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　在继grunt、gulp实现自动化构建之后，webpack又引领前端打包潮流，众所周知的是，vue-cli的脚手架就是基于webpack进行项目打包的。而webpack还在上升的势头的时候，又一打包神器横空出世——parcel。&lt;/p&gt;
&lt;h2&gt;Parcel&lt;/h2&gt;
&lt;h3&gt;快速，零配置的 Web 应用程特性　　&lt;/h3&gt;
&lt;p&gt;　　快速打包&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;　　　　&lt;/em&gt;&lt;/em&gt;Parcel 使用工作进程启用多核编译，并具有文件系统缓存，即使在重新启动后也可快速重新构建。&lt;br/&gt;　　打包所有资源&lt;br/&gt;　　　　Parcel 支持JS，CSS，HTML，文件资源等等 - 不需要安装任何插件。&lt;br/&gt;　　自动转换&lt;br/&gt;　　　　在需要时，代码使用 Babel，PostCSS 和 PostHTML 自动转换 - 即使是 node_modules。&lt;br/&gt;　　零配置代码拆分&lt;br/&gt;　　　　Parcel 使用动态 import() 语法拆分您的输出包，所以只加载初始加载时所需的内容。&lt;br/&gt;　　模块热替换&lt;br/&gt;　　　　当你在开发过程中进行更改时，Parcel 会自动更新浏览器中的模块，不需要进行任何配置。&lt;br/&gt;　　友好的错误记录&lt;br/&gt;　　　　遇到错误时，Parcel 会以语法高亮的形式打印的代码帧，以帮助你查明问题。&lt;/p&gt;
&lt;h3&gt;为啥用 parcel？&lt;/h3&gt;
&lt;p&gt;　　现在有很多Web应用程序打包工具，包括webpack 和 browserify。所以，我们为什么还需要一个呢？主要的原因是围绕开发者的经验。　&lt;/p&gt;
&lt;p&gt;　　很多打包工具都围绕配置和插件进行构建的，因此看到有500行以上配置的应用程序正常运行并不罕见。这种配置不仅繁琐和费时，而且也很难得到正确的配置，必须为每个应用程序复制。通常情况下，这可能导致次优化的应用程序发送到生产环境。parcel 被设计为零配置：只要将它指向你的应用程序的入口点，它就能做正确的事情。&lt;br/&gt;　　现有的打包工具大多都执行得慢，具有很多文件和依赖的大型应用将花费数分钟去构建，随着时间的推移，这将会相当痛苦的事情。监听文件变更能帮助重新编译，当时初始构建的时候通常还是会很慢。parcel 利用现代的多核处理能力和工作线程去并行编译你的代码。这导致了初始构建的速度极大的提升。它还有一个文件系统缓存，可以保存每个文件的编译结果，以便更快的后续启动。&lt;br/&gt;　　最后，现有的打包工具都是围绕字符串加载/转换进行构建的，其中转换需要一个字符串，解析它，然后进行一些转换，之后再次生成代码。通常这最终导致许多解析和代码生成在单个文件上运行，这是低效的。相反，parcel 的转换工作在 AST上，所以这样每个文件就有一个解析，多个转换和一个代码生成。&lt;/p&gt;
&lt;h3&gt;Parcel 是如何工作的？　&lt;/h3&gt;
&lt;p&gt;　　Parcel 将 资源 树转换成 包(bundles) 树。许多其它的打包工具基本上是基于 JavaScript 资源，还有附加在其上的其它格式的资源。例如，在 JS 文件中内联成字符串。 Parcel 是对文件类型无感知的，它能按你所期待的方式那样与任意类型的资源工作，且毋须配置。&lt;br/&gt;　　构建资源树&lt;br/&gt;　　Parcel 接受单个入口资源作为输入，可以是任意类型：JS、HTML、CSS、图片文件等等。在 Parcel 中定义了许多不同的资源类型，它知道如何去处理特定的文件类型。资源会被解析，资源的依赖会被提取，资源会被转换成最终编译好的形态。此过程创建了一个资源树。&lt;br/&gt;　　构建文件束树&lt;br/&gt;　　一旦资源树被构建好，资源会被放置在文件束树中。首先一个入口资源会被创建成一个文件束，然后动态的 import() 会被创建成子文件束 ，这引发了代码的拆分。当不同类型的文件资源被引入，兄弟文件束就会被创建。例如你在 JavaScript 中引入了 CSS 文件，那它会被放置在一个与 JavaScript 文件对应的兄弟文件束中。如果资源被多于一个文件束引用，它会被提升到文件束树中最近的公共祖先中，这样该资源就不会被多次打包。&lt;br/&gt;　　打包&lt;br/&gt;　　在文件束树被构建之后，每个文件束都会被 packager 写到一个特定文件类型的文件中。packagers 知道如何从每个资源中将代码合并起来，生成到最终被浏览器加载的文件中。&lt;br/&gt;[ps：基于官网&lt;a href=&quot;https://parceljs.org/&quot; target=&quot;_blank&quot;&gt;https://parceljs.org/&lt;/a&gt;进行的总结]&lt;/p&gt;
&lt;h2&gt;入门Demo&lt;/h2&gt;
&lt;p&gt;　　一、初始化npm&lt;/p&gt;

&lt;p&gt;　　二、添加babel 并安装 babel-preset-env依赖&lt;/p&gt;
&lt;p&gt;　　1.新建.babelrc 文件　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;presets&quot;: [
    &quot;env&quot;
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.安装依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install babel-preset-env --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　三、添加parcel&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install parcel-bundler --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　四、最后生成的package.json文件大概就这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;name&quot;: &quot;parcel-demo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;parcel&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;,
    &quot;start&quot;:&quot;parcel index.html&quot;
  },
  &quot;keywords&quot;: [
    &quot;parcel&quot;
  ],
  &quot;author&quot;: &quot;aaron&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;babel-cli&quot;: &quot;^6.26.0&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.6.1&quot;,
    &quot;parcel-bundler&quot;: &quot;^1.2.0&quot;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;[　ps：给npm添加启动项：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&quot;start&quot;:&quot;parcel index.html&quot;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;]　　&lt;/p&gt;
&lt;p&gt;　　五、最后根据官网新建index.html，index.js等文件，然后命令行打包，然后运行npm  start 或 parcel index.html 启动，简单的demo就生成了。&lt;/p&gt;
&lt;p&gt;　　index.html / index.js / main.js / main.css&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hello Parcel&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;parcel&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./js/index.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import main from './main'&lt;span&gt;;

main();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import classes from '../css/main.css'&lt;span&gt;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; ()=&amp;gt;&lt;span&gt;{
    console.log(classes);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.main&lt;/span&gt;{&lt;span&gt;
    background&lt;/span&gt;:&lt;span&gt; url(&quot;../images/parcel.png&quot;)&lt;/span&gt;;&lt;span&gt;
    color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141454/201712/1141454-20171213121001504-93929513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141454/201712/1141454-20171213120020379-558724377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;更多&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141454/201712/1141454-20171213120916972-279155989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果报了上面那些错误。貌似node.js 7.6版本以下对await / async 不支持，所以在执行打包时需要升级node.js版本。&lt;/p&gt;
&lt;p&gt;　　parcel中文官网：&lt;a href=&quot;http://www.parceljs.io/&quot; target=&quot;_blank&quot;&gt;http://www.parceljs.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　parcel GitHub：&lt;a href=&quot;https://github.com/parcel-bundler/parcel&quot; target=&quot;_blank&quot;&gt;https://github.com/parcel-bundler/parcel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　关于parcel的更多使用方法还需深入了解才行，每一个打包工具我都觉得都有它的独特魅力。&lt;/p&gt;
&lt;p&gt;　　期待parcel的发展......&lt;/p&gt;
&lt;p&gt;　　&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Dec 2017 04:29:00 +0000</pubDate>
<dc:creator>PC.aaron</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aaron-pan/p/8032226.html</dc:identifier>
</item>
<item>
<title>【深度学习系列】用PaddlePaddle和Tensorflow实现经典CNN网络Vgg - Charlotte77</title>
<link>http://www.cnblogs.com/charlotte77/p/8028651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlotte77/p/8028651.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　上周我们讲了经典CNN网络AlexNet对图像分类的效果，2014年，在AlexNet出来的两年后，牛津大学提出了Vgg网络，并在ILSVRC 2014中的classification项目的比赛中取得了第2名的成绩（第一名是GoogLeNet，也是同年提出的）。在论文《&lt;a href=&quot;https://arxiv.org/abs/1409.1556&quot; target=&quot;_blank&quot;&gt;Very Deep Convolutional Networks for Large-Scale Image Recognition&lt;/a&gt;》中，作者提出通过缩小卷积核大小来构建更深的网络。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Vgg网络结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;VGGnet是Oxford的Visual Geometry Group的team，在ILSVRC 2014上的主要工作是证明了增加网络的深度能够在一定程度上影响网络最终的性能，如下图，文章通过逐步增加网络深度来提高性能，虽然看起来有一点小暴力，没有特别多取巧的，但是确实有效，很多pretrained的方法就是使用VGG的model（主要是16和19），VGG相对其他的方法，参数空间很大，所以train一个vgg模型通常要花费更长的时间，不过公开的pretrained model让我们很方便的使用，paper中的几种模型如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/853467/201712/853467-20171213101823551-72988506.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;540&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 图1 vgg网络结构&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;图中D和E分别为VGG-16和VGG-19，参数分别是138m和144m，是文中两个效果最好的网络结构，VGG网络结构可以看做是AlexNet的加深版，VGG在图像检测中效果很好（如：Faster-RCNN），这种传统结构相对较好的保存了图片的局部位置信息（不像GoogLeNet中引入Inception可能导致位置信息的错乱）。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们来仔细看一下vgg16的网络结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/853467/201712/853467-20171213115318707-1750025335.png&quot; alt=&quot;&quot; width=&quot;208&quot; height=&quot;755&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;       　　　　　　　　　　　　　　　　　　　　　　图2 vgg16网络结构　　　　　　　　　　　　　　　　　　　　　　　　　&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;从图中可以看到，每个卷积层都使用更小的3×3卷积核对图像进行卷积，并把这些小的卷积核排列起来作为一个卷积序列。通俗点来讲就是对原始图像进行3×3卷积，然后再进行3×3卷积，连续使用小的卷积核对图像进行多次卷积。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在alexnet里我们一开始的时候是用11*11的大卷积核网络，为什么在这里要用3*3的小卷积核来对图像进行卷积呢？并且还是使用连续的小卷积核？VGG一开始提出的时候刚好与LeNet的设计原则相违背，因为LeNet相信大的卷积核能够捕获图像当中相似的特征（权值共享）。AlexNet在浅层网络开始的时候也是使用9×9、11×11卷积核，并且尽量在浅层网络的时候避免使用1×1的卷积核。但是VGG的神奇之处就是在于使用多个3×3卷积核可以模仿较大卷积核那样对图像进行局部感知。后来多个小的卷积核串联这一思想被GoogleNet和ResNet等吸收。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从图1的实验结果也可以看到，VGG使用多个3x3卷积来对高维特征进行提取。因为如果使用较大的卷积核，参数就会大量地增加、运算时间也会成倍的提升。例如3x3的卷积核只有9个权值参数，使用7*7的卷积核权值参数就会增加到49个。因为缺乏一个模型去对大量的参数进行归一化、约减，或者说是限制大规模的参数出现，因此训练核数更大的卷积网络就变得非常困难了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　VGG相信如果使用大的卷积核将会造成很大的时间浪费，减少的卷积核能够减少参数，节省运算开销。虽然训练的时间变长了，但是总体来说预测的时间和参数都是减少的了。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt; Vgg的优势&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　与AlexNet相比：&lt;/span&gt;&lt;/p&gt;
&lt;ul data-anchor-id=&quot;ttv1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;相同点&lt;/span&gt;&lt;/p&gt;
&lt;blockquote class=&quot;white-blockquote&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;整体结构分五层；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;除softmax层外，最后几层为全连接层；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;五层之间通过max pooling连接。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;不同点&lt;/span&gt;&lt;/p&gt;
&lt;blockquote class=&quot;white-blockquote&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;使用3×3的小卷积核代替7×7大卷积核，网络构建的比较深；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于LRN太耗费计算资源，性价比不高，所以被去掉；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;采用了更多的feature map，能够提取更多的特征，从而能够做更多特征的组合。　　&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;用PaddlePaddle实现Vgg&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1.网络结构&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;Created by huxiaoman 2017.12.12
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;vggnet.py:用vgg网络实现cifar-10分类
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; paddle.v2 as paddle
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; vgg(input):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; conv_block(ipt, num_filter, groups, dropouts, num_channels=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; paddle.networks.img_conv_group(
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             input=&lt;span&gt;ipt,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             num_channels=&lt;span&gt;num_channels,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             pool_size=2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             pool_stride=2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             conv_num_filter=[num_filter] *&lt;span&gt; groups,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             conv_filter_size=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             conv_act=&lt;span&gt;paddle.activation.Relu(),
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             conv_with_batchnorm=&lt;span&gt;True,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             conv_batchnorm_drop_rate=&lt;span&gt;dropouts,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             pool_type=&lt;span&gt;paddle.pooling.Max())
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     conv1 = conv_block(input, 64, 2, [0.3, 0], 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     conv2 = conv_block(conv1, 128, 2, [0.4&lt;span&gt;, 0])
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     conv3 = conv_block(conv2, 256, 3, [0.4, 0.4&lt;span&gt;, 0])
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     conv4 = conv_block(conv3, 512, 3, [0.4, 0.4&lt;span&gt;, 0])
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     conv5 = conv_block(conv4, 512, 3, [0.4, 0.4&lt;span&gt;, 0])
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     drop = paddle.layer.dropout(input=conv5, dropout_rate=0.5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     fc1 = paddle.layer.fc(input=drop, size=512, act=&lt;span&gt;paddle.activation.Linear())
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     bn =&lt;span&gt; paddle.layer.batch_norm(
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         input=&lt;span&gt;fc1,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         act=&lt;span&gt;paddle.activation.Relu(),
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         layer_attr=paddle.attr.Extra(drop_rate=0.5&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     fc2 = paddle.layer.fc(input=bn, size=512, act=&lt;span&gt;paddle.activation.Linear())
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; fc2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;2.训练模型&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding:utf-8&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;Created by huxiaoman 2017.12.12
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;train_vgg.py:训练vgg16对cifar10数据集进行分类
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys, os
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; paddle.v2 as paddle
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; vggnet &lt;span&gt;import&lt;/span&gt;&lt;span&gt; vgg
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; with_gpu = os.getenv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;WITH_GPU&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     datadim = 3 * 32 * 32
&lt;span&gt; 15&lt;/span&gt;     classdim = 10
&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; PaddlePaddle init&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;     paddle.init(use_gpu=with_gpu, trainer_count=8&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;     image =&lt;span&gt; paddle.layer.data(
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;         name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, type=&lt;span&gt;paddle.data_type.dense_vector(datadim))
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     
&lt;span&gt; 23&lt;/span&gt;     net =&lt;span&gt; vgg(image)
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     out =&lt;span&gt; paddle.layer.fc(
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         input=net, size=classdim, act=&lt;span&gt;paddle.activation.Softmax())
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt;     lbl =&lt;span&gt; paddle.layer.data(
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, type=&lt;span&gt;paddle.data_type.integer_value(classdim))
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     cost = paddle.layer.classification_cost(input=out, label=&lt;span&gt;lbl)
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create parameters&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     parameters =&lt;span&gt; paddle.parameters.create(cost)
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create optimizer&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     momentum_optimizer =&lt;span&gt; paddle.optimizer.Momentum(
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         momentum=0.9&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         regularization=paddle.optimizer.L2Regularization(rate=0.0002 * 128&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         learning_rate=0.1 / 128.0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         learning_rate_decay_a=0.1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         learning_rate_decay_b=50000 * 100&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         learning_rate_schedule=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;discexp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; End batch and end pass event handler&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; event_handler(event):
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; isinstance(event, paddle.event.EndIteration):
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; event.batch_id % 100 ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nPass %d, Batch %d, Cost %f, %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;                    event.pass_id, event.batch_id, event.cost, event.metrics)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                 sys.stdout.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;                sys.stdout.flush()
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; isinstance(event, paddle.event.EndPass):
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; save parameters&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;             with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;params_pass_%d.tar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % event.pass_id, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;                parameters.to_tar(f)
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt;             result =&lt;span&gt; trainer.test(
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                 reader=&lt;span&gt;paddle.batch(
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                     paddle.dataset.cifar.test10(), batch_size=128&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 feeding={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                          &lt;span&gt;'&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nTest with Pass %d, %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (event.pass_id, result.metrics)
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create trainer&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;     trainer =&lt;span&gt; paddle.trainer.SGD(
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         cost=cost, parameters=parameters, update_equation=&lt;span&gt;momentum_optimizer)
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Save the inference topology to protobuf.&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;     inference_topology = paddle.topology.Topology(layers=&lt;span&gt;out)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     with open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;inference_topology.pkl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;        inference_topology.serialize_for_inference(f)
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;    trainer.train(
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         reader=&lt;span&gt;paddle.batch(
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;            paddle.reader.shuffle(
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                 paddle.dataset.cifar.train10(), buf_size=50000&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             batch_size=128&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         num_passes=200&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         event_handler=&lt;span&gt;event_handler,
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         feeding={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; 
&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; inference&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Image
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; load_image(file):
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         im =&lt;span&gt; Image.open(file)
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         im = im.resize((32, 32&lt;span&gt;), Image.ANTIALIAS)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         im =&lt;span&gt; np.array(im).astype(np.float32)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         im = im.transpose((2, 0, 1))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; CHW&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;         im = im[(2, 1, 0), :, :]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; BGR&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;         im =&lt;span&gt; im.flatten()
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;         im = im / 255.0
&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; im
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;     test_data =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     cur_dir = os.path.dirname(os.path.realpath(&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     test_data.append((load_image(cur_dir + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/image/dog.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;), ))
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;     probs =&lt;span&gt; paddle.infer(
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         output_layer=out, parameters=parameters, input=&lt;span&gt;test_data)
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;     lab = np.argsort(-probs)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; probs and lab are the results of one batch data&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Label of image/dog.png is: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; lab[0][0]
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;     main()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;3.训练结果&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;107.5&quot;&gt;&lt;img id=&quot;code_img_closed_353b32d9-fcb1-4d15-b2ed-f305c8d1e32d&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_353b32d9-fcb1-4d15-b2ed-f305c8d1e32d&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_353b32d9-fcb1-4d15-b2ed-f305c8d1e32d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;210&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;nohup: ignoring input
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; I1127 09:36:58.313799 13026 Util.cpp:166] commandline:  --use_gpu=True --trainer_count=7
&lt;span&gt; 3&lt;/span&gt; [INFO 2017-11-27 09:37:04,477 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_0__&lt;/span&gt;: c = 64, h = 32, w = 32, size = 65536
&lt;span&gt; 4&lt;/span&gt; [INFO 2017-11-27 09:37:04,478 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_0__&lt;/span&gt;: c = 64, h = 32, w = 32, size = 65536
&lt;span&gt; 5&lt;/span&gt; [INFO 2017-11-27 09:37:04,479 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_1__&lt;/span&gt;: c = 64, h = 32, w = 32, size = 65536
&lt;span&gt; 6&lt;/span&gt; [INFO 2017-11-27 09:37:04,480 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_1__&lt;/span&gt;: c = 64, h = 32, w = 32, size = 65536
&lt;span&gt; 7&lt;/span&gt; [INFO 2017-11-27 09:37:04,480 layers.py:2667] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__pool_0__&lt;/span&gt;: c = 64, h = 16, w = 16, size = 16384
&lt;span&gt; 8&lt;/span&gt; [INFO 2017-11-27 09:37:04,481 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_2__&lt;/span&gt;: c = 128, h = 16, w = 16, size = 32768
&lt;span&gt; 9&lt;/span&gt; [INFO 2017-11-27 09:37:04,482 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_2__&lt;/span&gt;: c = 128, h = 16, w = 16, size = 32768
&lt;span&gt;10&lt;/span&gt; [INFO 2017-11-27 09:37:04,483 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_3__&lt;/span&gt;: c = 128, h = 16, w = 16, size = 32768
&lt;span&gt;11&lt;/span&gt; [INFO 2017-11-27 09:37:04,484 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_3__&lt;/span&gt;: c = 128, h = 16, w = 16, size = 32768
&lt;span&gt;12&lt;/span&gt; [INFO 2017-11-27 09:37:04,485 layers.py:2667] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__pool_1__&lt;/span&gt;: c = 128, h = 8, w = 8, size = 8192
&lt;span&gt;13&lt;/span&gt; [INFO 2017-11-27 09:37:04,485 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_4__&lt;/span&gt;: c = 256, h = 8, w = 8, size = 16384
&lt;span&gt;14&lt;/span&gt; [INFO 2017-11-27 09:37:04,486 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_4__&lt;/span&gt;: c = 256, h = 8, w = 8, size = 16384
&lt;span&gt;15&lt;/span&gt; [INFO 2017-11-27 09:37:04,487 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_5__&lt;/span&gt;: c = 256, h = 8, w = 8, size = 16384
&lt;span&gt;16&lt;/span&gt; [INFO 2017-11-27 09:37:04,488 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_5__&lt;/span&gt;: c = 256, h = 8, w = 8, size = 16384
&lt;span&gt;17&lt;/span&gt; [INFO 2017-11-27 09:37:04,489 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_6__&lt;/span&gt;: c = 256, h = 8, w = 8, size = 16384
&lt;span&gt;18&lt;/span&gt; [INFO 2017-11-27 09:37:04,490 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_6__&lt;/span&gt;: c = 256, h = 8, w = 8, size = 16384
&lt;span&gt;19&lt;/span&gt; [INFO 2017-11-27 09:37:04,490 layers.py:2667] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__pool_2__&lt;/span&gt;: c = 256, h = 4, w = 4, size = 4096
&lt;span&gt;20&lt;/span&gt; [INFO 2017-11-27 09:37:04,491 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_7__&lt;/span&gt;: c = 512, h = 4, w = 4, size = 8192
&lt;span&gt;21&lt;/span&gt; [INFO 2017-11-27 09:37:04,492 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_7__&lt;/span&gt;: c = 512, h = 4, w = 4, size = 8192
&lt;span&gt;22&lt;/span&gt; [INFO 2017-11-27 09:37:04,493 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_8__&lt;/span&gt;: c = 512, h = 4, w = 4, size = 8192
&lt;span&gt;23&lt;/span&gt; [INFO 2017-11-27 09:37:04,494 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_8__&lt;/span&gt;: c = 512, h = 4, w = 4, size = 8192
&lt;span&gt;24&lt;/span&gt; [INFO 2017-11-27 09:37:04,495 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_9__&lt;/span&gt;: c = 512, h = 4, w = 4, size = 8192
&lt;span&gt;25&lt;/span&gt; [INFO 2017-11-27 09:37:04,495 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_9__&lt;/span&gt;: c = 512, h = 4, w = 4, size = 8192
&lt;span&gt;26&lt;/span&gt; [INFO 2017-11-27 09:37:04,496 layers.py:2667] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__pool_3__&lt;/span&gt;: c = 512, h = 2, w = 2, size = 2048
&lt;span&gt;27&lt;/span&gt; [INFO 2017-11-27 09:37:04,497 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_10__&lt;/span&gt;: c = 512, h = 2, w = 2, size = 2048
&lt;span&gt;28&lt;/span&gt; [INFO 2017-11-27 09:37:04,498 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_10__&lt;/span&gt;: c = 512, h = 2, w = 2, size = 2048
&lt;span&gt;29&lt;/span&gt; [INFO 2017-11-27 09:37:04,499 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_11__&lt;/span&gt;: c = 512, h = 2, w = 2, size = 2048
&lt;span&gt;30&lt;/span&gt; [INFO 2017-11-27 09:37:04,499 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_11__&lt;/span&gt;: c = 512, h = 2, w = 2, size = 2048
&lt;span&gt;31&lt;/span&gt; [INFO 2017-11-27 09:37:04,502 layers.py:2539] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__conv_12__&lt;/span&gt;: c = 512, h = 2, w = 2, size = 2048
&lt;span&gt;32&lt;/span&gt; [INFO 2017-11-27 09:37:04,502 layers.py:3062] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__batch_norm_12__&lt;/span&gt;: c = 512, h = 2, w = 2, size = 2048
&lt;span&gt;33&lt;/span&gt; [INFO 2017-11-27 09:37:04,503 layers.py:2667] output &lt;span&gt;for&lt;/span&gt; &lt;span&gt;__pool_4__&lt;/span&gt;: c = 512, h = 1, w = 1, size = 512
&lt;span&gt;34&lt;/span&gt; I1127 09:37:04.563228 13026 MultiGradientMachine.cpp:99] numLogicalDevices=1 numThreads=7 numDevices=8
&lt;span&gt;35&lt;/span&gt; I1127 09:37:04.822993 13026 GradientMachine.cpp:85&lt;span&gt;] Initing parameters..
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; I1127 09:37:05.728123 13026 GradientMachine.cpp:92&lt;span&gt;] Init parameters done.
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; Pass 0, Batch 0, Cost 2.407296, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.8828125&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;...................................................................................................
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; Pass 0, Batch 100, Cost 1.994910, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.84375&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;...................................................................................................
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; Pass 0, Batch 200, Cost 2.199248, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.8671875&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;...................................................................................................
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; Pass 0, Batch 300, Cost 1.982006, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.8125&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;..........................................................................................
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; Test with Pass 0, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.8999999761581421&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;```
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;```
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; Pass 199, Batch 0, Cost 0.012132, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.0&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;...................................................................................................
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; Pass 199, Batch 100, Cost 0.021121, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.0078125&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;...................................................................................................
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; Pass 199, Batch 200, Cost 0.068369, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.0078125&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;...................................................................................................
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; Pass 199, Batch 300, Cost 0.015805, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.0&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; ..........................................................................................I1128 01:57:44.727157 13026 MultiGradientMachine.cpp:99] numLogicalDevices=1 numThreads=7 numDevices=8
&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; Test with Pass 199, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;classification_error_evaluator&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0.10890000313520432&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; Label of image/dog.png &lt;span&gt;is&lt;/span&gt;: 5
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;从训练结果来看，开了7个线程，8个Tesla K80，迭代200次，耗时16h21min，相比于之前训练的lenet和alexnet的几个小时来说，时间消耗很高，但是结果很好，准确率是89.11%，在同设备和迭代次数情况下，比lenet的和alexnet的精度都要高。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;用Tensorflow实现vgg&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　1.网络结构&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;174&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; inference_op(input_op, keep_prob):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     p =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一块 conv1_1-conv1_2-pool1&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     conv1_1 = conv_op(input_op, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv1_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 n_out = 64, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     conv1_2 = conv_op(conv1_1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv1_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 n_out = 64, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     pool1 = mpool_op(conv1_2, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh = 2, kw = 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 dw = 2, dh = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第二块 conv2_1-conv2_2-pool2&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     conv2_1 = conv_op(pool1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv2_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 n_out = 128, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     conv2_2 = conv_op(conv2_1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv2_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 n_out = 128, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     pool2 = mpool_op(conv2_2, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh = 2, kw = 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 dw = 2, dh = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第三块 conv3_1-conv3_2-conv3_3-pool3&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     conv3_1 = conv_op(pool2, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv3_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 n_out = 256, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     conv3_2 = conv_op(conv3_1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv3_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 n_out = 256, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     conv3_3 = conv_op(conv3_2, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv3_3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 n_out = 256, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     pool3 = mpool_op(conv3_3, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh = 2, kw = 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 dw = 2, dh = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第四块 conv4_1-conv4_2-conv4_3-pool4&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     conv4_1 = conv_op(pool3, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv4_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     conv4_2 = conv_op(conv4_1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv4_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     conv4_3 = conv_op(conv4_2, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv4_3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     pool4 = mpool_op(conv4_3, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh = 2, kw = 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 dw = 2, dh = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第五块 conv5_1-conv5_2-conv5_3-pool5&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     conv5_1 = conv_op(pool4, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv5_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     conv5_2 = conv_op(conv5_1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv5_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     conv5_3 = conv_op(conv5_2, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv5_3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     pool5 = mpool_op(conv5_3, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh = 2, kw = 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 dw = 2, dh = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把pool5 ( [7, 7, 512] )  拉成向量&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     shp  =&lt;span&gt; pool5.get_shape()
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     flattened_shape = shp[1].value * shp[2].value * shp[3&lt;span&gt;].value
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     resh1 = tf.reshape(pool5, [-1, flattened_shape], name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;resh1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全连接层1 添加了 Droput来防止过拟合    &lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     fc1 = fc_op(resh1, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, n_out = 2048, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     fc1_drop = tf.nn.dropout(fc1, keep_prob, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc1_drop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全连接层2 添加了 Droput来防止过拟合    &lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     fc2 = fc_op(fc1_drop, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, n_out = 2048, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     fc2_drop = tf.nn.dropout(fc2, keep_prob, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc2_drop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全连接层3 加一个softmax求给类别的概率&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;     fc3 = fc_op(fc2_drop, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, n_out = 1000, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     softmax =&lt;span&gt; tf.nn.softmax(fc3)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     predictions = tf.argmax(softmax, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; predictions, softmax, fc3, p
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;2.训练网络结构&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;262&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;Created by huxiaoman 2017.12.12
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;vgg_tf.py:训练tensorflow版的vgg16网络，对cifar-10shuju进行分类
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; math
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cifar10
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; batch_size = 128
&lt;span&gt; 13&lt;/span&gt; num_batches = 200
&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义函数对卷积层进行初始化&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; input_op : 输入数据 &lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name : 该卷积层的名字，用tf.name_scope()来命名&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; kh,kw : 分别是卷积核的高和宽&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; n_out : 输出通道数&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; dh,dw : 步长的高和宽&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; p ： 是参数列表，存储VGG所用到的参数&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 采用xavier方法对卷积核权值进行初始化&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; conv_op(input_op, name, kh, kw, n_out, dh, dw, p):
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     n_in = input_op.get_shape()[-1].value &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获得输入图像的通道数&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;    with tf.name_scope(name) as scope:
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         kernel = tf.get_variable(scope+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             shape = [kh, kw, n_in, n_out], dtype =&lt;span&gt; tf.float32,
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;             initializer =&lt;span&gt; tf.contrib.layers.xavier_initializer_conv2d())
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  卷积层计算&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         conv = tf.nn.conv2d(input_op, kernel, (1, dh, dw, 1), padding = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         bias_init_val = tf.constant(0.0, shape = [n_out], dtype =&lt;span&gt; tf.float32)
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         biases = tf.Variable(bias_init_val, trainable = True, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         z =&lt;span&gt; tf.nn.bias_add(conv, biases)
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         activation = tf.nn.relu(z, name =&lt;span&gt; scope)
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         p +=&lt;span&gt; [kernel, biases]
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; activation
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义函数对全连接层进行初始化&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; input_op : 输入数据&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name : 该全连接层的名字&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; n_out : 输出的通道数&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; p : 参数列表 &lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化方法用 xavier方法&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fc_op(input_op, name, n_out, p):
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     n_in = input_op.get_shape()[-1&lt;span&gt;].value
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    with tf.name_scope(name) as scope:
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         kernel = tf.get_variable(scope+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             shape = [n_in, n_out], dtype =&lt;span&gt; tf.float32,
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             initializer =&lt;span&gt; tf.contrib.layers.xavier_initializer())
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         biases = tf.Variable(tf.constant(0.1, shape =&lt;span&gt; [n_out],
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;             dtype = tf.float32), name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;         activation = tf.nn.relu_layer(input_op, kernel,  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  ???????????????&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;             biases, name =&lt;span&gt; scope)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         p +=&lt;span&gt; [kernel, biases]
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; activation 
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义函数 创建 maxpool层&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; input_op : 输入数据 &lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name : 该卷积层的名字，用tf.name_scope()来命名&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; kh,kw : 分别是卷积核的高和宽&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; dh,dw : 步长的高和宽&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; mpool_op(input_op, name, kh, kw, dh, dw):
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; tf.nn.max_pool(input_op, ksize = [1,kh,kw,1&lt;span&gt;],
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;         strides = [1, dh, dw, 1], padding = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SAME&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, name =&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;---------------创建 VGG-16------------------&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; inference_op(input_op, keep_prob):
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     p =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一块 conv1_1-conv1_2-pool1&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     conv1_1 = conv_op(input_op, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv1_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 n_out = 64, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     conv1_2 = conv_op(conv1_1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv1_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                 n_out = 64, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     pool1 = mpool_op(conv1_2, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh = 2, kw = 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                 dw = 2, dh = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第二块 conv2_1-conv2_2-pool2&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;     conv2_1 = conv_op(pool1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv2_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 n_out = 128, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;     conv2_2 = conv_op(conv2_1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv2_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 n_out = 128, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     pool2 = mpool_op(conv2_2, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh = 2, kw = 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                 dw = 2, dh = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第三块 conv3_1-conv3_2-conv3_3-pool3&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;     conv3_1 = conv_op(pool2, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv3_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                 n_out = 256, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     conv3_2 = conv_op(conv3_1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv3_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                 n_out = 256, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     conv3_3 = conv_op(conv3_2, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv3_3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                 n_out = 256, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     pool3 = mpool_op(conv3_3, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh = 2, kw = 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                 dw = 2, dh = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第四块 conv4_1-conv4_2-conv4_3-pool4&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;     conv4_1 = conv_op(pool3, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv4_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     conv4_2 = conv_op(conv4_1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv4_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     conv4_3 = conv_op(conv4_2, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv4_3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     pool4 = mpool_op(conv4_3, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh = 2, kw = 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                 dw = 2, dh = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第五块 conv5_1-conv5_2-conv5_3-pool5&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;     conv5_1 = conv_op(pool4, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv5_1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;     conv5_2 = conv_op(conv5_1, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv5_2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;     conv5_3 = conv_op(conv5_2, name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv5_3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh=3, kw=3&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;                 n_out = 512, dh = 1, dw = 1, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;     pool5 = mpool_op(conv5_3, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, kh = 2, kw = 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 dw = 2, dh = 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把pool5 ( [7, 7, 512] )  拉成向量&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt;     shp  =&lt;span&gt; pool5.get_shape()
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     flattened_shape = shp[1].value * shp[2].value * shp[3&lt;span&gt;].value
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     resh1 = tf.reshape(pool5, [-1, flattened_shape], name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;resh1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全连接层1 添加了 Droput来防止过拟合    &lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;     fc1 = fc_op(resh1, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, n_out = 2048, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;     fc1_drop = tf.nn.dropout(fc1, keep_prob, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc1_drop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全连接层2 添加了 Droput来防止过拟合    &lt;/span&gt;
&lt;span&gt;122&lt;/span&gt;     fc2 = fc_op(fc1_drop, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, n_out = 2048, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     fc2_drop = tf.nn.dropout(fc2, keep_prob, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc2_drop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全连接层3 加一个softmax求给类别的概率&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt;     fc3 = fc_op(fc2_drop, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, n_out = 1000, p =&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;     softmax =&lt;span&gt; tf.nn.softmax(fc3)
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;     predictions = tf.argmax(softmax, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; predictions, softmax, fc3, p
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义评测函数&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; time_tensorflow_run(session, target, feed, info_string):
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;     num_steps_burn_in = 10
&lt;span&gt;135&lt;/span&gt;     total_duration = 0.0
&lt;span&gt;136&lt;/span&gt;     total_duration_squared = 0.0
&lt;span&gt;137&lt;/span&gt; 
&lt;span&gt;138&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(num_batches +&lt;span&gt; num_steps_burn_in):
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;         start_time =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;         _ = session.run(target, feed_dict =&lt;span&gt; feed)
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;         duration = time.time() -&lt;span&gt; start_time
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; i &amp;gt;=&lt;span&gt; num_steps_burn_in:
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; i  % 10&lt;span&gt;: 
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s: step %d, duration = %.3f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % 
&lt;span&gt;145&lt;/span&gt;                     (datetime.now(), i-&lt;span&gt;num_steps_burn_in, duration))
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             total_duration +=&lt;span&gt; duration
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;             total_duration_squared += duration *&lt;span&gt; duration
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;     mean_dur = total_duration /&lt;span&gt; num_batches 
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;     var_dur = total_duration_squared / num_batches - mean_dur *&lt;span&gt; mean_dur
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;     std_dur =&lt;span&gt; math.sqrt(var_dur)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s: %s across %d steps, %.3f +/- %.3f sec / batch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;(datetime.now(), info_string, num_batches, mean_dur, std_dur))
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; 
&lt;span&gt;153&lt;/span&gt; 
&lt;span&gt;154&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; train_vgg16():
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;    with tf.Graph().as_default():
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         image_size = 224  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入图像尺寸&lt;/span&gt;
&lt;span&gt;157&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成随机数测试是否能跑通&lt;/span&gt;
&lt;span&gt;158&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;images = tf.Variable(tf.random_normal([batch_size, image_size, image_size, 3], dtype=tf.float32, stddev=1e-1))&lt;/span&gt;
&lt;span&gt;159&lt;/span&gt;         with tf.device(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/cpu:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;             images, labels =&lt;span&gt; cifar10.distorted_inputs()
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;         keep_prob =&lt;span&gt; tf.placeholder(tf.float32)
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;         prediction,softmax,fc8,p =&lt;span&gt; inference_op(images,keep_prob)
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;         init =&lt;span&gt; tf.global_variables_initializer()
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;         sess =&lt;span&gt; tf.Session()
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;        sess.run(init)
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;         time_tensorflow_run(sess, prediction,{keep_prob:1.0}, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Forward&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用以模拟训练的过程&lt;/span&gt;
&lt;span&gt;168&lt;/span&gt;         objective = tf.nn.l2_loss(fc8)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给一个loss&lt;/span&gt;
&lt;span&gt;169&lt;/span&gt;         grad = tf.gradients(objective, p)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相对于loss的 所有模型参数的梯度&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt;         time_tensorflow_run(sess, grad, {keep_prob:0.5},&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Forward-backward&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; 
&lt;span&gt;172&lt;/span&gt; 
&lt;span&gt;173&lt;/span&gt; 
&lt;span&gt;174&lt;/span&gt; 
&lt;span&gt;175&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;     train_vgg16()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　当然，我们也可以用tf.slim来简化一下网络结构&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;96&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; vgg16(inputs):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  with slim.arg_scope([slim.conv2d, slim.fully_connected],
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                       activation_fn=&lt;span&gt;tf.nn.relu,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                       weights_initializer=tf.truncated_normal_initializer(0.0, 0.01&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                       weights_regularizer=slim.l2_regularizer(0.0005&lt;span&gt;)):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     net = slim.repeat(inputs, 2, slim.conv2d, 64, [3, 3], scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     net = slim.max_pool2d(net, [2, 2], scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     net = slim.repeat(net, 2, slim.conv2d, 128, [3, 3], scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     net = slim.max_pool2d(net, [2, 2], scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     net = slim.repeat(net, 3, slim.conv2d, 256, [3, 3], scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     net = slim.max_pool2d(net, [2, 2], scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     net = slim.repeat(net, 3, slim.conv2d, 512, [3, 3], scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     net = slim.max_pool2d(net, [2, 2], scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     net = slim.repeat(net, 3, slim.conv2d, 512, [3, 3], scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conv5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     net = slim.max_pool2d(net, [2, 2], scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pool5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     net = slim.fully_connected(net, 4096, scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     net = slim.dropout(net, 0.5, scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dropout6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     net = slim.fully_connected(net, 4096, scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     net = slim.dropout(net, 0.5, scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dropout7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     net = slim.fully_connected(net, 1000, activation_fn=None, scope=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fc8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　对比训练结果，在同等设备和环境下，迭代200tensorflow的训练结果是89.18%，耗时18h12min，对比paddlepaddle的效果，精度差不多，时间慢一点。其实可以对数据进行处理后再进行训练，转换成tfrecord多线程输入在训练，时间应该会快很多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过论文的分析和实验的结果，我总结了几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;strong&gt;1.LRN层太耗费计算资源，作用不大，可以舍去。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　   2.大卷积核可以学习更大的空间特征，但是需要的参数空间也更多，小卷积核虽然学习的空间特征有限，但所需参数空间更小，多层叠加训练可能效果更好。&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　   3.越深的网络效果越好，但是要避免梯度消失的问题，选取relu的激活函数、batch_normalization等都可以从一定程度上避免。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　4.小卷积核+深层网络的效果，在迭代相同次数时，比大卷积核+浅层网络效果更好，对于我们自己设计网络时可以有借鉴作用。但是前者的训练时间可能更长，不过可能比后者收敛速度更快，精确度更好。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;ps:为了方便大家及时看到我的更新，我搞了一个公众号，以后文章会同步发布与公众号和博客园，这样大家就能及时收到通知啦，有不懂的问题也可以在公众号留言，这样我能够及时看到并回复。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以通过扫下面的二维码或者直接搜公众号：CharlotteDataMining 就可以了，谢谢关注^_^&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/853467/201712/853467-20171213123124801-1124596682.jpg&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 本文同步发布于：https://mp.weixin.qq.com/s?__biz=MzI0OTQwMTA5Ng==&amp;amp;mid=2247483677&amp;amp;idx=1&amp;amp;sn=9402a0532bc6330f83e58c7e18f51b93&amp;amp;chksm=e9935b7adee4d26cd69de6c89b25be994735094ef420befd1d275f97821819ba9528f13e079a#rd&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考文献：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.https://arxiv.org/pdf/1409.1556.pdf&lt;/p&gt;

</description>
<pubDate>Wed, 13 Dec 2017 04:27:00 +0000</pubDate>
<dc:creator>Charlotte77</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charlotte77/p/8028651.html</dc:identifier>
</item>
</channel>
</rss>