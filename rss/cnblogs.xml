<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Swift-001-Swift简介及基础语法 - 胡锦涛_Steven</title>
<link>http://www.cnblogs.com/StevenHuSir/p/Swift_Brief.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/StevenHuSir/p/Swift_Brief.html</guid>
<description>
&lt;p class=&quot;p1&quot;&gt;1.&lt;strong&gt;Swift简介&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;2014年WWDC 发布的新开发语言，可与OC共同运行于Mac OS 和 iOS 平台,用于搭建基于苹果平台的应用程序。&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s1&quot;&gt;swift2.0之后的语法则趋于稳定，2017年发布的swift4.0虽有改动，但也只是增添了一些新特性。这些新特性需要在Xcode9上运行才能显示出效果。值得一提的是它支持unicode9,也就是说，可以用某些图片图标来充当变量。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;2.特点&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;①&lt;span class=&quot;s2&quot;&gt;快速&lt;span class=&quot;s1&quot;&gt;,&lt;span class=&quot;s3&quot;&gt;&lt;span&gt;安全&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span&gt;,使用安全的编程模式并添加很多新特性，使编程更简单&lt;/span&gt;，&lt;span class=&quot;s4&quot;&gt;&lt;strong&gt;扩展性更强&lt;/strong&gt;&lt;span class=&quot;s1&quot;&gt;(&lt;span class=&quot;s5&quot;&gt;支持Cocoa 和 Cocoa Touch框架&lt;span class=&quot;s1&quot;&gt;)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;②&lt;span class=&quot;s3&quot;&gt;&lt;span&gt;&lt;strong&gt;取消了OC指针和其他不安全访问&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span&gt;的使用.变量总是初始化之前使用，&lt;/span&gt;&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;数组和整数检查溢出&lt;/strong&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span&gt;，内存自动管理&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;③支持&lt;span class=&quot;s2&quot;&gt;代码预览&lt;span class=&quot;s1&quot;&gt;，&lt;span&gt;允许程序员在不编译和运行应用程序的前提下运行 Swift 代码并实时查看结果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;④舍弃OC 早起的SmallTalk的语法，全面改为打点调用(&lt;span class=&quot;s3&quot;&gt;&lt;strong&gt;使用点语法调用属性或者函数&lt;/strong&gt;&lt;span class=&quot;s1&quot;&gt;).&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;⑤提供了&lt;strong&gt;类似Java的命名空间&lt;/strong&gt;(name space)/&lt;strong&gt;泛型&lt;/strong&gt;(generic)/&lt;strong&gt;运算对象重载&lt;/strong&gt;(operator overloading&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;⑥&lt;span class=&quot;s2&quot;&gt;语法非常简洁&lt;span class=&quot;s1&quot;&gt;，&lt;span&gt;让编程的流程大大缩短、&lt;/span&gt;&lt;span class=&quot;s3&quot;&gt;简化、高效&lt;span class=&quot;s1&quot;&gt;、强大.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;⑦去掉NS前缀&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;3.为什么要学习Swift&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s1&quot;&gt;swift作为面向协议语言，&lt;strong&gt;不仅能写移动端，也可以做到搭建服务器端&lt;/strong&gt;。纵观国内外iOS开发界，已经有许多公司直接或间接采用swift开发，使用swift语言开发已成为未来iOS开发的趋势。swift以&lt;strong&gt;简洁、优雅&lt;/strong&gt;等优点迅速俘获广大开发者的青睐。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;二、用Playground 体验swift开发&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;打开Xcode ,选择创建一个playground 项目&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716234329518-147546263.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;左边代码区，右边显示区(编译结果)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716234346632-1975011878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;创建一个普通的UIView对象&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716234402431-457988177.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s1&quot;&gt;playgound文件的左边是代码区，右边则是显示结果的区域。当点击用于眼睛时会实时显示出界面效果&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;可以立即快速查看(Quick Look)和显示结果(Show Result)正如上图所示：&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s3&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;Swift 和OC的重大区别&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1&amp;gt;在swift中是没有.h和.m文件之分的。所有的代码全部都存储在一个文件里面。在swift中所有的代码都被封装在{}里面&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;2&amp;gt;OC使用alloc init进行初始化，而swift使用()&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;3&amp;gt;OC中使用[]来调用方法，而swift中采用点语法。比如UIColor.red&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;4&amp;gt;swift中不需要用分号分割语句&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;5&amp;gt;&lt;span class=&quot;s2&quot;&gt;不需要#import导入头文件，就可直接使用,&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s1&quot;&gt;6&amp;gt;&lt;strong&gt;print: NSLog,&lt;/strong&gt; true 和 false  替代 Yes 和 No &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;7&amp;gt;函数和闭包 &lt;strong&gt;使用func来声明一个函数，使用名字和参数来调用函数。使用-&amp;gt;来指定函数返回值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;8&amp;gt;子类的定义方法是在它们的类名后面加上父类的名字，用冒号分割。 子类如果要重写父类的方法的话，需要用override标记&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;9&amp;gt;&lt;strong&gt;枚举和结构体&lt;/strong&gt; 使用enum来创建一个枚举,使用struct来创建一个结构体。结构体和类有很多相同的地方，比如方法和构造器。它们结构体之间最大的一个区别就是 &lt;span&gt;结构体是传值，类是传引用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;10&amp;gt;接口和扩展: 使用protocol来声明一个接口&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;三、常量和变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;1&amp;gt;.数据类型：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;常见的数据类型变量：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716234554658-313104273.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;但其实，在swift中，是不存在基本的数据类型的，所谓的数据类型，其实都只是结构体&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716234612923-971716899.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;2.变量和常量：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;声明：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;swift中用&lt;strong&gt;let&lt;/strong&gt;声明常量，用&lt;strong&gt;var&lt;/strong&gt;声明变量。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;常量不能修改他的值&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716234650162-584319274.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;//错误示范，let z 在声明的时候并没有赋值常量是不可改变的，只能在声明时赋值&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716234723079-2025812418.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;在开发中，通常会优先选择使用let，因为不可变会更安全一点。所以建议在写代码之时，先选择let，等到需要变化的时候再改成var。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;自动推导：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;创建一个UIView,不指定类型。可以看到控制台上会打印出UIView的信息。这个现象被称为swift的自动推导。事实上，&lt;span class=&quot;s2&quot;&gt;在代码左侧定义的类型只是程序员希望的类型，而右侧才是程序真实的类型&lt;span class=&quot;s1&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716234816482-141223746.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;也就是说，变量或常量的类型会根据右侧代码执行的结果，推导出对应的类型。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;可以使用热键&lt;span class=&quot;s2&quot;&gt;&lt;strong&gt;option&lt;/strong&gt;&lt;span class=&quot;s1&quot;&gt;点击查看类型。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716234847543-1531511269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;严格之处：&lt;span&gt;在Swift 中，任何不同类型的数据之间是不允许直接运算的&lt;/span&gt;。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716234913920-1463809048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;如果非要让不同类型数据之间能够运算，可以将其中一个类型进行转换&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716234926932-2117756198.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;此时得到的结果就是25。在swift中，做&lt;span class=&quot;s2&quot;&gt;类型转换&lt;span class=&quot;s1&quot;&gt;&lt;span&gt;时是&lt;/span&gt;&lt;span class=&quot;s3&quot;&gt;将数据括起来&lt;/span&gt;&lt;span class=&quot;s3&quot;&gt;&lt;span class=&quot;s1&quot;&gt;，相当于swift结构体中的构造函数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716235042778-226768093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;当然也可以将前面的整数转换成Double型。此时就能打印出小数来。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716235056728-1792328740.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;结果是25.5&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;//&lt;strong&gt;指定类型&lt;/strong&gt;：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1425839/201807/1425839-20180716235117609-1149077527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 16 Jul 2018 15:52:00 +0000</pubDate>
<dc:creator>胡锦涛_Steven</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/StevenHuSir/p/Swift_Brief.html</dc:identifier>
</item>
<item>
<title>洛谷P3371单源最短路径Dijkstra版（链式前向星处理） - 非柠不可</title>
<link>http://www.cnblogs.com/fnbk/p/9321115.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnbk/p/9321115.html</guid>
<description>&lt;p&gt;首先讲解一下链式前向星是什么。简单的来说就是用一个数组（用结构体来表示多个量）来存一张图，每一条边的出结点的编号都指向这条边同一出结点的另一个编号（&lt;em&gt;&lt;span&gt;怎么这么的绕&lt;/span&gt;&lt;/em&gt;）&lt;/p&gt;
&lt;p&gt;如下面的程序就是存链式前向星。（不用链式前向星用邻接矩阵过不了，因为数据大会超空间限制）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; node{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quan,to,qian;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; }lian[&lt;span&gt;500010&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; qian[&lt;span&gt;10010&lt;/span&gt;&lt;span&gt;];//开始都为0，是个边界
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; z){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     lian[++ans].qian=&lt;span&gt;qian[x];//存前一个的编号，自己可以模拟一下很好理解的
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     lian[ans].quan=&lt;span&gt;z;//存对应的比边权
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     lian[ans].to=&lt;span&gt;y;//与之相连的点是哪一个存下来
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     qian[x]=&lt;span&gt;ans;//变成当前编号方便存下一个
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;学会了链式前向星，接下来就是Dijkstra算法。&lt;/p&gt;
&lt;p&gt;Dijkstra算法是基于贪心的算法，它是寻找每一点相连的边的最小值，在对整个图进行更新，做n-1次，也可以认为是一种动态规划，但不适用于有负边的情况，以后我会对它进行堆优化，现在用的Dijkstra是未经优化的版本。&lt;/p&gt;
&lt;p&gt;在很多高级算法的书上都会提到，我就不画图和证明正确性了，借助程序讲&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt; 1 #include&amp;lt;bits/stdc++.h&amp;gt;&lt;br/&gt;2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; node{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; quan,to,qian;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; }lian[&lt;span&gt;500010&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; n,m,s,dis[&lt;span&gt;10010&lt;/span&gt;],ans,qian[&lt;span&gt;10010&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; vis[&lt;span&gt;10010&lt;/span&gt;&lt;span&gt;]; 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; z){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     lian[++ans].qian=&lt;span&gt;qian[x];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     lian[ans].quan=&lt;span&gt;z;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     lian[ans].to=&lt;span&gt;y;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     qian[x]=&lt;span&gt;ans;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}//链式前向星存储
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dijkstra(){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     memset(vis,&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(vis));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     memset(dis,&lt;span&gt;0x3f&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(dis));
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     dis[s]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; now=&lt;span&gt;s;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     vis[s]=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;){//要将整张图寻找,所以要找n-1次
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             vis[now]=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;//记录是否已经遍历过
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; p=&lt;span&gt;qian[now];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (p!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){//边界是0前面已经说明，要自己理解
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (not vis[lian[p].to]&amp;amp;&amp;amp;(lian[p].quan+dis[now]&amp;lt;&lt;span&gt;dis[lian[p].to]))
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     dis[lian[p].to]=lian[p].quan+&lt;span&gt;dis[now];
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 p=&lt;span&gt;lian[p].qian;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            } //链式前向星寻找，每次更新没有遍历过的点的最小值
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; minn=&lt;span&gt;0x7fffffff&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=n;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt; (not vis[j]&amp;amp;&amp;amp;dis[j]&amp;lt;&lt;span&gt;minn){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                   minn=&lt;span&gt;dis[j];
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                   now=&lt;span&gt;j;//找最小的没遍历的点继续更新
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;m,&amp;amp;&lt;span&gt;s);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=m;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b,c;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;b,&amp;amp;&lt;span&gt;c);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        add(a,b,c);//处理读入数据
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    dijkstra();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (dis[i]&amp;gt;&lt;span&gt;100000000&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;2147483647&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;       &lt;span&gt;else&lt;/span&gt; printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,dis[i]);//输出结果
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; }&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 16 Jul 2018 15:41:00 +0000</pubDate>
<dc:creator>非柠不可</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnbk/p/9321115.html</dc:identifier>
</item>
<item>
<title>补习系列-springboot mime类型处理 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/9320944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/9320944.html</guid>
<description>[unable to retrieve full-text content]目标 1. 了解http常见的mime类型定义； 2. 如何使用springboot 处理json请求及响应； 3. 如何使用springboot 处理 xml请求及响应； 4. http参数的获取及文件上传下载； 5. 如何获得原始请求的字节流； 6.了解springboot 如何实现内容转换； </description>
<pubDate>Mon, 16 Jul 2018 15:26:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnbk/p/9321115.html</dc:identifier>
</item>
<item>
<title>ThreadLocal原理深入解析 - takumiCX</title>
<link>http://www.cnblogs.com/takumicx/p/9320881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takumicx/p/9320881.html</guid>
<description>&lt;h2 id=&quot;从一次项目经历说起&quot;&gt;1. 从一次项目经历说起&lt;/h2&gt;
&lt;p&gt;在上家公司做spark的任务调度系统时,碰到过这么一个需求:&lt;br/&gt;1.任务由一个线程执行,同时在执行过程中会创建多个线程执行子任务,子线程在执行子任务时又会创建子线程执行子任务的子任务。整个任务结构就像一棵高度为3的树。&lt;br/&gt;2.每个任务在执行过程中会生成一个任务ID,我需要把这个任务ID传给子线程执行的子任务,子任务同时也会生成自己的任务ID,并把自己的任务ID向自己的子任务传递。&lt;br/&gt;流程可由下图所示&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180716225018798-436102582.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方案有很多,比如借助外部存储如数据库,或者自己在内存中维护一个存储ID的数据结构。考虑到系统健壮性和可维护性,最后采用了jdk中的&lt;code&gt;InheritableThreadLocal&lt;/code&gt;来实现这个需求。&lt;br/&gt;来看下InheritableThreadLocal的结构&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InheritableThreadLocal&amp;lt;T&amp;gt; extends ThreadLocal&amp;lt;T&amp;gt; {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;InheritableThreadLocal继承自ThreadLocal,ThreadLocal可以说是一个存储线程私有变量的容器(当然这个说法严格来说不准确,后面我们就知道为什么)，而InheritableThreadLocal正如Inheritable所暗示的那样,它是可继承的:使用它可使子线程继承父线程的所有线程私有变量。因此我写了个工具类，底层使用InheritableThreadLocal来存储任务的ID，并且使该ID能够被子线程继承。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class InheritableThreadLocalUtils {

    private static final ThreadLocal&amp;lt;Integer&amp;gt; local = new InheritableThreadLocal&amp;lt;&amp;gt;();

    public static void set(Integer t) {
        local.set(t);
    }

    public static Integer get() {
        return local.get();
    }

    public static void remove() {
        local.remove();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过这个工具类的set方法和get方法分别实现任务ID的存取。然而在Code Review的時候，有同事觉得我这代码写的有问题:原因大概是InheritableThreadLocal在这里只有一个，子线程的任务ID在存储的时候会相互覆盖掉。真的会这样吗？为此我们用代码测试下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static void main(String[] args) {

    ExecutorService executorService = Executors.newCachedThreadPool();

    for(int i=0;i&amp;lt;10;i++){
        executorService.execute(new TaskThread(i));
    }

}

static class TaskThread implements Runnable{

    Integer taskId;

    public TaskThread(Integer taskId) {
        this.taskId = taskId;
    }

    @Override
    public void run() {
        InheritableThreadLocalUtils.set(taskId);
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.execute(new Runnable() {
            @Override
            public void run() {
                System.out.println(InheritableThreadLocalUtils.get());
            }
        });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码开启了10个线程标号从0到9，我们在每个线程中将对应的标号存储到InheritableThreadLocal，然后开启一个子线程，在子线程中获取InheritableThreadLocal中的变量。最后的结果如下&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180716225541005-1712892361.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个线程都准确的获取到了父线程对应的ID,可见并没有覆盖的问题。InheritableThreadLocal确实是用来存储和获取线程私有变量的，但是真实的变量并不是存储在这个InheritableThreadLocal对象中,它只是为我们存取线程私有变量提供了入口而已。因为InheritableThreadLocal只是在ThreadLocal的基础上提供了继承功能,为了弄清这个问题我们研究下ThreadLocal的源码。&lt;/p&gt;
&lt;h2 id=&quot;threadlocal源码解析&quot;&gt;2. ThreadLocal源码解析&lt;/h2&gt;
&lt;p&gt;ThreadLocal主要方法有两个，一个set用来存储线程私有变量，一个get用来获取线程私有变量。&lt;/p&gt;
&lt;h4 id=&quot;set方法源码解析&quot;&gt;2.1 set方法源码解析&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Sets the current thread's copy of this thread-local variable
 * to the specified value.  Most subclasses will have no need to
 * override this method, relying solely on the {@link #initialValue}
 * method to set the values of thread-locals.
 *
 * @param value the value to be stored in the current thread's copy of
 *        this thread-local.
 */
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Thread t = Thread.currentThread()获取了当前线程实例t,继续跟进第二行的getMap方法，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Get the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param  t the current thread
 * @return the map
 */
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;t是线程实例,而threadLocals明显是t的一个成员变量,进入一探究竟&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* ThreadLocal values pertaining to this thread. This map is maintained
 * by the ThreadLocal class. */
ThreadLocal.ThreadLocalMap threadLocals = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ThreadLocalMap是个什么结构?&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static class ThreadLocalMap {

    /**
     * The entries in this hash map extend WeakReference, using
     * its main ref field as the key (which is always a
     * ThreadLocal object).  Note that null keys (i.e. entry.get()
     * == null) mean that the key is no longer referenced, so the
     * entry can be expunged from table.  Such entries are referred to
     * as &quot;stale entries&quot; in the code that follows.
     */
    static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
            super(k);
            value = v;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ThreadLocalMap是类Thread中的一个静态内部类,看起来像一个HashMap,但和HashMap又有些不一样(关于它们的区别后面会讲),那我们就把它当一个特殊的HashMap好了。因此set方法中第二行代码&lt;br/&gt;ThreadLocalMap map = getMap(t)是通过线程实例t得到一个ThreadLocalMap。接下来的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (map != null)
        map.set(this, value);
    else
        createMap(t, value);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Create the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param t the current thread
 * @param firstValue value for the initial entry of the map
 */
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果这个threadlocalmap为null,先创建一个threadlocalmap,然后以当前threadlocal对象为key,以要存储的变量为值存储到threadlocalmap中。&lt;/p&gt;
&lt;h4 id=&quot;get方法源码解析&quot;&gt;2.2 get方法源码解析&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;
/**
 * Returns the value in the current thread's copy of this
 * thread-local variable.  If the variable has no value for the
 * current thread, it is first initialized to the value returned
 * by an invocation of the {@link #initialValue} method.
 *
 * @return the current thread's value of this thread-local
 */
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings(&quot;unchecked&quot;)
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先获取当前线程实例t,然后通过getMap(t)方法得到threadlocalmap(ThreadLocalMap是Thread的成员变量)。若这个map不为null,则以threadlocal为key获取线程私有变量,否则执行setInitialValue方法。看下这个方法的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;protected T initialValue() {
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先获取threadlocal的初始化值,默认为null,可以通过重写自定义该值;如果threadlocalmap为null,先创建一个;以当前threadlocal对象为key，以初始化值为value存入map中，最后返回这个初始化值。&lt;/p&gt;
&lt;h4 id=&quot;threadlocal源码总结&quot;&gt;2.3 ThreadLocal源码总结&lt;/h4&gt;
&lt;p&gt;总的来说,ThreadLocal的源码并不复杂,但是逻辑很绕。现总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.ThreadLocal对象为每个线程存取私有的本地变量提供了入口，变量实际存储在线程实例的内部一个叫ThreadLocalMap的数据结构中。&lt;/li&gt;
&lt;li&gt;2.ThreadLocalMap是一个类HashMap的数据结构，Key为ThreadLoca对象(其实是一个弱引用)，Value为要存储的变量值。&lt;/li&gt;
&lt;li&gt;3.使用ThreadLocal进行存取，其实就是以ThreadLocal对象为隐含的key对各个线程私有的Map进行存取。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以用下图的内存图像帮助理解和记忆&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180716225036320-525184510.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;threadlocalmap详解&quot;&gt;3. ThreadLocalMap详解&lt;/h2&gt;
&lt;p&gt;先看源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static class ThreadLocalMap {

    /**
     * The entries in this hash map extend WeakReference, using
     * its main ref field as the key (which is always a
     * ThreadLocal object).  Note that null keys (i.e. entry.get()
     * == null) mean that the key is no longer referenced, so the
     * entry can be expunged from table.  Such entries are referred to
     * as &quot;stale entries&quot; in the code that follows.
     */
    static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
            super(k);
            value = v;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;threadlocalmap的key为弱引用&quot;&gt;3.1 ThreadLocalMap的key为弱引用&lt;/h4&gt;
&lt;p&gt;ThreadLocalMap的key并不是ThreadLocal,而是WeakReference,这是一个弱引用，说它弱是因为如果一个对象只被弱引用引用到，那么下次垃圾收集时就会被回收掉。如果引用ThreadLocal对象的只有ThreadLocalMap的key，那么下次垃圾收集过后该key就会变为null。&lt;/p&gt;
&lt;h4 id=&quot;为何要用弱引用&quot;&gt;3.2 为何要用弱引用&lt;/h4&gt;
&lt;p&gt;减少了内存泄漏。试想我曾今存储了一个ThreadLocal对象到ThreadLocalMap中，但后来我不需要这个对象了,只有ThreadLocalMap中的key还引用了该对象。如果这是个强引用的话，该对象将一直无法回收。因为我已经失去了其他所有该对象的外部引用，这个ThreadLocal对象将一直存在，而我却无法访问也无法回收它，导致内存泄漏。又因为ThreadLocalMap的生命周期和线程实例的生命周期一致，只要该线程一直不退出，比如线程池中的线程，那么这种内存泄漏问题将会不断积累，直到导致系统奔溃。而如果是弱引用的话，当ThreadLocal失去了所有外部强引用的话，下次垃圾收集该ThreadLocal对象将被回收，对应的ThreadLocalMap中的key将为null。下次get和set方法被执行时将会对key为null的Entry进行清理。有效的减少了内存泄漏的可能和影响。&lt;/p&gt;
&lt;h4 id=&quot;如何真正避免内存泄漏&quot;&gt;3.3 如何真正避免内存泄漏&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;及时调用ThreadLocal的remove方法&lt;/li&gt;
&lt;li&gt;及时销毁线程实例&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;ThreadLocal为我们存取线程私有变量提供了入口,变量实际存储在线程实例的map结构中;使用它可以让每个线程拥有一份共享变量的拷贝，以非同步的方式解决多线程对资源的争用&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 14:58:00 +0000</pubDate>
<dc:creator>takumiCX</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takumicx/p/9320881.html</dc:identifier>
</item>
<item>
<title>C# 栈的应用 - 见风任然是风</title>
<link>http://www.cnblogs.com/sunven/p/9320803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunven/p/9320803.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;栈的特性：后进先出（LIFO）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;回文判断&quot;&gt;回文判断&lt;/h2&gt;
&lt;p&gt;类似123321，123a321即为回文&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将字符串前一半入栈&lt;/li&gt;
&lt;li&gt;依次弹出栈与字符串后一半比较&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static bool IsPlalindrome(string str)
{
    var stack = new Stack&amp;lt;char&amp;gt;();
    for (int i = 0; i &amp;lt; str.Length / 2; i++)
    {
        stack.Push(str[i]);
    }

    var len = str.Length % 2 == 0 ? str.Length / 2 : (str.Length + 1) / 2;
    for (int i = len; i &amp;lt; str.Length; i++)
    {
        if (stack.Pop() != str[i])
        {
            return false;
        }
    }
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;进制转化&quot;&gt;进制转化&lt;/h2&gt;
&lt;p&gt;10进制转8进制 1024→2000&lt;/p&gt;
&lt;p&gt;转换流程如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1024&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;取模入栈&lt;/li&gt;
&lt;li&gt;整除运算直至为0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void Main()
{
    Console.WriteLine(Get(4396, 8));
    Console.ReadKey();
}

public static int Get(int value, int i)
{
    var stack = new Stack&amp;lt;int&amp;gt;();
    while (value != 0)
    {
        stack.Push(value % i);
        value /= i;
    }
    return int.Parse(string.Join(&quot;&quot;, stack));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;括号匹配&quot;&gt;括号匹配&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;圆括号、方括号和花括号可以任意嵌套&lt;/li&gt;
&lt;li&gt;正确格式：{{90[]}}(4)&lt;/li&gt;
&lt;li&gt;错误格式：{2(1}1)[3]&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果时&lt;code&gt;(&lt;/code&gt;,&lt;code&gt;[&lt;/code&gt;,&lt;code&gt;{&lt;/code&gt; 则入栈&lt;/li&gt;
&lt;li&gt;如果时&lt;code&gt;)&lt;/code&gt;,&lt;code&gt;]&lt;/code&gt;,&lt;code&gt;}&lt;/code&gt; 则将对应左边括号弹出栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void Main()
{
    Console.WriteLine(Check(&quot;{abc[1](2)}sss(aaa)[({})]&quot;));
    Console.ReadKey();
}

public static bool Check(string str)
{
    var stack = new Stack&amp;lt;char&amp;gt;();
    foreach (var c in str)
    {
        switch (c)
        {
            case '(':
            case '{':
            case '[':
                stack.Push(c);
                break;
            case ')':
                if (stack.Count == 0 || stack.Pop() != '(')
                {
                    return false;
                }
                else
                {
                    break;
                }
            case '}':
                if (stack.Count == 0 || stack.Pop() != '{')
                {
                    return false;
                }
                else
                {
                    break;
                }
            case ']':
                if (stack.Count == 0 || stack.Pop() != '[')
                {
                    return false;
                }
                else
                {
                    break;
                }
        }
    }
    return stack.Count == 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;中缀转后缀表达式求职&quot;&gt;中缀转后缀表达式求职&lt;/h2&gt;
&lt;p&gt;运算规则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从左算到右&lt;/li&gt;
&lt;li&gt;先乘除，后加减&lt;/li&gt;
&lt;li&gt;先括号内，后括号外&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相邻两个操作符优先级判断如下：&lt;/p&gt;
&lt;p&gt;c1表示前一个操作符，c2表示后一个操作符&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;(&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;)&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分操作数栈和操作符栈&lt;/li&gt;
&lt;li&gt;操作数进操作数栈&lt;/li&gt;
&lt;li&gt;当前操作符优先级大于顶栈操作符则入栈&lt;/li&gt;
&lt;li&gt;当前操作符优先级小于顶栈操作符，则弹出顶栈，弹出两个操作数运算，运算结果再入栈&lt;/li&gt;
&lt;li&gt;重复上一步骤，直至将当前操作符入栈&lt;/li&gt;
&lt;li&gt;若最后两栈都不为空，则依次弹出操作符与操作数计算，直至操作符栈为空，此时操作数栈剩一个元素即为最终结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static void Main()
{
    Console.WriteLine(Calculation(&quot;(2+3)*2+2*(6-3)/(4-2)+2&quot;));
    Console.ReadKey();
}

public static int Calculation(string str)
{
    //操作数栈
    var opndStack = new Stack&amp;lt;int&amp;gt;();
    //操作符栈
    var optrStack = new Stack&amp;lt;char&amp;gt;();
    foreach (var c in str)
    {
        if (char.IsDigit(c))
        {
            //当前的字符是操作数
            opndStack.Push(int.Parse(c.ToString()));
        }
        else
        {
            //当前的字符是操作符
            while (optrStack.Count != 0)
            {
                var priority = Priority(optrStack.Peek(), c);
                if (priority == '&amp;lt;')
                {
                    //栈顶优先级小与当前操作符
                    //入栈
                    optrStack.Push(c);
                    break;
                }
                if (priority == '=')
                {
                    //栈顶优先级等于当前操作符
                    //就是左右括号匹配，弹出左括号
                    optrStack.Pop();
                    break;
                }

                if (priority != '&amp;gt;')
                {
                    continue;
                }
                //栈顶优先级大于当前操作符
                //需要计算
                var optr = optrStack.Pop();
                var value2 = opndStack.Pop();
                var value1 = opndStack.Pop();
                opndStack.Push(Operate(value1, optr, value2));
            }
            //1.第一次栈为空直接入栈。
            //2.退栈直至为空当前操作符也需要入栈,但&quot;)&quot;无需入栈
            if (optrStack.Count == 0 &amp;amp;&amp;amp; c != ')')
            {
                optrStack.Push(c);
            }
        }
    }
    while (optrStack.Count != 0)
    {
        var optr = optrStack.Pop();
        var value2 = opndStack.Pop();
        var value1 = opndStack.Pop();
        opndStack.Push(Operate(value1, optr, value2));
    }
    return opndStack.Count == 1 ? opndStack.Pop() : 0;
}

public static int Operate(int value1, char optr, int value2)
{
    switch (optr)
    {
        case '+':
            return value1 + value2;
        case '-':
            return value1 - value2;
        case '*':
            return value1 * value2;
        case '/':
            return value1 / value2;
    }
    return 0;
}

/// &amp;lt;summary&amp;gt;
/// 比较栈顶操作符与当前操作符优先级
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;c1&quot;&amp;gt;栈顶操作符&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;c2&quot;&amp;gt;当前操作符&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public static char Priority(char c1, char c2)
{
    switch (c1)
    {
        case '+':
        case '-':
            if (c2 == '+' || c2 == '-' || c2 == ')')
            {
                return '&amp;gt;';
            }
            return '&amp;lt;';
        case '*':
        case '/':
            if (c2 == '(')
            {
                return '&amp;lt;';
            }
            return '&amp;gt;';
        case '(' when c2 == ')':
            return '=';
        case '(':
            return '&amp;lt;';
        case ')':
            return '&amp;gt;';
    }
    return '&amp;gt;';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;reference&quot;&gt;reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/gavin_john/article/details/71374487&quot;&gt;栈的应用&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 14:31:00 +0000</pubDate>
<dc:creator>见风任然是风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunven/p/9320803.html</dc:identifier>
</item>
<item>
<title>吴恩达《深度学习》第四门课（2）卷积神经网络：实例探究 - ysyouaremyall</title>
<link>http://www.cnblogs.com/ys99/p/9320781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ys99/p/9320781.html</guid>
<description>&lt;h2&gt;2.1为什么要进行实例探究&lt;/h2&gt;
&lt;p&gt;（1）就跟学编程一样，先看看别人怎么写的，可以模仿。&lt;/p&gt;
&lt;p&gt;（2）在计算机视觉中一个有用的模型，，用在另一个业务中也一般有效，所以可以借鉴。&lt;/p&gt;
&lt;p&gt;（3）本周会介绍的一些卷积方面的经典网络经典的包括：LeNet、AlexNet、VGG；流行的包括：ResNet、Inception，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716191626433-201470186.png&quot; alt=&quot;&quot; width=&quot;247&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2经典网络&lt;/h2&gt;
&lt;p&gt;（1）LeNet-5网络结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716192543643-1801814313.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;270&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）在LeNet-5中的一些注意点：网络输入单通道的，大概有6万个参数，池化用的是平均池化而不是最大值池化，还没有用到padding，输出也不是现在的softmax，激活函数用的是sigmoid和tanh。综上可以看出来许多设置在今天看来都是不合适的了，说明网络在发展。&lt;/p&gt;
&lt;p&gt;（3）AlexNet网络结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716193736937-444964175.png&quot; alt=&quot;&quot; width=&quot;755&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）AlexNet与LeNet-5有非常多相似之处，但前者的网络更深更大，参数达到6000万，同时使用了Relu激活函数。&lt;/p&gt;
&lt;p&gt;（5）VGG-16网络结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716194509367-294382132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（6）VGG-16网络的说明：16代表卷积层加全连接层一共16层，图中的×2表示连续两次相同的卷积，所有卷积padding都是用了same，卷积核的个数都是成倍增加，而高宽刚好对半减小，真个网络非常简洁优美，网络参数非常多达到了1.38亿各参数，在今天看来依旧是非常大的网络。&lt;/p&gt;
&lt;h2&gt;2.3残差网络（Residual Networks（ResNets））&lt;/h2&gt;
&lt;p&gt;（1）一般正常的网络会进行如下操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716195835438-1200529521.png&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;291&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）然后将a&lt;sup&gt;[l]&lt;/sup&gt;传到下下层的激活函数之前，即进行如下计算，就得到了残差块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716200008278-1729473424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）以下是一个有五个残差块的网络：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716200118550-604451682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）残差网络克服了网络很深时存在的梯度消失或爆炸的问题。&lt;/p&gt;
&lt;p&gt;（5）下图展示了普通网络和残差网络随着网络深度训练误差的变化，普通网络由于网络很深之后难以训练所以训练误差变大了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716200316667-1737086612.png&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.4残差网络有什么用&lt;/h2&gt;
&lt;p&gt;（1）因为残差网络很容易学习恒等式函数，所以随着网络加深，至少不会让网络变差。如下图中添加了两层，使用Relu激活函数，当W&lt;sup&gt;[l+2]&lt;/sup&gt;，b&lt;sup&gt;[l+2]&lt;/sup&gt;都为0时，输出还是和不添加这两层的结果一样，都是a&lt;sup&gt;[l]&lt;/sup&gt;，这就是学习恒等式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716201446846-1304452453.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）另个一需要讨论的问题就是维度匹配问题，当z&lt;sup&gt;[l+2]&lt;/sup&gt;和a&lt;sup&gt;[l]&lt;/sup&gt;相同时，可以直接相加，如果不同时需要在让a&lt;sup&gt;[l]&lt;/sup&gt;与矩阵W&lt;sub&gt;s&lt;/sub&gt;相乘，W&lt;sub&gt;s&lt;/sub&gt;的维度为（a&lt;sup&gt;[l+2]&lt;/sup&gt;,a&lt;sup&gt;[l]&lt;/sup&gt;），如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716202154239-647863084.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.5网络中的网络以及1×1卷积&lt;/h2&gt;
&lt;p&gt;（1）1×1计算示意图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716203948829-1770915622.png&quot; alt=&quot;&quot; width=&quot;610&quot; height=&quot;184&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）作用：首先相当于把一个点的所有通道进行了全连接操作；其次是起到压缩通道的作用（最重要的作用），或者保持不变，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716204135784-899670356.png&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.6谷歌Inception网路简介&lt;/h2&gt;
&lt;p&gt;（1）构建卷积层时，你要决定使用多大的卷积核（如1×1,3×3,5×5等）或者要不要添加池化层，而Inception网络的Inception层作用就是它将替你做决定。&lt;/p&gt;
&lt;p&gt;（2）下面就是一个典型的Inception模块的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716204938389-1433083838.png&quot; alt=&quot;&quot; width=&quot;673&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）用1×1卷积核来构建瓶颈层可以大大减少计算量：&lt;/p&gt;
&lt;p&gt;首先是没有添加1×1卷积核如下图所示，由于加法的运算次数和乘法运算次数接近，所以这里只求乘法的计算次数：（5*5*192）*（28*28*32）=1.2亿&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716205710627-632761065.png&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;260&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加了卷积核之后，如下图所示，整个的输入输出是没有发生改变的，乘法计算量为（1*1*16）*（28*28*16）+（5*5*16）*（28*28*32）=1240万。只有上面的十分之一。所以计算量减少了很多，同时只要合理构建，不会影响网络性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716210750759-349169354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.7Inception网络&lt;/h2&gt;
&lt;p&gt;（1）下面是Inception的一个单元，需要注意的是池化时保持尺寸不变，同时池化不能改变通道数导致通道特别多，所以在其后面添加了1×1卷积核压缩通道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716211625519-2088264406.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）下面是一个完整的Inception网络，其中可以看到有一些分支，他们同样可以做最终输出预测，这样做是为了防止过拟合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716212212528-1370299601.png&quot; alt=&quot;&quot; width=&quot;732&quot; height=&quot;388&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.8使用开源的实现方案&lt;/h2&gt;
&lt;p&gt;（1）在GitHub上找资源，然后在此基础上进行开发，会有更快的进展。&lt;/p&gt;
&lt;h2&gt;2.9迁移学习&lt;/h2&gt;
&lt;p&gt;（1）下载别人的模型，以前预训练的权重来初始化，同时将输出层根据自己的需要来修改，比如说分三种类别（已经包括其它了），那么输出为3个单元的sotfmax。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716213735936-724027002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）冻结别人训练好的参数，在深度学习框架中可能参数是trainableParameter=0，或者freeze=1等，视实际框架而定。&lt;/p&gt;
&lt;p&gt;（3）一个重要技巧是：数据量少时只训练最后一层，这时可以将图片输入，然后将最后一层前的输出存到硬盘中，因为这些值是不会改变的。然后在用这些值作为输入训练最后一层，这样不要每次都经过前面的网络，训练会大大加快。&lt;/p&gt;
&lt;p&gt;（4）当数据量越来越大时，从后往前可以训练更多的层，极端情况下是所有层的参数都参与训练。&lt;/p&gt;
&lt;h2&gt;2.10数据扩充&lt;/h2&gt;
&lt;p&gt;（1）镜像、随机裁剪、旋转、剪切、扭曲&lt;/p&gt;
&lt;p&gt;（2）色彩转换（如给一些通道加值）&lt;/p&gt;
&lt;p&gt;（3）在实际使用过程中可以使用多线程，一些线程从硬盘中取出数据，然后进行数据扩充，再传入其他线程进行训练，这样就可以并行实现了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180716215125630-1757268258.png&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.11计算机视觉现状&lt;/h2&gt;
&lt;p&gt;（1）对于计算机视觉而言，其实当前的数据量是远远不够的，所以需要设计出一些更复杂的网络，以及人工去调整非常多的超参数，其本质都是因为数据量不够；假设数据量非常够的时候，网络也好，超参数也好都可以使用更简单的架构和调整。&lt;/p&gt;
&lt;p&gt;（2）再次强调多多使用迁移学习，站在巨人的肩膀上。另外如果要自己设计研究全新的网络可能需要自己从头开始训练。&lt;/p&gt;
&lt;p&gt;（3）为了在竞赛中取得好成绩，常常是以巨大的计算量为代价的（如用多个网络计算输出取平均），这在实际应用中不太实用。&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 14:25:00 +0000</pubDate>
<dc:creator>ysyouaremyall</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ys99/p/9320781.html</dc:identifier>
</item>
<item>
<title>2018百度之星开发者大赛－paddlepaddle学习 - bobxx</title>
<link>http://www.cnblogs.com/bobxxxl/p/9320751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bobxxxl/p/9320751.html</guid>
<description>&lt;p&gt;本次比赛赛题是进行人流密度的估计，因为之前看过很多人体姿态估计和目标检测的论文，隐约感觉到可以用到这次比赛上来，所以趁着现在时间比较多，赶紧报名参加了一下比赛，比赛规定用paddlepaddle来进行开发，所以最近几天先学习一下paddlepaddle的相关流程，在这里记录一下，也好让自己真正的能够学到东西。&lt;/p&gt;

&lt;p&gt;在我看来，设计一个深度学习网络（主要是基于CNN的，其他的没怎么接触），主要有以下几方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据的读取（这里主要是图片数据和它的“标签”）。&lt;/li&gt;
&lt;li&gt;数据的预处理（包含数据集增强和你需要的操作）。&lt;/li&gt;
&lt;li&gt;如何将你的数据送入网络。&lt;/li&gt;
&lt;li&gt;网络结构的设计（layer的使用）。&lt;/li&gt;
&lt;li&gt;损失函数的计算（这部分是根据你的任务决定的）。&lt;/li&gt;
&lt;li&gt;优化器的选择（我想一般是adam吧）&lt;a href=&quot;https://blog.csdn.net/u010089444/article/details/76725843&quot;&gt;这里&lt;/a&gt;有一篇博客分享了各种优化算法的不同。&lt;/li&gt;
&lt;li&gt;模型的存储以及加载（加载这部分其实挺重要的，之前看过一篇论文说应用ImageNet上预训练的模型进行迁移学习，往往能在新的任务上取得更好的效果，当然也不是绝对的）。&lt;/li&gt;
&lt;li&gt;如何进行测试（可以说就是如何进行前向传播）。&lt;/li&gt;
&lt;li&gt;可选：可视化。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来就以上几部分进行学习，在次非常感谢&lt;a href=&quot;http://www.cnblogs.com/charlotte77/&quot;&gt;Charlotte77&lt;/a&gt;和&lt;a href=&quot;https://my.csdn.net/qq_33200967&quot;&gt;夜雨飘零1&lt;/a&gt;。他们的博文给予了我莫大的帮助，向大佬叩首。&lt;/p&gt;

&lt;p&gt;对于本次比赛来说，我的数据是图片（各种监控的图片，大小不同），标注是json格式的文件，所以接下来要讨论一下在paddlepaddle中如何以图片为输入。&lt;/p&gt;
&lt;p&gt;参见&lt;a href=&quot;https://www.cnblogs.com/charlotte77/p/7802226.html&quot;&gt;大佬Charlotte77的博文&lt;/a&gt;，paddlepaddle主要是通过reader来进行数据的输入，这里我参考了paddlepaddle github 上的&lt;a href=&quot;https://github.com/PaddlePaddle/models/tree/develop/fluid/object_detection&quot;&gt;SSD的例子&lt;/a&gt;的例子，先看他们的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;train_reader = paddle.batch(
    reader.train(data_args, train_file_list), batch_size=batch_size)
test_reader = paddle.batch(
    reader.test(data_args, val_file_list), batch_size=batch_size)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中reader是import来的，我们以reader.train来看一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def train(settings, file_list, shuffle=True):
    file_list = os.path.join(settings.data_dir, file_list)
    if 'coco' in settings.dataset:
        train_settings = copy.copy(settings)
        if '2014' in file_list:
            sub_dir = &quot;train2014&quot;
        elif '2017' in file_list:
            sub_dir = &quot;train2017&quot;
        train_settings.data_dir = os.path.join(settings.data_dir, sub_dir)
        return coco(train_settings, file_list, 'train', shuffle)
    else:
        return pascalvoc(settings, file_list, 'train', shuffle)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里看得出来，是利用了之前定义的coco函数或者pascalvoc函数，就是从不同的数据集读取数据，以coco为例，看一下，到底返回了什么，&lt;a href=&quot;https://github.com/PaddlePaddle/models/blob/develop/fluid/object_detection/reader.py&quot;&gt;这里&lt;/a&gt;代码有点长，我们主要看返回的是什么：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
            if 'cocoMAP' in settings.ap_version:
                yield im, boxes, lbls, iscrowd, \
                    [im_id, im_width, im_height]
            else:
                yield im, boxes, lbls, iscrowd

    return reader&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;balabala一大堆，终于发现，返回的是一个生成器reader，可见，主要就在于生成这个生成器，下面来总结一下padlepaddle输入数据的生成：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把你的数据（图片，标签）搞出来，然后用yield来产生一个生成器：reader。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;将此reader生成batch，也就是train_reader = paddle.batch(reader, batch_size=batch_size)这样子。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接下来就是送入网络了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面第三步就是将数据送入网络，这是如何办到的呢,用过tensorflow的童鞋们可能知道，我们可以用一个palceholder（占位符）来链接我们的原始数据和我们的网络，在这里，也是同样的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;image = fluid.layers.data(name='image', shape=image_shape, dtype='float32')
gt_box = fluid.layers.data(name='gt_box', shape=[4], dtype='float32', lod_level=1)
gt_label = fluid.layers.data(name='gt_label', shape=[1], dtype='int32', lod_level=1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用的是fluid.layers.data，等一下，lod_level是啥，这里paddlepaddle有个序列输入格式，这里lod_level为１说明这条数据是序列格式，那为啥我们的图片不是序列格式？这里图片的size第一维应该就是batch_size,我们注意到后面的gt_box和gt_label没有制定第一维，他们就是一个向量或者整数，为啥不像tensorflow里面直接就指定第一维为batch_size?因为paddlepaddle输入数据格式里面没有QAQ!具体查看&lt;a href=&quot;https://www.cnblogs.com/charlotte77/p/7802226.html&quot;&gt;大佬Charlotte77的博文&lt;/a&gt;吧，这部分我在官网没找到...&lt;/p&gt;
&lt;p&gt;有了这个“占位符”之后，只需将我们之前的那个batch_size的train_reader feed进去就好了，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;feeder = fluid.DataFeeder(place=place, feed_list=[image, gt_box, gt_label])
if args.parallel:
    loss_v, = train_exe.run(fetch_list=[loss.name],feed=feeder.feed(data))#这里的data就是之前train_reader的数据，fetch_list就是要执行的operation的名称,feed的顺序就是上面feed_list指定的
else:
    loss_v, = exe.run(fluid.default_main_program(),
                      feed=feeder.feed(data),
                      fetch_list=[loss])
#train_exe和exe是之前定义的，类似与tensorflow的session(个人感觉，实际上还是不一样的)如下：
#exe = fluid.Executor(place)
#train_exe = fluid.ParallelExecutor(use_cuda=args.use_gpu, loss_name=loss.name)
#其中place为指定设备（CPU GPU）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，总结一下，如何将数据送入网络（在有了reader的前提下）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义一个“占位符”,也就是fluid.layers.data。&lt;/li&gt;
&lt;li&gt;定义一个feeder(fluid.DataFeeder),来指定设备和feed顺序。&lt;/li&gt;
&lt;li&gt;运用执行器（这个后面再说）的run,指定你需要运行的operation，然后feed数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看到这里，我总是感觉paddlepaddle的fluid和tensorflow很像，先定义图模型，然后运行，但是看到官方说fluid是和TensorFlow Eager Execution很像，据我了解（没有用过，所以有可能是错误的，望批评指正）TensorFlow Eager Execution是针对之前tensoflow不能实时出结果（必须sess.run）来设计的，但是现在看好像不是很像，以后看懂了再来解释。留坑。&lt;/p&gt;

&lt;p&gt;这部分我们直接看代码吧，在SSD的例子中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;locs, confs, box, box_var = mobile_net(num_classes, image, image_shape)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用了&lt;a href=&quot;https://github.com/PaddlePaddle/models/blob/develop/fluid/object_detection/mobilenet_ssd.py&quot;&gt;mobile_net模型&lt;/a&gt;，这个有兴趣自己看吧，主要是fluid.layers中各种层的应用，这个估计各个深度学习框架都差不多，这部分实现的还是挺全的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;loss = fluid.layers.ssd_loss(locs, confs, gt_box, gt_label, box,box_var)
loss = fluid.layers.reduce_sum(loss)
...
optimizer = fluid.optimizer.RMSProp(
    learning_rate=fluid.layers.piecewise_decay(boundaries, values),
    regularization=fluid.regularizer.L2Decay(0.00005), )
optimizer.minimize(loss)
place = fluid.CUDAPlace(0) if args.use_gpu else fluid.CPUPlace()
exe = fluid.Executor(place)
exe.run(fluid.default_startup_program())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看这一部分，定义了loss，然后指定了优化器，然后最小化loss，指定设备，然后启动我们的程序。我感觉这里是个大坑！有没有发现有些文档里面不是这么个流程，而是这样子的（来源paddlepaddle &lt;a href=&quot;https://github.com/PaddlePaddle/book/blob/high-level-api-branch/03.image_classification/train.py&quot;&gt;03.image_classification&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;place = fluid.CUDAPlace(0) if use_cuda else fluid.CPUPlace()
trainer = fluid.Trainer(
    train_func=train_program, optimizer_func=optimizer_program, place=place)
trainer.train(
    reader=train_reader,
    num_epochs=EPOCH_NUM,
    event_handler=event_handler,
    feed_order=['pixel', 'label'])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定了一个trainer然后调用train。&lt;/p&gt;
&lt;p&gt;还有&lt;a href=&quot;http://www.cnblogs.com/charlotte77/p/7906363.html&quot;&gt;一种&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;parameters = paddle.parameters.create(cost)
trainer = paddle.trainer.SGD(cost=cost,
                             parameters=parameters,update_equation=momentum_optimizer)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先根据cost(loss)产生要优化的参数，然后指定这些参数进行优化。&lt;/p&gt;
&lt;p&gt;这到底用哪一种呢？幸好有&lt;a href=&quot;https://blog.csdn.net/qq_33200967/article/details/79126897&quot;&gt;大佬夜雨飘零1&lt;/a&gt;的经验，是因为新版本Fluid的原因，现在大部分都是用executor来进行编写的。所以以后也不用烦恼了，这里吐槽一下官方文档，感觉维护人员要少吃一个鸡腿，不同版本变化太大，然而官方只给最新的示例，但是对于之前的代码并没有进行版本的说明，导致我们学习起来有点混乱，希望能够重新写一下book。&lt;/p&gt;

&lt;p&gt;这部分&lt;a href=&quot;http://paddlepaddle.org/docs/0.14.0/documentation/fluid/zh/new_docs/user_guides/howto/training/save_load_variables.html&quot;&gt;官方文档&lt;/a&gt;资料挺全的，当然对于大家比较关心的如何加载ImageNet 预训练模型，也是有的，&lt;a href=&quot;https://github.com/PaddlePaddle/models/tree/develop/image_classification&quot;&gt;这里&lt;/a&gt;有例子，但是说实话这里有点问题，大佬在&lt;a href=&quot;https://github.com/PaddlePaddle/Paddle/issues/9274&quot;&gt;这里&lt;/a&gt;也做了讨论，本来想参考官方文档进行resnet的加载，但是一方面官方脚本执行时连接不上，再看模型加载会出现各种问题，所以暂时放弃了这种想法，等一下官方的优化。&lt;/p&gt;
&lt;p&gt;这部分的主要代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exe = fluid.Executor(fluid.CPUPlace())
param_path = &quot;./my_paddle_model&quot;
prog = fluid.default_main_program()
fluid.io.save_params(executor=exe, dirname=param_path, main_program=None)
...
exe = fluid.Executor(fluid.CPUPlace())
param_path = &quot;./my_paddle_model&quot;
prog = fluid.default_main_program()
fluid.io.load_params(executor=exe, dirname=param_path,
                     main_program=prog)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见是通过fluid.io来实现的。&lt;/p&gt;

&lt;p&gt;这部分应该是paddlepaddle的优势了，一方面我们训练的过程中希望能够进行测试，一方面当我们的模型训练完以后我们也希望能够利用前向传播进行预测。paddlepaddle都有这两方面实现：第一种官方给了很好的示例，这里就不赘述了。对于第二种，paddlepaddle也进行了很好的封装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;inferencer = fluid.Inferencer(
# infer_func=softmax_regression, # uncomment for softmax regression
# infer_func=multilayer_perceptron, # uncomment for MLP
infer_func=convolutional_neural_network,  # uncomment for LeNet5
param_path=params_dirname,
place=place)
results = inferencer.infer({'img': img})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;convolutional_neural_network就是你的模型里面生成predict的那个函数，params_dirname是保存参数的路径，可见，用paddlepaddle来进行前向传播十分简单，定义好数据之后，加载参数，然后调用infer就可以预测了。&lt;/p&gt;

&lt;p&gt;paddlepaddle还有很好的部署能力，但是局限于我现在用的功能，这部分并没有研究，这篇博客主要是串一下如何用paddlepadle搭建深度学习模型，其中有很多细节没有注意，而且有很多地方也不一定准确，希望各位多批评指正。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u010089444/article/details/76725843&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/u010089444/article/details/76725843&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/charlotte77/p/7802226.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/charlotte77/p/7802226.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/charlotte77/p/7906363.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/charlotte77/p/7906363.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/PaddlePaddle/models/tree/develop/fluid/object_detection&quot; class=&quot;uri&quot;&gt;https://github.com/PaddlePaddle/models/tree/develop/fluid/object_detection&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/PaddlePaddle/book/blob/high-level-api-branch/03.image_classification/train.py&quot; class=&quot;uri&quot;&gt;https://github.com/PaddlePaddle/book/blob/high-level-api-branch/03.image_classification/train.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_33200967/article/details/79126897&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qq_33200967/article/details/79126897&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://paddlepaddle.org/docs/0.14.0/documentation/fluid/zh/new_docs/user_guides/howto/training/save_load_variables.html&quot; class=&quot;uri&quot;&gt;http://paddlepaddle.org/docs/0.14.0/documentation/fluid/zh/new_docs/user_guides/howto/training/save_load_variables.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 14:16:00 +0000</pubDate>
<dc:creator>bobxx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bobxxxl/p/9320751.html</dc:identifier>
</item>
<item>
<title>《前端之路》之四 JavaScript 的闭包、作用域、作用域链 - SmallW</title>
<link>http://www.cnblogs.com/erbingbing/p/9320050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/erbingbing/p/9320050.html</guid>
<description>&lt;h4 id=&quot;javascript-的闭包&quot;&gt;04：JavaScript 的闭包&lt;/h4&gt;
&lt;h5 id=&quot;一定义&quot;&gt;一、定义：&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;常规定义：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;闭包的定义： 有权利访问外部函数作用域的函数。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;通俗定义：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、函数内部包含了函数。然后内部函数可以访问外部函数的作用域。
2、内部函数可以访问 父级函数的作用域。
...等等等&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;二思考&quot;&gt;二、思考：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;1、我们在日常的开发过程中会应用到 闭包么？
2、如果有遇到的话，会是在什么情况下遇到的？
3、举一些 具体的例子。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;1、我们在日常的开发过程中会应用到 闭包么？&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;以之前的知识对于 闭包的理解来讲是这样的&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
    (function(){
        for(var i=0; i&amp;lt;10; i++) {
            console.log(i)
        }
    })()
    &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;或者说是这样的&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
    var fnX = function() {
        var x = 123
        function y() {
            alert(x)
        }
        y()
    }

    fnX()   // 123&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;总结下之前的理解就是： 内部函数能访问外部函数作用域，能够保存变量不被销毁而一直存在。&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;三作用&quot;&gt;三、作用：&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;在JavaScript中有作用域和执行环境的问题，在函数内部的变量在函数外部是无法访问的，在函数内部却可以得到全局变量。由于种种原因，我们有时候需要得到函数内部的变量，可是用常规方法是得不到的，这时我们就可以创建一个闭包，用来在外部访问这个变量。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;通过将一个方法或者属性声明为私用的，可以让对象的实现细节对其他对象保密以降低对象之间的耦合程度，可以保持数据的完整性并对其修改方式加以约束，这样可以是代码更可靠，更易于调试。封装是面向对象的设计的基石。&lt;/code&gt;&lt;/p&gt;
&lt;h6 id=&quot;什么是作用域&quot;&gt;3.1 什么是作用域&lt;/h6&gt;
&lt;h6 id=&quot;es5的作用域问题&quot;&gt;3.1.1 ES5的作用域问题&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;在 ES5 中 我们常常会说的一个概念是 局部变量 和 全局变量

那么 局部变量 和 全局变量 所这个 局部 和 全局则为 作用域。

这个概念其实介绍起来还是比较多虚无。 但是我记得有一本书 叫 《你不知道的JS》

在这本书的 上册 作者详细的介绍了 作用域 这个概念。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;作用域是什么&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　1.现代JavaScript已经不再是解释执行的，而是编译执行的。但是与传统的编译语言不同，它不是提前编译，编译结果不能进行移植。编译过程中，同样会经过分词／词法分析,解析／语法分析,代码生成三个阶段。

　　2.以var a = 2;语句为例，对这一程序语句对处理，需要经过引擎,编译器,作用域三者的配合。其中，引擎从头到尾负责整个javascript程序的编译和执行过程；编译器负责语法分析和代码生成；作用域负责收集并维护由所有声明的标识符组成的系列查询，并实施一套规则，确定当前执行的代码对这些标识符的访问权限。

　　3.对于var a = 2;编译器首先查找作用域中是否已经有该名称的变量，然后引擎中执行编译器生成的代码时，会首先查找作用域。如果找到就执行赋值操作，否则就抛出异常

　　4.引擎对变量的查找有两种：LHS查询和RHS查询。当变量出现中赋值操作左侧时是LHS查询，出现中右侧是RHS查询&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;词法作用域&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.词法作用域就是定义在词法阶段的作用域。词法作用域是由你在写代码时将变量和块作用域写在哪里决定的，词法处理器分析代码时会保持作用域不变

2.作用域查找会在找到第一个匹配的标识符时停止

3.eval和with可以欺骗词法作用域，不推荐使用&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;函数作用域和块作用域&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.JavaScript具有基于函数的作用域，属于这个函数的变量都可以在整个函数的范围内使用及复用
2.(function fun(){})() 函数表达式和函数声明的区别是看function关键字出现在声明中的位置。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式

3.with,try/catch具有块作用域，方便好用的实现块级作用域的是es6带来的let关键字&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;提升&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    1. 变量的提升
    2. 函数提升  （这里就不过多的赘述了）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;动态作用域&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　　1.词法作用域是一套引擎如何寻找变量以及会在何处找到变量的规则。词法作用域最重要的特征是它的定义过程发生中代码的书写阶段

　　2.动态作用域让作用域作为一个在运行时就被动态确定的形式，而不是在写代码时进行静态确定的形式。eg:&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function foo(){ 
    console.log(a);  // 2 
} 
function bar(){ 
    var a = 3; 
    foo(); 
} 
var a = 2; 
bar(); &lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;词法作用域让foo()中的a通过RHS引用到了全局作用域中的a，所以输出2；动态作用域不关心函数和作用域如何声明以及在何处声明，只关心从何处调用。换言之，作用域链是基于调用栈的，而不是代码中的作用域嵌套。如果以动态作用域来看，上面代码中执行时会输出3


　　3.JavaScript不具备动态作用域，但是this机制中某种程度上很像动态作用域，this关注函数如何调用。&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;es6的作用域问题&quot;&gt;3.1.2 ES6的作用域问题&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;在 ES6 中 出现了块级作用域的概念

let const 在（） 内则 （）内的作用域 为 块级作用域。&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;什么是执行环境&quot;&gt;3.2 什么是执行环境&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;执行环境 即为 当前作用域内的环境。&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;什么是作用域链&quot;&gt;3.3 什么是作用域链&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;这个概念其实 也是比较虚的概念，不太好理解。但是一旦理解就不会忘记了。

所谓 链 其实就是链条， 将需要链接在一起的东西链接在一起（感觉说了一句废话）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;作用域链的通俗理解：&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在函数内部作用域 通过 作用域链 可以访问 函数外部作用域 的属性或者方法。

一层层的 作用域链 往外走  到最后 则为 window 对象的全局作用域。

然后这一条条的 作用域链 就形成了一整条关联的链条。&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;四具体案例的分析&quot;&gt;四、具体案例的分析:&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;这里 我们举了一个栗子 🌰&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;eg1:&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person(name) {
    this.name = name
    this.getName = function() {
        return this.name
    }
}

var one = new Person('zhang')
one.getName() // zhang
one.name      // zhang

var two = new Person('wang')
two.getName() // wang
one.name      // wang
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;eg2:&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Person(name) {
    var _name = name
    this.getName = function() {
        return _name
    }
} 

var one = new Person('zhang')
one.getName() // zhang

var two = new Person('wang')
two.getName() // wang
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;eg1 vs eg2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;这二个例子进行对比，虽然 都拿到了自己想要的 name 但是 eg1 的方式会比 eg2 获取 name 
的方式要多一个， 即为 作为对象的属性来 获取到 当前的 name （one.name）&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;那如果 你想让你的 name 属性只能通过 getName 方法来获取，不希望有别的方法来获取 甚至是改变的话，那么 闭包 设置私有属性就是一个很安全的做法，那么这个时候闭包的作用就体现出来了。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/erbing/blog/blob/master/%E5%89%8D%E7%AB%AF%08%E4%B9%8B%E8%B7%AF/04%EF%BC%9AJavaScript%20%E9%97%AD%E5%8C%85.md&quot;&gt;Github地址，欢迎 Star&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 12:50:00 +0000</pubDate>
<dc:creator>SmallW</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/erbingbing/p/9320050.html</dc:identifier>
</item>
<item>
<title>设计模式（二十一）—— 状态模式 - Answer.Geng</title>
<link>http://www.cnblogs.com/Answer-Geng/p/9319827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Answer-Geng/p/9319827.html</guid>
<description>&lt;h2 id=&quot;模式简介&quot;&gt;模式简介&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在某些情况下，一个对象的行为取决于它当前所处的状态，当对象属性(状态)在系统运行过程中发生变化，它呈现出的行为也随之发生改变。例如可调节亮度的台灯，假设灯光亮度分为三级，每次按下按钮，台灯会根据当前亮度增加一级，若已经是最亮的状态，按下按钮则关闭台灯。&lt;/p&gt;
&lt;h2 id=&quot;结构分析&quot;&gt;结构分析&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;uml类图&quot;&gt;UML类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180716185317034-1404098128.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;角色说明&quot;&gt;角色说明&lt;/h3&gt;
&lt;p&gt;环境类。客户端操作的类，包含一个IState类型的对象，保存其当前状态。&lt;/p&gt;
&lt;p&gt;状态接口。定义一个统一的接口以封装与Context的特定状态相关的行为。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConcreteState&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体状态。实现状态接口，表示Context某个状态相关的行为。&lt;/p&gt;
&lt;h3 id=&quot;工作原理&quot;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;Context类将与状态相关的请求委托给ConcreteState对象处理，并将自身以参数形式传递给ConcreteState对象，如此，便可以在处理完请求后访问Context的SetState方法为Context设置新的状态。&lt;/p&gt;
&lt;h3 id=&quot;结构代码&quot;&gt;结构代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//环境类
class Context
{
    private IState _state;
    public Context(IState state)
    {
        _state = state;
        Console.WriteLine($&quot;Initialize state -&amp;gt; {state}&quot;);
    }

    public void SetState(IState state)
    {
        _state = state;
        Console.WriteLine($&quot;Set State -&amp;gt; {state}&quot;);
    }

    public void Request()
    {
        _state.Handle(this);
    }
}

//状态接口
interface IState
{
    void Handle(Context context);
}

//具体状态类A
class ConcreteStateA : IState
{
    public void Handle(Context context)
    {
        context.SetState(new ConcreteStateB());
    }
}

//具体状态类B
class ConcreteStateB : IState
{
    public void Handle(Context context)
    {
        context.SetState(new ConcreteStateA());
    }
}

//客户端调用
static void Main(string[] args)
{
    Context context = new Context(new ConcreteStateA());
    for (int i = 0; i &amp;lt; 5; i++)
    {
        context.Request();
    }
    Console.ReadLine();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180716185605443-221284650.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例分析&quot;&gt;示例分析&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;本节模拟第一节中提到的台灯示例。首先创建台灯类Lamp，提供共有方法SetState设置当前状态，包含一个保存当前状态的私有字段_state，并通过Request方法调用该状态的下台灯发光的行为。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Lamp
{
    private IState _state;
    public Lamp(IState state)
    {
        _state = state;
        Console.WriteLine($&quot;Initialize state -&amp;gt; {state}&quot;);
    }
    public void SetState(IState state)
    {
        _state = state;
        Console.WriteLine($&quot;Set State -&amp;gt; {state}&quot;);
    }

    public void Request()
    {
        _state.Handle(this);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明状态接口，并分别实现具体状态类，这里包括四种状态Closed、Dim、Medium、Bright。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface IState
{
    void Handle(Lamp context);
}

class Closed : IState
{
    public void Handle(Lamp context)
    {
        context.SetState(new Dim());
    }
}

class Dim : IState
{
    public void Handle(Lamp context)
    {
        context.SetState(new Medium());
    }
}

class Medium : IState
{
    public void Handle(Lamp context)
    {
        context.SetState(new Bright());
    }
}

class Bright : IState
{
    public void Handle(Lamp context)
    {
        context.SetState(new Closed());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端调用，将台灯的初始状态设置为Closed，并连续调用，输出台灯状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Program
{
    static void Main(string[] args)
    {
        Lamp lamp = new Lamp(new Closed());
        for (int i = 0; i &amp;lt; 10; i++)
        {
            lamp.Request();
        }
        Console.ReadLine();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/971601/201807/971601-20180716192012275-1447930891.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;适用场景&quot;&gt;适用场景&lt;/h2&gt;
&lt;hr/&gt;&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个操作中含有大量的分支的条件语句，且这些分支依赖于该对象的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 16 Jul 2018 12:05:00 +0000</pubDate>
<dc:creator>Answer.Geng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Answer-Geng/p/9319827.html</dc:identifier>
</item>
<item>
<title>从 Secure Element 到 Android KeyStore - 程序员赵鑫</title>
<link>http://www.cnblogs.com/xinzhao/p/9319419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinzhao/p/9319419.html</guid>
<description>&lt;p&gt;忽如一夜春风来，智能手机来到每个人的手上，我们用它支付、理财、娱乐、工作、记录生活、存储私密信息、乘坐公共交通、开启家门、控制汽车...。智能手机是如此的重要，不知天天把它拿在手上的你,是否关心过它是否足够安全。&lt;/p&gt;
&lt;p&gt;本文从Secure Element（安全单元）说起，介绍手机设备上若干重要的安全角色和概念。为后续文章介绍如何基于手机安全地实现认证、支付、DRM等业务流程打下基础。&lt;/p&gt;
&lt;h3 id=&quot;sesecure-element&quot;&gt;SE（Secure Element）&lt;/h3&gt;
&lt;p&gt;按照Global Platform的定义：安全单元提供私密信息的安全存储、重要程序的安全执行等功能。其内部组件包含有：CPU、RAM、ROM、加密引擎、传感器等，大致如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/SEInternal.PNG&quot; alt=&quot;SecureElementInternal&quot;/&gt;&lt;/p&gt;
&lt;p&gt;外在表现上SE是一块物理上独立的芯片卡。从外在表现上可以分为三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UICC 通用集成电路卡，由电信运营商发布和使用。就是大家购买手机号时的手机SIM卡；&lt;/li&gt;
&lt;li&gt;Embedded SE 虽然也是独立的芯片，但普通用户看不到，由手机制造厂商在手机出厂前集成在手机内部；&lt;/li&gt;
&lt;li&gt;Micro SD 以SD存储卡的形式存在，通过插入SD卡槽集成到手机上。由独立的SE制造商制造和销售；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/SEShape.PNG&quot; alt=&quot;SecureElementShape&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SE物理上独立，采用安全协议与外部通讯。具有自己独立的执行环境和安全存储，软件和硬件上防篡改。软件通过签名等方式防篡改很多人都了解，说下硬件防篡改，简单说就是物理拆改SE，它会自毁。最简单的硬件防篡改的例子，大家可以参考大家给自己车安装车牌时所使用的单向螺丝和防盗帽。&lt;/p&gt;
&lt;p&gt;SE固若金汤，但保存在其中的数据和程序需要有更新机制，这通过TSM（Trusted Service Manager）来实现，以保证安全。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/TrustedServiceManager.PNG&quot; alt=&quot;TrustedServiceManager&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SE不年轻了从19世纪70年代就开始发展，但它十分安全，是目前手机上最安全的技术措施。&lt;/p&gt;
&lt;h3 id=&quot;nfcnear-field-communication&quot;&gt;NFC（Near-field Communication）&lt;/h3&gt;
&lt;p&gt;近场通信是一种短距高频的无线电技术，在13.56MHz频率运行于20厘米距离内，由非接触式射频识别（RFID，公交卡、校园一卡通、门禁卡等都采用RFID技术实现）演变而来，由飞利浦、诺基亚和索尼于2004年共同研制开发。目前已成为ISO/IEC IS 18092国际标准、EMCA-340标准与ETSI TS 102 190标准。&lt;/p&gt;
&lt;p&gt;NFC设备有三种工作模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;卡模拟模式（Card emulation mode）：这个模式其实就是相当于一张采用RFID技术的IC卡。可以替代现在大量的IC卡（包括信用卡）场合商场刷卡、IPASS、门禁管制、车票、门票等等。&lt;/li&gt;
&lt;li&gt;读卡器模式（Reader/Writer mode）：作为非接触读卡器使用，可用来实现给公交卡充值等功能。&lt;/li&gt;
&lt;li&gt;点对点模式（P2P mode）：这个模式和红外线差不多，可用于数据交换，只是传输距离较短，传输创建速度较快，传输速度也快些，功耗低（蓝牙也类似）。将两个具备NFC功能的设备链接，能实现数据点对点传输，如下载音乐、交换图片或者同步设备地址薄。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三种工作模式中，卡模拟模式用途最为广泛，可将用平时使用的各种卡通过手机模拟实现，从此出门不再带卡。此种方式下，NFC芯片通过非接触读卡器的RF域来供电，即便是手机没电也可以工作。&lt;/p&gt;
&lt;p&gt;NFC设备若要进行卡片模拟（Card Emulation）相关应用，则必须内置安全单元（Security Element, SE）以保存重要隐私数据。可以说NFC给SE插上了翅膀，在NFC广泛应用的今天，SE如此的重要，成为电信运营商（移动、联通、电信等）、手机厂商（华为、小米等）、操作系统厂商（谷歌、苹果等）的兵家必争之地。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/NFC.PNG&quot; alt=&quot;NFC&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;hcehost-card-emulation&quot;&gt;HCE（Host Card Emulation）&lt;/h3&gt;
&lt;p&gt;因为不涉及硬件制造，在SE的竞争过程中，操作系统厂商相对弱势，确切的说是谷歌弱势，因为苹果既是操作系统厂商，也是手机厂商。&lt;/p&gt;
&lt;p&gt;早期Goole Pay是基于SE实现的，但由于在SE生态环境中弱势的竞争地位，导致Google Pay适配的机型少，难以发展。从Android 4.4开始，谷歌独辟蹊径在Android系统中提供了HCE服务，用来绕过SE直接控制NFC Controller。大概的模式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/HCE.PNG&quot; alt=&quot;HCE&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HCE不在依赖设备上的SE模块，只要有NFC芯片就可以实现支付等功能，但其实是无奈之举。方便是方便了，有两个主要缺点：一个是安全性有所降低，虽然可以使用白盒密码、服务端token校验等一系列手段来提升安全性，但相比SE，安全性降低到依赖Android OS，只要OS被攻破，HCE就无法保证安全；一个是费电，NFC Controller + SE的方案，可以在手机无电的情况下，使用NFC读卡器的电磁信号供电。而HCE则必须在手机供电，OS正常工作甚至还要联网的情况下才能使用。&lt;/p&gt;
&lt;p&gt;相对的，因为对设备有这强的控制力，苹果的Apple Pay是基于SE实现的，更安全一些。&lt;/p&gt;
&lt;h3 id=&quot;teetrusted-execution-environment&quot;&gt;TEE（Trusted Execution Environment）&lt;/h3&gt;
&lt;p&gt;SE千般好，除了慢。硬件隔离，独立的计算和存储资源，意味着SE的计算性能差、跟主机的数据传输速度也慢，这限制了SE的应用场景。与此同时，移动互联网发展迅速，迫切需要一个更好的安全生态。因此TEE应运而生。&lt;/p&gt;
&lt;p&gt;TEE是一个硬件安全执行环境，通常跟平时使用的Rich OS（Android等）共用同一个主处理器（CPU），提供了代码和数据的安全防护、外置设备的安全访问等功能。TEE具有自己的TEE OS，可以安装和卸载执行其中的安全应用TA（TEE Application）。跟SE相比，是一个相对不那么安全，但运行速度更快、功能更丰富的安全环境。为所有支持TEE的手机，提供了操作系统之外的安全方案。&lt;/p&gt;
&lt;p&gt;SE、TEE以及REE的对比：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;安全级别&lt;/td&gt;
&lt;td&gt;最高（硬件防篡改）&lt;/td&gt;
&lt;td&gt;高（硬件安全方案）&lt;/td&gt;
&lt;td&gt;普通&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;性能&lt;/td&gt;
&lt;td&gt;差&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;td&gt;高&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;是否在主处理器执行&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是（极个别情况有独立处理器）&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;安全的外设访问&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;提供硬件证明&lt;/td&gt;
&lt;td&gt;一定程度上提供&lt;/td&gt;
&lt;td&gt;提供&lt;/td&gt;
&lt;td&gt;不提供&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;软件生态&lt;/td&gt;
&lt;td&gt;较差&lt;/td&gt;
&lt;td&gt;较好&lt;/td&gt;
&lt;td&gt;极好&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;TEE的内部API和外部API都由Global Platform定义和发布。TEE得到了业界广泛的支持，比如ARM在2006年就发布了ARM处理器下的TEE方案TrustZone，AMD、Intel、华为海思等，也有自己的TEE方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/TEE.PNG&quot; alt=&quot;TEE&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TEE广泛应用在支付、身份认证、内容保护等领域。举例来讲，视频厂商往往需要DRM（Digital rights management）系统来保护版权内容能够顺利得在用户设备上播放，而不被泄露。TEE天然适合用来完成这种需求，其安全存储的能力可以用来保存解密版权内容所需密钥，这样，TEE Application访问可信的服务端获取已加密的版权视频后，使用安全密钥解密，然后利用安全访问外置设备的能力，锁住显卡和声卡，将解密后的视频送往显卡和声卡播放。整个过程中，不管是加密密钥还是视频内容都没有离开过TEE，保护了版权视频的安全。尤其值得一提的，因其锁定外置设备的能力，想通过录屏来窃取内容，也是不可能的。&lt;/p&gt;
&lt;h3 id=&quot;android-fingerprint&quot;&gt;Android Fingerprint&lt;/h3&gt;
&lt;p&gt;Android设备的指纹识别，依赖TEE来实现用户指纹认证，要求指纹采集、注册和识别都必须在TEE内部进行，已保证安全。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://zhaox.github.io/assets/images/AndroidFingerprint.png&quot; alt=&quot;AndroidFingerprint&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;android-keystore&quot;&gt;Android KeyStore&lt;/h3&gt;
&lt;p&gt;Android从4.0开始引入了KeyStore，开发者可以使用KeyStore API生成密钥、使用密钥签名、使用密钥加解密、获取密钥的属性信息，但无法将密钥本身从KeyStore中取出。因为密钥不进入应用进程，这大大提高了密钥的安全性。随着Android版本更迭，KeyStore的实现不断进化得更加安全，在有些设备上，不仅密钥不进入应用进程，甚至不进入Android OS只存储在TEE或SE中，接下来我们大概列举下KeyStore的进化。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;4.0&lt;/td&gt;
&lt;td&gt;创世版本，密钥使用用户的passcde加密后存储，支持RSA、ECDSA&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;4.1&lt;/td&gt;
&lt;td&gt;增加了使用安全硬件的基础设施，在可能的情况下密钥会被存储到安全硬件中&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;6.0&lt;/td&gt;
&lt;td&gt;增加支持AES、HMAC；增加了密钥绑定用户认证的能力，即可以指定某些密钥，在每一次使用时，必须由用户进行认证（指纹、passcode等）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;7.0&lt;/td&gt;
&lt;td&gt;强制要求预装7.0系统的设备必须拥有安全硬件并且支持基于安全硬件的KeyStore&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;8.0&lt;/td&gt;
&lt;td&gt;增加了设备证明（Key Attestation）能力，开发者可通过验证Key Attestation的证书链，来确认密钥的确保存在了安全硬件中&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;能被业界接受的，就是好方案。&lt;/p&gt;
</description>
<pubDate>Mon, 16 Jul 2018 11:05:00 +0000</pubDate>
<dc:creator>程序员赵鑫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinzhao/p/9319419.html</dc:identifier>
</item>
</channel>
</rss>