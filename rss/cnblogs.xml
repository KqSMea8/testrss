<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>电脑中如何安装虚拟机 最详细最具体的虚拟机安装教程 - 泽国江山入战图</title>
<link>http://www.cnblogs.com/code12306/p/8466056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/code12306/p/8466056.html</guid>
<description>&lt;p&gt;在介绍具体虚拟机安装教程之前，我们前来了解一下虚拟机是什么？以及虚拟机的作用是什么？虚拟机是一个利用软件来模拟出完整计算机系统的工具。具有完整硬件系统功能的、运行在一个完全隔离环境中。当您遇到与您操作系统不相兼容的程序时，虚拟机就可以帮您解决了这些麻&lt;/p&gt;&lt;div id=&quot;content&quot; readability=&quot;172.89312977099&quot;&gt;
&lt;p&gt;虚拟机是一个利用软件来模拟出完整计算机系统的工具。具有完整硬件系统功能的、运行在一个完全隔离环境中。虚拟机的使用范围很广，如未知软件评测、运行可疑型工具等，即使这些程序中带有病毒，它能做到的只有破坏您的虚拟系统，大可不用担心它伤害您的物理机电脑。因为虚拟机是一个完全独立与您主机的操作系统。现在主流的Windows操作系统是win7和win8，当您遇到与您操作系统不相兼容的程序时，虚拟机就可以帮您解决了这些麻烦。还有想体验Windows和Linux双系统的用户，选择虚拟机更是一个不错的选择。下面，小编就来带您走进虚拟机的安装世界，教您最详细的虚拟机安装教程步骤，让虚拟机安装不再复杂。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465281.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;562&quot; height=&quot;307&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;如何安装虚拟机 最详细的虚拟机安装教程&lt;/p&gt;
&lt;p&gt;类似教程：&lt;strong&gt;&lt;a href=&quot;http://www.jb51.net/softjc/129280.html&quot; target=&quot;_blank&quot;&gt;虚拟机怎么用 虚拟机安装教程&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：安装虚拟机软件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、首先，我们应选择一个合适的虚拟机版本。下面我们就以最新的原版虚拟机9.0.3为例，为大家剖析虚拟机的安装。&lt;/p&gt;
&lt;p&gt;2、打开已经下载好的虚拟机安装包，出现以下界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465282.jpg&quot; alt=&quot;虚拟机9.0.3安装&quot; width=&quot;497&quot; height=&quot;381&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;虚拟机9.0.3安装&lt;/p&gt;
&lt;p&gt; 3、选择next，继续下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465283.jpg&quot; alt=&quot;虚拟机安装示意图&quot; width=&quot;499&quot; height=&quot;376&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里，我们选择typical典型版安装。如您对虚拟机没什么特别高的用途要求，typical即可完全满足您的日常要求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465284.jpg&quot; alt=&quot;typical典型版安装&quot; width=&quot;499&quot; height=&quot;378&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、改变安装路径，最好不要放在C盘，多数人C盘都是系统盘，为保证系统盘的干净，在这里我们可以选择自己电脑上面剩余空间较大的E磁盘安装为例，如下图所示。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465285.jpg&quot; alt=&quot;选择虚拟机安装路径&quot; width=&quot;499&quot; height=&quot;379&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、之后继续点击next，进入下一步操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465286.jpg&quot; alt=&quot;取消掉虚拟机产品更新&quot; width=&quot;499&quot; height=&quot;380&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;取消掉虚拟机产品更新&lt;/p&gt;
&lt;p&gt;如上图，&lt;strong&gt;Check for product update检查产品更新、在这里我们可以把前面的对号去掉选择忽略，就是取消掉勾&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465287.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;500&quot; height=&quot;382&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Help improve VMware帮忙改进产品，继续去掉上面的对号，选择next&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465288.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;501&quot; height=&quot;382&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt; 如上图，这两个对号就不要去掉了，一个是桌面快捷方式，一个是开始菜单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465289.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;500&quot; height=&quot;379&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 7、如上图，选择continue，软件正式在电脑中安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465290.jpg&quot; alt=&quot;虚拟机安装进度条&quot; width=&quot;497&quot; height=&quot;382&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;虚拟机安装进度条&lt;/p&gt;
&lt;p&gt;到快完成的时候，会提示我们需要输入KEY产品密钥。&lt;/p&gt;

&lt;p&gt;8、在这里提示我们输入key，即产品序列号。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465291.jpg&quot; alt=&quot;输入虚拟机产品序列号&quot; width=&quot;497&quot; height=&quot;376&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;输入虚拟机产品序列号&lt;/p&gt;

&lt;p&gt;&lt;span&gt;0A0XG-DNJ06-0Z8T9-NR0E0-0AJLD&lt;/span&gt;这个是小编百度搜索的，不保证永远还可以使用，但目前短期内没问题。如果后期不能使用，请百度自行搜索关键字：&lt;span&gt;虚拟机9.0.3序列号&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465292.jpg&quot; alt=&quot;完成虚拟机的安装&quot; width=&quot;499&quot; height=&quot;381&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;完成虚拟机的安装&lt;/p&gt;
&lt;p&gt;9、点击finish，即可安装虚拟机完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：下载操作系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这里小编推荐大家去&lt;span&gt;msdn.itellyou.cn&lt;/span&gt;下载，这里有各种版本的操作系统和开发人员工具，很不错的一个网站。&lt;/p&gt;
&lt;p&gt;在这里我们选择&lt;span&gt;windows xp professional#p#分页标题#e#&lt;/span&gt;简体中文专业版，您可以根据自己的需要下载自己所需的操作系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465293.jpg&quot; alt=&quot;下载虚拟机操作系统&quot; width=&quot;737&quot; height=&quot;432&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;下载虚拟机操作系统&lt;/p&gt;
&lt;p&gt;选择复制所选的项，然后打开您的迅雷，新建任务。开始下载您需要的操作系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：安装操作系统至虚拟机&lt;br/&gt;&lt;/strong&gt; &lt;br/&gt;1、打开桌面上的虚拟机软件，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465294.jpg&quot; alt=&quot;打开虚拟机软件&quot; width=&quot;101&quot; height=&quot;102&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;打开虚拟机软件&lt;/p&gt;
&lt;p&gt;2、选择接受此协议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465295.jpg&quot; alt=&quot;选择接受虚拟机安装协议&quot; width=&quot;498&quot; height=&quot;385&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;选择接受虚拟机安装协议&lt;/p&gt;
&lt;p&gt;3、之后虚拟机界面就呈现出来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465296.jpg&quot; alt=&quot;虚拟机内部界面&quot; width=&quot;585&quot; height=&quot;330&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;虚拟机内部界面&lt;/p&gt;
&lt;p&gt;我们选择第一行第一个，create a new virtual machine创建一个新的虚拟机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465297.jpg&quot; alt=&quot;创建一个新的虚拟机&quot; width=&quot;432&quot; height=&quot;449&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;创建一个新的虚拟机&lt;/p&gt;
&lt;p&gt;4、仍然选择typical典型版安装，然后再点击Next，继续下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465298.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;427&quot; height=&quot;447&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、在installer disc image里面找到我们刚才下载的操作系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/2014010713465299.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;428&quot; height=&quot;447&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;虚拟机安装系统示意图&lt;/p&gt;
&lt;p&gt;在这里我们需要输入xp的key，上面小编输入大家可以直接忽略，因为在后面提示这个key无效。我们可以输入PP436-MTRWV-8Y3XR-MKHH8-BKBP8，亲测可用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652100.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;346&quot; height=&quot;161&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的英语是提示我们软件可能会与我们的操作系统冲突，我们可以看作是友情提示，因为小编在使用过程中从没发现有过什么冲突。在下面的小方框中打上对号，选择yes。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652101.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;427&quot; height=&quot;444&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;虚拟机安装操作系统图解&lt;/p&gt;
&lt;p&gt;注意：虚拟机名字就不要变更了，默认的操作系统名更容易识别。Location本地位置，只要别放C盘就可以。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652102.jpg&quot; alt=&quot;为虚拟机安装的系统分配磁盘大小&quot; width=&quot;427&quot; height=&quot;447&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;为虚拟机安装的系统分配磁盘大小&lt;/p&gt;
&lt;p&gt;Maximum disk size 虚拟机大小，一般选择系统默认的大小就可以。如电脑配置较高、硬盘容量较大的，可适当增大。在这里我们选择split disk into multiple files虚拟磁盘分割成多个文件，这样可以在以后的使用中加快反应速度。之后点击Next进行下一步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652103.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;428&quot; height=&quot;447&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、虚拟机已配置完毕，之后点击finish，重启虚拟机即可，安装完成系统了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652104.jpg&quot; alt=&quot;虚拟机中成功安装的系统&quot; width=&quot;591&quot; height=&quot;439&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;虚拟机中成功安装的系统&lt;/p&gt;
&lt;p&gt;虚拟机中成功安装草组系统之后，还需要配置操作系统，以下是虚拟机系统正在配置中的提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652105.jpg&quot; alt=&quot;配置虚拟机操作系统&quot; width=&quot;591&quot; height=&quot;440&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;配置虚拟机操作系统&lt;/p&gt;
&lt;p&gt;稍后我们即可听见熟悉的windows xp开机界面声音和看到界面了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652106.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;591&quot; height=&quot;437&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的步骤都是自动安装，我们只需等待几分钟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652107.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;591&quot; height=&quot;437&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，出现错误，需要更改操作系统的使用信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652108.jpg&quot; alt=&quot;继续配置虚拟机内部的操作系统&quot; width=&quot;579&quot; height=&quot;461&quot; border=&quot;0&quot;/&gt;#p#分页标题#e#&lt;br/&gt; &lt;/p&gt;

&lt;p&gt;如上图，姓名单位可以自己随便写。然后点击下一步，继续操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652109.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;580&quot; height=&quot;461&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后，我们即可进入了新的操作系统界面了，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652110.jpg&quot; alt=&quot;进入虚拟机安装的XP系统界面&quot; width=&quot;581&quot; height=&quot;464&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;进入虚拟机安装的XP系统界面&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652111.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;577&quot; height=&quot;430&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;熟悉的XP系统桌面界面&lt;/p&gt;
&lt;p&gt;选择安装vmware tools虚拟机工具，一般在您第一次进入时候系统就会自动提示您进行安装。如无提示，则选择vm目录下的vmware tools进行手动安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652112.jpg&quot; alt=&quot;vmware tools虚拟机工具&quot; width=&quot;581&quot; height=&quot;461&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后就是vmware tools设置了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652113.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;401&quot; height=&quot;330&quot; border=&quot;0&quot;/&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652114.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;501&quot; height=&quot;387&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;选择继续下一步&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652115.jpg&quot; alt=&quot;如何安装虚拟机 最详细的虚拟机安装教程&quot; width=&quot;503&quot; height=&quot;383&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;完成虚拟机vmware tools的安装&lt;/p&gt;
&lt;p&gt;至此，一个纯净的XP虚拟机就安装完成，我们可以在该虚拟机中，我们可以在虚拟机XP系统化中，安装任何的测试应用或者软件了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://files.jb51.net/file_images/article/201401/20140107134652116.jpg&quot; alt=&quot;虚拟机检测出的系统信息&quot; width=&quot;587&quot; height=&quot;383&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;虚拟机检测出的系统信息&lt;/p&gt;
&lt;p&gt;这个是检测出的系统信息。供大家查看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;编后小结&lt;/span&gt;&lt;/strong&gt;：现在网上各种汉化版横飞，有的版本在汉化时存在很多问题，不建议大家使用。之所以选择原版的虚拟机版本、是因为原版虚拟机较汉化版而言，使用起来更安全、放心。相信您在学会了满是英文的虚拟机软件安装以后，再使用别的版本时，更加得心应手。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 24 Feb 2018 07:33:00 +0000</pubDate>
<dc:creator>泽国江山入战图</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/code12306/p/8466056.html</dc:identifier>
</item>
<item>
<title>Javascript获取数组中的最大值和最小值方法汇总 - ranyonsue</title>
<link>http://www.cnblogs.com/ranyonsue/p/8466057.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ranyonsue/p/8466057.html</guid>
<description>&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;sort()方法&lt;/p&gt;
&lt;p&gt;b-a从大到小，a-b从小到大&lt;/p&gt;
&lt;p&gt;var max2 = arr.sort(function(a,b){&lt;/p&gt;
&lt;p&gt;    return b-a;&lt;/p&gt;
&lt;p&gt;})[0];&lt;/p&gt;
&lt;p&gt;console.log(max2)&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;//最小值&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Array.prototype.min = function() {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;var min = this[0];&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;var len = this.length;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;for (var i = 1; i &amp;lt; len; i++){&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;if (this[i] &amp;lt; min){&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;min = this[i];&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;return min;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;//最大值&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Array.prototype.max = function() {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;var max = this[0];&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;var len = this.length;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;for (var i = 1; i &amp;lt; len; i++){&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;if (this[i] &amp;gt; max) {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;max = this[i];&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;return max;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;

&lt;p&gt;如果你是引入类库进行开发，害怕类库也实现了同名的原型方法，可以在生成函数之前进行重名判断：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;if (typeof Array.prototype['max'] == 'undefined') {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;Array.prototype.max = function() {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;... ...&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法三&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用Math.max和Math.min方法可以迅速得到结果。apply能让一个方法指定调用对象与传入参数，并且传入参数是以数组形式组织的。恰恰现在有一个方法叫Math.max，调用对象为Math，与多个参数&lt;/p&gt;
&lt;p&gt;Array.max = function( array ){&lt;/p&gt;
&lt;p&gt;return Math.max.apply( Math, array );&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;Array.min = function( array ){&lt;/p&gt;
&lt;p&gt;return Math.min.apply( Math, array );&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;但是，John Resig是把它们做成Math对象的静态方法，不能使用大神最爱用的链式调用了。但这方法还能更精简一些，不要忘记，Math对象也是一个对象，我们用对象的字面量来写，又可以省几个比特了。&lt;/p&gt;
&lt;p&gt;Array.prototype.max = function(){&lt;/p&gt;
&lt;p&gt;return Math.max.apply({},this)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;Array.prototype.min = function(){&lt;/p&gt;
&lt;p&gt;return Math.min.apply({},this)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;[1,2,3].max()// =&amp;gt; 3&lt;/p&gt;
&lt;p&gt;[1,2,3].min()// =&amp;gt; 1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法四&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;function getMaximin(arr,maximin)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;if(maximin==&quot;max&quot;)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;return Math.max.apply(Math,arr);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;else if(maximin==&quot;min&quot;)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;return Math.min.apply(Math, arr);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;var a=[3,2,4,2,10];&lt;/p&gt;
&lt;p&gt;var b=[12,4,45,786,9,78];&lt;/p&gt;
&lt;p&gt;console.log(getMaximin(a,&quot;max&quot;));//10&lt;/p&gt;
&lt;p&gt;console.log(getMaximin(b,&quot;min&quot;));//04&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法五&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;var a=[1,2,3,5];&lt;/p&gt;
&lt;p&gt;alert(Math.max.apply(null, a));//最大值&lt;/p&gt;
&lt;p&gt;alert(Math.min.apply(null, a));//最小值&lt;/p&gt;
&lt;p&gt;多维数组可以这么修改：&lt;/p&gt;
&lt;p&gt;var a=[1,2,3,[5,6],[1,4,8]];&lt;/p&gt;
&lt;p&gt;var ta=a.join(&quot;,&quot;).split(&quot;,&quot;);//转化为一维数组&lt;/p&gt;
&lt;p&gt;alert(Math.max.apply(null,ta));//最大值&lt;/p&gt;
&lt;p&gt;alert(Math.min.apply(null,ta));//最小值&lt;/p&gt;

</description>
<pubDate>Sat, 24 Feb 2018 07:33:00 +0000</pubDate>
<dc:creator>ranyonsue</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ranyonsue/p/8466057.html</dc:identifier>
</item>
<item>
<title>Java中的Throable类是不是受查异常？ - Beginner_H</title>
<link>http://www.cnblogs.com/xz816111/p/8466048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xz816111/p/8466048.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Q: Throable是不是受查异常？&lt;br/&gt;A: 是&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se9/html/jls-11.html#jls-11.1.1&quot;&gt;Java规范&lt;/a&gt;中，对非受查异常和受查异常的定义是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The unchecked exception classes are the &lt;code&gt;run-time&lt;/code&gt; exception classes and the &lt;code&gt;error&lt;/code&gt; classes.&lt;/li&gt;
&lt;li&gt;The checked exception classes are &lt;strong&gt;all exception classes other than the unchecked exception classes&lt;/strong&gt;. That is, the checked exception classes are Throwable and all its subclasses other than RuntimeException and its subclasses and Error and its subclasses.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说，除了&lt;code&gt;run-time exception&lt;/code&gt;和其子类，以及&lt;code&gt;error&lt;/code&gt;和其子类，其它的所有异常都是受查异常。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;java中的异常分类如下&quot;&gt;Java中的异常分类如下：&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xz816111/786501/o_v2NAj.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Error&lt;/code&gt;通常是一些底层的和硬件有关的错误，与程序本身无关，不应该被捕获，因为捕获了无能为力。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RuntimeException&lt;/code&gt;是程序本身出错抛出的异常，这类错误一定是程序员本身逻辑错误或不严谨造成的，可以捕获也可以不捕获，如果不主动捕获则会被JVM处理。&lt;/li&gt;
&lt;li&gt;余下的&lt;code&gt;受查异常&lt;/code&gt;，是在编写程序时无法提前预料到的，如文件读写异常、数据库访问异常等，这并不是程序本身的错误，为了保证程序的健壮性，这些异常必须被捕获。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 24 Feb 2018 07:32:00 +0000</pubDate>
<dc:creator>Beginner_H</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xz816111/p/8466048.html</dc:identifier>
</item>
<item>
<title>Dagger2 使用全解析 - sw926</title>
<link>http://www.cnblogs.com/sw926/p/8466020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sw926/p/8466020.html</guid>
<description>&lt;p&gt;Dagger是一个注入工具，何为注入，我们要生产一批机器人，每个机器人都有一个控制器，我们可以在机器人内部 new 出一个控制器：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot {
    &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; controller = &lt;span class=&quot;fu&quot;&gt;Controller&lt;/span&gt;()
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码 Robot 和 Controller 耦合，修改一下上面的代码，从外部传入控制器，这就叫注入：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot(&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; controller: Controller)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样做的好处就是修改了控制器，但是不用修改机器人的代码，一般情况下，我们需要把控制器声明为接口，这样一个机器人就可以兼容不同的控制器&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;interface Controller {
    fun &lt;span class=&quot;fu&quot;&gt;move&lt;/span&gt;()
    fun &lt;span class=&quot;fu&quot;&gt;stop&lt;/span&gt;()
}

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; BasicController : Controller {
    &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;move&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
    }

    &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;stop&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
    }
}

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; AdvancedController : Controller {
    &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;move&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
    }

    &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;stop&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// ..&lt;/span&gt;
    }
}

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot(&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; controller: Controller)

fun &lt;span class=&quot;fu&quot;&gt;createRobot&lt;/span&gt;(controller: Controller) = Robot(controller)

fun &lt;span class=&quot;fu&quot;&gt;test&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; basicRobot = &lt;span class=&quot;fu&quot;&gt;createRobot&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;BasicController&lt;/span&gt;())
    &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; advancedRobot = &lt;span class=&quot;fu&quot;&gt;createRobot&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;AdvancedController&lt;/span&gt;())
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码就是精简版的Dagger，当然结构天差地别，但是思路差不多，下面开始讲Dagger。&lt;br/&gt;Dagger是个注入框架，帮助我们来实现注入的功能，拿上面的例子来说，我们写好了 Robot 和 各种 Controller 的代码，Dagger 帮我们将他们联系起来，也就是实现函数 createRobot 的功能。&lt;br/&gt;Dagger2 的功能是通过编译器生成中间代码来实现的，编译器可以为我们生成代码，但是要生成什么代码是需要我们指定的，拿上面的例子来说，我们需要为 Robot 注入一个 Controller，我们需要指定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Controller 的构造方法&lt;/li&gt;
&lt;li&gt;需要注入的成员变量&lt;/li&gt;
&lt;li&gt;在什么地方注入&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;未使用 Dagger 之前，代码是这样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Controller
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot(&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; controller: Controller)

&lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; controller = &lt;span class=&quot;fu&quot;&gt;Controller&lt;/span&gt;()
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; robot = Robot(controller)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们来改写代码，首先要指定 Controller 的构造方法，在 Controller 的构造函数添加 @Inject 注解：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Controller @Inject &lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定需要注入的变量&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot {
    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; controller: Controller
} &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在编译一下，等待 Dagger 生成中间代码，Dagger为我们生成以下的代码：&lt;/p&gt;
&lt;p&gt;Controller_Factory.java&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Controller_Factory &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Factory&amp;lt;Controller&amp;gt; {
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Controller_Factory INSTANCE = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Controller_Factory&lt;/span&gt;();

  &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Controller &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Controller&lt;/span&gt;();
  }

  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Factory&amp;lt;Controller&amp;gt; &lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; INSTANCE;
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Robot_MembersInjector.java&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot_MembersInjector &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; MembersInjector&amp;lt;Robot&amp;gt; {
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Provider&amp;lt;Controller&amp;gt; controllerProvider;

  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Robot_MembersInjector&lt;/span&gt;(Provider&amp;lt;Controller&amp;gt; controllerProvider) {
    assert controllerProvider != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;controllerProvider&lt;/span&gt; = controllerProvider;
  }

  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; MembersInjector&amp;lt;Robot&amp;gt; &lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(Provider&amp;lt;Controller&amp;gt; controllerProvider) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Robot_MembersInjector&lt;/span&gt;(controllerProvider);
  }

  &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;injectMembers&lt;/span&gt;(Robot instance) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NullPointerException(&lt;span class=&quot;st&quot;&gt;&quot;Cannot inject members into a null reference&quot;&lt;/span&gt;);
    }
    instance.&lt;span class=&quot;fu&quot;&gt;controller&lt;/span&gt; = controllerProvider.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常好，Dagger 为我们生成了一个 Controller 的构造类 Controller_Factory，我们可以通过&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;Controller_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取一个单例的 Controller 对象，或者通过：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;fu&quot;&gt;Controller_Factory&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;()
&lt;span class=&quot;co&quot;&gt;// or&lt;/span&gt;
Controller_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建一个新的 Controller 对象，如果要注入到 Robot，需要使用 Robot_MembersInjector 的 injectMembers 的函数，改造后的最终代码是&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Controller @Inject &lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt;()

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot {
    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; controller: Controller

    &lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; factory = Controller_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;()
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; injector = Robot_MembersInjector.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(factory)
        injector.&lt;span class=&quot;fu&quot;&gt;injectMembers&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在添加一个注入的成员变量 power：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Controller @Inject &lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt;()

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Power @Inject &lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt;()

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot {
    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; controller: Controller
    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; power: Power

    &lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; controllerFactory = Controller_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;()
        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; powerFactory = Power_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;()

        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; injector = Robot_MembersInjector.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(controllerFactory, powerFactory)

        injector.&lt;span class=&quot;fu&quot;&gt;injectMembers&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时应该祭出 Componet 了，我们来声明一个 AppComponet：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@Component
interface AppComponent {
    fun &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(robot: Robot)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后使用 Component 来注入变量，Dagger 会根据 AppComponent 生成一个 DaggerAppComponent：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot {
    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; controller: Controller
    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; power: Power

    &lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt;() {
        DaggerAppComponent.&lt;span class=&quot;fu&quot;&gt;builder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来分析一下 DaggerAppComponent 的源码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DaggerAppComponent &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; AppComponent {
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; MembersInjector&amp;lt;Robot&amp;gt; robotMembersInjector;

  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DaggerAppComponent&lt;/span&gt;(Builder builder) {
    assert builder != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;fu&quot;&gt;initialize&lt;/span&gt;(builder);
  }

  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Builder &lt;span class=&quot;fu&quot;&gt;builder&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Builder&lt;/span&gt;();
  }

  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; AppComponent &lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Builder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;();
  }

  &lt;span class=&quot;fu&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;)
  &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;initialize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Builder builder) {

    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;robotMembersInjector&lt;/span&gt; =
        Robot_MembersInjector.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(Controller_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(), Power_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;());
  }

  &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(Robot robot) {
    robotMembersInjector.&lt;span class=&quot;fu&quot;&gt;injectMembers&lt;/span&gt;(robot);
  }

  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Builder {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Builder&lt;/span&gt;() {}

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; AppComponent &lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;() {
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DaggerAppComponent&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DaggerAppComponent 为我们构造了 Robot_MembersInjector ，在 &lt;em&gt;public void inject(Robot robot)&lt;/em&gt; 调用了 &lt;em&gt;injectMembers&lt;/em&gt; 方法，如果我们把 Robot 的代码复制一遍，新建一个 Robot2 类，AppComponet 修改为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@Component
interface AppComponent {
    fun &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(robot: Robot)
    fun &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(robot: Robot2)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DaggerAppComponent 有什么变化呢？它会多一个 &lt;em&gt;robot2MembersInjector&lt;/em&gt; 成员变量，&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;initialize&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Builder builder) {

&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;robotMembersInjector&lt;/span&gt; =
    Robot_MembersInjector.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(Controller_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(), Power_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;());

&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;robot2MembersInjector&lt;/span&gt; =
    Robot2_MembersInjector.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(Controller_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;(), Power_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;());
}

&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(Robot robot) {
robotMembersInjector.&lt;span class=&quot;fu&quot;&gt;injectMembers&lt;/span&gt;(robot);
}

&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(Robot2 robot) {
robot2MembersInjector.&lt;span class=&quot;fu&quot;&gt;injectMembers&lt;/span&gt;(robot);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同理，在 Componet 添加多个 inject，会生成对应的 MembersInjector。现在我们注入的 Power 和 Controller 是不是单例的呢？不是的。来看 Robot_MembersInjector 的 injectMembers 函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;injectMembers&lt;/span&gt;(Robot instance) {
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
  &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NullPointerException(&lt;span class=&quot;st&quot;&gt;&quot;Cannot inject members into a null reference&quot;&lt;/span&gt;);
}
instance.&lt;span class=&quot;fu&quot;&gt;controller&lt;/span&gt; = controllerProvider.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
instance.&lt;span class=&quot;fu&quot;&gt;power&lt;/span&gt; = powerProvider.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应的 MembersInjector 的 get 方法都是 new 出一个对象。现在我们想把 Power 注入变成单例的，先加个 &lt;a href=&quot;mailto:*@Singleton*&quot;&gt;*@Singleton*&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@Singleton
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Power @Inject &lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译一下，报错了...&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Error:(11, 2) 错误: com.sw926.dagger2example.AppComponent (unscoped) may not reference scoped bindings:
@dagger.Component()
^
      @Singleton class com.sw926.dagger2example.Power&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Component 是连接 Provider 和 Injector 的桥梁，&lt;a href=&quot;mailto:*@Singleton&quot;&gt;*@Singleton&lt;/a&gt;* 是作用域，不在一个域看来不让连接，那么给 Component 也加上注解：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@Singleton
@Component
interface AppComponent {
    fun &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(robot: Robot)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译通过了，再来看 DaggerAppComponent 的源码，powerProvider 部分改变了，变成了&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;powerProvider&lt;/span&gt; = DoubleCheck.&lt;span class=&quot;fu&quot;&gt;provider&lt;/span&gt;(Power_Factory.&lt;span class=&quot;fu&quot;&gt;create&lt;/span&gt;());&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DoubleCheck 的源码不用贴了，作用就是能保证 Provider get 的时候返回的是单例，而且是安全的，而是是懒加载的，很完美。&lt;/p&gt;
&lt;p&gt;作为一个严谨的程序，一个 Power 哪里够用，我们需要一个备用的，也就是说，需要两个单例的 Power，现在 Module 要登场了。Module 是构造方法的仓库，我们把 Power 的注解去掉，改为在 Module 中提供构造方法，然后在 Component 中指定 Module&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Power

@Module
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; AppModule {

    @Provides
    @Singleton
    fun &lt;span class=&quot;fu&quot;&gt;providePower&lt;/span&gt;() = &lt;span class=&quot;fu&quot;&gt;Power&lt;/span&gt;()
}

@Singleton
@&lt;span class=&quot;fu&quot;&gt;Component&lt;/span&gt;(modules = [(AppModule::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;)])
interface AppComponent {
    fun &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(robot: Robot)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在添加一个 BackUp Power&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Power&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; name: String)

&lt;span class=&quot;co&quot;&gt;// 添加一个 BackUp 注解&lt;/span&gt;
@Qualifier
@Documented
@&lt;span class=&quot;fu&quot;&gt;Retention&lt;/span&gt;(RUNTIME)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; @interface BackUp {
}

&lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;

@Module
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; AppModule {

    @Singleton
    @Provides
    fun &lt;span class=&quot;fu&quot;&gt;providePower&lt;/span&gt;(): Power = &lt;span class=&quot;fu&quot;&gt;Power&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;main&quot;&lt;/span&gt;)

    @BackUp
    @Singleton
    @Provides
    fun &lt;span class=&quot;fu&quot;&gt;provideBackUpPower&lt;/span&gt;(): Power = &lt;span class=&quot;fu&quot;&gt;Power&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;backup&quot;&lt;/span&gt;)
}

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot {
    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; controller: Controller

    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; power: Power
    @field:[Inject BackUp] lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; backUpPower: Power

    &lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt;() {
        DaggerAppComponent.&lt;span class=&quot;fu&quot;&gt;builder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在注入 Power的时候，默认是 &lt;em&gt;main&lt;/em&gt;, 如果添加了 @BackUp 注解，就是 &lt;em&gt;backup&lt;/em&gt;，Robot_MembersInjector 会有三个 Provider&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;  &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;injectMembers&lt;/span&gt;(Robot instance) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (instance == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
      &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NullPointerException(&lt;span class=&quot;st&quot;&gt;&quot;Cannot inject members into a null reference&quot;&lt;/span&gt;);
    }
    instance.&lt;span class=&quot;fu&quot;&gt;controller&lt;/span&gt; = controllerProvider.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
    instance.&lt;span class=&quot;fu&quot;&gt;power&lt;/span&gt; = powerProvider.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
    instance.&lt;span class=&quot;fu&quot;&gt;backUpPower&lt;/span&gt; = backUpPowerProvider.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是时候来验证一下是否是单例了，我们来创建两个 Robot ，看他们的 Power 和 BackUpPower 是否一样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; robot1 = Robot()
&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; robot2 = Robot()

Log.&lt;span class=&quot;fu&quot;&gt;d&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Dagger2Test&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;robot1 :(${robot1.power}, ${robot1.backUpPower}), &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;robot2: (${robot2.power}, ${robot2.backUpPower}&quot;&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;robot1 :(com.sw926.dagger2example.Power@5f1ad48, com.sw926.dagger2example.Power@862e7e1), 
robot2: (com.sw926.dagger2example.Power@dc97906, com.sw926.dagger2example.Power@24c8bc7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说好的单例呢，怎么能骗人呢？大神们当然不会骗人，那肯定是我们的使用方式不对了，我们再来看看代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@Singleton
@Provides
fun &lt;span class=&quot;fu&quot;&gt;providePower&lt;/span&gt;(): Power = &lt;span class=&quot;fu&quot;&gt;Power&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;main&quot;&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;

@Singleton
@&lt;span class=&quot;fu&quot;&gt;Component&lt;/span&gt;(modules = [(AppModule::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;)])
interface AppComponent {

    fun &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(robot: Robot)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们把注入分为三个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供者（Provider）&lt;/li&gt;
&lt;li&gt;接受者，Robot 中的成员变量 power&lt;/li&gt;
&lt;li&gt;提供者和接受者直接的桥梁、纽带，也就 AppComponent&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Dagger 中，使用 Scope 注解的 Provider 提供的对象在作用域内唯一，这个唯一性由谁来控制呢？当然是 Component，每个 Component 只能确保自己注入时的作用域唯一，上面的例子每个 Robot 都创建了一个 AppComponent，所以注入的对象不相同，如果我们把 AppComponent 放在 Application 中创建，&lt;br/&gt;那么注入的对象就是全局唯一对象了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; App : &lt;span class=&quot;fu&quot;&gt;Application&lt;/span&gt;() {

    companion &lt;span class=&quot;kw&quot;&gt;object&lt;/span&gt; {
        lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; appComponent: AppComponent
    }

    &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;()
        appComponent = DaggerAppComponent.&lt;span class=&quot;fu&quot;&gt;builder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;()
    }

}

&lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot {
    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; controller: Controller

    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; power: Power
    @field:[Inject BackUp] lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; backUpPower: Power

    &lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt;() {
        App.&lt;span class=&quot;fu&quot;&gt;appComponent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;robot1 :(com.sw926.dagger2example.Power@862e7e1, com.sw926.dagger2example.Power@dc97906), 
robot2: (com.sw926.dagger2example.Power@862e7e1, com.sw926.dagger2example.Power@dc97906&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果同一个作用域内希望获取两个 Power，那么必须要起个名字区分一下，Qualifier 就是用来区别作用域内的两个对象，我们也可以用 @Named，相当于为第二个 Power起了一个名字：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@Module
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; AppModule {

    @Singleton
    @Provides
    fun &lt;span class=&quot;fu&quot;&gt;providePower&lt;/span&gt;(): Power = &lt;span class=&quot;fu&quot;&gt;Power&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;main&quot;&lt;/span&gt;)

    @&lt;span class=&quot;fu&quot;&gt;Named&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;backup&quot;&lt;/span&gt;)
    @Provides
    @Singleton
    fun &lt;span class=&quot;fu&quot;&gt;provideBackUpPower&lt;/span&gt;(): Power = &lt;span class=&quot;fu&quot;&gt;Power&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;backup&quot;&lt;/span&gt;)
}

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Robot {
    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; controller: Controller

    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; power: Power
    @field:[Inject &lt;span class=&quot;fu&quot;&gt;Named&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;backup&quot;&lt;/span&gt;)] lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; backUpPower: Power

    &lt;span class=&quot;fu&quot;&gt;constructor&lt;/span&gt;() {
        App.&lt;span class=&quot;fu&quot;&gt;appComponent&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们有了一个全局的 AppComponent，放在 Application 里面，管理 App 全局唯一的对象，现在我想有一个 Activity 生命周期的 Component，放在 每个 Activity 里面，Activity 的生命周期肯定在 App 的声明周期里面，所以 ActivityComponent 需要能够注入 AppComponent 注入的对象，现在 AppComponent 能够注入 Power BackUpPower，那么 ActivityComponent 也需要能够注入，这是需要用到 dependencies：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@ForActivity
@&lt;span class=&quot;fu&quot;&gt;Component&lt;/span&gt;(dependencies = [(AppComponent::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;)], modules = [(ActivityModule::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;)])
interface ActivityComponent {

    fun &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(mainActivity: MainActivity)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们为 ActivityComponent 设置了一个作用域 @ForActivity，ActivityComponent 依赖于 AppComponent，现在来看看这样做有什么用。&lt;/p&gt;
&lt;p&gt;注入一个对象需要一个 Provider，Provider 有以下几种形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指定类的构造函数&lt;br/&gt;&lt;code&gt;kotlin class Controller @Inject constructor()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 Provider 函数&lt;br/&gt;&lt;code&gt;kotlin @Singleton @Provides fun providePower(): Power = Power(&quot;main&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从 dependencies 读取&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前两种不用说了，来说说第三种，ActivityComponent 的 module 是 ActivityModule&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@Module
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ActivityModule {

    @ForActivity
    @Provides
    fun &lt;span class=&quot;fu&quot;&gt;providePowerName&lt;/span&gt;(@&lt;span class=&quot;fu&quot;&gt;Named&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;backup&quot;&lt;/span&gt;) power: Power): String {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; power.&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;em&gt;providePowerName&lt;/em&gt; 需要参数 &lt;a href=&quot;mailto:*@Named&quot;&gt;*@Named&lt;/a&gt;(&quot;backup&quot;) power: Power*，这个 power 哪里找？当然是 Dagger 帮我们找，Provider 的三种形式，第一种没有，ActivityModule 里面没有，AppModule 里面有，但是怎么建立连接呢，很简单，在 AppComponent 写一个函数就行&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@Singleton
@&lt;span class=&quot;fu&quot;&gt;Component&lt;/span&gt;(modules = [(AppModule::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;)])
interface AppComponent {

    fun &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(robot: Robot)

    @&lt;span class=&quot;fu&quot;&gt;Named&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;backup&quot;&lt;/span&gt;)
    fun &lt;span class=&quot;fu&quot;&gt;getBackUpPower&lt;/span&gt;(): Power
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么写一个函数就行，源码我也没看过，就当做这是 Dagger 的协议吧，编译后会生成对应的函数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@Override
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Power &lt;span class=&quot;fu&quot;&gt;getBackUpPower&lt;/span&gt;() {
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; provideBackUpPowerProvider.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在 ActivityComponent 的 module ActivityModule 找到了对应的 Provider，就可以正常提供 Power Name 了。&lt;/p&gt;
&lt;p&gt;有了 AppComponent、ActivityComponent，下面就要添加 FragmentComponent了，Fragment 依赖于 Activity，那么我们这样做，FragmentComponent 只能由 ActivityComponent 创建，这就要用到 SubComponent，FragmentComponent 使用 @Subcomponent 注解，同时必须注明一个 Builder：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@ForFragment
@&lt;span class=&quot;fu&quot;&gt;Subcomponent&lt;/span&gt;(modules = [(FragmentModule::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;)])
interface FragmentComponent {

    @Subcomponent.&lt;span class=&quot;fu&quot;&gt;Builder&lt;/span&gt;
    interface Builder {
        fun &lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;(): FragmentComponent
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ActivityComponent 改写为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@ForActivity
@&lt;span class=&quot;fu&quot;&gt;Component&lt;/span&gt;(dependencies = [(AppComponent::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;)], modules = [(ActivityModule::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;)])
interface ActivityComponent {

    fun &lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(mainActivity: MainActivity)

    fun &lt;span class=&quot;fu&quot;&gt;fragmentComponent&lt;/span&gt;(): FragmentComponent.&lt;span class=&quot;fu&quot;&gt;Builder&lt;/span&gt;

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 ActivityModule 里面指明 subcomponents ：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@&lt;span class=&quot;fu&quot;&gt;Module&lt;/span&gt;(subcomponents = [(FragmentComponent::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;)])
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ActivityModule {

    @ForActivity
    @Provides
    fun &lt;span class=&quot;fu&quot;&gt;providePowerName&lt;/span&gt;(@&lt;span class=&quot;fu&quot;&gt;Named&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;backup&quot;&lt;/span&gt;) power: Power): String {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; power.&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译完成之后我们就可以使用 ActivityComponent 创建一个 FragmentComponent 了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; activityComponent = DaggerActivityComponent.&lt;span class=&quot;fu&quot;&gt;builder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;appComponent&lt;/span&gt;(App.&lt;span class=&quot;fu&quot;&gt;appComponent&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;()
activityComponent.&lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)

&lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; fragmentComponent = activityComponent.&lt;span class=&quot;fu&quot;&gt;fragmentComponent&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后说一下 Module 的 includes，也就是一个 Module 可以包含一组 Module&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;@Module
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ActivityModule2 {

    @Provides
    fun &lt;span class=&quot;fu&quot;&gt;provideException&lt;/span&gt;(): Exception {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; Exception(&lt;span class=&quot;st&quot;&gt;&quot;test Exception &quot;&lt;/span&gt;)
    }
}

@&lt;span class=&quot;fu&quot;&gt;Module&lt;/span&gt;(subcomponents = [(FragmentComponent::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;)], includes = [(ActivityModule2::&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt;)])
&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ActivityModule {

    @ForActivity
    @Provides
    fun &lt;span class=&quot;fu&quot;&gt;providePowerName&lt;/span&gt;(@&lt;span class=&quot;fu&quot;&gt;Named&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;backup&quot;&lt;/span&gt;) power: Power): String {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; power.&lt;span class=&quot;fu&quot;&gt;name&lt;/span&gt;
    }
}

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MainActivity : &lt;span class=&quot;fu&quot;&gt;AppCompatActivity&lt;/span&gt;() {


    @Inject lateinit &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; exception: Exception

    &lt;span class=&quot;kw&quot;&gt;override&lt;/span&gt; fun &lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(savedInstanceState: Bundle?) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(savedInstanceState)
        &lt;span class=&quot;fu&quot;&gt;setContentView&lt;/span&gt;(R.&lt;span class=&quot;fu&quot;&gt;layout&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;activity_main&lt;/span&gt;)

        &lt;span class=&quot;kw&quot;&gt;val&lt;/span&gt; activityComponent = DaggerActivityComponent.&lt;span class=&quot;fu&quot;&gt;builder&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;appComponent&lt;/span&gt;(App.&lt;span class=&quot;fu&quot;&gt;appComponent&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;()
        activityComponent.&lt;span class=&quot;fu&quot;&gt;inject&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;)

        Log.&lt;span class=&quot;fu&quot;&gt;d&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Dagger2Test&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Exception: $exception&quot;&lt;/span&gt;)
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode kotlin&quot;&gt;
&lt;code class=&quot;sourceCode kotlin&quot;&gt;D/Dagger2Test: Exception: java.&lt;span class=&quot;fu&quot;&gt;lang&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Exception&lt;/span&gt;: test Exception &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上，使用 Dagger 好几年了，终于把思路理的比较清晰了，在此抛砖引玉，如果错误，欢迎指正。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 07:29:00 +0000</pubDate>
<dc:creator>sw926</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sw926/p/8466020.html</dc:identifier>
</item>
<item>
<title>（二）异步方法BeginInvoke和EndInvoke - 奔游浪子</title>
<link>http://www.cnblogs.com/ttmdl/p/8466005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ttmdl/p/8466005.html</guid>
<description>&lt;p&gt;.Net framework可以让你异步调用任何方法，你可以定义一个与你要调用的方法的签名相同的委托。公共语言运行时将自动为该委托定义与签名相同的BeginInvok和EndInvoke方法。&lt;/p&gt;
&lt;p&gt;BeginInvoke方法触发你的异步方法，它和你想要执行的异步方法有相同的参数。另外还有两个可选参数，第一个是AsyncCallback委托是异步完成的回调方法。第二个是用户自定义对象，该对象将传递到回调方法中。BeginInvoke立即返回并且不等待完成异步的调用（继续执行该下面的代码，不需要等待）。BeginInvoke返回IAsyncResult接口，可用于检测异步调用的过程。&lt;/p&gt;
&lt;p&gt;通过EndInvoke方法检测异步调用的结果。如果异步调用尚未完成，EndInvoke将阻塞调用线程，直到它完成&lt;/p&gt;
&lt;p&gt;下面代码演示使用BeginInvoke和EndInvoke进行异步调用的四种常见方式。在调用BeginInvoke可以做以下工作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;做一些其他操作，然后调用EndInvoke方法阻塞线程直到该方法完成。&lt;/li&gt;
&lt;li&gt;使用IAsyncResult.AsyncWaitHandle属性，使用它的WaitOne方法阻塞线程直到收到WaitHandle信号，然后调用EndInvoke。&lt;/li&gt;
&lt;li&gt;检查BeginInvoke返回值IAsyncResult的状态来决定方法是否完成，然后调用EndInvoke方法。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AsyncMethodCaller(&lt;span&gt;int&lt;/span&gt; callDuration, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadId);
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {       
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            
        }
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TestMethod(&lt;span&gt;int&lt;/span&gt; callDuration, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadId)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test method begins:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;睡一会 模拟耗时操作&lt;/span&gt;
&lt;span&gt;            Thread.Sleep(callDuration);
            threadId &lt;/span&gt;=&lt;span&gt; Thread.CurrentThread.ManagedThreadId;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My call time was {0}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, callDuration.ToString());
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;情况一：通过EndInovke阻塞线程，直到异步调用结束。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadId;
            AsyncMethodCaller caller &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AsyncMethodCaller(TestMethod);
            IAsyncResult result &lt;/span&gt;= caller.BeginInvoke(&lt;span&gt;3000&lt;/span&gt;, &lt;span&gt;out&lt;/span&gt; threadId, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用EndInvoke方法，等待异步嗲用完成，并得到结果。&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; returnValue = caller.EndInvoke(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; threadId, result);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The call executed on thread {0},with return value {1}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threadId, returnValue);
            Console.Read();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;情况二：通过WaitHandle属性阻塞线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadId;
            AsyncMethodCaller caller &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AsyncMethodCaller(TestMethod);
            IAsyncResult result &lt;/span&gt;= caller.BeginInvoke(&lt;span&gt;3000&lt;/span&gt;, &lt;span&gt;out&lt;/span&gt; threadId, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main thread {0} does some work.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待WaitHandle信号&lt;/span&gt;
&lt;span&gt;            result.AsyncWaitHandle.WaitOne();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用EndInvoke方法，等待异步嗲用完成，并得到结果。&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; returnValue = caller.EndInvoke(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; threadId, result);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭等待句柄&lt;/span&gt;
&lt;span&gt;            result.AsyncWaitHandle.Close();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The call executed on thread {0},with return value {1}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threadId, returnValue);
            Console.Read();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;情况三：检查BeginInvoke返回结果的状态。&lt;/p&gt;
&lt;p&gt;可以通过BeginInvoke的返回结果的IsCompleted属性检查异步是否完成。你可以在异步没有完成的时候做其他的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadId;
            AsyncMethodCaller caller &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AsyncMethodCaller(TestMethod);
            IAsyncResult result &lt;/span&gt;= caller.BeginInvoke(&lt;span&gt;3000&lt;/span&gt;, &lt;span&gt;out&lt;/span&gt; threadId, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            Thread.Sleep(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main thread {0} does some work.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (result.IsCompleted == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            {
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用EndInvoke方法，等待异步嗲用完成，并得到结果。&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; returnValue = caller.EndInvoke(&lt;span&gt;out&lt;/span&gt;&lt;span&gt; threadId, result);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭等待句柄&lt;/span&gt;
&lt;span&gt;            result.AsyncWaitHandle.Close();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The call executed on thread {0},with return value {1}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threadId, returnValue);
            Console.Read();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;情况4、可以使用回调函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; RunOnThreadPool(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadId);

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Callback(IAsyncResult ar)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始回调方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回调方法的参数: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ar.AsyncState);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是否线程池: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.IsThreadPoolThread);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程池线程 id: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.ManagedThreadId);
        }


        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Test(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadId)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是否线程池: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, Thread.CurrentThread.IsThreadPoolThread);
            Thread.Sleep(TimeSpan.FromSeconds(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
            threadId &lt;/span&gt;=&lt;span&gt; Thread.CurrentThread.ManagedThreadId;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;线程池线程 id 是: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, threadId);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1046577/201802/1046577-20180224152629955-1567299591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 回调函数的执行，是在EndInvoke之后执行的。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 07:27:00 +0000</pubDate>
<dc:creator>奔游浪子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ttmdl/p/8466005.html</dc:identifier>
</item>
<item>
<title>SSE图像算法优化系列十七：一些图像处理中常用小过程的SSE实现。 - Imageshop</title>
<link>http://www.cnblogs.com/Imageshop/p/8465587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Imageshop/p/8465587.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　在做图像处理的SSE优化时，也会经常遇到一些小的过程、数值优化等代码，本文分享一些个人收藏或实现的代码片段给大家。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　一、快速求对数运算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对数运算在图像处理中也是个经常会遇到的过程，特备是在一些数据压缩和空间转换时常常会用到，而且是个比较耗时的函数，标准的SSE库里并没有提供该函数的实现，如果需要高精度的SSE版本，网络上已经有了，参考：&lt;a href=&quot;https://github.com/to-miz/sse_mathfun_extension/blob/master/sse_mathfun.h&quot; target=&quot;_blank&quot;&gt;https://github.com/to-miz/sse_mathfun_extension/blob/master/sse_mathfun.h&lt;/a&gt;，这个的精度和标准库的精度基本一致了，稍作整理后的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;126&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    对数函数的SSE实现，高精度版&lt;/span&gt;
&lt;span&gt;inline __m128 _mm_log_ps(__m128 x)
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;int&lt;/span&gt; _ps_min_norm_pos[&lt;span&gt;4&lt;/span&gt;] = { &lt;span&gt;0x00800000&lt;/span&gt;, &lt;span&gt;0x00800000&lt;/span&gt;, &lt;span&gt;0x00800000&lt;/span&gt;, &lt;span&gt;0x00800000&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;int&lt;/span&gt; _ps_inv_mant_mask[&lt;span&gt;4&lt;/span&gt;] = { ~&lt;span&gt;0x7f800000&lt;/span&gt;, ~&lt;span&gt;0x7f800000&lt;/span&gt;, ~&lt;span&gt;0x7f800000&lt;/span&gt;, ~&lt;span&gt;0x7f800000&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;int&lt;/span&gt; _pi32_0x7f[&lt;span&gt;4&lt;/span&gt;] = { &lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0x7f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_1[&lt;span&gt;4&lt;/span&gt;] = { &lt;span&gt;1.0f&lt;/span&gt;, &lt;span&gt;1.0f&lt;/span&gt;, &lt;span&gt;1.0f&lt;/span&gt;, &lt;span&gt;1.0f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_0p5[&lt;span&gt;4&lt;/span&gt;] = { &lt;span&gt;0.5f&lt;/span&gt;, &lt;span&gt;0.5f&lt;/span&gt;, &lt;span&gt;0.5f&lt;/span&gt;, &lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_sqrthf[&lt;span&gt;4&lt;/span&gt;] = { &lt;span&gt;0.707106781186547524f&lt;/span&gt;, &lt;span&gt;0.707106781186547524f&lt;/span&gt;, &lt;span&gt;0.707106781186547524f&lt;/span&gt;, &lt;span&gt;0.707106781186547524f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_log_p0[&lt;span&gt;4&lt;/span&gt;] = { &lt;span&gt;7.0376836292E-2f&lt;/span&gt;, &lt;span&gt;7.0376836292E-2f&lt;/span&gt;, &lt;span&gt;7.0376836292E-2f&lt;/span&gt;, &lt;span&gt;7.0376836292E-2f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_log_p1[&lt;span&gt;4&lt;/span&gt;] = { -&lt;span&gt;1.1514610310E-1f&lt;/span&gt;, -&lt;span&gt;1.1514610310E-1f&lt;/span&gt;, -&lt;span&gt;1.1514610310E-1f&lt;/span&gt;, -&lt;span&gt;1.1514610310E-1f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_log_p2[&lt;span&gt;4&lt;/span&gt;] = { &lt;span&gt;1.1676998740E-1f&lt;/span&gt;, &lt;span&gt;1.1676998740E-1f&lt;/span&gt;, &lt;span&gt;1.1676998740E-1f&lt;/span&gt;, &lt;span&gt;1.1676998740E-1f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_log_p3[&lt;span&gt;4&lt;/span&gt;] = { -&lt;span&gt;1.2420140846E-1f&lt;/span&gt;, -&lt;span&gt;1.2420140846E-1f&lt;/span&gt;, -&lt;span&gt;1.2420140846E-1f&lt;/span&gt;, -&lt;span&gt;1.2420140846E-1f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_log_p4[&lt;span&gt;4&lt;/span&gt;] = { &lt;span&gt;1.4249322787E-1f&lt;/span&gt;, &lt;span&gt;1.4249322787E-1f&lt;/span&gt;, &lt;span&gt;1.4249322787E-1f&lt;/span&gt;, &lt;span&gt;1.4249322787E-1f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_log_p5[&lt;span&gt;4&lt;/span&gt;] = { -&lt;span&gt;1.6668057665E-1f&lt;/span&gt;, -&lt;span&gt;1.6668057665E-1f&lt;/span&gt;, -&lt;span&gt;1.6668057665E-1f&lt;/span&gt;, -&lt;span&gt;1.6668057665E-1f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_log_p6[&lt;span&gt;4&lt;/span&gt;] = { &lt;span&gt;2.0000714765E-1f&lt;/span&gt;, &lt;span&gt;2.0000714765E-1f&lt;/span&gt;, &lt;span&gt;2.0000714765E-1f&lt;/span&gt;, &lt;span&gt;2.0000714765E-1f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_log_p7[&lt;span&gt;4&lt;/span&gt;] = { -&lt;span&gt;2.4999993993E-1f&lt;/span&gt;, -&lt;span&gt;2.4999993993E-1f&lt;/span&gt;, -&lt;span&gt;2.4999993993E-1f&lt;/span&gt;, -&lt;span&gt;2.4999993993E-1f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_log_p8[&lt;span&gt;4&lt;/span&gt;] = { &lt;span&gt;3.3333331174E-1f&lt;/span&gt;, &lt;span&gt;3.3333331174E-1f&lt;/span&gt;, &lt;span&gt;3.3333331174E-1f&lt;/span&gt;, &lt;span&gt;3.3333331174E-1f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_log_q1[&lt;span&gt;4&lt;/span&gt;] = { -&lt;span&gt;2.12194440e-4f&lt;/span&gt;, -&lt;span&gt;2.12194440e-4f&lt;/span&gt;, -&lt;span&gt;2.12194440e-4f&lt;/span&gt;, -&lt;span&gt;2.12194440e-4f&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; __declspec(align(&lt;span&gt;16&lt;/span&gt;)) &lt;span&gt;float&lt;/span&gt; _ps_log_q2[&lt;span&gt;4&lt;/span&gt;] = { &lt;span&gt;0.693359375f&lt;/span&gt;, &lt;span&gt;0.693359375f&lt;/span&gt;, &lt;span&gt;0.693359375f&lt;/span&gt;, &lt;span&gt;0.693359375f&lt;/span&gt;&lt;span&gt; };

    __m128 one &lt;/span&gt;= *(__m128*&lt;span&gt;)_ps_1;
    __m128 invalid_mask &lt;/span&gt;=&lt;span&gt; _mm_cmple_ps(x, _mm_setzero_ps());
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; cut off denormalized stuff &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    x &lt;/span&gt;= _mm_max_ps(x, *(__m128*&lt;span&gt;)_ps_min_norm_pos);
    __m128i emm0 &lt;/span&gt;= _mm_srli_epi32(_mm_castps_si128(x), &lt;span&gt;23&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; keep only the fractional part &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    x &lt;/span&gt;= _mm_and_ps(x, *(__m128*&lt;span&gt;)_ps_inv_mant_mask);
    x &lt;/span&gt;= _mm_or_ps(x, _mm_set1_ps(&lt;span&gt;0.5f&lt;/span&gt;&lt;span&gt;));

    emm0 &lt;/span&gt;= _mm_sub_epi32(emm0, *(__m128i *&lt;span&gt;)_pi32_0x7f);
    __m128 e &lt;/span&gt;=&lt;span&gt; _mm_cvtepi32_ps(emm0);
    e &lt;/span&gt;=&lt;span&gt; _mm_add_ps(e, one);

    __m128 mask &lt;/span&gt;= _mm_cmplt_ps(x, *(__m128*&lt;span&gt;)_ps_sqrthf);
    __m128 tmp &lt;/span&gt;=&lt;span&gt; _mm_and_ps(x, mask);
    x &lt;/span&gt;=&lt;span&gt; _mm_sub_ps(x, one);
    e &lt;/span&gt;=&lt;span&gt; _mm_sub_ps(e, _mm_and_ps(one, mask));
    x &lt;/span&gt;=&lt;span&gt; _mm_add_ps(x, tmp);

    __m128 z &lt;/span&gt;=&lt;span&gt; _mm_mul_ps(x, x);
    __m128 y &lt;/span&gt;= *(__m128*&lt;span&gt;)_ps_log_p0;
    y &lt;/span&gt;=&lt;span&gt; _mm_mul_ps(y, x);
    y &lt;/span&gt;= _mm_add_ps(y, *(__m128*&lt;span&gt;)_ps_log_p1);
    y &lt;/span&gt;=&lt;span&gt; _mm_mul_ps(y, x);
    y &lt;/span&gt;= _mm_add_ps(y, *(__m128*&lt;span&gt;)_ps_log_p2);
    y &lt;/span&gt;=&lt;span&gt; _mm_mul_ps(y, x);
    y &lt;/span&gt;= _mm_add_ps(y, *(__m128*&lt;span&gt;)_ps_log_p3);
    y &lt;/span&gt;=&lt;span&gt; _mm_mul_ps(y, x);
    y &lt;/span&gt;= _mm_add_ps(y, *(__m128*&lt;span&gt;)_ps_log_p4);
    y &lt;/span&gt;=&lt;span&gt; _mm_mul_ps(y, x);
    y &lt;/span&gt;= _mm_add_ps(y, *(__m128*&lt;span&gt;)_ps_log_p5);
    y &lt;/span&gt;=&lt;span&gt; _mm_mul_ps(y, x);
    y &lt;/span&gt;= _mm_add_ps(y, *(__m128*&lt;span&gt;)_ps_log_p6);
    y &lt;/span&gt;=&lt;span&gt; _mm_mul_ps(y, x);
    y &lt;/span&gt;= _mm_add_ps(y, *(__m128*&lt;span&gt;)_ps_log_p7);
    y &lt;/span&gt;=&lt;span&gt; _mm_mul_ps(y, x);
    y &lt;/span&gt;= _mm_add_ps(y, *(__m128*&lt;span&gt;)_ps_log_p8);
    y &lt;/span&gt;=&lt;span&gt; _mm_mul_ps(y, x);

    y &lt;/span&gt;=&lt;span&gt; _mm_mul_ps(y, z);
    tmp &lt;/span&gt;= _mm_mul_ps(e, *(__m128*&lt;span&gt;)_ps_log_q1);
    y &lt;/span&gt;=&lt;span&gt; _mm_add_ps(y, tmp);
    tmp &lt;/span&gt;= _mm_mul_ps(z, *(__m128*&lt;span&gt;)_ps_0p5);
    y &lt;/span&gt;=&lt;span&gt; _mm_sub_ps(y, tmp);
    tmp &lt;/span&gt;= _mm_mul_ps(e, *(__m128*&lt;span&gt;)_ps_log_q2);
    x &lt;/span&gt;=&lt;span&gt; _mm_add_ps(x, y);
    x &lt;/span&gt;=&lt;span&gt; _mm_add_ps(x, tmp);
    x &lt;/span&gt;= _mm_or_ps(x, invalid_mask); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; negative arg will be NAN&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　看上去有一大堆代码，不过实测这个的速度越是标准库（&lt;strong&gt;本文是指启动增强指令集选项设置为：未设置，设计上编译器在此种情况下会自动设置为SSE2增强，这可以从反编译logf函数看到，因此，这里的速度比较还不是和纯Fpu实现的比较&lt;/strong&gt;）的2倍，如果稍微降低点精度，比如_ps_log_p5到_ps_log_p8之间的代码，还能提高点速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另外，在很多场合我们还可以使用另外一种低精度的log函数，其C代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;https://stackoverflow.com/questions/9411823/fast-log2float-x-implementation-c&lt;/span&gt;
inline &lt;span&gt;float&lt;/span&gt; IM_Flog(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; val)
{
    union
    {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; val;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x;
    } u &lt;/span&gt;=&lt;span&gt; { val };
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; log_2 = (&lt;span&gt;float&lt;/span&gt;)(((u.x &amp;gt;&amp;gt; &lt;span&gt;23&lt;/span&gt;) &amp;amp; &lt;span&gt;255&lt;/span&gt;) - &lt;span&gt;128&lt;/span&gt;&lt;span&gt;);
    u.x &lt;/span&gt;&amp;amp;= ~(&lt;span&gt;255&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;23&lt;/span&gt;&lt;span&gt;);
    u.x &lt;/span&gt;+= (&lt;span&gt;127&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;23&lt;/span&gt;&lt;span&gt;);
    log_2 &lt;/span&gt;+= ((-&lt;span&gt;0.34484843f&lt;/span&gt;) * u.val + &lt;span&gt;2.02466578f&lt;/span&gt;) * u.val - &lt;span&gt;0.67487759f&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; log_2 * &lt;span&gt;0.69314718f&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这个函数大概有小数点后2位精度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上述代码大约也是标准函数的2倍速度左右。但是上述函数是可以向量化的，我们来尝试实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们首先来看联合体，其实这个东西就是两个东西占同一个内存空间，然后外部用不同的规则去读取他，在SSE里，有着丰富的cast函数，他也是干这个事情的，比如这里的联合体就可以用_mm_castps_si128来转换，而实际上这个Intrinsic并不会产生任何的汇编语句。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么后面的那些移位、或运算、非运算、加减乘除之类的就是直接翻译了，毫无难处，完整的代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;inline __m128 _mm_flog_ps(__m128 x)
{
    __m128i I &lt;/span&gt;=&lt;span&gt; _mm_castps_si128(x);
    __m128 log_2 &lt;/span&gt;= _mm_cvtepi32_ps(_mm_sub_epi32(_mm_and_si128(_mm_srli_epi32(I, &lt;span&gt;23&lt;/span&gt;), _mm_set1_epi32(&lt;span&gt;255&lt;/span&gt;)), _mm_set1_epi32(&lt;span&gt;128&lt;/span&gt;&lt;span&gt;)));
    I &lt;/span&gt;= _mm_and_si128(I, _mm_set1_epi32(-&lt;span&gt;2139095041&lt;/span&gt;));        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    255 &amp;lt;&amp;lt; 23&lt;/span&gt;
    I = _mm_add_epi32(I, _mm_set1_epi32(&lt;span&gt;1065353216&lt;/span&gt;));        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    127 &amp;lt;&amp;lt; 23&lt;/span&gt;
    __m128 F =&lt;span&gt; _mm_castsi128_ps(I);
    __m128 T &lt;/span&gt;= _mm_add_ps(_mm_mul_ps(_mm_set1_ps(-&lt;span&gt;0.34484843f&lt;/span&gt;), F), _mm_set1_ps(&lt;span&gt;2.02466578f&lt;/span&gt;&lt;span&gt;));
    T &lt;/span&gt;= _mm_sub_ps(_mm_mul_ps(T, F), _mm_set1_ps(&lt;span&gt;0.67487759f&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _mm_mul_ps(_mm_add_ps(log_2, T), _mm_set1_ps(&lt;span&gt;0.69314718f&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　经过实测，这个速度可以达到标准库的7到8倍的优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　二、快速求幂运算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一般图像编程中有log出现的地方就会有exp出现，因此exp的优化也尤为重要，同样在&lt;a href=&quot;https://github.com/to-miz/sse_mathfun_extension/blob/master/sse_mathfun.h&quot; target=&quot;_blank&quot;&gt;sse_mathfun.h&lt;/a&gt;中也有exp的优化（还有sin,cos的SSE优化语句呢），我这里就不贴那个的代码了，我们同样关注下用联合体实现的近似快速算法，其C代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;float&lt;/span&gt; IM_Fexp(&lt;span&gt;float&lt;/span&gt; Y)            
&lt;span&gt;{
    union
    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; Value;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; X[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    } V;
    V.X[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = (&lt;span&gt;int&lt;/span&gt;)(Y * &lt;span&gt;1512775&lt;/span&gt; + &lt;span&gt;1072632447&lt;/span&gt; + &lt;span&gt;0.5F&lt;/span&gt;&lt;span&gt;);
    V.X[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)V.Value;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　测试这个和标准的exp库函数速度居然差不多，不晓得为啥，但我们来试下他的SSE优化版本了。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;　V.X[1] = (int)(Y * 1512775 + 1072632447 + 0.5F);这句话没啥难度，直接翻译就可以了，注意几个强制类型转化就可以了，如下所示：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
__m128i T = _mm_cvtps_epi32(_mm_add_ps(_mm_mul_ps(Y, _mm_set1_ps(&lt;span&gt;1512775&lt;/span&gt;)), _mm_set1_ps(&lt;span&gt;1072632447&lt;/span&gt;)));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;由于我们想一次性处理4个float类型的数据，因此也就需要4个union的空间，这样就需要2个__m128i变量来保存数据，每个XMM寄存器的数据应该分别为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　T1    0    T0    0         +     T3   0    T2    0 　　　　（高位----》低位）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个可以使用unpack来实现，具体如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    __m128i TL =&lt;span&gt; _mm_unpacklo_epi32(_mm_setzero_si128(), T);
    __m128i TH &lt;/span&gt;= _mm_unpackhi_epi32(_mm_setzero_si128(), T);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　最后我们认为__m128i里的数据是double数据，直接一个cast就可以了，然后因为我们只需要单精度的数据，再使用_mm_cvtpd_ps将double转换为float类型，注意这个时候还需要将他们连接再一起形成一个完整的__m128变量，最终的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;inline __m128 _mm_fexp_ps(__m128 Y)
{
    __m128i T &lt;/span&gt;= _mm_cvtps_epi32(_mm_add_ps(_mm_mul_ps(Y, _mm_set1_ps(&lt;span&gt;1512775&lt;/span&gt;)), _mm_set1_ps(&lt;span&gt;1072632447&lt;/span&gt;&lt;span&gt;)));
    __m128i TL &lt;/span&gt;=&lt;span&gt; _mm_unpacklo_epi32(_mm_setzero_si128(), T);
    __m128i TH &lt;/span&gt;=&lt;span&gt; _mm_unpackhi_epi32(_mm_setzero_si128(), T);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _mm_movelh_ps(_mm_cvtpd_ps(_mm_castsi128_pd(TL)), _mm_cvtpd_ps(_mm_castsi128_pd(TH)));
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　实测这个的提速大概有10倍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果要求double的exp，其SSE代码你会了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　三、pow函数的优化。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一种常用的近似算法如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
inline &lt;span&gt;float&lt;/span&gt; IM_Fpow(&lt;span&gt;float&lt;/span&gt; a, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; b) 
{
    union
    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; Value;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; X[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    } V;
    V.X[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = (&lt;span&gt;int&lt;/span&gt;)(b * (V.X[&lt;span&gt;1&lt;/span&gt;] - &lt;span&gt;1072632447&lt;/span&gt;) + &lt;span&gt;1072632447&lt;/span&gt;&lt;span&gt;);
    V.X[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)V.Value;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　和exp很类似，留给有兴趣的人自己实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;四：两个求倒数函数的优化误区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　SSE提供了连个快速求倒数的函数，_mm_rcp_ps，_mm_rsqrt_ps，他们都是近似值，只有12bit的精度，如果想通过他们得到精确的倒数值，需要牛顿 - 拉弗森方法，比如利用_mm_rcp_ps求精确倒数的代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;__forceinline __m128 _mm_prcp_ps(__m128 a)
{
    __m128 rcp &lt;/span&gt;= _mm_rcp_ps(a);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    此函数只有12bit的精度.                    &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; _mm_sub_ps(_mm_add_ps(rcp, rcp), _mm_mul_ps(a, _mm_mul_ps(rcp, rcp)));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    x1 = x0 * (2 - d * x0) = 2 * x0 - d * x0 * x0，使用牛顿 - 拉弗森方法这种方法可以提高精度到23bit&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　但是实测这个还不如直接用_mm_div_ps的速度，即使是下面的函数：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;__forceinline __m128 _mm_fdiv_ps(__m128 a, __m128 b)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _mm_mul_ps(a, _mm_rcp_ps(b));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　似乎速度也不够好，而且精度还低了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　特别低，如果使用_mm_rcp_ps和_mm_rsqrt_ps联合求近似sqrt，即如下代码，速度好像还慢了，真搞不明白为什么。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;__forceinline __m128 _mm_fsqrt_ps(__m128 a)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _mm_rcp_ps(_mm_rsqrt_ps(a));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 五、其他参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在&lt;a href=&quot;http://www.alfredklomp.com/programming/sse-intrinsics/%20&quot; target=&quot;_blank&quot;&gt;http://www.alfredklomp.com/programming/sse-intrinsics/&lt;/a&gt; 以及 &lt;a href=&quot;http://www.itkeyword.com/doc/0326039046115117x827/c++-sse2-intrinsics-comparing-unsigned-integers&quot; target=&quot;_blank&quot;&gt;http://www.itkeyword.com/doc/0326039046115117x827/c++-sse2-intrinsics-comparing-unsigned-integers&lt;/a&gt;等网站上还有很多参考的资料，希望大家自己去学习下。&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 24 Feb 2018 07:25:00 +0000</pubDate>
<dc:creator>Imageshop</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Imageshop/p/8465587.html</dc:identifier>
</item>
<item>
<title>字符串操作性能优化 - </title>
<link>http://www.cnblogs.com/baiyujing/p/8465996.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baiyujing/p/8465996.html</guid>
<description>&lt;p&gt;　　昨天看到关于字符串操作性能优化的帖子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.使用值类型的ToString方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;首先理解装箱和拆箱：1.装箱在值类型向引用类型转换时发生。2.&lt;span class=&quot;Apple-tab-span&quot;&gt; 拆箱在引用类型向值类型转换时发生&lt;/span&gt;。&lt;strong&gt;装箱操作和拆箱操作是要额外耗费cpu和内存资源的，&lt;/strong&gt;所以在c# 2.0之后引入了泛型来减少装箱操作和拆箱操作消耗&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;值类型ToString是不会装箱。例如：string a = a + 1;和string a= a + 1.tostring();前者会引起&lt;strong&gt;装箱&lt;/strong&gt;额外消耗资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.运用StringBuilder类 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;mt1&quot; class=&quot;sentence&quot; data-guid=&quot;88a36736b5abb346cc5b1be26b78f774&quot; data-source=&quot;The &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;String object is immutable.&quot;&gt;　　String是不可变的。&lt;span id=&quot;mt1&quot; class=&quot;sentence SentenceHover&quot; data-guid=&quot;88a36736b5abb346cc5b1be26b78f774&quot; data-source=&quot;The &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;String object is immutable.&quot;&gt;&lt;span&gt; 对象是不可变的。&lt;/span&gt; &lt;span id=&quot;mt2&quot; class=&quot;sentence&quot; data-guid=&quot;9fa3fee9781f29bf2da2caa74df94cfa&quot; data-source=&quot;Every time you use one of the methods in the &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;System&amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; xmlns=&amp;quot;&amp;quot;&amp;gt;.String class, you create a new string object in memory, which requires a new allocation of space for that new object.&quot;&gt;每次使用 &lt;span&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.string(v=vs.100).aspx&quot;&gt;System&lt;span&gt;.String&lt;/span&gt;&lt;/a&gt; 类中的一个方法时，都要在内存中创建一个新的字符串对象，这就需要为该新对象分配新的空间。 &lt;span id=&quot;mt3&quot; class=&quot;sentence&quot; data-guid=&quot;1c2a6140a182adac7201e42e7337b6fb&quot; data-source=&quot;In situations where you need to perform repeated modifications to a string, the overhead associated with creating a new &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;String object can be costly.&quot;&gt;在需要对字符串执行重复修改的情况下，与创建新的 &lt;span&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.string(v=vs.100).aspx&quot;&gt;String&lt;/a&gt; 对象相关的系统开销可能会非常大。 &lt;span id=&quot;mt4&quot; class=&quot;sentence&quot; data-guid=&quot;a1c723ade6353f6f324b54d67453f1b5&quot; data-source=&quot;The &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;System.Text&amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; xmlns=&amp;quot;&amp;quot;&amp;gt;.StringBuilder class can be used when you want to modify a string without creating a new object.&quot;&gt;如果要修改字符串而不创建新的对象，则可以使用&lt;span&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.text.stringbuilder(v=vs.100).aspx&quot;&gt;System.Text&lt;span&gt;.StringBuilder&lt;/span&gt;&lt;/a&gt; 类。 &lt;span id=&quot;mt5&quot; class=&quot;sentence&quot; data-guid=&quot;8bee0c070e6805ca5dcdf5778ebb7c48&quot; data-source=&quot;For example, using the &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;StringBuilder class can boost performance when concatenating many strings together in a loop.&quot;&gt;例如，当在一个循环中将许多字符串连接在一起时，使用 &lt;span&gt;&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/system.text.stringbuilder(v=vs.100).aspx&quot;&gt;StringBuilder&lt;/a&gt; 类可以提升性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;88a36736b5abb346cc5b1be26b78f774&quot; data-source=&quot;The &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;String object is immutable.&quot;&gt;&lt;span class=&quot;sentence SentenceHover&quot; data-guid=&quot;88a36736b5abb346cc5b1be26b78f774&quot; data-source=&quot;The &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;String object is immutable.&quot;&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;9fa3fee9781f29bf2da2caa74df94cfa&quot; data-source=&quot;Every time you use one of the methods in the &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;System&amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; xmlns=&amp;quot;&amp;quot;&amp;gt;.String class, you create a new string object in memory, which requires a new allocation of space for that new object.&quot;&gt;&lt;span&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;1c2a6140a182adac7201e42e7337b6fb&quot; data-source=&quot;In situations where you need to perform repeated modifications to a string, the overhead associated with creating a new &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;String object can be costly.&quot;&gt;&lt;span&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;a1c723ade6353f6f324b54d67453f1b5&quot; data-source=&quot;The &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;System.Text&amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; xmlns=&amp;quot;&amp;quot;&amp;gt;.StringBuilder class can be used when you want to modify a string without creating a new object.&quot;&gt;&lt;span&gt;&lt;span class=&quot;sentence&quot; data-guid=&quot;8bee0c070e6805ca5dcdf5778ebb7c48&quot; data-source=&quot;For example, using the &amp;lt;span class=&amp;quot;mtpsTagOuterHtml&amp;quot; &amp;gt;StringBuilder class can boost performance when concatenating many strings together in a loop.&quot;&gt;&lt;span&gt;　　下面简单写个案例实践一下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; str + i引起装箱消耗额外资源
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Test1(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
        {
            Stopwatch watch &lt;/span&gt;=&lt;span&gt; Stopwatch.StartNew();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; a = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                a &lt;/span&gt;= a + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            }
            watch.Stop();
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; sec = watch.ElapsedMilliseconds / &lt;span&gt;1000.0f&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时:{0}秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sec);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 值类型ToString不会装箱
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Test2(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
        {
            Stopwatch watch &lt;/span&gt;=&lt;span&gt; Stopwatch.StartNew();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; a = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                a &lt;/span&gt;= a + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.ToString();
            }
            watch.Stop();
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; sec = watch.ElapsedMilliseconds / &lt;span&gt;1000.0f&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时:{0}秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sec);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; str + i引起装箱消耗额外资源
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Test3(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            Stopwatch watch &lt;/span&gt;=&lt;span&gt; Stopwatch.StartNew();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
            {
                str &lt;/span&gt;= str +&lt;span&gt; i;
            }
            watch.Stop();
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; sec = watch.ElapsedMilliseconds / &lt;span&gt;1000.0f&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时:{0}秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sec);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 使用String,在内存中创建一个新的字符串对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Test4(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            Stopwatch watch &lt;/span&gt;=&lt;span&gt; Stopwatch.StartNew();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
            {
                str &lt;/span&gt;= str +&lt;span&gt; i.ToString();
            }
            watch.Stop();
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; sec = watch.ElapsedMilliseconds / &lt;span&gt;1000.0f&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时:{0}秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sec);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 使用StringBuilder
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;count&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Test5(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count)
        {
            System.Text.StringBuilder str &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Text.StringBuilder();
            Stopwatch watch &lt;/span&gt;=&lt;span&gt; Stopwatch.StartNew();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
            {
                str.Append(i.ToString());
            }
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; result =&lt;span&gt; str.ToString();
            watch.Stop();
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; sec = watch.ElapsedMilliseconds / &lt;span&gt;1000.0f&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;耗时:{0}秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, sec);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1230725/201802/1230725-20180224151318659-671200913.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　多次运行结果可以看到Test1,Test2每次装箱引起性能消耗不是很大，当到100000000（一亿）时有一秒左右差距。Test4,Test5当运行10000时，差距零点几，当运行100000时使用StringBuilder明显性能提升，当然我们可能也用不到如此长的string字符串，以前有个项目sql语句非常复杂是通过StringBuilder拼接的，当时只知道照着用，现在才知道还可以略微提升性能。&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 07:25:00 +0000</pubDate>
<dc:creator>&lt;天上白玉京&gt;</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baiyujing/p/8465996.html</dc:identifier>
</item>
<item>
<title>c# 利用IMap 收取163邮件 - 鱼东东</title>
<link>http://www.cnblogs.com/yudongdong/p/8465551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudongdong/p/8465551.html</guid>
<description>
&lt;p&gt;最近我要做一个爬虫。这个爬虫需要如下几个步骤：&lt;/p&gt;
&lt;p&gt;1 填写注册内容(需要邮箱注册)&lt;/p&gt;
&lt;p&gt;2 过拖拽验证码(geetest)&lt;/p&gt;
&lt;p&gt;3 注册成功会给邮箱发一封确认邮箱&lt;/p&gt;
&lt;p&gt;4 点击确认邮箱中的链接 完成注册&lt;/p&gt;

&lt;p&gt;我这里就采用163邮箱注册。&lt;/p&gt;
&lt;p&gt;邮箱协议有 pop3 和 imap 和 smtp&lt;/p&gt;
&lt;p&gt;我试了pop3  不能够筛选邮件 例如筛选未读 和 发件人这2个条件 所以放弃用pop3&lt;/p&gt;
&lt;p&gt;imap协议是支持的。&lt;/p&gt;
&lt;p&gt;我就找了一个开源的第三方lib：S22.Imap&lt;/p&gt;
&lt;p&gt;用法很简单:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test163()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; imapServer = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;imap.163.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port = &lt;span&gt;993&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (ImapClient client = &lt;span&gt;new&lt;/span&gt; ImapClient(imapServer, port, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxx@163.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, AuthMethod.Login, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Returns a collection of identifiers of all mails matching the specified search criteria.&lt;/span&gt;
                IEnumerable&amp;lt;&lt;span&gt;uint&lt;/span&gt;&amp;gt; uids =&lt;span&gt; client.Search(SearchCondition.Unseen());
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Download mail messages from the default mailbox.&lt;/span&gt;
                IEnumerable&amp;lt;MailMessage&amp;gt; messages =&lt;span&gt; client.GetMessages(uids,FetchOptions.HtmlOnly);

                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;We are connected!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;发现 在login的时候 报错了：&lt;/p&gt;
&lt;p&gt;提示&lt;span&gt;“NO Select Unsafe Login. Please contact kefu@188.com for help”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;163邮箱也会收到一个告警邮件&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201802/472365-20180224140128676-1924324032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;经过查证 发现得需要在发送 login 命令之前 得先发送 id 命令&lt;/p&gt;
&lt;p&gt;至于为什么要这么做 我的理解是得先伪装成普通的客户端吧(有理解错误请指出谢谢)&lt;/p&gt;
&lt;p&gt;我fork了一份SS2.imap的代码 打算兼容163的这个特殊情况改掉源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201802/472365-20180224140341745-256541845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201802/472365-20180224140534828-115300090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后走Login方法就不会报错了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/472365/201802/472365-20180224140607716-233182431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Github地址：https://github.com/yuzd/S22.Imap&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 06:10:00 +0000</pubDate>
<dc:creator>鱼东东</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudongdong/p/8465551.html</dc:identifier>
</item>
<item>
<title>WPF: 深入理解 Weak Event 模型 - WPInfo</title>
<link>http://www.cnblogs.com/wpinfo/p/understanding_weak_event.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wpinfo/p/understanding_weak_event.html</guid>
<description>&lt;p&gt;在之前写的一篇文章（&lt;a href=&quot;http://www.cnblogs.com/wpinfo/p/xaml_control_event_bp.html&quot; target=&quot;_blank&quot;&gt;XAML: 自定义控件中事件处理的最佳实践&lt;/a&gt;）中，我们曾提到了在 .NET 中如果事件没有反注册，将会引起内存泄露。这主要是因为当事件源会对事件监听者产生一个强引用，导致事件监听者无法被垃圾回收。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们首先将进一步说明内存泄露的问题；然后，我们会重点介绍 .NET 中的 Weak Event 模型以及它的应用；之所以使用 Weak Event 模型就是为了解决常规事件中所引起的内存泄露；最后，我们会自己来实现 Weak Event 模型。&lt;/p&gt;
&lt;h2&gt;一、再谈内存泄露&lt;/h2&gt;
&lt;h3&gt;1. 原因&lt;/h3&gt;
&lt;p&gt;我们通常会这样为事件添加事件监听： &lt;span class=&quot;cnblogs_code&quot;&gt;&amp;lt;source&amp;gt;.&amp;lt;&lt;span&gt;event&lt;/span&gt;&amp;gt; += &amp;lt;listener-&lt;span&gt;delegate&lt;/span&gt;&amp;gt;&lt;/span&gt; 。这样注册事件会使事件源对事件监听者产生一个强引用（如下图）。即使事件监听者不再使用时，它也无法被垃圾回收，从而引起了内存泄露。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/676860/201802/676860-20180224105615696-1530040070.png&quot; alt=&quot;&quot;/&gt;而事件源之所以对事件监听者产生强引用，这是由于事件是基于委托，当为某事件注册了监听时，该事件对应的委托会存储对事件监听者的引用。要解决这个问题，只能通过反注册事件。&lt;/p&gt;
&lt;h3&gt;2. 具体问题&lt;/h3&gt;
&lt;p&gt;一个具体的例子是，对于 XAML 应用中的数据绑定，我们会为 Model 实现 INotifyPropertyChanged 接口，这个接口里面包含一个事件：PropertyChanged。当这个事件被触发时，那么表示属性值发生了改变，这时 UI 上绑定此属性的控件的值也要跟着变化。&lt;/p&gt;
&lt;p&gt;在这个场景中，Model 作为数据源，而 UI 作为事件监听者。如果按照常规事件来处理 Model 中的 PropertyChanged 事件，那么，Model 就会对 UI 上的控件产生一个强引用。甚至在控件从可视化树 (VisualTree) 上移除后，只要 Model 的生命周期还没结束，那么控件就一定不能被回收。&lt;/p&gt;
&lt;p&gt;可想而之，当 UI 中使用数据绑定的控件在 VisualTree 上经常变化时（添加或移除），造成的内存泄露问题将会非常严重。&lt;/p&gt;
&lt;p&gt;因此，WPF 引入了 Weak Event 模式来解决这个问题。&lt;/p&gt;
&lt;h2&gt;二、Weak Event 模型&lt;/h2&gt;
&lt;h3&gt;1. WeakEventManager 与 IWeakEventListener&lt;/h3&gt;
&lt;p&gt;Weak Event 模型主要解决的问题就是内存泄露。它通过 WeakEventManager 来实现；WeakEventManager 为作事件源和事件监听者的“中间人”，当事件源的事件触发时，由它负责向事件监听者传递事件。而 WeakEventManager 对事件监听者的引用是弱引用，因此，并不影响事件监听者被垃圾回收。如下图： &lt;img src=&quot;https://images2018.cnblogs.com/blog/676860/201802/676860-20180224105639977-1284502914.png&quot; alt=&quot;&quot;/&gt;WeakEventManager 是一个抽象类，包含两个抽象方法和一些受保护方法，因此要使用它，就需要创建它的派生类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeakEventManager : DispatcherObject
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; WeakEventManager GetCurrentManager(Type managerType);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetCurrentManager(Type managerType, WeakEventManager manager);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DeliverEvent(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs args);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ProtectedAddHandler(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source, Delegate handler);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ProtectedAddListener(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source, IWeakEventListener listener);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ProtectedRemoveHandler(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source, Delegate handler);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ProtectedRemoveListener(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source, IWeakEventListener listener);

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StartListening(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StopListening(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了 WeakEventManager，还要用到 IWeakEventListener 接口，需要处理事件的类要实现这个接口，它包含一个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWeakEventListener
    {
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; ReceiveWeakEvent(Type managerType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ReceiveWeakEvent 方法可以得到 EventManager 的类型以及事件源和事件参数，它返回 bool 类型，用于指明传递过来的事件是否被处理。&lt;/p&gt;
&lt;h3&gt;2. WPF 如何解决问题&lt;/h3&gt;
&lt;p&gt;在 WPF 中，对于 INotifyPropertyChanged 接口的 PropertyChanged 事件，以及 INotifyCollectionChanged 接口的 CollectionChanged 事件等，都有对应的 WeakEventManager 来处理它们。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/676860/201802/676860-20180224102512277-949669954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正是借助于这些 WeakEventManager 来实现了 Weak Event 模型，解决了常规事件强引用的问题，从而使得当控件的生命周期早于 Model 的生命周期时，它们能够被垃圾回收。&lt;/p&gt;
&lt;h2&gt;三、实现 Weak Event 模型&lt;/h2&gt;
&lt;p&gt;实现我们自己的 Weak Event 模型非常简单，不过，首先，我们需要了解在什么情况下需要这么做，以下是几种使用场合：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事件源的生命周期比事件监听者的长；&lt;/li&gt;
&lt;li&gt;事件源和事件监听者的生命周期不明确；&lt;/li&gt;
&lt;li&gt;事件监听者不知道该何时移除事件监听或者不容易移除；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;很明显，前面提到的关于数据绑定的问题是属于第一种情况。&lt;/p&gt;
&lt;p&gt;实现 Weak Event 模型有三种方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用 WeakEventManager&amp;lt;TEventSource,TEventArgs&amp;gt; ；&lt;/li&gt;
&lt;li&gt;创建自定义 WeakEventManager 类；&lt;/li&gt;
&lt;li&gt;使用现有的 WeakEventManager；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在开始实现之前，我们首要需要有一个事件源和事件。假定我们有一个 ValueObject 类，它有一个事件 ValueChanged，用来表示值已经更改；并且，我们再明确一下实现 Weak Event 模型的目的：去除 ValueObject 对监听 ValueChanged 事件对象的强引用，解决内存泄露。&lt;/p&gt;
&lt;p&gt;以下是事件源的相关代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#region&lt;/span&gt; 事件源

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ValueChangedHanlder(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, ValueChangedEventArgs e);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueChangedEventArgs : EventArgs
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; NewValue { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueObject
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; ValueChangedHanlder ValueChanged;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ChangeValue(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; newValue)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改了值&lt;/span&gt;
            ValueChanged?.Invoke(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ValueChangedEventArgs { NewValue =&lt;span&gt; newValue });
        }
    }

    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt; 事件源
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;补充一点：为事件源实现 Weak Event 模型，事件源本身不需要作任何改动。&lt;/p&gt;
&lt;h3&gt;1. 使用 WeakEventManager&amp;lt;TEventSource,TEventArgs&amp;gt;&lt;/h3&gt;
&lt;p&gt;WeakEventManager&amp;lt;TEventSource, TEventArgs&amp;gt; 的两个泛型类型分别是事件源与事件参数，它有 AddHanlder/RemoveHanlder 两个方法。我们可以这样使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValueObject();
            WeakEventManager&lt;/span&gt;&amp;lt;ValueObject, ValueChangedEventArgs&amp;gt;.AddHandler(vo, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ValueChanged&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, OnValueChanged);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发事件&lt;/span&gt;
            vo.ChangeValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is new value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnValueChanged(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, ValueChangedEventArgs e)
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[Handler in Main] 值已改变，新值: {e.NewValue}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码的运行结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[Handler in Main] 值已改变，新值: This is new value
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 AddHanlder 方法中，我们需要手工指明要监听的事件名，所以，我们可以看出，在 AddHanlder 方法内部会用到反射，因此会略微耗一些性能。而接下来将要提到的自定义 WeakEventManager 类，则不存在这个问题，不过，它写的代码要更多。&lt;/p&gt;
&lt;h3&gt;2. 创建自定义 WeakEventManager 类&lt;/h3&gt;
&lt;p&gt;创建一个类，名为 ValueChangedEventManager，使它继承自 WeakEventManager，并重写其抽象方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueChangedEventManager : WeakEventManager
    {
         &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StartListening(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vo = source &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ValueObject;
            vo.ValueChanged &lt;/span&gt;+=&lt;span&gt; Vo_ValueChanged;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; StopListening(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vo = source &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ValueObject;
            vo.ValueChanged &lt;/span&gt;-=&lt;span&gt; Vo_ValueChanged;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Vo_ValueChanged(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, ValueChangedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向事件监听者传递事件&lt;/span&gt;
            &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.DeliverEvent(sender, e);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，我们看到，由于自定义的 WeakEventManager 类作了事件的监听者，所以事件源不再引用事件监听者了，而是现在的 WeakEventManager。&lt;/p&gt;
&lt;p&gt;然后，继续在它里面添加以下代码，用于方便处理事件监听：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回当前实例
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ValueChangedEventManager CurrentManager
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mgr = GetCurrentManager(&lt;span&gt;typeof&lt;/span&gt;(ValueChangedEventManager)) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ValueChangedEventManager;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mgr == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    mgr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValueChangedEventManager();
                    SetCurrentManager(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ValueChangedEventManager), mgr);
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mgr;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 添加事件监听
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;source&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;eventListener&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; AddListener(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source, IWeakEventListener eventListener)
        {
            CurrentManager.ProtectedAddListener(source, eventListener);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 移除事件监听
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;source&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;eventListener&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RemoveListener(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source, IWeakEventListener eventListener)
        {
            CurrentManager.ProtectedRemoveListener(source, eventListener);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：这里我们定义了一个静态只读属性，返回当前 WeakEventManager 的单例，并利用它来调用其基类的对应方法。&lt;/p&gt;
&lt;p&gt;接下来，我们创建一个类 ValueChangedListener，并使它实现 IWeakEventListener 接口。这个类负责处理由 WeakEventManager 传递过来的事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueChangedListener : IWeakEventListener
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; HandleValueChangedEvent(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, ValueChangedEventArgs e)
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[ValueChangedListener] 值已改变，新值: {e.NewValue}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从 WeakEventManager 接收到事件，由 IWeakEventListener 定义
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;managerType&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ReceiveWeakEvent(Type managerType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对类型判断，如果是对应类型，则进行事件处理&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (managerType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ValueChangedEventManager))
            {
                HandleValueChangedEvent(sender, (ValueChangedEventArgs)e);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 ReceiveWeakEvent 方法中会调用  HandleValueChangedEvent 方法来处理传给 Listener 的事件。使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;var&lt;/span&gt; vo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValueObject();
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; eventListener = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValueChangedListener();
   ValueChangedEventManager.AddListener(vo, eventListener);

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发事件&lt;/span&gt;
   vo.ChangeValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is new value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当执行到最后一句代码时，会输出如下结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[ValueChangedListener] 值已改变，新值: This is new value
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 使用现有的 WeakEventManager&lt;/h3&gt;
&lt;p&gt;WPF 中包含了一些现成的 WeakEventManager，像上面图中的那些类，都派生于 WeakEventManager。如果你使用的是这些 EventManager 对应要处理的事件，则可以直接使用相应的 WeakEventManager。&lt;/p&gt;
&lt;p&gt;举例来说，有一个 Person 类，我们需要关注它的属性值变化，那么就可以为它实现 INotifyPropertyChanged，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person : INotifyPropertyChanged
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _name;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; PropertyChangedEventHandler PropertyChanged;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Name
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _name; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                _name &lt;/span&gt;=&lt;span&gt; value;
                RaisePropertyChanged(nameof(Name));
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RaisePropertyChanged(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; propertyName)
        {
            PropertyChanged&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyChangedEventArgs(propertyName));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：现在讨论的场景不仅用于 WPF ，也适用于其它任何平台，只要你有同样的需求：监测属性值变化。&lt;/p&gt;
&lt;p&gt;然后，我们再创建一个类 PropertyChangedEventListener 用于响应 PropertyChanged 事件；像上面的 ValueChangedListener 类一样，这个类也要实现 IWeakEventListener 接口，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 监听并处理 PropertyChanged 事件
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PropertyChangedEventListener : IWeakEventListener
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ReceiveWeakEvent(Type managerType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (managerType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(PropertyChangedEventManager))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对事件进行处理，如更新 UI 中对应绑定的值&lt;/span&gt;
                Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[PropertyChangedEventListener] 此属性值已改变: { (e as PropertyChangedEventArgs).PropertyName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 ReceiveWeakEvent 方法中，我们可以添加当某属性更改时，如何来处理。其实，我们在这里已经简单地模拟了 WPF 中通过数据绑定更新 UI 的思路，不过真正的情况一定会比这要复杂。来看如何使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; property = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyChangedEventListener();
    PropertyChangedEventManager.AddListener(person, property, nameof(person.Name));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过修改属性值，触发 PropertyChanged 事件&lt;/span&gt;
    person.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jim&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[PropertyChangedEventListener] 此属性值已改变: Name
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本文讨论了 WPF 中的 Weak Event 模型，它用于解决常规事件中内存泄露的问题。它的实现原理是使用 WeakEventManager 作为“中间人”而将事件源与事件监听者之间的强引用去除，当事件源中的事件触发后，由 WeakEventManager 将事件源和事件参数再传递监听者，而事件监听者在收到事件后，根据传过来的参数对事件作相应的处理。除此以外，我们也讨论了使用 Weak Event 模型的场景以及实现 Weak Event 模型的三种方法。&lt;/p&gt;
&lt;p&gt;如果你在开发过程中，遇到了类似的场景或者同样的问题，也可以尝试使用 Weak Event 来解决。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/wpf/advanced/weak-event-patterns&quot; target=&quot;_blank&quot;&gt;Weak Event Patterns&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.windows.weakeventmanager?view=netframework-4.7.1&quot; target=&quot;_blank&quot;&gt;WeakEventManager Class&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://reedcopsey.com/2009/08/06/preventing-event-based-memory-leaks-weakeventmanager/&quot; target=&quot;_blank&quot;&gt;Preventing Event-based Memory Leaks – WeakEventManager&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/wpinfo/WeakEventDemo.zip&quot; target=&quot;_blank&quot;&gt;源码下载&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 24 Feb 2018 05:46:00 +0000</pubDate>
<dc:creator>WPInfo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wpinfo/p/understanding_weak_event.html</dc:identifier>
</item>
<item>
<title>OpenLayers3调用天地图wmts示例 - Empty倚楼听风雨</title>
<link>http://www.cnblogs.com/EmptyBlog/p/8465366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyBlog/p/8465366.html</guid>
<description>&lt;p&gt;最近，工作中有需要用OpenLayers3脚本库调用天地图的wmts服务接口，由于这两个都是刚开始接触，所以是摸着石头过河，遇到了地图显示不了的问题。&lt;/p&gt;&lt;p&gt;我也通过用浏览器直接提供的地址打开，来进行参数对比。再看了OpenLayers3和天地图的相关文档和网络上的文章，也加入了相关群下载相关资料浏览并询问群友，还是未果。&lt;/p&gt;&lt;p&gt;虽然官网http://www.zjditu.cn/resource/apihelp 有这么一个例子，但是我替换成提供的正式地址，并没有显示地图（每个层级都是需要的，否则只能通过放大或者缩小才能看到，还有layer的值大小写需要匹配）。&lt;/p&gt;&lt;p&gt;最后还是让提供方给了个例子，完成了实现（刚开始要，没给，不知道是忙还是什么情况）。&lt;/p&gt;&lt;p&gt;为了让刚接触这种需求的广大程序猿能够少走点弯路，下面给出示例，有注释。有些参数不懂或者想使用复杂功能的，则查阅下列网址：&lt;/p&gt;&lt;div readability=&quot;179&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://openlayers.org/en/v4.6.4/css/ol.css&quot; type=&quot;text/css&quot;&amp;gt;
    &amp;lt;script src=&quot;https://openlayers.org/en/v4.6.4/build/ol.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;amp;&lt;span&gt;nbsp;选中的经纬度：
        &lt;/span&gt;&amp;lt;input id=&quot;Coordinates&quot; type=&quot;text&quot; value=&quot;&quot; disabled=&quot;disabled&quot; style=&quot;width: 350px;&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div id=&quot;map&quot; class=&quot;map&quot; style=&quot;height: 493px;&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div id=&quot;div_overlay&quot; style=&quot;display: none;&quot;&amp;gt;
        &amp;lt;div id=&quot;marker&quot; title=&quot;&quot;&amp;gt;
            &amp;lt;img src=&quot;position_orange.png&quot; /&amp;gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div id=&quot;popup&quot; title=&quot;&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        &lt;span&gt;var&lt;/span&gt; projection = ol.proj.get('EPSG:4326');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置坐标系&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; projectionExtent =&lt;span&gt; projection.getExtent();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分辨率&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; resolutions =&lt;span&gt; [
            &lt;/span&gt;1.40625&lt;span&gt;,
            &lt;/span&gt;0.703125&lt;span&gt;,
            &lt;/span&gt;0.3515625&lt;span&gt;,
            &lt;/span&gt;0.17578125&lt;span&gt;,
            &lt;/span&gt;0.087890625&lt;span&gt;,
            &lt;/span&gt;0.0439453125&lt;span&gt;,
            &lt;/span&gt;0.02197265625&lt;span&gt;,
            &lt;/span&gt;0.010986328125&lt;span&gt;,
            &lt;/span&gt;0.0054931640625&lt;span&gt;,
            &lt;/span&gt;0.00274658203125&lt;span&gt;,
            &lt;/span&gt;0.001373291015625&lt;span&gt;,
            &lt;/span&gt;0.0006866455078125&lt;span&gt;,
            &lt;/span&gt;0.00034332275390625&lt;span&gt;,
            &lt;/span&gt;0.000171661376953125&lt;span&gt;,
            &lt;/span&gt;0.0000858306884765625&lt;span&gt;,
            &lt;/span&gt;0.00004291534423828125&lt;span&gt;,
            &lt;/span&gt;0.000021457672119140625&lt;span&gt;,
            &lt;/span&gt;0.000010728836059570312&lt;span&gt;,
            &lt;/span&gt;0.000005364418029785156&lt;span&gt;,
            &lt;/span&gt;0.000002682209014892578&lt;span&gt;,
            &lt;/span&gt;0.000001341104507446289&lt;span&gt;
        ];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;瓦片矩阵&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; matrixIds = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; centerXY = &quot;121.54449462890625,29.875946044921875&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地图中心点，默认宁波市&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; center =&lt;span&gt; ReturnCenter(centerXY);

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; emap_attributions = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.Attribution({
            html: &lt;/span&gt;'&amp;lt;span class=&quot;span_switch&quot; onclick=&quot;ChangeToImgMap()&quot;&amp;gt;点击切换地图类型&amp;lt;/span&amp;gt;'&lt;span&gt;
        });
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; EMap() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; map = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.Map({
                controls: ol.control.defaults({
                    attribution: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                }).extend([
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ol.control.MousePosition()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否显示鼠标所在地图点的经纬度&lt;/span&gt;
&lt;span&gt;                ]),
                layers: [
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.layer.Tile({
                      source: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.source.WMTS({
                          attributions: emap_attributions,
                          name: &lt;/span&gt;&quot;中国矢量1-14级&quot;&lt;span&gt;,
                          url: &lt;/span&gt;&quot;http://t{0-6}.tianditu.com/vec_c/wmts&quot;&lt;span&gt;,
                          layer: &lt;/span&gt;&quot;vec&quot;&lt;span&gt;,
                          style: &lt;/span&gt;&quot;default&quot;&lt;span&gt;,
                          matrixSet: &lt;/span&gt;&quot;c&quot;&lt;span&gt;,
                          format: &lt;/span&gt;&quot;tiles&quot;&lt;span&gt;,
                          wrapX: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地图缩小后，防止在一个页面出现多个一样的地图&lt;/span&gt;
                          tileGrid: &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.tilegrid.WMTS({
                              origin: ol.extent.getTopLeft(projectionExtent),
                              resolutions: resolutions.slice(&lt;/span&gt;0, 15),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;slice方法不清楚的请百度&lt;/span&gt;
                              matrixIds: matrixIds.slice(0, 15&lt;span&gt;)
                          })
                      }),
                      maxResolution: resolutions[&lt;/span&gt;0&lt;span&gt;],
                      minResolution: resolutions[&lt;/span&gt;14&lt;span&gt;]
                  }),
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.layer.Tile({
                      source: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.source.WMTS({
                          attributions: emap_attributions,
                          name: &lt;/span&gt;&quot;中国矢量注记1-14级&quot;&lt;span&gt;,
                          url: &lt;/span&gt;&quot;http://t{0-6}.tianditu.com/cva_c/wmts&quot;&lt;span&gt;,
                          layer: &lt;/span&gt;&quot;cva&quot;&lt;span&gt;,
                          style: &lt;/span&gt;&quot;default&quot;&lt;span&gt;,
                          matrixSet: &lt;/span&gt;&quot;c&quot;&lt;span&gt;,
                          format: &lt;/span&gt;&quot;tiles&quot;&lt;span&gt;,
                          wrapX: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                          tileGrid: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.tilegrid.WMTS({
                              origin: ol.extent.getTopLeft(projectionExtent),
                              resolutions: resolutions.slice(&lt;/span&gt;0, 15&lt;span&gt;),
                              matrixIds: matrixIds.slice(&lt;/span&gt;0, 15&lt;span&gt;)
                          })
                      }),
                      maxResolution: resolutions[&lt;/span&gt;0&lt;span&gt;],
                      minResolution: resolutions[&lt;/span&gt;14&lt;span&gt;]
                  }),
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.layer.Tile({
                      source: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.source.WMTS({
                          attributions: emap_attributions,
                          name: &lt;/span&gt;&quot;浙江矢量15-17级&quot;&lt;span&gt;,
                          url: &lt;/span&gt;&quot;http://srv{0-6}.zjditu.cn/ZJEMAP_2D/wmts&quot;&lt;span&gt;,
                          layer: &lt;/span&gt;&quot;TDT_ZJEMAP&quot;&lt;span&gt;,
                          style: &lt;/span&gt;&quot;default&quot;&lt;span&gt;,
                          matrixSet: &lt;/span&gt;&quot;TileMatrixSet0&quot;&lt;span&gt;,
                          format: &lt;/span&gt;&quot;image/png&quot;&lt;span&gt;,
                          wrapX: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                          tileGrid: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.tilegrid.WMTS({
                              origin: ol.extent.getTopLeft(projectionExtent),
                              resolutions: resolutions.slice(&lt;/span&gt;15, 18&lt;span&gt;),
                              matrixIds: matrixIds.slice(&lt;/span&gt;15, 18&lt;span&gt;)
                          })
                      }),
                      maxResolution: resolutions[&lt;/span&gt;14],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定当前级数的上一级来平滑过渡，否则滚轮缩放当前级数会显示空白&lt;/span&gt;
                      minResolution: resolutions[17&lt;span&gt;]
                  }),
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.layer.Tile({
                      source: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.source.WMTS({
                          attributions: emap_attributions,
                          name: &lt;/span&gt;&quot;浙江矢量注记15-17级&quot;&lt;span&gt;,
                          url: &lt;/span&gt;&quot;http://srv{0-6}.zjditu.cn/ZJEMAPANNO_2D/wmts&quot;&lt;span&gt;,
                          layer: &lt;/span&gt;&quot;ZJEMAPANNO&quot;&lt;span&gt;,
                          style: &lt;/span&gt;&quot;default&quot;&lt;span&gt;,
                          matrixSet: &lt;/span&gt;&quot;TileMatrixSet0&quot;&lt;span&gt;,
                          format: &lt;/span&gt;&quot;image/png&quot;&lt;span&gt;,
                          wrapX: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                          tileGrid: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.tilegrid.WMTS({
                              origin: ol.extent.getTopLeft(projectionExtent),
                              resolutions: resolutions.slice(&lt;/span&gt;15, 18&lt;span&gt;),
                              matrixIds: matrixIds.slice(&lt;/span&gt;15, 18&lt;span&gt;)
                          })
                      }),
                      maxResolution: resolutions[&lt;/span&gt;14],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定当前级数的上一级来平滑过渡，否则滚轮缩放当前级数会显示空白&lt;/span&gt;
                      minResolution: resolutions[17&lt;span&gt;]
                  }),
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.layer.Tile({
                      source: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.source.WMTS({
                          attributions: emap_attributions,
                          name: &lt;/span&gt;&quot;XX县矢量18-20级&quot;&lt;span&gt;,
                          url: &lt;/span&gt;&quot;替换成你需要的wmts服务接口地址&quot;&lt;span&gt;,
                          layer: &lt;/span&gt;&quot;jsemap&quot;&lt;span&gt;,
                          style: &lt;/span&gt;&quot;default&quot;&lt;span&gt;,
                          matrixSet: &lt;/span&gt;&quot;TileMatrixSet0&quot;&lt;span&gt;,
                          format: &lt;/span&gt;&quot;image/png&quot;&lt;span&gt;,
                          wrapX: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                          tileGrid: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.tilegrid.WMTS({
                              origin: ol.extent.getTopLeft(projectionExtent),
                              resolutions: resolutions.slice(&lt;/span&gt;18, 21&lt;span&gt;),
                              matrixIds: matrixIds.slice(&lt;/span&gt;18, 21&lt;span&gt;)
                          })
                      }),
                      maxResolution: resolutions[&lt;/span&gt;17],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定当前级数的上一级来平滑过渡，否则滚轮缩放当前级数会显示空白&lt;/span&gt;
                      minResolution: resolutions[20&lt;span&gt;]
                  }),
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.layer.Tile({
                      source: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.source.WMTS({
                          attributions: emap_attributions,
                          name: &lt;/span&gt;&quot;XX县矢量注记18-20级&quot;&lt;span&gt;,
                          url: &lt;/span&gt;&quot;替换成你需要的wmts服务接口地址&quot;&lt;span&gt;,
                          layer: &lt;/span&gt;&quot;jsemapanno&quot;&lt;span&gt;,
                          style: &lt;/span&gt;&quot;default&quot;&lt;span&gt;,
                          matrixSet: &lt;/span&gt;&quot;TileMatrixSet0&quot;&lt;span&gt;,
                          format: &lt;/span&gt;&quot;image/png&quot;&lt;span&gt;,
                          wrapX: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                          tileGrid: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.tilegrid.WMTS({
                              origin: ol.extent.getTopLeft(projectionExtent),
                              resolutions: resolutions.slice(&lt;/span&gt;18, 21&lt;span&gt;),
                              matrixIds: matrixIds.slice(&lt;/span&gt;18, 21&lt;span&gt;)
                          })
                      }),
                      maxResolution: resolutions[&lt;/span&gt;17],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定当前级数的上一级来平滑过渡，否则滚轮缩放当前级数会显示空白&lt;/span&gt;
                      minResolution: resolutions[21&lt;span&gt;]
                  })
                ],
                target: &lt;/span&gt;&quot;map&quot;&lt;span&gt;,
                view: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.View({
                    center: center,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地图中心点&lt;/span&gt;
                    projection: projection,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;投影类别&lt;/span&gt;
                    zoom: 10,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认缩放级别&lt;/span&gt;
                    maxZoom: 20,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大缩放级别&lt;/span&gt;
                    minZoom: 1&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最小缩放级别&lt;/span&gt;
&lt;span&gt;                })
            });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;鼠标点击时设置中心点覆盖物&lt;/span&gt;
            GetElementId(&quot;map&quot;).onclick = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                coordinates &lt;/span&gt;= GetElementsByClassName('ol-mouse-position')[0&lt;span&gt;].innerHTML;
                SetPosition(map, coordinates);
            };
        }

        EMap();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示E电子地图&lt;/span&gt;

        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetElementId(id) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; document.getElementById(id);
        }
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetElementsByClassName(className) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; document.getElementsByClassName(className);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中心点处理&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ReturnCenter(centerXY) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; centerObj = centerXY.split(','&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; centerX = centerObj[0&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; centerY = centerObj[1&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; [parseFloat(centerX), parseFloat(centerY)];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一定要转换下类型，否则拖拽后，地图就消失了&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置中心点覆盖物&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SetPosition(map, coordinates) {
            GetElementId(&lt;/span&gt;&quot;Coordinates&quot;).value =&lt;span&gt; coordinates;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newcenter =&lt;span&gt; ReturnCenter(coordinates);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Position marker&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; marker = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ol.Overlay({
                position: newcenter,
                positioning: &lt;/span&gt;'bottom-center'&lt;span&gt;,
                element: document.getElementById(&lt;/span&gt;'marker'&lt;span&gt;),
                stopEvent: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            });
            map.addOverlay(marker);
        }
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Sat, 24 Feb 2018 05:27:00 +0000</pubDate>
<dc:creator>Empty倚楼听风雨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyBlog/p/8465366.html</dc:identifier>
</item>
</channel>
</rss>