<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux 中/data 数据分区磁盘空间不足，如何挂载磁盘。 - 三天两觉</title>
<link>http://www.cnblogs.com/xuenil/p/9481896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuenil/p/9481896.html</guid>
<description>&lt;p&gt;首先，咱们需要模拟一下环境，下图  使用VMware为我添加一块300G（实际200M~~手动滑稽 -_-）的硬盘设备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1460131/201808/1460131-20180815142713693-1138391152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照步骤一步一步添加就好。添加完成后需要重启你的虚拟机，方能生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1460131/201808/1460131-20180815142937677-211989211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，那么咱们的环境就有了。我已经为咱们的“服务器”安装了个300G（200M）的硬盘了，现在咱们把它挂载到 /data 下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步，为新磁盘创建分区。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@~]# ll /dev/sdb*    #检查第二块硬盘，及分区
brw-rw---- 1 root disk 8, 16 Aug 15 14:35 /dev/sdb
#这里显示，你有第二块磁盘，但是没有分区啊，兄弟~~
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为磁盘创建分区，可以用两个命令，fdisk  and  parted 。这里咱们先讲 fdisk 。parted等下再说&lt;/p&gt;
&lt;p&gt;fdisk 命令，-c 选项：关闭dos兼容模式，-u 以扇区为单位为磁盘分区。&lt;/p&gt;
&lt;p&gt;当需要为你的磁盘分的细致一些的时候可以使用，咱们现在要把300G都挂载到 /data 就不使用命令选项了。&lt;/p&gt;
&lt;p&gt;下面是等下需要用到的 fdisk  内部指令含义：&lt;/p&gt;
&lt;p&gt;m  显示帮助。       n   创建分区。      p  显示磁盘分区信息。     d   删除分区。      w   保存并退出。     q   退出不保存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@~]# fdisk /dev/sdb      #fdisk 命令后面直接加 磁盘文件就好

WARNING: DOS-compatible mode is deprecated. It's strongly recommended to
         switch off the mode (command 'c') and change display units to
         sectors (command 'u').
&lt;span&gt;#这里的警告信息就是，建议你关闭dos兼容模式，且启用-u选项，简单说就是让你使用 -cu 选项。
不过这个警告并不需要太在意，它只会在磁盘未分区时显示，且不会对咱们下面的操作有任何影响。&lt;/span&gt;
Command (m for help): p   &lt;span&gt;#先看一下磁盘分区情况&lt;/span&gt;

Disk /dev/sdb: 213 MB, 213909504 bytes
64 heads, 32 sectors/track, 204 cylinders
Units = cylinders of 2048 * 512 = 1048576 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x1bf8bec7

   Device Boot      Start         End      Blocks   Id  System

&lt;span&gt;#嗯，空白的    就是没有进行过磁盘分区。&lt;/span&gt;
Command (m for help): n     &lt;span&gt; #创建磁盘分区&lt;/span&gt;
Command action
   e   extended
   p   primary partition (1-4)  &lt;span&gt; #这里是系统提示，是按 e 创建扩展分区，还是按 p 创建主分区了？&lt;/span&gt;
p                &lt;span&gt;#咱们就准备整一个分区，自然选择 p  主分区啦~~&lt;/span&gt;
Partition number (1-4): 1       &lt;span&gt; #键入1 ， 就是1号主分区的意思。&lt;/span&gt;
First cylinder (1-204, default 1):&lt;span&gt;“回车键” （按下Enter）&lt;/span&gt;    &lt;span&gt;#这里是让你选择分区开始的柱面，回车就是默认，最初的意思&lt;/span&gt;            
Using default value 1
Last cylinder, +cylinders or +size{K,M,G} (1-204, default 204):&lt;span&gt;“回车键” （按下Enter）&lt;/span&gt;   &lt;span&gt;#这里是让你选择分区结束的柱面，回车就是默认，最后的意思&lt;/span&gt;    
Using default value 204    &lt;span&gt;（创建好了）&lt;/span&gt;

Command (m for help): p       &lt;span&gt; #咱们再看一下&lt;/span&gt;

Disk /dev/sdb: 213 MB, 213909504 bytes
64 heads, 32 sectors/track, 204 cylinders
Units = cylinders of 2048 * 512 = 1048576 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x1bf8bec7

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1         204      208880   83  Linux
&lt;span&gt;#嗯嗯，分区名称/dev/sdb1，大小差不多“300G”&lt;/span&gt;
Command (m for help): w     &lt;span&gt;# 键入 w ，一定要保存后退出。不然所有的设置都不会生效。&lt;/span&gt;
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　fdisk -l 查看一下磁盘的信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@~]# fdisk -l| grep '/dev/sdb'

Disk /dev/sdb: 213 MB, 213909504 bytes
/dev/sdb1               1         204      208880   83  Linux

&lt;span&gt;#这就说明咱们呢的磁盘分区已经创建OK。
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;第二步，为你的分区创建文件系统（格式化）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先要手动更新一下系统 sdb 磁盘分区表有变化了~~&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@~]# partprobe /dev/sdb
[root@~]# 

&lt;span&gt;# 傲娇的Linux 并不会给你任何提示。但是这个步骤必不可少
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　然后直接给分区直接装个 ext4文件系统就好了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@~]# mkfs.ext4 /dev/sdb1    &lt;span&gt;#mkfs 命令接 .ext4 中间不需要使用空格。后面要跟分区的文件名，并不是磁盘文件名，这个要注意。&lt;/span&gt;
mke2fs 1.41.12 (17-May-2010)
··························此处省略数行
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 21 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
&lt;span&gt;#最后这两个提示信息是最重要的，它的意思是说：这个文件系统将在21挂载或是180以后自动检查，使用 tune2fs -c 或-i 可以覆盖掉默认自动检查。
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　反正我是不需要系统默认检查什么的，那我就直接关掉好了，就使用它建议的 tune2fs 命令就好了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@~]# tune2fs -c 0 -i 0 /dev/sdb1    &lt;span&gt;# -c 和 -i 后面都是零（不检查的意思），还是磁盘分区文件~~&lt;/span&gt;
tune2fs 1.41.12 (17-May-2010) 
Setting maximal mount count to -1
Setting interval between checks to 0 seconds
&lt;span&gt;#提示信息我就不逐条翻译了，大概意思就是系统不会自动检查了。
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;第三步，将 /dev/sdb1 挂载~~到 /data ，并实现开机自动挂载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;mount 挂载，这个简单，我就不讲了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@~]# mount /dev/sdb1 /data
[root@~]# df -h           &lt;span&gt; #最好 df -h 查看一下&lt;/span&gt;
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda3        19G  2.3G   16G  13% /
tmpfs           490M     0  490M   0% /dev/shm
/dev/sda1       190M   66M  115M  37% /boot
/dev/sdb1       194M  1.8M  182M   1% /data
               #这里不应该是300G吗，难道是我挂错了?- _ -？
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　开机自动实现挂载的方法有很多，咱们就简单的讲三种好了。&lt;/p&gt;
&lt;p&gt;方法一：通过 /etc/rc.local   实现开机运行 mount /dev/sdb1 /data 。来实现开机自动挂载&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@~]# ll /etc/rc.local 
lrwxrwxrwx 1 root root 13 Aug  6 17:57 /etc/rc.local -&amp;gt; rc.d/rc.local
&lt;span&gt;# /etc/rc.local  是 /etc/rc.d/rc.local 的符号链接。在root权限下直接修改符号链接的文件就可以了。&lt;/span&gt;
[root@~]# vim /etc/rc.d/rc.local      &lt;span&gt;#但是我有强迫症，我就要修改源文件。哼哼~~&lt;/span&gt;

#!/bin/sh
#
# This script will be executed *after* all the other init scripts.
# You can put your own initialization stuff in here if you don't
# want to do the full Sys V style init stuff.

touch /var/lock/subsys/local
&lt;span&gt;mount /dev/sdb1 /data&lt;/span&gt;            &lt;span&gt;#编写这么一句就好了，但是我不建议这么做。可能是因为比较Low吧&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二：通过 /etc/fstab 实现开机自动挂载&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Sat Jul 28 14:15:11 2018
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
UUID=4b7f430b-398b-4ca4-a6f4-75e11c8498f0 /                       ext4    defaults        1 1
UUID=b001470a-e506-4b50-a705-7b4343ac6a7c /boot                   ext4    defaults        1 2
UUID=ec344814-973b-45d3-95f0-7ce6265b3247 swap                    swap    defaults        0 0
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0
&lt;span&gt;/dev/sdb1               /data/                  ext4    defaults        0 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#第一列设备的名称         #第二列 挂载点（目录）     #3，文件系统类型   #4，defaults 是默认挂载参数   &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#第一个 0 是指是否进行备份 0（不进行） 第二个 0 是指是否开机磁盘检查 0 （不检查）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法三：通过chkconfig 实现开机自动启动。&lt;/p&gt;
&lt;p&gt;这个方法我也不太建议，毕竟chkconfig还是用来启用系统服务比较好，挂载的事情还是交给 fstab 的好。&lt;/p&gt;
&lt;p&gt;下面的链接就是我写的如何实现chkconfig的开机自启动~~链接，有兴趣的可以看下。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/xuenil/p/9470812.html&lt;/p&gt;
&lt;p&gt;至于fdisk  与  parted 的区别，咱们明天再讲~~~~~。&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 07:51:00 +0000</pubDate>
<dc:creator>三天两觉</dc:creator>
<og:description>首先，咱们需要模拟一下环境，下图 使用VMware为我添加一块300G（实际200M~~手动滑稽 -_-）的硬盘设备。 按照步骤一步一步添加就好。添加完成后需要重启你的虚拟机，方能生效。 OK，那么咱</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuenil/p/9481896.html</dc:identifier>
</item>
<item>
<title>小程序(一) base64 文字编码解码以及图片编码 - 时光不老，我们不散</title>
<link>http://www.cnblogs.com/songmeiling/p/9461682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songmeiling/p/9461682.html</guid>
<description>&lt;p&gt;一、文字编码以及解码&lt;/p&gt;
&lt;p&gt;　　1、小程序util.js公共js中封装的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  *  base64编码(编码，配合encodeURIComponent使用)
  *  @parm : str 传入的字符串
  *  使用：
        1、引入util.js(路径更改) :const util  = require('../../utils/util.js');
        2、util.base64_encode(util.utf16to8('base64 编码'));
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; base64_encode(str) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面是64个基本的编码&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; base64EncodeChars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; out, i, len;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; c1, c2, c3;
  len &lt;/span&gt;=&lt;span&gt; str.length;
  i &lt;/span&gt;= 0&lt;span&gt;;
  out &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; len) {
    c1 &lt;/span&gt;= str.charCodeAt(i++) &amp;amp; 0xff&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; len) {
      out &lt;/span&gt;+= base64EncodeChars.charAt(c1 &amp;gt;&amp;gt; 2&lt;span&gt;);
      out &lt;/span&gt;+= base64EncodeChars.charAt((c1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4&lt;span&gt;);
      out &lt;/span&gt;+= &quot;==&quot;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    c2 &lt;/span&gt;= str.charCodeAt(i++&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i ==&lt;span&gt; len) {
      out &lt;/span&gt;+= base64EncodeChars.charAt(c1 &amp;gt;&amp;gt; 2&lt;span&gt;);
      out &lt;/span&gt;+= base64EncodeChars.charAt(((c1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4) | ((c2 &amp;amp; 0xF0) &amp;gt;&amp;gt; 4&lt;span&gt;));
      out &lt;/span&gt;+= base64EncodeChars.charAt((c2 &amp;amp; 0xF) &amp;lt;&amp;lt; 2&lt;span&gt;);
      out &lt;/span&gt;+= &quot;=&quot;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    c3 &lt;/span&gt;= str.charCodeAt(i++&lt;span&gt;);
    out &lt;/span&gt;+= base64EncodeChars.charAt(c1 &amp;gt;&amp;gt; 2&lt;span&gt;);
    out &lt;/span&gt;+= base64EncodeChars.charAt(((c1 &amp;amp; 0x3) &amp;lt;&amp;lt; 4) | ((c2 &amp;amp; 0xF0) &amp;gt;&amp;gt; 4&lt;span&gt;));
    out &lt;/span&gt;+= base64EncodeChars.charAt(((c2 &amp;amp; 0xF) &amp;lt;&amp;lt; 2) | ((c3 &amp;amp; 0xC0) &amp;gt;&amp;gt; 6&lt;span&gt;));
    out &lt;/span&gt;+= base64EncodeChars.charAt(c3 &amp;amp; 0x3F&lt;span&gt;);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; out;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  *  base64编码(编码，配合encodeURIComponent使用)
  *  @parm : str 传入的字符串
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; utf16to8(str) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; out, i, len, c;
  out &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
  len &lt;/span&gt;=&lt;span&gt; str.length;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; len; i++&lt;span&gt;) {
    c &lt;/span&gt;=&lt;span&gt; str.charCodeAt(i);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((c &amp;gt;= 0x0001) &amp;amp;&amp;amp; (c &amp;lt;= 0x007F&lt;span&gt;)) {
      out &lt;/span&gt;+=&lt;span&gt; str.charAt(i);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (c &amp;gt; 0x07FF&lt;span&gt;) {
      out &lt;/span&gt;+= String.fromCharCode(0xE0 | ((c &amp;gt;&amp;gt; 12) &amp;amp; 0x0F&lt;span&gt;));
      out &lt;/span&gt;+= String.fromCharCode(0x80 | ((c &amp;gt;&amp;gt; 6) &amp;amp; 0x3F&lt;span&gt;));
      out &lt;/span&gt;+= String.fromCharCode(0x80 | ((c &amp;gt;&amp;gt; 0) &amp;amp; 0x3F&lt;span&gt;));
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      out &lt;/span&gt;+= String.fromCharCode(0xC0 | ((c &amp;gt;&amp;gt; 6) &amp;amp; 0x1F&lt;span&gt;));
      out &lt;/span&gt;+= String.fromCharCode(0x80 | ((c &amp;gt;&amp;gt; 0) &amp;amp; 0x3F&lt;span&gt;));
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; out;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  *  base64解码(配合decodeURIComponent使用)
  *  @parm : input 传入的字符串
  *  使用：
        1、引入util.js(路径更改) :const util  = require('../../utils/util.js');
        2、util.base64_decode('YmFzZTY0IOe8lueggQ==');
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; base64_decode(input) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; base64EncodeChars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; output = &quot;&quot;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; chr1, chr2, chr3;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; enc1, enc2, enc3, enc4;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; i = 0&lt;span&gt;;
  input &lt;/span&gt;= input.replace(/[^A-Za-z0-9\+\/\=]/g, &quot;&quot;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; input.length) {
    enc1 &lt;/span&gt;= base64EncodeChars.indexOf(input.charAt(i++&lt;span&gt;));
    enc2 &lt;/span&gt;= base64EncodeChars.indexOf(input.charAt(i++&lt;span&gt;));
    enc3 &lt;/span&gt;= base64EncodeChars.indexOf(input.charAt(i++&lt;span&gt;));
    enc4 &lt;/span&gt;= base64EncodeChars.indexOf(input.charAt(i++&lt;span&gt;));
    chr1 &lt;/span&gt;= (enc1 &amp;lt;&amp;lt; 2) | (enc2 &amp;gt;&amp;gt; 4&lt;span&gt;);
    chr2 &lt;/span&gt;= ((enc2 &amp;amp; 15) &amp;lt;&amp;lt; 4) | (enc3 &amp;gt;&amp;gt; 2&lt;span&gt;);
    chr3 &lt;/span&gt;= ((enc3 &amp;amp; 3) &amp;lt;&amp;lt; 6) |&lt;span&gt; enc4;
    output &lt;/span&gt;= output +&lt;span&gt; String.fromCharCode(chr1);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (enc3 != 64&lt;span&gt;) {
      output &lt;/span&gt;= output +&lt;span&gt; String.fromCharCode(chr2);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (enc4 != 64&lt;span&gt;) {
      output &lt;/span&gt;= output +&lt;span&gt; String.fromCharCode(chr3);
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; utf8_decode(output);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  *  utf-8解码
  *  @parm : utftext 传入的字符串
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; utf8_decode(utftext) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; string = ''&lt;span&gt;;
  let i &lt;/span&gt;= 0&lt;span&gt;;
  let c &lt;/span&gt;= 0&lt;span&gt;;
  let c1 &lt;/span&gt;= 0&lt;span&gt;;
  let c2 &lt;/span&gt;= 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; utftext.length) {
    c &lt;/span&gt;=&lt;span&gt; utftext.charCodeAt(i);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c &amp;lt; 128&lt;span&gt;) {
      string &lt;/span&gt;+=&lt;span&gt; String.fromCharCode(c);
      i&lt;/span&gt;++&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((c &amp;gt; 191) &amp;amp;&amp;amp; (c &amp;lt; 224&lt;span&gt;)) {
      c1 &lt;/span&gt;= utftext.charCodeAt(i + 1&lt;span&gt;);
      string &lt;/span&gt;+= String.fromCharCode(((c &amp;amp; 31) &amp;lt;&amp;lt; 6) | (c1 &amp;amp; 63&lt;span&gt;));
      i &lt;/span&gt;+= 2&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      c1 &lt;/span&gt;= utftext.charCodeAt(i + 1&lt;span&gt;);
      c2 &lt;/span&gt;= utftext.charCodeAt(i + 2&lt;span&gt;);
      string &lt;/span&gt;+= String.fromCharCode(((c &amp;amp; 15) &amp;lt;&amp;lt; 12) | ((c1 &amp;amp; 63) &amp;lt;&amp;lt; 6) | (c2 &amp;amp; 63&lt;span&gt;));
      i &lt;/span&gt;+= 3&lt;span&gt;;
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; string;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * base64编码函数封装
    * @parm: str(传入要编成base64的内容)
    * 使用：
        1、引入util.js(路径更改) :const util  = require('../../utils/util.js');
        2、util.baseEncode('base64 编码');
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; baseEncode(str) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; base64_encode(utf16to8(str));
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * base64解码函数封装
    * @parm: str(传入要解为正常字体)
    * 使用：
        1、引入util.js(路径更改) :const util  = require('../../utils/util.js');
        2、util.baseDecode(util.baseEncode('base64 编码'))
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; baseDecode(str) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; base64_decode(str);
}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抛出函数使用&lt;/span&gt;
module.exports =&lt;span&gt; {
  baseEncode: baseEncode,
  baseDecode: baseDecode
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、页面中的用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;//../../相对路径&lt;/p&gt;
&lt;p&gt;const util = require('../../utils/util.js');&lt;/p&gt;
&lt;p&gt;//编码：&lt;/p&gt;
&lt;p&gt;util.baseEncode('base64 编码');&lt;/p&gt;
&lt;p&gt;//解码：&lt;/p&gt;
&lt;p&gt;util.baseDecode(util.baseEncode('base64 编码'));&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;二、图片转为base64编码：（以上传logo为例）&lt;/p&gt;
&lt;p&gt; 　　1、html元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
           &amp;lt;!-- 上传logo start --&amp;gt;
            &amp;lt;view class='card_scanning_list_logo'&amp;gt;
              &amp;lt;view class='card_scanning_list_logo_tit'&amp;gt;添加LOGO&amp;lt;/view&amp;gt;
              &amp;lt;view class='card_scanning_list_logo_box'&amp;gt;
                &amp;lt;view class='card_scanning_logo'&amp;gt;
                  &amp;lt;canvas  canvas-id='myCanvas' style=&quot;width:60px; height:60px;&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
                &amp;lt;/view&amp;gt;
                &amp;lt;view class='card_scanning_logo_add' bindtap='addLogo'&amp;gt;
                  &amp;lt;i class=&quot;icon iconfont icon-jia&quot;&amp;gt;&amp;lt;/i&amp;gt;
                &amp;lt;/view&amp;gt;
              &amp;lt;/view&amp;gt;
            &amp;lt;/view&amp;gt;
            &amp;lt;!-- 上传logo end --&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2、css样式&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.card_scanning_list_logo_tit&lt;/span&gt;{&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt;0 50rpx&lt;/span&gt;;
}&lt;span&gt;
.card_scanning_list_logo_box&lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; auto&lt;/span&gt;;
}&lt;span&gt;
.card_scanning_logo&lt;/span&gt;{&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt;2px&lt;/span&gt;;&lt;span&gt;
  border&lt;/span&gt;:&lt;span&gt;1px solid #e8e5e5&lt;/span&gt;;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; display: inline-block; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt;60px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt;60px&lt;/span&gt;;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;
}&lt;span&gt;
.card_scanning_logo image&lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;
}&lt;span&gt;
.card_scanning_logo_add&lt;/span&gt;{
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; display: inline-block; &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt;118rpx&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt;100rpx&lt;/span&gt;;&lt;span&gt;
  text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt; 100rpx&lt;/span&gt;;&lt;span&gt;
  border&lt;/span&gt;:&lt;span&gt;1px solid transparent&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt;4rpx&lt;/span&gt;;
}&lt;span&gt;
.card_scanning_logo_add i&lt;/span&gt;{&lt;span&gt;
  font-size&lt;/span&gt;:&lt;span&gt;80rpx&lt;/span&gt;;&lt;span&gt;
  color&lt;/span&gt;:&lt;span&gt; #696666&lt;/span&gt;;
}&lt;span&gt;
.card_scanning_list_logo&lt;/span&gt;{&lt;span&gt;
  overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
}&lt;span&gt;
.card_scanning_list_logo_box&lt;/span&gt;{&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt;20rpx 50rpx 0&lt;/span&gt;;
}&lt;span&gt;
.card_editor_tit_box&lt;/span&gt;{&lt;span&gt;
  text-align&lt;/span&gt;:&lt;span&gt;center&lt;/span&gt;;&lt;span&gt;
  line-height&lt;/span&gt;:&lt;span&gt;40rpx&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt;20rpx 40rpx&lt;/span&gt;;
}&lt;span&gt;
.card_editor_tit_box&lt;/span&gt;{&lt;span&gt;
 line-height&lt;/span&gt;:&lt;span&gt;2.3&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、上传js，以及接口的调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加logo&lt;/span&gt;
  addLogo:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; that = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　//为canvas 的id
    const ctx &lt;/span&gt;= wx.createCanvasContext('myCanvas'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(ctx);&lt;/span&gt;
    const platform =&lt;span&gt; wx.getSystemInfoSync().platform;
    const imgWidth &lt;/span&gt;= 60, imgHeight = 60&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; base64Img = &quot;&quot;&lt;span&gt;;
    wx.chooseImage({
      count: &lt;/span&gt;1, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认9&lt;/span&gt;
      sizeType: ['original', 'compressed'], &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以指定是原图还是压缩图，默认二者都有&lt;/span&gt;
      sourceType: ['album', 'camera'], &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以指定来源是相册还是相机，默认二者都有&lt;/span&gt;
      success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (res) {
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成的图片临时路径画成canvas&lt;/span&gt;
        ctx.drawImage(res.tempFilePaths[0], 0, 0&lt;span&gt;, imgWidth, imgHeight);
        ctx.draw(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, () =&amp;gt;&lt;span&gt; {
          wx.canvasGetImageData({
            canvasId: &lt;/span&gt;'myCanvas'&lt;span&gt;,
            x: &lt;/span&gt;0&lt;span&gt;,
            y: &lt;/span&gt;0&lt;span&gt;,
            width: imgWidth,
            height: imgHeight,
            success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(res);&lt;/span&gt;
              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; png编码&lt;/span&gt;
              let pngData =&lt;span&gt; upng.encode([res.data.buffer], res.width, res.height)
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; base64编码&lt;/span&gt;
              let base64_img =&lt;span&gt; wx.arrayBufferToBase64(pngData)
              &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; base64_image = 'data:image/jpeg;base64,' +&lt;span&gt; base64_img;
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log(base64_image);&lt;/span&gt;
&lt;span&gt;              wx.request({
                url: &lt;/span&gt;&quot;https://mp.cn/index.php/SmallProgram/Index/base64_upload&quot;&lt;span&gt;,  //此处并非真实接口地址
                method: &lt;/span&gt;'POST'&lt;span&gt;,
                data: {
                  &lt;/span&gt;&quot;img_base64&quot;&lt;span&gt;: base64_image
                },
                header: {
                  &lt;/span&gt;&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;&lt;span&gt;
                },
                success: res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                  console.log(res);
                  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( res.data.code == 1&lt;span&gt;){
                    wx.showModal({
                      title: &lt;/span&gt;''&lt;span&gt;,
                      content: &lt;/span&gt;'上传成功'&lt;span&gt;,
                      showCancel: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                    })
                  }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    wx.showModal({
                      title: &lt;/span&gt;''&lt;span&gt;,
                      content: &lt;/span&gt;'上传失败，请重新上传'&lt;span&gt;,
                      showCancel: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                    })
                  }
                  
                }
              })
            },
            fail(res) {
              console.log(res)
            },
          })
        })
      }
    })
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、效果图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211223/201808/1211223-20180815154953675-1105056108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 15 Aug 2018 07:50:00 +0000</pubDate>
<dc:creator>时光不老，我们不散</dc:creator>
<og:description>一、文字编码以及解码 1、小程序util.js公共js中封装的方法 2、页面中的用法： //../../相对路径 const util = require('../../utils/util.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songmeiling/p/9461682.html</dc:identifier>
</item>
<item>
<title>Java并发编程笔记之ConcurrentHashMap原理探究 - 狂小白</title>
<link>http://www.cnblogs.com/huangjuncong/p/9478505.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/9478505.html</guid>
<description>&lt;p&gt;在多线程环境下，使用&lt;code&gt;HashMap&lt;/code&gt;进行&lt;code&gt;put&lt;/code&gt;操作时存在丢失数据的情况，为了避免这种bug的隐患，强烈建议使用&lt;code&gt;ConcurrentHashMap&lt;/code&gt;代替&lt;code&gt;HashMap。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;HashTable是一个线程安全的类，它使用synchronized来锁住整张Hash表来实现线程安全，即每次锁住整张表让线程独占，相当于所有线程进行读写时都去竞争一把锁，导致效率非常低下。ConcurrentHashMap可以做到读取数据不加锁，并且其内部的结构可以让其在进行写操作的时候能够将锁的粒度保持地尽量地小，允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的Hashtable，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CouncurrentHashMap实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap 为了提高本身的并发能力，在内部采用了一个叫做 Segment 的结构，一个 Segment 其实就是一个类 Hash Table 的结构，Segment 内部维护了一个链表数组，我们用下面这一幅图来看下 ConcurrentHashMap 的内部结构,从下面的结构我们可以了解到，ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部，因此，这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长，但是带来的好处是写操作的时候可以只对元素所在的 Segment 进行操作即可，不会影响到其他的 Segment，这样，在最理想的情况下，ConcurrentHashMap 可以最高同时支持 Segment 数量大小的写操作（刚好这些写操作都非常平均地分布在所有的 Segment上），所以，通过这一种结构，ConcurrentHashMap 的并发能力可以大大的提高。我们用下面这一幅图来看下ConcurrentHashMap的内部结构详情图，如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201808/1202638-20180814213921035-778397290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不难看出，ConcurrentHashMap采用了二次hash的方式，第一次hash将key映射到对应的segment，而第二次hash则是映射到segment的不同桶(bucket)中。&lt;/p&gt;
&lt;p&gt;为什么要用二次hash，主要原因是为了构造分离锁，使得对于map的修改不会锁住整个容器，提高并发能力。当然，没有一种东西是绝对完美的，二次hash带来的问题是整个hash的过程比hashmap单次hash要长，所以，如果不是并发情形，不要使用concurrentHashmap。&lt;/p&gt;
&lt;p&gt;JAVA7之前ConcurrentHashMap主要采用锁机制，在对某个Segment进行操作时，将该Segment锁定，不允许对其进行非查询操作，而在JAVA8之后采用CAS无锁算法，这种乐观操作在完成前进行判断，如果符合预期结果才给予执行，对并发操作提供良好的优化.&lt;/p&gt;
&lt;p&gt;让我们先看JDK1.7的ConcurrentHashMap的原理分析&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;JDK1.7的ConcurrentHashMap&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;如上所示，是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。&lt;/p&gt;
&lt;p&gt;让我们看看Segment里面的成员变量，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;class&lt;/span&gt; Segment&amp;lt;K,V&amp;gt;&lt;span&gt; extends ReentrantLock implements Serializable {
    transient &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Segment中元素的数量&lt;/span&gt;
    transient &lt;span&gt;int&lt;/span&gt; modCount;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对table的大小造成影响的操作的数量(比如put或者remove操作)&lt;/span&gt;
    transient &lt;span&gt;int&lt;/span&gt; threshold;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;阈值,Segment里面元素的数量超过这个值那么就会对Segment进行扩容&lt;/span&gt;
    final &lt;span&gt;float&lt;/span&gt; loadFactor;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;负载因子,用于确定threshold&lt;/span&gt;
    transient &lt;span&gt;volatile&lt;/span&gt; HashEntry&amp;lt;K,V&amp;gt;[] table;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表数组,数组中的每一个元素代表了一个链表的头部&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着再看看HashEntry中的组成，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 　&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * ConcurrentHashMap列表Entry。注意，这不会作为用户可见的Map.Entry导出。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;class&lt;/span&gt; HashEntry&amp;lt;K,V&amp;gt;&lt;span&gt; {
        final &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
        final K key;
        &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; V value;
        &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt; HashEntry&amp;lt;K,V&amp;gt;&lt;span&gt; next;

        HashEntry(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, HashEntry&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hash =&lt;span&gt; hash;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 设置具有volatile写语义的next字段。&lt;/span&gt;&lt;span&gt;
        final &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; setNext(HashEntry&amp;lt;K,V&amp;gt;&lt;span&gt; n) {
            UNSAFE.putOrderedObject(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, nextOffset, n);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Unsafe mechanics&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt;&lt;span&gt; final sun.misc.Unsafe UNSAFE;&lt;br/&gt;　　　　　//下一个HashEntry的偏移量
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nextOffset;
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                UNSAFE &lt;/span&gt;=&lt;span&gt; sun.misc.Unsafe.getUnsafe();
                Class k &lt;/span&gt;= HashEntry.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;　　　　　　　　　　//获取HashEntry next在内存中的偏移量
                nextOffset &lt;/span&gt;=&lt;span&gt; UNSAFE.objectFieldOffset
                    (k.getDeclaredField(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(e);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和 HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。&lt;/p&gt;
&lt;p&gt;原理上来说：ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock。不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理，理论上 ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。&lt;/p&gt;
&lt;p&gt;接着让我们继续看看JDK1.7中ConcurrentHashMap的成员变量和构造函数，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认初始容量&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = &lt;span&gt;16&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认加载因子&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = &lt;span&gt;0.75f&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认segment层级&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; DEFAULT_CONCURRENCY_LEVEL = &lt;span&gt;16&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最大容量&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; MAXIMUM_CAPACITY = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; segment最小容量&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; MIN_SEGMENT_TABLE_CAPACITY = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个segment最大容量&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; MAX_SEGMENTS = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;16&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁之前重试次数&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; RETRIES_BEFORE_LOCK = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConcurrentHashMap() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConcurrentHashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConcurrentHashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConcurrentHashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity,
                             &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; loadFactor, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; concurrencyLevel) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(loadFactor &amp;gt; &lt;span&gt;0&lt;/span&gt;) || initialCapacity &amp;lt; &lt;span&gt;0&lt;/span&gt; || concurrencyLevel &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (concurrencyLevel &amp;gt;&lt;span&gt; MAX_SEGMENTS)
            concurrencyLevel &lt;/span&gt;=&lt;span&gt; MAX_SEGMENTS;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到两种大小的最匹配参数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; sshift = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; segment数组的长度是由concurrentLevel计算来的，segment数组的长度是2的N次方，
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认concurrencyLevel = 16, 所以ssize在默认情况下也是16,此时 sshift = 4
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sshift相当于ssize从1向左移的次数&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; ssize = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (ssize &amp;lt;&lt;span&gt; concurrencyLevel) {
            &lt;/span&gt;++&lt;span&gt;sshift; 
            ssize &lt;/span&gt;&amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 段偏移量，默认值情况下此时segmentShift = 28&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.segmentShift = &lt;span&gt;32&lt;/span&gt; -&lt;span&gt; sshift;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 散列算法的掩码，默认值情况下segmentMask = 15&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.segmentMask = ssize - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;gt;&lt;span&gt; MAXIMUM_CAPACITY)
            initialCapacity &lt;/span&gt;=&lt;span&gt; MAXIMUM_CAPACITY;

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c = initialCapacity /&lt;span&gt; ssize;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c * ssize &amp;lt;&lt;span&gt; initialCapacity)
            &lt;/span&gt;++&lt;span&gt;c;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cap =&lt;span&gt; MIN_SEGMENT_TABLE_CAPACITY;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (cap &amp;lt;&lt;span&gt; c)
            cap &lt;/span&gt;&amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; create segments and segments[0]&lt;/span&gt;
        Segment&amp;lt;K,V&amp;gt; s0 =
            &lt;span&gt;new&lt;/span&gt; Segment&amp;lt;K,V&amp;gt;(loadFactor, (&lt;span&gt;int&lt;/span&gt;)(cap *&lt;span&gt; loadFactor),
                             (HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashEntry[cap]);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建ssize长度的Segment数组&lt;/span&gt;
        Segment&amp;lt;K,V&amp;gt;[] ss = (Segment&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Segment[ssize];
        UNSAFE.putOrderedObject(ss, SBASE, s0); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ordered write of segments[0]&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.segments =&lt;span&gt; ss;
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，concurrencyLevel 一经指定，不可改变，后续如果ConcurrentHashMap的元素数量增加导致ConrruentHashMap需要扩容，ConcurrentHashMap不会增加Segment的数量，而只会增加Segment中链表数组的容量大小，这样的好处是扩容过程不需要对整个ConcurrentHashMap做rehash，而只需要对Segment里面的元素做一次rehash就可以了。&lt;/p&gt;
&lt;p&gt;　　整个ConcurrentHashMap的初始化方法还是非常简单的，先是根据concurrencyLevel来new出Segment，这里Segment的数量是不大于concurrencyLevel的最大的2的指数，就是说Segment的数量永远是2的指数个，这样的好处是方便采用移位操作来进行hash，加快hash的过程。接下来就是根据intialCapacity确定Segment的容量的大小，每一个Segment的容量大小也是2的指数，同样使为了加快hash的过程。&lt;/p&gt;
&lt;p&gt;注意一下两个变量segmentShift和segmentMask，这两个变量在后面将会起到很大的作用，假设构造函数确定了Segment的数量是2的n次方，那么segmentShift就等于32减去n，而segmentMask就等于2的n次方减一。&lt;/p&gt;
&lt;p&gt;接下来让我们看看JDK1.7中的ConcurrentHashMap的核心方法 put 方法和get 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        Segment&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; s;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();&lt;br/&gt;　　　　　//(1)
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);&lt;br/&gt;　　　　　//(2)
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = (hash &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp;&lt;span&gt; segmentMask;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObject          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; nonvolatile; recheck&lt;/span&gt;
             (segments, (j &amp;lt;&amp;lt; SSHIFT) + SBASE)) == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  in ensureSegment&lt;/span&gt;
            s =&lt;span&gt; ensureSegment(j);&lt;br/&gt;　　　　　//(3)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s.put(key, hash, value, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码（1）计算key的hash值&lt;/p&gt;
&lt;p&gt;代码（2）根据hash值，segmentShift，segmentMask定位到哪个Segment。&lt;/p&gt;
&lt;p&gt;代码（3）将键值对保存到对应的segment中。&lt;/p&gt;
&lt;p&gt;可以看到首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put。 Segment 中进行具体的 put的源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
　　final V put(K key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, V value, boolean onlyIfAbsent) {&lt;br/&gt;　　　　　　　//(1)
            HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt; node = tryLock() ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; :
                scanAndLockForPut(key, hash, value);
            V oldValue;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　　　 //（2）
                HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab =&lt;span&gt; table;&lt;br/&gt;　　　　　　　　　 //（3）
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = (tab.length - &lt;span&gt;1&lt;/span&gt;) &amp;amp;&lt;span&gt; hash;&lt;br/&gt;　　　　　　　　　 //(4)
                HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt; first =&lt;span&gt; entryAt(tab, index);&lt;br/&gt;　　　　　　　　　 //(5)
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (HashEntry&amp;lt;K,V&amp;gt; e =&lt;span&gt; first;;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        K k;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((k = e.key) == key ||&lt;span&gt;
                            (e.hash &lt;/span&gt;== hash &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))) {
                            oldValue &lt;/span&gt;=&lt;span&gt; e.value;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;onlyIfAbsent) {
                                e.value &lt;/span&gt;=&lt;span&gt; value;
                                &lt;/span&gt;++&lt;span&gt;modCount;
                            }
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                        e &lt;/span&gt;=&lt;span&gt; e.next;
                    }&lt;br/&gt;　　　　　　　　　　　　//(6)
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　　　　　　　　
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;　　　　　　　　　　　　　　　　 //(7)
                            node.setNext(first);
                        &lt;/span&gt;&lt;span&gt;else  //(8)&lt;/span&gt;&lt;span&gt;
                            node &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashEntry&amp;lt;K,V&amp;gt;&lt;span&gt;(hash, key, value, first);
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c = count + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;　　　　　　　　　　　　　　//(9)
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c &amp;gt; threshold &amp;amp;&amp;amp; tab.length &amp;lt;&lt;span&gt; MAXIMUM_CAPACITY)
                            rehash(node);
                        &lt;/span&gt;&lt;span&gt;else   //(10)&lt;/span&gt;&lt;span&gt;
                            setEntryAt(tab, index, node);
                        &lt;/span&gt;++&lt;span&gt;modCount;
                        count &lt;/span&gt;=&lt;span&gt; c;
                        oldValue &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　　　//（11）
                unlock();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。&lt;/p&gt;
&lt;p&gt;代码（1）首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 &lt;code&gt;scanAndLockForPut()&lt;/code&gt; 自旋获取锁。&lt;/p&gt;
&lt;p&gt;代码（2）每一个Segment对应一个HashEntry[ ]数组。&lt;/p&gt;
&lt;p&gt;代码（3）&lt;/p&gt;








&lt;p&gt;总的来说，put 的流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。&lt;/li&gt;
&lt;li&gt;遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。&lt;/li&gt;
&lt;li&gt;不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。&lt;/li&gt;
&lt;li&gt;最后会解除在 代码（1） 中所获取当前 Segment 的锁。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接着让我们看看其扩容，rehash源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
     　　&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 两倍于之前的容量
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        @SuppressWarnings(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unchecked&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rehash(HashEntry&amp;lt;K,V&amp;gt;&lt;span&gt; node) {

            HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt;[] oldTable =&lt;span&gt; table;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; oldTable.length;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扩大1倍（左移一位）&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; newCapacity = oldCapacity &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算新的阈值&lt;/span&gt;
            threshold = (&lt;span&gt;int&lt;/span&gt;)(newCapacity *&lt;span&gt; loadFactor);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建新的数组&lt;/span&gt;
            HashEntry&amp;lt;K,V&amp;gt;[] newTable =&lt;span&gt;
                (HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt;[]) &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashEntry[newCapacity];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mask&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; sizeMask = newCapacity - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历旧数组数据&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; oldCapacity ; i++&lt;span&gt;) {
                HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt; e = oldTable[i]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对应一个链表的表头结点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt; next =&lt;span&gt; e.next;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算e对应的这条链表在新数组中对应的下标&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; idx = e.hash &amp;amp;&lt;span&gt; sizeMask; 
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  只有一个结点时直接放入（新的）数组中&lt;/span&gt;
                        newTable[idx] =&lt;span&gt; e;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表有多个结点时：&lt;/span&gt;
                        HashEntry&amp;lt;K,V&amp;gt; lastRun = e; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 就链表的表头结点做为新链表的尾结点&lt;/span&gt;
                        &lt;span&gt;int&lt;/span&gt; lastIdx =&lt;span&gt; idx;
                        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (HashEntry&amp;lt;K,V&amp;gt; last =&lt;span&gt; next;
                             last &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                             last &lt;/span&gt;=&lt;span&gt; last.next) {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 旧数组中一个链表中的数据并不一定在新数组中属于同一个链表，所以这里需要每次都重新计算&lt;/span&gt;
                            &lt;span&gt;int&lt;/span&gt; k = last.hash &amp;amp;&lt;span&gt; sizeMask;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k !=&lt;span&gt; lastIdx) {
                                lastIdx &lt;/span&gt;=&lt;span&gt; k;
                                lastRun &lt;/span&gt;=&lt;span&gt; last;
                            }
                        }
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; lastRun（和之后的元素）插入数组中。&lt;/span&gt;
                        newTable[lastIdx] =&lt;span&gt; lastRun;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从（旧链表）头结点向后遍历，遍历到最后一组不同于前面hash值的组头。&lt;/span&gt;
                        &lt;span&gt;for&lt;/span&gt; (HashEntry&amp;lt;K,V&amp;gt; p = e; p != lastRun; p =&lt;span&gt; p.next) {
                            V v &lt;/span&gt;=&lt;span&gt; p.value;
                            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; p.hash;
                            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = h &amp;amp;&lt;span&gt; sizeMask;
                            HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt; n =&lt;span&gt; newTable[k];
                            newTable[k] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashEntry&amp;lt;K,V&amp;gt;(h, p.key, v, n); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拼接链表&lt;/span&gt;
&lt;span&gt;                        }
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将之前的旧数据都添加到新的结构中之后，才会插入新的结点（依旧是插入表头）&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; nodeIndex = node.hash &amp;amp; sizeMask; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; add the new node&lt;/span&gt;
&lt;span&gt;            node.setNext(newTable[nodeIndex]);
            newTable[nodeIndex] &lt;/span&gt;=&lt;span&gt; node;
            table &lt;/span&gt;=&lt;span&gt; newTable;
    　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着，再看看&lt;code&gt;scanAndLockForPut()&lt;/code&gt; 自旋获取锁，源码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; HashEntry&amp;lt;K,V&amp;gt; scanAndLockForPut(K key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, V value) {
            HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt; first = entryForHash(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, hash);
            HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt; e =&lt;span&gt; first;
            HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt; node = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; retries = -&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定位节点时为负数&lt;br/&gt;&lt;/span&gt;　　　　　　　//(1)
            &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;tryLock()) {
                HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt; f; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先在下面重新检查&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (retries &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 推测性地创建节点&lt;/span&gt;
                            node = &lt;span&gt;new&lt;/span&gt; HashEntry&amp;lt;K,V&amp;gt;(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        retries &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (key.equals(e.key))
                        retries &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        e &lt;/span&gt;=&lt;span&gt; e.next;
                }&lt;br/&gt;　　　　　　　　　　//(2)
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (++retries &amp;gt;&lt;span&gt; MAX_SCAN_RETRIES) {
                    &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((retries &amp;amp; &lt;span&gt;1&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                         (f &lt;/span&gt;= entryForHash(&lt;span&gt;this&lt;/span&gt;, hash)) !=&lt;span&gt; first) {
                    e &lt;/span&gt;= first = f; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果Entry改变则重新遍历&lt;/span&gt;
                    retries = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扫描包含给定key的节点，同时尝试获取锁，如果没有找到，则创建并返回一个。&lt;/p&gt;
&lt;p&gt;返回时，保证锁被持有。&lt;/p&gt;
&lt;p&gt;与大多数方法不同，对方法equals的调用不进行筛选:由于遍历速度无关紧要，我们还可以帮助预热相关代码和访问。&lt;/p&gt;
&lt;p&gt;代码（1）尝试自旋获取锁。&lt;/p&gt;
&lt;p&gt;代码（2）如果重试的次数达到了 &lt;code&gt;MAX_SCAN_RETRIES&lt;/code&gt; 则改为阻塞锁获取，保证能获取成功。&lt;/p&gt;

&lt;p&gt;接下来，再让我们看看JDK1.7中的get方法，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(Object key) {
        Segment&lt;/span&gt;&amp;lt;K,V&amp;gt; s; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; manually integrate access methods to reduce overhead&lt;/span&gt;
        HashEntry&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; hash(key);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先计算出segment数组的下标  （(h &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask)）&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; u = (((h &amp;gt;&amp;gt;&amp;gt; segmentShift) &amp;amp; segmentMask) &amp;lt;&amp;lt; SSHIFT) +&lt;span&gt; SBASE;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((s = (Segment&amp;lt;K,V&amp;gt;)UNSAFE.getObjectVolatile(segments, u)) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
            (tab &lt;/span&gt;= s.table) != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据下标找到segment
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后(tab.length - 1) &amp;amp; h) 得到对应HashEntry数组的下标
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历链表&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (HashEntry&amp;lt;K,V&amp;gt; e = (HashEntry&amp;lt;K,V&amp;gt;&lt;span&gt;) UNSAFE.getObjectVolatile
                     (tab, ((&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;)(((tab.length - &lt;span&gt;1&lt;/span&gt;) &amp;amp; h)) &amp;lt;&amp;lt; TSHIFT) +&lt;span&gt; TBASE);
                 e &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;; e =&lt;span&gt; e.next) {
                K k;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((k = e.key) == key || (e.hash == h &amp;amp;&amp;amp;&lt;span&gt; key.equals(k)))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.value;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到get 逻辑没有前面的方法复杂：&lt;/p&gt;
&lt;p&gt;只需要将 Key 通过 Hash 之后定位到具体的 Segment ，再通过一次 Hash 定位到具体的元素上。&lt;/p&gt;
&lt;p&gt;由于 HashEntry 中的 value 属性是用 volatile 关键词修饰的，保证了内存可见性，所以每次获取时都是最新值。&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap 的 get 方法是非常高效的，&lt;strong&gt;因为整个过程都不需要加锁&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;接着再看看remove方法，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V remove(Object key) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算hash值&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据hash值找到对应的segment&lt;/span&gt;
        Segment&amp;lt;K,V&amp;gt; s =&lt;span&gt; segmentForHash(hash);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用Segment.remove 函数&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; s == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : s.remove(key, hash, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean remove(Object key, Object value) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; hash(key);
        Segment&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; s;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (s = segmentForHash(hash)) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
            s.remove(key, hash, value) &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Segment.remove函数的源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
 　　　　&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * Remove; match on key only if value null, else match both.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        final V remove(Object key, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, Object value) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;tryLock())
                scanAndLock(key, hash);
            V oldValue &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab =&lt;span&gt; table;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算HashEntry数组下标&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; index = (tab.length - &lt;span&gt;1&lt;/span&gt;) &amp;amp;&lt;span&gt; hash;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到头结点&lt;/span&gt;
                HashEntry&amp;lt;K,V&amp;gt; e =&lt;span&gt; entryAt(tab, index);
                HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt; pred = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    K k;
                    HashEntry&lt;/span&gt;&amp;lt;K,V&amp;gt; next =&lt;span&gt; e.next;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((k = e.key) == key ||&lt;span&gt;
                        (e.hash &lt;/span&gt;== hash &amp;amp;&amp;amp; key.equals(k))) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到对应节点&lt;/span&gt;
                        V v =&lt;span&gt; e.value;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt; || value == v ||&lt;span&gt; value.equals(v)) {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当pred为空时，表示要移除的是链表的表头节点，重新设置链表&lt;/span&gt;
&lt;span&gt;                                setEntryAt(tab, index, next);
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                pred.setNext(next);
                            &lt;/span&gt;++&lt;span&gt;modCount;
                            &lt;/span&gt;--&lt;span&gt;count;
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录旧value值&lt;/span&gt;
                            oldValue =&lt;span&gt; v;
                        }
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    pred &lt;/span&gt;=&lt;span&gt; e;
                    e &lt;/span&gt;=&lt;span&gt; next;
                }
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                unlock();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;JDK1.8中的ConcurrentHashMap原理分析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1.7 已经解决了并发问题，并且能支持 N 个 Segment 这么多次数的并发，但依然存在 HashMap 在 1.7 版本中的问题。那么是什么问题呢？&lt;/p&gt;
&lt;p&gt;　　很明显那就是查询遍历链表效率太低。&lt;/p&gt;
&lt;p&gt;因此 1.8 做了一些数据结构上的调整。，在 JAVA8 中它摒弃了 Segment（锁段）的概念，而是启用了一种全新的方式实现，利用 CAS 算法。底层依然由“数组”+链表+红黑树的方式思想，但是为了做到并发，又增加了很多辅助的类，例如 TreeBin、Traverser等对象内部类。&lt;/p&gt;
&lt;p&gt;如何让多线程之间，对象的状态对于各线程的“可视性”是顺序一致的：ConcurrentHashMap 使用了 happens-before 规则来实现。 happens-before规则（摘取自 JAVA 并发编程）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序次序法则：线程中的每个动作A都 happens-before 于该线程中的每一个动作B，其中，在程序中，所有的动作B都能出现在A之后。&lt;/li&gt;
&lt;li&gt;监视器锁法则：对一个监视器锁的解锁 happens-before 于每一个后续对同一监视器锁的加锁。&lt;/li&gt;
&lt;li&gt;volatile 变量法则：对 volatile 域的写入操作 happens-before 于每一个后续对同一个域的读写操作。&lt;/li&gt;
&lt;li&gt;线程启动法则：在一个线程里，对 Thread.start 的调用会 happens-before 于每个启动线程的动作。&lt;/li&gt;
&lt;li&gt;线程终结法则：线程中的任何动作都 happens-before 于其他线程检测到这个线程已经终结、或者从 Thread.join 调用中成功返回，或 Thread.isAlive 返回 false。&lt;/li&gt;
&lt;li&gt;中断法则：一个线程调用另一个线程的 interrupt happens-before 于被中断的线程发现中断。&lt;/li&gt;
&lt;li&gt;终结法则：一个对象的构造函数的结束 happens-before 于这个对象 finalizer 的开始。&lt;/li&gt;
&lt;li&gt;传递性：如果 A happens-before 于 B，且 B happens-before 于 C，则 A happens-before于C：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        假设代码有两条语句，代码顺序是语句1先于语句2执行；那么只要语句之间不存在依赖关系，那么打乱它们的顺序对最终的结果没有影响的话，那么真正交给CPU去执行时，他们的执行顺序可以是先执行语句2然后语句1。&lt;/p&gt;
&lt;p&gt;首先来看下底层的组成结构（下图是百度来的，懒得画了）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201808/1202638-20180815140658667-1171328968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到JDK1.8ConcurrentHashMap 和JDK1.8的HashMap是很相似的。其中抛弃了原有的 Segment 分段锁，而采用了 &lt;code&gt;CAS + synchronized&lt;/code&gt; 来保证并发安全性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
//键值输入。 此类永远不会作为用户可变的Map.Entry导出（即，一个支持setValue;请参阅下面的MapEntry），&lt;br/&gt;//但可以用于批量任务中使用的只读遍历。 具有负哈希字段的节点的子类是特殊的，并且包含空键和值（但永远不会导出）。 否则，键和val永远不会为空。&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
        final &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
        final K key;
        &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt;&lt;span&gt; V val;
        &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt; next;

        Node(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V val, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hash =&lt;span&gt; hash;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.val =&lt;span&gt; val;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; final K getKey()       { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; key; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; final V getValue()     { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; val; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; hashCode()   { &lt;span&gt;return&lt;/span&gt; key.hashCode() ^&lt;span&gt; val.hashCode(); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; final String toString(){ &lt;span&gt;return&lt;/span&gt; key + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; val; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; final V setValue(V value) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; final boolean equals(Object o) {
            Object k, v, u; Map.Entry&lt;/span&gt;&amp;lt;?,?&amp;gt;&lt;span&gt; e;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((o instanceof Map.Entry) &amp;amp;&amp;amp;&lt;span&gt;
                    (k &lt;/span&gt;= (e = (Map.Entry&amp;lt;?,?&amp;gt;)o).getKey()) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                    (v &lt;/span&gt;= e.getValue()) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                    (k &lt;/span&gt;== key || k.equals(key)) &amp;amp;&amp;amp;&lt;span&gt;
                    (v &lt;/span&gt;== (u = val) ||&lt;span&gt; v.equals(u)));
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 对map.get（）的虚拟化支持; 在子类中重写。
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt; find(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h, Object k) {
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; e = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    K ek;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == h &amp;amp;&amp;amp;&lt;span&gt;
                        ((ek &lt;/span&gt;= e.key) == k || (ek != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; k.equals(ek))))
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也将 1.7 中存放数据的 HashEntry 改为 Node，但作用都是相同的。&lt;/p&gt;
&lt;p&gt;其中的 &lt;code&gt;val next&lt;/code&gt; 都用了 volatile 修饰，保证了可见性。&lt;/p&gt;
&lt;p&gt;接着再看看put方法的源码，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
 　　&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; putVal(key, value, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
 　　}

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;* Implementation for put and putIfAbsent &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    final V putVal(K key, V value, boolean onlyIfAbsent) {&lt;br/&gt;　　　　　//(1)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt; || value == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();&lt;br/&gt;　　　　　//(2)
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; spread(key.hashCode());
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; binCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;　　　　　//(3)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt;[] tab =&lt;span&gt; table;;) {
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt; f; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i, fh;&lt;br/&gt;　　　　　　　//(4)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                tab &lt;/span&gt;=&lt;span&gt; initTable();&lt;br/&gt;　　　　　　　//(5)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((f = tabAt(tab, i = (n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; hash)) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (casTabAt(tab, i, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                             &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)))
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no lock when adding to empty bin&lt;/span&gt;
&lt;span&gt;            }&lt;br/&gt;　　　　　　　//(6)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((fh = f.hash) ==&lt;span&gt; MOVED)
                tab &lt;/span&gt;=&lt;span&gt; helpTransfer(tab, f);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                V oldVal &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;　　　　　　　　　　//(7)
                synchronized (f) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tabAt(tab, i) ==&lt;span&gt; f) {&lt;br/&gt;　　　　　　　　　　　　　　//(8)
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fh &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                            binCount &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;　　　　　　　　　　　　　　　　　//(9)
                            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; e = f;; ++&lt;span&gt;binCount) {
                                K ek;&lt;br/&gt;　　　　　　　　　　　　　　　　　　　//（10）
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                                    ((ek &lt;/span&gt;= e.key) == key ||&lt;span&gt;
                                     (ek &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(ek)))) {
                                    oldVal &lt;/span&gt;=&lt;span&gt; e.val;
                                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;onlyIfAbsent)
                                        e.val &lt;/span&gt;=&lt;span&gt; value;
                                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                }
                                Node&lt;/span&gt;&amp;lt;K,V&amp;gt; pred =&lt;span&gt; e;&lt;br/&gt;　　　　　　　　　　　　　　　　　　　//(11)如果遍历到了最后一个结点，那么就证明新的节点需要插入 就把它插入在链表尾部
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = e.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                    pred.next &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;(hash, key,
                                                              value, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                                }
                            }
                        }&lt;br/&gt;　　　　　　　　　　　　　　//（12）
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (f instanceof TreeBin) {
                            Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; p;
                            binCount &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = ((TreeBin&amp;lt;K,V&amp;gt;&lt;span&gt;)f).putTreeVal(hash, key,
                                                           value)) &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                oldVal &lt;/span&gt;=&lt;span&gt; p.val;
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;onlyIfAbsent)
                                    p.val &lt;/span&gt;=&lt;span&gt; value;
                            }
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (binCount != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {&lt;br/&gt;　　　　　　　　　　　　//（13）
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;=&lt;span&gt; TREEIFY_THRESHOLD)
                        treeifyBin(tab, i);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldVal != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldVal;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
        }&lt;br/&gt;　　　　　//代码（14）
        addCount(&lt;/span&gt;&lt;span&gt;1L&lt;/span&gt;&lt;span&gt;, binCount);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码（1）若为空 抛异常&lt;/p&gt;
&lt;p&gt;代码（2）计算hash值&lt;/p&gt;
&lt;p&gt;代码（3）&lt;/p&gt;
&lt;p&gt;代码（4）判断是否需要进行初始化。&lt;/p&gt;
&lt;p&gt;代码（5）&lt;code&gt;f&lt;/code&gt; 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。&lt;/p&gt;
&lt;p&gt;代码（6）如果当前位置的 &lt;code&gt;hashcode == MOVED == -1&lt;/code&gt;,则需要进行扩容。&lt;/p&gt;
&lt;p&gt;代码（7）如果都不满足，则利用 synchronized 锁写入数据。结点上锁 这里的结点可以理解为hash值相同组成的链表的头结点&lt;/p&gt;
&lt;p&gt;代码（8）fh〉0 说明这个节点是一个链表的节点 不是树的节点.&lt;/p&gt;
&lt;p&gt;代码（9）在这里遍历链表所有的结点&lt;/p&gt;
&lt;p&gt;代码（10）如果hash值和key值相同 则修改对应结点的value值&lt;/p&gt;
&lt;p&gt;代码（11）如果遍历到了最后一个结点，那么就证明新的节点需要插入 就把它插入在链表尾部&lt;/p&gt;
&lt;p&gt;代码（12）如果这个节点是树节点，就按照树的方式插入值&lt;/p&gt;
&lt;p&gt;代码（13）如果数量大于 &lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; 则要转换为红黑树。&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET方法(JAVA8)&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(Object key) {  
    Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; e, p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, eh; K ek;  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算hash值  &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; spread(key.hashCode());  
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据hash值确定节点位置  &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;  
        (e &lt;/span&gt;= tabAt(tab, (n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; h)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果搜索到的节点key与传入的key相同且不为null,直接返回这个节点    &lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((eh = e.hash) ==&lt;span&gt; h) {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ek = e.key) == key || (ek != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(ek)))  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.val;  
        }  
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果eh&amp;lt;0 说明这个节点在树上 直接寻找  &lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (eh &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (p = e.find(h, key)) != &lt;span&gt;null&lt;/span&gt; ? p.val : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则遍历链表 找到对应的值并返回  &lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == h &amp;amp;&amp;amp;&lt;span&gt;  
                ((ek &lt;/span&gt;= e.key) == key || (ek != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(ek))))  
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e.val;  
        }  
    }  
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接着再看看JDK1.8中ConcurrentHashMap的remove方法源码，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; REMOVE OR REPLACE方法(JAVA8)&lt;/span&gt;
&lt;span&gt; final V replaceNode(Object key, V value, Object cv) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; spread(key.hashCode());
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt;[] tab =&lt;span&gt; table;;) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt; f; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i, fh;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数组不为空，长度不为0，指定hash码值为0&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == &lt;span&gt;0&lt;/span&gt; ||&lt;span&gt;
            (f &lt;/span&gt;= tabAt(tab, i = (n - &lt;span&gt;1&lt;/span&gt;) &amp;amp; hash)) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是一个 forwardNode&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((fh = f.hash) ==&lt;span&gt; MOVED)
            tab &lt;/span&gt;=&lt;span&gt; helpTransfer(tab, f);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            V oldVal &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            boolean validated &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            synchronized (f) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tabAt(tab, i) ==&lt;span&gt; f) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fh &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                        validated &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环寻找&lt;/span&gt;
                        &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;K,V&amp;gt; e = f, pred = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;;) {
                            K ek;
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; equal 相同 取出&lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                                ((ek &lt;/span&gt;= e.key) == key ||&lt;span&gt;
                                 (ek &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(ek)))) {
                                V ev &lt;/span&gt;=&lt;span&gt; e.val;
                                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; value为null或value和查到的值相等  &lt;/span&gt;
                                &lt;span&gt;if&lt;/span&gt; (cv == &lt;span&gt;null&lt;/span&gt; || cv == ev ||&lt;span&gt;
                                    (ev &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; cv.equals(ev))) {
                                    oldVal &lt;/span&gt;=&lt;span&gt; ev;
                                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                        e.val &lt;/span&gt;=&lt;span&gt; value;
                                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                        pred.next &lt;/span&gt;=&lt;span&gt; e.next;
                                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                        setTabAt(tab, i, e.next);
                                }
                                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                            }
                            pred &lt;/span&gt;=&lt;span&gt; e;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = e.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若是树 红黑树高效查找/删除&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (f instanceof TreeBin) {
                        validated &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        TreeBin&lt;/span&gt;&amp;lt;K,V&amp;gt; t = (TreeBin&amp;lt;K,V&amp;gt;&lt;span&gt;)f;
                        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; r, p;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((r = t.root) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                            (p &lt;/span&gt;= r.findTreeNode(hash, key, &lt;span&gt;null&lt;/span&gt;)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            V pv &lt;/span&gt;=&lt;span&gt; p.val;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cv == &lt;span&gt;null&lt;/span&gt; || cv == pv ||&lt;span&gt;
                                (pv &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; cv.equals(pv))) {
                                oldVal &lt;/span&gt;=&lt;span&gt; pv;
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    p.val &lt;/span&gt;=&lt;span&gt; value;
                                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (t.removeTreeNode(p))
                                    setTabAt(tab, i, untreeify(t.first));
                            }
                        }
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (validated) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldVal != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        addCount(&lt;/span&gt;-&lt;span&gt;1L&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldVal;
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出 JDK1.8 和 JDK1.7 对 ConcurrentHashMap 的实现改变，笔者更喜欢 CAS 无锁机制，如果只是看我写以上代码注释明显不足以了解 JAVA8 的 ConcurrentHashMap 的实现，我也仅仅提供源码阅读的思路，其中 cas、volatile、final 等注意已经给解释，所以如果大家真的感兴趣还是写程序，打断点，一步步看看这个代码的实现.&lt;/p&gt;
&lt;p&gt;1.8 在 1.7 的数据结构上做了大的改动，采用红黑树之后可以保证查询效率（&lt;code&gt;O(logn)&lt;/code&gt;），甚至取消了 ReentrantLock 改为了 synchronized，这样可以看出在新版的 JDK 中对 synchronized 优化是很到位的。&lt;/p&gt;

&lt;p&gt;相信到这里为止，理解上面的内容，遇到面试，问题都迎刃而解，下面是网上找的面试题，如下：&lt;/p&gt;
&lt;p&gt;（1）你知道 HashMap 的工作原理吗？你知道 HashMap 的 get() 方法的工作原理吗？&lt;/p&gt;
&lt;p&gt;HashMap 是基于 hashing 的原理，我们使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当我们给 put() 方法传递键和值时，我们先对键调用 hashCode() 方法，返回的 hashCode 用于找到 bucket 位置来储存 Entry 对象。&lt;/p&gt;
&lt;p&gt;（2）你知道 ConcurrentHashMap 的工作原理吗？你知道 ConcurrentHashMap 在 JAVA8 和 JAVA7 对比有哪些不同呢?&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap 为了提高本身的并发能力，在内部采用了一个叫做 Segment 的结构，一个 Segment 其实就是一个类 Hash Table 的结构，Segment 内部维护了一个链表数组，我们用下面这一幅图来看下 ConcurrentHashMap 的内部结构,从下面的结构我们可以了解到，ConcurrentHashMap 定位一个元素的过程需要进行两次Hash操作，第一次 Hash 定位到 Segment，第二次 Hash 定位到元素所在的链表的头部，因此，这一种结构的带来的副作用是 Hash 的过程要比普通的 HashMap 要长，但是带来的好处是写操作的时候可以只对元素所在的 Segment 进行操作即可，不会影响到其他的 Segment，这样，在最理想的情况下，ConcurrentHashMap 可以最高同时支持 Segment 数量大小的写操作（刚好这些写操作都非常平均地分布在所有的 Segment上），所以，通过这一种结构，ConcurrentHashMap 的并发能力可以大大的提高。&lt;/p&gt;
&lt;p&gt;JAVA7之前ConcurrentHashMap主要采用锁机制，在对某个Segment进行操作时，将该Segment锁定，不允许对其进行非查询操作，而在JAVA8之后采用CAS无锁算法，这种乐观操作在完成前进行判断，如果符合预期结果才给予执行，对并发操作提供良好的优化&lt;/p&gt;
&lt;p&gt;（3）当两个对象的hashcode相同会发生什么？&lt;/p&gt;
&lt;p&gt;因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为Map使用LinkedList存储对象，这个Entry（包含有键值对的Map.Entry对象）会存储在LinkedList中。（当向 Map 中添加 key-value 对，由其 key 的 hashCode() 返回值决定该 key-value 对（就是 Entry 对象）的存储位置。当两个 Entry 对象的 key 的 hashCode() 返回值相同时，将由 key 通过 eqauls() 比较值决定是采用覆盖行为（返回 true），还是产生 Entry 链（返回 false）），此时若你能讲解JDK1.8红黑树引入，面试官或许会刮目相看。&lt;/p&gt;
&lt;p&gt;（4）如果两个键的 hashcode 相同，你如何获取值对象？&lt;/p&gt;
&lt;p&gt;当我们调用get()方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，然后获取值对象。如果有两个值对象储存在同一个 bucket，将会遍历 LinkedList 直到找到值对象。找到 bucket 位置之后，会调用 keys.equals() 方法去找到 LinkedList 中正确的节点，最终找到要找的值对象。（当程序通过 key 取出对应 value 时，系统只要先计算出该 key 的 hashCode() 返回值，在根据该 hashCode 返回值找出该 key 在 table 数组中的索引，然后取出该索引处的 Entry，最后返回该 key 对应的 value 即可）。&lt;/p&gt;
&lt;p&gt;（5）如果HashMap的大小超过了负载因子（load factor）定义的容量，怎么办？&lt;/p&gt;
&lt;p&gt;当一个map填满了75%的bucket时候，和其它集合类（如ArrayList等）一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。&lt;/p&gt;
&lt;p&gt;（6）你了解重新调整HashMap大小存在什么问题吗？&lt;/p&gt;
&lt;p&gt;当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在LinkedList中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在LinkedList的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？&lt;/p&gt;
&lt;p&gt;（7）请问ConcurrentHashMap中变量使用final和volatile修饰有什么用呢？其中链表是final的next属性，那么发生删除某个元素，如何实现的？&lt;/p&gt;
&lt;p&gt;使用final来实现不变模式（immutable），他是多线程安全里最简单的一种保障方式。因为你拿他没有办法，想改变它也没有机会。不变模式主要通过final关键字来限定的。在JMM中final关键字还有特殊的语义。Final域使得确保初始化安全性（initialization safety）成为可能，初始化安全性让不可变形对象不需要同步就能自由地被访问和共享。&lt;/p&gt;
&lt;p&gt;使用volatile来保证某个变量内存的改变对其他线程即时可见，在配合CAS可以实现不加锁对并发操作的支持&lt;/p&gt;
&lt;p&gt;remove执行的开始就将table赋给一个局部变量tab，将tab依次复制出来，最后直到该删除位置，将指针指向下一个变量。&lt;/p&gt;
&lt;p&gt;（8）描述一下ConcurrentHashMap中remove操作，有什么需要注意的？&lt;/p&gt;
&lt;p&gt;需要注意如下几点。第一，当要删除的结点存在时，删除的最后一步操作要将count的值减一。这必须是最后一步操作，否则读取操作可能看不到之前对段所做的结构性修改。第二，remove执行的开始就将table赋给一个局部变量tab，这是因为table是volatile变量，读写volatile变量的开销很大。编译器也不能对volatile变量的读写做任何优化，直接多次访问非volatile实例变量没有多大影响，编译器会做相应优化。&lt;/p&gt;
&lt;p&gt;（9）HashTable与ConcurrentHashMap有什么区别，描述锁分段技术。&lt;/p&gt;
&lt;p&gt;HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定的。&lt;/p&gt;

</description>
<pubDate>Wed, 15 Aug 2018 07:43:00 +0000</pubDate>
<dc:creator>狂小白</dc:creator>
<og:description>在多线程环境下，使用HashMap进行put操作时存在丢失数据的情况，为了避免这种bug的隐患，强烈建议使用ConcurrentHashMap代替HashMap。 HashTable是一个线程安全的类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/9478505.html</dc:identifier>
</item>
<item>
<title>Kibana（一张图片胜过千万行日志） - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/9476813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/9476813.html</guid>
<description>&lt;p&gt;&lt;span&gt;Kibana是一个开源的分析和可视化平台，设计用于和Elasticsearch一起工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你用Kibana来搜索，查看，并和存储在Elasticsearch索引中的数据进行交互。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以轻松地执行高级数据分析，并且以各种图标、表格和地图的形式可视化数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kibana使得理解大量数据变得很容易。它简单的、基于浏览器的界面使你能够快速创建和共享动态仪表板，实时显示Elasticsearch查询的变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.  安装Kibana&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814191248737-811570641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814191520367-184155487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.  Kibana配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/current/settings.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.elastic.co/guide/en/kibana/current/settings.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.  访问Kibana&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;Kibana是一个Web应用程序，你可以通过5601来访问它。例如：localhost:5601 或者 http://YOURDOMAIN.com:5601&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当访问Kibana时，默认情况下，Discover页面加载时选择了默认索引模式。时间过滤器设置为最近15分钟，搜索查询设置为match-all(\*)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1.  检查Kibana状态&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http://localhost:5601/status&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814193042396-1698058646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者 http://192.168.101.5:5601/api/status 返回JSON格式状态信息&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.  用Elasticsearch连接到Kibana&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;在你开始用Kibana之前，你需要告诉Kibana你想探索哪个Elasticsearch索引。第一次访问Kibana是，系统会提示你定义一个索引模式以匹配一个或多个索引的名字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（提示：默认情况下，Kibana连接允许在localhost上的Elasticsearch实例。为了连接到一个不同的Elasticsearch实例，修改kabana.yml中Elasticsearch的URL，然后重启Kibana。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了配置你想要用Kibana访问的Elasticsearch索引：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、访问Kibana UI。例如，localhost:56011 或者 http://YOURDOMAIN.com:5601&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、指定一个索引模式来匹配一个或多个你的Elasticsearch索引。当你指定了你的索引模式以后，任何匹配到的索引都将被展示出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（画外音：*匹配0个或多个字符；  指定索引默认是为了匹配索引，确切的说是匹配索引名字）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、点击“&lt;strong&gt;Next Step&lt;/strong&gt;”以选择你想要用来执行基于时间比较的包含timestamp字段的索引。如果你的索引没有基于时间的数据，那么选择“&lt;strong&gt;I don’t want to use the Time Filter&lt;/strong&gt;”选项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、点击“&lt;strong&gt;Create index pattern&lt;/strong&gt;”按钮来添加索引模式。第一个索引模式自动配置为默认的索引默认，以后当你有多个索引模式的时候，你就可以选择将哪一个设为默认。（提示：Management &amp;gt; Index Patterns）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814200208889-480093301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814200220481-132250130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814200232910-1800632871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，Kibana已经连接到你的Elasticsearch数据。Kibana展示了一个只读的字段列表，这些字段是匹配到的这个索引配置的字段。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.  Discover&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;你可以从Discover页面交互式的探索你的数据。你可以访问与所选择的索引默认匹配的每个索引中的每个文档。你可以提交查询请求，过滤搜索结构，并查看文档数据。你也可以看到匹配查询请求的文档数量，以及字段值统计信息。如果你选择的索引模式配置了time字段，则文档随时间的分布将显示在页面顶部的直方图中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814201551940-917551371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814202140065-1741268963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.1.  设置时间过滤&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814202528095-388522899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814202537854-228504795.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814202546400-1628872682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.2.  搜索数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以在搜索框中输入查询条件来查询当前索引模式匹配的索引。在查询的时候，你可以使用Kibana标准的查询语言（基于Lucene的查询语法）或者完全基于JSON的Elasticsearch查询语言DSL。Kibana查询语言可以使用自动完成和简化的查询语法作为实验特性，您可以在查询栏的“选项”菜单下进行选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你提交一个查询请求时，直方图、文档表和字段列表都会更新，以反映搜索结果。命中（匹配到的文档）总数会显示在工具栏中。文档表格中显示了前500个命中。默认情况下，按时间倒序排列，首先显示最新的文档。你可以通过点击“Time”列来逆转排序顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814204558449-1716141956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814204613529-1033417049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.2.1.  Lucene查询语法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kibana查询语言基于Lucene查询语法。下面是一些提示，可能会帮到你：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;为了执行一个文本搜索，可以简单的输入一个文本字符串。例如，如果你想搜索web服务器的日志，你可以输入关键字&quot;&lt;strong&gt;safari&lt;/strong&gt;&quot;，这样你就可以搜索到所有有关&quot;safari&quot;的字段&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;为了搜索一个特定字段的特定值，可以用字段的名称作为前缀。例如，你输入&quot;&lt;strong&gt;status:200&lt;/strong&gt;&quot;，将会找到所有status字段的值是200的文档&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;为了搜索一个范围值，你可以用括号范围语法，&lt;strong&gt;[START_VALUE TO END_VALUE]&lt;/strong&gt;。例如，为了找到状态码是4xx的文档，你可以输入&lt;strong&gt;status:[400 TO 499]&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;为了指定更改复杂的查询条件，你可以用布尔操作符 &lt;strong&gt;AND&lt;/strong&gt; , &lt;strong&gt;OR&lt;/strong&gt; , 和 &lt;strong&gt;NOT&lt;/strong&gt;。例如，为了找到状态码是4xx并且extension字段是php或者html的文档，你可以输入&lt;strong&gt;status:[400 TO 499] AND (extension:php OR extension:html)&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814210025045-321466232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814210037141-1350750433.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814210045905-317397752.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.2.2.  Kibana查询语法增强&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;新的更简单的语法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你熟悉Kibana的旧Lucene查询语法，那么你应该对这种新的语法也不会陌生。基本原理保持不变，我们只是简单地改进了一些东西，使查询语言更易于使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;response:200&lt;/span&gt; 将匹配response字段的值是200的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用引号引起来的一段字符串叫短语搜索。例如，&lt;span&gt;&lt;span&gt;message:&quot;Quick brown fox&quot; &lt;/span&gt; &lt;span&gt;将在message字段中搜索&quot;quick brown fox&quot;这个短语。如果没有引号，将会匹配到包含这些词的所有文档，而不管它们的顺序如何。这就意味着，会匹配到&quot;Quick brown fox&quot;，而不会匹配&quot;quick fox brown&quot;。（画外音：引号引起来作为一个整体）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询解析器将不再基于空格进行分割。多个搜索项必须由明确的布尔运算符分隔。注意，布尔运算符不区分大小写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Lucene中，&lt;span&gt;response:200 extension:php&lt;/span&gt; 等价于 &lt;span&gt;response:200 and extension:php&lt;/span&gt;。这将匹配response字段值匹配200并且extenion字段值匹配php的文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们把中间换成or，那么&lt;span&gt;response:200 or extension:php&lt;/span&gt;将匹配response字段匹配200 或者 extension字段匹配php的文档。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，and 比 or 具有更高优先级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;response:200 and extension:php or extension:css&lt;/span&gt; 将匹配response是200并且extension是php，或者匹配extension是css而response任意&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;括号可以改变这种优先级&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;response:200 and (extension:php or extension:css)&lt;/span&gt; 将匹配response是200并且extension是php或者css的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一种简写的方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;response:(200 or 404)&lt;/span&gt; 将匹配response字段是200或404的文档。字符值也可以是多个，比如：&lt;span&gt;tags:(success and info and security)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还可以用not&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;not response:200&lt;/span&gt; 将匹配response不是200的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;response:200 and not (extension:php or extension:css)&lt;/span&gt; 将匹配response是200并且extension不是php也不是css的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;范围检索和Lucene有一点点不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代替 byte:&amp;gt;1000，我们用byte &amp;gt; 1000&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;= 都是有效的操作符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;response:*  将匹配所有存在response字段的文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通配符查询也是可以的。&lt;span&gt;machine.os:win*&lt;/span&gt; 将匹配machine.os字段以win开头的文档，像&quot;windows 7&quot;和&quot;windows 10&quot;这样的值都会被匹配到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通配符也允许我们一次搜索多个字段，例如，假设我们有machine.os和machine.os.keyword两个字段，我们想要搜索这两个字段都有&quot;windows 10&quot;，那么我们可以这样写&lt;span&gt;&quot;machine.os*:windows 10&quot;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.2.3.  刷新搜索结果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180814214254188-293227620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 5.3.  按字段过滤&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815121322148-157573776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815121332626-1053895090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上是控制列表显示哪些字段，还有一种方式是在查看文档数据的时候点那个像书一样的小图标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815133824582-1195635014.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;删除也是可以的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815134015059-1343338379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们还可以编辑一个DSL查询语句，用于过滤筛选，例如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815121716160-2000146352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.4.  查看文档数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815131712346-1865507022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815131808342-285963630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.5.  查看文档上下文&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815134349647-866081044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815134358034-807747437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.6.  查看字段数据统计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815134630606-139801031.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815134637921-1936955305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6.  Visualize&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;Visualize使得你可以创建在你的Elasticsearch索引中的数据的可视化效果。然后，你可以构建dashboard来展示相关可视化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kibana可视化是基于Elasticsearch查询的。通过用一系列的Elasticsearch聚集来提取并处理你的数据，你可以创建图片来线上你需要了解的趋势、峰值和低点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6.1.  创建一个可视化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了创建一个可视化的视图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1步：点击左侧导航条中的“&lt;strong&gt;Visualize&lt;/strong&gt;”按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2步：点击“Create new visualization”按钮或者&lt;strong&gt;加号(+)&lt;/strong&gt;按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3步：选择一个可视化类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4步：指定一个搜索查询来检索可视化数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第5步：在可视化的构建器中选择Y轴的聚合操作。例如，sum，average，count等等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第6步：设置X轴&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815142051383-1539845797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815142101389-1765706122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815142116982-1931645008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815142134893-603647500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;更多请看这里&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/current/createvis.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.elastic.co/guide/en/kibana/current/createvis.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/current/xy-chart.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.elastic.co/guide/en/kibana/current/xy-chart.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/current/visualize.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.elastic.co/guide/en/kibana/current/visualize.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7.  Dashboard&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; &lt;span&gt;Kibana仪表板显示可视化和搜索的集合。你可以安排、调整和编辑仪表板内容，然后保存仪表板以便共享它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7.1.  构建一个Dashboard&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第1步：在导航条上点击“&lt;strong&gt;Dashboard&lt;/strong&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第2步：点击“Create new dashboard”或者“加号(+)”按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3步：点击“Add”按钮&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第4步：为了添加一个可视化，从可视化列表中选择一个，或者点击“Add new visualization”按钮新创建一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第5步：为了添加一个已保存的查询，点击“Saved Search”选项卡，然后从列表中选择一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第6步：当你完成添加并且调整了dashboard的内容后，去顶部菜单栏，点击“Save”，然后输入一个名字。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认情况下，Kibana仪表板使用浅色主题。要使用深色主题，单击“选项”并选择“使用深色主题”。要将dark主题设置为默认，请转到管理&amp;gt;Management &amp;gt; Advanced ，并将dashboard:defaultDarkTheme设置为On。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815144328057-886948163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815144337309-990057504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815144346857-1932587218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.  Monitoring&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
Elasticsearch控制台打印日志
[2018-08-15T14:48:26,874][INFO ][o.e.c.m.MetaDataCreateIndexService] [Px524Ts] [.monitoring-kibana-6-2018.08.15] creating index, cause [auto(bulk api)], templates [.monitoring-kibana], shards [1]/[0], mappings [doc]

Kibana控制台打印日志
log   [03:26:53.605] [info][license][xpack] Imported license information from Elasticsearch for the [monitoring] cluster: mode: basic | status: active
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815145420812-1817184513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815145431388-1721016029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815145449472-1969113550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815145458683-691543790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/874963/201808/874963-20180815145507959-542848475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/kibana/current/elasticsearch-metrics.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.elastic.co/guide/en/kibana/current/elasticsearch-metrics.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9.  其它相关&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; &lt;span&gt;《&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cjsblog/p/9459781.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Logstash&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/cjsblog/p/9439331.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Elasticsearch&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 15 Aug 2018 07:05:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<og:description>Kibana是一个开源的分析和可视化平台，设计用于和Elasticsearch一起工作。 你用Kibana来搜索，查看，并和存储在Elasticsearch索引中的数据进行交互。 你可以轻松地执行高级</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/9476813.html</dc:identifier>
</item>
<item>
<title>C# NPOI数据导出到Excel之反射 - FIGHTING360</title>
<link>http://www.cnblogs.com/zhangtingzu/p/9481430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangtingzu/p/9481430.html</guid>
<description>&lt;p&gt;　　之前努力去理解过反射，但是项目中几乎用不到反射，所以对反射理解效果很差。正好最近做了一个类库，功能是将数据导出到Excel&lt;span&gt;，里面用到了反射。我觉得这个是理解反射比较好的案例，所以将此记录下来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;反射理解：反射是.NET中的重要机制，通过反射，可以在运行时获得程序或程序集中每一个类型（包括类、结构、委托、接口和枚举等）的成员和成员的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面的程序功能是将一组数据导出到&lt;/span&gt;Excel&lt;span&gt;：&lt;/span&gt;&lt;span&gt;List&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;导出到&lt;/span&gt;&lt;span&gt;Excel&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这里实体T&lt;span&gt;以下面(StudentEntity)的简单例子来理解：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentEntity
    {
        [Description(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;姓名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Description(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;年龄&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Description(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        [Description(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;手机号码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; telphone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;　　最终&lt;/span&gt;&lt;span&gt;输出&lt;/span&gt;excel&lt;span&gt;表格如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/939563/201808/939563-20180815140430929-458105344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　分析一下：&lt;/p&gt;
&lt;p&gt;　　在这里动态变化的只有T&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　表格第&lt;/span&gt;1&lt;span&gt;行是固定的表头信息，是一种合并单元格的形式，合并的列数也就是&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;的字段数量；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　表格第&lt;/span&gt;2&lt;span&gt;行信息是不固定的，是根据实体&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;里面的字段描述来生成的&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;当然也可以不用按照我这个模式来&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　表格第&lt;/span&gt;3-5&lt;span&gt;行就是具体的实体数据。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;根据上面的分析得到，我们需要从&lt;/span&gt;T&lt;span&gt;中获取信息如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1.T&lt;span&gt;的字段个数，也就是表格的列数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2.T&lt;span&gt;的字段描述，也就是第&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;行显示的名称；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　在这里就需要用到反射，当第1&lt;span&gt;行和第&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;行产生好后，循环遍历&lt;/span&gt;&lt;span&gt;List&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;生成数据就可以了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　下面就一步一步来代码实现；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;步骤&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;span&gt;：新建一个控制台应用程序&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;也可以建类库、&lt;/span&gt;&lt;span&gt;winform&lt;/span&gt;&lt;span&gt;程序&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;步骤&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;span&gt;：右击“引用”，选择“管理&lt;/span&gt;&lt;span&gt;NuGet&lt;/span&gt;&lt;span&gt;程序包”；在左面的浏览里输入&lt;/span&gt;&lt;span&gt;NPOI&lt;/span&gt;&lt;span&gt;，选择最新的版本安装就可以了，我这里选择的是“最新稳定版&lt;/span&gt;&lt;span&gt;2.3.0&lt;/span&gt;&lt;span&gt;”；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/939563/201808/939563-20180815140646605-1769670746.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/939563/201808/939563-20180815140702298-912604774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;步骤3&lt;/strong&gt;&lt;span&gt;：定义方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 导出数据到Excel
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;数据集合&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;head&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表头(第一行数据)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sheetName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;sheet名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ExportToExcel&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; data, &lt;span&gt;string&lt;/span&gt; head, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; sheetName)
        {

        } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;　步骤4&lt;/strong&gt;&lt;span&gt;：创建一个工作簿&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;表&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ExportToExcel&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; data, &lt;span&gt;string&lt;/span&gt; head, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; sheetName)
        {
            IWorkbook wb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HSSFWorkbook();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置工作簿的名称&lt;/span&gt;
            sheetName = &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(sheetName) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sheet1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : sheetName;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个工作簿&lt;/span&gt;
            ISheet sh =&lt;span&gt; wb.CreateSheet(sheetName);
         }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　把引用添加上：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　using&lt;/span&gt;&lt;span&gt; NPOI.HSSF.UserModel;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　using&lt;/span&gt;&lt;span&gt; NPOI.SS.UserModel;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　步骤5&lt;/strong&gt;：设置前2行(表头+抬头)&lt;/p&gt;
&lt;p&gt;　　总体预览：(代码为第9行以下)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ExportToExcel&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; data, &lt;span&gt;string&lt;/span&gt; head, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; sheetName)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             IWorkbook wb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HSSFWorkbook();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置工作簿的名称&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             sheetName = &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(sheetName) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sheet1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : sheetName;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个工作簿&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             ISheet sh =&lt;span&gt; wb.CreateSheet(sheetName);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局索引&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; gloal_index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             System.Reflection.PropertyInfo[] oProps = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (T en &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (oProps == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     oProps =&lt;span&gt; ((Type)en.GetType()).GetProperties();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (gloal_index == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;#region&lt;/span&gt; 表头(第1行)
&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                     &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;#region&lt;/span&gt; 抬头(第2行)
&lt;span&gt;25&lt;/span&gt;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                     &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;                     gloal_index = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;#region&lt;/span&gt; 这里是List&amp;lt;T&amp;gt;具体内容
&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;                 gloal_index++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; 　　首先通过反射获取到T&lt;span&gt;的信息，其中列数的值就是&lt;/span&gt;oProps.Length；&lt;/p&gt;
&lt;p&gt;　　前两行的设置有gloal_index变量来控制，gloal_index为0时，即循环第一次执行时，初始化前两行数据，然后置gloal_index的值为2，即正常处理List&amp;lt;T&amp;gt;的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　5.1 表头里的代码&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#region&lt;/span&gt; 表头(第1行)
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并单元格&lt;/span&gt;
 sh.AddMergedRegion(&lt;span&gt;new&lt;/span&gt; NPOI.SS.Util.CellRangeAddress(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, oProps.Length - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第1行&lt;/span&gt;
IRow row0 = sh.CreateRow(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第1行高度&lt;/span&gt;
row0.Height = &lt;span&gt;20&lt;/span&gt; * &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第1行第1列&lt;/span&gt;
ICell icell1top0 = row0.CreateCell(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第1行第1列格式&lt;/span&gt;
icell1top0.CellStyle =&lt;span&gt; Getcellstyle(wb, &quot;head&quot;);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第1行第1列内容&lt;/span&gt;
&lt;span&gt; icell1top0.SetCellValue(head);
&lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　5.2 抬头(第2行)的代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#region&lt;/span&gt; 抬头(第2行)
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第2行&lt;/span&gt;
IRow row1 = sh.CreateRow(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置高度&lt;/span&gt;
row1.Height = &lt;span&gt;20&lt;/span&gt; * &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;columnt_index是列的索引&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; columnt_index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (System.Reflection.PropertyInfo item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; oProps)
{
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取T的字段名称&lt;/span&gt;
         &lt;span&gt;string&lt;/span&gt; name =&lt;span&gt; item.Name;
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取T的字段名称的描述&lt;/span&gt;
         &lt;span&gt;string&lt;/span&gt; des = ((DescriptionAttribute)Attribute.GetCustomAttribute(item, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DescriptionAttribute))).Description;

          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第2行的第columnt_index列&lt;/span&gt;
          ICell icell1top =&lt;span&gt; row1.CreateCell(columnt_index);
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第2行的第columnt_index列的格式&lt;/span&gt;
          icell1top.CellStyle =&lt;span&gt; Getcellstyle(wb, &quot;&quot;);
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第2行的第columnt_index列的内容&lt;/span&gt;
           &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(des))
           {
                  cell1top.SetCellValue(des);
           }
           &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
           {
                  icell1top.SetCellValue(name);
           }
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第2行的第columnt_index列的宽度&lt;/span&gt;
           sh.SetColumnWidth(columnt_index, (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;15&lt;/span&gt; + &lt;span&gt;0.72&lt;/span&gt;) * &lt;span&gt;256&lt;/span&gt;&lt;span&gt;));
           columnt_index&lt;/span&gt;++&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　步骤6&lt;/strong&gt;&lt;span&gt;：设置主体内容&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;除前两行外&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#region&lt;/span&gt; 这里是List&amp;lt;T&amp;gt;具体内容
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第gloal_index行&lt;/span&gt;
 IRow row_zs =&lt;span&gt; sh.CreateRow(gloal_index);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; column_index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (System.Reflection.PropertyInfo pi &lt;span&gt;in&lt;/span&gt;&lt;span&gt; oProps)
{
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第gloal_index行的第columnt_index列&lt;/span&gt;
         ICell icell1top =&lt;span&gt; row_zs.CreateCell(column_index);
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第gloal_index行的第columnt_index列格式&lt;/span&gt;
          icell1top.CellStyle =&lt;span&gt; Getcellstyle(wb, &quot;&quot;);
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取en字段值&lt;/span&gt;
          &lt;span&gt;string&lt;/span&gt; v_value = pi.GetValue(en, &lt;span&gt;null&lt;/span&gt;) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : pi.GetValue(en, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;).ToString();
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第gloal_index行的第columnt_index列的内容&lt;/span&gt;
&lt;span&gt;          icell1top.SetCellValue(v_value);

          column_index&lt;/span&gt;++&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　步骤7&lt;/strong&gt;&lt;span&gt;：输出数据&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出内容&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; (FileStream stm = File.OpenWrite(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;D:\studentInfo.xls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
{
        wb.Write(stm);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　格式设置方法Getcellstyle如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 格式设置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; ICellStyle Getcellstyle(IWorkbook wb, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; type)
        {
            ICellStyle cellStyle &lt;/span&gt;=&lt;span&gt; wb.CreateCellStyle();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义字体  &lt;/span&gt;
            IFont font =&lt;span&gt; wb.CreateFont();
            font.FontName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;微软雅黑&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;水平对齐  &lt;/span&gt;
            cellStyle.Alignment =&lt;span&gt; NPOI.SS.UserModel.HorizontalAlignment.Left;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;垂直对齐  &lt;/span&gt;
            cellStyle.VerticalAlignment =&lt;span&gt; VerticalAlignment.Center;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动换行  &lt;/span&gt;
            cellStyle.WrapText = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缩进&lt;/span&gt;
            cellStyle.Indention = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (type)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    cellStyle.SetFont(font);
                    cellStyle.Alignment &lt;/span&gt;=&lt;span&gt; HorizontalAlignment.Center;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    cellStyle.SetFont(font);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cellStyle;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　步骤8：以T为StudentEntity为例生成测试数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            StudentEntity se1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StudentEntity() { name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age = &lt;span&gt;20&lt;/span&gt;, address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上海&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, telphone = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;16278171615&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            StudentEntity se2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StudentEntity() { name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age = &lt;span&gt;18&lt;/span&gt;, address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, telphone = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;19278187590&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            StudentEntity se3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StudentEntity() { name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;王五&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age = &lt;span&gt;19&lt;/span&gt;, address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;广州&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, telphone = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18278187590&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };

            List&lt;/span&gt;&amp;lt;StudentEntity&amp;gt; selist = &lt;span&gt;new&lt;/span&gt; List&amp;lt;StudentEntity&amp;gt;&lt;span&gt;();
            selist.Add(se1);
            selist.Add(se2);
            selist.Add(se3);
            ExportToExcel&lt;/span&gt;&amp;lt;StudentEntity&amp;gt;(selist, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生信息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生信息表&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.Read();
         }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　完整代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NPOI.HSSF.UserModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NPOI.HSSF.Util;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; NPOI.SS.UserModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.ComponentModel;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ExcelReflection
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            StudentEntity se1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StudentEntity() { name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age = &lt;span&gt;20&lt;/span&gt;, address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上海&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, telphone = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;16278171615&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            StudentEntity se2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StudentEntity() { name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age = &lt;span&gt;18&lt;/span&gt;, address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, telphone = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;19278187590&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            StudentEntity se3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StudentEntity() { name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;王五&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, age = &lt;span&gt;19&lt;/span&gt;, address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;广州&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, telphone = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;18278187590&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };

            List&lt;/span&gt;&amp;lt;StudentEntity&amp;gt; selist = &lt;span&gt;new&lt;/span&gt; List&amp;lt;StudentEntity&amp;gt;&lt;span&gt;();
            selist.Add(se1);
            selist.Add(se2);
            selist.Add(se3);
            ExportToExcel&lt;/span&gt;&amp;lt;StudentEntity&amp;gt;(selist, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生信息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生信息表&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.Read();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 导出数据到Excel
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;data&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;数据集合&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;head&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;表头(第一行数据)&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sheetName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;sheet名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ExportToExcel&amp;lt;T&amp;gt;(List&amp;lt;T&amp;gt; data, &lt;span&gt;string&lt;/span&gt; head, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; sheetName)
        {
            IWorkbook wb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HSSFWorkbook();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置工作簿的名称&lt;/span&gt;
            sheetName = &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(sheetName) ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sheet1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : sheetName;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个工作簿&lt;/span&gt;
            ISheet sh =&lt;span&gt; wb.CreateSheet(sheetName);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局索引&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; gloal_index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            System.Reflection.PropertyInfo[] oProps &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (T en &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oProps == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    oProps &lt;/span&gt;=&lt;span&gt; ((Type)en.GetType()).GetProperties();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (gloal_index == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 表头(第1行)
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并单元格&lt;/span&gt;
                    sh.AddMergedRegion(&lt;span&gt;new&lt;/span&gt; NPOI.SS.Util.CellRangeAddress(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, oProps.Length - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第1行&lt;/span&gt;
                    IRow row0 = sh.CreateRow(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第1行高度&lt;/span&gt;
                    row0.Height = &lt;span&gt;20&lt;/span&gt; * &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第1行第1列&lt;/span&gt;
                    ICell icell1top0 = row0.CreateCell(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第1行第1列格式&lt;/span&gt;
                    icell1top0.CellStyle = Getcellstyle(wb, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第1行第1列内容&lt;/span&gt;
&lt;span&gt;                    icell1top0.SetCellValue(head);
                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

                    &lt;span&gt;#region&lt;/span&gt; 抬头(第2行)
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第2行&lt;/span&gt;
                    IRow row1 = sh.CreateRow(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置高度&lt;/span&gt;
                    row1.Height = &lt;span&gt;20&lt;/span&gt; * &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;columnt_index是列的索引&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; columnt_index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (System.Reflection.PropertyInfo item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; oProps)
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取T的字段名称&lt;/span&gt;
                        &lt;span&gt;string&lt;/span&gt; name =&lt;span&gt; item.Name;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取T的字段名称的描述&lt;/span&gt;
                        &lt;span&gt;string&lt;/span&gt; des = ((DescriptionAttribute)Attribute.GetCustomAttribute(item, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DescriptionAttribute))).Description;

                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第2行的第columnt_index列&lt;/span&gt;
                        ICell icell1top =&lt;span&gt; row1.CreateCell(columnt_index);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第2行的第columnt_index列的格式&lt;/span&gt;
                        icell1top.CellStyle = Getcellstyle(wb, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第2行的第columnt_index列的内容&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(des))
                        {
                            icell1top.SetCellValue(des);
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        {
                            icell1top.SetCellValue(name);
                        }
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第2行的第columnt_index列的宽度&lt;/span&gt;
                        sh.SetColumnWidth(columnt_index, (&lt;span&gt;int&lt;/span&gt;)((&lt;span&gt;15&lt;/span&gt; + &lt;span&gt;0.72&lt;/span&gt;) * &lt;span&gt;256&lt;/span&gt;&lt;span&gt;));
                        columnt_index&lt;/span&gt;++&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;

                    gloal_index &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 这里是List&amp;lt;T&amp;gt;具体内容
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第gloal_index行&lt;/span&gt;
                IRow row_zs =&lt;span&gt; sh.CreateRow(gloal_index);
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; column_index = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (System.Reflection.PropertyInfo pi &lt;span&gt;in&lt;/span&gt;&lt;span&gt; oProps)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建第gloal_index行的第columnt_index列&lt;/span&gt;
                    ICell icell1top =&lt;span&gt; row_zs.CreateCell(column_index);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第gloal_index行的第columnt_index列格式&lt;/span&gt;
                    icell1top.CellStyle = Getcellstyle(wb, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取en字段值&lt;/span&gt;
                    &lt;span&gt;string&lt;/span&gt; v_value = pi.GetValue(en, &lt;span&gt;null&lt;/span&gt;) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : pi.GetValue(en, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;).ToString();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置第gloal_index行的第columnt_index列的内容&lt;/span&gt;
&lt;span&gt;                    icell1top.SetCellValue(v_value);

                    column_index&lt;/span&gt;++&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;

                gloal_index&lt;/span&gt;++&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出内容&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (FileStream stm = File.OpenWrite(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;D:\studentInfo.xls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                wb.Write(stm);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 格式设置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; ICellStyle Getcellstyle(IWorkbook wb, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; type)
        {
            ICellStyle cellStyle &lt;/span&gt;=&lt;span&gt; wb.CreateCellStyle();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义字体  &lt;/span&gt;
            IFont font =&lt;span&gt; wb.CreateFont();
            font.FontName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;微软雅黑&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;水平对齐  &lt;/span&gt;
            cellStyle.Alignment =&lt;span&gt; NPOI.SS.UserModel.HorizontalAlignment.Left;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;垂直对齐  &lt;/span&gt;
            cellStyle.VerticalAlignment =&lt;span&gt; VerticalAlignment.Center;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动换行  &lt;/span&gt;
            cellStyle.WrapText = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缩进&lt;/span&gt;
            cellStyle.Indention = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (type)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                    cellStyle.SetFont(font);
                    cellStyle.Alignment &lt;/span&gt;=&lt;span&gt; HorizontalAlignment.Center;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    cellStyle.SetFont(font);
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cellStyle;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上只是反射很小的一个应用，个人觉得对理解反射比较有帮助。&lt;/p&gt;
&lt;p&gt;　　以上代码可能还有需要改进之处，欢迎批评改正。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 06:58:00 +0000</pubDate>
<dc:creator>FIGHTING360</dc:creator>
<og:description>之前努力去理解过反射，但是项目中几乎用不到反射，所以对反射理解效果很差。正好最近做了一个类库，功能是将数据导出到Excel，里面用到了反射。我觉得这个是理解反射比较好的案例，所以将此记录下来。 反射理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangtingzu/p/9481430.html</dc:identifier>
</item>
<item>
<title>不到200行代码，实现基于规则的轻量级流数据实时时序分析引擎 - Beta-TNT</title>
<link>http://www.cnblogs.com/Beta-TNT/p/9481389.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Beta-TNT/p/9481389.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Wed, 15 Aug 2018 06:52:00 +0000</pubDate>
<dc:creator>Beta-TNT</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2FBeta-TNT%2Fp%2F9481389.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>.Net Core缓存组件(Redis)源码解析 - MicroHeart！</title>
<link>http://www.cnblogs.com/MicroHeart/p/9475047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MicroHeart/p/9475047.html</guid>
<description>&lt;p&gt;　　上一篇文章已经介绍了MemoryCache，MemoryCache存储的数据类型是Object，也说了Redis支持五中数据类型的存储，但是微软的Redis缓存组件只实现了Hash类型的存储。在分析源码之前，先学几个关于Redis操作的命令。&lt;/p&gt;
&lt;h3&gt;一、Redis命令&lt;/h3&gt;
&lt;p&gt;　　Redis所有的命令在&lt;a href=&quot;http://doc.redisfans.com/&quot; target=&quot;_blank&quot;&gt;http://doc.redisfans.com/&lt;/a&gt;上有详细介绍。下面介绍几个常用的关于Hash类型的命令。&lt;/p&gt;
&lt;h4&gt;　　HSET：用于添加缓存&lt;/h4&gt;
&lt;p&gt;　　　　用法：HSET key field value 。&lt;/p&gt;
&lt;p&gt;　　　　返回值：如果 &lt;tt class=&quot;docutils literal&quot;&gt;field&lt;/tt&gt; 是哈希表中的一个新建域，并且值设置成功，返回 &lt;tt class=&quot;docutils literal&quot;&gt;1&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;　　　　　　　　如果哈希表中域 &lt;tt class=&quot;docutils literal&quot;&gt;field&lt;/tt&gt; 已经存在且旧值已被新值覆盖，返回 &lt;tt class=&quot;docutils literal&quot;&gt;0&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;　　　　例如：HSET user Name Microheart&lt;/p&gt;
&lt;p&gt;　　　　　　　HSET user Age 18&lt;/p&gt;
&lt;div class=&quot;line&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/794803/201808/794803-20180814155810250-219157395.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h4 class=&quot;line&quot;&gt;　　HMSET：用于同时添加多个&lt;/h4&gt;
&lt;p&gt;　　　　用法：HMSET key [field value field1 value1 ...]&lt;/p&gt;
&lt;p&gt;　　　　返回值：如果命令执行成功，返回 &lt;tt class=&quot;docutils literal&quot;&gt;OK&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;　　　　　　　　当 &lt;tt class=&quot;docutils literal&quot;&gt;key&lt;/tt&gt; 不是哈希表(hash)类型时，返回一个错误。&lt;/p&gt;
&lt;p&gt;　　　　例如：HMSET user1 Name Microheart Age 18&lt;/p&gt;
&lt;div class=&quot;line&quot;&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/794803/201808/794803-20180814160344865-2050085668.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h4 class=&quot;line&quot;&gt;　　HGET：获取字段值&lt;/h4&gt;
&lt;p&gt;　　　　用法：HGET key field &lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　返回值：给定域的值。&lt;/p&gt;
&lt;p&gt;　　　　　　　　当给定域不存在或是给定 &lt;tt class=&quot;docutils literal&quot;&gt;key&lt;/tt&gt; 不存在时，返回 &lt;tt class=&quot;docutils literal&quot;&gt;nil&lt;/tt&gt; &lt;/p&gt;
&lt;p&gt;　　　　例如：HGET user Name (&lt;span&gt;注意 Redis区分大小写&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/794803/201808/794803-20180814160735665-97095928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　HMGET：获取多个字段的值&lt;/h4&gt;
&lt;p&gt;　　　　用法：HMGET key [field1,field2]&lt;/p&gt;
&lt;p&gt;　　　　返回值：一个包含多个给定域的关联值的表，表值的排列顺序和给定域参数的请求顺序一样。&lt;/p&gt;
&lt;p&gt;　　　　例如：HMGET user Name Age&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/794803/201808/794803-20180814161109535-682071120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　EXPIRE：设置缓存的过期时间&lt;/h4&gt;
&lt;p&gt;　　　　用法：EXPIRE key seconds&lt;/p&gt;
&lt;p&gt;　　　　返回值：设置成功返回 &lt;tt class=&quot;docutils literal&quot;&gt;1&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;　　　　　　　　当 &lt;tt class=&quot;docutils literal&quot;&gt;key&lt;/tt&gt; 不存在或者不能为 &lt;tt class=&quot;docutils literal&quot;&gt;key&lt;/tt&gt; 设置生存时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 &lt;tt class=&quot;docutils literal&quot;&gt;key&lt;/tt&gt; 的生存时间)，返回 &lt;tt class=&quot;docutils literal&quot;&gt;0&lt;/tt&gt; 。&lt;/p&gt;
&lt;p&gt;　　　　例如：EXPIRE user 60&lt;/p&gt;
&lt;div class=&quot;line&quot;&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/794803/201808/794803-20180814165829624-410356157.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　TTL：表示剩余生存时间。57表示还有57秒这个缓存过期。过期后，Redis会自动删除。在 Redis 2.4 版本中，过期时间的延迟在 1 秒钟之内 —— 也即是，就算 &lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;key&lt;/span&gt;&lt;/tt&gt; 已经过期，但它还是可能在过期之后一秒钟之内被访问到，而在新的 Redis 2.6 版本中，延迟被降低到 1 毫秒之内。&lt;/p&gt;
&lt;h3&gt;二、在.Net Core中使用Redis组件&lt;/h3&gt;
&lt;p&gt;　　首先在Startup类中添加Redis缓存功能。配置的Option中设置的InstanceName的值会作为key的一部分。比如设置的InstanceName为test，代码中设置一个缓存key为user，存储到Redis中的实际key为testuser。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
      services.AddMvc();
      services.AddDistributedRedisCache(option &lt;/span&gt;=&amp;gt;&lt;span&gt;
      {
           option.Configuration &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;121.41.55.55:6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;span&gt;//连接字符串&lt;/span&gt;
           option.InstanceName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
      });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在需要使用的地方注入IDistributedCache。如下面所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : Controller
{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IDistributedCache redisCache;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(IDistributedCache redisCache)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.redisCache =&lt;span&gt; redisCache;
        }
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            redisCache.SetAsync(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Encoding.UTF8.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DistributedCacheEntryOptions()
            {
                AbsoluteExpiration &lt;/span&gt;= DateTime.Now.AddSeconds(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;span&gt;//设置过期时间，时间一到缓存立刻就被移除了&lt;/span&gt;
            });

            redisCache.SetString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;span&gt;//没有设置缓存过期时间，表示是永久缓存

            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 三、源码解析&lt;/h3&gt;
&lt;p&gt;　　源码在&lt;a href=&quot;https://github.com/aspnet/Caching&quot; target=&quot;_blank&quot;&gt;https://github.com/aspnet/Caching&lt;/a&gt;，Redis的源码相对简单，主要是因为很多都直接使用的StackExchange.Redis的API。&lt;/p&gt;
&lt;h4&gt;RedisCacheOptions类：主要是Redis配置相关。&lt;/h4&gt;
&lt;p&gt;　　Configuration：设置Redis配置，如连接字符串、超时时间等，最终被装换为StackExchange.Redis中的&lt;a href=&quot;https://github.com/StackExchange/StackExchange.Redis/blob/master/StackExchange.Redis/StackExchange/Redis/ConfigurationOptions.cs&quot; target=&quot;_blank&quot;&gt;ConfigurationOptions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　InstanceName：实例名称。会和代码中设置的key拼接成为Redis中的key。&lt;/p&gt;
&lt;h4&gt;RedisCacheServiceCollectionExtensions类：跟服务注入相关。&lt;/h4&gt;
&lt;p&gt;　　就一个方法AddDistributedRedisCache，依赖注入IDistributedCache的实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddDistributedRedisCache(&lt;span&gt;this&lt;/span&gt; IServiceCollection services, Action&amp;lt;RedisCacheOptions&amp;gt;&lt;span&gt; setupAction)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (services == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(services));
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (setupAction == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(setupAction));
            }
            services.AddOptions();
            services.Configure(setupAction);
            services.Add(ServiceDescriptor.Singleton&lt;/span&gt;&amp;lt;IDistributedCache, RedisCache&amp;gt;&lt;span&gt;());&lt;span&gt;//注入一个单例
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;RedisCache类：最主要的类，缓存操作相关的类。&lt;/h4&gt;
&lt;p&gt;　　其中插入、获取数据的方法比较重要。&lt;/p&gt;
&lt;h4&gt;3.1 Set方法，插入数据。&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public void Set(string key, byte[] value, DistributedCacheEntryOptions options)      &lt;br/&gt;{
          　&lt;span&gt;//省略一些逻辑判断&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
            Connect();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; creationTime =&lt;span&gt; DateTimeOffset.UtcNow;
　　　　　　　&lt;span&gt;//对于一个缓存可以设置为绝对过期时间，相对于现在时间的过期时间和滑动过期时间三种(上一篇文章有例子)，其实前两种时间类型可以相互转换。&lt;br/&gt;　　　　　　　//下面这一步就是 如果设置了绝对过期时间或者相对于现在时间的过期时间，装换为绝对过期时间
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; absoluteExpiration =&lt;span&gt; GetAbsoluteExpiration(creationTime, options);
　　　　　　　&lt;span&gt;//调用了StackExchange.Redis的API 插入缓存
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = _cache.ScriptEvaluate(SetScript, &lt;span&gt;new&lt;/span&gt; RedisKey[] { _instance +&lt;span&gt; key },//&lt;span&gt;这里的key是实例名称+key=Redis中的key,当然我们在查找缓存的时候，并不需要我们手动拼接，只需要传我们复制的key，不需要实例名称&lt;br/&gt;　　　　　　
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisValue[]
                {
                        absoluteExpiration&lt;/span&gt;?.Ticks ??&lt;span&gt; NotPresent,
                        options.SlidingExpiration&lt;/span&gt;?.Ticks ??&lt;span&gt; NotPresent,&lt;br/&gt;　　　　　　　　　　　　　　　&lt;span&gt;//如果对于一个缓存同时设置了绝对过期时间和滑动过期时间，则取即将到期的时间，也就是最小的那个时间。&lt;/span&gt;
                        GetExpirationInSeconds(creationTime, absoluteExpiration, options) &lt;/span&gt;??&lt;span&gt; NotPresent,
                        value
                });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;上面的添加缓存中，使用了脚本插入。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SetScript = (&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;
                redis.call('HMSET', KEYS[1], 'absexp', ARGV[1], 'sldexp', ARGV[2], 'data', ARGV[4])&lt;span&gt;//设置key、绝对过期时间、滑动过期时间、和value的值&lt;/span&gt;
                if ARGV[3] ~= '-1' then
                  redis.call('EXPIRE', KEYS[1], ARGV[3])&lt;span&gt;//设置缓存的时间 &lt;/span&gt;
                end
                return 1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果absexp和sldexp都没有设置值，默认为-1，表示永不过期，缓存时间就是从设置的绝对过期时间和滑动过期时间中取，当时间到了，Redis自动删除过期缓存，这一点和MemoryCache不一样，MemoryCahe是在对缓存操作的时候，会扫描整个缓存删除，存在很大的延时，而Redis采用下面三种策略清理过期的key:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key&lt;/li&gt;
&lt;li&gt;主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key&lt;/li&gt;
&lt;li&gt;当前已用内存超过maxmemory限定时，触发主动清理策略&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这就保证了过期缓存的及时清理。关于Redis清理过期key的策略可以看&lt;a href=&quot;https://www.cnblogs.com/chenpingzhao/archive/2016/02/24/5211456.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　当插入一条Hash类型数据时，打开RedisManager会看到下面这样，absexp：绝对过期时间，sldexp：滑动过期时间，data：就是我们代码中设置的value。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/794803/201808/794803-20180815133049449-1897050353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.2 Get方法中，实现的主要获取功能调用了下面代码。&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisExtensions
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; HmGetScript = (&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;return redis.call('HMGET', KEYS[1], unpack(ARGV))&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;span&gt;//通过脚本HMGET命令获取key的值
　　　　　//Get方法中调用此方法，memebers为固定值 data，也就是获取字段data的值 
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RedisValue[] HashMemberGet(&lt;span&gt;this&lt;/span&gt; IDatabase cache, &lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] members)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; cache.ScriptEvaluate(
                HmGetScript,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisKey[] { key },
                GetRedisMembers(members));&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (RedisValue[])result;
        }

        &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;RedisValue[]&amp;gt;&lt;span&gt; HashMemberGetAsync(
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IDatabase cache,
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key,
            &lt;/span&gt;&lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] members)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; cache.ScriptEvaluateAsync(
                HmGetScript,
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisKey[] { key },
                GetRedisMembers(members));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: Error checking?&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (RedisValue[])result;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RedisValue[] GetRedisMembers(&lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] members)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; redisMembers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisValue[members.Length];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; members.Length; i++&lt;span&gt;)
            {
                redisMembers[i] &lt;/span&gt;=&lt;span&gt; (RedisValue)members[i];
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisMembers;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remove方法就直接调用了StackExchange的API，这里就不做解释。&lt;/p&gt;
&lt;p&gt;　　相比MemoryCache的代码，Redis代码相对简单，主要是微软的开发人员&quot;偷工减料&quot;吧(我自己感觉)，很多重要的方法，比如Redis连接、添加、设置过期时间、都调用了StackExchange的API，没有实现自己的链接池等等。更像是对StackExchangeAPI中的Hash类型的再次封装。&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 06:07:00 +0000</pubDate>
<dc:creator>MicroHeart！</dc:creator>
<og:description>上一篇文章已经介绍了MemoryCache，MemoryCache存储的数据类型是Object，也说了Redis支持五中数据类型的存储，但是微软的Redis缓存组件只实现了Hash类型的存储。在分析源</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MicroHeart/p/9475047.html</dc:identifier>
</item>
<item>
<title>演讲实录！谷得技术总监陈镇洪教你打造游戏研发流水线 - 网易云</title>
<link>http://www.cnblogs.com/163yun/p/9480745.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/163yun/p/9480745.html</guid>
<description>&lt;p&gt;本文来自&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//sq.163yun.com/blog&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;网易云社区&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;7月31日，2018云创大会游戏论坛在杭州国际博览中心103B圆满举行。本场游戏论坛聚焦探讨了可能对游戏行业发展有重大推动的新技术、新实践，如AR、区块链、安全、大数据等。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-a0e23116985b698527e7222d6c49fd4a_hd.jpg&quot; alt=&quot;&quot; width=&quot;662&quot; data-rawwidth=&quot;662&quot; data-rawheight=&quot;440&quot; data-original=&quot;https://pic3.zhimg.com/v2-a0e23116985b698527e7222d6c49fd4a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-a0e23116985b698527e7222d6c49fd4a_b.jpg&quot; data-size=&quot;normal&quot;/&gt;谷得游戏技术总监陈镇洪表示，通用化组件能快速提升游戏开发效率&lt;/p&gt;

&lt;p&gt;谷得游戏技术总监陈镇洪做了《谷得游戏如何打造自主研发流水线》的主题演讲，表示游戏厂商们应当建立平台部，实现游戏研发的通用化，助力流水线型的游戏开发工作。&lt;/p&gt;

&lt;p&gt;过去的开发模式项目组之间是互相独立的，因此常常会面临重复制造轮子、重复踩坑、没有质量保证等问题，而技术中心的成立则可以有效打破这种僵局。陈镇洪表示，技术中心即平台部，它是各个项目组之间的运转中心，可以将各个项目中通用的模块进行归纳、优化、总结、提炼，进而提供给有同样需求的其他项目。以这个雏形不断循环，不仅能够优化整个研发流程，而且能够快速占领市场先机，把握产品竞争优势。&lt;/p&gt;

&lt;p&gt;陈镇洪阐述道，这个平台部应该具备四大特点。&lt;/p&gt;

&lt;p&gt;第一个特点，组件化开发。产品的研发过程可以拆解为一个个被量化的模块，比如底层框架、核心玩法、功能系统，而任何游戏几乎都可以拆解为这三个模块。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;底层框架，包括有游戏管理器、UI框架、网络模块、资源模块、热更新模块、消息事件模块等等，它们彼此之间互相独立，共同组成了一个游戏的骨架；&lt;/li&gt;
&lt;li&gt;核心玩法，不同类型的游戏核心玩法不一样，可以借助动作编辑器、子弹编辑器、AI编辑器、地图事件编辑器等工具实现通用化，避免重复性工作；&lt;/li&gt;
&lt;li&gt;功能系统，包括登陆支付、聊天、角色、装备等，不同游戏的功能系统也不一样。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第二个特点，工具自动化。游戏研发都会经历纯手动开发到流程化、再到自动化的阶段，但重要的是要在研发过程中发现痛点，并形成工具，比如云构建、动作编辑器、地图编辑器等等。其中，云构建很好地解决了手游打包的问题，简化了沟通流程和人员工作量。&lt;/p&gt;

&lt;p&gt;第三个特点，上线标准。上线标准的核心是将上线准备工作拆解组装，以协助项目组顺利完成，主要包括性能优化、机型适配、渠道接入等，这个过程是保障游戏上线的必要工作。&lt;/p&gt;

&lt;p&gt;第四个特征，质量把控。为了保证游戏安全，我们需要在某些研发阶段做几次全面的检查，知道它究竟有没有这样的问题，然后去解决这些事情。&lt;/p&gt;

&lt;p&gt;陈镇洪最后提到，在游戏研发如此激烈的情况下，如何像流水线一样快速有保障地开发一款游戏，是提升公司竞争力以及个人竞争力非常重要的事情。而想要打造研发流水线，有两条路径可以选择：第一条线是项目研发，分为项目立项、研发中以及上线前三个阶段；第二条线则是TDR评审，由评审委员会对项目的各个阶段进行全面的检查。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以下是陈镇洪演讲实录：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;各位来宾，各位同行，大家下午好！我是谷得游戏的技术总监陈镇洪。&lt;/p&gt;

&lt;p&gt;今天我分享的是主题是《谷得游戏如何打造自主研发流水线》。游戏的研发现在越来越激烈，一款游戏不可能从零开始开发，如果做一到两年再上线市场机会就丢失了，像吃鸡游戏，出来第一款，马上出来第二款、第三款。所以当你有一个idea的时候，如何保证快速的高质量研发出来，就是我今天分享的重点。&lt;/p&gt;

&lt;p&gt;过去式的开发模式项目组之间是互相独立的，所以项目组没有互相传承跟积累。举个例子，项目A从零开始研发到上线，项目V立项的时候还是要经历这样的过程。所以导致了各种各样的问题，包括重复制造轮子、重复踩坑、没有质量保证等等。因为项目组之间天然是一种竞争的关系，而且他们也有进度各方面的压力，所以希望他们主动去分享经验是非常难的。&lt;/p&gt;

&lt;p&gt;怎么打破这种局面呢？我的做法是成立一个平台部，类似技术中心的概念，它是各个项目组之间的运转中心。举个例子，项目A将一个比较通用的模块提到平台部，平台部进行归纳、优化、总结、提炼，项目B这时候有需求了，就能够把这个功能给到项目B，项目B减少了研发时间，同时平台部不断研发一些新的工作，将一些功能和工具给到项目A和项目B，也减少了他们的时间。以这个雏形不断循环，整个流程就比较顺畅。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-4b49c776219bd0c21ccfd62849509a79_hd.jpg&quot; alt=&quot;&quot; width=&quot;658&quot; data-rawwidth=&quot;658&quot; data-rawheight=&quot;268&quot; data-original=&quot;https://pic3.zhimg.com/v2-4b49c776219bd0c21ccfd62849509a79_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-4b49c776219bd0c21ccfd62849509a79_b.jpg&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来我将重点说明怎么围绕平台部来做这些事情。&lt;/p&gt;

&lt;p&gt;第一个特征：组件化开发。一个产品的研发过程是可以被拆解为一个个被量化的模块，未来的游戏不会从零开始研发，而是从一个已经研发上线的产品、或者说从已有的基础模块上面进行组装，成为一个新的游戏。就好象你买电脑一样，你的需求可以拆解成一个个硬件配置，然后把这些硬件买回来进行组装，就可以用了。举一个案例，《世界2》是一款argp产品，它的拆解从大的方向、大的概念来讲，可以被拆解为三个部分：底层框架、核心玩法、功能系统。任何游戏，或者大部分游戏都可以拆解为这三个模块。&lt;/p&gt;

&lt;p&gt;首先是底层框架，底层框架包括有游戏管理器、UI框架、网络模块、资源模块、热更新模块、消息事件模块等等各种各样的模块，它们彼此之间是互相独立的，然后把它们组成一个游戏的骨架，类似于一个建筑，它们就是地基，只有这些模块稳定的同时，才能在上面建造出更多花样。其次是核心玩法，不同类型的游戏核心玩法不一样，怎么把这个核心玩法进行拆解呢？战斗副本有什么可以拆解的？一方面它要同步，你可以选择是真同步的技术或者是装了同步的技术，另一方面还可以借助编辑器：动作编辑器中，每个角色都需要有各种各样的动作，以及各种各样技能，你需要有一个强大的工具，可以让策划更加灵活去做这个事情；子弹编辑器中，决定你释放出来的技能是一个暴光还是一个冲击波；AI编辑器中，会包括怪物的行为、树怎么去编辑等等；地图事件编辑器中，一些剧情或者战斗中的陷阱通过这个来做，还有镜头、数据表等等......我们拆分出这些模块之后，在下一次做这种类型游戏的时候就可以完全通用化。而其中的某些模块也可以单独拿出来使用，比如做一个动作游戏，就可以把其中的动作编辑器、AI编辑器拿出来用，而其他模块不需要动，这样就不会重复性工作。最后是功能系统，包括登陆支付、聊天、角色、装备，不同游戏的功能系统也不一样。&lt;/p&gt;

&lt;p&gt;《创造者》是目前公司正在研究的，也是我所负责的一款新产品，是开放世界+沙盒+大规模多人+二次元叙事的一款游戏。从画面上看它是由一个个方块组成的游戏，里面所有的方块和树，甚至远处的栏杆等等各种各样的东西，在这个游戏里面都可以被破坏或者建造。所以如果你很不爽可以把整个山坡、整个树全部砍掉，或者建一个非常漂亮的房子。&lt;/p&gt;

&lt;p&gt;《创造者》的拆解我们是怎么做的呢？它也可以被拆解为几个模块，包括底层框架、核心玩法、功能系统。我们做这个立项的时候，已经有了一定的底层框架和核心玩法的积累，所以整个游戏立项的时候只要解决核心玩法定型的问题，整个游戏的雏形就已经出来了。这个重点是研发工期临时缩减了一半，所以这个前提是策划不要频繁改动需求的前提下。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-7a72d8242801638fdd874684195cd7bc_hd.jpg&quot; alt=&quot;&quot; width=&quot;663&quot; data-rawwidth=&quot;663&quot; data-rawheight=&quot;283&quot; data-original=&quot;https://pic3.zhimg.com/v2-7a72d8242801638fdd874684195cd7bc_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-7a72d8242801638fdd874684195cd7bc_b.jpg&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;刚才说过不同的游戏类型其核心玩法是不一样的，《创造者》核心除了战斗之外还有核心玩法，做每个核心玩法的时候会做技术攻关，把一个新的游戏核心玩法包装利用出来，形成一个组件化的形式。像我们这样的游戏难点是非常大的，因为所有的数据、地形是动态生成的，所以导致不能被烘焙，它必须是通过数据来生成的一个地形。所以要解决很多问题，这个过程中我们遇到很多难点，像数据量比较大、网格内存大：整个游戏里面我们建了一个城堡，城堡所使用方块的数量、家具等加起来大概40多万个，所以肉眼就可以看到40多万个物件，那是非常恐怖的事情；还有大量火把光，玩家可以自己放火把，想放多少火把都可以，没有限制；还有寻路，因为整个地图范围比较大，寻路问题也是必须解决的问题。&lt;/p&gt;

&lt;p&gt;这个游戏的类型也是一片蓝海，所以过程中有很多东西我们都是以先行者的姿态在解决。对此，我们做了一系列的技术攻关。一方面，因为网格内存比较大，所以网格方面我们对一些看不到的地方或者方块与方块之间连接的面，会相应的删减，比如只保留你看到的表面的东西。另一方面，我们会进行定型核定，会以一个小区域进行合并，而不是一下子把整个区域进行合并，在空间力度的把控上更加重视，所以我们大概是以16X16X16个方块作为一个网格。此外，在解决大量火把光问题的时候，我们还自定义了顶点光，实现了顶点颜色的渲染......通过这些实践总结，我们就可以快速做出第二款游戏。&lt;/p&gt;

&lt;p&gt;第二个特征，工具自动化。游戏研发过程中，都会经历从纯手动开发的阶段到流程化、再到自动化的阶段。这个事情其实并不是很难，重点是怎么在研发过程中去发现一些痛点，然后把它做成工具并开发出来，所以对于研发的理解是非常重要的。&lt;/p&gt;

&lt;p&gt;我们做了一些什么样的工具呢？第一是云构建，它解决了手游打包的麻烦事情。举个例子，首先策划会提出程序打包的需求，开发在程序打包的时候不仅要跑到版本机上面先配置好环境、构建完成之后还要经过漫长的等待、打好了还要进行各种参数配置、证书配置、描述文件配置等等，然后继续打包、构建，才能上传和安装下载。整个流程非常烦琐，所以我们做了一键打包，你只需要通过一个按纽，就可以直接得到一个版本。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-36e8d119f7ec3da987c2cbae8961b74d_hd.jpg&quot; alt=&quot;&quot; width=&quot;669&quot; data-rawwidth=&quot;669&quot; data-rawheight=&quot;185&quot; data-original=&quot;https://pic3.zhimg.com/v2-36e8d119f7ec3da987c2cbae8961b74d_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-36e8d119f7ec3da987c2cbae8961b74d_b.jpg&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，里面显示了每个构建版本所需要的时间，平均每个应用构建的时间不到10分钟。通过这个基础的东西我们还做了很多外围的应用，比如像闹钟一样可以定时每天晚上零点的时候打一个包，隔天早上上班的时候就可以看得到，知道今天程序员具体做了哪些工作等等。还有其他一些周边工具，比如资源更新，资源更新是一个很复杂的功能，我们把它做成一个工具流，将复杂的系统转化为简单的操作，并把类似的思想运用到了游戏各流程中去。对于策划来讲，只需要通过这个界面去部署，通过部署好的信息就可以上传、更新和下载资源。此外还有一个SDK聚合，把重复的工作量转化为只做一次，这里面不仅指渠道，还包括很多自定义的组件，比如语音SDK或者苹果的特性ARK等等，我们都把它做成了一个SDK聚合的东西。跟云构建一样，当我点击云构建的时候，我可以选择需要的渠道或者是组件，让它自动聚合上去。整个东西跟我们一开始做底层框架的时候是挂钩在一起的。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-96d5d68c9ab8aa6b3aebeb542c03804a_hd.jpg&quot; alt=&quot;&quot; width=&quot;659&quot; data-rawwidth=&quot;659&quot; data-rawheight=&quot;188&quot; data-original=&quot;https://pic2.zhimg.com/v2-96d5d68c9ab8aa6b3aebeb542c03804a_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-96d5d68c9ab8aa6b3aebeb542c03804a_b.jpg&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;除了一些周边的工具之外，在游戏研发中也需要做一些自动化的工具。&lt;/p&gt;

&lt;p&gt;一是动作编辑器。我们在游戏中的理念之一是尽可能地解放策划思维，策划通过工具和模板就可以把自己想实现的功能做出来，而不需要告诉程序你要怎么做，这个沟通成本是非常大的，同时也限制了策划的思想。动作编辑分为几个模块：其一是角色的定义，包括角色的所有动作、状态和事件，比如具体的普攻信息、动作片断、触发特效等等，每个事件都有不同的编辑面板，分为各种各样参数的配置；其二是中断的定义，当玩家点击了两次技能A再点击技能B，会出现另外一个攻击技能，这时候通过中断定义的配置，会切到另外的动作片断。这两者共同形成了整个动作编辑器。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-afd131121a8ce486fe1dfe4df6229493_hd.jpg&quot; alt=&quot;&quot; width=&quot;568&quot; data-rawwidth=&quot;568&quot; data-rawheight=&quot;349&quot; data-original=&quot;https://pic2.zhimg.com/v2-afd131121a8ce486fe1dfe4df6229493_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-afd131121a8ce486fe1dfe4df6229493_b.jpg&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;二是地图编辑器。地图编辑是游戏开发中非常重要的工具之一，我们专门有两个美术做这样的事情，得力于我们强大的编辑器，让美术在编辑地图的时候完完全全解放了很多机械性、重复性的工作。如下图所示，右边是各种编辑功能，比如画刷、其他区域选择等等。左边是其中的某一个功能，比如地形生成，编辑器中也会有一些地形生成的模板，可以通过配置模板自动生成一个村庄、草原、沙漠或者树林，在这个基础上面再进行修改。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-ce39e1de63b09c16a6ae88998d0ebd99_hd.jpg&quot; alt=&quot;&quot; width=&quot;590&quot; data-rawwidth=&quot;590&quot; data-rawheight=&quot;339&quot; data-original=&quot;https://pic3.zhimg.com/v2-ce39e1de63b09c16a6ae88998d0ebd99_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-ce39e1de63b09c16a6ae88998d0ebd99_b.jpg&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;各种编辑器的目的就是想要解放人员的工作量，无论是程序、策划还是美术。而且我们不仅有这几个编辑器，还有更多的编辑器。&lt;/p&gt;

&lt;p&gt;第三个特征，上线标准。一个游戏上线的时候要做很多事情，比如性能优化、卡断检测、是否发热、会不会内存闪退等等。而上线标准的核心就是将上线准备工作拆解组装，以协助项目组顺利完成，主要包括：性能优化，对项目深度优化，把问题找出来，并给出建议报告；机型适配，适配各种各样的机型以解决兼容性问题；渠道接入，做各种各样SDK的接入。这个过程是保障游戏上线的必要工作，也类似于组件开发的思路一样，把上线一些通用的工作抽离出来，由平台部做这样的事情。因为这些通用化的工作由一个部门去做的时候，它可以不断积累沉淀，所以在做第二个项目的时候，就可以有非常多的经验去解决问题。&lt;/p&gt;

&lt;p&gt;第四个特征，质量把控。为了保证游戏安全，我们需要在某些研发阶段做几次全面的检查，知道它究竟有没有这样的问题，然后去解决这些事情。&lt;/p&gt;

&lt;p&gt;最后总结一下今天讲的内容。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-edf98a4be74f0ede3849760f1ace66f6_hd.jpg&quot; alt=&quot;&quot; width=&quot;661&quot; data-rawwidth=&quot;661&quot; data-rawheight=&quot;266&quot; data-original=&quot;https://pic1.zhimg.com/v2-edf98a4be74f0ede3849760f1ace66f6_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-edf98a4be74f0ede3849760f1ace66f6_b.jpg&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果想要打造研发流水线，有两条路径可以选择。&lt;/p&gt;

&lt;p&gt;第一条线是项目研发，分为三个阶段：项目立项、研发中以及上线前。项目立项的时候，通过组件化减少工作量；而在研发当中可以借助云构建、打包等工具，在过程中不断优化整个项目研发效率；在上线前，确保上线前的质量，比如性能优化、机型适配等等各种各样通用化的工作。这些动作分别在三个不同的阶段进行，会给这个项目做一个全面的支撑。第二条线则是TDR评审。TDR评审是由评审委员会组成的，评审委员应该包括平台部里面的技术专家，以及其他项目的专家，在项目某个阶段的时候进行全面的检查。检测应分为三次：项目立项之后做第一个Demo的时候，第一次测试的时候审查整体的性能和框架，整个游戏正式上线前还会进行更全面的检测，不同阶段的检测内容也不一样。&lt;/p&gt;

&lt;p&gt;所以现在在游戏研发如此激烈的情况下，如何像流水线一样快速地开发一款游戏、有保障地开发一款游戏，是提升你公司竞争力以及个人竞争力非常重要的事情。&lt;/p&gt;

&lt;p&gt;谢谢大家。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.163yun.com/product-secure?tag=M_cnblogs_9480745&quot;&gt;免费试用网易云易盾安全服务&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 04:39:00 +0000</pubDate>
<dc:creator>网易云</dc:creator>
<og:description>本文来自网易云社区。 7月31日，2018云创大会游戏论坛在杭州国际博览中心103B圆满举行。本场游戏论坛聚焦探讨了可能对游戏行业发展有重大推动的新技术、新实践，如AR、区块链、安全、大数据等。 谷得</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/163yun/p/9480745.html</dc:identifier>
</item>
<item>
<title>学在民大-新思路篇 - 舞动的心</title>
<link>http://www.cnblogs.com/liuzhen1995/p/9480682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuzhen1995/p/9480682.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815114901887-2032062249.jpg&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;316&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;一直想好好写这篇《学在民大-新思路篇》，但是一直没有腾出整块时间，来好好写完这篇文章。在中南民族大学的四年学习过程中，新思路实验室给予我的不仅仅是专业知识上面的收获，更是丰富和完善了我的价值观和人生观。下面就按照大学每个学期的时间流程来描述我的学习之旅（PS：当然最关键的还是寒暑假的额外学习时间，这些时间段就默认包含在相应学期末的时间段里，不单独以标题列出）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下列出之前写的我的大学系列篇章：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;我是复读一年后，来到中南民族大学。复读的高考成绩也不理想，可以说是我复读一年来考的最差的一次。虽然是最差的一次，但是我不能够再次选择复读一年。所以，在我进入中南民族大学那一刻开始，我就对自己后续的大学学习生活有了初步规划，并且额外珍惜当前的学习生活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大一上开学前，我打算竞选班级班长。在我之前的学习生涯中，一直是一位普通学生，只会默默的学习。所以，我打算利用大学班长这一职务来锻炼自己的社交综合能力。新生军训结束不久，我如愿竞选成功，成为了我们软件工程1404班班长。当时知道这个消息时，我真的非常开心，可以说是高考失利后，第一次这么开心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于刚开始任职班级干部，以前也没有什么经验，所以大一上的生活过的真的是痛苦加充实，也收获成长了很多。大一上，绝大数的业余时间用于处理班级事务，期间通过学长学姐的宣传了解知道了新思路实验室。当时对专业知识的学习还不是很深入，只了解到新思路实验室里面有很多大神级学长学姐，他们对专业知识充满热情，参加过很多专业性比赛，拿过很多大奖，毕业后的去向有去BAT的，也有进一步深造学习的，感觉就是很厉害。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，在大一上唯一一门专业课《C语言程序设计》我学的特别卖力，而且通过每次实验课的操作，让我更加深刻了解C语言的同时，也让我慢慢的喜欢上了编程。大一上唯一彻底的学习时间就是本学期的最后一个月，这个时间段也刚好是考试月，所有的教学活动以及学院的班级事务或者文艺活动都停止了，每周都会安排几个科目的期末考试，但是大部分比较重要的科目会安排在最后两周考核。所以，对于相应科目的期末备考时间还是比较充裕。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只记得，在大一上最后一个月的期末备考时间段里，我每天都会早上六点钟爬起来去南书院占座，学习到晚上10：00闭馆后离开返回宿舍。这段学习和复习的时间完全是自己一个人在进行规划和复习，不同于高三有老师带的那种。所以，这样的复习模式在刚开始是很痛苦的，感觉大脑很疲劳。不过，最终我是坚持完成了这一个月的复习备考，期末各科考试成绩也都比较理想。每科基本都达到了90分以上，也让我对自己后续的专业学习充满了信心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大一上快要离校前，新思路实验室的学长学姐到我们新生每个专业或者班级都有宣传，让我在寒假时间看看相应的专业书籍，准备大一下开学的实验室各部门小组的招新考核。当时我通过宣传的信息，打算报考数据库组。当时，国内对大数据描述和宣传的很多，而且我当时对这些了解的也不多，就是感觉大数据很火，自己对数据库方面的专业知识也比较感兴趣，所以就选择了报考数据库组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大一上的寒假应该是我大学期间过的最舒畅的一个寒假，寒假期间在家就简单的看了下《数据库系统概论》，翻了下《C语言程序设计》，熟悉下相关的语法技巧。那时我自己还没有笔记本电脑，那是因为学院规定大一上不让带，所以大一上也就没有购买笔记本电脑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;新学期开学第二周的周末就是新思路实验室的招新考核时间，星期六一整天是各个技术小组和部门的笔试考核时间，星期六晚上或者星期天的时间一般是相应小组和部门的面试时间。我们新思路实验室目前技术小组有数据库组、C++组、iOS组、微软技术组、算法组、极客组、JavaEE组、前端组、Android组、产品组和设计组，部门有财务部、宣传部和策划部。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不同技术小组的学习线路不同，之所以划分出这么多技术小组，是为了减少初学者刚开始学习的专业知识任务量，另一方面也是为了让相应同学在某一个方向学习的更加深入。大一上的春招考核，由于报考数据库组的同学不多，加之自己也稍微准备了下，所以很幸运的通过了数据库组的笔试和面试，成为了数据组的一名见习组员。见习时间为3个月，在暑假来临之前会有最终的考核，决定是否成为新思路实验室的正式成员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在见习的3个月时间内，数据库组的学姐（PS：那时我们数据库组没有学长...）给我们新生制定了具体的学习路线和规划。基本上上前一个半月的时间里，每周都会有一次新生技术培训例会，给我讲解学习路线和规划中内容的重难点，带着我们学习。后面一个半月的时间，让我利用自学加上前段时间学习的专业知识，自己设计和搭建一个简单的数据库系统，最好可以写出一个可视化的前端界面来操作相应数据表中的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在大一下五月份，我有了自己的笔记本电脑，感觉非常开心，终于可以有更多的时间在电脑上操作具体的专业知识。大一下班级事务也比较多，特别是班级形象设计大赛，整整准备了一个半月的时间，从前期的策划，到中期的节目排列，到最后的决赛花了很多心思和精力。所以，在这期间对于数据库组的技术学习，只能保证基本的时间来学习，所以表现得也很平常。不过，非常感谢期间数据组的学姐的帮助，让我坚持了下来，也带着我走向了技术学习之路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大一下的暑假，应该是我真正了解技术的时间。在这个暑假，我们组的一位学姐暑假时间留在实验室，带着我和另一位新生同学，一起讨论设计图书馆管理系统。从前期的需求分析讨论，到具体数据库表字段的设计和相关模型设计，以及最终的前端界面的搭建。我们都是一起讨论，并且定期都有碰面会议讨论。这个暑假，让我对于专业知识初步有了一个方向，而且也体会到了专业知识的具体实际作用，学习的兴趣也大大提高了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;进入到了大二上，大我们一届的组员就进入了大三。组内的管理任务就要让我们大二成员来进行管理，此刻也要开始准备招新一届的大一成员。当时我接任了我们数据组的行政组长，主要负责每周的技术例会安排，以及相关事务的通知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大二上的技术学习例会主要是由我来组织，期间要和指导老师协商好大致的技术学习路线。我们大二这一届当时主要学习了下SQLServer的报表服务以及非关系型MongoDB数据库，期间技术组长还展示了下如何使用C#搭建简单的前端界面，用于操作我们自己设计搭建的数据库中的数据。我自己在期间，则使用Java的Swing控件搭建了一个课程管理系统的前端界面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大二上我花在实验室的学习时间相对于大一下来说，还是比较多的，因为这个时间段班级事务比较少。但是，由于我担任了笛箫协会笛二组的组长，需要每天晚上去南区操作，教新生练习吹笛子。所以，在大二上的技术学习过程中，我的付出时间还是没有实验室其它技术小组组长花的时间多，也就是说当时我在我们14级实验室成员里面，技术还是比较菜的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而，正在开始新思路实验室的技术学习之路是在大二上11月份。到了11月份之后，实验室每周的行政例会就开始宣传动员各个小组同学准备参加微软创新杯比赛以及大学生创新创业项目的申请。这时准备这些比赛的主力军刚好就是我们大二成员，从11月份开始，专业课程也快进入到了尾声，也要开始着手准备相关科目的期末考试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只记得当时为了准备微软创新杯比赛报名材料以及大学生创新创业项目的申请文档材料以及答辩材料，我们数据库组大二成员，在实验室差不多有连续一周的时间待到晚上11点才回宿舍，期间还包夜了三四天的时间。现在想想都感觉很疯狂，因为备考期间还要完成比赛相关材料的准备，晚上安静不会受到打扰，所以选择来实验室包夜，完成相关任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;大二下应该是我技术学习的快车道，这个时间段各个技术小组的主力军都是大二成员。因为大三成员忙着找工作或者复习考研相关事务，基本上不会来实验室，也不会参与到实验室的管理。而这段时间也是各个专业比赛的准备黄金时间，基本上每年的5、6、7、8月份都会有相应比赛的初赛或者决赛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在大二下，我的时间基本上都花在了技术的学习上，社团班级相关事务花的时间基本上很少。在大二下，我作为主要成员报名参加了‘互联网+’比赛，以及计算机设计大赛。‘互联网+’比赛，需要完成一份商业策划书，主要目的在于推广本项目的核心亮点以及商业卖点。计算机设计大赛需完成的项目正好也是我后面毕业设计采用的项目——《最炫广场舞》APP，我当时负责安卓端的设计及界面搭建。当时，我对于Android技术一点都不了解，仅仅学了下Java的基础语法知识。所以，为了完成该项目的第一版，我花了三个月时间从零基础到晚上该项目的所有界面搭建。现在想想，还感觉很有成就感。因为，大二下专业课程也很多，我只能在每天的业余时间看书学习，也基本上是在实验室里度过。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而，非常遗憾的是我们报名参加计算机设计大赛的这个项目没有进入决赛。主要问题还是我们的项目完成度不够高，也是自己对于Andorid前端的学习时间不够，其中的部分功能设计与实现不够好。虽然，这个项目未能进入最终的比赛，但是在这个比赛的准备过程中，让我学会了Andorid前端界面的搭建，也对专业知识有了更进一步的了解。对应着那一句话：虽然结果不够好，但是过程是充实的，最终的收获也是非常大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;期间准备的‘互联网+’比赛的项目，进入了湖北省复赛，当时指导老师带我们参赛的小组同学去黄冈市参加了本届比赛的复赛。比赛期间的住宿和用餐全是组委会解决，住宿和用餐条件基本上是黄冈市内最好的招待。最终我们报名参加的项目，在八只队伍答辩中拿到了第5名，荣获了湖北省‘互联网+’省赛铜奖。虽然成绩一般，但是这次外出比赛体验还是很不错呀，通过其它高校同学的项目，也学习收获了很多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这期间，我自己还报名参加了第七届蓝桥杯个人赛。但是由于自己还报名参加了其它比赛，所以在这个个人赛的准备上基本没有花时间，所以仅仅去打了一个酱油，什么奖项也没有拿到，当时也挺打击自己的自信心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在后面还和实验室的JavaEE组、Android组同学一起组成了一个5人小组，报名参加了第七届服务外包大赛。我负责项目后端的数据库设计及搭建，JavaEE同学负责相关接口功能的实现，Android组同学负责完成本项目的Android界面的设计与搭建，并结合相关接口实现整个项目的运转。团队的协作能力还是强大的，不同技术小组的擅长也快速推动中项目的完成进度。最终我们报名参加的作品荣获了全国三等奖，作品的完善度只能说是达到了70%。虽然没能取得更好的成绩，但是对于我们一组全是大二成员的同学来说，得到的鼓励还是蛮大的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在准备参加各大比赛的期间，我还接任了新思路实验高层管理岗位——理事长，主要负责实验室内部各大比赛文档的整理以及成员信息的搜集和管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大二下的暑假我也是基本上呆在实验室，自己琢磨学习了下JavaEE方面的SSH框架，并且使用相应框架搭建实现了用户登陆注册功能，对接口的初步实现和应用有了初步认识和了解。期间，也简单学习了下HTML和JavaScript技术。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;展示一张大二下5月份我带着我们数据库组同学去木兰草原玩耍的合照（PS：是不是很有爱^-^）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815115340312-503061783.jpg&quot; alt=&quot;&quot; width=&quot;541&quot; height=&quot;678&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;进入大三上后，我自己对于专业知识方面了解的更多了，对新思路实验室各个技术小组的学习方向了解也比较全面，对自己的技术兴趣点也基本确定。期间主要带带大二的组员开每周的技术例会，以及负责实验室内部的行政事务。业余时间主要花在专业课的学习，以及自己感兴趣的技术点上面。基本上不会再去准备参加各大专业比赛，这些比赛的的参与者主力军由大二成员来担任。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一阶段虽然感觉没有大二开始的迷茫，以及后续的事务繁忙。但是这个关键时间段，让我们自己思考后续的专业从事方向，以及自己对毕业去向的思考。这个时间段，我深深的反思了下自己在大二学年的学习历程，总结出一点：要在某个方向取得好的成绩，就必须花费足够的时间和精力才能够实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这期间，我也体会到算法对于我们专业的重要性。所以，在大三上开启算法课程时，我便认真地完成了每一次的实验课程任务，并且还额外完成了隔壁班老师布置的实验任务。并报名参加了第八届蓝桥杯个人赛Java组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大三上的寒假，我在家基本上是在刷《算法设计与分析基础》课本上的示例习题，并认真理解其中每一个算法思想，让我深深的体会到了算法的魅力。&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;大三下开学后不久，理事长就要换届，我基本上不参与实验室的行政管理事务以及小组内的每周技术分享例会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;开学后，我每天的时间基本上都花在了蓝桥杯个人赛备赛刷题上了。这个学期专业课程比较少，业余时间充裕。我每天刷的算法题差不多会有10道题，并且完成了每道题考察技术点的理解和总结。最终幸运的拿到了省赛一等奖，获得了去北京参加决赛的机会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;省赛结束，距离决赛还有一个半月的时间。这一个半月的时间，我也差不多是天天待在宿舍刷算法题。把蓝桥杯个人赛的历年真题都刷了一遍。最终去北京参加决赛时，拿了全国二等奖。虽然与一等奖失之交臂，但是这份准备比赛的历程也让我收获很多。比如，第一次去北京，还是代表学校去参加比赛，期间的住宿和来往车费都是学校报销，感觉美滋滋。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个比赛结束后，这也差不多是我在新思路实验室的全部学习历程，现在回想都感觉在实验室的学习很充实。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大三下的暑假在完成专业实习和准备考研复习的历程度过，没有回家。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在此，展示一张我去北京参加蓝桥杯决赛期间和同学去天安门游玩拍摄的图片（PS：很兴奋，终于站在了只能在电视里面看到的天安门前面拍照）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815120128435-28209551.png&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;652&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;大四上开学后，学院通知评选推免生。我的专业绩点由于大二大三参加比赛较多，落下了不少，但是我凭着自己参加比赛得奖的综合评分最终还是取得了我们软件工程专业第一名，获得了我们专业推免生名额之一，最后选择了去华南理工大学进一步深造读研。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;我们团结的软工1404班同学毕业部分合照：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815120535581-483082733.png&quot; alt=&quot;&quot; width=&quot;1097&quot; height=&quot;689&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815120611044-1685914586.png&quot; alt=&quot;&quot; width=&quot;1103&quot; height=&quot;678&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815120648472-396654135.png&quot; alt=&quot;&quot; width=&quot;1104&quot; height=&quot;715&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815120751641-1215475774.png&quot; alt=&quot;&quot; width=&quot;1104&quot; height=&quot;723&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;摘 要&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;广场舞在国内越来越受到广大中老年群体的喜爱，舞群组织不规范导致扰民问题时有发生、舞蹈教学视频缺乏导致广场舞爱好者训练难等问题。为了解决上述问题，设计和研发了最炫广场舞APP。本系统设计下列功能需求：1）提供周边舞群功能，规范市民周边舞群活动地点，并且做好登记和管理工作；2）提供当前热门舞蹈教学视频以及用户视频上传分享功能；3）提供周边舞具商品推荐功能；4）提供舞友交流功能。移动端基于Android实现，后台管理功能基于Python的Flask框架实现，数据库采用非关系型数据库MongoDB来搭建。系统所需图片、视频等文件信息存放在Apache服务器上，后端具体服务和文件存放部署在阿里云服务器上。全文由四部分组成：1）前言，介绍系统的相关背景；2）需求分析，介绍系统的具体功能需求模块及性能需求；3）系统设计，介绍系统的概要设计、详细设计和数据库设计；4）调试与分析，介绍系统基本功能调试结果。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;部分界面设计图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815120940670-831531964.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815120952076-709278953.png&quot; alt=&quot;&quot; width=&quot;333&quot; height=&quot;572&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815121028959-1133211286.png&quot; alt=&quot;&quot; width=&quot;326&quot; height=&quot;572&quot;/&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815121058355-70338475.png&quot; alt=&quot;&quot; width=&quot;320&quot; height=&quot;571&quot;/&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/927750/201808/927750-20180815121127272-408408659.png&quot; alt=&quot;&quot; width=&quot;335&quot; height=&quot;569&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;项目开源GitHub链接：&lt;a href=&quot;https://github.com/miaomiaoqiushui/TheBestSquareDance&quot; target=&quot;_blank&quot;&gt;https://github.com/miaomiaoqiushui/TheBestSquareDance&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 15 Aug 2018 04:14:00 +0000</pubDate>
<dc:creator>舞动的心</dc:creator>
<og:description>写在前面 一直想好好写这篇《学在民大-新思路篇》，但是一直没有腾出整块时间，来好好写完这篇文章。在中南民族大学的四年学习过程中，新思路实验室给予我的不仅仅是专业知识上面的收获，更是丰富和完善了我的价值</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuzhen1995/p/9480682.html</dc:identifier>
</item>
<item>
<title>彻底告别加解密模块代码拷贝-JCE核心Cpiher详解 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9480540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9480540.html</guid>
<description>&lt;p&gt;javax.crypto.Cipher，翻译为密码，其实叫做&lt;strong&gt;密码器&lt;/strong&gt;更加合适。Cipher是JCA(Java Cryptographic Extension，Java加密扩展)的核心，提供基于多种加解密算法的加解密功能。在不了解Cipher之前，我们在完成一些需要加解密的模块的时候总是需要到处拷贝代码，甚至有些错误的用法也被无数次拷贝，踩坑之后又要拷贝补坑的代码。为什么不尝试理解Cipher然后合理地使用呢？&lt;/p&gt;

&lt;p&gt;转换模式transformation一般由三个部分组成，格式是：&lt;strong&gt;算法/工作模式/填充模式(algorithm/mode/padding)&lt;/strong&gt;。例如：DES/CBC/PKCS5Padding。&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;算法&lt;/h2&gt;
&lt;p&gt;算法就是指具体加解密算法的名称英文字符串，例如&quot;SHA-256&quot;、&quot;RSA&quot;等，这里不对具体算法的实现原理做具体展开。&lt;/p&gt;
&lt;h2 id=&quot;工作模式&quot;&gt;工作模式&lt;/h2&gt;
&lt;p&gt;工作模式其实主要是针对分组密码。分组密码是将明文消息编码表示后的数字（简称明文数字）序列，划分成长度为n的组（可看成长度为n的矢量），每组分别在密钥的控制下变换成等长的输出数字（简称密文数字）序列。工作模式的出现主要基于下面原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当需要加密的明文长度十分大(例如文件内容)，由于硬件或者性能原因需要分组加密。&lt;/li&gt;
&lt;li&gt;多次使用相同的密钥对多个分组加密，会引发许多安全问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从本质上讲，工作模式是一项增强密码算法或者使算法适应具体应用的技术，例如将分组密码应用于数据块组成的序列或者数据流。目前主要包括下面五种由NIST定义的工作模式：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;电子密码本(ECB)&lt;/td&gt;
&lt;td&gt;Electronic CodeBook&lt;/td&gt;
&lt;td&gt;用相同的密钥分别对明文分组独立加密&lt;/td&gt;
&lt;td&gt;单个数据的安全传输(例如一个加密密钥)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;密码分组链接(CBC)&lt;/td&gt;
&lt;td&gt;Cipher Block Chaining&lt;/td&gt;
&lt;td&gt;加密算法的输入是上一个密文组合下一个明文组的异或&lt;/td&gt;
&lt;td&gt;面向分组的通用传输或者认证&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;密文反馈(CFB)&lt;/td&gt;
&lt;td&gt;Cipher FeedBack&lt;/td&gt;
&lt;td&gt;一次处理s位，上一块密文作为加密算法的输入，产生的伪随机数输出与明文异或作为下一单元的密文&lt;/td&gt;
&lt;td&gt;面向分组的通用传输或者认证&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;输出反馈(OFB)&lt;/td&gt;
&lt;td&gt;Output FeedBack&lt;/td&gt;
&lt;td&gt;与CFB类似，只是加密算法的输入是上一次加密的输出，并且使用整个分组&lt;/td&gt;
&lt;td&gt;噪声信道上的数据流的传输(如卫星通信)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;计数器(CTR)&lt;/td&gt;
&lt;td&gt;Counter&lt;/td&gt;
&lt;td&gt;每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增&lt;/td&gt;
&lt;td&gt;面向分组的通用传输或者用于高速需求&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上面五种工作模式可以用于3DES和AES在内的任何分组密码，至于选择哪一种工作模式需要结合实际情况分析。&lt;/p&gt;
&lt;h2 id=&quot;填充模式&quot;&gt;填充模式&lt;/h2&gt;
&lt;p&gt;Padding指的是：块加密算法要求原文数据长度为固定块大小的整数倍，如果原文数据长度大于固定块大小，则需要在固定块填充数据直到整个块的数据是完整的。例如我们约定块的长度为128，但是需要加密的原文长度为129，那么需要分成两个加密块，第二个加密块需要填充127长度的数据，填充模式决定怎么填充数据。&lt;/p&gt;
&lt;p&gt;对数据在加密时进行填充、解密时去除填充则是通信双方需要重点考虑的因素。对原文进行填充，主要基于以下原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，考虑安全性。由于对原始数据进行了填充，使原文能够“伪装”在填充后的数据中，使得攻击者很难找到真正的原文位置。&lt;/li&gt;
&lt;li&gt;其次，由于块加密算法要求原文数据长度为固定块大小的整数倍，如果加密原文不满足这个条件，则需要在加密前填充原文数据至固定块大小的整数倍。&lt;/li&gt;
&lt;li&gt;另外，填充也为发送方与接收方提供了一种标准的形式以约束加密原文的大小。只有加解密双方知道填充方式，才可知道如何准确移去填充的数据并进行解密。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用的填充方式至少有5种，不同编程语言实现加解密时用到的填充多数来自于这些方式或它们的变种方式。以下五种填充模式摘抄自参考资料的论文：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.填充数据为填充字节序列的长度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种填充方式中，填充字符串由一个字节序列组成，每个字节填充该字节序列的长度。假定块长度为8，原文数据长度为9，则填充字节数 等于0x07；如果明文数据长度为8的整数倍，则填充字节数为0x08。填充字符串如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原文数据1: FF FF FF FF FF FF FF FF FF&lt;/li&gt;
&lt;li&gt;填充后数据1:FF FF FF FF FF FF FF FF FF 07 07 07 07 07 07 07&lt;/li&gt;
&lt;li&gt;==========================================================&lt;/li&gt;
&lt;li&gt;原文数据2:FF FF FF FF FF FF FF FF&lt;/li&gt;
&lt;li&gt;填充后数据2:FF FF FF FF FF FF FF FF 08 08 08 08 08 08 08 08&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2.填充数据为0x80后加0x00&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种填充方式中，填充字符串的第一个字节数是0x80，后面的每个字节是0x00。假定块长度为8，原文数据长度为9或者为8的整数倍，则 填充字符串如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原文数据1: FF FF FF FF FF FF FF FF FF&lt;/li&gt;
&lt;li&gt;填充后数据1:FF FF FF FF FF FF FF FF FF 80 00 00 00 00 00 00&lt;/li&gt;
&lt;li&gt;==========================================================&lt;/li&gt;
&lt;li&gt;原文数据2:FF FF FF FF FF FF FF FF&lt;/li&gt;
&lt;li&gt;填充后数据2:FF FF FF FF FF FF FF FF 80 00 00 00 00 00 00 00&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3.填充数据的最后一个字节为填充字节序列的长度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种填充方式中，填充字符串的最后一个字节为该序列的长度，而前面的字节可以是0x00，也可以是随机的字节序列。假定块长度为8，原文数据长度为9或者为8的整数倍，则填充字符串如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原文数据1:FF FF FF FF FF FF FF FF FF&lt;/li&gt;
&lt;li&gt;填充后数据1:FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 07或FF FF FF FF FF FF FF FF FF 0A B0 0C 08 05 09 07&lt;/li&gt;
&lt;li&gt;===============================================================================&lt;/li&gt;
&lt;li&gt;原文数据2:FF FF FF FF FF FF FF FF&lt;/li&gt;
&lt;li&gt;填充后数据2:FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 08或FF FF FF FF FF FF FF FF 80 06 AB EA 03 02 01 08&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4.填充数据为空格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种填充方式中，填充字符串的每个字节为空格对应的字节数0x20。假定块长度为8，原文数据长度为9或者为8的整数倍，则填充字符串如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原文数据1: FF FF FF FF FF FF FF FF FF&lt;/li&gt;
&lt;li&gt;填充后数据1:FF FF FF FF FF FF FF FF FF 20 20 20 20 20 20 20&lt;/li&gt;
&lt;li&gt;===============================================================================&lt;/li&gt;
&lt;li&gt;原文数据2:FF FF FF FF FF FF FF FF&lt;/li&gt;
&lt;li&gt;填充后数据2:FF FF FF FF FF FF FF FF 20 20 20 20 20 20 20 20&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;5.填充数据为0x00&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种填充方式中，填充字符串的每个字节为0x00。假定块长度为8，原文数据长度为9或者8的整数倍，则填充字符串如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原文数据1: FF FF FF FF FF FF FF FF FF&lt;/li&gt;
&lt;li&gt;填充后数据1:FF FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00&lt;/li&gt;
&lt;li&gt;===============================================================================&lt;/li&gt;
&lt;li&gt;原文数据2:FF FF FF FF FF FF FF FF&lt;/li&gt;
&lt;li&gt;填充后数据2:FF FF FF FF FF FF FF FF 00 00 00 00 00 00 00 00&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;transformation小结&quot;&gt;transformation小结&lt;/h2&gt;
&lt;p&gt;SunJCE Provider支持的Cipher的部分详细信息如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;AES&lt;/td&gt;
&lt;td&gt;EBC、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128等&lt;/td&gt;
&lt;td&gt;NoPadding、ISO10126Padding、PKCS5Padding&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;AESWrap&lt;/td&gt;
&lt;td&gt;EBC&lt;/td&gt;
&lt;td&gt;NoPadding&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ARCFOUR&lt;/td&gt;
&lt;td&gt;EBC&lt;/td&gt;
&lt;td&gt;NoPadding&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;Blowfish、DES、DESede、RC2&lt;/td&gt;
&lt;td&gt;EBC、CBC、PCBC、CTR、CTS、CFB、CFB8-CFB128等&lt;/td&gt;
&lt;td&gt;NoPadding、ISO10126Padding、PKCS5Padding&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DESedeWrap&lt;/td&gt;
&lt;td&gt;CBC&lt;/td&gt;
&lt;td&gt;NoPadding&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PBEWithMD5AndDES、PBEWithMD5AndTripleDES、PBEWithSHA1AndDESede、PBEWithSHA1AndRC2_40&lt;/td&gt;
&lt;td&gt;CBC&lt;/td&gt;
&lt;td&gt;PKCS5Padding&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RSA&lt;/td&gt;
&lt;td&gt;ECB、NONE&lt;/td&gt;
&lt;td&gt;NoPadding、PKCS1Padding等&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;Java原生支持的Padding(Cipher)汇总如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;NoPadding&lt;/td&gt;
&lt;td&gt;不采用填充模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ISO10126Padding&lt;/td&gt;
&lt;td&gt;XML加密语法和处理文档中有详细描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;OAEPPadding, OAEPWith&amp;lt;digest&amp;gt;And&amp;lt;mgf&amp;gt;Padding&lt;/td&gt;
&lt;td&gt;PKCS1中定义的最优非对称加密填充方案，digest代表消息摘要类型，mgf代表掩码生成函数，例如：OAEPWithMD5AndMGF1Padding或者OAEPWithSHA-512AndMGF1Padding&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;PKCS1Padding&lt;/td&gt;
&lt;td&gt;PKCS1，RSA算法使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;PKCS5Padding&lt;/td&gt;
&lt;td&gt;PKCS5，RSA算法使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SSL3Padding&lt;/td&gt;
&lt;td&gt;见SSL Protocol Version 3.0的定义&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其他Padding需要第三方Provider提供。&lt;/p&gt;

&lt;h2 id=&quot;cipher的七个主要公有属性&quot;&gt;Cipher的七个主要公有属性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;1、ENCRYPT_MODE，整型值1，加密模式，用于Cipher的初始化。&lt;/li&gt;
&lt;li&gt;2、DECRYPT_MODE，整型值2，解密模式，用于Cipher的初始化。&lt;/li&gt;
&lt;li&gt;3、WRAP_MODE，整型值3，包装密钥模式，用于Cipher的初始化。&lt;/li&gt;
&lt;li&gt;4、UNWRAP_MODE，整型值4，解包装密钥模式，用于Cipher的初始化。&lt;/li&gt;
&lt;li&gt;5、PUBLIC_KEY，整型值1，解包装密钥模式下指定密钥类型为公钥。&lt;/li&gt;
&lt;li&gt;6、PRIVATE_KEY，整型值2，解包装密钥模式下指定密钥类型为私钥。&lt;/li&gt;
&lt;li&gt;7、SECRET_KEY，整型值3，解包装密钥模式下指定密钥类型为密钥，主要用于不是非对称加密的密钥(只有一个密钥，不包含私钥和公钥)。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;cipher的主要方法&quot;&gt;Cipher的主要方法&lt;/h2&gt;
&lt;h3 id=&quot;getinstance方法&quot;&gt;getInstance方法&lt;/h3&gt;
&lt;p&gt;Cipher提供三个静态工厂方法getInstance用于构建其实例，三个方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static final Cipher getInstance(String transformation)
                                throws NoSuchAlgorithmException,
                                       NoSuchPaddingException

public static final Cipher getInstance(String transformation,
                                       String provider)
                                throws NoSuchAlgorithmException,
                                       NoSuchProviderException,
                                       NoSuchPaddingException

public static final Cipher getInstance(String transformation,
                                       Provider provider)
                                throws NoSuchAlgorithmException,
                                       NoSuchPaddingException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中transformation，这里称为&lt;strong&gt;转换(模式)&lt;/strong&gt;，是核心参数，见前面一个小节的解析。另外，有两个工厂方法要求必须传入java.security.Provider的全类名或者实例，因为Cipher要从对应的提供商中获取指定转换模式的实现，第一个工厂方法只有单参数transformation，它会从现成所有的java.security.Provider中匹配取出第一个满足transformation的服务，从中实例化CipherSpi(&lt;strong&gt;要理解Cipher委托到内部持有的CipherSpi实例完成具体的加解密功能&lt;/strong&gt;)。实际上Cipher实例的初始化必须依赖于转换模式和提供商。&lt;/p&gt;
&lt;h3 id=&quot;init方法&quot;&gt;init方法&lt;/h3&gt;
&lt;p&gt;init方法一共有八个变体方法，此方法主要用于初始化Cipher。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//额外参数是Key(密钥)
public final void init(int opmode,
                       Key key)
                throws InvalidKeyException

//额外参数是Key(密钥)和SecureRandom(随机源)
public final void init(int opmode,
                       Key key,
                       SecureRandom random)
                throws InvalidKeyException

//额外参数是Key(密钥)和AlgorithmParameterSpec(算法参数透明定义)
public final void init(int opmode,
                       Key key,
                       AlgorithmParameterSpec params)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException 

//额外参数是Key(密钥)、AlgorithmParameterSpec(算法参数透明定义)和SecureRandom(随机源)
public final void init(int opmode,
                       Key key,
                       AlgorithmParameterSpec params,
                       SecureRandom random)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException

//额外参数是Key(密钥)、AlgorithmParameters(算法参数)
public final void init(int opmode,
                       Key key,
                       AlgorithmParameters params)
                throws InvalidKeyException,
                       InvalidAlgorithmParameterException

//额外参数是Key(密钥)、AlgorithmParameters(算法参数)、SecureRandom(随机源)
public final void init(int opmode,
                       Key key,
                       AlgorithmParameters params,
                       SecureRandom random)
                    throws InvalidKeyException,
                       InvalidAlgorithmParameterException

//额外参数是Certificate(证书)
public final void init(int opmode,
                       Certificate certificate)
                throws InvalidKeyException

//额外参数是Certificate(证书)、SecureRandom(随机源)
public final void init(int opmode,
                       Certificate certificate,
                       SecureRandom random)
                throws InvalidKeyException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;opmode(操作模式)是必须参数，可选值是ENCRYPT_MODE、DECRYPT_MODE、WRAP_MODE和UNWRAP_MODE。Key类型参数如果不是非对称加密，对应的类型是SecretKey，如果是非对称加密，可以是PublicKey或者PrivateKey。SecureRandom是随机源，因为有些算法需要每次加密结果都不相同，这个时候需要依赖系统或者传入的随机源，一些要求每次加解密结果相同的算法如AES不能使用此参数(或者必须指定固定的随机源种子)。Certificate是带有密钥的证书实现。算法参数主要包括IV(initialization vector，初始化向量)等等。&lt;/p&gt;
&lt;h3 id=&quot;wrap方法和unwrap方法&quot;&gt;wrap方法和unwrap方法&lt;/h3&gt;
&lt;p&gt;wrap方法用于包装一个密钥。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final byte[] wrap(Key key)
                  throws IllegalBlockSizeException,
                         InvalidKeyException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wrap方法使用的时候需要注意Cipher的opmode要初始化为WRAP_MODE。&lt;/p&gt;
&lt;p&gt;unwrap方法用于解包装一个密钥。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final Key unwrap(byte[] wrappedKey,
                        String wrappedKeyAlgorithm,
                        int wrappedKeyType)
                 throws InvalidKeyException,
                        NoSuchAlgorithmException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;unwrap方法使用的时候需要注意Cipher的opmode要初始化为UNWRAP_MODE，在调用unwrap方法时候，需要指定之前包装密钥的算法和Key的类型。&lt;/p&gt;
&lt;p&gt;其实wrap和unwrap是一个互逆的操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;wrap方法的作用是把原始的密钥通过某种加密算法包装为加密后的密钥，这样就可以避免在传递密钥的时候泄漏了密钥的明文。&lt;/li&gt;
&lt;li&gt;unwrap方法的作用是把包装(加密)后的密钥解包装为原始的密钥，得到密钥的明文。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum EncryptUtils {

    /**
     * 单例
     */
    SINGLETON;

    private static final String SECRECT = &quot;passwrod&quot;;

    public String wrap(String keyString) throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        //初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是&quot;passward&quot;)
        keyGenerator.init(128, new SecureRandom(SECRECT.getBytes()));
        SecretKey secretKey = keyGenerator.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);
        Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
        cipher.init(Cipher.WRAP_MODE, secretKeySpec);
        SecretKeySpec key = new SecretKeySpec(keyString.getBytes(), &quot;AES&quot;);
        byte[] bytes = cipher.wrap(key);
        return Hex.encodeHexString(bytes);
    }

    public String unwrap(String keyString) throws Exception {
        byte[] rawKey = Hex.decodeHex(keyString);
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        //初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是&quot;passward&quot;)
        keyGenerator.init(128, new SecureRandom(SECRECT.getBytes()));
        SecretKey secretKey = keyGenerator.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);
        Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
        cipher.init(Cipher.UNWRAP_MODE, secretKeySpec);
        SecretKey key = (SecretKey) cipher.unwrap(rawKey, &quot;AES&quot;, Cipher.SECRET_KEY);
        return new String(key.getEncoded());
    }

    public static void main(String[] args) throws Exception {
        String wrapKey = EncryptUtils.SINGLETON.wrap(&quot;doge&quot;);
        System.out.println(wrapKey);
        System.out.println(EncryptUtils.SINGLETON.unwrap(wrapKey));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子是通过AES对密钥进行包装和解包装，调用main方法，输出：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;77050742188d4b97a1d401db902b864d
doge&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;update方法&quot;&gt;update方法&lt;/h3&gt;
&lt;p&gt;update方法有多个变体，其实意义相差无几：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final byte[] update(byte[] input)

public final byte[] update(byte[] input,
                           int inputOffset,
                           int inputLen)

public final int update(byte[] input,
                        int inputOffset,
                        int inputLen,
                        byte[] output)
                 throws ShortBufferException    

public final int update(ByteBuffer input,
                        ByteBuffer output)
                 throws ShortBufferException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;update方法主要用于部分加密或者部分解密，至于加密或是解密取决于Cipher初始化时候的opmode。即使它有多个变体，但是套路是一样的：依赖于一个输入的缓冲区(带有需要被加密或者被解密的数据)、返回值或者参数是一个输出的缓冲区，一些额外的参数可以通过偏移量和长度控制加密或者解密操作的数据段。部分加密或者解密操作完毕后，必须要调用&lt;code&gt;Cipher#doFinal()&lt;/code&gt;方法来结束加密或者解密操作。&lt;/p&gt;
&lt;h3 id=&quot;dofinal方法&quot;&gt;doFinal方法&lt;/h3&gt;
&lt;p&gt;doFinal方法也存在多个变体：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 结束多部分加密或者解密操作。
 * 此方法需要在update调用链执行完毕之后调用，返回的结果是加密或者解密结果的一部分。
 * 此方法正常调用结束之后Cipher会重置为初始化状态。
 */
public final byte[] doFinal()
                     throws IllegalBlockSizeException,
                            BadPaddingException

/**
 * 结束多部分加密或者解密操作。
 * 此方法需要在update调用链执行完毕之后调用，传入的output作为缓冲区接收加密或者解密结果的一部分。
 * 此方法正常调用结束之后Cipher会重置为初始化状态。
 */
public final int doFinal(byte[] output,
                         int outputOffset)
                  throws IllegalBlockSizeException,
                         ShortBufferException,
                         BadPaddingException                         

/**
 * 结束单部分加密或者解密操作。
 * 此方法接收需要加密或者解密的完整报文，返回处理结果
 * 此方法正常调用结束之后Cipher会重置为初始化状态。
 */
public final byte[] doFinal(byte[] input)
                     throws IllegalBlockSizeException,
                            BadPaddingException

/**
 * 结束单部分或者多部分加密或者解密操作。
 * 参数inputOffset为需要加解密的报文byte数组的起始位置，inputLen为需要加密或者解密的字节长度
 * 此方法正常调用结束之后Cipher会重置为初始化状态。
 */
public final byte[] doFinal(byte[] input,
                            int inputOffset,
                            int inputLen)
                     throws IllegalBlockSizeException,
                            BadPaddingException      

/**
 * 结束单部分或者多部分加密或者解密操作。
 * 参数inputOffset为需要加解密的报文byte数组的起始位置，inputLen为需要加密或者解密的字节长度，output用于接收加解密的结果
 * 此方法正常调用结束之后Cipher会重置为初始化状态。
 */
public final int doFinal(byte[] input,
                         int inputOffset,
                         int inputLen,
                         byte[] output)
                  throws ShortBufferException,
                         IllegalBlockSizeException,
                         BadPaddingException                                                         

/**
 * 结束单部分或者多部分加密或者解密操作。
 * 参数inputOffset为需要加解密的报文byte数组的起始位置，inputLen为需要加密或者解密的字节长度，
 * output用于接收加解密的结果，outputOffset用于设置output的起始位置
 * 此方法正常调用结束之后Cipher会重置为初始化状态。
 */
public final int doFinal(byte[] input,
                         int inputOffset,
                         int inputLen,
                         byte[] output,
                         int outputOffset)
                  throws ShortBufferException,
                         IllegalBlockSizeException,
                         BadPaddingException 
/**
 * 结束单部分或者多部分加密或者解密操作。
 * 参数input为输入缓冲区，output为输出缓冲区
 * 此方法正常调用结束之后Cipher会重置为初始化状态。
 */
public final int doFinal(ByteBuffer input,
                         ByteBuffer output)
                  throws ShortBufferException,
                         IllegalBlockSizeException,
                         BadPaddingException                                              &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;doFinal主要功能是结束单部分或者多部分加密或者解密操作。单部分加密或者解密适用于需要处理的报文长度较短无需分块的情况，这个时候直接使用&lt;code&gt;byte[] doFinal(byte[] input)&lt;/code&gt;方法即可。多部分加密或者解密适用于需要处理的报文长度长度较大，需要进行分块的情况，这个时候需要调用多次&lt;code&gt;update&lt;/code&gt;方法变体进行部分块的加解密，最后调用&lt;code&gt;doFinal&lt;/code&gt;方法变体进行部分加解密操作的结束。举个例子，例如处理块的大小为8，实际需要加密的报文长度为23，那么需要分三块进行加密，前面2块长度为8的报文需要调用update进行部分加密，部分加密的结果可以从update的返回值获取到，最后的7长度(其实一般会填充到长度为块长度8)的报文则调用doFinal进行加密，结束整个部分加密的操作。另外，值得注意的是只要Cipher正常调用完任一个&lt;code&gt;doFinal&lt;/code&gt;变体方法(过程中不抛出异常)，那么Cipher会重置为初始化状态，可以继续使用，这个可复用的特性可以降低创建Cipher实例的性能损耗。&lt;/p&gt;
&lt;h3 id=&quot;updateadd方法&quot;&gt;updateADD方法&lt;/h3&gt;
&lt;p&gt;首先ADD的意思是Additional Authentication Data(额外的身份认证数据)。updateADD也有三个方法变体：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void updateAAD(byte[] src)

public final void updateAAD(byte[] src,
                            int offset,
                            int len)

public final void updateAAD(ByteBuffer src)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的方法变体都只依赖一个输入缓冲区，带有额外的身份认证数据，一般使用在&lt;code&gt;GCM&lt;/code&gt;或者&lt;code&gt;CCM&lt;/code&gt;加解密算法中。如果使用此方法，它的调用必须在Cipher的&lt;code&gt;update&lt;/code&gt;和&lt;code&gt;doFinal&lt;/code&gt;变体方法之前调用，其实理解起来也很简单，身份验证必须在实际的加解密操作之前进行。目前，&lt;code&gt;updateADD&lt;/code&gt;的资料比较少，笔者在生产环境找那个也尚未实践过，所以不做展开分析。&lt;/p&gt;
&lt;h3 id=&quot;其他方法&quot;&gt;其他方法&lt;/h3&gt;
&lt;p&gt;其他方法主要是Getter方法，用于获取Cipher的相关信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public final Provider getProvider()：获取Cipher的提供商。&lt;/li&gt;
&lt;li&gt;public final String getAlgorithm()：获取Cipher使用的算法名称。&lt;/li&gt;
&lt;li&gt;public final int getBlockSize()：分组加密中，每一组都有固定的长度，也称为块，此方法是返回块的大小（以字节为单位）。&lt;/li&gt;
&lt;li&gt;public final int getOutputSize(int inputLen)：根据给定的输入长度inputLen（以字节为单位），返回保存下一个update或doFinal操作结果所需的输出缓冲区长度（以字节为单位）。&lt;/li&gt;
&lt;li&gt;public final byte[] getIV()：返回Cipher中的初始化向量的字节数组。&lt;/li&gt;
&lt;li&gt;public final AlgorithmParameters getParameters()：返回Cipher使用的算法参数。&lt;/li&gt;
&lt;li&gt;public final ExemptionMechanism getExemptionMechanism()：返回Cipher使用的豁免(exemption)机制对象。&lt;/li&gt;
&lt;li&gt;public static final int getMaxAllowedKeyLength(String transformation)：根据所安装的JCE策略文件，返回指定转换的最大密钥长度。&lt;/li&gt;
&lt;li&gt;public static final AlgorithmParameterSpec getMaxAllowedParameterSpec(String transformation)：根据JCE策略文件，返回Cipher指定transformation下最大的AlgorithmParameterSpec对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面画一个图来详细分析一下Cipher的工作流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/cipher-1.png&quot; alt=&quot;cipher-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然上图只分析了Cipher的使用过程，其实还有一个重要的步骤就是密钥的处理，但是密钥的处理和具体的算法使用是相关的，所以图中没有体现。再放一张官方描述Cipher加载的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/cipher-2.png&quot; alt=&quot;cipher-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要过程包括：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;1、创建Cipher实例，这个时候会从平台中所有的提供商(Provider)中根据transformation匹配第一个可以使用的CipherSpi实例，&quot;算法/工作模式/填充模式&quot;必须完全匹配才能选中。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在${JAVA_HONE}/jre/lib/security中的java.security文件中可以看到默认加载的提供商。如果需要添加额外或者自实现的Provider，可以通过java.security.Security的静态方法addProvider添加。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;2、通过Cipher实例的init方法初始化Cipher，主要参数是opmode和密钥。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3、根据初始化的方式和是否需要分组处理，选择合适的方法进行调用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了方便Cipher的使用，最好先引入&lt;code&gt;apache-codec&lt;/code&gt;依赖，这样能简化Hex、Base64等操作。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-codec&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-codec&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.11&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大多数情况下，加密后的byte数组的中元素取值不在Unicode码点的范围内，表面上看到的就是乱码，实际上它们是有意义的，因此需要考虑把这种byte数组转换为非乱码的字符串以便传输，常见的方式有Hex(二进制转换为十六进制)、Base64等等。下面举例中没有针对异常类型进行处理统一外抛，切勿模仿，还有，所有的字符串转化为字节数组都没有指定字符编码，因此只能使用非中文的明文进行处理。&lt;/p&gt;
&lt;h2 id=&quot;加密模式&quot;&gt;加密模式&lt;/h2&gt;
&lt;p&gt;加密模式下，Cipher只能用于加密，主要由init方法中的opmode决定。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String encryptByAes(String content, String password) throws Exception {
    //这里指定了算法为AES_128，工作模式为EBC，填充模式为NoPadding
    Cipher cipher = Cipher.getInstance(&quot;AES_128/ECB/NoPadding&quot;);
    KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
    //因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组
    keyGenerator.init(128, new SecureRandom(password.getBytes()));
    SecretKey secretKey = keyGenerator.generateKey();
    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);
    //基于加密模式和密钥初始化Cipher
    cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
    //单部分加密结束，重置Cipher
    byte[] bytes = cipher.doFinal(content.getBytes());
    //加密后的密文由二进制序列转化为十六进制序列，依赖apache-codec包
    return Hex.encodeHexString(bytes);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实整个过程Cipher的使用都很简单，比较复杂的反而是密钥生成的过程。上面的例子需要注意，因为使用了填充模式为NoPadding，输入的需要加密的报文长度必须是16(128bit)的倍数。&lt;/p&gt;
&lt;h2 id=&quot;解密模式&quot;&gt;解密模式&lt;/h2&gt;
&lt;p&gt;解密模式的使用大致和加密模式是相同的，把处理过程逆转过来就行：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public String decryptByAes(String content, String password) throws Exception {
    //这里要把十六进制的序列转化回二进制的序列，依赖apache-codec包
    byte[] bytes = Hex.decodeHex(content);
    //这里指定了算法为AES_128，工作模式为EBC，填充模式为NoPadding
    Cipher cipher = Cipher.getInstance(&quot;AES_128/ECB/NoPadding&quot;);
    KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
    //因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组
    keyGenerator.init(128, new SecureRandom(password.getBytes()));
    SecretKey secretKey = keyGenerator.generateKey();
    SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);
    //基于解密模式和密钥初始化Cipher
    cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
    //单部分加密结束，重置Cipher
    byte[] result = cipher.doFinal(bytes);
    return new String(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子需要注意，因为使用了填充模式为NoPadding，输入的需要加密的报文长度必须是16(128bit)的倍数。&lt;/p&gt;
&lt;h2 id=&quot;包装密钥模式和解包装密钥模式&quot;&gt;包装密钥模式和解包装密钥模式&lt;/h2&gt;
&lt;p&gt;密钥的包装和解包装模式是一对互逆的操作，主要作用是通过算法对密钥进行加解密，从而提高密钥泄漏的难度。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum EncryptUtils {

    /**
     * 单例
     */
    SINGLETON;

    private static final String SECRECT = &quot;passwrod&quot;;

    public String wrap(String keyString) throws Exception {
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        //初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是&quot;passward&quot;)
        keyGenerator.init(128, new SecureRandom(SECRECT.getBytes()));
        SecretKey secretKey = keyGenerator.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);
        Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
        cipher.init(Cipher.WRAP_MODE, secretKeySpec);
        SecretKeySpec key = new SecretKeySpec(keyString.getBytes(), &quot;AES&quot;);
        byte[] bytes = cipher.wrap(key);
        return Hex.encodeHexString(bytes);
    }

    public String unwrap(String keyString) throws Exception {
        byte[] rawKey = Hex.decodeHex(keyString);
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        //初始化密钥生成器，指定密钥长度为128，指定随机源的种子为指定的密钥(这里是&quot;passward&quot;)
        keyGenerator.init(128, new SecureRandom(SECRECT.getBytes()));
        SecretKey secretKey = keyGenerator.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);
        Cipher cipher = Cipher.getInstance(&quot;AES&quot;);
        cipher.init(Cipher.UNWRAP_MODE, secretKeySpec);
        SecretKey key = (SecretKey) cipher.unwrap(rawKey, &quot;AES&quot;, Cipher.SECRET_KEY);
        return new String(key.getEncoded());
    }

    public static void main(String[] args) throws Exception {
        String wrapKey = EncryptUtils.SINGLETON.wrap(&quot;doge&quot;);
        System.out.println(wrapKey);
        System.out.println(EncryptUtils.SINGLETON.unwrap(wrapKey));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分组部分加密和分组解密&quot;&gt;分组(部分)加密和分组解密&lt;/h2&gt;
&lt;p&gt;当一个需要加密的报文十分长的时候，我们可以考虑把报文切割成多个小段，然后针对每个小段进行加密，这就是分组加密。分组解密的过程类同，可以看作是分组加密的逆向过程。下面还是用AES算法为例举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.apache.commons.codec.binary.Hex;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.SecureRandom;

/**
 * @author throwable
 * @version v1.0
 * @description
 * @since 2018/8/15 1:06
 */
public enum Part {

    /**
     * SINGLETON
     */
    SINGLETON;

    private static final String PASSWORD = &quot;throwable&quot;;

    private Cipher createCipher() throws Exception {
        return Cipher.getInstance(&quot;AES&quot;);
    }

    public String encrypt(String content) throws Exception {
        Cipher cipher = createCipher();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        //因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组
        keyGenerator.init(128, new SecureRandom(PASSWORD.getBytes()));
        SecretKey secretKey = keyGenerator.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);
        //基于加密模式和密钥初始化Cipher
        cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        byte[] raw = content.getBytes();
        StringBuilder builder = new StringBuilder();
        //[0,9]
        byte[] first = cipher.update(raw, 0, 10);
        builder.append(Hex.encodeHexString(first));
        //[10,19]
        byte[] second = cipher.update(raw, 10, 10);
        builder.append(Hex.encodeHexString(second));
        //[20,25]
        byte[] third = cipher.update(raw, 20, 6);
        builder.append(Hex.encodeHexString(third));
        //多部分加密结束，得到最后一段加密的结果，重置Cipher
        byte[] bytes = cipher.doFinal();
        String last = Hex.encodeHexString(bytes);
        builder.append(last);
        return builder.toString();
    }

    public String decrypt(String content) throws Exception {
        byte[] raw = Hex.decodeHex(content);
        Cipher cipher = createCipher();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AES&quot;);
        //因为AES要求密钥的长度为128，我们需要固定的密码，因此随机源的种子需要设置为我们的密码数组
        keyGenerator.init(128, new SecureRandom(PASSWORD.getBytes()));
        SecretKey secretKey = keyGenerator.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);
        //基于解密模式和密钥初始化Cipher
        cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
        StringBuilder builder = new StringBuilder();
        //[0,14]
        byte[] first = cipher.update(raw, 0, 15);
        builder.append(new String(first));
        //[15,29]
        byte[] second = cipher.update(raw, 15, 15);
        builder.append(new String(second));
        //[30,31]
        byte[] third = cipher.update(raw, 30, 2);
        builder.append(new String(third));
        //多部分解密结束，得到最后一段解密的结果，重置Cipher
        byte[] bytes = cipher.doFinal();
        builder.append(new String(bytes));
        return builder.toString();
    }

    public static void main(String[] args) throws Exception{
        String raw = &quot;abcdefghijklmnopqrstyuwxyz&quot;;
        String e = Part.SINGLETON.encrypt(raw);
        System.out.println(e);
        System.out.println(Part.SINGLETON.decrypt(e));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的分段下标已经在注释中给出，分段的规则由实际情况考虑，一般AES加解密报文不大的时候可以直接单部分加解密即可，这里仅仅是为了做展示。&lt;/p&gt;
&lt;h2 id=&quot;查看当前jdk中cipher的所有提供商&quot;&gt;查看当前JDK中Cipher的所有提供商&lt;/h2&gt;
&lt;p&gt;我们可以直接查看当前的使用的JDK中Cipher的所有提供商和支持的加解密服务，简单写个main函数就行：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.security.Provider;
import java.security.Security;
import java.util.Set;

public class Main {

    public static void main(String[] args) throws Exception {
        Provider[] providers = Security.getProviders();
        if (null != providers) {
            for (Provider provider : providers) {
                Set&amp;lt;Provider.Service&amp;gt; services = provider.getServices();
                for (Provider.Service service : services) {
                    if (&quot;Cipher&quot;.equals(service.getType())) {
                        System.out.println(String.format(&quot;provider:%s,type:%s,algorithm:%s&quot;, service.getProvider(), service.getType(), service.getAlgorithm()));
                    }
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;笔者使用的JDK是JDK8的最后一个更新的版本8u181(1.8.0_181)，运行main函数输出如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;provider:SunJCE version 1.8,type:Cipher,algorithm:RSA
provider:SunJCE version 1.8,type:Cipher,algorithm:DES
provider:SunJCE version 1.8,type:Cipher,algorithm:DESede
provider:SunJCE version 1.8,type:Cipher,algorithm:DESedeWrap
provider:SunJCE version 1.8,type:Cipher,algorithm:PBEWithMD5AndDES
provider:SunJCE version 1.8,type:Cipher,algorithm:PBEWithMD5AndTripleDES
provider:SunJCE version 1.8,type:Cipher,algorithm:PBEWithSHA1AndDESede
provider:SunJCE version 1.8,type:Cipher,algorithm:PBEWithSHA1AndRC2_40
provider:SunJCE version 1.8,type:Cipher,algorithm:PBEWithSHA1AndRC2_128
.....输出内容太多忽略剩余部分&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;因为Java原生支持的transformation是有限的，有些时候我们需要使用一些算法其他工作模式或者填充模式原生无法支持，这个时候我们需要引入第三方的Provider甚至自己实现Provider。常见的第三方Provider是bouncycastle(BC)，目前BC的最新依赖为：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.bouncycastle&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;bcprov-jdk15on&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.60&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举个例子，Java原生是不支持AESWRAP算法的，因此可以引入BC的依赖，再使用转换模式AESWRAP。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.apache.commons.codec.binary.Hex;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.security.Security;

public enum EncryptUtils {

    /**
     * SINGLETON
     */
    SINGLETON;

    private static final String SECRET = &quot;throwable&quot;;
    private static final String CHARSET = &quot;UTF-8&quot;;

    //装载BC提供商
    static {
        Security.addProvider(new BouncyCastleProvider());
    }


    private Cipher createAesCipher() throws Exception {
        return Cipher.getInstance(&quot;AESWRAP&quot;);
    }

    public String encryptByAes(String raw) throws Exception {
        Cipher aesCipher = createAesCipher();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AESWRAP&quot;);
        keyGenerator.init(128, new SecureRandom(SECRET.getBytes(CHARSET)));
        SecretKey secretKey = keyGenerator.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AESWRAP&quot;);
        aesCipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);
        byte[] bytes = aesCipher.doFinal(raw.getBytes(CHARSET));
        return Hex.encodeHexString(bytes);
    }

    public String decryptByAes(String raw) throws Exception {
        byte[] bytes = Hex.decodeHex(raw);
        Cipher aesCipher = createAesCipher();
        KeyGenerator keyGenerator = KeyGenerator.getInstance(&quot;AESWRAP&quot;);
        keyGenerator.init(128, new SecureRandom(SECRET.getBytes(CHARSET)));
        SecretKey secretKey = keyGenerator.generateKey();
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getEncoded(), &quot;AESWRAP&quot;);
        aesCipher.init(Cipher.DECRYPT_MODE, secretKeySpec);
        return new String(aesCipher.doFinal(bytes), CHARSET);
    }

    public static void main(String[] args) throws Exception {
        String raw = &quot;throwable-a-doge&quot;;
        String en = EncryptUtils.SINGLETON.encryptByAes(raw);
        System.out.println(en);
        String de = EncryptUtils.SINGLETON.decryptByAes(en);
        System.out.println(de);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子需要注意，因为使用了AESWRAP算法，输入的需要加密的报文长度必须是8的倍数。&lt;/p&gt;

&lt;p&gt;熟练掌握Cipher的用法、转换模式transformation的一些知识之后，影响我们编写加解密模块代码的主要因素就是加解密算法的原理或者使用，这些需要我们去学习专门的加解密算法相关的知识。另外，&lt;strong&gt;有些时候我们发现不同平台或者不同语言使用同一个加密算法不能相互解密加密&lt;/strong&gt;，其实原因很简单，绝大部分原因是工作模式选取或者填充模式选取的不同导致的，排除掉这两点，剩下的可能性就是算法的实现不相同，依据这三点因素(或者说就是transformation这唯一的因素)去判断和寻找解决方案即可。关于加解密算法原理、工作模式等相关知识可以参考下面的资料。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《密码编码学与网络安全-原理与实践(第六版)》&lt;/li&gt;
&lt;li&gt;《信息安全原理与实践(第2版)》&lt;/li&gt;
&lt;li&gt;《关于加密数据的填充方式的研究》&lt;/li&gt;
&lt;li&gt;JavaSE8 API文档&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，一些特殊的方法例如&lt;code&gt;Ciper#updateADD&lt;/code&gt;暂时没遇到使用场景，这里就不写没实践过的Demo。下一篇文章将会介绍一些主流的加解密算法的基本原理和通过Cipher对这些算法进行加解密应用。&lt;/p&gt;
&lt;p&gt;（本文完 c-7-d）&lt;/p&gt;
</description>
<pubDate>Wed, 15 Aug 2018 03:43:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 javax.crypto.Cipher，翻译为密码，其实叫做 密码器 更加合适。Cipher是JCA(Java Cryptographic Extension，Java加密扩展)的核心，提供基于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9480540.html</dc:identifier>
</item>
</channel>
</rss>