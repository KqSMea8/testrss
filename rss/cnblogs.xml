<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Hystrix针对不可用服务的保护机制以及引入缓存 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/9557991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/9557991.html</guid>
<description>&lt;p&gt;   之前我写过一篇博文，&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/JavaArchitect/p/9399209.html&quot;&gt;通过案例了解Hystrix的各种基本使用方式&lt;/a&gt;，在这篇文章里，我们是通过Hystrix调用正常工作的服务，也就是说，Hytrix的保护机制并没有起作用，这里我们将在HystrixProtectDemo.java里演示调用不可用的服务时，hystrix启动保护机制的流程。这个类是基于NormalHystrixDemo.java改写的，只是在其中增加了getFallback方法，代码如下。     &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
1  //省略必要的package和import代码
2       public class HystrixProtectDemo extends HystrixCommand&amp;lt;String&amp;gt; {
3               RestClient client = null;
4               HttpRequest request = null;
5           //构造函数很相似
6               public HystrixDemoProtectDemo() {
7               super(HystrixCommandGroupKey.Factory.asKey(&quot;ExampleGroup&quot;));
8               }
9          //initRestClient方法没变
10              private void initRestClient(){
11              //和NormalHystrixDemo.java一样，具体请参考代码
12              }
13              //run方法也没变
14              protected String run() {
15                      //和NormalHystrixDemo.java一样，具体请参考代码
16              }
17          //这次多个了getFallback方法，一旦出错，会调用其中的代码
18              protected String getFallback() {
19                      //省略跳转到错误提示页面的动作
20                      return &quot;Call Unavailable Service.&quot;;
21              }
22              //main函数
23              public static void main(String[] args) {
24                      HystrixDemoProtectDemo normalDemo = new HystrixDemoProtectDemo();
25                      normalDemo.initRestClient();
26                      try {
27                              Thread.sleep(1000);
28                      } catch (InterruptedException e) {
29                              e.printStackTrace();
30                      }           
31                      String result = normalDemo.execute();
32                      System.out.println(&quot;Call available function, result is:&quot; + result);
33              }
34      }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    这个类里的构造函数和NormalHystrixDemo.java很相似，而initRestClient和run方法根本没变，所以就不再详细给出了。&lt;/p&gt;
&lt;p&gt;    在第18行里，我们重写了HystrixCommand类的getFallback方法，在其中定义了一旦访问出错的动作，这里仅仅是输出一段话，在实际的项目里，可以跳转到相应的错误提示页面。&lt;/p&gt;
&lt;p&gt;    而main函数里的代码和NormalHystrixDemo.java里的完全一样，只是，在运行这段代码前无需运行HystrixServerDemo项目的启动类，这样服务一定是调用不到的。运行本段代码后，我们能看到如下的结果。　　&lt;/p&gt;
&lt;p&gt;             In run&lt;/p&gt;
&lt;p&gt;             Call available function, result is:Call Unavailable Service.&lt;/p&gt;
&lt;p&gt;    从第2行的输出上，我们能确认，一旦调用服务出错，Hystrix处理类能自动地调用getFallback方法。&lt;/p&gt;
&lt;p&gt;    如果这里没有定义getFallback方法，那么一旦服务不可用，那么用户可能在连接超时之后，在浏览器里看到一串毫无意义的内容，这样用户体验就很差，如果整个系统的其它容错措施也没到位，甚至就有可能导致当前和下游模块瘫痪。&lt;/p&gt;
&lt;p&gt;    相反，在这里由于我们在hystirx提供的getFallback方法里做了充分的准备，那么一旦出现错误，这段错误处理的代码能被立即触发，其效果就相当于熔断后继的处理流程。&lt;/p&gt;
&lt;p&gt;    由getFallback出面，友好地告知用户出问题了，以及后继该如何处理，这样一方面能及时熔断请求从而保护整个系统，另一方面不会造成因体验过差而用户大规模流失的情况。&lt;/p&gt;
&lt;p&gt;    如果每次请求都要走后台应用程序乃至再到数据库检索一下数据，这对服务器的压力太大，有时候这一因素甚至会成为影响网站服务性能的瓶颈。所以，大多数网站会把一些无需实时更新的数据放入缓存，前端请求是到缓存里拿数据。    &lt;/p&gt;
&lt;p&gt;    Hystrix在提供保护性便利的同时，也能支持缓存的功能，在下面的HystrixCacheDemo.java里，我们将演示Hystrix从缓存中读取数据的步骤，代码如下。     &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
1    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略必要的package和import代码&lt;/span&gt;
2    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; HystrixCacheDemo &lt;span&gt;extends&lt;/span&gt; HystrixCommand&amp;lt;String&amp;gt;&lt;span&gt; {
&lt;/span&gt;3        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户id&lt;/span&gt;
4&lt;span&gt;        Integer id;
&lt;/span&gt;5         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用一个HashMap来模拟数据库里的数据&lt;/span&gt;
6        &lt;span&gt;private&lt;/span&gt; HashMap&amp;lt;Integer,String&amp;gt; userList = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;Integer,String&amp;gt;&lt;span&gt;();
&lt;/span&gt;7        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
8        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HystrixCacheDemo(Integer id) {
&lt;/span&gt;9        &lt;span&gt;super&lt;/span&gt;(HystrixCommandGroupKey.Factory.asKey(&quot;RequestCacheCommand&quot;&lt;span&gt;));        
&lt;/span&gt;10            &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;11            userList.put(1, &quot;Tom&quot;&lt;span&gt;);
&lt;/span&gt;12        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在第3行里，我们定义了一个用户id，并在第6行定义了一个存放用户信息的HashMap。&lt;/p&gt;
&lt;p&gt;    在第8行的构造函数里，我们在第10行里用参数id来初始化了本对象的id属性，并在第11行里，通过put方法模拟地构建了一个用户，在项目里，用户的信息其实是存在数据库里的。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
13        &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String run() {
&lt;/span&gt;14            System.out.println(&quot;In run&quot;&lt;span&gt;);
&lt;/span&gt;15            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; userList.get(id);
&lt;/span&gt;16        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    如果不走缓存的话，第13行定义run函数将会被execute方法触发，在其中的第15行里，我们通过get方法从userList这个HashMap里获得一条用户数据，这里我们用get方法来模拟根据id从数据库里获取数据的诸多动作。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
17         protected String getCacheKey() {
18                      return String.valueOf(id);
19              }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第17行定义的getCacheKey方法是Hystrix实现缓存的关键，在其中我们可以定义“缓存对象的标准”，具体而言，我们在这里是返回String.valueOf(id)，也就是说，如果第二个HystrixCacheDemo对象和第一个对象具有相同的String.valueOf(id)的值，那么第二个对象在调用execute方法时，就可以走缓存。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {        
&lt;/span&gt;21         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化上下文，否则无法用缓存机制&lt;/span&gt;
22            HystrixRequestContext context =&lt;span&gt; HystrixRequestContext.initializeContext();
&lt;/span&gt;23            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个具有相同id的对象&lt;/span&gt;
24            HystrixCacheDemo cacheDemo1 = &lt;span&gt;new&lt;/span&gt; HystrixCacheDemo(1&lt;span&gt;);
&lt;/span&gt;25            HystrixCacheDemo cacheDemo2 = &lt;span&gt;new&lt;/span&gt; HystrixCacheDemo(1&lt;span&gt;);
&lt;/span&gt;26            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个对象调用的是run方法，没有走缓存    &lt;/span&gt;
27            System.out.println(&quot;the result for cacheDemo1 is:&quot; +&lt;span&gt; cacheDemo1.execute());
&lt;/span&gt;28            System.out.println(&quot;whether get from cache：&quot; +&lt;span&gt; cacheDemo1.isResponseFromCache);
&lt;/span&gt;29            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二个对象，由于和第一个对象具有相同的id，所以走缓存    &lt;/span&gt;
30            System.out.println(&quot;the result for cacheDemo2 is:&quot; +&lt;span&gt; cacheDemo2.execute());
&lt;/span&gt;31            System.out.println(&quot;whether get from cache：&quot; +&lt;span&gt; cacheDemo2.isResponseFromCache);
&lt;/span&gt;32            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;销魂上下文，以清空缓存&lt;/span&gt;
33&lt;span&gt;            context.shutdown();
&lt;/span&gt;34            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再次初始化上下文，但由于缓存已清，所以cacheDemo3没走缓存&lt;/span&gt;
35            context =&lt;span&gt; HystrixRequestContext.initializeContext();
&lt;/span&gt;36            HystrixCacheDemo cacheDemo3 = &lt;span&gt;new&lt;/span&gt; HystrixCacheDemo(1&lt;span&gt;);
&lt;/span&gt;37            System.out.println(&quot;the result for 3 is:&quot; +&lt;span&gt; cacheDemo3.execute());
&lt;/span&gt;38            System.out.println(&quot;whether get from cache：&quot; +&lt;span&gt; cacheDemo3.isResponseFromCache);
&lt;/span&gt;39            context.shutdown();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    在第20行的main方法里，我们定义了如下的主要逻辑。&lt;/p&gt;
&lt;p&gt;    第一，在第22行，通过initializeContext方法，初始化了上下文，这样才能启动缓存机制。，在第24和25行里，我们创建了两个不同名的，但相同id的HystrixCacheDemo对象。&lt;/p&gt;
&lt;p&gt;    第二，在第27行里，我们通过cacheDemo1对象的execute方法，根据id查找用户，虽然我们在这里是通过run方法里第15行的get方法从HashMap里取数据，但大家可以把这想象成从数据表里取数据。&lt;/p&gt;
&lt;p&gt;    第三，在第30行里，我们调用了cacheDemo2对象的execute方法，由于它和cacheDemo1对象具有相同的id，所以这里并没有走execute方法，而是直接从保存cacheDemo1.execute的缓存里拿数据，这就可以避免因多次访问数据库而造成了系统损耗。&lt;/p&gt;
&lt;p&gt;    第四，我们在第33行销毁了上下文，并在第35行里重新初始化了上下文，之后，虽然在第36行定义的cacheDemo3对象的id依然是1，但由于上下文对象被重置过，其中的缓存也被清空，所以在第37里执行的execute方法并没有走缓存。&lt;/p&gt;
&lt;p&gt;    运行上述代码，我们能看到如下的输出，这些打印结果能很好地验证上述对主要流程的说明。    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;    In run
&lt;/span&gt;2    the result &lt;span&gt;for&lt;/span&gt;&lt;span&gt; cacheDemo1 is:Tom
&lt;/span&gt;3    whether get from cache：&lt;span&gt;false&lt;/span&gt;
4    the result &lt;span&gt;for&lt;/span&gt;&lt;span&gt; cacheDemo2 is:Tom
&lt;/span&gt;5    whether get from cache：&lt;span&gt;true&lt;/span&gt;
6&lt;span&gt;    In run
&lt;/span&gt;7    the result &lt;span&gt;for&lt;/span&gt; 3 is:Tom
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    这里请大家注意，在缓存相关的getCacheKey方法里，我们不是定义“保存缓存值”的逻辑，而是定义“缓存对象的标准”，初学者经常会混淆这点。具体而言，在这里的getCacheKey方法里，我们并没有保存id是1的User对象的值（这里是Tom），而是定义了如下的标准：只要两个（或多个）HystrixCacheDemo对象具有相同的String.valueOf(id)的值，而且缓存中也已经存有id的1的结果值，那么后继对象则可以直接从缓存里读数据。&lt;/p&gt;

&lt;p&gt;    在上文里，我们演示了通过Hystrix调用可用以及不可用服务的运行结果，并在调用过程中引入了缓存机制，这里，我们将在上述案例的基础上归纳Hystrix的一般工作流程。&lt;/p&gt;
&lt;p&gt;    第一，我们可以通过extends HystrixCommand&amp;lt;T&amp;gt;的方式，让一个类具备Hystrix保护机制的特性，其中T是泛型，在上述案例中我们用到的是String。&lt;/p&gt;
&lt;p&gt;    第二，一旦继承了HystrixCommand之后，我们就可以通过重写run方法和getFallback方法来定义调用“可用”和“不可用”服务的业务功能代码，其中，这两个方法的返回值需要和第一步里定义的泛型T一致。而在项目里，我们一般在getFallback方法里，定义“服务不可用”时的保护措施（也就是后文里将要提到的降级措施）。&lt;/p&gt;
&lt;p&gt;    第三，我们还可以通过缓存机制来降低并发情况下对服务器的压力，在Hystrix里，我们可以在getCacheKey里定义“判断可以走缓存对象的标准”。&lt;/p&gt;
&lt;p&gt;    在使用缓存是，请注意两点，第一需要开启上下文，第二，Hystrix会根据定义在类里的属性判断多次调用的对象是否是同一个，如果是，而且之前被调用过，则可以走缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    本文谢绝转载。&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 29 Aug 2018 23:34:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<og:description>之前我写过一篇博文，通过案例了解Hystrix的各种基本使用方式，在这篇文章里，我们是通过Hystrix调用正常工作的服务，也就是说，Hytrix的保护机制并没有起作用，这里我们将在HystrixPr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/9557991.html</dc:identifier>
</item>
<item>
<title>Java并发（6）- CountDownLatch、Semaphore与AQS - knock_小新</title>
<link>http://www.cnblogs.com/konck/p/9473591.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/konck/p/9473591.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;上一篇文章中详细分析了基于AQS的ReentrantLock原理，ReentrantLock通过AQS中的state变量0和1之间的转换代表了独占锁。那么可以思考一下，当state变量大于1时代表了什么？J.U.C中是否有基于AQS的这种实现呢？如果有，那他们都是怎么实现的呢？这些疑问通过详细分析J.U.C中的Semaphore与CountDownLatch类后，将会得到解答。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Semaphore与CountDownLatch的共享逻辑&lt;/li&gt;
&lt;li&gt;Semaphore与CountDownLatch的使用示例&lt;br/&gt;2.1 Semaphore的使用&lt;br/&gt;2.2 CountDownLatch的使用&lt;/li&gt;
&lt;li&gt;源码分析&lt;br/&gt;3.1 AQS中共享锁的实现&lt;br/&gt;3.2 Semaphore源码分析&lt;br/&gt;3.3 CountDownLatch源码分析&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;semaphore与countdownlatch的共享方式&quot;&gt;1. Semaphore与CountDownLatch的共享方式&lt;/h2&gt;
&lt;p&gt;独占锁意味着只能有一个线程获取锁，其他的线程在锁被占用的情况下都必须等待锁释放后才能进行下一步操作。由此类推，共享锁是否意味着可以由多个线程同时使用这个锁，不需要等待呢？如果是这样，那锁的意义也就不存在了。在J.U.C中共享意味着有多个线程可以同时获取锁，但这个多个是有限制的，并不是无限个，J.U.C中通过Semaphore与CountDownLatch来分别实现了两种有限共享锁。&lt;/p&gt;
&lt;p&gt;Semaphore又叫信号量，他通过一个共享的’信号包‘来给每个使用他的线程来分配信号，当信号包中的信号足够时，线程可以获取锁，反之，信号包中信号不够了，则不能获取到锁，需要等待足够的信号被释放，才能获取。&lt;/p&gt;
&lt;p&gt;CountDownLatch又叫计数器，他通过一个共享的计数总量来控制线程锁的获取，当计数器总量大于0时，线程将被阻塞，不能够获取锁，只有当计数器总量为0时，所有被阻塞的线程同时被释放。&lt;/p&gt;
&lt;p&gt;可以看到Semaphore与CountDownLatch都有一个共享总量，这个共享总量就是通过state来实现的。&lt;/p&gt;
&lt;h2 id=&quot;semaphore与countdownlatch的使用示例&quot;&gt;2. Semaphore与CountDownLatch的使用示例&lt;/h2&gt;
&lt;p&gt;在详细分析Semaphore与CountDownLatch的原理之前，先来看看他们是怎么使用的，这样方便后续我们理解他们的原理。先知道他是什么？然后再问为什么？下面通过两个示例来详细说明Semaphore与CountDownLatch的使用。&lt;/p&gt;
&lt;h3 id=&quot;semaphore的使用&quot;&gt;2.1 Semaphore的使用&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//初始化10个信号量在信号包中，让ABCD4个线程分别去获取
public static void main(String[] args) throws InterruptedException {
    Semaphore semaphore = new Semaphore(10);
    SemaphoreTest(semaphore);
}

private static void SemaphoreTest(final Semaphore semaphore) throws InterruptedException {
    //线程A初始获取了4个信号量，然后分3次释放了这4个信号量
    Thread threadA = new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                semaphore.acquire(4);
                System.out.println(Thread.currentThread().getName() + &quot; get 4 semaphore&quot;);
                Thread.sleep(2000);
                System.out.println(Thread.currentThread().getName() + &quot; release 1 semaphore&quot;);
                semaphore.release(1);
                Thread.sleep(2000);
                System.out.println(Thread.currentThread().getName() + &quot; release 1 semaphore&quot;);
                semaphore.release(1);
                Thread.sleep(2000);
                System.out.println(Thread.currentThread().getName() + &quot; release 2 semaphore&quot;);
                semaphore.release(2);

            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    });
    threadA.setName(&quot;threadA&quot;);

    //线程B初始获取了5个信号量，然后分2次释放了这5个信号量
    Thread threadB = new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                semaphore.acquire(5);
                System.out.println(Thread.currentThread().getName() + &quot; get 5 semaphore&quot;);
                Thread.sleep(2000);
                System.out.println(Thread.currentThread().getName() + &quot; release 2 semaphore&quot;);
                semaphore.release(2);
                Thread.sleep(2000);
                System.out.println(Thread.currentThread().getName() + &quot; release 3 semaphore&quot;);
                semaphore.release(3);

            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    });
    threadB.setName(&quot;threadB&quot;);

    //线程C初始获取了4个信号量，然后分1次释放了这4个信号量
    Thread threadC = new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                semaphore.acquire(4);
                System.out.println(Thread.currentThread().getName() + &quot; get 4 semaphore&quot;);
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName() + &quot; release 4 semaphore&quot;);
                semaphore.release(4);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    });
    threadC.setName(&quot;threadC&quot;);
    
    //线程D初始获取了10个信号量，然后分1次释放了这10个信号量
    Thread threadD = new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                semaphore.acquire(10);
                System.out.println(Thread.currentThread().getName() + &quot; get 10 semaphore&quot;);
                Thread.sleep(1000);
                System.out.println(Thread.currentThread().getName() + &quot; release 10 semaphore&quot;);
                semaphore.release(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    });
    threadD.setName(&quot;threadD&quot;);
    
    //线程A和线程B首先分别获取了4个和5个信号量，总信号量变为了1个
    threadA.start();
    threadB.start();
    Thread.sleep(1);
    //线程C尝试获取4个发现不够则等待
    threadC.start();
    Thread.sleep(1);
    //线程D尝试获取10个发现不够则等待
    threadD.start();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;threadB get 5 semaphore
threadA get 4 semaphore
threadA release 1 semaphore
threadB release 2 semaphore
threadC get 4 semaphore
threadA release 1 semaphore
threadC release 4 semaphore
threadB release 3 semaphore
threadA release 2 semaphore
threadD get 10 semaphore
threadD release 10 semaphore&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到threadA和threadB在获取了9个信号量之后threadC和threadD之后等待信号量足够时才能继续往下执行。而threadA和threadB在信号量足够时是可以同时执行的。&lt;/p&gt;
&lt;p&gt;其中有一个问题，当threadD排队在threadC之前时，信号量如果被释放了4个，threadC会先于threadD执行吗？还是需要排队等待呢？这个疑问在详细分析了Semaphore的源码之后再来给大家答案。&lt;/p&gt;
&lt;h3 id=&quot;countdownlatch的使用&quot;&gt;2.2 CountDownLatch的使用&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;//初始化计数器总量为2
public static void main(String[] args) throws InterruptedException {
    CountDownLatch countDownLatch = new CountDownLatch(2);
    CountDownLatchTest(countDownLatch);
}

private static void CountDownLatchTest(final CountDownLatch countDownLatch) throws InterruptedException {
    //threadA尝试执行，计数器为2被阻塞
    Thread threadA = new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                countDownLatch.await();
                System.out.println(Thread.currentThread().getName() + &quot; await&quot;);

            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    });
    threadA.setName(&quot;threadA&quot;);

    //threadB尝试执行，计数器为2被阻塞
    Thread threadB = new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                countDownLatch.await();
                System.out.println(Thread.currentThread().getName() + &quot; await&quot;);
                
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    });
    threadB.setName(&quot;threadB&quot;);
    
    //threadC在1秒后将计数器数量减1
    Thread threadC = new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                Thread.sleep(1000);
                countDownLatch.countDown();
                
                System.out.println(Thread.currentThread().getName() + &quot; countDown&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    });
    threadC.setName(&quot;threadC&quot;);
    
    //threadD在5秒后将计数器数量减1
    Thread threadD = new Thread(new Runnable() {

        @Override
        public void run() {
            try {
                Thread.sleep(5000);
                countDownLatch.countDown();
                
                System.out.println(Thread.currentThread().getName() + &quot; countDown&quot;);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        }
    });
    threadD.setName(&quot;threadD&quot;);
    
    threadA.start();
    threadB.start();
    threadC.start();
    threadD.start();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;threadC countDown
threadD countDown
threadA await
threadB await&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;threadA和threadB在尝试执行时由于计数器总量为2被阻塞，当threadC和threadD将计数器总量减为0后，threadA和threadB同时开始执行。&lt;/p&gt;
&lt;p&gt;总结一下：Semaphore就像旋转寿司店，共有10个座位，当座位有空余时，等待的人就可以坐上去。如果有只有2个空位，来的是一家3口，那就只有等待。如果来的是一对情侣，就可以直接坐上去吃。当然如果同时空出5个空位，那一家3口和一对情侣可以同时上去吃。CountDownLatch就像大型商场里面的临时游乐场，每一场游乐的时间过后等待的人同时进场玩，而一场中间会有不爱玩了的人随时出来，但不能进入，一旦所有进入的人都出来了，新一批人就可以同时进场。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;3. 源码分析&lt;/h2&gt;
&lt;p&gt;明白了Semaphore与CountDownLatch是做什么的，怎么使用的。接下来就来看看Semaphore与CountDownLatch底层时怎么实现这些功能的。&lt;/p&gt;
&lt;h3 id=&quot;aqs中共享锁的实现&quot;&gt;3.1 AQS中共享锁的实现&lt;/h3&gt;
&lt;p&gt;上篇文章通过对ReentrantLock的分析，得倒了AQS中实现独占锁的几个关键方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//状态量，独占锁在0和1之间切换
private volatile int state;

//调用tryAcquire获取锁，获取失败后加入队列中挂起等操作，AQS中实现
public final void acquire(int arg);

//独占模式下尝试获取锁，ReentrantLock中实现
protected boolean tryAcquire(int arg);

//调用tryRelease释放锁以及恢复线程等操作，AQS中实现
public final boolean release(int arg);

//独占模式下尝试释放锁，ReentrantLock中实现
protected boolean tryRelease(int arg);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中具体的获取和释放独占锁的逻辑都放在ReentrantLock中自己实现，AQS中负责管理获取或释放独占锁成功失败后需要具体处理的逻辑。那么共享锁的实现是否也是遵循这个规律呢？由此我们在AQS中发现了以下几个类似的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//调用tryAcquireShared获取锁，获取失败后加入队列中挂起等操作，AQS中实现
public final void acquireShared(int arg)；

//共享模式下尝试获取锁
protected int tryAcquireShared(int arg)；

//调用tryReleaseShared释放锁以及恢复线程等操作，AQS中实现
public final boolean releaseShared(int arg)；

//共享模式下尝试释放锁
protected boolean tryReleaseShared(int arg)；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;共享锁和核心就在上面4个关键方法中，先来看看Semaphore是怎么调用上述方法来实现共享锁的。&lt;/p&gt;
&lt;h3 id=&quot;semaphore源码分析&quot;&gt;3.2 Semaphore源码分析&lt;/h3&gt;
&lt;p&gt;首先是Semaphore的构造方法，同ReentrantLock一样，他有两个构造方法，这样也是为了实现公平共享锁和非公平共享锁，大家可能有疑问，既然是共享锁，为什么还分公平和非公平的呢？这就回到了上面那个例子后面的疑问，前面有等待的线程时，后来的线程是否可以直接获取信号量，还是一定要排队。等待当然是公平的，插队就是非公平的。&lt;/p&gt;
&lt;p&gt;还是用旋转寿司的例子来说：现在只有2个空位，已经有一家3口在等待，这时来了一对情侣，公平共享锁的实现就是这对情侣必须等待，只到一家3口上桌之后才轮到他们，而非公平共享锁的实现是可以让这对情况直接去吃，因为刚好有2个空位，让一家3口继续等待（好像是很不公平......），这种情况下非公平共享锁的好处就是可以最大化寿司店的利润（好像同时也得罪了等待的顾客......），也是Semaphore默认的实现方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Semaphore(int permits) {
    sync = new NonfairSync(permits);
}

public Semaphore(int permits, boolean fair) {
    sync = fair ? new FairSync(permits) : new NonfairSync(permits);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Semaphore的例子中使用了两个核心方法acquire和release，分别调用了AQS中的acquireSharedInterruptibly和releaseShared方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//获取permits个信号量
public void acquire(int permits) throws InterruptedException {
    if (permits &amp;lt; 0) throw new IllegalArgumentException();
    sync.acquireSharedInterruptibly(permits);
}

//释放permits个信号量
public void release(int permits) {
    if (permits &amp;lt; 0) throw new IllegalArgumentException();
    sync.releaseShared(permits);
}

public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) &amp;lt; 0) //尝试获取arg个信号量
        doAcquireSharedInterruptibly(arg); //获取信号量失败时排队挂起
}

public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) { //尝试释放arg个信号量
        doReleaseShared();
        return true;
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Semaphore在获取和释放信号量的流程都是通过AQS来实现，具体怎么算获取成功或释放成功则由Semaphore本身实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//公平共享锁尝试获取acquires个信号量
protected int tryAcquireShared(int acquires) {
    for (;;) {
        if (hasQueuedPredecessors()) //前面是否有排队，有则返回获取失败
            return -1;
        int available = getState(); //剩余的信号量（旋转寿司店剩余的座位）
        int remaining = available - acquires;
        if (remaining &amp;lt; 0 ||
            compareAndSetState(available, remaining)) // 剩余信号量不够，够的情况下尝试获取（旋转寿司店座位不够，或者同时来两对情况抢座位）
            return remaining;
    }
}
//非公平共享锁尝试获取acquires个信号量
final int nonfairTryAcquireShared(int acquires) {
    for (;;) {
        int available = getState(); //剩余的信号量（旋转寿司店剩余的座位）
        int remaining = available - acquires;
        if (remaining &amp;lt; 0 ||
            compareAndSetState(available, remaining)) // 剩余信号量不够，够的情况下尝试获取（旋转寿司店座位不够，或者同时来两对情侣抢座位）
            return remaining;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到公平共享锁和非公平共享锁的区别就在是否需要判断队列中是否有已经等待的线程。公平共享锁需要先判断，非公平共享锁直接插队，尽管前面已经有线程在等待。&lt;/p&gt;
&lt;p&gt;为了验证这个结论，稍微修改下上面的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;threadA.start();
threadB.start();
Thread.sleep(1);
threadD.start(); //threadD已经在排队
Thread.sleep(3500);
threadC.start(); //3500毫秒后threadC来插队&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;threadB get 5 semaphore
threadA get 4 semaphore
threadB release 2 semaphore
threadA release 1 semaphore
threadC get 4 semaphore //threadC先与threadD获取到信号量
threadA release 1 semaphore
threadB release 3 semaphore
threadC release 4 semaphore
threadA release 2 semaphore
threadD get 10 semaphore
threadD release 10 semaphore&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个示例很好的说明了当为非公平锁时会先尝试获取共享锁，然后才排队。&lt;/p&gt;
&lt;p&gt;当获取信号量失败之后会去排队，排队这个操作通过AQS中的doAcquireSharedInterruptibly方法来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void doAcquireSharedInterruptibly(int arg)
    throws InterruptedException {
    final Node node = addWaiter(Node.SHARED); //加入等待队列
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor(); //获取当前节点的前置节点
            if (p == head) {
                int r = tryAcquireShared(arg); //前置节点是头节点时，说明当前节点是第一个挂起的线程节点，再次尝试获取共享锁
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r); //与ReentrantLock不同的地方：获取共享锁成功设置头节点，同时通知下一个节点
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp; //非头节点或者获取锁失败，检查节点状态，查看是否需要挂起线程
                parkAndCheckInterrupt()) //挂起线程，当前线程阻塞在这里！
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一段代码和ReentrantLock中的acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法基本一样，说下两个不同的地方。一是加入等待队列时这里加入的是Node.SHARED类型的节点。二是获取锁成功后会通知下一个节点，也就是唤醒下一个线程。以旋转寿司店的例子为例，前面同时走了5个客人，空余5个座位，一家3口坐进去之后会告诉后面的一对情侣，让他们也坐进去，这样就达到了共享的目的。shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法在上一篇文章中都有详细说明，这里就做解释了。&lt;/p&gt;
&lt;p&gt;再来看看releaseShared方法时怎么释放信号量的，首先调用tryReleaseShared来尝试释放信号量，释放成功后调用doReleaseShared来判断是否需要唤醒后继线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected final boolean tryReleaseShared(int releases) {
    for (;;) {
        int current = getState();
        int next = current + releases;
        if (next &amp;lt; current) // overflow //释放信号量过多
            throw new Error(&quot;Maximum permit count exceeded&quot;);
        if (compareAndSetState(current, next)) //cas操作设置新的信号量
            return true;
    }
}

private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null &amp;amp;&amp;amp; h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) { //SIGNAL状态下唤醒后继节点
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h); //唤醒后继节点
            }
            else if (ws == 0 &amp;amp;&amp;amp;
                        !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;释放的逻辑很好理解，相比ReentrantLock只是在state的数量上有点差别。&lt;/p&gt;
&lt;h3 id=&quot;countdownlatch源码分析&quot;&gt;3.3 CountDownLatch源码分析&lt;/h3&gt;
&lt;p&gt;CountDownLatch相比Semaphore在实现逻辑上要简单的多，同时他也没有公平和非公平的区别，因为当计数器达到0的时候，所有等待的线程都会释放，不为0的时候，所有等待的线程都会阻塞。直接来看看CountDownLatch的两个核心方法await和countDown。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void await() throws InterruptedException {
    //和Semaphore的不同在于参数为1，其实这个参数对CountDownLatch来说没什么意义，因为后面CountDownLatch的tryAcquireShared实现是通过getState() == 0来判断的
    sync.acquireSharedInterruptibly(1); 
}

public boolean await(long timeout, TimeUnit unit)
    throws InterruptedException {
    //这里加入了一个等待超时控制，超过时间后直接返回false执行后面的代码，不会长时间阻塞
    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout)); 
}

public void countDown() {
    sync.releaseShared(1); //每次释放1个计数
}

public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) &amp;lt; 0) //尝试获取arg个信号量
        doAcquireSharedInterruptibly(arg); //获取信号量失败时排队挂起
}

protected int tryAcquireShared(int acquires) {
    return (getState() == 0) ? 1 : -1; //奠定了同时获取锁的基础，无论State初始为多少，只能计数等于0时触发
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和Semaphore区别有两个，一是State每次只减少1，同时只有为0时才释放所有等待线程。二是提供了一个超时等待方法。acquireSharedInterruptibly方法跟Semaphore一样，就不细说了，这里重点说下tryAcquireSharedNanos方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquireShared(arg) &amp;gt;= 0 ||
        doAcquireSharedNanos(arg, nanosTimeout);
}

//最小自旋时间
static final long spinForTimeoutThreshold = 1000L;

private boolean doAcquireSharedNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (nanosTimeout &amp;lt;= 0L)
        return false;
    final long deadline = System.nanoTime() + nanosTimeout; //计算了一个deadline
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return true;
                }
            }
            nanosTimeout = deadline - System.nanoTime(); 
            if (nanosTimeout &amp;lt;= 0L) //超时后直接返回false，继续执行
                return false;
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                nanosTimeout &amp;gt; spinForTimeoutThreshold) //大于最小cas操作时间则挂起线程
                LockSupport.parkNanos(this, nanosTimeout); //挂起线程也有超时限制
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点看标了注释的几行代码，首先计算了一个超时时间，当超时后直接退出等待，继续执行。如果未超时并且大于最小的cas操作时间，这里定义的是1000ns，则挂起，同时挂起操作也有超时限制。这样就实现了超时等待。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4.总结&lt;/h2&gt;
&lt;p&gt;至此关于AQS的共享锁的两个实现Semaphore与CountDownLatch就分析完了，他们与非共享最大的区别就在于是否能多个线程同时获取锁。看完后希望大家能对Semaphore与CountDownLatch有深刻的理解，不明白的时候想想旋转寿司店和游乐场的例子，如果对大家有帮助，觉得写的好的话，可以点个赞，当然更希望大家能积极指出文中的错误和提出积极的改进意见。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 23:30:00 +0000</pubDate>
<dc:creator>knock_小新</dc:creator>
<og:description>引言 上一篇文章中详细分析了基于AQS的ReentrantLock原理，ReentrantLock通过AQS中的state变量0和1之间的转换代表了独占锁。那么可以思考一下，当state变量大于1时代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/konck/p/9473591.html</dc:identifier>
</item>
<item>
<title>滚动 docker 中的 nginx 日志 - sparkdev</title>
<link>http://www.cnblogs.com/sparkdev/p/9537520.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sparkdev/p/9537520.html</guid>
<description>&lt;p&gt;&lt;span&gt;Nginx 自己没有处理日志的滚动问题，它把这个球踢给了使用者。一般情况下，你可以使用 logrotate 工具来完成这个任务，或者如果你愿意，你可以写各式各样的脚本完成同样的任务。本文笔者介绍如何滚动运行在 docker 中的 nginx 日志文件(下图来自互联网)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201808/952033-20180826151015024-952153251.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Nginx 官方其实给出了如何滚动日志的说明：&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;Rotating Log-files&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;In order to rotate log files, they need to be renamed first. After that USR1 signal should be sent to the master process. The master process will then re-open all currently open log files and assign them an unprivileged user under which the worker processes are running, as an owner. After successful re-opening, the master process closes all open files and sends the message to worker process to ask them to re-open files. Worker processes also open new files and close old files right away. As a result, old files are almost immediately available for post processing, such as compression.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这段说明的大意是：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;先把旧的日志文件重命名&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后给 nginx master 进程发送 USR1 信号&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;nginx master 进程收到信号后会做一些处理，然后要求工作者进程重新打开日志文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;工作者进程打开新的日志文件并关闭旧的日志文件&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其实真正需要我们做的工作只有前面两点！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设你的系统中已经安装好了 docker，这里我们直接运行一个 nginx 容器：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ docker run -&lt;span&gt;d \
    &lt;/span&gt;-p &lt;span&gt;80&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;&lt;span&gt; \
    &lt;/span&gt;-v $(&lt;span&gt;pwd&lt;/span&gt;)/logs/nginx:/var/log/&lt;span&gt;nginx \
    &lt;/span&gt;--restart=&lt;span&gt;always \
    &lt;/span&gt;--name=&lt;span&gt;mynginx \
    nginx:&lt;/span&gt;&lt;span&gt;1.11&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意，我们把 nginx 的日志绑定挂载到了当前目录下的 logs 目录下。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;把下面的内容保存到 test.sh 文件中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ((i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=&lt;span&gt;100000&lt;/span&gt;;i++&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
    curl http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost &amp;gt; /dev/null&lt;/span&gt;
    &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后运行这个脚本，就可以模拟产生连续的日志记录。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;创建 rotatelog.sh 文件，其内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

getdatestring()
{
    TZ&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Asia/Chongqing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;date&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+%Y%m%d%H%M&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}
datestring&lt;/span&gt;=&lt;span&gt;$(getdatestring)

&lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; /var/log/nginx/access.log /var/log/nginx/&lt;span&gt;access.${datestring}.log
&lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; /var/log/nginx/error.log /var/log/nginx/&lt;span&gt;error.${datestring}.log
&lt;/span&gt;&lt;span&gt;kill&lt;/span&gt; -USR1 `&lt;span&gt;cat&lt;/span&gt; /var/run/nginx.pid`
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;getdatestring 函数取当前的时间并格式化为字符串，比如 &quot;201807241310&quot;，笔者比较喜欢用日期和时间来命名文件。注意这里通过 TZ='Asia/Chongqing' 指定了时区，因为默认情况下格式化的是 UTC 时间，用起来怪怪的(要实时脑补 +8 小时)。&lt;/span&gt;&lt;span&gt;下面的两条 mv 命令用来重命名日志文件。&lt;/span&gt;&lt;span&gt;最后通过 kill 命令向 nginx master 进程发送 USR1 信号。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过下面的命令为 rotatelog.sh 文件添加可执行权限并复制到 $(pwd)/logs/nginx 目录下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;chmod&lt;/span&gt; +x rotatelog.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
$ &lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;cp&lt;/span&gt; rotatelog.&lt;span&gt;sh&lt;/span&gt; $(&lt;span&gt;pwd&lt;/span&gt;)/logs/nginx
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们的 nginx 运行在容器中，所以需要在容器中给 nginx master 进程发送 USR1 信号。因此我们需要通过 docker exec 命令在 mynginx 容器中执行 rotatelog.sh 脚本：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker exec mynginx bash /var/log/nginx/rotatelog.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行一次上面的命令，会如期产生一批新的日志文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201808/952033-20180826151229421-342171949.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们把这个命令配置在定时任务中，让它每天早上 1 点钟执行一次。执行 crontab -e 命令，并在文件的末尾添加下面的行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
* &lt;span&gt;1&lt;/span&gt; * * * docker exec mynginx bash /var/log/nginx/rotatelog.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201808/952033-20180826151259774-1652685460.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;保存并退出就可以了。下图是笔者测试过程中每 5 分钟滚动一次的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201808/952033-20180826151329336-1434362812.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;理论上这么做是可以的，因为通过绑定挂载的数据卷中的内容从宿主机上看和从容器中看都是一样的。但是真正这么做的时候你很可能碰到权限问题。在宿主机中，你一般使用的是普通用户，而在容器中产生的日志文件的所有者是会是特殊的用户，并且一般不会给其它用户写和执行的权限：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201808/952033-20180826151408056-1800472630.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，如果你在宿主机中使用的是 root 用户就不会有问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实这个问题的全称应该是：能从宿主机中给 docker 容器中的 nginx master 进程发送信号吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;答案是，可以的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;笔者这《&lt;a href=&quot;https://www.cnblogs.com/sparkdev/p/7598590.html&quot; target=&quot;_blank&quot;&gt;在 docker 容器中捕获信号&lt;/a&gt;》一文中介绍了容器中信号的捕获问题，感兴趣的朋友可以去看看。在那篇文章中我们介绍了 docker 向容器中进程发送信号的 kill 命令。我们可以通过命令：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ docker container &lt;span&gt;kill&lt;/span&gt; mynginx -s USR1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;向容器中的 1 号进程(nginx master)发送 USR1 信号(这种方式只能向 1 号进程发送信号)：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/952033/201808/952033-20180826151514123-1050265659.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结合上面的两个问题，我们可以写出另外的一种方式来滚动 docker 中的 nginx 日志。这种方式不需要通过 docker exec 命令在容器中执行命令，而完全在宿主机中完成所有的操作：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;先重命名容器数据卷中的日志文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;给容器中的 1 号进程发送 USR1 信号&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;相比之下我还是更喜欢第一种方式，它逻辑上清晰，操作上几乎与宿主机完全隔离，也不容易出错。但是通过第二种方式的尝试，我们不但可以找到新的实现方式，还会加深对容器操作的理解。学而不思则罔啊！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-configure-logging-and-log-rotation-in-nginx-on-an-ubuntu-vps&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;How To Configure Logging and Log Rotation in Nginx on an Ubuntu VPS&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-manage-logfiles-with-logrotate-on-ubuntu-16-04&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;How To Manage Logfiles with Logrotate on Ubuntu 16.04&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 23:15:00 +0000</pubDate>
<dc:creator>sparkdev</dc:creator>
<og:description>Nginx 自己没有处理日志的滚动问题，它把这个球踢给了使用者。一般情况下，你可以使用 logrotate 工具来完成这个任务，或者如果你愿意，你可以写各式各样的脚本完成同样的任务。本文笔者介绍如何滚</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sparkdev/p/9537520.html</dc:identifier>
</item>
<item>
<title>ELK日志系统之使用Rsyslog快速方便的收集Nginx日志 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/9557969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/9557969.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;常规的日志收集方案中Client端都需要额外安装一个Agent来收集日志，例如logstash、filebeat等，额外的程序也就意味着环境的复杂，资源的占用，有没有一种方式是不需要额外安装程序就能实现日志收集呢？Rsyslog就是你要找的答案！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Rsyslog是高速的日志收集处理服务，它具有高性能、安全可靠和模块化设计的特点，能够接收来自各种来源的日志输入（例如：file，tcp，udp，uxsock等），并通过处理后将结果输出的不同的目的地（例如：mysql，mongodb，elasticsearch，kafka等），每秒处理日志量能够超过百万条。&lt;/p&gt;
&lt;p&gt;Rsyslog作为syslog的增强升级版本已经在各linux发行版&lt;strong&gt;默认安装&lt;/strong&gt;了，无需额外安装。&lt;/p&gt;

&lt;p&gt;ELK通过Rsyslog收集日志流程图如下：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/30/16587d1d4bd17a5d?w=1209&amp;amp;h=620&amp;amp;f=png&amp;amp;s=51937&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;处理流程为：Nginx --syslog--&amp;gt; Rsyslog --omkafka--&amp;gt; Kafka --&amp;gt; Logstash --&amp;gt; Elasticsearch --&amp;gt; Kibana&lt;/li&gt;
&lt;li&gt;Nginx产生日志通过syslog系统服务传给Rsyslog服务端，Rsyslog接收到日志后通过omkafka模块将日志写入Kafka，Logstash读取Kafka队列然后写入Elasticsearch，用户通过Kibana检索Elasticsearch里存储的日志&lt;/li&gt;
&lt;li&gt;Rsyslog服务系统自带无需安装，所以整个流程中客户端不需要额外安装应用&lt;/li&gt;
&lt;li&gt;服务端虽然Rsyslog也已安装，但默认没有omkafka模块，如果需要Rsyslog写入Kafka需要先安装这个模块&lt;/li&gt;
&lt;li&gt;omkafka模块在rsyslog v8.7.0之后的版本才支持，所以需要先通过&lt;code&gt;rsyslogd -v&lt;/code&gt;命令查看rsyslog版本，如果版本较低则需要升级&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;rsyslog升级&quot;&gt;Rsyslog升级&lt;/h2&gt;
&lt;p&gt;1.添加rsyslog源的key&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# apt-key adv --recv-keys --keyserver keys.gnupg.net AEF0CF8E&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.添加rsyslog源地址&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo &quot;deb http://debian.adiscon.com/v8-stable wheezy/&quot; &amp;gt;&amp;gt; /etc/apt/sources.list
echo &quot;deb-src http://debian.adiscon.com/v8-stable wheezy/&quot; &amp;gt;&amp;gt; /etc/apt/sources.list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.升级rsyslog服务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# apt-get update &amp;amp;&amp;amp; apt-get -y install rsyslog&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;添加omkafka模块&quot;&gt;添加omkafka模块&lt;/h2&gt;
&lt;p&gt;1.安装编译工具，下边autoreconf需要用到，不然无法生成configure文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# apt-get -y install pkg-config autoconf automake libtool unzip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.omkafka需要安装一堆的依赖包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# apt-get -y install libdbi-dev libmysqlclient-dev postgresql-client libpq-dev  libnet-dev   librdkafka-dev   libgrok-dev libgrok1 libgrok-dev libpcre3-dev libtokyocabinet-dev libglib2.0-dev  libmongo-client-dev  libhiredis-dev
# apt-get -y install libestr-dev libfastjson-dev uuid-dev liblogging-stdlog-dev libgcrypt-dev
# apt-get -y install flex bison librdkafka1 librdkafka-dev librdkafka1-dbg&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.编译安装omkafka模块&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# mkdir tmp &amp;amp;&amp;amp; cd tmp

# git init
# git pull git@github.com:VertiPub/omkafka.git

# autoreconf -fvi
# ./configure --sbindir=/usr/sbin --libdir=/usr/lib --enable-omkafka &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install &amp;amp;&amp;amp; cd ..&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;rsyslog收集nginx日志&quot;&gt;Rsyslog收集nginx日志&lt;/h2&gt;
&lt;h5 id=&quot;client端nginx配置&quot;&gt;Client端Nginx配置&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;log_format  jsonlog '{'
    '&quot;host&quot;: &quot;$host&quot;,'
    '&quot;server_addr&quot;: &quot;$server_addr&quot;,'
    '&quot;http_x_forwarded_for&quot;:&quot;$http_x_forwarded_for&quot;,'
    '&quot;remote_addr&quot;:&quot;$remote_addr&quot;,'
    '&quot;time_local&quot;:&quot;$time_local&quot;,'
    '&quot;request_method&quot;:&quot;$request_method&quot;,'
    '&quot;request_uri&quot;:&quot;$request_uri&quot;,'
    '&quot;status&quot;:$status,'
    '&quot;body_bytes_sent&quot;:$body_bytes_sent,'
    '&quot;http_referer&quot;:&quot;$http_referer&quot;,'
    '&quot;http_user_agent&quot;:&quot;$http_user_agent&quot;,'
    '&quot;upstream_addr&quot;:&quot;$upstream_addr&quot;,'
    '&quot;upstream_status&quot;:&quot;$upstream_status&quot;,'
    '&quot;upstream_response_time&quot;:&quot;$upstream_response_time&quot;,'
    '&quot;request_time&quot;:$request_time'
'}';


access_log syslog:server=rsyslog.domain.com,facility=local7,tag=nginx_access_log,severity=info jsonlog;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.Nginx在&lt;strong&gt;v1.10之后&lt;/strong&gt;的版本才支持syslog的方式处理日志，请确保你的Nginx版本高于1.10&lt;/p&gt;
&lt;p&gt;2.为了降低logstash的处理压力，同时也为了降低整个配置的复杂度，我们nginx的日志直接采用json格式&lt;/p&gt;
&lt;p&gt;3.抛弃文本文件记录nginx日志，改用syslog直接将日志传输到远端的rsyslog服务器，以便我们后续的处理；这样做的另一个非常重要的好处是我们再也无需考虑nginx日志的分割和定期删除问题（一般我们为了方便管理通常会采用logrotate服务来对日志进行按天拆分和定期删除,以免磁盘被占满）&lt;/p&gt;
&lt;p&gt;4.access_log直接输出到syslog服务，各参数解释如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;syslog&lt;/strong&gt;：指明日志用syslog服务接收&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;server&lt;/strong&gt;：接收syslog发送日志的Rsyslog服务端地址，默认使用udp协议，端口是514&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;facility&lt;/strong&gt;：指定记录日志消息的类型，例如认证类型auth、计划任务cron、程序自定义的local0-7等，没有什么特别的含义，不必深究，默认的值是local7&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tag&lt;/strong&gt;：给日志添加一个tag，主要是为了方便我们在服务端区分是哪个服务或者client传来的日志，例如我们这里给了tag：&lt;code&gt;nginx_access_log&lt;/code&gt;，如果有多个服务同时都写日志给rsyslog，且配置了不通的tag，在rsyslog服务端就可以根据这个tag找出哪些是nginx的日志&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;severity&lt;/strong&gt;：定义日志的级别，例如debug，info，notice等，默认是error&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;server端rsyslog配置&quot;&gt;Server端Rsyslog配置&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;# cat /etc/rsyslog.d/rsyslog_nginx_kafka_cluster.conf 
module(load=&quot;imudp&quot;)
input(type=&quot;imudp&quot; port=&quot;514&quot;)

# nginx access log ==&amp;gt; rsyslog server(local) ==&amp;gt; kafka
module(load=&quot;omkafka&quot;)

template(name=&quot;nginxLog&quot; type=&quot;string&quot; string=&quot;%msg%&quot;)

if $inputname == &quot;imudp&quot; then {
    if ($programname == &quot;nginx_access_log&quot;) then
        action(type=&quot;omkafka&quot;
            template=&quot;nginxLog&quot;
            broker=[&quot;10.82.9.202:9092&quot;,&quot;10.82.9.203:9092&quot;,&quot;10.82.9.204:9092&quot;]
            topic=&quot;rsyslog_nginx&quot;
            partitions.auto=&quot;on&quot;
            confParam=[
                &quot;socket.keepalive.enable=true&quot;
            ]
        )
}

:rawmsg, contains, &quot;nginx_access_log&quot; ~&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1.在rsyslog.d目录下添加一个专门处理nginx日志的配置文件&lt;/p&gt;
&lt;p&gt;2.rsyslog配置文件重要配置解释如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;module&lt;/strong&gt;：加载模块，这里我们需要加载imudp模块来接收nginx服务器syslog发过来的日志数据，也需要加载omkafka模块来将日志写入到kafka&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;input&lt;/strong&gt;：开启udp协议，端口514，也可以同时开启tcp协议，两者可以共存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;template&lt;/strong&gt;：定义一个模板，名字叫nginxLog，模板里可以定义日志的格式，因为我们传的已经是json了，不需要再匹配格式，所以这里不额外定义，注意模板名字要唯一&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;action&lt;/strong&gt;：在匹配到inputname为&lt;code&gt;imudp&lt;/code&gt;且programname为&lt;code&gt;nginx_access_log&lt;/code&gt;（就是我们上边nginx配置里边的tag）之后的处理方式，这里的配置为匹配到的日志通过omkafka模块写入kafka集群，还有一些关于omkafka更详细的配置参考上边给出的omkafka模块官方文档&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:rawmsg, contains&lt;/strong&gt;：最后这一行的意思是忽略包含&lt;code&gt;nginx_access_log&lt;/code&gt;的日志，没有这一行的话rsyslog服务默认会把所有日志都记录到message里边一份，我们已经把日志输出到kafka了，本地就没必要再记录了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.omkafka模块检查kafka里边topic是否存在，如果不存在则创建，无需手动创建kafka的topic&lt;/p&gt;
&lt;h5 id=&quot;server端logstash配置&quot;&gt;Server端logstash配置&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;input {
    kafka {
        bootstrap_servers =&amp;gt; &quot;10.82.9.202:9092,10.82.9.203:9092,10.82.9.204:9092&quot;
        topics =&amp;gt; [&quot;rsyslog_nginx&quot;]
    }
}

filter {
    mutate {
        gsub =&amp;gt; [&quot;message&quot;, &quot;\\x&quot;, &quot;\\\x&quot;]
    }

    json {
        source =&amp;gt; &quot;message&quot;
    }

    date {
        match =&amp;gt; [&quot;time_local&quot;,&quot;dd/MMM/yyyy:HH:mm:ss Z&quot;]
        target =&amp;gt; &quot;@timestamp&quot;
    }

}

output {
    elasticsearch {
        hosts =&amp;gt; [&quot;10.82.9.205&quot;, &quot;10.82.9.206&quot;, &quot;10.82.9.207&quot;]
        index =&amp;gt; &quot;rsyslog-nginx-%{+YYYY.MM.dd}&quot;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重要配置参数解释如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;input&lt;/strong&gt;：配置kafka的集群地址和topic名字&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;filter&lt;/strong&gt;：一些过滤策略，因为传入kafka的时候是json格式，所以不需要额外处理，唯一需要注意的是如果日志中有中文，例如url中有中文内容时需要替换&lt;code&gt;\\x&lt;/code&gt;，不然json格式会报错&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;output&lt;/strong&gt;：配置ES服务器集群的地址和index，index自动按天分割&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;联调测试&quot;&gt;联调测试&lt;/h5&gt;
&lt;p&gt;配置完成后分别重启rsyslog服务和nginx服务，访问nginx产生日志&lt;/p&gt;
&lt;p&gt;1.查看kafka是否有正常生成topic&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# bin/kafka-topics.sh --list --zookeeper 127.0.0.1:2181
__consumer_offsets
rsyslog_nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.查看topic是否能正常接收日志&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic rsyslog_nginx
{&quot;host&quot;: &quot;domain.com&quot;,&quot;server_addr&quot;: &quot;172.17.0.2&quot;,&quot;http_x_forwarded_for&quot;:&quot;58.52.198.68&quot;,&quot;remote_addr&quot;:&quot;10.120.89.84&quot;,&quot;time_local&quot;:&quot;28/Aug/2018:14:26:00 +0800&quot;,&quot;request_method&quot;:&quot;GET&quot;,&quot;request_uri&quot;:&quot;/&quot;,&quot;status&quot;:200,&quot;body_bytes_sent&quot;:1461,&quot;http_referer&quot;:&quot;-&quot;,&quot;http_user_agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;,&quot;upstream_addr&quot;:&quot;-&quot;,&quot;upstream_status&quot;:&quot;-&quot;,&quot;upstream_response_time&quot;:&quot;-&quot;,&quot;request_time&quot;:0.000}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.kibana添加index，查看Elasticsearch中是否有数据，如果前两步都正常，kibana搜不到index或index没有数据，多半是index名字写错了之类的基础问题，仔细检查&lt;/p&gt;
&lt;h2 id=&quot;kibana查询展示&quot;&gt;kibana查询展示&lt;/h2&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;打开Kibana添加&lt;code&gt;rsyslog-nginx-*&lt;/code&gt;的Index，并选择timestamp，创建Index Pattern&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/30/16587d1d4adb76fe?w=1423&amp;amp;h=738&amp;amp;f=png&amp;amp;s=87770&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;进入Discover页面，可以很直观的看到各个时间点请求量的变化，根据左侧Field实现简单过滤，例如我们想查看所有访问状态为404的uri，可以点击request_uri和status后边的add，这两项的内容将出现在右侧，然后点击status下边404状态码后边的加号，则只查看状态为404的请求，点击上方auto-refresh可以设置页面自动刷新时间&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/30/16587d1d49a76e22?w=1422&amp;amp;h=706&amp;amp;f=png&amp;amp;s=89587&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过各种条件的组合查询可以实现各种各样的需求，例如每秒请求、带宽占用、异常比例、慢响应、TOP IP、TOP URL等等各种情况，并且可以通过Visualize很方便的将这些信息绘制图标，生成Dashboard保存&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/30/16587d1d49e20898?w=1423&amp;amp;h=649&amp;amp;f=png&amp;amp;s=70750&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;&lt;li&gt;Nginx的access log绝对是网站的一个宝藏，通过日志量的变化可以知道网站的流量情况，通过对status状态的分析可以知道我们提供服务的可靠性，通过对特定活动url的追踪可以实时了解活动的火爆程度，通过对某些条件的组合查询也能为网站运营提供建议和帮助，从而使我们的网站更友好更易用&lt;/li&gt;
&lt;li&gt;Rsyslog服务的单点问题可以通过部署多个Rsyslog服务过三层负载来保证高可用，不过以我们的经验来说rsyslog服务还是很稳定的，跑了一年多，每分钟日志处理量在20w左右，没有出现过宕机情况，不想这么复杂的话可以写个check rsyslog服务状态的脚本跑后台，挂了自动拉起来&lt;/li&gt;
&lt;li&gt;整个过程中我们使用了UDP协议，第一是因为Nginx日志的syslog模式默认支持的就是UDP协议，翻了官网没找到支持TCP的方式，我想这也是考虑到UDP协议的性能要比TCP好的多，第二也考虑到如果使用TCP遇到网络不稳定的情况下可能会不停的重试或等待，影响到Nginx的稳定。对于因为内容过长超过以太网数据帧长度的问题暂时没有遇到&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/23/16566511aeeda3f3?w=430&amp;amp;h=476&amp;amp;f=jpeg&amp;amp;s=38786&quot; alt=&quot;长按关注公众号查看更多原创文章&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得文章对你有帮助，请转发分享给更多的人。如果你觉得读的不尽兴，推荐阅读以下文章：&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 23:06:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>常规的日志收集方案中Client端都需要额外安装一个Agent来收集日志，例如logstash、filebeat等，额外的程序也就意味着环境的复杂，资源的占用，有没有一种方式是不需要额外安装程序就能实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/37Y37/p/9557969.html</dc:identifier>
</item>
<item>
<title>跟厂长学PHP内核（三）：源码目录结构 - 了不起的厂长</title>
<link>http://www.cnblogs.com/enochzzg/p/9557825.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enochzzg/p/9557825.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上篇文章我们已经介绍了源码分析工具的安装、配置以及调试方法，本文我们来讲述一下PHP源码的目录结构。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以&lt;code&gt;php-7.0.12&lt;/code&gt;为例，看过源码的同学们应该发现源码目录多达十多个，下面是每个目录的说明。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;TSRM&lt;/td&gt;
&lt;td&gt;线程相关安全的实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Zend&lt;/td&gt;
&lt;td&gt;PHP解析器的核心实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;build&lt;/td&gt;
&lt;td&gt;linux下编译相关的目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ext&lt;/td&gt;
&lt;td&gt;PHP的扩展&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;main&lt;/td&gt;
&lt;td&gt;PHP的主要代码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;netware&lt;/td&gt;
&lt;td&gt;网络目录，socket的定义与实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;pear&lt;/td&gt;
&lt;td&gt;PHP扩展及应用的代码仓库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;sapi&lt;/td&gt;
&lt;td&gt;PHP的应用层接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;scripts&lt;/td&gt;
&lt;td&gt;Linux下的脚本目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;tests&lt;/td&gt;
&lt;td&gt;测试脚本目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;travis&lt;/td&gt;
&lt;td&gt;用于构建，非PHP特有目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;win32&lt;/td&gt;
&lt;td&gt;Windows下编译PHP的相关脚本&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;虽然源码目录众多，但是核心目录却只有&lt;code&gt;sapi、main、zend、ext、TSRM&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;sapi&quot;&gt;2.1、SAPI&lt;/h2&gt;
&lt;p&gt;还记得PHP的应用场景吗？我们可以在命令行中访问PHP，也可以通过浏览器访问PHP脚本，甚至可以嵌入到单片机供C、C++程序调用。它们分别对应cli模式、fpm/cgi模式、embed模式，除了这些还有apache2handler、litespeed模式。&lt;br/&gt;&lt;img src=&quot;http://p13vfrwta.bkt.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%283%29.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SAPI全称Server API，负责PHP对外提供服务规范，它定义了结构体&lt;code&gt;sapi_module_struct&lt;/code&gt;，该结构体定义了模式启动、关闭、激活、失效等多个钩子函数指针，每个模式将这些函数指针指向自己的函数，就可以轻松扩展PHP对外服务的方式。以上几种模式也正是实现了&lt;code&gt;sapi_module_strcut&lt;/code&gt;才完成了PHP的多场景应用。&lt;/p&gt;
&lt;h2 id=&quot;main&quot;&gt;2.2、main&lt;/h2&gt;
&lt;p&gt;main目录的作用是承接SAPI的请求，分析出要执行的脚本文件和参数，并对环境和配置进行初始化，比如初始化变量和常量、注册函数、解析配置文件、加载扩展等等。&lt;br/&gt;&lt;img src=&quot;http://p13vfrwta.bkt.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%284%29.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;zend&quot;&gt;2.3、Zend&lt;/h2&gt;
&lt;p&gt;Zend目录就是大家所熟知的Zend引擎，是PHP最核心的部分，主要负责PHP的语法实现、内存管理及脚本的编译运行环境等，它由编译器、执行器两部分组成。&lt;/p&gt;
&lt;p&gt;编译器负责将PHP代码进行词法、语法分析，并生成抽象语法树，然后进一步编译为opcode，opcode是Zend虚拟机可识别的指令，php7一共有173个opcode，所有的语法都是由这些opcode组成的。执行器负责执行编译器输出的opcode。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p13vfrwta.bkt.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%287%29.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ext&quot;&gt;2.4、ext&lt;/h2&gt;
&lt;p&gt;ext是extension的缩写，它是扩展PHP内核功能的一种方式，分为PHP扩展与zend扩展，都支持用户自定义开发，这两种都比较常见，PHP扩展有gd、json、date、array等，而我们熟知的opcache就是Zend扩展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p13vfrwta.bkt.clouddn.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20%288%29.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tsrm&quot;&gt;2.5、TSRM&lt;/h2&gt;
&lt;p&gt;TSRM全称叫做Thread Safe Resource Manager，也就是线程安全资源管理器。&lt;/p&gt;
&lt;p&gt;我们知道，全局变量就是定义在函数外的变量，它属于公共资源，在多线程的环境下，访问公共资源就可能会引起冲突，TSRM就是为解决该问题而诞生的。它为每个线程分配一个独立的自增ID，该ID作为当前线程的全局变量内存区的索引，从而实现线程的完全独立。&lt;/p&gt;
&lt;p&gt;其实PHP大部分SAPI都是单线程的，所以并不需要过多关注线程安全，但是在Apache或者用户自己实现的PHP环境下，就需要考虑线程安全问题了。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 16:49:00 +0000</pubDate>
<dc:creator>了不起的厂长</dc:creator>
<og:description>上篇文章我们已经介绍了源码分析工具的安装、配置以及调试方法，本文我们来讲述一下PHP源码的目录结构。 一、目录概览 以 为例，看过源码的同学们应该发现源码目录多达十多个，下面是每个目录的说明。 目录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enochzzg/p/9557825.html</dc:identifier>
</item>
<item>
<title>iOS 开发之 GCD 不同场景使用 - xiaoyouPrince</title>
<link>http://www.cnblogs.com/xiaoyouPrince/p/9557773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyouPrince/p/9557773.html</guid>
<description>&lt;p&gt;本文在&lt;a href=&quot;https://www.jianshu.com/p/29cc1f3440aa&quot;&gt;iOS 开发值 GCD 基础&lt;/a&gt; 的基础上，继续总结了 GCD 的一些API 和在不同场景下的使用。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;GCD 栅栏方法：dispatch_barrier_async&lt;/h3&gt;
&lt;p&gt;我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于 栅栏 一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。&lt;/p&gt;
&lt;p&gt;dispatch_barrier_async函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在dispatch_barrier_async函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行.&lt;/p&gt;
&lt;p&gt;示意如图：&lt;img src=&quot;https://images2018.cnblogs.com/blog/905487/201808/905487-20180830000749475-497172722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;/**
 * 栅栏方法 dispatch_barrier_async
 */

- (void)barrier {

    // 1. 创建并发队列队列
    dispatch_queue_t queue = dispatch_queue_create(&quot;com.xiaoyouPrince&quot;, DISPATCH_QUEUE_CONCURRENT);

    // 2. 添加异步任务
    dispatch_async(queue, ^{

        // 追加任务1
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
    });

    dispatch_async(queue, ^{
        // 追加任务2
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
    });

    // 栅栏任务
    dispatch_barrier_async(queue, ^{
        // 追加任务 barrier
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;barrier---%@&quot;,[NSThread currentThread]);// 打印当前线程
        }
    });


    dispatch_async(queue, ^{
        // 追加任务3
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
    });

    dispatch_async(queue, ^{
        // 追加任务4
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;4---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
    });
}


------------------打印结果-----------------
1---{number = 4, name = (null)}
2---{number = 3, name = (null)}
1---{number = 4, name = (null)}
2---{number = 3, name = (null)}
barrier---{number = 4, name = (null)}
barrier---{number = 4, name = (null)}
4---{number = 3, name = (null)}
3---{number = 4, name = (null)}
4---{number = 3, name = (null)}
3---{number = 4, name = (null)}
------------------打印结果-----------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在dispatch_barrier_async相关代码执行结果中可以看出：&lt;/p&gt;
&lt;p&gt;在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;GCD 延时执行方法：dispatch_after&lt;/h3&gt;
&lt;p&gt;我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的dispatch_after函数来实现。&lt;/p&gt;
&lt;p&gt;需要注意的是：dispatch_after函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after函数是很有效的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;/**
 * 延时执行方法 dispatch_after
 */

- (void)after {

    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;after---begin&quot;);

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0* NSEC_PER_SEC)), dispatch_get_main_queue(), ^{

        // 2.0秒后异步追加任务代码到主队列，并开始执行
        NSLog(@&quot;after---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    });

}

输出结果：

2018-08-29 17:53:08.713784+0800 GCD-demo[20282:5080295] currentThread---{number = 1, name = main}

2018-08-29 17:53:08.713962+0800 GCD-demo[20282:5080295] after---begin

2018-08-29 17:53:10.714283+0800 GCD-demo[20282:5080295] after---{number = 1, name = main}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在dispatch_after相关代码执行结果中可以看出：在打印 after---begin 之后大约 2.0 秒的时间，打印了 after---{number = 1, name = main}&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;GCD 一次性代码（只执行一次）：dispatch_once&lt;/h3&gt;
&lt;p&gt;我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 dispatch_once 函数。使用dispatch_once 函数能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的环境下，dispatch_once也可以保证线程安全。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;
/**
 * 一次性代码（只执行一次）dispatch_once
 */

- (void)once {

    static dispatch_once_t onceToken;
    dispatch_once(&amp;amp;onceToken, ^{
        // 只执行1次的代码(这里面默认是线程安全的)
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;GCD 快速迭代方法：dispatch_apply&lt;/h3&gt;
&lt;p&gt;通常我们会用 for 循环遍历，但是 GCD 给我们提供了快速迭代的函数dispatch_apply。dispatch_apply按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。&lt;/p&gt;
&lt;p&gt;我们可以利用异步队列同时遍历。比如说遍历 0~5 这6个数字，for 循环的做法是每次取出一个元素，逐个遍历。dispatch_apply可以同时遍历多个数字。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;/**
 * 快速迭代方法 dispatch_apply
 */

- (void)apply {

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    NSLog(@&quot;apply---begin&quot;);

    dispatch_apply(6, queue, ^(size_t index) {
        NSLog(@&quot;%zd---%@&quot;,index, [NSThread currentThread]);
    });
    
    NSLog(@&quot;apply---end&quot;);
}

--------------------输出结果：-------------------

apply---begin

1---{number = 3, name = (null)}
0---{number = 1, name = main}
2---{number = 4, name = (null)}
3---{number = 5, name = (null)}
4---{number = 3, name = (null)}
5---{number = 1, name = main}

apply---end

--------------------输出结果：-------------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 dispatch_apply 相关代码执行结果中可以看出：&lt;/p&gt;
&lt;p&gt;0~5 打印顺序不定，最后打印了 apply---end。&lt;/p&gt;
&lt;p&gt;因为是在并发队列中异步队执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是apply---end一定在最后执行。这是因为 dispatch_apply 函数会等待全部任务执行完毕。&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;GCD 的队列组：dispatch_group&lt;/h3&gt;
&lt;p&gt;有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。&lt;/p&gt;
&lt;p&gt;调用队列组的 dispatch_group_async 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 dispatch_group_enter、dispatch_group_leave 组合 来实现dispatch_group_async。&lt;/p&gt;
&lt;p&gt;调用队列组的 dispatch_group_notify 回到指定线程执行任务。或者使用 dispatch_group_wait回到当前线程继续向下执行（会阻塞当前线程）。&lt;/p&gt;
&lt;h4 id=&quot;toc_6&quot;&gt;dispatch_group_notify&lt;/h4&gt;
&lt;p&gt;监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;/**
 * 队列组 dispatch_group_notify
 */

- (void)groupNotify {

    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;group---begin&quot;);

    // 1. 创建 group
    dispatch_group_t group =  dispatch_group_create();
    
    // 2. 异步执行组内的全局队列任务
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // 追加任务1
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
    });

    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // 追加任务2
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
    });



    dispatch_group_notify(group, dispatch_get_main_queue(), ^{

        // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
        NSLog(@&quot;group---end&quot;);
    });
}

-------------------输出结果：-----------------
currentThread---{number = 1, name = main}
group---begin

 1---{number = 4, name = (null)}
 2---{number = 3, name = (null)}
 2---{number = 3, name = (null)}
 1---{number = 4, name = (null)}
 3---{number = 1, name = main}
 3---{number = 1, name = main}
 
group---end

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从dispatch_group_notify相关代码运行输出结果可以看出：&lt;br/&gt;当所有任务都执行完成之后，才执行 dispatch_group_notify block 中的任务。&lt;/p&gt;
&lt;h4 id=&quot;toc_7&quot;&gt;dispatch_group_wait&lt;/h4&gt;
&lt;p&gt;暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;/**
 * 队列组 dispatch_group_wait
 */
- (void)groupWait {

    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;group---begin&quot;);

    // 1. 创建group
    dispatch_group_t group =  dispatch_group_create();

    // 2. 异步执行组中全局队列任务
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // 追加任务1
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
    });

    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        // 追加任务2
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
    });

    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）
    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
    
    NSLog(@&quot;group---end&quot;);
}

------------------输出结果：------------------

currentThread---{number = 1, name = main}
group---begin
2---{number = 4, name = (null)}
1---{number = 3, name = (null)}
2---{number = 4, name = (null)}
1---{number = 3, name = (null)}
group---end
------------------输出结果：------------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从dispatch_group_wait相关代码运行输出结果可以看出：&lt;/p&gt;
&lt;p&gt;当所有任务执行完成之后，才执行 dispatch_group_wait 之后的操作。但是，使用dispatch_group_wait 会阻塞当前线程。&lt;/p&gt;
&lt;h4 id=&quot;toc_8&quot;&gt;dispatch_group_enter、dispatch_group_leave&lt;/h4&gt;
&lt;p&gt;dispatch_group_enter 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1&lt;/p&gt;
&lt;p&gt;dispatch_group_leave 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。&lt;/p&gt;
&lt;p&gt;当 group 中未执行完毕任务数为0的时候，才会使dispatch_group_wait解除阻塞，以及执行追加到dispatch_group_notify中的任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;/**
 * 队列组 dispatch_group_enter、dispatch_group_leave
 */
- (void)groupEnterAndLeave
{

    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;group---begin&quot;);

    // 1.创建 group
    dispatch_group_t group = dispatch_group_create();

    // 2. 获取全局并发队列
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    // 3. 进入 group 中执行
    dispatch_group_enter(group);

    // 3.1. 向队列中异步执行任务
    dispatch_async(queue, ^{

        // 追加任务1
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
        
        // 3.2. 任务执行之后，离开组【leave 和 enter 必须成对使用】
        dispatch_group_leave(group);
    });


    // 4. 再次进入组执行新的任务
    dispatch_group_enter(group);
    // 4.1. 向队列中异步执行任务
    dispatch_async(queue, ^{

        // 追加任务2
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;2---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
        
        // 4.2. 任务执行之后，离开组【leave 和 enter 必须成对使用】
        dispatch_group_leave(group);
    });


    // group 内部的任务都执行完之后通知执行下面代码
    dispatch_group_notify(group, dispatch_get_main_queue(), ^{

        // 等前面的异步操作都执行完毕后，回到主线程.
        for(inti = 0; i &amp;lt; 2; ++i) {
            [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
            NSLog(@&quot;3---%@&quot;,[NSThread currentThread]);      // 打印当前线程
        }
        NSLog(@&quot;group---end&quot;);
    });
}


-------------------输出结果------------------
currentThread---{number = 1, name = main}
group---begin
1---{number = 4, name = (null)}
2---{number = 3, name = (null)}
1---{number = 4, name = (null)}
2---{number = 3, name = (null)}
3---{number = 1, name = main}
3---{number = 1, name = main}
group---end
-------------------输出结果------------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从dispatch_group_enter、dispatch_group_leave相关代码运行结果中可以看出：当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。&lt;strong&gt;这里的dispatch_group_enter、dispatch_group_leave组合，其实等同于dispatch_group_async。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;toc_9&quot;&gt;GCD 信号量：dispatch_semaphore&lt;/h3&gt;
&lt;p&gt;GCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 Dispatch Semaphore 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。Dispatch Semaphore 提供了三个函数。&lt;/p&gt;
&lt;p&gt;dispatch_semaphore_create：创建一个Semaphore并初始化信号的总量&lt;/p&gt;
&lt;p&gt;dispatch_semaphore_signal：发送一个信号，让信号总量加1&lt;/p&gt;
&lt;p&gt;dispatch_semaphore_wait：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。&lt;/p&gt;
&lt;p&gt;注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。&lt;/p&gt;
&lt;p&gt;Dispatch Semaphore 在实际开发中主要用于：&lt;/p&gt;
&lt;p&gt;保持线程同步，将异步执行任务转换为同步执行任务&lt;/p&gt;
&lt;p&gt;保证线程安全，为线程加锁&lt;/p&gt;
&lt;h4 id=&quot;toc_10&quot;&gt;Dispatch Semaphore 线程同步&lt;/h4&gt;
&lt;p&gt;我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 tasksForKeyPath: 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;- (NSArray *)tasksForKeyPath:(NSString *)keyPath {

    __block NSArray *tasks = nil;

    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {

        if([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) {

            tasks = dataTasks;

        } else if([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) {

            tasks = uploadTasks;

        } else if([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) {

            tasks = downloadTasks;

        } else if([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) {

            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;];

        }
        
        dispatch_semaphore_signal(semaphore);
    }];

    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    
    return tasks;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;/**
 * semaphore 线程同步
 */

- (void)semaphoreSync {

    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程

    NSLog(@&quot;semaphore---begin&quot;);

    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);

    __block int number = 0;

    dispatch_async(queue, ^{

        // 追加任务1
        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
        NSLog(@&quot;1---%@&quot;,[NSThread currentThread]);      // 打印当前线程
         
        number = 100;

        dispatch_semaphore_signal(semaphore);
    });

    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

    NSLog(@&quot;semaphore---end,number = %zd&quot;,number);

}


----------------------输出结果-----------------
currentThread---{number = 1, name = main}
semaphore---begin
1---{number = 3, name = (null)}
semaphore---end, number = 100
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 Dispatch Semaphore 实现线程同步的代码可以看到：&lt;/p&gt;
&lt;p&gt;semaphore---end 是在执行完number = 100; 之后才打印的。而且输出结果 number 为 100。这是因为异步执行不会做任何等待，可以继续执行任务。异步执行将任务1追加到队列之后，不做等待，接着执行dispatch_semaphore_wait方法。此时 semaphore == 0，当前线程进入等待状态。然后，异步任务1开始执行。任务1执行到dispatch_semaphore_signal之后，总信号量加1，此时 semaphore == 1，dispatch_semaphore_wait方法检测到总信号量为1，正在被阻塞的线程（主线程）恢复继续执行。最后打印semaphore---end,number = 100。这样就实现了线程同步，将异步执行任务转换为同步执行任务。&lt;/p&gt;
&lt;h4 id=&quot;toc_11&quot;&gt;Dispatch Semaphore 线程安全和线程同步（为线程加锁）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;线程安全：&lt;/strong&gt;如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。&lt;/p&gt;
&lt;p&gt;若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程同步：&lt;/strong&gt;可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。&lt;/p&gt;
&lt;p&gt;举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。&lt;/p&gt;
&lt;p&gt;下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。&lt;/p&gt;
&lt;p&gt;场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。&lt;/p&gt;
&lt;h5 id=&quot;toc_12&quot;&gt;非线程安全（不使用 semaphore）&lt;/h5&gt;
&lt;p&gt;先来看看不考虑线程安全的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;/**
 * 非线程安全：不使用 semaphore
 * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票
 */
- (void)initTicketStatusNotSave {

    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;semaphore---begin&quot;);

    self.ticketSurplusCount = 50; // 初始化车票 50 张

    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.xiaoyouPrince1&quot;, DISPATCH_QUEUE_SERIAL);

    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.xiaoyouPrince2&quot;, DISPATCH_QUEUE_SERIAL);

    // 北京窗口异步执行卖票操作
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketNotSafe];
    });

    // 上海窗口异步执行卖票操作
    dispatch_async(queue2, ^{
        [weakSelf saleTicketNotSafe];
    });
}



/**
 * 售卖火车票(非线程安全)
 */

- (void)saleTicketNotSafe {

    while(1) {
    
        if(self.ticketSurplusCount &amp;gt; 0) {  //如果还有票，继续售卖
            self.ticketSurplusCount--;

            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);
            [NSThread sleepForTimeInterval:0.2];
            
        } else{ //如果已卖完，关闭售票窗口

            NSLog(@&quot;票已经售完&quot;);
            break;
        }
    }
}


----------------- 输出结果（部分打印） -------------------
currentThread &amp;lt;NSThread: 0x608000079280&amp;gt;{number = 1, name = main}
non_semaphore_begin
剩余票数 48,窗口:{number = 4, name = (null)}
剩余票数 49,窗口:{number = 3, name = (null)}
剩余票数 47,窗口:{number = 4, name = (null)}
剩余票数 46,窗口:{number = 3, name = (null)}
剩余票数 45,窗口:{number = 4, name = (null)}
剩余票数 44,窗口:{number = 3, name = (null)}
剩余票数 43,窗口:{number = 4, name = (null)}
剩余票数 42,窗口:{number = 3, name = (null)}
剩余票数 40,窗口:{number = 4, name = (null)}
剩余票数 41,窗口:{number = 3, name = (null)}
剩余票数 39,窗口:{number = 4, name = (null)}
剩余票数 0,窗口:{number = 3, name = (null)}
...\
票已经售完
票已经售完
----------------- 输出结果（部分打印） -------------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。&lt;/p&gt;
&lt;h5 id=&quot;toc_13&quot;&gt;线程安全（使用 semaphore 加锁）&lt;/h5&gt;
&lt;p&gt;考虑线程安全的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-objc&quot;&gt;/**

 * 线程安全：使用 semaphore 加锁
 * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
 */

- (void)initTicketStatusSave {

    NSLog(@&quot;currentThread---%@&quot;,[NSThread currentThread]);  // 打印当前线程
    NSLog(@&quot;semaphore---begin&quot;);
    
    // 有成员变量 dispatch_semaphore_t semaphreLock
    semaphreLock = dispatch_semaphore_create(1);
    
    self.ticketSurplusCount = 50;
    
    // queue1 代表北京火车票售卖窗口
    dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.xiaoyouPrince1&quot;, DISPATCH_QUEUE_SERIAL);

    // queue2 代表上海火车票售卖窗口
    dispatch_queue_t queue2 = dispatch_queue_create(&quot;com.xiaoyouPrince2&quot;, DISPATCH_QUEUE_SERIAL);
    
    __weak typeof(self) weakSelf = self;
    dispatch_async(queue1, ^{
        [weakSelf saleTicketSafe];
    });

    dispatch_async(queue2, ^{
        [weakSelf saleTicketSafe];
    });
}

/**
 * 售卖火车票(线程安全)
 */
- (void)saleTicketSafe {

    while(1) {

        // 相当于加锁
        dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);

        if(self.ticketSurplusCount &amp;gt; 0) {  //如果还有票，继续售卖

            self.ticketSurplusCount--;

            NSLog(@&quot;%@&quot;, [NSString stringWithFormat:@&quot;剩余票数：%d 窗口：%@&quot;, self.ticketSurplusCount, [NSThread currentThread]]);

            [NSThread sleepForTimeInterval:0.2];

        } else{ //如果已卖完，关闭售票窗口

            NSLog(@&quot;车票已经售完&quot;);
            
            // 相当于解锁
            dispatch_semaphore_signal(semaphoreLock);
            break;
        }
        
        // 相当于解锁
        dispatch_semaphore_signal(semaphoreLock);
    }
}

----------------- 输出结果（部分打印） -------------------
currentThread &amp;lt;NSThread: 0x608000079280&amp;gt;{number = 1, name = main}
non_semaphore_begin
剩余票数 49,窗口:{number = 4, name = (null)}
剩余票数 48,窗口:{number = 3, name = (null)}
剩余票数 47,窗口:{number = 4, name = (null)}
剩余票数 46,窗口:{number = 3, name = (null)}
剩余票数 45,窗口:{number = 4, name = (null)}
....\
剩余票数 4,窗口:{number = 3, name = (null)}
剩余票数 3,窗口:{number = 4, name = (null)}
剩余票数 2,窗口:{number = 3, name = (null)}
剩余票数 1,窗口:{number = 4, name = (null)}
剩余票数 0,窗口:{number = 3, name = (null)}
票已经售完
----------------- 输出结果（部分打印） -------------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，在考虑了线程安全的情况下，使用dispatch_semaphore 机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。&lt;/p&gt;
&lt;p&gt;创建一个 semaphoreLock 对象。后续可能有多个线程同时访问被车票余量，当有线程访问到票余量时进行 dispatch_semaphore_wait 操作。使得 semaphoreLock 总信号量 减 1 (等于0 ，相当于加锁) ，并继续操作票余量，进行一次 self.ticketSurplusCount-- 操作。当票数量减少之后执行 dispatch_semaphore_signal 使得 semaphoreLock 总信号量 + 1 (等于1 ，相当于解锁)&lt;/p&gt;
&lt;p&gt;此过程中如果有其他并发线程要访问 票余量。同样会先来到 dispatch_semaphore_wait 操作。此时 semaphoreLock 的总信号量为 0 ，直接阻塞线程。当上一个访问余量的线程操作完成之后执行 dispatch_semaphore_signal 操作解锁之后，就会继续本线程的访问。从而确保了票余量的线程安全。&lt;/p&gt;
&lt;p&gt;资料：&lt;br/&gt;&lt;a href=&quot;https://developer.apple.com/documentation/dispatch?changes=latest_major&amp;amp;language=objc&quot;&gt;最新官方文档&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 16:09:00 +0000</pubDate>
<dc:creator>xiaoyouPrince</dc:creator>
<og:description>iOS 开发之 GCD 不同场景使用 本文在iOS 开发值 GCD 基础 的基础上，继续总结了 GCD 的一些API 和在不同场景下的使用。 GCD 栅栏方法：dispatch_barrier_asy</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoyouPrince/p/9557773.html</dc:identifier>
</item>
<item>
<title>Jenkins - Extended E-mail配置教程 - _小喜</title>
<link>http://www.cnblogs.com/xiaoxi-3-/p/9557766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxi-3-/p/9557766.html</guid>
<description>&lt;p&gt;在Jenkins的使用中邮件提醒是一个常用功能，&lt;a href=&quot;https://wiki.jenkins.io/display/JENKINS/Email-ext+plugin&quot;&gt;Extended E-mail Notification&lt;/a&gt;是一个功能更为齐全，使用也更为复杂的插件，本文即将为大家详细讲解如何配置相关内容，感兴趣的话继续往下看吧！～～&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;一全局设置&quot;&gt;一、全局设置&lt;/h4&gt;
&lt;p&gt;进入系统管理- 系统设置 - Extended E-mail Notification&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;⚠️注意事项：&lt;br/&gt;1)如果设置QQ邮箱的话，密码必须为授权码，方法为：登录QQ邮箱，在“帐户”里开启“POP3/SMTP”并获取授权码。（否则报错535）&lt;br/&gt;2)必须勾选【Use SMTP Authentication】【Use SSL】&lt;br/&gt;3)用户名必须与系统管理员邮件地址保持一致。（否则报错501）&lt;br/&gt;4)设置接收人（Recipients）,多个接收人时用英文空格分隔。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、SMTP基础设置，见下图：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7116457-02cdf86c32e4ad6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7116457-a7b655bbcc4a3155.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;2、拓展设置，见下图：&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7116457-a3b2c98020988b41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7116457-bcdb4de09a0c755d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7116457-e84837d71e736ee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;设置好以上内容后，点击保存。即全局设置完成～～&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;二job中使用extended-e-mail&quot;&gt;二、Job中使用Extended E-mail&lt;/h4&gt;
&lt;p&gt;1、在Job的“构建后操作”中选择“Editable Email Notification”选项即可使用Extended E-mail Notification插件。&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7116457-d2dc1dd424a68152.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7116457-c01880a4e75251fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7116457-f7b55463679fc80b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;设置好以上内容后，点击保存。即Job中使用Extended E-mail设置完成～～&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;三default-content&quot;&gt;三、Default Content&lt;/h4&gt;
&lt;p&gt;以下为我的Default Content，仅供参考：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&amp;lt;title&amp;gt;${PROJECT_NAME}-第${BUILD_NUMBER}次构建日志&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
 
&amp;lt;body leftmargin=&quot;8&quot; marginwidth=&quot;0&quot; topmargin=&quot;8&quot; marginheight=&quot;4&quot;
    offset=&quot;0&quot;&amp;gt;
    &amp;lt;table width=&quot;95%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;
        style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;(本邮件是程序自动下发的，请勿回复！)&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;br /&amp;gt;
            &amp;lt;b&amp;gt;&amp;lt;font color=&quot;#0B610B&quot;&amp;gt;构建信息($BUILD_STATUS)&amp;lt;/font&amp;gt;&amp;lt;/b&amp;gt;
            &amp;lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;ul&amp;gt;
                    &amp;lt;li&amp;gt;项目名称 ： ${PROJECT_NAME}&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;构建编号 ： 第${BUILD_NUMBER}次构建&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;触发原因 ： ${CAUSE}&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;构建日志 ： &amp;lt;a href=&quot;${BUILD_URL}console&quot;&amp;gt;${BUILD_URL}console&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;工作目录 ： &amp;lt;a href=&quot;${PROJECT_URL}ws&quot;&amp;gt;${PROJECT_URL}ws&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;Allure Report ： &amp;lt;a href=&quot;${BUILD_URL}allure&quot;&amp;gt;${BUILD_URL}allure&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;/ul&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;b&amp;gt;&amp;lt;font color=&quot;#0B610B&quot;&amp;gt;构建日志(最后100行):&amp;lt;/font&amp;gt;&amp;lt;/b&amp;gt;
            &amp;lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;textarea cols=&quot;80&quot; rows=&quot;30&quot; readonly=&quot;readonly&quot;
                    style=&quot;font-family: Courier New&quot;&amp;gt;${BUILD_LOG, maxLines=100}&amp;lt;/textarea&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;以上，对你有帮助的话，点赞❤️吧～～&lt;br/&gt;欢迎关注我的&lt;a href=&quot;https://www.jianshu.com/u/da1677475c27&quot;&gt;简书&lt;/a&gt;,&lt;a href=&quot;http://www.cnblogs.com/xiaoxi-3-/&quot;&gt;博客&lt;/a&gt;,&lt;a href=&quot;https://testerhome.com/wangxiaoxi3&quot;&gt;TesterHome&lt;/a&gt;,&lt;a href=&quot;https://github.com/wangxiaoxi3&quot;&gt;Github&lt;/a&gt;～～～&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 16:06:00 +0000</pubDate>
<dc:creator>_小喜</dc:creator>
<og:description>前言： 在Jenkins的使用中邮件提醒是一个常用功能，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxi-3-/p/9557766.html</dc:identifier>
</item>
<item>
<title>spring-AOP - 嗜血蚂蚁</title>
<link>http://www.cnblogs.com/shixiemayi/p/9557638.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shixiemayi/p/9557638.html</guid>
<description>&lt;p&gt;Spring提供了一个AOP框架，让我把切面插入到方法执行的周围。&lt;/p&gt;
&lt;p&gt;1、概念&lt;/p&gt;
&lt;p&gt;　定义通用功能，通过申明定义这些功能要以何种方式在何处应用，而不需要修改受影响的类。这些通用功能可以模块化为特殊的类，即切面。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接点：连接点是一个应用执行过程中能够插入一个切面的点（Spring只支持方法级别的连接点）&lt;/li&gt;
&lt;li&gt;切点：定义匹配通知织入的一个或多个连接点（在哪做）&lt;/li&gt;
&lt;li&gt;通知：切面的工作（做什么）&lt;/li&gt;
&lt;li&gt;切面：由切点和通知的结合&lt;/li&gt;
&lt;li&gt;织入：把切面应用到目标对象并创建新的代理对象的过程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　通知分类&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前置通知：在目标方法调用之前执行&lt;/li&gt;
&lt;li&gt;后置通知：在目标方法执行之后执行，不管是正常执行还是抛了异常&lt;/li&gt;
&lt;li&gt;返回通知：在目标方法执行成功后执行，不管方法是否有返回值&lt;/li&gt;
&lt;li&gt;异常通知：在目标方法抛出异常后调用&lt;/li&gt;
&lt;li&gt;环绕通知：通知方法将目标方法封装起来，可以达到前几种通知的效果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、Spring切面编程分为：基于注解和基于XML配置形式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于注解形式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先开启Aspect代理功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;aop:aspectj-autoproxy&amp;gt;&amp;lt;/aop:aspectj-autoproxy&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义切面，并将该bean交给spring管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cn.pojo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.JoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; org.aspectj.lang.annotation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
@Aspect
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Audience {

    @Pointcut(&lt;/span&gt;&quot;execution(* com.cn.pojo.Performance.*(..))&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt;  performance(){}

    @Before(&lt;/span&gt;&quot;performance()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; takeSeats(){
        System.out.println( &lt;/span&gt;&quot;Before:take seats!&quot;&lt;span&gt;);
    }

    @After(&lt;/span&gt;&quot;performance()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; goHome(){
        System.out.println(&lt;/span&gt;&quot;After:go home!&quot;&lt;span&gt;);
    }

    @AfterReturning(value &lt;/span&gt;= &quot;performance()&quot;, returning = &quot;result&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; applause(JoinPoint joinPoint,Object result){
        System.out.println(&lt;/span&gt;&quot;AfterReturning:clap clap clap!&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;AfterReturning:&quot;+joinPoint.getArgs()[0&lt;span&gt;]);
        System.out.println(&lt;/span&gt;&quot;AfterReturning:applause-当前在场人数：&quot;+&lt;span&gt;result);
    }

    @AfterThrowing(value &lt;/span&gt;= &quot;performance()&quot;, throwing = &quot;ex&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demandRefund(JoinPoint joinPoint, Exception ex){
        System.out.println(&lt;/span&gt;&quot;AfterThrowing:demanding a refund!&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;AfterThrowing:&quot;+joinPoint.getArgs()[0&lt;span&gt;]);
        System.out.println(&lt;/span&gt;&quot;AfterThrowing:异常信息为 &quot;+&lt;span&gt;ex.getMessage());

    }

    @Around(&lt;/span&gt;&quot;performance()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object all(ProceedingJoinPoint proceedingJoinPoint){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;Around:执行perform方法-前置通知&quot;&lt;span&gt;);
            Object obj&lt;/span&gt;=proceedingJoinPoint.proceed(&lt;span&gt;new&lt;/span&gt; Object[]{189&lt;span&gt;});
            System.out.println(&lt;/span&gt;&quot;Around:执行perform方法-返回通知&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable throwable) {
            System.out.println(&lt;/span&gt;&quot;Around:执行perform方法-异常通知&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;Around:执行perform方法---后置通知&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 除了execution外，还有以下指示器用于定义切点：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td rowspan=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;方法入参切点函数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;args()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;类名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;通过判别目标类方法运行时入参对象的类型定义指定连接点。如args(com.baobaotao.Waiter)表示所有有且仅有一个按类型匹配于Waiter的入参的方法。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;@args()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;类型注&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解类名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;通过判别目标方法的运行时入参对象的类是否标注特定注解来指定连接点。如@args(com.baobaotao.Monitorable)表示任何这样的一个目标方法：它有一个入参且入参对象的类标注@Monitorable注解。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td rowspan=&quot;4&quot;&gt;
&lt;p&gt;&lt;span&gt;目标类切点函数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;within()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;类名匹配串&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;表示特定域下的所有连接点。如within(com.baobaotao.service.*)表示com.baobaotao.service包中的所有连接点，也即包中所有类的所有方法，而within(com.baobaotao.service.*Service)表示在com.baobaotao.service包中，所有以Service结尾的类的所有连接点。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;target()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;类名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;假如目标类按类型匹配于指定类，则目标类的所有连接点匹配这个切点。如通过target(com.baobaotao.Waiter)定义的切点，Waiter、以及Waiter实现类NaiveWaiter中所有连接点都匹配该切点。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;@within()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;类型注解类名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;假如目标类按类型匹配于某个类A，且类A标注了特定注解，则目标类的所有连接点匹配这个切点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如@within(com.baobaotao.Monitorable)定义的切点，假如Waiter类标注了@Monitorable注解，则Waiter以及Waiter实现类NaiveWaiter类的所有连接点都匹配。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;@target()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;类型注解类名&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;目标类标注了特定注解，则目标类所有连接点匹配该切点。如@target(com.baobaotao.Monitorable)，假如NaiveWaiter标注了@Monitorable，则NaiveWaiter所有连接点匹配切点。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;基于XML方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;定义POJO&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.cn.pojo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.JoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Audience {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; takeSeats(){
        System.out.println( &lt;/span&gt;&quot;Before:take seats!&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; goHome(){
        System.out.println(&lt;/span&gt;&quot;After:go home!&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; applause(JoinPoint joinPoint,Object result){
        System.out.println(&lt;/span&gt;&quot;AfterReturning:clap clap clap!&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; demandRefund(JoinPoint joinPoint, Exception ex){
        System.out.println(&lt;/span&gt;&quot;AfterThrowing:demanding a refund!&quot;&lt;span&gt;);

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object all(ProceedingJoinPoint proceedingJoinPoint){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            System.out.println(&lt;/span&gt;&quot;Around:执行perform方法-前置通知&quot;&lt;span&gt;);
            Object obj&lt;/span&gt;=proceedingJoinPoint.proceed(&lt;span&gt;new&lt;/span&gt; Object[]{189&lt;span&gt;});
            System.out.println(&lt;/span&gt;&quot;Around:执行perform方法-返回通知&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable throwable) {
            System.out.println(&lt;/span&gt;&quot;Around:执行perform方法-异常通知&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;Around:执行perform方法---后置通知&quot;&lt;span&gt;);
        }
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将POJO申明为切面，并交spring管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:aspect ref=&quot;audience&quot;&amp;gt;
            &amp;lt;aop:pointcut id=&quot;perform&quot;&lt;span&gt;
                          expression&lt;/span&gt;=&quot;execution(* com.cn.pojo.Performance.*(..))&quot;&amp;gt;&amp;lt;/aop:pointcut&amp;gt;
            &amp;lt;aop:before method=&quot;takeSeats&quot;&lt;span&gt;
                        pointcut&lt;/span&gt;-ref=&quot;perform&quot;&amp;gt;&amp;lt;/aop:before&amp;gt;
            &amp;lt;aop:after method=&quot;goHome&quot;&lt;span&gt;
                       pointcut&lt;/span&gt;-ref=&quot;perform&quot;&amp;gt;&amp;lt;/aop:after&amp;gt;
            &amp;lt;aop:after-returning method=&quot;applause&quot;&lt;span&gt;
                                 pointcut&lt;/span&gt;-ref=&quot;perform&quot;&lt;span&gt;
                                 returning&lt;/span&gt;=&quot;result&quot;&amp;gt;&amp;lt;/aop:after-returning&amp;gt;
            &amp;lt;aop:after-throwing method=&quot;demandRefund&quot;&lt;span&gt;
                                pointcut&lt;/span&gt;-ref=&quot;perform&quot;&lt;span&gt;
                                throwing&lt;/span&gt;=&quot;ex&quot;&amp;gt;&amp;lt;/aop:after-throwing&amp;gt;
            &amp;lt;aop:around method=&quot;all&quot;&lt;span&gt;
                        pointcut&lt;/span&gt;-ref=&quot;perform&quot;&amp;gt;&amp;lt;/aop:around&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
 &amp;lt;/aop:config&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 29 Aug 2018 15:56:00 +0000</pubDate>
<dc:creator>嗜血蚂蚁</dc:creator>
<og:description>Spring提供了一个AOP框架，让我把切面插入到方法执行的周围。 1、概念 定义通用功能，通过申明定义这些功能要以何种方式在何处应用，而不需要修改受影响的类。这些通用功能可以模块化为特殊的类，即切面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shixiemayi/p/9557638.html</dc:identifier>
</item>
<item>
<title>使用Node搭建reactSSR服务端渲染架构 - leung_blog</title>
<link>http://www.cnblogs.com/leungUwah/p/9557738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leungUwah/p/9557738.html</guid>
<description>&lt;p&gt;如题；本文所讲架构主要用到技术栈有：&lt;strong&gt;Node, Express, React, Mobx, webpack4, ES6, ES7, axios, ejs,  log4js, scss，echarts，ant desige&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;使用Express初始化Node服务&lt;/h2&gt;
&lt;p&gt;开始本项目首先你的电脑要安装有node，npm这个没什么好说的。其次本次Node服务用的框架是express；所以要安装：&lt;code class=&quot;language-sh&quot;&gt;express-generator&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后使用express your-project初始化你的express项目&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
npm install express-generator -g &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行这条命令全局安装express-generator，如果你不想全局安装把-g去掉即可&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化express项目之后我们开始把react，webpack整合到这个node服务上。&lt;/p&gt;
&lt;h2&gt;初始化React项目并整合webpack&lt;/h2&gt;
&lt;p&gt;这里整合webpack使用的是webpack4的版本，如果你熟悉vue-cli(vue-cli3之前的版本)的话你应该会知道webpack配置有多少个文件，这里参考了vue-cli生成的webpack配置。&lt;/p&gt;
&lt;h2&gt;添加src文件夹&lt;/h2&gt;
&lt;p&gt;src文件夹下的内容都是整个react的一些核心配置，如请求处理，css样式，公共组件，路由，页面，stores全局状态数据。&lt;/p&gt;
&lt;h2&gt;配置.babelrc&lt;/h2&gt;
&lt;p&gt;因为用到ES6，ES7语法所以要配置.babelrc文件。这个文件东西不多下面直接贴出代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &quot;presets&quot;: [[&quot;es2015&quot;, { &quot;modules&quot;: &lt;span&gt;false&lt;/span&gt; }], &quot;react&quot;, &quot;stage-0&quot;&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &quot;plugins&quot;&lt;span&gt;: [
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &quot;transform-decorators-legacy&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     [&quot;import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;style&quot;: &quot;css&quot;&lt;span&gt; }],
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &quot;transform-runtime&quot;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;  ]
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;修改Node服务app.js&lt;/h2&gt;
&lt;p&gt;其实主要是加上这句：app.use('/', reactSSR); 其就是为了项目启动的时候开启热更新并渲染views中reactSSR.ejs这个模板引擎文件从而达到服务端渲染的目的。&lt;/p&gt;
&lt;h2&gt;项目结构&lt;/h2&gt;
&lt;p&gt;这里把项目主要的文件夹结构放到最后。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/850786/201808/850786-20180829235358411-33191321.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;项目GitHub地址：&lt;a href=&quot;https://github.com/Uwah/node-react&quot; target=&quot;_blank&quot;&gt;https://github.com/Uwah/node-react&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;后期部署上服务器之后会找个时间更新博客，主要是用到pm2&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 15:54:00 +0000</pubDate>
<dc:creator>leung_blog</dc:creator>
<og:description>如题；本文所讲架构主要用到技术栈有：Node, Express, React, Mobx, webpack4, ES6, ES7, axios, ejs, log4js, scss，echa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leungUwah/p/9557738.html</dc:identifier>
</item>
<item>
<title>Netty 学习笔记（1）Netty 通信原理 - dashuai的博客</title>
<link>http://www.cnblogs.com/kubixuesheng/p/9497401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubixuesheng/p/9497401.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180810001534123-208731972.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;138&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      本文主要从 select 和 epoll 系统调用入手，来打开 Netty 的大门，从认识 Netty 的基础原理 —— I/O 多路复用模型开始。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;　　Netty 底层的通信机制是基于I/O多路复用模型构建的，简单一句话概括就是多路网络连接可以复用一个I/O线程，在 Java 层面也就是封装了其 NIO API，但是 JDK 底层基于 Linux 的 epoll 机制实现（其实是三个函数）。注意在老旧的 Linux 上，可能还是 select，没考证过，但是时下主流版本，肯定早就是 epoll 机制了，不妨就认为 JDK NIO 底层是基于 epoll 模型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818170523552-1404067602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　想象这样一个场景：老师站在讲台上提问，下面100个学生把答案写在纸上，谁写完谁举手示意，让老师来检查，完成的好就可以放学回家。如果学生张三举手，李四也举手，就表示他们已经完成了，老师就立即依次去检查张三和李四的答案，检查完毕，老师就可以返回讲台休息或者溜达等等，接着王五，赵四儿又举手，然后老师马上去检查他们的答案。。。以此往复。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818161441966-1980231043.png&quot; alt=&quot;&quot; width=&quot;325&quot; height=&quot;281&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上这种生活现象就是 I/O 多路复用模型，Linux下的 select、poll，和epoll 就是实现的这种机制，这样就避免了大量的无用操作，比如，老师不需要依次的等待一个学生写完了，然后检查一个学生，检查完毕，再去等待下一个学生。。。（对应多客户端单线程模型），也不需要请100个老师，每个老师对应1个学生（一客户端一线程的 BIO 模型），而是让所有学生先自己闷头写答案，写完才主动举手示意，老师在去检查答案，处理完毕，老师就可以走了，继续等待其它学生举手，全程一个老师就能处理（epoll 函数），这就是所谓的非阻塞模式。另外，老师也不需要顺序的询问每个学生的问题完成情况（select 函数）只需要看谁举手。。。这样老师不烦躁，学生也能专心答题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818161614675-970533382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　类比到通信，整个I/O过程只在调用 select、poll、epoll 这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，从而使得系统在单线程（进程）的情况下，可以同时处理多个客户端请求，这就是I/O 多路复用模型。与传统的多线程（单线程）模型相比，I/O多路复用的最大优势就是系统开销小，系统不需要创建新的额外线程，也不需要维护这些线程的运行、切换、同步问题，降低了系统的开发和维护的工作量，节省了时间和系统资源。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;　　主要的应用场景，服务器需要同时处理多个处于监听状态或多个连接状态的套接字，服务器需要同时处理多种网络协议的套接字。&lt;/p&gt;
&lt;p&gt;　　支持I/O多路复用的系统调用主要有select、pselect、poll、epoll。而当前推荐使用的是epoll，优势如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;支持一个进程打开的socket fd（file description）不受限制&lt;/li&gt;
&lt;li&gt;I/O效率不会随着fd数目的增加而线性下将&lt;/li&gt;
&lt;li&gt;使用mmap加速内核与用户空间的消息传递。&lt;/li&gt;
&lt;li&gt;epoll拥有更加简单的API。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;　　而常见的一种 I/O 多路复用模型有所谓的 reactor 模式，Netty 就实现了多线程的 reactor 模型（reactor 模型有三种，单线程，多线程和主从），即当有感兴趣的事件（event）发生，就通知对应的事件处理器（ChannelHandler）去处理这个事件，如果没有就不处理。故用一个线程（NioEventLoop）做轮询就可以了。如果要获得更高性能，可以使用少量的线程，一个负责接收请求（boss NioEventLoopGroup），其他的负责处理请求（worker NioEventLoopGroup），对于多 CPU 时效率会更高（Netty 的线程池会默认启动 2 倍的 CPU 核数个线程）。&lt;/p&gt;
&lt;p&gt;　　后续笔记会详细分析。&lt;/p&gt;


&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　Socket是一种&quot;打开—读/写—关闭&quot;模式的实现，服务器和客户端各自维护一个&quot;文件&quot;，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　不同层次的抽象，对 Socket 的解释是不一样的，在计算机网络中，解释 Socket 是 ip 地址+端口号，都对，主要看是哪一层次的抽象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818172611775-1572576078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在网络编程层次，这些Socket函数是操作系统内核实现的，用户代码无法触及，只能使用，这些内核代码把TCP/IP协议栈和网卡封装，暴露出来对用户友好的API，就成了所谓的 Socket 函数，用户代码可以用这些 Socket 函数操纵本地的TCP/IP协议栈和网卡，和服务器通信。&lt;/p&gt;
&lt;p&gt;　　回到网络层次，OSI 的上三层等价于 TCP/IP 协议族的应用层（典型的 Telnet、FTP 等应用）, OSI 下两层等价于 TCP/IP 协议族中随系统提供的设备驱动程序和硬件。在一个网络程序中, 对应OSI 模型，上三层处理应用本身的细节，却对应用底层的通信细节了解很少；下四层可以处理所有的底层网络的通信细节。OSI 的上三层可以对应所谓的用户进程，下四层通常对应操作系统内核的一部分，因此，把第4层和第5层之间的接口抽象为 Socket API 是自然而然的一个过程，即所谓的 Socket 所处的位置就是 TCP/IP 协议族应用层和传输层的交界处。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818171744001-1567287908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　在 Linux 的网络编程这个层次中，客户机和服务器各有一个Socket文件，当两台主机通信时，客户机里的客户端应用进程 A 发送消息，通过 TCP协议数据包头的 SYN 标志位置1，进行主动打开，经 A 主机的 TCP/IP 协议栈发送到 LAN，然后经 WAN 中的路由器传给服务端应用进程 B 的目的主机所在的 LAN，之后经目的主机的 LAN 将报文传给目的主机，最后经目的主机的 TCP/IP 协议栈处理，服务器被动打开，将消息递交给目的应用程序 B。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818171930048-356912540.png&quot; alt=&quot;&quot; width=&quot;596&quot; height=&quot;366&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　具体分析如下，在连接建立阶段，客户端调用 connect() 函数发起主动连接——触发客户端的 TCP 协议栈发送 SYN 报文，此时客户端处于 SYN-SENT 态，如下。而在此之前，服务端的 Socket 需要已经处于监听态（LISTEN），在 Linux 上就是调用 listen() 函数即可实现监听 Socket。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818173234413-900110860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　服务端的 TCP 协议栈收到该 SYN 报文后，发送给处于 LISTEN 状态的服务端 Socket，服务端应用进程通过调用 accept() 函数触发其 TCP 协议栈发送 SYN+ACK 报文返回给客户端，此时服务端从 LISTEN 态转移到 SYN-RCVD 态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818184111674-32621120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　客户端收到服务端的 SYN+ACK 报文后，发送确认的 ACK 报文，此时客户端从 SYN-SENT 态进入 ESTABLISHED 态，当服务端收到客户端的 ACK 报文后，同样会从 SYN-RCVD 态也进入 ESTABLISHED 态，此时服务端的 accept() 函数返回。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818184214207-1095054762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　经过如上三个报文交互，TCP 连接建立，然后就可以进行数据传输。&lt;/p&gt;
&lt;p&gt;　　在数据传输阶段，客户端的 Socket 可以调用 send() 函数发送数据，然后服务端的 Socket 接到客户端 Socket 传来的请求，调用 read() 函数读取，调用 write() 函数写入响应。&lt;/p&gt;
&lt;p&gt;　　在连接断开阶段，以客户端主动关闭为例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818190000930-1500277220.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;330&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　客户端的 TCP 协议栈主动发送一个 FIN 报文，主动关闭到服务端方向的连接，此时客户端状态从 ESTABLISHED  态转移到 FIN-WAIT-1 态。通过调用 close() 函数即可实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818190330751-293437504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　服务端 TCP 协议栈收到 FIN 报文，就发回客户端一个 ACK 报文确认关闭，此时，服务端状态从 ESTABLISHED 态转移到 CLOSE-WAIT 态（因为是被动关闭），和 SYN 一样，一个 FIN 也占用一个序号，&lt;span&gt;同时服务端还向客户端传送一个文件结束符。当客户端接受到服务端确认关闭的报文后，客户端状态从 FIN-WAIT-1 态转移到 FIN-WAIT-2 态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818190404157-340463020.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着这个服务端程序就关闭它的连接，这会导致服务端的 TCP 协议栈也会发送一个 FIN 报文给客户端，这里也能清楚看到，ACK 不消耗序号。此时，服务端状态从  CLOSE-WAIT  转移到 LAST-ACK 态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818190557517-436825819.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　客户端收到服务端的 FIN 报文，也必须发回一个ACK 确认报文&lt;/span&gt;。此时，客户端状态从 FIN-WAIT-2 态转移到 TIME-WAIT 态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180818190717362-162227811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此，TCP 连接关闭。&lt;/p&gt;

&lt;p&gt;　　对于运行在 Java 虚拟机上的 Java 语言来说，其自身的 Socket 函数，就是对操作系统的这些系统调用函数的封装而已。看看这些系统调用函数，有助于理解非阻塞通信原理，先认识一些辅助的 Socket 系统调用函数。&lt;/p&gt;
&lt;p&gt;　　socket 函数：对应于普通文件的打开操作，要知道 Linux 中，一切都是文件，包括 Socket 本身也是一个文件，分别存在于客户端和服务端机器上。前面也提到了 fd，即普通文件的打开操作会返回一个文件描述符——file description，即 fd，socket() 函数就是用来创建 Socket 描述符（socket descriptor，即 sd） 的，它唯一标识一个 Socket。这个 sd 跟 fd 一样，后续的操作都会用到它，把它作为参数，通过它来进行一些 Socket 的读写操作。&lt;/p&gt;
&lt;p&gt;　　bind 函数：给一个 sd 绑定一个协议和地址+端口号。&lt;/p&gt;
&lt;p&gt;　　listen 函数：socket() 函数创建的 Socket 默认是一个主动类型的，listen 函数将 Socket 变为被动类型的，用于等待客户的连接请求。&lt;/p&gt;
&lt;p&gt;　　connect 函数：客户端通过调用 connect 函数来建立与 TCP 服务器的连接。&lt;/p&gt;
&lt;p&gt;　　accept 函数：TCP 服务端依次调用 socket()、bind()、listen() 之后，就会监听指定的 Socket 地址了，TCP 客户端依次调用 socket()、connect() 之后就向 TCP 服务端发送一个连接请求。服务端监听到这个请求后，调用 accept() 函数接收请求，如果 accept()  函数成功返回，则标识服务端与客户端已经正确建立连接，此时服务端可以通过 accept 函数返回的 Socket 来完成与客户端的通信，之后的操作就和普通的 I/O 操作（read 函数和 write 函数）没什么区别。&lt;/p&gt;

&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;　　Linux 提供了 select/poll 函数，这些系统调用的进程通过将一个或多个 fd（文件描述符，Linux 的一切都是文件） 传递给 select 或 poll 系统调用，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的 I/O 系统调用上，这样 select/poll 可以帮我们侦测多个 fd 是否处于就绪状态。&lt;/p&gt;
&lt;p&gt;　　具体的说，联系老师和学生考试的例子，select/poll 顺序扫描 fd 是否就绪，但是 select 支持的 fd 数量有限，因此它的使用受到了一些制约。Linux 还提供一个 epoll 系统调用，两个东西本质是一样的，只不过 epoll 高级一些，能力更强一些，是基于事件驱动方式代替顺序扫描，因此性能更高——当有 fd 就绪时，立即回调函数rollback。该函数允许进程指示内核等待多个事件中的任何一个发生，并只在有一个或多个事件发生或经历一段指定的时间后才唤醒它。&lt;/p&gt;
&lt;p&gt;　　也就是说，我们调用 select/epoll 告知内核对哪些描述符（读、写或异常条件〉感兴趣以及等待多长时间。我们感兴趣的描述符不局限于套接字，任何描述符都可以使用select来测试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　乍一看上面的解释，可能会懵逼，当然，懂得就略过。下面就详细分析下，毕竟人家都黑我们 Javaer 不懂。。。&lt;/p&gt;
&lt;p&gt;　　众所周知，read、write、recv, 和 recvfrom 等函数都是阻塞的函数，所谓阻塞，简单说，就是当函数不能成功执行完毕的时候，程序就会一直停在这里，无法继续执行以后的代码。&lt;/p&gt;
&lt;p&gt;　　严格的说，Linux 对一个 fd 指定的文件或设备, 有两种工作方式: 阻塞与非阻塞方式。阻塞方式是指当试图对该 fd 进行读写时，如果当时没有数据可读，或者暂时不可写，程序就进入等待状态，直到可读或者可写为止。非阻塞方式是指如果 fd 没有数据可读，或者不可写，读/写的函数马上返回，不会等待结果。使用 selcet/epoll 函数就可以实现非阻塞编程。&lt;/p&gt;
&lt;p&gt;　　先看 selcet 函数，它本质是一个轮循函数，即当循环询问fd时，可设置超时时间，超时时间到了就跳过代码继续往下执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;fd_set readfd;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; timeval timeout;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  
&lt;span&gt; 4&lt;/span&gt; FD_ZERO(&amp;amp;readfd); &lt;span&gt;// &lt;/span&gt;&lt;span&gt;初始化 readfd&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; FD_SET(gps_fd, &amp;amp;readfd); &lt;span&gt;// &lt;/span&gt;&lt;span&gt;把 gps_fd 加入 readfd&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; timeout.tv_sec = &lt;span&gt;3&lt;/span&gt;; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;设置 3 秒超时&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; timeout.tv_usec = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;  
&lt;span&gt; 9&lt;/span&gt; j = &lt;span&gt;select&lt;/span&gt;(gps_fd+&lt;span&gt;1&lt;/span&gt;, &amp;amp;readfd, NULL, NULL, &amp;amp;timeout); &lt;span&gt;// &lt;/span&gt;&lt;span&gt;用 select 对 gps_fd 进行轮循&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(j&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;( FD_ISSET(gps_fd, &amp;amp;readfd) ){ &lt;span&gt;// &lt;/span&gt;&lt;span&gt;如果 gps_fd 可读&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         i =&lt;span&gt; read(gps_fd, buf, SIZE);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         buf[i] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('be01bb0f-68df-42aa-b636-fac55dcaf977')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_be01bb0f-68df-42aa-b636-fac55dcaf977&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_be01bb0f-68df-42aa-b636-fac55dcaf977&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('be01bb0f-68df-42aa-b636-fac55dcaf977',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_be01bb0f-68df-42aa-b636-fac55dcaf977&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
C 系列的代码 ztm 的很繁琐，实现个简单的聊天 demo，都要很多代码和繁琐的考虑。。。到了如今，Java 强大的生态系统愈发完善，其 Netty 已经可以和 C++ 实现的异步非阻塞服务器抗衡，愈发想不通，为什么还有人要用 C++ 语言来实现类似项目（纯属个人吐槽。。。），这里只是依靠之前的知识基础，其实我也忘得差不多了。。。写了一个小小的方法，直观感受下，我们重点还是在 Java 这块。
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　主要看 select 函数的参数，帮助我们理解它的工作原理。先看参数类型，fd_set 是一个集合（struct），其中存放的是 fd，有的书也叫文件句柄。timeval 也是一个 struct，代表时间值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; maxfdp, fd_set *readfds, fd_set *writefds, fd_set *errorfds, &lt;span&gt;struct&lt;/span&gt; timeval *timeout); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一个参数 int maxfdp：指fd_set集合中所有 fd 的范围，即所有文件描述符的最大值加1，不能错。&lt;/p&gt;
&lt;p&gt;　　第二个参数 fd_set  *readfds：集合中包括 fd，select 会监视这些 fd 是否可读，看名字 readfds 也能看出来，如果 readfds 中有一个文件可读，select 就会返回一个大于 0 的值，表示有文件可读，如果没有可读的，则根据 timeout 参数判断是否超时，若超时，select 返回 0，若发生错误直接返回负值。也可以传入 NULL 值，表示不关心任何文件的读变化。&lt;/p&gt;
&lt;p&gt;　　第三个参数 fd_set  *writefds：集合中包括 fd，select 监视这些 fd 是否可写，如果有一个 fd 可写，select 就返回一个大于 0 的值，否则根据 timeout 判断是否超时，后续和 readfds 一样。&lt;/p&gt;
&lt;p&gt;　　第四个参数 fd_set  *errorfds：同上，select 可以监视 fd 的错误异常。 &lt;/p&gt;
&lt;p&gt;　　第五个参数 struct timeval  *timeout：是 select 的超时时间，它可使 select 处于三种状态；&lt;/p&gt;
&lt;p&gt;　　　　1、传入 NULL，select 变为阻塞函数，一定等到被监视的 fd 集合中，某个 fd 发生变化为止；&lt;/p&gt;
&lt;p&gt;　　　　2、设为 0，select 变成非阻塞函数，不管 fd 是否有变化，都立刻返回，fd 无变化返回  0，有变化返回一个正值；&lt;/p&gt;
&lt;p&gt;　　　　3、大于 0，select 的阻塞超时时间，时间内有事件到来就返回，否则在超时后就一定返回，返回值同上。 &lt;/p&gt;
&lt;p&gt;　　前面说了，selcet 函数本质是一个轮循函数，即 select 内部会循环询问参数集合里的 fd，原理其实也很简单，每次轮询发现有 fd 发生变化，就会返回，否则一直轮询直到超时，如果没有超时就直接返回，不阻塞。轮询的目的就是发现 fd 可读或者可写，然后可以让单个进程去处理 I/O 事件，避免 fork 多个客户进程。　&lt;/p&gt;

&lt;p&gt;　　熟悉 Java NIO 编程的都知道，JDK 里也有 select() 方法，一般也叫它I/O多路复用器（网上有人翻译为选择器，个人感觉并不能突出其实现思想，我采纳了《Netty 权威指南》作者的翻译），它实际上底层并不是基于 Linux 的 select 系统函数实现，不要被名字误导，它是基于 epoll 系统函数而实现。下面就学习下这个系统函数，帮助我们理解 Java NIO 编程思想。&lt;/p&gt;
&lt;p&gt;　　epoll 是 Linux 下 I/O多路复用器——select/poll 的增强版，最早出现在 Linux 内核 2.5.44中，其实现与使用方式与 select/poll 有一些差异，epoll 是通过了一组函数来完成有关任务，而不是类似 select 函数那样，只依靠一个函数。&lt;/p&gt;
&lt;h2&gt;select 函数的缺陷&lt;/h2&gt;
&lt;p&gt;　　简单的看下 select 的执行流程；首先要设置 maxfdp，将 fd 加入 select 监控集，使用一个 array 保存放到 select 监控集中的 fd，一是用于在 select 返回后，array 作为源数据和 fdset 进行 fd_isset 判断。二是在 select 返回后会把以前加入的但并无事件发生的 fd 清空，则每次开始 select 都要从 array 取得 fd 逐一加入。select 的模型必须在 select 前循环 array（加fd，取 maxfd），返回后循环 array。下面的 demo 只一次调用，很简单。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {  
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;10&lt;/span&gt;] = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         fd_set rdfds; &lt;span&gt;// &lt;/span&gt;&lt;span&gt;监视可读事件的 fd 集合&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;struct&lt;/span&gt; timeval tv; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超时时间&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;  
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         FD_ZERO(&amp;amp;rdfds); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化 readfds&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         FD_SET(&lt;span&gt;0&lt;/span&gt;, &amp;amp;rdfds); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; fd==0 表示键盘输入&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         tv.tv_sec = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         tv.tv_usec = &lt;span&gt;500&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         ret = &lt;span&gt;select&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &amp;amp;rdfds, NULL, NULL, &amp;amp;tv); &lt;span&gt;// &lt;/span&gt;&lt;span&gt;第一个参数是 maxfdp，值是监控的 fd 号 + 1，本例就是 0 + 1 &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(ret &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;               printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;selcet error \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ret == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;               printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timeout \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;  
&lt;span&gt;16&lt;/span&gt;               printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ret = %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ret);  
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(FD_ISSET(&lt;span&gt;0&lt;/span&gt;, &amp;amp;rdfds)){ &lt;span&gt;// 说明&lt;/span&gt;&lt;span&gt;监控的 fd 可读，stdin 输入已经发生  &lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;               printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; reading 。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;               read(&lt;span&gt;0&lt;/span&gt;, buf, &lt;span&gt;9&lt;/span&gt;); &lt;span&gt;// &lt;/span&gt;&lt;span&gt;从键盘读取输入  &lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }  
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         write(&lt;span&gt;1&lt;/span&gt;, buf, strlen(buf)); &lt;span&gt;// &lt;/span&gt;&lt;span&gt;在终端回显  &lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, strlen(buf));  
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　显然，可以发现 select 会做很多无用功。&lt;/p&gt;
&lt;p&gt;　　1、即使只有一个 fd 就绪，select 也要遍历整个 fd 集合，这显然是无意义的操作。&lt;/p&gt;
&lt;p&gt;　　2、如果事件需要循环处理，那么每次 select 后，都要清空以前加入的但并无事件发生的 fd 数组（本例子就一个），在每次重新开始 select 时，都要再次从 array 取得 fd 逐一加入 fd_set 集合，每次这样的操作都需要做一次从进程的用户空间到内核空间的内存拷贝，使得 select 的效率较低。&lt;/p&gt;
&lt;p&gt;　　3、select 能够处理的最大 fd 数目是有限制的，而且限制很低，一般为 1024，如果客户端过多，会大大降低服务器响应效率。&lt;/p&gt;
&lt;h2&gt;epoll 高效的原因&lt;/h2&gt;
&lt;p&gt;　　select 函数将当前进程轮流加入每个 fd 对应设备的等待队列去询问该 fd 有无可读/写事件，无非是想，在哪一个设备就绪时能够通知当前进程退出调用，Linux 的开发者想到，找个“代理”的回调函数代替当前进程，去加入 fd 对应设备的等待队列，让这个代理的回调函数去等待设备就绪，当有设备就绪就将自己唤醒，然后该回调函数就把这个设备的 fd 放到一个就绪队列，同时通知可能在等待的轮询进程来这个就绪队列里取已经就绪的 fd。当前轮询的进程不需要遍历整个被侦听的 fd 集合。&lt;/p&gt;
&lt;p&gt;　　简单说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;epoll 将用户关心的 fd 放到了 Linux 内核里的一个事件表中，而不是像 select/poll 函数那样，每次调用都需要复制 fd 到内核。内核将持久维护加入的 fd，减少了内核和用户空间复制数据的性能开销。&lt;/li&gt;
&lt;li&gt;当一个 fd 的事件发生（比如说读事件），epoll 机制无须遍历整个被侦听的 fd 集，只要遍历那些被内核 I/O 事件异步唤醒而加入就绪队列的 fd 集合，减少了无用功。&lt;/li&gt;
&lt;li&gt;epoll 机制支持的最大 fd 上限远远大于 1024，在 1GB 内存的机器上是 10 万左右，具体数目可以 cat/proc/sys/fs/file-max查看。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;epoll 机制的两种工作方式：ET 和 LT&lt;/h2&gt;
&lt;p&gt;　　epoll 由三个系统调用组成，分别是 epoll_create，epoll_ctl 和 epoll_wait。epoll_create 用于创建和初始化一些内部使用的数据结构，epoll_ctl 用于添加，删除或修改指定的 fd 及其期待的事件，epoll_wait 就是用于等待任何先前指定的fd事件就绪。&lt;/p&gt;
&lt;p&gt;　　服务端使用 epoll 步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用 epoll_create 在 Linux 内核中创建一个事件表；&lt;/li&gt;
&lt;li&gt;将 fd（监听套接字 listener）添加到所创建的事件表；&lt;/li&gt;
&lt;li&gt;在主循环中，调用 epoll_wait 等待返回就绪的 fd 集合；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d0c279c2-8420-42a5-b761-0e5b3d5b6f52')&quot; readability=&quot;53&quot;&gt;&lt;img id=&quot;code_img_closed_d0c279c2-8420-42a5-b761-0e5b3d5b6f52&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d0c279c2-8420-42a5-b761-0e5b3d5b6f52&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d0c279c2-8420-42a5-b761-0e5b3d5b6f52',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d0c279c2-8420-42a5-b761-0e5b3d5b6f52&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;101&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; epoll_event ev, events[&lt;span&gt;20&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in clientaddr, serveraddr;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; epfd;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sd;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxi;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nfds;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; sock_fd, conn_fd;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;];

    epfd &lt;/span&gt;= epoll_create(&lt;span&gt;2560&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成 epoll 句柄,size 告诉内核监听的 fd 数目最大值
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当创建 epoll 句柄后，它就会占用一个 fd 值，所以在使用完 epoll，必须调用 close() 释放资源，否则可能导致 fd 被耗尽。&lt;/span&gt;
    sd = socket(AF_INET, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 Socket&lt;/span&gt;
    ev.data.fd = sd; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置与要处理事件相关的 fd,这里就是 Socket 的 sd&lt;/span&gt;
    ev.events = EPOLLIN; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置感兴趣的 fd 事件类型, EPOLLIN 表示 fd 可读（包括对端 Socket 正常关闭)事件&lt;/span&gt;
    epoll_ctl(epfd, EPOLL_CTL_ADD, sd, &amp;amp;ev);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; EPOLL_CTL_ADD：注册新的 fd 到 epfd 中&lt;/span&gt;
    memset(&amp;amp;serveraddr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(serveraddr));
    serveraddr.sin_family &lt;/span&gt;=&lt;span&gt; AF_INET;
    serveraddr.sin_addr.s_addr &lt;/span&gt;=&lt;span&gt; htonl(INADDR_ANY);
    serveraddr.sin_port &lt;/span&gt;=&lt;span&gt; htons(SERV_PORT);
    bind(sd, (&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; sockaddr*)&amp;amp;serveraddr, &lt;span&gt;sizeof&lt;/span&gt;(serveraddr)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绑定 Socket&lt;/span&gt;
&lt;span&gt;    socklen_t clilen;
    listen(sd, &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转为监听的 Socket&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        nfds &lt;/span&gt;= epoll_wait(epfd, events, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待 fd 感兴趣的事件发生,函数返回需要处理的事件数目&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; nfds; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(events[i].data.fd == sd) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新连接到了&lt;/span&gt;
                clilen = &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in);
                conn_fd &lt;/span&gt;= accept(sd, (&lt;span&gt;struct&lt;/span&gt; sockaddr*)&amp;amp;clientaddr, &amp;amp;&lt;span&gt;clilen);
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept a new client : %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, inet_ntoa(clientaddr.sin_addr));
                ev.data.fd &lt;/span&gt;=&lt;span&gt; conn_fd;
                ev.events &lt;/span&gt;= EPOLLIN; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 fd 的监听事件为可写&lt;/span&gt;
                epoll_ctl(epfd, EPOLL_CTL_ADD, conn_fd, &amp;amp;ev); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册新的 Socket 到 epfd&lt;/span&gt;
            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(events[i].events &amp;amp; EPOLLIN) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可读事件被触发&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;((sock_fd = events[i].data.fd) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((n = recv(sock_fd, buf, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(errno ==&lt;span&gt; ECONNRESET) {
                        close(sock_fd);
                        events[i].data.fd &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;readline error \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(n == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                    close(sock_fd);
                    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;关闭 \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    events[i].data.fd &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                }
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d -- &amp;gt; %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,sock_fd, buf);
                ev.data.fd &lt;/span&gt;=&lt;span&gt; sock_fd;
                ev.events &lt;/span&gt;=&lt;span&gt; EPOLLOUT;
                epoll_ctl(epfd, EPOLL_CTL_MOD, sock_fd, &lt;/span&gt;&amp;amp;ev); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 修改监听事件为可读&lt;/span&gt;
            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(events[i].events &amp;amp; EPOLLOUT) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可写事件被触发&lt;/span&gt;
                sock_fd =&lt;span&gt; events[i].data.fd;
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OUT\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,buf);
                send(sock_fd, buf, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                ev.data.fd &lt;/span&gt;=&lt;span&gt; sock_fd;
                ev.events &lt;/span&gt;=&lt;span&gt; EPOLLIN;
                epoll_ctl(epfd, EPOLL_CTL_MOD,sock_fd, &lt;/span&gt;&amp;amp;&lt;span&gt;ev);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　把 fd 加入到 epoll 的监听队列中， 当 fd 可读/写事件，这个条件发生时，在经验看来，epoll_wait() 当然会立即返回（也叫被触发），事实上确实是这样的，而且返回值是需要处理的 fd 事件的数目。这里要讨论的是 epoll_wait() 函数返回的条件到底都有什么。&lt;/p&gt;
&lt;p&gt;　　如果 epoll_wait() 只在读/写事件发生时返回，就像前面举的经验例子，该触发叫做边缘触发——ET(edge-triggered)，也就是说如果事件处理函数只读取了该 fd 的缓冲区的部分内容就返回了，接下来再次调用 epoll_wait()，虽然此时该就绪的 fd 对应的缓冲区中还有数据，但 epoll_wait() 函数也不会返回。&lt;/p&gt;
&lt;p&gt;　　相反，无论当前的 fd 中是否有读/写事件反生了，只要 fd 对应的缓冲区中有数据可读/写，epoll_wait() 就立即返回，这叫做水平触发——LT(level-triggered)。&lt;/p&gt;
&lt;p&gt;　　一句话总结，在 ET 模式下，只有 fd 状态发生改变，fd 才会被再次选出。ET 模式的特殊性，使 ET 模式下的一次轮询必须处理完本次轮询出的 fd 缓冲区里的的所有数据，否则该 fd 将不会在下次轮询中被选出。&lt;/p&gt;
&lt;p&gt;　　select/poll 使用的触发方式是 LT，相对来说比较低效，而 ET 是 epoll 的高速工作方式。&lt;/p&gt;
&lt;h2&gt;epoll 缺点&lt;/h2&gt;
&lt;p&gt;　　epoll 每次只遍历活跃的 fd (如果是 LT，也会遍历先前活跃的 fd)，在活跃 fd 较少的情况下就会很有优势，如果大部分 fd 都是活跃的，epoll 的效率可能还不如 select/poll。&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div readability=&quot;14&quot;&gt;

&lt;p&gt;　　如果写过 Java NIO 代码，那么就能推测到 JDK NIO 的 epoll 模型是 LT，在 Netty 的实际开发中，也能体会到 NioServerSocketChannel 是 LT，当然如果使用 Netty 自己实现的 epoll Channel，就是 ET。&lt;/p&gt;
&lt;p&gt;　　Netty 的 NioEventLoop 模型中，每次轮询都会进行负载均衡，限制了每次从 fd 中读取数据的最大值，造成一次读事件处理并不会 100% 读完 fd 缓冲区中的所有数据。在基于 LT 的 NioServerSocketChannel 中，Netty 不需要做特殊处理，在处理完一个 I/O 事件后直接从 SelectionKey 中移除该事件即可，如果有未读完的数据，下次轮询仍会获得该事件。而在EpollServerSocketChannel，如果一次事件处理不把数据读完，需要手动地触发一次事件，否则下次轮询将不会读取先前活跃的 fd 遗留的数据。 &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;　　刚刚创立，很新鲜。。。考虑到我不是大师，也不是一个团队，个人业余时间梳理记录的学习心得，肯定会有无法避免的漏洞。。。博客文章可以返回去修改，但是貌似微信文章不行，发了就不能方便的改。故我选择博客+微信公众号双发，也算是异地备份了，哈哈。&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1NjY0NzI3OQ==&amp;amp;mid=2247483667&amp;amp;idx=1&amp;amp;sn=ad8a259d6806befafe3e80847e94d87c&amp;amp;chksm=fbc09713ccb71e05d65e02bb050dfa570a698e4cd458e6fb89bb9845a920551bfe18783d5af1&amp;amp;token=1077576625&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;微信文章的链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682679/201808/682679-20180810011339673-1494327915.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Aug 2018 15:50:00 +0000</pubDate>
<dc:creator>dashuai的博客</dc:creator>
<og:description>前言 本文主要从 select 和 epoll 系统调用入手，来打开 Netty 的大门，从认识 Netty 的基础原理 —— I/O 多路复用模型开始。 Netty 的通信原理 Netty 底层的通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubixuesheng/p/9497401.html</dc:identifier>
</item>
</channel>
</rss>