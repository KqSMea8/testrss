<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>尝试造了个工具类库，名为 Diana - 牧云云</title>
<link>http://www.cnblogs.com/MuYunyun/p/8106644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MuYunyun/p/8106644.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;项目地址: &lt;a href=&quot;https://github.com/MuYunyun/diana&quot;&gt;diana&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.7948717948718&quot;&gt;
&lt;p&gt;文档地址: &lt;a href=&quot;http://muyunyun.cn/diana/&quot; class=&quot;uri&quot;&gt;http://muyunyun.cn/diana/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;造轮子的意义&quot;&gt;造轮子的意义&lt;/h3&gt;
&lt;p&gt;为啥已经有如此多的前端工具类库还要自己造轮子呢？个人认为有以下几个观点吧：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定制性强，能根据自己的需求为主导延伸开发。万一一不小心还能帮到别人（比如 React 库）；&lt;/li&gt;
&lt;li&gt;纸上得来终觉浅，很多流行的库，只是照着它们的 API 进行使用，其实这些库里蕴含着大量的知识、技巧，最好的办法就是仿照它们来写些小 demo，从而体会这些库的精髓；&lt;/li&gt;
&lt;li&gt;造轮子的过程中能让自己体会到与平常业务开发不一样的乐趣；比如和日常业务开发中很大的一个区别是会对测试用例具有比较严格的要求；而且写文档能力提升了。&lt;/li&gt;
&lt;li&gt;就先瞎编到这里了。。。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;抛开内部方法(写相应的专题效果可能会更好，所以这里先略过)，下面分享一些开发 &lt;a href=&quot;https://github.com/MuYunyun/diana&quot;&gt;diana 库&lt;/a&gt; 时的一些心得：&lt;/p&gt;
&lt;h3 id=&quot;项目目录结构&quot;&gt;项目目录结构&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;├── LICENSE                  开源协议
├── README-zh_en.md          英文说明文档
├── README.md                中文说明文档
├── coverage                 代码覆盖率文件
├── docs                     文档目录
│   └── static-parts
│       ├── index-end.html   静态文档目录结尾文件
│       └── index-start.html 静态文档目录开头文件
├── karma.conf.js            karma 配置文件
├── lib
│   ├── diana.back.js        服务端引用入口
│   └── diana.js             浏览器引用入口
├── package.json
├── script
│   ├── build.js             构建文件
│   ├── check.js             结合 pre-commit 进行 eslint 校验
│   ├── tag-script.js        自动生成文档的标签
│   ├── web-script.js        自动生成文档
│   ├── webpack.browser.js   浏览器端 webpack 配置文件
│   └── webpack.node.js      服务器端 webpack 配置文件
├── snippets
├── src
│   ├── browser              浏览器端方法
│   ├── common               共用方法
│   ├── node                 node 端方法
│   └── util.js              库内通用方法
├── tag_database             文档标签
└── test                     测试文件
    ├── browserTest
    ├── commonTest
    ├── index.js
    └── nodeTest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目录结构也随着方法的增多在不停迭代当中，建议直接到&lt;a href=&quot;https://github.com/MuYunyun/diana&quot;&gt;库中&lt;/a&gt;查看最新的目录结构。&lt;/p&gt;
&lt;p&gt;相应地，具体的方法会随着时间迭代，所以首先推荐查看&lt;a href=&quot;http://muyunyun.cn/diana/&quot;&gt;文档&lt;/a&gt;，点击如下图的 Ⓢ 就能查看源码。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://oqhtscus0.bkt.clouddn.com/54db4bd9519dd7938b0cc38e0b9a50ea.jpg-300&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;让模块同时在-node.js-与浏览器中运行&quot;&gt;让模块同时在 Node.js 与浏览器中运行&lt;/h3&gt;
&lt;p&gt;我们可以通过如下方法来判断模块当前是运行在 Node.js 还是浏览器中，然后使用不同的方式实现我们的功能。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;// Only Node.JS has a process variable that is of [[Class]] process&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; isNode &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;prototype&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;toString&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;call&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; process &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'undefined'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;?&lt;/span&gt; process : &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'[object process]'&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但如果用户使用了模块打包工具，这样做会导致 Node.js 与浏览器的实现方式都会被包含在最终的输出文件中。针对这个问题，开源社区提出了在 package.json 中添加 browser 字段的&lt;a href=&quot;https://github.com/defunctzombie/package-browser-field-spec&quot;&gt;提议&lt;/a&gt;，目前 webpack 和 rollup 都已经支持这个字段了。&lt;/p&gt;
&lt;p&gt;给 browser 字段提供一个文件路径作为在浏览器端使用时的模块入口，但需要注意的是，打包工具会优先使用 browser 字段指定的文件路径作为模块入口，所以你的 main 字段 和 module 字段会被忽略，但是这会导致打包工具不会优化你的代码。详细信息请参考&lt;a href=&quot;http://link.zhihu.com/?target=https%3A//github.com/webpack/webpack/issues/4674&quot;&gt;这个问题&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://github.com/MuYunyun/diana&quot;&gt;diana 库&lt;/a&gt; 为了在不同环境中使用适当的文件，在 package.json 中进行了如下声明：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;  &lt;span class=&quot;st&quot;&gt;&quot;browser&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;lib/diana.js&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;st&quot;&gt;&quot;main&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;lib/diana.back.js&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 或者 &quot;module&quot;: &quot;lib/diana.back.js&quot;,&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一来，在 node 环境中，引用的是 &lt;code&gt;lib/diana.back.js&lt;/code&gt; 文件，在浏览器环境中，引用的是 &lt;code&gt;lib/diana.js&lt;/code&gt; 文件。然后就能愉快地在浏览器端和 node 端愉快地使用自己特有的 api 了。&lt;/p&gt;
&lt;h3 id=&quot;常见模块规范比较&quot;&gt;常见模块规范比较&lt;/h3&gt;
&lt;p&gt;另外为了使 &lt;a href=&quot;https://github.com/MuYunyun/diana&quot;&gt;diana 库&lt;/a&gt; 的打包文件兼容 node 端、以及浏览器端的引用，选择了 UMD 规范进行打包，那么为什么要选择 UMD 规范呢？让我们看下以下几种规范之间的异同：&lt;/p&gt;
&lt;h4 id=&quot;commonjs&quot;&gt;CommonJS&lt;/h4&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;CommonJs 是服务器端模块的规范，&lt;code&gt;Node.js 采用了这个规范&lt;/code&gt;。这些规范涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、服务器网关接口、包管理等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;根据 CommonJS 规范，一个单独的文件就是一个模块。加载模块使用 &lt;code&gt;require&lt;/code&gt; 方法，该方法读取一个文件并执行，最后返回文件内部的 &lt;code&gt;exports&lt;/code&gt; 对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;CommonJS 加载模块是同步的。像 Node.js 主要用于服务器的编程，加载的模块文件一般都已经存在本地硬盘，所以加载起来比较快，不用考虑异步加载的方式，所以 CommonJS 规范比较适用。但如果是浏览器环境，要从服务器加载模块，这是就必须采用异步模式。所以就有了 AMD、CMD 解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;amdcmd&quot;&gt;AMD、CMD&lt;/h4&gt;
&lt;h4 id=&quot;umd&quot;&gt;UMD&lt;/h4&gt;
&lt;p&gt;UMD 是 AMD 和 CommonJS 的结合。因为 AMD 是以浏览器为出发点的异步加载模块，CommonJS 是以服务器为出发点的同步加载模块，所以人们想出了另一个更通用的模式 UMD，来解决跨平台的问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MuYunyun/diana/blob/master/lib/diana.js#L1&quot;&gt;diana 库&lt;/a&gt; 选择了以 umd 方式进行输出，来看下 UMD 做了啥：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (root&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; factory) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; exports &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'object'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; module &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'object'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 CommonJS 模式&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;factory&lt;/span&gt;()
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; define &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'function'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;define&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;amd&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 接着判断是否支持 AMD（define是否存在），存在则使用 AMD 方式加载模块。&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;define&lt;/span&gt;([]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; factory)
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; exports &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'object'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// CommonJS 的另一种形式&lt;/span&gt;
    exports[&lt;span class=&quot;st&quot;&gt;'diana'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;factory&lt;/span&gt;()
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;
    root[&lt;span class=&quot;st&quot;&gt;'diana'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;factory&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;// Window&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; module
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;测试踩坑之路&quot;&gt;测试踩坑之路&lt;/h3&gt;
&lt;h4 id=&quot;代码覆盖率&quot;&gt;代码覆盖率&lt;/h4&gt;
&lt;p&gt;单元测试的代码覆盖率统计，是衡量测试用例好坏的一个的方法。但凡是线上用的库，基本上都少不了高质量的代码覆盖率的检测。如下图为 diana 库的测试覆盖率展示。&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://oqhtscus0.bkt.clouddn.com/7efbacda331e914df3eedb3670b747a8.jpg-400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到覆盖率分为以下 4 种类型，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;行覆盖率（line coverage）：是否每一行都执行了？&lt;/li&gt;
&lt;li&gt;函数覆盖率（function coverage）：是否每个函数都调用了？&lt;/li&gt;
&lt;li&gt;分支覆盖率（branch coverage）：是否每个if代码块都执行了？&lt;/li&gt;
&lt;li&gt;语句覆盖率（statement coverage）：是否每个语句都执行了？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;番外：github 上显示的覆盖率是根据行覆盖率来展示的。&lt;br/&gt;&lt;a href=&quot;https://codecov.io/gh/MuYunyun/diana&quot;&gt;&lt;img src=&quot;https://codecov.io/gh/MuYunyun/diana/branch/master/graph/badge.svg&quot; alt=&quot;codecov&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;mocha-istanbul&quot;&gt;mocha + istanbul&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MuYunyun/diana/blob/d81991f588046b428e2ac959fb6b87e6edb4938e/package.json#L23&quot;&gt;最初的版本&lt;/a&gt;, 仅仅用到 mocha 进行测试 *.test.js 文件，然后在 &lt;a href=&quot;https://codecov.io/gh/MuYunyun/diana&quot;&gt;codecov&lt;/a&gt; 得到测试覆盖率。&lt;/p&gt;
&lt;h4 id=&quot;引人-karma&quot;&gt;引人 karma&lt;/h4&gt;
&lt;p&gt;如果仅仅测试 es5、es6 的语法，其实用 mocha 就已经够用了，但是涉及到测试 Dom 操作的语法等就必须建立一个浏览器，在上面进行测试。karma 的作用其实就是自动帮我们建立一个测试用的浏览器环境。&lt;/p&gt;
&lt;p&gt;为了让浏览器支持 Common.js 规范，中间用了 karma + browserify，尽管测试用例都跑通了，但是最后的代码覆盖率的文件里只有各个方法的引用路径。最后只能又回到 karma + webpack 来，这里又踩到一个坑，&lt;a href=&quot;https://segmentfault.com/a/1190000004283830&quot;&gt;打包编译JS代码覆盖率问题&lt;/a&gt;，踩了一些坑后，终于实现了可以查看编译前代码的覆盖率。图如下：&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://oqhtscus0.bkt.clouddn.com/e0ba39166c6999a3c3ce76bc63f511aa.jpg-400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这幅图我们能清晰地看到源代码中测试用例跑过各行代码的次数(左侧的数字)，以及测试用例没有覆盖到的代码(图中红色所示)。然后我们就能改善相应的测试用例从而提高测试覆盖率。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MuYunyun/diana/blob/master/karma.conf.js&quot;&gt;配置文件&lt;/a&gt;，核心部分如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;28&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;module&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(config) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'test/index.js'&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 需载入浏览器的文件&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;preprocessors&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 预处理&lt;/span&gt;
      &lt;span class=&quot;st&quot;&gt;'test/index.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'webpack'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'coverage'&lt;/span&gt;]
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;webpack&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\.&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;js&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;use&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'sourcemap-istanbul-instrumenter-loader'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 这里用 istanbul-instrumenter-loader 插件的 0.0.2 版本，其它版本有坑~&lt;/span&gt;
          &lt;span class=&quot;dt&quot;&gt;exclude&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;ss&quot;&gt;/node_modules/&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;\.&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;spec.js&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;coverageReporter&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'lcov'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 貌似只能支持这种类型的读取&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;dir&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'coverage/'&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;remapIstanbulReporter&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 生成 coverage 文件&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;reports&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;'text-summary'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'coverage/coverage.json'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;lcovonly&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'coverage/lcov.info'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'coverage/html/'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;reporters&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'progress'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'karma-remap-istanbul'&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// remap-isbanbul 也报了一个未找到 sourcemap 的 error，直接注释了 remap-istanbul 包的 CoverageTransformer.js 文件的 169 行，以后有机会再捣鼓吧。（心累）&lt;/span&gt;
    ...
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文围绕 &lt;a href=&quot;https://github.com/MuYunyun/diana&quot;&gt;diana 库&lt;/a&gt; 对造轮子的意义，模块兼容性，测试用例进行了思考总结。后续会对该库流程自动化以及性能上做些分享。&lt;br/&gt;该库参考学习了很多优秀的库，感谢 &lt;a href=&quot;https://github.com/jashkenas/underscore&quot;&gt;underscore&lt;/a&gt;、&lt;a href=&quot;https://github.com/proYang/outils&quot;&gt;outils&lt;/a&gt;、&lt;a href=&quot;https://github.com/chenhuiYj/ec-do&quot;&gt;ec-do&lt;/a&gt;、&lt;a href=&quot;https://github.com/Chalarangelo/30-seconds-of-code&quot;&gt;30-seconds-of-code&lt;/a&gt; 等库对我的帮助。&lt;/p&gt;
&lt;p&gt;最后欢迎各位大佬在 &lt;a href=&quot;https://github.com/MuYunyun/diana/issues&quot;&gt;issues&lt;/a&gt; 尽情吐槽。&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 22:06:00 +0000</pubDate>
<dc:creator>牧云云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MuYunyun/p/8106644.html</dc:identifier>
</item>
<item>
<title>MobileNets总结 - Thaurun</title>
<link>http://www.cnblogs.com/heguanyou/p/8100246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heguanyou/p/8100246.html</guid>
<description>&lt;p&gt;Google在2017年上半年发表了一篇关于可以运行在手机等移动设备上的神经网络结构——&lt;a href=&quot;https://arxiv.org/abs/1704.04861&quot;&gt;MobileNets&lt;/a&gt;。MobileNets是基于深度可分离卷积（depthwise separable convolution）而设计的轻量级深度神经网络。这文章也介绍了两个超参数可以很好的平衡延时与精度，这两个超参数可以使人更方便地选出自己想要的网络结构。MobileNets的结构能用在图片分类、人脸识别、目标检测等上面。论文的&lt;a href=&quot;https://github.com/apache/incubator-mxnet/blob/master/example/image-classification/symbols/mobilenet.py&quot;&gt;mxnet代码&lt;/a&gt;已经开源，tensorflow的相关代码也开源了。&lt;/p&gt;
&lt;h2 id=&quot;深度可分离卷积depthwise-separable-convolution&quot;&gt;深度可分离卷积（depthwise separable convolution）&lt;/h2&gt;
&lt;p&gt;在上一篇博客中——&lt;a href=&quot;https://www.cnblogs.com/heguanyou/p/8087422.html&quot;&gt;ShuffleNet总结&lt;/a&gt;中已经说明过卷积的计算了，与这里卷积相关计算有一点不同的是：这论文中长度为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;方阵计算的复杂度直接设为&lt;span class=&quot;math inline&quot;&gt;\(n^2\)&lt;/span&gt;，而我在前一篇博客中设为&lt;span class=&quot;math inline&quot;&gt;\(n^3\)&lt;/span&gt;，实际上能优化到&lt;span class=&quot;math inline&quot;&gt;\(n^{2.376}\)&lt;/span&gt;，加上openmp等多核多线程技术，方阵计算复杂度为&lt;span class=&quot;math inline&quot;&gt;\(n^2\)&lt;/span&gt;是合理的。&lt;/p&gt;
&lt;p&gt;论文中的主要的思想是将一个标准卷积（standard convolution）分解成两个卷积，一个是深度卷积（depthwise convolution），这个卷积应用在每一个输入通道上；另一个是&lt;span class=&quot;math inline&quot;&gt;\(1 \times 1\)&lt;/span&gt;的逐点卷积（pointwise convolution），这个卷积合并每一个深度卷积的输出。&lt;/p&gt;
&lt;h3 id=&quot;分解&quot;&gt;分解&lt;/h3&gt;
&lt;p&gt;为什么标准卷积能分解，怎么分解？先来看下论文给出的分解方法。如图一所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201712/1191997-20171225005859725-1166321660.jpg&quot; alt=&quot;combine&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图1 标准卷积的分解&lt;/center&gt;
&lt;p&gt;事实上标准卷积的分解可以用矩阵乘法来理解。在上一篇博客中——&lt;a href=&quot;https://www.cnblogs.com/heguanyou/p/8087422.html&quot;&gt;ShuffleNet总结&lt;/a&gt;卷积的计算时，如果卷积核&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;为&lt;span class=&quot;math inline&quot;&gt;\(D_K \times D_K \times M \times N\)&lt;/span&gt;，输入的&lt;span class=&quot;math inline&quot;&gt;\(D_F \times D_F \times M\)&lt;/span&gt;张量&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;（也叫Feature）,输出的&lt;span class=&quot;math inline&quot;&gt;\(D_F \times D_F \times N\)&lt;/span&gt;张量&lt;span class=&quot;math inline&quot;&gt;\(G\)&lt;/span&gt;（这里都采用了论文中的符号，&lt;span class=&quot;math inline&quot;&gt;\(D_K\)&lt;/span&gt;为卷积核的长与宽，&lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;是是输入的通道数，&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;输出通道数，&lt;span class=&quot;math inline&quot;&gt;\(D_F\)&lt;/span&gt;是Feature的长与宽），先要将&lt;span class=&quot;math inline&quot;&gt;\(F\)&lt;/span&gt;转换成一个&lt;span class=&quot;math inline&quot;&gt;\((M \times D_K \times D_K) \times (D_F \times D_F)\)&lt;/span&gt;矩阵（就是im2col），卷积核&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;转换为&lt;span class=&quot;math inline&quot;&gt;\(N \times(M \times D_K \times D_K)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;卷积核这个矩阵可以分解成两个矩阵&lt;span class=&quot;math inline&quot;&gt;\(DW\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(PW\)&lt;/span&gt;的乘积，其中&lt;span class=&quot;math inline&quot;&gt;\({DW}\)&lt;/span&gt;代表depthwise convolution，&lt;span class=&quot;math inline&quot;&gt;\({PW}\)&lt;/span&gt;代表pointwise convolution。&lt;span class=&quot;math inline&quot;&gt;\(DW\)&lt;/span&gt;的shape为如图1b)所示的&lt;span class=&quot;math inline&quot;&gt;\(M \times (1 \times D_k \times D_k)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(DP\)&lt;/span&gt;的shape为如图1c)所示的&lt;span class=&quot;math inline&quot;&gt;\(N \times (M \times 1 \times 1)\)&lt;/span&gt;，所以这两个相乘的shape刚好是卷积核&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;的shape：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ K_{N \times(M \times D_K \times D_K)}={PW}_{N \times (M \times 1 \times 1)} \times {DW}_{M \times (1 \times D_k \times D_k)} \tag{1.1} \]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;标准卷积计算&quot;&gt;标准卷积计算&lt;/h4&gt;
&lt;p&gt;可以证明分解出来的两个卷积核与一个标准卷积核是等价的。标准卷积下的计算方法以下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ G_{N \times (D_F \times D_F)} = K_{N \times(M \times D_K \times D_K)} \times F_{(M \times D_K \times D_K) \times (D_F \times D_F)} \tag{1.2} \]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;分解后的计算&quot;&gt;分解后的计算&lt;/h4&gt;
&lt;p&gt;分解成两个卷积后，先与第一个卷积核&lt;span class=&quot;math inline&quot;&gt;\(DW\)&lt;/span&gt;卷积，由于这个卷积核作用于每一个输入的通道，&lt;strong&gt;实现上就是分组了，一共分成了M组&lt;/strong&gt;，这个需要循环计算M次：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ {G1}_{M \times (D_F \times D_F)} = {DW}_{M \times(1 \times D_K \times D_K)} \times F_{(M/M \times D_K \times D_K) \times (D_F \times D_F)} \tag{1.3} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;得到的&lt;span class=&quot;math inline&quot;&gt;\({G1}\)&lt;/span&gt;再转换成一个&lt;span class=&quot;math inline&quot;&gt;\((M \times 1 \times 1) \times (D_F \times D_F)\)&lt;/span&gt;矩阵&lt;span class=&quot;math inline&quot;&gt;\({G2}\)&lt;/span&gt;，再通过与&lt;span class=&quot;math inline&quot;&gt;\({PW}\)&lt;/span&gt;卷积可得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ {G3}_{N \times (D_F \times D_F)} = {PW}_{N \times(M \times 1 \times 1)} \times {G2}_{(M \times 1 \times 1) \times (D_F \times D_F)} \tag{1.4} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分解前后单元网络结构对比如图2所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201712/1191997-20171225005933631-1297130077.jpg&quot; alt=&quot;compare&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图2 分解前后的对比图&lt;/center&gt;
&lt;h3 id=&quot;计算复杂度&quot;&gt;计算复杂度&lt;/h3&gt;
&lt;p&gt;对于标准卷积来说，根据式(1.2)可以看到计算量为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Cost_{std} = D_K \times D_K \times M \times N \times D_F \times D_F \tag{1.5} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于分解后的卷积，根据式(1.3)与式(1.4)可以看到计算量为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Cost_{sep} = D_K \times D_K \times M \times D_F \times D_F + M \times N \times D_F \times D_F\tag{1.6} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分解前后的计算量之比是：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ p = \frac{Cost_{sep}}{Cost_{std}} = \frac{1}{N} + \frac{1}{D_K^2} \tag{1.7} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看到前后的计算量是小了很多的。&lt;/p&gt;
&lt;h2 id=&quot;mobilenets结构&quot;&gt;MobileNets结构&lt;/h2&gt;
&lt;p&gt;经过上面的说明可以看得MoblieNets的结构如图3所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201712/1191997-20171225005958443-834565511.jpg&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图3 MobileNets的网络结构&lt;/center&gt;
&lt;h2 id=&quot;两个超参数&quot;&gt;两个超参数&lt;/h2&gt;
&lt;p&gt;这两个超参数也是相当容易理解的，一个是减小输出通道数&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;，一个是减少输入图片的大小（退出是分辨率resolution）。&lt;/p&gt;
&lt;h3 id=&quot;width-multiplier-alpha&quot;&gt;Width Multiplier &lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如果上面输出的通道数都是原来的&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;倍，那么我们可以知道计算量由式(1.6)变为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Cost_{sep}^\alpha = D_K \times D_K \times \alpha M \times D_F \times D_F + \alpha M \times \alpha N \times D_F \times D_F\tag{1.8} \]&lt;/span&gt;&lt;br/&gt;由于&lt;span class=&quot;math inline&quot;&gt;\(D_K\)&lt;/span&gt;一般比&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;小很多，所以计算量与参数量都大约是&lt;span class=&quot;math inline&quot;&gt;\(\alpha =1\)&lt;/span&gt;（MobileNets的基准线）时的&lt;span class=&quot;math inline&quot;&gt;\(\alpha^2\)&lt;/span&gt;倍。&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;一般取值为0.25，0.5，0.75和1。比如的结果如图4所示。&lt;/p&gt;
&lt;h3 id=&quot;resolution-multipliter-rho&quot;&gt;Resolution Multipliter &lt;span class=&quot;math inline&quot;&gt;\(\rho\)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这个用于控制输入图片的大小，输入的图片越小，后面的feature也会相于地变小，所以能减小计算量，但是并不能减小参数量，因为这个对于卷积核的大小没有影响，计算计算量由式(1.8)变为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Cost_{sep}^{\alpha\rho} = D_K \times D_K \times \alpha M \times \rho D_F \times \rho D_F + \alpha M \times \alpha N \times \rho D_F \times \rho D_F\tag{1.9} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以明显地看到，计算量为原来的&lt;span class=&quot;math inline&quot;&gt;\(\rho^2\)&lt;/span&gt;倍，如果以224大小为基准线，那么输入大小一般建议取为192、160与128。具体结果如图4所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1191997/201712/1191997-20171225010033194-241012434.jpg&quot;/&gt;&lt;/p&gt;
&lt;center&gt;图4 两个超参数对准确率、计算量与参数量的影响。&lt;/center&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;MobileNets基以上面几种技术，训练出来的网络能很好地用于各类视觉任务，比如目标检测、分类等。&lt;/p&gt;
&lt;p&gt;【防止爬虫转载而导致的格式问题——链接】：&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/heguanyou/p/8100246.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/heguanyou/p/8100246.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 17:01:00 +0000</pubDate>
<dc:creator>Thaurun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heguanyou/p/8100246.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 Canvas 的 3D 机房创建 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/8099898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/8099898.html</guid>
<description>&lt;p&gt;对于 3D 机房来说，监控已经不是什么难事，不同的人有不同的做法，今天试着用 HT 写了一个基于 HTML5 的机房，发现果然 HT 简单好用。本例是将灯光、雾化以及 eye 的最大最小距离等等功能在 3D 机房中进行的一个综合性的例子。接下来我将对这个例子的实现进行解析，算是自己对这个例子的一个总结吧。整个例子因为没有设计师的参与，所以样式上可能比较简陋，但是在一些细节的地方，比如墙上的贴图、门框嵌入以及灭火器等等，都是尽可能地还原真实的场景，也是花了些心思做这个例子的！&lt;/p&gt;
&lt;p&gt;本例地址：&lt;a href=&quot;http://www.hightopo.com/guide/guide/core/3d/examples/example_3droom.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/guide/guide/core/3d/examples/example_3droom.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本例动态图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201712/591709-20171224205621006-729271335.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从最基础的开始，场景的布置，照 HTML 的思路，这个场景就是将整个页面放在一个 div 中，再向这个 div 中添加一个顶部的 div 以及一个中间部分的 div，说实在，如果用 HTML 实现这个步骤，我们要写的代码不多，但是如果要写几次这段代码，想必谁都会觉得烦吧。。。HT 将这种实现方法封装了起来，整个外部的 div 就是 HT 的基础组件，这里我们用到的是 ht.widget.BorderPane 组件，上部的 div 封装在 ht.widget.Toolbar 工具条类中，下部分是 3D 部分 ht.graph3d.Graph3dView 组件，将页面中的两个部分通过下面的方式添加进 BorderPane 组件中，并将 BorderPane 添加进 body 体中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
toolbar = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.widget.Toolbar(items);                                                                                                
dataModel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.DataModel();
g3d &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.graph3d.Graph3dView(dataModel);    
g3d.getView().style.background &lt;/span&gt;= 'black'&lt;span&gt;;
g3d.setGridSize(&lt;/span&gt;100&lt;span&gt;);
g3d.setGridGap(&lt;/span&gt;100&lt;span&gt;); 
g3d.setFar(&lt;/span&gt;30000&lt;span&gt;);
g3d.setOrthoWidth(&lt;/span&gt;5000&lt;span&gt;);  
g3d.setFogNear(&lt;/span&gt;100);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认为1，代表从该距离起物体开始受雾效果影响&lt;/span&gt;
g3d.setFogFar(8000&lt;span&gt;);
g3d.reset &lt;/span&gt;=&lt;span&gt; reset;
g3d.reset();
g3d.enableToolTip();                                 
borderPane &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.widget.BorderPane();
borderPane.setTopView(toolbar);
borderPane.setCenterView(g3d);       

view &lt;/span&gt;=&lt;span&gt; borderPane.getView();  
view.className &lt;/span&gt;= 'main'&lt;span&gt;;
document.body.appendChild(view);
window.addEventListener(&lt;/span&gt;'resize', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
    borderPane.invalidate();
}, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码将 borderPane.getView() 添加进 body 体中，是因为 Graph3dView 的界面 DOM 结构是由最底层的 div 元素，以及渲染层 canvas 元素组合而成，通过 getView() 可得到最底层的 div 元素。&lt;/p&gt;
&lt;p&gt;我们还注意到上面代码中没有提及的一个参数 items，这个 items 是 toolbar 工具条的元素，一个数组元素，下面展示一下代码，这里简单地解释了一下，详细信息请参考 &lt;a href=&quot;http://www.hightopo.com/guide/guide/core/toolbar/ht-toolbar-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 工具条手册&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;119&quot;&gt;
&lt;pre&gt;
items = [ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具条中的元素数组&lt;/span&gt;
&lt;span&gt;    {
        label: &lt;/span&gt;'White',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具条元素的标签文字&lt;/span&gt;
        groupId: 'headLightColor',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对工具条元素进行分组，同一个分组内的元素选中会自动出现互斥效果&lt;/span&gt;
        selected: &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具条元素是否被选中，值为true或false，对复选框、开关按钮和单选按钮有效&lt;/span&gt;
        action: &lt;span&gt;function&lt;/span&gt;(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数类型，工具条元素被点击时调用&lt;/span&gt;
            g3d.setHeadlightColor('white'&lt;span&gt;);
        }
    },        
    {
        label: &lt;/span&gt;'Red'&lt;span&gt;,
        groupId: &lt;/span&gt;'headLightColor'&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){                             
            g3d.setHeadlightColor(&lt;/span&gt;'red'&lt;span&gt;);
        }
    }, 
    {
        label: &lt;/span&gt;'Blue'&lt;span&gt;,
        groupId: &lt;/span&gt;'headLightColor'&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){                             
            g3d.setHeadlightColor(&lt;/span&gt;'blue'&lt;span&gt;);
        }
    },        
    {
        label: &lt;/span&gt;'Yellow'&lt;span&gt;,
        groupId: &lt;/span&gt;'headLightColor'&lt;span&gt;,        
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){                             
            g3d.setHeadlightColor(&lt;/span&gt;'yellow'&lt;span&gt;);
        }
    },        
    {
        id: &lt;/span&gt;'step'&lt;span&gt;,                        
        unfocusable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具条元素是否不可获取焦点，默认鼠标滑过时会显示一个矩形边框，可设置为true关闭此效果&lt;/span&gt;
&lt;span&gt;        slider: {
            width: &lt;/span&gt;70&lt;span&gt;,
            step: &lt;/span&gt;500&lt;span&gt;,
            min: &lt;/span&gt;0&lt;span&gt;,
            max: &lt;/span&gt;10000&lt;span&gt;,
            value: &lt;/span&gt;0&lt;span&gt;,                            
            onValueChanged: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                g3d.setHeadlightRange(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getValue());
            }       
        }                
    },
    &lt;/span&gt;'separator', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示分隔条&lt;/span&gt;
&lt;span&gt;    {
        label: &lt;/span&gt;'Fog'&lt;span&gt;,
        type: &lt;/span&gt;'check',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;工具条元素类型，check表示复选框，toggle表示开关按钮，radio表示单选按钮                        &lt;/span&gt;
        action: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            g3d.setFogDisabled(&lt;/span&gt;!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.selected);
        }
    },
    {
        label: &lt;/span&gt;'White'&lt;span&gt;,
        groupId: &lt;/span&gt;'fogColor'&lt;span&gt;,
        selected: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){                             
            g3d.setFogColor(&lt;/span&gt;'white'&lt;span&gt;);
        }
    },                     
    {
        label: &lt;/span&gt;'Red'&lt;span&gt;,
        groupId: &lt;/span&gt;'fogColor'&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){                             
            g3d.setFogColor(&lt;/span&gt;'red'&lt;span&gt;);
        }
    },        
    {
        label: &lt;/span&gt;'Yellow'&lt;span&gt;,
        groupId: &lt;/span&gt;'fogColor'&lt;span&gt;,        
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){                             
            g3d.setFogColor(&lt;/span&gt;'yellow'&lt;span&gt;);
        }
    },
    {                       
        unfocusable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        label: &lt;/span&gt;'FogNear'&lt;span&gt;,
        slider: {
            width: &lt;/span&gt;70&lt;span&gt;,
            min: &lt;/span&gt;10&lt;span&gt;,
            max: &lt;/span&gt;4000&lt;span&gt;,
            value: &lt;/span&gt;100&lt;span&gt;,                            
            onValueChanged: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                g3d.setFogNear(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getValue());
            }       
        }                
    },                        
    {                       
        unfocusable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        label: &lt;/span&gt;'FogFar'&lt;span&gt;,
        slider: {
            width: &lt;/span&gt;70&lt;span&gt;,
            min: &lt;/span&gt;5000&lt;span&gt;,
            max: &lt;/span&gt;15000&lt;span&gt;,
            value: &lt;/span&gt;8000&lt;span&gt;,                            
            onValueChanged: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                g3d.setFogFar(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getValue());
            }       
        }                
    },                    
    &lt;/span&gt;'separator'&lt;span&gt;, 
    {
        id: &lt;/span&gt;'movable'&lt;span&gt;,
        label: &lt;/span&gt;'Movable'&lt;span&gt;,
        type: &lt;/span&gt;'check'&lt;span&gt;,
        selected: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;                
    }, 
    {
        label: &lt;/span&gt;'Editable'&lt;span&gt;,
        type: &lt;/span&gt;'check'&lt;span&gt;,
        selected: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
            g3d.setEditable(item.selected);
        }
    },
    {
        label: &lt;/span&gt;'Wireframe'&lt;span&gt;,
        type: &lt;/span&gt;'check'&lt;span&gt;,
        selected: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(item.selected){
                dataModel.each(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
                    data.s({
                        &lt;/span&gt;'wf.visible': 'selected'&lt;span&gt;,
                        &lt;/span&gt;'wf.color': 'red'&lt;span&gt;                                        
                    });
                });                                
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                dataModel.each(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
                    data.s({
                        &lt;/span&gt;'wf.visible': &lt;span&gt;false&lt;/span&gt;&lt;span&gt;                                       
                    });
                });                               
            }                            
        }
    },
    {
        type: &lt;/span&gt;'toggle'&lt;span&gt;,
        label: &lt;/span&gt;'Orthographic Projection'&lt;span&gt;,                        
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){  
            g3d.setOrtho(item.selected);                           
        }                    
    },
    {
        type: &lt;/span&gt;'toggle'&lt;span&gt;,
        selected: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        label: &lt;/span&gt;'First Person Mode'&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
            g3d.setFirstPersonMode(item.selected);  
            g3d.reset();
        }
    },                                                       
    &lt;/span&gt;'separator'&lt;span&gt;,                      
    {
        type: &lt;/span&gt;'check'&lt;span&gt;,
        label: &lt;/span&gt;'Origin Axis'&lt;span&gt;,
        selected: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
            g3d.setOriginAxisVisible(item.selected);                           
        }
    },   
    {
        type: &lt;/span&gt;'check'&lt;span&gt;,
        label: &lt;/span&gt;'Center Axis'&lt;span&gt;,
        selected: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
            g3d.setCenterAxisVisible(item.selected);                           
        }
    },                             
    {
        type: &lt;/span&gt;'check'&lt;span&gt;,
        label: &lt;/span&gt;'Grid'&lt;span&gt;,
        selected: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
            g3d.setGridVisible(item.selected);                           
        }
    },                    
    {
        label: &lt;/span&gt;'Export Image'&lt;span&gt;,
        action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){                             
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; w =&lt;span&gt; window.open();
            w.document.open();                            
            w.document.write(&lt;/span&gt;&quot;&amp;lt;img src='&quot; + g3d.toDataURL(g3d.getView().style.background) + &quot;'/&amp;gt;&quot;&lt;span&gt;);
                            w.document.close();
        }
    }                    
];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来就是创建场景中的各个模型，首先是三个灯光，中间部分一个，左右后方各一个（我将光源标记出来了，看图~），颜色分别为绿、红、蓝，以及地板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201712/591709-20171224221132568-1696877536.png&quot; alt=&quot;&quot; width=&quot;854&quot; height=&quot;557&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
redLight = &lt;span&gt;new&lt;/span&gt; ht.Light();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;灯光类&lt;/span&gt;
redLight.p3(-1600, 200, -2200&lt;span&gt;);
redLight.s({
    &lt;/span&gt;'light.color': 'red'&lt;span&gt;,
    &lt;/span&gt;'light.range': 1000&lt;span&gt;
});
dataModel.add(redLight);
                
blueLight &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Light();
blueLight.p3(&lt;/span&gt;1600, 200, -2200&lt;span&gt;);
blueLight.s({
    &lt;/span&gt;'light.color': 'blue'&lt;span&gt;,
    &lt;/span&gt;'light.range': 1000&lt;span&gt;
});
dataModel.add(blueLight);                                   
                
greenLight &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Light();
greenLight.p3(&lt;/span&gt;-800, 400, -200&lt;span&gt;);
greenLight.s({
    &lt;/span&gt;'light.center': [-300, 0, -900&lt;span&gt;],
    &lt;/span&gt;'light.type': 'spot'&lt;span&gt;,
    &lt;/span&gt;'light.color': 'green'&lt;span&gt;,
    &lt;/span&gt;'light.range': 4000&lt;span&gt;,
    &lt;/span&gt;'light.exponent': 10&lt;span&gt;
});
dataModel.add(greenLight);                
                
floor &lt;/span&gt;= createNode([0, -5, -1500], [5200, 10, 4200&lt;span&gt;]);
floor.s({                             
    &lt;/span&gt;'shape3d': 'rect'&lt;span&gt;,
    &lt;/span&gt;'shape3d.top.color': '#F0F0F0'&lt;span&gt;                    
});  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来将场景中间部分的服务器、两边的服务器、灭火器，墙上的空调、墙背面的空调等等等等都添加进场景中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;87&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(i=0; i&amp;lt;3; i++&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j=0; j&amp;lt;3; j++&lt;span&gt;){
        createServer1(&lt;/span&gt;250+i*280, -1200-500*j, j === 2&lt;span&gt;);
        createServer1(&lt;/span&gt;-250-i*280, -1200-500*j, j === 1&lt;span&gt;);
    }
}
                     
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建2排2的服务器 放在场景的两边&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;(i=0; i&amp;lt;2; i++&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j=0; j&amp;lt;2; j++&lt;span&gt;){
        createServer2(&lt;/span&gt;1500+i*200, -700-500*&lt;span&gt;j, 
                            (i &lt;/span&gt;=== 1 ? (j === 1 ? '#00FFFF' : '#C800FF') : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
        createServer2(&lt;/span&gt;-1500-i*200, -700-500*&lt;span&gt;j, 
                            (j &lt;/span&gt;=== 1 ? (i === 1 ? 'red' : 'yellow') : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
    }
}                                          
          
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fire extinguisher&lt;/span&gt;
createFireExtinguisher(1300, -1800, [0.45, 0&lt;span&gt;]); 
createFireExtinguisher(&lt;/span&gt;-1300, -1800&lt;span&gt;); 
createFireExtinguisher(&lt;/span&gt;1100, -2450&lt;span&gt;);   
createFireExtinguisher(&lt;/span&gt;-1100, -2450, [0.45, 0&lt;span&gt;]);  
                
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; air condition&lt;/span&gt;
createNode([1120, 170, -700], [80, 340, 170&lt;span&gt;]).s({
    &lt;/span&gt;'all.color': '#EDEDED'&lt;span&gt;,
    &lt;/span&gt;'left.image': 'stand'&lt;span&gt;
}).setToolTip(&lt;/span&gt;'Air Conditioner'&lt;span&gt;); 
createNode([&lt;/span&gt;-1120, 170, -700], [80, 340, 170&lt;span&gt;]).s({
    &lt;/span&gt;'all.color': '#EDEDED'&lt;span&gt;,
    &lt;/span&gt;'right.image': 'stand'&lt;span&gt;
}).setToolTip(&lt;/span&gt;'Air Conditioner'&lt;span&gt;); 
createNode([&lt;/span&gt;1680, 400, -1850], [370, 120, 60&lt;span&gt;]).s({
    &lt;/span&gt;'all.color': '#767676'&lt;span&gt;,
    &lt;/span&gt;'front.image': 'air1'&lt;span&gt;
}).setToolTip(&lt;/span&gt;'Air Conditioner'&lt;span&gt;);             
createNode([&lt;/span&gt;-1680, 400, -1850], [370, 120, 60&lt;span&gt;]).s({
   &lt;/span&gt;'all.color': '#767676'&lt;span&gt;,
   &lt;/span&gt;'front.image': 'air2'&lt;span&gt;
}).setToolTip(&lt;/span&gt;'Air Conditioner'&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=0; i&amp;lt;2; i++&lt;span&gt;){
    createNode([&lt;/span&gt;300+i*580, 90, -2630], [260, 180, 60&lt;span&gt;]).s({
        &lt;/span&gt;'all.color': '#EDEDED'&lt;span&gt;,
        &lt;/span&gt;'back.image': 'air3'&lt;span&gt;
    }).setToolTip(&lt;/span&gt;'Air Conditioner'&lt;span&gt;);  
    createNode([&lt;/span&gt;-300-i*580, 90, -2630], [260, 180, 60&lt;span&gt;]).s({
        &lt;/span&gt;'all.color': '#EDEDED'&lt;span&gt;,
        &lt;/span&gt;'back.image': 'air3'&lt;span&gt;
    }).setToolTip(&lt;/span&gt;'Air Conditioner'&lt;span&gt;);                      
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 其中 createServer1 方法是用来创建服务器的方法，由一个 ht.Node 作为机身以及 ht.Shape 作为机门组合而成，并在机柜的内部添加了随机数台设备：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;100&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; createServer1(x, z, disabled){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建服务器 1（中间部分）&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; h = 360, w = 150, d = 170, k = 10&lt;span&gt;,
         main &lt;/span&gt;= createNode([0, 0, 0&lt;span&gt;], [w, h, d]),
         face &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ht.Shape(),
         s &lt;/span&gt;= {'all.visible': &lt;span&gt;false&lt;/span&gt;, 'front.visible': &lt;span&gt;true&lt;/span&gt;};  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置node节点只有前面可见       &lt;/span&gt;
&lt;span&gt;                  
    dataModel.add(face);
    face.addPoint({x: &lt;/span&gt;-w/2, y: d/2-1});&lt;span&gt;//&lt;/span&gt;&lt;span&gt;门上的三个点&lt;/span&gt;
    face.addPoint({x: w/2, y: d/2-1&lt;span&gt;});
    face.addPoint({x: w&lt;/span&gt;+w/2, y: d/2-1&lt;span&gt;});
    face.setSegments([&lt;/span&gt;1, 2, 1&lt;span&gt;]);                
    face.setTall(h);
    face.setThickness(&lt;/span&gt;1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置厚度      &lt;/span&gt;
&lt;span&gt;    face.s(s);                
    face.setHost(main);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;吸附在main节点上&lt;/span&gt;
&lt;span&gt;                
    main.s({
        &lt;/span&gt;'all.color': '#403F46'&lt;span&gt;,
        &lt;/span&gt;'front.visible': &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    });                
                
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;disabled){                
        face.s({
            &lt;/span&gt;'all.color': 'rgba(0, 40, 60, 0.7)'&lt;span&gt;,
            &lt;/span&gt;'all.reverse.flip': &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反面是否显示正面的东西&lt;/span&gt;
            'all.transparent': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为透明&lt;/span&gt;
&lt;span&gt;       });
       face.face &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化face属性             &lt;/span&gt;
       face.open = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
       face.angle &lt;/span&gt;= -Math.PI * 0.6&lt;span&gt;;                       
       face.setToolTip(&lt;/span&gt;'Double click to open the door'&lt;span&gt;);
                    
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; up = createNode([0, h/2-k/2, d/2], [w, k, 1]).s(s),
            down = createNode([0, -h/2+k/2, d/2], [w, k, 1]).s(s),
            right = createNode([w/2-k/2, 0, d/2], [k, h, 1]).s(s),
            left = createNode([-w/2+k/2, 0, d/2], [k, h, 1]).s(s);
&lt;span&gt;                                
       up.setHost(face);
       down.setHost(face);
       left.setHost(face);
       right.setHost(face);

       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机创建机柜中的设备数量 2个或者4个&lt;/span&gt;
       &lt;span&gt;var&lt;/span&gt; num = Math.ceil(Math.random() * 2&lt;span&gt;),
       start &lt;/span&gt;= 20 + 20 *&lt;span&gt; Math.random();
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;num; i++&lt;span&gt;){
           &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; node = createNode([0, start+45*i, 0], [w-6, 16, d-30&lt;span&gt;]);
           node.setHost(main);
           node.s({
               &lt;/span&gt;'front.image': 'server'&lt;span&gt;,
               &lt;/span&gt;'all.color': '#E6DEEC'&lt;span&gt;,
               &lt;/span&gt;'all.reverse.cull': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
           });
           node.pop &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化设备“弹出”的属性&lt;/span&gt;
           node.setToolTip('Double click to pop the server'&lt;span&gt;);

           &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; node = createNode([0, -start-45*i, 0], [w-6, 16, d-30&lt;span&gt;]);
           node.setHost(main);
           node.s({
               &lt;/span&gt;'front.image': 'server'&lt;span&gt;,
               &lt;/span&gt;'all.color': '#E6DEEC'&lt;span&gt;,
               &lt;/span&gt;'all.reverse.cull': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
           }); 
           node.pop &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
           node.setToolTip(&lt;/span&gt;'Double click to pop the server'&lt;span&gt;);
       }                    
   }
                
   main.p3(x, h&lt;/span&gt;/2+1, z);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个服务器我们还制作了门的打开以及关闭的动作，还有服务器内部的设备的弹出以及恢复位置。首先，对 3d 组件添加了过滤函数，对双击事件的元素过滤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201712/591709-20171224233444256-2107749922.png&quot; alt=&quot;&quot; width=&quot;447&quot; height=&quot;291&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
g3d.onDataDoubleClicked = &lt;span&gt;function&lt;/span&gt;(data, e, dataInfo){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图元被双击时回调&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(data.face){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;face是定义门时候开启的属性 是在节点定义的时候添加的 下面的 pop 也是一样&lt;/span&gt;
        data.getHost().getAttaches().each(&lt;span&gt;function&lt;/span&gt;(attach){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历吸附到自身的所有节点的ht.List类型数组&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(attach.pop){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pop 是定义设备是否弹出的属性&lt;/span&gt;
&lt;span&gt;                toggleData(attach);
            }
       });
    }
    toggleData(data, dataInfo.name);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以下是对 toggleData 的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; toggleData(data, name){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开关门 以及 设备弹出缩回的动作&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; angle =&lt;span&gt; data.angle,
    pop &lt;/span&gt;=&lt;span&gt; data.pop;
            
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(angle != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(anim){
            anim.stop(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ht内置的函数 参数为true时终止动画&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oldAngle = data.window ?&lt;span&gt; data.getRotationX() : data.getRotation();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(data.open){
            angle &lt;/span&gt;= -&lt;span&gt;angle;
        }
        data.open &lt;/span&gt;= !&lt;span&gt;data.open;
        anim &lt;/span&gt;=&lt;span&gt; ht.Default.startAnim({
            action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(v){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(data.window){
                    data.setRotationX(oldAngle &lt;/span&gt;+ v *&lt;span&gt; angle);    
               }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                   data.setRotation(oldAngle &lt;/span&gt;+ v *&lt;span&gt; angle);
               }                                
           }
       });
   }
   &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(pop != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(anim){
           anim.stop(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p3 =&lt;span&gt; data.p3(),
            s3 &lt;/span&gt;=&lt;span&gt; data.s3(),
            dist &lt;/span&gt;= pop ? -s3[2] : s3[2&lt;span&gt;];
        data.pop &lt;/span&gt;= !&lt;span&gt;data.pop;                        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(data.pop){
            data.s({
                &lt;/span&gt;'note': 'Detail...'&lt;span&gt;,  
                &lt;/span&gt;'note.background': '#3498DB'&lt;span&gt;,
                &lt;/span&gt;'note.font': '26px Arial'&lt;span&gt;,
                &lt;/span&gt;'note.position': 6&lt;span&gt;,
                &lt;/span&gt;'note.t3': [-30, -3, 30&lt;span&gt;],
                &lt;/span&gt;'note.expanded': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;'note.toggleable': &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;'note.autorotate': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;                        
            });                                     
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
             data.s(&lt;/span&gt;'note', &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }                                                
        anim &lt;/span&gt;=&lt;span&gt; ht.Default.startAnim({
             action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(v){
                 data.p3(p3[&lt;/span&gt;0], p3[1], p3[2] + v *&lt;span&gt; dist);                                                               
             }
        }); 
    }            
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中间部分的服务器我就不赘述了，这里聊一下比较有趣的部分，灭火器模型的制作，并不是 Max3d 制作而成的，而是代码生成的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201712/591709-20171224232542537-507672601.png&quot; alt=&quot;&quot; width=&quot;157&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出来，这个灭火器是由底部一个圆柱，中间一个半圆形以及顶部一个小圆柱并在上面贴图合成的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; createFireExtinguisher(x, z, uvOffset){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建灭火器&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; w = 80&lt;span&gt;, 
          h &lt;/span&gt;= 200&lt;span&gt;,
          body &lt;/span&gt;= createNode([0, 0, 0], [w, h, w]).s({&lt;span&gt;//&lt;/span&gt;&lt;span&gt;身体的圆柱&lt;/span&gt;
              'shape3d': 'cylinder',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;圆柱&lt;/span&gt;
              'shape3d.image': 'fire'&lt;span&gt;,
              &lt;/span&gt;'shape3d.uv.offset': uvOffset,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;决定3d图形整体贴图的uv偏移&lt;/span&gt;
              'shape3d.reverse.cull': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
          }),                    
          sphere &lt;/span&gt;= createNode([0, h/2, 0], [w, w, w]).s({
              'shape3d': 'sphere',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;球体&lt;/span&gt;
              'shape3d.color': '#F20000'&lt;span&gt;,
              &lt;/span&gt;'shape3d.reverse.cull': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
          }),
          top &lt;/span&gt;= createNode([0, h/2+w/3, 0], [w/2, w/2, w/2]).s({//头部的圆柱
              'shape3d': 'cylinder'&lt;span&gt;,
              &lt;/span&gt;'shape3d.color': '#242424'&lt;span&gt;,
              &lt;/span&gt;'shape3d.reverse.cull': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
          });
                    
    sphere.setHost(body);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置吸附 只要body移动sphere也会移动&lt;/span&gt;
&lt;span&gt;    top.setHost(sphere);
    body.p3([x, h&lt;/span&gt;/2, z]);
    body.setToolTip('Fire Extinguisher'&lt;span&gt;);
    sphere.setToolTip(&lt;/span&gt;'Fire Extinguisher'&lt;span&gt;);
    top.setToolTip(&lt;/span&gt;'Fire Extinguisher'&lt;span&gt;);
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以上！这个 3d 机房的例子非常有代表性，性能也展示得很全面，觉得有必要拿出来讲一下，希望能对你们有一定的帮助~&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 15:56:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/8099898.html</dc:identifier>
</item>
<item>
<title>在Intellij里使用Erlang依赖库 - zzqboy</title>
<link>http://www.cnblogs.com/zzqboy/p/8099405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzqboy/p/8099405.html</guid>
<description>&lt;p&gt;这里以protobuffs为例，记录一下环境的配置，发现这种东西中文的资料真的不多，无论是分享还是记录都是很好的&lt;/p&gt;
&lt;p&gt;1.创建一个文件夹名use_proto, 配置rebar.config文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
{deps, [{protobuffs,&quot;.*&quot;,{git,&quot;git://github.com/basho/erlang_protobuffs.git&quot;}}]}.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　进入目录执行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
rebar create-app appid=use_proto
rebar get-deps
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　目录如下&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1287239/201712/1287239-20171224230431600-269106700.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　注意此时最后用管理员启动cmd，否则会出现下面错误&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1287239/201712/1287239-20171224232146006-591932452.jpg&quot; alt=&quot;&quot; width=&quot;664&quot; height=&quot;154&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.导入intellij&lt;/p&gt;
&lt;p&gt;打开你的intellij-&amp;gt;file-&amp;gt;import project from external model&lt;/p&gt;
&lt;p&gt;然后一直next&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287239/201712/1287239-20171224234627162-1844911935.jpg&quot; alt=&quot;&quot; width=&quot;410&quot; height=&quot;422&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以在上面一个步骤看到导入了两个库，这个为导入成功的标志，看一下project structure, 或者你能修改成下面的样子也行(就不用在导入intellij前get-deps)，否则一定要在导入前下好依赖包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287239/201712/1287239-20171224234803943-2007889888.jpg&quot; alt=&quot;&quot; width=&quot;625&quot; height=&quot;184&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就可以写我们的测试脚本了，在src里添加下面两个文件&lt;/p&gt;
&lt;p&gt;player.proto&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
message Person {
     required int32 age = 1;
     required string name = 2;
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;test_proto.erl&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
-module(test_proto).
-author(&quot;zzqboy&quot;).

%% API
-export([main/0]).
-include(&quot;player_pb.hrl&quot;).

main() -&amp;gt;
  Player = #person{age = 18, name = &quot;zzq&quot;},
  player_pb:encode_person(Player).
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3.添加compile和erl命令参数，运行代码&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1287239/201712/1287239-20171224235012975-317215462.jpg&quot; alt=&quot;&quot; width=&quot;791&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到结果，说明已经成功将record类型转为二进制，ye~~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287239/201712/1287239-20171224235128584-573957608.jpg&quot; alt=&quot;&quot; width=&quot;956&quot; height=&quot;91&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 24 Dec 2017 15:54:00 +0000</pubDate>
<dc:creator>zzqboy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzqboy/p/8099405.html</dc:identifier>
</item>
<item>
<title>VMWare 虚拟化 Ubuntu 64 （16.04）-- docker 无法链接 pull 镜像 ？(solved) - ~阿坨坨</title>
<link>http://www.cnblogs.com/atuotuo/p/8099891.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atuotuo/p/8099891.html</guid>
<description>
&lt;p&gt;根据项目的需要，虚拟化一个Ubuntu OS 来玩 docker，虚拟机选择的是WMWare （VMware-player-14.0.0-6661328）; Ubuntu的镜像来自于官网（ubuntu-16.04.3-desktop-amd64.iso）。&lt;/p&gt;
&lt;p&gt;期初做这个WM的时候是在Win7 Professonal 64 完成的，做完之后在Windows 2012 server 上面运行，VM一切正常（包括使用docker pull 镜像）。 &lt;/p&gt;
&lt;p&gt;后来，又在一台Win10 home 版的机器上部署虚拟机，发现部署完成之后docker 不能 pull 镜像，报错如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ docker pull mysql
Using default tag: latest
Error response from daemon: Get https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;registry-1.docker.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;网上搜索了一大堆，解决问题的方案都是分为两派：&lt;/p&gt;
&lt;p&gt;1. “添加国内镜像仓库”，例如ali-cloud, dao-cloud， 等等。。。&lt;/p&gt;
&lt;p&gt;2. 查看防火墙，关闭防火墙。&lt;/p&gt;

&lt;p&gt;经过分析，以及不断地尝试，首先排除防火墙的问题。此外，“添加国内镜像的方法”也只是一个替代方案，没有从根本上解决问题。 整理思路之后，尝试着在&lt;span&gt;WMWare的网络设置&lt;/span&gt;上试试看：&lt;/p&gt;
&lt;p&gt;查看WmWare的网络设置，默认情况下是NAT，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201712/396477-20171224234744521-897073117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在NAT的模式下，尝试pull一个mysql的镜像，报错如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201712/396477-20171224234647115-864716373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;试着修改WMWare网络的网络设置为“bridge”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201712/396477-20171224234851865-1595522772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;再次运行pull命令,  where amazing happened!!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/396477/201712/396477-20171224235040475-1413077699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;其实，我们只是&lt;span&gt;&lt;strong&gt;将WMWare的网络设置从 “NAT” 修改成为 “Bridge”， 然后就OK了&lt;/strong&gt;&lt;/span&gt;。具体的原理和原因我也无从查证，希望有大神能有指点指点。&lt;/p&gt;
&lt;p&gt;虽然折腾的有点晚了，不过还是解决了问题 :) &lt;/p&gt;
&lt;p&gt;感谢大家的观看，如果知道原因的也请留言，一起讨论！！ Thanks &lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 15:54:00 +0000</pubDate>
<dc:creator>~阿坨坨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/atuotuo/p/8099891.html</dc:identifier>
</item>
<item>
<title>2017年终总结 - 小浩学长</title>
<link>http://www.cnblogs.com/xiaohaoxuezhang/p/8099809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohaoxuezhang/p/8099809.html</guid>
<description>&lt;p&gt;　　今年鸡年，鄙人24岁，犯值太岁，算命说我今年会有一个机会，如果我能报握住，那未来将会大富大贵，起先我也只是听听，没想到这个机会来得如此快。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;　　今年刚过完年回来成都上班，正值原公司效益不好，准备裁员，我们项目组全部被砍。然后就接到我Jack（我师傅）电话，说他从阿里离职出来准备创业，问我有创业的打算没有。我一听，这不是传闻的机会来了吗？没想到这才刚过完年24天就来了，这命是我妈去算的，她当时听到高兴得不得了，然后自然而然就为创业做打算了。&lt;br/&gt;　　三月份到七月份就在成都出租房里自学底层Webgl API，顺着Jack的WonderJs 3D游戏引擎的UML图开始照猫画虎，写了一个自己的3D引擎AmyJs，虽然只能画一个三角形，但麻雀虽小五脏俱全。整个引擎干什么、什么阶段干什么自己也是有个大概，对引擎基础UI贴图、光照、阴影、Buffer处理、GPU渲染流水线都有了一定的了解。独自开发了2个多月时间，进入五月份的时候,我已经压抑不住自己内心的麻雀，还想再体验一下公司里开发，和同事聊天的感觉，这个时候我就去找个web前端工作。学习vue开发项目，空闲时间就去学习FRP（函数反应式编程）和FP（函数式编程），不得不说切换编程范式确实是个很难受的过程，在这个过程里需要你忘记以前学过的东西，你会感觉自己又不会编程了，又重新体验了一下编程入门的感觉。&lt;br/&gt;函数式编程其将函数作为第一公民，引入不可变数据更加如虎添翼，根据我们公司近三个月的使用情况来看，将来肯定会越来越流行，替代OOP登上王座。而函数反应式编程也是今年特别火的技术，把各种数据当做流来处理，完全符合LISP里说的流水线式处理，用在前端可谓是再好不过。&lt;br/&gt;　　七月份至今，Jack找我说，准备就绪，可以过来一起搞了，七月份就离职交接工作然后回家呆了一段时间，当我再次回来成都时，我也该放弃一些东西，以前觉得放手是很简单的事情，但只有经历过才知道，放弃一件事和开始一件事一样需要很大的勇气，在这五个月里跟随Jack学习了灵学，收获很大，现在我们来说说创业时期我所放弃和开始的东西。&lt;br/&gt;　　1.放弃朋友。我这个人很害怕孤独，所以以前总会舍弃自己的时间和利益去换取别人的重视，这是我从小到大一直存在的心理缺陷，直到我跟Jack进行心理治疗时才慢慢改正过来。在创业前几个月我周末经常会去和朋友打麻将，而且熬了很多通宵，每熬一次都对我造成无法估计的损害，不仅仅是精神、身体的损害。每次熬夜过后我都非常悔恨，但我控制不住自己，那只有强行改变，我就把所有群都退了，再也不接受任何活动，这样慢慢适应一个月就基本没有再人约我了。嗜欲深者天机浅，这句话我现在能理解他的含义，嗜欲深会让我们把注意力放在诱惑上，而放弃了回归自己，与高我沟通的机会。&lt;br/&gt;　　2.放弃游戏。现在看来虽然我偶尔两周会找同学打一会游戏，但我越来越对游戏没兴趣，每次打着打着就会感觉自己怎么会喜欢这种东西。然后就起身回家做一些有意义的事情，看看书听听歌都能让我感觉很舒适，尤其是由于经常戴耳机造成我神经性耳鸣以后，我对网吧也越来越厌恶，我现在知道任何一件事的发生都有它的意义，它的发生就是为了让你去改变、让你去反思自己。&lt;br/&gt;　　3.放弃自卑和嫉妒。后面跟Jack进行心理治疗以后我才知道这也是心理缺陷，主要是由于自卑和嫉妒，想通过炫耀自己来让别人觉得我很厉害，这也是个大众通病。以前的自己每次学到新的知识、取得成就、包括我最近开始的一万小时学习，就喜欢去朋友圈炫耀，目的就是想让人知道我技术达到了很高的层次，后面导致我的朋友越来越少，我能感觉到他们的恶意，然后我进行了反思和Jack讨论，发现这原来是内心小孩在作祟，主要原因是童年经历了一些事情让我非常在意别人的看法，我记得高中我考上全班第一以后就有这种心态，别人都在注视着我，我不敢犯错，只能努力证明自己。以后没有大事就不发发朋友圈，每次学习了一千个小时的时候就去朋友圈记录一下，这个要不要去，我觉得可以去让关心我的人知道，比较半年多一条，也不会让人反感。&lt;br/&gt;　　4.开始关注自己。我开始意识到自己是这世界的主人，所有这一切都是围绕我来开展，所有事情都是我想要的，是我吸引过来的。这也是为什么我们越害怕一个事情，它发生的概率就越大，因为我们一直在向宇宙发生申请，让它过来。以前自己的关注点在别人身上或者说关注外在，任何人、任何事如果让我不舒服就会影响我的情绪，很多时候我控制不住自己的情绪，然后就独自生气，彻夜难眠。动怒伤肝、熬夜伤肝，所以导致我肝功能解读差，当我明白以后我也就很少再让自己处于生气的状态，如果一个人突然来惹我生气，他一定是来考验我的，所以谢谢他，感谢他的所作所为让我更加不会生气。&lt;br/&gt;　　5.开始锻炼减肥。自己胖了将近十年了，我想要什么就能得到什么，不断对自己说，我想变得很瘦，很帅，皮肤很好，然后你的身体就会不会抗拒努力，他会自发的想让你变好，这里定下一个小目标，现在离回家还有48天，我要瘦20斤，我会回家给他们看到觉醒以后的我是什么样子。&lt;br/&gt;　　6.开始学习英语。之前说了，我们可以做成任何事情，可以成为任何一种人，学习英语只是其他一个很简单的事情。&lt;/p&gt;&lt;p&gt;　　我们来聊聊这五个月时间我学到的技术吧。&lt;br/&gt;　　1.项目从0到1的经历，这是很美妙的东西，只有体会过才知道不断思考提炼架构是多么爽的事情。&lt;br/&gt;　　2.代码质量，以前虽然学过很多重构书籍，但每次做完功能让Jack审核的时候总会让我收获巨大，学习他如何思考问题是非常重要的一件事情。&lt;br/&gt;　　3.测试，我们公司目标是要开发顶尖的引擎和编辑器，所以95%的测试覆盖率是最基础的。&lt;br/&gt;　　4.我们也使用了Facebook新开发的reason和reasonReact重写了编辑器，全部使用的严格的函数式编程。&lt;/p&gt;&lt;p&gt;　　感谢Jack、感谢这一年离开我的朋友、感谢这一年经历的痛苦，是你们让我不断进步，将来，生活会更加美好。&lt;/p&gt;&lt;p&gt;　　到这里就是我一年的收获了，本命年真是太有意义了，这一年成功完成了自己的觉醒。&lt;br/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 15:31:00 +0000</pubDate>
<dc:creator>小浩学长</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohaoxuezhang/p/8099809.html</dc:identifier>
</item>
<item>
<title>Git（二）Git几个区的关系与Git和GitHub的关联 - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/8099185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/8099185.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　前面只是大概的介绍了一点基础的东西，接下来会更加深入的去了解一下Git。&lt;/p&gt;
&lt;h2&gt;一、Git的工作区、暂存区和版本库之间的区别和联系&lt;/h2&gt;
&lt;p&gt;　　1）工作区&lt;/p&gt;
&lt;p&gt;　　　　在PC中能看得到的&lt;span&gt;创建的一个管理仓库的目录。比如目录下GitTest里的文件&lt;/span&gt;(.git隐藏目录版本库除外)。&lt;span&gt;或者以后需要再新建的目录文件等等都属于工作区范畴&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224205039303-1967924303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）版本库（repository）　&lt;/p&gt;
&lt;p&gt;　　　　工作区&lt;span&gt;有一个隐藏目录.git，这个不算工作区，而是Git的版本库&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　Git的版本库里&lt;span&gt;存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区&lt;/span&gt;，还有&lt;span&gt;Git为我们自动创建的第一个分支master，以及指向master的一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　指针叫HEAD。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　3）联系&lt;/p&gt;
&lt;p&gt;　　　　在初始化git版本库之后会生成一个隐藏的文件 .git ，可以将该文件理解为git的版本库 repository，而我们自己建立的项目文件夹即工作区 working directory ,&lt;/p&gt;
&lt;p&gt;　　　　在.git 文件夹里面还有很多文件，其中有&lt;span&gt;一个index 文件 就是暂存区也可以叫做 stage&lt;/span&gt; ,git还为我们自动生成了一个分支master以及指向该分支的指针head。　　　&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224205725287-1447668820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　从图中可以看出来&lt;span&gt;respository包括分支master和stage&lt;/span&gt;, working diretory 可以理解为&lt;span&gt;我们打开开发环境如eclipse，里面的内容即工作区的内容，在工作区里面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　有的代码以及配置文件等我们需要提交到版本库里面，最终是到了分支master上面，暂存区只是一个临时保存修改文件的地方&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　　　前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：&lt;/p&gt;
&lt;p&gt;　　　　　　第一步是：用git add把文件添加进去，实际上就是把文件修改添加到暂存区；&lt;/p&gt;
&lt;p&gt;　　　　　　第二步是：用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。&lt;/p&gt;
&lt;p&gt;　　　　因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。&lt;/p&gt;
&lt;p&gt;　　4）编写一个Demo&lt;/p&gt;
&lt;p&gt;　　　　我们在lance.txt再添加一行内容为eeeeee，接着在目录下新建一个文件为fosun.txt 内容为test，我们先用命令 git status来查看下状态，如下：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224210747490-973426237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　现在我们先使用git add . 命令把2个文件都添加到暂存区中，再使用git status来查看下状态，如下：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224210846537-1683737432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　接着我们可以使用git commit一次性提交到分支上，如下：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224211014209-910284701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　注意：当在工作去修改了文件或者新建了文件没有加入到暂存区去时，使用git status显示的是红色的。加入到之后是绿色的了。&lt;/p&gt;
&lt;h2&gt;二、远程仓库&lt;/h2&gt;
&lt;h3&gt;2.1、本地与远程GitHub的配置&lt;/h3&gt;
&lt;p&gt;　　在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要进行简单的设置：&lt;/p&gt;
&lt;p&gt;　　　　1）创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，&lt;/p&gt;
&lt;p&gt;　　　　　　如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　　　ssh-keygen  -t rsa –C “youremail@example.com”
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224213130318-704214175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。&lt;/p&gt;
&lt;p&gt;　　　　2）登录github,打开” settings”中的SSH Keys页面，然后点击“Add SSH Key”,填上任意title，在Key文本框里黏贴id_rsa.pub文件的内容。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224213346553-1280678958.png&quot; alt=&quot;&quot; width=&quot;972&quot; height=&quot;255&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　然后&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224213617928-2145320307.png&quot; alt=&quot;&quot; width=&quot;795&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　然后&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224213825771-853688438.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;339&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　点击 Add Key，你就应该可以看到已经添加的key。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224213930646-81988955.png&quot; alt=&quot;&quot; width=&quot;781&quot; height=&quot;427&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2、添加远程库&lt;/h3&gt;
&lt;p&gt;　　1）需求&lt;/p&gt;
&lt;p&gt;　　　　我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，&lt;/p&gt;
&lt;p&gt;　　　　这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。&lt;/p&gt;
&lt;p&gt;　　2）首先，登录github上，然后在右上角找到“create a new repo”创建一个新的仓库。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224214850568-283850948.png&quot; alt=&quot;&quot; width=&quot;776&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　然后&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224215025209-2053315340.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;459&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　在Repository name填入&lt;code&gt;GitTest&lt;/code&gt;，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224215204896-562898294.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;487&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　目前，在GitHub上的这个&lt;code&gt;testgit&lt;/code&gt;仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，&lt;/p&gt;
&lt;p&gt;　　　　然后，把本地仓库的内容推送到GitHub仓库。&lt;/p&gt;
&lt;p&gt;　　　　现在，我们根据GitHub的提示，在本地的GitTest仓库下运行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　　　git remote add origin https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/zyh2017/GitTest.git&lt;br/&gt;　　　　git push -u origin master&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224215645193-1439092432.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　　　把本地库的&lt;span&gt;内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　　　由于远程库是空的，我们&lt;span&gt;第一次推送master分支时，加上了 –u参数&lt;/span&gt;，Git不但会把本地的master分支内容推送的远程新的master分支，&lt;/p&gt;
&lt;p&gt;　　　　还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面&lt;/p&gt;
&lt;p&gt;　　　　中看到远程库的内容已经和本地一模一样了，上面的要输入github的用户名和密码如下所示：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224215944428-252152373.png&quot; alt=&quot;&quot; width=&quot;760&quot; height=&quot;399&quot;/&gt;　　　&lt;/p&gt;
&lt;p&gt;　　　　从现在起，只要本地作了提交，就可以通过如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　　　git push origin master
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。&lt;/p&gt;
&lt;h3&gt;2.3、从远程库克隆&lt;/h3&gt;
&lt;p&gt;　　上面我们了解了先有本地库，后有远程库时候，如何关联远程库。&lt;/p&gt;
&lt;p&gt;　　现在我们想，假如远程库有新的内容了，我想克隆到本地来 如何克隆呢？&lt;/p&gt;
&lt;p&gt;　　举个简单的例子：&lt;/p&gt;
&lt;p&gt;　　　　1）首先，登录github，创建一个新的仓库GitTest2&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224220732756-1509332686.png&quot; alt=&quot;&quot; width=&quot;597&quot; height=&quot;463&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　结果：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224220801287-1309673216.png&quot; alt=&quot;&quot; width=&quot;650&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　现在，远程库已经准备好了，下一步是使用命令git clone克隆一个本地库了。如下所示：&lt;/p&gt;
&lt;p&gt;　　　　执行命令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/zyh2017/GitTest2.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224220948146-1800804800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　结果：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201712/999804-20171224221045709-1079735178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　喜欢就“推荐”哦！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 14:14:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/8099185.html</dc:identifier>
</item>
<item>
<title>Material使用05 自定义主题、黑夜模式\白天模式切换 - NeverCtrl_C</title>
<link>http://www.cnblogs.com/NeverCtrl-C/p/8099416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeverCtrl-C/p/8099416.html</guid>
<description>&lt;p&gt;需求：&lt;/p&gt;
&lt;p&gt;　　1 不使用materil依赖内建的主题，使用自己创建的主题&lt;/p&gt;
&lt;p&gt;　　2 利用自己创建的主题实现白天模式和黑夜模式&lt;/p&gt;

&lt;h2&gt;1 自定义主题&lt;/h2&gt;
&lt;h3&gt;　　1.1 创建自定义主题文件 them.scss&lt;/h3&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224172810975-1383816394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_5ae37737-2a7c-494c-861b-bc541f79da05&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5ae37737-2a7c-494c-861b-bc541f79da05&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5ae37737-2a7c-494c-861b-bc541f79da05&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入material自定义主题支持&lt;/span&gt;
@import '~@angular/material/theming'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入material公用的主题风格&lt;/span&gt;
@include mat-&lt;span&gt;core();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义颜色&lt;/span&gt;
$my-app-primary: mat-palette($mat-&lt;span&gt;blue);
$my&lt;/span&gt;-app-accent: mat-palette($mat-&lt;span&gt;teal, A200, A100, A400);
$my&lt;/span&gt;-app-warn: mat-palette($mat-&lt;span&gt;red);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用自定义颜色组装自定义主题&lt;/span&gt;
$my-app-theme: mat-light-theme($my-app-primary, $my-app-accent, $my-app-&lt;span&gt;warn);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置自定义主题，使其生效&lt;/span&gt;
@include angular-material-theme($my-app-theme);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;　　　　1.1.1 引入material主题支持和material公用的主题风格&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入material自定义主题支持&lt;/span&gt;
@import '~@angular/material/theming'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入material公用的主题风格&lt;/span&gt;
@include mat-core();
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　　　1.1.2 根据material公用的主题风格设定自己的主题颜色&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义颜色&lt;/span&gt;
$my-app-primary: mat-palette($mat-blue); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主色&lt;/span&gt;
$my-app-accent: mat-palette($mat-teal, A200, A100, A400); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 副色&lt;/span&gt;
$my-app-warn: mat-palette($mat-red); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 警告色&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　代码解释01： $my-app-primary就是一个自定义的变量&lt;/p&gt;
&lt;p&gt;　　　　代码解释02： $mat-blue表示使用material主题风格中的blue这种颜色&lt;/p&gt;
&lt;p&gt;　　　　代码解释03： $my-app-primary: mat-palette($mat-blue); 表示通过material主题风格的函数将material主题风格中的blue颜色赋值给$my-app-primary变量&lt;/p&gt;
&lt;p&gt;　　　　技巧01：如何查看material的主题风格中提供了哪些颜色 -&amp;gt; &lt;a href=&quot;https://material.io/color/#!/?view.left=0&amp;amp;view.right=0&amp;amp;primary.color=4FC3F7&quot; target=&quot;_blank&quot;&gt;点击前往&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;　　　　1.1.3 利用自己的主题颜色组成自定义主题&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用自定义颜色组装自定义主题&lt;/span&gt;
$my-app-theme: mat-light-theme($my-app-primary, $my-app-accent, $my-app-warn);
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　　　1.1.4 设置主题颜色使其生效&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置自定义主题，使其生效&lt;/span&gt;
@include angular-material-theme($my-app-theme);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　1.2 在全局样式文件中引入自定义的主题文件them.scss&lt;/h3&gt;
&lt;p&gt;　　　　技巧01：需要将默认引入的materi内建主题注释掉&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224173732990-764909287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_c8fcd71d-da49-4b57-a7da-a8115090ca67&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c8fcd71d-da49-4b57-a7da-a8115090ca67&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c8fcd71d-da49-4b57-a7da-a8115090ca67&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; You can add global styles to this file, and also import other style files &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @import '~@angular/material/prebuilt-themes/deeppurple-amber.css'; // 导入material的内建主体&lt;/span&gt;
@import 'theme.scss'&lt;span&gt;;


html, body, app&lt;/span&gt;-root, md-sidenav-&lt;span&gt;container, .site {
    width: &lt;/span&gt;100%&lt;span&gt;;
    height: &lt;/span&gt;100%&lt;span&gt;;
    margin: &lt;/span&gt;0&lt;span&gt;;
}

.site {
    display: flex;
    flex&lt;/span&gt;-&lt;span&gt;direction: column;
}
header {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; background-color: skyblue;&lt;/span&gt;
&lt;span&gt;}
main {
    flex: &lt;/span&gt;1&lt;span&gt;;
}
footer {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; background-color: skyblue; &lt;/span&gt;
&lt;span&gt;}

.fill&lt;/span&gt;-remaining-space { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; flex项目自动填充多余空间&lt;/span&gt;
    flex: 1 1&lt;span&gt; auto;
}

.full&lt;/span&gt;-&lt;span&gt;width {
    width: &lt;/span&gt;100%&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　1.3 效果如下&lt;/h3&gt;
&lt;p&gt; 　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224173925787-1690487828.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2 利用多主题实现多模式&lt;/h2&gt;
&lt;h3&gt;　　2.1 添加黑夜主题&lt;/h3&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224214047428-1696074806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_0c1eb0a5-e5f2-4540-b522-53487a670eff&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0c1eb0a5-e5f2-4540-b522-53487a670eff&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0c1eb0a5-e5f2-4540-b522-53487a670eff&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入material自定义主题支持&lt;/span&gt;
@import '~@angular/material/theming'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入material公用的主题风格&lt;/span&gt;
@include mat-&lt;span&gt;core();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义颜色&lt;/span&gt;
$my-app-primary: mat-palette($mat-blue); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主色&lt;/span&gt;
$my-app-accent: mat-palette($mat-teal, A200, A100, A400); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 副色&lt;/span&gt;
$my-app-warn: mat-palette($mat-red); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 警告色&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用自定义颜色组装自定义主题&lt;/span&gt;
$my-app-theme: mat-light-theme($my-app-primary, $my-app-accent, $my-app-&lt;span&gt;warn);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置自定义主题，使其生效&lt;/span&gt;
@include angular-material-theme($my-app-&lt;span&gt;theme);



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义颜色&lt;/span&gt;
$my-dark-primary: mat-palette($mat-blue-grey); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主色&lt;/span&gt;
$my-dark-accent: mat-palette($mat-amber, A200, A100, A400); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 副色&lt;/span&gt;
$my-dark-warn: mat-palette($mat-deep-orange); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 警告色&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 利用自定义颜色组装自定义主题&lt;/span&gt;
$my-dark-theme: mat-light-theme($my-dark-primary, $my-dark-accent, $my-dark-&lt;span&gt;warn);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置自定义主题，使其生效&lt;/span&gt;
.myapp-dark-&lt;span&gt;theme {
    @include angular&lt;/span&gt;-material-theme($my-dark-&lt;span&gt;theme);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　技巧01：将黑夜主题放在一个class类中进行引入，当这个类被激活时就表示开启黑夜模式&lt;/p&gt;
&lt;h3&gt;　　2.2 在页眉组件添加一个按钮用于开启或者关闭黑夜模式&lt;/h3&gt;
&lt;h4&gt;　　　　2.2.1 在共享模块中引入MdSlideToggleModule&lt;/h4&gt;
&lt;p&gt; 　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224214429943-1844435301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_eb4001fb-0c3a-493f-9b1a-1f678c6ae61e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eb4001fb-0c3a-493f-9b1a-1f678c6ae61e&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eb4001fb-0c3a-493f-9b1a-1f678c6ae61e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
import { NgModule } from '@angular/core'&lt;span&gt;;
import { CommonModule } from &lt;/span&gt;'@angular/common'&lt;span&gt;;
import { 
  MdSidenavModule, 
  MdToolbarModule,
  MdIconModule,
  MdButtonModule,
  MdIconRegistry,
  MdCardModule,
  MdInputModule,
  MdListModule,
  MdSlideToggleModule
 } from &lt;/span&gt;'@angular/material'&lt;span&gt;;
 import { HttpModule } from &lt;/span&gt;'@angular/http'&lt;span&gt;;

@NgModule({
  imports: [
    CommonModule,
    HttpModule,
    MdSidenavModule,
    MdToolbarModule,
    MdIconModule,
    MdButtonModule,
    MdCardModule,
    MdInputModule,
    MdListModule,
    MdSlideToggleModule
  ],
  declarations: [],
  exports: [
    CommonModule,
    MdSidenavModule,
    MdToolbarModule,
    MdIconModule,
    MdButtonModule,
    HttpModule,
    MdCardModule,
    MdInputModule,
    MdListModule,
    MdSlideToggleModule
  ]
})
export class SharedModule { }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;　　　　2.2.2 在组件中使用MdSlideToggleModule提供的md-slide-toggle组件&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224214606740-1615932929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d6f01222-0650-4544-9407-9ef99b5544cd&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d6f01222-0650-4544-9407-9ef99b5544cd&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d6f01222-0650-4544-9407-9ef99b5544cd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;md-toolbar color=&quot;primary&quot;&amp;gt;
    &amp;lt;button md-icon-button (click)=&quot;openSidebar()&quot;&amp;gt;
        &amp;lt;md-icon&amp;gt;menu&amp;lt;/md-icon&amp;gt;
    &amp;lt;/button&amp;gt;
    &amp;amp;&lt;span&gt;nbsp;
    &lt;/span&gt;&amp;lt;span&amp;gt;企业协作平台&amp;lt;/span&amp;gt;
    &amp;lt;!-- &amp;amp;&lt;span&gt;nbsp;
    &lt;/span&gt;&amp;lt;md-icon&amp;gt;accessibility&amp;lt;/md-icon&amp;gt;
    &amp;lt;md-icon svgIcon=&quot;header&quot;&amp;gt;&amp;lt;/md-icon&amp;gt; --&amp;gt;
    &amp;lt;span class='fill-remaining-space'&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;md-slide-toggle (change)='onChange($event.checked)'&amp;gt;黑夜模式&amp;lt;/md-slide-toggle&amp;gt;
&amp;lt;/md-toolbar&amp;gt;               
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　代码解释01：&amp;lt;span class='fill-remaining-space'&amp;gt;&amp;lt;/span&amp;gt;的主要作用是撑满剩余的空间&lt;/p&gt;
&lt;p&gt;　　　　　　代码解释02：(change)='onChange($event.checked)' 的作用是当md-slide-toggle组件发生变化时执行相应的方法，参数md-slide-toggle的当前值&lt;/p&gt;
&lt;p&gt;　　　　　　技巧01：md-slide-toggle官方文档 -&amp;gt; &lt;a href=&quot;https://material.angular.io/components/slide-toggle/overview&quot; target=&quot;_blank&quot;&gt;点击前往&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt; 　　　　2.2.3 在使用md-slide-toggle的组件编写一个输出变量&lt;/h4&gt;
&lt;p&gt;　　　　　　当md-slide-toggle组件的值发生变化时就将变化后的值发送给使用md-slide-toggle这个组件的父组件&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224215113068-1011006667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_a761cbc8-371a-4d9e-a0b8-8b5f32f071d5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a761cbc8-371a-4d9e-a0b8-8b5f32f071d5&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a761cbc8-371a-4d9e-a0b8-8b5f32f071d5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
import { Component, OnInit, Output, EventEmitter } from '@angular/core'&lt;span&gt;;

@Component({
  selector: &lt;/span&gt;'app-header'&lt;span&gt;,
  templateUrl: &lt;/span&gt;'./header.component.html'&lt;span&gt;,
  styleUrls: [&lt;/span&gt;'./header.component.scss'&lt;span&gt;]
})
export class HeaderComponent implements OnInit {
  @Output()
  toggle &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; EventEmitter&amp;lt;&lt;span&gt;void&lt;/span&gt;&amp;gt;&lt;span&gt;();

  @Output()
  toggleDarkTheme &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; EventEmitter&amp;lt;&lt;span&gt;boolean&lt;/span&gt;&amp;gt;&lt;span&gt;();

  constructor() { }

  ngOnInit() {
  }

  openSidebar() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.toggle.emit();
  }

  onChange(eventValue: &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log('是否黑夜模式：' + eventValue);&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.toggleDarkTheme.emit(eventValue);
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;　　　　2.2.4 在父组件中监听使用md-slide-toggle的那个组件触发的事件&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224215422162-1728094240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_57e714a6-7252-4ef6-b2f9-12bb031e01de&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_57e714a6-7252-4ef6-b2f9-12bb031e01de&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_57e714a6-7252-4ef6-b2f9-12bb031e01de&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;md-sidenav-container [class.myapp-dark-theme]=&quot;darkTheme&quot;&amp;gt;
  &amp;lt;md-sidenav #sidenav mode=&quot;push&quot;&amp;gt;
    &amp;lt;app-sidenav&amp;gt;&amp;lt;/app-sidenav&amp;gt;
  &amp;lt;/md-sidenav&amp;gt;
  &amp;lt;div class=&quot;site&quot;&amp;gt;
    &amp;lt;header&amp;gt;
      &amp;lt;app-header (toggle)=&quot;sidenav.toggle()&quot; (toggleDarkTheme)=&quot;switchTheme($event)&quot;&amp;gt;&amp;lt;/app-header&amp;gt;
    &amp;lt;/header&amp;gt;
    &amp;lt;main&amp;gt;
      &amp;lt;router-outlet&amp;gt;&amp;lt;/router-outlet&amp;gt;
    &amp;lt;/main&amp;gt;
    &amp;lt;footer&amp;gt;
      &amp;lt;app-footer&amp;gt;&amp;lt;/app-footer&amp;gt;
    &amp;lt;/footer&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/md-sidenav-container&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　代码解释01：&amp;lt;app-header (toggle)=&quot;sidenav.toggle()&quot; (toggleDarkTheme)=&quot;switchTheme($event)&quot;&amp;gt;&amp;lt;/app-header&amp;gt; 当app-header组件触发toggleDarkTheme会引发使用app-haeder组件的父组件触发switchTheme方法，并将app-header组件发出的参数接收到作为switchTheme方法的参数&lt;/p&gt;
&lt;h4&gt; 　　　　2.2.5 在父组件中编写switchTheme方法&lt;/h4&gt;
&lt;p&gt;　　　　　　该方法根据接收到的参数真假来判断是否开启黑夜模式对应的class类&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224220033490-1966019584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224220127912-1203110391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_a1b384b7-6ffb-4ea4-9f3d-9714d5a863cf&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a1b384b7-6ffb-4ea4-9f3d-9714d5a863cf&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a1b384b7-6ffb-4ea4-9f3d-9714d5a863cf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
import { Component } from '@angular/core'&lt;span&gt;;

@Component({
  selector: &lt;/span&gt;'app-root'&lt;span&gt;,
  templateUrl: &lt;/span&gt;'./app.component.html'&lt;span&gt;,
  styleUrls: [&lt;/span&gt;'./app.component.scss'&lt;span&gt;]
})
export class AppComponent { 
  darkTheme &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

  switchTheme(dark) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.darkTheme =&lt;span&gt; dark;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; alert(this.darkTheme);&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　2.3 效果图如下&lt;/h3&gt;
&lt;h4&gt;　　　　2.3.1 白天模式&lt;/h4&gt;
&lt;p&gt; 　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224220311725-1328408032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　　　2.3.2 黑夜模式&lt;/h4&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1057762/201712/1057762-20171224220347771-264689367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　2.4 待解决问题&lt;/h3&gt;
&lt;p&gt;　　　　2017年12月24日22:04:30&lt;/p&gt;
&lt;p&gt;　　　　md-card组件的主题失效&lt;/p&gt;
&lt;p&gt; 　　　　md-side-nav组件的主题失效&lt;/p&gt;

</description>
<pubDate>Sun, 24 Dec 2017 14:06:00 +0000</pubDate>
<dc:creator>NeverCtrl_C</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeverCtrl-C/p/8099416.html</dc:identifier>
</item>
<item>
<title>Android查缺补漏--BroadcastReceiver的类型与使用 - codingblock</title>
<link>http://www.cnblogs.com/codingblock/p/8034110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingblock/p/8034110.html</guid>
<description>&lt;p&gt;Broadcast 是一种被用于应用内和应用之间传递信息的机制。一个广播可以对应多个接受者。一个完整的广播机制，需要具有以下三个要素：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送广播的Broadcast&lt;/li&gt;
&lt;li&gt;接受广播的BroadcastReceiver&lt;/li&gt;
&lt;li&gt;传递信息的Intent&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;广播的注册分为静态注册和动态注册：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;静态注册：静态注册的广播是指在AndroidManifest中注册的广播，此种广播在应用安装时就被系统解析，不需要启动应用就可以收到相应的广播。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcastReceiver&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;动态注册：通过Context.registerReceiver()来实现，不需要时要通过Context.unRegisterReceiver()解除广播，此种广播必须应用启动后才能注册并接收广播。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 动态注册广播接收器
registerReceiver(new DynamicBroadcastReceiver(), new IntentFilter(MyBroadcastReceiver.ACTION));&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;广播又分为普通广播、有序广播、本地广播和sticky广播。&lt;/p&gt;
&lt;h3 id=&quot;一普通广播&quot;&gt;一、普通广播&lt;/h3&gt;
&lt;p&gt;普通广播通过Context.sendBroadcast()发送，我们没有办法制定Receiver们对于普通广播的接收顺序。理论上所有的接收器（Receiver）接收到广播的顺序不确定，但一般是按照其在AndroidMainfest.xml文件中注册的顺序（不绝对）。&lt;br/&gt;普通广播中，接受者不能将处理结果传递给下一个接收器，也无法终止广播的传播。&lt;/p&gt;
&lt;p&gt;如下代码是一个静态注册的广播示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyBroadcastReceiver extends BroadcastReceiver {

    String TAG = MyBroadcastReceiver.class.getSimpleName();

    public static final String ACTION = &quot;MY_BROADCAST_RECEIVER&quot;;

    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i(TAG, &quot;接收到广播消息：&quot; + intent.getStringExtra(BroadcastTestActivity.INTENT_INFO));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再AndroidMainfest.xml中注册这个广播:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcastReceiver&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来在Activity中调用Context.sendBroadcast()发送广播就可以了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Intent intent = new Intent(MyBroadcastReceiver.ACTION);
intent.putExtra(INTENT_INFO, &quot;我是一个普通广播&quot;);
sendBroadcast(intent);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;log如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;12-08 17:29:44.259 6644-6644/cn.codingblock.androidadvancestudy I/MyBroadcastReceiver: 接收到广播消息：我是一个普通广播&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;普通广播的接收顺序测试&lt;br/&gt;我们仿照MyBroadcastReciver创建多个接收器，代码一样：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * 静态注册的广播接收器2
 * Created by liuwei on 17/12/7.
 */
public class MyBroadcast2Receiver extends BroadcastReceiver {

    String TAG = MyBroadcast2Receiver.class.getSimpleName();

    public static final String ACTION = &quot;MY_BROADCAST_RECEIVER&quot;;

    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i(TAG, &quot;接收到广播消息：&quot; + intent.getStringExtra(BroadcastTestActivity.INTENT_INFO));
    }
}
/**
 * 静态注册的广播接收器3
 * Created by liuwei on 17/12/7.
 */
public class MyBroadcast3Receiver extends BroadcastReceiver {...}
/**
 * 静态注册的广播接收器4
 * Created by liuwei on 17/12/7.
 */
public class MyBroadcast4Receiver extends BroadcastReceiver {...}
/**
 * 静态注册的广播接收器5
 * Created by liuwei on 17/12/7.
 */
public class MyBroadcast5Receiver extends BroadcastReceiver {...}
/**
 * 静态注册的广播接收器6
 * Created by liuwei on 17/12/7.
 */
public class MyBroadcast6Receiver extends BroadcastReceiver {...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在AndroidMainfest.xml中为以上广播都注册同一个action&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcastReceiver&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;

&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcast6Receiver&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;

&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcast2Receiver&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;

&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcast3Receiver&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;

&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcast4Receiver&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;

&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcast5Receiver&quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击发送广播，查看log：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;12-08 17:29:44.259 6644-6644/cn.codingblock.androidadvancestudy I/MyBroadcastReceiver: 接收到广播消息：我是一个普通广播
12-08 17:29:44.268 6644-6644/cn.codingblock.androidadvancestudy I/MyBroadcast6Receiver: 接收到广播消息：我是一个普通广播
12-08 17:29:44.271 6644-6644/cn.codingblock.androidadvancestudy I/MyBroadcast2Receiver: 接收到广播消息：我是一个普通广播
12-08 17:29:44.273 6644-6644/cn.codingblock.androidadvancestudy I/MyBroadcast3Receiver: 接收到广播消息：我是一个普通广播
12-08 17:29:44.277 6644-6644/cn.codingblock.androidadvancestudy I/MyBroadcast4Receiver: 接收到广播消息：我是一个普通广播
12-08 17:29:44.280 6644-6644/cn.codingblock.androidadvancestudy I/MyBroadcast5Receiver: 接收到广播消息：我是一个普通广播&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二有序广播&quot;&gt;二、有序广播&lt;/h3&gt;
&lt;p&gt;在AndroidMainfest.xml中注册广播时通过priority（值越优先级越高）节点为广播添加优先级，然后再用Context.sendOrderedBroadcast()发送，接收者们就会按照优先级顺序依次执行。&lt;/p&gt;
&lt;p&gt;有序广播的接收者和给下一个接收者传递数据，并且接收者在收到广播之后可以抛弃广播，使广播不再向后传递。&lt;/p&gt;
&lt;p&gt;为上面6个接收器添加优先级：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcastReceiver&quot;&amp;gt;
    &amp;lt;intent-filter android:priority=&quot;1&quot;&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;

&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcast6Receiver&quot;&amp;gt;
    &amp;lt;intent-filter android:priority=&quot;6&quot;&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;

&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcast2Receiver&quot;&amp;gt;
    &amp;lt;intent-filter android:priority=&quot;2&quot;&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;

&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcast3Receiver&quot;&amp;gt;
    &amp;lt;intent-filter android:priority=&quot;3&quot;&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;

&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcast4Receiver&quot;&amp;gt;
    &amp;lt;intent-filter android:priority=&quot;4&quot;&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;

&amp;lt;receiver android:name=&quot;.broadcast.MyBroadcast5Receiver&quot;&amp;gt;
    &amp;lt;intent-filter android:priority=&quot;5&quot;&amp;gt;
        &amp;lt;action android:name=&quot;MY_BROADCAST_RECEIVER&quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/receiver&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后通过sendOrderedBroadcast发送广播观察log：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;intent = new Intent(MyBroadcastReceiver.ACTION);
intent.putExtra(INTENT_INFO, &quot;我是一个有序广播&quot;);
sendOrderedBroadcast(intent, null);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;log如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;12-08 18:17:26.455 25919-25919/cn.codingblock.androidadvancestudy I/MyBroadcast6Receiver: 接收到广播消息：我是一个有序广播
12-08 18:17:26.462 25919-25919/cn.codingblock.androidadvancestudy I/MyBroadcast5Receiver: 接收到广播消息：我是一个有序广播
12-08 18:17:26.464 25919-25919/cn.codingblock.androidadvancestudy I/MyBroadcast4Receiver: 接收到广播消息：我是一个有序广播
12-08 18:17:26.465 25919-25919/cn.codingblock.androidadvancestudy I/MyBroadcast3Receiver: 接收到广播消息：我是一个有序广播
12-08 18:17:26.466 25919-25919/cn.codingblock.androidadvancestudy I/MyBroadcast2Receiver: 接收到广播消息：我是一个有序广播
12-08 18:17:26.467 25919-25919/cn.codingblock.androidadvancestudy I/MyBroadcastReceiver: 接收到广播消息：我是一个有序广播&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;abortBroadcast()抛弃广播：&lt;br/&gt;普通的广播是没有办法抛弃的，否则会抛出RuntimeException的异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有有序广播才可以通过此方法抛弃。我们在MyBroadcast6Receiver中添加abortBroadcast()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyBroadcast6Receiver extends BroadcastReceiver {

    String TAG = MyBroadcast6Receiver.class.getSimpleName();

    public static final String ACTION = &quot;MY_BROADCAST_RECEIVER&quot;;

    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i(TAG, &quot;接收到广播消息：&quot; + intent.getStringExtra(BroadcastTestActivity.INTENT_INFO));
        abortBroadcast();
        Log.i(TAG, &quot;丢弃广播&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后点击发送有序广播，log如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;12-08 18:34:27.989 1329-1329/cn.codingblock.androidadvancestudy I/MyBroadcast6Receiver: 接收到广播消息：我是一个有序广播
12-08 18:34:27.989 1329-1329/cn.codingblock.androidadvancestudy I/MyBroadcast6Receiver: 丢弃广播&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到广播已经被丢弃了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;setResult()传递给下一个接收者结果。&lt;/li&gt;
&lt;li&gt;getResult()接收上一个接收者的结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在MyBroadcast6Receiver中添加setResult方法，在MyBroadcast5Receiver添加getResult方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyBroadcast6Receiver extends BroadcastReceiver {

    String TAG = MyBroadcast6Receiver.class.getSimpleName();

    public static final String ACTION = &quot;MY_BROADCAST_RECEIVER&quot;;

    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i(TAG, &quot;接收到广播消息：&quot; + intent.getStringExtra(BroadcastTestActivity.INTENT_INFO));
//        abortBroadcast();
//        Log.i(TAG, &quot;丢弃广播&quot;);
        setResult(006, &quot;我是老6传来的消息&quot;, null);
    }
}
public class MyBroadcast5Receiver extends BroadcastReceiver {

    String TAG = MyBroadcast5Receiver.class.getSimpleName();

    public static final String ACTION = &quot;MY_BROADCAST_RECEIVER&quot;;

    @Override
    public void onReceive(Context context, Intent intent) {
        Log.i(TAG, &quot;接收到广播消息：&quot; + intent.getStringExtra(BroadcastTestActivity.INTENT_INFO));
        String data = getResultData();
        Log.i(TAG, &quot;data=&quot; + data);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;log如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;12-08 18:40:01.415 10372-10372/cn.codingblock.androidadvancestudy I/MyBroadcast6Receiver: 接收到广播消息：我是一个有序广播
12-08 18:40:01.434 10372-10372/cn.codingblock.androidadvancestudy I/MyBroadcast5Receiver: 接收到广播消息：我是一个有序广播
12-08 18:40:01.434 10372-10372/cn.codingblock.androidadvancestudy I/MyBroadcast5Receiver: data=我是老6传来的消息
12-08 18:40:01.440 10372-10372/cn.codingblock.androidadvancestudy I/MyBroadcast4Receiver: 接收到广播消息：我是一个有序广播
12-08 18:40:01.442 10372-10372/cn.codingblock.androidadvancestudy I/MyBroadcast3Receiver: 接收到广播消息：我是一个有序广播
12-08 18:40:01.445 10372-10372/cn.codingblock.androidadvancestudy I/MyBroadcast2Receiver: 接收到广播消息：我是一个有序广播
12-08 18:40:01.447 10372-10372/cn.codingblock.androidadvancestudy I/MyBroadcastReceiver: 接收到广播消息：我是一个有序广播&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三本地广播&quot;&gt;三、本地广播&lt;/h3&gt;
&lt;p&gt;以上的广播对于系统来说是全局的，发出广播后，系统内的应用只要注册了相应的接收器就都可以收到广播。如果我们想在本应用发出的广播只在此应用内可以收到，那么可以使用本地广播了。&lt;/p&gt;
&lt;p&gt;本地广播由 LocalBroadcastManager 管理，是在 API 21 以后添加的，使用起来也很方便，需要先通过 LocalBroadcastManager.getInstance() 方法获取其单例，剩下的用法与其他广播类似，其主要方法有以下几个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;registerReceiver():注册广播接收器。&lt;/li&gt;
&lt;li&gt;unregisterReceiver():解除广播接收器。&lt;/li&gt;
&lt;li&gt;sendBroadcast():发送异步广播。&lt;/li&gt;
&lt;li&gt;sendBroadcastSync():发送同步广播。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用本地广播时，无需在AndroidMainfest.xml中注册，必须使用 LocalBroadcastManager.getInstance(...).registerReceiver(..)来注册接收器。&lt;/p&gt;
&lt;p&gt;我们来写个本地广播的小栗子，首先注册两个本地广播：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LocalBroadcastManager.getInstance(context).registerReceiver(new MyBroadcastReceiver(), new IntentFilter(MyBroadcastReceiver.ACTION));
LocalBroadcastManager.getInstance(context).registerReceiver(new MyBroadcast2Receiver(), new IntentFilter(MyBroadcastReceiver.ACTION));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后发送本地广播：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;intent.putExtra(INTENT_INFO, &quot;我是一个本地广播&quot;);
LocalBroadcastManager.getInstance(context).sendBroadcast(intent);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;log如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;12-09 17:20:47.799 15019-15019/cn.codingblock.androidadvancestudy I/MyBroadcastReceiver: 接收到广播消息：我是一个本地广播
12-09 17:20:47.799 15019-15019/cn.codingblock.androidadvancestudy I/MyBroadcast2Receiver: 接收到广播消息：我是一个本地广播&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四sticky广播不建议使用&quot;&gt;四、sticky广播（不建议使用）&lt;/h3&gt;
&lt;p&gt;sticky广播会一直处于滞留状态，sticky广播被发出后，只要有能够匹配其的新接收器被注册了就可以收到广播，sticky广播通过Context.sendStickyBroadcast()发送。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;最后想说的是，本系列文章为博主对Android知识进行再次梳理，查缺补漏的学习过程，一方面是对自己遗忘的东西加以复习重新掌握，另一方面相信在重新学习的过程中定会有巨大的新收获，如果你也有跟我同样的想法，不妨关注我一起学习，互相探讨，共同进步！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;参考文献：&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;《Android开发艺术探索》&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;《Android开发进阶从小工到专家》&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 24 Dec 2017 13:44:00 +0000</pubDate>
<dc:creator>codingblock</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingblock/p/8034110.html</dc:identifier>
</item>
<item>
<title>OVS 总体架构、源码结构及数据流程全面解析 - bakari</title>
<link>http://www.cnblogs.com/bakari/p/8097478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bakari/p/8097478.html</guid>
<description>&lt;p&gt;在前文「&lt;a href=&quot;http://www.cnblogs.com/bakari/p/8097439.html&quot;&gt;从 Bridge 到 OVS&lt;/a&gt;」中，我们已经对 OVS 进行了一番探索。本文决定从 OVS 的整体架构到各个组件都进行一个详细的介绍。&lt;/p&gt;
&lt;h2 id=&quot;ovs-架构&quot;&gt;OVS 架构&lt;/h2&gt;
&lt;p&gt;OVS 是产品级的虚拟交换机，大量应用在生产环境中，支撑整个数据中心虚拟网络的运转。OVS 基于 SDN 的思想，将整个核心架构分为控制面和数据面，数据面负责数据的交换工作，控制面实现交换策略，指导数据面工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171224102317818-1090106576.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从整体上看，OVS 可以划分为三大块，管理面、数据面和控制面。&lt;/p&gt;
&lt;p&gt;数据面就是以用户态的 ovs-vswitchd 和内核态的 datapath 为主的转发模块，以及与之相关联的数据库模块 ovsdb-server，控制面主要是由 ovs-ofctl 模块负责，基于 OpenFlow 协议与数据面进行交互。而管理面则是由 OVS 提供的各种工具来负责，这些工具的提供也是为了方便用户对底层各个模块的控制管理，提高用户体验。下面就对这些工具进行一个逐一的阐述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ovs-ofctl&lt;/code&gt;&lt;/strong&gt;：这个是控制面的模块，但本质上它也是一个管理工具，主要是基于 OpenFlow 协议对 OpenFlow 交换机进行监控和管理，通过它可以显示一个 OpenFlow 交换机的当前状态，包括功能、配置和表中的项。使用时，有很多参数，我们可以通过 ovs-ofctl --help 查看。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;常用命令：

ovs-ofctl show switch-name ：输出交换机信息，包括其流量表和端口信息。

ovs-ofctl dump-ports switch-name：输出交换机的端口统计信息，包括收发包、丢包、错误包等数量。

ovs-ofctl add-flow switch-name：为交换机配置流策略。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ovs-dpctl&lt;/code&gt;&lt;/strong&gt;：用来配置交换机的内核模块 datapath，它可以创建，修改和删除 datapath，一般，单个机器上的 datapath 有 256 条（0-255）。一条 datapath 对应一个虚拟网络设备。该工具还可以统计每条 datapath 上的设备通过的流量，打印流的信息等，更过参数通过 ovs-dpctl --help 查看。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;常用命令：

ovs-dpctl show ：显示所有 datapath 的基本信息。

ovs-dpctl dump-dps ：显示所有 datapath 的名字。

ovs-dpctl dump-flows DP ：显示一条 datapath DP 上的流信息。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ovs-appctl&lt;/code&gt;&lt;/strong&gt;：查询和控制运行中的 OVS 守护进程，包括 ovs-switchd，datapath，OpenFlow 控制器等，兼具 ovs-ofctl、ovs-dpctl 的功能，是一个非常强大的命令。ovs-vswitchd 等进程启动之后就以一个守护进程的形式运行，为了能够很好的让用户控制这些进程，就有了这个命令。详细可以 ovs-appctl --help 查看。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ovs-vsctl&lt;/code&gt;&lt;/strong&gt;：查询和更新 ovs-vswitchd 的配置，这也是一个很强大的命令，网桥、端口、协议等相关的命令都由它来完成。此外，还负责和 ovsdb-server 相关的数据库操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;常用命令：

ovs-vsctl show ：显示主机上已有的网桥及端口信息。

ovs-vsctl add-br br0：添加网桥 br0。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ovsdb-client&lt;/code&gt;&lt;/strong&gt;：访问 ovsdb-server 的客户端程序，通过 ovsdb-server 执行一些数据库操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;常用命令：

ovsdb-client dump：用来查看ovsdb内容。

ovsdb-client transact ：用来执行一条类 sql。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ovsdb-tool&lt;/code&gt;&lt;/strong&gt;：和 ovsdb-client 要借助 ovsdb-server 才能进行相关数据库操作不同，ovsdb-tool 可以直接操作数据库。&lt;/p&gt;
&lt;h2 id=&quot;ovs-源码结构&quot;&gt;OVS 源码结构&lt;/h2&gt;
&lt;p&gt;OVS 源码结构中，主要包含以下几个主要的模块，数据交换逻辑在 vswitchd 和 datapath 中实现，vswitchd 是最核心的模块，OpenFlow 的相关逻辑都在 vswitchd 中实现，datapath 则不是必须的模块。ovsdb 用于存储 vswitch 本身的配置信息，如端口、拓扑、规则等。控制面部分采用的是 OVS 自家实现的 OVN，和其他控制器相比，OVN 对 OVS 和 OpenStack 有更好的兼容性和性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171224102359443-1589744207.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出 OVS 的分层结构，最上层 vswitchd 主要与 ovsdb 通信，做配置下发和更新等，中间层是 ofproto ，用于和 OpenFlow 控制器通信，并基于下层的 ofproto provider 提供的接口，完成具体的设备操作和流表操作等工作。&lt;/p&gt;
&lt;p&gt;dpif 层实现对流表的操作。&lt;/p&gt;
&lt;p&gt;netdev 层实现了对网络设备（如 Ethernet）的抽象，基于 netdev provider 接口实现多种不同平台的设备，如 Linux 内核的 system, tap, internal 等，dpdk 系的 vhost, vhost-user 等，以及隧道相关的 gre, vxlan 等。&lt;/p&gt;
&lt;h2 id=&quot;数据转发流程&quot;&gt;数据转发流程&lt;/h2&gt;
&lt;p&gt;通过一个例子来看看 OVS 中数据包是如何进行转发的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171224102412506-951322711.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）ovs 的 datapath 接收到从 ovs 连接的某个网络端口发来的数据包，从数据包中提取源/目的 IP、源/目的 MAC、端口等信息。&lt;/p&gt;
&lt;p&gt;2）ovs 在内核态查看流表结构（通过 hash），如果命中，则快速转发。&lt;/p&gt;
&lt;p&gt;3）如果没有命中，内核态不知道如何处置这个数据包，所以，通过 netlink upcall 机制从内核态通知用户态，发送给 ovs-vswitchd 组件处理。&lt;/p&gt;
&lt;p&gt;4）ovs-vswitchd 查询用户态精确流表和模糊流表，如果还不命中，在 SDN 控制器接入的情况下，经过 OpenFlow 协议，通告给控制器，由控制器处理。&lt;/p&gt;
&lt;p&gt;5）如果模糊命中， ovs-vswitchd 会同时刷新用户态精确流表和内核态精确流表，如果精确命中，则只更新内核态流表。&lt;/p&gt;
&lt;p&gt;6）刷新后，重新把该数据包注入给内核态 datapath 模块处理。&lt;/p&gt;
&lt;p&gt;7）datapath 重新发起选路，查询内核流表，匹配；报文转发，结束。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;OVS 为了方便用户操作，提供了很多管理工具，我们平常在使用过程中只需记住每个工具的作用，具体的命令可以使用 -h 或 --help 查看。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对云计算感兴趣的小伙伴可以关注我的微信公众号：aCloudDeveloper，专注云计算领域，坚持分享干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171224102452490-840809963.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Dec 2017 13:33:00 +0000</pubDate>
<dc:creator>bakari</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bakari/p/8097478.html</dc:identifier>
</item>
</channel>
</rss>