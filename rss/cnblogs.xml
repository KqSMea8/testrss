<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Dora.Interception，为.NET Core度身打造的AOP框架 [5]：轻松地实现与其他AOP框架的整合 - Artech</title>
<link>http://www.cnblogs.com/artech/p/dora-interception-05.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/dora-interception-05.html</guid>
<description>&lt;p&gt;这里所谓的与第三方AOP框架的整合不是说改变Dora.Interception现有的编程，而是恰好相反，即在&lt;strong&gt;不改变现有编程模式下采用第三方AOP框架或者自行实现的拦截机制&lt;/strong&gt;。虽然我们默认提供基于IL Emit实现方式，并且对IL指令进行了深度的优化，但是如果我们真的具有更好的选择，我们可以通过简单的扩展完成对底层拦截机制改变。&lt;/p&gt;

&lt;p&gt;对于Dora.Interception来说，方法调用之所有能够被拦截的根源在于我们改变了服务实例的提供方式，原来的对象被替换成了可被拦截的代理对象。针对代理对象的提供体现在如下这个IInterceptingProxyFactory接口上。如果提供类型体现为一个接口，Wrap方法会被调用来创建一个封装目标对象的代理（如果不需要被拦截，则直接返回目标对象）；如果提供类型体现为一个类型，Create方法则被用来实现对代理对象的创建，如果不需要被拦截，方法提供的后面两个参数会被用来提供目标对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IInterceptingProxyFactory
{
    IServiceProvider ServiceProvider { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; Wrap(Type typeToIntercept, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; target);
    &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; Create(Type typeToIntercept, IServiceProvider serviceProvider, Func&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; targetAccessor = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Dora.Interception提供了如下一个实现了IInterceptingProxyFactory接口的基类InterceptingProxyFactoryBase。后者帮助我们实现针对拦截器的解析，解析后的拦截器体现为一个InterceptorDecoration对象。作为它的派生类型只需要实现两个受保护的虚方法Wrap和Create根据解析出来的拦截器实现可被拦截的代理对象的创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterceptingProxyFactoryBase : IInterceptingProxyFactory
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IInterceptorResolver InterceptorResolver { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IServiceProvider ServiceProvider { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InterceptingProxyFactoryBase(IInterceptorResolver interceptorResolver, IServiceProvider serviceProvider);    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Create(Type typeToIntercept, IServiceProvider serviceProvider, Func&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; targetAccessor = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Wrap(Type typeToIntercept, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; target);

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanIntercept(Type typeToIntercept);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Wrap(Type typeToIntercept, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; target, InterceptorDecoration interceptors);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Create(Type typeToIntercept, IServiceProvider serviceProvider, InterceptorDecoration interceptors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果所示的是InterceptorDecoration， 我们可以得到应用到目标类型中所有方法（包括属性的Get和Set方法）上的拦截器（实际上所有拦截器按照指定顺序构建而成的拦截器管道，最终体现为一个类型为InterceptorDelegate 的委托对象）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterceptorDecoration
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InterceptorDelegate GetInterceptor(MethodInfo methodInfo);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MethodInfo GetTargetMethod(MethodInfo methodInfo);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsInterceptable(MethodInfo methodInfo);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IReadOnlyDictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, InterceptorDelegate&amp;gt; Interceptors { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsEmpty { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IReadOnlyDictionary&amp;lt;MethodInfo, MethodBasedInterceptorDecoration&amp;gt; MethodBasedInterceptors { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IReadOnlyDictionary&amp;lt;PropertyInfo, PropertyBasedInterceptorDecoration&amp;gt; PropertyBasedInterceptors { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MethodBasedInterceptorDecoration
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; InterceptorDelegate Interceptor { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MethodInfo Method { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PropertyBasedInterceptorDecoration
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PropertyInfo Property { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MethodBasedInterceptorDecoration GetMethodBasedInterceptor { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MethodBasedInterceptorDecoration SetMethodBasedInterceptor { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自定义的IInterceptingProxyFactory实现只需要按照普通的服进行注册即可。&lt;/p&gt;

&lt;p&gt;由于Castle原生的框架并没有提供针对Task的支持，所以我们利用另一个名为&lt;a href=&quot;https://github.com/JSkimming/Castle.Core.AsyncInterceptor&quot;&gt;Castle.Core.AsyncInterceptor&lt;/a&gt;将Castle的拦截实现整合到Dora.Interception。具体的实现体现在如下这个DynamicProxyFactory中。该类型对应的NuGet包为“Dora.Interception.Castle”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DynamicProxyFactory : InterceptingProxyFactoryBase
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DynamicProxyFactory(IInterceptorResolver interceptorResolver, IServiceProvider serviceProvider);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Create(Type typeToIntercept, IServiceProvider serviceProvider, InterceptorDecoration interceptors);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Wrap(Type typeToIntercept, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; target, InterceptorDecoration interceptors);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果需要采用基于Caslte的拦截实现机制，我们只需要做如下的设置即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {        
        services
            ...
            AddInterception(builder&lt;/span&gt;=&amp;gt;&lt;span&gt;builder.SetCastleDynamicProxy());
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IServiceProvider ConfigureServices(IServiceCollection services)
    {        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; services
            ...
            .BuildInterceptableServiceProvider(builder&lt;/span&gt;=&amp;gt;&lt;span&gt;builder.SetCastleDynamicProxy());
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-01.html&quot;&gt;[1]：更加简练的编程体验&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-02.html&quot;&gt;[2]：基于约定的拦截器定义方式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-03.html&quot;&gt;[3]：多样性的拦截器应用方式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-04.html&quot;&gt;[4]：与依赖注入框架的深度整合&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-05.html&quot;&gt;[5]：对拦截机制的灵活定制&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Nov 2018 23:21:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>这里所谓的与第三方AOP框架的整合不是说改变Dora.Interception现有的编程，而是恰好相反，即在不改变现有编程模式下采用第三方AOP框架或者自行实现的拦截机制。虽然我们默认提供基于IL E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/artech/p/dora-interception-05.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 2.1 : 十四.静态文件与访问授权、防盗链 - FlyLolo</title>
<link>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_14.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_14.html</guid>
<description>&lt;p&gt;我的网站的图片不想被公开浏览、下载、盗链怎么办？本文主要通过解读一下ASP.NET Core对于静态文件的处理方式的相关源码，来看一下为什么是wwwroot文件夹，如何修改或新增一个静态文件夹，为什么新增的文件夹名字不会被当做controller处理？访问授权怎么做？&lt;/p&gt;

&lt;p&gt;所谓静态文件，直观的说就是wwwroot目录下的一些直接提供给访问者的文件，例如css，图片、js文件等。 当然这个wwwroot目录是默认目录，&lt;/p&gt;
&lt;p&gt;这个是在Main-&amp;gt;CreateDefaultBuilder的时候做了默认设置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingEnvironmentExtensions
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Initialize(&lt;span&gt;this&lt;/span&gt; IHostingEnvironment hostingEnvironment, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; contentRootPath, WebHostOptions options)
        {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; webRoot =&lt;span&gt; options.WebRoot;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (webRoot == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Default to /wwwroot if it exists.&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; wwwroot = Path.Combine(hostingEnvironment.ContentRootPath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wwwroot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Directory.Exists(wwwroot))
                {
                    hostingEnvironment.WebRootPath &lt;/span&gt;=&lt;span&gt; wwwroot;
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                hostingEnvironment.WebRootPath &lt;/span&gt;=&lt;span&gt; Path.Combine(hostingEnvironment.ContentRootPath, webRoot);
            }
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略部分代码&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;前文关于中间件部分说过，在Startup文件中，有一个 &lt;span class=&quot;cnblogs_code&quot;&gt;app.UseStaticFiles()&lt;/span&gt; 方法的调用，这里是将静态文件的处理中间件作为了“处理管道”的一部分，&lt;/p&gt;
&lt;p&gt;并且这个中间件是写在 &lt;span class=&quot;cnblogs_code&quot;&gt;app.UseMvc&lt;/span&gt; 之前， 所以当一个请求进来之后， 会先判断是否为静态文件的请求，如果是，则在此做了请求处理，这时候请求会发生短路，不会进入后面的mvc中间件处理步骤。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseExceptionHandler(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            app.UseStaticFiles();

            app.UseCookiePolicy();
            app.UseAuthentication();
            app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                routes.MapRoute(
                    name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;除了这个默认的wwwroot目录，需要新增一个目录来作为静态文件的目录，可以Startup文件的 &lt;span class=&quot;cnblogs_code&quot;&gt;app.UseStaticFiles()&lt;/span&gt; 下面继续use，例如下面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            app.UseFileServer(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileServerOptions
            {
                FileProvider &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PhysicalFileProvider(
        Path.Combine(Directory.GetCurrentDirectory(), &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NewFilesPath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)),
                RequestPath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/NewFiles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;含义就是指定应用程序目录中的一个名为“&lt;span data-mce-=&quot;&quot;&gt;NewFilesPath&lt;/span&gt;”的文件夹，将它也设置问静态文件目录， 而这个目录的访问路径为&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;span data-mce-=&quot;&quot;&gt;/NewFiles&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;例如文件夹&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;span data-mce-=&quot;&quot;&gt;NewFilesPath&lt;span data-mce-=&quot;&quot;&gt;&quot;下面有一个test.jpg, 那么我们可以通过这样的地址来访问它：http://localhost:64237/&lt;span data-mce-=&quot;&quot;&gt;NewFiles/test.jpg。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;静态文件的处理中间件为StaticFileMiddleware，主要的处理方法 &lt;span class=&quot;cnblogs_code&quot;&gt;Invoke&lt;/span&gt; 代码如下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(HttpContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fileContext = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StaticFileContext(context, _options, _matchUrl, _logger, _fileProvider, _contentTypeProvider);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;fileContext.ValidateMethod())
            {
                _logger.LogRequestMethodNotSupported(context.Request.Method);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;fileContext.ValidatePath())
            {
                _logger.LogPathMismatch(fileContext.SubPath);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;fileContext.LookupContentType())
            {
                _logger.LogFileTypeNotSupported(fileContext.SubPath);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;fileContext.LookupFileInfo())
            {
                _logger.LogFileNotFound(fileContext.SubPath);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If we get here, we can try to serve the file&lt;/span&gt;
&lt;span&gt;                fileContext.ComprehendRequestHeaders();
                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (fileContext.GetPreconditionState())
                {
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; StaticFileContext.PreconditionState.Unspecified:
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; StaticFileContext.PreconditionState.ShouldProcess:
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (fileContext.IsHeadMethod)
                        {
                            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; fileContext.SendStatusAsync(Constants.Status200Ok);
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                        {
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (fileContext.IsRangeRequest)
                            {
                                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; fileContext.SendRangeAsync();
                                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; fileContext.SendAsync();
                            _logger.LogFileServed(fileContext.SubPath, fileContext.PhysicalPath);
                            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException)
                        {
                            context.Response.Clear();
                        }
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; StaticFileContext.PreconditionState.NotModified:
                        _logger.LogPathNotModified(fileContext.SubPath);
                        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; fileContext.SendStatusAsync(Constants.Status304NotModified);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; StaticFileContext.PreconditionState.PreconditionFailed:
                        _logger.LogPreconditionFailed(fileContext.SubPath);
                        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; fileContext.SendStatusAsync(Constants.Status412PreconditionFailed);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; exception = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException(fileContext.GetPreconditionState().ToString());
                        Debug.Fail(exception.ToString());
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; exception;
                }
            }
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(context);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;当HttpContext进入此中间件后会尝试封装成StaticFileContext， 然后对其逐步判断，例如请求的URL是否与设置的静态目录一致， 判断文件是否存在，判断文件类型等，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;span data-mce-=&quot;&quot;&gt;若符合要求 ，会进一步判断文件是否有修改等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;默认情况下，静态文件是不需要授权，可以公开访问的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;因为即使采用了授权， &lt;span class=&quot;cnblogs_code&quot;&gt;app.UseAuthentication();&lt;/span&gt; 一般也是写在 &lt;span class=&quot;cnblogs_code&quot;&gt;app.UseStaticFiles()&lt;/span&gt; 后面的，那么如果我们想对其进行授权管理，首先想到可以改写 &lt;span class=&quot;cnblogs_code&quot;&gt;StaticFileMiddleware&lt;/span&gt; 这个中间件，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;在其中添加一些自定义的判断条件，但貌似不够友好。而且这里只能做一些大类的判断，比如请求的IP地址是否在允许范围内这样的还行，如果要根据登录用户的权限来判断（比如用户只能看到自己上传的图片）就不行了，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;因为权限的判断写在这个中间件之后。所以可以通过Filter的方式来处理，首先可以在应用目录中新建一个&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;span data-mce-=&quot;&quot;&gt;images&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;文件夹， 而这时就不要把它设置为静态文件目录了，这样这个&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;span data-mce-=&quot;&quot;&gt;images&lt;span data-mce-=&quot;&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;目录的文件默认情况下是不允许访问的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;然后通过Controller返回文件的方式来处理请求，如下代码所示&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [AuthorizeFilter]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileController : Controller
    {
        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FileResult Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file = Path.Combine(Directory.GetCurrentDirectory(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;images&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, name);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; PhysicalFile(file, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/octet-stream&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在AuthorizeFilter中进行相关判断，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthorizeFilter: ActionFilterAttribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuting(ActionExecutingContext context)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(context);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString().ToLower().Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; isAllow = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在此进行一系列访问权限验证，如果失败，返回一个默认图片，例如logo或不允许访问的提示图片&lt;/span&gt;

                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isAllow)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file = Path.Combine(Directory.GetCurrentDirectory(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;images&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    context.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; PhysicalFileResult(file, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/octet-stream&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 26 Nov 2018 22:48:00 +0000</pubDate>
<dc:creator>FlyLolo</dc:creator>
<og:description>我的网站的图片不想被公开浏览、下载、盗链怎么办？本文主要通过解读一下ASP.NET Core对于静态文件的处理方式的相关源码，来看一下为什么是wwwroot文件夹，如何修改或新增一个静态文件夹，为什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FlyLolo/p/ASPNETCore2_14.html</dc:identifier>
</item>
<item>
<title>Random Projection在k-means的应用 - Byron_Wu</title>
<link>http://www.cnblogs.com/bjwu/p/10024094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bjwu/p/10024094.html</guid>
<description>&lt;h2 id=&quot;随机投影-random-projection&quot;&gt;1. 随机投影 （Random Projection）&lt;/h2&gt;
&lt;p&gt;首先，这是一种降维方法。之前已经介绍过相对普遍的PCA的降维方法，这里介绍另一种降维方法Random Project。相比于PCA，他的好处可以这样说：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Random Projection与PCA不一样，其操作简单，只要构建一个投影矩阵即可，而PCA降维还要做SVD，计算开销比较大&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;brief-introduction&quot;&gt;1.1 Brief Introduction&lt;/h3&gt;
&lt;p&gt;随机投影的理论依据是&lt;a href=&quot;https://en.wikipedia.org/wiki/Johnson%E2%80%93Lindenstrauss_lemma&quot;&gt;J-L Lemma&lt;/a&gt;，公式的核心思想总结一句话就是：&lt;strong&gt;在高维欧氏空间里的点集映射到低维空间里相对距离得到某误差范围内的保持&lt;/strong&gt;。至于为什么要保持，主要是很多机器学习算法都是在以利用点与点之间的距离信息展开计算分析的(如k-means)。&lt;/p&gt;
&lt;h3 id=&quot;johnsonlindenstrauss-lemma&quot;&gt;1.2 Johnson–Lindenstrauss lemma&lt;/h3&gt;
&lt;p&gt;其实并不想这么数学，但是这么重要的定理不说不行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1389398/201811/1389398-20181127011726556-252574461.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定理表示：对于任意一个样本大小为&lt;strong&gt;m&lt;/strong&gt;的集合，如果我们通过随机投影将其维度降到一个合适的范围 &lt;span class=&quot;math inline&quot;&gt;\(n&amp;gt;8ln(m)/ \epsilon^2\)&lt;/span&gt; 内，那么我们将以较高的概率保证投影后的数据点之间的距离信息变化不大。这样我们在做K-mean之类的算法时，就可以先将高维度的数据利用随机投影进行降维处理，然后在执行算法。&lt;/p&gt;
&lt;p&gt;式中，&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;为投影到n维空间的正交投影。显然，这样的正交投影操作通常会减少样本点之间的平均距离。但是该定理Lemma可以看成这样操作：首先，你通过算法获得随机投影，这可能减少平均距离，然后您scale up距离，以便平均距离返回到其先前的值。 这个操作将不再是一个NP-hard问题，时间复杂度降为多项式复杂度。&lt;/p&gt;
&lt;h3 id=&quot;method&quot;&gt;1.3 Method&lt;/h3&gt;
&lt;p&gt;介绍完JL Lemma，接下来就很简单了。如果&lt;span class=&quot;math inline&quot;&gt;\(X_{d \times N}\)&lt;/span&gt; 是d维的原始样本矩阵，那么&lt;span class=&quot;math inline&quot;&gt;\(X^{RP}_{k \times N} = R_{k\times d}X_{d \times N}\)&lt;/span&gt;是降维后的k维样本矩阵。这个计算过程十分简单，生成随机矩阵&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;且将&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;映射从&lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt;为到&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;维空间中的时间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(nkd)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;高斯随机投影-gaussian-random-projection&quot;&gt;1.4 高斯随机投影 Gaussian random projection&lt;/h3&gt;
&lt;p&gt;可以使用高斯分布生成随机矩阵 &lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;。第一行是从&lt;span class=&quot;math inline&quot;&gt;\(S ^ {d-1}\)&lt;/span&gt;均匀选择的随机单位向量。 第二行是来自与第一行正交的空间的随机单位向量，第三行是来自与前两行正交的空间的随机单位矢量，依此类推。 在这种选择 &lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt; 的方式中，&lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt; 是正交矩阵（其转置的倒数），并且满足以下属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;球对称(Spherical symmetry)：对于任何正交矩阵&lt;span class=&quot;math inline&quot;&gt;\(A \in O(d)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(RA\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt; 具有相同的分布。&lt;/li&gt;
&lt;li&gt;正交性：R的行彼此正交。&lt;/li&gt;
&lt;li&gt;R的行是单位长度向量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要讨论高斯随机投影为什么有效，我们需要先来讨论下一个核心问题，高斯投影是否可以从理论上保证投影降维前后，数据点的空间分布距离基本保持不变呢？这个问题其实可以等价于证明另一个问题，即高斯投影能否做到将高维空间的点均匀的投影到低维空间中，如果能做到这一点，那么我们也可以证明其具备“投影降维前后，数据点的空间分布距离基本保持不变”的能力。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;我们来考虑一个采样问题，就是怎样在高维单位球体的表面上均匀的采样。首先，考虑二维的情况，就是在球形的周长上采样。我们考虑如下方法：第一，先在一个包含该圆形的外接正方形内均匀的采样；第二，将采样到的点投影到圆形上。具体地说就是，第一，先独立均匀的从区间[−1,1]（我们假设圆形跟正方形的中心点都在原点）内产生两个值组成一个二维的点(x1,x2)；第二，将该二维点投影到圆形上。例如，如下图所示，如果我们产生点是图中的A,B两点，那么投影到圆形上就是C点，如果产生的是点D，那么投影到圆形上就是E点。但是，用这样的方法得到点在圆形上并不是均匀分布的，比如产生C点的概率将大于产生E点概率，因为可以投影到C点对应的那条直线比E点对应的那条直线要长。解决的办法是去掉圆形外面的点，也就是如果我们首先产生的点在圆形外的话（比如点B），那么我们就丢弃该点，重新在产生，这样的话产生的点在圆形上是均匀分布的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1389398/201811/1389398-20181127011745217-1311594816.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;那么，我们能否将此方法扩展到高维的情况下呢？答案是不行的。因为在高维的情况下球与正方体的体积比将非常非常小，几乎接近于零。也就是我们在正方体内产生的点几乎不可能落到球体内部，那么也就无法产生有效的点。那么，在高维的球体上，我们应该怎样才能产生一个均匀分布与球体表面的点呢？答案是利用高斯分布。即将上述第一步改成：以均值为零方差为1的高斯分布独立地产生d个值，形成一个d维的点x=(x1,x2,⋯,xd)；然后第二步：将点x归一化x̃ =x/‖x‖。用这种方法产生点必定均匀分布在高维球体表面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;random-projection在k-means中的应用&quot;&gt;2. Random Projection在k-means中的应用&lt;/h2&gt;
&lt;p&gt;对于k-means来说，将样本划分为距离最近的一个聚簇，这个过程可以使用下面的式子来表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.zhihu.com/equation?tex=%5CVert+x_i+-+%5Cmu_j+%5CVert_2%5E2+%3D+%5CVert+x_i+%5CVert_2%5E2+%2B+%5CVert+%5Cmu_j+%5CVert_2%5E2+-+2x_i%5ET%5Cmu_j&quot; alt=&quot;\Vert x_i - \mu_j \Vert_2^2 = \Vert x_i \Vert_2^2 + \Vert \mu_j \Vert_2^2 - 2x_i^T\mu_j&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个数据点样本都要和聚簇中心做一次上述操作，所以一次迭代过程中计算复杂度为 &lt;img src=&quot;http://www.zhihu.com/equation?tex=O%28nkd%29&quot; alt=&quot;O(nkd)&quot;/&gt; ， &lt;img src=&quot;http://www.zhihu.com/equation?tex=d&quot; alt=&quot;d&quot;/&gt; 是 指 样本 维度。观察上面的式子， &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5CVert+x_i+%5CVert_2%5E2&quot; alt=&quot;\Vert x_i \Vert_2^2&quot;/&gt; 的计算是可以预先完成的， &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5CVert+%5Cmu_j+%5CVert_2%5E2&quot; alt=&quot;\Vert \mu_j \Vert_2^2&quot;/&gt; 可以在每次迭代时预先计算好，而不必对每个样本都计算一次。所以更新的关键操作就是 &lt;img src=&quot;http://www.zhihu.com/equation?tex=x_i%5ET%5Cmu_j&quot; alt=&quot;x_i^T\mu_j&quot;/&gt; 的计算，即计算数据样本矩阵 &lt;img src=&quot;http://www.zhihu.com/equation?tex=A&quot; alt=&quot;A&quot;/&gt; 和 聚簇 中心 &lt;img src=&quot;http://www.zhihu.com/equation?tex=%5Cmu_j&quot; alt=&quot;\mu_j&quot;/&gt; 的内积 &lt;img src=&quot;http://www.zhihu.com/equation?tex=A%5ET%5Cmu_j&quot; alt=&quot;A^T\mu_j&quot;/&gt; 。所以我们可以想办法在样本矩阵上做操作来减小计算的复杂度。&lt;/p&gt;
&lt;p&gt;这时候，随机投影的降维操作就派上了用场，下图是随机投影在随机投影在k-means上操作的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1389398/201811/1389398-20181127011737161-1627574619.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reference:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/LittleHann/p/6558575.html#undefined&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/LittleHann/p/6558575.html#undefined&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/ljj583905183/article/details/47980169&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/ljj583905183/article/details/47980169&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Random_projection&quot; class=&quot;uri&quot;&gt;https://en.wikipedia.org/wiki/Random_projection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45408671&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/45408671&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 26 Nov 2018 17:20:00 +0000</pubDate>
<dc:creator>Byron_Wu</dc:creator>
<og:description>1. 随机投影 （Random Projection） 首先，这是一种降维方法。之前已经介绍过相对普遍的PCA的降维方法，这里介绍另一种降维方法Random Project。相比于PCA，他的好处可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bjwu/p/10024094.html</dc:identifier>
</item>
<item>
<title>.NET Core实战项目之CMS 第五章 入门篇-Dapper的快速入门看这篇就够了 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10024091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10024091.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;上篇文章我们讲了如在在实际项目开发中使用Git来进行代码的版本控制，当然介绍的都是比较常用的功能。今天我再带着大家一起熟悉下一个ORM框架Dapper，实例代码的演示编写完成后我会通过Git命令上传到GitHub上，正好大家可以再次熟悉下Git命令的使用，来巩固上篇文章的知识。本篇文章已经收入&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9977862.html&quot;&gt;.NET Core实战项目之CMS 第一章 入门篇-开篇及总体规划&lt;/a&gt; 有兴趣的朋友可以加入.NET Core项目实战交流群637326624 进行交流。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;/p&gt;
&lt;p&gt;原文地址：https://www.cnblogs.com/yilezhu/p/10024091.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;dapper是什么&quot;&gt;Dapper是什么&lt;/h2&gt;
&lt;p&gt;Dapper是.NET下一个轻量级的ORM框架，它和Entity Framework或Nhibnate不同，属于轻量级的，并且是半自动的。也就是说实体类都要自己写。它没有复杂的配置文件，一个单文件就可以了。Dapper通过扩展你的IDbConnection来进行工作的。如果你想了解更多内容的话请点击&lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;dapper快速入门&quot;&gt;Dapper快速入门&lt;/h2&gt;
&lt;p&gt;前面几篇文章我们进行介绍的时候都是手动在代码里面创建的模拟数据，这篇文章我们就结合Dapper来从数据库进行相关的操作。为了演示的方便，这里的实例代码我们就使用一个简单地asp.net core控制台程序来进行。&lt;/p&gt;
&lt;h3 id=&quot;开始前的准备&quot;&gt;开始前的准备&lt;/h3&gt;
&lt;ol readability=&quot;20.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在我们的项目文件夹，单击鼠标右键选择“在当前文件夹下面打开Git Bash”&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;然后输入&lt;code&gt;git checkout Master&lt;/code&gt; 切换回Mater分支，然后输入&lt;code&gt;git checkout -b Sample05&lt;/code&gt; 创建一个新的名为“Sample05”的分支，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127010719702-1700391606.png&quot; alt=&quot;1543242325029&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用vs2017创建一个新的项目，名称为“Sample05” 位置位于我们当前的目录，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127010719242-1764739203.png&quot; alt=&quot;1543242490572&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;接下来打开数据库，新建一个Content内容表，表结构还沿用之前教程中的实体，这里只给出MSSql的脚本：至于MySql的你自己建了，如果你实在不会的话可以到群里问其他小伙伴要吧&lt;/p&gt;
&lt;pre class=&quot;mssql&quot;&gt;
&lt;code&gt;CREATE TABLE [dbo].[content](
 [id] [int] IDENTITY(1,1) NOT NULL,
 [title] [nvarchar](50) NOT NULL,
 [content] [nvarchar](max) NOT NULL,
 [status] [int] NOT NULL,
 [add_time] [datetime] NOT NULL,
 [modify_time] [datetime] NULL,
 CONSTRAINT [PK_Content] PRIMARY KEY CLUSTERED 
(
 [id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY] TEXTIMAGE_ON [PRIMARY]

GO

ALTER TABLE [dbo].[content] ADD  CONSTRAINT [DF_Content_status]  DEFAULT ((1)) FOR [status]
GO

ALTER TABLE [dbo].[content] ADD  CONSTRAINT [DF_content_add_time]  DEFAULT (getdate()) FOR [add_time]
GO

CREATE TABLE [dbo].[comment](
 [id] [int] IDENTITY(1,1) NOT NULL,
 [content_id] [int] NOT NULL,
 [content] [nvarchar](512) NOT NULL,
 [add_time] [datetime] NOT NULL,
 CONSTRAINT [PK_comment] PRIMARY KEY CLUSTERED 
(
 [id] ASC
)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, IGNORE_DUP_KEY = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = ON) ON [PRIMARY]
) ON [PRIMARY]

GO

ALTER TABLE [dbo].[comment] ADD  CONSTRAINT [DF_comment_add_time]  DEFAULT (getdate()) FOR [add_time]
GO
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;项目中新增数据库表对应的实体对象，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class Content
    {
        /// &amp;lt;summary&amp;gt;
        /// 主键
        /// &amp;lt;/summary&amp;gt;
        public int id { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 标题
        /// &amp;lt;/summary&amp;gt;
        public string title { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 内容
        /// &amp;lt;/summary&amp;gt;
        public string content { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 状态 1正常 0删除
        /// &amp;lt;/summary&amp;gt;
        public int status { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 创建时间
        /// &amp;lt;/summary&amp;gt;
        public DateTime add_time { get; set; } = DateTime.Now;
        /// &amp;lt;summary&amp;gt;
        /// 修改时间
        /// &amp;lt;/summary&amp;gt;
        public DateTime? modify_time { get; set; }
    }
public class Comment
    {
        /// &amp;lt;summary&amp;gt;
        /// 主键
        /// &amp;lt;/summary&amp;gt;
        public int id { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 文章id
        /// &amp;lt;/summary&amp;gt;
        public int content_id { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 评论内容
        /// &amp;lt;/summary&amp;gt;
        public string content { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 添加时间
        /// &amp;lt;/summary&amp;gt;
        public DateTime add_time { get; set; } = DateTime.Now;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;项目中添加Dapper的Nugets包，相信一路看教程过来的你一定知道怎么新增Nuget包吧，这里就不过多介绍了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127010718696-2076532440.png&quot; alt=&quot;1543243792492&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实战演示&quot;&gt;实战演示&lt;/h3&gt;
&lt;ol readability=&quot;63.5&quot;&gt;&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;插入操作：将一个对象插入到数据库中，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
        /// 测试插入单条数据
        /// &amp;lt;/summary&amp;gt;
       static void test_insert()
        {
            var content = new Content
            {
                title = &quot;标题1&quot;,
                content = &quot;内容1&quot;,

            };
            using (var conn = new SqlConnection(&quot;Data Source=127.0.0.1;User ID=sa;Password=1;Initial Catalog=Czar.Cms;Pooling=true;Max Pool Size=100;&quot;))
            {
                string sql_insert = @&quot;INSERT INTO [Content]
                (title, [content], status, add_time, modify_time)
VALUES   (@title,@content,@status,@add_time,@modify_time)&quot;;
                var result = conn.Execute(sql_insert, content);
                Console.WriteLine($&quot;test_insert：插入了{result}条数据！&quot;);
            }
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;一次批量插入多条数据，测试代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
        /// 测试一次批量插入两条数据
        /// &amp;lt;/summary&amp;gt;
       static void test_mult_insert()
        {
            List&amp;lt;Content&amp;gt; contents = new List&amp;lt;Content&amp;gt;() {
               new Content
            {
                title = &quot;批量插入标题1&quot;,
                content = &quot;批量插入内容1&quot;,

            },
               new Content
            {
                title = &quot;批量插入标题2&quot;,
                content = &quot;批量插入内容2&quot;,

            },
        };

            using (var conn = new SqlConnection(&quot;Data Source=127.0.0.1;User ID=sa;Password=1;Initial Catalog=Czar.Cms;Pooling=true;Max Pool Size=100;&quot;))
            {
                string sql_insert = @&quot;INSERT INTO [Content]
                (title, [content], status, add_time, modify_time)
VALUES   (@title,@content,@status,@add_time,@modify_time)&quot;;
                var result = conn.Execute(sql_insert, contents);
                Console.WriteLine($&quot;test_mult_insert：插入了{result}条数据！&quot;);
            }
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;执行下代码查看到控制台输出如下的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127010718350-1551698885.png&quot; alt=&quot;1543246862147&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后到数据库查看下表中的数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127010717944-1215361902.png&quot; alt=&quot;1543246898729&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;下面我们再分别测试下删除一条数据，与一次删除多条数据吧，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
        /// 测试删除单条数据
        /// &amp;lt;/summary&amp;gt;
        static void test_del()
        {
            var content = new Content
            {
                id = 2,

            };
            using (var conn = new SqlConnection(&quot;Data Source=127.0.0.1;User ID=sa;Password=1;Initial Catalog=Czar.Cms;Pooling=true;Max Pool Size=100;&quot;))
            {
                string sql_insert = @&quot;DELETE FROM [Content]
WHERE   (id = @id)&quot;;
                var result = conn.Execute(sql_insert, content);
                Console.WriteLine($&quot;test_del：删除了{result}条数据！&quot;);
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 测试一次批量删除两条数据
        /// &amp;lt;/summary&amp;gt;
        static void test_mult_del()
        {
            List&amp;lt;Content&amp;gt; contents = new List&amp;lt;Content&amp;gt;() {
               new Content
            {
                id=3,

            },
               new Content
            {
                id=4,

            },
        };

            using (var conn = new SqlConnection(&quot;Data Source=127.0.0.1;User ID=sa;Password=1;Initial Catalog=Czar.Cms;Pooling=true;Max Pool Size=100;&quot;))
            {
                string sql_insert = @&quot;DELETE FROM [Content]
WHERE   (id = @id)&quot;;
                var result = conn.Execute(sql_insert, contents);
                Console.WriteLine($&quot;test_mult_del：删除了{result}条数据！&quot;);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127010717539-1101672916.png&quot; alt=&quot;1543247418059&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后去数据库里查看，发现主键为2，3，4的数据都已经被删除了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127010717130-2065855725.png&quot; alt=&quot;1543247491525&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;下面我们再测试下修改吧，也是分别测试一次只修改一条数据（主键为5），与一次批量修改多条数据（主键为6，7）&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
        /// 测试修改单条数据
        /// &amp;lt;/summary&amp;gt;
        static void test_update()
        {
            var content = new Content
            {
                id = 5,
                title = &quot;标题5&quot;,
                content = &quot;内容5&quot;,

            };
            using (var conn = new SqlConnection(&quot;Data Source=127.0.0.1;User ID=sa;Password=1;Initial Catalog=Czar.Cms;Pooling=true;Max Pool Size=100;&quot;))
            {
                string sql_insert = @&quot;UPDATE  [Content]
SET         title = @title, [content] = @content, modify_time = GETDATE()
WHERE   (id = @id)&quot;;
                var result = conn.Execute(sql_insert, content);
                Console.WriteLine($&quot;test_update：修改了{result}条数据！&quot;);
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 测试一次批量修改多条数据
        /// &amp;lt;/summary&amp;gt;
        static void test_mult_update()
        {
            List&amp;lt;Content&amp;gt; contents = new List&amp;lt;Content&amp;gt;() {
               new Content
            {
                id=6,
                title = &quot;批量修改标题6&quot;,
                content = &quot;批量修改内容6&quot;,

            },
               new Content
            {
                id =7,
                title = &quot;批量修改标题7&quot;,
                content = &quot;批量修改内容7&quot;,

            },
        };

            using (var conn = new SqlConnection(&quot;Data Source=127.0.0.1;User ID=sa;Password=1;Initial Catalog=Czar.Cms;Pooling=true;Max Pool Size=100;&quot;))
            {
                string sql_insert = @&quot;UPDATE  [Content]
SET         title = @title, [content] = @content, modify_time = GETDATE()
WHERE   (id = @id)&quot;;
                var result = conn.Execute(sql_insert, contents);
                Console.WriteLine($&quot;test_mult_update：修改了{result}条数据！&quot;);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们执行下测试代码看下结果吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127010716689-467431312.png&quot; alt=&quot;1543248037237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再到数据库中查看下数据，上步骤5中最后一张图相比较&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127010716286-1098726517.png&quot; alt=&quot;1543248094960&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;增删改都测试了，下面就开始测试查询吧，我们分别来测试下查询指定的数据以及一次查询多条数据来看下结果吧。还是先上代码，：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; /// &amp;lt;summary&amp;gt;
        /// 查询单条指定的数据
        /// &amp;lt;/summary&amp;gt;
        static void test_select_one()
        {
            using (var conn = new SqlConnection(&quot;Data Source=127.0.0.1;User ID=sa;Password=1;Initial Catalog=Czar.Cms;Pooling=true;Max Pool Size=100;&quot;))
            {
                string sql_insert = @&quot;select * from [dbo].[content] where id=@id&quot;;
                var result = conn.QueryFirstOrDefault&amp;lt;Content&amp;gt;(sql_insert, new { id=5});
                Console.WriteLine($&quot;test_select_one：查到的数据为：&quot;);
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 查询多条指定的数据
        /// &amp;lt;/summary&amp;gt;
        static void test_select_list()
        {
            using (var conn = new SqlConnection(&quot;Data Source=127.0.0.1;User ID=sa;Password=1;Initial Catalog=Czar.Cms;Pooling=true;Max Pool Size=100;&quot;))
            {
                string sql_insert = @&quot;select * from [dbo].[content] where id in @ids&quot;;
                var result = conn.Query&amp;lt;List&amp;lt;Content&amp;gt;&amp;gt;(sql_insert, new { ids=new int[] { 6,7} });
                Console.WriteLine($&quot;test_select_one：查到的数据为：&quot;);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们打上断点然后去看下结果吧！这里图片我没有截成功，所以就不贴了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;关联查询，Dapper的强大之处就在于其关联查询了！为了测试的方便，我们给主键为5的content添加两个comment中，这个插入的代码就不贴出来了，留给大家自行书写吧，如果不会的话可以加群问群里的其他小伙伴吧。这里需要新建一个类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ContentWithCommnet
    {
        /// &amp;lt;summary&amp;gt;
        /// 主键
        /// &amp;lt;/summary&amp;gt;
        public int id { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 标题
        /// &amp;lt;/summary&amp;gt;
        public string title { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 内容
        /// &amp;lt;/summary&amp;gt;
        public string content { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 状态 1正常 0删除
        /// &amp;lt;/summary&amp;gt;
        public int status { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 创建时间
        /// &amp;lt;/summary&amp;gt;
        public DateTime add_time { get; set; } = DateTime.Now;
        /// &amp;lt;summary&amp;gt;
        /// 修改时间
        /// &amp;lt;/summary&amp;gt;
        public DateTime? modify_time { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 文章评论
        /// &amp;lt;/summary&amp;gt;
        public IEnumerable&amp;lt;Comment&amp;gt; comments { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就是测试代码，运行的查询测试代码如下：查询id为5的文章，文章是包含评论列表的&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void test_select_content_with_comment()
        {
            using (var conn = new SqlConnection(&quot;Data Source=127.0.0.1;User ID=sa;Password=1;Initial Catalog=Czar.Cms;Pooling=true;Max Pool Size=100;&quot;))
            {
                string sql_insert = @&quot;select * from content where id=@id;
select * from comment where content_id=@id;&quot;;
                using (var result = conn.QueryMultiple(sql_insert, new { id = 5 }))
                {
                    var content = result.ReadFirstOrDefault&amp;lt;ContentWithComment&amp;gt;();
                    content.comments = result.Read&amp;lt;Comment&amp;gt;();
                    Console.WriteLine($&quot;test_select_content_with_comment:内容5的评论数量{content.comments.Count()}&quot;);
                }

            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下所示，调试的代码没法截图我也很无奈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127010715753-447029625.png&quot; alt=&quot;1543251360510&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;github源码&quot;&gt;GitHub源码&lt;/h2&gt;
&lt;p&gt;GitHub的测试源码已经上传，https://github.com/yilezhu/Czar.Cms/tree/Sample05 放在Czar.Cms的Sample05分支上面。大家可以参考下，觉得有用的话记得star哦！&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文给大家演示了Dapper的常用方法，不过都是通过同步的方式进行操作的，如果你想使用异步的话可以自行进行测试。文中的大部分内容都有截图，个别调试无法截图的大伙可以自行调试查看！相信通过本文的实例讲解，大伙应该能够使用dapper进行相应的开发！下一篇文章我们将进行vue的讲解！当然也只是进行很浅层次的讲解。因为我是一个后端，也是抱着学习的态度来进行vue的记录的！主要是以快速上为主。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 26 Nov 2018 17:11:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>﻿ 写在前面 上篇文章我们讲了如在在实际项目开发中使用Git来进行代码的版本控制，当然介绍的都是比较常用的功能。今天我再带着大家一起熟悉下一个ORM框架Dapper，实例代码的演示编写完成后我会通过G</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10024091.html</dc:identifier>
</item>
<item>
<title>Vim+Taglist+AutoComplPop之代码目录分栏信息和自动补全提示（Ubuntu环境） - 蜡笔小新之乐斗小菜</title>
<link>http://www.cnblogs.com/django816/p/10024001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/django816/p/10024001.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一步：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt;首先在Ubuntu环境中安装ctags:  sudo apt-get install ctags&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二部：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &lt;span&gt;安装Taglist-------------Taglist是vim的一个插件，提供源代码符号的结构化视图。从&lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=273&quot; target=&quot;_blank&quot;&gt;http://www.vim.org/scripts/script.php?script_id=273&lt;/a&gt;下载安装包，也可以从&lt;a href=&quot;http://vim-taglist.sourceforge.net/index.html&quot; target=&quot;_blank&quot;&gt;http://vim-taglist.sourceforge.net/index.html&lt;/a&gt;下载。&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;span&gt; 解压：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;span&gt;&lt;strong&gt;&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;      1.$unzip &lt;span class=&quot;hljs-operator&quot;&gt;-d taglist taglist_xx.zip
&lt;span class=&quot;hljs-variable&quot;&gt;      2.$cd taglist
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;code class=&quot;hljs bash has-numbering&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;&lt;span class=&quot;hljs-variable&quot;&gt;&lt;span&gt;复制到指定路径下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      1.$&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span&gt;cp doc/taglist&lt;/span&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&lt;span&gt;.txt /usr/share/vim/vim73/doc/ &lt;/span&gt;&lt;br/&gt;&lt;span&gt;      2.$&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span&gt;cp plugin/taglist&lt;/span&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;&lt;span&gt;.vim /usr/share/vim/vim73/plugin/&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;第三部：&lt;span&gt;输入指令 $sudo nano /etc/vim/vimrc  打开文件后添加如下代码：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;imap () ()&amp;lt;Left&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;imap [] []&amp;lt;Left&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;imap {} {}&amp;lt;Left&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;imap &quot;&quot; &quot;&quot;&amp;lt;Left&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;imap '' ''&amp;lt;Left&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;imap &amp;lt;&amp;gt; &amp;lt;&amp;gt;&amp;lt;Left&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;inoremap &amp;lt;c-z&amp;gt; &amp;lt;left&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;inoremap &amp;lt;c-j&amp;gt; &amp;lt;down&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;inoremap &amp;lt;c-k&amp;gt; &amp;lt;up&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;inoremap &amp;lt;c-l&amp;gt; &amp;lt;right&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;:set tabstop=4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;:set softtabstop=4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;:set expandtab&lt;/span&gt;&lt;br/&gt;&lt;span&gt;:set nu&lt;/span&gt;&lt;br/&gt;&lt;span&gt;:set ruler &quot; show the cursor position all the time&lt;/span&gt;&lt;br/&gt;&lt;span&gt;:set cino=g0,:0 &quot;switch case对齐风格&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;syntax on&lt;/span&gt;&lt;br/&gt;&lt;span&gt;:set completeopt=preview,menu&lt;/span&gt;&lt;br/&gt;&lt;span&gt;:set completeopt=longest,menu&lt;/span&gt;&lt;br/&gt;&lt;span&gt;:set wildmenu&lt;/span&gt;&lt;br/&gt;&lt;span&gt;:set backspace=2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;:set nobackup&lt;/span&gt;&lt;br/&gt;&lt;span&gt;autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete&lt;/span&gt;&lt;br/&gt;&lt;span&gt;autocmd FileType python set omnifunc=pythoncomplete#Complete&lt;/span&gt;&lt;br/&gt;&lt;span&gt;autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;autocmd FileType html set omnifunc=htmlcomplete#CompleteTags&lt;/span&gt;&lt;br/&gt;&lt;span&gt;autocmd FileType css set omnifunc=csscomplete#CompleteCSS&lt;/span&gt;&lt;br/&gt;&lt;span&gt;autocmd FileType xml set omnifunc=xmlcomplete#CompleteTags&lt;/span&gt;&lt;br/&gt;&lt;span&gt;autocmd FileType java set omnifunc=javacomplete#Complet&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;taglist 设置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let Tlist_Auto_Open=1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;:set tags=tags&lt;/span&gt;&lt;br/&gt;&lt;span&gt;:set autochdir&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;只显示当前文件的tags&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let Tlist_Enable_Fold_Column = 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let Tlist_Show_One_File = 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;设置taglist宽度&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let Tlist_WinWidth=30&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;taglist 窗口是最后一个窗口，则退出VIM&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let Tlist_Exit_OnlyWindow=1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;在VIM窗口右侧显示taglist窗口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let Tlist_Use_Right_Window=1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第四部：&lt;/span&gt;&lt;/strong&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;&lt;span&gt;安装AutoComplPop&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;  下载：&lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=1879&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://www.vim.org/scripts/script.php?script_id=1879&lt;/a&gt;   同其他脚本插件的安装方法一致，将解压后的文件拷贝到~/.vim/ 下的相应目录里：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;   a)先创建三个文件夹autoload、doc、plugin：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490717/201811/1490717-20181127000142828-777667439.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;    &lt;span&gt;b)然后进入到解压后的AutoComplPop目录里,进行如下操作：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490717/201811/1490717-20181127000501694-2099526936.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;&lt;span&gt; c)最后重新打开vim,命令行输入：vim 在打开的界面底部输入：helptags ~/.vim/doc/按下Enter键执行即可。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;至此，安装配置结束，随意打开一个.h头文件，效果如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1490717/201811/1490717-20181126233215649-1914028280.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;

&lt;pre name=&quot;code&quot; class=&quot;prettyprint&quot;&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Mon, 26 Nov 2018 16:12:00 +0000</pubDate>
<dc:creator>蜡笔小新之乐斗小菜</dc:creator>
<og:description>第一步： 首先在Ubuntu环境中安装ctags: sudo apt-get install ctags 第二部： 安装Taglist Taglist是vim的一个插件，提供源代码符号的结构化视图。从</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/django816/p/10024001.html</dc:identifier>
</item>
<item>
<title>ThreadPoolExecutor代码解析 - 自带buff</title>
<link>http://www.cnblogs.com/brandonli/p/10023970.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brandonli/p/10023970.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;派生体系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;java.util.concurrent&lt;/p&gt;
&lt;p&gt;　　ThreadPoolExecutor&lt;/p&gt;
&lt;p&gt;　　　　AbstractExecutorService&lt;/p&gt;
&lt;p&gt;　　　　　　ExecutorService&lt;/p&gt;
&lt;p&gt;　　　　　　　　Executor&lt;/p&gt;

&lt;p&gt;这个类是Executor框的核心实现，它的名字向我们表明，它是使用thread pool实现的。这个thread pool主要解决了两个问题:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;执行大量的单个异步任务，一般情况下，它能提升整体的性能。&lt;/li&gt;
&lt;li&gt;执行由多个任务组成的任务集合，通过Future列表返回每个任务的执行结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;设计原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/895062/201811/895062-20181126232812913-694665583.png&quot; alt=&quot;&quot; width=&quot;799&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;重要概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为了能够在更多上下文环境中使用，ThreadPool定义了一些概念，这些概念都直接或间接对应着可调节参数，如果不了解这些概念含义，很难正确地使用这些参数。下面来看一下这些概念及其含义:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;当前，核心，最小，最大线程数(poolSize, corePoolSize, minimumPoolSize, maximumPoolSize)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;poolSize: 当前处于运行和空闲状态的总线程数。&lt;/p&gt;
&lt;p&gt;corePoolSize: 核心线程数, 当poolSize&amp;lt;=corePoolSize时，存在的线程称为coreThread。&lt;/p&gt;
&lt;p&gt;minimumPoolSize: 最小线程数，当minimumPoolsize = allowCoreThreadTimeOut ? 0 : corePoolSize ,&lt;/p&gt;
&lt;p&gt;maximunPoolSize: 最大线程数。&lt;/p&gt;
&lt;p&gt;ThreadPool在运行过程中会自动的调节线程数量(poolSize), 一般来说，poolSize处于[corePoolSize maximumPoolSize]区间之内。&lt;/p&gt;
&lt;p&gt;当用户调用execute提交一个任务时，如果poolSize&amp;lt;corePoolSize, 会创建一个新线程处理这个任务。如果如果poolSize处于[corePoolSize maximumPoolSize]区间内，只有队列满是才会创建新线程。无论如何，poolSize不会大于maximumPoolSize。&lt;/p&gt;
&lt;p&gt;默认情况下，ThreadPool没有收到任何任务时pooSize = 0, 只有当ThreadPool开始收到任务之后才会创建线程。但是可以通过覆盖prestartCoreThread或prestartAllCoreThreads方法改变这种行为，提前创建线程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线程工厂--ThreadFactory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ThreadPool使用实现了ThreadFactory接口的实现创建新线程。Executors工厂类提供了defaultThreadFactory方法，该方法返回一个默认的ThreadFactory实例。使用这个实例创建的线程具有相同的优先级，是非后台线程，命名上使用相同的前缀。如果不满意这这些行为，可以自己实现一个ThreadFactory交给ThreadPool使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;保持存活时间(keepAliveTime)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果poolSize &amp;gt; corePoolSize, 当一个线程的空闲时间大于keepAliveTime, 它会被终止掉。默认情况下当poolSize &amp;lt;= corePoolSize时，keepAliveTime不会有影响，如果调用 allowCoreThreadTimeOut(true), 可以让keepAliveTime在这个时间也起作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;任务排队(queuing)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何BlockingQueue的实例都可以用于保存排队的任务。不同的BlockingQueue实现决定了不同的排队策略:&lt;/p&gt;
&lt;p&gt;SynchronousQueue: 同步队列，当提交一个任务时，要求ThreadPool中当前有至少一个空闲线程，或者可以创建新的线程(poolSize &amp;lt; maximumPoolSize)立即执行这个任务，否则ThreadPool会拒绝这个任务。&lt;/p&gt;
&lt;p&gt;LinkedBlockingQueue: 无限制的队列(只受限于能够使用的内存), 不会处于full状态, offer方法不会返回false，这意味这ThreadPool的pooSize&amp;lt;=corePoolSize, 不会创建大于corePoolSize的线程数。&lt;/p&gt;
&lt;p&gt;ArrayBlockingQueue: 有限制的队列, 受限于它的capacity。当poolSize == corePoolSize且队列没满时, 新提交的任务会追加到队列中排队执行。 当poolSize在[corePoolSize maximumPooSize)区间同时队被填列满时，将会创建新的线程。直到poolSize == maximumPoolSize位置。 如果队列被填满同时pooSize == maximumPoolSize，新的任务会被拒绝。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;拒绝任务(rejected tasks)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当ThreadPool遇到以下两种情况时会触发拒绝任务策略:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;正常情况下BlockingQueue被填满，同时poolSize == maximumPoolSize。&lt;/li&gt;
&lt;li&gt;被关闭&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ThreadPool使用RejectedExecutionHandler处理丢弃动作，默认定义了4中丢弃策略:&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor.AbortPolicy: 抛出RejectedExecutionException异常。&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor.CallerRunsPolicy: 自己执行这个被抛弃的任务。&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor.DiscardPolicy: 悄无声息的丢弃掉这人任务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ThreadPool定义了5状态&lt;/p&gt;
&lt;p&gt;RUNNING: 接受新提交的任务，执行队列中发任务。&lt;/p&gt;
&lt;p&gt;SHUTDOWN: 不接受新提交的任务，但仍然会执行队列中的人。&lt;/p&gt;
&lt;p&gt;STOP: 不接受新提交的任务，不执行队列中的任务，而且会打断正在执行中的任务。&lt;/p&gt;
&lt;p&gt;TIDYING: 所有的任务都终止了，并且线程数为0，当所有的线程都过渡到TIDYING状态后会调用treminated方法。&lt;/p&gt;
&lt;p&gt;TERMINATED: treminated方法调用已经完成。&lt;/p&gt;

&lt;p&gt;状态之间的转换关系&lt;/p&gt;
&lt;p&gt;RUNNING --&amp;gt; SHUTDOWN&lt;/p&gt;
&lt;p&gt;调用shutdown()&lt;/p&gt;
&lt;p&gt;(RUNNING或SHUTDOWN) -- &amp;gt; STOP&lt;/p&gt;
&lt;p&gt;调用shutdownNow()&lt;/p&gt;
&lt;p&gt;SHUTDOWN --&amp;gt; TIDYING&lt;/p&gt;
&lt;p&gt;队列为空，同时线程数为0&lt;/p&gt;
&lt;p&gt;TIDYING --&amp;gt; TREMINATED&lt;/p&gt;
&lt;p&gt;treminated()执行完成。&lt;/p&gt;

&lt;div readability=&quot;72&quot;&gt;
&lt;p&gt;&lt;span&gt;向ThreadPool提交任务: execute&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;ThreadPoolExecutor实例创建之后，在没有调用execute提交任务之前，ThreadPool中是没有线程的，线程的创建是依赖exeute来驱动的。可以说，exeute是ThreadPoolExecutor运行的触发器，所有我选择先从exeute方法开始分析代码。&lt;/p&gt;
&lt;p&gt;public void execute(Runnable command) {&lt;/p&gt;
&lt;p&gt;　　if (command == null)&lt;/p&gt;
&lt;p&gt;　　　　throw new NullPointerException();&lt;/p&gt;
&lt;p&gt;　　int c = ctl.get();&lt;/p&gt;
&lt;p&gt;　　if (workerCountOf(c) &amp;lt; corePoolSize) { //&lt;strong&gt;如果线程数小于 corePoolSize, 创建一个新线程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　if (addWorker(command, true))&lt;/p&gt;
&lt;p&gt;　　　　　return;&lt;/p&gt;
&lt;p&gt;　　　　c = ctl.get();&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;　　if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) { //&lt;strong&gt;如果处于RUNNGIN状态把任务放到队列中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　int recheck = ctl.get();&lt;/p&gt;
&lt;p&gt;　　　　if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command)) /&lt;strong&gt;/再次检查线程状态，如果不是RUNNING状态，把任务从队列删除，然后拒绝这个任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　reject(command);&lt;/p&gt;
&lt;p&gt;　　　　else if (workerCountOf(recheck) == 0) //&lt;strong&gt;如果线程数为0,创建一个新线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　addWorker(null, false);&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;　　/*&lt;strong&gt;如果运行到这里说明当前不是出于RUNNING状态，或处于RUNNING状态但队列已经被填满&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　*尝试创建新的线程执行这个任务，如果失败，拒绝这任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　*/&lt;/p&gt;
&lt;p&gt;　　else if (!addWorker(command, false))&lt;/p&gt;
&lt;p&gt;　　　　reject(command);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;以上就是exeute代码，它很简单，但其中ctl成员变量比较费解。ctl是AtomicInteger类型，它被用来打包保存ThreadPoolExecutor的状态和线程数。&lt;/p&gt;
&lt;p&gt;AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));&lt;/p&gt;
&lt;p&gt;它初始化时，把状态设置成RUNNING，下面来看看它的结构&lt;/p&gt;

&lt;p&gt;高位 ---- &amp;gt; 低位&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;0064-1542278739179-cell-0-0&quot;&gt;
&lt;p&gt;运算状态(run state)&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;0064-1542278739179-cell-0-1&quot;&gt;
&lt;p&gt;线程数(workerCount)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;0064-1542278739179-cell-1-0&quot;&gt;
&lt;p&gt;31 -- 29&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;0064-1542278739179-cell-1-1&quot;&gt;
&lt;p&gt;28 -- 0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;状态位&lt;/p&gt;
&lt;p&gt;RUNNING&lt;/p&gt;


&lt;p&gt;SHUTDOWN&lt;/p&gt;



&lt;p&gt;STOP&lt;/p&gt;


&lt;p&gt;TIDYING&lt;/p&gt;


&lt;p&gt;TREMINATED&lt;/p&gt;


&lt;p&gt;知道了这些数据的保存方式，把他们取出来，只需要一些简单的位运算就可以了。&lt;/p&gt;
&lt;p&gt;状态的大小关系 RUNNING &amp;lt; SHUTDOWN &amp;lt; STOP &amp;lt; TIDYING &amp;lt; TREMINATED,&lt;/p&gt;
&lt;p&gt;runStateOf(clt.get()) &amp;lt; SHUTDOWN RUNNING状态&lt;/p&gt;
&lt;p&gt;runStateOf(clt.get()) &amp;gt;= SHUTDOWN 非RUNNING状态&lt;/p&gt;
&lt;p&gt;这个大小关系要记住，这样理解代码会更快。&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;创建新线程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ThreadPool把线程封装成Worker对对象，添加worker就是添加线程，addWorker方法做的事情就是添加线程。&lt;/p&gt;
&lt;p&gt;private boolean addWorker(Runnable firstTask, boolean core) {&lt;/p&gt;
&lt;p&gt;    /*&lt;strong&gt;这段代码的作用是确保满足一下条件的任意一个时才创建新线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   *1.  处于RUNNING 状态, 可以接受新任务，可以继续执行队列中的任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   *2. 处于SHUTDOWN状态,  队列不是空，且当前没有提交新任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   */&lt;/p&gt;
&lt;p&gt;    retry:&lt;/p&gt;
&lt;p&gt;    for (;;) {&lt;/p&gt;
&lt;p&gt;        int c = ctl.get();&lt;/p&gt;
&lt;p&gt;        int rs = runStateOf(c);&lt;/p&gt;

&lt;p&gt;        // Check if queue empty only if necessary.&lt;/p&gt;
&lt;p&gt;        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;   //&lt;strong&gt;非RUNNINGG状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;            ! (rs == SHUTDOWN &amp;amp;&amp;amp;  &lt;/p&gt;
&lt;p&gt;               firstTask == null &amp;amp;&amp;amp;  //&lt;strong&gt;当前提交的新任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;               ! workQueue.isEmpty())) // &lt;strong&gt;队列不是空&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;            return false;&lt;/p&gt;

&lt;p&gt;        for (;;) {&lt;/p&gt;
&lt;p&gt;            int wc = workerCountOf(c);&lt;/p&gt;
&lt;p&gt;            if (wc &amp;gt;= CAPACITY ||&lt;/p&gt;
&lt;p&gt;                wc &amp;gt;= (core ? corePoolSize : maximumPoolSize)) //&lt;strong&gt;如果当前调用创建的是core线程,  确保当前线程数 &amp;lt;corePoolSize, 否则确保当前线程数&amp;lt; maximumPoolSize&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                return false;&lt;/p&gt;
&lt;p&gt;            if (compareAndIncrementWorkerCount(c))  //&lt;strong&gt;原子操作，增加线程数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                break retry;&lt;/p&gt;
&lt;p&gt;            c = ctl.get();  // Re-read ctl&lt;/p&gt;
&lt;p&gt;            if (runStateOf(c) != rs)&lt;/p&gt;
&lt;p&gt;                continue retry;&lt;/p&gt;
&lt;p&gt;            // else CAS failed due to workerCount change; retry inner loop&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;    //&lt;strong&gt;执行到这里表示已经通过检查可以创建新线程，并且线程数已经加1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    boolean workerStarted = false;&lt;/p&gt;
&lt;p&gt;    boolean workerAdded = false;&lt;/p&gt;
&lt;p&gt;    Worker w = null;&lt;/p&gt;
&lt;p&gt;    try {&lt;/p&gt;
&lt;p&gt;        w = new Worker(firstTask);&lt;/p&gt;
&lt;p&gt;        final Thread t = w.thread;&lt;/p&gt;
&lt;p&gt;        if (t != null) {&lt;/p&gt;
&lt;p&gt;            final ReentrantLock mainLock = this.mainLock;&lt;/p&gt;
&lt;p&gt;            mainLock.lock();&lt;/p&gt;
&lt;p&gt;            try {&lt;/p&gt;
&lt;p&gt;                // Recheck while holding lock.&lt;/p&gt;
&lt;p&gt;                // Back out on ThreadFactory failure or if&lt;/p&gt;
&lt;p&gt;                // shut down before lock acquired.&lt;/p&gt;
&lt;p&gt;                int rs = runStateOf(ctl.get());&lt;/p&gt;

&lt;p&gt;                if (rs &amp;lt; SHUTDOWN ||&lt;/p&gt;
&lt;p&gt;                    (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {  //&lt;strong&gt;再次检查，确保当前仍然满足允许创建线程的条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                    if (t.isAlive()) // &lt;strong&gt;确保Thread还没有调用start()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                        throw new IllegalThreadStateException();&lt;/p&gt;
&lt;p&gt;                    workers.add(w); //&lt;strong&gt;把worker线程放进HashSet中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                    int s = workers.size();&lt;/p&gt;
&lt;p&gt;                    if (s &amp;gt; largestPoolSize)&lt;/p&gt;
&lt;p&gt;                        largestPoolSize = s;&lt;/p&gt;
&lt;p&gt;                    workerAdded = true;&lt;/p&gt;
&lt;p&gt;                }&lt;/p&gt;
&lt;p&gt;            } finally {&lt;/p&gt;
&lt;p&gt;                mainLock.unlock();&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;
&lt;p&gt;            if (workerAdded) {&lt;/p&gt;
&lt;p&gt;                t.start();  //&lt;strong&gt;启动新线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                workerStarted = true;&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    } finally {&lt;/p&gt;
&lt;p&gt;        if (! workerStarted)&lt;/p&gt;
&lt;p&gt;            addWorkerFailed(w);&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;    return workerStarted;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;div readability=&quot;397&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程的主循环&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Worker实现了Runnable接口&lt;/p&gt;
&lt;p&gt;private final class Worker extends AbstractQueuedSynchronizer  implements Runnable&lt;/p&gt;
&lt;p&gt;构造方法&lt;/p&gt;
&lt;p&gt;Worker(Runnable firstTask) {&lt;/p&gt;
&lt;p&gt;        setState(-1); // inhibit interrupts until runWorker&lt;/p&gt;
&lt;p&gt;        this.firstTask = firstTask;&lt;/p&gt;
&lt;p&gt;        this.thread = getThreadFactory().newThread(this);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;创建线程时把Worker实例本身当做线程的Runnable产生，所以当线程启动后，将会调用Worker的run方法。&lt;/p&gt;
&lt;p&gt;public void run() {&lt;/p&gt;
&lt;p&gt;        runWorker(this);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;线程的主循环就在runWorker方法中实现&lt;/p&gt;
&lt;p&gt;final void runWorker(Worker w) {&lt;/p&gt;
&lt;p&gt;    Thread wt = Thread.currentThread();&lt;/p&gt;
&lt;p&gt;    Runnable task = w.firstTask;  //&lt;strong&gt;如果firstTask!=null, 先执行firstTask&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    w.firstTask = null;&lt;/p&gt;
&lt;p&gt;    w.unlock(); // allow interrupts&lt;/p&gt;
&lt;p&gt;    boolean completedAbruptly = true;&lt;/p&gt;
&lt;p&gt;    try {&lt;/p&gt;
&lt;p&gt;        while (task != null || (task = getTask()) != null) { //&lt;strong&gt;如果没有firstTask,  从队列中取出一个task, 如果没有取到，退出线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;            w.lock();&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        //&lt;strong&gt;如果处于状态&amp;gt;=STOP(前面已经讲过状态直接的大小关系), 确保线程处于interrupted状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       //&lt;strong&gt;否则清除线程的interrupted状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;            if ((runStateAtLeast(ctl.get(), STOP) ||&lt;/p&gt;
&lt;p&gt;                 (Thread.interrupted() &amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;                  runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;&lt;/p&gt;
&lt;p&gt;                !wt.isInterrupted())&lt;/p&gt;
&lt;p&gt;                wt.interrupt();&lt;/p&gt;
&lt;p&gt;            try {&lt;/p&gt;
&lt;p&gt;                beforeExecute(wt, task); //&lt;strong&gt;执行任务前调用的方法，默认什么都没干，用户可以根据需要覆盖它&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                Throwable thrown = null;&lt;/p&gt;
&lt;p&gt;                try {&lt;/p&gt;
&lt;p&gt;                    task.run(); //&lt;strong&gt;执行任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                } catch (RuntimeException x) {&lt;/p&gt;
&lt;p&gt;                    thrown = x; throw x;&lt;/p&gt;
&lt;p&gt;                } catch (Error x) {&lt;/p&gt;
&lt;p&gt;                    thrown = x; throw x;&lt;/p&gt;
&lt;p&gt;                } catch (Throwable x) {&lt;/p&gt;
&lt;p&gt;                    thrown = x; throw new Error(x);&lt;/p&gt;
&lt;p&gt;                } finally {&lt;/p&gt;
&lt;p&gt;                    afterExecute(task, thrown); //&lt;strong&gt;任务完成之后调用的方法, 默认什么都没干，用户可以根据需要覆盖它&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                }&lt;/p&gt;
&lt;p&gt;            } finally {&lt;/p&gt;
&lt;p&gt;                task = null; //&lt;strong&gt;把当前task置空，这样才能调用getTask从队列里取出任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                w.completedTasks++;&lt;/p&gt;
&lt;p&gt;                w.unlock();&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        completedAbruptly = false;&lt;/p&gt;
&lt;p&gt;    } finally {&lt;/p&gt;
&lt;p&gt;       //&lt;strong&gt;正常退出线程 completedAbruptly是true, 异常导致的线程退出为false&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        processWorkerExit(w, completedAbruptly);&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;从队列中得到排队的任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在runWorker主循环中，除了第一次的任务从worker的firsTask(在它不是null的情况下)取之外, 后面每次都是调用getTask从队列中取出一个任务。&lt;/p&gt;
&lt;p&gt;下面是getTask的代码分析&lt;/p&gt;
&lt;p&gt;private Runnable getTask() {&lt;/p&gt;
&lt;p&gt;    boolean timedOut = false; // Did the last poll() time out?&lt;/p&gt;

&lt;p&gt;    for (;;) {&lt;/p&gt;
&lt;p&gt;        int c = ctl.get();&lt;/p&gt;
&lt;p&gt;        int rs = runStateOf(c); //&lt;strong&gt;得到当前状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;        // &lt;strong&gt;如果当前状态 &amp;gt; SHUTDOWN 退出线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    // &lt;strong&gt;如果当前状态 == SHUTDOWN 且 队列为空，退出线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {&lt;/p&gt;
&lt;p&gt;            decrementWorkerCount();  //减少当前线程数&lt;/p&gt;
&lt;p&gt;            return null;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;

&lt;p&gt;        int wc = workerCountOf(c); //&lt;strong&gt;得到当前的线程数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;        //&lt;strong&gt;线程是否允许超时的条件: 设置允许coreThread超时，或者当前线程数 &amp;gt; corePoolSize&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;&lt;/p&gt;

&lt;p&gt;    //&lt;strong&gt;线程退出需要同时满足以下两个条件条件:&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;    //&lt;strong&gt;1. 当前线程数&amp;gt;maximumPooSize 或 允许超时同时检查到已经超时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    //&lt;strong&gt;2. 当前线程数&amp;gt;1 或 队列为空&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))&lt;/p&gt;
&lt;p&gt;            &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {&lt;/p&gt;
&lt;p&gt;            if (compareAndDecrementWorkerCount(c)) //&lt;strong&gt;减少当前线程数, 这个方法确保多线程环境下不会过多地结束线程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                return null;&lt;/p&gt;
&lt;p&gt;            continue;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;

&lt;p&gt;        try {&lt;/p&gt;
&lt;p&gt;           //&lt;strong&gt;取出一个任务。如果允许超时，调用poll，否则调用take&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;            Runnable r = timed ?&lt;/p&gt;
&lt;p&gt;                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :&lt;/p&gt;
&lt;p&gt;                workQueue.take();&lt;/p&gt;
&lt;p&gt;            if (r != null)&lt;/p&gt;
&lt;p&gt;                return r;&lt;/p&gt;
&lt;p&gt;            timedOut = true; //&lt;strong&gt;已经超时，运行到这里表明poll超时返回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        } catch (InterruptedException retry) {&lt;/p&gt;
&lt;p&gt;            timedOut = false;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;getTask的功能除了取出一个任务以外，它还负责在条件满足的情况下正常地结束一个线程&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程结束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;private void processWorkerExit(Worker w, boolean completedAbruptly) {&lt;/p&gt;
&lt;p&gt;    if (completedAbruptly) // &lt;strong&gt;如果线程是由于异常原因结束的，这里要纠正线程数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        decrementWorkerCount();&lt;/p&gt;

&lt;p&gt;    final ReentrantLock mainLock = this.mainLock;&lt;/p&gt;
&lt;p&gt;    mainLock.lock();&lt;/p&gt;
&lt;p&gt;    try {&lt;/p&gt;
&lt;p&gt;        completedTaskCount += w.completedTasks;&lt;/p&gt;
&lt;p&gt;        workers.remove(w);  //&lt;strong&gt;把线程从HashSet中删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    } finally {&lt;/p&gt;
&lt;p&gt;        mainLock.unlock();&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;    tryTerminate(); //&lt;strong&gt;尝试终止整个ThreadPool&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    int c = ctl.get();&lt;/p&gt;
&lt;p&gt;    if (runStateLessThan(c, STOP)) {  //&lt;strong&gt;如果当前状态&amp;lt;STOP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        if (!completedAbruptly) { //&lt;strong&gt;如果不是异常结束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;             //&lt;strong&gt;计算最小线程数min&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;&lt;/p&gt;
&lt;p&gt;            if (min == 0 &amp;amp;&amp;amp; ! workQueue.isEmpty()) &lt;/p&gt;
&lt;p&gt;                min = 1;&lt;/p&gt;
&lt;p&gt;            if (workerCountOf(c) &amp;gt;= min)  //&lt;strong&gt;如果当前线程数&amp;gt;=min直接返回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                return; // replacement not needed&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        //&lt;strong&gt;创建新线程, 条件:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        //&lt;strong&gt;当前线程正常结束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        //&lt;strong&gt;当前线程异常结束，但当前线程数小于最小线程数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        addWorker(null, false);&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;上面的代码实现了线程的生命周期的管理，线程只有在ThreadPoolExecutor的状态处于RUNNGIN或SHUTDOWN时才可以存在。下面是这两种状态下线程的生存状态:&lt;/p&gt;
&lt;p&gt;RUNNING：&lt;/p&gt;
&lt;p&gt;    允许coreThread超时: 线程空闲(意味着队列为空)时间超过 keepAliveTime, 线程会被结束, 直到线程数为0。&lt;/p&gt;
&lt;p&gt;    不允许coreThread超时:  线程空闲时间超过 keepAliveTime, 线程会被结束，直到线程数为corePoolSize。&lt;/p&gt;
&lt;p&gt;SHUDOWN:&lt;/p&gt;
&lt;p&gt;      当线程把已经在队列里的所有任务执行完毕后，所有线程都会进入退出流程，最终退出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;整个ThreadPoolExecutor的状态变迁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面已经讲过，ThreadPool的状态和线程数被打包方进一个32整数中：&lt;/p&gt;
&lt;p&gt;AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));&lt;/p&gt;
&lt;p&gt;初始化把状态设置成RUNNING, 线程为0&lt;/p&gt;
&lt;p&gt;调用shutdown时把状态从RUNNING置为SHUTDOWN,  随后过渡到TIDYING-&amp;gt;TREMINATED。&lt;/p&gt;
&lt;p&gt;当调用shutdownNow时把状态从(RUNNING 或 SHUTDOWN) 设置为STOP,  随后过渡到TIDYING-&amp;gt;TREMINATED。&lt;/p&gt;
&lt;p&gt;public void shutdown() {&lt;/p&gt;
&lt;p&gt;    final ReentrantLock mainLock = this.mainLock;&lt;/p&gt;
&lt;p&gt;    mainLock.lock();&lt;/p&gt;
&lt;p&gt;    try {&lt;/p&gt;
&lt;p&gt;        checkShutdownAccess();&lt;/p&gt;
&lt;p&gt;        advanceRunState(SHUTDOWN);    //&lt;strong&gt;只有当前状态&amp;lt;SHUTDOWN时才执行状态设置的动作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        interruptIdleWorkers();  //&lt;strong&gt;打断所有空闲的的线程，让这些线程有机会自己结束&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        onShutdown(); // &lt;strong&gt;回调方法，默认什么都没做，子类可以覆盖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    } finally {&lt;/p&gt;
&lt;p&gt;        mainLock.unlock();&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;    tryTerminate(); //&lt;strong&gt;尝试执行ThreadPool的结束操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;shutdownNow和shutdown的操作大致一样，不同的是它把状态设置成STOP，还会返回队列中没有来得及执行的任务list。&lt;/p&gt;
&lt;p&gt;tryTerminate方法作用是尝试结束整个ThreadPool, 它不一定会执行真正的结束动作。它在三个地方被调用, worker线程结束时，shudown中，shutdownNow中。&lt;/p&gt;
&lt;p&gt;final void tryTerminate() {&lt;/p&gt;
&lt;p&gt;    for (;;) {&lt;/p&gt;
&lt;p&gt;        int c = ctl.get();&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;//满足以下三个条件中的任何一个就立即返回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    //1. 处于RUNNGING状态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    //2. 状态&amp;gt;= TIDYING&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    //3. 处于SHUTDOWN状态，且队列不是空&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        if (isRunning(c) ||&lt;/p&gt;
&lt;p&gt;            runStateAtLeast(c, TIDYING) ||&lt;/p&gt;
&lt;p&gt;            (runStateOf(c) == SHUTDOWN &amp;amp;&amp;amp; ! workQueue.isEmpty()))&lt;/p&gt;
&lt;p&gt;            return;&lt;/p&gt;
&lt;p&gt;    //&lt;strong&gt;如果处于STOP状态，且线程数不为0，通知一个处于空闲的线程结束自己&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        if (workerCountOf(c) != 0) { // Eligible to terminate&lt;/p&gt;
&lt;p&gt;            interruptIdleWorkers(ONLY_ONE);&lt;/p&gt;
&lt;p&gt;            return;&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;    //&lt;strong&gt;执行到这里表示目前状态&amp;gt;=SHUTDOWN，线程数已经是0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        final ReentrantLock mainLock = this.mainLock;&lt;/p&gt;
&lt;p&gt;        mainLock.lock();&lt;/p&gt;
&lt;p&gt;        try {&lt;/p&gt;
&lt;p&gt;            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) { //&lt;strong&gt;总有一个线程会运行到这里，把状态置为 TIDYING&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                try {&lt;/p&gt;
&lt;p&gt;                    terminated(); //&lt;strong&gt;调用回调方面，默认什么都没干，子类可以覆盖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                } finally {&lt;/p&gt;
&lt;p&gt;                    ctl.set(ctlOf(TERMINATED, 0));  //&lt;strong&gt;把状态置为TREMINATED, 自此整个ThreadPool才算终结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;                    termination.signalAll();&lt;/p&gt;
&lt;p&gt;                }&lt;/p&gt;
&lt;p&gt;                return;&lt;/p&gt;
&lt;p&gt;            }&lt;/p&gt;
&lt;p&gt;        } finally {&lt;/p&gt;
&lt;p&gt;            mainLock.unlock();&lt;/p&gt;
&lt;p&gt;        }&lt;/p&gt;
&lt;p&gt;        // else retry on failed CAS&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;tryTerminate之所以要在三个地方调用，是为了保证当调用shutdown或shutdownNow之后，总有一个线程会完成最后的终结工作。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;参数设置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分析完前面代码后，再来使用它，它的参数怎么设置自然就了然于心。&lt;/p&gt;
&lt;p&gt;public ThreadPoolExecutor(int corePoolSize,&lt;/p&gt;
&lt;p&gt;                          int maximumPoolSize,&lt;/p&gt;
&lt;p&gt;                          long keepAliveTime,&lt;/p&gt;
&lt;p&gt;                          TimeUnit unit,&lt;/p&gt;
&lt;p&gt;                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;/p&gt;
&lt;p&gt;                          ThreadFactory threadFactory,&lt;/p&gt;
&lt;p&gt;                          RejectedExecutionHandler handler) &lt;/p&gt;
&lt;p&gt;public void allowCoreThreadTimeOut(boolean value)&lt;/p&gt;
&lt;p&gt;public void setCorePoolSize(int corePoolSize) &lt;/p&gt;
&lt;p&gt;public void setKeepAliveTime(long time, TimeUnit unit)&lt;/p&gt;
&lt;p&gt;public void setMaximumPoolSize(int maximumPoolSize)&lt;/p&gt;
&lt;p&gt;public void setRejectedExecutionHandler(RejectedExecutionHandler handler) &lt;/p&gt;
&lt;p&gt;public void setThreadFactory(ThreadFactory threadFactory)&lt;/p&gt;
&lt;/div&gt;



</description>
<pubDate>Mon, 26 Nov 2018 16:06:00 +0000</pubDate>
<dc:creator>自带buff</dc:creator>
<og:description>派生体系 java.util.concurrent ThreadPoolExecutor AbstractExecutorService ExecutorService Executor 这个类是Ex</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brandonli/p/10023970.html</dc:identifier>
</item>
<item>
<title>改变GPS速度的小工具——第一版 - 一生二</title>
<link>http://www.cnblogs.com/zzgblg/p/10023959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzgblg/p/10023959.html</guid>
<description>&lt;p&gt;功能：导航测试中，安卓APP使用GT模拟以达到测试的目的，但是使用RD提供的Demo生成的文件，速度不够快，模拟不了超速的场景，故需要把速度值调高&lt;/p&gt;
&lt;p&gt;腾讯GT使用的GPS文件格式：&lt;/p&gt;
&lt;p&gt;116.28499730,40.04132990,5.0,77.9,40.000000,2018-03-06 15:25:49,1520321149.574,0.0&lt;br/&gt;116.28502120,40.04133370,5.0,77.9,2.077989,2018-03-06 15:25:50,1520321150.574,0.0&lt;br/&gt;116.28504460,40.04133760,5.0,77.9,2.038668,2018-03-06 15:25:51,1520321151.574,0.0&lt;br/&gt;116.28506850,40.04134140,5.0,77.9,2.077989,2018-03-06 15:25:52,1520321152.574,0.0&lt;br/&gt;116.28509210,40.04134520,5.0,77.9,2.052990,2018-03-06 15:25:53,1520321153.574,0.0&lt;br/&gt;116.28511580,40.04134910,5.0,77.9,2.063629,2018-03-06 15:25:54,1520321154.574,0.0&lt;/p&gt;
&lt;p&gt;如上所示：第五个逗号前的数字（如：第一行的40.000000）就是我们需要改变的速度值&lt;/p&gt;
&lt;p&gt;第一版代码如下：&lt;/p&gt;
&lt;pre&gt;
#被修改的速度值与实际时速相差大概4倍&lt;br/&gt;def chang_velocity() :&lt;br/&gt;velocity = input(&quot;请输入要改变的速度：&quot;)&lt;br/&gt;with open('befor.gps' ,'r') as f,open('after.gps' ,'a') as f1:&lt;br/&gt;for line in f:&lt;br/&gt;data = line.strip().split(',')&lt;br/&gt;data[4] = velocity&lt;br/&gt;new_data = &quot;,&quot;.join(data)#对join方法理解的还是不好，需要加深理解，此处用法是把切割的列表转换成字符串，通过逗号连接，以前知道通过join转为字符串，但是不知道引号内可以加入分隔符&lt;br/&gt;f1.write(new_data+&quot;\n&quot;)&lt;br/&gt;f1.close()&lt;br/&gt;f.close()&lt;br/&gt;if __name__ == '__main__':&lt;br/&gt;runner = chang_velocity()&lt;br/&gt;使用该代码通过pyinstaller工具打包成Windows下的可执行文件输入速度值即可！&lt;br/&gt;该工具下一步可以在给定速度范围内随机生成速度值，并对速度值位数加以限制&lt;br/&gt;顺便感谢滴滴地图的测开们，是你们的懒惰，才有了我的进步！
&lt;/pre&gt;

</description>
<pubDate>Mon, 26 Nov 2018 16:01:00 +0000</pubDate>
<dc:creator>一生二</dc:creator>
<og:description>功能：导航测试中，安卓APP使用GT模拟以达到测试的目的，但是使用RD提供的Demo生成的文件，速度不够快，模拟不了超速的场景，故需要把速度值调高 腾讯GT使用的GPS文件格式： 116.284997</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzgblg/p/10023959.html</dc:identifier>
</item>
<item>
<title>C语言第四次实验 - 徐大帅i</title>
<link>http://www.cnblogs.com/XsjaboutC/p/10023905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/XsjaboutC/p/10023905.html</guid>
<description>&lt;p&gt;这次实验共计7道题目&lt;/p&gt;
&lt;p&gt;以下代码亲测无误&lt;/p&gt;
&lt;p&gt;1.用选择排序法，键盘输入10个整数，对10个整数进行排序（升序）&lt;/p&gt;
&lt;p&gt;　　1.第一种思路就是常规思路，输入--排序--输出&lt;/p&gt;
&lt;p&gt;源代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;常规思路，输入，排序，输出 &lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;],i,j,t; 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a[%d]=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;); //也可以换为i
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;a[i]);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }&lt;br/&gt;　　　　/*以下是选择排序*/
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;9&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(j=i+&lt;span&gt;1&lt;/span&gt;;j&amp;lt;&lt;span&gt;10&lt;/span&gt;;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(a[i]&amp;gt;&lt;span&gt;a[j])
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;               {t=a[i];a[i]=a[j];a[j]=&lt;span&gt;t;} //进行交换
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the sorted numbers:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); //输出
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;)    
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a[i]);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.第二种思路就是 我嫌最后一步又用个for循环输出麻烦，想着就是在排序的时候，就给输出出来&lt;/p&gt;
&lt;p&gt;　　于是乎有了  输入--排序+输出   这个思路&lt;/p&gt;
&lt;p&gt;源代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;思路，输入--&amp;gt;排序,输出 也就是在排序的途中输出 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从而省略了最后的一个for循环   &lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;],i,j,t;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a(%d)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;a[i]);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the sorted numbers:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;9&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    { 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(j=i+&lt;span&gt;1&lt;/span&gt;;j&amp;lt;&lt;span&gt;10&lt;/span&gt;;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(a[i]&amp;gt;&lt;span&gt;a[j])
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;               {t=a[i];a[i]=a[j];a[j]=&lt;span&gt;t;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a[i]);  //此次位置确定下来后输出
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a[i]);  //因外层循环为9次，后补出最后一位元素
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.用冒泡排序法，键盘输入10个整数，对10个整数进行排序（升序）&lt;/p&gt;
&lt;p&gt;规规矩矩的谭浩强那本书代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;10&lt;/span&gt;&lt;span&gt;],i,j,t;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;)  //输入
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a(%d)=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;a[i]);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;9&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;&lt;span&gt;9&lt;/span&gt;-i;j++&lt;span&gt;)  //在每一趟中进行9-i次比较
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(a[j]&amp;gt;a[j+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]) //相邻两个数比较
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 {t=a[j];a[j]=a[j+&lt;span&gt;1&lt;/span&gt;];a[j+&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;t;} 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             
&lt;span&gt;15&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the sorted numbers:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); //输出
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++&lt;span&gt;)    
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a[i]);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.编程实现：输入4行5列的矩阵，输出其中的最大的那个元素的值，以其所在的行号和列标&lt;/p&gt;
&lt;p&gt;内心想法：题目真的是一个类型的，还是要做...那我就贴出来吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;4&lt;/span&gt;][&lt;span&gt;5&lt;/span&gt;&lt;span&gt;],i,j,m,n,max;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;4&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;&lt;span&gt;5&lt;/span&gt;;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a[%d][%d]=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i+&lt;span&gt;1&lt;/span&gt;,j+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;a[i][j]);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     max=a[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;4&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;&lt;span&gt;5&lt;/span&gt;;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(max&amp;lt;&lt;span&gt;a[i][j])
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                max=&lt;span&gt;a[i][j];
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                m=i;n=&lt;span&gt;j;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max is %d,row is %d,column is %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,max,m+&lt;span&gt;1&lt;/span&gt;,n+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;); //m，n各加1，是为了符合我们的意识
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;            
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt; } 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.输入一行字符，分别统计出其英文字母，空格，数字和其他字符的个数。&lt;/p&gt;
&lt;p&gt;想了一下，因为这星期刚学字符数组，故要用到字符数组 来做这题&lt;/p&gt;
&lt;p&gt;emmm 就先定义一个字符数组吧，要多大长度呢？100？不够？1000？这总够了吧&lt;/p&gt;
&lt;p&gt;于是乎有了 char str[1000]&lt;/p&gt;
&lt;p&gt;强行解释了输入的长度大于字符数组定义的长度&lt;/p&gt;
&lt;p&gt;然后再遍历这个数组&lt;/p&gt;
&lt;p&gt;逐个判断---对号入座&lt;/p&gt;
&lt;p&gt;讲了这么多废话，代码给贴出来吧&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Ascii码判断范围 &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; str[&lt;span&gt;100&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b,c,d,i;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     a=b=c=d=i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     gets(str);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果用scanf输入的话遇到空格后面的就没输入到变量中 &lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(str[i]!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  //到结束符停止
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    { 　　/*对号入座中*/
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;((str[i]&amp;gt;=&lt;span&gt;65&lt;/span&gt; &amp;amp;&amp;amp; str[i]&amp;lt;=&lt;span&gt;90&lt;/span&gt;) || (str[i]&amp;gt;=&lt;span&gt;97&lt;/span&gt; &amp;amp;&amp;amp; str[i]&amp;lt;=&lt;span&gt;122&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             a++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(str[i]&amp;gt;=&lt;span&gt;48&lt;/span&gt; &amp;amp;&amp;amp; str[i]&amp;lt;=&lt;span&gt;57&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;               b++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(str[i]==&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;               c++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;   
&lt;span&gt;19&lt;/span&gt;             d++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;英文字母个数:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a); 
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数字个数:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,b); 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;空格个数:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,c); 
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;其他字符个数:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,d); 
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;  }&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;切记一定不要用scanf来输入，我运行的时候结果一直不对，总是空格后的字符没加进入，一开始我还以为是while里面的表达式的原因呢，找了好久&lt;/p&gt;
&lt;p&gt;此外 遍历数组还可以用for 循环----for(i=0;i&amp;lt;strlen(str);i++)&lt;/p&gt;
&lt;p&gt;while循环里面的判断条件也可以换成别的&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; str[&lt;span&gt;100&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,num,letter,space,others;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     num=letter=space=others=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     gets(str);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入字符串&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;strlen(str);i++&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;常规的判断方法*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;((str[i]&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; str[i]&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) || (str[i]&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; str[i]&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             letter++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(str[i]&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; str[i]&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;               num++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(str[i]==&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;               space++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;   
&lt;span&gt;19&lt;/span&gt;             others++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;英文字母个数:%d\n数字个数:%d\n空格字数:%d\n其他字符个数:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,letter,num,space,others);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }   &lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嘿嘿，我觉得我这变量名字起的还挺好&lt;/p&gt;
&lt;p&gt;敲黑板了桥黑板了！&lt;/p&gt;
&lt;p&gt;以上两个均未解决输入的字符串长度大于字符数组长度的问题&lt;/p&gt;
&lt;p&gt;这次没用字符数组，就直接定义了一个字符变量 s ，利用getchar()来进行输入即可&lt;/p&gt;
&lt;p&gt;于是乎有了下面这条代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{ 
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt;&lt;span&gt; s; 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b,c,d,big,small; 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     a=b=c=d=big=small=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;please input the string\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;((s=getchar())!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环从键盘读入字符直到一行结束（输入回车） &lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    { 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;((s&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;s&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)||(s&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;s&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    { 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(s&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;s&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) big++&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(s&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;s&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) small++&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         a++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a存入字母数&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(s==&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;) b++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b存入空格数&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(s&amp;gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;amp;&amp;amp;s&amp;lt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)c++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;c存入数字数&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; d++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;d存入其它符号数 &lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    } 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;char:%d Capital letters:%d Lower:%d\nspace:%d\nnumber:%d\nOther:%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,a,big,small,b,c,d);  
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;貌似在判断字母那边画蛇添足了一步，写个代码还不是随心所欲嘛，自己多加个条件也行啊。&lt;/p&gt;

&lt;p&gt;5.打印九九乘法表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=&lt;span&gt;9&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {  /*这个括号一定要带上*/
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=i;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d*%d=%d  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,j,i,i*&lt;span&gt;j);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.求多项式：s=1/2-2/3+3/5-5/8+... 前20项之和（不用数组）&lt;/p&gt;
&lt;p&gt;哼，这一章是数组，题目要求还不给用数组，这是要怎样哈，不用数组我也有办法&lt;/p&gt;
&lt;p&gt;思路：利用迭代法，来进行分子，分母之间的切换，再用一个标志来解决正负问题&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,sign;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt;&lt;span&gt; a,b,n,sum;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     a=&lt;span&gt;1&lt;/span&gt;;b=&lt;span&gt;2&lt;/span&gt;;sum=&lt;span&gt;0&lt;/span&gt;;sign=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=&lt;span&gt;20&lt;/span&gt;;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         sign=-sign;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制每一项的符号 &lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         sum=sum+a/b*&lt;span&gt;sign;  
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;引入n，进行迭代交换 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         n=&lt;span&gt;a;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         a=&lt;span&gt;b;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         b=n+&lt;span&gt;b;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sum=%f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,sum);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  &lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;7.将长整形数s中每一位上为偶数的数码依次取出，构成一个新数放在t中，高位仍放在高位，低位仍放在低位（此题不用数组）&lt;/p&gt;
&lt;p&gt;要求：s从键盘输入&lt;/p&gt;
&lt;p&gt;例：s=123456789      t=2468&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i=-&lt;span&gt;1&lt;/span&gt;,m,p=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; s,t=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pelease input number s:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%ld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;s); //%ld长整形输入
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(s) //当s为0时，条件为假结束循环
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         m=s%&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(m%&lt;span&gt;2&lt;/span&gt;==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             t=t+m*&lt;span&gt;p;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             p=p*&lt;span&gt;10&lt;/span&gt;;  //这程序关键，我也不好描述
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         s/=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t=%ld&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,t);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上就是我这次实验报告的成果。&lt;/p&gt;
&lt;p&gt;困了。。。不想写总结了。。。&lt;/p&gt;
&lt;p&gt;下次再更了。。。&lt;/p&gt;
&lt;p&gt;2018-11-26 23:45:29&lt;/p&gt;

</description>
<pubDate>Mon, 26 Nov 2018 15:48:00 +0000</pubDate>
<dc:creator>徐大帅i</dc:creator>
<og:description>这次实验共计7道题目 以下代码亲测无误 1.用选择排序法，键盘输入10个整数，对10个整数进行排序（升序） 1.第一种思路就是常规思路，输入--排序--输出 源代码如下： 2.第二种思路就是 我嫌最后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/XsjaboutC/p/10023905.html</dc:identifier>
</item>
<item>
<title>Kickstart Round H 2018 - basasuya</title>
<link>http://www.cnblogs.com/Basasuya/p/10023901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Basasuya/p/10023901.html</guid>
<description>&lt;p&gt;打了ks好久都没有更新&lt;br/&gt;诶，自己的粗心真的是没救了，A题大数据都能错&lt;br/&gt;A&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;climits&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;list&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;iomanip&amp;gt;
using namespace std;
// const int N = 7005;
// const int M = 2e5 + 5;
const int INF = 0x3f3f3f3f;
const int MOD = 1000000007;
typedef long long ll;

char seq[105][55];
int tot, Root;
int nx[10005][2];
int tag[10005];
int newNode() {
    nx[tot][0] = nx[tot][1] = -1; tag[tot] = 0;
    return tot ++;
}
int N, P; 

void Insert(char* s) {
    int len = strlen(s);
    int root = Root;
    for(int i = 0; i &amp;lt; len; ++i) {
        int id = s[i] == 'R';
        if(nx[root][id] == -1) {
            nx[root][id] = newNode();
        }
        root = nx[root][id];
    }
    tag[root] ++;
}

ll dfs(int rt, int deep) {
    if(tag[rt]) return 1ll&amp;lt;&amp;lt;(N - deep);
    ll ans = 0;
    if(nx[rt][0] != -1) ans += dfs(nx[rt][0], deep + 1);
    if(nx[rt][1] != -1) ans += dfs(nx[rt][1], deep + 1);
    return ans;
}
int main() {
    freopen(&quot;A-large-practice2.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;A-large-practice2.out&quot;, &quot;w&quot;, stdout);
    int T;
    scanf(&quot;%d&quot;, &amp;amp;T);
    for(int _ = 1; _ &amp;lt;= T; ++_) {
        tot = 0;
        Root = newNode();
        scanf(&quot;%d %d&quot;, &amp;amp;N, &amp;amp;P);
        for(int i = 0; i &amp;lt; P; ++i) {
            scanf(&quot;%s&quot;, seq[i]);
            Insert(seq[i]);
        }
        printf(&quot;Case #%d: %lld\n&quot;, _, (1ll&amp;lt;&amp;lt;N) - dfs(Root, 0));

    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;climits&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;list&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;iomanip&amp;gt;
using namespace std;
const int M = 5e6 + 5;
const int INF = 0x3f3f3f3f;
const int MOD = 1000000007;
typedef long long ll;

char seq[M];
int main() {
    freopen(&quot;B-large.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;B-large.out&quot;, &quot;w&quot;, stdout);
    int T;
    scanf(&quot;%d&quot;, &amp;amp;T);
    for(int _ = 1; _ &amp;lt;= T; ++_) {
        int n;
        scanf(&quot;%d %s&quot;, &amp;amp;n, seq + 1);
        int ans = 0; int tmp = 0;
        for(int i = 1; i &amp;lt;= (n+1)/2; ++i) {
            tmp += seq[i] - '0';
        }
        ans = max(ans, tmp);
        for(int i = (n+1)/2 + 1, j = 1; i &amp;lt;= n; ++i, ++j) {
            tmp -= seq[j] - '0';
            tmp += seq[i] - '0';
            ans = max(ans, tmp);
        }


        printf(&quot;Case #%d: %d\n&quot;, _, ans);

    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C容斥原理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;climits&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;list&amp;gt;
#include &amp;lt;queue&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;map&amp;gt;
#include &amp;lt;set&amp;gt;
#include &amp;lt;bitset&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;functional&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;iomanip&amp;gt;
using namespace std;
// const int N = 7005;
const int M = 2e5 + 5;
const int INF = 0x3f3f3f3f;
const int MOD = 1000000007;
typedef long long ll;

ll Mul[M];
ll Pow(ll x, ll y) {
    ll ans = 1;
    while(y) {
        if(y &amp;amp; 1) ans = 1ll * ans * x % MOD;
        x = 1ll * x * x % MOD;
        y &amp;gt;&amp;gt;= 1;
    }
    return ans;
}

ll C(int x, int y) {
    if(y == 0) return 1;
    if(x == y) return 1;
    return 1ll* Mul[x] * Pow(Mul[y] * Mul[x - y] % MOD, MOD - 2) % MOD;
}
int main() {
    freopen(&quot;C-small-attempt0.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;C-small-attempt0.out2&quot;, &quot;w&quot;, stdout);
    int T;
    scanf(&quot;%d&quot;, &amp;amp;T);
    Mul[1] = 1;
    Mul[0] = 1;
    for(int i = 2; i &amp;lt; M; ++i) {
        Mul[i] = Mul[i-1] * i % MOD;
    }
    for(int _ = 1; _ &amp;lt;= T; ++_) {
        int n, m;
        scanf(&quot;%d %d&quot;, &amp;amp;n, &amp;amp;m);
        ll ans = Mul[2*n];
        int init = 2*n; ll mul2 = 1;
        for(int i = 1; i &amp;lt;= m; ++i) {
            init --;
            mul2 = mul2 * 2 % MOD;
            ll tmp = mul2 * Mul[init] % MOD * C(m, i) % MOD;
            ans = (ans + ( (i % 2) ? -tmp : tmp) + MOD) % MOD;
        }

        printf(&quot;Case #%d: %lld\n&quot;, _, ans);
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 26 Nov 2018 15:47:00 +0000</pubDate>
<dc:creator>basasuya</dc:creator>
<og:description>打了ks好久都没有更新 诶，自己的粗心真的是没救了，A题大数据都能错 A include include include include include include include include</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Basasuya/p/10023901.html</dc:identifier>
</item>
<item>
<title>python文件 - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-file.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-file.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;文件的概念&quot;&gt;1. 文件的概念&lt;/h2&gt;
&lt;h3 id=&quot;文件的概念和作用&quot;&gt;1.1 文件的概念和作用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;计算机的 &lt;strong&gt;文件&lt;/strong&gt;，就是存储在某种 &lt;strong&gt;长期储存设备&lt;/strong&gt; 上的一段 &lt;strong&gt;数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;长期存储设备包括：硬盘、U 盘、移动硬盘、光盘...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;文件的作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将数据长期保存下来，在需要的时候使用&lt;/p&gt;
&lt;h3 id=&quot;文件的存储方式&quot;&gt;1.2 文件的存储方式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在计算机中，文件是以 &lt;strong&gt;二进制&lt;/strong&gt; 的方式保存在磁盘上的&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;文本文件和二进制文件&quot;&gt;文本文件和二进制文件&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;文本文件
&lt;ul&gt;&lt;li&gt;可以使用 &lt;strong&gt;文本编辑软件&lt;/strong&gt; 查看&lt;/li&gt;
&lt;li&gt;本质上还是二进制文件&lt;/li&gt;
&lt;li&gt;例如：python 的源程序&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二进制文件
&lt;ul&gt;&lt;li&gt;保存的内容 不是给人直接阅读的，而是 &lt;strong&gt;提供给其他软件使用的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;例如：图片文件、音频文件、视频文件等等&lt;/li&gt;
&lt;li&gt;二进制文件不能使用 &lt;strong&gt;文本编辑软件&lt;/strong&gt; 查看&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;文件的基本操作&quot;&gt;2. 文件的基本操作&lt;/h2&gt;
&lt;h3 id=&quot;操作文件的套路&quot;&gt;2.1 操作文件的套路&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;计算机&lt;/strong&gt; 中要操作文件的套路非常固定，一共包含&lt;strong&gt;三个步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开文件&lt;/li&gt;
&lt;li&gt;读、写文件
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;读&lt;/strong&gt; 将文件内容读入内存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写&lt;/strong&gt; 将内存内容写入文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关闭文件&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;操作文件的函数方法&quot;&gt;2.2 操作文件的函数/方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;Python&lt;/code&gt; 中要操作文件需要记住 1 个函数和 3 个方法&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;open&lt;/td&gt;
&lt;td&gt;打开文件，并且返回文件操作对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;02&lt;/td&gt;
&lt;td&gt;read&lt;/td&gt;
&lt;td&gt;将文件内容读取到内存&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;03&lt;/td&gt;
&lt;td&gt;write&lt;/td&gt;
&lt;td&gt;将指定内容写入文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;04&lt;/td&gt;
&lt;td&gt;close&lt;/td&gt;
&lt;td&gt;关闭文件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;open&lt;/code&gt; 函数负责打开文件，并且返回文件对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read&lt;/code&gt;/&lt;code&gt;write&lt;/code&gt;/&lt;code&gt;close&lt;/code&gt; 三个方法都需要通过 &lt;strong&gt;文件对象&lt;/strong&gt; 来调用&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;read-方法-读取文件&quot;&gt;2.3 read 方法 —— 读取文件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;open&lt;/code&gt; 函数的第一个参数是要打开的文件名（文件名区分大小写）
&lt;ul&gt;&lt;li&gt;如果文件 &lt;strong&gt;存在&lt;/strong&gt;，返回 &lt;strong&gt;文件操作对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果文件 &lt;strong&gt;不存在&lt;/strong&gt;，会 &lt;strong&gt;抛出异常&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;read&lt;/code&gt; 方法可以一次性 &lt;strong&gt;读入&lt;/strong&gt; 并 &lt;strong&gt;返回&lt;/strong&gt; 文件的 &lt;strong&gt;所有内容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;close&lt;/code&gt; 方法负责 &lt;strong&gt;关闭文件&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;如果 &lt;strong&gt;忘记关闭文件&lt;/strong&gt;，&lt;strong&gt;会造成系统资源消耗，而且会影响到后续对文件的访问&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;read&lt;/code&gt; 方法执行后，会把 &lt;strong&gt;文件指针&lt;/strong&gt; 移动到 &lt;strong&gt;文件的末尾&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 1. 打开文件
file = open(&quot;test.txt&quot;)

# 2. 读取
text = file.read()
print(text)

# 3. 关闭文件
file.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提示&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在开发中，通常会先编写 &lt;strong&gt;打开&lt;/strong&gt; 和 &lt;strong&gt;关闭&lt;/strong&gt; 的代码，再编写中间针对文件的 &lt;strong&gt;读/写&lt;/strong&gt; 操作！&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;文件指针&quot;&gt;文件指针&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;文件指针&lt;/strong&gt; 标记 &lt;strong&gt;从哪个位置开始读取数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第一次打开&lt;/strong&gt; 文件时，通常 &lt;strong&gt;文件指针会指向文件的开始位置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当执行了 &lt;code&gt;read&lt;/code&gt; 方法后，&lt;strong&gt;文件指针&lt;/strong&gt; 会移动到 &lt;strong&gt;读取内容的末尾&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;默认情况下会移动到 &lt;strong&gt;文件末尾&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;思考&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果执行了一次 &lt;code&gt;read&lt;/code&gt; 方法，读取了所有内容，那么再次调用 &lt;code&gt;read&lt;/code&gt; 方法，还能够获得到内容吗？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;答案&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不能&lt;/li&gt;
&lt;li&gt;第一次读取之后，文件指针移动到了文件末尾，再次调用不会读取到任何的内容&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;打开文件的方式&quot;&gt;2.4 打开文件的方式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;open&lt;/code&gt; 函数默认以 &lt;strong&gt;只读方式&lt;/strong&gt; 打开文件，并且返回文件对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;语法如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;f = open(&quot;文件名&quot;, &quot;访问方式&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;r&lt;/td&gt;
&lt;td&gt;以&lt;strong&gt;只读&lt;/strong&gt;方式打开文件。文件的指针将会放在文件的开头，这是&lt;strong&gt;默认模式&lt;/strong&gt;。如果文件不存在，抛出异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;w&lt;/td&gt;
&lt;td&gt;以&lt;strong&gt;只写&lt;/strong&gt;方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;以&lt;strong&gt;追加&lt;/strong&gt;方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;r+&lt;/td&gt;
&lt;td&gt;以&lt;strong&gt;读写&lt;/strong&gt;方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;w+&lt;/td&gt;
&lt;td&gt;以&lt;strong&gt;读写&lt;/strong&gt;方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;a+&lt;/td&gt;
&lt;td&gt;以&lt;strong&gt;读写&lt;/strong&gt;方式打开文件。如果该文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;提示&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;频繁的移动文件指针，&lt;strong&gt;会影响文件的读写效率&lt;/strong&gt;，开发中更多的时候会以 &lt;strong&gt;只读&lt;/strong&gt;、&lt;strong&gt;只写&lt;/strong&gt; 的方式来操作文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;写入文件示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 打开文件
file = open(&quot;test.txt&quot;, 'w')

file.write(&quot;hehe&quot;)
file.write(&quot;开心下&quot;)

# 关闭文件
file.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;按行读取文件内容&quot;&gt;2.5 按行读取文件内容&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;read&lt;/code&gt; 方法默认会把文件的 &lt;strong&gt;所有内容&lt;/strong&gt; &lt;strong&gt;一次性读取到内存&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果文件太大，对内存的占用会非常严重&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;readline-方法&quot;&gt;&lt;code&gt;readline&lt;/code&gt; 方法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;readline&lt;/code&gt; 方法可以一次读取一行内容&lt;/li&gt;
&lt;li&gt;方法执行后，会把 &lt;strong&gt;文件指针&lt;/strong&gt; 移动到下一行，准备再次读取&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;读取大文件的正确姿势&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 打开文件
file = open(&quot;test.txt&quot;)

while True:
    text = file.readline()
    if not text:
        break

    print(text, end=&quot;&quot;)

# 关闭文件
file.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;文件读写案例-复制文件&quot;&gt;2.6 文件读写案例 —— 复制文件&lt;/h3&gt;
&lt;p&gt;目标：用代码的方式，来实现文件复制过程&lt;/p&gt;
&lt;h4 id=&quot;小文件复制&quot;&gt;小文件复制&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 打开文件
file = open(&quot;test.txt&quot;)

while True:
    text = file.readline()
    if not text:
        break

    print(text, end=&quot;&quot;)

# 关闭文件
file.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;大文件复制&quot;&gt;大文件复制&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;打开一个已有文件，逐行读取内容，并顺序写入到另外一个文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;file_read = open(&quot;test.txt&quot;)
file_write = open(&quot;test-Copy.txt&quot;, &quot;w&quot;)

while True:
    text = file_read.readline()

    if not text:
        break

    file_write.write(text)

file_write.close()
file_read.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;文件目录的常用管理操作&quot;&gt;3. 文件/目录的常用管理操作&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;strong&gt;终端&lt;/strong&gt; / &lt;strong&gt;文件浏览器&lt;/strong&gt;、 中可以执行常规的 &lt;strong&gt;文件&lt;/strong&gt; / &lt;strong&gt;目录&lt;/strong&gt; 管理操作，例如：
&lt;ul&gt;&lt;li&gt;创建、重命名、删除、改变路径、查看目录内容、……&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Python&lt;/code&gt; 中，如果希望通过程序实现上述功能，需要导入 &lt;code&gt;os&lt;/code&gt; 模块&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;文件操作&quot;&gt;文件操作&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;rename&lt;/td&gt;
&lt;td&gt;重命名文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;os.rename(源文件名, 目标文件名)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;02&lt;/td&gt;
&lt;td&gt;remove&lt;/td&gt;
&lt;td&gt;删除文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;os.remove(文件名)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;目录操作&quot;&gt;目录操作&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;listdir&lt;/td&gt;
&lt;td&gt;目录列表&lt;/td&gt;
&lt;td&gt;&lt;code&gt;os.listdir(目录名)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;02&lt;/td&gt;
&lt;td&gt;mkdir&lt;/td&gt;
&lt;td&gt;创建目录&lt;/td&gt;
&lt;td&gt;&lt;code&gt;os.mkdir(目录名)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;03&lt;/td&gt;
&lt;td&gt;rmdir&lt;/td&gt;
&lt;td&gt;删除目录&lt;/td&gt;
&lt;td&gt;&lt;code&gt;os.rmdir(目录名)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;04&lt;/td&gt;
&lt;td&gt;getcwd&lt;/td&gt;
&lt;td&gt;获取当前目录&lt;/td&gt;
&lt;td&gt;&lt;code&gt;os.getcwd()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;05&lt;/td&gt;
&lt;td&gt;chdir&lt;/td&gt;
&lt;td&gt;修改工作目录&lt;/td&gt;
&lt;td&gt;&lt;code&gt;os.chdir(目标目录)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;06&lt;/td&gt;
&lt;td&gt;path.isdir&lt;/td&gt;
&lt;td&gt;判断是否是文件&lt;/td&gt;
&lt;td&gt;&lt;code&gt;os.path.isdir(文件路径)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;提示：文件或者目录操作都支持 &lt;strong&gt;相对路径&lt;/strong&gt; 和 &lt;strong&gt;绝对路径&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;文本文件的编码格式&quot;&gt;4. 文本文件的编码格式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;文本文件存储的内容是基于 &lt;strong&gt;字符编码&lt;/strong&gt; 的文件，常见的编码有 &lt;code&gt;ASCII&lt;/code&gt; 编码，&lt;code&gt;UNICODE&lt;/code&gt; 编码等&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Python 2.x 默认使用 &lt;code&gt;ASCII&lt;/code&gt; 编码格式&lt;br/&gt;Python 3.x 默认使用 &lt;code&gt;UTF-8&lt;/code&gt; 编码格式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;ascii-编码&quot;&gt;&lt;code&gt;ASCII&lt;/code&gt; 编码&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;计算机中只有 &lt;code&gt;256&lt;/code&gt; 个 &lt;code&gt;ASCII&lt;/code&gt; 字符&lt;/li&gt;
&lt;li&gt;一个 &lt;code&gt;ASCII&lt;/code&gt; 在内存中占用 &lt;strong&gt;1 个字节&lt;/strong&gt; 的空间
&lt;ul&gt;&lt;li&gt;&lt;code&gt;8&lt;/code&gt; 个 &lt;code&gt;0/1&lt;/code&gt; 的排列组合方式一共有 &lt;code&gt;256&lt;/code&gt; 种，也就是 &lt;code&gt;2 ** 8&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201811/1156642-20181126233839605-965096806.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;utf-8-编码格式&quot;&gt;&lt;code&gt;UTF-8&lt;/code&gt; 编码格式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;计算机中使用 &lt;strong&gt;1~6 个字节&lt;/strong&gt; 来表示一个 &lt;code&gt;UTF-8&lt;/code&gt; 字符，涵盖了 &lt;strong&gt;地球上几乎所有地区的文字&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;大多数汉字会使用 &lt;strong&gt;3 个字节&lt;/strong&gt; 表示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UTF-8&lt;/code&gt; 是 &lt;code&gt;UNICODE&lt;/code&gt; 编码的一种编码格式&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;ptyhon-2.x-中如何使用中文&quot;&gt;4.2 Ptyhon 2.x 中如何使用中文&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在 Python 2.x 文件的 &lt;strong&gt;第一行&lt;/strong&gt; 增加以下代码，解释器会以 &lt;code&gt;utf-8&lt;/code&gt; 编码来处理 python 文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# *-* coding:utf8 *-*&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这方式是官方推荐使用的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;也可以使用&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf8&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;unicode-字符串&quot;&gt;unicode 字符串&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;Python 2.x&lt;/code&gt; 中，即使指定了文件使用 &lt;code&gt;UTF-8&lt;/code&gt; 的编码格式，但是在遍历字符串时，仍然会 &lt;strong&gt;以字节为单位遍历&lt;/strong&gt; 字符串&lt;/li&gt;
&lt;li&gt;要能够 &lt;strong&gt;正确的遍历字符串&lt;/strong&gt;，在定义字符串时，需要 &lt;strong&gt;在字符串的引号前&lt;/strong&gt;，增加一个小写字母 &lt;code&gt;u&lt;/code&gt;，告诉解释器这是一个 &lt;code&gt;unicode&lt;/code&gt; 字符串（使用 &lt;code&gt;UTF-8&lt;/code&gt; 编码格式的字符串）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# *-* coding=UTF-8 *-*

my_str = u&quot;hello这是字符串&quot;

print(my_str)

for c in my_str:

    print(c)
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 26 Nov 2018 15:46:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] 1. 文件的概念 1.1 文件的概念和作用 计算机的 文件 ，就是存储在某种 长期储存设备 上的一段 数据 长期存储设备包括：硬盘、U 盘、移动硬盘、光盘... 文件的作用 将数据长期保存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-file.html</dc:identifier>
</item>
</channel>
</rss>