<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>编译虚拟机jvm——openjdk的编译 - 阿宝天天见</title>
<link>http://www.cnblogs.com/abaoge/p/7932612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abaoge/p/7932612.html</guid>
<description>&lt;p&gt;java只所以被推广，实际上很大原因是因为本身是跨平台的，很大作用是因为虚拟机的关系。&lt;/p&gt;
&lt;p&gt;一般情况下开发人员不需要关注虚拟机内部实现就可以日常开发了，但是有时候涉及到性能的时候就需要了解虚拟机的实现机制了。&lt;/p&gt;
&lt;p&gt;那么今天写的内容更多的是关于编译一套自己的虚拟机，为日后了解虚拟机底层原理铺铺路。&lt;/p&gt;
&lt;p&gt;编译虚拟机可能会遇到很多坑，也很花费时间。也因大家的环境的差异，可能遇到的问题都不一致。&lt;/p&gt;
&lt;p&gt;我只能说把自己遇到的问题都列出来，权当抛砖引玉了。&lt;/p&gt;
&lt;p&gt;1首先我们应该下载openjdk的源码，这个openjdk实际上是有一个版本历史的，大家可以去了解一下，&lt;/p&gt;
&lt;p&gt;  然后这里面的源码内容和oracle jdk内容大部分都是一致的，少数内容不一样。  &lt;/p&gt;
&lt;p&gt;  我这里下载的openjdk 源码是openjdk-7u75-src-b13-18_dec_2014.zip，每个人的版本可能不太一样，不过   是openjdk的源码就行。&lt;/p&gt;
&lt;p&gt;2除了上面的东西要准备，其实还要准备一个oracle的jdk，这个jdk我用的是jdk-6u32-linux-x64.bin。&lt;/p&gt;
&lt;p&gt;3然后是在linux上先准备好各种依赖，这些依赖获得方式待会儿会讲，另外要讲的是，我这里的linux系统&lt;/p&gt;
&lt;p&gt;  是ubuntu的 16.04LTS 64位的，所以之前的东西也最好都准备64位的。&lt;/p&gt;

&lt;p&gt;东西都准备好了，现在我们开干！！！！&lt;/p&gt;
&lt;p&gt;1如果之前你设置了java_home或者classpath环境变量，请先注释掉。&lt;/p&gt;
&lt;p&gt;2将openjdk-7u75-src-b13-18_dec_2014.zip解压后得到openjdk文件夹，我们把他放到/usr下。&lt;/p&gt;
&lt;p&gt;3执行jdk-6u32-linux-x64.bin，得到jdk1.6.0_32文件夹，我们讲这个文件夹放到/usr/java下。&lt;/p&gt;
&lt;p&gt;4输入vim /etc/profile，在最后加入如下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
export LANG=&lt;span&gt;C

#BootStrap&lt;/span&gt;-JDK的安装路径，替换为自己bootstrap-&lt;span&gt;JDK的路径

export ALT_BOOTDIR&lt;/span&gt;=/usr/java/jdk1.&lt;span&gt;6&lt;/span&gt;&lt;span&gt;.0_32

#同上，我之前使用的是openjdk编译的，后面运行hotspot时出现问题替换为oracleJDK，读者可以直接替换为OracleJDK

export ALT_JDK_IMPORT_PATH&lt;/span&gt;=/usr/java/jdk1.&lt;span&gt;6&lt;/span&gt;&lt;span&gt;.0_32

#规定几个线程来执行这个脚本
export HOTSPOT_BUILD_JOBS&lt;/span&gt;=&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
export ALT_PARALLEL_COMPILE_JOBS&lt;/span&gt;=&lt;span&gt;4&lt;/span&gt;&lt;span&gt;

#要编译的内容，读者可以根据需要自行选择

export BUILD_LANGTOOLS&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;

#export BUILD_JAXWS&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;

#export BUILD_JAXP&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;

#export BUILD_CORBA&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;

export BUILD_HOTSPOT&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;

export BUILD_JDK&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;

export SKIP_COMPARE_IMAGES&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;

BUILD_DEPLOY&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;

BUILD_INSTALL&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;

#编译结果存放的路径，建议存放在openjdk源码中build文件夹

export ALT_OUTPUTDIR&lt;/span&gt;=/usr/openjdk/&lt;span&gt;build

export ALLOW_DOWNLOADS&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;

#这两个环境变量需要去掉，不然会出问题

unset JAVA_HOME

unset CLASSPATH

make &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; | tee $ALT_OUTPUTDIR/build.log　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意的是需要source /etc/profile，以更新配置。但是输入后会马上跑起来，但是现在是不会成功的，因为依赖那些还没弄好。直接马上接着按ctrl+c以暂停。&lt;/p&gt;
&lt;p&gt;5在终端执行一些命令以安装必要的依赖，命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sudo apt-&lt;span&gt;get&lt;/span&gt; install build-essential gawk m4 libasound2-dev libcups2-dev libxrender-dev xorg-dev xutils-dev x11proto-print-dev binutils libmotif-common ant
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有些地方还安装了openjdk-6-jdk，其实这里不安装这个更好，我们用的是oracle的jdk来编译我们的openjdk源码，不建议用openjdk-6-jdk来编译openjdk源码，那也正是我build.sh脚本里面指向的jdk地址是export ALT_BOOTDIR=/usr/java/jdk1.6.0_32的原因。&lt;/p&gt;
&lt;p&gt;6现在我们到/usr/openjdk目录去执行make sanity命令，检查是否配置都没问题了。如果没有问题就会显示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1244747/201711/1244747-20171130195016758-745640298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7万事具备，只欠东风，输入make，开始编译，编译出的东西会生成在/usr/openjdk/build目录。&lt;/p&gt;
&lt;p&gt;流程就是这样的，不过期间会出现一些问题，根据他报的错我们要修正一些错误，修正之后再继续make命令接着编译。&lt;/p&gt;

&lt;p&gt;下面是我遇到的一些错误和解决办法。&lt;/p&gt;

&lt;p&gt;1&amp;gt;&lt;/p&gt;
&lt;p&gt;echo &quot;*** This OS is not supported:&quot; `uname -a`; exit 1;&lt;/p&gt;
&lt;p&gt;openjdk/hotspot/make/linux/Makefile:240: recipe for target 'check_os_version' failed&lt;/p&gt;
&lt;p&gt;解决：&lt;/p&gt;
&lt;p&gt;将/openjdk/hotspot/make/linux/Makefile中的check_os_version下面三行注释掉&lt;/p&gt;
&lt;p&gt;check_os_version:&lt;br/&gt;#ifeq ($(DISABLE_HOTSPOT_OS_VERSION_CHECK)$(EMPTY_IF_NOT_SUPPORTED),)&lt;br/&gt;# $(QUIETLY) &amp;gt;&amp;amp;2 echo &quot;*** This OS is not supported:&quot; `uname -a`; exit 1;&lt;br/&gt;#endif&lt;/p&gt;

&lt;p&gt;2&amp;gt;&lt;/p&gt;
&lt;p&gt;undefined reference to `void G1SATBCardTableModRefBS::write_ref_array_pre_work&amp;lt;oopDesc*&amp;gt;(oopDesc**, int)'&lt;/p&gt;
&lt;p&gt;解决：将hotspot/src/share/vm/gc_implementation/g1里的g1SATBCardTableModRefBS.cpp&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;template &amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;class T&amp;gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void G1SATBCardTableModRefBS::write_ref_array_pre_work(T* dst, &lt;span class=&quot;hljs-keyword&quot;&gt;int count) { &lt;span class=&quot;hljs-keyword&quot;&gt;if (!JavaThread::satb_mark_queue_set().is_active()) &lt;span class=&quot;hljs-keyword&quot;&gt;return; T* elem_ptr = dst; &lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; count; i++, elem_ptr++) { T heap_oop = oopDesc::load_heap_oop(elem_ptr); &lt;span class=&quot;hljs-keyword&quot;&gt;if (!oopDesc::is_null(heap_oop)) { enqueue(oopDesc::decode_heap_oop_not_null(heap_oop)); } } }内容下加上如下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;








&lt;p&gt;openjdk/jdk/src/share/classes/java/util/CurrencyData.properties文件中以下时间改成10年以内&lt;/p&gt;
&lt;p&gt;AZ=AZM;2005-12-31-20-00-00;AZN&lt;/p&gt;
&lt;p&gt;MZ=MZM;2006-06-30-22-00-00;MZN&lt;br/&gt;RO=ROL;2005-06-30-21-00-00;RON&lt;/p&gt;
&lt;p&gt;TR=TRL;2004-12-31-22-00-00;TRY&lt;/p&gt;
&lt;p&gt;VE=VEB;2008-01-01-04-00-00;VEF&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4&amp;gt;&lt;/em&gt;之后可能在编译RMIServerImpl_Stub.class的时候，很可能是内存不够了，因为我通过系统监视器观察得到这段时间内内存在暴增，具体原因也不知道，但是我连续几次在make命令重新来的时候，到最后一次&lt;/p&gt;
&lt;p&gt;又成功了。所以遇到这种情况这种情况可以多次重来。最后一次内存就没有暴增了。&lt;/p&gt;

&lt;p&gt;编译成功就是如下的样子了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244747/201711/1244747-20171130233335305-1233630891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;之后在build文件夹内就能找到你编译好的jdk。&lt;/p&gt;
&lt;p&gt;谢谢大家，有什么不明了的可以向我提问。&lt;/p&gt;

</description>
<pubDate>Thu, 30 Nov 2017 15:37:00 +0000</pubDate>
<dc:creator>阿宝天天见</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abaoge/p/7932612.html</dc:identifier>
</item>
<item>
<title>微信小程序与Java后台的通信 - 的川</title>
<link>http://www.cnblogs.com/dichuan/p/7932442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dichuan/p/7932442.html</guid>
<description>&lt;h2&gt;一、写在前面&lt;/h2&gt;
&lt;p&gt;最近接触了小程序的开发，后端选择Java，因为小程序的代码运行在腾讯的服务器上，而我们自己编写的Java代码运行在我们自己部署的服务器上，所以一开始不是很明白小程序如何与后台进行通信的，然后查找资料发现结合了官方提供的api后好像和我们普通的web前后端通信也没有多大的区别，有想法后就写了这个测试程序。&lt;/p&gt;
&lt;h2&gt;二、API文档&lt;/h2&gt;
&lt;h3&gt;wx.request(OBJECT)&lt;/h3&gt;
&lt;p&gt;发起网络请求。使用前请先阅读&lt;a href=&quot;https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-network.html&quot;&gt;说明&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;OBJECT参数说明：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数名&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;开发者服务器接口地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;data&lt;/td&gt;
&lt;td&gt;Object/String&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;请求的参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;header&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;设置请求的 header，header 中不能设置 Referer。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;method&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;（需大写）有效值：OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;dataType&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;json&lt;/td&gt;
&lt;td&gt;如果设为json，会尝试对返回的数据做一次 JSON.parse&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;success&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;收到开发者服务成功返回的回调函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;fail&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;接口调用失败的回调函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;complete&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;接口调用结束的回调函数（调用成功、失败都会执行）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;success返回参数说明：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.9202127659574&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;data&lt;/td&gt;
&lt;td&gt;Object/String&lt;/td&gt;
&lt;td&gt;开发者服务器返回的数据&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;statusCode&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;开发者服务器返回的 HTTP 状态码&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.8529411764706&quot;&gt;&lt;td&gt;header&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;开发者服务器返回的 HTTP Response Header&lt;/td&gt;
&lt;td&gt;&lt;a title=&quot;基础库 1.2.0 开始支持，低版本需做兼容处理。&quot; href=&quot;https://mp.weixin.qq.com/debug/wxadoc/dev/framework/compatibility.html&quot;&gt;1.2.0&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;data 数据说明：&lt;/p&gt;
&lt;p&gt;最终发送给服务器的数据是 String 类型，如果传入的 data 不是 String 类型，会被转换成 String 。转换规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于 &lt;code&gt;header['content-type']&lt;/code&gt; 为 &lt;code&gt;application/json&lt;/code&gt; 的数据，会对数据进行 JSON 序列化&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;header['content-type']&lt;/code&gt; 为 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 的数据，会将数据转换成 query string （encodeURIComponent(k)=encodeURIComponent(v)&amp;amp;encodeURIComponent(k)=encodeURIComponent(v)...）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wx.request({
  url: 'test.php', //仅为示例，并非真实的接口地址
&lt;span&gt;  data: {
     x: ''&lt;span&gt; ,
     y: ''&lt;span&gt;
  },
  header: {
      'content-type': 'application/json' // 默认值
&lt;span&gt;  },
  success: function&lt;span&gt;(res) {
    console.log(res.data)
  }
})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、基本思路&lt;/h2&gt;
&lt;p&gt;将数据通过get方式传到Java servlet类，servlet得到微信小程序的数据打印出来并返回一个数据给微信小程序，从而实现一个最简单的前后端通信。&lt;/p&gt;
&lt;h2&gt;四、关键代码&lt;/h2&gt;
&lt;p&gt;微信小程序代码&lt;/p&gt;
&lt;p&gt;index.wxml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &amp;lt;view&amp;gt;
  &amp;lt;button bindtap='bindtest'&amp;gt;test&amp;lt;/button&amp;gt;
  &amp;lt;/view&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
  bindtest: function&lt;span&gt;(){
    wx.request({
      url: 'http://localhost:8080/Demo01/servlet02'&lt;span&gt;,
      data:{
        username:'001'&lt;span&gt;,
        password:'abc'&lt;span&gt;
      },
      method:'GET'&lt;span&gt;,
      header: {
        'content-type': 'application/json' // 默认值
&lt;span&gt;      },
      success:function&lt;span&gt;(res){
        console.log(res.data);
&lt;span&gt;      },
      fail:function&lt;span&gt;(res){
        console.log(&quot;.....fail.....&quot;&lt;span&gt;);
      }
    })
  },&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Java serlvet类代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws&lt;span&gt; ServletException, IOException {
        // TODO Auto-generated method stub
&lt;span&gt;        
        response.setContentType(&quot;text/html;charset=utf-8&quot;&lt;span&gt;);          
        /* 设置响应头允许ajax跨域访问 */&lt;span&gt;  
        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;&lt;span&gt;);  
        /* 星号表示所有的异域请求都可以接受， */&lt;span&gt;  
        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET,POST&quot;&lt;span&gt;);  
       
        //获取微信小程序get的参数值并打印
        String username = request.getParameter(&quot;username&quot;&lt;span&gt;);
        String password = request.getParameter(&quot;password&quot;&lt;span&gt;);
        System.out.println(&quot;username=&quot;+username+&quot; ,password=&quot;+&lt;span&gt;password);
        
        //返回值给微信小程序
        Writer out =&lt;span&gt; response.getWriter(); 
        out.write(&quot;进入后台了&quot;&lt;span&gt;);
        out.flush();   
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、效果演示&lt;/h2&gt;
&lt;p&gt;前端控制台&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1262589/201711/1262589-20171130222949664-1097140093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ecplise控制台&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1262589/201711/1262589-20171130223036555-737498592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此说明微信小程序与Java后台通信成功！当然这是最简单的通信，比较复杂的是需要对Json数据的处理，以后有时间再总结下。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Nov 2017 15:28:00 +0000</pubDate>
<dc:creator>的川</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dichuan/p/7932442.html</dc:identifier>
</item>
<item>
<title>BST 解析 （一） - dog_tang</title>
<link>http://www.cnblogs.com/tangxiaobo199181/p/7929795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangxiaobo199181/p/7929795.html</guid>
<description>&lt;p&gt;这篇博文主要初步介绍Binary Search Tree(BST)的一些基本功能以及应用场景，由于BST的相关知识比较多，下一节会接着补充BST的一些功能。这一节主要分为以下六个要素：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;BST 的定义&lt;/li&gt;
&lt;li&gt;BST的应用场景&lt;/li&gt;
&lt;li&gt;BST searching 分析&lt;/li&gt;
&lt;li&gt;BST insertion 分析&lt;/li&gt;
&lt;li&gt;最大值/最小值的查找&lt;/li&gt;
&lt;li&gt;Next Larger Key的分析&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一：BST的定义&lt;/p&gt;
&lt;p&gt;invariant:&lt;/p&gt;
&lt;p&gt;BST是对于任意的node x，如果node y是node x的左边的节点, 那么Key(y) &amp;lt;= Key(x); 对于任意的node x， 如果node y 是node x的右边的节点， 那么key(y)&amp;gt;=key(x).&lt;/p&gt;
&lt;p&gt;下图是一个BST结构的example：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201711/1287224-20171130195602945-1677022482.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意上面的树状结构和Heap很相似，但其实他们是有非常大的本质区别的；heap的结构本质是array，每一个node本身是没有一个指向children和parent的pointer的。然而BST的每一个node都是包含有指向它的children和parent的pointer。 BST中的node的C++的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node{
    
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key;
    Node &lt;/span&gt;*&lt;span&gt;left;
    Node &lt;/span&gt;*&lt;span&gt;right;
    Node &lt;/span&gt;*&lt;span&gt;parent;
    
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;constructor&lt;/span&gt;
&lt;span&gt;    Node();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key set &amp;amp; get&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; setKey(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; innerKey);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getKey();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;left child pointer's get &amp;amp; set&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; setLeft(Node *&lt;span&gt;innerLeft);
    Node &lt;/span&gt;*&lt;span&gt; getLeft();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;right child pointer's get &amp;amp; set&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; setRight(Node *&lt;span&gt;innerRight);
    Node &lt;/span&gt;*&lt;span&gt;getRight();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;parent pointer's get &amp;amp; set&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; setParent(Node *&lt;span&gt;innerParent);
    Node &lt;/span&gt;*&lt;span&gt;getParent();
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;二：BST的应用场景&lt;/p&gt;
&lt;p&gt;例如比赛场馆的预订这个案例中，要求预订的时间前后一个小时这个场馆并没有被其他人预订；在这个案例中，我的预订时间前面之前的被别人预订过的时间肯定小于我的预订时间， 而后面的预订时间肯定大于我的预订时间， 如果想成功预订还得继续比较他们的中间时间差是否大于1小时。为了更好的描述这个案例， 我用下面的图示来帮助说明：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201711/1287224-20171130201708148-1868973284.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面这就是一个典型的BST的案例，虽然我是用一个一维的coordinate表示，但其本质就是一个BST。&lt;/p&gt;

&lt;p&gt;三：BST searching 分析&lt;/p&gt;
&lt;p&gt;如果有-个BST的数据结构，让我们找一个key，那么这个过程是怎样的呢？首先第一步从root开始比较，如果小于root的key则跟left child比较，否则跟right child接着比较；如此递归下去直到找到我们的key或者一直到了BST的leaf。如果找到key，则返回这个key；如果一直到了leaf都没有找到，则说明这个key根本就不在这个BST，返回NULL。这个过程是一直比较的过程，所有步骤中的basic operation都是比较的话，称之为Comparison Model. 下面两符图分别展示了返回key和返回NULL 的2中情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201711/1287224-20171130200635883-1137876224.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;下面代码的过程是用C++实现BST 的searching的过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *Description: search(int key) is publically invoked, in order to search the key in the BST
 *
 *parameters:
            1. key //the value which we want to find within the BST
 *
 *return void
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Node &lt;/span&gt;*BST::search(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key){
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;-&amp;gt;root == NULL) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;the BST has not initialzed yet&lt;/span&gt;
        
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
        
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; search(key, &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;root);
    }
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *Description: recuresivly to search the key, the work starts from root and level by level down to leaf, if fails to find out, return NULL.
 *
 *
 *parameters:
 *           1: key//value which should be searched
 *           2: node//this is the node the the key compares with
 *
 *return Node *
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Node&lt;/span&gt;* BST::search(&lt;span&gt;int&lt;/span&gt; key, Node *&lt;span&gt;node){
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node==NULL) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;we have found all the nodes, but no one matches, which means it is not within the BST&lt;/span&gt;
     
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
        
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key == node-&amp;gt;getKey()) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;we spot on the key, return the node&lt;/span&gt;
            
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
            
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;lt; node-&amp;gt;getKey()){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;the key is smaller than the node, so it is must be in the left subtree.&lt;/span&gt;
            
        &lt;span&gt;return&lt;/span&gt; search(key, node-&amp;gt;&lt;span&gt;getLeft());
            
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the key is bigger than the node, so it is must be in the right subtree.&lt;/span&gt;
            
        &lt;span&gt;return&lt;/span&gt; search(key, node-&amp;gt;&lt;span&gt;getRight());
            
    }

} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据以上的步骤的分析，BST search的worst case efficiency = height of BST, 即efficiency = O(h), h 是指BST的高度，注意这里的h不像Heap那样是logN哦，这里的h是一个介于logN和N之间的一个值；当然了我们可以通过BST的balancing过程将BST的高度都转换成logN，但这一块比较复杂需要在后面讲解。现在我们只需要知道是BST的height就行。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;四：BST 的insertion分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果希望向BST插入一个node （称为A），并且继续保持BST的结构，则需要通过以下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从root开始比较，如果A的key小于node，则跟node的left child接着比较，如果大于等于node的key，则跟node的right child的key接着比较；一直比较到leaf为止&lt;/li&gt;
&lt;li&gt;如果A的key值小于leaf的值，则将node A 插入到当前leaf的左边，否则插入node的右边；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其具体的图示过程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201711/1287224-20171130205601523-561041643.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;insertion的c++实现过程如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *insert(int key) is publically invoked, and the key could be inserted at proper position
 *
 *parameters:
            1. key //the value of an node
 
 *
 *return void
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; BST::insert(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key){
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;-&amp;gt;root != NULL) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;The BST has already intialized, so we need to compare the keys level by level according to the BST critirals.
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;we gonna start from the root node to compare values until we find a leaf&lt;/span&gt;
        insert(key, &lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;root);
        
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        
        Node &lt;/span&gt;*rootNode = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;root =&lt;span&gt; rootNode;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;root-&amp;gt;&lt;span&gt;setKey(key);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;root-&amp;gt;&lt;span&gt;setLeft(NULL);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;root-&amp;gt;&lt;span&gt;setRight(NULL);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;-&amp;gt;root-&amp;gt;&lt;span&gt;setParent(NULL);
        
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *Description: recuresivly to find where the key should be inserted, the work starts from root and level by level down to leaf
 *
 *CAUTION: WE DO NOT DISCUSS DUPLICATE KEYS HERE
 *
 *parameters:
 *           1: key//value which should be inserted
 *           2: node//this is the node the the key compares with
 *
 *return void
 *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; BST::insert(&lt;span&gt;int&lt;/span&gt; key, Node *&lt;span&gt;node){
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key&amp;lt;node-&amp;gt;getKey()) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;indicates that the key should be in the left side of node;&lt;/span&gt;
        
        &lt;span&gt;if&lt;/span&gt; (node-&amp;gt;getLeft()!=NULL) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;node's left child is not null, so we need to down to search&lt;/span&gt;
&lt;span&gt;            
            insert(key, node&lt;/span&gt;-&amp;gt;&lt;span&gt;getLeft());
            
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;node is a leaf, we have hit the spot&lt;/span&gt;
&lt;span&gt;            
            Node &lt;/span&gt;*newNode = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
            newNode&lt;/span&gt;-&amp;gt;&lt;span&gt;setKey(key);
            newNode&lt;/span&gt;-&amp;gt;&lt;span&gt;setLeft(NULL);
            newNode&lt;/span&gt;-&amp;gt;&lt;span&gt;setRight(NULL);
            newNode&lt;/span&gt;-&amp;gt;&lt;span&gt;setParent(node);
            node&lt;/span&gt;-&amp;gt;&lt;span&gt;setLeft(newNode);
           
            
        }
        
        
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;gt; node-&amp;gt;getKey()){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;indicates that the key should be in the right side of node;&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (node-&amp;gt;getRight()!=NULL) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;node's right child is not null, so we need to search down&lt;/span&gt;
&lt;span&gt;            
            insert(key, node&lt;/span&gt;-&amp;gt;&lt;span&gt;getRight());
            
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;node is a leaf, spot on&lt;/span&gt;
&lt;span&gt;            
            Node &lt;/span&gt;*newNode = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
            newNode&lt;/span&gt;-&amp;gt;&lt;span&gt;setKey(key);
            newNode&lt;/span&gt;-&amp;gt;&lt;span&gt;setLeft(NULL);
            newNode&lt;/span&gt;-&amp;gt;&lt;span&gt;setRight(NULL);
            newNode&lt;/span&gt;-&amp;gt;&lt;span&gt;setParent(node);
            node&lt;/span&gt;-&amp;gt;&lt;span&gt;setRight(newNode);
            
        }
        
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的过程和BST的search很类似，也是通过不断的比较，只是在最后在leaf后面插入一个元素，找到leaf后插入的动作可以看做是常量O(1)。那么insertion 的时间复杂度是：efficiency = O（h）+O（1）=O（h）; 所以它同样是BST的高度height。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;五：最值的查找&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于BST自身特点和结构，我们其实非常容易就可以找到最大值和最小值的。由于BST中比当前node小的node始终在左边，而比当前node大的node始终在自己的右边。所以我们就可以从root开始一直开始遍历node的left child，知道leftchild等于nil为止，那么就说明这个node就是最小值；相反如果找最大值，就一直找node的right child，直到right child为nil为止。其具体的图例和实现过程如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201711/1287224-20171130213121539-1564111638.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *Description: The function is to find out the minimum key node within the subtree rooted at self
 *
 *
 *parameters: void
 *
 *
 *return: node;//the minimum node
 *
 *
 ****&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Node &lt;/span&gt;*&lt;span&gt; Node::findMin(){
    
    Node &lt;/span&gt;*currentNode = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (currentNode-&amp;gt;getLeft() !=&lt;span&gt; NULL) {
        
        currentNode &lt;/span&gt;= currentNode-&amp;gt;&lt;span&gt;getLeft();
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; currentNode;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最值的寻找的时间复杂度同样是这个BST的高度height，即O(h);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;六：next larger/smaller 分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;next larger 是指比某个node A 大的值，但是比所有其他大于node A的nodes 都要小；比较绕口，其实本质就是在所有比node A 大的集合中，key值最接近node A 的哪一个node。同理可知next smaller的含义。那么在BST中如何寻找一个node的next larger或者next smaller呢？看下图展示寻找next larger的过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201711/1287224-20171130225558836-702481167.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;根据以上寻找next larger的图示，可以总结出以下2条规律：&lt;/p&gt;
&lt;p&gt;1. 如果node有right subtree，那么这个node的next larger就是它的right subtree的最小值&lt;/p&gt;
&lt;p&gt;2.如果node没有subtree, 那么这个node的next larger就需要一直的往parent node traversal, 直到node 是 它的left children tree的一个节点为止。&lt;/p&gt;
&lt;p&gt;那么它的worst case的时间复杂度同样是0（h）。&lt;/p&gt;
&lt;p&gt;next larger的实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *
 *Description: this function's aim is to find the next next of this node
 *
 *
 *parameters: void
 *
 *
 *return: Node// the next larger node
 *
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Node&lt;/span&gt;*&lt;span&gt; Node::findNextLarger(){
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;-&amp;gt;getRight() == NULL) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this node does not have any right subtree&lt;/span&gt;
&lt;span&gt;        
        Node &lt;/span&gt;*tempNode = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (tempNode-&amp;gt;getParent()-&amp;gt;getLeft() !=&lt;span&gt; tempNode) {
            
            
            tempNode &lt;/span&gt;= tempNode-&amp;gt;&lt;span&gt;getParent();
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tempNode == NULL) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;no next larger value exsits&lt;/span&gt;
                
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
            }
            
        }
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tempNode-&amp;gt;&lt;span&gt;getParent();
        
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this node does have a right subtree&lt;/span&gt;
        
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;-&amp;gt;getRight()-&amp;gt;findMin();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return the right subtree's minimun key&lt;/span&gt;
&lt;span&gt;        
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么这章的BST(一)的内容就结束了，那么这里还有几个小问题哈，从头到尾我们没有分析BST的height具体是多少，也没有介绍delete node的过程，下一节我会分析这2块。&lt;/p&gt;
&lt;p&gt;如果有什么文件，欢迎大家指教。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Nov 2017 15:01:00 +0000</pubDate>
<dc:creator>dog_tang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tangxiaobo199181/p/7929795.html</dc:identifier>
</item>
<item>
<title>从CentOS安装完成到生成词云python学习日记 - wcctml</title>
<link>http://www.cnblogs.com/wcctml/p/7932325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wcctml/p/7932325.html</guid>
<description>&lt;p&gt;欢迎访问我的个人博客:&lt;a href=&quot;http://www.keepstan.ga/index.php/python/15.html&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;人生苦短，我用python。学习python怎么能不搞一下词云呢是不是(ง •̀_•́)ง&lt;br/&gt;于是便有了这篇边实践边记录的笔记。&lt;/p&gt;
&lt;p&gt;环境：VMware 12pro + CentOS7 + Python 2.7.5&lt;/p&gt;
&lt;h2 id=&quot;安装系统&quot;&gt;安装系统&lt;/h2&gt;
&lt;p&gt;之前一直用的是win10子系统，现在试试CentOS，CentOS官网下载最新系统dvd版 安装到VMware 12pro。网上很多教程。例如这个&lt;a href=&quot;https://jingyan.baidu.com/article/a3f121e4b18b74fc9052bb14.html&quot;&gt;链接&lt;/a&gt;。等待安装完成后开始。&lt;/p&gt;
&lt;h2 id=&quot;第一个命令&quot;&gt;第一个命令&lt;/h2&gt;
&lt;p&gt;用Ubuntu的时候没有的命令会提示你安装，感觉很简单的事。但是到CentOS上却变得很头痛。&lt;/p&gt;
&lt;p&gt;打开终端在执行以下命令安装python-pip时提示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo yum install python-pip

没有可用软件包 python-pip。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;google了一下说是这个包在EPEL源里，要添加EPEL源才可以。&lt;br/&gt;执行下面两个命令就安装好了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install epel-release.noarch 

yum install python-pip&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;python库安装&quot;&gt;python库安装&lt;/h2&gt;
&lt;p&gt;接下来安装一个词云&lt;strong&gt;wordcloud&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install -i https://pypi.tuna.tsinghua.edu.cn/simple wordcloud

截取部分提示错误信息 
unable to execute gcc: No such file or directory
error: command 'gcc' failed with exit status 1

连gcc都没有(ง •̀_•́)ง。先安装gcc
yum install gcc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;gcc装完后继续安装wordcloud!又报了下面的错误&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_posixsubprocess.c:3:20: 致命错误：Python.h：没有那个文件或目录

于是需要先安装python-devel

sudo yum install python-devel　　#注意这里不是python-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CentOS 下叫做 &lt;strong&gt;python-devel&lt;/strong&gt;，Ubuntu 下还是叫做 &lt;strong&gt;python-dev&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;wordcloud安装完毕&lt;/strong&gt;！&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;p&gt;生成词云一份代码，并且随便找一份英文（我在ChinaDaily找的文章 &lt;a href=&quot;http://www.chinadaily.com.cn/china/2017-11/28/content_35086176.htm&quot;&gt;Recruiters starting to employ social media&lt;/a&gt; 放到 txt/word.txt中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding: UTF-8 -*-
import matplotlib
# Force matplotlib to not use any Xwindows backend.
#matplotlib.use('Agg')

from wordcloud import WordCloud

textfile = open(u'txt/word.txt','r').read()
wordcloud = WordCloud(background_color=&quot;white&quot;,width=800, height=600, margin=5).generate(textfile)

# width,height,margin可以设置图片属性
# generate 可以对全部文本进行自动分词,但是它对中文支持不好
#background_color参数为设置背景颜色,默认颜色为黑色

wordcloud.to_file('word.png')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行命令运行 python clouddemo.py 报错提示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SyntaxError: Non-ASCII character '\xe5' in file clouddemo.py on line 6, 
but no encoding declared; see http://www.python.org/peps/pep-0263.html for details&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;原因如下&quot;&gt;原因如下&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Python默认是以ASCII作为编码方式的，如果在Python源码中包含了中文（或者其他非英语系的语言），此时即使你把自己编写的Python源文件以UTF-8格式保存，但实际上，这依然是不行的。&lt;br/&gt;解决办法很简单，只要在文件开头加入下面代码；指定文件的编码格式为utf-8。上面的代码我已经加好了(。・`ω´・)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding: UTF-8 -*-  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编码问题解决了。接下来重新运行。&lt;br/&gt;还是报错！！！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ImportError: No module named Tkinter&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先yum list installed | grep ^tk&lt;br/&gt;查看是否存在相应模块，如果不存在则通过yum install tkinter 和yum install -y tk-devel下载相应模块。&lt;/p&gt;
&lt;p&gt;重新执行命令提示下一个错误&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_tkinter.TclError: no display name and no $DISPLAY environment variable
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然一波N折，但是最后还是成功了！！！看看源代码目录下的词云图！&lt;br/&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://orqvlsr1d.bkt.clouddn.com/word.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 Nov 2017 14:51:00 +0000</pubDate>
<dc:creator>wcctml</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wcctml/p/7932325.html</dc:identifier>
</item>
<item>
<title>从MVC到Ajax再到前后端分离的思考 - 窗外天空晴朗</title>
<link>http://www.cnblogs.com/young-z/p/7923693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/young-z/p/7923693.html</guid>
<description>[unable to retrieve full-text content]前言 一位小妹去面试前端，前端leader问了&quot;什么是ajax？&quot;，答：“接收后台的数据，然后然后自己填充和渲染样式”；一位小哥去面试后台，技术经理问了“什么是ajax？”，答：“在不需重新加载整个网页的情况下，发送异步请求，返回json数据给前端”。准确答案到底是什么？Ajax到底属于前端还是属于</description>
<pubDate>Thu, 30 Nov 2017 14:44:00 +0000</pubDate>
<dc:creator>窗外天空晴朗</dc:creator>
<dc:identifier>http://www.cnblogs.com/young-z/p/7923693.html</dc:identifier>
</item>
<item>
<title>react入门到进阶（一） - 宣火鱼竹</title>
<link>http://www.cnblogs.com/firefish1/p/7905015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/firefish1/p/7905015.html</guid>
<description>&lt;h3 id=&quot;一何为react&quot;&gt;一、何为react&lt;/h3&gt;
&lt;p&gt;Facebook在F8会议上首次提出这个概念，一套全新的框架就此诞生。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;React 不是一个完整的 MVC、MVVM 框架，其只负责 View 层&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;React 跟 Web Components 不冲突&lt;/li&gt;
&lt;li&gt;React 的特点就是“轻”，数据单向绑定，独立、小巧、快速、创新&lt;/li&gt;
&lt;li&gt;组件化的开发思路，小组件构成大组件，高度可重用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而react则广泛应用于&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;复杂场景下的高性能&lt;/li&gt;
&lt;li&gt;重用组件库，组件组合&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;二react组件基础&quot;&gt;二、react组件基础&lt;/h3&gt;
&lt;h4 id=&quot;react虚拟dom概念&quot;&gt;1、react虚拟dom概念&lt;/h4&gt;
&lt;p&gt;当一个数据改变时，而你又需要将它实时反应到UI上时，你就需要对&lt;strong&gt;DOM&lt;/strong&gt;进行操作，但是复杂或频繁的&lt;strong&gt;DOM&lt;/strong&gt;操作通常是性能瓶颈产生的原因，于是我们在&lt;strong&gt;app源码&lt;/strong&gt;和&lt;strong&gt;DOM&lt;/strong&gt;之间加入了虚拟DOM（Virtual DOM）。&lt;br/&gt;所以在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为&lt;code&gt;virtual DOM&lt;/code&gt;。&lt;br/&gt;虚拟DOM是React的一大亮点，具有&lt;strong&gt;batching(批处理)&lt;/strong&gt;和高效的&lt;strong&gt;Diff算法&lt;/strong&gt;。&lt;em&gt;这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面&lt;/em&gt;，由虚拟 DOM来确保只对界面上真正变化的部分进行实际的DOM操作。如果没有 &lt;code&gt;Virtual DOM&lt;/code&gt;，简单来说就是直接重置 innerHTML。这样操作，在一个大型列表所有数据都变了的情况下，还算是合理，但是，当只有一行数据发生变化时，它也需要重置整个 innerHTML，这时候显然就造成了大量浪费。&lt;/p&gt;
&lt;h4 id=&quot;react组件&quot;&gt;2、react组件&lt;/h4&gt;
&lt;p&gt;先来个小例子看看什么是react组件，创建一个js文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import React from 'react';
import ReactDom  from 'react-dom';

export default class ComponentHeader extends React.Component{
  render(){
    return(
      &amp;lt;header&amp;gt;
        &amp;lt;h1&amp;gt;yondu is a good father&amp;lt;/h1&amp;gt;
      &amp;lt;/header&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个文件就创建了一个名为&lt;code&gt;ComponentHeader&lt;/code&gt; 的组件，值得注意的是&lt;code&gt;export default&lt;/code&gt;是可以让这个组件外用。&lt;/p&gt;
&lt;p&gt;然后我们在一个项目的入口文件里引用这个组件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var React = require('react');
var ReactDOM = require('react-dom');
import ComponentHeader from './components/header';//组件文件的相对位置

class Index extends React.Component {
    render(){
        return(
            &amp;lt;ComponentHeader/&amp;gt;
        );
    }
}//创建可以用ComponentHeader组件的组件Index
    ReactDOM.render(&amp;lt;Index/&amp;gt;,document.getElementById('example'));//把你创建的组件在id为example的dom中使用&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然在&lt;code&gt;render&lt;/code&gt;中，你也可以用一个参数的形式，它的作用是可以用于判断，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var component = &amp;lt;ComponentHeader/&amp;gt;//在render中，就可以直接用component代替&amp;lt;ComponentHeader/&amp;gt;
//所以可以有以下形式
if(ture){
    component = &amp;lt;ComponentHeader/&amp;gt;
}
else{
    component = &amp;lt;ComponentFooter/&amp;gt;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上例子就是创建一个组件然后使用的过程，需要注意的地方是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;组件的&lt;code&gt;return&lt;/code&gt;函数里返回的html节点只能是一个，如有多个，可以在外面包一个&lt;code&gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果想让组件外用，加上&lt;code&gt;export default&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;jsx内置表达式&quot;&gt;3、JSX内置表达式&lt;/h4&gt;
&lt;p&gt;三元表达式是JSX里面经常使用的一种语法，我们先来看一看&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;render(){
    var text=&quot;不为空&quot;;
    return(
        &amp;lt;p&amp;gt;{text == &quot;&quot; ？ &quot;内容为空&quot; : &quot;内容为&quot;+text}/p&amp;gt;
    )
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先表达式要用&lt;code&gt;{}&lt;/code&gt;包裹，然后三元表达式主要是看三元运算符，语法是 &lt;strong&gt;条件 ? 结果1 : 结果2&lt;/strong&gt;;. 这里你把条件写在问号(?)的前面后面跟着用冒号(:)分隔的结果1和结果2。满足条件时结果1否则结果2。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(b == 5) ? a=&quot;true&quot; : a=&quot;false&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在JSX中用动态绑定时，参数需要用&lt;code&gt;{}&lt;/code&gt;包裹，而且外面不需要用引号，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;render(){
    var bool=true;
    var name=&quot;点一下&quot;;
    return(
        &amp;lt;input type=&quot;button&quot; value={name} disabled={bool}&amp;gt;
    )
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JSX中的注释是这样&lt;code&gt;{/*注释*/}&lt;/code&gt;的形式&lt;/p&gt;
&lt;h4 id=&quot;生命周期&quot;&gt;4、生命周期&lt;/h4&gt;
&lt;p&gt;可以利用生命周期函数做到钩子函数（Hook）的很多功能&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;列表项&lt;/li&gt;
&lt;li&gt;component instantiated 组件初始化
&lt;ul&gt;&lt;li&gt;getDefaultProps( ) 获取默认属性的生命周期函数&lt;/li&gt;
&lt;li&gt;getInitialState( ) 获取初始化&lt;code&gt;State&lt;/code&gt;的函数&lt;/li&gt;
&lt;li&gt;componentWillMount( ) 组件将要加载&lt;/li&gt;
&lt;li&gt;render( ) 渲染&lt;/li&gt;
&lt;li&gt;componentDidMount( ) 组件加载完毕（第一次render( )完毕后）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;props changed 属性更改
&lt;ul&gt;&lt;li&gt;componentWillReceiveProps( )&lt;/li&gt;
&lt;li&gt;shouldComponentUpdate( )&lt;/li&gt;
&lt;li&gt;componentWillUpdate( ) 组件将要更新&lt;/li&gt;
&lt;li&gt;render( )&lt;/li&gt;
&lt;li&gt;componentDidUpdate( ) 组件更新完毕（第一次render( )完毕，等组件加载完毕）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;setState( )&lt;/li&gt;
&lt;li&gt;component deleted
&lt;ul&gt;&lt;li&gt;componentWillUnmount( ) 组件卸载函数 （第一次render( )完毕，等组件更新完毕）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们可以看看&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var React = require('react');
var ReactDOM = require('react-dom');
import ComponentHeader from './components/header';

class Index extends React.Component {
    componentWillMount(){
        //直接写逻辑
        console.log(&quot;Index组件将要加载的时间&quot;);
    }
    render(){
        return(
            &amp;lt;ComponentHeader/&amp;gt;
        );
    }
    componentDidMount(){
        //直接写逻辑
        console.log(&quot;Index组件加载完毕的时间&quot;);
    }
}
ReactDOM.render(&amp;lt;Index/&amp;gt;,document.getElementById('example'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生命周期函数的运用如上就可见一斑了。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Nov 2017 14:42:00 +0000</pubDate>
<dc:creator>宣火鱼竹</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/firefish1/p/7905015.html</dc:identifier>
</item>
<item>
<title>机器视觉 之 三个坐标系 - 胡马依北风</title>
<link>http://www.cnblogs.com/xinxue/p/7597897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinxue/p/7597897.html</guid>
<description>&lt;p&gt;  机器视觉中，有三个常用的坐标系：图像坐标系、相机坐标系和世界坐标系。它们之间的转换关系，是三维重构几何框架的基础。&lt;/p&gt;
&lt;p&gt;  本文主要介绍，这三个坐标系的定义和转换关系，最后，通过这些转换关系，将&lt;span&gt;三维空间&lt;/span&gt;中的&lt;span&gt;点坐标&lt;/span&gt; (Xw, Yw, Zw)，与&lt;span&gt;二维图像&lt;/span&gt;中的&lt;span&gt;像素坐标&lt;/span&gt; (u, v) 对应起来。&lt;/p&gt;

&lt;p&gt;  图像坐标系，是以二维图像为基准所建立的坐标系。根据单位的不同，可分为 &lt;span&gt;像素坐标 &lt;span&gt;(单位 = 像素个数) 和 &lt;span&gt;物理尺寸坐标 &lt;span&gt;(单位 = mm)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.1  分类&lt;/h2&gt;
&lt;p&gt;  像素坐标 (u, v) 中，&lt;span&gt;&lt;span&gt;原点 &lt;span&gt;为图像左上角点，&lt;span&gt;坐标轴&lt;/span&gt; &lt;span&gt;为 u 轴 和 v 轴，表示物体所在的&lt;span&gt;行数和列数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  物理尺寸坐标 (x, y) 中，&lt;span&gt;原点 &lt;span&gt;为图像的主点，也即光轴与像平面的交点，&lt;span&gt;坐标轴&lt;/span&gt; 为 x 轴 (平行 u 轴) 和 y 轴 (平行 v 轴)，表示物体的&lt;span&gt;尺寸大小&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;http://images2017.cnblogs.com/blog/890227/201709/890227-20170927192655919-636960203.jpg&quot; alt=&quot;&quot; width=&quot;226&quot; height=&quot;182&quot;/&gt;  &lt;/p&gt;
&lt;h2&gt;1.2  转换关系&lt;/h2&gt;
&lt;p&gt;　假设每一个像素，&lt;span&gt;在 x 轴和 y 轴 方向上的&lt;span&gt;物理尺寸&lt;/span&gt;为 dx 和 dy&lt;/span&gt;，则在&lt;span&gt;忽略相机成像畸变&lt;/span&gt;的情况下，&lt;span&gt;像素坐标&lt;/span&gt;和&lt;span&gt;物理尺寸坐标&lt;/span&gt;的&lt;span&gt;转换关系&lt;/span&gt;如下：&lt;/p&gt;
&lt;p&gt;　$\begin{cases} u = \dfrac{x}{d_{x}} + u_{0} \\ v = \dfrac{y}{d_{y}} + v_{0} \end{cases} $ &lt;/p&gt;
&lt;p&gt;　两者的&lt;span&gt;齐次坐标&lt;span&gt;转换关系&lt;/span&gt;&lt;/span&gt;为：&lt;/p&gt;
&lt;p&gt;   $\begin{bmatrix} u \\ v \\ 1 \end{bmatrix} = \begin{bmatrix} \dfrac{1}{d_{x}} &amp;amp; 0 &amp;amp; u_{0} \\ 0 &amp;amp; \dfrac{1}{d_{y}} &amp;amp; v_{0} \\ 0 &amp;amp; 0 &amp;amp; 1 \end{bmatrix} \begin{bmatrix} x\\ y \\ 1 \end{bmatrix} $&lt;/p&gt;


&lt;p&gt;　相机坐标系 $(Xc, Yc, Zc)$中，&lt;span&gt;原点&lt;/span&gt; 为相机透镜的中心，&lt;span&gt;坐标轴&lt;/span&gt; Xc 轴与 x 轴平行，Yc 轴与 y 轴平行，Zc 轴与相机光轴重合&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;http://images2017.cnblogs.com/blog/890227/201709/890227-20170928212833278-1727583947.jpg&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    设相机的焦距为 f，则根据小孔成像模型，可知&lt;span&gt;&lt;span&gt;相机坐标系下&lt;span&gt;空间点&lt;/span&gt;&lt;/span&gt; $(Xc, Yc, Zc)$，与&lt;/span&gt;&lt;span&gt;物理尺寸坐标&lt;/span&gt; $(x, y)$ 的关系如下：&lt;/p&gt;
&lt;p&gt;    $\begin{cases} \dfrac{x}{f} = \dfrac{X_{c}}{Z_{c}} \\ \dfrac{y}{f} = \dfrac{Y_{c}}{Z_{c}} \end{cases} $  =&amp;gt;  $\begin{cases} Z_{c} \cdot x = f \cdot {X_{c}} \\ Z_{c} \cdot y = f \cdot {Y_{c}} \end{cases} $    =&amp;gt;    $ Z_{c} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix} = \begin{bmatrix} f &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; f &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \end{bmatrix} \begin{bmatrix} X_{c} \\ Y_{c} \\ Z_{c} \\ 1 \end{bmatrix} $&lt;/p&gt;
&lt;p&gt;   像素坐标 $(u, v)$ 与相机坐标点 $(Xc, Yc, Zc)$ 的关系为：&lt;/p&gt;
&lt;p&gt;    $ Z_{c} \begin{bmatrix} u \\ v \\ 1 \end{bmatrix} = \begin{bmatrix} \dfrac{1}{d_{x}} &amp;amp; 0 &amp;amp; u_{0} \\ 0 &amp;amp; \dfrac{1}{d_{y}} &amp;amp; v_{0} \\ 0 &amp;amp; 0 &amp;amp; 1 \end{bmatrix} \begin{bmatrix} f &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; f &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \end{bmatrix} \begin{bmatrix} X_{c} \\ Y_{c} \\ Z_{c} \\ 1 \end{bmatrix} = \begin{bmatrix} \dfrac{f}{d_{x}} &amp;amp; 0 &amp;amp; u_{0} \\ 0 &amp;amp; \dfrac{f}{d_{y}} &amp;amp; v_{0} \\ 0 &amp;amp; 0 &amp;amp; 1 \end{bmatrix}  \begin{bmatrix} X_{c} \\ Y_{c} \\ Z_{c} \\ 1 \end{bmatrix}$&lt;/p&gt;


&lt;p&gt;  &lt;span&gt;世界坐标系，是实际物体位置的参考系，&lt;/span&gt;从 &lt;span&gt;世界坐标系 &lt;span&gt;转换为&lt;/span&gt;&lt;/span&gt; &lt;span&gt;相机坐标系 &lt;span&gt;的过程，可视为刚体变换，具体&lt;/span&gt;&lt;/span&gt;见 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/xinxue/p/7513192.html&quot;&gt;机器视觉 之 刚体变换&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;   $ \begin{bmatrix} X_{c} \\ Y_{c} \\ Z_{c} \\  1 \end{bmatrix} = \begin{bmatrix} R &amp;amp; T \\ 0^{T} &amp;amp; 1 \end{bmatrix} \begin{bmatrix} X_{w} \\ Y_{w} \\ Z_{w} \\ 1 \end{bmatrix}$&lt;/p&gt;
&lt;p&gt;  这样，就建立了图像中的 像素点 (u, v) 和 世界坐标中的 空间点 (Xw, Yw, Zw) 之间的对应关系。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;span&gt;世界坐标系&lt;/span&gt;，可根据运算的方便自由放置。若世界坐标系和相机坐标系重合，则 $R$ 为单位矩阵，$T$ 为零矩阵，即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   $ \begin{bmatrix} X_{c} \\ Y_{c} \\ Z_{c} \end{bmatrix} = \begin{bmatrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \end{bmatrix} \begin{bmatrix} X_{w} \\ Y_{w} \\ Z_{w} \end{bmatrix}$&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;  表面上看，像素点 (u, v)， 通过相机内参 A，转换为相机坐标下的 (Xc, Yc, Zc)，再经过 $RT$ 变换，便可得到世界坐标下的 (Xw, Yw, Zw)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   $ Z_{c} \begin{bmatrix} u \\ v \\ 1 \end{bmatrix} = \begin{bmatrix} \dfrac{f}{d_{x}} &amp;amp; 0 &amp;amp; u_{0} \\ 0 &amp;amp; \dfrac{f}{d_{y}} &amp;amp; v_{0} \\ 0 &amp;amp; 0 &amp;amp; 1 \end{bmatrix}  \begin{bmatrix} R &amp;amp; T \\ 0^{T} &amp;amp; 1 \end{bmatrix} \begin{bmatrix} X_{w} \\ Y_{w} \\ Z_{w} \\ 1 \end{bmatrix}$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  实际上，这有两个问题：  一是，决定远近的 &lt;span&gt;Zc&lt;/span&gt; 未知； 二是，成像物体的&lt;span&gt;特征&lt;/span&gt;未知。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  工程中，解决这两个问题的一个方法是：加&lt;span&gt;光学投射器&lt;/span&gt;，组成&lt;span&gt;结构光&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  光学投射器，投射出具有固定特征的光模式 (例如光线、光平面、光栅或光网格等)；当打在物体表面上，可对物体在空间的位置进行约束；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  之后，再经过上述的坐标变换，便可得到物体对应点的唯一坐标值。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; 参考资料&lt;/h2&gt;
&lt;p&gt;     &amp;lt;视觉测量&amp;gt; 张广军，第2章，第 7章&lt;/p&gt;

</description>
<pubDate>Thu, 30 Nov 2017 14:36:00 +0000</pubDate>
<dc:creator>胡马依北风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinxue/p/7597897.html</dc:identifier>
</item>
<item>
<title>JAVAFX-4 开发应用 - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/7932241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/7932241.html</guid>
<description>&lt;h2 id=&quot;javafx-形状&quot;&gt;JavaFx 形状&lt;/h2&gt;
&lt;ul readability=&quot;1.42280945758&quot;&gt;&lt;li&gt;Node类是所有JavaFX场景图形节点的基本基类。它提供了转换和应用效果到任何节点的能力。&lt;br/&gt;javafx.scene.shape.Shape类是Node类的子类。所有较旧的JavaFX 2.x Builder中使用，但在JavaFX 8中这个类已弃用。&lt;/li&gt;
&lt;li&gt;包名: Package javafx.scene.shape&lt;/li&gt;
&lt;li&gt;官方 api &lt;a href=&quot;https://docs.oracle.com/javafx/2/api/&quot; class=&quot;uri&quot;&gt;https://docs.oracle.com/javafx/2/api/&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;包含: Line Ellipse Rectangle Quad Curve Polygon 支持 SVGPath&lt;/p&gt;
&lt;h4 id=&quot;线条&quot;&gt;线条&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绘制起始点&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1160484/201711/1160484-20171130223049492-160303088.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;基本上 理解 swing 的线条绘制的 理解这个类同&lt;br/&gt;四个参数 startX，startY，endX和endY 在单独的方发中也有相应的提供,调用即可&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;连个需要强调的参数&lt;br/&gt;线节点默认为1.0的笔触宽度和黑色的笔触颜色。所有形状的笔触颜色为null&lt;br/&gt;-代码:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1160484/201711/1160484-20171130223059508-2049634424.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;rectangle-矩形&quot;&gt;Rectangle 矩形&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1160484/201711/1160484-20171130223106977-270122848.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;path-路径&quot;&gt;Path 路径&lt;/h4&gt;
&lt;p&gt;Path元素实际上从javafx.scene.shape.PathElement类扩展，它仅在Path对象的上下文中使用。&lt;br/&gt;所以不能实例化一个LineTo类放在场景图中。使用To作为后缀的类是Path元素，而不是Shape节点。&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以及 TO 结尾都是 path 扩展组件中的元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;多边形折线&quot;&gt;多边形折线&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1160484/201711/1160484-20171130223116617-700082806.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运行效果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1160484/201711/1160484-20171130223122805-738103559.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;曲线&quot;&gt;曲线&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;startX，startY，endX和endY参数是曲线的起点和终点。controlX1，controlY1，controlX2和controlY2 是控件点。endX，endY。 看了这几个参数相信大家基本上已经了解了吧&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;核心代码&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1160484/201711/1160484-20171130223134617-425875523.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行效果&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1160484/201711/1160484-20171130223143492-1982179517.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;fx文本&quot;&gt;FX文本&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;直接继承了shape&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1160484/201711/1160484-20171130223148633-2015068149.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;代码&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1160484/201711/1160484-20171130223154617-688246064.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行效果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1160484/201711/1160484-20171130223200242-1567521355.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 30 Nov 2017 14:32:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/7932241.html</dc:identifier>
</item>
<item>
<title>Redis 主从复制 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/7932178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/7932178.html</guid>
<description>&lt;p&gt;本章介绍Redis的一个强大功能--主从复制。一台master主机可以拥有多台slave从机。而一台slave从机又可以拥有多个slave从机。如此下去，形成强大的多级服务器集群架构（高扩展）。可以避免Redis单点故障，实现容灾恢复效果（高可用）。读写分离的架构，满足读多写少的并发应用场景。&lt;/p&gt;
&lt;h2 id=&quot;主从复制的作用&quot;&gt;主从复制的作用&lt;/h2&gt;
&lt;p&gt;主从复制，读写分离，容灾恢复。一台主机负责写入数据，多台从机负责备份数据。在高并发的场景下，即便是主机挂了，可以用从机代替主机继续工作，避免单点故障导致系统性能问题。读写分离，让读多写少的应用性能更佳。&lt;/p&gt;
&lt;h2 id=&quot;主从复制架构&quot;&gt;主从复制架构&lt;/h2&gt;
&lt;p&gt;搭建主从价格主要有两个命令：info replication （查询主从复制信息）；slaveof ip port（设置主从关系）。&lt;/p&gt;
&lt;p&gt;架构图：一主二仆一兵（也可以多主多仆多兵）&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/806956/201711/806956-20171130101339573-1805956209.png&quot; alt=&quot;主从复制架构&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;搭建前的准备工作&quot;&gt;搭建前的准备工作&lt;/h3&gt;
&lt;p&gt;因为穷，笔者选择用一台服务器模拟三台主机。和生产环境的区别仅仅是ip地址和port端口不同。&lt;br/&gt;第一步：将redis.conf 拷贝三份，名字分别是，redis6379.conf，redis6380.conf，redis6381.conf&lt;br/&gt;第二步：修改三个文件的port端口，pid文件名，日志文件名，rdb文件名&lt;br/&gt;第三步：分别打开三个窗口模拟三台服务器，开启redis服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@itdragon bin]# cp redis.conf redis6379.conf
[root@itdragon bin]# cp redis.conf redis6380.conf
[root@itdragon bin]# cp redis.conf redis6381.conf
[root@itdragon bin]# vim redis6379.conf
logfile &quot;6379.log&quot;
dbfilename dump_6379.rdb
[root@itdragon bin]# vim redis6380.conf
pidfile /var/run/redis_6380.pid
port 6380
logfile &quot;6380.log&quot;
dbfilename dump_6380.rdb
[root@itdragon bin]# vim redis6381.conf
port 6381
pidfile /var/run/redis_6381.pid
logfile &quot;6381.log&quot;
dbfilename dump_6381.rdb
[root@itdragon bin]# ./redis-server redis6379.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; keys *
(empty list or set)
[root@itdragon bin]# ./redis-server redis6380.conf 
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6380
127.0.0.1:6380&amp;gt; keys *
(empty list or set)
[root@itdragon bin]# ./redis-server redis6381.conf 
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6381
127.0.0.1:6381&amp;gt; keys *
(empty list or set)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;主从复制搭建步骤&quot;&gt;主从复制搭建步骤&lt;/h3&gt;
&lt;h4 id=&quot;基础搭建-őдőb&quot;&gt;基础搭建 (๑ŐдŐ)b&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;第一步：查询主从复制信息&lt;/strong&gt;，分别选择三个端口，执行命令：info replication。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 6379 端口
[root@itdragon bin]# ./redis-server redis6379.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; info replication
# Replication
role:master
connected_slaves:0
......

# 6380 端口
127.0.0.1:6380&amp;gt; info replication
# Replication
role:master
connected_slaves:0
......

# 6381 端口
127.0.0.1:6381&amp;gt; info replication
# Replication
role:master
connected_slaves:0
......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三个端口都打印相同的信息：role:master 角色是master，connected_slaves:0 连接从机数量为零。了解更多参数含义可访问连接： &lt;a href=&quot;http://redisdoc.com/server/info.html&quot; class=&quot;uri&quot;&gt;http://redisdoc.com/server/info.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二步：选择6379端口，执行命令：set k1 v1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set k1 v1
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步：设置主从关系&lt;/strong&gt;，分别选择6380端口和6381端口，执行命令：SLAVEOF 127.0.0.1 6379&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 6380 端口
127.0.0.1:6380&amp;gt; SLAVEOF 127.0.0.1 6379
OK
127.0.0.1:6380&amp;gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
......

# 6381 端口
127.0.0.1:6381&amp;gt; SLAVEOF 127.0.0.1 6379
OK
127.0.0.1:6381&amp;gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
......

# 6379 端口
127.0.0.1:6379&amp;gt; info replication
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6380,state=online,offset=98,lag=1
slave1:ip=127.0.0.1,port=6381,state=online,offset=98,lag=1
......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主从关系发生了变化：&lt;br/&gt;6380端口和6381端口打印的信息： role:slave 从机；master_host:127.0.0.1 主机的ip地址；master_port:6379 主机的port 端口。&lt;br/&gt;6379端口打印的信息： role:master 主机；connected_slaves:2 连了两个从机； slaveX : ID、IP 地址、端口号、连接状态、从库信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四步：全量复制&lt;/strong&gt;，分别选择6380端口和6381端口，执行命令：get k1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 6380 端口
127.0.0.1:6380&amp;gt; get k1
&quot;v1&quot;

# 6381 端口
127.0.0.1:6381&amp;gt; get k1
&quot;v1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个端口都可以打印k1的值，说明在建立主从关系时，从机便拥有了主机的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第五步：增量复制&lt;/strong&gt;，选择6379端口，执行命令：set k2 v2。然后分别选择6380端口和6381端口，执行命令：get k2&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 6379 端口
127.0.0.1:6379&amp;gt; set k2 v2
OK

# 6380 端口
127.0.0.1:6380&amp;gt; get k2
&quot;v2&quot;

# 6381 端口
127.0.0.1:6381&amp;gt; get k2
&quot;v2&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个端口都可以打印k2的值，说明建立主从关系后，主机新增的数据都会复制给从机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第六步：主从的读写分离&lt;/strong&gt;，选择6380端口，执行命令：set k3 v3&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 6380 端口
127.0.0.1:6380&amp;gt; set k3 v3
(error) READONLY You can't write against a read only slave.

# 6379 端口
127.0.0.1:6379&amp;gt; set k3 v3
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从机6380写入失败，是因为读写分离的机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第七步：主机宕机的情况&lt;/strong&gt;，选择6379端口，执行命令：shutdown&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 6379 端口
127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT

# 6380 端口
127.0.0.1:6380&amp;gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
......

# 6381 端口
127.0.0.1:6381&amp;gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从打印的结果得知：从机原地待命&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第八步：主机宕机后恢复&lt;/strong&gt;，选择6379端口，重启Redis服务，执行命令：set k4 v4。分别选择6380端口和6381端口，执行命令：get k4&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 6379 端口
[root@itdragon bin]# ./redis-server redis6379.conf 
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6379
127.0.0.1:6379&amp;gt; set k4 v4
OK

# 6380 端口
127.0.0.1:6380&amp;gt; get k4
&quot;v4&quot;

# 6381 端口
127.0.0.1:6381&amp;gt; get k4
&quot;v4&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主机重启后，一切正常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第九步：从机宕机后恢复&lt;/strong&gt;，选择6380端口，执行命令：shutdown。选择6379端口，执行命令：set k5 v5。选择6380端口，重启Redis服务后执行命令：get k5&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 6380 端口
127.0.0.1:6380&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT
[root@itdragon bin]# ./redis-server redis6380.conf
[root@itdragon bin]# ./redis-cli -h 127.0.0.1 -p 6380
127.0.0.1:6380&amp;gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
......
127.0.0.1:6380&amp;gt; get k5
&quot;v5&quot;

# 6379 端口
127.0.0.1:6379&amp;gt; set k5 v5
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从机宕机后，一切正常。笔者用的是redis.4.0.2版本的。看过其他教程，从机宕机恢复后，只能同步主机新增数据，也就是k5是没有值的，可是笔者反复试过，均有值。留着备忘！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第十步：去中性化思想&lt;/strong&gt;，选择6380端口，执行命令：SLAVEOF 127.0.0.1 6381。选择6381端口，执行命令：info replication&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 6380 端口
127.0.0.1:6380&amp;gt; SLAVEOF 127.0.0.1 6381
OK

# 6381 端口
127.0.0.1:6381&amp;gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
......
connected_slaves:1
slave0:ip=127.0.0.1,port=6380,state=online,offset=1677,lag=1
......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然6381 是6380的主机，是6379的从机。在Redis眼中，6381依旧是从机。一台主机配多台从机，一台从机在配多台从机，从而实现了庞大的集群架构。同时也减轻了一台主机的压力，缺点是增加了服务器间的延迟。&lt;/p&gt;
&lt;h4 id=&quot;从机上位-őдőb&quot;&gt;从机上位 (๑ŐдŐ)b&lt;/h4&gt;
&lt;p&gt;模拟主机宕机，人为手动怂恿从机上位的场景。先将三个端口恢复成6379是主机，6380和6381是从机的架构。&lt;br/&gt;从机上位步骤：&lt;br/&gt;第一步：模拟主机宕机，选择6379端口，执行命令：shutdown&lt;br/&gt;第二步：断开主从关系，选择6380端口，执行命令：SLAVEOF no one&lt;br/&gt;第三步：重新搭建主从，选择6381端口，执行命令：info replication，SLAVEOF 127.0.0.1 6380&lt;br/&gt;第四步：之前主机恢复，选择6379端口，重启Redis服务，执行命令：info replication&lt;br/&gt;在6379主机宕机后，6380从机断开主从关系，6381开始还在原地待命，后来投靠6380主机后，6379主机回来了当它已是孤寡老人，空头司令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 6379端口

127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT

# 6380端口
127.0.0.1:6380&amp;gt; SLAVEOF no one
OK
127.0.0.1:6380&amp;gt; set k6 v6
OK

# 6381端口
127.0.0.1:6381&amp;gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
......
127.0.0.1:6381&amp;gt; SLAVEOF 127.0.0.1 6380
OK
127.0.0.1:6381&amp;gt; get k6
&quot;v6&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;哨兵监控-őдőb&quot;&gt;哨兵监控 (๑ŐдŐ)b&lt;/h4&gt;
&lt;p&gt;从机上位是需要人为控制，在生产环境中是不可取的，不可能有人实时盯着它，也不可能大半夜起床重新搭建主从关系。在这样的需求促使下，哨兵模式来了！！！&lt;br/&gt;哨兵有三大任务：&lt;br/&gt;&lt;strong&gt;1 监控&lt;/strong&gt;：哨兵会不断地检查你的Master和Slave是否运作正常&lt;br/&gt;&lt;strong&gt;2 提醒&lt;/strong&gt;：当被监控的某个Redis出现问题时, 哨兵可以通过API向管理员或者其他应用程序发送通知&lt;br/&gt;&lt;strong&gt;3 故障迁移&lt;/strong&gt;：若一台主机出现问题时，哨兵会自动将该主机下的某一个从机设置为新的主机，并让其他从机和新主机建立主从关系。&lt;/p&gt;
&lt;p&gt;哨兵搭建步骤：&lt;br/&gt;第一步：新开一个窗口，取名sentinel，方便观察哨兵日志信息&lt;br/&gt;第二步：创建sentinel.conf文件，也可以从redis的解压文件夹中拷贝一份。&lt;br/&gt;第三步：设置监控的主机和上位的规则，编辑sentinel.conf，输入 sentinel monitor itdragon-redis 127.0.0.1 6379 1 保存退出。解说：指定监控主机的ip地址，port端口，得票数。&lt;br/&gt;第四步：前端启动哨兵，执行命令：./redis-sentinel sentinel.conf。&lt;br/&gt;第五步：模拟主机宕机，选择6379窗口，执行命令：shutdown。&lt;br/&gt;第六步：等待从机投票，在sentinel窗口中查看打印信息。&lt;br/&gt;第七步：启动6379服务器，&lt;br/&gt;语法结构：sentinel monitor 自定义数据库名 主机ip 主机port 得票数&lt;br/&gt;若从机得票数大于设置值，则成为新的主机。若之前的主机恢复后，&lt;br/&gt;如果哨兵也宕机了？？？那就多配几个哨兵并且相互监控。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# sentinel窗口
[root@itdragon bin]# vim sentinel.conf
sentinel monitor itdragon-redis 127.0.0.1 6379 1
[root@itdragon bin]# ./redis-sentinel sentinel.conf
......
21401:X 29 Nov 15:39:15.052 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ itdragon-redis 127.0.0.1 6380
21401:X 29 Nov 15:39:15.052 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ itdragon-redis 127.0.0.1 6380
21401:X 29 Nov 15:39:45.081 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ itdragon-redis 127.0.0.1 6380

21401:X 29 Nov 16:40:52.055 # -sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ itdragon-redis 127.0.0.1 6380
21401:X 29 Nov 16:41:02.028 * +convert-to-slave slave 127.0.0.1:6379 127.0.0.1 6379 @ itdragon-redis 127.0.0.1 6380
......

# 6379端口
127.0.0.1:6379&amp;gt; SHUTDOWN
not connected&amp;gt; QUIT

# 6380端口
127.0.0.1:6380&amp;gt; info replication
# Replication
role:master
connected_slaves:1
slave0:ip=127.0.0.1,port=6381,state=online,offset=72590,lag=0
......

# 6381端口
127.0.0.1:6381&amp;gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6380
......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;+sdown 说明已经监控到有宕机情况&lt;br/&gt;-sdown 说明已经恢复服务&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/806956/201711/806956-20171130122319183-1678406720.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/806956/201711/806956-20171130122334808-1362262992.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;主从复制的原理&quot;&gt;主从复制的原理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;全量复制&lt;/strong&gt;&lt;br/&gt;实现原理：建立主从关系时，从机会给主机发送sync命令，主机接收命令，后台启动的存盘进程，同时收集所有用于&lt;strong&gt;修改命令&lt;/strong&gt;，传送给从机。&lt;br/&gt;&lt;strong&gt;增量复制&lt;/strong&gt;&lt;br/&gt;实现原理：主机会继续将新收集到的&lt;strong&gt;修改命令&lt;/strong&gt;依次传给从机，实现数据的同步效果。&lt;/p&gt;
&lt;h2 id=&quot;主从复制的缺点&quot;&gt;主从复制的缺点&lt;/h2&gt;
&lt;p&gt;Redis的主从复制最大的缺点就是延迟，主机负责写，从机负责备份，这个过程有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，从机器数量的增加也会使这个问题更加严重。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;1 查看主从复制关系命令：info replication&lt;br/&gt;2 设置主从关系命令：slaveof 主机ip 主机port&lt;br/&gt;3 开启哨兵模式命令：./redis-sentinel sentinel.conf&lt;br/&gt;4 主从复制原则：开始是全量赋值，之后是增量赋值&lt;br/&gt;5 哨兵模式三大任务：监控，提醒，自动故障迁移&lt;/p&gt;
&lt;p&gt;Redis 的主从复制到这里就结束了，有什么不对的地方欢迎指正。下一章Redis 的集群搭建和整合Spring&lt;/p&gt;
</description>
<pubDate>Thu, 30 Nov 2017 14:17:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/7932178.html</dc:identifier>
</item>
<item>
<title>架构设计之防止或缓解雪崩效应 - 熊猫猛男</title>
<link>http://www.cnblogs.com/XiongMaoMengNan/p/7900405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/XiongMaoMengNan/p/7900405.html</guid>
<description>[unable to retrieve full-text content]熔断是当某个服务调用慢或者有大量超时现象(过载)，系统停止后续针对该服务的调用而直接返回，直至情况好转才恢复调用。这通常是为防止造成整个系统故障而采取的一种保护措施，也称过载保护。很多时候刚开始，可能只是出现了局部小规模系统故障，但后来故障影响的范围越来越大，最终导致了全局性的后果。</description>
<pubDate>Thu, 30 Nov 2017 13:53:00 +0000</pubDate>
<dc:creator>熊猫猛男</dc:creator>
<dc:identifier>http://www.cnblogs.com/XiongMaoMengNan/p/7900405.html</dc:identifier>
</item>
</channel>
</rss>