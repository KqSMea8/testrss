<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java并发编程：并发容器之CopyOnWriteArrayList - 卫旗</title>
<link>http://www.cnblogs.com/weiqihome/p/9292123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiqihome/p/9292123.html</guid>
<description>&lt;p&gt;　　Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。&lt;/p&gt;
&lt;h2&gt;什么是CopyOnWrite容器&lt;/h2&gt;
&lt;p&gt;　　CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。&lt;/p&gt;
&lt;h2&gt;CopyOnWriteArrayList的实现原理&lt;/h2&gt;
&lt;p&gt;　　在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向CopyOnWriteArrayList中add方法的实现（向CopyOnWriteArrayList里添加元素），可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
     * Appends the specified element to the end of this list.
     *
     * @param e element to be appended to this list
     * @return {@code true} (as specified by {@link Collection#add})
     */
    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　读的时候不需要加锁，如果读的时候有多个线程正在向CopyOnWriteArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的CopyOnWriteArrayList。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
// Positional Access Operations

    @SuppressWarnings(&quot;unchecked&quot;)
    private E get(Object[] a, int index) {
        return (E) a[index];
    }

    /**
     * {@inheritDoc}
     *
     * @throws IndexOutOfBoundsException {@inheritDoc}
     */
    public E get(int index) {
        return get(getArray(), index);
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;JDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
 
public class CopyOnWriteMap&amp;lt;K, V&amp;gt; implements Map&amp;lt;K, V&amp;gt;, Cloneable {
    private volatile Map&amp;lt;K, V&amp;gt; internalMap;
 
    public CopyOnWriteMap() {
        internalMap = new HashMap&amp;lt;K, V&amp;gt;();
    }
 
    public V put(K key, V value) {
 
        synchronized (this) {
            Map&amp;lt;K, V&amp;gt; newMap = new HashMap&amp;lt;K, V&amp;gt;(internalMap);
            V val = newMap.put(key, value);
            internalMap = newMap;
            return val;
        }
    }
 
    public V get(Object key) {
        return internalMap.get(key);
    }
 
    public void putAll(Map&amp;lt;? extends K, ? extends V&amp;gt; newData) {
        synchronized (this) {
            Map&amp;lt;K, V&amp;gt; newMap = new HashMap&amp;lt;K, V&amp;gt;(internalMap);
            newMap.putAll(newData);
            internalMap = newMap;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。&lt;/p&gt;
&lt;h2&gt;CopyOnWrite的应用场景&lt;/h2&gt;
&lt;p&gt;　　CopyOnWrite容器用于读多写少的并发场景，比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.ifeve.book;
 
import java.util.Map;
 
import com.ifeve.book.forkjoin.CopyOnWriteMap;
 
/**
 * 黑名单服务
 *
 * @author fangtengfei
 *
 */
public class BlackListServiceImpl {
 
    private static CopyOnWriteMap&amp;lt;String, Boolean&amp;gt; blackListMap = new CopyOnWriteMap&amp;lt;String, Boolean&amp;gt;(
            1000);
 
    public static boolean isBlackList(String id) {
        return blackListMap.get(id) == null ? false : true;
    }
 
    public static void addBlackList(String id) {
        blackListMap.put(id, Boolean.TRUE);
    }
 
    /**
     * 批量添加黑名单
     *
     * @param ids
     */
    public static void addBlackList(Map&amp;lt;String,Boolean&amp;gt; ids) {
        blackListMap.putAll(ids);
    }
 
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码很简单，但是使用CopyOnWriteMap需要注意两件事情：&lt;/p&gt;
&lt;p&gt;　　1、减少扩容开销。根据实际需要，初始化CopyOnWrite容器的大小，避免写时CopyOnWrite扩容的开销。&lt;/p&gt;
&lt;p&gt;　　2、使用批量添加。因为每次添加，容器都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList()方法。&lt;/p&gt;
&lt;h2&gt;CopyOnWrite的缺点&lt;/h2&gt;
&lt;p&gt;　　CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;内存占用问题，&lt;/strong&gt;因为CopyOnWrite的写时复制机制，所以在写操作的时候内存里会有两个对象的内存，旧的对象和新写入的对象。如果这写对象占用较大的内存，比如占用200M内存，那么复制的时候就会再占用很大的内存，并且复制的时候会花费较多的时间，响应的时间就会边长。&lt;/p&gt;
&lt;p&gt;　　针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如&lt;a href=&quot;http://ifeve.com/concurrenthashmap/&quot; target=&quot;_blank&quot;&gt;ConcurrentHashMap&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　数据一致性问题&lt;/strong&gt;。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Jul 2018 15:35:00 +0000</pubDate>
<dc:creator>卫旗</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weiqihome/p/9292123.html</dc:identifier>
</item>
<item>
<title>函数式编程之Partial application - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9291920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9291920.html</guid>
<description>&lt;p&gt;上一篇关于Currying的介绍，我们提到F#是如何做Currying变换的：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let addWithThreeParameters x y z = x + y + z
let intermediateFn1 = addWithThreeParameters 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;给定一个接受三个参数的函数&lt;code&gt;addWithThreeParameters&lt;/code&gt;，我们通过&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let intermediateFn1 = addWithThreeParameters 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的方式创建出了一个新的函数&lt;code&gt;intermediateFn1&lt;/code&gt;，其函数签名为：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;int -&amp;gt; int -&amp;gt; int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是F#用来描述函数签名的方式，它表示函数接受两个int类型的参数，返回类型为int类型。&lt;br/&gt;类似地：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;(int -&amp;gt; int) -&amp;gt; int&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示参数为&lt;code&gt;(int -&amp;gt; int)&lt;/code&gt;类型的函数，返回类型为int；而&lt;code&gt;(int -&amp;gt; int)&lt;/code&gt;又是一个函数，表示接受一个int类型的参数，返回类型仍然为int。&lt;/p&gt;
&lt;p&gt;对于F#而言，函数本身需要接受三个参数，但是我们调用的时候只给一个参数，从而创建出接受两个参数的新函数，这种方式被称作是&lt;code&gt;Partial application&lt;/code&gt;。也就是说我们通过&lt;code&gt;Partial application&lt;/code&gt;的方式完成了Currying。&lt;br/&gt;&lt;code&gt;Partial application&lt;/code&gt;是常用的函数式编程风格，对于初学者而言也很重要。我们在Currying一节介绍过Curring的目的是为了生成一个只接受一个参数的新函数，从而可以将两个函数粘结在一起。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1232840/o_Jietu20180710-214351@2x.png&quot;/&gt;&lt;br/&gt;那么&lt;code&gt;Partial application&lt;/code&gt;就是F#完成Curring的一种手段。&lt;/p&gt;
&lt;p&gt;还记得C#版本的Currying吗？我们是通纯手工方式创建了新的Currying函数。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public Func&amp;lt;int, int&amp;gt; AddWithTwoParameters(int x)
{
    Func&amp;lt;int, int&amp;gt; subFunction = y =&amp;gt; x + y;

    return subFunction;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在C#里面函数式没法通过只传递一个参数的方式来生成一个新的函数，在C#中声明一个三个参数的函数，调用的时候只传入一个参数会编译出错，这是众所周知的。&lt;br/&gt;当然，非要用C#演示&lt;code&gt;Partial application&lt;/code&gt;，我们可以用一种不自然的方式来做到：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static Func&amp;lt;T2, T3, TR&amp;gt; Apply&amp;lt;T1, T2, T3, TR&amp;gt;
(Func&amp;lt;T1, T2, T3, TR&amp;gt; function, T1 arg1)
{
    return (arg2, arg3) =&amp;gt; function(arg1, arg2, arg3);
}

//调用
Func&amp;lt;int, int, int&amp;gt; add = (a, b) =&amp;gt; a + b;
var add5 = Apply(add, 5);
var add51 = add5(1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;F#是这样做的：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let add5 = (+) 5    // partial application
let add51= add5 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果说&lt;code&gt;Partial application&lt;/code&gt;还可以用C#来勉强实现，后面描述的函数式特性几乎不会出现在OO风格的代码里，所以后面的章节大都会以F#来演示。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Partial application&lt;/code&gt;之所以在函数式编程中占有很重要的地位，他不仅仅能够完成Curring变换，还可以将函数变成一个可重用的组件，考虑下面的代码：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;[1;2;3] |&amp;gt; List.map add51 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将&lt;code&gt;add51&lt;/code&gt;这个新函数应用到了[1;2;3]这个list中的每个元素中。&lt;br/&gt;下面的这个例子更复杂一些，用来演示通过&lt;code&gt;Partial application&lt;/code&gt;来完成OO范式中的&lt;code&gt;Dependency Injection&lt;/code&gt;功能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个函数(add)用来把两个数字加起来 ，除此之外，还要将运算过程记录成log&lt;/li&gt;
&lt;li&gt;Logging函数是一个接受两个参数的函数，分别为string和一个泛类型`a，返回类型为unit，所以logging函数的签名为string-&amp;gt;'a-&amp;gt;unit&lt;/li&gt;
&lt;li&gt;Logging函数有多种不同类型的实现，例如console logger，file logger&lt;br/&gt;你可以认为logging函数是拥有一个契约(string-&amp;gt;'a-&amp;gt;unit)的接口，对应的实现可以有多个&lt;/li&gt;
&lt;li&gt;如何把具体的logger 注入到add函数中？&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;//创建一个调用add函数，并且可以注入logger实现的函数
let addWithPluggableLogger logger x y =
    let result = x + y
    logger &quot;x+y&quot;  result 
    result 

// 创建一个consoleLogger
let consoleLogger argName argValue = 
    printfn &quot;%s=%A&quot; argName argValue 

//把addWithConsoleLogger做partial应用，把consoleLogger应用在上面，同时创建出一个具有添加log能力
//的add函数，他的函数签名为`int -&amp;gt; int -&amp;gt; int`，跟普通的add函数式一致的，
//但是此刻他拥有了添加log的能力: 
let addWithConsoleLogger = addWithPluggableLogger consoleLogger 
addWithConsoleLogger  1 2 
addWithConsoleLogger  42 99&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也许你已经看出来函数参数的顺序决定能否&lt;code&gt;Partial application&lt;/code&gt;, 因为在做&lt;code&gt;Partial&lt;/code&gt;应用的时候总是按照参数从左到右的顺序执行的，你无法把一个参数应用在函数的最后一个位置。&lt;br/&gt;下节将会描述如何设计函数让其能够支持&lt;code&gt;Partial application&lt;/code&gt;，以及F#中的管道符&lt;code&gt;|&amp;gt;&lt;/code&gt;的用法。想学习函数式编程的同学可以持续关注。&lt;/p&gt;
</description>
<pubDate>Tue, 10 Jul 2018 15:32:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9291920.html</dc:identifier>
</item>
<item>
<title>吴恩达《深度学习》第二门课（1）深度学习的实用层面 - ysyouaremyall</title>
<link>http://www.cnblogs.com/ys99/p/9292100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ys99/p/9292100.html</guid>
<description>&lt;h2&gt;1.1训练，验证，测试集（Train/Dev/Test sets）&lt;/h2&gt;
&lt;p&gt;（1）深度学习是一个按照下图进行循环的快速迭代的过程，往往需要多次才能为应用程序找到一个称心的神经网络。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710185832667-1174917589.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）在机器学习中，通常将样本分成训练集，验证集和测试集三部分，数据规模相对较小，适合传统的划分比例（如6:2:2），数据集规模比较大的，验证集和测试集要小于数据总量的20%或者10%甚至更低。&lt;/p&gt;
&lt;p&gt;（3）交叉验证集和测试集务必来自同分布。&lt;/p&gt;
&lt;p&gt;（4）有时候只有训练集和验证集，没有独立的测试集（将无法提供无偏性能评估），这时人们也会把验证集称为测试集。&lt;/p&gt;
&lt;h2&gt;1.2偏差，方差（Bias/Varicance）&lt;/h2&gt;
&lt;p&gt;（1）以下三个图分别表示欠拟合（高偏差），适度拟合，过拟合（高方差）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710191128080-410377276.png&quot; alt=&quot;&quot; width=&quot;761&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）最优误差也称为贝叶斯误差，本节中假设最有误差为零（如在图像分类中人可以辨别出所有图像的类别）。&lt;/p&gt;
&lt;p&gt;（3）训练误差减去左右误差为偏差，结果大说明偏差大；验证集误差减去训练误差为方差，结果大说明偏差大。&lt;/p&gt;
&lt;p&gt;（4）是存在高偏差高方差的情况的，如下图，直线导致高偏差，局部过拟合导致高方差：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710191445139-1466381755.png&quot; alt=&quot;&quot; width=&quot;332&quot; height=&quot;215&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.3机器学习基础&lt;/h2&gt;
&lt;p&gt;（1）偏差和方差是两种完全不同的情况，有分别对应的处理方法，不要盲目的使用一些策略。&lt;/p&gt;
&lt;p&gt;（2）在深度学习时代，只要正则适度，通常构建一个更大的网络便可以在不影响方差的同时减少偏差，而采用更多数据通常可以在不过多影响偏差的同时减少方差。&lt;/p&gt;
&lt;h2&gt;1.4正则化&lt;/h2&gt;
&lt;p&gt;（1）过拟合常用的两种解决方法：添加正则化项（容易实现），增加更多数据（有时候很难得到更多数据）。&lt;/p&gt;
&lt;p&gt;（2）L1正则化往往会使得W最终稀疏，即w向量中很多是0，事实证明它并没有减少太多的存储空间，所以现在越来越多人还是使用L2正则。&lt;/p&gt;
&lt;p&gt;（3）L2正则式子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710194856977-2069775137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710194908325-2045805955.png&quot; alt=&quot;&quot;/&gt;被定义为矩阵中所有元素的平方求和。&lt;/p&gt;
&lt;p&gt;（4）正则化常常被称为“权重衰减”，是因为正则项会试图让W变得更小，实际上相当于给矩阵W乘以（1-αλ/m）,如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710195244181-1138008952.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.5为什么正则化有利于预防过拟合&lt;/h2&gt;
&lt;p&gt;（1）第一种直观理解，首先一个很复杂的神经网络（过拟合）：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710195907950-1857386574.png&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;158&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后添加正则项，使λ，这时候很多权重变成0，然后相当于消除了很多隐藏单元，复杂网络变成很简单的网络（欠拟合），从过拟合到欠拟合中间会经历最优拟合的情况，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710200309133-2045398506.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;253&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）第二种理解，W实际不会变成零，只会变得非常小，这时候z也会变得非常小，那么根据以下的激活函数，将会在中间线性的地方活动，那么相当与经过很多次线性变换，所以这也导致网络变得简答，消除了过拟合情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710200509544-1925003778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.6dropout正则化&lt;/h2&gt;
&lt;p&gt;（1）原网络如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710224648880-654952174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）设置keep-prob为0.8（相当于一个d&lt;sup&gt;[l]&lt;/sup&gt;向量中80%为1，百分之20%为零），这个向量与某一层的输出a&lt;sup&gt;[l]&lt;/sup&gt;相乘（与零相乘自然输出就为零了），其网络示意图如下（图中是设置为0.5）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710224932312-2136720128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）在上一步乘积之后的值又会除以0.8，如下面的公式，这样可以保证均值不会发生改变（因为单元数减少会导致后面一层的输入减少，通过除以减少量来维持不变）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710225139695-323023296.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）测试的时候不使用dropout。&lt;/p&gt;
&lt;h2&gt;1.7理解dropout&lt;/h2&gt;
&lt;p&gt;（1）直观上理解：不要依赖于任何一个特征，因为该单元的输入可能随时被清除，或者说该单元的输入也都可能被随机清除，因此不愿意在任何一个输入单元上加上太多的权重，会把权重分摊给其他单元，这其实产生了收缩权重的平方范数的效果。&lt;/p&gt;
&lt;p&gt;（2）dropout被正式的作为一种正则化的替代方式，L2对不同权重的衰减是不同的，他取决于倍增的激活函数的大小。&lt;/p&gt;
&lt;p&gt;（3）不同层之间可以使用不同的keep-prob，一般矩阵W越大的层，越容易导致过拟合，所以keep-prob的值设置的越低（输入层一般为1），如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710230847820-369280810.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）计算机视觉中常用dropout,因为像素（特征）太多，数据量太少，常常导致过拟合。&lt;/p&gt;
&lt;p&gt;（5）dropout的一大缺点就是代价函数J不再明确定义，每次迭代，都会随机移除一些节点，或者说某种程度上很难准确计算。&lt;/p&gt;
&lt;h2&gt;1.8其他正则化方法&lt;/h2&gt;
&lt;p&gt;（1）数据增强：旋转、扭曲、任意裁剪放大等。&lt;/p&gt;
&lt;p&gt;（2）early stopping:在交叉验证集代价函数（误差率等）下降又上升的拐点处停止，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180710232221206-1831256766.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;early stoping的主要缺点就是控制w不太大的时候，也终止的优化代价函数J，而不能向其他方式一样：一方面不断的使代价函数变小，用另外的方式来控制使其不发生过拟合。&lt;/p&gt;
&lt;h2&gt;1.9归一化输入&lt;/h2&gt;
&lt;p&gt;未完成，待续……&lt;/p&gt;
</description>
<pubDate>Tue, 10 Jul 2018 15:27:00 +0000</pubDate>
<dc:creator>ysyouaremyall</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ys99/p/9292100.html</dc:identifier>
</item>
<item>
<title>Vue 1.0动画 - juneChen</title>
<link>http://www.cnblogs.com/junechen/p/9292059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/junechen/p/9292059.html</guid>
<description>&lt;p&gt;&lt;span&gt;Vue &lt;span&gt;1.0&lt;/span&gt;动画（自定义动画）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;步骤：&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　1.给当前动画元素添加‘transition’属性  其值就是动画名称(假如：fade)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　2.给动画名称写css定义&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　a: .fade-transition{/*定义动画过渡*/   transition:1s  all ease;}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　b: .fade-enter{/*定义进入动画  注意：进入离开最终一样*/}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　c：fade-leave{/*定义离开动画*/}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;html 如下：　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;wrap&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;按钮&quot; @click=&quot;show&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;box&quot; v-show='isShow'  transition='fade'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box&lt;/span&gt;{&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt;100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt;100px&lt;/span&gt;;    
}&lt;span&gt;
.fade-transition&lt;/span&gt;{ &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;定义动画的过渡效果&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  transition&lt;/span&gt;:&lt;span&gt;1s all ease&lt;/span&gt;;  
}&lt;span&gt;
.fade-enter&lt;/span&gt;{ &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;进入动画&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  opacity&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;  
}&lt;span&gt;
.fade-leave&lt;/span&gt;{&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;离开的动画&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  opacity&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;
  transform&lt;/span&gt;:&lt;span&gt;translate(200px)    
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;var vm=new Vue({&lt;/p&gt;
&lt;p&gt;　　el:'#box',&lt;/p&gt;
&lt;p&gt;　　data:{&lt;/p&gt;
&lt;p&gt;　　　　isShow:true&lt;/p&gt;
&lt;p&gt;　　},&lt;/p&gt;
&lt;p&gt;　　methods:{&lt;/p&gt;
&lt;p&gt;　　　　show(){&lt;/p&gt;
&lt;p&gt;　　　　　　this.isShow=!this.isShow;&lt;/p&gt;
&lt;p&gt;　　　　}&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;vue 1.0 结合animate.css定义动画&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;页面记得引入animate.cdd&lt;/p&gt;
&lt;p&gt;html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;box2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;按钮&quot;&lt;/span&gt;&lt;span&gt; @click&lt;/span&gt;&lt;span&gt;='show'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;div2&quot;&lt;/span&gt;&lt;span&gt;  class&lt;/span&gt;&lt;span&gt;=&quot;animated&quot;&lt;/span&gt;&lt;span&gt;  v-show&lt;/span&gt;&lt;span&gt;='isShow' &lt;/span&gt;&lt;span&gt;transition&lt;/span&gt;&lt;span&gt;=&quot;bounce&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;css&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#div2&lt;/span&gt;{&lt;span&gt;
   width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
   height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
   background&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;&lt;span&gt;
   margin&lt;/span&gt;:&lt;span&gt; 50px auto&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
       el:&lt;/span&gt;'#box2'&lt;span&gt;,
         data:{
            isShow:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
         },
         methods:{
             show(){
                  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.isShow=!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isShow;
             }
        },
       transitions:{
           bounce:{
           　　enterClass:&lt;/span&gt;&quot;zoomInLeft&quot;&lt;span&gt;,
           　　leaveClass:&lt;/span&gt;&quot;zoomInRight&quot;&lt;span&gt;
           }
       }
 })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 10 Jul 2018 15:16:00 +0000</pubDate>
<dc:creator>juneChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/junechen/p/9292059.html</dc:identifier>
</item>
<item>
<title>【自然语言处理篇】--Chatterbot聊天机器人 - LHBlog</title>
<link>http://www.cnblogs.com/LHWorldBlog/p/9292024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LHWorldBlog/p/9292024.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、前述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ChatterBot是一个基于机器学习的聊天机器人引擎，构建在python上，主要特点是可以自可以从已有的对话中进行学(jiyi)习(pipei)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、具体&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;安装&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、安装&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是的，安装超级简单，用pip就可以啦&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;pip install chatterbot&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大家已经知道chatterbot的聊天逻辑和输入输出以及存储，是由各种adapter来限定的，我们先看看流程图，一会软再一起看点例子，看看怎么用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1250469/201807/1250469-20180710224509787-1829282027.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、每个部分都设计了不同的“适配器”(Adapter)。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;机器人应答逻辑&lt;/strong&gt; =&amp;gt; Logic Adapters&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Closest Match Adapter  字符串模糊匹配(编辑距离)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Closest Meaning Adapter  借助nltk的WordNet，近义词评估&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Time Logic Adapter 处理涉及时间的提问&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mathematical Evaluation Adapter 涉及数学运算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;存储器后端&lt;/strong&gt; =&amp;gt; Storage Adapters&lt;/span&gt;&lt;br/&gt;&lt;span&gt; Read Only Mode 只读模式，当有输入数据到chatterbot的时候，数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;据库并不会发生改变&lt;/span&gt;&lt;br/&gt;&lt;span&gt; Json Database Adapter 用以存储对话数据的接口，对话数据以Json格式&lt;/span&gt;&lt;br/&gt;&lt;span&gt;进行存储。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mongo Database Adapter  以MongoDB database方式来存储对话数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;输入形式&lt;/strong&gt; =&amp;gt; Input Adapters&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Variable input type adapter 允许chatter bot接收不同类型的输入的，如strings,dictionaries和Statements&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Terminal adapter 使得ChatterBot可以通过终端进行对话&lt;/span&gt;&lt;br/&gt;&lt;span&gt; HipChat Adapter 使得ChatterBot 可以从HipChat聊天室获取输入语句，通过HipChat 和 ChatterBot 进行对话&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Speech recognition 语音识别输入，详见chatterbot-voice&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;输出形式&lt;/strong&gt; =&amp;gt; Output Adapters&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Output format adapter支持text，json和object格式的输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Terminal adapter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;HipChat Adapter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Mailgun adapter允许chat bot基于Mailgun API进行邮件的发送&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Speech synthesisTTS(Text to speech)部分，详见chatterbot-voice&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础版本&quot;&gt;&lt;span&gt;基础版本&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# -*- coding: utf-&lt;span&gt;8&lt;/span&gt; -*-
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; chatterbot import ChatBot


# 构建ChatBot并指定Adapter
bot &lt;/span&gt;=&lt;span&gt; ChatBot(
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Default Response Example Bot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    storage_adapter&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.storage.JsonFileStorageAdapter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;strong&gt;#存储的Adapter&lt;/strong&gt;
    logic_adapters&lt;/span&gt;=&lt;span&gt;[
        {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;import_path&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.logic.BestMatch&lt;/span&gt;&lt;span&gt;'&lt;strong&gt;#回话逻辑&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
        },
        {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;import_path&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.logic.LowConfidenceAdapter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,#回话逻辑
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;threshold&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;0.65&lt;/span&gt;&lt;span&gt;,&lt;strong&gt;#低于置信度，则默认回答
            &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default_response&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am sorry, but I do not understand.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        }
    ],
    trainer&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.trainers.ListTrainer&lt;/span&gt;&lt;span&gt;'&lt;strong&gt;#给定的语料是个列表&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
)

# 手动给定一点语料用于训练
bot.train([
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;How can I help you?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I want to create a chat bot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Have you read the documentation?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;No, I have not&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;This should help get you started: http://chatterbot.rtfd.org/en/latest/quickstart.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
])

# 给定问题并取回结果
question &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;How do I make an omelette?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
print(question)
response &lt;/span&gt;=&lt;span&gt; bot.get_response(question)
print(response)

print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
question &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;how to make a chat bot?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
print(question)
response &lt;/span&gt;=&lt;span&gt; bot.get_response(question)
print(response)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;How do I make an omelette?
I am sorry, but I do &lt;/span&gt;&lt;span&gt;not&lt;/span&gt;&lt;span&gt; understand.


how to make a chat bot?
Have you read the documentation?&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;处理时间和数学计算的Adapter&quot;&gt;&lt;span&gt;处理时间和数学计算的Adapter&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; chatterbot &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ChatBot


bot &lt;/span&gt;=&lt;span&gt; ChatBot(
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Math &amp;amp; Time Bot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    logic_adapters&lt;/span&gt;=&lt;span&gt;[
        &lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chatterbot.logic.MathematicalEvaluation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chatterbot.logic.TimeLogicAdapter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    ],
    input_adapter&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chatterbot.input.VariableInputTypeAdapter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    output_adapter&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chatterbot.output.OutputAdapter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行数学计算&lt;/span&gt;
question = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;What is 4 + 9?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(question)
response &lt;/span&gt;=&lt;span&gt; bot.get_response(question)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 回答和时间相关的问题&lt;/span&gt;
question = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;What time is it?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(question)
response &lt;/span&gt;=&lt;span&gt; bot.get_response(question)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(response)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;What &lt;span&gt;is&lt;/span&gt; 4 + 9&lt;span&gt;?
( &lt;/span&gt;4 + 9 ) = 13&lt;span&gt;

What time &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; it?
The current time &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; 05:08 PM&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 导出语料到json文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; chatterbot &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ChatBot

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
如果一个已经训练好的chatbot，你想取出它的语料，用于别的chatbot构建，可以这么做
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

chatbot &lt;/span&gt;=&lt;span&gt; ChatBot(
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Export Example Bot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    trainer&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.trainers.ChatterBotCorpusTrainer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 训练一下咯&lt;/span&gt;
chatbot.train(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.corpus.english&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把语料导出到json文件中&lt;/span&gt;
chatbot.trainer.export_for_training(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./my_export.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;反馈式学习聊天机器人&quot;&gt;&lt;span&gt;反馈式学习聊天机器人&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; chatterbot &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ChatBot
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging

&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
反馈式的聊天机器人，会根据你的反馈进行学习
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把下面这行前的注释去掉，可以把一些信息写入日志中&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; logging.basicConfig(level=logging.INFO)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个聊天机器人&lt;/span&gt;
bot =&lt;span&gt; ChatBot(
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Feedback Learning Bot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    storage_adapter&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.storage.JsonFileStorageAdapter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    logic_adapters&lt;/span&gt;=&lt;span&gt;[
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.logic.BestMatch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ],
    input_adapter&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.input.&lt;strong&gt;TerminalAdapter&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;,#命令行端&lt;/strong&gt;
    output_adapter&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.output.TerminalAdapter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)

DEFAULT_SESSION_ID &lt;/span&gt;=&lt;span&gt; bot.default_session.id


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_feedback():
    &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; chatterbot.utils &lt;span&gt;import&lt;/span&gt;&lt;span&gt; input_function

    text &lt;/span&gt;=&lt;span&gt; input_function()

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Yes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; text:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; text:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Please type either &quot;Yes&quot; or &quot;No&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; get_feedback()


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Type something to begin...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每次用户有输入内容，这个循环就会开始执行&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        input_statement &lt;/span&gt;=&lt;span&gt; bot.input.process_input_statement()
        statement, response &lt;/span&gt;=&lt;span&gt; bot.generate_response(input_statement, DEFAULT_SESSION_ID)

        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n Is &quot;{}&quot; this a coherent response to &quot;{}&quot;? \n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(response, input_statement))

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; get_feedback():
            bot.learn_response(response,input_statement)

        bot.output.process_response(response)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新chatbot的历史聊天数据&lt;/span&gt;
&lt;span&gt;        bot.conversation_sessions.update(
            bot.default_session.id_string,
            (statement, response, )
        )

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直到按ctrl-c 或者 ctrl-d 才会退出&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt; (KeyboardInterrupt, EOFError, SystemExit):
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 使用Ubuntu数据集构建聊天机器人&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;from&lt;/span&gt; chatterbot &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ChatBot
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; logging


&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
这是一个使用Ubuntu语料构建聊天机器人的例子
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许打日志&lt;/span&gt;
logging.basicConfig(level=&lt;span&gt;logging.INFO)

chatbot &lt;/span&gt;=&lt;span&gt; ChatBot(
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Example Bot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    trainer&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.trainers.UbuntuCorpusTrainer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用Ubuntu数据集开始训练&lt;/span&gt;
&lt;span&gt;chatbot.train()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 我们来看看训练后的机器人的应答&lt;/span&gt;
response = chatbot.get_response(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;How are you doing today?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(response)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;借助微软的聊天机器人&quot;&gt;&lt;span&gt;借助微软的聊天机器人&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; chatterbot &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ChatBot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; settings &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Microsoft

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
关于获取微软的user access token请参考以下的文档
https://docs.botframework.com/en-us/restapi/directline/
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

chatbot &lt;/span&gt;=&lt;span&gt; ChatBot(
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MicrosoftBot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    directline_host &lt;/span&gt;= Microsoft[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;directline_host&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    direct_line_token_or_secret &lt;/span&gt;= Microsoft[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;direct_line_token_or_secret&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    conversation_id &lt;/span&gt;= Microsoft[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conversation_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    input_adapter&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.input.Microsoft&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    output_adapter&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.output.Microsoft&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    trainer&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.trainers.ChatterBotCorpusTrainer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)

chatbot.train(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.corpus.english&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是的，会一直聊下去&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        response &lt;/span&gt;=&lt;span&gt; chatbot.get_response(None)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直到按ctrl-c 或者 ctrl-d 才会退出&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt; (KeyboardInterrupt, EOFError, SystemExit):
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;HipChat聊天室Adapter&quot;&gt;&lt;span&gt;HipChat聊天室Adapter&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; chatterbot &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ChatBot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; settings &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HIPCHAT

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
炫酷一点，你可以接到一个HipChat聊天室，你需要一个user token，下面文档会告诉你怎么做
https://developer.atlassian.com/hipchat/guide/hipchat-rest-api/api-access-tokens
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;

chatbot &lt;/span&gt;=&lt;span&gt; ChatBot(
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HipChatBot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    hipchat_host&lt;/span&gt;=HIPCHAT[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HOST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    hipchat_room&lt;/span&gt;=HIPCHAT[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ROOM&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    hipchat_access_token&lt;/span&gt;=HIPCHAT[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ACCESS_TOKEN&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    input_adapter&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.input.HipChat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    output_adapter&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.output.HipChat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    trainer&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.trainers.ChatterBotCorpusTrainer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)

chatbot.train(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chatterbot.corpus.english&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 没错，while True，会一直聊下去！&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        response &lt;/span&gt;=&lt;span&gt; chatbot.get_response(None)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直到按ctrl-c 或者 ctrl-d 才会退出&lt;/span&gt;
    &lt;span&gt;except&lt;/span&gt;&lt;span&gt; (KeyboardInterrupt, EOFError, SystemExit):
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;邮件回复的聊天系统&quot;&gt;&lt;span&gt;邮件回复的聊天系统&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; chatterbot &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ChatBot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; settings &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MAILGUN

&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
这个功能需要你新建一个文件settings.py，并在里面写入如下的配置:
MAILGUN = {
    &quot;CONSUMER_KEY&quot;: &quot;my-mailgun-api-key&quot;,
    &quot;API_ENDPOINT&quot;: &quot;https://api.mailgun.net/v3/my-domain.com/messages&quot;
}
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下面这个部分可以改成你自己的邮箱&lt;/span&gt;
FROM_EMAIL = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mailgun@salvius.org&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
RECIPIENTS &lt;/span&gt;= [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gunthercx@gmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

bot &lt;/span&gt;=&lt;span&gt; ChatBot(
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mailgun Example Bot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    mailgun_from_address&lt;/span&gt;=&lt;span&gt;FROM_EMAIL,
    mailgun_api_key&lt;/span&gt;=MAILGUN[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CONSUMER_KEY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
    mailgun_api_endpoint&lt;/span&gt;=MAILGUN[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;API_ENDPOINT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
    mailgun_recipients&lt;/span&gt;=&lt;span&gt;RECIPIENTS,
    input_adapter&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chatterbot.input.Mailgun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    output_adapter&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chatterbot.output.Mailgun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    storage_adapter&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chatterbot.storage.JsonFileStorageAdapter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    database&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;../database.db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 简单的邮件回复&lt;/span&gt;
response = bot.get_response(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;How are you?&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Check your inbox at &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, RECIPIENTS)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;一个中文的例子&quot;&gt;&lt;span&gt;一个中文的例子&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;注意chatterbot，中文聊天机器人的场景下一定要用python3.X，用python2.7会有编码问题。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;手动设置一些语料&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; chatterbot &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ChatBot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; chatterbot.trainers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ListTrainer
 
 
Chinese_bot &lt;/span&gt;= ChatBot(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Training demo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Chinese_bot.set_trainer(ListTrainer)
Chinese_bot.train([
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;你好&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;你好&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;有什么能帮你的？&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;想买数据科学的课程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;具体是数据科学哪块呢？&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;机器学习&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
])
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 测试一下&lt;/span&gt;
question = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;你好&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(question)
response &lt;/span&gt;=&lt;span&gt; Chinese_bot.get_response(question)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(response)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

question &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请问哪里能买数据科学的课程&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(question)
response &lt;/span&gt;=&lt;span&gt; Chinese_bot.get_response(question)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(response)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;你好
你好


请问哪里能买数据科学的课程
具体是数据科学哪块呢？&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;利用已经提供好的小中文语料库&quot;&gt;&lt;span&gt;利用已经提供好的小中文语料库&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; chatterbot &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ChatBot
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; chatterbot.trainers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ChatterBotCorpusTrainer
 
chatbot &lt;/span&gt;= ChatBot(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ChineseChatBot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
chatbot.set_trainer(ChatterBotCorpusTrainer)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用中文语料库训练它&lt;/span&gt;
chatbot.train(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;chatterbot.corpus.chinese&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始对话&lt;/span&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(chatbot.get_response(input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 10 Jul 2018 15:07:00 +0000</pubDate>
<dc:creator>LHBlog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LHWorldBlog/p/9292024.html</dc:identifier>
</item>
<item>
<title>Linux 安装Redis(使用Mac远程访问) - 梦三</title>
<link>http://www.cnblogs.com/huangyi-427/p/9291990.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangyi-427/p/9291990.html</guid>
<description>&lt;p&gt;阅读本文需要先阅读&lt;a href=&quot;https://www.cnblogs.com/huangyi-427/p/9284856.html&quot; target=&quot;_blank&quot;&gt;安装Redis&amp;lt;准备&amp;gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一 架构细节&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所有的redis节点彼此互联(PING-PONG机制) 内部使用二进制协议优化传输速度和带宽&lt;/p&gt;
&lt;p&gt;节点的fail是通过集群中超过半数的节点检测失效时才生效&lt;/p&gt;
&lt;p&gt;客户端与redis节点直连 不需要中间代理层 客户端不需要连接集群所有节点 连接集群中任何一个可用节点即可&lt;/p&gt;
&lt;p&gt;redis-cluster把所有的物理节点映射到[0-16383]slot上 cluster负责维护(redis集群中内置了16384个哈希槽 当需要在redis集群中放置一个key-value时 redis先对key使用crc16算法算出一个结果 然后把结果对16384求余数 这样每个key都会对应一个编号在0-16383之间的哈希槽 redis会根据节点数量大致均等的将哈希槽映射到不同的节点)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775225/201807/775225-20180710225628212-1588709290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775225/201807/775225-20180710225654963-287540015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;redis集群中至少应该有三个节点 要保证集群的高可用 需要每个节点有一个备份机&lt;/p&gt;
&lt;p&gt;redis集群至少需要6台服务器&lt;/p&gt;
&lt;p&gt;这里我准备了6台服务器&lt;/p&gt;
&lt;p&gt;120.79.191.xxx　　39.108.121.xxx　　120.77.148.xxx　　39.108.162.xxx　　120.79.62.xxx　　112.74.54.xxx&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二 在六台服务器上分别安装运行redis&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;redis依赖&lt;/p&gt;
&lt;p&gt;　　yum install gcc-c++&lt;/p&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;p&gt;　　cd redis压缩包所在目录&lt;/p&gt;
&lt;p&gt;　　tar -xvf redis-4.0.10.tar.gz&lt;/p&gt;
&lt;p&gt;编译&lt;/p&gt;
&lt;p&gt;　　cd redis解压包内部 -&amp;gt; cd /hy/redis-4.0.10&lt;/p&gt;
&lt;p&gt;　　make&lt;/p&gt;
&lt;p&gt;　　make install PREFIX=/usr/local/redis&lt;/p&gt;
&lt;p&gt;配置文件准备&lt;/p&gt;
&lt;p&gt;　　cp /hy/redis-4.0.10/redis.conf /usr/local/redis/bin&lt;/p&gt;
&lt;p&gt;编辑(根据key修改value)&lt;/p&gt;
&lt;p&gt;　　vim /usr/local/redis/bin/redis.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 注释掉bind
# bind &lt;/span&gt;127.0.0.1&lt;span&gt;
# 设置后台启动
daemonize yes
# 设置集群密码
masterauth redis12345
# 设置单机密码
requirepass redis12345
# 开启集群
cluster&lt;/span&gt;-&lt;span&gt;enabled yes
# 设置集群节点超时
cluster&lt;/span&gt;-node-timeout 15000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入bin目录&lt;/p&gt;
&lt;p&gt;　　cd /usr/local/redis/bin&lt;/p&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;p&gt;　　./redis-server redis.conf&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三 选择其中一台服务器配置集群&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ruby环境&lt;/p&gt;
&lt;p&gt;　　yum install curl&lt;/p&gt;
&lt;p&gt;　　curl -L get.rvm.io | bash -s stable&lt;/p&gt;
&lt;p&gt;　　gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3&lt;/p&gt;
&lt;p&gt;　　\curl -sSL https://get.rvm.io | bash -s stable&lt;/p&gt;
&lt;p&gt;　　source ~/.bashrc&lt;/p&gt;
&lt;p&gt;　　source ~/.bash_profile&lt;/p&gt;
&lt;p&gt;　　source /usr/local/rvm/scripts/rvm&lt;/p&gt;
&lt;p&gt;　　rvm list known&lt;/p&gt;
&lt;p&gt;　　rvm install 2.5.1&lt;/p&gt;
&lt;p&gt;　　rvm use 2.5.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775225/201807/775225-20180710225605497-802228081.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装ruby脚本库&lt;/p&gt;
&lt;p&gt;　　cd ruby脚本库压缩包所在目录&lt;/p&gt;
&lt;p&gt;　　gem install redis-4.0.1.gem&lt;/p&gt;
&lt;p&gt;编辑(根据key修改value)&lt;/p&gt;
&lt;p&gt;　　vim /usr/local/rvm/gems/ruby-2.5.1/gems/redis-4.0.1/lib/redis/client.rb&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
:host =&amp;gt; &quot;0.0.0.0&quot;&lt;span&gt;,
:password &lt;/span&gt;=&amp;gt; &quot;redis12345&quot;,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;脚本文件准备&lt;/p&gt;
&lt;p&gt;　　cp /hy/redis-4.0.10/src/redis-trib.rb /usr/local/redis/bin&lt;/p&gt;
&lt;p&gt;执行脚本命令&lt;/p&gt;
&lt;p&gt;　　cd /usr/local/redis/bin&lt;/p&gt;
&lt;p&gt;　　./redis-trib.rb create --replicas 1 120.79.191.xxx:6379 39.108.121.xxx:6379 120.77.148.xxx:6379 39.108.162.xxx:6379 120.79.62.xxx:6379 112.74.54.xxx:6379&lt;/p&gt;

</description>
<pubDate>Tue, 10 Jul 2018 14:59:00 +0000</pubDate>
<dc:creator>梦三</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangyi-427/p/9291990.html</dc:identifier>
</item>
<item>
<title>SpringCloud（一）浅谈SpringCloud - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/9291790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/9291790.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;现在微服务实在是太火了，所以我们必不可少的是要学习一下SpringCloud了，服务化的核心就是将传统的一站式应用&lt;br/&gt;根据业务拆分成一个一个的服务，而微服务在这个基础上要更彻底地去耦合（不再共享DB、KV，去掉重量级ESB），并&lt;br/&gt;且强调DevOps和快速演化。&lt;/p&gt;
&lt;p&gt;springcloud中常用的组件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务发现——Netflix Eureka&lt;/li&gt;
&lt;li&gt;客户端负载均衡——Netflix Ribbon&lt;/li&gt;
&lt;li&gt;断路器——Netflix Hystrix&lt;/li&gt;
&lt;li&gt;服务网关——Netflix Zuul&lt;/li&gt;
&lt;li&gt;分布式配置——Spring Cloud Config&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一springcloud的架构设计&quot;&gt;一、SpringCloud的架构设计&lt;/h2&gt;
&lt;h3 id=&quot;springcloud架构图细解&quot;&gt;1.1 SpringCloud架构图细解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sU15fEO.png&quot;/&gt;&lt;br/&gt;上面的SpirngCloud的架构图，分层概述一下。&lt;/p&gt;
&lt;ul readability=&quot;21.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;web服务器的选型，这个我选择的是nginx+keepalived，haproxy也是一个选择，但是haproxy在反向代理处理跨域&lt;br/&gt;访问的时候问题很多。所以我们nginx有些地方做了keep-alive模式处理，减少了三次握手的次数，提高了连接效率。&lt;br/&gt;keepalived做nginx的负载，虚拟一个vip对外，两个nginx做高可用，nginx本身反向代理zuul集群。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;api gateway，这里的zuul很多人诟病，说是速度慢推荐直接用nginx，这里我还是推荐使用zuul的，毕竟zuul含有&lt;br/&gt;拦截器和反向代理，在权限管理、单点登录、用户认证时候还是很有用的，而且zuul自带ribbon负载均衡，如果你直接用&lt;br/&gt;nginx，还需要单独做一个feign或者ribbon层，用来做业务集群的负载层，毕竟直接把接口暴露给web服务器太危险了。&lt;br/&gt;这里zuul带有ribbon负载均衡和hystrix断路器，直接反向代理serviceId就可以代理整个集群了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;业务集群，这一层我有些项目是分两层的，就是上面加了一个负载层，下面是从service开始的，底层只是单纯的接口，&lt;br/&gt;controller是单独一层由feign实现，然后内部不同业务服务接口互调，直接调用controller层，只能说效果一般，多&lt;br/&gt;了一次tcp连接。所以我推荐合并起来，因为做过spring cloud项目的都知道，feign是含有ribbon的，而zuul也含有&lt;br/&gt;ribbon，这样的话zuul调用服务集群，和服务集群间接口的互调都是高可用的，保证了通讯的稳定性。Hystrix还是要有&lt;br/&gt;的，没有断路器很难实现服务降级，会出现大量请求发送到不可用的节点。当然service是可以改造的，如果改造成rpc方&lt;br/&gt;式，那服务之间互调又是另外一种情况了，那就要做成负载池和接口服务池的形式了，负载池调用接口池，接口池互相rpc&lt;br/&gt;调用，feign client只是通过实现接口达到了仿rpc的形式，不过速度表现还是不错的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;redis缓存池，这个用来做session共享，分布式系统session共享是一个大问题。同时呢，redis做二级缓存对降低整个&lt;br/&gt;服务的响应时间，并且减少数据库的访问次数是很有帮助的。当然redis cluster还是redis sentinel自己选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;eureak注册中心这个高可用集群，这里有很多细节，比如多久刷新列表一次，多久监测心跳什么的，都很重要。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;spring admin，这个是很推荐的，这个功能很强大，可以集成turbine断路器监控器，而且可以定义所有类的log等级，&lt;br/&gt;不用单独去配置，还可以查看本地log日志文件，监控不同服务的机器参数及性能，非常强大。它加上elk动态日志收集系&lt;br/&gt;统，对于项目运维非常方便。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;zipkin，这个有两种方式，直接用它自己的功能界面查看方式，或者用stream流的方式，由elk动态日志系统收集。但&lt;br/&gt;是我必须要说，这个对系统的性能损害非常大，因为链路追踪的时候会造成响应等待，而且等待时间非常长接近1秒，这在&lt;br/&gt;生产环境是不能忍受的，所以生产环境最好关掉，有问题调试的时候再打开。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;消息队列，这个必须的，分布式系统不可能所有场景都满足强一致性，这里只能由消息队列来作为缓冲，这里我用的是&lt;br/&gt;Kafka。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;分布式事物，我认为这是分布式最困难的，因为不同的业务集群都对应自己的数据库，互相数据库不是互通的，互相服&lt;br/&gt;务调用只能是相互接口，有些甚至是异地的，这样造成的结果就是网络延迟造成的请求等待，网络抖动造成的数据丢失，&lt;br/&gt;这些都是很可怕的问题，所以必须要处理分布式事物。我推荐的是利用消息队列，采取二阶段提交协议配合事物补偿机制，&lt;br/&gt;具体的实现需要结合业务，这里篇幅有限就不展开说了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;config配置中心，这是很有必要的，因为服务太多配置文件太多，没有这个很难运维。这个一般利用消息队列建立一个&lt;br/&gt;spring cloud bus，由git存储配置文件，利用bus总线动态更新配置文件信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;实时分布式日志系统，logstash收集本地的log文件流，传输给elasticsearch，logstash有两种方式，1、是每一台&lt;br/&gt;机器启动一个logstash服务，读取本地的日志文件，生成流传给elasticsearch。2、logback引入logstash包，然后直&lt;br/&gt;接生产json流传给一个中心的logstash服务器，它再传给elasticsearch。elasticsearch再将流传给kibana，动态查&lt;br/&gt;看日志，甚至zipkin的流也可以直接传给elasticsearch。这个配合spring admin，一个查看动态日志，一个查看本地&lt;br/&gt;日志，同时还能远程管理不同类的日志级别，对集成和运维非常有利。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;两个总结&quot;&gt;1.2 两个总结&lt;/h3&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;spring cloud的很多东西都比较精确，比如断路器触发时间、事物补偿时间、http响应时间等，这些都需要好好的设计，&lt;br/&gt;而且可以优化的点非常多。比如：http通讯可以使用okhttp，jvm优化，nio模式，数据连接池等等，都可以很大的提高&lt;br/&gt;性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;docker问题，很多人说不用docker就不算微服务。其实我个人意见，spring cloud本身就是微服务的，只需要jdk环境&lt;br/&gt;即可。编写dockerfile也无非是集成jdk、添加jar包、执行jar而已，或者用docker compose，将多个不同服务的image&lt;br/&gt;组合run成容器而已。但是带来的问题很多，比如通讯问题、服务器性能损耗问题、容器进程崩溃问题，当然如果你有一套成&lt;br/&gt;熟的基于k8s的容器管理平台，这个是没问题的，如果没有可能就要斟酌了。而spring cloud本身就是微服务分布式的架构&lt;br/&gt;，所以个人还是推荐直接机器部署的，当然好的DevOps工具将会方便很多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二springcloud常用组件介绍&quot;&gt;二、SpringCloud常用组件介绍&lt;/h2&gt;
&lt;h3 id=&quot;eureka&quot;&gt;2.1 Eureka&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/JQ55mSX.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个RESTful服务，用来定位运行在AWS地区（Region）中的中间层服务。由两个组件组成：Eureka服务器和Eureka客户端。&lt;br/&gt;Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并&lt;br/&gt;提供服务的故障切换支 持。Netflix在其生产环境中使用的是另外的客户端，它提供基于流量、资源利用率以及出错状态的&lt;br/&gt;加权负载均衡。&lt;/p&gt;
&lt;h3 id=&quot;ribbon&quot;&gt;2.2 Ribbon&lt;/h3&gt;
&lt;p&gt;Ribbon，远程过程调用，包含软件负载均衡算法。&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/2NgtTuD.png&quot;/&gt;&lt;br/&gt;Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。&lt;br/&gt;下面是用到的一些负载均衡策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单轮询负载均衡&lt;/li&gt;
&lt;li&gt;加权响应时间负载均衡&lt;/li&gt;
&lt;li&gt;区域感知轮询负载均衡&lt;/li&gt;
&lt;li&gt;随机负载均衡&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Ribbon中还包括以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;易于与服务发现组件（比如Netflix的Eureka）集成&lt;/li&gt;
&lt;li&gt;使用Archaius完成运行时配置&lt;/li&gt;
&lt;li&gt;使用JMX暴露运维指标，使用Servo发布&lt;/li&gt;
&lt;li&gt;多种可插拔的序列化选择&lt;/li&gt;
&lt;li&gt;异步和批处理操作&lt;/li&gt;
&lt;li&gt;自动SLA框架&lt;/li&gt;
&lt;li&gt;系统管理/指标控制台&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;hystrix&quot;&gt;2.3 Hystrix&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ISGrUVg.png&quot;/&gt;&lt;br/&gt;断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它&lt;br/&gt;确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正​​，应用程序可以尝试调&lt;br/&gt;用操作。&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/tzu3QK3.png&quot;/&gt;&lt;br/&gt;断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助&lt;br/&gt;快速地拒绝对一个操作，即 很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高&lt;br/&gt;每次改变状态的时间的事件，该信息可以被用来监测由断路器保 护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在&lt;br/&gt;打开状态。&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/htdPI3w.png&quot;/&gt;&lt;br/&gt;流程图:&lt;/p&gt;
&lt;h3 id=&quot;zuul&quot;&gt;2.4 Zuul&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Nn0rdPB.png&quot;/&gt;&lt;br/&gt;类似nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。&lt;/p&gt;
&lt;h3 id=&quot;spring-cloud-config&quot;&gt;2.5 Spring Cloud Config&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/vjuHkpq.png&quot;/&gt;&lt;br/&gt;当一个系统中的配置文件发生改变的时候，我们需要重新启动该服务，才能使得新的配置文件生效，spring cloud config可以实&lt;br/&gt;现微服务中的所有系统的配置文件的统一管理，而且还可以实现当配置文件发生变化的时候，系统会自动更新获取新的配置&lt;/p&gt;
</description>
<pubDate>Tue, 10 Jul 2018 14:15:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/9291790.html</dc:identifier>
</item>
<item>
<title>R语言S3类的理解与构建 - ywliao</title>
<link>http://www.cnblogs.com/ywliao/p/9285778.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ywliao/p/9285778.html</guid>
<description>&lt;h3 id=&quot;r语言类&quot;&gt;R语言类&lt;/h3&gt;
&lt;p&gt;R语言的类有S3类和S4类，S3类用的比较广，创建简单粗糙但是灵活，而S4类比较精细，具有跟C++一样严格的结构。这里我们主要讲S3类。&lt;/p&gt;
&lt;h3 id=&quot;s3类的结构&quot;&gt;S3类的结构&lt;/h3&gt;
&lt;p&gt;S3类内部是一个list，append某个list类名称，就能成为该类。list里面的内容就是我们所说的属性.&lt;br/&gt;首先创建一个list&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;me &amp;lt;- list(seq = &quot;ATGC&quot;, length = nchar(&quot;ATGC&quot;))
me
$seq
[1] &quot;ATGC&quot;

$length
[1] 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在me这个list只属于list类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;me
$seq
[1] &quot;ATGC&quot;

$length
[1] 4

attr(,&quot;class&quot;)
[1] &quot;list&quot;   &quot;DNAseq&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们append 一个类名&quot;DNAseq&quot;，就这样我们创建了一个DNAseq类，类的属性有seq和length，值为ATGC和4&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class(me) &amp;lt;- append(class(me), &quot;DNAseq&quot;)
class(me)
[1] &quot;list&quot;   &quot;DNAseq&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过普通的list的方法来获得类的属性，比如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;me$seq
[1] &quot;ATGC&quot;
me$length
[1] 4&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;s3类的创建&quot;&gt;S3类的创建&lt;/h3&gt;
&lt;h3 id=&quot;简单直接的构建方法&quot;&gt;简单直接的构建方法&lt;/h3&gt;
&lt;p&gt;依据刚才的类的结构，我们用函数进行类的构建，函数的输入是要传入进行类的初始化的值，而函数的返回就是新生成的类。这样我们就可以根据不同的初始化值进行类的实例化。&lt;br/&gt;首先构造一个类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Straight forward approach
DNAseq &amp;lt;- function(seq = &quot;ATGCATGCATGCATGCATGC&quot;){
  me &amp;lt;- list(
    seq = seq,
    length = nchar(seq)
  )
  # Set the name for the class
  class(me) &amp;lt;- append(class(me), &quot;DNAseq&quot;)
  return(me)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类的实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;seq1 &amp;lt;- DNAseq()
seq1

$seq
[1] &quot;ATGCATGCATGCATGCATGC&quot;

$length
[1] 20

attr(,&quot;class&quot;)
[1] &quot;list&quot;   &quot;DNAseq&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;局部环境构建类的方法&quot;&gt;局部环境构建类的方法&lt;/h4&gt;
&lt;p&gt;当然本质还是list，但是巧妙的利用了函数运行时的局部环境。函数运行时，内部的环境是和外界隔离的，在函数内创建的变量不会影响函数外。而这种方法巧妙的取出了这个内部环境的指针，并且将它放到了list里面。最后append类名。在环境里面存放了list的指针，而在list里面又存放了环境的指针。之所以内部环境没有消失，我猜想是因为返回的类里面具有环境的指针的引用，所以内存没有释放，是一个智能指针，当然，我没有对这深究。这次属性并不是直接存放在list里面，而是存放在函数里面的环境中。而list里面放着：方法和当前环境的指针。assign是对环境中某个变量赋值，可以用get函数中获得环境中变量的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Local enviroment approach
DNASeq &amp;lt;- function(seq = &quot;ATGCATGCATGCATGCATGC&quot;){
  ## Get the enviroment for this
  thisEnv &amp;lt;- environment()
  
  seq &amp;lt;- seq
  length &amp;lt;- nchar(seq)
  
  ## Create the list used to represent the
  ## object for this class
  me &amp;lt;- list(
    ## Define the enviroment where this list is defined so
    ## that I can refer to it
    thisEnv = thisEnv,
    
    ## Method to refer to the current enviroment
    getEnv = function(){
      return(get(&quot;thisEnv&quot;, thisEnv))
    }
  )
    
    ## Define the value of list within the 
    ## current enviroment
    assign(&quot;this&quot;, me, envir = thisEnv)
    
    ##Set the name for the class
    class(me) &amp;lt;- append(class(me), &quot;DNASeq&quot;)
    return(me)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;seq2 &amp;lt;- DNASeq()
seq2
$thisEnv
&amp;lt;environment: 0x8e86a20&amp;gt;

$getEnv
function () 
{
    return(get(&quot;thisEnv&quot;, thisEnv))
}
&amp;lt;environment: 0x8e86a20&amp;gt;

$getseq
function () 
{
    return(get(&quot;seq&quot;, thisEnv))
}
&amp;lt;environment: 0x8e86a20&amp;gt;

$reverseComplement
function () 
{
    print(&quot;Calling the reverseComplement function of DNASeq class&quot;)
    to_base &amp;lt;- c(&quot;A&quot;, &quot;T&quot;, &quot;G&quot;, &quot;C&quot;)
    names(to_base) &amp;lt;- c(&quot;T&quot;, &quot;A&quot;, &quot;C&quot;, &quot;G&quot;)
    trans_seq_vect &amp;lt;- to_base[unlist(strsplit(get(&quot;seq&quot;, thisEnv), 
        split = &quot;&quot;))]
    trans_rev_vect &amp;lt;- trans_seq_vect[length(trans_seq_vect):1]
    newseq &amp;lt;- paste0(trans_rev_vect, collapse = &quot;&quot;)
    return(DNASeq(newseq))
}
&amp;lt;environment: 0x8e86a20&amp;gt;

attr(,&quot;class&quot;)
[1] &quot;list&quot;   &quot;DNASeq&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获得里面的seq属性的值，这里使用get获得环境中的变量的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;get(&quot;seq&quot;, seq2$getEnv())
[1] &quot;ATGCATGCATGCATGCATGC&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，如果使用这种方法生成的类，我们获得属性通常不再函数外用get，因为这样并不像面向对象的用法，我们会在给类一个方法，某个类调用这个方法之后就可以获得某个属性的值，比如可以在list中再写一个函数，getseq，就等于get(&quot;seq&quot;, thisEnv)，这样就可以面向对象的使用seq2$getseq()来获得seq属性。当我们列表中添加方法时，注意应该用遵循列表的格式，用&quot;,”分开不同的方法或者不同的值。&lt;/p&gt;
&lt;h3 id=&quot;创建方法&quot;&gt;创建方法&lt;/h3&gt;
&lt;p&gt;类中除了含有属性外，肯定还得含有方法。上面我们讲到用局部环境变量创建S3类时可以在list里面存放方法。当然还有一种比较普遍的，在两种方式创建的S3类中都能使用的创建方法的途径。使用某方法.某类来创建某类的方法。比如print.gg就是对gg类的print的方法。但是在创建这种方法之前我们首先得用这个方法的名字创建一个函数，这样运行函数时首先进入这个函数，然后在函数里面使用useMethod函数，在环境中寻找该类的该方法。虽然下面的代码比较复杂，但是重点时看UseMethod。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Creating methods
reverseComplement &amp;lt;- function(object){
  UseMethod(&quot;reverseComplement&quot;, object)
}
reverseComplement.default &amp;lt;- function(object){
  print(&quot;The class of this object can not be found&quot;)
}

# Straight forward approach
#
# For S3 classes created by Straight forward approach
reverseComplement.DNAseq &amp;lt;- function(object){
  print(&quot;Calling the reverseComplement function of DNAseq class&quot;)
  ## Compelement according to the vector below
  to_base &amp;lt;- c(&quot;A&quot;, &quot;T&quot;, &quot;G&quot;, &quot;C&quot;)
  names(to_base) &amp;lt;- c(&quot;T&quot;, &quot;A&quot;, &quot;C&quot;, &quot;G&quot;)
  ## Transform long charactor to vector and complement
  trans_seq_vect &amp;lt;- to_base[unlist(strsplit(object$seq, split = &quot;&quot;))]
  ## Reverse
  trans_rev_vect &amp;lt;- trans_seq_vect[length(trans_seq_vect):1]
  ## Collape to long character
  newseq &amp;lt;- paste0(trans_rev_vect, collapse = &quot;&quot;)
  # Return a new DNAseq class
  return(DNAseq(newseq))
}

# For S3 classed created by local enviroment approach
reverseComplement.DNASeq &amp;lt;- function(object){
  print(&quot;Calling the reverseComplement function of DNASeq class&quot;)
  ## Compelement according to the vector below
  to_base &amp;lt;- c(&quot;A&quot;, &quot;T&quot;, &quot;G&quot;, &quot;C&quot;)
  names(to_base) &amp;lt;- c(&quot;T&quot;, &quot;A&quot;, &quot;C&quot;, &quot;G&quot;)
  ## Transform long charactor to vector and complement
  trans_seq_vect &amp;lt;- to_base[unlist(strsplit(get(&quot;seq&quot;, seq2$getEnv()), split = &quot;&quot;))]
  ## Reverse
  trans_rev_vect &amp;lt;- trans_seq_vect[length(trans_seq_vect):1]
  ## Collape to long character
  newseq &amp;lt;- paste0(trans_rev_vect, collapse = &quot;&quot;)
  # Return a new DNASeq class
  return(DNASeq(newseq))
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面还有一个default函数，表示默认的方法，如果该类找不到该类匹配的方法，就会使用默认方法。&lt;/p&gt;
&lt;h3 id=&quot;类继承&quot;&gt;类继承&lt;/h3&gt;
&lt;p&gt;S3类可以使用继承，在原来类的基础上再append一个新的类名即为新的类，用NextMethod可以调用下一层类的方法。&lt;br/&gt;创建一个primer类继承DNAseq类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#inheritance 
Primer &amp;lt;- function(seq = &quot;ATGCATGCATGCATGCATGCGGCC&quot;){
  pr &amp;lt;- strtrim(seq, 20)
  me &amp;lt;- DNAseq(pr)
  class(me) &amp;lt;- append(class(me), &quot;Primer&quot;)
  return(me)
}
Primer1 &amp;lt;- Primer()
Primer1
$seq
[1] &quot;ATGCATGCATGCATGCATGC&quot;

$length
[1] 20

attr(,&quot;class&quot;)
[1] &quot;list&quot;   &quot;DNAseq&quot; &quot;Primer&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用方法的时候会按照从左到右的顺序，再这个例子中，默认先调用DNAseq的方法，如果想要调用Primer类的方法，首先写一个Primer的reverseComplement方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Creating methods 
reverseComplement.Primer &amp;lt;- function(object){
  print(&quot;Running reverseComplement of Primer class&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在DNAseq类中调用下一类的方法，使用NextMethod&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;reverseComplement.DNAseq &amp;lt;- function(object){
  print(&quot;Calling the reverseComplement function of DNAseq class&quot;)
  NextMethod(&quot;reverseComplement&quot;, object)
  ## Compelement according to the vector below
  to_base &amp;lt;- c(&quot;A&quot;, &quot;T&quot;, &quot;G&quot;, &quot;C&quot;)
  names(to_base) &amp;lt;- c(&quot;T&quot;, &quot;A&quot;, &quot;C&quot;, &quot;G&quot;)
  ## Transform long charactor to vector and complement
  trans_seq_vect &amp;lt;- to_base[unlist(strsplit(object$seq, split = &quot;&quot;))]
  ## Reverse
  trans_rev_vect &amp;lt;- trans_seq_vect[length(trans_seq_vect):1]
  ## Collape to long character
  newseq &amp;lt;- paste0(trans_rev_vect, collapse = &quot;&quot;)
  # Return a new DNAseq class
  return(DNAseq(newseq))
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;reverseComplement(Primer1)
[1] &quot;Calling the reverseComplement function of DNAseq class&quot;
[1] &quot;Running reverseComplement of Primer class&quot;
$seq
[1] &quot;GCATGCATGCATGCATGCAT&quot;

$length
[1] 20

attr(,&quot;class&quot;)
[1] &quot;list&quot;   &quot;DNAseq&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;reverseComplement(seq1)
[1] &quot;Calling the reverseComplement function of DNAseq class&quot;
[1] &quot;The class of this object can not be found&quot;
$seq
[1] &quot;GCATGCATGCATGCATGCAT&quot;

$length
[1] 20

attr(,&quot;class&quot;)
[1] &quot;list&quot;   &quot;DNAseq&quot;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 10 Jul 2018 14:11:00 +0000</pubDate>
<dc:creator>ywliao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ywliao/p/9285778.html</dc:identifier>
</item>
<item>
<title>记今日的面试 - allen_xia</title>
<link>http://www.cnblogs.com/allenxia/p/9291728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/allenxia/p/9291728.html</guid>
<description>&lt;p&gt;今天的上午下午各一场面试，虽然自己有精心准备，但是面试的效果还是不是很好，网上搜罗的面试题，算法题等等，都有消化吸收，也不能说完全没有用吧，至少在笔试题还是用上了的，功夫也算是没有白费，废话不多说了，总结下今日面试不好的地方，砥砺前行！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上午面试&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;　1.promise的处理分为then，与catch，then的返回值被下一个promise对象所接收，这个then return的值是否有限制：&lt;/p&gt;
&lt;p&gt;　　刚听到这个题目的时候我是懵逼的，promise的then一般接收resolve函数，promise的catch一般接收错误的函数，then的返回值会被下一个promise接收，但是对于返回值的约定，这点不是很清楚，面试结束过后就去百度了一下，也没找到结果，暂时作为一个疑点&lt;/p&gt;
&lt;p&gt;　2.vue-router的配置&lt;/p&gt;
&lt;p&gt;　　vue-router有base与mode配置项，vue-router有使用过，但是没有配置过，再次去翻看vue文档，找到了结果&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;mode：
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;类型: string
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 默认值: &quot;hash&quot; (浏览器环境) | &quot;abstract&quot;&lt;span&gt; (Node.js 环境)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 可选值: &quot;hash&quot; | &quot;history&quot; | &quot;abstract&quot;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;配置路由模式:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式。
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; #        
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;base：
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;类型: string
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; 默认值: &quot;/&quot;
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; 应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 &quot;/app/&quot;。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　3.vue的生命周期&lt;/p&gt;
&lt;p&gt;　　vue生命周期的介绍网上有很多，今天面试的时候，我回答了8个周期的钩子,回答的不是很全面，所以查阅了资料进行了补充&lt;/p&gt;
&lt;p&gt;　　（1）beforecreate created &lt;/p&gt;
&lt;p&gt;　　　　　　beforecreate：组件实例刚刚被创建，　　组件属性计算之前，如data属性&lt;/p&gt;
&lt;p&gt;　　　　　　created:  组件实例创建完成，属性绑定，但是dom未生成&lt;/p&gt;
&lt;p&gt;　　（2）beforemount beforemounted&lt;/p&gt;
&lt;p&gt;　　　　　　beforemount：模版编译挂载之前&lt;/p&gt;
&lt;p&gt;　　　　　　mounted：模版编译挂载之后&lt;/p&gt;
&lt;p&gt;　　（3）beforeupdate updated&lt;/p&gt;
&lt;p&gt;　　　　　　beforeupdate：更新之前&lt;/p&gt;
&lt;p&gt;　　　　　　updated：更新之后&lt;/p&gt;
&lt;p&gt;　　  (4)  beforedestory destoryed&lt;/p&gt;
&lt;p&gt;　　　　　　beforedestory：组件销毁之前调用&lt;/p&gt;
&lt;p&gt;　　　　　　　　在下午的面试中，面试官问我，什么时候调用这个钩子，我没有用过，没有回答，百度==》&lt;code&gt;beforeDestroy&lt;/code&gt;： 你确认删除XX吗？ destroyed ：当前组件已被删除，清空相关内容&lt;/p&gt;
&lt;p&gt;　　　　　　destoryed：销毁之后&lt;/p&gt;
&lt;p&gt;　　下午：&lt;/p&gt;
&lt;p&gt;　　　　1.原生js实现一个居中弹窗：&lt;/p&gt;
&lt;p&gt;　　　　　　关于弹窗实现我回答出来了，就是点击弹窗按钮生成一个div，append到body里面去，在回答居中的问题上，有点问题，除了display：flex，面试官问我是否有别的办法，我说了给定位，然后left：50%，再margin-left：自身宽度的一半，他继续问，如果未知宽度呢，当时除了display没想到别的办法，有点紧张，后来面完了在路上想到了，还是定位，视口宽度的一半减去元素自身宽度的一半，未知宽度可以用clientwidth来获取，视口宽度：document.documentelement.clientwidth来获取，即使是没定定宽的元素，这样也是可以获取的。&lt;/p&gt;
&lt;p&gt;　　　　2.原生轮播图：&lt;/p&gt;
&lt;p&gt;　　　　　　之前写过很多次的原生轮播图，但是面试的时候竟然没回答出来，回来赶紧看了一遍，父容器相对定位，超出隐藏，里面放一个ul，绝对定位，ul的宽度为所有图片的宽度，比如图片为7张，ul的宽度为700%，然后里面的li全部浮动到左边，通过改变ul的left值，来实现图片的左右轮播。回答的时候脑抽来竟然说父容器也是绝对定位...&lt;/p&gt;
&lt;p&gt;　　以上是今天面试的总结，结果应该不是很好，总结总结经验，下次继续，多储备一些vue相关的知识，继续加油！&lt;/p&gt;

</description>
<pubDate>Tue, 10 Jul 2018 14:01:00 +0000</pubDate>
<dc:creator>allen_xia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/allenxia/p/9291728.html</dc:identifier>
</item>
<item>
<title>System.IO.Pipelines: .NET高性能IO - 潇湘风夜</title>
<link>http://www.cnblogs.com/xxfy1/p/9290235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxfy1/p/9290235.html</guid>
<description>&lt;p&gt;&lt;code&gt;System.IO.Pipelines&lt;/code&gt;是一个新的库，旨在简化在.NET中执行高性能IO的过程。它是一个依赖.NET Standard的库，&lt;strong&gt;适用于所有.NET实现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Pipelines诞生于.NET Core团队，为使Kestrel成为业界最快的Web服务器之一。最初从作为Kestrel内部的实现细节发展成为可重用的API，它在.Net Core 2.1中作为可用于所有.NET开发人员的最高级BCL API（System.IO.Pipelines）提供。&lt;/p&gt;
&lt;h2 id=&quot;它解决了什么问题&quot;&gt;它解决了什么问题？&lt;/h2&gt;
&lt;p&gt;为了正确解析Stream或Socket中的数据，代码有固定的样板，并且有许多极端情况，为了处理他们，不得不编写难以维护的复杂代码。&lt;br/&gt;实现高性能和正确性，同时也难以处理这种复杂性。Pipelines旨在解决这种复杂性。&lt;/p&gt;
&lt;h2 id=&quot;有多复杂&quot;&gt;有多复杂？&lt;/h2&gt;
&lt;p&gt;让我们从一个简单的问题开始吧。我们想编写一个TCP服务器，它接收来自客户端的用行分隔的消息（由&lt;code&gt;\n&lt;/code&gt;分隔）。（译者注：即一行为一条消息）&lt;/p&gt;
&lt;h2 id=&quot;使用networkstream的tcp服务器&quot;&gt;使用NetworkStream的TCP服务器&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;声明：与所有对性能敏感的工作一样，应在应用程序中测量每个方案的实际情况。根据您的网络应用程序需要处理的规模，可能不需要在乎的各种技术的开销。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Pipelines之前用.NET编写的典型代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;async Task ProcessLinesAsync(NetworkStream stream)
{
    var buffer = new byte[1024];
    await stream.ReadAsync(buffer, 0, buffer.Length);
    
    // 在buffer中处理一行消息
    ProcessLine(buffer);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此代码可能在本地测试时正确工作，但它有几个潜在错误：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一次&lt;code&gt;ReadAsync&lt;/code&gt;调用可能没有收到整个消息（行尾）。&lt;/li&gt;
&lt;li&gt;它忽略了&lt;code&gt;stream.ReadAsync()&lt;/code&gt;返回值中实际填充到&lt;code&gt;buffer&lt;/code&gt;中的数据量。（译者注：即不一定将&lt;code&gt;buffer&lt;/code&gt;填充满）&lt;/li&gt;
&lt;li&gt;一次&lt;code&gt;ReadAsync&lt;/code&gt;调用不能处理多条消息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些是读取流数据时常见的一些缺陷。为了解决这个问题，我们需要做一些改变：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们需要缓冲传入的数据，直到找到新的行。&lt;/li&gt;
&lt;li&gt;我们需要解析缓冲区中返回的所有行&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;async Task ProcessLinesAsync(NetworkStream stream)
{
    var buffer = new byte[1024];
    var bytesBuffered = 0;
    var bytesConsumed = 0;

    while (true)
    {
        var bytesRead = await stream.ReadAsync(buffer, bytesBuffered, buffer.Length - bytesBuffered);
        if (bytesRead == 0)
        {
            // EOF 已经到末尾
            break;
        }
        // 跟踪已缓冲的字节数
        bytesBuffered += bytesRead;
        
        var linePosition = -1;

        do
        {
            // 在缓冲数据中查找找一个行末尾
            linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed);

            if (linePosition &amp;gt;= 0)
            {
                // 根据偏移量计算一行的长度
                var lineLength = linePosition - bytesConsumed;

                // 处理这一行
                ProcessLine(buffer, bytesConsumed, lineLength);

                // 移动bytesConsumed为了跳过我们已经处理掉的行 (包括\n)
                bytesConsumed += lineLength + 1;
            }
        }
        while (linePosition &amp;gt;= 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一次，这可能适用于本地开发，但一行可能大于1KiB（1024字节）。我们需要调整输入缓冲区的大小，直到找到新行。&lt;/p&gt;
&lt;p&gt;因此，我们可以在堆上分配缓冲区去处理更长的一行。我们从客户端解析较长的一行时，可以通过使用&lt;code&gt;ArrayPool&amp;lt;byte&amp;gt;&lt;/code&gt;避免重复分配缓冲区来改进这一点。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;async Task ProcessLinesAsync(NetworkStream stream)
{
    byte[] buffer = ArrayPool&amp;lt;byte&amp;gt;.Shared.Rent(1024);
    var bytesBuffered = 0;
    var bytesConsumed = 0;

    while (true)
    {
        // 在buffer中计算中剩余的字节数
        var bytesRemaining = buffer.Length - bytesBuffered;

        if (bytesRemaining == 0)
        {
            // 将buffer size翻倍 并且将之前缓冲的数据复制到新的缓冲区
            var newBuffer = ArrayPool&amp;lt;byte&amp;gt;.Shared.Rent(buffer.Length * 2);
            Buffer.BlockCopy(buffer, 0, newBuffer, 0, buffer.Length);
            // 将旧的buffer丢回池中
            ArrayPool&amp;lt;byte&amp;gt;.Shared.Return(buffer);
            buffer = newBuffer;
            bytesRemaining = buffer.Length - bytesBuffered;
        }

        var bytesRead = await stream.ReadAsync(buffer, bytesBuffered, bytesRemaining);
        if (bytesRead == 0)
        {
            // EOF 末尾
            break;
        }
        
        // 跟踪已缓冲的字节数
        bytesBuffered += bytesRead;
        
        do
        {
            // 在缓冲数据中查找找一个行末尾
            linePosition = Array.IndexOf(buffer, (byte)'\n', bytesConsumed, bytesBuffered - bytesConsumed);

            if (linePosition &amp;gt;= 0)
            {
                // 根据偏移量计算一行的长度
                var lineLength = linePosition - bytesConsumed;

                // 处理这一行
                ProcessLine(buffer, bytesConsumed, lineLength);

                // 移动bytesConsumed为了跳过我们已经处理掉的行 (包括\n)
                bytesConsumed += lineLength + 1;
            }
        }
        while (linePosition &amp;gt;= 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码有效，但现在我们正在重新调整缓冲区大小，从而产生更多缓冲区副本。它将使用更多内存，因为根据代码在处理一行行后不会缩缓冲区的大小。为避免这种情况，我们可以存储缓冲区序列，而不是每次超过1KiB大小时调整大小。&lt;/p&gt;
&lt;p&gt;此外，我们不会增长1KiB的 缓冲区，直到它完全为空。这意味着我们最终传递给&lt;code&gt;ReadAsync&lt;/code&gt;越来越小的缓冲区，这将导致对操作系统的更多调用。&lt;/p&gt;
&lt;p&gt;为了缓解这种情况，我们将在现有缓冲区中剩余少于512个字节时分配一个新缓冲区：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;译者注：这段代码太复杂了，懒得翻译注释了，大家将就看吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class BufferSegment
{
    public byte[] Buffer { get; set; }
    public int Count { get; set; }

    public int Remaining =&amp;gt; Buffer.Length - Count;
}

async Task ProcessLinesAsync(NetworkStream stream)
{
    const int minimumBufferSize = 512;

    var segments = new List&amp;lt;BufferSegment&amp;gt;();
    var bytesConsumed = 0;
    var bytesConsumedBufferIndex = 0;
    var segment = new BufferSegment { Buffer = ArrayPool&amp;lt;byte&amp;gt;.Shared.Rent(1024) };

    segments.Add(segment);

    while (true)
    {
        // Calculate the amount of bytes remaining in the buffer
        if (segment.Remaining &amp;lt; minimumBufferSize)
        {
            // Allocate a new segment
            segment = new BufferSegment { Buffer = ArrayPool&amp;lt;byte&amp;gt;.Shared.Rent(1024) };
            segments.Add(segment);
        }

        var bytesRead = await stream.ReadAsync(segment.Buffer, segment.Count, segment.Remaining);
        if (bytesRead == 0)
        {
            break;
        }

        // Keep track of the amount of buffered bytes
        segment.Count += bytesRead;

        while (true)
        {
            // Look for a EOL in the list of segments
            var (segmentIndex, segmentOffset) = IndexOf(segments, (byte)'\n', bytesConsumedBufferIndex, bytesConsumed);

            if (segmentIndex &amp;gt;= 0)
            {
                // Process the line
                ProcessLine(segments, segmentIndex, segmentOffset);

                bytesConsumedBufferIndex = segmentOffset;
                bytesConsumed = segmentOffset + 1;
            }
            else
            {
                break;
            }
        }

        // Drop fully consumed segments from the list so we don't look at them again
        for (var i = bytesConsumedBufferIndex; i &amp;gt;= 0; --i)
        {
            var consumedSegment = segments[i];
            // Return all segments unless this is the current segment
            if (consumedSegment != segment)
            {
                ArrayPool&amp;lt;byte&amp;gt;.Shared.Return(consumedSegment.Buffer);
                segments.RemoveAt(i);
            }
        }
    }
}

(int segmentIndex, int segmentOffest) IndexOf(List&amp;lt;BufferSegment&amp;gt; segments, byte value, int startBufferIndex, int startSegmentOffset)
{
    var first = true;
    for (var i = startBufferIndex; i &amp;lt; segments.Count; ++i)
    {
        var segment = segments[i];
        // Start from the correct offset
        var offset = first ? startSegmentOffset : 0;
        var index = Array.IndexOf(segment.Buffer, value, offset, segment.Count - offset);

        if (index &amp;gt;= 0)
        {
            // Return the buffer index and the index within that segment where EOL was found
            return (i, index);
        }

        first = false;
    }
    return (-1, -1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此代码只是得到很多更加复杂。当我们正在寻找分隔符时，我们同时跟踪已填充的缓冲区序列。为此，我们此处使用&lt;code&gt;List&amp;lt;BufferSegment&amp;gt;&lt;/code&gt;查找新行分隔符时表示缓冲数据。其结果是，&lt;code&gt;ProcessLine&lt;/code&gt;和&lt;code&gt;IndexOf&lt;/code&gt;现在接受&lt;code&gt;List&amp;lt;BufferSegment&amp;gt;&lt;/code&gt;作为参数，而不是一个&lt;code&gt;byte[]，offset和count&lt;/code&gt;。我们的解析逻辑现在需要处理一个或多个缓冲区序列。&lt;/p&gt;
&lt;p&gt;我们的服务器现在处理部分消息，它使用池化内存来减少总体内存消耗，但我们还需要进行更多更改：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们使用的&lt;code&gt;byte[]&lt;/code&gt;和&lt;code&gt;ArrayPool&amp;lt;byte&amp;gt;&lt;/code&gt;的只是普通的托管数组。这意味着无论何时我们执行&lt;code&gt;ReadAsync&lt;/code&gt;或&lt;code&gt;WriteAsync&lt;/code&gt;，这些缓冲区都会在异步操作的生命周期内被固定（以便与操作系统上的本机IO API互操作）。这对GC有性能影响，因为无法移动固定内存，这可能导致堆碎片。根据异步操作挂起的时间长短，池的实现可能需要更改。&lt;/li&gt;
&lt;li&gt;可以通过解耦&lt;strong&gt;读取逻辑&lt;/strong&gt;和&lt;strong&gt;处理逻辑&lt;/strong&gt;来优化吞吐量。这会创建一个批处理效果，使解析逻辑可以使用更大的缓冲区块，而不是仅在解析单个行后才读取更多数据。这引入了一些额外的复杂性
&lt;ul&gt;&lt;li&gt;我们需要两个彼此独立运行的循环。一个读取Socket和一个解析缓冲区。&lt;/li&gt;
&lt;li&gt;当数据可用时，我们需要一种方法来向&lt;strong&gt;解析逻辑&lt;/strong&gt;发出信号。&lt;/li&gt;
&lt;li&gt;我们需要决定如果循环读取Socket“太快”会发生什么。如果&lt;strong&gt;解析逻辑&lt;/strong&gt;无法跟上，我们需要一种方法来限制&lt;strong&gt;读取循环（逻辑）&lt;/strong&gt;。这通常被称为“流量控制”或“背压”。&lt;/li&gt;
&lt;li&gt;我们需要确保事情是线程安全的。我们现在在&lt;strong&gt;读取循环&lt;/strong&gt;和&lt;strong&gt;解析循环&lt;/strong&gt;之间共享多个缓冲区，并且这些缓冲区在不同的线程上独立运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理逻辑&lt;/strong&gt;现在分布在两个不同的代码段中，从填充缓冲区池的代码是从套接字读取的，而从缓冲区池取数据的代码是&lt;strong&gt;解析逻辑&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;我们需要非常小心在&lt;strong&gt;解析逻辑&lt;/strong&gt;完成之后我们如何处理缓冲区序列。如果我们不小心，我们可能会返回一个仍由Socket读取逻辑写入的缓冲区序列。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;复杂性已经到了极端（我们甚至没有涵盖所有案例）。高性能网络应用通常意味着编写非常复杂的代码，以便从系统中获得更高的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;System.IO.Pipelines的目标是使这种类型的代码更容易编写。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用system.io.pipelines的tcp服务器&quot;&gt;使用System.IO.Pipelines的TCP服务器&lt;/h2&gt;
&lt;p&gt;让我们来看看这个例子的样子System.IO.Pipelines：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;async Task ProcessLinesAsync(Socket socket)
{
    var pipe = new Pipe();
    Task writing = FillPipeAsync(socket, pipe.Writer);
    Task reading = ReadPipeAsync(pipe.Reader);

    return Task.WhenAll(reading, writing);
}

async Task FillPipeAsync(Socket socket, PipeWriter writer)
{
    const int minimumBufferSize = 512;

    while (true)
    {
        // 从PipeWriter至少分配512字节
        Memory&amp;lt;byte&amp;gt; memory = writer.GetMemory(minimumBufferSize);
        try 
        {
            int bytesRead = await socket.ReceiveAsync(memory, SocketFlags.None);
            if (bytesRead == 0)
            {
                break;
            }
            // 告诉PipeWriter从套接字读取了多少
            writer.Advance(bytesRead);
        }
        catch (Exception ex)
        {
            LogError(ex);
            break;
        }

        // 标记数据可用，让PipeReader读取
        FlushResult result = await writer.FlushAsync();

        if (result.IsCompleted)
        {
            break;
        }
    }

    // 告诉PipeReader没有更多的数据
    writer.Complete();
}

async Task ReadPipeAsync(PipeReader reader)
{
    while (true)
    {
        ReadResult result = await reader.ReadAsync();

        ReadOnlySequence&amp;lt;byte&amp;gt; buffer = result.Buffer;
        SequencePosition? position = null;

        do 
        {
            // 在缓冲数据中查找找一个行末尾
            position = buffer.PositionOf((byte)'\n');

            if (position != null)
            {
                // 处理这一行
                ProcessLine(buffer.Slice(0, position.Value));
                
                // 跳过 这一行+\n (basically position 主要位置？)
                buffer = buffer.Slice(buffer.GetPosition(1, position.Value));
            }
        }
        while (position != null);

        // 告诉PipeReader我们以及处理多少缓冲
        reader.AdvanceTo(buffer.Start, buffer.End);

        // 如果没有更多的数据，停止都去
        if (result.IsCompleted)
        {
            break;
        }
    }

    // 将PipeReader标记为完成
    reader.Complete();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的行读取器的pipelines版本有2个循环：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;FillPipeAsync&lt;/code&gt;从Socket读取并写入PipeWriter。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReadPipeAsync&lt;/code&gt;从PipeReader中读取并解析传入的行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与原始示例不同，在任何地方都没有分配显式缓冲区。这是管道的核心功能之一。所有缓冲区管理都委托给PipeReader/PipeWriter实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这使得使用代码更容易专注于业务逻辑而不是复杂的缓冲区管理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在第一个循环中，我们首先调用&lt;code&gt;PipeWriter.GetMemory(int)&lt;/code&gt;从底层编写器获取一些内存; 然后我们调用&lt;code&gt;PipeWriter.Advance(int)&lt;/code&gt;告诉PipeWriter我们实际写入缓冲区的数据量。然后我们调用&lt;code&gt;PipeWriter.FlushAsync()&lt;/code&gt;来提供数据给PipeReader。&lt;/p&gt;
&lt;p&gt;在第二个循环中，我们正在使用PipeWriter最终来自的缓冲区Socket。当调用&lt;code&gt;PipeReader.ReadAsync()&lt;/code&gt;返回时，我们得到一个ReadResult包含2条重要信息，包括以&lt;code&gt;ReadOnlySequence&amp;lt;byte&amp;gt;&lt;/code&gt;形式读取的数据和&lt;code&gt;bool IsCompleted&lt;/code&gt;，让reader知道writer是否写完（EOF）。在找到行尾（EOL）分隔符并解析该行之后，我们将缓冲区切片以跳过我们已经处理过的内容，然后我们调用&lt;code&gt;PipeReader.AdvanceTo&lt;/code&gt;告诉PipeReader我们消耗了多少数据。&lt;/p&gt;
&lt;p&gt;在每个循环结束时，我们完成了reader和writer。这允许底层Pipe释放它分配的所有内存。&lt;/p&gt;
&lt;h2 id=&quot;system.io.pipelines&quot;&gt;System.IO.Pipelines&lt;/h2&gt;
&lt;p&gt;除了处理内存管理之外，其他核心管道功能还包括能够在Pipe不实际消耗数据的情况下查看数据。&lt;/p&gt;
&lt;p&gt;PipeReader有两个核心API &lt;code&gt;ReadAsync&lt;/code&gt;和&lt;code&gt;AdvanceTo&lt;/code&gt;。&lt;code&gt;ReadAsync&lt;/code&gt;获取Pipe数据，&lt;code&gt;AdvanceTo&lt;/code&gt;告诉PipeReader不再需要这些缓冲区，以便可以丢弃它们（例如返回到底层缓冲池）。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这是一个http解析器的示例，它在接收Pipe到有效起始行之前读取部分数据缓冲区数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/95136/42349904-1a6e3484-8063-11e8-8ac2-7f8e636b4a23.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;readonlysequencet&quot;&gt;ReadOnlySequence&amp;lt;T&amp;gt;&lt;/h2&gt;
&lt;p&gt;该Pipe实现存储了在PipeWriter和PipeReader之间传递的缓冲区的链接列表。PipeReader.ReadAsync暴露一个ReadOnlySequence&amp;lt;T&amp;gt;新的BCL类型，它表示一个或多个ReadOnlyMemory&amp;lt;T&amp;gt;段的视图，类似于Span&amp;lt;T&amp;gt;和Memory&amp;lt;T&amp;gt;提供数组和字符串的视图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/95136/42292592-74a4028e-7f88-11e8-85f7-a6b2f925769d.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该Pipe内部维护指向reader和writer可以分配或更新它们的数据集合，。SequencePosition表示缓冲区链表中的单个点，可用于有效地对ReadOnlySequence&amp;lt;T&amp;gt;进行切片。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这段实在翻译困难，给出原文&lt;br/&gt;The Pipe internally maintains pointers to where the reader and writer are in the overall set of allocated data and updates them as data is written or read. The SequencePosition represents a single point in the linked list of buffers and can be used to efficiently slice the ReadOnlySequence&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于ReadOnlySequence&amp;lt;T&amp;gt;可以支持一个或多个段，因此高性能处理逻辑通常基于单个或多个段来分割快速和慢速路径（fast and slow paths?）。&lt;/p&gt;
&lt;p&gt;例如，这是一个将ASCII ReadOnlySequence&amp;lt;byte&amp;gt;转换为string以下内容的例程：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;string GetAsciiString(ReadOnlySequence&amp;lt;byte&amp;gt; buffer)
{
    if (buffer.IsSingleSegment)
    {
        return Encoding.ASCII.GetString(buffer.First.Span);
    }

    return string.Create((int)buffer.Length, buffer, (span, sequence) =&amp;gt;
    {
        foreach (var segment in sequence)
        {
            Encoding.ASCII.GetChars(segment.Span, span);

            span = span.Slice(segment.Length);
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;背压和流量控制&quot;&gt;背压和流量控制&lt;/h2&gt;
&lt;p&gt;在一个完美的世界中，读取和解析工作是一个团队：读取线程消耗来自网络的数据并将其放入缓冲区，而解析线程负责构建适当的数据结构。通常，解析将比仅从网络复制数据块花费更多时间。结果，读取线程可以轻易地压倒解析线程。结果是读取线程必须减慢或分配更多内存来存储解析线程的数据。为获得最佳性能，在频繁暂停和分配更多内存之间存在平衡。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，管道有两个设置来控制数据的流量，PauseWriterThreshold和ResumeWriterThreshold。PauseWriterThreshold决定有多少数据应该在调用&lt;code&gt;PipeWriter.FlushAsync&lt;/code&gt;之前进行缓冲停顿。ResumeWriterThreshold控制reader消耗多少后写入可以恢复。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/95136/42291183-0114a0f2-7f7f-11e8-983f-5332b7585a09.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当Pipe的数据量超过PauseWriterThreshold，&lt;code&gt;PipeWriter.FlushAsync&lt;/code&gt;会异步阻塞。数据量变得低于ResumeWriterThreshold，它会解锁时。两个值用于防止在极限附近发生反复阻塞和解锁。&lt;/p&gt;
&lt;h2 id=&quot;io调度&quot;&gt;IO调度&lt;/h2&gt;
&lt;p&gt;通常在使用async / await时，会在线程池线程或当前线程上调用continuation SynchronizationContext。&lt;/p&gt;
&lt;p&gt;在执行IO时，对执行IO的位置进行细粒度控制非常重要，这样可以更有效地利用CPU缓存，这对于Web服务器等高性能应用程序至关重要。Pipelines公开了一个PipeScheduler确定异步回调运行位置的方法。这使得调用者可以精确控制用于IO的线程。&lt;/p&gt;
&lt;p&gt;实践中的一个示例是在Kestrel Libuv传输中，其中IO回调在专用事件循环线程上运行。&lt;/p&gt;
&lt;h2 id=&quot;pipereader模式的其他好处&quot;&gt;PipeReader模式的其他好处：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一些底层系统支持“无缓冲等待”，即，在底层系统中实际可用数据之前，永远不需要分配缓冲区。例如，在带有epoll的Linux上，可以等到数据准备好之后再实际提供缓冲区来进行读取。这避免了具有大量线程等待数据的问题不会立即需要保留大量内存。&lt;/li&gt;
&lt;li&gt;默认情况下Pipe，可以轻松地针对网络代码编写单元测试，因为解析逻辑与网络代码分离，因此单元测试仅针对内存缓冲区运行解析逻辑，而不是直接从网络中消耗。它还可以轻松测试那些难以测试发送部分数据的模式。ASP.NET Core使用它来测试Kestrel的http解析器的各个方面。&lt;/li&gt;
&lt;li&gt;允许将底层OS缓冲区（如Windows上的Registered IO API）暴露给用户代码的系统非常适合管道，因为缓冲区始终由PipeReader实现提供。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;其他相关类型&quot;&gt;其他相关类型&lt;/h2&gt;
&lt;p&gt;作为制作System.IO.Pipelines的一部分，我们还添加了许多新的原始BCL类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;MemoryPool&amp;lt;T&amp;gt;&lt;/code&gt;，&lt;code&gt;IMemoryOwner&amp;lt;T&amp;gt;&lt;/code&gt;，&lt;code&gt;MemoryManager&amp;lt;T&amp;gt;&lt;/code&gt; - .NET Core 1.0添加了&lt;code&gt;ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt;，在.NET Core 2.1中，我们现在有一个更通用的抽象，适用于任何工作的池&lt;code&gt;Memory&amp;lt;T&amp;gt;&lt;/code&gt;。这提供了一个可扩展点，允许您插入更高级的分配策略以及控制缓冲区的管理方式（例如，提供预先固定的缓冲区而不是纯托管的阵列）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IBufferWriter&amp;lt;T&amp;gt;&lt;/code&gt; - 表示用于写入同步缓冲数据的接收器。（PipeWriter实现这个）&lt;/li&gt;
&lt;li&gt;IValueTaskSource - &lt;code&gt;ValueTask&amp;lt;T&amp;gt;&lt;/code&gt;自.NET Core 1.1以来就已存在，但在.NET Core 2.1中获得了一些超级权限，允许无分配的等待异步操作。有关详细信息，请参阅https://github.com/dotnet/corefx/issues/27445。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;我如何使用管道&quot;&gt;我如何使用管道？&lt;/h2&gt;
&lt;p&gt;API存在于&lt;code&gt;System.IO.Pipelines&lt;/code&gt; nuget包中。&lt;/p&gt;
&lt;p&gt;以下是使用管道处理基于行的消息的.NET Core 2.1服务器应用程序的示例（上面的示例）&lt;a href=&quot;https://github.com/davidfowl/TcpEcho%E3%80%82%E5%AE%83%E5%BA%94%E8%AF%A5%E8%BF%90%E8%A1%8C%60dotnet&quot; class=&quot;uri&quot;&gt;https://github.com/davidfowl/TcpEcho。它应该运行`dotnet&lt;/a&gt; run`（或通过在Visual Studio中运行）。它侦听端口8087上的套接字并将收到的消息写入控制台。您可以使用netcat或putty等客户端建立与8087的连接，并发送基于行的消息以使其正常工作。&lt;/p&gt;
&lt;p&gt;今天Pipelines为Kestrel和SignalR提供支持，我们希望看见它作为.NET社区中许多网络库和组件的核心。&lt;/p&gt;
&lt;h2 id=&quot;资料&quot;&gt;资料：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;转载自&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/07/09/system-io-pipelines-high-performance-io-in-net/&quot;&gt;System.IO.Pipelines: High performance IO in .NET&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.marcgravell.com/2018/07/pipe-dreams-part-1.html&quot;&gt;Pipelines - a guided tour of the new IO API in .NET, part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.marcgravell.com/2018/07/pipe-dreams-part-2.html&quot;&gt;Pipelines - a guided tour of the new IO API in .NET, part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;2号资料的中文翻译 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/39223648&quot;&gt;Pipelines - .NET中的新IO API指引(一)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/System.IO.Pipelines/&quot;&gt;System.IO.Pipelines-Nuget包&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;PS: 首次翻译英文文章，不足错漏请指出，多谢支持&lt;/p&gt;
</description>
<pubDate>Tue, 10 Jul 2018 12:31:00 +0000</pubDate>
<dc:creator>潇湘风夜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xxfy1/p/9290235.html</dc:identifier>
</item>
</channel>
</rss>