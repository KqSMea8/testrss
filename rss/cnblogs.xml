<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>经典游戏软件工程案例分享--最终幻想14的毁灭与重生(一) - 奥桐木</title>
<link>http://www.cnblogs.com/xiaoweiwang/p/9944313.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoweiwang/p/9944313.html</guid>
<description>&lt;p&gt; 最终幻想14是最著名的MMO（大型多人在线网游）之一，它的发展历程可以说是游戏届最传奇的一个故事了。从刚发布时候的1.0版本被当成是刷新网游界下限并受到玩家和媒体的一致差评到4.0版本获得IGN9.2的高分超越魔兽世界7.0，这简直让人难以置信。按照往常经验来说，一个大型网游的口碑很难逆转，发布之后表现不佳便会由于开发团队解散或者种种原因逐步走向灭亡。这期间到底发生了什么样的故事让一个失败的产品逆转口碑？带着好奇，youtube上的众筹纪录片团队noclip对最终幻想团队进行了深度采访，本文从软件工程视角进行讲述，感兴趣的同学可以看Bilibili上的纪录片翻译版，文末有链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111223436581-1407170976.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;对于一个MMO来说，9.2的评分创造了新的纪录，超越了它的前辈魔兽世界，成为了史上第一评分MMO。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111224313811-1156670412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111224402934-1958253221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111224427435-458222844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111224457442-1991154193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111224511292-31990969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这是一个值得被纪录和述说故事，我们无法想象开发者的经历了怎么样的苦难，带着疑问，noclip出发去东京了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111224957909-1743045652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111225028214-611539064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111225042696-553533927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文主要从制作组本身的视角来了解FF14灾难开服到涅槃重生的过程，提到FF14之前必须得说FF11，FF11是SE第一个网络游戏，取得了非常大的成功，很多FF14开发人员来自FF11.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111230104339-2002075597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111230144100-692713863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111230235226-2141835911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，FF14作为这个IP的续作，会在FF11的设计思路上更进一步，但是开发人员把这个想的太简单了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111230610364-424149370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111230639844-432717349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111230651812-1832021501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 下面是一些制作人员讲述最初版本所遇到的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111225520493-2005409871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111230844359-487336825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231138919-2117337916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231154603-686925500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231226886-143744331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231245079-1352678810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可想而知，通过大量脚本配置出来的游戏，会导致一系列问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231325030-881940184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231401988-2138010277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231427357-120074255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231504736-36449028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111225300292-1674226695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231540069-1664388851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231554925-808413585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于前作的成功，开发人员有所懈怠&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231636505-352653809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231654998-570952176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231713090-516268206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 每个人都很出色，但是一个大型软件工程不仅仅需要个人的专业性，更需要团结协作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231830402-1770367707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231842283-1652023201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 开发人员的闭门造车导致了一系列问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231914156-566668546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111231929015-95403308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232002969-1786061408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232016475-2090325908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232121087-687433340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232136123-1456199023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公测数据的不理想导致了团队开始慌了，但是时间已经太迟了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232158604-1192664565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232212999-1233174301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232406069-1162237246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232439335-501371538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 游戏软件发展太快并且竞争激烈，没有创新闭门造车已经跟不上时代。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232507248-288094243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232544591-193668055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232620158-1683780422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232710701-1583413875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;魔兽世界取得了MMO历史上巨大的成功，FF14开发者们仍然故步自封&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232757658-768523493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111232855438-1067997015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;甚至高层仍然对FF14预期发售充满信心，毕竟FF11刚开始表现也没有太好，也是一步步发布新版本，但是他们没想到的是FF14有多烂&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233027926-1025885598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233051576-1439766976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233110127-1667086402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233121218-435355928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是FF14 1.0在2010年9月30日发售了，在强大的最终幻想IP之下，表现竟然还不错！&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233311752-1085997589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是没过多久，情况急转直下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233348964-699748308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233401149-455157453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;玩游戏的玩家会感觉没有事情可以做，媒体也毫不留情给出了差评&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233525279-571474287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233544755-1630230000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233553598-1151654812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233607511-1994525105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233617212-928052664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233625707-1200738524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大量的差评导致了开发团队非常失落&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233652220-586584092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 开发者付出了无数心血给一个注定死亡的游戏令人心寒&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233729118-1144050570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233900585-1531679378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首席财政官分析了当时的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111233918311-613345883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234016611-1366198963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234033153-1312344580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;玩家的口碑是对游戏最好的评价&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234056232-377509484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234136805-289915459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FF14失败了，开发者最先做的是对等待了好几年玩家的致歉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234254381-1635702996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234304533-1776519189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234316931-142644338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是道歉就有用了吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234353046-659588848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234401119-973848699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是游戏策划对发售时游戏的评价&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234451212-243176575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234515897-1225650001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务器程序员&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234531106-1180880038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234547621-830688465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234553381-664355118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234603333-1623990359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295435/201811/1295435-20181111234620473-975263584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么到底要怎么解决这些问题呢？下期再见。&lt;/p&gt;

</description>
<pubDate>Sun, 11 Nov 2018 15:49:00 +0000</pubDate>
<dc:creator>奥桐木</dc:creator>
<og:description>最终幻想14是最著名的MMO（大型多人在线网游）之一，它的发展历程可以说是游戏届最传奇的一个故事了。从刚发布时候的1.0版本被当成是刷新网游界下限并受到玩家和媒体的一致差评到4.0版本获得IGN9.2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoweiwang/p/9944313.html</dc:identifier>
</item>
<item>
<title>程序员买房指南——LZ的三次买房和一次卖房经历 - 左潇龙</title>
<link>http://www.cnblogs.com/zuoxiaolong/p/life86.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuoxiaolong/p/life86.html</guid>
<description>&lt;h3&gt;引言&lt;/h3&gt;

&lt;p&gt;　　买房，一直是程序员群体绕不开的一个话题，尤其是&lt;strong&gt;到了一定年纪和人生阶段以后，买房这件事会变得越来越迫切&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　为什么LZ一上来就说，买房是程序员绕不开的一个话题？&lt;/p&gt;
&lt;p&gt;　　其实原因很简单，由于程序员这个职业的特点，导致大多数程序员都是拼搏在外，那必然就导致程序员这个群体中，除了极少数本地土著以外，大部分都有购房需求，不然就要一直租房，或者放弃当前的工作回老家，因此在生活上，&lt;strong&gt;程序员大部分都属于购房者的刚需群体&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　但如果仅仅是有这样的刚性需求的话，程序员也不一定会面对买房这个话题，因为如果收入堪忧，根本买不起的话，那么买房这件事也注定与大多数程序员无缘。&lt;/p&gt;
&lt;p&gt;　　就像要饭的就不太会考虑买房，因为他们的收入不足以让他们考虑这件事，当然了，这是以前，在现在这个社会，就不好说了，谁知道要饭的和程序员到底哪个收入高点呢，-_-。&lt;/p&gt;
&lt;p&gt;　　哈哈，言归正传，对于大部分程序员来说，赚钱的能力都还是可以的，至少还房贷一般都问题不大，缺的都是首付。&lt;/p&gt;
&lt;p&gt;　　也正是首付这座大山，拦住了大部分程序员买房的这条路。&lt;/p&gt;

&lt;h3&gt;上路要趁早&lt;/h3&gt;

&lt;p&gt;　　尽管有首付这座大山，但LZ依然劝大家，&lt;strong&gt;要尽快凿开首付这座大山，踏上买房之路&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　说到这，可能有的同学要说了，“LZ啊，你不会是炒房者派来的卧底吧？”&lt;/p&gt;
&lt;p&gt;　　对于这个问题，LZ只能说，“来来来，你来我面前说，保证不打死你。”&lt;/p&gt;
&lt;p&gt;　　LZ郑重声明，LZ绝非是炒房客派来的卧底，-_-。&lt;/p&gt;
&lt;p&gt;　　咳咳......&lt;/p&gt;
&lt;p&gt;　　言归正传，为何LZ要劝大家早日上路？&lt;/p&gt;
&lt;p&gt;　　理由再简单不过，因为&lt;strong&gt;房价可能会涨，越早买就能掏越少的钱&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　那这个时候一定会有同学说，万一房价降了怎么办？马老板都说了8年后房子如葱，最不值钱的就是房子。&lt;/p&gt;
&lt;p&gt;　　首先，马老板只说房子如葱，也就是以后房子会越来越多，并没有说房子会变成白菜价，也就是说，&lt;strong&gt;房子多如葱并不等同于房子就会变成白菜价&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　其次，&lt;strong&gt;房子永远会有那么一批人买不起&lt;/strong&gt;，不可能真的变成全民都买得起的白菜价，再者说了，就算真成了白菜价，那么问题来了，白菜是谁都吃的起的吗？&lt;/p&gt;
&lt;p&gt;　　最后，房子的属性是商品，既然是商品，就可能会降价，比如你买了一个IPHONE，当时可能是5、6千的价钱，用了2、3年后，买这个手机可能只需要2、3千了，你多花了差不多一倍的钱，而你如果卖的话，可能连2、3千都卖不到。&lt;/p&gt;
&lt;p&gt;　　但大多数人并不会觉得买这手机亏了。&lt;/p&gt;
&lt;p&gt;　　为什么不会觉得亏？&lt;/p&gt;
&lt;p&gt;　　首先是大多数人对于这个有了心理预期，知道它会降价，其次，早买早享受，毕竟享受了一两年较新的款式，付出点代价在大家看来也是应该的。&lt;/p&gt;
&lt;p&gt;　　所以，为何到了房子这里大家就想不通了？&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;就算房子真的降价，那你也提前享受了，付出点代价也是完全说的过去的&lt;/strong&gt;，&lt;strong&gt;毕竟住自己房子可比租房爽多了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　凡是那些说买房子不如租一辈子房，然后把买房的钱存起来拿利息，等着房子降价的，要吗是单身狗，没老婆没孩子，根本还没体验到租房的苦逼之处，要吗就是根本买不起房，所以就拿这种论调来安慰自己。&lt;/p&gt;
&lt;p&gt;　　租房到底有多苦逼，只有租过的才知道。&lt;/p&gt;
&lt;p&gt;　　想买个东西得思前想后，比如LZ，一直想要个台式电脑，愣是工作了7年都没买，是LZ买不起台式电脑吗？&lt;/p&gt;
&lt;p&gt;　　非也，是租房买起来太麻烦，所以LZ一直憋着一股劲，等着自己买房子了再买，而且配置一定要高，CPU一定要I9，内存少了64G都不好意思说话，硬盘必须是SSD，512G的都不好使，必须TB级别，不止如此，配套也必须牛逼，键盘鼠标1000块以下不考虑，耳机怎么着也得个2000块以上才拿得出手，还有摄像头、耳机、音响、麦克风等等，没事就开个直播喊个“老铁666”。&lt;/p&gt;
&lt;p&gt;　　除了买东西麻烦以外，租房还有个恶心的地方，那就是要一不小心碰见个奇葩房东的话，那酸爽简直是让你高潮迭起。&lt;/p&gt;
&lt;p&gt;　　另外，租房经常需要搬家就更不用说了，每次搬家都累得要死，而且还要扔不少东西，浪费精力又浪费钱。&lt;/p&gt;
&lt;p&gt;　　总而言之，租房的苦逼之处实在太多，此处不再一一列举，如果有兴趣的同学，欢迎在评论区补充你租房遇到的奇葩事，-_-。&lt;/p&gt;
&lt;p&gt;　　说了这么多，是时候总结一下了，从上面的论点来看，如果你是刚需，那么买房子基本不可能亏，只管想尽一切办法上路即可，退一万步说，就算是最终房价降了，你最终亏了钱，但你也提前享受了几年，甚至十几二十年住自己房子的待遇，这是多少钱都换不来的，毕竟人生能有多少个十年二十年？&lt;/p&gt;
&lt;p&gt;　　等到你头发斑白，就算房价真的便宜了，几块钱就能买套房，那又有什么意义呢？&lt;/p&gt;

&lt;h3&gt;第一次上路——坎坷&lt;/h3&gt;

&lt;p&gt;　　接下来，LZ就讲讲自己的第一次上路，这一次经历，LZ称之为坎坷，-_-。&lt;/p&gt;
&lt;p&gt;　　很多人都会说，“LZ啊，不是我不想买，而是我首付不够啊。”&lt;/p&gt;
&lt;p&gt;　　是的，没错，这是绝大多数人的理由，但是，如果你看完LZ第一次买房的经历以后，你可能就不会再说这句话了。&lt;/p&gt;
&lt;p&gt;　　至少，&lt;span&gt;&lt;strong&gt;你不会再轻易说这句话&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　LZ第一次买房是2015年的国庆，至今LZ还记忆尤深，当时买房的初衷，就是因为LZ有了危机感，觉得北京的房子已经买不起，所以想要在老家给自己买套房子，以备不时之需，而且LZ此时也结婚1年半了，房子早晚总得买一套不是？&lt;/p&gt;
&lt;p&gt;　　于是，趁着国庆假期，LZ和媳妇一起踏上了回家看房的路途。&lt;/p&gt;
&lt;p&gt;　　看房子是个技术活儿，非常耗时，而且LZ老家是在县城，当时看房子是专门开车，到LZ县城所属的市区看的，因此也着急回县城。&lt;/p&gt;
&lt;p&gt;　　于是，LZ用了最简单的办法选房，那就是找了一个关系比较近，而且刚好在市区买房的朋友，问了一下他们买的哪个小区，然后直接来到了小区的售楼处。&lt;/p&gt;
&lt;p&gt;　　为什么这么相信这个朋友？&lt;/p&gt;
&lt;p&gt;　　因为LZ的母亲和这位朋友的母亲认识，据LZ母亲所说，这个朋友和他老公，还有这个朋友的母亲是看了100多个小区，才选定的这个小区。&lt;/p&gt;
&lt;p&gt;　　我勒个擦，简直无情。&lt;/p&gt;
&lt;p&gt;　　到了售楼处，售楼小姐就开始唾沫横飞的给LZ介绍了。&lt;/p&gt;
&lt;p&gt;　　当时基本只有两个选择，一个是期房，价钱便宜点，总价大约在60万的样子，而一个是现房，而且是楼王，但是价格要贵不少，总价大约要80万的样子。&lt;/p&gt;
&lt;p&gt;　　对于买房这件事，因为LZ觉得一买就差不多是一辈子，因此肯定要买好的，所以LZ第一时间盯准的是80万的楼王。&lt;/p&gt;
&lt;p&gt;　　不过这个楼王按照3成首付来算，需要大约24万首付，而LZ当时全身的身价，是6万块钱。&lt;/p&gt;
&lt;p&gt;　　这怎么买？&lt;/p&gt;
&lt;p&gt;　　别说是80万的这套了，就是60万的那套也买不起啊。&lt;/p&gt;
&lt;p&gt;　　就是借钱，一下要借十几万，都快接近20万了，哪是那么好借的？&lt;/p&gt;
&lt;p&gt;　　想到这，LZ基本上已经放弃了。&lt;/p&gt;
&lt;p&gt;　　不过，售楼部小姐后面说了一句话，让LZ心中又升起了希望。&lt;/p&gt;
&lt;p&gt;　　她说，最近公司有优惠，首付可以分期，半年付清即可。&lt;/p&gt;
&lt;p&gt;　　而第一期需要交的钱，是6万元！&lt;/p&gt;
&lt;p&gt;　　LZ一听，6万？可以啊，手里刚好有6万多呢。&lt;/p&gt;
&lt;p&gt;　　不过后面的钱怎么办？&lt;/p&gt;
&lt;p&gt;　　无意之间，LZ想起了自己的公积金，从上班开始到现在，LZ的公积金一毛钱都没动过，已经整整交了将近4年。&lt;/p&gt;
&lt;p&gt;　　虽说一开始的时候，公积金很少，但这么多年积累下来，应该也差不多得有个8、9万块了。&lt;/p&gt;
&lt;p&gt;　　于是，LZ开始和售楼部小姐商量取公积金的事情，而售楼部小姐一听，一再确保说，肯定没问题，公积金肯定能取出来。&lt;/p&gt;
&lt;p&gt;　　LZ当然不会这么单纯的相信售楼部小姐的话，但是LZ也有自己的判断，因为LZ早就确认过，异地买房，是可以把公积金取出来的，这点上是肯定没有问题的，只是具体的材料LZ不太确定都需要什么。&lt;/p&gt;
&lt;p&gt;　　而如果假设这公积金可以用上的话，那相当于LZ就只差不到9万块了，而距离首付交完还有将近半年的时间，这段时间LZ还有工资进账，而且中间有春节，不出意外，还有1-2个月的奖金。&lt;/p&gt;
&lt;p&gt;　　到时候就算凑不够9万，估计也差不了太多钱，随便找人借一下，临时用一下应该问题不大，而且以LZ当时的工资水平，应该用不了多久就还上了。&lt;/p&gt;
&lt;p&gt;　　这么一盘算下来，LZ果断的一拍桌子：“买！”&lt;/p&gt;
&lt;p&gt;　　于是，当场交了6万块定金，同时也算是首付一期的钱，并且签订了购房合同。&lt;/p&gt;
&lt;p&gt;　　买完房子，LZ开开心心的过了个国庆，节后便回去上班了。&lt;/p&gt;
&lt;p&gt;　　上班第一件事，自然是咨询公司的HR，公积金怎么才能取出来，都需要哪些材料。&lt;/p&gt;
&lt;p&gt;　　前面说了，公积金取是肯定可以取的，只要你买了房子，重点其实是哪些材料，HR给了LZ一个列表，LZ比对了一下，缺了一个很重要的东西。&lt;/p&gt;
&lt;p&gt;　　首付发票！&lt;/p&gt;
&lt;p&gt;　　马勒戈壁的，这是什么鬼？赶紧联系售楼部小姐问一下。&lt;/p&gt;
&lt;p&gt;　　结果一问，LZ傻眼了，售楼部小姐说，首付发票是要首付交完以后才能给的，但是拿不到首付发票，就没法取公积金，拿不到公积金，LZ这首付就没钱交，这特么不是死循环了？&lt;/p&gt;
&lt;p&gt;　　LZ质问售楼部小姐，“你当时不是说可以取出来的吗？”&lt;/p&gt;
&lt;p&gt;　　售楼部小姐的回答是，“咱们老家这里取公积金不需要首付发票啊！”&lt;/p&gt;
&lt;p&gt;　　LZ的心里只能一万只草泥马飞过。&lt;/p&gt;
&lt;p&gt;　　其实最简单的办法，肯定是找人先借钱把首付交了，然后等拿到首付发票以后，再把公积金取出来，然后再把钱还给人家即可，等于是临时借用一段时间。&lt;/p&gt;
&lt;p&gt;　　但问题是，LZ当时根本就借不来这么多钱，因为LZ的同事还没有成长起来，工资都还有点低呢。&lt;/p&gt;
&lt;p&gt;　　有的同学，可能有疑问了，“这和你同事有啥关系？”&lt;/p&gt;
&lt;p&gt;　　LZ只想说，那关系可大了，等看到LZ第二次买房你就知道了，/偷笑。&lt;/p&gt;
&lt;p&gt;　　这时候，可能有的同学又说了，“那找亲戚朋友借点如何？”&lt;/p&gt;
&lt;p&gt;　　LZ只能说，很难，在老家那种地方，一个月工资普遍是2000来块钱，谁能有20万这么多的巨款。&lt;/p&gt;
&lt;p&gt;　　当然，如果你真要借，1分多甚至2分的利息，应该是可以借到的，但是，LZ是绝不会借这种钱的，也奉劝各位不要打这种心思，这么高的利息，就有点太不值当了，这房子不如不买。&lt;/p&gt;
&lt;p&gt;　　因为钱的问题，LZ和媳妇当时还大吵了一架，也算是印证了“贫贱夫妻百事哀”这句话，当时LZ一气之下，还破罐子破摔的对媳妇说道：“不买了！交过的钱也不要了，就这么着吧。”&lt;/p&gt;
&lt;p&gt;　　媳妇一听，两眼就开始泛红，LZ见状也是于心不忍，不过LZ当场并没有说什么安慰的话，都在气头上，拉不下那个脸，而且事情没有根本解决，安慰有个屁用。&lt;/p&gt;
&lt;p&gt;　　不过LZ是很理智的一个人，气话归气话，6万块钱哪能说不要就不要了，开什么玩笑？那特么是辛苦挣来的啊。&lt;/p&gt;
&lt;p&gt;　　所以，LZ再次给售楼部小姐打电话，开始软磨硬泡，软硬兼施，不但表达了LZ的苦逼之处，动之以情，也偶尔敲打下售楼部小姐，意思大致就是如果不帮忙的忙，这房子就没法买了。&lt;/p&gt;
&lt;p&gt;　　好在售楼部小姐不算是那种巨坑的人，不管是处于好心，还是为了自己的业绩，最终还是给了LZ一个解决办法。&lt;/p&gt;
&lt;p&gt;　　拿到发票以后，LZ顺利了取出了将近9万的公积金，并让HR办理了季度转，这个是在北京可以办理的，可以把公积金每三个月自动打给你。&lt;/p&gt;
&lt;p&gt;　　有了这9万块，首付的问题基本已经解决了，虽说后面最终还是差了2万块，但因为钱少，所以很轻松的找人借用了下解决了。&lt;/p&gt;
&lt;p&gt;　　原本购房这件事到此就结束了，无非是LZ接下来尽快挣钱，把欠的2万块首付钱还掉就行了。&lt;/p&gt;
&lt;p&gt;　　结果就在16年3月份，也就是LZ刚买完房子交完首付的时候，LZ拿到了杭州阿里中间件的offer。&lt;/p&gt;
&lt;p&gt;　　对于一个Java程序员来说，拿到阿里的offer不去肯定还是有些可惜的，哪怕是要换城市。&lt;/p&gt;
&lt;p&gt;　　更何况，LZ觉得杭州这地方不错，房价和户口等都比北京要好搞很多，于是就毅然决然的离开了。&lt;/p&gt;
&lt;p&gt;　　巧的是，LZ离开的时候，刚好按季度提取公积金过去了三个月，也就是说，LZ刚好可以在走之前，把北京的公积金取得一毛不剩。&lt;/p&gt;
&lt;p&gt;　　不过事情总是不会那么顺利，就当LZ欢天喜地的准备收钱的时候，突然发现，HR当时并没有给LZ办理按季度转，她给忘了！忘了！&lt;/p&gt;
&lt;p&gt;　　这可咋办？&lt;/p&gt;
&lt;p&gt;　　三个月公积金可是不少钱哦，而且直接取走省事啊，留在北京或者转走还是很烦的。&lt;/p&gt;
&lt;p&gt;　　不过，好在LZ公司的HR虽然把事情忘了在先，但总体还是很靠谱的，最后HR妹子还是帮忙想办法给解决了。&lt;/p&gt;
&lt;p&gt;　　就这样，LZ在离开北京去杭州入职之前，刚好把北京的公积金取得一干二净。&lt;/p&gt;
&lt;p&gt;　　当时LZ觉得，就冲这一点，这房子就算是买值了，至少把公积金充分利用了，而且以后的也能取。&lt;/p&gt;
&lt;p&gt;　　完美！&lt;/p&gt;

&lt;h3&gt;中途小结&lt;/h3&gt;

&lt;p&gt;　　这一次买房，是LZ第一次买，虽说遇到了点坎坷，但总算最后啃下来了。&lt;/p&gt;
&lt;p&gt;　　从这次真实的买房经历，LZ也总结了几点小小的经验和教训，在此献给所有程序员。　　&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;买房不一定非要自己挣够首付，因为往往等你挣够了，房价早就上天了。更何况，看完LZ的买房经历，你还有什么资格抱怨你的首付不够？办法总比困难多。&lt;/li&gt;
&lt;li&gt;买房这事模糊不得，凡是重要的事情，必须早早落实，比如LZ取公积金这件事，就没有早早落实，只是大概知道可以取，但怎么取，需要什么材料，之前并没有了解清楚，以至于差点毁于一旦。&lt;/li&gt;
&lt;li&gt;房贷一定要30年，不要搞什么10年、20年，更不要全款。有的同学可能问为啥？其实很简单，房贷是你这辈子为数不多可以利用的杠杆，必须用到极致，这可以让你的财富快速积累。&lt;/li&gt;
&lt;li&gt;公积金是个好东西，要充分利用起来，这部分钱存在ZF那里，基本上利息都亏掉了，要尽早利用起来。你说怎么利用？买房啊！&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;h3&gt;第二次买房——神奇&lt;/h3&gt;

&lt;p&gt;　　第二次买房经历，LZ用神奇这两个字来形容，看完你就知道为什么LZ称之为神奇。&lt;/p&gt;
&lt;p&gt;　　之前在&lt;a href=&quot;https://www.cnblogs.com/zuoxiaolong/p/life55.html&quot; target=&quot;_blank&quot;&gt;《2016——注定不平凡的一年》&lt;/a&gt;这篇文章里，LZ已经详细介绍过第二次买房的经历，但是当时写的比较独立，没有连续性，为了更好的阅读体验，LZ会在这篇文章里连起来再讲述一遍。&lt;/p&gt;
&lt;p&gt;　　既如此，咱们接着文章前面讲的，在LZ第一次买完房以后，当时的首付除了LZ自己本来存的钱，以及公积金取出来的钱，还找同学借了差不多2万块钱（说好三个月内还），才把那套房子啃下来。&lt;/p&gt;
&lt;p&gt;　　而LZ入职阿里，是16年的3月中旬，这时候，LZ刚交完最后一期首付，可以说是身无分文。&lt;/p&gt;
&lt;p&gt;　　而且，换工作本身也会损失一部分钱，比如一个多星期没上班的工资钱，还有因为跨城市搬家损失的房租钱等等。&lt;/p&gt;
&lt;p&gt;　　可想而知，LZ刚到杭州这个月，基本是靠着吃土过来的。&lt;/p&gt;
&lt;p&gt;　　不止如此，LZ接下来还要每个月还将近6000块的房贷（当时LZ房贷只搞了10年，-_-），而且还要想着点存钱，尽快把那2万块还给人家。&lt;/p&gt;
&lt;p&gt;　　这种经济情况，可以说是LZ有史以来最差的了。&lt;/p&gt;
&lt;p&gt;　　但是，即便如此，LZ在杭州安顿好以后，LZ想到的第一件事，依然是让媳妇没事去看看房子，了解一下杭州的房市行情。&lt;/p&gt;
&lt;p&gt;　　为啥？&lt;/p&gt;
&lt;p&gt;　　因为特么在北京吃了房价太多亏了，而LZ觉得杭州有阿里，互联网不会太差，房价应该有上升空间，说不定哪天就像北京一样买不起了，所以，当然要早早做好准备工作了，就算买不起，最起码也要先了解清楚行情，做到了然于胸。&lt;/p&gt;
&lt;p&gt;　　更何况，LZ的老婆在16年6月中旬到了杭州以后，一时之间也没找到工作，因此平时除了偶尔面试一下，也算是时间充裕，也算是给老婆找了个事干。&lt;/p&gt;
&lt;p&gt;　　就这样，虽然LZ身无分文，但LZ媳妇仍然没事会去看看房子。&lt;/p&gt;
&lt;p&gt;　　这样的生活持续了大约两个星期，直到一天晚上，剧情出现了很大的转折。&lt;/p&gt;
&lt;p&gt;　　那天是6月30日，LZ记得非常清楚，当时LZ刚把那2万还给人家不久，全身上下花的只剩500块钱。&lt;/p&gt;
&lt;p&gt;　　不过这其实LZ算准了的，6月30日这天刚好发工资，因此虽然身上只有500块钱了，但LZ却一点也不担心接下来的花销，相反，LZ反而觉得一身轻松。&lt;/p&gt;
&lt;p&gt;　　因为买第一套房子欠下来的首付钱，终于是彻底还干净了，除了房贷以外，LZ终于是进入了无债一身轻的日子。&lt;/p&gt;
&lt;p&gt;　　然而，LZ还没有高兴太久，媳妇的电话就打过来了。&lt;/p&gt;
&lt;p&gt;　　“老公，我看到一个房子，好便宜啊，总价才60万不到，算下来一平米才将近7000块钱。只不过人家明天就封盘了，再开盘估计就要涨价了，要是今晚要定的话，得交4万块定金。”&lt;/p&gt;
&lt;p&gt;　　LZ当时听到这个消息，一开始是不相信。&lt;/p&gt;
&lt;p&gt;　　为啥？&lt;/p&gt;
&lt;p&gt;　　总价才60万不到？&lt;/p&gt;
&lt;p&gt;　　纳尼？比LZ老家买的房子还便宜？要知道，LZ老家刚刚买的那套，可是花了将近80万啊！&lt;/p&gt;
&lt;p&gt;　　虽说老家那套面积大的多，140多平，算下来单价比杭州这个要便宜点，但那又如何？&lt;/p&gt;
&lt;p&gt;　　60万依旧还是很便宜啊！&lt;/p&gt;
&lt;p&gt;　　这特么不会是套假房子吧？又或者是不属于杭州，而是周边的？&lt;/p&gt;
&lt;p&gt;　　LZ自然把这些疑惑都丢给了媳妇，但是媳妇一口咬定，这就是杭州的房子，不会错的。&lt;/p&gt;
&lt;p&gt;　　这下LZ纠结了，要说这房子不买的话，LZ总觉得有点可惜。因为这是LZ第一次离安家如此之近，之前在北京，买房子这事压根是LZ想都不敢想的事情。&lt;/p&gt;
&lt;p&gt;　　但要说买吧，LZ看了看自己的银行卡余额，无奈的摇了摇头。&lt;/p&gt;
&lt;p&gt;　　这特么怎么买？连个定金都不够啊！&lt;/p&gt;
&lt;p&gt;　　虽说一会儿会发工资，但是也远远不够4万块啊。&lt;/p&gt;
&lt;p&gt;　　而且，这才刚刚把上一套房子的首付钱还完，难道又要再次借钱，再次勒紧裤腰带还首付钱吗？&lt;/p&gt;
&lt;p&gt;　　这样的日子，什么时候是个头啊？宝宝心里苦啊！&lt;/p&gt;
&lt;p&gt;　　更重要的是，就算LZ想勒紧裤腰带，谁又能借LZ这么多钱呢？&lt;/p&gt;
&lt;p&gt;　　但是，越是复杂的情况，LZ的思路就越清楚。&lt;/p&gt;
&lt;p&gt;　　60万都不到的房子啊！7000块一平啊！&lt;/p&gt;
&lt;p&gt;　　只要这房子是正儿八经杭州的房子，那就铁定是百分百赚的，不买肯定会后悔啊！&lt;/p&gt;
&lt;p&gt;　　有的同学看到这可能会说，“7000块啊！还是很贵啊！”&lt;/p&gt;
&lt;p&gt;　　LZ只想说，你如果看多了北京动辄5、6万一平，甚至十几万一平的房价，然后骤然看到个7000块一平的，你肯定不会觉得7000块贵的，你只会觉得这房子简直就是白菜价。&lt;/p&gt;
&lt;p&gt;　　而且那个房子的位置媳妇在电话里也告诉LZ了，LZ查了下，离公司8公里，开车的话，估计也就是20分钟的样子。&lt;/p&gt;
&lt;p&gt;　　这距离，说实话，对于在北京待过的LZ来说，这特么就是相当于在家门口上班啊。&lt;/p&gt;
&lt;p&gt;　　一通内心挣扎下来，LZ还是决定，不论如何，也要去现场看看再说。&lt;/p&gt;
&lt;p&gt;　　既然要去现场看看，那甭管用不用得上，肯定要先把定金带上，不然到了地方再借钱岂不是太晚了吗？&lt;/p&gt;
&lt;p&gt;　　于是，LZ抄起电话，给北京的老同事去了两个电话，不到半个小时，LZ就借了5万块，加上一会儿发的工资，应付4万块的定金肯定是绰绰有余了。&lt;/p&gt;
&lt;p&gt;　　就这样，6点下班以后，LZ早早的就离开了公司，奔赴售楼处。&lt;/p&gt;
&lt;p&gt;　　到了地方，LZ看了下样板房，觉得十分不错，而且这个房子虽然是期房，但其实已经建的差不多了，所以倒也不太用怕烂尾什么的。&lt;/p&gt;
&lt;p&gt;　　最终，在再次确认房子确实是属于杭州以后，LZ果断的交了定金。&lt;/p&gt;
&lt;p&gt;　　而售楼部小姐告诉LZ，要在两周内把首付交齐。&lt;/p&gt;
&lt;p&gt;　　不过LZ由于走的匆忙，还带着工牌，后来被售楼部小姐看到，售楼部小姐又补充了一句，是阿里员工的话，可以延迟到1个月交首付。&lt;/p&gt;
&lt;p&gt;　　纳尼？还有这待遇？&lt;/p&gt;
&lt;p&gt;　　不管怎么说，定金交了，没有回头路了，接下来就是借钱、借钱、再借钱！&lt;/p&gt;
&lt;p&gt;　　具体借钱的过程此处就不详细描述了，这个没有可复制性，说了也没什么意义。&lt;/p&gt;
&lt;p&gt;　　不过有一件事还是要提一下，其中的1万块钱，是来自于LZ粉丝群里的一位同学主动拿出的，本来LZ就是在群里闲聊，提到了首付还差不少钱，压根没打算从群里借钱，而且，也觉得不会有人借钱。&lt;/p&gt;
&lt;p&gt;　　毕竟几百几千的，说实话帮助不大，但是上万的话，估计不太会有人放心借给LZ。&lt;/p&gt;
&lt;p&gt;　　但是这位热心小伙伴，主动提出要借给LZ钱，尽绵薄之力，更是直接要了LZ支付宝账号，连个电话都没打，就把钱给打过来了。&lt;/p&gt;
&lt;p&gt;　　着实是让LZ感受到，人间自有真情在啊！&lt;/p&gt;
&lt;p&gt;　　当然，这1万块钱，LZ已经早早的还给了小伙伴，但这份帮助，LZ还是一直都记得的。&lt;/p&gt;
&lt;p&gt;　　就这样，首付到手，接下来的事情就比较简单了。&lt;/p&gt;
&lt;p&gt;　　不过杭州买房子与之前在老家有一点不同的是，要先经过银行的审核，才签订购房合同。&lt;/p&gt;
&lt;p&gt;　　对此LZ倒没有什么疑问，因为这样的流程，其实也是为了保障买方的利益，毕竟等你交了首付，才发现批贷通不过，岂不是也很蛋疼？&lt;/p&gt;
&lt;p&gt;　　当然了，就程序员的工资来说，一般批贷都不是什么问题，完全可以达到要求。&lt;/p&gt;
&lt;p&gt;　　就这样，用了差不多不到一个月，LZ就又拿下了一套房子，并再次进入了还钱的日子。&lt;/p&gt;
&lt;p&gt;　　而这一次，是要还整整20万，这20万，刚好就是房子的首付。&lt;/p&gt;
&lt;p&gt;　　也就是说，LZ这个房子的所有首付都是借来的。&lt;/p&gt;
&lt;p&gt;　　空手套白狼，LZ这辈子也算是玩过了。&lt;/p&gt;
&lt;p&gt;　　这一次买房的经历，绝对堪称神奇了。&lt;/p&gt;
&lt;p&gt;　　更神奇的是，自从LZ买房以后，LZ的那套房子，就在以每一个星期1、2千的速度在上涨。&lt;/p&gt;
&lt;p&gt;　　简直疯狂！&lt;/p&gt;

&lt;h3&gt;中途小结&lt;/h3&gt;

&lt;p&gt;　　由于第二次买房价钱太便宜，LZ经常被同事笑称，这套房子是充话费送的。&lt;/p&gt;
&lt;p&gt;　　不得不说，这一次买房的经历确实神奇，让人意想不到，但即便如此，LZ还是觉得有一些可以参考的价值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;再次用事实证明，买房不一定非要攒够首付才能买！甚至恰恰相反，除了少数二代和土豪以外，大部分人买房都是在首付不够的情况下买的。&lt;/li&gt;
&lt;li&gt;二线城市（或者说一些准一线城市）会比目前的北上深更加适合程序员，从工资和房价的比例来算的话，这些城市应该是比例最高的。&lt;/li&gt;
&lt;li&gt;和同事们搞好关系，说不定这帮一起战斗过的人，在你缺钱的时候，比你的亲戚朋友更加靠谱。有的同学可能会问，难道是因为同事的爱更加深刻吗？或者是因为战斗的情谊更加珍贵吗？咳咳，非也，是因为程序员一般工资都不低，而且不爱乱花钱，他们有闲钱啊！&lt;/li&gt;
&lt;li&gt;如果钱实在不多，那么房子位置差点，或者小区物业差点等等这些问题都不大，先上车再说，这样你至少不会掉队，大不了以后再置换嘛。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;h3&gt;第一次卖房——曲折　&lt;/h3&gt;

&lt;p&gt;　　第一次卖房这件事，LZ称之为曲折，至于为什么这么形容，你看完就知道了，简直能特么写一部短篇小说。&lt;/p&gt;
&lt;p&gt;　　16年7月份买完房子以后，LZ心里的一块石头总算了落了地，不管怎么说，现在总算是有一套房子了，再也不用担心未来房价上涨了。&lt;/p&gt;
&lt;p&gt;　　事实也证明，这套房子买的很是时候，截止到现在，也就2年多点的时间，这套房子已经翻了3倍多了。&lt;/p&gt;
&lt;p&gt;　　按理说，作为一个小老百姓，LZ已经赚了个盆体满钵，而且老家一套，杭州一套，也算是“儿女”双全，应该及时收手，结束这场没有硝烟的房市征战了。&lt;/p&gt;
&lt;p&gt;　　但是，事实证明，人的欲望是无穷无尽的，因为LZ的贪心，LZ并没有停下与房子纠缠的脚步。&lt;/p&gt;
&lt;p&gt;　　不过，刚借了20万，LZ短时间内肯定是无力折腾了，所以，在16年7月份买完房子以后，直到2017年的五一这段时间，LZ基本是处于闷声还钱的阶段。&lt;/p&gt;
&lt;p&gt;　　然而，当钱还完以后，LZ的心思又开始活络了。&lt;/p&gt;
&lt;p&gt;　　不过，一开始的时候，LZ并没有打算买或者卖房子，而是打算装修房子！&lt;/p&gt;
&lt;p&gt;　　租了这么久的房子，如今房子买好了，首付钱也还完了，自然是要赶紧装修一下住进去咯。&lt;/p&gt;
&lt;p&gt;　　于是，LZ和媳妇商量了下，等差不多存够个5万块，就开始装修。&lt;/p&gt;
&lt;p&gt;　　那段时间，每天下班以后，LZ和媳妇没事就讨论房子装修的事，LZ也可以明显感觉到，一提到装修这事，媳妇每次都是双眸发亮，一脸期待的样子。&lt;/p&gt;
&lt;p&gt;　　然而，就当LZ攒够了钱，马上就要开始装修的时候，LZ无意间听到一个消息。&lt;/p&gt;
&lt;p&gt;　　“杭州2022年要举办亚运会，而且现在每一个已婚并且拥有杭州户口的人，都可以且只能买两套房。”&lt;/p&gt;
&lt;p&gt;　　LZ琢磨了下，这个消息可能意味着两件事，第一，2022年的时候，杭州的房价有可能再涨一波，可能性比较大。第二，LZ还能在杭州再买一套房，而且就算再有钱，也只能买一套，第三套不让买了。&lt;/p&gt;
&lt;p&gt;　　这下LZ对装修这件事有些犹豫了。&lt;/p&gt;
&lt;p&gt;　　为啥？&lt;/p&gt;
&lt;p&gt;　　因为LZ做事情喜欢一步到位，一劳永逸，既然还能再买一套，而且2022年又可能涨价，那依照LZ的性格，肯定是一鼓作气，把两套房子都给买了再说啊。&lt;/p&gt;
&lt;p&gt;　　不过虽说LZ有这个想法，但其实LZ此时，还是更加倾向于先装修。&lt;/p&gt;
&lt;p&gt;　　一个是看到媳妇那么开心，不忍心让她再等，另外一个则是，LZ当时一个月房租是2200，房贷才2300，你说这交着房租是不是贼闹心？&lt;/p&gt;
&lt;p&gt;　　不过，后来LZ到小区交房的时候，感受了一下小区的情况，却逐渐改变了主意。&lt;/p&gt;
&lt;p&gt;　　为啥？&lt;/p&gt;
&lt;p&gt;　　这套房买的确实很便宜，也赚了不少钱，但便宜也有便宜的劣势，那就是小区挨着高架，难免会有些噪音，而且小区也比较低档，所以物业也只能算是一般般。&lt;/p&gt;
&lt;p&gt;　　而LZ老家买的那套80万的房子，基本是属于老家的豪宅（地理位置基本相当于西湖的湖中心，-_-），所以物业非常好，这样一对比，更让LZ觉得杭州这套物业不够好。&lt;/p&gt;
&lt;p&gt;　　更何况，装修这件事虽说听起来美好，但谁都知道，装修是一件非常累人的活，尤其是LZ和媳妇都要上班，而且还没车的情况下，装修那更是一件麻烦事，就算你搞个全包，你不也得经常去盯着点吗？&lt;/p&gt;
&lt;p&gt;　　不过最终让LZ下决心的，还是因为房子的楼层。&lt;/p&gt;
&lt;p&gt;　　当初便宜的低楼层都卖完了，太低的话，比如1、2层这种LZ是坚决不考虑的，因此LZ买的楼层比较高，大约是28/33的样子（具体不记得了，LZ经常忘记自己的房子在哪，-_-），而且之前在北京一直住高层，感觉高层也可以接受，最起码视野宽阔。&lt;/p&gt;
&lt;p&gt;　　但LZ去真实感受过以后，就有点小后悔了。&lt;/p&gt;
&lt;p&gt;　　为啥？&lt;/p&gt;
&lt;p&gt;　　房子是一梯两户，也就是说，大约60多家共用一个电梯，而LZ又住的比较高，可想而知，以后等电梯肯定会成为常事。&lt;/p&gt;
&lt;p&gt;　　最重要的，还是LZ其实是有点恐高的，所以每次做电梯到那么高的地方，都有点心有余悸，而且现在的商人大家懂的，电梯到底安不安全，鬼特么才知道啊！&lt;/p&gt;
&lt;p&gt;　　看到这可能有的同学会说了，“既然你对这房子这么不满意，当初为啥还买呢？比如楼层咋不买个好点的，不高不低的？小区咋不买个好点的？”&lt;/p&gt;
&lt;p&gt;　　呵呵，如果你真有这样的疑问，LZ真是要无语了，你说能特么为啥？&lt;/p&gt;
&lt;p&gt;　　因为没钱啊！这个最便宜啊！&lt;/p&gt;
&lt;p&gt;　　还能为啥？&lt;/p&gt;
&lt;p&gt;　　当然了，不愿意住归不愿意住，但不代表LZ买这房子后悔了，相反，LZ一直觉得买对了，毕竟赚了不少钱呢。&lt;/p&gt;
&lt;p&gt;　　但甭管怎么说，LZ住是不愿意住了，准备把这套房当做投资，也暂时不装修，到时再买一套二手，直接住进去。&lt;/p&gt;
&lt;p&gt;　　这样的话，不仅省了装修的麻烦，而且也不用等着散甲醛了，更可以吃一堑长一智，好好挑一挑楼层物业什么的。&lt;/p&gt;
&lt;p&gt;　　一切听起来都是那么美好，那么问题来了，钱从哪来？&lt;/p&gt;
&lt;p&gt;　　卖老家的那套房子！&lt;/p&gt;
&lt;p&gt;　　这并不难想到，只有这样LZ才可能凑够钱。&lt;/p&gt;
&lt;p&gt;　　而且老家那套房子，LZ原本是为了在北京长期打拼准备的，因为在北京买不起，所以就买了一套老家的，而且老家那套离高铁站不远的，LZ从北京坐高铁回老家只需要两个半小时，然后再坐车10分钟就能到家，到时候老婆孩子可以在老家长期生活，而LZ则每一两个月回来一次。&lt;/p&gt;
&lt;p&gt;　　这其实是LZ当时精心安排的，虽说有点奔波，但其实已经是最好的安排了，谁让咱买不起北京的房子呢？&lt;/p&gt;
&lt;p&gt;　　然而，这一切现在已经没有意义了，因为LZ户口也转到杭州了，房子也在杭州买了，哪怕杭州这套房子再差，那也是套房子。&lt;/p&gt;
&lt;p&gt;　　老家肯定是回不去了，更何况，LZ的老家其实是在县城，而老家买的那套房子是在市区，所以，那套房子目前完全就属于闲置状态，还得每年交着昂贵的物业费，还着房贷，租还租不出去，因为还是毛坯。&lt;/p&gt;
&lt;p&gt;　　而且就算能租出去，LZ也不太舍得，毕竟这套房子属于高档小区，租出去太糟蹋了，而且LZ老家那四五线城市也租不上价钱。&lt;/p&gt;
&lt;p&gt;　　那就啥也别说了，卖吧！&lt;/p&gt;
&lt;p&gt;　　于是，LZ就随便在网上找了个老家那城市的中介，把房子给挂上去了。&lt;/p&gt;
&lt;p&gt;　　至于价格的话，LZ也算了下，当初买的价钱是70多万将近80万，再加上贷款的利息，以及交过的税费，LZ的成本差不多是82万左右。&lt;/p&gt;
&lt;p&gt;　　而LZ当时也简单了解了下，当时LZ那小区的房价大约是6000多那么一点点，核算成总价也就是可以卖85万多点。&lt;/p&gt;
&lt;p&gt;　　而中介说了，一般挂上去的价格都要稍微留点还价的余地，于是，LZ给了中介一个价钱——90万！&lt;/p&gt;
&lt;p&gt;　　挂上去以后，LZ便开始不断的接到电话，不过大多都是一些扯淡的电话。&lt;/p&gt;
&lt;p&gt;　　直到有一次，有一个中介A说，有买家A愿意全款购买，问能不能便宜点。&lt;/p&gt;
&lt;p&gt;　　LZ一听，全款好啊，这样能省LZ不少事，而且可以尽快拿到钱，于是LZ思来想去，最终给了一个价钱——88万。&lt;/p&gt;
&lt;p&gt;　　而这个价钱买家A也答应了，也很爽快的交给了中介A一万块定金，LZ当时都以为这笔88万的买卖要做成了。&lt;/p&gt;
&lt;p&gt;　　结果就在此时，又来了一个中介B，说有个买家B也看上了，虽然这个买家B是按揭，但人家上来就给92万，而且也交了定金，整整比那个买家A多了4万块钱。&lt;/p&gt;
&lt;p&gt;　　我勒个擦？4万块啊！&lt;/p&gt;
&lt;p&gt;　　LZ肯定是动心了啊！但LZ并没有第一时间答应。&lt;/p&gt;
&lt;p&gt;　　为啥？&lt;/p&gt;
&lt;p&gt;　　因为这个中介B所在的中介公司，是LZ媳妇的一个亲戚C开的，这也是LZ听到了中介B的公司名才想起来的。&lt;/p&gt;
&lt;p&gt;　　其实C开了个中介公司，这事LZ和媳妇早就知道，但为啥没直接找他帮着卖呢？&lt;/p&gt;
&lt;p&gt;　　其实是因为LZ之前曾很认真的问过媳妇一句，“媳妇，咱小两口就有话直说了啊，以你的判断来看，你觉得你这个亲戚靠谱不？”&lt;/p&gt;
&lt;p&gt;　　媳妇听完，略微犹豫了一会儿，然后缓缓的摇了摇头。&lt;/p&gt;
&lt;p&gt;　　看到这个，LZ就果断放弃了找C帮着卖房的打算，毕竟如果人不怎么靠谱的话，办事一般也不怎么靠谱，更何况，有个常说的词叫杀熟，说的就是关系越近越容易被坑，除非是特别近，比如父母或者亲兄弟姐妹这种关系。&lt;/p&gt;
&lt;p&gt;　　也正因为如此，哪怕中介B这边买家多出了4万块，LZ也有些犹豫。&lt;/p&gt;
&lt;p&gt;　　不过最后LZ还是选择了中介B，至于原因的话没别的，毕竟4万块，光这一个理由就足够了，而且LZ还是愿意让自己去相信，亲戚是不会坑亲戚的。&lt;/p&gt;
&lt;p&gt;　　于是乎，LZ和媳妇商量了下，既然都已经选择了中介B，那也索性不瞒着C了，便给C打了个电话，说卖房子刚好来到了他的中介公司，之前都忘了他有个中介公司，否则就直接找他了。&lt;/p&gt;
&lt;p&gt;　　这自然是LZ找的一个说辞而已，毕竟卖房子没有直接找他，多少还是要解释下的。&lt;/p&gt;
&lt;p&gt;　　C听了以后说应该早点找他，现在中介B已经和LZ谈好了，他也不好意思压人家的中介费了，否则原本可以不要我们的中介费。&lt;/p&gt;
&lt;p&gt;　　对此LZ表示是完全OK的，因为本来也没打算占这个便宜，只要能安安稳稳把房子卖出去，交个9000块的中介费LZ还是完全不在乎的，而且也是应该的。&lt;/p&gt;
&lt;p&gt;　　C听了以后也表示，会交代一下中介B，让他务必保证我们的利益，让LZ放心就行。&lt;/p&gt;
&lt;p&gt;　　既如此，LZ自然是果断把那个买家A给拒绝了。&lt;/p&gt;
&lt;p&gt;　　这时候有的同学可能要说了，“你都收了买家A的定金了啊，拒绝了人家不需要赔钱吗？”&lt;/p&gt;
&lt;p&gt;　　LZ只能说，LZ并没有收到买家A的定金，买家A的定金是给了中介了，而且LZ也没有和买家A或者中介签订任何协议，毕竟LZ人一直在杭州，根本就没回去，所以，和买家A之间，最多只能算是个远程口头协议而已。&lt;/p&gt;
&lt;p&gt;　　虽说拒绝买家A从良心上来说有点不好意思，但谁家的钱都不是大风刮来的，毕竟是4万块钱，LZ没有理由不要。&lt;/p&gt;
&lt;p&gt;　　后来，这个买家A不知道从哪里要到了LZ的电话，还给LZ专门打了电话。&lt;/p&gt;
&lt;p&gt;　　意思是说，他为了买房子把原来的房子都卖了，总之就是各种不容易，各种没退路，但LZ就是一句话，“很抱歉，毕竟是4万块钱啊。”&lt;/p&gt;
&lt;p&gt;　　最后这个买家A似乎是有点恼羞成怒了，直接说了句，“他出92万，那我就出95万！怎么样？”&lt;/p&gt;
&lt;p&gt;　　LZ当时一听，这个老哥看样子是真上头了啊，都开始搞起竞价了，但LZ内心肯定是不相信的，毕竟从88万涨到95万，这特么也太夸张了，而且听他的口气就是赌气的那种，根本不像是真心的。&lt;/p&gt;
&lt;p&gt;　　但就算他不是真心的，LZ也不能直接说你出95万也不卖你啊，所以LZ只能让他自己知难而退，便认真的说了句，“你要是愿意出95万的话，我肯定是愿意卖给你的，但是得给我交个定金，最起码要5万块，否则我确实没办法就这么相信，希望你能理解。”&lt;/p&gt;
&lt;p&gt;　　果不其然，这个买家一听LZ这么说，深深的叹了口气，然后说了句“还是算了”，就把电话给挂了。&lt;/p&gt;
&lt;p&gt;　　就这样，最终LZ的房子算是以92万的价格定了下来，而LZ也开始和中介B沟通起了具体的交易过程。&lt;/p&gt;
&lt;p&gt;　　按照中介B所说，卖房如果是按揭的话，LZ应该最少要回老家两趟，第一趟主要是签合同，交首付这些，第二趟则主要是过户。&lt;/p&gt;
&lt;p&gt;　　但是，由于LZ的房子没满二（当时还差大概5个月的样子），提前交易的话，要多交5%的税（将近5万），所以买家想满二以后再过户，LZ只能先签合同拿首付，至于尾款的话，要等到满二以后过户才能拿到。&lt;/p&gt;
&lt;p&gt;　　听到这个，LZ顿时有点犹豫了，要等差不多半年才能拿到所有的钱？那LZ现在卖个什么劲啊？&lt;/p&gt;
&lt;p&gt;　　还不如先不卖，然后等到满二以后再卖呢，反正怎么都要等到那时候才能完成交易，现在只拿个首付，钱又不够LZ买杭州的房子，有啥用呢？&lt;/p&gt;
&lt;p&gt;　　不过，LZ并没有一口回绝说房子不卖，而且也确实是巧，当时LZ刚好有事要回老家一个星期，于是LZ便和中介B说，如果自己确定要卖的话，会趁回老家的这个星期，挑个时间去市区一趟，把合同签了，顺便把首付收了，然后等满二以后，再回来进行过户。如果确定不卖的话，也会在这个星期内给他一个确定的答复。&lt;/p&gt;
&lt;p&gt;　　其实这已经是LZ的缓兵之计了，这个时候，LZ已经更倾向于不卖了，因为要等半年拿到尾款实在太久了，还不如等到满二再卖，到时候能省5%的税，说不定还能卖高点。&lt;/p&gt;
&lt;p&gt;　　只不过考虑到C是LZ媳妇亲戚的关系，所以才没好意思这么快就说又不卖了。&lt;/p&gt;
&lt;p&gt;　　这就是找亲戚的弊端了，如果是不认识的中介，那LZ就直接说不卖就完事了，就和之前那个中介A一样。&lt;/p&gt;
&lt;p&gt;　　结果，让LZ意外的事情发生了，就在LZ刚回老家的第二天，中介B突然打电话说，买家已经把50万首付打到他们公司的账户了，他们先代收了，让LZ直接去签合同拿首付。&lt;/p&gt;
&lt;p&gt;　　纳尼？还能这样操作的？&lt;/p&gt;
&lt;p&gt;　　这LZ一听就火了，第一时间就给中介B打电话，“谁特么让你随便帮我收钱的？谁给你的这个权利？我不是说了还没确定要卖呢，你替我收个毛的钱？”&lt;/p&gt;
&lt;p&gt;　　结果中介B竟然还一口委屈的说，“是C总让我务必保障你的利益，所以我就先把钱收了，免得到时候买家反悔再不掏首付。现在这样你来了直接拿钱，一点风险都没有了。”&lt;/p&gt;
&lt;p&gt;　　对于中介B的这个说法，LZ对此是嗤之以鼻的，先收钱肯定是为了生米煮成熟饭，想挣这笔中介费而已，什么保障LZ的利益，纯属扯淡。&lt;/p&gt;
&lt;p&gt;　　原本LZ压根犯不着跟这个中介生气，因为他收钱是他收的，是他自己过线了，LZ压根就没收到过买家一分钱，也没签过任何协议，所以哪怕是他代收了首付，LZ还是可以随时退出，而不需要付任何法律上的责任。　　&lt;/p&gt;
&lt;p&gt;　　但就在LZ跟中介说，让他把定金和首付退给人家，LZ不打算卖以后，很快C的电话就打了过来。&lt;/p&gt;
&lt;p&gt;　　C和LZ扯了很多，但核心的意思就是，如果LZ就这样不卖了，让他在这个中介B的员工面前很没面子，让LZ还是把房子给卖了，去签合同拿首付。&lt;/p&gt;
&lt;p&gt;　　纳尼？还能这样操作的？&lt;/p&gt;
&lt;p&gt;　　LZ不卖房就是不给C面子，这房子还特么非卖不可了？&lt;/p&gt;
&lt;p&gt;　　卖个毛！凭啥LZ就得为了你的面子牺牲，非得卖房不可？本来LZ虽然倾向于不卖，但毕竟没有百分百确定，但现在啥也别说，就是不卖了，爱特么谁谁。&lt;/p&gt;
&lt;p&gt;　　结果中介B听到C说LZ不卖了以后，又给LZ打了个电话，说如果LZ现在说不卖，对方可能起诉LZ，让LZ赔偿定金。&lt;/p&gt;
&lt;p&gt;　　哟？装委屈不行，现在又开始威胁LZ了？&lt;/p&gt;
&lt;p&gt;　　去你大爷的，就是不卖。&lt;/p&gt;
&lt;p&gt;　　LZ当时的原话是，“如果法院真的判我要赔偿定金，那我就赔，但现在我就是不卖了，你让他去告吧。”&lt;/p&gt;
&lt;p&gt;　　其实这话LZ是冲着中介说的，意思也很明显，就是你别威胁LZ，老子不吃这一套。&lt;/p&gt;
&lt;p&gt;　　最后，中介B和LZ媳妇的亲戚C看LZ油盐不进，只能让买家来把他的定金和首付又拿了回去，这件事也算是告一段落。&lt;/p&gt;
&lt;p&gt;　　说实话，LZ总觉得那个中介B说的有点假，因为LZ不太相信那个买家，在完全没见到LZ的情况下，就敢把50万首付打给中介，这应该是那个中介想圈住LZ的套路而已。&lt;/p&gt;
&lt;p&gt;　　不过这都不重要了，反正是不卖了，而且事情也结束了。&lt;/p&gt;
&lt;p&gt;　　就这样，五个多月过去，到了2017年的12月份，LZ的房子终于满二了，这也意味着买家不需要交5%的税了，而LZ自然也能多卖点。&lt;/p&gt;
&lt;p&gt;　　不过此时LZ的房产证还没有办下来，所以LZ倒也没有急着立马挂上去卖，直到2018年的1月份，LZ拿到了房产证，此时才算是万事俱备，连东风都不欠了。&lt;/p&gt;
&lt;p&gt;　　然而，此时杭州的房价又涨了不少，LZ觉得就算卖了老家的房子，也不一定能换一套杭州的房子，所以这个时候，LZ又特么有点犹豫了。&lt;/p&gt;
&lt;p&gt;　　到底是装修第一套房子，还是卖老家房子然后在杭州再买个二套？&lt;/p&gt;
&lt;p&gt;　　思来想去，LZ觉得，还是装修第一套房子吧。&lt;/p&gt;
&lt;p&gt;　　毕竟如果卖了老家的房子，又不够在杭州买的话，那还不如留着老家的房子。&lt;/p&gt;
&lt;p&gt;　　就这样，2018年春节前的那段时间，LZ和媳妇又开始讨论起了装修，甚至连车都选好了，因为此时已经早就存够了装修钱，而且还有剩余。&lt;/p&gt;
&lt;p&gt;　　原本什么都定的差不多了，就打算过完年以后，差不多就开始动工了。&lt;/p&gt;
&lt;p&gt;　　结果，过完年以后，无意之间LZ看房产APP的时候发现，老家的房价涨了，而且还涨了不少，LZ的那个小区，都快1万1平了。&lt;/p&gt;
&lt;p&gt;　　这就意味着，LZ的那套房子现在可以卖将近140万！比之前的92万可是多了40多万啊！这才过去半年多点而已！&lt;/p&gt;
&lt;p&gt;　　简直无情啊！&lt;/p&gt;
&lt;p&gt;　　但不管怎么说，卖了老家的房子以后，似乎又买得起杭州的房子了，就算买不起，差的肯定也不多，还是完全不成问题的。&lt;/p&gt;
&lt;p&gt;　　就这样，LZ犹豫了一小段时间，最终还是决定，卖老家房子！&lt;/p&gt;
&lt;p&gt;　　这一次，LZ没有直接找中介，而是直接把房源信息挂到了网上，等着中介来找自己。&lt;/p&gt;
&lt;p&gt;　　结果这下LZ的电话炸了，一连几十个电话打过来，全是中介公司，主要就是登记一下LZ的房子信息，比如几栋几单元几楼、满不满二、价钱多少等等。&lt;/p&gt;
&lt;p&gt;　　直到LZ把信息撤掉，电话的频率才逐渐下降下来，但那几天还是偶尔会来一个中介公司的电话。&lt;/p&gt;
&lt;p&gt;　　既然是卖房子，最敏感的就是价格了，当时LZ对房价比较看好，所以开得很高，张口就是145万，最低可还到140万。&lt;/p&gt;
&lt;p&gt;　　结果差不多等了1个多月快2个月了，一个来真心谈价钱的都没有，全是中介公司的烟雾弹，都说是手里有准客户，但其实就是要信息的，根本就没有买家。&lt;/p&gt;
&lt;p&gt;　　逐渐的，LZ也渐渐失去了耐心，同时也意识到140万太高了（一开始也确实是乱开的价），所以开始了降价，这一降就是5万块，也就是135万。&lt;/p&gt;
&lt;p&gt;　　但是，让LZ失望的是，135万依旧是无人问津。&lt;/p&gt;
&lt;p&gt;　　这样又过了一个月，LZ意识到，135万还是有点高，于是乎LZ又降了5万，变成了130万。&lt;/p&gt;
&lt;p&gt;　　这样一来，终于有一个中介说，有一个客户130万想买，不过对方还想还价，他正在跟对方谈。&lt;/p&gt;
&lt;p&gt;　　此时已经来到了2018年的7月份，距离LZ初次挂牌已经过去了4个月。&lt;/p&gt;
&lt;p&gt;　　好在这次终究是没让LZ失望，买家同意了130万的价格，而且和这个中介交流的过程中，LZ也觉得，这个中介是比较靠谱的，并且LZ和中介梳理了好多次交易流程，总算是把交易流程彻底定了下来。&lt;/p&gt;
&lt;p&gt;　　毕竟LZ远在杭州，回老家一趟不易，肯定是要把所有流程都安排好才行。&lt;/p&gt;
&lt;p&gt;　　总的来说，交易流程分这么几步，首先是签二手房交易合同，然后LZ陪买方去银行面签，紧接着买方交首付，然后LZ拿首付去银行还贷（因为LZ当初是贷款买的），接下来就等银行出一个还贷证明（大概一周），然后拿着去房管局解押，紧接着就进行过户，然后基本上就等着银行放款了。&lt;/p&gt;
&lt;p&gt;　　整个过程下来，LZ回了老家两趟，共计花费时间1个半月拿到了所有的钱。&lt;/p&gt;
&lt;p&gt;　　总的来说，真正卖房的这次经历还是非常顺利的，这其实主要还是中介比较靠谱，什么事都提前安排好了，所以LZ回老家办事都比较顺利，没有出现什么意外，否则可能不止要回老家两趟。&lt;/p&gt;
&lt;p&gt;　　不过，从2017年的6月份左右，到2018年的8月份，整个卖房周期足足跨越了1年零2个月，可谓是曲折离奇。&lt;/p&gt;
&lt;p&gt;　　不论是LZ的心里变化，还是亲戚事件，都给这次卖房经历，增加了不少意外性。&lt;/p&gt;
&lt;p&gt;　　好在最终，房子还是顺顺利利的卖出去了，而且按照最后的成交价来算的话，LZ差不多赚了足足40多万，将近50万的样子。&lt;/p&gt;
&lt;p&gt;　　这也算是瞎猫碰见了死耗子，让LZ给刚好撞上了。&lt;/p&gt;

&lt;h3&gt;中途小结&lt;/h3&gt;

&lt;p&gt;　　这次卖房的过程，可算是让LZ操碎了心，感觉LZ那一年每天都在想卖房这个事情，而当LZ收到所有房款的时候，感觉就像打赢了一场战争一样，终于松了口气。&lt;/p&gt;
&lt;p&gt;　　不过虽然过程曲折，但其实LZ还是收获了不少经验，简单分享一下，供用得上的同学参考。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;异地的房子卖起来真是各种麻烦，所以如果不是没办法，尽量不要买非工作地的房子。&lt;/li&gt;
&lt;li&gt;具体的交易流程必须要一点点搞清楚，不然很容易被坑。如果你不清楚流程是否靠谱，可以在评论区问LZ，LZ现在基本上算是半个专家。&lt;/li&gt;
&lt;li&gt;尽可能满二再卖，否则5%的税还是挺狠的，会导致你卖不上价钱。&lt;/li&gt;
&lt;li&gt;买卖还是尽量不要跟亲戚打交道了吧，其实LZ早就知道这个道理，如果不是那个中介公司刚好是亲戚开的，LZ其实很不想在买卖的事情上和亲戚打交道。&lt;/li&gt;
&lt;li&gt;收定金要一定要慎重，LZ之所以能多次反悔，本质原因是LZ压根没收过定金，也没签过任何定金协议之类的，如果你确实收了定金，又打了收据给买家或者中介，那你基本上就没什么反悔的余地了，除非你愿意赔偿违约金。&lt;/li&gt;
&lt;li&gt;如果可以，还是找大的中介公司，毕竟房产交易是大买卖，求稳为主，不要为了省那点中介费，最后给自己找麻烦。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;h3&gt;第三次买房——兴奋　　&lt;/h3&gt;

&lt;p&gt;　　第三次买房，LZ称之为兴奋，这种感觉是前两次都没有的，因为前两次就算买了，也要很久才能住进去，基本是遥遥无期。&lt;/p&gt;
&lt;p&gt;　　但这第三次不同，买了就是要直接住的，这是真正要告别租房的一次购房。&lt;/p&gt;
&lt;p&gt;　　其实这次买房子LZ买的非常快，因为LZ有一个硬性要求，那就是物业必须要好，而就杭州来说，物业比较顶尖的有三家，万科、绿城和滨江。&lt;/p&gt;
&lt;p&gt;　　首先滨江可以基本排除，因为滨江的离LZ都太远，而绿城和万科，LZ简单对比了下，感觉还是万科更好一些。&lt;/p&gt;
&lt;p&gt;　　所以，确定了物业必须是万科以后，LZ的选择范围就基本固定了，因为万科的房子一般都比较贵，而LZ的钱也比较有限，所以LZ能买得起，又是万科物业，并且离公司不是很远的，就只有一个小区了。&lt;/p&gt;
&lt;p&gt;　　这就好买多了，小区一下就选好了。&lt;/p&gt;
&lt;p&gt;　　于是，LZ约了中介，集中一天，连续在那个小区看了十几套房，一下就相中了其中一套。&lt;/p&gt;
&lt;p&gt;　　原因无他，首先是这一家是5/10层，楼层几乎完美，而且一梯两户，也就是说，一个电梯只有20家使用（其实不到20家，因为1层、2层基本不需要），绝对不至于等电梯，更何况，就算电梯有问题，5楼爬一爬，就当锻炼身体了，也问题不大。&lt;/p&gt;
&lt;p&gt;　　其次这家的后面是一座山，空气就不提了，简直完美，对着山撸一把DOTA，简直不要太爽，而且背后有山，意为背后有靠山，寓意也非常之好（是不是有点小迷信了，-_-）。&lt;/p&gt;
&lt;p&gt;　　最重要的，还是这一家的装修，是最符合LZ和媳妇的爱好的，可以拎包入住，而且房子非常新，房东装修完以后基本没住过，家具家电基本全都是新的。&lt;/p&gt;
&lt;p&gt;　　没的说，直接交定金，拿下！&lt;/p&gt;
&lt;p&gt;　　而整个交易过程也很顺利，和卖房的时候差不多，无非是LZ的角色对调了一下，从卖方变成了买方而已。&lt;/p&gt;
&lt;p&gt;　　不过杭州的二手房交易有一点和老家不同，那就是交易资金会被冻结，卖方拿钱会慢一些，不过这其实是为了保障买方的利益，所以LZ自然不会有什么意见。&lt;/p&gt;
&lt;p&gt;　　而且对方也是一对80后夫妻，比LZ大个4、5岁，互相比较能谈得来，每次交易的时候，中介在那搞，我们在那聊会儿天基本就完事了，轻松加愉快。&lt;/p&gt;
&lt;p&gt;　　唯一美中不足的是，房子不满二，所以LZ多交了12万的税，这可是白白给国家了，本来房子只有225万，结果最后各种税加中介费，足足花了245万。&lt;/p&gt;
&lt;p&gt;　　要知道，因为LZ是二套，可是要掏六成的首付啊！&lt;/p&gt;
&lt;p&gt;　　不过，LZ的运气还不错，虽然最近杭州的房价在降，但是LZ这个小区的价钱并没怎么降，普遍只降了5万块，而且因为LZ本身买的也比较便宜，所以至少目前还不亏，而且从长远来看，应该还是看涨的。&lt;/p&gt;
&lt;p&gt;　　况且，看着媳妇最近热火朝天的收拾新家，花多少钱都值了，这种幸福感是真的很难用钱去衡量的。&lt;/p&gt;

&lt;h3&gt;中途小结&lt;/h3&gt;

&lt;p&gt;　　第三次买房LZ写的比较简单，因为确实过程很快，也很顺利，没什么好写的。&lt;/p&gt;
&lt;p&gt;　　而且这次是买来住的，所以整体是一个比较个性化的选择过程，是没有多大参考价值的。&lt;/p&gt;
&lt;p&gt;　　就像前面LZ说的，LZ就想选物业好的，楼层适中的，但可能有的人对这个并不在意，而是在意地理位置、周边发展，或者是否靠近地铁等等。&lt;/p&gt;
&lt;p&gt;　　所以，LZ买的，并不一定适合你，只能提供一些参考给你。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;对于追求生活品质的人来说，物业还是挺重要的，一个好的物业和差的物业，那住起来的感觉完全不同，谁住谁知道。&lt;/li&gt;
&lt;li&gt;一般地段好或者是刚需类的房子都不太会降价，而一些华而不实的房子是很容易降价的，比如杭州这一次降价风潮中，降的最狠的一般都是“老破小”，或者是非常偏远，纯靠概念炒作起来的地方。&lt;/li&gt;
&lt;li&gt;作为拥有两个房贷的人，深刻的体会到，先不说买房子能不能升值赚钱，但最起码可以强行让你存钱，只不过这些钱都以房子的形式存在着而已。就像LZ一样，如果不是买房子的话，存钱的速度肯定没有这么快，因为钱在手里很容易不经意就花掉了。所以还是那句话，自从有了房贷以后，LZ存钱的速度连自己都害怕。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;h3&gt;结尾的话&lt;/h3&gt;

&lt;p&gt;　　挺巧的是，LZ今年刚好30周岁，三十而立，也终于要结束租房的日子了。&lt;/p&gt;
&lt;p&gt;　　说实话，不光是媳妇最近忙的热火朝天的，LZ也是一样，这么多年想买台式电脑一直没买，就等着这一天了，想想还真有点小兴奋呢，-_-。&lt;/p&gt;
&lt;p&gt;　　7年的奋斗，终是没有辜负，接下来的日子，想必幸福感会比以前强不少。&lt;/p&gt;
&lt;p&gt;　　所以，房子最大的意义，还是它所带来的幸福感，这是多少钱都换不来的。&lt;/p&gt;
&lt;p&gt;　　文章末尾，送上LZ新家的照片，还有LZ刚租的拿来练手的豪车，也是LZ考了9年驾照以来，第一次开车，-_-。&lt;/p&gt;
&lt;p&gt;　　最终，希望所有的程序员，都能够早日摆脱租房的日子，虽然，租房的日子也很令人怀念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558323/201811/558323-20181110043022586-2070538121.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;933&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558323/201811/558323-20181110043943935-530791438.png&quot; alt=&quot;&quot; width=&quot;692&quot; height=&quot;519&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558323/201811/558323-20181110043353308-637068622.png&quot; alt=&quot;&quot; width=&quot;696&quot; height=&quot;521&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558323/201811/558323-20181110043437519-1604670630.png&quot; alt=&quot;&quot; width=&quot;693&quot; height=&quot;519&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558323/201811/558323-20181110043522389-866287514.png&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;517&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558323/201811/558323-20181110043601071-646270916.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;515&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558323/201811/558323-20181110043704336-1159496131.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;515&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558323/201811/558323-20181110043645214-436836770.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;515&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/558323/201811/558323-20181110132047742-1065199398.jpg&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;917&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Nov 2018 15:46:00 +0000</pubDate>
<dc:creator>左潇龙</dc:creator>
<og:description>引言 买房，一直是程序员群体绕不开的一个话题，尤其是到了一定年纪和人生阶段以后，买房这件事会变得越来越迫切。 为什么LZ一上来就说，买房是程序员绕不开的一个话题？ 其实原因很简单，由于程序员这个职业的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuoxiaolong/p/life86.html</dc:identifier>
</item>
<item>
<title>Go基础系列：读取标准输入 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9944229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9944229.html</guid>
<description>&lt;p&gt;fmt包中提供了3类读取输入的函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Scan家族：从标准输入os.Stdin中读取数据，包括Scan()、Scanf()、Scanln()&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;SScan家族：从字符串中读取数据，包括Sscan()、Sscanf()、Sscanln()&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Fscan家族：从io.Reader中读取数据，包括Fscan()、Fscanf()、Fscanln()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Scanln、Sscanln、Fscanln在遇到换行符的时候停止&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Scan、Sscan、Fscan将换行符当作空格处理&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Scanf、Sscanf、Fscanf根据给定的format格式读取，就像Printf一样&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这3家族的函数都返回读取的记录数量，并会设置报错信息，例如读取的记录数量不足、超出或者类型转换失败等。&lt;/p&gt;
&lt;p&gt;以下是它们的定义方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go doc fmt | grep -Ei &quot;func [FS]*Scan&quot;
func Fscan(r io.Reader, a ...interface{}) (n int, err error)
func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error)
func Fscanln(r io.Reader, a ...interface{}) (n int, err error)
func Scan(a ...interface{}) (n int, err error)
func Scanf(format string, a ...interface{}) (n int, err error)
func Scanln(a ...interface{}) (n int, err error)
func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为还没介绍io.Reader，所以Fscan家族的函数暂且略过，但用法和另外两家族的scan类函数是一样的。&lt;/p&gt;
&lt;h2 id=&quot;scanscanf和scanln&quot;&gt;Scan、Scanf和Scanln&lt;/h2&gt;
&lt;p&gt;Scan家族函数从标准输入读取数据时，将以空格为分隔符分隔标准输入中的内容，并将分隔后的各个记录保存到给定的变量中。其中Scanf()可以指定分隔符。&lt;/p&gt;
&lt;p&gt;例如，使用Scanln函数等待用户输入数据，或从管道中读取数据。下面的代码将等待用户输入，且将读取的内容分别保存到name变量和age变量中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
)

func main() {
    var (
        name string
        age  int
    )
    fmt.Print(&quot;输入姓名和年龄，使用空格分隔：&quot;)
    fmt.Scanln(&amp;amp;name, &amp;amp;age)
    fmt.Printf(&quot;name: %s\nage: %d\n&quot;, name, age)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为Scanln()遇到换行符或EOF的时候终止读取，所以在输入的时候只要按下回车键就会结束读取。&lt;/p&gt;
&lt;p&gt;运行它，将提示输入姓名：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;请输入姓名和年龄，空格分隔：
周伯通 69
name: 周伯通
age: 69&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理Scanf()也在遇到换行符或EOF的时候终止读取行为。使用Scanf()的时候，需要给定格式化字符串形式：&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fmt.Scanf(&quot;%s %d&quot;,&amp;amp;name,&amp;amp;age)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入时，第一个字段会转换成字符串格式保存到&lt;code&gt;name&lt;/code&gt;变量中，第二个记录会转换成整数保存到&lt;code&gt;age&lt;/code&gt;中，如果转换失败，将不会进行保存。例如输入&lt;code&gt;malongshuai aaa&lt;/code&gt;，由于&lt;code&gt;aaa&lt;/code&gt;无法转换成int，所以age变量的值仍然为初始化的数值0。&lt;/p&gt;
&lt;p&gt;Scanf可指定分隔符，其中上面的是&lt;code&gt;%s %d&lt;/code&gt;中间的空格就是分隔符。例如下面指定&lt;code&gt;:&lt;/code&gt;作为分隔符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fmt.Scanf(&quot;%s : %d&quot;,&amp;amp;name,&amp;amp;age)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在输入时，必须按照以下格式进行输入：首先至少一个空格，然后一个冒号，再至少一个空格：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;周伯通 : 23    // 或者连续多个空格  &quot;周伯通     :   23&quot;
name: 周伯通
age: 23&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果使用的是&lt;code&gt;fmt.Scan()&lt;/code&gt;，则输入数据时可以换行输入，Scan()会将换行符作为空格进行处理，直到读取到了2个记录之后自动终止读取操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fmt.Scan(&amp;amp;name, &amp;amp;age)

请输入姓名和年龄，空格分隔：周伯通
87
name: 周伯通
age: 87&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说，只使用Scanf类函数比较好。&lt;/p&gt;
&lt;h2 id=&quot;返回值&quot;&gt;返回值&lt;/h2&gt;
&lt;p&gt;这些函数都有返回值：读取的记录数量和err信息。&lt;/p&gt;
&lt;p&gt;以Scanln()为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    var (
        name string
        age  int
    )
    fmt.Print(&quot;输入姓名和年龄，使用空格分隔：&quot;)
    n, err := fmt.Scanln(&amp;amp;name, &amp;amp;age)

    fmt.Printf(&quot;name: %s\nage: %d\n&quot;, name, age)

    fmt.Println(&quot;records count:&quot;,n)
    fmt.Println(&quot;err or not:&quot;,err)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;malongshuai 23     // n = 2, err = nil
malongshuai        // n = 1, err != nil
malongshuai long   // n = 2, err != nil
malongshuai 23 23  // n = 2, err != nil&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sscansscanf和scanln&quot;&gt;Sscan、Sscanf和Scanln&lt;/h2&gt;
&lt;p&gt;Sscan家族的函数用于从给定字符串中读取数据，用法和Scan家族类似。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func Sscan(str string, a ...interface{}) (n int, err error)
func Sscanln(str string, a ...interface{}) (n int, err error)
func Sscanf(str string, format string, a ...interface{}) (n int, err error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
)

func main() {
    var (
        name string
        age  int
    )
    input := &quot;malongshuai 23&quot;

    fmt.Sscan(input, &amp;amp;name, &amp;amp;age)
    fmt.Printf(&quot;name: %s\nage: %d\n&quot;, name, age)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Sscanf()可以指定分隔符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;input := &quot;malongshuai : 23&quot;

fmt.Sscanf(input, &quot;%s : %d&quot;, &amp;amp;name, &amp;amp;age)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用bufio中读取标准输入&quot;&gt;使用bufio中读取标准输入&lt;/h2&gt;
&lt;p&gt;除了fmt包的Scan类函数，bufio包也可以读取标准输入。当然，读取标准输入只是它的一个功能示例，它的作用是操作缓冲IO。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;os&quot;
)

var inputReader *bufio.Reader
var input string
var err error

func main() {
    inputReader = bufio.NewReader(os.Stdin)
    fmt.Println(&quot;输入姓名：&quot;)
    input, err = inputReader.ReadString('\n')
    if err == nil {
        fmt.Printf(&quot;The input was: %s\n&quot;, input)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中NewReader()创建一个bufio.Reader实例，表示创建一个从给定文件中读取数据的读取器对象。然后调用读取器对象(Reader实例)的ReadString()方法，这个方法以&lt;code&gt;\n&lt;/code&gt;作为分隔符，它的分隔符必须只能是单字符，且必须使用单引号包围，因为它会作为byte读取。ReadString()读取来自os.Stdin的内容后将其保存到input变量中，同时返回是否出错的信息。ReadString()只有一种情况会返回err：没有遇到分隔符。&lt;/p&gt;
&lt;p&gt;ReadString会将读取的内容&lt;strong&gt;包括分隔符&lt;/strong&gt;都一起放进缓冲中，如果读取文件时读到了结尾，则会将整个文件内容放进缓冲，并将文件终止标识符io.EOF放进设置为err。&lt;/p&gt;
&lt;p&gt;通常无需单独定义这些变量，下面是更常见的用法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;inputReader := bufio.NewReader(os.Stdin)
input, err := inputReader.ReadString('\n')&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 11 Nov 2018 15:27:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>fmt包中提供了3类读取输入的函数： Scan家族：从标准输入os.Stdin中读取数据，包括Scan()、Scanf()、Scanln() SScan家族：从字符串中读取数据，包括Sscan()、S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9944229.html</dc:identifier>
</item>
<item>
<title>Redis源码阅读（六）集群-故障迁移(下) - gogo一</title>
<link>http://www.cnblogs.com/gogoCome/p/9944152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gogoCome/p/9944152.html</guid>
<description>&lt;p&gt;　　最近私人的事情比较多，没有抽出时间来整理博客。书接上文，上一篇里总结了Redis故障迁移的几个关键点，以及Redis中故障检测的实现。本篇主要介绍集群检测到某主节点下线后，是如何选举新的主节点的。注意到Redis集群是无中心的，那么使用分布式一致性的算法来使集群中各节点能对在新主节点的选举上达成共识就是一个比较可行的方案。&lt;/p&gt;
&lt;p&gt;　　在工程上，Raft一致性算法是比较易于实现和理解的分布式一致性算法；Redis也是使用了Raft来做主节点选举的。所以这里先简单介绍下Raft的原理：&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、Raft算法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　Raft为解决一致性问题， 引入了Leader中心。简单来说就是通过选举出一个单Leader，让Leader来接收来自客户端的所有数据，Leader会将数据分发给所有节点，当Leader判断出数据已经分发到系统中大半节点以后，即认为该数据已经可以在系统中持久化存储，并通知客户端该数据提交成功，后续系统中数据的一致性可以让分布式系统内部通过数据同步的方式实现。（注意到这里和Redis去中心化的思想不符，所以Redis只是利用了其中选举的部分）&lt;/p&gt;
&lt;p&gt;算法主要部分如下：&lt;/p&gt;
&lt;p&gt;　　1. Leader选举&lt;/p&gt;
&lt;p&gt;　　2. 客户数据一致化处理（即论文中的log repliecation部分）&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;Leader选举&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　Raft给系统中的节点分配了三种状态，分别是Follower, Candidates, Leader；选举过程即是在分布式式系统中选出Leader状态节点的过程。三种状态的转换关系如下所示：&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1438066/201811/1438066-20181111224726151-2131792237.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;25&quot;&gt;
&lt;p&gt;　　当系统中没有Leader时，所有节点初始状态均为Follewer，每个节点在经历time_out时间后，会自动转变为Candidate，并尝试发起投票以便成为新的Leader；为了保证系统中只存在一个Leader，当选新Leader的条件是Candidate收到了超过半数节点以上的投票&lt;span&gt;（每个节点在每轮投票中只能投给唯一的节点，通常是投个第一个发来邀票请求的节点）&lt;/span&gt;，达到该条件后，Candidate即变为Leader。注意到投票是有轮次的，只有收到当前轮次的投票才是有效票。在状态机中，用term来表示投票的轮次。&lt;/p&gt;
&lt;p&gt;根据上面介绍的流程，容易注意到为实现Leader的选举，有几个前提：&lt;span&gt;1. 每个节点都需要知道系统中到底有哪些节点存在（为了能向每个节点邀票，同时要知道节点总数才能判断最终是否收到了多数的投票）； 2. 所有节点应该有统一的初始化term，且后续需要不断的同步term&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第一点前提，只需要初始化阶段给所有节点置统一的term即可；而第二点前提则要求各节点主动拥抱新term，无情抛弃老term；具体来说就是每个节点收到旧term的消息，可以不处理消息请求，并把自身的较高的term返回；而每个节点收到新的term之后，则要积极响应，并在响应结束之后更新自己的term。&lt;/p&gt;
&lt;p&gt;　　有一种可能，就是在选举轮次中所有的节点都没有收到多数节点的投票认可，那么就需要发起新一轮的投票；为了减少新一轮投票依旧无法选出Leader的概率，每个Candidate节点的time_out时间是随机的，这样通常会有一个最先发出请求的节点占得先机，能收获大多数的选票。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;20.462583977321&quot;&gt;
&lt;h3&gt;客户数据一致化处理&lt;/h3&gt;
&lt;div readability=&quot;10.527415143603&quot;&gt;　　由于Redis中并没有用到Raft算法的一致化数据处理，这里不过多描述（该部分内容比较复杂，需要考虑的异常场景较多）；详细的介绍可以看这篇博文，&lt;a href=&quot;https://www.cnblogs.com/mindwind/p/5231986.html&quot;&gt;https://www.cnblogs.com/mindwind/p/5231986.html&lt;/a&gt;；个人觉得这篇博文很直观的介绍了分布式系统下在各种异常情况下，数据的一致性是如何保证的。&lt;/div&gt;
&lt;div readability=&quot;31&quot;&gt;
&lt;h2&gt;二、Redis选举新主节点的实现&lt;/h2&gt;
&lt;p&gt;　　Redis选举新的主节点，有一个很重要的概念需要先理解下，就是epoch——纪元，类似于Raft中term的意义。Redis的数据结构中记录了两个epoch，分别是currentepoch和configepoch；这两个纪元的作用是不同的。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;currentepoch: &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;这个变量是记录整个集群投票轮次的&lt;/span&gt;，初始时，集群中所有节点的currentepoch都是0；后面虽然没个发起投票的节点都会自增该值，但也会同时将该值作为投票轮次信息发给其他节点，整个集群最终还是会具有相同的currentepoch值；&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;　configepoch:&lt;/strong&gt;  &lt;/span&gt;&lt;span&gt;这个变量是记录节点自身的特征值，主要用于判断槽的归属节点是否需要更新&lt;/span&gt;；考虑如下的场景，A节点负责槽1,2,3且configepoch=n，A节点掉线后从属节点B接替了A的工作成为新的主节点，那么B此时就负责1,2,3槽，B的configepoch=n1(n1一定大于n，因为每当有从节点通过故障迁移接替主节点工作时，该从节点的configepoch就会变更为整个集群中最大的configepoch)；当A节点恢复工作后，还不知道自己已经被替代了，还向其他节点宣称自己是1,2,3槽的负责节点。其他节点已将1,2,3槽的负责节点改为B了，当其他节点收到A恢复之后的心跳包，会比较1,2,3槽所属节点B的configepoch(=n1)与A的configepoch(=n)哪个更大，发现n1更大就不会变更自己的记录，反过来还要通知A它所负责的槽已经被接管了。&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;h4&gt;介绍下Redis选举主节点的流程：&lt;/h4&gt;
&lt;p&gt;　　1. 从节点检测到自己从属的主节点下线，开始发起一次选举；发起方式是向所有主节点广播发送一条投票请求，希望其他主节点同意自己为新的主节点；（带上自己记录的currentepoch，即Raft算法中的term），源码中如下：&lt;/p&gt;
&lt;div readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;从节点的故障转移，是在函数clusterHandleSlaveFailover中处理的，该函数在集群定时器函数clusterCron中调用。本函数
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;用于处理从节点进行故障转移的整个流程，包括：判断是否可以发起选举；判断选举是否超时；判断自己是否拉
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;到了足够的选票；使自己升级为新的主节点这些所有流程。
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;slave调用&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clusterHandleSlaveFailover(&lt;span&gt;void&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;clusterBeforeSleep对CLUSTER_TODO_HANDLE_FAILOVER状态的处理,或者clusterCron中实时处理
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;也就是当前从节点与主节点已经断链了多长时间,从通过ping pong超时，检测到本slave的master掉线了，从这时候开始算&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;    mstime_t data_age;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该变量表示距离发起故障转移流程，已经过去了多少时间；&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;     mstime_t auth_age = mstime() - server.cluster-&amp;gt;&lt;span&gt;failover_auth_time;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该变量表示当前从节点必须至少获得多少选票，才能成为新的主节点&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; needed_quorum = (server.cluster-&amp;gt;size / &lt;span&gt;2&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示是否是管理员手动触发的故障转移流程；&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; manual_failover = server.cluster-&amp;gt;mf_end != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
&lt;span&gt; 16&lt;/span&gt;                           server.cluster-&amp;gt;mf_can_start; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明向从发送了cluster failover force要求该从进行强制故障转移&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该变量表示故障转移流程(发起投票，等待回应)的超时时间，超过该时间后还没有获得足够的选票，则表示本次故障转移失败；&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;    mstime_t auth_timeout, 
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该变量表示判断是否可以开始下一次故障转移流程的时间，只有距离上一次发起故障转移时，已经超过auth_retry_time之后，
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;才表示可以开始下一次故障转移了（auth_age &amp;gt; auth_retry_time）；&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;             auth_retry_time;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;     server.cluster-&amp;gt;todo_before_sleep &amp;amp;= ~&lt;span&gt;CLUSTER_TODO_HANDLE_FAILOVER;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Compute the failover timeout (the max time we have to send votes
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;     * and wait for replies), and the failover retry time (the time to wait
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;     * before waiting again.
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;     * Timeout is MIN(NODE_TIMEOUT*2,2000) milliseconds.
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;     * Retry is two times the Timeout.
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     auth_timeout = server.cluster_node_timeout*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (auth_timeout &amp;lt; &lt;span&gt;2000&lt;/span&gt;) auth_timeout = &lt;span&gt;2000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     auth_retry_time = auth_timeout*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Pre conditions to run the function, that must be met both in case
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;     * of an automatic or manual failover:
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;     * 1) We are a slave.
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;     * 2) Our master is flagged as FAIL, or this is a manual failover.
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;     * 3) It is serving slots. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    当前节点是主节点；当前节点是从节点但是没有主节点；当前节点的主节点不处于下线状态并且不是手动强制进行故障转移；
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;    当前节点的主节点没有负责的槽位。满足以上任一条件，则不能进行故障转移，直接返回即可；
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (nodeIsMaster(myself) ||
&lt;span&gt; 47&lt;/span&gt;         myself-&amp;gt;slaveof == NULL ||
&lt;span&gt; 48&lt;/span&gt;         (!nodeFailed(myself-&amp;gt;slaveof) &amp;amp;&amp;amp; !manual_failover) ||
&lt;span&gt; 49&lt;/span&gt;         myself-&amp;gt;slaveof-&amp;gt;numslots == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;真正把slaveof置为NULL在后面真正备选举为主的时候设置，见后面的replicationUnsetMaster&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; There are no reasons to failover, so we set the reason why we
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;         * are returning without failing over to NONE. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;         server.cluster-&amp;gt;cant_failover_reason =&lt;span&gt; REDIS_CLUSTER_CANT_FAILOVER_NONE;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;    }; 
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;slave从节点进行后续处理，并且和主服务器断开了连接&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Set data_age to the number of seconds we are disconnected from
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;     * the master. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将data_age设置为从节点与主节点的断开秒数&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (server.repl_state == REDIS_REPL_CONNECTED) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果主从之间是因为网络不通引起的，read判断不出epoll err事件，则状态为这个&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;         data_age = (mstime_t)(server.unixtime - server.master-&amp;gt;&lt;span&gt;lastinteraction) 
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                    * &lt;span&gt;1000&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;也就是当前从节点与主节点最后一次通信过了多久了&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; { 
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里一般都是直接kill主master进程，从epoll err感知到了，会在replicationHandleMasterDisconnection把状态置为REDIS_REPL_CONNECT
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本从节点和主节点断开了多久，&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;         data_age = (mstime_t)(server.unixtime - server.repl_down_since) * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Remove the node timeout from the data age as it is fine that we are
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;     * disconnected from our master at least for the time it was down to be
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;     * flagged as FAIL, that's the baseline. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; node timeout 的时间不计入断线时间之内 如果data_age大于server.cluster_node_timeout，则从data_age中
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;减去server.cluster_node_timeout，因为经过server.cluster_node_timeout时间没有收到主节点的PING回复，才会将其标记为PFAIL&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (data_age &amp;gt;&lt;span&gt; server.cluster_node_timeout)
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         data_age -= server.cluster_node_timeout; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从通过ping pong超时，检测到本slave的master掉线了，从这时候开始算&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Check if our data is recent enough. For now we just use a fixed
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;     * constant of ten times the node timeout since the cluster should
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;     * react much faster to a master down.
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;     * Check bypassed for manual failovers. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查这个从节点的数据是否较新：   
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 目前的检测办法是断线时间不能超过 node timeout 的十倍&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; data_age主要用于判断当前从节点的数据新鲜度；如果data_age超过了一定时间，表示当前从节点的数据已经太老了，
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;    不能替换掉下线主节点，因此在不是手动强制故障转移的情况下，直接返回；&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (data_age &amp;gt;
&lt;span&gt; 89&lt;/span&gt;         ((mstime_t)server.repl_ping_slave_period * &lt;span&gt;1000&lt;/span&gt;) +
&lt;span&gt; 90&lt;/span&gt;         (server.cluster_node_timeout *&lt;span&gt; REDIS_CLUSTER_SLAVE_VALIDITY_MULT))
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;manual_failover) {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;            clusterLogCantFailover(REDIS_CLUSTER_CANT_FAILOVER_DATA_AGE);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; If the previous failover attempt timedout and the retry time has
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;     * elapsed, we can setup a new one. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt; &lt;span&gt;    例如集群有7个master，其中redis1下面有2个slave,突然redis1掉了，则slave1和slave2竞争要求其他6个master进行投票，如果这6个
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;    master投票给slave1和slave2的票数都是3，也就是3个master投给了slave1,另外3个master投给了slave2，那么两个slave都得不到超过一半
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;    的票数，则只有靠这里的超时来进行重新投票了。不过一半这种情况很少发生，因为发起投票的时间是随机的，因此一半一个slave的投票报文auth req会比
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    另一个slave的投票报文先发出。越先发出越容易得到投票
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt; &lt;span&gt;    如果auth_age大于auth_retry_time，表示可以开始进行下一次故障转移了。如果之前没有进行过故障转移，则auth_age等
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;    于mstime，肯定大于auth_retry_time；如果之前进行过故障转移，则只有距离上一次发起故障转移时，已经超过
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;    auth_retry_time之后，才表示可以开始下一次故障转移。
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (auth_age &amp;gt;&lt;span&gt; auth_retry_time) {  
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次超时从新发送auth req要求其他主master投票，都会先走这个if，然后下次调用该函数才会走if后面的流程&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt;         server.cluster-&amp;gt;failover_auth_time = mstime() +
&lt;span&gt;115&lt;/span&gt;             &lt;span&gt;500&lt;/span&gt; + &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Fixed delay of 500 milliseconds, let FAIL msg propagate. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;             random() % &lt;span&gt;500&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Random delay between 0 and 500 milliseconds. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等到这个时间到才进行故障转移&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt;         server.cluster-&amp;gt;failover_auth_count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;         server.cluster-&amp;gt;failover_auth_sent = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         server.cluster-&amp;gt;failover_auth_rank = clusterGetSlaveRank();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本节点按照在master中的repl_offset来获取排名&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; We add another delay that is proportional to the slave rank.
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;         * Specifically 1 second * rank. This way slaves that have a probably
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;         * less updated replication offset, are penalized. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;         server.cluster-&amp;gt;failover_auth_time +=
&lt;span&gt;124&lt;/span&gt;             server.cluster-&amp;gt;failover_auth_rank * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             
&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; However if this is a manual failover, no delay is needed. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;        注意如果是管理员发起的手动强制执行故障转移，则设置server.cluster-&amp;gt;failover_auth_time为当前时间，表示会
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;        立即开始故障转移流程；最后，调用clusterBroadcastPong，向该下线主节点的所有从节点发送PONG包，包头部分带
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;        有当前从节点的复制数据量，因此其他从节点收到之后，可以更新自己的排名；最后直接返回；
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (server.cluster-&amp;gt;&lt;span&gt;mf_end) {
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;             server.cluster-&amp;gt;failover_auth_time =&lt;span&gt; mstime();
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;             server.cluster-&amp;gt;failover_auth_rank = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;        redisLog(REDIS_WARNING,
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start of election delayed for %lld milliseconds &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;139&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(rank #%d, offset %lld).&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;             server.cluster-&amp;gt;failover_auth_time -&lt;span&gt; mstime(),
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             server.cluster-&amp;gt;&lt;span&gt;failover_auth_rank,
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;            replicationGetSlaveOffset());
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Now that we have a scheduled election, broadcast our offset
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;         * to all the other slaves so that they'll updated their offsets
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;         * if our offset is better. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt; &lt;span&gt;        调用clusterBroadcastPong，向该下线主节点的所有从节点发送PONG包，包头部分带
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;        有当前从节点的复制数据量，因此其他从节点收到之后，可以更新自己的排名；最后直接返回；
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;150&lt;/span&gt; &lt;span&gt;        clusterBroadcastPong(CLUSTER_BROADCAST_LOCAL_SLAVES);
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; 
&lt;span&gt;154&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 进行故障转移 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt; 
&lt;span&gt;156&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; It is possible that we received more updated offsets from other
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;     * slaves for the same master since we computed our election delay.
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;     * Update the delay if our rank changed.
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;     * Not performed if this is a manual failover. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;162&lt;/span&gt; &lt;span&gt;    如果还没有开始故障转移，则调用clusterGetSlaveRank，取得当前从节点的最新排名。因为在开始故障转移之前，
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;    可能会收到其他从节点发来的心跳包，因而可以根据心跳包中的复制偏移量更新本节点的排名，获得新排名newrank，
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;    如果newrank比之前的排名靠后，则需要增加故障转移开始时间的延迟，然后将newrank记录到server.cluster-&amp;gt;failover_auth_rank中；
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;166&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (server.cluster-&amp;gt;failover_auth_sent == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
&lt;span&gt;167&lt;/span&gt;         server.cluster-&amp;gt;mf_end == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还没有进行过故障庄毅&lt;/span&gt;
&lt;span&gt;168&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; newrank =&lt;span&gt; clusterGetSlaveRank();
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (newrank &amp;gt; server.cluster-&amp;gt;&lt;span&gt;failover_auth_rank) {
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; added_delay =
&lt;span&gt;172&lt;/span&gt;                 (newrank - server.cluster-&amp;gt;failover_auth_rank) * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;             server.cluster-&amp;gt;failover_auth_time +=&lt;span&gt; added_delay;
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;             server.cluster-&amp;gt;failover_auth_rank =&lt;span&gt; newrank;
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;            redisLog(REDIS_WARNING,
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Slave rank updated to #%d, added %lld milliseconds of delay.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;                newrank, added_delay);
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Return ASAP if we can't still start the election. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;182&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果执行故障转移的时间未到，先返回&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (mstime() &amp;lt; server.cluster-&amp;gt;&lt;span&gt;failover_auth_time) {
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; &lt;span&gt;        clusterLogCantFailover(REDIS_CLUSTER_CANT_FAILOVER_WAITING_DELAY);
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; 
&lt;span&gt;188&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Return ASAP if the election is too old to be valid. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;189&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果距离应该执行故障转移的时间已经过了很久   
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么不应该再执行故障转移了（因为可能已经没有需要了）
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接返回&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (auth_age &amp;gt; auth_timeout) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果auth_age大于auth_timeout，说明之前的故障转移超时了，因此直接返回；&lt;/span&gt;
&lt;span&gt;193&lt;/span&gt; &lt;span&gt;        clusterLogCantFailover(REDIS_CLUSTER_CANT_FAILOVER_EXPIRED);
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;     
&lt;span&gt;197&lt;/span&gt; 
&lt;span&gt;198&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Ask for votes if needed. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向其他节点发送故障转移请求&lt;/span&gt;
&lt;span&gt;200&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (server.cluster-&amp;gt;failover_auth_sent == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; 
&lt;span&gt;202&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加配置纪元&lt;/span&gt;
&lt;span&gt;203&lt;/span&gt;         server.cluster-&amp;gt;currentEpoch++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; 
&lt;span&gt;205&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录发起故障转移的配置纪元&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt;         server.cluster-&amp;gt;failover_auth_epoch = server.cluster-&amp;gt;&lt;span&gt;currentEpoch;
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt;         redisLog(REDIS_WARNING,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting a failover election for epoch %llu.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;             (unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;) server.cluster-&amp;gt;&lt;span&gt;currentEpoch);
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; 
&lt;span&gt;211&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向其他所有节点发送信息，看它们是否支持由本节点来对下线主节点进行故障转移&lt;/span&gt;
&lt;span&gt;212&lt;/span&gt; &lt;span&gt;        clusterRequestFailoverAuth();
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; 
&lt;span&gt;214&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开标识，表示已发送信息&lt;/span&gt;
&lt;span&gt;215&lt;/span&gt;         server.cluster-&amp;gt;failover_auth_sent = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; 
&lt;span&gt;217&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO:       
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在进入下个事件循环之前，执行：      
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1）保存配置文件      
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2）更新节点状态        
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3）同步配置&lt;/span&gt;
&lt;span&gt;222&lt;/span&gt;         clusterDoBeforeSleep(CLUSTER_TODO_SAVE_CONFIG|
&lt;span&gt;223&lt;/span&gt;                              CLUSTER_TODO_UPDATE_STATE|
&lt;span&gt;224&lt;/span&gt; &lt;span&gt;                             CLUSTER_TODO_FSYNC_CONFIG);
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Wait for replies. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;226&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; 
&lt;span&gt;228&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Check if we reached the quorum. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;229&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前节点获得了足够多的投票，那么对下线主节点进行故障转移&lt;/span&gt;
&lt;span&gt;230&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (server.cluster-&amp;gt;failover_auth_count &amp;gt;=&lt;span&gt; needed_quorum) {
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 旧主节点&lt;/span&gt;
&lt;span&gt;232&lt;/span&gt;         clusterNode *oldmaster = myself-&amp;gt;slaveof; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在后面clusterSetNodeAsMaster中把slaveof置为NULL&lt;/span&gt;
&lt;span&gt;233&lt;/span&gt; 
&lt;span&gt;234&lt;/span&gt; &lt;span&gt;        redisLog(REDIS_WARNING,
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failover election won: I'm the new master.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; &lt;span&gt;        redisLog(REDIS_WARNING,
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configEpoch set to %llu after successful failover&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;                 (unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;) myself-&amp;gt;&lt;span&gt;configEpoch);
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; 
&lt;span&gt;240&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; We have the quorum, perform all the steps to correctly promote
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; &lt;span&gt;         * this slave to a master.
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; &lt;span&gt;         *
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; &lt;span&gt;         * 1) Turn this node into a master. 
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; &lt;span&gt;         *    将当前节点的身份由从节点改为主节点
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;246&lt;/span&gt; &lt;span&gt;        clusterSetNodeAsMaster(myself);
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让从节点取消复制，成为新的主节点&lt;/span&gt;
&lt;span&gt;248&lt;/span&gt; &lt;span&gt;        replicationUnsetMaster();
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt; 
&lt;span&gt;250&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 2) Claim all the slots assigned to our master. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;251&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收所有主节点负责处理的槽  轮训16384个槽位，当前节点接手老的主节点负责的槽位；&lt;/span&gt;
&lt;span&gt;252&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; REDIS_CLUSTER_SLOTS; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clusterNodeGetSlotBit(oldmaster,j)) {
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将槽设置为未分配的               &lt;/span&gt;
&lt;span&gt;255&lt;/span&gt; &lt;span&gt;                 clusterDelSlot(j);            
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将槽的负责人设置为当前节点&lt;/span&gt;
&lt;span&gt;257&lt;/span&gt; &lt;span&gt;                clusterAddSlot(myself,j);
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt; 
&lt;span&gt;261&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 3) Update my configEpoch to the epoch of the election. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;262&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新集群配置纪元  本节点此时的配置epoch就是集群中最大的configEpoch&lt;/span&gt;
&lt;span&gt;263&lt;/span&gt;         myself-&amp;gt;configEpoch = server.cluster-&amp;gt;&lt;span&gt;failover_auth_epoch;
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt; 
&lt;span&gt;265&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 4) Update state and save config. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;266&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新节点状态       &lt;/span&gt;
&lt;span&gt;267&lt;/span&gt; &lt;span&gt;        clusterUpdateState();     
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 并保存配置文件&lt;/span&gt;
&lt;span&gt;269&lt;/span&gt;         clusterSaveConfigOrDie(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt; 
&lt;span&gt;271&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果一个主master下面有2个savle，如果master挂了，通过选举slave1被选为新的主，则slave2通过这里来触发重新连接到新主，即slave1，见clusterUpdateSlotsConfigWith&lt;/span&gt;
&lt;span&gt;272&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 5) Pong all the other nodes so that they can update the state
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt; &lt;span&gt;         *    accordingly and detect that we switched to master role. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;274&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向所有节点发送 PONG 信息      
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让它们可以知道当前节点已经升级为主节点了      &lt;/span&gt;
&lt;span&gt;276&lt;/span&gt;         clusterBroadcastPong(CLUSTER_BROADCAST_ALL);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;真正触发其他本来属于同一个master的slave节点，连接到这个新选举出的master，是在clusterUpdateSlotsConfigWith   &lt;/span&gt;
&lt;span&gt;277&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 6) If there was a manual failover in progress, clear the state. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;      
&lt;span&gt;278&lt;/span&gt; 
&lt;span&gt;279&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有手动故障转移正在执行，那么清理和它有关的状态&lt;/span&gt;
&lt;span&gt;280&lt;/span&gt; &lt;span&gt;        resetManualFailover();
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明没有获得足够的票数，打印:Waiting for votes, but majority still not reached.&lt;/span&gt;
&lt;span&gt;283&lt;/span&gt;         clusterLogCantFailover(REDIS_CLUSTER_CANT_FAILOVER_WAITING_VOTES); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;例如6个主节点，现在只有1个主节点投票auth ack过来了，则会打印这个&lt;/span&gt;
&lt;span&gt;284&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2. 主节点接收所有从节点发来的投票请求，但会比较该请求附带的配置纪元是否为新的（大于主节点自己记录的currentepoch），只有带着大于等于的消息才是有效请求；主节点只会投票给第一个发来有效投票请求的从节点。&lt;/p&gt;
&lt;div readability=&quot;34.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;node为sender
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主节点对slave发送过来的CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST进行投票&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;集群中所有节点收到用于拉票的CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST包后，只有负责一定槽位的主节点能投票，其他没资格的节点直接忽略掉该包。
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求节点的主节点    &lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;     clusterNode *master = node-&amp;gt;&lt;span&gt;slaveof;   
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求节点的当前配置纪元   &lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt;     uint64_t requestCurrentEpoch = ntohu64(request-&amp;gt;&lt;span&gt;currentEpoch);    
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求节点想要获得投票的纪元  &lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;     uint64_t requestConfigEpoch = ntohu64(request-&amp;gt;&lt;span&gt;configEpoch);   
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求节点的槽布局&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *claimed_slots = request-&amp;gt;&lt;span&gt;myslots;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; force_ack = request-&amp;gt;mflags[&lt;span&gt;0&lt;/span&gt;] &amp;amp;&lt;span&gt; CLUSTERMSG_FLAG0_FORCEACK;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; IF we are not a master serving at least 1 slot, we don't have the
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;     * right to vote, as the cluster size in Redis Cluster is the number
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;     * of masters serving at least one slot, and quorum is the cluster
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;     * size + 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果节点为从节点，或者是一个没有处理任何槽的主节点， 
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么它没有投票权&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (nodeIsSlave(myself) || myself-&amp;gt;numslots == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从节点和不负责槽位处理的直接返回，不参与投票&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Request epoch must be &amp;gt;= our currentEpoch. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请求的配置纪元必须大于等于当前节点的配置纪元&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;      &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;     如果发送者的currentEpoch小于当前节点的currentEpoch，则拒绝为其投票。因为发送者的状态与当前集群状态不一致，
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;     可能是长时间下线的节点刚刚上线，这种情况下，直接返回即可；
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (requestCurrentEpoch &amp;lt; server.cluster-&amp;gt;&lt;span&gt;currentEpoch) {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;        redisLog(REDIS_WARNING,
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failover auth denied to %.40s: reqEpoch (%llu) &amp;lt; curEpoch(%llu)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             node-&amp;gt;&lt;span&gt;name,
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             (unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;) requestCurrentEpoch,
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             (unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;) server.cluster-&amp;gt;&lt;span&gt;currentEpoch);
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; I already voted for this epoch? Return ASAP. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已经投过票了&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    如果当前节点lastVoteEpoch，与当前节点的currentEpoch相等，说明本界选举中，当前节点已经投过票了，不
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    在重复投票，直接返回（因此，如果有两个从节点同时发起拉票，则当前节点先收到哪个节点的包，就只给那个
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    节点投票。注意，即使这两个从节点分属不同主节点，也只能有一个从节点获得选票）；
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (server.cluster-&amp;gt;lastVoteEpoch == server.cluster-&amp;gt;&lt;span&gt;currentEpoch) {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        redisLog(REDIS_WARNING,
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failover auth denied to %.40s: already voted for epoch %llu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                 node-&amp;gt;&lt;span&gt;name,
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                 (unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;) server.cluster-&amp;gt;&lt;span&gt;currentEpoch);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     
&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Node must be a slave and its master down.
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;     * The master can be non failing if the request is flagged
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;     * with CLUSTERMSG_FLAG0_FORCEACK (manual failover). &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;    如果发送节点是主节点；或者发送节点虽然是从节点，但是找不到其主节点；或者发送节点的主节点并未下线
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    并且这不是手动强制开始的故障转移流程，则根据不同的条件，记录日志后直接返回；
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (nodeIsMaster(node) || master == NULL ||
&lt;span&gt; 67&lt;/span&gt;         (!nodeFailed(master) &amp;amp;&amp;amp; !force_ack)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果从接收到cluster failover，然后发起auth req要求投票，则master受到后，就是该master在线也需要进行投票&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (nodeIsMaster(node)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;auth  request必须由slave发起&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;            redisLog(REDIS_WARNING,
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failover auth denied to %.40s: it is a master node&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                     node-&amp;gt;&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (master ==&lt;span&gt; NULL) {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;slave认为自己的master下线了，但是本节点不知道他的master是那个，也就不知道是为那个master的slave投票，
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为我们要记录是对那个master的从节点投票的，看if后面的流程&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;            redisLog(REDIS_WARNING,
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failover auth denied to %.40s: I don't know its master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                     node-&amp;gt;&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!nodeFailed(master)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从这里也可以看出，必须集群中有一个主节点判断出某个节点fail了，才会处理slave发送过来的auth req
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;slave认为自己的master下线了，于是发送过来auth request,本主节点收到该信息后，发现
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该slave对应的master是正常的，因此给出打印，不投票&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;            redisLog(REDIS_WARNING,
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failover auth denied to %.40s: its master is up&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                     node-&amp;gt;&lt;span&gt;name);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; We did not voted for a slave about this master for two
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;     * times the node timeout. This is not strictly needed for correctness
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;     * of the algorithm but makes the base case more linear. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;      &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;     针对同一个下线主节点，在2*server.cluster_node_timeout时间内，只会投一次票，这并非必须的限制条
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;     件（因为之前的lastVoteEpoch判断，已经可以避免两个从节点同时赢得本界选举了），但是这可以使得获
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;     胜从节点有时间将其成为新主节点的消息通知给其他从节点，从而避免另一个从节点发起新一轮选举又进
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;     行一次没必要的故障转移；
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果之前一段时间已经对请求节点进行过投票，那么不进行投票&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (mstime() - node-&amp;gt;slaveof-&amp;gt;voted_time &amp;lt; server.cluster_node_timeout * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;        redisLog(REDIS_WARNING,
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failover auth denied to %.40s: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;can't vote about this master before %lld milliseconds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                 node-&amp;gt;&lt;span&gt;name,
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                 (&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;) ((server.cluster_node_timeout*&lt;span&gt;2&lt;/span&gt;)-
&lt;span&gt;104&lt;/span&gt;                              (mstime() - node-&amp;gt;slaveof-&amp;gt;&lt;span&gt;voted_time)));
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; The slave requesting the vote must have a configEpoch for the claimed
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;     * slots that is &amp;gt;= the one of the masters currently serving the same
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;     * slots in the current configuration. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        判断发送节点，对其宣称要负责的槽位，是否比之前负责这些槽位的节点，具有相等或更新的配置纪元configEpoch：
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;    该槽位当前的负责节点的configEpoch，是否比发送节点的configEpoch要大，若是，说明发送节点的配置信息不是最新的，
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;    可能是一个长时间下线的节点又重新上线了，这种情况下，不能给他投票，因此直接返回；
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; REDIS_CLUSTER_SLOTS; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳过未指派节点&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (bitmapTestBit(claimed_slots, j) == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找是否有某个槽的配置纪元大于节点请求的纪元&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (server.cluster-&amp;gt;slots[j] == NULL || server.cluster-&amp;gt;slots[j]-&amp;gt;configEpoch &amp;lt;=&lt;span&gt; requestConfigEpoch) 
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里就是configEpoch真正发挥作用的地方&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有的话，说明节点请求的纪元已经过期，没有必要进行投票&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; If we reached this point we found a slot that in our current slots
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;         * is served by a master with a greater configEpoch than the one claimed
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;         * by the slave requesting our vote. Refuse to vote for this slave. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;        redisLog(REDIS_WARNING,
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failover auth denied to %.40s: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;slot %d epoch (%llu) &amp;gt; reqEpoch (%llu)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                 node-&amp;gt;&lt;span&gt;name, j,
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                 (unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;) server.cluster-&amp;gt;slots[j]-&amp;gt;&lt;span&gt;configEpoch,
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;                 (unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt;) requestConfigEpoch);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; We can vote for this slave. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为节点投票    &lt;/span&gt;
&lt;span&gt;143&lt;/span&gt; &lt;span&gt;    clusterSendFailoverAuth(node);
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新时间值&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt;     server.cluster-&amp;gt;lastVoteEpoch = server.cluster-&amp;gt;&lt;span&gt;currentEpoch;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;     node-&amp;gt;slaveof-&amp;gt;voted_time =&lt;span&gt; mstime();
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt;     redisLog(REDIS_WARNING, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Failover auth granted to %.40s for epoch %llu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;         node-&amp;gt;name, (unsigned &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;) server.cluster-&amp;gt;&lt;span&gt;currentEpoch);
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3. 如果有从节点收到了系统中超过半数主节点的投票，则变为新的主节点，并向所有节点广播自己当选的信息；&lt;/p&gt;
&lt;p&gt;　　4,.如果从节点在超时时间内没有收到多数主节点的投票，也没有收到其他从节点升级为新主节点的广播，就会再次发起投票，重复第3步。&lt;/p&gt;
&lt;p&gt;　　新的主节点向所有其他节点广播之后，其他的节点会更新自己的配置，将新的主节点和其负责的槽对应起来。再有和相关槽对应的命令发到集群就会被转发给这个新的主节点；至此故障迁移结束。我们可以考虑下，如果同时有半数以上的服务器掉线了，是否会导致集群彻底失效呢？&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 11 Nov 2018 15:10:00 +0000</pubDate>
<dc:creator>gogo一</dc:creator>
<og:description>Redis源码阅读（六）集群-故障迁移(下) Redis源码阅读（六）集群-故障迁移(下) 最近私人的事情比较多，没有抽出时间来整理博客。书接上文，上一篇里总结了Redis故障迁移的几个关键点，以及R</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gogoCome/p/9944152.html</dc:identifier>
</item>
<item>
<title>python面向对象学习（二）基本语法 - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-oop-base-grammar.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-oop-base-grammar.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;上一篇简单的介绍了面向对象的基础概念，本节，一起来看一下，&lt;code&gt;python&lt;/code&gt;中面向对象的相关语法。&lt;/p&gt;
&lt;h2 id=&quot;dir内置函数&quot;&gt;1. dir内置函数&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;Python&lt;/code&gt; 中 &lt;strong&gt;对象几乎是无所不在的&lt;/strong&gt;，我们之前学习的 &lt;strong&gt;变量&lt;/strong&gt;、&lt;strong&gt;数据&lt;/strong&gt;、&lt;strong&gt;函数&lt;/strong&gt; 都是对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 &lt;code&gt;Python&lt;/code&gt; 中可以使用以下两个方法验证：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;strong&gt;标识符&lt;/strong&gt; / &lt;strong&gt;数据&lt;/strong&gt; 后输入一个 &lt;code&gt;.&lt;/code&gt;，然后按下 &lt;code&gt;TAB&lt;/code&gt; 键，&lt;code&gt;iPython&lt;/code&gt; 会提示该对象能够调用的 &lt;strong&gt;方法列表&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201811/1156642-20181111212453208-609632987.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用内置函数 &lt;code&gt;dir&lt;/code&gt; 传入 &lt;strong&gt;标识符&lt;/strong&gt; / &lt;strong&gt;数据&lt;/strong&gt;，可以查看对象内的 &lt;strong&gt;所有属性及方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201811/1156642-20181111212559952-1557251589.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__方法名__&lt;/code&gt; 格式的方法是 &lt;code&gt;Python&lt;/code&gt; 提供的 &lt;strong&gt;内置方法 / 属性&lt;/strong&gt;，稍后会给大家介绍一些常用的 内置方法 / 属性&lt;/p&gt;
&lt;h2 id=&quot;定义简单的类只包含方法&quot;&gt;2. 定义简单的类（只包含方法）&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;面向对象&lt;/strong&gt; 是 &lt;strong&gt;更大&lt;/strong&gt; 的 &lt;strong&gt;封装&lt;/strong&gt;，在 &lt;strong&gt;一个类中 封装 多个方法&lt;/strong&gt;，这样 &lt;strong&gt;通过这个类创建出来的对象，就可以直接调用这些方法了&lt;/strong&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;定义只包含方法的类&quot;&gt;2.1 定义只包含方法的类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;Python&lt;/code&gt; 中要定义一个只包含方法的类，语法格式如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class ClassName:

    def method1(self, params):
        ...
        
    def method1(self, params):
        ...&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt; 的定义格式和之前学习过的&lt;strong&gt;函数&lt;/strong&gt; 几乎一样&lt;/li&gt;
&lt;li&gt;区别在于第一个参数必须是 &lt;code&gt;self&lt;/code&gt;，大家暂时先记住，稍后介绍 &lt;code&gt;self&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：&lt;strong&gt;类名&lt;/strong&gt; 的 命名规则 要符合 &lt;strong&gt;大驼峰命名法&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;创建对象&quot;&gt;2.2 创建对象&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当一个类定义完成之后，要使用这个类来创建对象，语法格式如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;var_name = ClassName()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编写第一个面向对象程序&quot;&gt;2.3 编写第一个面向对象程序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;编写一个&lt;code&gt;鱼&lt;/code&gt;类&lt;/li&gt;
&lt;li&gt;鱼类中有两个方法：&lt;code&gt;游动&lt;/code&gt;和&lt;code&gt;冒泡&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不需要属性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;编写程序如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Fish:
    &quot;&quot;&quot;这是一个鱼类&quot;&quot;&quot;

    def swim(self):
        print(&quot;鱼在游&quot;)

    def bubble(self):
        print(&quot;鱼冒泡了&quot;)


jack = Fish()

jack.swim()
jack.bubble()
print(&quot;%x&quot; % id(jack))


love_fish = Fish()

love_fish.swim()
love_fish.bubble()
print(&quot;%x&quot; % id(love_fish))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;方法中的self参数&quot;&gt;3. 方法中的self参数&lt;/h2&gt;
&lt;h3 id=&quot;案例改造-给对象添加属性&quot;&gt;3.1 案例改造 —— 给对象添加属性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;Python&lt;/code&gt; 中，要 &lt;strong&gt;给对象设置属性&lt;/strong&gt;，非常的容易，&lt;strong&gt;但是不推荐使用&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;因为：对象属性的封装应该封装在类的内部&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;只需要在 &lt;strong&gt;类的外部的代码&lt;/strong&gt; 中直接通过 &lt;code&gt;.&lt;/code&gt; 设置一个属性即可&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;jack.name = &quot;jack&quot;
...
love_fish.name = &quot;love_fish&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用-self-在方法内部输出每一只猫的名字&quot;&gt;3.2 使用 &lt;code&gt;self&lt;/code&gt; 在方法内部输出每一只猫的名字&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;由 &lt;strong&gt;哪一个对象&lt;/strong&gt; 调用的方法，方法内的 &lt;code&gt;self&lt;/code&gt; 就是 &lt;strong&gt;哪一个对象的引用&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在类封装的方法内部，&lt;code&gt;self&lt;/code&gt; 就表示 &lt;strong&gt;当前调用方法的对象自己&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用方法时&lt;/strong&gt;，程序员不需要传递 &lt;code&gt;self&lt;/code&gt; 参数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在方法内部&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;可以通过 &lt;code&gt;self.&lt;/code&gt; &lt;strong&gt;访问对象的属性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;也可以通过 &lt;code&gt;self.&lt;/code&gt; &lt;strong&gt;调用其他的对象方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;改造的代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Fish:
    &quot;&quot;&quot;这是一个鱼类&quot;&quot;&quot;

    def swim(self):
        print(&quot;%s 鱼在游&quot; % self.name)

    def bubble(self):
        print(&quot;%s 鱼冒泡了&quot; % self.name)


jack = Fish()

# 可以使用 .属性名 的方法来给对象的属性赋值
jack.name = &quot;jack&quot;

jack.swim()
jack.bubble()
print(jack)


love_fish = Fish()

love_fish.name = &quot;love_fish&quot;

love_fish.swim()
love_fish.bubble()
print(love_fish)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;strong&gt;类的外部&lt;/strong&gt;，通过 &lt;code&gt;变量名.&lt;/code&gt; 访问对象的 &lt;strong&gt;属性和方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;strong&gt;类封装的方法中&lt;/strong&gt;，通过 &lt;code&gt;self.&lt;/code&gt; 访问对象的 &lt;strong&gt;属性和方法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;初始化方法&quot;&gt;4. 初始化方法&lt;/h2&gt;
&lt;h3 id=&quot;之前代码存在的问题-在类的外部给对象增加属性&quot;&gt;4.1 之前代码存在的问题 —— 在类的外部给对象增加属性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;将案例代码进行调整，&lt;strong&gt;先调用方法 再设置属性&lt;/strong&gt;，观察一下执行效果&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;jack = Fish()

jack.swim()
jack.bubble()
jack.name = &quot;jack&quot;
print(jack)


love_fish = Fish()

love_fish.swim()
love_fish.bubble()
love_fish.name = &quot;love_fish&quot;
print(love_fish)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;程序执行报错如下：AttributeError: 'Fish' object has no attribute 'name'&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;__init__&lt;/code&gt; 方法是 &lt;strong&gt;专门&lt;/strong&gt; 用来定义一个类 &lt;strong&gt;具有哪些属性的方法&lt;/strong&gt;！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 &lt;code&gt;Fish&lt;/code&gt; 中增加 &lt;code&gt;__init__&lt;/code&gt; 方法，验证该方法在创建对象时会被自动调用&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Fish:

    def __init__(self):
        print(&quot;执行初始化&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在初始化方法内部定义属性&quot;&gt;4.3 在初始化方法内部定义属性&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;__init__&lt;/code&gt; 方法内部使用 &lt;code&gt;self.属性名 = 属性的初始值&lt;/code&gt; 就可以 &lt;strong&gt;定义属性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;定义属性之后，再使用 &lt;code&gt;Finsh&lt;/code&gt; 类创建的对象，都会拥有该属性&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Fish:

    def __init__(self):
        print(&quot;执行初始化&quot;)

        self.name = &quot;jack&quot;

    def bubble(self):
        print(&quot;%s 鱼冒泡了&quot; % self.name)


jack = Fish()

jack.bubble()
print(jack.name)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;改造初始化方法-初始化的同时设置初始值&quot;&gt;4.4 改造初始化方法 —— 初始化的同时设置初始值&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在开发中，如果希望在 &lt;strong&gt;创建对象的同时，就设置对象的属性&lt;/strong&gt;，可以对 &lt;code&gt;__init__&lt;/code&gt; 方法进行 &lt;strong&gt;改造&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;把希望设置的属性值，定义成 &lt;code&gt;__init__&lt;/code&gt; 方法的参数&lt;/li&gt;
&lt;li&gt;在方法内部使用 &lt;code&gt;self.属性 = 形参&lt;/code&gt; 接收外部传递的参数&lt;/li&gt;
&lt;li&gt;在创建对象时，使用 &lt;code&gt;类名(属性1, 属性2...)&lt;/code&gt; 调用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Fish:

    def __init__(self, name):
        print(&quot;执行初始化&quot;)

        self.name = name

    def bubble(self):
        print(&quot;%s 鱼冒泡了&quot; % self.name)


jack = Fish(&quot;jack&quot;)

jack.bubble()
print(jack.name)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;内置的方法和属性&quot;&gt;5. 内置的方法和属性&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;01&lt;/td&gt;
&lt;td&gt;&lt;code&gt;__del__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;对象被从内存中销毁&lt;/strong&gt;前，会被 &lt;strong&gt;自动&lt;/strong&gt; 调用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;02&lt;/td&gt;
&lt;td&gt;&lt;code&gt;__str__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;返回&lt;strong&gt;对象的描述信息&lt;/strong&gt;，&lt;code&gt;print&lt;/code&gt; 函数输出使用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;del__-方法&quot;&gt;5.1 __del__ 方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;Python&lt;/code&gt; 中
&lt;ul&gt;&lt;li&gt;当使用 &lt;code&gt;类名()&lt;/code&gt; 创建对象时，为对象 &lt;strong&gt;分配完空间&lt;/strong&gt;后，&lt;strong&gt;自动&lt;/strong&gt; 调用 &lt;code&gt;__init__&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;当一个 &lt;strong&gt;对象被从内存中销毁&lt;/strong&gt; 前，会 &lt;strong&gt;自动&lt;/strong&gt; 调用 &lt;code&gt;__del__&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用场景&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;__init__&lt;/code&gt; 改造初始化方法，可以让创建对象更加灵活&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__del__&lt;/code&gt; 如果希望在对象被销毁前，再做一些事情，可以考虑一下 &lt;code&gt;__del__&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生命周期&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;一个对象从调用 &lt;code&gt;类名()&lt;/code&gt; 创建，生命周期开始&lt;/li&gt;
&lt;li&gt;一个对象的 &lt;code&gt;__del__&lt;/code&gt; 方法一旦被调用，生命周期结束&lt;/li&gt;
&lt;li&gt;在对象的生命周期内，可以访问对象属性，或者让对象调用方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Fish:

    def __init__(self, name):

        self.name = name

        print(&quot;%s 创建了&quot; % self.name)

    def __del__(self):

        print(&quot;%s 死了&quot; % self.name)


jack = Fish(&quot;jack&quot;)
print(jack.name)

# 使用del删除一个对象
del jack
print(&quot;*&quot; * 50)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;str__-方法&quot;&gt;5.2 __str__ 方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;Python&lt;/code&gt; 中，使用 &lt;code&gt;print&lt;/code&gt; 输出 &lt;strong&gt;对象变量&lt;/strong&gt;，默认情况下，会输出这个变量 &lt;strong&gt;引用的对象&lt;/strong&gt; 是 &lt;strong&gt;由哪一个类创建的对象&lt;/strong&gt;，以及 &lt;strong&gt;在内存中的地址&lt;/strong&gt;（&lt;strong&gt;十六进制表示&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;如果在开发中，希望使用 &lt;code&gt;print&lt;/code&gt; 输出 &lt;strong&gt;对象变量&lt;/strong&gt; 时，能够打印 &lt;strong&gt;自定义的内容&lt;/strong&gt;，就可以利用 &lt;code&gt;__str__&lt;/code&gt; 这个内置方法了&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：&lt;code&gt;__str__&lt;/code&gt; 方法必须返回一个字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Fish:

    def __init__(self, name):

        self.name = name

        print(&quot;%s 创建了&quot; % self.name)

    def __del__(self):

        print(&quot;%s 死了&quot; % self.name)

    def __str__(self):

        return &quot;我是小鱼鱼 %s&quot; % self.name


jack = Fish(&quot;jack&quot;)
print(jack)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 11 Nov 2018 15:09:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] 上一篇简单的介绍了面向对象的基础概念，本节，一起来看一下， 中面向对象的相关语法。 1. dir内置函数 在 中 对象几乎是无所不在的 ，我们之前学习的 变量 、 数据 、 函数 都是对象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-oop-base-grammar.html</dc:identifier>
</item>
<item>
<title>Shell编程-04-Shell中变量数值计算 - Surpassme</title>
<link>http://www.cnblogs.com/surpassme/p/9944091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surpassme/p/9944091.html</guid>
<description>&lt;h3 id=&quot;算术运算符&quot;&gt;算术运算符&lt;/h3&gt;
&lt;p&gt;    在任何一门形式的语言中均会存在算术运算的情况，Shell常见的运算符如下所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;+ - * / %&lt;/td&gt;
&lt;td&gt;加 减 乘 除 求余&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;**&lt;/td&gt;
&lt;td&gt;幂运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;++ --&lt;/td&gt;
&lt;td&gt;自增 自减&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;amp;&amp;amp; || !&lt;/td&gt;
&lt;td&gt;与（and） 或（or） 非(取反)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&amp;lt; &amp;lt;= &amp;gt; &amp;gt;= == !=&lt;/td&gt;
&lt;td&gt;小于 小于等于 大于 大于等于 等于 不等于&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&amp;lt;&amp;lt; &amp;gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;左移位 右移位&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;~ | &amp;amp; ^&lt;/td&gt;
&lt;td&gt;按位取反 按位异或 按位与 按位或&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;= += -= *= /= %=&lt;/td&gt;
&lt;td&gt;如a+=1与a=a+1相同&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;算术运算命令&quot;&gt;算术运算命令&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;(())&lt;/td&gt;
&lt;td&gt;整数运算，效率很高&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;let&lt;/td&gt;
&lt;td&gt;整数运算，类似于(())&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;expr&lt;/td&gt;
&lt;td&gt;整数运算，另外还有很多额外功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;bc&lt;/td&gt;
&lt;td&gt;Linux中的计算器，适合整数及小数运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;$[]&lt;/td&gt;
&lt;td&gt;整数运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;awk&lt;/td&gt;
&lt;td&gt;既可用于整数运算，也可用于小数运算&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;declare&lt;/td&gt;
&lt;td&gt;定义变量值和属性，-i 参数可以用于定义整型变量并进行运算&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;数值运算用法&quot;&gt;数值运算用法&lt;/h3&gt;
&lt;h4 id=&quot;用法&quot;&gt;(())用法&lt;/h4&gt;
&lt;p&gt;    双小括号常用于数值运算和数值比较，因其效率很高，用法灵活，因此是常用的运算之一。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;((i=i+1))&lt;/td&gt;
&lt;td&gt;运算后并进行赋值，即先进行i+1计算并将该值赋值给i&lt;/td&gt;
&lt;td&gt;只能使用echo &lt;span class=&quot;math inline&quot;&gt;\(((i=i+1))进行输出 | | i=\)&lt;/span&gt;((i+1))&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;((2&amp;gt;1&amp;amp;&amp;amp;8&amp;gt;3))&lt;/td&gt;
&lt;td&gt;进行比较后再进行逻辑运算&lt;/td&gt;
&lt;td&gt;常用于条件判断&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;echo $((4+2))&lt;/td&gt;
&lt;td&gt;直接进行计算并输出结果&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;用法示例&quot;&gt;(())用法示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# echo $((90-12));echo $((80+12)) # 基本运算
78
92
[root@localhost ~]# ((a=100))
[root@localhost ~]# ((a*=2))
[root@localhost ~]# echo $a  # 输出运算结果
200
[root@localhost ~]# ((a=100+2**10-200%100)) # 复杂运算
[root@localhost ~]# echo $a
1124
[root@localhost ~]# a=$((50**2*2+2500)) # 运算并进行赋值
[root@localhost ~]# echo $a
7500
[root@localhost ~]# a=100
[root@localhost ~]# echo $((a++));echo $((++a)) # 自增运算
100
102
[root@localhost ~]# echo $((a**2))
10404
[root@localhost ~]# echo $((2==2)) # 比较运算
1                                  # 1：代表结果为真
[root@localhost ~]# echo $((2&amp;gt;2))
0                                  # 0：代表结果为假&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;++/--:如果++/--在&lt;strong&gt;变量前面&lt;/strong&gt;，则代表先进行运算再输出结果，如果++/--在&lt;strong&gt;变量后面&lt;/strong&gt;，则先输出结果再进行运算&lt;br/&gt;(()):在执行命令时不需要添加$，直接使用((4+3))即可，如果输出进行变量赋值，则需要添加$，如使用a=$((4+3))&lt;br/&gt;(())中所有字符中有无空格均不受影响&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;let用法&quot;&gt;let用法&lt;/h4&gt;
&lt;p&gt;    let的语法格式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let var=value&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;let用法示例&quot;&gt;let用法示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# a=8
[root@localhost ~]# b=9
[root@localhost ~]# c=$a+$b
[root@localhost ~]# echo $c
8+9                          # 进行字符串连接
[root@localhost ~]# let c=$a+$b
[root@localhost ~]# echo $c
17                           # 进行相加&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;let let c=$a+$b等同于((c=$a+$b))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;expr用法&quot;&gt;expr用法&lt;/h4&gt;
&lt;p&gt;    expr的语法格式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;expr 表达式&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;expr用法示例&quot;&gt;expr用法示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# expr 4+8; expr 2*5
4+8
2*5
[root@localhost ~]# expr 4 + 8; expr 2 \* 5 # 注意空格
12
10
[root@localhost ~]# a=100
[root@localhost ~]# b=200
[root@localhost ~]# c=`expr $a + $b`
[root@localhost ~]# echo $c
300
[root@localhost ~]# a=2
[root@localhost ~]# b=5
[root@localhost ~]# c=`expr $a \* $b`
[root@localhost ~]# echo $c
10&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用expr的注意事项如下所示：&lt;br/&gt;运算符与计算项之间左右间必须要有一个空格，否则会出现报错&lt;br/&gt;使用*需要进行转义符&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;bc用法&quot;&gt;bc用法&lt;/h4&gt;
&lt;p&gt;    bc是Linux中的计算器，可作为命令行计算工具使用&lt;/p&gt;
&lt;h4 id=&quot;bc用法示例&quot;&gt;bc用法示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# bc
bc 1.06.95
Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
1+2
3
1.0369+2.014789
3.051689

[root@localhost ~]# echo 100+200 | bc # 通过管道进行计算
300
[root@localhost ~]# a=250
[root@localhost ~]# b=360
[root@localhost ~]#  c=`echo $a + $b | bc`
[root@localhost ~]# echo $c
610&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;awk用法示例&quot;&gt;awk用法示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# echo &quot;12.36 12.36&quot; | awk '{print $1+$2}'
24.72
[root@localhost ~]# echo &quot;12.36 12.36&quot; | awk '{print $1*$2+$2}'
165.13
[root@localhost ~]# echo &quot;12.36 12.36&quot; | awk '{print $1*($2+$2)}'
305.539
[root@localhost ~]# echo &quot;10 100&quot; | awk '{print $1*($2+$2)}'
2000&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;declare用法&quot;&gt;declare用法&lt;/h4&gt;
&lt;p&gt;    declare的语法格式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;declare -i var=value&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;declare用法示例&quot;&gt;declare用法示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# declare -i a=120 b=130
[root@localhost ~]# a=a+b           #因为已经申明为整数，可以直接进行运算
[root@localhost ~]# echo $a
250&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;用法示例-1&quot;&gt;$[]用法示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# a=120
[root@localhost ~]# b=1290
[root@localhost ~]# a=$[a+b]
[root@localhost ~]# echo $a
1410
[root@localhost ~]# echo $[5/3]
1
[root@localhost ~]# echo $[5%3]
2&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;read用法示例&quot;&gt;read用法示例&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]# read -t 20 -p &quot;Input 3 number:&quot; a b c
Input 3 number:1 2 3
[root@localhost ~]# echo $a $b $c # 通过用户输入传递变量赋值
1 2 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;本文同步在微信订阅号上发布，如各位小伙伴们喜欢我的文章，也可以关注我的微信订阅号：woaitest，或扫描下面的二维码添加关注：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3349421-2a0edd703123621d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyQRCode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Nov 2018 14:55:00 +0000</pubDate>
<dc:creator>Surpassme</dc:creator>
<og:description>[TOC] 算术运算符     在任何一门形式的语言中均会存在算术运算的情况，Shell常见的运算符如下所示： | 运算符 | 含义 | | | | | + \ / % | 加 减</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surpassme/p/9944091.html</dc:identifier>
</item>
<item>
<title>工控随笔_04_西门子_解决Step 7软件因授权问题不能打开的方式和方法 - volcanol</title>
<link>http://www.cnblogs.com/volcanol/p/9944053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volcanol/p/9944053.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　西门子的软件是授权软件，只有经过授权认证的用户才能使用，如果没有通过授权认证则不能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正常的使用软件的相关功能。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一、西门子授权不成功问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111202354104-1719168399.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如上图所示报故障代码： 000001-0505。报警文本为：未找到有效的许可证密钥。应用程序将关闭。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二、西门子授权管理器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在西门子TIA的软件通过授权管理器ALM软件来管理软件的授权。在安装Step7时，默认是安装ALM&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的，ALM也可以单独安装。安装方式这里就不说了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以通过在桌面上双击图标打开ALM软件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111210131837-820246479.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如上图所示为西门子授权管理器软件ALM。 双击打开如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111210314783-2026567827.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;软件界面分成两个主要工作区域。　左边为计算机盘符树形浏览器，右边为详细窗口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111210532757-1540191513.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;                      图、计算机驱动器树形浏览器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111210617223-1713778882.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　图、详细信息窗口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面为有一栏工具栏，用来进行常规操作， 这里有一个地方需要介绍一下，就是查看模式下拉&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;列表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111210757625-156509162.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　图 工具栏， 查看模式下拉列表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如上图所示，黑色标志下面表示的就是查看模式下拉列表，可以用来选择不同的查看模式。这里我&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;们选择的查看授权密钥模式。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三、查看已经安装的授权密钥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们选择授权查看模式，然后在左侧的计算机驱动树形浏览器中选择 C:\ 盘，然后在右侧的详细窗口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就能看到已经安装的授权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111211214584-768107918.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　图  查看已经安装的授权密钥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如上图所示， 黑色标志区域，选择查看授权，同时选择C盘符，就可以查看安装在C盘的授权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　各列说明：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1、 status  通过不同的图形图标显示授权的状态， 过期，正常等信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               2、Family  说明授权属于哪个产品家族系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               3、Product 说明授权是哪个软件的授权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               4、version 表示授权适用于哪个版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               5、Number 表示安装了几个授权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               6、Licese Key 表示授权的文件名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               7、License Number 表示授权序列号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               8、standard License type 表示授权的类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;               9、License type 表示授权的期限&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;四、授权状态 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在授权管理器里面通过不同的图形表示授权的状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111212005668-1403232961.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如上图所示，黑色标志部分表示授权的状态。这里表示授权状态正常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111212932741-1609225733.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如上图所示，黑色箭头所指地方表示授权已经过期。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111213330321-1532708311.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　如上图所示黑色箭头所指的 绿色小箭头图标 表示 授权正常，且正在使用。 这里从任务栏可以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到我们打开了Simatic Manager。 所以使用的授权是Step7 Basis V5.5 。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;五、删除过期授权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在授权详细区域我们可以点击右键来删除过期的授权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111221510680-1164528193.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如上图所示，通过右击选中要删除的授权，然后弹出菜单里面选择Delete来删除授权，通常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样子不能删除授权，会弹出对话框，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111221703133-327283480.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;图、 删除授权失败&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们是否不能删除授权了呢？  当我们通过ALM不能删除授权的时候，我们可以通过删除授权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文件来删除授权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、 修改Windows Explorer设置显示受系统保护的文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先打开Windows资源管理器的文件夹选项对话框，通过下面的方式打开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111222021118-1525056580.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;通过上面的操作打开文件夹选项对话框，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111222205905-536178326.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　如上图选择查看选项卡，然后取消 “隐藏受保护的操作系统文件” ， 同时选择 “显示隐藏文件、文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;件夹和驱动器”， 点击确定按钮。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、打开授权文件存储目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在安装授权的驱动下面有一个隐藏文件夹，这个文件夹存储了西门子软件的授权文件。如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111222447745-1278484544.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　图 西门子授权文件目录&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如上图打开，黑色标志指示的目录 &quot;AX NF ZZ&quot;，就可以看到授权文件，如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111222618635-580364214.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　图、西门子授权文件&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如上图所示，SIFLxxx文件就是西门子软件授权文件。只要删除对应的文件就能删除过期的授权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们通过ALM查看我这里过期的授权：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111222840113-1661331944.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;这里我的过期授权文件时： SITTADSYS0801，找到文件如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111223002840-1195403876.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　选中授权文件，直接删除即可以删除过期的授权文件。然后我们返回ALM查看是否已经&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成功删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　删除前：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111212932741-1609225733.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;删除后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111223155811-1909152782.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　如上图所示，在Siamtic PCS7 的Maintenance ES 和 Simatic CFC Step7 Simotion之间的过期授权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;已经成功删除。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;六、重新安装授权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过西门子授权工具&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111223456241-1736739012.jpg&quot; alt=&quot;&quot;/&gt;来安装授权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　授权安装工具：&lt;a href=&quot;https://pan.baidu.com/s/1qiUEyzcy34FXoqpOw_BBng%20&quot; target=&quot;_blank&quot;&gt;Sim_EKB&lt;/a&gt;     &lt;/span&gt;提取码：8vet &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下载授权安装工具，然后打开软件，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/304449/201811/304449-20181111223833750-559388691.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　1、首先选择授权要安装到那个盘符，这里选择的是C盘， &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、然后点击并选中左侧属性浏览器中的： 需要的密钥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、然后点击选择，如上图全选指示的复选框，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、然后点击，安装长密钥按钮，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　经过上面的四步就将密钥安装成功。 这里说明一下，也可以安装短密钥，但是短密钥有一个不方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;便的地方就是密钥过期后不方便通过前面描述的方法删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　关于西门子ALM的内容就到这里。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;--------------------------------------------------------------分割线---------------------------------------------------------------&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、文章均为个人原创，欢迎转载，转载请保留出处：https://www.cnblogs.com/volcanol/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、获取工控PLC、变频器、HMI、计算机、Windows、Linux、嵌入式资料点击：&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/volcanol/archive/2012/06/05/2537339.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;获取资料&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、打赏或支持请转至页面上半部分左侧支付宝和微信二维码，或移步：&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/volcanol/archive/2012/06/05/2537339.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;打赏或支持&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、如果觉得对您有帮助，记得在页面右下角点推荐哟！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;--------------------------------------------------------------分割线---------------------------------------------------------------&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 11 Nov 2018 14:46:00 +0000</pubDate>
<dc:creator>volcanol</dc:creator>
<og:description>西门子的软件是授权软件，只有经过授权认证的用户才能使用，如果没有通过授权认证则不能 正常的使用软件的相关功能。 一、西门子授权不成功问题 如上图所示报故障代码： 000001-0505。报警文本为：未</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/volcanol/p/9944053.html</dc:identifier>
</item>
<item>
<title>把ABP框架部署到Docker中 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/9765907.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/9765907.html</guid>
<description>&lt;p&gt;　　本文旨在将Abp项目部署到Docker容器中，借助Gitee存储，Jenkins持续构建，利用Docker Compose生成镜像、启动镜像，在官网给定的Abp项目中，虽然用到了Dockerfile、Docker Compose，但是没有资料指明该如何使用这两个文件，借此我通过改造这两个文件来完成Abp部署任务。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、前期准备工作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、把从&lt;a href=&quot;https://aspnetboilerplate.com/&quot; target=&quot;_blank&quot;&gt;Abp官网&lt;/a&gt;下载下来的项目(我这取名为Surround方便讲解)修改成以下项目路径结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181111180722194-1898460626.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中的docker文件夹中加入Docker Compose项目，点击项目解决方案右键docker支持，将出现一个docker compose项目，对于整个docker compose项目的路径按照约定设计(对于VS 2017 15.8版本后添加不再有这个docker compose项目，可以考虑从&lt;a href=&quot;https://gitee.com/530521314/Abp_Surround.git&quot; target=&quot;_blank&quot;&gt;我的仓库&lt;/a&gt;中直接搬运到本机上)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、处理docker compose中的脚本配置，在docker-compose.yaml中指定两个服务相关信息，镜像名称、dockerfile的路径地址，此处在build中指定context为本目录的上级目录，按照上图中的位置就是在/xxx项目这一级，然后指定dockerfile的路径为src/Surround.Web.Host/Dockerfile指明具体的Dockerfle路径，同样对于surroundmvc同样如此处理。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
version: '3.4'&lt;span&gt;

services:
  surroundhost:
    image: ${DOCKER_REGISTRY}surroundhost
    build:
      context: ../
      dockerfile: src/Surround.Web.Host/Dockerfile
  surroundmvc:
    image: ${DOCKER_REGISTRY}surroundmvc
    build:
      context: ../
      dockerfile: src/Surround.Web.Mvc/Dockerfile&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　对于docker-compose.override.yaml文件，这是对前一个文件的补充，docker compose会将两个文件进行合并，在此文件中指定环境变量和对外端口此处docker compose设置的端口优先级高于dockerfile设置的端口，此处设置后dockerfile的端口则失效，此处设置内部端口为80端口，外部端口随机获取一个，如果想固定端口，则可以写 - &quot;32100:80&quot; 那么外部端口便固定为32100。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
version: '3.4'&lt;span&gt;

services:
  surroundhost:
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - &lt;/span&gt;&quot;80&quot;&lt;span&gt;
  surroundmvc:
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    ports:
      - &lt;/span&gt;&quot;80&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　3、选中Surround.Web.Mvc点击右键选中添加，加入新的dockerfile文件，不再使用已有的dockerfile文件，同时建议修改dockerfile中的指定端口为80端口，这样就促成了约定所有的新项目加入进来容器内部都使用80端口，如有需要另改即可，同样对Surround.Web.Host也执行这样的操作。　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181111204631006-1186327035.png&quot; alt=&quot;&quot; width=&quot;649&quot; height=&quot;447&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　4、需要注释Surround.Web.Host中的该部分配置：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181110225019627-692752528.png&quot; alt=&quot;&quot; width=&quot;742&quot; height=&quot;348&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　该部分配置用于Swagger文档的根目录位置，但是如果不注释掉Web.Host中的ServerRootAddress将会引起，由于外部端口与此处指定的端口不一致导致。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181110224719011-336967362.png&quot; alt=&quot;&quot; width=&quot;865&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5、在Jenkins中新建项目并编写脚本&lt;/p&gt;
&lt;p&gt;　　如需查看Jenkins的安装过程可以查看&lt;a href=&quot;https://www.cnblogs.com/CKExp/p/9536864.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CKExp/p/9536864.html&lt;/a&gt;，这里不再陈述，&lt;/p&gt;
&lt;p&gt;　　在另一篇&lt;a href=&quot;https://www.cnblogs.com/CKExp/p/9940479.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CKExp/p/9940479.html&lt;/a&gt;，讲解了Surround在Jenkins中新建项目的过程，可以直接使用。&lt;/p&gt;
&lt;p&gt;　　本次执行完毕，之后有新代码提交，将会自动构建，如果需要指定对外端口，可以在docker-compose.override.yaml文档中指定外部端口，如果不指定，则每次生成后都是使用的随机端口，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、部署完毕查看效果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　构建完毕可以通过脚本查看docker ps -a,查看容器已经生成并已经处于运行中了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181111220639521-150505803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过服务器地址:外部端口的形式可以直接访问查看。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181111220921878-1953896849.png&quot; alt=&quot;&quot; width=&quot;824&quot; height=&quot;385&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181111220933976-2026087178.png&quot; alt=&quot;&quot; width=&quot;823&quot; height=&quot;380&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　至此，abp部署在docker中算是完成了，主要是修改了原有abp项目中的docker compose文件和dockerfile文件。&lt;/p&gt;

&lt;p&gt;　　本文地址： &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: ABP框架入门系列(一)&quot; href=&quot;https://www.cnblogs.com/CKExp/p/9765907.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CKExp/p/9765907.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;　　欢迎关注微信订阅号，有新的文章将同步到订阅号中&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201811/1133736-20181111221756062-86565422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;2018-11-11,望技术有成后能回来看见自己的脚步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Sun, 11 Nov 2018 14:16:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>本文旨在将Abp项目部署到Docker容器中，借助Gitee存储，Jenkins持续构建，利用Docker Compose生成镜像、启动镜像，在官网给定的Abp项目中，虽然用到了Dockerfile、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/9765907.html</dc:identifier>
</item>
<item>
<title>数据结构与算法 -- 二叉树链式详解（（非）/递归遍历，叶子个数，深度计算） - CMusketeer</title>
<link>http://www.cnblogs.com/cmusketeer/p/9940183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmusketeer/p/9940183.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;PS：树型结构是一种重要的非线性数据结构，教科书上一般都是树与二叉树，由此可见，树和二叉树是有区别和联系的，网上有人说二叉树是树的一种特殊形式，但经过查资料，树和二叉树没有一个肯定的说法，但唯一可以肯定都是树型结构。但是按照定义来看二叉树并不是树的一种特殊形式（下面解释）。树型数据结构的作用可以表示数据元素之间一对多的关系，一个公司里的各个部门都可以用树形来表示。&lt;/p&gt;
&lt;h2 class=&quot;para&quot;&gt;二叉树不是树的一种特殊情形，主要差别：&lt;/h2&gt;
&lt;ol&gt;&lt;li class=&quot;para&quot;&gt;树中结点的最大度数没有限制，而二叉树结点的最大度数为2；&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;树的结点无左、右之分，而二叉树的结点有左、右之分。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;二叉树类型&lt;/h2&gt;
&lt;p class=&quot;para&quot;&gt;(1)完全二叉树 ——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有&lt;a href=&quot;https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9&quot; target=&quot;_blank&quot;&gt;叶子结点&lt;/a&gt;，并且叶子结点都是从左到右依次排布，这就是&lt;a href=&quot;https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&quot; target=&quot;_blank&quot;&gt;完全二叉树&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;(2)满二叉树 ——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。&lt;/p&gt;
&lt;p class=&quot;para&quot;&gt;(3)平衡二叉树——&lt;strong&gt;&lt;span&gt;平衡二叉树&lt;/span&gt;&lt;/strong&gt;又被称为AVL树（区别于&lt;span&gt;&lt;a href=&quot;https://baike.baidu.com/item/AVL/7543015&quot; target=&quot;_blank&quot; data-lemmaid=&quot;7543015&quot;&gt;&lt;span&gt;AVL&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵&lt;span&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/10421057&quot; target=&quot;_blank&quot; data-lemmaid=&quot;10421057&quot;&gt;&lt;span&gt;平衡二叉树&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h2 class=&quot;para&quot;&gt;二叉树的链式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258190/201811/1258190-20181110174841302-1847985206.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;
&lt;h3 class=&quot;para&quot;&gt;1：结构体&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; twoCha {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; twoCha *Lchild, *&lt;span&gt;Rchild;//左右孩子结点
} twoCha, &lt;/span&gt;*twoChaL;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2：创建二叉树&lt;/h3&gt;
&lt;p&gt;当我们在键盘上敲了一行的char类型数据，可以按照一定的结构储存在计算机上，就要写一个算法，二叉树分左右孩子，所以，如果没有左（右）孩子就输入一个空格或者#，代表空。如果有左（右）孩子就新建一个结点，来存放该结点的数据data。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; createTwo(twoChaL &amp;amp;&lt;span&gt;tL) {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;ch);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ch == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    {
        tL &lt;/span&gt;=&lt;span&gt; NULL;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        tL&lt;/span&gt;= (twoChaL)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(twoCha));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tL ==&lt;span&gt; NULL)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;错误tl=NULL\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            tL&lt;/span&gt;-&amp;gt;data =&lt;span&gt; ch;
            createTwo(tL&lt;/span&gt;-&amp;gt;&lt;span&gt;Lchild);
            createTwo(tL&lt;/span&gt;-&amp;gt;&lt;span&gt;Rchild);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3：递归遍历&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258190/201811/1258190-20181110175759563-1499910127.png&quot; alt=&quot;&quot; width=&quot;354&quot; height=&quot;261&quot;/&gt;画的不好，凑活着看吧。&lt;/p&gt;
&lt;p&gt;我们以这个二叉树为例子，来分析他的遍历形式，遍历分为三种&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先序遍历 -- 根左右 -- ABDCE&lt;/li&gt;
&lt;li&gt;中序遍历 -- 左根右 -- DBAEC&lt;/li&gt;
&lt;li&gt;后序遍历 -- 左右根 -- DBECA&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; diGuiBianLi(twoChaL &amp;amp;tL,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; xl)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tL ==&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(xl == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先序遍历&lt;/span&gt;
            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,tL-&amp;gt;&lt;span&gt;data);
            diGuiBianLi(tL&lt;/span&gt;-&amp;gt;&lt;span&gt;Lchild,xl);
            diGuiBianLi(tL&lt;/span&gt;-&amp;gt;&lt;span&gt;Rchild,xl);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(xl == &lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中序遍历&lt;/span&gt;
            diGuiBianLi(tL-&amp;gt;&lt;span&gt;Lchild,xl);
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,tL-&amp;gt;&lt;span&gt;data);
            diGuiBianLi(tL&lt;/span&gt;-&amp;gt;&lt;span&gt;Rchild,xl);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(xl == &lt;span&gt;3&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后序遍历&lt;/span&gt;
            diGuiBianLi(tL-&amp;gt;&lt;span&gt;Lchild,xl);
            diGuiBianLi(tL&lt;/span&gt;-&amp;gt;&lt;span&gt;Rchild,xl);
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,tL-&amp;gt;&lt;span&gt;data);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归的代码非常少，但是一开始接触 理解起来还是比较难的，当然，你一旦理解后，那就非常简单了。递归的思想就是把一个大问题分成多个类似的小问题解决。&lt;/p&gt;
&lt;h3&gt;4：叶子个数&lt;/h3&gt;
&lt;p&gt;方法：查找一个结点没有左右孩子，就是叶子结点。可以定义一个static int count变量，如果该结点没有左右结点那么就让count++；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; leafCount(twoChaL &amp;amp;&lt;span&gt;tL)
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tL !=&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tL-&amp;gt;Lchild == NULL &amp;amp;&amp;amp; tL-&amp;gt;Rchild ==&lt;span&gt; NULL)
        {
            count&lt;/span&gt;++&lt;span&gt;;
        }
        leafCount(tL&lt;/span&gt;-&amp;gt;&lt;span&gt;Lchild);
        leafCount(tL&lt;/span&gt;-&amp;gt;&lt;span&gt;Rchild);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5：深度&lt;/h3&gt;
&lt;p&gt;方法：看结点的左孩子和右孩子哪一个更长，当深入到最低结点时，左右孩子比较，谁大谁加一（相等左孩子加一）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; treeDeep(twoChaL &amp;amp;&lt;span&gt;tL)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; deep = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tL !=&lt;span&gt; NULL)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; leftdeep = treeDeep(tL-&amp;gt;&lt;span&gt;Lchild);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rightdeep = treeDeep(tL-&amp;gt;&lt;span&gt;Rchild);&lt;/span&gt;&lt;span&gt;
        deep &lt;/span&gt;= leftdeep &amp;gt;= rightdeep?leftdeep+&lt;span&gt;1&lt;/span&gt;:rightdeep+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deep;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 6：非递归遍历&lt;/h3&gt;
&lt;p&gt;这里以中序为例，利用栈的知识点（顺序栈），首先把根节点进栈，然后依次左孩子进栈，直到左孩子为NULL时结束，但是NULL也是入栈的，然后再把NULL出栈，下一步就是把栈顶元素取出并打印，再把该栈顶元素的右孩子进栈，不管右孩子是不是NULL都要入栈，入栈之前把栈顶元素弹栈。&lt;/p&gt;
&lt;p&gt;定义栈的data域，要用结点的结构体&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; top = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;栈&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; push(twoChaL *&lt;span&gt;a,twoChaL elem){
    a[&lt;/span&gt;++top]=&lt;span&gt;elem;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;弹栈函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; pop(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (top==-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
    }
    top&lt;/span&gt;--&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到栈顶元素&lt;/span&gt;
twoChaL getTop(twoChaL *&lt;span&gt;a){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a[top];
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; zhongXu2(twoChaL Tree){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺序栈&lt;/span&gt;
    twoChaL a[&lt;span&gt;100&lt;/span&gt;&lt;span&gt;];
    twoChaL p;
    push(a, Tree);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根结点进栈&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (top!=-&lt;span&gt;1&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;top!=-1说明栈内不为空&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; ((p=getTop(a)) &amp;amp;&amp;amp;p){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取栈顶元素，且不能为NULL&lt;/span&gt;
            push(a, p-&amp;gt;Lchild);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将该结点的左孩子进栈，如果没有左孩子，NULL进栈&lt;/span&gt;
&lt;span&gt;        }
        pop();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳出循环，栈顶元素肯定为NULL，将NULL弹栈&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        //测试数据，主要观察栈中NULL出栈后，还有什么在栈中（栈顶）,
          if(a[top]){
            printf(&quot; 跳出循环 %c\n&quot;,a[top]-&amp;gt;data);
        }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (top!=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
            p&lt;/span&gt;=getTop(a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取栈顶元素&lt;/span&gt;
            pop();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;栈顶元素弹栈&lt;/span&gt;
            printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p-&amp;gt;&lt;span&gt;data);
            push(a, p&lt;/span&gt;-&amp;gt;Rchild);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将p指向的结点的右孩子进栈&lt;/span&gt;
&lt;span&gt;        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;结果图：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1258190/201811/1258190-20181110183635461-832458017.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 11 Nov 2018 14:15:00 +0000</pubDate>
<dc:creator>CMusketeer</dc:creator>
<og:description>前言 PS：树型结构是一种重要的非线性数据结构，教科书上一般都是树与二叉树，由此可见，树和二叉树是有区别和联系的，网上有人说二叉树是树的一种特殊形式，但经过查资料，树和二叉树没有一个肯定的说法，但唯一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmusketeer/p/9940183.html</dc:identifier>
</item>
<item>
<title>innodb是如何巧妙实现事务隔离级别 - 木瓜芒果</title>
<link>http://www.cnblogs.com/volcano-liu/p/9893317.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/volcano-liu/p/9893317.html</guid>
<description>&lt;p&gt;　　之前的文章&lt;a href=&quot;https://www.cnblogs.com/volcano-liu/p/9890832.html&quot; target=&quot;_blank&quot;&gt;mysql锁机制详解&lt;/a&gt;中我们详细讲解了innodb的锁机制，锁机制是用来保证在并发情况下数据的准确性，而要保证数据准确通常需要事务的支持，而mysql存储引擎innodb是通过锁机制来巧妙地实现事务的隔离特性中的4种隔离级别。&lt;/p&gt;
&lt;p&gt;　　事务ACID特性，其中I代表隔离性(Isolation)。隔离性是指，多个用户的并发事务访问同一个数据库时，一个用户的事务不应该被其他用户的事务干扰，多个并发事务之间要相互隔离。&lt;/p&gt;
&lt;h2&gt;1. 事务之间如何互相干扰&lt;/h2&gt;
&lt;p&gt;　　一个事务是如何干扰其他事务呢？举个例子，有如下表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; lock_example(id &lt;span&gt;smallint&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;),name &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;),&lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; id)engine&lt;span&gt;=&lt;/span&gt;innodb;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　表中有如下数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, zhangsan
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, lisi
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, wangwu
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;demo1:&lt;/h3&gt;
&lt;p&gt;　　事务A，先执行，处于未提交的状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zhaoliu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　事务B，后执行，也未提交：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; t;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果事务B能够读取到(4, zhaoliu)这条记录，说明事务A就对事务B产生了影响，这种影响叫做“&lt;span&gt;读脏&lt;/span&gt;”，即读到了未提交事务操作的记录。&lt;/p&gt;
&lt;h3&gt;demo2:&lt;/h3&gt;
&lt;p&gt;　　事务A，先执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; t &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;;&lt;p&gt;结果集为&lt;/p&gt;&lt;p&gt;1,zhangsan
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　事务B，后执行，并且提交：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;update&lt;/span&gt; t &lt;span&gt;set&lt;/span&gt; name&lt;span&gt;=&lt;/span&gt;xxx &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　事务A，再次执行相同的查询：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; t &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

结果集为：

&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, xxx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这次是已提交事务B对事务A产生的影响，这种影响叫做“&lt;span&gt;不可重复读&lt;/span&gt;”，即一个事务内相同的查询，却得到了不同的结果。&lt;/p&gt;
&lt;h3&gt;demo3:&lt;/h3&gt;
&lt;p&gt;　　事务A，先执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; t &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;;
&lt;/pre&gt;
&lt;p&gt;　结果集为：&lt;/p&gt;
&lt;p&gt;　NULL&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　事务B，后执行，并且提交：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;, zhaoliu);
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　事务A，首次查询了id&amp;gt;3的结果为NULL，于是想插入一条为4的记录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; t &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;, xxoo);

结果集为：

Error : duplicate &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　你可能会想。。。你TM在逗我？查了id&amp;gt;3为空集，insert id=4时又告诉我PK冲突？→_→&lt;/p&gt;
&lt;p&gt;　　这次是已提交事务B对事务A产生的影响，这种影响叫做“&lt;span&gt;幻读&lt;/span&gt;”。&lt;/p&gt;
&lt;p&gt;　　如上，并发的事务可能导致其他事务出现&lt;span&gt;读脏&lt;/span&gt;、&lt;span&gt;不可重复读&lt;/span&gt;、&lt;span&gt;幻读&lt;/span&gt;。为了避免如上情况出现，innodb又做了哪些努力呢？&lt;/p&gt;
&lt;h2&gt;2. InnoDB实现了哪几种事务的隔离级别?&lt;/h2&gt;
&lt;p&gt;　　InnoDB实现了四种不同事务的隔离级别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读未提交(Read Uncommitted)&lt;/li&gt;
&lt;li&gt;读提交(Read Committed, RC)&lt;/li&gt;
&lt;li&gt;可重复读(Repeated Read, RR)&lt;/li&gt;
&lt;li&gt;串行化(Serializable)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　不同事务的隔离级别，实际上是一致性与并发性的一个权衡与折衷。&lt;/p&gt;
&lt;h2&gt;3. 四种事务的隔离级别，innodb如何实现?&lt;/h2&gt;
&lt;p&gt;　　InnoDB使用不同的锁策略(Locking Strategy)来实现不同的隔离级别。&lt;/p&gt;
&lt;h3&gt;a. 读未提交(Read Uncommitted)&lt;/h3&gt;
&lt;p&gt;　　这种事务隔离级别下，select语句不加锁，也不是快照读。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SELECT statements are performed in a nonlocking fashion.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　此时，可能读取到不一致的数据，即“读脏”。这是并发最高，一致性最差的隔离级别。&lt;/p&gt;
&lt;h3&gt;b. 读提交(Read Committed, RC)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;普通select是快照读；&lt;/li&gt;
&lt;li&gt;加锁的select, update, delete等语句，除了在外键约束检查(foreign-key constraint checking)以及重复键检查(duplicate-key checking)时会封锁区间，其他时刻都只使用&lt;strong&gt;记录锁&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;间隙锁(gap lock)、临建锁(next-key lock)在该级别下失效；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  此时，其他事务的插入依然可以执行，就可能导致，读取到幻影记录。该级别是最常使用的。而且如果是不上锁的select，可能产生不可重复读。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;该级别下是通过快照读来防止读脏的。因为在该级别下的快照读总是能读到最新的行数据快照，当然，必须是已提交事务写入的，所以可能产生不可重复读。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;c. 可重复读(Repeated Read, RR)&lt;/h3&gt;
&lt;p&gt;　　这是InnoDB默认的隔离级别，在RR下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;普通的select使用快照读(snapshot read)，这是一种不加锁的一致性读(Consistent Nonlocking Read)，底层使用MVCC来实现；&lt;/li&gt;
&lt;li&gt;加锁的select(select ... in share mode / select ... for update), update, delete等语句，它们的锁，依赖于它们是否在唯一索引(unique index)上使用了唯一的查询条件(unique search condition，此时使用记录锁)，或者范围查询条件(range-type search condition，此时使用间隙锁或临键锁)；&lt;/li&gt;
&lt;li&gt;在唯一索引上使用唯一的查询条件，会使用记录锁(record lock)，而不会封锁记录之间的间隔，即不会使用间隙锁(gap lock)与临键锁(next-key lock)；&lt;/li&gt;
&lt;li&gt;范围查询条件或者是非唯一索引，会使用间隙锁与临键锁，锁住索引记录之间的范围，避免范围间插入记录，以避免产生幻影行记录，以及避免不可重复读；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;span&gt;在该级别下&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;通过快照读以及锁定区间来实现避免产生幻读和不可重复读；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;某个事务首次read记录的时间为T，未来不会读取到T时间之后已提交事务写入的记录，以保证连续相同的read读到相同的结果集，这可以防止不可重复读；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;RR下是通过间隙锁，临键锁来解决幻影读问题；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;d. 串行化(Serializable)&lt;/h3&gt;
&lt;p&gt;　　这种事务的隔离级别下，所有select语句都会被隐式的转化为select ... in share mode，也就是默认上共享读锁(S锁)。&lt;/p&gt;
&lt;p&gt;　　所以，如果事务A先执行如下sql之后，会尝试获取所查询行的IS锁(和别的IS、IX锁是兼容的)，这时别的事务也能获取这些行的IS锁甚至是S锁，但是如果接下来，事务A如果update或delete其中的某些行，这时就获取了X锁，别的事务即便是执行普通的select语句也会阻塞，因为它们尝试获取IS锁，但是IS锁和X锁是互斥的，这样就避免了读脏、不可重复读以及幻读，所有事务就只能串行了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; ... ;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一致性最好的，但并发性最差的隔离级别。高并发量的场景下，几乎不会使用上述a和d这两种隔离级别。&lt;/p&gt;
&lt;h2&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;  并发事务之间相互干扰，就可能导致事务出现读脏，不可重复读，幻读等问题。&lt;/p&gt;
&lt;p&gt;  InnoDB实现了SQL92标准中的四种隔离级别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读未提交：select不加锁，可能出现读脏；&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;读提交(RC)：普通select快照读，锁select /update /delete 会使用记录锁，可能出现不可重复读；&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;可重复读(RR)：普通select快照读，锁select /update /delete 根据查询条件等情况，会选择记录锁，或者间隙锁/临键锁，以防止读取到幻影记录；&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;串行化：select隐式转化为select ... in share mode，会被update与delete互斥；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  InnoDB默认的隔离级别是RR，用得最多的隔离级别是RC&lt;/p&gt;

</description>
<pubDate>Sun, 11 Nov 2018 14:06:00 +0000</pubDate>
<dc:creator>木瓜芒果</dc:creator>
<og:description>mysql是如何巧妙地实现事务的4种隔离级别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/volcano-liu/p/9893317.html</dc:identifier>
</item>
</channel>
</rss>