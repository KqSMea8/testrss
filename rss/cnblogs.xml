<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>设计模式之单例模式 - SimpleWu</title>
<link>http://www.cnblogs.com/SimpleWu/p/9859269.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/9859269.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;作者：SimpleWu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;为什么要使用单例模式&quot;&gt;为什么要使用单例模式？&lt;/h4&gt;
&lt;p&gt;​ 古代的皇帝有且只能有一个，如果有多个皇帝会怎么样，那么就会出问题。所以有些对象有且只能有一个的，多了就会出问题，一山难容二虎。这个时候就有了我们的单例模式。&lt;/p&gt;
&lt;h4 id=&quot;什么是单例模式&quot;&gt;什么是单例模式？&lt;/h4&gt;
&lt;p&gt;在系统中，有些对象比如：配置文件，工具类，线程池，日志对象等。我们只需要一个就够了，多了就不便于管理。&lt;/p&gt;
&lt;p&gt;有些对象，我们需要确保在一个程序中有且只能有一个，那么我们就需要单例模式。&lt;/p&gt;
&lt;p&gt;单例模式分为两种：&lt;strong&gt;饿汉式，懒汉式&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;懒汉式&quot;&gt;懒汉式&lt;/h4&gt;
&lt;p&gt;从线程安全性上讲，不加同步的懒汉式是线程不安全的，比如，有两个线程，一个是线程A，一个是线程B，它们同时调用getInstance方法，那就可能导致并发问题。&lt;/p&gt;
&lt;p&gt;懒汉式是典型的时间换空间，也就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 设计模式-单例模式-懒汉式
 * @作者:SimpleWu
 * 2018年10月26日 下午10:54:02
 */

public class Lazy {
    //私有化构造函数,不允许程序员手动再new对象
    private Lazy(){}
    
    private static Lazy lazy;
    
    public static Lazy getInstance(){
        //当外部调用这个方法的时候判断，如果这个变量为null则给他创建个对象
        //否则直接返回类中的lazy
        if(lazy == null){
            lazy = new Lazy();
        }
        return lazy;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;饿汉式&quot;&gt;饿汉式&lt;/h4&gt;
&lt;p&gt;在类被加载时，自动会创建单例实例对象。不管用户是否会去调用该成员。&lt;/p&gt;
&lt;p&gt;饿汉式是典型的空间换时间，当类装载的时候就会创建类实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断了，节省了运行时间。&lt;/p&gt;
&lt;p&gt;饿汉式是线程安全的，因为虚拟机保证只会装载一次，在装载类的时候是不会发生并发的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 设计模式-单例模式-饿汉式
 * @作者:SimpleWu
 * 2018年10月26日 下午11:13:19
 */
public class Hungry {
    private Hungry(){};
    
    //在类装置器中就已经创建好了
    private static Hungry hungry = new Hungry();
    
    public static Hungry getInstance(){
        return hungry;
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 26 Oct 2018 15:16:00 +0000</pubDate>
<dc:creator>SimpleWu</dc:creator>
<og:description>设计模式之单例模式 作者：SimpleWu 为什么要使用单例模式？ ​ 古代的皇帝有且只能有一个，如果有多个皇帝会怎么样，那么就会出问题。所以有些对象有且只能有一个的，多了就会出问题，一山难容二虎。这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/9859269.html</dc:identifier>
</item>
<item>
<title>你知道吗， CoreGraphics绘图系统和Bezier贝塞尔曲线坐标系的顺时针方向是相反的！ - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/9859244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/9859244.html</guid>
<description>&lt;p&gt;UIBezierPath是对Core Graphics框架的一种上层封装，目的是让绘图需求可以被更方便的使用。&lt;/p&gt;
&lt;p&gt;那你有没有发现被UIBezierPath封装后与之前有什么改变？&lt;/p&gt;
&lt;p&gt;答：有三个变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.屏蔽繁杂重复的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.功能阉割&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.坐标系顺时针方向反转&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;证明1:屏蔽繁杂重复的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相比Core Graphics框架，UIBezierPath帮我们做了一些繁琐的事件。比如有这样一个场景：需要画一个圆，但是它的每个1/4弧线的strokpath颜色是不同的。对于这样的需求。&lt;/p&gt;
&lt;p&gt;有个错误的做法是：&lt;/p&gt;
&lt;p&gt;1.拿到上下文&lt;/p&gt;
&lt;p&gt;2.设置第一个1/4户的strokpath颜色，用上下文绘制第一个1/4弧&lt;/p&gt;
&lt;p&gt;3.设置第一个2/4户的strokpath颜色，用上下文绘制第一个2/4弧&lt;/p&gt;
&lt;p&gt;4.设置第一个3/4户的strokpath颜色，用上下文绘制第一个3/4弧&lt;/p&gt;
&lt;p&gt;5.设置第一个4/4户的strokpath颜色，用上下文绘制第一个4/4弧&lt;/p&gt;
&lt;p&gt;最后的结果会发现，这四段弧的颜色是最后一个4/4弧的strokpath的颜色&lt;/p&gt;
&lt;p&gt;原因是：对于一个上下文来说，strokPathColor属性只有一个，虽然设置了4次，但总是后面的覆盖前面的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一种解决方法是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在第2步之前，先循环4次操作&lt;/p&gt;
&lt;div readability=&quot;17.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let content =&lt;span&gt; UIGraphicsGetCurrentContext()
content&lt;/span&gt;?&lt;span&gt;.setStrokeColor(UIColor.blue.cgColor)
content&lt;/span&gt;?.saveGState()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在每一步绘制前，恢复上下文栈中的存储到当前上下文&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
content?.restoreGState()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;另一种解决方法是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接创建4个UIBezierPath，用贝塞尔曲线绘制着4段弧。&lt;/p&gt;
&lt;p&gt;这样就很直观的看出，每个UIBezierPath的上下文都是独立的。内部帮我们自己做了上下文的存栈和出栈。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;证明2:功能阉割&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然有了UIBezierPath的封装我们用起来方便了，但是相应的代价是所提供的功能被阉割了。有些强大的功能UIBezierPath没有提供实现，比如：现在要画一个圆形的渐变球，就只能使用Core Graphics框架。&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;25.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用上下文绘制渐变色（圆形）&lt;/span&gt;
let context =&lt;span&gt; UIGraphicsGetCurrentContext()
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色空间&lt;/span&gt;
let colorSpace =&lt;span&gt; CGColorSpaceCreateDeviceRGB()
let startColor &lt;/span&gt;=&lt;span&gt; UIColor.black
let endColor &lt;/span&gt;=&lt;span&gt; UIColor.red
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色数组&lt;/span&gt;
let colors =&lt;span&gt; [startColor.cgColor,endColor.cgColor]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;颜色所处位置&lt;/span&gt;
let locations:[CGFloat] = [&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
let gradient &lt;/span&gt;= CGGradient(colorsSpace: colorSpace, colors: colors &lt;span&gt;as&lt;/span&gt;!&lt;span&gt; CFArray, locations: locations)
let center &lt;/span&gt;= CGPoint(x: rect.size.width*&lt;span&gt;0.5&lt;/span&gt;, y: rect.size.height*&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;)
let radius &lt;/span&gt;= rect.size.height*&lt;span&gt;0.3&lt;/span&gt;&lt;span&gt;
context&lt;/span&gt;?.drawRadialGradient(gradient!, startCenter: center, startRadius: radius*&lt;span&gt;0.2&lt;/span&gt;, endCenter: center, endRadius: radius, options: CGGradientDrawingOptions.drawsBeforeStartLocation)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;证明3:坐标系顺时针方向反转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你知道吗， CoreGraphics绘图系统和Bezier贝塞尔曲线坐标系的顺时针方向是相反的！&lt;/p&gt;

&lt;p&gt;我记得上学时老师讲的坐标系是这样的： &lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026225558664-533989020.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;X轴指向右侧，Y轴指向上面。对应的弧度如图上标的那样。顺时针也是钟表表针转动的方向。这就是最早接触的坐标系，熟悉的单纯模样。&lt;/p&gt;

&lt;p&gt;在工作时，当我们往屏幕上布局UI时，用到的坐标系是下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026225647819-342921351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于UI控件来讲的坐标系模式，X轴方向向右，Y轴方向向下。&lt;/p&gt;
&lt;p&gt;请注意弧度值也相应的转了方向，它是沿着X，Y指向的方向开始逐渐增加的。&lt;/p&gt;
&lt;p&gt;顺时针还是熟悉的钟表表针转动方向。&lt;/p&gt;

&lt;p&gt;关键代码如下：&lt;/p&gt;
&lt;div readability=&quot;26.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
        let content =&lt;span&gt; UIGraphicsGetCurrentContext()

        var endAngl &lt;/span&gt;= _progressValue*CGFloat(M_PI*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        var clockState &lt;/span&gt;= (_direction ==&lt;span&gt; .onTime)
       
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;圆&lt;/span&gt;
        var des: String = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        des &lt;/span&gt;= clockState ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UIGraphics上下文绘制、顺时针&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UIGraphics上下文绘制、逆时针”&lt;/span&gt;
&lt;span&gt;
        content&lt;/span&gt;?.move(to: CGPoint(x: width-arcRadius, y: height*&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;))
        let bez &lt;/span&gt;= UIBezierPath(arcCenter: arcCenter, radius: arcRadius, startAngle: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, endAngle: endAngl, clockwise: clockState)
            content&lt;/span&gt;?&lt;span&gt;.addPath(bez.cgPath)

        NSString(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;: des).draw(&lt;span&gt;in&lt;/span&gt;: CGRect(x: &lt;span&gt;2&lt;/span&gt;, y: &lt;span&gt;2&lt;/span&gt;, width: width*&lt;span&gt;0.4&lt;/span&gt;, height: height*&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;), withAttributes: atts)
        log &lt;/span&gt;= String(format: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;绘制弧度: %.4f Pi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, endAngl/&lt;span&gt;3.14&lt;/span&gt;&lt;span&gt;)
        
        content&lt;/span&gt;?.strokePath()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026225836211-1441056445.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UIBezierPath顺时针模式下，从0到2PI的效果&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026230001324-1006814804.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;UIBezierPath逆时针模式下，从0到2PI的效果&lt;/p&gt;

&lt;p&gt;然后突出的CoreGraphics表示不服，我就要与众不同。如下图：&lt;/p&gt;
&lt;div readability=&quot;28.5&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026230029591-338446287.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;说出来你可能不信，你会发现顺时针方向往上了。这明明是逆时针方向啊！WTF？&lt;/p&gt;
&lt;p&gt;来看下代码和实现效果吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:objc;gutter:true;&quot;&gt;
       let content = UIGraphicsGetCurrentContext()

        var endAngl = _progressValue*CGFloat(M_PI*2)
        var clockState = (_direction == .onTime)
       
        //圆
        var des: String = &quot;&quot;
        des = clockState ? &quot;UIGraphics上下文绘制、顺时针&quot; : &quot;UIGraphics上下文绘制、逆时针”

        content?.move(to: CGPoint(x: width-arcRadius, y: height*0.5))
        content?.addArc(center: arcCenter, radius: arcRadius, startAngle: 0, endAngle: endAngl, clockwise: clockState)

        NSString(string: des).draw(in: CGRect(x: 2, y: 2, width: width*0.4, height: height*0.5), withAttributes: atts)
        log = String(format: &quot;绘制弧度: %.4f Pi&quot;, endAngl/3.14)
        
        content?.strokePath()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;实际效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026230155111-1371409861.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CoreGraphics顺时针模式下，从0到2PI的效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201810/826860-20181026230234697-1384836494.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CoreGraphics逆时针模式下，从0到2PI的效果&lt;/p&gt;

&lt;p&gt;CoreGraphics和Bezier贝塞尔曲线都是平时开发中的利器，认真品味一下两者的区别，会让我们对它们有更深的认识。&lt;/p&gt;
&lt;p&gt;有讲的不对的地方欢迎指正。&lt;/p&gt;
&lt;p&gt;Demo地址：https://github.com/zhfei/CoordinateSystem&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 26 Oct 2018 15:11:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>UIBezierPath是对Core Graphics框架的一种上层封装，目的是让绘图需求可以被更方便的使用。 那你有没有发现被UIBezierPath封装后与之前有什么改变？ 答：有三个变化。 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/9859244.html</dc:identifier>
</item>
<item>
<title>Netty实现高性能IOT服务器(Groza)之精尽代码篇中 - 三升水</title>
<link>http://www.cnblogs.com/sanshengshui/p/9859030.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanshengshui/p/9859030.html</guid>
<description>&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded md-expand&quot; data-src=&quot;/home/james/IdeaProjects/netty-learning-example/pic/blueprint-company-concept-7366.jpg&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181026220623730-1639489753.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;运行环境:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;JDK 8+&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Maven 3.0+&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;技术栈:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;IDE:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;IDEA或者Eclipse&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Lombok插件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;近年来，物联网高歌猛进，美国有“工业互联网”，德国有“工业4.0”，我国也有“中国制造2025”，这背后都是云计算、大数据。据波士顿咨询报告，单单中国制造业，云计算、大数据、人工智能等新技术就能为其带来高达6万亿的额外附加值。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;国内外巨头纷纷驻足工业互联网，国外如亚马逊AWS、微软Azure，国内则是三大电信运营商、百度云、华为、金山云等，其中腾讯云、阿里云最甚，还拉来了传统制造大佬,国内巨头纷纷在物联网上布局。在2018云栖-深圳峰会上，阿里巴巴资深副总裁，阿里云总裁胡晓明宣布阿里巴巴将正式进军IoT。胡晓明表示，IoT是阿里巴巴集团继电商、金融、物流、云计算之后的一条新的主赛道。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;以上这些内容，作者作为一个开发人员，并不是一个投资人员和创业先锋。并不太关系这些具体细节。我所关心的是如何用技术去&lt;span&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;span&gt;或者&lt;span&gt;&lt;strong&gt;模拟&lt;/strong&gt;&lt;span&gt;一个支持百万链接的IOT服务器,并不严谨，仅做大家参考。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;关于为什么选用下图的中间件或者对MQTT不太了解的话,可以阅读我之前的2篇文章:&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-0.010204081632653&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/sanshengshui/p/9797352.html&quot;&gt;&lt;span&gt;IOT高性能服务器实现之路&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/sanshengshui/p/9826009.html&quot;&gt;&lt;span&gt;Netty实现高性能IOT服务器(Groza)之手撕MQTT协议篇上&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;技术轮廓图&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/IdeaProjects/netty-learning-example/pic/netty-iot.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181026220601301-1163557282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;运行测试&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-list-item&quot;&gt; &lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;md-end-block&quot;&gt;&lt;span&gt;git clone &lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://github.com/sanshengshui/netty-learning-example&quot;&gt;https://github.com/sanshengshui/netty-learning-example&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;cd netty-iot&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;运行 NettyIotApplication&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;打开 &lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;http://localhost:8080/groza/v1/123456/auth,&quot;&gt;http://localhost:8080/groza/v1/123456/auth,&lt;/a&gt;获取密码！&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/auth.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181026220458826-1969346935.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/auth.png&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;启动Eclipse Paho,并填写用户名和密码，即可连接。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;另起一个Eclipse Paho,订阅随意主题,例如test。另一个Eclipse Paho发布主题test。即可收到消息。&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;取消主题订阅，再次发布消息。就收不到消息。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181026220537362-1139204975.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E5%9B%BE%E7%89%87/%E7%9B%91%E6%8E%A7%E5%8F%B0.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;有了前面2篇文章的铺垫并学习了MQTT V3.1.1 协议,说了那么多，手痒痒的很。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;You build it, You run it！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;项目结构介绍&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 netty-&lt;span&gt;iot
        ├── auth &lt;/span&gt;--&lt;span&gt; 认证
          ├── service &lt;/span&gt;--&lt;span&gt; 用户名,密码认证实现类
          ├── util &lt;/span&gt;--&lt;span&gt; 认证工具类
        ├── common &lt;/span&gt;--&lt;span&gt; 公共类
          ├── auth &lt;/span&gt;--&lt;span&gt; 用户名,密码认证接口
          ├── message &lt;/span&gt;--&lt;span&gt; 协议存储实体及接口类
          ├── session &lt;/span&gt;--&lt;span&gt; session存储实体及接口类
          ├── subscribe &lt;/span&gt;--&lt;span&gt; 订阅存储实体及接口类
        ├── config &lt;/span&gt;--&lt;span&gt; Redis配置
        ├── protocol &lt;/span&gt;--&lt;span&gt; MQTT协议实现
        ├── server &lt;/span&gt;--&lt;span&gt; MQTT服务器
        ├── store &lt;/span&gt;--&lt;span&gt; Redis数据存储
          ├── cache 
          ├── message 
          ├── session
          ├── subscribe
        ├── web &lt;/span&gt;--&lt;span&gt; web服务
        ├── NettyIotApplication &lt;/span&gt;-- 服务启动类
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;体验 Redis 需要使用 Linux 或者 Mac 环境，如果是 Windows 可以考虑使用虚拟机。主要方式有四种：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;使用 Docker 安装。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通过 Github 源码编译。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;直接安装 apt-get install(Ubuntu)、yum install(RedHat) 或者 brew install(Mac)。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-0.8953488372093&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果读者懒于安装操作，也可以使用网页版的 &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://try.redis.io/&quot;&gt;&lt;span&gt;Web Redis&lt;/span&gt;&lt;/a&gt; &lt;span&gt;直接体验。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;具体操作如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;Docker 方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  # 拉取 redis 镜像
  &lt;/span&gt;&amp;gt;&lt;span&gt; docker pull redis
  # 运行 redis 容器
  &lt;/span&gt;&amp;gt; docker run --name myredis -d -p6379:6379&lt;span&gt; redis
  # 执行容器中的 redis&lt;/span&gt;-&lt;span&gt;cli，可以直接使用命令行操作 redis
  &lt;/span&gt;&amp;gt; docker exec -it myredis redis-cli...
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;Github 源码编译方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  # 下载源码
  &lt;/span&gt;&amp;gt; git clone --branch 2.8 --depth 1 git@github.com:antirez/&lt;span&gt;redis.git
  &lt;/span&gt;&amp;gt;&lt;span&gt; cd redis
  # 编译
  &lt;/span&gt;&amp;gt;&lt;span&gt; make
  &lt;/span&gt;&amp;gt;&lt;span&gt; cd src
  # 运行服务器，daemonize表示在后台运行
  &lt;/span&gt;&amp;gt; ./redis-server --&lt;span&gt;daemonize yes
  # 运行命令行
  &lt;/span&gt;&amp;gt; ./redis-cli...
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;直接安装方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  # mac
  &lt;/span&gt;&amp;gt;&lt;span&gt; brew install redis
  # ubuntu
  &lt;/span&gt;&amp;gt; apt-&lt;span&gt;get install redis
  # redhat
  &lt;/span&gt;&amp;gt;&lt;span&gt; yum install redis
  # 运行客户端
  &lt;/span&gt;&amp;gt; redis-cli
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;使用&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Spring Boot&lt;span&gt;&lt;code&gt;除了支持常见的ORM框架外，更是对常用的中间件提供了非常好封装，随着&lt;/code&gt;&lt;span&gt;Spring Boot2.x&lt;span&gt;&lt;code&gt;的到来，支持的组件越来越丰富，也越来越成熟，其中对&lt;/code&gt;&lt;span&gt;Redis&lt;span&gt;&lt;code&gt;的支持不仅仅是丰富了它的API，更是替换掉底层&lt;/code&gt;&lt;span&gt;Jedis&lt;span&gt;&lt;code&gt;的依赖，取而代之换成了&lt;/code&gt;&lt;span&gt;Lettuce(生菜),大家可以参考这篇&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/memmsc/article/details/80523376&quot;&gt;&lt;span&gt;文章&lt;/span&gt;&lt;/a&gt;&lt;span&gt;对工程进行配置。所以我使用Lettuce作为客户端来对我的MQTT协议传输的消息进行缓存。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;下列的是Redis所对应的操作方式&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForValue： 对应 String（字符串）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForZSet： 对应 ZSet（有序集合）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForHash： 对应 Hash（哈希）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForList： 对应 List（列表）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForSet： 对应 Set（集合）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;opsForGeo： 对应 GEO（地理位置）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我主要使用&lt;span&gt;&lt;strong&gt;opsForValue&lt;/strong&gt;&lt;span&gt;,&lt;span&gt;&lt;strong&gt;opsForHash&lt;/strong&gt;&lt;span&gt;和&lt;span&gt;&lt;strong&gt;opsForZSet&lt;/strong&gt;&lt;span&gt;，对于字符串。我推荐使用&lt;span&gt;&lt;strong&gt;StringRedisTemplate&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;以下对于opsForValue和opsForHash的基础操作，我在这里简短的讲解一下。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Redis的Hash数据机构&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Redis的散列可以让用户将多个键值对存储到一个Redis键里面。 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;public interface HashOperations&amp;lt;H,HK,HV&amp;gt; &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;HashOperations提供一系列方法操作hash：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
 java &amp;gt; template.opsForHash().put(&quot;books&quot;,&quot;java&quot;,&quot;think in java&quot;&lt;span&gt;);
  redis&lt;/span&gt;-cli &amp;gt; hset books java &quot;think in java&quot;&lt;span&gt;  # 命令行的字符串如果包含空格，要用引号括起来
  (integer) &lt;/span&gt;1
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForHash().put(&quot;books&quot;,&quot;golang&quot;,&quot;concurrency in go&quot;&lt;span&gt;);
  redis&lt;/span&gt;-cli &amp;gt; hset books golang &quot;concurrency in go&quot;&lt;span&gt;
  (integer) &lt;/span&gt;1
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForHash().put(&quot;books&quot;,&quot;python&quot;,&quot;python cookbook&quot;&lt;span&gt;);
  redis&lt;/span&gt;-cli &amp;gt; hset books python &quot;python cookbook&quot;&lt;span&gt;
  (integer) &lt;/span&gt;1
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForHash().entries(&quot;books&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; hgetall books  # entries()，key 和 value 间隔出现
  &lt;/span&gt;1) &quot;java&quot;
  2) &quot;think in java&quot;
  3) &quot;golang&quot;
  4) &quot;concurrency in go&quot;
  5) &quot;python&quot;
  6) &quot;python cookbook&quot;
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForHash().size(&quot;books&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; hlen books
  (integer) &lt;/span&gt;3
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForHash().get(&quot;redisHash&quot;,&quot;age&quot;&lt;span&gt;)
  redi&lt;/span&gt;-cli &amp;gt;&lt;span&gt; hget books java
  &lt;/span&gt;&quot;think in java&quot;
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt;&lt;span&gt; 
  Map&lt;/span&gt;&amp;lt;String,Object&amp;gt; testMap = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
        testMap.put(&lt;/span&gt;&quot;java&quot;,&quot;effective java&quot;&lt;span&gt;);
        testMap.put(&lt;/span&gt;&quot;python&quot;,&quot;learning python&quot;&lt;span&gt;);
        testMap.put(&lt;/span&gt;&quot;golang&quot;,&quot;modern golang programming&quot;&lt;span&gt;);
  template.opsForHash().putAll(&lt;/span&gt;&quot;books&quot;&lt;span&gt;,testMap);
  redis&lt;/span&gt;-cli &amp;gt; hmset books java &quot;effective java&quot; python &quot;learning python&quot; golang &quot;modern golang programming&quot;&lt;span&gt;  # 批量 set
  OK...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;Redis的Set数据结构&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
java &amp;gt; template.opsForSet().add(&quot;python&quot;,&quot;java&quot;,&quot;golang&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; sadd books python java golang
  (integer) &lt;/span&gt;3
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForSet().members(&quot;books&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; smembers books  # 注意顺序，和插入的并不一致，因为 set 是无序的
  &lt;/span&gt;1) &quot;java&quot;
  2) &quot;python&quot;
  3) &quot;golang&quot;
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForSet().isMember(&quot;books&quot;,&quot;java&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; sismember books java  # 查询某个 value 是否存在，相当于 contains(o)
  (integer) &lt;/span&gt;1
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForSet().size(&quot;books&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; scard books  # 获取长度相当于 count()
  (integer) &lt;/span&gt;3
  ------&lt;span&gt;
  java &lt;/span&gt;&amp;gt; template.opsForSet().pop(&quot;books&quot;&lt;span&gt;)
  redis&lt;/span&gt;-cli &amp;gt;&lt;span&gt; spop books  # 弹出一个
  &lt;/span&gt;&quot;java&quot;...
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
 
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;MQTT&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;MQTT是一种轻量级的发布/订阅消息传递协议，最初由IBM和Arcom（后来成为Eurotech的一部分）于1998年左右创建。现在，&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html&quot;&gt;&lt;span&gt;MQTT 3.1.1规范&lt;/span&gt;&lt;/a&gt;&lt;span&gt;已由&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://www.oasis-open.org/committees/mqtt/charter.php&quot;&gt;&lt;span&gt;OASIS联盟&lt;/span&gt;&lt;/a&gt;&lt;span&gt;标准化。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;客户端下载&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497594/201810/1497594-20181026221123345-1465421653.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/home/james/%E4%B8%8B%E8%BD%BD/paho_logo_400.png&quot;&gt;&lt;img alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;对于MQTT客户端，我选用&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;http://www.eclipse.org/paho/&quot;&gt;&lt;span&gt;Eclipse Paho&lt;/span&gt;&lt;/a&gt;&lt;span&gt;,Eclipse Paho项目提供针对物联网（IoT）的新的，现有的和新兴的应用程序的MQTT和MQTT-SN消息传递协议的开源客户端实现。具体&lt;span class=&quot; md-link&quot;&gt;&lt;a&gt;&lt;span&gt;下载地址&lt;/span&gt;&lt;/a&gt;&lt;span&gt;,大家根据自己的操作系统自行下载。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;MQTT控制报文&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  ├── Connect --&lt;span&gt; 连接服务端
  ├── DisConnect &lt;/span&gt;--&lt;span&gt; 断开连接
  ├── PingReq &lt;/span&gt;--&lt;span&gt; 心跳请求
  ├── PubAck &lt;/span&gt;--&lt;span&gt; 发布确认
  ├── PubComp &lt;/span&gt;--&lt;span&gt; 发布完成(QoS2,第散步)
  ├── Publish &lt;/span&gt;--&lt;span&gt; 发布消息
  ├── PubRec &lt;/span&gt;--&lt;span&gt; 发布收到(QoS2,第一步)
  ├── PubRel &lt;/span&gt;--&lt;span&gt; 发布释放(QoS2,第二步)
  ├── Subscribe &lt;/span&gt;--&lt;span&gt; 订阅主题
  ├── UnSubscribe &lt;/span&gt;-- 取消订阅
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
Connect
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;让我们对照着MQTT 3.1.1协议来实现客户端Connect协议。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;6&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当我们对消息解码时，如果协议名不正确服务端&lt;span&gt;&lt;strong&gt;可以&lt;/strong&gt;&lt;span&gt;断开客户端的连接，按照本规范，服务端&lt;span&gt;&lt;strong&gt;不能&lt;/strong&gt;&lt;span&gt;继续处理CONNECT报。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;9.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务端使用客户端标识符 (ClientId) 识别客户端。连接服务端的每个客户端都有唯一的客户端标识符（ClientId）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消息解码器出现异常&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (msg.decoderResult().isFailure()) {
              Throwable cause &lt;/span&gt;=&lt;span&gt; msg.decoderResult().cause();
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cause &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MqttUnacceptableProtocolVersionException) {
                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不支持的协议版本&lt;/span&gt;
                  MqttConnAckMessage connAckMessage =&lt;span&gt; (MqttConnAckMessage) MqttMessageFactory.newMessage(
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.CONNACK, &lt;span&gt;false&lt;/span&gt;, MqttQoS.AT_MOST_ONCE, &lt;span&gt;false&lt;/span&gt;, 0&lt;span&gt;),
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttConnAckVariableHeader(MqttConnectReturnCode.CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION, &lt;span&gt;false&lt;/span&gt;), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                  channel.writeAndFlush(connAckMessage);
                  channel.close();
                  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
              } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cause &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; MqttIdentifierRejectedException) {
                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不合格的clientId&lt;/span&gt;
                  MqttConnAckMessage connAckMessage =&lt;span&gt; (MqttConnAckMessage) MqttMessageFactory.newMessage(
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.CONNACK, &lt;span&gt;false&lt;/span&gt;, MqttQoS.AT_MOST_ONCE, &lt;span&gt;false&lt;/span&gt;, 0&lt;span&gt;),
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttConnAckVariableHeader(MqttConnectReturnCode.CONNECTION_REFUSED_IDENTIFIER_REJECTED, &lt;span&gt;false&lt;/span&gt;), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                  channel.writeAndFlush(connAckMessage);
                  channel.close();
                  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
              }
              channel.close();
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;9&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;clientId为空或null的情况, 这里要求客户端必须提供clientId, 不管cleanSession是否为1, 此处没有参考标准协议实现&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
  &lt;span&gt;    &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StrUtil.isBlank(msg.payload().clientIdentifier())) {
              MqttConnAckMessage connAckMessage &lt;/span&gt;=&lt;span&gt; (MqttConnAckMessage) MqttMessageFactory.newMessage(
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.CONNACK, &lt;span&gt;false&lt;/span&gt;, MqttQoS.AT_MOST_ONCE, &lt;span&gt;false&lt;/span&gt;, 0&lt;span&gt;),
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttConnAckVariableHeader(MqttConnectReturnCode.CONNECTION_REFUSED_IDENTIFIER_REJECTED, &lt;span&gt;false&lt;/span&gt;), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
              channel.writeAndFlush(connAckMessage);
              channel.close();
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;10&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;用户名和密码验证, 这里要求客户端连接时必须提供用户名和密码, 不管是否设置用户名标志和密码标志为1, 此处没有参考标准协议实现&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
  &lt;span&gt;        &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
   String username =&lt;span&gt; msg.payload().userName();
             String password &lt;/span&gt;= msg.payload().passwordInBytes() == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(msg.payload().passwordInBytes(), CharsetUtil.UTF_8);
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;grozaAuthService.checkValid(username,password)) {
                 MqttConnAckMessage connAckMessage &lt;/span&gt;=&lt;span&gt; (MqttConnAckMessage) MqttMessageFactory.newMessage(
                         &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.CONNACK, &lt;span&gt;false&lt;/span&gt;, MqttQoS.AT_MOST_ONCE, &lt;span&gt;false&lt;/span&gt;, 0&lt;span&gt;),
                         &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttConnAckVariableHeader(MqttConnectReturnCode.CONNECTION_REFUSED_BAD_USER_NAME_OR_PASSWORD, &lt;span&gt;false&lt;/span&gt;), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                 channel.writeAndFlush(connAckMessage);
                 channel.close();
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
             }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;ol-list&quot; start=&quot;5&quot; readability=&quot;1.9938461538462&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;2.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果会话中已存储这个新连接的clientId, 就关闭之前该clientId的连接&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (grozaSessionStoreService.containsKey(msg.payload().clientIdentifier())){
              SessionStore sessionStore &lt;/span&gt;=&lt;span&gt; grozaSessionStoreService.get(msg.payload().clientIdentifier());
              Channel previous &lt;/span&gt;=&lt;span&gt; sessionStore.getChannel();
              Boolean cleanSession &lt;/span&gt;=&lt;span&gt; sessionStore.isCleanSession();
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cleanSession){
                  grozaSessionStoreService.remove(msg.payload().clientIdentifier());
                  grozaSubscribeStoreService.removeForClient(msg.payload().clientIdentifier());
                  grozaDupPublishMessageStoreService.removeByClient(msg.payload().clientIdentifier());
                  grozaDupPubRelMessageStoreService.removeByClient(msg.payload().clientIdentifier());
              }
              previous.close();
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;4.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;处理遗嘱信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
 SessionStore sessionStore = &lt;span&gt;new&lt;/span&gt; SessionStore(msg.payload().clientIdentifier(), channel, msg.variableHeader().isCleanSession(), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (msg.variableHeader().isWillFlag()){
              MqttPublishMessage willMessage &lt;/span&gt;=&lt;span&gt; (MqttPublishMessage) MqttMessageFactory.newMessage(
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.PUBLISH,&lt;span&gt;false&lt;/span&gt;, MqttQoS.valueOf(msg.variableHeader().willQos()),msg.variableHeader().isWillRetain(),0&lt;span&gt;),
                      &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttPublishVariableHeader(msg.payload().willTopic(),0&lt;span&gt;),
                      Unpooled.buffer().writeBytes(msg.payload().willMessageInBytes())
              );
              sessionStore.setWillMessage(willMessage);
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2.5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;处理连接心跳包&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;if&lt;/span&gt; (msg.variableHeader().keepAliveTimeSeconds() &amp;gt; 0&lt;span&gt;){
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (channel.pipeline().names().contains(&quot;idle&quot;&lt;span&gt;)){
                  channel.pipeline().remove(&lt;/span&gt;&quot;idle&quot;&lt;span&gt;);
              }
              channel.pipeline().addFirst(&lt;/span&gt;&quot;idle&quot;,&lt;span&gt;new&lt;/span&gt; IdleStateHandler(0, 0, Math.round(msg.variableHeader().keepAliveTimeSeconds() * 1.5f&lt;span&gt;)));
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class=&quot;md-fences md-end-block md-fences-with-lineno ty-contain-cm modeLoaded&quot;&gt;
至此存储会话消息及返回接受客户端连接 将clientId存储到channel的map中
&lt;/pre&gt;&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;3.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;grozaSessionStoreService.put(msg.payload().clientIdentifier(),sessionStore);
          channel.attr(AttributeKey.valueOf(&lt;/span&gt;&quot;clientId&quot;&lt;span&gt;)).set(msg.payload().clientIdentifier());
          Boolean sessionPresent &lt;/span&gt;= grozaSessionStoreService.containsKey(msg.payload().clientIdentifier()) &amp;amp;&amp;amp; !&lt;span&gt;msg.variableHeader().isCleanSession();
          MqttConnAckMessage okResp &lt;/span&gt;=&lt;span&gt; (MqttConnAckMessage) MqttMessageFactory.newMessage(
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.CONNACK,&lt;span&gt;false&lt;/span&gt;,MqttQoS.AT_MOST_ONCE,&lt;span&gt;false&lt;/span&gt;,0&lt;span&gt;),
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MqttConnAckVariableHeader(MqttConnectReturnCode.CONNECTION_ACCEPTED,sessionPresent),
                  &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
          );
          channel.writeAndFlush(okResp);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;10.905689789556&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果cleanSession为0, 需要重发同一clientId存储的未完成的QoS1和QoS2的DUP消息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;msg.variableHeader().isCleanSession()){
              List&lt;/span&gt;&amp;lt;DupPublishMessageStore&amp;gt; dupPublishMessageStoreList =&lt;span&gt; grozaDupPublishMessageStoreService.get(msg.payload().clientIdentifier());
              List&lt;/span&gt;&amp;lt;DupPubRelMessageStore&amp;gt; dupPubRelMessageStoreList =&lt;span&gt; grozaDupPubRelMessageStoreService.get(msg.payload().clientIdentifier());
              dupPublishMessageStoreList.forEach(dupPublishMessageStore &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                  MqttPublishMessage publishMessage &lt;/span&gt;=&lt;span&gt; (MqttPublishMessage)MqttMessageFactory.newMessage(
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.PUBLISH,&lt;span&gt;true&lt;/span&gt;,MqttQoS.valueOf(dupPublishMessageStore.getMqttQoS()),&lt;span&gt;false&lt;/span&gt;,0&lt;span&gt;),
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MqttPublishVariableHeader(dupPublishMessageStore.getTopic(),dupPublishMessageStore.getMessageId()),
                          Unpooled.buffer().writeBytes(dupPublishMessageStore.getMessageBytes())
                  );
                  channel.writeAndFlush(publishMessage);
              });
              dupPubRelMessageStoreList.forEach(dupPubRelMessageStore &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                  MqttMessage pubRelMessage &lt;/span&gt;=&lt;span&gt; MqttMessageFactory.newMessage(
                          &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MqttFixedHeader(MqttMessageType.PUBREL,&lt;span&gt;true&lt;/span&gt;,MqttQoS.AT_MOST_ONCE,&lt;span&gt;false&lt;/span&gt;,0&lt;span&gt;),
                          MqttMessageIdVariableHeader.from(dupPubRelMessageStore.getMessageId()),
                          &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                  );
                  channel.writeAndFlush(pubRelMessage);
              });
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;其他MQTT报文大家对照着工程并对照着&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://juejin.im/post/5bcc4e1ce51d457a0e17c908&quot;&gt;&lt;span&gt;MQTT v3.1.1&lt;/span&gt;&lt;/a&gt;&lt;span&gt;自行查看!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;用户名密码认证&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * 用户名和密码认证服务
   * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 穆书伟
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  @Service
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AuthServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; GrozaAuthService {
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RSAPrivateKey privateKey;
  ​
      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; checkValid(String username, String password) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(username)){
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
          }
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(password)){
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
          }
          RSA rsa &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RSA(privateKey,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
          String value &lt;/span&gt;=&lt;span&gt; rsa.encryptBcd(username, KeyType.PrivateKey);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value.equals(password) ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
      }
  ​
      @PostConstruct
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
          privateKey &lt;/span&gt;= IoUtil.readObj(AuthServiceImpl.&lt;span&gt;class&lt;/span&gt;.getClassLoader().getResourceAsStream(&quot;keystore/auth-private.key&quot;&lt;span&gt;));
      }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;关于Netty实现高性能IOT服务器(Groza)之精尽代码篇中详解到这里就结束了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;下文会带大家推进Netty实现MQTT协议的IOT服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;版权声明:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;作者：穆书伟&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;博客园出处：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/sanshengshui&quot;&gt;https://www.cnblogs.com/sanshengshui&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;github出处：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://github.com/sanshengshui&quot;&gt;https://github.com/sanshengshui&lt;/a&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;个人博客出处：&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;https://sanshengshui.github.io/&quot;&gt;https://sanshengshui.github.io/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Oct 2018 14:13:00 +0000</pubDate>
<dc:creator>三升水</dc:creator>
<og:description>运行环境: JDK 8+ Maven 3.0+ Redis JDK 8+ Maven 3.0+ Redis 技术栈: SpringBoot 2.0+ Redis (Lettuce客户端,RedisTe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanshengshui/p/9859030.html</dc:identifier>
</item>
<item>
<title>Java入门系列-21-多线程 - 极客大全</title>
<link>http://www.cnblogs.com/AIThink/p/9858875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AIThink/p/9858875.html</guid>
<description>&lt;h2 id=&quot;什么是线程&quot;&gt;什么是线程&lt;/h2&gt;
&lt;p&gt;在操作系统中，一个应用程序的执行实例就是&lt;strong&gt;进程&lt;/strong&gt;，进程有独立的内存空间和系统资源，在任务管理器中可以看到进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;是CPU调度和分派的基本单位，也是进程中执行运算的最小单位，可完成一个独立的顺序控制流程，当然一个进程中可以有多个线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程&lt;/strong&gt;：一个进程中同时运行了多个线程，每个线程用来完成不同的工作。多个线程交替占用CPU资源，并非真正的并行执行。&lt;/p&gt;
&lt;p&gt;使用多线程能充分利用CPU的资源，简化编程模型，带来良好的用户体验。&lt;/p&gt;
&lt;p&gt;一个进程启动后拥有一个&lt;strong&gt;主线程&lt;/strong&gt;，主线程用于产生其他子线程，而且主线程必须最后完成执行，它执行各种关闭动作。&lt;/p&gt;
&lt;p&gt;在Java中main()方法为主线程入口，下面使用 Thread 类查看主线程名。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MainThread {
    public static void main(String[] args) {
        //获取当前线程
        Thread t=Thread.currentThread();
        System.out.println(&quot;当前线程名字：&quot;+t.getName());
        //自定义线程名字
        t.setName(&quot;MyThread&quot;);
        System.out.println(&quot;当前线程名字：&quot;+t.getName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建线程&quot;&gt;创建线程&lt;/h2&gt;
&lt;p&gt;在Java中创建线程有两种方式&lt;br/&gt;1.继承 java.lang.Thread 类&lt;br/&gt;2.实现 java.lang.Runnable 接口&lt;/p&gt;
&lt;h4 id=&quot;继承-thread-类创建线程&quot;&gt;1.继承 Thread 类创建线程&lt;/h4&gt;
&lt;p&gt;(1)定义MyThread类继承Thread类&lt;/p&gt;
&lt;p&gt;(2)重写run()方法，编写线程执行体&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyThread extends Thread{

    //重写run方法
    @Override
    public void run() {
        for (int i = 1; i &amp;lt;= 10; i++) {
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3)创建线程对象，调用start()方法启动线程&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestMyThread {

    public static void main(String[] args) {
        MyThread myThread=new MyThread();
        //启动线程
        myThread.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多个线程同时启动后是交替执行的，线程每次执行时长由分配的CPU时间片长度决定&lt;/p&gt;
&lt;p&gt;修改 TestMyThread.java 观察多线程交替执行&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestMyThread {

    public static void main(String[] args) {
        MyThread myThread1=new MyThread();
        MyThread myThread2=new MyThread();
        myThread1.start();
        myThread2.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;多运行几次观察效果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;启动线程能否直接调用 run()方法？&lt;br/&gt;不能，调用run()方法只会是主线程执行。调用start()方法后，子线程执行run()方法，主线程和子线程并行交替执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;实现-runnable-接口创建线程&quot;&gt;2.实现 Runnable 接口创建线程&lt;/h4&gt;
&lt;p&gt;(1)定义MyRunnable类实现Runnable接口&lt;/p&gt;
&lt;p&gt;(2)实现run()方法，编写线程执行体&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyRunnable implements Runnable{
    //实现 run方法
    @Override
    public void run() {
        for (int i = 1; i &amp;lt;= 10; i++) {
            System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3)创建线程对象，调用start()方法启动线程&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestMyRunnable {

    public static void main(String[] args) {
        Runnable runnable=new MyRunnable();
        //创建线程，传入runnable
        Thread t=new Thread(runnable);
        t.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;线程的生命周期&quot;&gt;线程的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784606/201810/784606-20181026214146269-1674150498.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建状态&lt;/strong&gt;：线程创建完成，比如 &lt;code&gt;MyThread thread=new MyThread&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就绪状态&lt;/strong&gt;：线程对象调用 start() 方法，线程会等待CPU分配执行时间，并没有立马执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;运行状态&lt;/strong&gt;：线程分配到了执行时间，进入运行状态。线程在运行中发生礼让 &lt;code&gt;(yield)&lt;/code&gt; 会回到就绪状态&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞状态&lt;/strong&gt;：执行过程中遇到IO操作或代码 &lt;code&gt;Thread.sleep()&lt;/code&gt;，阻塞后的线程不能直接回到运行状态，需要重新进入就绪状态等待资源的分配。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;死亡状态&lt;/strong&gt;：自然执行完毕或外部干涉终止线程&lt;/p&gt;
&lt;h2 id=&quot;线程调度&quot;&gt;线程调度&lt;/h2&gt;
&lt;p&gt;线程调度指按照特定机制为多个线程分配CPU的使用权&lt;/p&gt;
&lt;p&gt;线程调度常用方法&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;setPriority(int newPriority)&lt;/td&gt;
&lt;td&gt;更改线程的优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;static void sleep(long millis)&lt;/td&gt;
&lt;td&gt;在指定的毫秒数内让当前正在执行的线程休眠&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;void join()&lt;/td&gt;
&lt;td&gt;等待该线程终止&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;static void yield()&lt;/td&gt;
&lt;td&gt;暂停当前正在执行的线程对象，并执行其他线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;void interrupt()&lt;/td&gt;
&lt;td&gt;中断线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;boolean isAlive()&lt;/td&gt;
&lt;td&gt;测试线程是否处于活动状态&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;线程优先级的设置&quot;&gt;线程优先级的设置&lt;/h4&gt;
&lt;p&gt;线程优先级由1~10表示，1最低，默认有限级为5。优先级高的线程获得CPU资源的概率较大。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestPriority {

    public static void main(String[] args) {
        Thread t1=new Thread(new MyRunnable(),&quot;线程A&quot;);
        Thread t2=new Thread(new MyRunnable(),&quot;线程B&quot;);
        //最大优先级
        t1.setPriority(Thread.MAX_PRIORITY);
        //最小优先级
        t2.setPriority(Thread.MIN_PRIORITY);
        t1.start();
        t2.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;线程休眠&quot;&gt;线程休眠&lt;/h4&gt;
&lt;p&gt;让线程暂时睡眠指定时长，线程进入阻塞状态，睡眠时间过后线程会再进入可运行状态。&lt;/p&gt;
&lt;p&gt;休眠时长以毫秒为单位，调用sleep()方法需要处理 InterruptedException异常。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestSleep {
    
    public static void main(String[] args) {
        for (int i = 1; i &amp;lt;= 10; i++) {
            System.out.println(&quot;第 &quot;+i+&quot; 秒&quot;);
            try {
                //让当前线程休眠1秒
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;强制运行&quot;&gt;强制运行&lt;/h4&gt;
&lt;p&gt;使用 join() 方法实现，可以认为是线程的插队，会先强制执行插队的线程。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class JoinThread implements Runnable{

    @Override
    public void run() {
        for (int i = 1; i &amp;lt;=10; i++) {
            System.out.println(&quot;线程名：&quot;+Thread.currentThread().getName()+&quot; i:&quot;+i);
        }
        System.out.println(&quot;插队线程执行完毕！&quot;);
    }   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestJoin {

    public static void main(String[] args) {
        Thread joinThread=new Thread(new JoinThread(),&quot;插队的线程&quot;);
        //启动后与主线程交替执行
        joinThread.start();
        for (int i = 1; i &amp;lt;= 10; i++) {
            if (i==5) {
                try {
                    System.out.println(&quot;====开始插队强制执行====&quot;);
                    joinThread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&quot;线程名：&quot;+Thread.currentThread().getName()+&quot; i:&quot;+i);
        }
        System.out.println(&quot;主线程执行完毕！&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最一开始执行，主线程 main 和 &quot;插队的线程&quot;是交替执行。当主线程的循环到第5次的时候，调用 &quot;插队的线程&quot;的join方法，开始强制执行&quot;插队的线程&quot;，待&quot;插队的线程&quot;执行完后，才继续恢复 main 线程的循环。&lt;/p&gt;
&lt;h4 id=&quot;线程礼让&quot;&gt;线程礼让&lt;/h4&gt;
&lt;p&gt;使用 yield() 方法实现，礼让后会暂停当前线程，转为就绪状态，其他具有相同优先级的线程获得运行机会。&lt;/p&gt;
&lt;p&gt;下面我们实现Runnable接口，在run方法中实现礼让，创建两个线程，达到某种条件时礼让。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class YieldThread implements Runnable{

    @Override
    public void run() {
        for (int i = 1; i &amp;lt;= 10; i++) {
            System.out.println(&quot;线程名：&quot;+Thread.currentThread().getName()+&quot; i:&quot;+i);
            //当前线程执行到5后发生礼让
            if (i==5) {
                System.out.println(Thread.currentThread().getName()+&quot; 礼让：&quot;);
                Thread.yield();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestYield {

    public static void main(String[] args) {
        Thread t1=new Thread(new YieldThread(),&quot;A&quot;);
        Thread t2=new Thread(new YieldThread(),&quot;B&quot;);
        t1.start();
        t2.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;只是提供一种可能，不能保证一定会实现礼让&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程同步&quot;&gt;线程同步&lt;/h2&gt;
&lt;p&gt;首先看一个多线共享同一个资源引发的问题&lt;/p&gt;
&lt;p&gt;仓库有10个苹果，小明、小红、小亮每次可以从仓库中拿1个苹果，拿完苹果后仓库中的苹果数量-1。&lt;/p&gt;
&lt;p&gt;先编写仓库资源类，实现接口&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//这个实现类将被多个线程对象共享
public class ResourceThread implements Runnable{
    private int num=10;
    @Override
    public void run() {
        while(true) {
            if (num&amp;lt;=0) {
                break;
            }
            num--;
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+&quot;拿走一个，还剩余：&quot;+num);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写测试类，创建两个线程对象，共享同一个资源&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestResource {

    public static void main(String[] args) {
        ResourceThread resource=new ResourceThread();
        //使用同一个Runnable实现类对象
        Thread t1=new Thread(resource,&quot;小明&quot;);
        Thread t2=new Thread(resource,&quot;小红&quot;);
        Thread t3=new Thread(resource,&quot;小亮&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后我们发现，每次拿完苹果后的剩余数量出现了问题，使用同步方法可以解决这个问题。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;访问修饰符 synchronized 返回类型 方法名(参数列表){
    ……
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;synchronized 就是为当前的线程声明一个锁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改 ResourceThread.java 实现同步&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//这个实现类将被多个线程对象共享
public class ResourceThread implements Runnable{
    private int num=10;
    private boolean isHave=true;
    @Override
    public void run() {
        while(isHave) {
            take();
        }
    }
    //同步方法
    public synchronized void take() {
        if (num&amp;lt;=0) {
            isHave=false;
            return;
        }
        num--;
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+&quot;拿走一个，还剩余：&quot;+num);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现同步的第二种方式同步代码块&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized(syncObject){
    //需要同步的代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;syncObject为需同步的对象，通常为this&lt;/p&gt;
&lt;p&gt;修改 ResourceThread.java 改为同步代码块&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//这个实现类将被多个线程对象共享
public class ResourceThread implements Runnable{
    private int num=10;
    private boolean isHave=true;
    @Override
    public void run() {
        while(isHave) {
            synchronized(this) {
                if (num&amp;lt;=0) {
                    isHave=false;
                    return;
                }
                num--;
                try {
                    Thread.sleep(300);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName()+&quot;拿走一个，还剩余：&quot;+num);               
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 26 Oct 2018 13:43:00 +0000</pubDate>
<dc:creator>极客大全</dc:creator>
<og:description>什么是线程 在操作系统中，一个应用程序的执行实例就是 进程 ，进程有独立的内存空间和系统资源，在任务管理器中可以看到进程。 线程 是CPU调度和分派的基本单位，也是进程中执行运算的最小单位，可完成一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/AIThink/p/9858875.html</dc:identifier>
</item>
<item>
<title>微服务架构下静态数据通用缓存机制 - 波斯马</title>
<link>http://www.cnblogs.com/bossma/p/9858847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bossma/p/9858847.html</guid>
<description>&lt;p&gt;在分布式系统中，特别是最近很火的微服务架构下，有没有或者能不能总结出一个业务静态数据的通用缓存处理机制或方案，这篇文章将结合一些实际的研发经验，尝试理清其中存在的关键问题以及探寻通用的解决之道。&lt;/p&gt;
&lt;h3&gt;什么是静态数据&lt;/h3&gt;
&lt;p&gt;这里静态数据是指不经常发生变化或者变化频率比较低的数据，比如车型库、用户基本信息、车辆基本信息等，车型库这种可能每个月会更新一次，用户和车辆基本信息的变化来源于用户注册、修改，这个操作的频率相对也是比较低的。&lt;/p&gt;
&lt;p&gt;另外这类数据的另一个特点是要求准确率和实时性都比较高，不能出现丢失、错误，以及过长时间的陈旧读。&lt;/p&gt;
&lt;p&gt;具体是不是应该归类为静态数据要看具体的业务，以及对变化频率高低的划分标准。在这里的业务定义中，上边这几类数据都归为静态数据。&lt;/p&gt;
&lt;h3 id=&quot;为什么需要缓存&quot; class=&quot;sectionedit3&quot;&gt;为什么需要缓存&lt;/h3&gt;
&lt;p&gt;在面向用户或车联网的业务场景中，车型信息、用户基本信息和车辆基本信息有着广泛而高频的业务需求，很多数据都需要对其进行关联处理。在这里缓存的目的就是为了提高数据查询效率。静态数据通常都保存在关系型数据库中，这类数据库的IO效率普遍不高，应对高并发的查询往往捉襟见肘。使用缓存可以极大的提升读操作的吞吐量，特别是KV类的缓存，没有复杂的关系操作，时间复杂度一般都在O(1)。注意这里说的缓存指内存缓存。&lt;/p&gt;
&lt;p&gt;当然除了使用缓存，还可以通过其它手段来提高IO吞吐量，比如读写分离，分库分表，但是这类面向关系型数据库的方案更倾向于同时提高读写效率，对于单纯提升读吞吐量的需求，这类方案不够彻底，不能在有限的资源情况下发挥更好的作用。&lt;/p&gt;
&lt;h3&gt;通用缓存机制&lt;/h3&gt;
&lt;p&gt;下面将直接给出一个我认为的通用处理机制，然后会对其进行分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/73642/201810/73642-20181026212745897-1183703475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于某个具体的业务，其涉及到六个核心程序：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;业务服务：提供对某种业务数据的操作接口，比如车辆服务，提供对车辆基本信息的增删改查服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;关系数据库：使用若干表持久化业务数据，比如SQLServer、MySQL、Oracle等。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;持久化队列：可独立部署的队列程序，支持数据持久化，比如RabbitMQ、RocketMQ、Kafka等。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;缓存处理程序：从队列接收数据，然后写入缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;数据一致处理程序：负责检查缓存数据库和关系型数据库中数据是否一致，如果不一致则使用关系数据库进行更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;缓存数据库（Redis）：支持持久化的缓存数据库，这里直接选了Redis，这个基本是业界标准了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以及两个外部定义：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;数据生产者：业务静态数据的来源，可以理解为前端APP、Web系统的某个功能或者模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;数据消费者：需要使用这些业务静态数据的服务或者系统，比如报警系统需要获取车辆对应的用户信息以便发送报警。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;level3&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;下面以问答的形式来说明为什么是这样一种机制。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么需要业务服务&quot;&gt;为什么需要业务服务？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;61.913000494315&quot;&gt;
&lt;p&gt;既然是微服务架构，当然离不开服务了，因为这里探讨的是业务静态数据，所以是业务服务。不过为了更好的理解，这里还是简单说下服务出现的原因。&lt;/p&gt;
&lt;div class=&quot;level4&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;当今业务往往需要在多个终端进行使用，比如PC、手机、平板等，既有网页的形式，又有APP的形式，另外某个数据可能在多种不同的业务被需要，如果将数据操作分布在多个程序中很可能产生数据不一致的情况，另外代码不可避免的冗余，读写性能更很难控制，变更也基本上是不敢变的。通过一个业务服务可以将对业务数据的操作有序的管理起来，并通过接口的形式对外提供操作能力，代码不用冗余了，性能也好优化了，数据不一致也得到了一定的控制，编写上层应用的人也舒服了。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么不是进程内缓存&quot;&gt;为什么不是进程内缓存？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;很多开发语言都提供了进程内缓存的支持，即使没有提供直接操作缓存的包或库，也可以通过静态变量的方式来实现。对数据的查询请求直接在进程内存完成，效率可以说是杠杠滴了。但是进程内缓存存在两个问题：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li class=&quot;level1&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;缓存数据的大小：进程可以缓存数据的大小受限于系统可用内存，同时如果机器上部署了多个服务，某个服务使用了太多的内存，则可能会影响其它服务的正常访问，因此不适合大量数据的缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;level1&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;缓存雪崩：缓存同时大量过期或者进程重启的情况下，可能产生大量的缓存穿透，过多的请求打到关系数据库上，可能导致关系数据库的崩溃，引发更大的不可用问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4 id=&quot;为什么是redis&quot;&gt;为什么是Redis？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;Redis这类数据库可以解决进程内缓存的两个问题：&lt;/p&gt;
&lt;p&gt;另外Redis提供了很好的读写性能，以及方便的水平扩容能力，还支持多种常用数据结构，使用起来比较方便，可以说是通用缓存首选。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么需要队列&quot;&gt;为什么需要队列？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;队列在这里的目的是为了解耦，坦白的说这个方案中可以没有队列，业务服务在关系数据库操作完成后，直接更新到缓存也是可以的。 之所以加上这个队列是由于当前的业务开发有很明显的系统拆分的需求，特别是在微服务架构下，为了降低服务之间的耦合，使用队列是个常用选择，在某些开发模型中也是很推崇的，比如Actor模型。&lt;/p&gt;
&lt;p&gt;举个例子，比如新注册一个用户，需要赠送其300积分，同时还要给其发个注册成功的邮件，如果将注册用户、赠送积分、发成功邮件都写到一起执行，会产生两个问题：一是注册操作耗时增加，二是其中某个处理引发整体不可用的几率增大，三是程序的扩展性不好；通多引入队列，将注册信息分别发到积分队列和通知队列，然后由积分模块和通知模块分别处理，用户、积分、通知三个模块的耦合降低了，相互影响变小了，以后再增加注册后的其它处理也就是增加个队列的事，整体的扩展性得到了增强。&lt;/p&gt;
&lt;p&gt;队列作为一种常用的解耦方案，在缓存这里虽然产生的影响不大，但是除了缓存难免同时还会有其它业务处理，所以为了统一处理机制，这里保留了下来。（既然用了，就把它发扬光大。）&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么队列需要持久化&quot;&gt;为什么队列需要持久化？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;持久化是为了解决网络抖动或者崩溃导致数据丢失的问题，在数据从业务服务到队列，队列自身处理，再从队列到缓存处理程序，中间都可能丢失数据。为了解决丢失数据的问题，需要发送时确认、队列自身持久化、接收时确认；但是需要注意确认机制可能会导致重复数据的产生，因为在未收到确认时就需要重新发送或接收，而数据实际上可能被正常处理，只是确认丢失了；确认机制还会降低队列的吞吐量，但是根据我们的定义业务静态数据的变更频率应该不高，如果同时还需要较高的并发分片是个不错的选择。&lt;/p&gt;
&lt;p&gt;这里持久化队列推荐选择RabbitMQ，虽然吞吐量支持的不是很大，但是各方面综合不错，并发够用就好。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么需要数据一致检查程序&quot;&gt;为什么需要数据一致检查程序？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;在业务服务操作完关系数据库后，数据发送到队列之前（或者不用队列就是直接写入缓存之前），业务服务崩溃了，这时候数据就不能更新到缓存了。还有一种情况是Redis发生了故障转移，master中的更新没有同步到slaver。通过引入这么一个检查程序，定时的检查关系数据库数据和缓存数据的差别，如果缓存数据比较陈旧，则更新之。这样提供了一种极端情况下的挽救措施。&lt;/p&gt;
&lt;p&gt;这个检查程序的运行频率需要综合考虑数据库压力和能够承受的数据陈旧时间，不能把数据库查死了，也不能陈旧太久导致大量数据不一致。可以通过设置上次检查时间点的方式，每次只检查从上次检查时间点（或者最近几次，防止Redis故障转移数据未同步的问题）到本次检查时间点发生变更的数据，这样每次检查只对增量变更，效率更高。&lt;/p&gt;
&lt;p&gt;同时需要理解在分布式系统中，微服务架构下，数据不一致是经常出现的，必须在一致性和可用性之间做出权衡，尽力去降低影响，比如使用准实时或最终一致性。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;只要数据一致检查程序是不是就够了&quot;&gt;只要数据一致检查程序是不是就够了？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;假设没有缓存处理程序，通过定时同步关系数据库和缓存数据库是不是就够了呢？这还是取决于业务，如果是车型库这种数据，增加一个新的车型，本来之前就没有，时间上并不是很敏感，这个是可以的。但是对于新增了用户或者车辆，数据消费者还是希望能够马上使用最新的数据进行处理，越快越好，这时使用同步或者准同步更新就能更加贴近需求。&lt;/p&gt;
&lt;/div&gt;
&lt;h4 id=&quot;为什么不用缓存过期机制&quot;&gt;为什么不用缓存过期机制？&lt;/h4&gt;
&lt;div class=&quot;level4&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;使用缓存过期机制可以不需要缓存处理程序和数据一致检查程序，业务服务首先从Redis查询数据，如果数据存在就直接返回，如果不存在则从关系数据库查询，然后写入Redis，然后再返回，这也是一种常用的缓存处理机制，网上可以查询到很多，很多人用的也很好。&lt;/p&gt;
&lt;p&gt;但是缓存的过期时间是个问题：缓存多长时间过期，设置的短可以降低数据的陈旧，但是会增加缓存穿透的概率，即使采用随机的缓存过期时间，在Redis重启或者故障转移的情况下还是会可能导致缓存雪崩，雪崩的情况下采用数据预热机制，也可能会导致服务更长时间的不可用；设置的长可以提升缓存的使用率，但是增加了数据陈旧，在上边对静态数据的定义中对其准确率和实时性都有较高的要求，业务上能不能接受需要考虑。而且如果操作数据和查询存在波动的峰谷，是不是要引入动态TTL的机制，以达到缓存使用和直接访问数据库的一种平衡，这就需要权衡业务需求和技术方案。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;总结&quot; class=&quot;sectionedit5&quot;&gt;总结&lt;/h3&gt;
&lt;div class=&quot;level3&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;通过上边的这些问题问答，再来看看上面提出的微服务架构下静态数据通用缓存处理机制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过业务服务来包装对数据的操作，不管是操作关系数据库还是缓存数据库，数据消费者其实不需要关心，它只关心业务服务能不能提供高并发实时数据的查询能力。&lt;/li&gt;
&lt;li&gt;利用分布式系统中经常使用队列进行解耦的方式，业务服务不干写入缓存的事，增加一个队列订阅数据变更，然后从队列取数据写入缓存数据库。&lt;/li&gt;
&lt;li&gt;对于绝大部分正常的情况，通过队列更新缓存数据和业务服务中更新缓存数据，其实时性是差不多的，同时实现了业务操作和写缓存的解耦。&lt;/li&gt;
&lt;li&gt;在极端崩溃导致数据不一致的情况下，通过数据一致检查程序进行补救，尽快更新缓存数据。&lt;/li&gt;
&lt;li&gt;现在业务服务可以通过访问Redis缓存来提供对静态数据的高并发准实时查询能力，缓存中不存在的数据就是不存在，没有缓存穿透。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于微服务架构而言，这个机制借助队列这种通用的解耦方式，独立了缓存更新处理，通过准实时更新和定时检查，保证了缓存的实时性和极端情况下较短时间内达到最终一致，通过缓存的持久化机制消除了缓存穿透和雪崩，在缓存的数据较大或读取并发较高时支持水平扩容，可以认为对业务静态数据提供了一种广泛适用的缓存处理机制。&lt;/p&gt;
&lt;p&gt;这个方案在某些情况下可能是没有必要的，比如你要缓存一个全国限行的城市列表，使用一个进程内缓存就够了。&lt;/p&gt;
&lt;p&gt;最后剩下的就是工作量的问题了，这个会给开发和维护带来复杂性，队列有没有用的顺手的，人手是不是够，业务需求是什么样的，需要考虑清楚。&lt;/p&gt;
&lt;h3&gt;后记&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Redis耦合问题：&lt;/strong&gt;图中业务服务直接访问了Redis，如果要实现业务服务对Redis的完全透明，这个还比较复杂，可以考虑采用AOP的方式，对关系数据库和Redis保持相同的类型定义，分别采用ORM和反序列化的方式标准化输出，这是个想法我也没有实现；同时缓存数据是准实时的，如果要求完全一致，还是应该提供从关系数据库查询的版本。另外如果要摆脱对Redis的直接依赖，还可以通过OpenResty来实现对资源的透明访问，这个不是本文的重点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务可用性问题：&lt;/strong&gt;这篇文章没有关注服务可用性问题，为了保证服务的高可用，每个服务或者程序都应该有多份部署的，无论是负载均衡的方案，或者传统的主备方案，在部分部署不可用时仍能够继续提供服务。&lt;/p&gt;
&lt;p&gt;写的比较快，有些理解不免偏颇，欢迎指正。&lt;/p&gt;
&lt;p&gt;另外附上我的独立博客访问地址：&lt;a href=&quot;http://blog.bossma.cn/architecture/microservice-business-static-data-universal-cache-mechanism/&quot; target=&quot;_blank&quot;&gt;http://blog.bossma.cn/architecture/microservice-business-static-data-universal-cache-mechanism/&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 26 Oct 2018 13:29:00 +0000</pubDate>
<dc:creator>波斯马</dc:creator>
<og:description>在分布式系统中，特别是最近很火的微服务架构下，有没有或者能不能总结出一个业务静态数据的通用缓存处理机制或方案，这篇文章将结合一些实际的研发经验，尝试理清其中存在的关键问题以及探寻通用的解决之道。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bossma/p/9858847.html</dc:identifier>
</item>
<item>
<title>ChunkDisappearImage-一个以矩形为单位的图片消失分解效果 - blueberryzzz</title>
<link>http://www.cnblogs.com/blueberryzzz/p/9858749.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blueberryzzz/p/9858749.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210416528-1645876247.gif&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210435112-1055274508.gif&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210448905-1309354276.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.将ChunkDisappearImage挂在一个空GameObject上。&lt;br/&gt;2.将ChunkDisappearImage的Material设为ChunkDisappearImageMaterial。&lt;br/&gt;3.设置RectTransform的宽、高、缩放、旋转等参数。设置ChunkDisappearImage的参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Speed：&lt;/strong&gt; 小方块移动的速度。&lt;br/&gt;&lt;strong&gt;TargetX,TargetY：&lt;/strong&gt; 每个小方块移动的终点坐标。&lt;br/&gt;&lt;strong&gt;SubRectX,SubRectY：&lt;/strong&gt; 每个小方块的长宽。&lt;br/&gt;&lt;strong&gt;Interval：&lt;/strong&gt; 每个小方块开始移动时间的间隔。&lt;br/&gt;&lt;strong&gt;SpeedArg：&lt;/strong&gt; 距离越远的方块是否运行越快，_SpeedArg为1时，所有方块运行速度基本相同，值越小，距离越远的方块运行的越快。&lt;br/&gt;ps：目标点的坐标，小方块的宽高都是Image对象为父节点的本地坐标。&lt;/p&gt;

&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;实现主要分为三个步骤：&lt;/strong&gt;&lt;br/&gt;1.修改image的mesh。&lt;br/&gt;2.将与运动相关的参数传入shader中。&lt;br/&gt;3.在移动结束后将mesh恢复为普通的image的shader。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210610120-36840052.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现细节&quot;&gt;实现细节&lt;/h2&gt;
&lt;h3 id=&quot;mesh的拆分&quot;&gt;mesh的拆分&lt;/h3&gt;
&lt;h4 id=&quot;image通过onpopulatemesh函数构建对应的mesh所以我们通过重写image的onpopulatemesh来对mesh进行构建&quot;&gt;1.Image通过OnPopulateMesh函数构建对应的mesh，所以我们通过重写Image的OnPopulateMesh来对mesh进行构建。&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Image的默认mesh：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210629788-526422195.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;拆分后的mesh：&lt;/strong&gt; 以拆分为四块为例&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210651135-147888723.png&quot;/&gt;&lt;br/&gt;将mesh拆分为很多个小矩形后，还得想办法告诉shader每个顶点是属于那个矩形的，才能以此为依据进行矩形的移动。&lt;/p&gt;
&lt;h4 id=&quot;如何告诉shader每个顶点是属于哪个矩形的&quot;&gt;2.如何告诉shader每个顶点是属于哪个矩形的。&lt;/h4&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public partial struct UIVertex
{
    public Vector3 position;
    public Vector3 normal;
    public Vector4 tangent;
    public Color32 color;
    public Vector2 uv0;
    public Vector2 uv1;
    public Vector2 uv2;
    public Vector2 uv3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看下描述一个UI顶点的结构体中都包含了哪些字段，UGUI中只用到了position，color，uv0这三个字段。&lt;br/&gt;这代表我们可以使用剩余的字段传我们需要的额外信息，这里选择使用uv1字段将每个矩形的左下角的点作为矩形的位置信息传入shader，在shader中，以此为基础进行小矩形块的移动。&lt;br/&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br/&gt;①不能用normal和tangent，因为UGUI在渲染时，传入shader中的position不是传入VertexHelper时的原始值，而是该点在根canvas上的坐标，同理，normal，tangent也做了相应的变换。不是原始值了。&lt;br/&gt;所以在传额外信息的时候要用uv1、uv2、uv3字段，这三个字段不会随点的移动、旋转、缩放而改变。&lt;br/&gt;②由于unity高版本在ugui渲染时做了优化，在默认情况下只会将position、color、uv0三个字段传入shader，所以需要手动将uv1设为生效才行。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210708398-136229368.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;image本地坐标到根canvas坐标的模型矩阵的计算&quot;&gt;image本地坐标到根canvas坐标的模型矩阵的计算&lt;/h3&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;mLocalToCanvas = canvas.rootCanvas.transform.localToWorldMatrix.inverse * transform.localToWorldMatrix;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;image的模型矩阵：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026212307027-2092634020.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;canvas的模型矩阵：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026212323455-1010775850.png&quot;/&gt;&lt;br/&gt;由于矩阵满足结合律，所以用用canvas的模型矩阵的逆乘以image的模型矩阵会将canvas的模型矩阵消掉，也就是image坐标-&amp;gt;canvas坐标的模型矩阵：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026212339587-582141206.png&quot;/&gt;&lt;br/&gt;用这个矩阵乘上image上的本地坐标就可以算出对应的canvas上的坐标。&lt;/p&gt;
&lt;h3 id=&quot;开始时间和结束时间的计算&quot;&gt;开始时间和结束时间的计算&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;开始时间&lt;/strong&gt;&lt;br/&gt;分两种情况：&lt;br/&gt;①当目标点在图片内时，不去算准确的起始时间，直接设置为0。&lt;br/&gt;②当目标点在图片外时，最近点一定是四个顶点之一。遍历四个顶点，计算一下离目标点最近的方块开始运动时的_Delta值，即f第一次不为0的时候&lt;br/&gt;&lt;strong&gt;结束时间&lt;/strong&gt;&lt;br/&gt;计算一下最远点的f为1的情况即可，由于距离目标点最远的点一定是四个顶点之一，所以枚举四个顶点即可。&lt;/p&gt;
&lt;h3 id=&quot;shader的重写&quot;&gt;shader的重写&lt;/h3&gt;
&lt;p&gt;我们要改动Image默认的shader的顶点着色器来实现每个顶点的位移和alpha值的降低。&lt;br/&gt;我们选择5.37f1的UGUI默认shader，UI-Default.shader进行修改，这个在unity官网就可以下到。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1362861/201810/1362861-20181026210734053-425371512.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;注意&quot;&gt;注意：&lt;/h4&gt;
&lt;p&gt;在Unity高版本打开低版本的shader时，会对一些函数做替换，如在2018.2打开5.37f1的shader时，会对如下语句进行修改。&lt;/p&gt;
&lt;pre class=&quot;glsl&quot;&gt;
&lt;code&gt;// Upgrade NOTE: replaced 'mul(UNITY_MATRIX_MVP,*)' with 'UnityObjectToClipPos(*)'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此demo中使用的是2018.2版本的unity，所以在低版本使用时要把这句话改回去，不然会报错。&lt;/p&gt;
&lt;h4 id=&quot;顶点的移动公式&quot;&gt;顶点的移动公式：&lt;/h4&gt;
&lt;pre class=&quot;glsl&quot;&gt;
&lt;code&gt;//计算该方块到目标点的距离，以此为标准作为每个方块移动时间的延迟
float distance = length(target.xyz - leftBottom.xyz);
//距离越远的方块是否运行越快，_SpeedArg为1时，所有方块运行速度大致相同，值越小，距离越远的方块运行的越快
float tempDis = 1 + distance * _SpeedArg;
float f = clamp((_Delta - distance * _Interval) / tempDis, 0, 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据f在0-1之间的变化，来控制方块在起点到终点之间的移动和alpha值的变化。&lt;br/&gt;①distance * _Interval保证每个距终点距离不同方块之间的开始移动时间会有一个间隔。&lt;br/&gt;②tempDis可以控制不同距离方块之间的速度比。&lt;/p&gt;

&lt;p&gt;原理其实并不难，主要只有两部分：改mesh，改shader。就是一些坐标的转换、开始结束时间的控制、版本的兼容性比较麻烦。&lt;br/&gt;在把整个流程跑通一次之后，就会对流程有一个较为全面的认识，下次做2D或是3D的一些效果思路也也会更广一些。&lt;/p&gt;
&lt;p&gt;代码链接：&lt;a href=&quot;https://github.com/blueberryzzz/UIAndShader/tree/master/UIAndShader/Assets/ChunkDisappearImage&quot; class=&quot;uri&quot;&gt;https://github.com/blueberryzzz/UIAndShader/tree/master/UIAndShader/Assets/ChunkDisappearImage&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Oct 2018 13:10:00 +0000</pubDate>
<dc:creator>blueberryzzz</dc:creator>
<og:description>效果 使用 1.将ChunkDisappearImage挂在一个空GameObject上。 2.将ChunkDisappearImage的Material设为ChunkDisappearImageMa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blueberryzzz/p/9858749.html</dc:identifier>
</item>
<item>
<title>Docker入门实践笔记（三）一篇文章搞懂Docker下安装Redis，以及Redis与SpringBoot整合 - 比脚更长的路</title>
<link>http://www.cnblogs.com/lonelyJay/p/9858301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lonelyJay/p/9858301.html</guid>
<description>&lt;p&gt;&lt;span&gt;内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先介绍单机版Redis镜像在Docker下的安装，然后在容器的Redis Shell中进行常用类型String、List、Set、Hash、SortedSet的增删改查操作测试，最后再结合SpringBoot项目进行简单的测试。后续会推出哨兵模式（Sentinel，一主二从三哨兵）和集群模式（Redis Cluster）的安装和部署，敬请关注。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　操作系统： CentOS 7.2 64位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Docker：17.12.1.ce&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Redis： 3.2.12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;适合人群&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　linux运维人员，docker运维人员，java人员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　转载请说明出处：&lt;a href=&quot;https://www.cnblogs.com/lonelyJay/p/9858301.html%20&quot; target=&quot;_blank&quot;&gt;Docker入门实践笔记（三）一篇文章搞懂Docker下安装Redis，以及Redis与SpringBoot整合&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Demo源码托管：&lt;a href=&quot;https://github.com/leo-zz/SpringBootDemo&quot;&gt;https://github.com/leo-zz/SpringBootDemo&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Docker官方文档：&lt;a href=&quot;https://hub.docker.com/r/library/redis/&quot;&gt;https://hub.docker.com/r/library/redis/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/lonelyJay/p/9681099.html&quot;&gt;　　Docker入门实践笔记（一）——安装Docker CE&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/lonelyJay/p/9848295.html&quot;&gt;　　Linux入门实践笔记（三）——数据盘格式化和和多分区挂载&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/skyessay/p/6485187.html&quot;&gt;　　spring boot整合redis&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Redis 命令参考：&lt;a href=&quot;http://redisdoc.com/&quot;&gt;http://redisdoc.com/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前提&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　服务器需要安装Docker CE，未安装的童鞋请参考 &lt;a href=&quot;https://www.cnblogs.com/lonelyJay/p/9681099.html&quot;&gt;Docker入门实践笔记（一）——安装Docker CE&lt;/a&gt; ；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　此示例将redis的缓存持久化到&lt;code&gt;~/redis/data&lt;/code&gt;路径下，如果需要分区挂载数据盘的童鞋，请参考&lt;a href=&quot;https://www.cnblogs.com/lonelyJay/p/9848295.html&quot;&gt;Linux入门实践笔记（三）——数据盘格式化和和多分区挂载&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;步骤&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;下载Redis镜像&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;　　使用&lt;code&gt;docker pull&lt;/code&gt;，从Docker仓库中下载Redis镜像，本示例下载的版本为3.2.12。使用&lt;code&gt;docker images&lt;/code&gt;查看已经下载的镜像信息。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从Docker仓库中下载Redis镜像&lt;/span&gt;
[user1@iz8vb62snc6e5cage5yvz9z /]$ sudo docker pull redis:3.2.12
3.2.12: Pulling from library/&lt;span&gt;redis
f17d81b4b692&lt;/span&gt;:&lt;span&gt; Pull complete
b32474098757&lt;/span&gt;:&lt;span&gt; Pull complete
8980cabe8bc2&lt;/span&gt;:&lt;span&gt; Pull complete
58af19693e78&lt;/span&gt;:&lt;span&gt; Pull complete
a977782cf22d&lt;/span&gt;:&lt;span&gt; Pull complete
9c1e268980b7&lt;/span&gt;:&lt;span&gt; Pull complete
Digest&lt;/span&gt;: sha256:&lt;span&gt;7b0a40301bc1567205e6461c5bf94c38e1e1ad0169709e49132cafc47f6b51f3
Status&lt;/span&gt;: Downloaded newer image &lt;span&gt;for&lt;/span&gt; redis:3.2.12
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看已经下载的镜像信息&lt;/span&gt;
&lt;span&gt;[user1@iz8vb62snc6e5cage5yvz9z home]$ sudo docker images
REPOSITORY         TAG                 IMAGE ID           CREATED             SIZE
redis               &lt;/span&gt;3.2.12             87856cc39862        8 days ago         76MB&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;span&gt;配置redis.conf&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;　　将redis.conf拷贝到&lt;code&gt;/home/user1/redis/config&lt;/code&gt;路径下，可以修改此文件以配置Redis；本示例使用默认配置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;[user1@iz8vb62snc6e5cage5yvz9z config]$ ls
redis&lt;/span&gt;.&lt;span&gt;conf
[user1@iz8vb62snc6e5cage5yvz9z config]$ pwd
&lt;/span&gt;/home/user1/redis/config&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;span&gt;创建Redis容器&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;　　使用&lt;code&gt;docker run&lt;/code&gt;创建Redis容器，然后使用&lt;code&gt;docker ps&lt;/code&gt;查看容器的运行情况。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[user1@iz8vb62snc6e5cage5yvz9z redis]$ sudo docker run -p 6379:6379 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;-v /home/user1/redis/config:/usr/local/etc/redis/redis.conf -v /home/user1/redis/data:/data --name jmsRedis &lt;/span&gt;&lt;br/&gt;&lt;span&gt;-d redis:3.2.12  redis-server /usr/local/etc/redis/redis.&lt;span&gt;conf
14d9c846b6586953c9528a0d6cbfe3257f4a936892e8d8778260a7aaf62b79c7
[user1@iz8vb62snc6e5cage5yvz9z redis]$ sudo docker ps
CONTAINER ID       IMAGE               COMMAND                 CREATED             STATUS             PORTS                   NAMES
14d9c846b658       redis&lt;/span&gt;:3.2.12        &quot;docker-entrypoint.s…&quot;   15 seconds ago     Up 15 seconds       0.0.0.0:6379-&amp;gt;6379/tcp   jmsRedis&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　创建容器的参数释义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　-p是指定容器到宿主机的端口映射，这里使用的是Redis的默认端口号6379，映射为宿主机的6379。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　-v是指定容器到宿主机的文件映射，这里将Redis容器的持久化数据存放路径/data映射到宿主机的/home/user1/redis/data；将Redis的配置文件/usr/local/etc/redis/redis.conf映射到宿主机的/home/user1/redis/config。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　--name是指定容器的名称为jmsRedis。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　-d表示在后台启动Redis。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　redis-server /usr/local/etc/redis/redis.conf 表示启动指定配置文件的Redis。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;容器内测试&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;　　执行docker exec进入容器，由于容器中安装了Redis，故可以执行redis-cli命令进入Redis shell。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[user1@iz8vb62snc6e5cage5yvz9z redis]$ sudo docker &lt;span&gt;exec&lt;/span&gt; -it 14d9c846b658 /bin/&lt;span&gt;bash  
root@14d9c846b658&lt;/span&gt;:/data&lt;span&gt;#&lt;/span&gt;&lt;span&gt; redis-cli -h localhost -p 6379&lt;/span&gt;
localhost:6379&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;测试String类型数据的增删改查&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;　　演示Redis中String类型数据的的设置set、查询get、删除del操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将字符串值 value 关联到 key 。如果 key 已经持有其他值， SET 就覆写旧值，无视类型。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;对于带有生存时间（TTL）的键来，当SET命令成功在这个键上执行时，这个键原有的TTL将被清除。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度：O(1);返回值：设置操作成功完成时，返回 OK.&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; set hello leo
OK
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回 key 所关联的字符串值。当 key 不存在时，返回 nil ，否则，返回 key 的值。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;如果 key 不是字符串类型，那么返回一个错误。时间复杂度：O(1)&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; get hello
&lt;/span&gt;&quot;leo&quot;&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除给定的一个或多个 key 。不存在的 key 会被忽略。返回值：被删除 key 的数量。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度：O(N)， N 为被删除的 key 的数量。删除单个字符串类型的 key ，时间复杂度为O(1)。删除单个列表、集合、有序集合或哈希表类型的 key ，&lt;br/&gt;时间复杂度为O(M)， M 为以上数据结构内的元素数量。&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; del hello
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1                                                                                 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;llocalhost:6379&amp;gt;&lt;span&gt; get hello
(nil)&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;测试List类型数据的增删改查&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;　　演示Redis中List类型数据的的插入rpush、范围查询lrange、按下标查询lindex、移除头元素lpop操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将一个或多个值 value 插入到列表 key 的表尾(最右边),索引依次递增。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度：O(1)，返回值：rpush后list的长度&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; rpush fruit apple
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; rpush fruit banana pear orange
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 4&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定。下标(index)参数 start 和 stop 都以 0 为底，&lt;br/&gt;也就是说，以 0 表示列表的第一个元素，以 1 表示列表的第二个元素;也可以使用负数下标，以 -1 表示列表的最后一个元素， &lt;br/&gt;-2 表示列表的倒数第二个元素，以此类推。&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;时间复杂度：O(S+N)， S 为偏移量 start ， N 为指定区间内元素的数量。遍历1次链表拿取所有范围内的数据。&lt;/span&gt;
localhost:6379&amp;gt; lrange fruit 0 -1
1) &quot;apple&quot;
2) &quot;banana&quot;
3) &quot;pear&quot;
4) &quot;orange&quot;&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回列表 key 中，下标为 index 的元素。 时间复杂度O(N)，需要遍历链表。&lt;/span&gt;
localhost:6379&amp;gt; lindex fruit 2
&quot;pear&quot;&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;移除并返回列表 key 的头元素。当 key 不存在时，返回 nil 。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度：O(1)，头元素是指index最小的元素。所有元素的index会随着pop操作更新&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; lpop fruit
&lt;/span&gt;&quot;apple&quot;&lt;span&gt;
​
localhost&lt;/span&gt;:6379&amp;gt; lrange fruit 0 -1
1) &quot;banana&quot;
2) &quot;pear&quot;
3) &quot;orange&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;测试SET类型数据的增删改查&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;　　演示Redis中Set类型数据的的插入sadd、集合查询smembers、判断成员是否存在sismember、移除成员srem操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;假如 key 不存在，则创建一个只包含 member 元素作成员的集合。当 key 不是集合类型时，返回一个错误。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度:O(N)， N 是被添加的元素的数量。返回值:被添加到集合中的新元素的数量，不包括被忽略的元素。&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; sadd animal tiger
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; sadd animal panda
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; sadd animal lion
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; sadd animal fish
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; sadd animal lion
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 0&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回集合 key 中的所有成员。不存在的 key 被视为空集合。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度:O(N)， N 为集合的基数。&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; smembers animal
&lt;/span&gt;1) &quot;panda&quot;
2) &quot;tiger&quot;
3) &quot;fish&quot;
4) &quot;lion&quot;&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断 member 元素是否集合 key 的成员。时间复杂度:O(1)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;如果 member 元素是集合的成员，返回 1 。如果 member 元素不是集合的成员，或 key 不存在，返回 0 。&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; sismember animal panda
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;移除集合 key 中的一个或多个 member 元素，不存在的 member 元素会被忽略。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度:O(N)， N 为给定 member 元素的数量。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;返回值:被成功移除的元素的数量，不包括被忽略的元素。当 key 不是集合类型，返回一个错误。&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; srem animal panda
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
​
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; sismember animal panda
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;测试HASH类型数据的增删改查&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;　　演示Redis中Hash类型数据的的插入hset、集合查询hgetall、根据Key查询hget、移除hdel操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将哈希表 key 中的域 field 的值设为 value 。如果 key 不存在，一个新的哈希表被创建并进行 HSET 操作。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;如果域 field 已经存在于哈希表中，旧值将被覆盖。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;返回值：如果 field 是哈希表中的一个新建域，并且值设置成功，返回 1 。如果哈希表中域 field 已经存在且旧值已被新值覆盖，返回 0 。时间复杂度：O(1)&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; hset phones mi8 xiaomi
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; hset phones v10 honor
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; hset phones pro2 smartisan
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; hset phones nex vivo
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回哈希表 key 中，所有的域和值。在返回值里，紧跟每个域名(field name)之后是域的值(value)，所以返回值的长度是哈希表大小的两倍。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度：O(N)， N 为哈希表的大小。&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; hgetall phones
&lt;/span&gt;1) &quot;mi8&quot;
2) &quot;xiaomi&quot;
3) &quot;v10&quot;
4) &quot;honor&quot;
5) &quot;pro2&quot;
6) &quot;smartisan&quot;
7) &quot;nex&quot;
8) &quot;vivo&quot;&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除哈希表 key 中的一个或多个指定域，不存在的域将被忽略。返回值:被成功移除的域的数量.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度:O(N)， N 为要删除的域的数量。&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; hdel phones pro2
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; hdel phones pro2
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 0&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回哈希表 key 中给定域 field 的值。时间复杂度：O(1);返回值：给定域的值,若不存在则返回nil。&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; hget phones pro2
(nil)
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; hget phones mi8
&lt;/span&gt;&quot;xiaomi&quot;&lt;span&gt;
​
localhost&lt;/span&gt;:6379&amp;gt;&lt;span&gt; hgetall phones
&lt;/span&gt;1) &quot;mi8&quot;
2) &quot;xiaomi&quot;
3) &quot;v10&quot;
4) &quot;honor&quot;
5) &quot;nex&quot;
6) &quot;vivo&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;测试Sorted set类型数据的增删改查&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;　　演示Redis中Hash类型数据的的插入zadd、范围查询zrange、限定score的范围查询zrangebyscore、移除zrem操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Sorted Set新增/删除一个元素的复杂度为log(N)，实现的数据结构感觉像是二叉树&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;将一个或多个 member 元素及其 score 值加入到有序集 key 当中。score 值可以是整数值或双精度浮点数。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;如果某个 member 已经是有序集的成员，那么更新这个 member 的 score 值，并通过重新插入这个 member 元素，来保证该 member 在正确的位置上。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度:O(M*log(N))， N 是有序集的基数， M 为成功添加的新成员的数量。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;返回值:被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。&lt;/span&gt;
localhost:6379&amp;gt; zadd zphones 1598&lt;span&gt; vivoZ3
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt; zadd zphones 1599&lt;span&gt; oppoK1
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt; zadd zphones 2499&lt;span&gt; XiaoMi8
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt; zadd zphones 1299&lt;span&gt; SmartisanPro2
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递增(从小到大)来排序。具有相同 score 值的成员按字典序(lexicographical order )来排列。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;以 0 表示有序集第一个成员，以 1 表示有序集第二个成员,支持负数下标，-1 表示最后一个成员，-2 表示倒数第二个成员&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度:O(log(N)+M)， N 为有序集的基数，而 M 为结果集的基数。&lt;/span&gt;
localhost:6379&amp;gt; zrange zphone 0 -1&lt;span&gt;
(&lt;/span&gt;&lt;span&gt;empty&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;&lt;span&gt; or set)
localhost&lt;/span&gt;:6379&amp;gt; zrange zphones 0 -1
1) &quot;SmartisanPro2&quot;
2) &quot;vivoZ3&quot;
3) &quot;oppoK1&quot;
4) &quot;XiaoMi8&quot;&lt;span&gt;
localhost&lt;/span&gt;:6379&amp;gt; zrange zphones 0 -1&lt;span&gt; withscores
&lt;/span&gt;1) &quot;SmartisanPro2&quot;
2) &quot;1299&quot;
3) &quot;vivoZ3&quot;
4) &quot;1598&quot;
5) &quot;oppoK1&quot;
6) &quot;1599&quot;
7) &quot;XiaoMi8&quot;
8) &quot;2499&quot;&lt;span&gt;
​
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;可选的 LIMIT 参数指定返回结果的数量及区间，注意当 offset 很大时，定位 offset 的操作可能需要遍历整个有序集，此过程最坏复杂度为 O(N) 时间。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;可选的 WITHSCORES 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 score 值一起返回。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;min 和 max 可以是-inf和+inf，可以在不知道有序集的最低和最高score值的情况下使用&lt;/span&gt;
localhost:6379&amp;gt; zrangebyscore zphones 999 1599&lt;span&gt; withscores
&lt;/span&gt;1) &quot;SmartisanPro2&quot;
2) &quot;1299&quot;
3) &quot;vivoZ3&quot;
4) &quot;1598&quot;
5) &quot;oppoK1&quot;
6) &quot;1599&quot;&lt;span&gt;
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。当 key 存在但不是有序集类型时，返回一个错误。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;时间复杂度:O(M*log(N))， N 为有序集的基数， M 为被成功移除的成员的数量。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;返回值:被成功移除的成员的数量&lt;/span&gt;
localhost:6379&amp;gt;&lt;span&gt; zrem zphones SmartisanPro2
(&lt;/span&gt;&lt;span&gt;integer&lt;/span&gt;) 1&lt;span&gt;
​
localhost&lt;/span&gt;:6379&amp;gt; zrange zphones 0 -1&lt;span&gt; withscores
&lt;/span&gt;1) &quot;vivoZ3&quot;
2) &quot;1598&quot;
3) &quot;oppoK1&quot;
4) &quot;1599&quot;
5) &quot;XiaoMi8&quot;
6) &quot;2499&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;span&gt;搭建SpringBoot测试项目&lt;/span&gt;&lt;/h5&gt;
&lt;h6&gt;&lt;span&gt;创建SpringBoot项目&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;　　通过IDEA中的Spring Initializr创建SpringBoot项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1455629/201810/1455629-20181026192741646-1389564350.png&quot;&gt;&lt;img title=&quot;1540451706434&quot; src=&quot;https://img2018.cnblogs.com/blog/1455629/201810/1455629-20181026192743055-1453194242.png&quot; alt=&quot;1540451706434&quot; width=&quot;723&quot; height=&quot;498&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Group和Artifact配置如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1455629/201810/1455629-20181026192743438-369145443.png&quot;&gt;&lt;img title=&quot;1540452619089&quot; src=&quot;https://img2018.cnblogs.com/blog/1455629/201810/1455629-20181026192743940-1315478275.png&quot; alt=&quot;1540452619089&quot; width=&quot;730&quot; height=&quot;501&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　选择SpringBoot的版本为1.5.x，并勾选Redis的依赖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1455629/201810/1455629-20181026192744365-519723944.png&quot;&gt;&lt;img title=&quot;1540451800559&quot; src=&quot;https://img2018.cnblogs.com/blog/1455629/201810/1455629-20181026192744853-734362403.png&quot; alt=&quot;1540451800559&quot; width=&quot;731&quot; height=&quot;504&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　选则项目所在路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1455629/201810/1455629-20181026192745358-2115234576.png&quot;&gt;&lt;img title=&quot;1540452660787&quot; src=&quot;https://img2018.cnblogs.com/blog/1455629/201810/1455629-20181026192745746-1349811165.png&quot; alt=&quot;1540452660787&quot; width=&quot;729&quot; height=&quot;509&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　项目创建完毕，可以删除maven wrapper相关的文件和文件夹。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1455629/201810/1455629-20181026192746042-1249417334.png&quot;&gt;&lt;img title=&quot;1540453560286&quot; src=&quot;https://img2018.cnblogs.com/blog/1455629/201810/1455629-20181026192746558-1462184927.png&quot; alt=&quot;1540453560286&quot; width=&quot;420&quot; height=&quot;274&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h6&gt;&lt;span&gt;POM&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;　　在创建项目中已经勾选了Redis相关的依赖，不需要再在POM文件中添加其他依赖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 可以看到Spring Initailizer已经帮我们引入了redis的依赖 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
​
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;yaml&lt;/span&gt;&lt;/h6&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:&lt;span&gt;
  redis&lt;/span&gt;:&lt;span&gt;
   host&lt;/span&gt;: 192.168.1.25 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;redis服务器的IP地址&lt;/span&gt;
   port: 6379 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;redis监听的端口号&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;Redis配置类&lt;/span&gt;&lt;/h6&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisConfig {
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注入 RedisConnectionFactory
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Autowired
    RedisConnectionFactory redisConnectionFactory;
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 实例化 RedisTemplate 对象
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RedisTemplate&amp;lt;String, Object&amp;gt;&lt;span&gt; createRedisTemplate() {
        RedisTemplate&lt;/span&gt;&amp;lt;String, Object&amp;gt; redisTemplate = &lt;span&gt;new&lt;/span&gt; RedisTemplate&amp;lt;&amp;gt;&lt;span&gt;();
        initializeRedisTemplate(redisTemplate, redisConnectionFactory);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate;
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置数据存入 redis 的序列化方式
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initializeRedisTemplate(RedisTemplate&amp;lt;String, Object&amp;gt;&lt;span&gt; redisTemplate, RedisConnectionFactory redisConnectionFactory) {
        redisTemplate.setKeySerializer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRedisSerializer());
        redisTemplate.setHashKeySerializer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRedisSerializer());
        redisTemplate.setHashValueSerializer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdkSerializationRedisSerializer());
        redisTemplate.setValueSerializer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JdkSerializationRedisSerializer());
        redisTemplate.setConnectionFactory(redisConnectionFactory);
   }
​
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 实例化 HashOperations 对象,可以使用 Hash 类型操作
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HashOperations&amp;lt;String, String, Object&amp;gt; hashOperations(RedisTemplate&amp;lt;String, Object&amp;gt;&lt;span&gt; redisTemplate) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForHash();
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 实例化 ValueOperations 对象,可以使用 String 操作
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValueOperations&amp;lt;String, Object&amp;gt; valueOperations(RedisTemplate&amp;lt;String, Object&amp;gt;&lt;span&gt; redisTemplate) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForValue();
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 实例化 ListOperations 对象,可以使用 List 操作
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ListOperations&amp;lt;String, Object&amp;gt; listOperations(RedisTemplate&amp;lt;String, Object&amp;gt;&lt;span&gt; redisTemplate) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForList();
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 实例化 SetOperations 对象,可以使用 Set 操作
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SetOperations&amp;lt;String, Object&amp;gt; setOperations(RedisTemplate&amp;lt;String, Object&amp;gt;&lt;span&gt; redisTemplate) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForSet();
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 实例化 ZSetOperations 对象,可以使用 ZSet 操作
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ZSetOperations&amp;lt;String, Object&amp;gt; zSetOperations(RedisTemplate&amp;lt;String, Object&amp;gt;&lt;span&gt; redisTemplate) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; redisTemplate.opsForZSet();
   }
​
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;Redis工具类&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;　　本示例主要进行Redis中Hash类型数据的操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RedisHashUtil&amp;lt;T&amp;gt;&lt;span&gt; {
​
    @Autowired
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; RedisTemplate&amp;lt;String, Object&amp;gt;&lt;span&gt; redisTemplate;
    @Resource
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; HashOperations&amp;lt;String, String, T&amp;gt;&lt;span&gt; hashOperations;
​
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getRedisKey() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;REDIS_DEMO&quot;&lt;span&gt;;
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key   key
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; value 对象
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; expire 过期时间(单位:秒),传入 -1 时表示不设置过期时间
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put(String key, T value, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; expire) {
        hashOperations.put(getRedisKey(), key, value);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (expire != -1&lt;span&gt;) {
            redisTemplate.expire(getRedisKey(), expire, TimeUnit.SECONDS);
       }
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 传入key的名称
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove(String key) {
        hashOperations.delete(getRedisKey(), key);
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 查询的key
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T get(String key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashOperations.get(getRedisKey(), key);
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取当前redis库下所有value
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt; getAll() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashOperations.values(getRedisKey());
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询查询当前redis库下所有key
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; getKeys() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashOperations.keys(getRedisKey());
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断key是否存在redis中
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 传入key的名称
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isKeyExists(String key) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashOperations.hasKey(getRedisKey(), key);
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询当前key下缓存数量
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; count() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashOperations.size(getRedisKey());
   }
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 清空redis
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        Set&lt;/span&gt;&amp;lt;String&amp;gt; set =&lt;span&gt; hashOperations.keys(getRedisKey());
        set.stream().forEach(key &lt;/span&gt;-&amp;gt;&lt;span&gt; hashOperations.delete(getRedisKey(), key));
   }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;测试类&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;　　使用Redis中HASH类型数据结构存储key-value类型的缓存。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisdemoApplicationTests {
​
    @Autowired
    RedisHashUtil&lt;/span&gt;&amp;lt;String&amp;gt;&lt;span&gt; redisHashUtil;
​
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; firstRedisTest() {
        System.out.println(&lt;/span&gt;&quot;***********************测试向Redis插入数据&quot;&lt;span&gt;);
        redisHashUtil.put(&lt;/span&gt;&quot;Mi8&quot;,&quot;XiaoMi&quot;,-1&lt;span&gt;);
        redisHashUtil.put(&lt;/span&gt;&quot;V10&quot;,&quot;Honor&quot;,-1&lt;span&gt;);
        redisHashUtil.put(&lt;/span&gt;&quot;Pro2&quot;,&quot;Smartisan&quot;,-1&lt;span&gt;);
        redisHashUtil.put(&lt;/span&gt;&quot;NEX&quot;,&quot;VIVO&quot;,-1&lt;span&gt;);
​
        System.out.println(&lt;/span&gt;&quot;**********************测试从Redis读取数据，以及查询数据总数&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; count =&lt;span&gt; redisHashUtil.count();
        List&lt;/span&gt;&amp;lt;String&amp;gt; all =&lt;span&gt; redisHashUtil.getAll();
        System.out.println(&lt;/span&gt;&quot;遍历hash中的value,共计&quot;+redisHashUtil.count()+&quot;个品牌。分别为：&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String s:all) {
            System.out.print(s&lt;/span&gt;+&quot;   &quot;&lt;span&gt;);
        }
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
​
        System.out.println(&lt;/span&gt;&quot;***********************测试Redis中是否存在指定数据&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(redisHashUtil.isKeyExists(&quot;Pro2&quot;&lt;span&gt;)){
            String pro2 &lt;/span&gt;= redisHashUtil.get(&quot;Pro2&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;型号为Pro2的手机存在，其品牌为：&quot;+&lt;span&gt;pro2);
        }
​
        System.out.println(&lt;/span&gt;&quot;***********************测试从Redis中删除数据&quot;&lt;span&gt;);
        redisHashUtil.remove(&lt;/span&gt;&quot;Pro2&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!redisHashUtil.isKeyExists(&quot;Pro2&quot;&lt;span&gt;)){
            System.out.println(&lt;/span&gt;&quot;型号为Pro2的手机被移除了&quot;&lt;span&gt;);
        }
​
        System.out.print(&lt;/span&gt;&quot;剩余型号还有：&quot;&lt;span&gt;);
        redisHashUtil.getKeys().forEach(key&lt;/span&gt;-&amp;gt; System.out.print(key+&quot;  &quot;&lt;span&gt;));
        System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
​
        System.out.println(&lt;/span&gt;&quot;***********************测试清空Redis中的hash数据&quot;&lt;span&gt;);
        redisHashUtil.clear();
        System.out.println(&lt;/span&gt;&quot;所有手机型号都被清空，剩余：&quot;+redisHashUtil.count()+&quot;个&quot;&lt;span&gt;);
    }
​
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h6&gt;&lt;span&gt;测试结果&lt;/span&gt;&lt;/h6&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;***********************&lt;span&gt;测试向Redis插入数据
&lt;/span&gt;**********************&lt;span&gt;测试从Redis读取数据，以及查询数据总数
遍历hash中的value,共计4个品牌。分别为：
XiaoMi   Honor   Smartisan   VIVO   
&lt;/span&gt;***********************&lt;span&gt;测试Redis中是否存在指定数据
型号为Pro2的手机存在，其品牌为：Smartisan
&lt;/span&gt;***********************&lt;span&gt;测试从Redis中删除数据
型号为Pro2的手机被移除了
剩余型号还有：Mi8  V10  NEX  
&lt;/span&gt;***********************&lt;span&gt;测试清空Redis中的hash数据
所有手机型号都被清空，剩余：0个&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　看到这的老铁都是真爱，源码已托管到GitHub，欢迎关注。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Oct 2018 12:07:00 +0000</pubDate>
<dc:creator>比脚更长的路</dc:creator>
<og:description>内容 先介绍单机版Redis镜像在Docker下的安装，然后在容器的Redis Shell中进行常用类型String、List、Set、Hash、SortedSet的增删改查操作测试，最后再结合Spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lonelyJay/p/9858301.html</dc:identifier>
</item>
<item>
<title>前端解读面向切面编程(AOP) - 潇湘待雨</title>
<link>http://www.cnblogs.com/pqjwyn/p/9858352.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pqjwyn/p/9858352.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;面向对象(OOP)作为经典的设计范式，对于我们来说可谓无人不知，还记得我们入行起始时那句经典的总结吗-&lt;strong&gt;万事万物皆对象&lt;/strong&gt;。&lt;br/&gt;是的，基于OOP思想封装、继承、多态的特点，我们会自然而然的遵循模块化、组件化的思维来设计开发应用，以到达易维护、可扩展、高复用的目的。&lt;br/&gt;既然OOP这么多优点，那么经常被大家提起的面向切面编程（AOP）是什么回事呢，下面我们就一起来看一下。&lt;/p&gt;
&lt;h2 id=&quot;aop定义&quot;&gt;AOP定义&lt;/h2&gt;
&lt;p&gt;第一步还是要知道aop是什么，先个来自维基百科的解释：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。&lt;br/&gt;侧面的概念源于对面向对象的程序设计的改进，但并不只限于此，它还可以用来改进传统的函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来.&lt;br/&gt;业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过侧面来封装、维护.&lt;br/&gt;这样原本分散在在整个应用程序中的变动就可以很好的管理起来。&lt;/p&gt;
&lt;h4 id=&quot;tip&quot;&gt;tip&lt;/h4&gt;
&lt;p&gt;确实有点那么不太清晰，有点乱。不过在乱之前，我们可以选能理解的部分先看一下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;侧面(也就是切面) 用来描述分散在对象、类或函数中的横切关注点&lt;/strong&gt;。&lt;br/&gt;重点在这，分散在对象中的横切关注点，可以猜一下是什么，应该就是不同对象之间公用的部分&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;侧面的概念源于对面向对象的程序设计的改进，它还可以用来改进传统的函数&lt;/strong&gt;.&lt;br/&gt;AOP 显然不是OOP的替代品，是OOP的一种补充。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。&lt;/strong&gt;&lt;br/&gt;具体到业务项目中来说，主关注点就是业务逻辑了。针对特定领域问题代码的调用，就是AOP要关注的部分&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;简而言之，AOP是针对业务处理过程中的切面(即非业务逻辑部分，例如错误处理，埋点，日志等)进行提取.&lt;/strong&gt;&lt;br/&gt;它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果(目的是降低耦合)。&lt;br/&gt;具体到实现来说就是通过动态的方式将非主关注点部分插入到主关注点(一般是业务逻辑中)&lt;/p&gt;
&lt;p&gt;说了这么多，可能不太明白，还是一起看代码吧。&lt;/p&gt;
&lt;h2 id=&quot;埋点场景&quot;&gt;埋点场景&lt;/h2&gt;
&lt;p&gt;很普遍的这么个场景，需要点击按钮之后进行信息上报。&lt;br/&gt;假设我们有这么个logger的工具，可以进行上报：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const logger = console.log
//引入即可使用
logger('按钮被点击了')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，我们直接撸起来吧：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const doSomething = ()=&amp;gt;{
    console.log('doSomething')
} 
let clickHandler = ()=&amp;gt;{
   logger('doSomething之前')
   // n行代码 
   doSomething() 
   logger('doSomething之后')
   //n 行代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来也没什么的，简单粗暴。&lt;br/&gt;如果有30个按钮，每个业务逻辑不同，都需要埋这个点(假设打点信息一致)。&lt;br/&gt;我们30个函数里面，都要手动写这个方法的话，这也太坑爹了吧。&lt;br/&gt;主要是与业务代码严重耦合，哪天不小心动了点其他内容，手抖误删了，就gg了。&lt;br/&gt;后续维护的时候，简直噩梦。&lt;br/&gt;仔细看一下，这不就是符合AOP的使用前提吗，那么试试AOP吧。&lt;/p&gt;
&lt;h3 id=&quot;关注点划分&quot;&gt;关注点划分&lt;/h3&gt;
&lt;p&gt;根据前面提的，可以划分下关注点。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;业务逻辑(doSomething)&lt;/td&gt;
&lt;td&gt;埋点信息 logger&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;前面提到AOP关注的是步骤具体到例子来说其实就是插入logger的步骤。&lt;br/&gt;插入时机无非时业务逻辑执行之前或者之后的阶段。&lt;br/&gt;具体实现起来也不那么困难&lt;/p&gt;
&lt;h3 id=&quot;实现思路&quot;&gt;实现思路&lt;/h3&gt;
&lt;p&gt;具体到js来说，由于语言本身的特性，天生就具有运行时动态插入逻辑的能力。&lt;br/&gt;重点在于在原函数上增加其他功能并不改变函数本身。&lt;/p&gt;
&lt;p&gt;毕竟函数可以接受一切形式的参数，当然函数也不例外了。&lt;br/&gt;当传入一个函数的时候，我们要对其操作的余地就很大了，&lt;br/&gt;保存原函数，然后利用后续参数加上call或apply，就可以达到我们的目的。&lt;br/&gt;此外为了给函数都增加一个属性，我们在原型上操作就行了。&lt;/p&gt;
&lt;h4 id=&quot;经典before或者after的实现&quot;&gt;经典before或者after的实现&lt;/h4&gt;
&lt;p&gt;网上太多类似实现了，直接看代码好了：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// action 即为我们的侧关注点，即logger
Function.prototype.after = function (action) {
    //保留当前函数，这里this指向运行函数即clickHandler
    var func = this;
    // return 被包装过的函数，这里就可以执行其他功能了。
    // 并且该方法挂在Function.prototype上，
    // 被返回的函数依然具有after属性,可以链式调用
    return function () {
        // 原函数执行，这里不考虑异步
        var result = func.apply(this, arguments);
        // 执行之后的操作
        action.apply(this,arguments);
        // 将执行结果返回
        return result;
    };
};
// before 实现类似，只不过执行顺序差别而已
Function.prototype.before = function (action) {
    var func = this;
    return function () {
        action.apply(this,arguments);
        return func.apply(this, arguments);
    };
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们使用AOP改造之后的代码就如下了:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const doSomething = ()=&amp;gt;{
    console.log('doSomething')
} 
let clickHandler = ()=&amp;gt;{
   // n行代码 
   doSomething() 
   //n 行代码
}
clickHandler = clickHandler.before(()=&amp;gt;{
     logger('doSomething之前')
}).after(()=&amp;gt;{
     logger('doSomething之后')
})
clickHandler() // 执行结果和预期一致&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里就实现了面向切面编程，我们的业务逻辑里面只管业务本身，侧关注点通过这种方式来动态引入，与主逻辑解耦，更加纯净、易于维护。&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;到这里，简单的AOP就介绍完成了。利用这种模式结合我们js本身的特性，可以尝试更多的可能。&lt;br/&gt;例如我们react中常见的HOC、es7的装饰者模式、HOF等，很多时候不得不感叹大牛们思想的精髓，会让我们有种顿悟的感觉。本文抛砖引玉，共同学习啦，对自己是总结和提高，更希望能帮助到需要的小伙伴。&lt;a href=&quot;https://github.com/xiaoxiangdaiyu/blog&quot;&gt;更多文章请移步我的博客&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;参考文章&quot;&gt;参考文章&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://www.alloyteam.com/2013/08/yong-aop-gai-shan-javascript-dai-ma/&quot;&gt;AllyTeam - 用AOP改善javascript代码&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/entry/5a12443951882512a860e93c&quot;&gt;深入浅出 Javascript Decorators 和 AOP 编程&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Oct 2018 11:45:00 +0000</pubDate>
<dc:creator>潇湘待雨</dc:creator>
<og:description>前言 面向对象(OOP)作为经典的设计范式，对于我们来说可谓无人不知，还记得我们入行起始时那句经典的总结吗 万事万物皆对象 。 是的，基于OOP思想封装、继承、多态的特点，我们会自然而然的遵循模块化、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pqjwyn/p/9858352.html</dc:identifier>
</item>
<item>
<title>python——使用ddt过程中遇到的问题及解决方案 - ClaireWang</title>
<link>http://www.cnblogs.com/Clairewang/p/9857921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Clairewang/p/9857921.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在使用DDT数据驱动+HTMLTestRunner输出测试报告时遇到过2个问题：&lt;/p&gt;
&lt;p&gt;　　1、生成的测试报告中，用例名称后有dict() -&amp;gt; new empty dictionary&lt;/p&gt;
&lt;p&gt;       2、使用ddt生成的用例名称无法更改&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、用例名称后有dict() -&amp;gt; new empty dictionary&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;报告中用例名称后有dict() -&amp;gt; new empty dictionary，如图所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/934168/201810/934168-20181026174141517-1724552620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;解决方案：&lt;/strong&gt;这是ddt高版本1.2.0的bug&lt;/p&gt;
&lt;p&gt;　　　　　　　1、cmd先通过pip uninstall ddt 卸载ddt,&lt;/p&gt;
&lt;p&gt;　　　　　　　2、然后再安装一个低版本的ddt，命令pip install ddt==1.1.3&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/934168/201810/934168-20181026174914780-122102182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　安装后再运行程序，结果如下&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/934168/201810/934168-20181026175003503-1922102423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、使用ddt生成的用例名称无法更改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如上图所示测试用例名称都是test_api_index，运行结果无法看出用例执行的是哪条数据，翻阅网上的资料找到一个比较好的方法，讲解比较详细，这段内容来自链接https://www.cnblogs.com/Simple-Small/p/9230382.html&lt;/p&gt;
&lt;p&gt;　　ddt源码中有个函数用来生成用例名称，&lt;strong&gt;mk_test_name&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　它接收两个参数：name 和 value.&lt;/p&gt;
&lt;p&gt;        name：为测试用例的名字。即test_api.&lt;/p&gt;
&lt;p&gt;        value：为测试数据，ddt是处理一组测试数据。而这个value就是这一组数据中的每一个测试数据。&lt;/p&gt;
&lt;p&gt;                 对value的值是有限制的：要么就是单值变量，要么就是元组或者列表并且要求元组和列表中的数据都是单值变量。如(&quot;name&quot;,&quot;port&quot;) 、[&quot;name&quot;,&quot;port&quot;]&lt;/p&gt;
&lt;p&gt;         如果传进来的测试数据，不符合value的要求，那么测试用例名字为：name_index。&lt;/p&gt;
&lt;p&gt;         如果传进来的测试数据，符合value的要求，那么测试用例名字为：name_index_value。如果value为列表或者元组，那么将列表/元组的每个数据依次追加在末尾。&lt;/p&gt;
&lt;p&gt;         比如传进来的name值为test_login，value值为[&quot;name&quot;,&quot;port&quot;]。那最终的测试用例名字是：test_login_01_name_port。&lt;/p&gt;
&lt;p&gt;         如果传进来的name值为test_login，value值为{&quot;userName&quot;:&quot;18500384561&quot;, &quot;password&quot;:&quot;123456&quot;}，那最终的测试用例名字为：test_login_1。&lt;strong&gt;因为它不支持对字典类型的数据处理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;         而我的接口自动化框架中，ddt处理的数据是一列表：列表当中每个数据都为字典。ddt一遍历整个列表，那传给value的值刚好是字典。。&lt;/p&gt;
&lt;p&gt;         所以我得到的测试用例名称就是：test_login_1,test_login_2,test_login_3&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/934168/201810/934168-20181026182452813-1062662693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了让我的测试报告，呈现的更好。那就改改ddt源码，让它能够适应我的框架。&lt;/p&gt;
&lt;p&gt;       考虑两个问题：&lt;/p&gt;
&lt;p&gt;        1、不同接口的测试用例名字如何来？？&lt;/p&gt;
&lt;p&gt;        2、如何让ddt支持对字典的处理？？&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        第一个问题：每一个测试用例主动提供一个用例名字，说明你是什么接口的什么场景用例。比如:接口名_场景名。login_success、login_noPasswd、login_wrongPasswd等。&lt;/p&gt;
&lt;p&gt;　　　　　　　　在我的框架当中，每一个测试用例是一个字典。那么我就在字典中添加一个键值对，case_name=用例名称&lt;/p&gt;
&lt;p&gt;　　第二个问题：在ddt中添加对字典的处理，如果字典中有case_name字段，则将字典中键名为case_name的值作为测试用例名称中的value值。&lt;/p&gt;
&lt;p&gt;       修改后的ddt源码为(红色粗体部分为修改的内容)：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/934168/201810/934168-20181026182426682-2027185033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更改代码后再执行，结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/934168/201810/934168-20181026180014680-1043475154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　喜欢可打赏鼓励下博主：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/934168/201808/934168-20180810183119467-999232961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;注：转载请注明：https://www.cnblogs.com/Clairewang/p/9857921.html&lt;/p&gt;
&lt;p&gt;　　文中第二个问题解决方案来自&lt;a&gt;https://www.cnblogs.com/Simple-Small&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Oct 2018 10:30:00 +0000</pubDate>
<dc:creator>ClaireWang</dc:creator>
<og:description>前言： 在使用DDT数据驱动+HTMLTestRunner输出测试报告时遇到过2个问题： 1、生成的测试报告中，用例名称后有dict() -&gt; new empty dictionary 2、使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Clairewang/p/9857921.html</dc:identifier>
</item>
<item>
<title>Python数据分析--Iris数据集实战 - Star_Zhao</title>
<link>http://www.cnblogs.com/star-zhao/p/9847082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/star-zhao/p/9847082.html</guid>
<description>&lt;p&gt;&lt;span&gt;本次主要围绕Iris数据集进行一个简单的数据分析, 另外在数据的可视化部分进行了重点介绍.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;win8, python3.7, jupyter notebook&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1. 项目背景&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E9%B8%A2%E5%B0%BE%E5%B1%9E/3459868?fr=aladdin&quot; target=&quot;_blank&quot;&gt;鸢尾属&lt;/a&gt;(拉丁学名：Iris L.), 单子叶植物纲, 鸢尾科多年生草本植物, 开的花大而美丽, 观赏价值很高. 鸢尾属约300种, Iris数据集中包含了其中的三种: 山鸢尾(Setosa),  杂色鸢尾(Versicolour), 维吉尼亚鸢尾(Virginica), 每种50个数据, 共含150个数据. 在每个数据包含四个属性: 花萼长度，花萼宽度，花瓣长度，花瓣宽度, 可通过这四个属性预测鸢尾花卉属于 (山鸢尾, 杂色鸢尾, 维吉尼亚鸢尾) 哪一类.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. 数据概览&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;数据来源: https://www.kaggle.com/benhamner/python-data-visualizations/data&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.1 读取数据&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数据为csv文件, 读取数据:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
df_Iris &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iris.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2 查看前/后5行数据&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;前5行&lt;/span&gt;
&lt;span&gt;df_Iris.head()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;后5行&lt;/span&gt;
df_Iris.tail()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181024223112728-1991552180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181024223249839-313883177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过这10行数据也就大致确定数据维度150行X6列以及各特征内的基本信息:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Id: 鸢尾花编号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SepaLengthCm: 花萼长度, 单位cm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SepalWidthCm: 花萼宽度, 单位cm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PetalLengthCm: 花瓣长度, 单位cm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PetalWidthCm; 花瓣宽度, 单位cm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Species: 鸢尾花种类.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.3 查看数据整体信息&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看数据整体信息&lt;/span&gt;
df_Iris.info()
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&amp;lt;class 'pandas.core.frame.DataFrame'&amp;gt;
RangeIndex: 150 entries, 0 to 149
Data columns (total 6 columns):
Id               150 non-null int64
SepalLengthCm    150 non-null float64
SepalWidthCm     150 non-null float64
PetalLengthCm    150 non-null float64
PetalWidthCm     150 non-null float64
Species          150 non-null object
dtypes: float64(4), int64(1), object(1)
memory usage: 7.1+ KB
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;得出信息: 150行, 6列,4个64位浮点数, 1个64位整型, 1个python对象, 数据中无缺失值.&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.4 描述性统计&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
df_Iris.describe()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;花萼长度最小值4.30, 最大值7.90, 均值5.84, 中位数5.80, 右偏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;花萼宽度最小值2.00, 最大值4.40, 均值3.05, 中位数3.00, 右偏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;花瓣长度最小值1.00, 最大值6.90, 均值3.76, 中位数4.35, 左偏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;花瓣宽度最小值0.10, 最大值2.50, 均值1.20, 中位数1.30, 左偏&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按中位数来度量: 花萼长度 &amp;gt; 花瓣长度 &amp;gt; 花萼宽度 &amp;gt; 花瓣宽度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181024224829170-129019716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注意这里是大写的字母O, 不是数字0.&lt;/span&gt;
df_Iris.describe(include =[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]).T
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;总数150, 3个种类, 最大频数为50, 也就是每种都为50个. 注意top里的指的不是Iris-versicolor最多, 是在频数相同的基础上按照字符串长度进行排名.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181024232234044-46470630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以通过这样对每种进行计数:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
df_Iris.Species.value_counts()
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
Iris-versicolor    50
Iris-virginica     50
Iris-setosa        50
Name: Species, dtype: int64
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;通过以上, 大致了解数据的基本信息, 现想把Species特征中的'Iris-'字符去掉, 进入特征工程环节.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. 特征工程&lt;/h2&gt;
&lt;h3&gt;3.1 数据清洗&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;去掉Species特征中的'Iris-'字符.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一种方法: 替换&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; df_Iris['Species']= df_Iris.Species.str.replace('Iris-','')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;第二种方法: 分割&lt;/span&gt;
df_Iris[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]= df_Iris.Species.apply(&lt;span&gt;lambda&lt;/span&gt; x: x.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[1&lt;span&gt;])
df_Iris.Species.unique()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
array(['setosa', 'versicolor', 'virginica'], dtype=object)
&lt;/pre&gt;
&lt;h3&gt;3.2 数据可视化&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://seaborn.pydata.org/&quot; target=&quot;_blank&quot;&gt;Seaborn&lt;/a&gt;是一个python的可视化库, 它基于matplotlib, 这使得它能与pandas紧密结合, 并且提供了高级绘图界面, 能更方便地完成探索性分析.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我想在这个项目上对seaborn多加练习, 因此, 会对这部分内容着重介绍.&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3.2.1 relplot&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; seaborn as sns
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;sns初始化&lt;/span&gt;
&lt;span&gt;sns.set()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置散点图x轴与y轴以及data参数&lt;/span&gt;
sns.relplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalLengthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data =&lt;span&gt; df_Iris)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalLengthCm and SepalWidthCm data analysize&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025144117164-447873225.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;花萼的长度和宽度在散点图上分了两个簇, 而且两者各自都有一定的关系. 鸢尾花又分为三个品种, 不妨看看关于这三个品种的分布.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;hue表示按照Species对数据进行分类, 而style表示每个类别的标签系列格式不一致.&lt;/span&gt;
sns.relplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalLengthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, hue=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, style=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=&lt;span&gt;df_Iris )
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalLengthCm and SepalWidthCm data by Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025144415520-2009153918.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt; 可以看到setosa这种花的花萼长度和宽度有明显的线性关系, 当然其他两种也存在一定的关系, 花萼的属性看完了, 看下花瓣的:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;花瓣长度与宽度分布散点图&lt;/span&gt;
sns.relplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalLengthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, hue=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, style=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=&lt;span&gt;df_Iris )
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalLengthCm and PetalWidthCm data by Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;花的品种和花瓣的长度, 宽度之间存在一定的关系.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025144555376-1928448907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;另外, 还可以对比花萼与花瓣的长度, 花萼与花瓣的宽度之间的关系.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;花萼与花瓣长度分布散点图&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sns.relplot(x='SepalLengthCm', y='PetalLengthCm', hue='Species', style='Species', data=df_Iris )&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;plt.title('SepalLengthCm and PetalLengthCm data by Species')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;花萼与花瓣宽度分布散点图&lt;/span&gt;
sns.relplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, hue=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, style=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=&lt;span&gt;df_Iris )
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalWidthCm and PetalWidthCm data by Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025144731516-472546178.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025144750440-1744272430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;花萼的长度与花瓣的宽度, 花萼的宽度与花瓣的长度之间应当也存在某种关系:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;花萼的长度与花瓣的宽度分布散点图&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sns.relplot(x='SepalLengthCm', y='PetalWidthCm', hue='Species', style='Species', data=df_Iris )&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;plt.title('SepalLengthCm and PetalWidthCm data by Species')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;花萼的宽度与花瓣的长度分布散点图&lt;/span&gt;
sns.relplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalLengthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, hue=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, style=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=&lt;span&gt;df_Iris )
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalWidthCm and PetalLengthCm data by Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025145028471-521742825.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025145209513-1092120147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Id编号与花萼长度, 花萼宽度, 花瓣长度, 花瓣宽度之间有没有关系呢:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;花萼长度与Id之间关系图&lt;/span&gt;
sns.relplot(x=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, y=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SepalLengthCm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hue=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,kind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, data=&lt;span&gt;df_Iris)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalLengthCm and Id data analysize&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;花萼宽度与Id之间关系图&lt;/span&gt;
sns.relplot(x=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, y=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SepalWidthCm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hue=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,kind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, data=&lt;span&gt;df_Iris)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalWidthCm and Id data analysize&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;花瓣长度与Id之间关系图&lt;/span&gt;
sns.relplot(x=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, y=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PetalLengthCm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hue=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,kind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, data=&lt;span&gt;df_Iris)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalLengthCm and Id data analysize&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;花瓣宽度与Id之间关系图&lt;/span&gt;
sns.relplot(x=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, y=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PetalWidthCm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,hue=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,kind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, data=&lt;span&gt;df_Iris)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalWidthCm and Id data analysize&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以得到信息: Id中前50个为setosa, 51到100为versicolour, 101到150为Virginica, 以及每个种类对应属性值的范围, 每个种类中的属性与其对应的Id没有明确的关系.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025143800959-901501471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.2.2 jointplot&lt;span class=&quot;n&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
sns.jointplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalLengthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=df_Iris)&lt;br/&gt;sns.jointplot(x='PetalLengthCm', y='PetalWidthCm', data=df_Iris)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;散点图和直方图同时显示, 可以直观地看出哪组频数最大, 哪组频数最小.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025192314481-1929838315.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025193240529-368620694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于频数的值, 在散点图上数点的话, 显然效率太低, 还易出错, 下面引出distplot&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3.2.3 distplot&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘制直方图, 其中kde=False表示不显示核函数估计图,这里为了更方便去查看频数而设置它为False.&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sns.distplot(df_Iris.SepalLengthCm,bins=8, hist=True, kde=False)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sns.distplot(df_Iris.SepalWidthCm,bins=13, hist=True, kde=False)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sns.distplot(df_Iris.PetalLengthCm, bins=5, hist=True, kde=False)&lt;/span&gt;
sns.distplot(df_Iris.PetalWidthCm, bins=5, hist=True, kde=False)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我这里的分组是按照上面jointplot里的组数进行设置, 现在就很直观地看到各组对应的频数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025222644272-128861498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面我们已经通过describe()方法计算出四个属性所对应的四分位数, 最大值以及最小值等统计量. 这些均是以表格的形式展示, 我们下面就介绍怎么以图样的形式展示四分位数.&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3.2.4 boxplot&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;boxplot所绘制的就是&lt;a href=&quot;https://baike.baidu.com/item/%E7%AE%B1%E5%BD%A2%E5%9B%BE?fromtitle=%E7%AE%B1%E7%BA%BF%E5%9B%BE&amp;amp;fromid=10101649&quot; target=&quot;_blank&quot;&gt;箱线图&lt;/a&gt;, 它能显示出一组数据的最大值, 最小值, 四分位数以及异常点.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于异常点的定义: 区间[Q1-1.5IQR, Q3+1.5IQR]之外的点, 其中Q1下四分位数(25%), Q3上四分位数(75%), IQR=Q3-Q1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在seaborn.boxplot中, 箱线图的画法分两种情况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果数据中无异常点, 那么箱线图的下边缘就是数据中的最小值, 上边缘就是数据中的最大值, 即下图的实线部分(虚线以及红点部分不会显示)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181026010532343-977962076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果数据中有异常点, 那么箱线图的下边缘Limit1指的是区间[Q1-1.5IQR, Q3+1.5IQR]内的最小值, 上边缘Limit2指的是区间内的最大值, 即下图的实线部分(虚线以及红点部分不会显示)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181026012523426-2139386044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;比如数据中的SepalLengthCm属性&lt;/span&gt;
sns.boxplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalLengthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=&lt;span&gt;df_Iris)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;比如数据中的SepalWidthCm属性&lt;/span&gt;
sns.boxplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=df_Iris)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181026014339997-17470113.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181026014315460-1772461450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 为了更直观地对比四个属性之间的关系, 我将四个属性对应的数值合并在新的DataFrame Iris中.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对于每个属性的data创建一个新的DataFrame&lt;/span&gt;
Iris1 = pd.DataFrame({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: np.arange(1,151), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Attribute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalLengthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:df_Iris.SepalLengthCm, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:df_Iris.Species})
Iris2 &lt;/span&gt;= pd.DataFrame({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: np.arange(151,301), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Attribute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:df_Iris.SepalWidthCm, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:df_Iris.Species})
Iris3 &lt;/span&gt;= pd.DataFrame({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: np.arange(301,451), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Attribute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalLengthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:df_Iris.PetalLengthCm, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:df_Iris.Species})
Iris4 &lt;/span&gt;= pd.DataFrame({&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: np.arange(451,601), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Attribute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:df_Iris.PetalWidthCm, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:df_Iris.Species})
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将四个DataFrame合并为一个.&lt;/span&gt;
Iris =&lt;span&gt; pd.concat([Iris1, Iris2, Iris3, Iris4])
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘制箱线图&lt;/span&gt;
sns.boxplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Attribute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=Iris)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对下图做一下简单分析: 就中位数来说, SepalLenthCm &amp;gt; PetalLengthCm &amp;gt; SepalWidthCm &amp;gt; PetalWidthCm; 就波动程度来说, PetalLengthCm &amp;gt; PetalWidthCm &amp;gt; SepalLengthCm &amp;gt; SepalWidthCm; 就异常值来说, 只有SepalWidthCm中存在异常值. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181025234449190-1720175004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将鸢尾花的三种种类再加入到箱线图中:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
sns.boxplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Attribute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,hue=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=Iris)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样就很容易能够对比三个种类在四个属性中的表现状况:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了SepalWidthCm属性外, 中位数在其他属性的三种花中均表现为: Virginica &amp;gt; versicolour &amp;gt;  setosa&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了setosa种类外, 中位数在其他种类的四个属性中均表现为: SepalLengthCm &amp;gt; PetalLengthCm &amp;gt; SepalWidthCm &amp;gt; PetalWidthCm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181026125834136-108811578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面将介绍一种更高级的四分位数展示方式: violinplot&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3.2.5 violinplot&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;violinplot绘制的是琴图, 是箱线图与核密度图的结合体, 既可以展示四分位数, 又可以展示任意位置的密度.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
sns.violinplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Attribute&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, hue=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=Iris )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181026163920621-25119656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中具体细节显示不是很明显, 对于PetalWidthCm都有些模糊了, 下面将拆分成四个小图, 另外为了和箱线图对比, 将箱线图也绘制出来.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;花萼长度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sns.boxplot(x='Species', y='SepalLengthCm', data=df_Iris)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sns.violinplot(x='Species', y='SepalLengthCm', data=df_Iris)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; plt.title('SepalLengthCm data by Species')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;花萼宽度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sns.boxplot(x='Species', y='SepalWidthCm', data=df_Iris)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sns.violinplot(x='Species', y='SepalWidthCm', data=df_Iris)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; plt.title('SepalWidthCm data by Species')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;花瓣长度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sns.boxplot(x='Species', y='PetalLengthCm', data=df_Iris)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sns.violinplot(x='Species', y='PetalLengthCm', data=df_Iris)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; plt.title('PetalLengthCm data by Species')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;花瓣宽度&lt;/span&gt;
sns.boxplot(x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=&lt;span&gt;df_Iris)
sns.violinplot(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, data=&lt;span&gt;df_Iris)
plt.title(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalWidthCm data by Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以明显看出, 琴图中的白点就是中位数, 黑色矩形的上短边则是上四分位数Q3, 黑色下短边则是下四分位数Q1;  而贯穿矩形的黑线的上端点则代表最小非异常值, 下端点则代表最大非异常值; 黑色矩形外部形状则表示核概率密度估计.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181026164815014-246723841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后介绍一种图形, 它能直接显示各个特征之间的不同关系&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3.2.6 pairplot&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除Id特征, 绘制分布图&lt;/span&gt;
sns.pairplot(df_Iris.drop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, axis=1), hue=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存图片, 由于在jupyter notebook中太大, 不能一次截图&lt;/span&gt;
plt.savefig(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pairplot.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469712/201810/1469712-20181026172519297-5455798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综上, 花萼的长度, 花萼的宽度, 花瓣的长度, 花瓣的宽度与花的种类之间均存在一定的相关性, 且对于这三个种类的分布, satosa在任何一种分布中较其他两者集中; 就同一种花的平均水平来看, 其花萼的长度最长, 花瓣的宽度最短; 就同一属性的平均水平来看, 三种花在除了花萼的宽度外的属性中平均水平均表现为: Virginica &amp;gt; versicolour &amp;gt;  setosa.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4. 构建模型&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;采用决策树分类算法.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.tree &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DecisionTreeClassifier
&lt;br/&gt;X &lt;/span&gt;= df_Iris[[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalLengthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SepalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalLengthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PetalWidthCm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]]
y &lt;/span&gt;= df_Iris[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将数据按照8:2的比例随机分为训练集, 测试集&lt;/span&gt;
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化决策树模型&lt;/span&gt;
dt =&lt;span&gt; DecisionTreeClassifier()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练模型&lt;/span&gt;
&lt;span&gt;dt.fit(X_train, y_train)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用测试集评估模型的好坏&lt;/span&gt;
dt.score(X_test, y_test)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
0.9666666666666667
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;在测试集上准确率达到97%,也还不错, 此次没有对决策树模型设置参数, 如果参数设置好了, 想必准确率会更高.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kaggle.com/benhamner/python-data-visualizations/notebook&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.kaggle.com/benhamner/python-data-visualizations/notebook&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 26 Oct 2018 10:25:00 +0000</pubDate>
<dc:creator>Star_Zhao</dc:creator>
<og:description>本次主要围绕Iris数据集进行一个简单的数据分析, 另外在数据的可视化部分进行了重点介绍. 环境 win8, python3.7, jupyter notebook 正文 1. 项目背景 鸢尾属(拉丁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/star-zhao/p/9847082.html</dc:identifier>
</item>
</channel>
</rss>