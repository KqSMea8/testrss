<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>整合了一个命令行程序的框架(1) - 陈宏博</title>
<link>http://www.cnblogs.com/huaface/p/8609662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huaface/p/8609662.html</guid>
<description>&lt;p&gt;接上一篇&lt;a href=&quot;http://www.cnblogs.com/huaface/p/8567904.html&quot;&gt;整合了一个命令行程序的框架&lt;/a&gt;我增加了一点功能&lt;/p&gt;
&lt;h3 id=&quot;aop和定时任务&quot;&gt;aop和定时任务&lt;/h3&gt;
&lt;p&gt;这次更新主要增加了审计日志还有集成了hangfire做定时任务&lt;/p&gt;
&lt;ol readability=&quot;12&quot;&gt;&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;先来看审计日志部分,审计日志主要是使用了Windsor的动态代理功能.每一个添加了Audited特性的方法或者类,在方法被调用时会输出参数和值.使用时只要在需要审计的service上增加Audited特性即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Audited]
public class DemoService : LunaServiceBase, IDemoService
{
    public string GetMessage(string name)
    {
        Logger.Info($&quot;GetMessage {name}&quot;);
        return &quot;测试&quot;;
    }

    public string GetDemo(DemoModel model)
    {
        var msg = $&quot;{model.Name}: {model.Age}&quot;;
        return msg;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时在start上增加了一个可选参数.目前只有一个设置项,就是是否开启审计日志功能.如果不开启的话,标记了aduited的service也不会输出审计日志&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;定时任务的用法和之前的还是有一些区别.如要体现在runner上.之前的runner要继承LunaRunnerBase,如果使用hangfire的话要继承LunaHangfireRunnerBase.同时在run方法里增加定时任务&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Runner : LunaHangfireRunnerBase
{
    public override void Run()
    {
        RecurringJob.AddOrUpdate&amp;lt;IJobService&amp;gt;(service =&amp;gt; service.OutputLog(), Cron.Minutely);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动的方法还是和之前一样的使用starter即可.这里有一点需要注意一下.一定要在调用starter的run方法之前配置好hangfire&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GlobalConfiguration.Configuration.UseSqlServerStorage(&quot;default&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里推荐使用topshelf之类的框架把程序搞成服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;p&gt;和上一版对比的话,这次主要的变更在starter类构造函数中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Starter(Type runnerType, StarterOption option)
{
    Container = new WindsorContainer();
    Container.Kernel.ComponentRegistered += (key, handler) =&amp;gt;
    {
        if (option.DisableAudit) return;

        if (handler.ComponentModel.Implementation.IsDefined(typeof(AuditedAttribute), true))
        {
            handler.ComponentModel.Interceptors.Add(new InterceptorReference(typeof(AuditingInterceptor)));
        }
    };

    Container.Register(
        Classes.FromAssemblyInThisApplication(runnerType.Assembly)
            .IncludeNonPublicTypes()
            .BasedOn&amp;lt;ITransientDependency&amp;gt;()
            .WithServiceAllInterfaces()
            .If(type =&amp;gt; !type.IsGenericTypeDefinition)
            .WithService.Self()
            .WithService.DefaultInterfaces()
            .LifestyleTransient()
    );

    Container.Register(
        Classes.FromAssemblyInThisApplication(runnerType.Assembly)
            .IncludeNonPublicTypes()
            .BasedOn&amp;lt;ISingletonDependency&amp;gt;()
            .If(type =&amp;gt; !type.IsGenericTypeDefinition)
            .WithService.Self()
            .WithService.DefaultInterfaces()
            .LifestyleSingleton()
    );

    Container.Register(
        Classes.FromAssemblyInThisApplication(runnerType.Assembly)
            .IncludeNonPublicTypes()
            .BasedOn&amp;lt;IInterceptor&amp;gt;()
            .If(type =&amp;gt; !type.IsGenericTypeDefinition)
            .WithService.Self()
            .LifestyleTransient()
    );

    Container.Register(
        Component.For&amp;lt;Starter&amp;gt;().Instance(this).LifestyleSingleton()
    );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新增注册了ComponentRegistered事件.在组件注册ioc完成时检测了组件是否声明了AuditedAttribute特性,如果有声明的话就会给组件增加一个拦截器实现审计日志.&lt;/p&gt;
&lt;p&gt;另外就是把starter自己也注册进了ioc,这其实是为了替换hangfire的JobActivator时使用ioc容器.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class LunaHangfireRunnerBase : LunaRunnerBase
{
    private BackgroundJobServer _backgroundJobServer;
    public Starter Starter { get; set; }
    public override void Init()
    {
        base.Init();
        JobActivator.Current = new WindsorJobActivator(Starter.Container.Kernel);
        _backgroundJobServer = new BackgroundJobServer();
    }

    public override void Stop()
    {
        _backgroundJobServer.Dispose();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到LunaHangfireRunnerBase类的属性注入了starter.本来考虑构造注入的,但是使用构造注入的话,继承这个类的runner在代码上就会看起来不是很纯洁,所以放弃了&lt;/p&gt;
&lt;p&gt;GitHub: &lt;a href=&quot;https://github.com/lun3322/Luna.Service&quot; class=&quot;uri&quot;&gt;https://github.com/lun3322/Luna.Service&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有完整的代码和例子,没写单元测试大家凑合看吧.欢迎star&lt;/p&gt;
&lt;p&gt;NuGet1: Install-Package Luna.Service&lt;/p&gt;
&lt;p&gt;NuGet2: Install-Package Luna.Service.Nlog&lt;/p&gt;
&lt;p&gt;NuGet2: Install-Package Luna.Service.Hangfire&lt;/p&gt;
</description>
<pubDate>Tue, 20 Mar 2018 07:41:00 +0000</pubDate>
<dc:creator>陈宏博</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huaface/p/8609662.html</dc:identifier>
</item>
<item>
<title>python 全栈开发，Day3(正式) - 肖祥</title>
<link>http://www.cnblogs.com/xiao987334176/p/8609471.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiao987334176/p/8609471.html</guid>
<description>&lt;h2&gt;一、基础数据类型&lt;/h2&gt;
&lt;p&gt;基础数据类型，有7种类型，&lt;em id=&quot;__mceDel&quot;&gt;存在即合理。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.int 整数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要是做运算的 。比如加减乘除，幂，取余  + - * / ** %...&lt;br/&gt;&lt;strong&gt;2.bool 布尔值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;判断真假以及作为条件变量&lt;br/&gt;&lt;strong&gt;3.str 字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储少量的数据。‘太白’,'password'... 操作简单，便于传输。&lt;br/&gt;&lt;strong&gt;4.list 列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; [1,2,'alex',{name:'zhang'}] 存放大量的数据，大量的数据放到列表中便于操作&lt;br/&gt;&lt;strong&gt;5.tuple 元组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也叫只读列表。(1,2,'alex',{name:'zhang'}) 一些重要的数据或者不想被更改的数据，使用元组&lt;br/&gt;&lt;strong&gt;6.dict 字典&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;{‘name_list’:'[zhang,lisi]'},存储关系型的数据,查询速度非常快，二分查找。&lt;br/&gt;&lt;strong&gt;7.set 集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;交集，并集，差集...&lt;/p&gt;

&lt;p&gt;分别举例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int整形&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
i = 4
#转化成二进制的最小位数
print(i.bit_length())
'''
1   0000 0001
1   0000 0010
3   0000 0011
4   0000 0100
'''
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出： 3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;str&lt;/strong&gt; 这里就不举了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bool 布尔值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说一下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据类型转换：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;int --&amp;gt; str&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
n = str(1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出： 1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int --&amp;gt; bool&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
n = bool(1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出： True&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;str --&amp;gt; bool&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
n = bool('')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出： False&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;空字符串是False，其他都是True &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;str 字符串索引与切片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先讲索引&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;字符串是有序的,有索引的,索引从0开始,默认取值是从左至右&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = 'python是最好的语言'
#取第一个字符
s1 = s[0]
#取索引值为2的元素
s2 = s[2]
#最后一个
s3 = s[-1]
print(s1)
print(s2)
print(s3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出：&lt;/p&gt;
&lt;p&gt;p&lt;br/&gt;t&lt;br/&gt;言&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;切片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语法： &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[起始索引：截止索引：步长]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;步长默认为1，表示从头开始取&lt;br/&gt;切片，也就是取连续的多个值&lt;br/&gt;&lt;span&gt;&lt;strong&gt;切片原则，顾头不顾尾&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;什么意思？举例说明&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = 'python是最好的语言'
s1 = s[0:2]
print(s1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出：&lt;/p&gt;
&lt;p&gt;py&lt;/p&gt;

&lt;p&gt;先看字符串的索引对应&lt;/p&gt;
&lt;p&gt;p  y  t  h  o  n&lt;/p&gt;
&lt;p&gt;↓  ↓  ↓  ↓   ↓  ↓&lt;/p&gt;
&lt;p&gt;0 1  2  3  4  5&lt;/p&gt;

&lt;p&gt;我是取 0～2 的，发现t没有显示出来，因为根据切片原则，末尾的不显示&lt;/p&gt;
&lt;p&gt;如果想输出末尾的，需要加1即可。比如s[0:3]&lt;/p&gt;

&lt;p&gt;中文字符串也是同样的，一个中文字，即一个索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = 'python是最好的语言'
s1 = s[7:9]
print(s1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出：&lt;/p&gt;
&lt;p&gt;最好&lt;/p&gt;

&lt;p&gt;全取&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = 'python是最好的语言'
s1 = s[:]
print(s1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出：&lt;/p&gt;
&lt;p&gt;python是最好的语言&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;切片会产生新的变量&lt;/span&gt;，在内存中，原字符串和切片后的字符串，是2个变量&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;s4 = s[:] 虽然结果是一样的，但它是2个变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对字符串操作，都会产生新的变量，除了赋值以外。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;取最后5个字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = 'python是最好的语言'
s1 = s[-5:]
print(s1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出：&lt;/p&gt;
&lt;p&gt;最好的语言&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步长&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认步长为1&lt;/p&gt;
&lt;p&gt;隔一个取1个，步长为2&lt;/p&gt;
&lt;p&gt;反向取值，也就是从后向前取，步长为-1&lt;/p&gt;

&lt;p&gt;隔1个，取一个&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = 'python是最好的语言'
s1 = s[::2]
print(s1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出：&lt;/p&gt;
&lt;p&gt;pto是好语&lt;/p&gt;

&lt;p&gt;反向取5个&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = 'python是最好的语言'
s1 = s[:-5:-1]
print(s1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出：&lt;/p&gt;
&lt;p&gt;言语的好&lt;/p&gt;

&lt;p&gt;反向全取&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = 'python是最好的语言'
s1 = s[::-1]
print(s1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出：&lt;/p&gt;
&lt;p&gt;言语的好最是nohtyp&lt;/p&gt;

&lt;p&gt;字符串常用操作方法&lt;/p&gt;
&lt;p&gt;用以下✴表示使用程度&lt;/p&gt;
&lt;p&gt;✴✴✴ 非常&lt;/p&gt;
&lt;p&gt;✴✴ 常用&lt;/p&gt;
&lt;p&gt;✴ 一般&lt;/p&gt;

&lt;p&gt;✴✴✴capitalize()  首字母大写，其他字母小写&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = 'laoshi'
s1 = s.capitalize()
print(s1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出：&lt;/p&gt;
&lt;p&gt;Laoshi&lt;/p&gt;

&lt;p&gt;✴✴✴upper()  全部大写&lt;/p&gt;
&lt;p&gt;✴✴✴lower()  全部小写&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = 'laoshi'
s1 = s.upper()
s2 = s.lower()
print(s1)
print(s2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行输出：&lt;/p&gt;
&lt;p&gt;LAOSHI&lt;br/&gt;laoshi&lt;/p&gt;

</description>
<pubDate>Tue, 20 Mar 2018 07:19:00 +0000</pubDate>
<dc:creator>肖祥</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiao987334176/p/8609471.html</dc:identifier>
</item>
<item>
<title>.net core实现redisClient - YSWALLE</title>
<link>http://www.cnblogs.com/yswenli/p/8608661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yswenli/p/8608661.html</guid>
<description>&lt;p&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　最近工作上有需要使用redis，于是便心血来潮打算自己写一个C#客户端。经过几天的努力，目前该客户端已经基本成型，下面简单介绍一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通信协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　要想自行实现redisClient，则必须先要了解Redis的socket能信协议。新版统一请求协议在 Redis 1.2 版本中引入， 并最终在 Redis 2.0 版本成为 Redis 服务器通信的标准方式。在这个协议中， 所有发送至 Redis 服务器的参数都是二进制安全（binary safe）的。&lt;/p&gt;
&lt;p&gt;　　以下是这个协议的一般形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
*&amp;lt;参数数量&amp;gt; CR LF
$&amp;lt;参数 1 的字节数量&amp;gt; CR LF
&amp;lt;参数 1 的数据&amp;gt; CR LF
...
$&amp;lt;参数 N 的字节数量&amp;gt; CR LF
&amp;lt;参数 N 的数据&amp;gt; CR LF
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注：命令本身也作为协议的其中一个参数来发送。举个例子， 以下是一个命令协议的打印版本：&lt;/p&gt;
&lt;div class=&quot;highlight-python&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; *&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; $&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;SET
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; $&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;mykey
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; $&lt;span&gt;7&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; myvalue
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个命令的实际协议值如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;highlight-python&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*3\r\n$3\r\nSET\r\n$5\r\nmykey\r\n$7\r\nmyvalue\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　稍后看到， 这种格式除了用作命令请求协议之外， 也用在命令的回复协议中： 这种只有一个参数的回复格式被称为&lt;strong&gt;批量回复（Bulk Reply）&lt;/strong&gt;。统一协议请求原本是用在回复协议中， 用于将列表的多个项返回给客户端的， 这种回复格式被称为&lt;strong&gt;多条批量回复（Multi Bulk Reply）&lt;/strong&gt;。一个多条批量回复以 &lt;tt class=&quot;docutils literal&quot;&gt;*&amp;lt;argc&amp;gt;\r\n&lt;/tt&gt; 为前缀， 后跟多条不同的批量回复， 其中 &lt;tt class=&quot;docutils literal&quot;&gt;argc&lt;/tt&gt; 为这些批量回复的数量。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　Redis 命令会返回多种不同类型的回复。一个状态回复（或者单行回复，single line reply）是一段以 &lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;&quot;+&quot;&lt;/span&gt;&lt;/tt&gt; 开始、 &lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;&quot;\r\n&quot;&lt;/span&gt;&lt;/tt&gt; 结尾的单行字符串。通过检查服务器发回数据的第一个字节， 可以确定这个回复是什么类型：&lt;/p&gt;
&lt;ul class=&quot;simple&quot;&gt;&lt;li&gt;状态回复（status reply）的第一个字节是 &lt;tt class=&quot;docutils literal&quot;&gt;&quot;+&quot;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;错误回复（error reply）的第一个字节是 &lt;tt class=&quot;docutils literal&quot;&gt;&quot;-&quot;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;整数回复（integer reply）的第一个字节是 &lt;tt class=&quot;docutils literal&quot;&gt;&quot;:&quot;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;批量回复（bulk reply）的第一个字节是 &lt;tt class=&quot;docutils literal&quot;&gt;&quot;$&quot;&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;多条批量回复（multi bulk reply）的第一个字节是 &lt;tt class=&quot;docutils literal&quot;&gt;&quot;*&quot;&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;.net Core Socket&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　说起socket，就不得不说IOCP了，这个方案本身就是为了解决多连接、高并发而设计的；但是话又说回来，任何方案都有局限性，不可能解决所有问题；这里不去讨论用在这里是否合适，反正本人就是想这么试一把：用一个简单的ioc模式实现&lt;a href=&quot;https://github.com/yswenli/SAEA/tree/master/Src/SAEA.Sockets&quot; target=&quot;_blank&quot;&gt;SAEA.Socket&lt;/a&gt;，并为此设定各种场景，反过来优化&lt;a href=&quot;https://github.com/yswenli/SAEA/tree/master/Src/SAEA.Sockets&quot; target=&quot;_blank&quot;&gt;SAEA.Socket&lt;/a&gt;本身。下面是一段服务器接收连接的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ProcessAccept(SocketAsyncEventArgs args)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (args == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 args = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketAsyncEventArgs();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 args.Completed +=&lt;span&gt; ProcessAccepted;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 args.AcceptSocket = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_listener.AcceptAsync(args))
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                ProcessAccepted(_listener, args);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 项目结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在网上找到&lt;a href=&quot;http://doc.redisfans.com/&quot; target=&quot;_blank&quot;&gt;redis的命令&lt;/a&gt;文档后，本人觉的准备工作差不多了，可以初步定一下项目结构：&lt;/p&gt;
&lt;p&gt;　　Core：定义的是redisclient相关最基本的业务&lt;/p&gt;
&lt;p&gt;　　Interface：定义的是一些需要抽象出来的接口&lt;/p&gt;
&lt;p&gt;　　Model：定义的是redis的数据模型及其请求、回复的类型枚举&lt;/p&gt;
&lt;p&gt;　　Net:这里就是将继承实现&lt;a href=&quot;https://github.com/yswenli/SAEA/tree/master/Src/SAEA.Sockets&quot; target=&quot;_blank&quot;&gt;SAEA.Socket&lt;/a&gt;而来的RedisConnection通信基础&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令解码器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过前面的准备工作了解到redisClient的关键在于命令的编解码，至于高大上算法或redis官方算法的实现，本人没有去详细了解，一冲动就自行实现了自定义版的解码器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Coder(RequestType commandName, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] @params)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            _autoResetEvent.WaitOne();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             _commandName =&lt;span&gt; commandName;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             sb.AppendLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; @params.Length);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; param &lt;span&gt;in&lt;/span&gt;&lt;span&gt; @params)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 sb.AppendLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; param.Length);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                sb.AppendLine(param);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sb.ToString();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResponseData Decoder()
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ResponseData();
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; command = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; error = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; len = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (_commandName)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.PING:
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;                     command =&lt;span&gt; BlockDequeue();
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (GetStatus(command, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error))
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.OK;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;                         result.Data = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PONG&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.Error;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;                         result.Data =&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.AUTH:
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SELECT:
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SLAVEOF:
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SET:
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.DEL:
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.HSET:
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.HDEL:
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.LSET:
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;                     command =&lt;span&gt; BlockDequeue();
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (GetStatus(command, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error))
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.OK;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                         result.Data = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.Error;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                         result.Data =&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.TYPE:
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                     command =&lt;span&gt; BlockDequeue();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (GetStatusString(command, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg))
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.OK;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.Error;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                     result.Data =&lt;span&gt; msg;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.GET:
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.GETSET:
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.HGET:
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.LPOP:
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.RPOP:
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SRANDMEMBER:
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SPOP:
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                     len = GetWordsNum(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (len == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.Empty;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                         result.Data =&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.String;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                         result.Data +=&lt;span&gt; BlockDequeue();
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.KEYS:
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.HKEYS:
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.LRANGE:
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SMEMBERS:
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                     result.Type =&lt;span&gt; ResponseType.Lines;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; rn = GetRowNum(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(error))
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.Error;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                         result.Data =&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再尝试读取一次，发现有回车行出现&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (rn == -&lt;span&gt;1&lt;/span&gt;) rn = GetRowNum(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(error))
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.Error;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                         result.Data =&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (rn &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; rn; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                             len = GetWordsNum(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                            sb.AppendLine(BlockDequeue());
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                     result.Data =&lt;span&gt; sb.ToString();
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.HGETALL:
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.ZRANGE:
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.ZREVRANGE:
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                     result.Type =&lt;span&gt; ResponseType.KeyValues;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                     sb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                     rn = GetRowNum(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(error))
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.Error;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                         result.Data =&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (rn &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; rn; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                             len = GetWordsNum(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;                            sb.AppendLine(BlockDequeue());
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;                     result.Data =&lt;span&gt; sb.ToString();
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.DBSIZE:
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.EXISTS:
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.EXPIRE:
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.PERSIST:
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SETNX:
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.HEXISTS:
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.HLEN:
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.LLEN:
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.LPUSH:
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.RPUSH:
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.LREM:
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SADD:
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SCARD:
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SISMEMBER:
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SREM:
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.ZADD:
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.ZCARD:
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.ZCOUNT:
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.ZREM:
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.PUBLISH:
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; val = GetValue(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(error))
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.Error;
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                         result.Data =&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (val == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.Empty;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;162&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.OK;
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;                     result.Data =&lt;span&gt; val.ToString();
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.INFO:
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; rnum = GetWordsNum(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(error))
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;                         result.Type =&lt;span&gt; ResponseType.Error;
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;                         result.Data =&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; info = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;                     &lt;span&gt;while&lt;/span&gt; (info.Length &amp;lt;&lt;span&gt; rnum)
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;                         info +=&lt;span&gt; BlockDequeue();
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;                     result.Type =&lt;span&gt; ResponseType.String;
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;                     result.Data =&lt;span&gt; info;
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.SUBSCRIBE:
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; r = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;                     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (IsSubed)
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;                         r =&lt;span&gt; BlockDequeue();
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (r == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;                             result.Type =&lt;span&gt; ResponseType.Sub;
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;                            BlockDequeue();
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;                             result.Data =&lt;span&gt; BlockDequeue();
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;                            BlockDequeue();
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;                             result.Data +=&lt;span&gt; BlockDequeue();
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;                             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt;&lt;span&gt; RequestType.UNSUBSCRIBE:
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; rNum = GetRowNum(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; wNum = GetWordsNum(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; &lt;span&gt;                    BlockDequeue();
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;                     wNum = GetWordsNum(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; channel =&lt;span&gt; BlockDequeue();
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; vNum = GetValue(BlockDequeue(), &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;                     IsSubed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;            _autoResetEvent.Set();
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;命令的封装与测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　有了socket、redisCoder之后，现在就可以按照官方的redis命令来进行.net core的封装了。本人将这些操作封装到RedisClient、RedisDataBase两个类中，然后又想到连接复用的问题，简单实现了一个连接池RedisClientFactory的类。这样一来就可以好好的来实验一把，看看之前的设想最终能不能实现了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_2c786575-5ecc-493b-b040-060c5b62e79f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2c786575-5ecc-493b-b040-060c5b62e79f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2c786575-5ecc-493b-b040-060c5b62e79f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***************************************************************************
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;*Copyright (c) 2018 Microsoft All Rights Reserved.
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;*CLR版本： 4.0.30319.42000
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;*机器名称：WENLI-PC
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;*公司名称：Microsoft
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;*命名空间：SAEA.RedisSocketTest
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;*文件名： Program
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;*版本号： V1.0.0.0
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;*唯一标识：3d4f939c-3fb9-40e9-a0e0-c7ec773539ae
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;*当前的用户域：WENLI-PC
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;*创建人： yswenli
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;*电子邮箱：wenguoli_520@qq.com
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;*创建时间：2018/3/17 10:37:15
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;*描述：
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;*=====================================================================
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;*修改标记
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;*修改时间：2018/3/19 10:37:15
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;*修改人： yswenli
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;*版本号： V1.0.0.0
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;*描述：
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;****************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; SAEA.Commom;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; SAEA.RedisSocket;
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SAEA.RedisSocketTest
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;             ConsoleHelper.Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SAEA.RedisSocketTest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;             ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入ip:port连接RedisServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; ipPort =&lt;span&gt; ConsoleHelper.ReadLine();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(ipPort))
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 ipPort = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1:6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             RedisClient redisClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisClient(ipPort);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;            redisClient.Connect(); 
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;redisClient.Connect(&quot;wenli&quot;); &lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; info =&lt;span&gt; redisClient.Info();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (info.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NOAUTH Authentication required.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                     ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入redis连接密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; auth =&lt;span&gt; ConsoleHelper.ReadLine();
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(auth))
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                         auth = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yswenli&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; redisClient.Auth(auth);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (a.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;                        ConsoleHelper.WriteLine(a);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;redisConnection.SlaveOf();
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;redisConnection.Ping();&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt;             redisClient.Select(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ConsoleHelper.WriteLine(redisConnection.Type(&quot;key0&quot;));&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;             ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dbSize:{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, redisClient.DBSize().ToString());
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;             RedisOperationTest(redisClient, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;            ConsoleHelper.ReadLine();
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RedisOperationTest(&lt;span&gt;object&lt;/span&gt; sender, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; status)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;             RedisClient redisClient =&lt;span&gt; (RedisClient)sender;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (status)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接redis服务器成功！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt;                 &lt;span&gt;#region&lt;/span&gt; key value
&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回车开始kv插值操作...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                ConsoleHelper.ReadLine();
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                     redisClient.GetDataBase().Set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + i, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;redisConnection.GetDataBase().Exists(&quot;key0&quot;);&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kv插入完成...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回车开始获取kv值操作...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;                ConsoleHelper.ReadLine();
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; keys = redisClient.GetDataBase().Keys().Data.ToArray(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; keys)
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; val =&lt;span&gt; redisClient.GetDataBase().Get(key);
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                     ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get val:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; val);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取kv值完成...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回车开始开始kv移除操作...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;                ConsoleHelper.ReadLine();
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; keys)
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;                    redisClient.GetDataBase().Del(key);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;移除kv值完成...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                 &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;                 &lt;span&gt;#region&lt;/span&gt; hashset
&lt;span&gt;126&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; hid = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wenli&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; 
&lt;span&gt;128&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回车开始HashSet插值操作...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;                ConsoleHelper.ReadLine();
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                     redisClient.GetDataBase().HSet(hid, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + i, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HashSet插值完成...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回车开始HashSet插值操作...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;                ConsoleHelper.ReadLine();
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; hkeys =&lt;span&gt; redisClient.GetDataBase().GetHKeys(hid).Data.ToArray();
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; hkey &lt;span&gt;in&lt;/span&gt;&lt;span&gt; hkeys)
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; val =&lt;span&gt; redisClient.GetDataBase().HGet(hid, hkey);
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;                     ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HGet val:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; val.Data);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; hall = redisClient.GetDataBase().HGetAll(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wenli&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HashSet查询完成...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; 
&lt;span&gt;148&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回车开始HashSet移除操作...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;                ConsoleHelper.ReadLine();
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; hkey &lt;span&gt;in&lt;/span&gt;&lt;span&gt; hkeys)
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;                    redisClient.GetDataBase().HDel(hid, hkey);
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HashSet移除完成...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; 
&lt;span&gt;156&lt;/span&gt; 
&lt;span&gt;157&lt;/span&gt;                 &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;158&lt;/span&gt; 
&lt;span&gt;159&lt;/span&gt; 
&lt;span&gt;160&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;redisConnection.GetDataBase().Suscribe((c, m) =&amp;gt;
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    ConsoleHelper.WriteLine(&quot;channel:{0} msg:{1}&quot;, c, m);
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    redisConnection.GetDataBase().UNSUBSCRIBE(c);
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;}, &quot;c39654&quot;);&lt;/span&gt;
&lt;span&gt;165&lt;/span&gt; 
&lt;span&gt;166&lt;/span&gt; 
&lt;span&gt;167&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试完成！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;                 ConsoleHelper.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接失败！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　经过上面的代码测试，使用redis-cli工具进行monitor命令监控发现——搞定了！另外源码本人已发到github上面了，SAEA.RedisSocket的详细可查看：&lt;a href=&quot;https://github.com/yswenli/SAEA/tree/master/Src/SAEA.RedisSocket&quot; target=&quot;_blank&quot;&gt;https://github.com/yswenli/SAEA/tree/master/Src/SAEA.RedisSocket&lt;/a&gt;&lt;a href=&quot;https://github.com/yswenli/SAEA/tree/master/Src/SAEA.RedisSocketTest&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;转载请标明本文来源：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: .net core实现redisClient&quot; href=&quot;http://www.cnblogs.com/yswenli/p/8608661.html%20&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/yswenli/p/8608661.html&lt;/a&gt; &lt;br/&gt;更多内容欢迎star作者的github：&lt;a href=&quot;https://github.com/yswenli/SAEA&quot; target=&quot;_blank&quot;&gt;https://github.com/yswenli/SAEA&lt;/a&gt;&lt;br/&gt;如果发现本文有什么问题和任何建议，也随时欢迎交流~&lt;/p&gt;
</description>
<pubDate>Tue, 20 Mar 2018 05:53:00 +0000</pubDate>
<dc:creator>YSWALLE</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yswenli/p/8608661.html</dc:identifier>
</item>
<item>
<title>Facebook兆级别图片存储及每秒百万级别图片查询原理 - peiyu1988</title>
<link>http://www.cnblogs.com/peiyu1988/p/8608194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peiyu1988/p/8608194.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Facebook(后面简称fb)是世界最大的社交平台，需要存储的数据时刻都在剧增（占比最大为图片，每天存储约&lt;span&gt;20亿&lt;/span&gt;张，大概是微信的三倍）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么问题来了，fb是如何存储兆级别的图片？并且又是如何处理每秒百万级别的图片查询？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文以简单易懂，图文并茂的方式来解释其中的原理，并不涉及空洞，难解的框架，也没有大篇章的废话铺陈，只有&lt;span&gt;痛点与反思&lt;/span&gt;；就如同fb的架构师所说：&lt;span&gt;fb的存储架构就像高速公路上换轮胎，没有最完美的设计，我们最求的只是如何让它变得更简单。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;短篇介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;fb的图片存储系统叫做&lt;span&gt;HayStack&lt;/span&gt;,目前已存储超过120PB的数据，用户每天会上传20亿张图片。fb图片搜索峰值，需要提供每秒100-200万张的图片搜索。这些数据还再不断地增加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;稍微分析下用户使用场景，图片写入一次，频繁读取，从不修改，很少删除。传统的文件系统：每个图片都会有一些元数据，在我们的需求中，这些信息无用，且浪费存储空间，更大的性能消耗是文件的元数据需要从磁盘读到内存中来定位图片位置，在fb的量级上，元数据的吞吐量便是一个巨大的瓶颈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高吞吐量，低延迟是HayStack所追求的，所以HayStack希望每个图片读取操作至多需要一个磁盘，并且减少每个图片的必要元数据，并将它们保存至内存中。为了做好容灾，HayStack会将图片复制多张并保存至不通数据中心，以确保不反回404，error给客户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;典型的设计方案&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141038/201803/1141038-20180320105756036-93758336.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图为典型的设计方案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.用户通过浏览器发送图片信息请求至web server；2.web server 构造一个url，引导浏览器到对应位置下载图片；3.通常这个url指向一个&lt;span&gt;CDN&lt;/span&gt;，如果CDN有缓存相关图片的话，它会将图片立刻返回给浏览器；4.否则，会解析url，并在Photo Storage中找到对应的图片；5.6.返回给用户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;NAS-NFS&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在fb的服务中，只有CDN不足以解决全部需求，对于新图片，热门图片CDN确实很高效。但是对于一些个人上传的老图片请求，CDN基本上会全部命中失败，又没有办法将图片全部缓存起来。所以这里，可以采用NAS-NFS来解决问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141038/201803/1141038-20180320111418766-467224784.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基本操作与上面相同，5.6.photo store server 解析url得出完整的卷和路径信息，在&lt;span&gt;NFS&lt;/span&gt;上读取数据，然后返回给CDN。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种设计的瓶颈：NFS卷的每个目录下存储上千张图片，导致读取时产生了过多的磁盘操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;HayStack&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HayStack架构包含3个核心组件：&lt;span&gt;HayStack Store，HayStack Directory和HayStack Cache&lt;/span&gt;。 Store是存储系统，负责管理图片的元数据。不同机器上的物理卷对应一个逻辑卷，HayStack将一个图片保存至一个逻辑卷时，那么图片便对应写入所有物理卷。Directory 维护了逻辑到物理卷的映射以及相应的元数据，例如说，某张图片保存在哪个物理卷里，某个物理卷的存储空间等。Cache的功能，类似内部的CDN，它帮Store挡住热门搜索。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141038/201803/1141038-20180320124844339-478275828.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;上图描述了3个核心组件的相互作用。在HayStack架构中，浏览器的请求被引导至CDN中（或Cache上），Cache本质就是CDN，为了避免冲突，我们使用CDN来表示外部系统，使用Cache表示内部系统。&lt;/p&gt;
&lt;p&gt;1.当用户发出请求给web server，2.web server 使用Directory来构建图片的url，3.4.5.6.7.8.9.10.url包含一段信息，如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;http(s)://CDN/Cache/machine_id/volume_ID_Photo&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一目了然，url包含CDN地址信息，Cache信息，以及保存图片的物理卷ID，以及图片信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141038/201803/1141038-20180320130146170-1340672683.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4，位用户上传图片的流程，1.用户发送请求至web server；2.web server请求Directory一个可用的逻辑卷，物理卷，并将图片信息记录下；3.将相关信息发送至web server；4.web server将图片上传至Store；5.返回成功信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Directory&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要有4个功能：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.它提供了逻辑卷到物理卷的映射，web服务器上传或读取图片时需要使用这个映射。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.它在分配写请求，读请求到物理卷时，需保证负载均衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.它决定一个图片的请求，是发送至CDN或Cache，这个决定可以动态调整是否依赖CDN。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.它指定哪些卷是只读的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们增加Store的时候，那些卷都是可写的，可写的机器会收到上传信息。当它们到达容量上限时，标记它们为只读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Cache&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Cache的实现可以理解为一个分布式Hash Table，以图片ID为key，定位缓存的图片数据。如果Cache未命中，那么Cache则根据URL到指定的Store中，读取图片数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Store&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很简单，根据提供的一些元数据信息，包括图片ID，逻辑卷ID，物理卷ID，找到对应的图片，未找到则返回错误信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面简单描述一下物理卷与映射的结构，一个物理卷可以理解为一个大型文件，包含一系列的needle，每个needle就是一张图片。如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141038/201803/1141038-20180320132738409-915498171.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1141038/201803/1141038-20180320132812169-261827960.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了快速索引needle，Store需要为每个卷提供一个内存中的key-value映射。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;HayStack文件系统&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HayStack可以理解成基于Unix文件系统搭建的对象存储架构。Store使用的文件系统是&lt;span&gt;XFS&lt;/span&gt;，XFS有两个优点，首先，XFS中的临近大型文件的blockmap很小，可放入内存存储。再者，XFS提供高效的文件预分配，减少磁盘碎片问题。使用XFS，可以完全避免检索文件系统导致的磁盘操作。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Mar 2018 05:47:00 +0000</pubDate>
<dc:creator>peiyu1988</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peiyu1988/p/8608194.html</dc:identifier>
</item>
<item>
<title>Python函数学习——递归 - 一只小小的寄居蟹</title>
<link>http://www.cnblogs.com/xiao-apple36/p/8607835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiao-apple36/p/8607835.html</guid>
<description>&lt;h3&gt;递归函数&lt;/h3&gt;
&lt;p&gt;在函数内部，可以调用其他函数。如果一个函数在&lt;span&gt;内部调用自身本身&lt;/span&gt;，这个函数就是递归函数。&lt;/p&gt;
&lt;h4&gt;函数实现过程&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; calc(n):
    v &lt;/span&gt;= int(n//2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(v)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; v &amp;gt;&lt;span&gt; 0:
        calc(v)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(n)

calc(&lt;/span&gt;10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
5
2
1&lt;span&gt;
0
&lt;/span&gt;1
2
5
10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么是这个结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327694/201803/1327694-20180320095022687-2057698539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;递归特性:&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;必须有一个明确的结束条件&lt;/li&gt;
&lt;li&gt;每次进入更深一层递归时，问题规模相比上次递归都应有所减少&lt;/li&gt;
&lt;li&gt;一般通过return结束递归&lt;/li&gt;
&lt;li&gt;递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;堆栈扫盲&lt;/em&gt;&lt;a href=&quot;http://www.cnblogs.com/lln7777/archive/2012/03/14/2396164.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/lln7777/archive/2012/03/14/2396164.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;递归深度&lt;/h4&gt;
&lt;p&gt;python默认对最大递归层数做了一个限制：997，但是也可以自己限制&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
sys.setrecursionlimit(&lt;/span&gt;10000)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改递归层数&lt;/span&gt;
n=&lt;span&gt;0
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; f():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; n
    n&lt;/span&gt;+=1
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(n)
    f()
f()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;递归应用&lt;/h4&gt;
&lt;h5&gt;1.下面我们来猜一下小明的年龄&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;小明是新来的同学，丽丽问他多少岁了。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;他说：我不告诉你，但是我比滔滔大两岁。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;滔滔说：我也不告诉你，我比晓晓大两岁&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;晓晓说：我也不告诉你，我比小星大两岁&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;小星也没有告诉他说：我比小华大两岁&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;最后小华说，我告诉你，我今年18岁了&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个怎么办呢？当然，有人会说，这个很简单啊，知道小华的，就会知道小星的，知道小星的就会知道晓晓的，以此类推，就会知道小明的年龄啦。这个过程已经非常接近递归的思想了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327694/201803/1327694-20180320100914372-529277293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用递归实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
age(5) = age(4)+2
age(4) = age(3) + 2 
age(3) = age(2) + 2
age(2) = age(1) + 2
age(1) = 18
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; calc_age(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 18
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; calc_age(n-1)+2

&lt;span&gt;print&lt;/span&gt;(calc_age(5)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt;2.一个数，除2直到不能整除2&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
n = 100
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; cal(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n ==&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        n &lt;/span&gt;= int(n // 2&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(n)
        cal(n)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;退出=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, n)
cal(&lt;/span&gt;100)
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;3.一个数，除2直到次数等于5退出&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; calc(n,count):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(n, count)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; count &amp;lt; 5&lt;span&gt;:
        r &lt;/span&gt;= calc(n / 2, count + 1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; r  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 里层返回为上层,此处不加return 返回None&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最里层返回&lt;/span&gt;
&lt;span&gt;
res &lt;/span&gt;= calc(188, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;res &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, res)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;递归调用过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327694/201803/1327694-20180320103307303-427764550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;4.深度查询&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
menus =&lt;span&gt; [
    {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [
            {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;朝阳&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: []},
            {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;昌平&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [
                {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;沙河&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: []},
                {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;回龙观&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: []},
            ]},
        ]
    },
    {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;上海&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [
            {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;宝山&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: []},
            {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;金山&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: []},
        ]
    }
]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;  深度查询&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1. 打印所有的节点&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2. 输入一个节点名字，沙河， 你要遍历找，找到了，就打印它，并返回true,&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印所有的节点&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; recu_Menu(menu):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; sub_menu &lt;span&gt;in&lt;/span&gt;&lt;span&gt; menu:
        menu_text &lt;/span&gt;= sub_menu[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        menu_children &lt;/span&gt;= sub_menu[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(menu_text)
        recu_Menu(menu_children)

recu_Menu(menus)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印所有的节点,输入一个节点名字，沙河， 你要遍历找，找到了，就打印它，并返回true,&lt;/span&gt;
flag =&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; recu_Menu_node(menu, node, layer):
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt; flag
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; sub_menu &lt;span&gt;in&lt;/span&gt;&lt;span&gt; menu:
        menu_text &lt;/span&gt;= sub_menu[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        menu_children &lt;/span&gt;= sub_menu[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;children&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; node ==&lt;span&gt; menu_text:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;找到%s在第%s层&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (node, layer))
            flag &lt;/span&gt;=&lt;span&gt; True
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            recu_Menu_node(menu_children, node, layer &lt;/span&gt;+ 1&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;menu_text=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, menu_text)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag

node_str &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入一个节点名字-&amp;gt; &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(recu_Menu_node(menus, node_str, 1))
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;5.猴子吃桃问题&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 题目：猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;  第二天早上又将剩下的桃子吃掉一半，又多吃了一个。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;  以后每天早上都吃了前一天剩下的一半零一个。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;  到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。&lt;/span&gt;

&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
下一天等于是前一天吃了一半还多一个剩下的。
所以f(n) = 2 * f(n - 1) + 2
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; peach(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 2 * peach(n-1) + 2

&lt;span&gt;print&lt;/span&gt;(peach(10))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1534&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;6.&lt;strong&gt;二分查找算法&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;从[1, 3, 6, 7, 9, 12, 14, 16, 17, 18, 20, 21, 22, 23, 30, 32, 33, 35]序列中找到30的位置&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1327694/201803/1327694-20180320132527998-1913819127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 代码实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
data = [1, 3, 6, 7, 9, 12, 14, 16, 17, 18, 20, 21, 22, 23, 30, 32, 33, 35&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;start to find&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 递归二分查找&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; binary_search(dataset, start, end, val):
    mid &lt;/span&gt;= int((start + end)/ 2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取中间数&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(dataset, mid, start, end)&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; start &amp;lt;=&lt;span&gt; end:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; dataset[mid] == val:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断中间值和要找的那个值的大小关系&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;find val&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dataset[mid])
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; dataset[mid] &amp;gt;&lt;span&gt; val:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mid %s is bigger than %s, keep looking in left %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (dataset[mid], val, mid))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; binary_search(dataset, start, mid-1&lt;span&gt;, val)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; dataset[mid] &amp;lt; val:&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mid %s is smaller than %s, keep looking in right %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (dataset[mid], val, mid))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; binary_search(dataset, mid+1&lt;span&gt;, end, val)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; if dataset[start] == val:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     print('finally find val:', dataset[start])&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     return start&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; else:&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data %s doesn't exist in dataset &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; val)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1

&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;start to find&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(binary_search(data,0,len(data)-1, 30))&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;start to find
mid &lt;/span&gt;17 &lt;span&gt;is&lt;/span&gt; smaller than 30, keep looking &lt;span&gt;in&lt;/span&gt; right 8&lt;span&gt;
mid &lt;/span&gt;23 &lt;span&gt;is&lt;/span&gt; smaller than 30, keep looking &lt;span&gt;in&lt;/span&gt; right 13&lt;span&gt;
mid &lt;/span&gt;32 &lt;span&gt;is&lt;/span&gt; bigger than 30, keep looking &lt;span&gt;in&lt;/span&gt; left 15&lt;span&gt;
find val &lt;/span&gt;30&lt;span&gt;
mid &lt;/span&gt;=14 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回位置为14&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;另一种实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
data = [1, 3, 6, 7, 9, 12, 14, 16, 17, 18, 20, 21, 22, 23, 30, 32, 33, 35&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;start to find&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; binary_search(dataset, val):
    mid &lt;/span&gt;= int(len(dataset)/ 2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取中间数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dataset)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; mid &amp;gt;&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; dataset[mid] == val:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断中间值和要找的那个值的大小关系&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;find n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dataset[mid])
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; dataset[mid] &amp;gt;&lt;span&gt; val:
            new_dataset &lt;/span&gt;= dataset[:mid]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 顾头不顾尾&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mid %s is bigger than %s, keep looking in left %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (dataset[mid], val, mid))
            binary_search(new_dataset, val)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; dataset[mid] &amp;lt; val:&lt;/span&gt;
            new_dataset = dataset[mid:]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 顾头不顾尾&lt;/span&gt;
            &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mid %s is smaller than %s, keep looking in right %s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; (dataset[mid], val, mid))
            binary_search(new_dataset, val)
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; dataset[0] ==&lt;span&gt; val:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;finally find val:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, dataset[0])
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data %s doesn't exist in dataset &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; val)

binary_search(data,&lt;/span&gt;30)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 20 Mar 2018 05:42:00 +0000</pubDate>
<dc:creator>一只小小的寄居蟹</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiao-apple36/p/8607835.html</dc:identifier>
</item>
<item>
<title>基于双向BiLstm神经网络的中文分词详解及源码 - 行动派Xdpie</title>
<link>http://www.cnblogs.com/vipyoumay/p/8608754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipyoumay/p/8608754.html</guid>
<description>&lt;blockquote readability=&quot;7.7214700193424&quot;&gt;
&lt;p&gt;在自然语言处理中（NLP，Natural Language ProcessingNLP，Natural Language Processing），分词是一个较为简单也基础的基本技术。常用的分词方法包括这两种：&lt;strong&gt;基于字典的机械分词&lt;/strong&gt; 和 &lt;strong&gt;基于统计序列标注的分词&lt;/strong&gt;。对于基于字典的机械分词本文不再赘述，可看&lt;a href=&quot;https://spaces.ac.cn/archives/3908&quot; title=&quot;字典分词方法&quot;&gt;字典分词方法&lt;/a&gt;。在本文中主要讲解基于深度学习的分词方法及原理，包括一下几个步骤：&lt;code&gt;1标注序列&lt;/code&gt;，&lt;code&gt;2双向LSTM网络预测标签&lt;/code&gt;，&lt;code&gt;3Viterbi算法求解最优路径&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;标注序列&quot;&gt;1 标注序列&lt;/h2&gt;
&lt;p&gt;中文分词的第一步便是标注字，字标注是通过给句子中每个字打上标签的思路来进行分词，比如之前提到过的，通过4标签来进行标注&lt;code&gt;（single，单字成词；begin，多字词的开头；middle，三字以上词语的中间部分；end，多字词的结尾。均只取第一个字母。）&lt;/code&gt;，这样，“为人民服务”就可以标注为“sbebe”了。4标注不是唯一的标注方式，类似地还有6标注，理论上来说，标注越多会越精细，理论上来说效果也越好，但标注太多也可能存在样本不足的问题，一般常用的就是4标注和6标注。前面已经提到过，字标注是通过给句子中每个字打上标签的思路来进行分词，比如之前提到过的，通过4标签来进行标注（single，单字成词；begin，多字词的开头；middle，三字以上词语的中间部分；end，多字词的结尾。均只取第一个字母。），这样，“为人民服务”就可以标注为“sbebe”了。4标注不是唯一的标注方式，类似地还有6标注，理论上来说，标注越多会越精细，理论上来说效果也越好，但标注太多也可能存在样本不足的问题，一般常用的就是4标注和6标注。标注实例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;人/b  们/e  常/s  说/s  生/b  活/e  是/s  一/s  部/s  教/b  科/m  书/e &lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;训练网络&quot;&gt;2 训练网络&lt;/h2&gt;
&lt;p&gt;这里所指的网络主要是指神经网络，再细化一点就是双向LSTM(长短时记忆网络)，双向LSTM是LSTM的改进版，LSTM是RNN的改进版。因此，首先需要理解RNN。&lt;/p&gt;
&lt;p&gt;RNN的意思是，为了预测最后的结果，我先用第一个词预测，当然，只用第一个预测的预测结果肯定不精确，我把这个结果作为特征，跟第二词一起，来预测结果；接着，我用这个新的预测结果结合第三词，来作新的预测；然后重复这个过程；直到最后一个词。这样，如果输入有n个词，那么我们事实上对结果作了n次预测，给出了n个预测序列。整个过程中，模型共享一组参数。因此，RNN降低了模型的参数数目，防止了过拟合，同时，它生来就是为处理序列问题而设计的，因此，特别适合处理序列问题。&lt;strong&gt;循环神经网络原理见下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2018-03-20-11-47-27.png&quot; alt=&quot;2018-03-20-11-47-27&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LSTM对RNN做了改进，使得能够捕捉更长距离的信息。但是不管是LSTM还是RNN，都有一个问题，它是从左往右推进的，因此后面的词会比前面的词更重要，但是对于分词这个任务来说是不妥的，因为句子各个字应该是平权的。因此出现了双向LSTM，它从左到右做一次LSTM，然后从右到左做一次LSTM，然后把两次结果组合起来。&lt;/p&gt;
&lt;p&gt;在分词中，LSTM可以根据输入序列输出一个序列，这个序列考虑了上下文的联系，因此，可以给每个输出序列接一个softmax分类器，来预测每个标签的概率。基于这个序列到序列的思路，我们就可以直接预测句子的标签。假设每次输入&lt;span class=&quot;math inline&quot;&gt;\(y_1\)&lt;/span&gt;-&lt;span class=&quot;math inline&quot;&gt;\(y_n\)&lt;/span&gt;由下图所示每个输入所对应的标签为&lt;span class=&quot;math inline&quot;&gt;\(x_1\)&lt;/span&gt;-&lt;span class=&quot;math inline&quot;&gt;\(x_n\)&lt;/span&gt;。再抽象一点用$ x_{ij} &lt;span class=&quot;math inline&quot;&gt;\(表示状态\)&lt;/span&gt;x_i$的第j个可能值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2018-03-20-11-48-06.png&quot; alt=&quot;2018-03-20-11-48-06&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终输出结果串联起来形成如下图所示的网络&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2018-03-20-11-49-50.png&quot; alt=&quot;2018-03-20-11-49-50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中从第一个可能标签到最后一个可能标签的任何一条路径都可能产生一个新的序列，每条路径可能性不一样，我们需要做的是找出可能的路径。由于路径非常多，因此采用穷举是非常耗时的，因此引入Viterbi算法。&lt;/p&gt;

&lt;h2 id=&quot;viterbi算法求解最优路径&quot;&gt;3 Viterbi算法求解最优路径&lt;/h2&gt;
&lt;p&gt;维特比算法是一个特殊但应用最广的动态规划算法，利用动态规划，可以解决任何一个图中的最短路径问题。而维特比算法是针对一个特殊的图——篱笆网络的有向图（Lattice )的最短路径问题而提出的。&lt;/p&gt;
&lt;p&gt;而维特比算法的精髓就是，既然知道到第i列所有节点Xi{j=123…}的最短路径，那么到第i+1列节点的最短路径就等于到第i列j个节点的最短路径+第i列j个节点到第i+1列各个节点的距离的最小值，关于维特比算法的详细可以&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95&quot; title=&quot;点击&quot;&gt;点击&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;keras代码讲解&quot;&gt;4 keras代码讲解&lt;/h2&gt;
&lt;p&gt;使用Keras构建bilstm网络，在keras中已经预置了网络模型，只需要调用相应的函数就可以了。需要注意的是，对于每一句话会转换为词向量（Embedding）如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2018-03-20-11-49-20.png&quot; alt=&quot;2018-03-20-11-49-20&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;embedded = Embedding(len(chars) + 1, word_size, input_length=maxlen, mask_zero=True)(sequence)&lt;/code&gt;并将不足的补零。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建网络&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; keras.layers &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Dense, Embedding, LSTM, TimeDistributed, Input, Bidirectional
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; keras.models &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Model


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; create_model(maxlen, chars, word_size):
    &lt;span class=&quot;co&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;    :param maxlen:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    :param chars:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    :param word_size:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    :return:&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &quot;&quot;&quot;&lt;/span&gt;
    sequence &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Input(shape&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(maxlen,), dtype&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'int32'&lt;/span&gt;)
    embedded &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Embedding(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(chars) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, word_size, input_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;maxlen, mask_zero&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)(sequence)
    blstm &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Bidirectional(LSTM(&lt;span class=&quot;dv&quot;&gt;64&lt;/span&gt;, return_sequences&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;), merge_mode&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'sum'&lt;/span&gt;)(embedded)
    output &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; TimeDistributed(Dense(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, activation&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'softmax'&lt;/span&gt;))(blstm)
    model &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Model(&lt;span class=&quot;bu&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;sequence, output&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;output)
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; model&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;训练数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# -*- coding:utf-8 -*-&lt;/span&gt;

&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; np
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; pd

&lt;span class=&quot;co&quot;&gt;# 设计模型&lt;/span&gt;
word_size &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;128&lt;/span&gt;
maxlen &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;

&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'data/msr_train.txt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'rb'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; inp:
    texts &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; inp.read().decode(&lt;span class=&quot;st&quot;&gt;'gbk'&lt;/span&gt;)
s &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; texts.split(&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\r\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;# 根据换行切分&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; clean(s):  &lt;span class=&quot;co&quot;&gt;# 整理一下数据，有些不规范的地方&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;u'“/s'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; s:
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; s.replace(&lt;span class=&quot;st&quot;&gt;u' ”/s'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;u'”/s'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; s:
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; s.replace(&lt;span class=&quot;st&quot;&gt;u'“/s '&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;u'‘/s'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; s:
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; s.replace(&lt;span class=&quot;st&quot;&gt;u' ’/s'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;u'’/s'&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; s:
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; s.replace(&lt;span class=&quot;st&quot;&gt;u'‘/s '&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;)
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; s


s &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;u''&lt;/span&gt;.join(&lt;span class=&quot;bu&quot;&gt;map&lt;/span&gt;(clean, s))
s &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.split(&lt;span class=&quot;st&quot;&gt;u'[，。！？、]/[bems]'&lt;/span&gt;, s)

data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []  &lt;span class=&quot;co&quot;&gt;# 生成训练样本&lt;/span&gt;
label &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; get_xy(s):
    s &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.findall(&lt;span class=&quot;st&quot;&gt;'(.)/(.)'&lt;/span&gt;, s)
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; s:
        s &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.array(s)
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(s[:, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]), &lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(s[:, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;])


&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; s:
    x &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; get_xy(i)
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; x:
        data.append(x[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;])
        label.append(x[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;])

d &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pd.DataFrame(index&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(data)))
d[&lt;span class=&quot;st&quot;&gt;'data'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data
d[&lt;span class=&quot;st&quot;&gt;'label'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; label
d &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; d[d[&lt;span class=&quot;st&quot;&gt;'data'&lt;/span&gt;].&lt;span class=&quot;bu&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;&amp;lt;=&lt;/span&gt; maxlen]
d.index &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(d))
tag &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pd.Series({&lt;span class=&quot;st&quot;&gt;'s'&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'m'&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'e'&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'x'&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;})

chars &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []  &lt;span class=&quot;co&quot;&gt;# 统计所有字，跟每个字编号&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; data:
    chars.extend(i)

chars &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pd.Series(chars).value_counts()
chars[:] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(chars) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# 保存数据&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; pickle

&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'model/chars.pkl'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'wb'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; outp:
    pickle.dump(chars, outp)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'** Finished saving the data.'&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# 生成适合模型输入的格式&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; keras.utils &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; np_utils

d[&lt;span class=&quot;st&quot;&gt;'x'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; d[&lt;span class=&quot;st&quot;&gt;'data'&lt;/span&gt;].&lt;span class=&quot;bu&quot;&gt;apply&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x: np.array(&lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(chars[x]) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; (maxlen &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(x))))


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; trans_one(x):
    _ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; y: np_utils.to_categorical(y, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;), tag[x].reshape((&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)))
    _ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(_)
    _.extend([np.array([[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]])] &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; (maxlen &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(x)))
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; np.array(_)


d[&lt;span class=&quot;st&quot;&gt;'y'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; d[&lt;span class=&quot;st&quot;&gt;'label'&lt;/span&gt;].&lt;span class=&quot;bu&quot;&gt;apply&lt;/span&gt;(trans_one)

&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; lstm_model

model &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; lstm_model.create_model(maxlen, chars, word_size)
model.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(loss&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'categorical_crossentropy'&lt;/span&gt;, optimizer&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'adam'&lt;/span&gt;, metrics&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;'accuracy'&lt;/span&gt;])

batch_size &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt;
history &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; model.fit(np.array(&lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(d[&lt;span class=&quot;st&quot;&gt;'x'&lt;/span&gt;])), np.array(&lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(d[&lt;span class=&quot;st&quot;&gt;'y'&lt;/span&gt;])).reshape((&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, maxlen, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)), batch_size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;batch_size,
                    nb_epoch&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;, verbose&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
model.save(&lt;span class=&quot;st&quot;&gt;'model/model.h5'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2018-03-20-13-21-20.png&quot; alt=&quot;2018-03-20-13-21-20&quot;/&gt;&lt;img src=&quot;http://qiniu.xdpie.com/2018-03-20-13-21-20.png&quot; alt=&quot;2018-03-20-13-21-20&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1080显卡训练每次需要耗时44s,训练20个epoch后精度达到95%&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;31&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; pickle
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; lstm_model
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; pd

&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'model/chars.pkl'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'rb'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; inp:
    chars &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pickle.load(inp)
word_size &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;128&lt;/span&gt;
maxlen &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;

model &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; lstm_model.create_model(maxlen, chars, word_size)
model.load_weights(&lt;span class=&quot;st&quot;&gt;'model/model.h5'&lt;/span&gt;, by_name&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)

&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; re
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; np

&lt;span class=&quot;co&quot;&gt;# 转移概率，单纯用了等概率&lt;/span&gt;
zy &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {&lt;span class=&quot;st&quot;&gt;'be'&lt;/span&gt;: &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;,
      &lt;span class=&quot;co&quot;&gt;'bm'&lt;/span&gt;: &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;,
      &lt;span class=&quot;co&quot;&gt;'eb'&lt;/span&gt;: &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;,
      &lt;span class=&quot;co&quot;&gt;'es'&lt;/span&gt;: &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;,
      &lt;span class=&quot;co&quot;&gt;'me'&lt;/span&gt;: &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;,
      &lt;span class=&quot;co&quot;&gt;'mm'&lt;/span&gt;: &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;,
      &lt;span class=&quot;co&quot;&gt;'sb'&lt;/span&gt;: &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;,
      &lt;span class=&quot;co&quot;&gt;'ss'&lt;/span&gt;: &lt;span class=&quot;fl&quot;&gt;0.5&lt;/span&gt;
      }

zy &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {i: np.log(zy[i]) &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; zy.keys()}


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; viterbi(nodes):
    paths &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {&lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;: nodes[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;], &lt;span class=&quot;st&quot;&gt;'s'&lt;/span&gt;: nodes[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;st&quot;&gt;'s'&lt;/span&gt;]}  &lt;span class=&quot;co&quot;&gt;# 第一层，只有两个节点&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; layer &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(nodes)):  &lt;span class=&quot;co&quot;&gt;# 后面的每一层&lt;/span&gt;
        paths_ &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; paths.copy()  &lt;span class=&quot;co&quot;&gt;# 先保存上一层的路径&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;# node_now 为本层节点， node_last 为上层节点&lt;/span&gt;
        paths &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {}  &lt;span class=&quot;co&quot;&gt;# 清空 path&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; node_now &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; nodes[layer].keys():
            &lt;span class=&quot;co&quot;&gt;# 对于本层的每个节点，找出最短路径&lt;/span&gt;
            sub_paths &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {}
            &lt;span class=&quot;co&quot;&gt;# 上一层的每个节点到本层节点的连接&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; path_last &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; paths_.keys():
                &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; path_last[&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; node_now &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; zy.keys():  &lt;span class=&quot;co&quot;&gt;# 若转移概率不为 0&lt;/span&gt;
                    sub_paths[path_last &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; node_now] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; paths_[path_last] &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; nodes[layer][node_now] &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; zy[
                        path_last[&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; node_now]
            &lt;span class=&quot;co&quot;&gt;# 最短路径,即概率最大的那个&lt;/span&gt;
            sr_subpaths &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pd.Series(sub_paths)
            sr_subpaths &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sr_subpaths.sort_values()  &lt;span class=&quot;co&quot;&gt;# 升序排序&lt;/span&gt;
            node_subpath &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sr_subpaths.index[&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]  &lt;span class=&quot;co&quot;&gt;# 最短路径&lt;/span&gt;
            node_value &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sr_subpaths[&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]  &lt;span class=&quot;co&quot;&gt;# 最短路径对应的值&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;# 把 node_now 的最短路径添加到 paths 中&lt;/span&gt;
            paths[node_subpath] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; node_value
    &lt;span class=&quot;co&quot;&gt;# 所有层求完后，找出最后一层中各个节点的路径最短的路径&lt;/span&gt;
    sr_paths &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; pd.Series(paths)
    sr_paths &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; sr_paths.sort_values()  &lt;span class=&quot;co&quot;&gt;# 按照升序排序&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; sr_paths.index[&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]  &lt;span class=&quot;co&quot;&gt;# 返回最短路径（概率值最大的路径）&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; simple_cut(s):
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; s:
        r &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; model.predict(np.array([&lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(chars[&lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(s)].fillna(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;).astype(&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt;)) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; (maxlen &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(s))]),
                          verbose&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;)[
                &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;][:&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(s)]
        r &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; np.log(r)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(r)
        nodes &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;bu&quot;&gt;dict&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;zip&lt;/span&gt;([&lt;span class=&quot;st&quot;&gt;'s'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'m'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'e'&lt;/span&gt;], i[:&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;])) &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; r]
        t &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; viterbi(nodes)
        words &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(s)):
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; t[i] &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'s'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'b'&lt;/span&gt;]:
                words.append(s[i])
            &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
                words[&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;+=&lt;/span&gt; s[i]
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; words
    &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt;:
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; []


not_cuts &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; re.&lt;span class=&quot;bu&quot;&gt;compile&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;u'([\da-zA-Z ]+)|[。，、？！\.&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\?&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;,!]'&lt;/span&gt;)


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; cut_word(s):
    result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
    j &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; not_cuts.finditer(s):
        result.extend(simple_cut(s[j:i.start()]))
        result.append(s[i.start():i.end()])
        j &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; i.end()
    result.extend(simple_cut(s[j:]))
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; result


&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(cut_word(&lt;span class=&quot;st&quot;&gt;'深度学习主要是特征学习'&lt;/span&gt;))&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;['深度', '学习', '主要', '是', '特征', '学习']&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;本例子使用 Bi-directional LSTM 来完成了序列标注的问题。本例中展示的是一个分词任务，但是还有其他的序列标注问题都是可以通过这样一个架构来实现的，比如 POS（词性标注）、NER（命名实体识别）等。在本例中，单从分类准确率来看的话差不多到 95% 了，还是可以的。可是最后的分词效果还不是非常好，但也勉强能达到实用的水平。&lt;/p&gt;

&lt;h2 id=&quot;源代码地址&quot;&gt;源代码地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/stephen-v/zh-segmentation-keras&quot; class=&quot;uri&quot;&gt;https://github.com/stephen-v/zh-segmentation-keras&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Mar 2018 05:36:00 +0000</pubDate>
<dc:creator>行动派Xdpie</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vipyoumay/p/8608754.html</dc:identifier>
</item>
<item>
<title>我对软件工程这门课的理解 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8608629.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8608629.html</guid>
<description>&lt;section id=&quot;output_wrapper_id&quot; readability=&quot;1&quot;&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;​阅&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;读本文大概需要 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; 分钟&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/section&gt;&lt;p&gt; &lt;img src=&quot;http://img-blog.csdn.net/20180320130231509&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;section id=&quot;output_wrapper_id&quot; readability=&quot;62&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、什么是软件工程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在此之前，除了知道有软件工程这个专业，我并不知道还有软件工程这门课程，因此我不敢凭空妄谈对软件工程这门课有什么理解。当我看到作业是谈谈自己对软件工程这门课的理解时，我是有点惊讶的，这学期刚刚开学两周，课也上了没几节，可以说我对软件工程这个概念完全没有理解。但是我想，既然是作业，我也只能强迫我自己去看书查资料说说我自己的理解和看法了。&lt;/p&gt;
&lt;p&gt;首先引用一下百度百科的定义：软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式等方面。&lt;/p&gt;
&lt;p&gt;从定义中，我很难区分这门课究竟是一门偏理论类型的课程还是偏实战类型的课程，而且软件工程的课本中讲的基本都是理论，在之前的一次课中，我清楚记得老师说过，软件工程这门课，就是要我们团结协作，然后开发出一个可观的项目来，因此我姑且理解为这门是理论与实践的结合课程吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img-blog.csdn.net/20180320130434167&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;这门课程订的课本叫《现代软件工程构建之法》，从名字理解第一想法就是几个人一起合作开发一个项目工程，其中包括从项目的名字、需求分析到项目的具体实施、团队每个人的任务分配等等，到最终项目的完美展现。翻开这本书的目录，我大概知道了软件工程这么课大概就三个方向的内容：&lt;/p&gt;
&lt;p&gt;（1）、软件工程相关概念及概述。简单来讲，就是一堆的概念和理论。对我来讲，我是很难一个一个章节去看这一部分的，或许是性格原因，我难以集中注意力去理解一堆的概念和理论。但同时我也认为，如果对于一个真正想从事编程相关工作的人，偏于实践，这个部分并不太重要。&lt;/p&gt;
&lt;p&gt;（2）、个人及团队在项目开发中地位以及作用的概述。这一部分稍微显得有趣些，一个人如何参与到一个项目中去，又如何发挥自己的项目开发中的作用，这个应该是每一个要做编程开发工作的人都要思考的事情。在具体的项目开发中，这也是我们大学生意识最薄弱的部分。我认为大部分的当代大学生也包括我自己，团队合作意识是相当差的，或者说根本没有。要么认为自己一个人能搞定，不需要一起协作完成；要么认为自己无法提供很好的帮助，不想参与到团队中来；要么认为人满为患，人越少越好，等等。对我我自己来说，这几个原因我基本都有，而且也是近期才意识到这个问题以及这个问题的严重性，因此对于这个部分的内容，我可能还会稍微认真去学习并努力去深入探究理解一下。&lt;/p&gt;
&lt;p&gt;（3）、从项目的需求分析到项目最终构建的流程概述。这是项目开发最重要的部分，我以为一个项目要想有条不紊的进行开发，团队成员必须对项目的流程以及自己的工作了如指掌。具体如何进行项目需求分析，以及项目构建的具体流程，这个在本文暂不做深入的探讨。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2、我能学会什么&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于软件工程这门课，我无法预测我能学会什么，但我知道我要学什么，也希望自己能坚持。&lt;/p&gt;
&lt;p&gt;（1）、知道自己接触过一些软件工程相关的概念，起码看到相关的概念有点印象。&lt;/p&gt;
&lt;p&gt;（2）、认真去学习自己如何才能在项目开发当中好好发挥自己的作用，如何才能在项目开发当中快速的成长。&lt;/p&gt;
&lt;p&gt;（3）、熟悉项目开发的流程，以及每一个流程的详细操作。&lt;/p&gt;
&lt;p&gt;相信学完软件工程这门课，不会再疑惑：&lt;/p&gt;
&lt;p&gt;（1）、团队协作开发究竟是如何进行的？&lt;/p&gt;
&lt;p&gt;（2）、不同的成员写的项目代码是如何提交到同一个项目中去的？&lt;/p&gt;
&lt;p&gt;（3）、一个完整的项目开发究竟经历怎样的过程？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3、我能做什么&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;目前大三，单看学校开设的哪几门课程，要做一个项目，完全不可能。但庆幸，寒暑假自己也独立去钻研过一些东西，要学的知识大部分已经学了，或者说接触过，已经有了相关的概念。我能做的：就是好好的做一个真正意义上有使用价值的产品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扫描关注微信公众号，了解更多&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://img-blog.csdn.net/20180320130818903&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/section&gt;</description>
<pubDate>Tue, 20 Mar 2018 05:06:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8608629.html</dc:identifier>
</item>
<item>
<title>3D模型展示以及体积、表面积计算 - 李奔涛</title>
<link>http://www.cnblogs.com/we-jack/p/8608623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/we-jack/p/8608623.html</guid>
<description>&lt;p&gt;本文原创 如转载请注明出处！！！&lt;/p&gt;
&lt;p&gt;本博客地址&lt;a href=&quot;http://www.cnblogs.com/we-jack&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/we-jack&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文原创，如果有同样需求的小伙伴请第一时间联系我 或者在留言区留言 &lt;/p&gt;
&lt;p&gt;上次为大家提供了3D模型的展示之后 发现网上有很多想要计算3D模型表面积和体积的需求 那么经过掉了几百根头发的艰辛历程之后 终于为大家解决了这一需求 按照惯例先上图为证&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1177866/201803/1177866-20180320114826352-1139024767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然我这样写 有的人认为我在忽悠 你说你的体积 表面积是这就是这啊 没有可验证性么  &lt;/p&gt;
&lt;p&gt;那好~ 没有对比就没有伤害 下面是某3D打印网站上传同样模型后给出的数据 各位看官们看好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1177866/201803/1177866-20180320115858687-1700109833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实打实的讲道理 他给出的体积还是负值 我都给转正了[:斜眼笑]&lt;/p&gt;
&lt;p&gt;好了 闲话少絮 直接给大家上代码 （JS代码如果有需要的直接留言找我）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;WebGL&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt; src&lt;/span&gt;&lt;span&gt;=&quot;js/three.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/STLLoader.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/TrackballControls.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/AsciiEffect.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;overflow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;hidden&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#eee&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先引入我们几个必须的JS （之前有人问OBJ模型怎么上传 这个问题可以直接百度three.js的使用方法）&lt;/p&gt;
&lt;p&gt;接下来用JS定义一个画布&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;    var WIDTH,HEIGHT;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     var    renderer;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;定义好了之后 我们初始化一下我们的three&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; initThree() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         WIDTH = document.documentElement.clientWidth/2;&amp;lt;!--{foreach from=$recommended_goods item=rgoods}--&amp;gt; &amp;lt;!-- {/foreach} --&amp;gt;
&lt;span&gt; 3&lt;/span&gt;         HEIGHT = document.documentElement.clientHeight/2;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 渲染器 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         renderer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.WebGLRenderer();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        renderer.setSize(WIDTH , HEIGHT);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         renderer.setClearColor(&lt;span&gt;new&lt;/span&gt; THREE.Color(0x66666&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         renderer.gammaInput = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         renderer.gammaOutput = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        document.body.appendChild(renderer.domElement);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下来是摄像头定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 摄像头 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; camera;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; initCamera() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; VIEW_ANGLE = 45&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 ASPECT = WIDTH /&lt;span&gt; HEIGHT,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 NEAR = 0.1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 FAR = 10000&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         camera = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         camera.position.set(20, 0, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置视野的中心坐标&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        camera.lookAt(scene.position);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;场景植入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 场景 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; scene;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; initScene() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         scene = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Scene();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;灯光定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 灯光 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; light,light2,light3;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; initLight() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;平行光&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         light = &lt;span&gt;new&lt;/span&gt; THREE.DirectionalLight(0xFFFFFF&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         light.position.set(0, 99, 0&lt;span&gt;).normalize();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        scene.add(light);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;环境光&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         light2 = &lt;span&gt;new&lt;/span&gt; THREE.AmbientLight(0x999999&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        scene.add(light2);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点光源&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         light3 = &lt;span&gt;new&lt;/span&gt; THREE.PointLight(0x00FF00&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         light3.position.set(300, 0, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        scene.add(light3);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;动画定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; animate() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        requestAnimationFrame( animate );
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        controls.update();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        effect.render( scene, camera );
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用所有方法开始执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; threeStart() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        initThree();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        initScene();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        initCamera();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        initLight();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        initObject();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        initControl();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        animate();
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 显示对象 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; cube;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initObject(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ASCII file&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; loader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.STLLoader();

        loader.addEventListener( &lt;/span&gt;'load', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ( event ) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loading = document.getElementById(&quot;Loading&quot;&lt;span&gt;);
            loading.parentNode.removeChild(loading);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; geometry =&lt;span&gt; event.content;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Area = 0.0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; volumes = 0.0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; geometry.faces.length; i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Pi =&lt;span&gt; geometry.faces[i].a;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Qi =&lt;span&gt; geometry.faces[i].b;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Ri =&lt;span&gt; geometry.faces[i].c;

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; P = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Vector3(geometry.vertices[Pi].x, geometry.vertices[Pi].y, geometry.vertices[Pi].z);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Q = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Vector3(geometry.vertices[Qi].x, geometry.vertices[Qi].y, geometry.vertices[Qi].z);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; R = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Vector3(geometry.vertices[Ri].x, geometry.vertices[Ri].y, geometry.vertices[Ri].z);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        volumes += volumeOfT(P, Q, R);  会产生负数..............&lt;/span&gt;
        volumes +=&lt;span&gt; volumeOfT(R, Q, P);
         Area &lt;/span&gt;+=&lt;span&gt; AreaOfTriangle(R, Q, P);
    }
    SurfaceArea &lt;/span&gt;= (Area / 100).toFixed(2&lt;span&gt;);
        console.log(&lt;/span&gt;'表面积:'+&lt;span&gt;SurfaceArea);
    loadedObjectVolume &lt;/span&gt;= (volumes / 1000).toFixed(2&lt;span&gt;);
        console.log(&lt;/span&gt;'体积:'+&lt;span&gt;loadedObjectVolume);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;砖红色&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; material = &lt;span&gt;new&lt;/span&gt; THREE.MeshPhongMaterial( { ambient: 0xff5533, color: 0xff5533, specular: 0x111111, shininess: 200&lt;span&gt; } );
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纯黑色&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            var material = new THREE.MeshBasicMaterial( { envMap: THREE.ImageUtils.loadTexture( 'http://localhost:8080/textures/metal.jpg', new THREE.SphericalReflectionMapping() ), overdraw: true } ) ;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;粉色 带阴影&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            var material = new THREE.MeshLambertMaterial( { color:0xff5533, side: THREE.DoubleSide } );&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;灰色&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            var material = new THREE.MeshLambertMaterial({color: 000000});    //材质设定  (颜色)&lt;/span&gt;

    &lt;span&gt;var&lt;/span&gt; mesh = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Mesh( geometry, material );
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; center =&lt;span&gt; THREE.GeometryUtils.center(geometry);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; boundbox=&lt;span&gt;geometry.boundingBox;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vector3 = boundbox.size(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vector3 = boundbox.size(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    console.log(vector3);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; scale =&lt;span&gt; vector3.length();
    camera.position.set(scale, &lt;/span&gt;0, 0&lt;span&gt;);
    camera.lookAt(scene.position);
    scene.add(camera);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用一个轴对象以可视化的3轴以简单的方式。X轴是红色的。Y轴是绿色的。Z轴是蓝色的。这有助于理解在空间的所有三个轴的方向。要添加这个帮手，使用下面的代码：&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; axisHelper = &lt;span&gt;new&lt;/span&gt; THREE.AxisHelper(800&lt;span&gt;);
    scene.add(axisHelper);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;周围边框&lt;/span&gt;
    bboxHelper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.BoxHelper();
    bboxHelper.visible &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; meshMaterial =&lt;span&gt; material;
    mainModel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Mesh(geometry, meshMaterial);
    bboxHelper.update(mainModel);
    bboxHelper.geometry.computeBoundingBox();
    scene.add(bboxHelper);


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;它吸引的特定对象3D对象（它看起来像金字塔）与线几何，这有助于可视化什么指定摄像机包含在它的视锥。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            var cameraParObj = new THREE.Object3D();&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            cameraParObj.position.y = 200;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            cameraParObj.position.z = 700;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            scene.add(cameraParObj);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            perspectiveCamera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.01, 1500);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            cameraParObj.add(perspectiveCamera);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            var cameraHelper = new THREE.CameraHelper(perspectiveCamera);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            scene.add(cameraHelper);&lt;/span&gt;


        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;地板网格&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var gridHelper = new THREE.GridHelper(500, 40); // 500 is grid size, 20 is grid step&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;gridHelper.position = new THREE.Vector3(0, 0, 0);&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;gridHelper.rotation = new THREE.Euler(0, 0, 0);&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;scene.add(gridHelper);&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var gridHelper2 = gridHelper.clone();&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;gridHelper2.rotation = new THREE.Euler(Math.PI / 2, 0, 0);&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;scene.add(gridHelper2);&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var gridHelper3 = gridHelper.clone();&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;gridHelper3.rotation = new THREE.Euler(Math.PI / 2, 0, Math.PI / 2);&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;scene.add(gridHelper3);&lt;/span&gt;

        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var grid = new THREE.GridHelper(300, 40, 25, [0, 0, 1], 0x000055, 0.2, true, &quot;#FFFFFF&quot;, &quot;left&quot;);&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;scene.add(grid);&lt;/span&gt;
&lt;span&gt;
        mesh.position.set(&lt;/span&gt;0,0,0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            mesh.position.x = scene.position.x;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            mesh.position.y = scene.position.y ;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            mesh.position.z = scene.position.z;&lt;/span&gt;
&lt;span&gt;        scene.add(mesh);

        renderer.clear();
        renderer.render(scene, camera);
    } );
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; loader.load( '3dfile/莫比乌斯环.STL' );&lt;/span&gt;
    loader.load( '3dfile/狼人.STL'&lt;span&gt; );
}

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; effect;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; controls;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initControl(){
        effect &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.AsciiEffect( renderer );
        effect.setSize( WIDTH, HEIGHT );
        controls &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.TrackballControls( camera,renderer.domElement);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码上面的注释都非常清楚了，根据这些我们很清楚的会看到在求体积的时候 我们必须先要得到&lt;span&gt;&lt;span&gt;一个四面体&lt;/span&gt;&lt;span&gt;的有&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;符号体积&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt; - 基于你的三角形并在原点处排在最前面。&lt;/span&gt;&lt;span&gt;音量的标志来自您的三角形是否指向原点的方向。&lt;/span&gt;&lt;span&gt;（三角形的法线本身取决于顶点的顺序，这就是为什么你在下面看不到它的原因。）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一点大家要是不懂的话 可以去搜索一下 &lt;a href=&quot;https://wenku.baidu.com/view/f129dd78ed630b1c58eeb51d.html&quot; target=&quot;_blank&quot;&gt;一种计算任意非凸多面体积分性质的符号方法&lt;/a&gt; 这个方法详细的讲解了 多面体的体积算法 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在代码的77行处我们可以看到 我在拿到多面体的每一个面之后进行了遍历从而求出中心点到每个面的距离 再根据THREE提供的方法 得到三个有效点 然后将所有的点进行组合 使用 (-v321 + v231 + v312 - v132 - v213 + v123)/6.0; 求得体积&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在计算表面积的时候出现了一点问题 如果模型出现在网格下面那么就会出现负值 但是数字的值是没有问题的 所以我们可以去将组合重新排序从而使负值转正 当然也可以使用绝对值的方法使数值转正&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后声明 如需转载请注明出处！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文原创，如果有同样需求的小伙伴请第一时间联系我 或者在留言区留言 &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Mar 2018 05:05:00 +0000</pubDate>
<dc:creator>李奔涛</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/we-jack/p/8608623.html</dc:identifier>
</item>
<item>
<title>Pandas与Matplotlib基础 - Pizzerias</title>
<link>http://www.cnblogs.com/dev-liu/p/pandas_plt_basic.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dev-liu/p/pandas_plt_basic.html</guid>
<description>&lt;p&gt;&lt;span&gt;pandas是Python中开源的，高性能的用于数据分析的库。其中包含了很多可用的数据结构及功能，各种结构支持相互转换，并且支持读取、保存数据。结合matplotlib库，可以将数据已图表的形式可视化，反映出数据的各项特征。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先借用一张图来描述一下pandas的一些基本使用方法，下面会通过一些实例对这些知识点进行应用。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201803/1295539-20180320121307556-347978856.png&quot; alt=&quot;&quot; width=&quot;1117&quot; height=&quot;788&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、安装pandas库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pandas库不属于Python自带的库，所以需要单独下载，如果已经安装了Python，可以使用pip工具下载pandas：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install pandas
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;如果还未安装Python的话，推荐使用&lt;a href=&quot;https://www.anaconda.com/download/&quot; target=&quot;_blank&quot;&gt;Anaconda&lt;/a&gt;，一款集成了Python及其一系列用于数据分析、科学计算的专用包的平台，省去了单独安装各个库的麻烦(内置Python版本为3.6)。&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot; width=&quot;1010&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201803/1295539-20180320121422937-1817196252.png&quot; alt=&quot;&quot; width=&quot;1102&quot; height=&quot;683&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、pandas的基本数据结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.Seris&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Seris是一维的，带索引的数组，支持多种数据类型。可以使用列表进行转换：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
s = pd.Series([3, -5, 7, 4], index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
a    3&lt;span&gt;
b   &lt;/span&gt;-5&lt;span&gt;
c    &lt;/span&gt;7&lt;span&gt;
d    &lt;/span&gt;4&lt;span&gt;
dtype: int64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;也可以重新指定索引：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
s.index = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
A    3&lt;span&gt;
B   &lt;/span&gt;-5&lt;span&gt;
C    &lt;/span&gt;7&lt;span&gt;
D    &lt;/span&gt;4&lt;span&gt;
dtype: int64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2.DataFrame&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一种二维的，类似于Excel表格的数据结构，可以为其指定列名、索引名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将字典结构转换为DataFrame：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
data =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Country&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Belgium&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;India&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Brazil&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Capital&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Brussels&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;New Delhi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Brasília&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Population&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [11190846, 1303171035, 207847528&lt;span&gt;]
}
df &lt;/span&gt;= pd.DataFrame(data, columns=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Country&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Capital&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Population&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;span&gt;   Country    Capital  Population
0  Belgium   Brussels    &lt;/span&gt;11190846
1    India  New Delhi  1303171035
2   Brazil   Brasília   207847528
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、基本操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.查看DataFrame数据的基本信息：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;对已一个刚接触的数据集，最好的了解它的方式就是先通过一些简单的命令查看他的基本结构，比如有多少行、多少列，列名是什么，是否有索引等等。pandas提供了这样的一系列命令让我们能够轻松的进行查询(以下部分实例使用&lt;a href=&quot;https://assets.datacamp.com/production/course_1639/datasets/life_expectancy_at_birth.csv&quot; target=&quot;_blank&quot;&gt;此数据集&lt;/a&gt;)。&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1) 查看行列信息：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df.shape)

&lt;/span&gt;&lt;span&gt;# &lt;/span&gt;&lt;span&gt;result&lt;/span&gt;
(260, 218)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;说明df包含260行，218列数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2) 查看列名及索引名：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;28.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df.columns)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df.index)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
Index([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Life expectancy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1800&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1801&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1802&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1803&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1804&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1805&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1806&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1807&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1808&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
       ...
       &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2007&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2008&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2009&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2010&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2011&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2012&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2013&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2014&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2015&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2016&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
      dtype&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, length=218&lt;span&gt;)
 
Int64Index([  0,   &lt;/span&gt;1,   2,   3,   4,   5,   6,   7,   8,   9&lt;span&gt;,
            ...
            &lt;/span&gt;250, 251, 252, 253, 254, 255, 256, 257, 258, 259&lt;span&gt;],
           dtype&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;int64&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, length=260)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3) 查看描述该DataFrame的基本信息：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df.info())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pandas.core.frame.DataFrame&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
Int64Index: &lt;/span&gt;260 entries, 0 to 259&lt;span&gt;
Columns: &lt;/span&gt;218 entries, Life expectancy to 2016&lt;span&gt;
dtypes: float64(&lt;/span&gt;217), object(1&lt;span&gt;)
memory usage: &lt;/span&gt;444.8+ KB
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看出df.info()显示的信息较全面，对索引、列、数据类型都做出了描述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4) 查看开头/结尾几行的数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对数据的基本情况了解后，有时候我们可能还想看一下具体的数据，从而有一个更加全面的认识，可以使用head(), tail()方法查看DataFrame的前几行/后几行数据。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df.head())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
         Life expectancy   1800   1801   1802   1803   1804   1805   1806&lt;span&gt;  \
0               Abkhazia    NaN    NaN    NaN    NaN    NaN    NaN    NaN   
&lt;/span&gt;1            Afghanistan  28.21  28.20  28.19  28.18  28.17  28.16  28.15   
2  Akrotiri &lt;span&gt;and&lt;/span&gt;&lt;span&gt; Dhekelia    NaN    NaN    NaN    NaN    NaN    NaN    NaN   
&lt;/span&gt;3                Albania  35.40  35.40  35.40  35.40  35.40  35.40  35.40   
4                Algeria  28.82  28.82  28.82  28.82  28.82  28.82  28.82   
 
    1807   1808  ...        2016&lt;span&gt;  
0    NaN    NaN  ...    0    NaN  
&lt;/span&gt;1  28.14  28.13  ...    1  52.72  
2    NaN    NaN  ...    2&lt;span&gt;    NaN  
&lt;/span&gt;3  35.40  35.40  ...    3  78.10  
4  28.82  28.82  ...    4  76.50&lt;span&gt;  
 
[&lt;/span&gt;5 rows x 218 columns]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df.tail())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
    Life expectancy   1800   1801   1802   1803   1804   1805   1806   1807&lt;span&gt;  \
&lt;/span&gt;255&lt;span&gt;      Yugoslavia    NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN   
&lt;/span&gt;256          Zambia  32.60  32.60  32.60  32.60  32.60  32.60  32.60  32.60   
257        Zimbabwe  33.70  33.70  33.70  33.70  33.70  33.70  33.70  33.70   
258&lt;span&gt;           ?land    NaN    NaN    NaN    NaN    NaN    NaN    NaN    NaN   
&lt;/span&gt;259     South Sudan  26.67  26.67  26.67  26.67  26.67  26.67  26.67  26.67   
 
      1808  ...     2016  
255&lt;span&gt;    NaN  ...      NaN  
&lt;/span&gt;256  32.60  ...    57.10  
257  33.70  ...    61.69  
258&lt;span&gt;    NaN  ...      NaN  
&lt;/span&gt;259  26.67  ...    56.10&lt;span&gt;  
 
[&lt;/span&gt;5 rows x 218 columns]&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我使用的这个数据集的列有点多，所以python使用了&quot;\&quot;进行换行，并使用省略号省去了大部分的列数据，使其不必显示所有的列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.从DataFrame中选择子集：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一个较庞大的数据集，我们有时候只想对其中的一部分数据进行分析，那么我们就需要用合适的方法从中取出。pandas支持使用多种方式对数据进行选取：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) 根据列名选择：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
selected_cols = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2010&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2011&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2012&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
date_df &lt;/span&gt;=&lt;span&gt; df[selected_cols]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(date_df.head())
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
   2010  2011  2012&lt;span&gt;
0   NaN   NaN   NaN
&lt;/span&gt;1  53.6  54.0  54.4
2&lt;span&gt;   NaN   NaN   NaN
&lt;/span&gt;3  77.2  77.4  77.5
4  76.0  76.1  76.2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2) 根据标签选择：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用loc[]方法通过指定列名、索引名来获得相应的数据集。以我上面使用的df数据为例，取第250行的'Life expectancy'列的数据：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(df.loc[250, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Life expectancy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
250&lt;span&gt;                  Vietnam
 
Name: Life expectancy, dtype: object&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3) 根据位置选择：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用iloc[]通过指定列名、索引名对应的索引位置(从0到n-1)获取数据(可以使用slice分片方式表示)。如果我想取前十行中最后两列的数据，应该这样表示：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
df.iloc[:10, -2&lt;span&gt;:]
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
   2015   2016&lt;span&gt;
0   NaN    NaN
&lt;/span&gt;1  53.8  52.72
2&lt;span&gt;   NaN    NaN
&lt;/span&gt;3  78.0  78.10
4  76.4  76.50
5  72.9  73.00
6  84.8  84.80
7  59.6  60.00
8&lt;span&gt;   NaN    NaN
&lt;/span&gt;9  76.4  76.50
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：iloc[]中的slice分片方式与列表的分片方式相同，都不包含最后一位。例如上面的df.iloc[:10, -2:]值包含0~9行，而不包含第10行数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4) 布尔索引(Boolean Indexing)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也叫做布尔掩码(Boolean mask)，是指先根据条件对DataFrame进行运算，生成一个值为True/False的DataFrame，再通过此DF与原DF进行匹配，得到符合条件的DF。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mask = df &amp;gt; 50
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df[mask].head())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;
         Life expectancy  1800  1801  1802  1803  1804  1805  1806  1807&lt;span&gt;  \
0               Abkhazia   NaN   NaN   NaN   NaN   NaN   NaN   NaN   NaN   
&lt;/span&gt;1&lt;span&gt;            Afghanistan   NaN   NaN   NaN   NaN   NaN   NaN   NaN   NaN   
&lt;/span&gt;2  Akrotiri &lt;span&gt;and&lt;/span&gt;&lt;span&gt; Dhekelia   NaN   NaN   NaN   NaN   NaN   NaN   NaN   NaN   
&lt;/span&gt;3&lt;span&gt;                Albania   NaN   NaN   NaN   NaN   NaN   NaN   NaN   NaN   
&lt;/span&gt;4&lt;span&gt;                Algeria   NaN   NaN   NaN   NaN   NaN   NaN   NaN   NaN   
 
   &lt;/span&gt;1808  ...    2007  2008  2009  2010  2011  2012  2013  2014  2015   2016&lt;span&gt;  
0   NaN  ...     NaN   NaN   NaN   NaN   NaN   NaN   NaN   NaN   NaN    NaN  
&lt;/span&gt;1   NaN  ...    52.4  52.8  53.3  53.6  54.0  54.4  54.8  54.9  53.8  52.72  
2&lt;span&gt;   NaN  ...     NaN   NaN   NaN   NaN   NaN   NaN   NaN   NaN   NaN    NaN  
&lt;/span&gt;3   NaN  ...    76.6  76.8  77.0  77.2  77.4  77.5  77.7  77.9  78.0  78.10  
4   NaN  ...    75.3  75.5  75.7  76.0  76.1  76.2  76.3  76.3  76.4  76.50&lt;span&gt;  
 
[&lt;/span&gt;5 rows x 218 columns]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;不符合条件的显示为NaN。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.Broadcasting&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过将某一列的值刷成固定的值。例如对一些身高数据做转换时，添加一列'SEX'列，并统一将值更新为'MALE'：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
heights = [59.0, 65.2, 62.9, 65.4, 63.7&lt;span&gt;]
data &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: heights, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
}
df_heights &lt;/span&gt;=&lt;span&gt; pd.DataFrame(data)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;span&gt;   height   sex
0    &lt;/span&gt;59.0&lt;span&gt;  Male
&lt;/span&gt;1    65.2&lt;span&gt;  Male
&lt;/span&gt;2    62.9&lt;span&gt;  Male
&lt;/span&gt;3    65.4&lt;span&gt;  Male
&lt;/span&gt;4    63.7  Male
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.设置列名及索引名：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果需要重新指定列名或索引名，可直接通过df.columns()，df.index()指定。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
df_heights.columns = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HEIGHT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SEX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
df_heights.index &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;david&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lily&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sara&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tim&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;span&gt;       HEIGHT   SEX
david    &lt;/span&gt;59.0&lt;span&gt;  Male
bob      &lt;/span&gt;65.2&lt;span&gt;  Male
lily     &lt;/span&gt;62.9&lt;span&gt;  Male
sara     &lt;/span&gt;65.4&lt;span&gt;  Male
tim      &lt;/span&gt;63.7  Male
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5.使用聚合函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果需要对数据进行一些统计，可使用聚合函数进行计算。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) df.sum()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将所有值按列加到一起：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights.sum())
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
HEIGHT                   316.2&lt;span&gt;
SEX       MaleMaleMaleMaleMale
dtype: object&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;字符串sum后会合并在一起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2) df.cumsum()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;统计累积加和值：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights.cumsum())
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;span&gt;      HEIGHT                   SEX
david     &lt;/span&gt;59&lt;span&gt;                  Male
bob    &lt;/span&gt;124.2&lt;span&gt;              MaleMale
lily   &lt;/span&gt;187.1&lt;span&gt;          MaleMaleMale
sara   &lt;/span&gt;252.5&lt;span&gt;      MaleMaleMaleMale
tim    &lt;/span&gt;316.2  MaleMaleMaleMaleMale
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;3) df.max() / df.min()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;求最大/最小值&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights.max())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
HEIGHT    65.4&lt;span&gt;
SEX       Male
dtype: object&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights.min())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
HEIGHT      59&lt;span&gt;
SEX       Male
dtype: object&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注： df.idxmax() / df.idxmin() 方法可得极值对应的索引值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4) df.mean()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;求平均数&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights.mean())
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
HEIGHT    63.24&lt;span&gt;
dtype: float64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;数据类型为字符串的列会被自动过滤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5) df.median()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;求中位数&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights.median())
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
HEIGHT    63.7&lt;span&gt;
dtype: float64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;6) df.describe()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取DF的基本统计信息：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights.describe())
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;span&gt;          HEIGHT
count   &lt;/span&gt;5.000000&lt;span&gt;
mean   &lt;/span&gt;63.240000&lt;span&gt;
std     &lt;/span&gt;2.589015&lt;span&gt;
min    &lt;/span&gt;59.000000
25%    62.900000
50%    63.700000
75%    65.200000&lt;span&gt;
max    &lt;/span&gt;65.400000
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;6.从DataFrame中删除数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) 通过指定行索引删除行数据：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
df_heights.drop([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;david&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tim&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])&lt;br/&gt;print(df_heights)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;       HEIGHT   SEX&lt;/p&gt;
&lt;p&gt;david    59.0  Male&lt;/p&gt;
&lt;p&gt;bob      65.2  Male&lt;/p&gt;
&lt;p&gt;lily     62.9  Male&lt;/p&gt;
&lt;p&gt;sara     65.4  Male&lt;/p&gt;
&lt;p&gt;tim      63.7  Male&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 我们发现drop'david', 'tim'所在行后，&lt;/span&gt;&lt;span&gt;再次打印df_height，之前删除的两行数据还在。说明drop()方法不会直接对原有的DF进行操作，如果需要改变原DF，需要进行赋值：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
df_heights = df_heights.drop([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;david&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tim&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;span&gt;      HEIGHT   SEX
bob     &lt;/span&gt;65.2&lt;span&gt;  Male
lily    &lt;/span&gt;62.9&lt;span&gt;  Male
sara    &lt;/span&gt;65.4  Male
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2) 通过指定列值删除列数据(需指定axis=1)：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(df_heights.drop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SEX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, axis=1&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;span&gt;HEIGHT
david &lt;/span&gt;177.0&lt;span&gt;
bob &lt;/span&gt;195.6&lt;span&gt;
lily &lt;/span&gt;188.7&lt;span&gt;
sara &lt;/span&gt;196.2&lt;span&gt;
tim &lt;/span&gt;191.1
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;同样，如果需要改变原DF，需要重新赋值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) 根据索引值进行排序：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights.sort_index())
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;span&gt;       HEIGHT   SEX
bob      &lt;/span&gt;65.2&lt;span&gt;  Male
david    &lt;/span&gt;59.0&lt;span&gt;  Male
lily     &lt;/span&gt;62.9&lt;span&gt;  Male
sara     &lt;/span&gt;65.4&lt;span&gt;  Male
tim      &lt;/span&gt;63.7  Male
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2) 根据值进行排序(需指定列名)：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(df_heights.sort_values(by=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HEIGHT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;span&gt;       HEIGHT   SEX
david    &lt;/span&gt;59.0&lt;span&gt;  Male
lily     &lt;/span&gt;62.9&lt;span&gt;  Male
tim      &lt;/span&gt;63.7&lt;span&gt;  Male
bob      &lt;/span&gt;65.2&lt;span&gt;  Male
sara     &lt;/span&gt;65.4  Male
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;8.排名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据列值进行排名：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights.rank())
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;span&gt;       HEIGHT  SEX
david     &lt;/span&gt;1.0  3.0&lt;span&gt;
bob       &lt;/span&gt;4.0  3.0&lt;span&gt;
lily      &lt;/span&gt;2.0  3.0&lt;span&gt;
sara      &lt;/span&gt;5.0  3.0&lt;span&gt;
tim       &lt;/span&gt;3.0  3.0
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;9.使用lambda函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，对df_heights中的身高列进行转换(inch -&amp;gt; cm)：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
df_heights = df_heights.apply(&lt;span&gt;lambda&lt;/span&gt; height: height*3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df_heights)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&lt;span&gt;       HEIGHT           SEX
david   &lt;/span&gt;177.0&lt;span&gt;  MaleMaleMale
bob     &lt;/span&gt;195.6&lt;span&gt;  MaleMaleMale
lily    &lt;/span&gt;188.7&lt;span&gt;  MaleMaleMale
sara    &lt;/span&gt;196.2&lt;span&gt;  MaleMaleMale
tim     &lt;/span&gt;191.1  MaleMaleMale
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、csv文件的导入导出&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
df = pd.read_csv(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tips.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df.info())
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pandas.core.frame.DataFrame&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
RangeIndex: &lt;/span&gt;244 entries, 0 to 243&lt;span&gt;
Data columns (total &lt;/span&gt;8&lt;span&gt; columns):
total_bill    &lt;/span&gt;244 non-&lt;span&gt;null float64
tip           &lt;/span&gt;244 non-&lt;span&gt;null float64
sex           &lt;/span&gt;244 non-&lt;span&gt;null object
smoker        &lt;/span&gt;244 non-&lt;span&gt;null object
day           &lt;/span&gt;244 non-&lt;span&gt;null object
time          &lt;/span&gt;244 non-&lt;span&gt;null object
size          &lt;/span&gt;244 non-&lt;span&gt;null int64
fraction      &lt;/span&gt;244 non-&lt;span&gt;null float64
dtypes: float64(&lt;/span&gt;3), int64(1), object(4&lt;span&gt;)
memory usage: &lt;/span&gt;15.3+ KB&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2.pd.read_csv()的一些常用选项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;header=None: 不导入column&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;names: 指定column&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
df = pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tips.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, header=None, names=column_names)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;na_values: 将NaN替换成指定字符&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
df = pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tips.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, header=None, names=column_names, na_values={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DAY&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;})
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;parse_dates:合并表示时间的列&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
date_df = pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;created_date.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, parse_dates=[[3, 4, 5]])
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、保存CSV文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持保存为csv格式及excel格式的文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;date_df.to_csv('tips1.csv')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;date_df.to_csv('tips2.csv', sep='|')     # 分隔符为'|'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;date_df.to_excel('tips3.xlsx')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、配合Matplotlib绘制简单图表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Matplotlib库是python的一个2D图形库，可以生成多种高质量的图形，通过各种不同类型的图形体现数据的价值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.绘制折线图：&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201803/1295539-20180320124332991-752316198.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;虽然数据比较全，但是仅仅从这个表格上去对比各个专业之间的差异还是有些困难的，这时我们就可以通过使用matplotlib画图表的方式展示这些数据之间的关系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) 引入pandas库后先导入数据：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
 
 
df &lt;/span&gt;= pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;percent-bachelors-degrees-women-usa.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, index_col=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df.info())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df.head())
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result&lt;/span&gt;
      Agriculture  Architecture  Art &lt;span&gt;and&lt;/span&gt; Performance    Biology   Business  \ ... ...         Social Sciences &lt;span&gt;and&lt;/span&gt;&lt;span&gt; History  
Year                                                                          ... ...   Year                               
&lt;/span&gt;1970     4.229798     11.921005                 59.7  29.088363   9.064439    ... ...   1970                         36.8  
1971     5.452797     12.003106                 59.9  29.394403   9.503187    ... ...   1971                         36.2  
1972     7.420710     13.214594                 60.4  29.810221  10.558962    ... ...   1972                         36.1  
1973     9.653602     14.791613                 60.2  31.147915  12.804602    ... ...   1973                         36.4  
1974    14.074623     17.444688                 61.9  32.996183  16.204850    ... ...   1974                         37.3  
 
 
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pandas.core.frame.DataFrame&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
Int64Index: &lt;/span&gt;42 entries, 1970 to 2011&lt;span&gt;
Data columns (total &lt;/span&gt;17&lt;span&gt; columns):
Agriculture                      &lt;/span&gt;42 non-&lt;span&gt;null float64
Architecture                     &lt;/span&gt;42 non-&lt;span&gt;null float64
Art &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; Performance              42 non-&lt;span&gt;null float64
Biology                          &lt;/span&gt;42 non-&lt;span&gt;null float64
Business                         &lt;/span&gt;42 non-&lt;span&gt;null float64
Communications &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; Journalism    42 non-&lt;span&gt;null float64
Computer Science                 &lt;/span&gt;42 non-&lt;span&gt;null float64
Education                        &lt;/span&gt;42 non-&lt;span&gt;null float64
Engineering                      &lt;/span&gt;42 non-&lt;span&gt;null float64
English                          &lt;/span&gt;42 non-&lt;span&gt;null float64
Foreign Languages                &lt;/span&gt;42 non-&lt;span&gt;null float64
Health Professions               &lt;/span&gt;42 non-&lt;span&gt;null float64
Math &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; Statistics              42 non-&lt;span&gt;null float64
Physical Sciences                &lt;/span&gt;42 non-&lt;span&gt;null float64
Psychology                       &lt;/span&gt;42 non-&lt;span&gt;null float64
Public Administration            &lt;/span&gt;42 non-&lt;span&gt;null float64
Social Sciences &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; History      42 non-&lt;span&gt;null float64
dtypes: float64(&lt;/span&gt;17&lt;span&gt;)
memory usage: &lt;/span&gt;5.9 KB
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看出，'Year'为索引列，这次数据统计一共包含了17个专业。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2) 绘图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以使用matplotlib.pyplot中的plt()方法进行绘图。我们先试着分析某一列的数据，看一下具体是如何展示的：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
df_CS = df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Computer Science&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
plt.plot(df_CS)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201803/1295539-20180320124512620-1759350839.png&quot; alt=&quot;&quot; width=&quot;1022&quot; height=&quot;492&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot; width=&quot;827&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从图中我们看到，索引值作为X轴的刻度展示，Y轴则表示这一列的具体数值。从这个图中可以直观的看出这段时间学位的获取情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3) 添加标题和标签&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;仅仅这样展示似乎有些单调，matplotlib还提供了一系列可供自定义的功能：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
df_CS = df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Computer Science&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
plt.plot(df_CS)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为图表添加标题&lt;/span&gt;
plt.title(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage of Computer Science's degrees awarded to women in the USA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为X轴添加标签&lt;/span&gt;
plt.xlabel(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Years&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为Y轴添加标签&lt;/span&gt;
plt.ylabel(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201803/1295539-20180320124638840-1322076687.png&quot; alt=&quot;&quot; width=&quot;999&quot; height=&quot;488&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;添加了标题和标签，就好看一些了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4) 绘制多个图形进行对比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们想看Math and Statistics与Computer Science的差异，可以一并绘出并展示：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
df_CS = df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Computer Science&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
df_MS &lt;/span&gt;= df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Math and Statistics&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以通过DataFrame的plot()方法直接绘制&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; color指定线条的颜色&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; style指定线条的样式&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; legend指定是否使用标识区分&lt;/span&gt;
df_CS.plot(color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, style=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, legend=&lt;span&gt;True)
df_MS.plot(color&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, style=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, legend=&lt;span&gt;True)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage of Computer Science's degrees VS Math and Statistics's&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Years&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201803/1295539-20180320124809568-717995815.png&quot; alt=&quot;&quot; width=&quot;973&quot; height=&quot;489&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看出Math and Statistics明显高于Computer Science。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，我们绘制所有数据的曲线：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; alpha指定透明度(0~1)&lt;/span&gt;
df.plot(alpha=0.7&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage of bachelor's degrees awarded to women in the USA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Years&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; axis指定X轴Y轴的取值范围&lt;/span&gt;
plt.axis((1970, 2000, 0, 200&lt;span&gt;))
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201803/1295539-20180320124858830-1811564378.png&quot; alt=&quot;&quot; width=&quot;1030&quot; height=&quot;513&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5) 保存图像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用plt.savefig()保存图像，支持PNG， JPG，PDF等格式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;plt.savefig('percent-bachelors.png')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;plt.savefig('percent-bachelors.jpg')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;plt.savefig('percent-bachelors.pdf')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.其他类型的图像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了折线图，matplob还支持绘制散点图等其他类型，只需要在调用plot()画图之前指定kind参数即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1) 散点图&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;散点图可以体现数据在一定范围内的分布情况。上述数据集不适合画散点图，所以我们重新导入一份著名的&lt;a href=&quot;http://archive.ics.uci.edu/ml/machine-learning-databases/iris/&quot; target=&quot;_blank&quot;&gt;鸢尾花数据&lt;/a&gt;(在数据分析和机器学习中经常被用到)。&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们在导入数据后，分析sepal(萼片)的长度和宽度数据：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
iris = pd.read_csv(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iris.csv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 源数据中没有给column，所以需要手动指定一下&lt;/span&gt;
iris.columns = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sepal_length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sepal_width&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;petal_length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;petal_width&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;species&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; kind表示图形的类型&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; x, y 分别指定X, Y 轴所指定的数据&lt;/span&gt;
iris.plot(kind=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scatter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, x=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sepal_length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sepal_width&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sepal length in cm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sepal width in cm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iris data analysis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201803/1295539-20180320125013689-89889476.png&quot; alt=&quot;&quot; width=&quot;1006&quot; height=&quot;508&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot; width=&quot;930&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从散点图可以看出，数据主要集中在中间靠下的这部分区域(如果使用折线图，就是这些点连起来的折线，将变得杂乱无章)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2) box箱图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;box箱图也可以体现数据的分布情况，与散点图不同的是，它还统计了最大/最小值、中位数的值，一目了然：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
iris.plot(kind=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;box&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sepal_length&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sepal length in cm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201803/1295539-20180320125059783-705559113.png&quot; alt=&quot;&quot; width=&quot;1005&quot; height=&quot;478&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot; width=&quot;908&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3) Histogram柱状图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;柱状图体现了数据的分布情况及出现的频率，将数据展示得更加直观。下面我们从数据集中取出类别为&quot;Iris-setosa&quot;的子集，并使用柱状图统计它的四类数据：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用mask取出子集&lt;/span&gt;
mask = (iris.species == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iris-setosa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
setosa &lt;/span&gt;=&lt;span&gt; iris[mask]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; bins指定柱状图的个数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; range指定X轴的取值范围&lt;/span&gt;
setosa.plot(kind=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hist&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, bins=50, range=(0, 8), alpha=0.5&lt;span&gt;)
plt.title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;setosa in iris&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295539/201803/1295539-20180320125203947-1731706079.png&quot; alt=&quot;&quot; width=&quot;1010&quot; height=&quot;522&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Pandas与Matplotlib中常用的内容就给大家介绍到这了。这两种工具非常容易上手，但是想要精通，真正用好也需要花些心思。后面有机会再写一些较深入的文章吧 : )&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Mar 2018 04:55:00 +0000</pubDate>
<dc:creator>Pizzerias</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dev-liu/p/pandas_plt_basic.html</dc:identifier>
</item>
<item>
<title>使用localtunne一分钟搞定微信公众号接入 - 进击的小羊驼</title>
<link>http://www.cnblogs.com/pass245939319/p/8608580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pass245939319/p/8608580.html</guid>
<description>&lt;p&gt;  记得15年那个刚刚进入工作的时候，公司有个微信公众号的项目，那个时候微信官方没有什么调试工具，也没有什么比较好的本地调试工具。当时有个功能需要调用微信JSSDK里面的扫一扫的功能。由于本地不能调试。开发起来很烦。每次都需要把代码上传到测试服务器，然后在测试。这样耗费了不少时间。前几天之前的同事再次开发公众号的时候。出了一些问题。然后在讨论的时候。得知了一个微信公众号本地开发的神器&quot;localtunne&quot;。可以自己本地直接调试开发微信公号。调用JSSDK。使用非常简单。&lt;/p&gt;
&lt;h4 id=&quot;什么是localtunne&quot;&gt;什么是localtunne&lt;/h4&gt;
&lt;p&gt;  Localtunnel 是一个可以让内网服务器暴露到公网上的开源项目。&lt;a href=&quot;https://github.com/localtunnel/localtunnel&quot;&gt;项目地址&lt;/a&gt;。他可以让你本地项目只需要一句命令直接让外网访问。&lt;/p&gt;
&lt;h4 id=&quot;怎么安装localtunne&quot;&gt;怎么安装localtunne&lt;/h4&gt;
&lt;p&gt;  localtunnel是基于Node.js。所有你本地需要安装nodeJS。如果本地已经安装直接运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#安装localtunnel
npm install -g localtunnel
#查看当前版本。现在最新是1.8.3
lt --version
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没有安装nodejs的可以参考nodejs官方下载安装。&lt;a href=&quot;http://nodejs.cn/&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;接入微信公众号&quot;&gt;接入微信公众号&lt;/h4&gt;
&lt;p&gt;  已经安装好了localtunne,怎么关联微信公众号呢？首先打开&lt;a href=&quot;https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login&quot;&gt;微信公众平台接口测试帐号申请&lt;/a&gt; 。直接使用手机微信扫码登录。&lt;br/&gt;然后看到需要填写接口配置信息和JS接口安全域名。&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/wx_gzh.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;这个时候就需要用到刚刚我们安装的localtunnel。我们直接在控制台输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; #这里3000指的是我本地程序的监听的端口。根据具体项目修改。运行成功会返回一个域名。这个域名等会会用到。
 robin:~ robin$   lt --port 3000
 your url is: https://wvfgfpvsdm.localtunnel.me  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们需要一段代码来做认证使用。 代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; Koa &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'koa'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; app &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Koa&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; config &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./config/config'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; sha1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'sha1'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;use&lt;/span&gt;(async ctx &lt;span class=&quot;op&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;co&quot;&gt;//仅仅用于测试&lt;/span&gt;
   &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;query&lt;/span&gt;)
   &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; token &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;config&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;signature&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; timestamp&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; nonce&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; echostr&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;query&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [token&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; timestamp&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; nonce]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; str &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;sha1&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;sort&lt;/span&gt;().&lt;span class=&quot;at&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (str &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; signature) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; echostr&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'出错了'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;listen&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3000&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  首先运行上面那段代码。然后我们把拿到域名了填写到网页上面。token可以随便填写要记住。然后点击提交按钮。这个时候会直接提示配置成功。同时本地程序也收到了微信的请求。&lt;br/&gt;&lt;img src=&quot;http://img.shepherd618.cn/wx_token.png&quot; alt=&quot;enter image description here&quot;/&gt;&lt;br/&gt;  这个时候已经完成了对公众号的接入。简单吧。如果需要用到JS接口还需要配置JS接口安全域名。 这个一个坑就是复制自己域名的时候千万不要带任何的协议。只需要复制https://或者http://后面部门就可以了。然后点击保存之后。就可以很愉快的使用js相关的API啦。当然localtunnel也有很多别的一些功能。有兴趣的可以研究下。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Mar 2018 04:53:00 +0000</pubDate>
<dc:creator>进击的小羊驼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pass245939319/p/8608580.html</dc:identifier>
</item>
</channel>
</rss>