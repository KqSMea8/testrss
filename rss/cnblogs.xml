<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>从原理到方案，一步步讲解web移动端实现自适应等比缩放 - 痴货</title>
<link>http://www.cnblogs.com/linax/p/9418760.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linax/p/9418760.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;span&gt;前言&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在移动端做自适应，我们常用的有媒体查询，rem ，em，宽度百分比这几种方案。但是都各有其缺点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先拿媒体查询来说，在某一个宽度区间内只能使用一种样式，为了适应不同屏幕要，css的代码量就会增多，并且后期页面如果有改动，会变得越来越不易维护。em得根据父元素的字体大小来计算宽高，有很大局限性。用百分比来设置宽度局限性也大，首先是得计算每个元素占父元素的宽度，而且只能设置宽度的百分比，而高度则很难通过百分比来设置。所以最后的希望寄托在了rem上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;rem与px&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在讲rem实现方案之前，我们还是按照国际惯例，讲一下rem与px之间的关系。&lt;code&gt;rem是指相对于根元素的字体大小的单位&lt;/code&gt;。这句话怎么理解呢？请看下面的公式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　元素的rem值 = 元素的px值 / 根节点字体大小 ，我们举栗子说明一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果我们设置了根元素的字体大小为13px，那么一个宽300px，高350px的元素对应的rem就是宽23.076923rem，高26.923076rem。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;html&lt;/span&gt;{&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; 13px&lt;/span&gt;;
}&lt;span&gt;

div&lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 23.076923rem&lt;/span&gt;; // 23.076923rem = 300px / 13px&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 26.923076rem&lt;/span&gt;;// 26.923076rem = 350px / 13px&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以通过查看器对上面的公式进行验证，&lt;span&gt;如图&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1000209/201808/1000209-20180804101428409-660486091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看出，浏览器根据rem值自动计算得到div的宽高分别为300px，350px。由此我们可以把根节点字体大小作为自变量，元素宽高作为因变量（注意：此处的宽高指的是浏览器通过换算得到的元素px值，而不是rem值）。当我们通过JavaScript动态改变根节点字体大小时，浏览器就会重新计算元素的宽高，也就可以实现了动态缩放。但是怎么把缩放跟屏幕宽度联系起来呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　回答上述问题之前我们得知道，任何的缩放都必须有一个参考点，才能称为缩放，这是我们平时很容易忽略的一点。所以&lt;/span&gt;&lt;span&gt;接下来我们以iphone6的设计稿为参考点，选择iphone6是因为现在大多数的UI出图都是iphone6的尺寸，我们写好css代码后，浏览器就可以在此基础上计算元素px值，从而达到缩放的效果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;同样通过例子来说明：UI图标注div宽300px, 高350px, 字体大小20px。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;index.html　　 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt;
          content&lt;/span&gt;&lt;span&gt;=&quot;user-scalable=no, initial-scale=1, maximum-scale=1,
           minimum-scale=1, width=device-width, height=device-height&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;./index.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        hello 大家
   &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./src/index.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;index.css&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div&lt;/span&gt;{&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; 0.533333rem&lt;/span&gt;; // 0.533333rem = 20px / 37.5px&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 8rem&lt;/span&gt;; 　　　　　　 // 8rem        = 300px / 37.5px &lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 9.333333rem&lt;/span&gt;;    // 9.333333rem = 350px / 37.5px&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt; 0 auto&lt;/span&gt;;&lt;span&gt;
    background-color&lt;/span&gt;:&lt;span&gt; lightskyblue&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 注意此处并没有设置根节的font-size为37.5px。但是计算rem时却使用了它，因为37.5px即为iphone6屏幕的十分之一，就是为了把iphone6作为参考基准，并且这样元素的宽高与屏幕的宽度之间就有了一个比例关系。当通过js通过改变font-size的值，并且保证这个值始终与屏幕宽度有一个比例关系时，浏览器根据公式重新计算元素的宽高就和屏幕宽度也就有了一个比例关系。当屏幕变宽，元素放大，当屏幕变窄元素缩小。&lt;/p&gt;

&lt;p&gt;index.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; htmlWidth = document.documentElement.clientWidth || document.body.clientWidth &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取屏幕宽度&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt;  htmlDom = document.getElementsByTagName('html')[0] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取html&lt;/span&gt;
htmlDom.style.fontSize = htmlWidth / 10 + 'px'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置html字体大小为屏幕的十分之一&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听窗口大小改变&lt;/span&gt;
window.addEventListener('resize', () =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  htmlWidth = document.documentElement.clientWidth ||&lt;span&gt; document.body.clientWidth
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;  htmlDom = document.getElementsByTagName('html')[0&lt;span&gt;]
    htmlDom.style.fontSize &lt;/span&gt;= htmlWidth / 10 + 'px'&lt;span&gt;;
})&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1000209/201808/1000209-20180804131301337-2037225072.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样基本上就已经可以实现自适应了&lt;/p&gt;

&lt;p&gt;但是还有一个重要的问题没解决。我们不能每一个元素的rem值都像上面那样挨个手动计算，这样效率太低。&lt;/p&gt;
&lt;p&gt;下面介绍两种解决方案：&lt;/p&gt;
&lt;p&gt;第一种：利用scss定义函数实现自动转换&lt;/p&gt;
&lt;p&gt;新建index2.scss文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@function px2rem($px)&lt;/span&gt;{&lt;span&gt;
  $rem&lt;/span&gt;:&lt;span&gt;37.5px&lt;/span&gt;;&lt;span&gt;
  @return ($px / $rem) + rem;
&lt;/span&gt;}&lt;span&gt;

div&lt;/span&gt;{&lt;span&gt;
  font-size&lt;/span&gt;:&lt;span&gt; px2rem(20px)&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; px2rem(300px)&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; px2rem(350px)&lt;/span&gt;;&lt;span&gt;
  margin&lt;/span&gt;:&lt;span&gt; 0 auto&lt;/span&gt;;&lt;span&gt;
  background-color&lt;/span&gt;:&lt;span&gt; lightskyblue&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 然后看看IDE自动帮我们编译后的文件index2.css, 和index.css文件一模一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div&lt;/span&gt;{&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; 0.533333rem&lt;/span&gt;;&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 8rem&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 9.333333rem&lt;/span&gt;;&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt; 0 auto&lt;/span&gt;;&lt;span&gt;
    background-color&lt;/span&gt;:&lt;span&gt; lightskyblue&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 第二种：借助webpack，px2rem-loader实现&lt;/p&gt;
&lt;p&gt;先下载各种loader&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm install style-loader css-loader px2rem-loader --save-dev&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 配置webpack&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42.5&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;span&gt;{&lt;/span&gt;　　&lt;br/&gt;test: /\.css$/,     &lt;br/&gt;　　  use: ExtractTextPlugin.extract({&lt;p&gt;　　　fallback: &quot;style-loader&quot;,&lt;/p&gt;&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　　use: [{&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;        　　loader: &quot;css-loader&quot;&lt;span&gt;,
　　　　　}, {&lt;br/&gt;loader: 'px2rem-loader?remUnit=37.5&amp;amp;remPrecision=6'&lt;span&gt;
        }],
     })&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;}&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;em&gt; &lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; index3.css&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div&lt;/span&gt;{&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 300px&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 350px&lt;/span&gt;;&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt; 0 auto&lt;/span&gt;;&lt;span&gt;
    background-color&lt;/span&gt;:&lt;span&gt; lightskyblue&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 通过webpack编译过后的index.css3文件还是和index.css文件一样。这样就直接可以按照ui图来写代码，不用任何计算。提高了效率&lt;/p&gt;

</description>
<pubDate>Sat, 04 Aug 2018 07:30:00 +0000</pubDate>
<dc:creator>痴货</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linax/p/9418760.html</dc:identifier>
</item>
<item>
<title>Spring MVC SessionAttributes ModelAttribute注解 - Dream_saddle</title>
<link>http://www.cnblogs.com/dream-saddle/p/9405032.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dream-saddle/p/9405032.html</guid>
<description>&lt;p&gt;　　本文主要针对 @SessionAttributes注解 和 @ModelAttribute注解的基础用法进行解析。至于为什么会将这两个注解放在一起，是因为它们之间还是有点影响的。&lt;/p&gt;


&lt;p&gt;　　光看这个注解的名字大概也就知道这个注解是用于往 Session 域中存数据的吧！这个注解是 Spring2.5版本才有的。&lt;/p&gt;
&lt;h2&gt;　属性&lt;/h2&gt;
&lt;h3&gt;　　　　① value：&lt;/h3&gt;
&lt;p&gt;　　　　　　一个字符串数组，表示存放到 Session 域中的属性名&lt;/p&gt;
&lt;h3&gt;　　　　② names: &lt;span&gt;(这个属性是 4.2版本才有的)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　　　　　和 value 属性一样，他们之间是彼此的别名而已&lt;/p&gt;
&lt;h3&gt;　　　　③ type：&lt;/h3&gt;
&lt;p&gt;　　　　　　一个 Class 数组，根据指定的类型，将模型中对应类型的数据放到 Session 域中&lt;/p&gt;
&lt;h2&gt;　属性对应源码&lt;/h2&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226851/201808/1226851-20180801154144792-326727680.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　用法&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;注意：@SessionAttributes 注解只能用在类上面。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　&lt;/strong&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; *;&lt;/span&gt;&lt;span&gt;

@Controller
@SessionAttributes(value&lt;/span&gt;={&quot;name&quot;, &quot;age&quot;}, types={String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})   &lt;span&gt; &lt;span&gt;//&lt;span&gt;value 换成 names 一样的效果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SessionAttribute {

    @RequestMapping(&lt;/span&gt;&quot;/testSessionAttribute1&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String testSessionAttribute1(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; map) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;name 属性被放入了 value 数组中，所以也就存入了 Session 域中&lt;/span&gt;
        map.put(&quot;name&quot;, &quot;张三&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;age 属性放入了 names 数组中，也一样存入了 Session 域中&lt;/span&gt;
        map.put(&quot;age&quot;, 19&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于 types 数组中有 String.class，所以，address 属性也会放入 Session 域中&lt;/span&gt;
        map.put(&quot;address&quot;, &quot;重庆市&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　　　页面显示：&lt;/p&gt;
&lt;p&gt;　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226851/201808/1226851-20180801174209940-1237312067.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　&lt;span&gt;&lt;strong&gt;　注意：value 属性不能和 names 属性一起使用，如果一起使用了会出现下面异常信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;org.springframework.core.annotation.AnnotationConfigurationException: In annotation [org.springframework.web.bind.annotation.SessionAttributes] declared on class com.test.SessionAttribute and synthesized from [@org.springframework.web.bind.annotation.SessionAttributes(names=[age], value=[name], types=[class java.lang.String])],&lt;span&gt; attribute 'names' and its alias 'value' are present with values of [{age}] and [{name}], but only one is permitted.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;h2&gt;　　修饰方法&lt;/h2&gt;
&lt;p&gt;　　　&lt;span&gt;&lt;strong&gt;　注意：有 @ModelAttribute 注解修饰的方法，会在 Controller 中的每个方法执行之前都执行一次。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　① 修饰没有返回值的方法&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226851/201808/1226851-20180802165658763-223571278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　上面这个方法被 @ModelAttribute 注解所修饰，且没有返回值。但是，在方法的入参处有一个 map 集合，且在方法内部向 mpa 中放入了一个键值对。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226851/201808/1226851-20180802165936670-23646790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　执行完了 isNotReturn() 方法后，就会接着来到 isNotReturnTest() 方法，该方法重定向到了 success.jsp 页面，那么，map 集合中存放的数据也会在 request 域中被带到页面上。&lt;/p&gt;
&lt;p&gt;　　　　最后从 request 域中获取 tom，页面输出：&lt;/p&gt;
&lt;p&gt;　　　　　　 &lt;img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPgAAAAyCAIAAAD+wIGOAAACIElEQVR4nO2Y0Y6FIAwF/f+fdh82uTEgtS2Iypl5MlpLpXOru9sOIMD2dAEAM0B0kADRQQJEBwkQHSRAdJAA0UECRAcJEB0kQHSQANFBAkQHCRAdJPiG6NsWqNMZHMqZ5rhKz4pzql2Yb2xftM2e+CJmq4iV2FjimOr/IJcZ0Tv5xvbZba4dbRHK2VOtvaL9G2vFpOuBfRnRE0mMu0ZZ5Rc9FAMJvrF9/VIeBbI/UQYq5ZQV0ScQ/pa9G/93iOGuEVw81HCfcvUPLKz/EZZknui1baF7xwbfJ7qRrZUc0ScQ+COvdek0uHVLskr398l29p+N+vbCJ3vipjHKuDxOiD62X4uRmeitHhgHPZy6WwQUfSo62spZXx3b7KLytOghCx/v1ztZQXQjPmR5aBVnJdFpXcT8MiB6J28XvTX5WsHFq9lOe6vopwUYJ4v3UutH4lnXPuPsV+g18n5WEL1QZD806dJ1z8k92HVj9csB75n6l6vbZzz9Wm/GzxM9MSESE7eWrDVEQ/lz4+10o3IOIXonrseo29x61f56WZsUdcVwzlPkacH1Jf/g7BS9Pr5J9P2hfr2clz6JvcV1P/wa2eMt+uuyKyw0KgLuEx1qXrd9TgPssJwWY2W6zIboM2H7QAJEBwkQHSRAdJAA0UECRAcJEB0kQHSQANFBAkQHCRAdJEB0kADRQQJEBwkQHSRAdJAA0UECRAcJEB0kQHSQ4A/Ej6b7Yj3+OgAAAABJRU5ErkJggg==&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　上面两个方法可合并为一个方法：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　执行该方法就会向 map 中放入一个键值对，并且转发到 success.jsp 页面，且将数据通过 request 域带到页面。&lt;/p&gt;

&lt;p&gt;　　　　② 修饰有返回值的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt;修饰有返回值的方法&lt;/span&gt;
    @ModelAttribute(value=&quot;argtest&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String havaArg(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; map, Model model) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * 下面这种情况，返回值会被默认放到隐藏的 Model 中，在 Model 中的 key默认为 返回值的首字母小写，
         * 可以通过 ModelAttribute 注解的 value 属性设置
         * value 为返回的值
         * model.addAttribute(&quot;string&quot;, &quot;值&quot;);
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;map.put(&quot;arg&quot;, &quot;修饰有返回值的方法&quot;);&lt;/span&gt;
        model.addAttribute(&quot;modelTest&quot;, &quot;model 测试&quot;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;修饰有返回值的方法&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　注释中已经说的很清楚了，上面方法中，返回了一个字符串，那么在 model 中就会以下面的方式将 这个字符串存入 model：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　　 model.addAttribute(&quot;string&quot;, 修饰有返回值的方法&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　由于默认以返回值的首字母小写作为 key，这样可定有一定局限性，所以我们可以再 @ModelAttribute 注解中加上 value 属性标明返回值在 model 中的 key，还是上面的例子来说，加上 value 属性值后就是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　　 model.addAttribute(&quot;argtest&quot;, 修饰有返回值的方法&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　修饰参数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt;修饰参数，就是从 Model 中获取对应的属性值&lt;/span&gt;
    @RequestMapping(&quot;/updateUserInfo&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String updateUserInfo(User user, 
            @ModelAttribute(&lt;/span&gt;&quot;modelTest&quot;&lt;span&gt;) String modelTest, 
            @ModelAttribute(value&lt;/span&gt;=&quot;argtest&quot;&lt;span&gt;) String argtest) {&lt;/span&gt;&lt;span&gt;
        
        System.out.println(&lt;/span&gt;&quot;ModelAttribute修改参数：&quot;+&lt;span&gt;modelTest);
        System.out.println(&lt;/span&gt;&quot;ModelAttribute修改参数：&quot;+&lt;span&gt;argtest);
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　上面方法输出内容如下：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;data:image/png;base64,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&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这里输出的内容就是我们上面 做修饰有返回值方法时放入的值。那么， @ModelAttribute 注解修饰参数就代表从 Model 中获取对应属性名的值。&lt;/p&gt;

&lt;h2&gt;　　修饰被 @RequestMapping 注解修饰的方法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　  @RequestMapping(&quot;/test2&quot;&lt;span&gt;)
    @ModelAttribute
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String test2() {
        System.out.println(&lt;/span&gt;&quot;修饰有 RequestMapping修饰的方法&quot;&lt;span&gt;);
        &lt;br/&gt;　　　　 &lt;span&gt;//这里返回的 &quot;success&quot; 就不在代表视图了，而是 RequestMapping 注解的 value 属性值才代表视图&lt;/span&gt;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 可见上面 test2() 方法上有两个注解，那么，&lt;span&gt;这个方法就不会在每次访问 Controller 时都会执行&lt;/span&gt;了。因为不是每次执行 Controller 都会执行该方法，所以，&lt;span&gt;返回的 &quot;success&quot;字符串也不会被放入 Model 中(就会是一个无效的操作)&lt;/span&gt;。同时，&lt;span&gt;返回值 &quot;success&quot; 也不代表视图，此时对应的页面就是 RequestMapping 注解对应的值 &quot;test2&quot;&lt;/span&gt;，所以，在访问 &quot;/test2&quot; 来到 test2() 方法后，返回回去的路径为 test2.jsp，由于没有该页面，出现 404。&lt;/p&gt;

&lt;p&gt;上面内容讲解了 SessionAttributes 注解和 ModelAttribute 注解各自的基本用法，下面就来看看他俩放在一起使用可能会出现什么问题&lt;/p&gt;

&lt;h2&gt;　　情况一&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
@SessionAttributes(value&lt;/span&gt;= {&quot;name&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行该 方法后，会将 name属性放入 Model 中和 Session 中&lt;br/&gt;　　 //只要 ModelAttribute 属性值和 SessionAttributes 注解 value 属性其中一个属性值一致，那么，ModelAttribute 修饰方法返回值也会被放入 Session 中&lt;/span&gt;
    @ModelAttribute(&quot;name&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;李四&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　　情况二&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; *；&lt;/span&gt;&lt;span&gt;

@Controller&lt;br/&gt;@SessionAttributes(value= {&quot;userInfo&quot;})&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        这段代码什么意思：
　　　        页面上存在一个表单，当点击提交后，整个表单中的数据就会自动封装为一个 UserInfo 对象，并传递到 Handler 方法中，输出，最后跳转到 &quot;success.jsp&quot; 页面，同时将 UserInfo 对象
　　            放到 Session 域中
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;/test2&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String test2(@ModelAttribute(&quot;userInfo&quot;&lt;span&gt;) UserInfo userInfo) {
        System.out.println(&lt;/span&gt;&quot;修改方法：&quot;+&lt;span&gt;userInfo);
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是，上面代码执行会出错的。会抛出下面异常信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 org.springframework.web.HttpSessionRequiredException: Expected &lt;span&gt;session attribute 'userInfo'  //Session 中不存在 userInfo 属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;　　解决办法&lt;/h2&gt;
&lt;p&gt;　　一、将 目标方法 即代码中 test2() 方法 的 @ModelAttribute(&quot;userInfo&quot;) 中的 userInfo 改名，只要不和 SessionAttributes 注解中的名字一样就可以了。&lt;/p&gt;
&lt;p&gt;　　二、目标方法 即代码中 test2() 方法 的 @ModelAttribute(&quot;userInfo&quot;) 去掉，添加一个对应的被 ModelAttribute 修饰的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import *;

@Controller
@SessionAttributes(value&lt;/span&gt;= {&quot;userInfo&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {&lt;/span&gt;&lt;span&gt;
    @ModelAttribute
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; getUserInfo(UserInfo userInfo, Model model) {
        model.addAttribute(&lt;/span&gt;&quot;userInfo&quot;&lt;span&gt;, userInfo);
    }&lt;/span&gt;&lt;span&gt;
    @RequestMapping(&lt;/span&gt;&quot;/test2&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String test2(UserInfo userInfo) {
        System.out.println(&lt;/span&gt;&quot;修改方法：&quot;+&lt;span&gt;userInfo);
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里只做了一个简单的处理介绍，关于更详细的原因，我会在后面说明。还得下去多了解一下源码过程！&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 06:56:00 +0000</pubDate>
<dc:creator>Dream_saddle</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dream-saddle/p/9405032.html</dc:identifier>
</item>
<item>
<title>Docker | 第五章：构建自定义镜像 - oKong_趔趄的猿</title>
<link>http://www.cnblogs.com/okong/p/docker-five.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okong/p/docker-five.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;7.787610619469&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.lqdev.cn/2018/08/02/docker/docker-four/&quot; title=&quot;上一章节&quot;&gt;上一章节&lt;/a&gt;，主要是介绍了下&lt;code&gt;Dockerfile&lt;/code&gt;的一些常用命令的说明。我们知道，利用&lt;code&gt;Dockerfile&lt;/code&gt;可以构建一个新的镜像，比如运行&lt;code&gt;Java&lt;/code&gt;环境，就需要一个&lt;code&gt;JDK&lt;/code&gt;环境的镜像，但直接使用公共的镜像时，一般上大小都比较大。所以本章节就主要结合&lt;code&gt;Dockerfile&lt;/code&gt;文件及&lt;code&gt;commit&lt;/code&gt;方式，构建属于自己的镜像，同时对镜像进行压缩和优化，同时也是对&lt;code&gt;Dockerfile&lt;/code&gt;知识的一个实践。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;利用dockerfile构建自定义镜像&quot;&gt;利用Dockerfile构建自定义镜像&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作为一个&lt;code&gt;java&lt;/code&gt;后端开发，这里就直接以构建一个Oracle官方&lt;code&gt;jre&lt;/code&gt;环境来示例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;选定基础镜像&quot;&gt;选定基础镜像&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;由于在Linux中，&lt;code&gt;JVM&lt;/code&gt;主要是调用系统的C语言库，Oracle的官方JRE，使用的是libc，也就是&lt;code&gt;glibc&lt;/code&gt;，这意味着你要运行任何Java程序，都需要先装好&lt;code&gt;glibc&lt;/code&gt;。所以我们直接去&lt;code&gt;https://hub.docker.com&lt;/code&gt;找一个基于&lt;code&gt;glibc&lt;/code&gt;的基础镜像（当然了，大家也可直接选定比如&lt;code&gt;CensOS&lt;/code&gt;这些Linux的发行版本了）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-3/21625649.jpg&quot; alt=&quot;glibc&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们之类直接选择默认排在第一个的&lt;code&gt;alpine-glibc&lt;/code&gt;作为我们的基础镜像，比较这个大小也才12M左右呀！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题外话：大家作为实验性质时，为了获取更小的基础镜像，可以选择&lt;code&gt;alpine&lt;/code&gt;这个基础镜像，比较这个只有5M大小，够精简了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-3/80278924.jpg&quot; alt=&quot;alpine&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;准备jre版本&quot;&gt;准备JRE版本&lt;/h3&gt;
&lt;blockquote readability=&quot;6.6705882352941&quot;&gt;
&lt;p&gt;这里我们直接去&lt;a href=&quot;https://www.java.com/en/download/manual.jsp&quot; title=&quot;点击跳转至官网&quot;&gt;Oracle官网&lt;/a&gt;选择&lt;code&gt;jre&lt;/code&gt;版本，这里选择的是&lt;code&gt;jre-8u181-linux-x64&lt;/code&gt;版本(由于对linux命令不是很熟悉，为了不必要的时间浪费，这里直接下载了镜像了，熟悉的各位可以直接使用&lt;code&gt;wget&lt;/code&gt;进行下载的)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-3/78294091.jpg&quot; alt=&quot;jre版本&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;编写dockerfile&quot;&gt;编写Dockerfile&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; # 基础镜像
 FROM frolvlad/alpine-glibc
 LABEL MAINTAINER oKong &amp;lt;499452441@qq.com&amp;gt;
 
 # 将JRE添加至镜像中，add 命令在源文件为压缩文件时，会自动解压的
 ADD jre-8u181-linux-x64.tar.gz /opt/docker/java/jre8

# 设置JAVA环境变量
# 这里需要注意下，解压后有个目录的，为jre1.8.0_181,一开始没注意，启动时报了：exec: &quot;java&quot;: executable file not found in $PATH: unknown 后才发现。
ENV JAVA_HOME /opt/docker/java/jre8/jre1.8.0_181
ENV CLASSPATH=$JAVA_HOME/bin
ENV PATH=.:$JAVA_HOME/bin:$PATH

# 这里无实际意义，只是在容器启动时，输出jre版本信息，验证是否安装成功
CMD [&quot;java&quot;,&quot;-version&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用&lt;code&gt;build&lt;/code&gt;命令，构建镜像，同时指定&lt;code&gt;tag&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  docker build -t lqdev.cn/jre8:0.1 .&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：后面有个&lt;code&gt;.&lt;/code&gt;的。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Sending build context to Docker daemon  81.19MB
Step 1/7 : FROM frolvlad/alpine-glibc
 ---&amp;gt; d3bc626306a1
Step 2/7 : LABEL MAINTAINER oKong &amp;lt;499452441@qq.com&amp;gt;
 ---&amp;gt; Running in e788d29cd1e1
Removing intermediate container e788d29cd1e1
 ---&amp;gt; 5d95db4ae169
Step 3/7 : ADD jre-8u181-linux-x64.tar.gz /opt/docker/java/jre8
 ---&amp;gt; 0f4bb83df722
Step 4/7 : ENV JAVA_HOME /opt/docker/java/jre8/jre1.8.0_181
 ---&amp;gt; Running in 57a1e1ef00ed
Removing intermediate container 57a1e1ef00ed
 ---&amp;gt; 6f2b543a91b7
Step 5/7 : ENV PATH ${PATH}:${JAVA_HOME}/bin
 ---&amp;gt; Running in 2d75c88f97fb
Removing intermediate container 2d75c88f97fb
 ---&amp;gt; 92a7a0f9926c
Step 6/7 : WORKDIR /opt/docker/java/jre8/jre1.8.0_181
 ---&amp;gt; Running in 7b9a69efc980
Removing intermediate container 7b9a69efc980
 ---&amp;gt; 158c08c995c3
Step 7/7 : CMD [&quot;java&quot;,&quot;-version&quot;]
 ---&amp;gt; Running in 9ab517f8292a
Removing intermediate container 9ab517f8292a
 ---&amp;gt; 9c8606ac315a
Successfully built 9c8606ac315a
Successfully tagged lqdev.cn/jre8:0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后查看下镜像列表，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  docker images&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/86438010.jpg&quot; alt=&quot;images&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明已经构建成功了，我们来运行下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; docker run -it -d --name myfirstjre  lqdev.cn/jre8:0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看下容器列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; docker ps -a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/42870826.jpg&quot; alt=&quot;容器列表&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;Dockerfile&lt;/code&gt;中使用&lt;code&gt;CMD&lt;/code&gt;命令覆盖了原本的&lt;code&gt;/bin/sh&lt;/code&gt;,容器已启动就停止了。所以我们看下日志，就知道是否&lt;code&gt;jre&lt;/code&gt;安装成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker logs -f c6873a97ff49&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/4121182.jpg&quot; alt=&quot;logs&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出了版本信息了，说明已经安装成功了。&lt;/p&gt;
&lt;h3 id=&quot;实践运行springboot的jar包&quot;&gt;实践：运行SpringBoot的jar包&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;现在我们就可以基于这个jre镜像进行实际的jar包部署了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt;文件方式:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 基于我们自定义构建的镜像
FROM lqdev.cn/jre8:0.1

VOLUME /opt/tmp
# 这是jar 可自行选择，这里直接使用了原先讲解springboot十四章节：基于Docker部署时的jar包
ADD chapter-14-0.0.1-SNAPSHOT.jar app.jar

# -Djava.security.egd=file:/dev/./urandom 可解决tomcat可能启动慢的问题
# 具体可查看：https://www.cnblogs.com/mightyvincent/p/7685310.html
ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]

# 对外端口
EXPOSE 8080&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后构建新镜像，并运行，同时查看日志输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  docker run -it -d --name springboot  lqdev.cn/springboot:0.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志控制台：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/71737623.jpg&quot; alt=&quot;控制台&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行的容器列表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/90005302.jpg&quot; alt=&quot;容器列表&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明我们已经成功了，jar也启动了。现在访问下部署的jar服务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/65153587.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;利用commit命令构建自定义镜像&quot;&gt;利用commit命令构建自定义镜像&lt;/h2&gt;
&lt;blockquote readability=&quot;5.7096774193548&quot;&gt;
&lt;p&gt;在&lt;a href=&quot;http://blog.lqdev.cn/2018/07/31/docker/docker-three/&quot; title=&quot;第三章&quot;&gt;第三章&lt;/a&gt;讲解&lt;code&gt;Docker&lt;/code&gt;常用命令时，有说到，利用&lt;code&gt;commit&lt;/code&gt;可从容器中构建一个新的镜像。所以这里简单讲解下利用此命令进行自动镜像的构建过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;构建思路：我们启动一个基础镜像，同时运行，然后我们进入容器，下载所需要的jre版本，并配置其环境变量。之后退出容器进行保存操作。这里就不直接下载了，我们直接拷贝jre到容器里&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动基础镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   docker run -it -d --name commitImages  frolvlad/alpine-glibc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拷贝jre到容器中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker cp /opt/docker/java/jre-8u181-linux-x64.tar.gz b0d354b9453a:/opt/docker/java/jre8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;这里会提示，说目录不存在，可利用exec命令，进入容器创建目录下，这里就不演示了。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;No such container:path: b0d354b9453a:/opt/docker/java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们进入容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; docker exec -it b0d354b9453a /bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入，&lt;code&gt;/opt/docker/java/jre8&lt;/code&gt;目录，进行常规linux下的jre安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  cd /opt/docker/java/jre8
  # 解压
  tar -xzvf jre-8u181-linux-x64.tar.gz
  # 配置环境变量,vi /etc/profile 末尾加入
  export JAVA_HOME=/opt/docker/java/jre8/jre1.8.0_181
  export CLASSPATH=$JAVA_HOME/bin
  export PATH=.:$JAVA_HOME/bin:$PATH
  # 生效配置
  source /etc/profile
  # 验证是否成功
  java -version
  输出:
  java version &quot;1.8.0_181&quot;
  Java(TM) SE Runtime Environment (build 1.8.0_181-b13)
  Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)
  # 这里有个坑，生效配置后退出容器后又失效了，搜索了后，把环境变量放在### ~/.bashrc 或者在~/.bashrc里面加一句source /etc/profile 但是还是未生效。。。。我放弃了。。 直接写个sh脚本启动 时加入吧。。
  
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们退出容器，利用&lt;code&gt;commit&lt;/code&gt;命令进行构建新镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker commit b0d354b9453a lqdev.cn/jre8:0.2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后查看：&lt;br/&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/14090123.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行jar，验证下是否正常，这里直接在启动的时候拷贝jar到镜像。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it -d -p 1234:8080 -v /opt/docker/java:/opt/docker/java/app.jar --name springboot2 lqdev.cn/jre8:0.2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后进入容器运行下java 命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 进入容器
docker exec -it 583d0f387555 /bin/sh
# 生效配置
source etc/profile
# 运行jar
nohup java  -Djava.security.egd=file:/dev/./urandom -jar /opt/docker/java/app.jar &amp;gt;log.txt &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;退出后，访问宿主的1234端口服务，就能看见部署成功了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/92629359.jpg&quot; alt=&quot;新服务&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实比较好的做法是：创建一个&lt;code&gt;sh&lt;/code&gt;脚本，脚本里设置了环境生效命令及java命令即可，大家可自行尝试下，这里就不演示了。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;镜像文件压缩技巧&quot;&gt;镜像文件压缩技巧&lt;/h2&gt;
&lt;p&gt;上一章节，我们利用&lt;code&gt;Dockerfile&lt;/code&gt;和&lt;code&gt;commit&lt;/code&gt;的方式生成镜像。现在我们看下，镜像文件大小：&lt;br/&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/33876532.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两种方式，commit还多了80M多。这里我们本着精简的原则，对镜像大小进行优化下。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;首先，镜像文件是按&lt;code&gt;镜像层(Layers)&lt;/code&gt;进行叠加的。总的来说就是：每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;选择一个精简的基础镜像&quot;&gt;选择一个精简的基础镜像&lt;/h3&gt;
&lt;p&gt;一个基础镜像的大小直接决定了新镜像的大小，所以可以选择尽量小的精简的镜像。本文就使用了&lt;code&gt;alpine-glibc&lt;/code&gt;作为基础镜像，大小12.8M。&lt;/p&gt;
&lt;h3 id=&quot;串联run命令&quot;&gt;串联RUN命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;多个RUN时，可通过 &amp;amp;&amp;amp; 和 / 支持将命令串联在一起&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;# 举例
RUN yum -y install java-1.7.0-openjdk-devel &amp;amp;&amp;amp; yum clean all&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;很多镜像大部分都是通过此方式进行RUN方式编写的。官网：&lt;a href=&quot;https://hub.docker.com/&quot; class=&quot;uri&quot; title=&quot;https://hub.docker.com/&quot;&gt;https://hub.docker.com/&lt;/a&gt;里面的大部分镜像都是如下写法&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/80952556.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;删除多余文件及命令安装包等&quot;&gt;删除多余文件及命令安装包等&lt;/h3&gt;
&lt;p&gt;比如&lt;code&gt;jre&lt;/code&gt;包中就有很多的文档及说明文件是非必要的，这些就可以删除了。以下只是个参考，大家可以自行删减,可以在&lt;code&gt;Dockerfile&lt;/code&gt;编写时，解压后，使用&lt;code&gt;RUN&lt;/code&gt;命令进行操作也可以直接把压缩包里删除后在拷贝：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rm -rf COPYRIGHT LICENSE README release THIRDPARTYLICENSEREADME-JAVAFX.txtTHIRDPARTYLICENSEREADME.txt Welcome.html
#删除其他无用文件
rm -rf     lib/plugin.jar \
           lib/ext/jfxrt.jar \
           bin/javaws \
           lib/javaws.jar \
           lib/desktop \
           plugin \
           lib/deploy* \
           lib/*javafx* \
           lib/*jfx* \
           lib/amd64/libdecora_sse.so \
           lib/amd64/libprism_*.so \
           lib/amd64/libfxplugins.so \
           lib/amd64/libglass.so \
           lib/amd64/libgstreamer-lite.so \
           lib/amd64/libjavafx*.so \
           lib/amd64/libjfx*.so&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对比下，确实少了很多了。&lt;br/&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-4/38385192.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然对于大小不关心的，也就无需理会了，毕竟现在存储空间都很大的，也就可能传输的时候慢点，哈哈~&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;镜像优化的大家可看看以下几篇文章或者自行搜索下相关资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_36763896/article/details/53293088&quot; class=&quot;uri&quot; title=&quot;https://blog.csdn.net/qq_36763896/article/details/53293088&quot;&gt;https://blog.csdn.net/qq_36763896/article/details/53293088&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://my.oschina.net/shyloveliyi/blog/1627020&quot; class=&quot;uri&quot; title=&quot;https://my.oschina.net/shyloveliyi/blog/1627020&quot;&gt;https://my.oschina.net/shyloveliyi/blog/1627020&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/chenyufeng1991/article/details/78766123&quot; class=&quot;uri&quot; title=&quot;https://blog.csdn.net/chenyufeng1991/article/details/78766123&quot;&gt;https://blog.csdn.net/chenyufeng1991/article/details/78766123&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;本章节主要是介绍如何利用&lt;code&gt;Dockerfile&lt;/code&gt;或者&lt;code&gt;commit&lt;/code&gt;方式构建自定义镜像。通过这两种方式，我们就能根据自己的实际业务需要进行个性化改造、优化，最终构建一个通用镜像。&lt;strong&gt;在构建自己的镜像时，尽量还是选择自己熟悉的、稳定的基础环境镜像进行构建，毕竟出了问题找起来也熟门熟路点&lt;/strong&gt;。通常，运维部门或者实施部门，制定的镜像属于资产，一般不会上送至&lt;code&gt;Docker&lt;/code&gt;远程仓库的，有了镜像，我们就需要有个地方去存储。下一章节，就重点讲解下如何构建私有仓库，管理自己的镜像文件！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;若文中有错误或者遗漏之处，还望指出，共同进步！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;老生常谈&quot;&gt;老生常谈&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;个人QQ：&lt;code&gt;499452441&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;微信公众号：&lt;code&gt;lqdevOps&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/default/wxgzh8cm.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;http://blog.lqdev.cn/&quot; class=&quot;uri&quot; title=&quot;http://blog.lqdev.cn&quot;&gt;http://blog.lqdev.cn&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 04:36:00 +0000</pubDate>
<dc:creator>oKong_趔趄的猿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okong/p/docker-five.html</dc:identifier>
</item>
<item>
<title>从零开始学 Web 之 CSS3（五）transform - Daotin</title>
<link>http://www.cnblogs.com/lvonve/p/9418017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvonve/p/9418017.html</guid>
<description>&lt;blockquote readability=&quot;6.9491150442478&quot;&gt;
&lt;p&gt;大家好，这里是「 从零开始学 Web 系列教程 」，并在下列地址同步更新......&lt;/p&gt;
&lt;p&gt;在这里我会从 Web 前端零基础开始，一步步学习 Web 相关的知识点，期间也会分享一些好玩的项目。现在就让我们一起进入 Web 前端学习的探索之旅吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Daotin/pic/raw/master/fgx.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;transform&lt;/code&gt; 字面上就是变形，改变的意思。在CSS3中transform主要包括以下几种：移动 &lt;code&gt;translate&lt;/code&gt;，缩放&lt;code&gt;scale&lt;/code&gt;，旋转&lt;code&gt;rotate&lt;/code&gt;，翻转&lt;code&gt;skew&lt;/code&gt;，改变旋转轴心等。&lt;/p&gt;
&lt;h2 id=&quot;元素的移动translate&quot;&gt;1、元素的移动：translate&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;使用transform实现元素的移动&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*使用transform实现元素的移动 
1.如果只有一个参数就代表x方向
2.如果有两个参数就代表x/y方向*/
transform: translate(100px);
transform: translate(400px,500px);
transform: translate(0px,500px);

/*添加水平或者垂直方向的移动*/
transform:translateX(300px);
transform:translateY(300px);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1、移动是参照元素的左上角 ；&lt;/p&gt;
&lt;p&gt;2、执行完毕之后会恢复到原始状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;缩放scale&quot;&gt;2、缩放：scale&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;实现缩放（参照元素的几何中心）：1指不缩放，&amp;gt;1.01放大， &amp;lt;0.99缩小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*实现缩放（参照元素的几何中心）：1指不缩放，&amp;gt;1.01放大  &amp;lt;0.99缩小。
1.如果只有一个参数，就代表x和y方向都进行相等比例的缩放
2.如果有两个参数，就代表x/y方向*/
transform: scale(2);
transform: scale(2,1);
/* 缩放指定的方向 */
transform:scaleX(0.5);
transform:scaleY(0.5);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;旋转rotate&quot;&gt;3、旋转：rotate&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;实现元素的旋转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*参数：正数就是顺时针方向，负数就是逆时针方向。*/ 
transform:rotate(90deg); &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;翻转skew&quot;&gt;4、翻转：skew&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;实现元素的翻转&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*如果角度为正，则往当前轴的负方向斜切，如果角度为负，则往当前轴的正方向斜切*/
transform:skew(-30deg);
/*两个值，一个往x方向，一个y方向*/
transform:skew(30deg,-30deg);
/*设置某个方向的斜切值*/
/*transform:skewX(30deg);*/
/*transform:skewY(30deg);*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;改变旋转轴心&quot;&gt;5、改变旋转轴心&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*设置旋转轴心
1.参数：x y
2.关键字：left top right bottom center*/
transform-origin: left top;
transform-origin: 10px 10px;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;同时添加多个transform属性值&quot;&gt;6、同时添加多个transform属性值&lt;/h2&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*单独写两个是无效的，后面的会覆盖前面的*/
transform: translateX(700px);
transform: rotate(-90deg);

/*需要合并起来写*/
transform: translateX(700px) rotate(-90deg);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1、transform 多个属性分开写的话，后面的属性会覆盖前面的，一定要合并起来写。&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;transform: rotate(-90deg) translateX(700px);&lt;/code&gt;会出问题，因为旋转会将坐标系旋转，所以先移动再旋转。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;案例旋转轴心案例&quot;&gt;案例：旋转轴心案例&lt;/h2&gt;
&lt;p&gt;效果：鼠标放在图形上，图形旋转，鼠标移开，图形回归原状。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        * {
            padding: 0;
            margin: 0;
        }
        .box {
            width: 100px;
            height: 100px;
            margin: 300px auto;
            position: relative;
        }
        .box &amp;gt; img {
            width: 100px;
            height: 100px;
            position: absolute;
            transition: transform 1s;
            transform-origin: 110px -10px;
        }
        .box:hover &amp;gt; img:nth-of-type(1) {
            transform: rotate(60deg);
        }
        .box:hover &amp;gt; img:nth-of-type(2) {
            transform: rotate(120deg);
        }
        .box:hover &amp;gt; img:nth-of-type(3) {
            transform: rotate(180deg);
        }
        .box:hover &amp;gt; img:nth-of-type(4) {
            transform: rotate(240deg);
        }
        .box:hover &amp;gt; img:nth-of-type(5) {
            transform: rotate(300deg);
        }
        .box:hover &amp;gt; img:nth-of-type(6) {
            transform: rotate(360deg);
        }
        
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/gzh.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/gzh.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/gzh.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/gzh.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/gzh.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/gzh.png&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754332/201808/754332-20180804104635131-1385530707.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;案例图形打散&quot;&gt;案例：图形打散&lt;/h2&gt;
&lt;p&gt;效果：鼠标放到图形上，图形打散，鼠标移开，图形归位。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        *{
            margin: 0;
            padding: 0;
        }
        body {
            background-color: rgb(110, 84, 226);
        }
        .box {
            width: 500px;
            height: 100%;
            margin: 100px auto;
        }
        .box &amp;gt; img {
            transition: transform 1s;
        }
        .box:hover &amp;gt; img:nth-of-type(1){
            transform: translate(-100px, 200px) rotate(30deg);
        }
        .box:hover &amp;gt; img:nth-of-type(2){
            transform: translate(-500px, -50px) rotate(60deg);
        }
        .box:hover &amp;gt; img:nth-of-type(3){
            transform: translate(300px, 10px) rotate(-50deg);
        }
        .box:hover &amp;gt; img:nth-of-type(4){
            transform: translate(600px, 20px) rotate(-90deg);
        }
        .box:hover &amp;gt; img:nth-of-type(5){
            transform: translate(30px, 200px) rotate(90deg);
        }
        .box:hover &amp;gt; img:nth-of-type(6){
            transform: translate(-100px, -200px) rotate(-30deg);
        }
        .box:hover &amp;gt; img:nth-of-type(7){
            transform: translate(-300px, 100px) rotate(-30deg);
        }
        .box:hover &amp;gt; img:nth-of-type(8){
            transform: translate(200px, 250px) rotate(30deg);
        }
        .box:hover &amp;gt; img:nth-of-type(9){
            transform: translate(0, -150px) rotate(-30deg);
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;box&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/shield_1_01.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/shield_1_02.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/shield_1_03.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/shield_1_04.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/shield_1_05.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/shield_1_06.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/shield_1_07.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/shield_1_08.png&quot;&amp;gt;
        &amp;lt;img src=&quot;./images/shield_1_09.png&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754332/201808/754332-20180804104648601-1832156241.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;案例脱标流盒子居中&quot;&gt;案例：脱标流盒子居中&lt;/h2&gt;
&lt;p&gt;我们之前也学过脱标流盒子的居中问题，当时做的是先移动父盒子的 50%（比如：left：50%），再往相反方向移动子盒子的 50%（比如：margin-left：100px;）。大家可以看到，子盒子的移动只能写具体的像素值，而不能写 -50%。如果子盒子的大小改变了，就需要重新计算。&lt;/p&gt;
&lt;p&gt;这里可以使用：&lt;code&gt;left: 50%;&lt;/code&gt; 和 &lt;code&gt;transform:translate(-50%, -50%);&lt;/code&gt; 就可以解决。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        .cir {
            width: 300px;
            height: 300px;
            background-color: #ccc;
            border-radius: 50%;
            margin: 100px auto;
            position: relative;
        }
        .rec {
            width: 100px;
            height: 100px;
            background-color: blue;
            position: absolute;
            left: 50%;
            top: 50%;
            /* margin-left: -50px;
            margin-top: -50px; */
            transform: translate(-50%, -50%);
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;cir&quot;&amp;gt;
        &amp;lt;div class=&quot;rec&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754332/201808/754332-20180804104703735-694459022.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;d三维变换&quot;&gt;7、3d三维变换&lt;/h2&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*添加三维移动--3D移动*/
/*translate3d(X方向的偏移，Y方向的偏移，Z方向的偏移)*/
/*transform: translate3d(400px,0,0);*/
/*transform: translate3d(400px,400px,0);*/
transform: translate3d(0px,0px,400px);

/*添加3d缩放*/
/*scale3d(x方向上的缩放，y方向的缩放，z方向的缩放)
&amp;gt;1.01 放大   &amp;lt;0.99 缩小*/
transform:scale3d(1,1,10);

/*添加三维旋转*/
/*rotate3d(x,y,z,angle):
x:代表x轴方向上的一个向量值
y:代表y轴方向上的一个向量值
z:代表z轴方向上的一个向量值
330deg：旋转的度数*/
transform: rotate3d(1,1,1,330deg);
/*注意：当只有一个方向的向量值的时候，数字大小无所谓，但是当有两个或三个向量值的时候，旋转轴心为三个向量值合成的一个向量值，这个时候，各个向量值的大小会对合成的向量值的方向有影响。*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;案例立方体&quot;&gt;案例：立方体&lt;/h2&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        * {
            margin: 0;
            padding: 0;
        }
        .cube {
            width: 100px;
            height: 100px;
            position: relative;
            margin: 100px auto;
            /* 旋转一定的角度便于查看 */
            transform: rotate3d(1,1,0,30deg);
            /* 保存变换之后的效果 （加在父元素身上）*/
            transform-style: preserve-3d;

        }
        .cube &amp;gt; div {
            width: 100px;
            height: 100px;
            position: absolute;
            opacity: 0.5;
        }
        .front {
            background-color: red;
            transform: translateZ(50px);
        }
        .back {
            background-color: orange;
            transform: translateZ(-50px) rotateY(180deg);
        }
        .left{
            background-color: yellow;
            transform: translateX(-50px) rotateY(-90deg);
        }
        .right {
            background-color: green;
            transform: translateX(50px) rotateY(90deg);
        }
        .top{
            background-color: blue;
            transform: translateY(-50px) rotateX(90deg);
        }
        .bottom{
            background-color: purple;
            transform: translateY(50px) rotateX(-90deg);
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;cube&quot;&amp;gt;
        &amp;lt;div class=&quot;front&quot;&amp;gt;front&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;back&quot;&amp;gt;back&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;left&quot;&amp;gt;left&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;right&quot;&amp;gt;right&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;top&quot;&amp;gt;top&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;bottom&quot;&amp;gt;bottom&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/754332/201808/754332-20180804112206593-2014071408.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;景深透视效果&quot;&gt;8、景深/透视效果&lt;/h2&gt;
&lt;p&gt;当&lt;code&gt;perspective:none/0;&lt;/code&gt;时，相当于没有设置，没有设置的时候，视角位于3D的几何中心位置，相当于在&lt;br/&gt;盒子内部往外看;&lt;/p&gt;
&lt;p&gt;当perspective的值大于中心到各个平面的距离时，相当于出了盒子看。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/*默认无透视效果*/
perspective: 0px;

/*perspective-origin属性规定了镜头在平面上的位置。默认是放在元素的中心*/
perspective-origin: 0px 0px;

/*transform-style：使被转换的子元素保留其 3D 转换(需要设置在父元素中)
flat: 不保留3d转换结果
preserve-3d：保留3d转换结果*/
transform-style: preserve-3d;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/Daotin/pic/raw/master/fgx.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 03:23:00 +0000</pubDate>
<dc:creator>Daotin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvonve/p/9418017.html</dc:identifier>
</item>
<item>
<title>基于vue实现一个简单的MVVM框架 - 余大彬</title>
<link>http://www.cnblogs.com/yuliangbin/p/9302721.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuliangbin/p/9302721.html</guid>
<description>&lt;p&gt;不知不觉接触前端的时间已经过去半年了，越来越发觉对知识的学习不应该只停留在会用的层面，这在我学jQuery的一段时间后便有这样的体会。&lt;/p&gt;
&lt;p&gt;虽然jQuery只是一个JS的代码库，只要会一些JS的基本操作学习一两天就能很快掌握jQuery的基本语法并熟练使用，但是如果不了解jQUery库背后的实现原理，相信只要你一段时间不再使用jQuery的话就会把jQuery忘得一干二净，这也许就是知其然不知其所以然的后果。&lt;/p&gt;
&lt;p&gt;最近在学vue的时候又再一次经历了这样的困惑，虽然能够比较熟练的掌握vue的基本使用，也能够对MV*模式、数据劫持、双向数据绑定、数据代理侃上两句。但是要是稍微深入一点就有点吃力了。所以这几天痛下决心研究大量技术文章（起初尝试看早期源码，无奈vue与jQuery不是一个层级的，相比于jQuery，vue是真正意义上的前端框架。只能无奈弃坑转而看技术博客），对vue也算有了一个管中窥豹的认识。最后尝试实践一下自己学到的知识，基于数据代理、数据劫持、模板解析、双向绑定实现了一个小型的vue框架。&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;-------------------------------------------------- 分割线，下面介绍vue的具体实现。&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;温馨提示：文章是按照每个模块的实现依赖关系来进行分析的，但是在阅读的时候可以按照vue的执行顺序来分析，这样对初学者更加的友好。推荐的阅读顺序为：实现VMVM、数据代理、实现Observe、实现Complie、实现Watcher。&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/yuliangbin/MVVM&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;源码链接，由于只实现了v-model,v-on,v-bind等比较小的功能，所以更便于理解和掌握vue的实现过程。如果对您有帮助的话，希望点一下star。&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;功能演示如下所示：&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1204111/201808/1204111-20180804083733818-270939026.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;title&quot;&gt;数据代理&lt;/h2&gt;
&lt;p&gt;以下面这个模板为例，要替换的根元素“#mvvm-app”内只有一个文本节点#text，#text的内容为{{name}}。我们就&lt;span&gt;以下面这个模板详细了解一下VUE框架的大体实现流程&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;mvvm-app&quot;&amp;gt;&lt;span&gt;
        {{name}}
    &amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;./js/observer.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./js/watcher.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./js/compile.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./js/mvvm.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;&lt;span&gt;
        let vm = new&lt;span&gt; MVVM({
            el: &quot;#mvvm-app&quot;&lt;span&gt;,
            data: {
                name: &quot;hello world&quot;&lt;span&gt;
            },&lt;span&gt;        
        })

    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;title&quot;&gt;数据代理&lt;/h2&gt;
&lt;h3&gt;1、什么是数据代理&lt;/h3&gt;
&lt;p&gt;在vue里面，我们将数据写在data对象中。但是我们在访问data里的数据时，既可以通过vm.data.name访问，也可以通过vm.name访问。这就是&lt;span&gt;数据代理：在一个对象中，可以动态的访问和设置另一个对象的属性。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2、实现原理&lt;/h3&gt;
&lt;p&gt;我们知道静态绑定（如vm.name = vm.data.name）可以一次性的将结果赋给变量，而使用Object.defineProperty()方法来绑定则可以通过set和get函数实现赋值的中间过程，从而实现数据的动态绑定。具体实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
let obj =&lt;span&gt; {};
let obj1 &lt;/span&gt;=&lt;span&gt; {
    name: &lt;/span&gt;'xiaoyu'&lt;span&gt;,
    age: &lt;/span&gt;18&lt;span&gt;,
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现origin对象代理target对象&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; proxyData(origin,target){
    Object.keys(target).forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(key){
        Object.defineProperty(origin,key,{&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义origin对象的key属性&lt;/span&gt;
            enumerable: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
            configurable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            get: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getter(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; target[key];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;origin[key] = target[key];&lt;/span&gt;
&lt;span&gt;            },
            set: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setter(newValue){
                target[key] &lt;/span&gt;=&lt;span&gt; newValue;
            }
        })
    })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;vue中的数据代理也是通过这种方式来实现的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; MVVM(options) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$options = options ||&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;this&lt;/span&gt;._data = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$options.data;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前实例vm&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据代理&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现 vm._data.xxx -&amp;gt; vm.xxx &lt;/span&gt;
    Object.keys(data).forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(key) {
        _this._proxyData(key);
    });
    observe(data, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$compile = &lt;span&gt;new&lt;/span&gt; Compile(options.el || document.body, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

}

MVVM.prototype &lt;/span&gt;=&lt;span&gt; {
_proxyData: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(key) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; key == 'object' &amp;amp;&amp;amp; !(key &lt;span&gt;instanceof&lt;/span&gt; Array)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里只实现了对对象的监听，没有实现数组的&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._proxyData(key);
    }
    Object.defineProperty(_this, key, {
        configurable: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        enumerable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        get: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; proxyGetter() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _this._data[key];
        },
        set: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; proxySetter(newVal) {
            _this._data[key] &lt;/span&gt;=&lt;span&gt; newVal;
        }
    });
},
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;实现Observe&lt;/h2&gt;
&lt;h3&gt;1、双向数据绑定&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;数据变动　　---&amp;gt;　　视图更新&lt;/li&gt;
&lt;li&gt;视图更新　　---&amp;gt;　　数据变动 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要想实现当数据变动时视图更新，首先要做的就是如何知道数据变动了，可以&lt;span&gt;通过Object.defineProperty()函数监听data对象里的数据&lt;/span&gt;，当数据变动了就会触发set()方法。所以我们需要实现一个数据监听器Observe，来对数据对象中的所有属性进行监听，当某一属性数据发生变化时，拿到最新的数据通知绑定了该属性的订阅器，订阅器再执行相应的数据更新回调函数，从而实现视图的刷新。&lt;/p&gt;
&lt;p&gt;当设置this.name = 'hello vue'时，就会执行set函数，通知订阅器里的订阅者执行相应的回调函数，实现数据变动，对应视图更新。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; observe(data){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; data != 'object'&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Observe(data);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Observe(data){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data =&lt;span&gt; data;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.walk(data);
}

Observe.prototype &lt;/span&gt;=&lt;span&gt; {
    walk: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
        let _this  &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data.hasOwnProperty(key)){&lt;/span&gt;&lt;span&gt;
                let value &lt;/span&gt;=&lt;span&gt; data[key];
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; value == 'object'&lt;span&gt;){
                    observe(value);
                }
                _this.defineReactive(data,key,data[key]);
            }
        }
    },
    defineReactive: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data,key,value){&lt;/span&gt;&lt;span&gt;
        Object.defineProperty(data,key,{
            enumerable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可枚举&lt;/span&gt;
            configurable: &lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能再define&lt;/span&gt;
            get: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                console.log(&lt;/span&gt;'你访问了' +&lt;span&gt; key);&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
            },
            set: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(newValue){
                console.log(&lt;/span&gt;'你设置了' +&lt;span&gt; key);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newValue == value) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                value &lt;/span&gt;=&lt;span&gt; newValue;
                observe(newValue);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听新设置的值&lt;/span&gt;
&lt;span&gt;            }
        })
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2、实现一个订阅器&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;要想通知订阅者，首先得要有一个订阅器（统一管理所有的订阅者）。&lt;/span&gt;为了方便管理，我们会为每一个data对象的属性都添加一个订阅器（new Dep）。&lt;/p&gt;
&lt;p&gt;订阅器里存着的是订阅者Watcher（后面会讲到），由于订阅者可能会有多个，我们需要建立一个数组来维护。&lt;span&gt;一旦数据变化，就会触发订阅器的notify()方法，订阅者就会调用自身的update方法实现视图更新。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Dep(){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subs =&lt;span&gt; [];
}
Dep.prototype &lt;/span&gt;=&lt;span&gt; {
    addSub: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(sub){&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subs.push(sub);
    },
    notify: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subs.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(sub) {
            sub.update();
        })
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;每次响应属性的set()函数调用的时候，都会触发订阅器，所以代码补充完整。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
Observe.prototype =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略的代码未作更改&lt;/span&gt;
    defineReactive: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data,key,value){
        let dep &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dep();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个订阅器，会被闭包在key属性的get/set函数内，因此每个属性对应唯一一个订阅器dep实例&lt;/span&gt;
&lt;span&gt;        Object.defineProperty(data,key,{
            enumerable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可枚举&lt;/span&gt;
            configurable: &lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能再define&lt;/span&gt;
            get: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                console.log(&lt;/span&gt;'你访问了' +&lt;span&gt; key);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
            },
            set: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(newValue){
                console.log(&lt;/span&gt;'你设置了' +&lt;span&gt; key);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newValue == value) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                value &lt;/span&gt;=&lt;span&gt; newValue;
                observe(newValue);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听新设置的值&lt;/span&gt;
                dep.notify();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知所有的订阅者&lt;/span&gt;
&lt;span&gt;            }
        })
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;实现Complie&lt;/h2&gt;
&lt;p&gt;compile主要做的事情是解析模板指令，将模板中的data属性替换成data属性对应的值（比如将{{name}}替换成data.name值），然后初始化渲染页面视图，并且为每个data属性添加一个监听数据的订阅者（new Watcher），一旦数据有变动，收到通知，更新视图。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;遍历解析需要替换的根元素el下的HTML标签必然会涉及到多次的DOM节点操作，因此不可避免的会引发页面的重排或重绘，为了提高性能和效率，我们把根元素el下的所有节点转换为文档碎片&lt;code&gt;fragment&lt;/code&gt;进行解析编译操作，解析完成，再将&lt;code&gt;fragment&lt;/code&gt;添加回原来的真实dom节点中。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注：文档碎片本身也是一个节点，但是当将该节点append进页面时，该节点标签作为根节点不会显示html文档中，其里面的子节点则可以完全显示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Compile解析模板，将模板内的子元素#text添加进文档碎片节点fragment。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Compile(el,vm){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$vm = vm;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;vm为当前实例&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.$el = document.querySelector(el);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得要解析的根元素&lt;/span&gt;  
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$fragment = &lt;span&gt;this&lt;/span&gt;.nodeToFragment(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.init();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$el.appendChild(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$fragment);
    }  
}
Compile.prototype &lt;/span&gt;=&lt;span&gt; {
    nodeToFragment: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(el){
        let fragment &lt;/span&gt;=&lt;span&gt; document.createDocumentFragment();
        let child;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (child =&lt;span&gt; el.firstChild){
            fragment.appendChild(child);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;append相当于剪切的功能&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fragment;
        
    },
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明：&lt;/p&gt;
&lt;p&gt;因为我们的模板只含有一个文本节点#text，因此compileElement方法执行后会进入_this.compileText(node,reg.exec(node.textContent)[1]);//#text,'name'&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
Compile.prototype =&lt;span&gt; {
    nodeToFragment: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(el){
        let fragment &lt;/span&gt;=&lt;span&gt; document.createDocumentFragment();
        let child;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (child =&lt;span&gt; el.firstChild){
            fragment.appendChild(child);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;append相当于剪切的功能&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fragment;
        
    },
    
    init: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.compileElement(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$fragment);
    },
    
    compileElement: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(node){
        let childNodes &lt;/span&gt;=&lt;span&gt; node.childNodes;
        const _this &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        let reg &lt;/span&gt;= /\{\{(.*)\}\}/&lt;span&gt;g;
        [].slice.call(childNodes).forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(node){
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_this.isElementNode(node)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果为元素节点，则进行相应操作&lt;/span&gt;
&lt;span&gt;                _this.compile(node);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (_this.isTextNode(node) &amp;amp;&amp;amp;&lt;span&gt; reg.test(node.textContent)){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果为文本节点，并且包含data属性(如{{name}}),则进行相应操作&lt;/span&gt;
                _this.compileText(node,reg.exec(node.textContent)[1]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#text,'name'&lt;/span&gt;
&lt;span&gt;            }
            
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.childNodes &amp;amp;&amp;amp;&lt;span&gt; node.childNodes.length){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果节点内还有子节点，则递归继续解析节点&lt;/span&gt;
&lt;span&gt;                _this.compileElement(node);
                
            }
        })
    },
    compileText: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(node,exp){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#text,'name'&lt;/span&gt;
            compileUtil.text(node,&lt;span&gt;this&lt;/span&gt;.$vm,exp);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#text,vm,'name'&lt;/span&gt;
    },&lt;br/&gt;};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CompileText()函数实现初始化渲染页面视图（将data.name的值通过#text.textContent = data.name显示在页面上），并且为每个DOM节点添加一个监听数据的订阅者（这里是为#text节点新增一个Wather）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
let updater =&lt;span&gt; {
    textUpdater: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(node,value){   
        node.textContent &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt; value == 'undefined' ? ''&lt;span&gt; : value;
    },&lt;/span&gt;&lt;span&gt;
}
    
let compileUtil &lt;/span&gt;=&lt;span&gt; {&lt;/span&gt;&lt;span&gt;
    text: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(node,vm,exp){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#text,vm,'name'&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.bind(node,vm,exp,'text'&lt;span&gt;);
    },&lt;/span&gt;&lt;span&gt;
    
    bind: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;(node,vm,exp,dir){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#text,vm,'name','text'&lt;/span&gt;
        let updaterFn = updater[dir + 'Updater'&lt;span&gt;];
        updaterFn &lt;/span&gt;&amp;amp;&amp;amp; updaterFn(node,&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._getVMVal(vm,exp));
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Watcher(vm,exp,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value){
            updaterFn &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; updaterFn(node,value)
        });
        console.log(&lt;/span&gt;'加进去了'&lt;span&gt;);
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们完成了一个能实现文本节点解析的Compile()函数，接下来我们实现一个Watcher()函数。&lt;/p&gt;
&lt;h2&gt;实现Watcher&lt;/h2&gt;
&lt;p&gt; 我们前面讲过，&lt;span&gt;Observe()函数实现data对象的属性劫持，并在属性值改变时触发订阅器的notify()通知订阅者Watcher&lt;/span&gt;，订阅者就会调用自身的update方法实现视图更新。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Compile()函数负责解析模板，初始化页面，并且为每个data属性新增一个监听数据的订阅者（new Watcher）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Watcher订阅者作为Observer和Compile之间通信的桥梁，所以我们可以大致知道Watcher的作用是什么。&lt;/p&gt;
&lt;p&gt;主要做的事情是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在自身实例化时往订阅器(dep)里面添加自己。&lt;/li&gt;
&lt;li&gt;自身必须有一个update()方法 。&lt;/li&gt;
&lt;li&gt;待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 先给出全部代码，再分析具体的功能。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Watcher&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Watcher(vm, exp, cb) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vm =&lt;span&gt; vm;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cb =&lt;span&gt; cb;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.exp =&lt;span&gt; exp;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value = &lt;span&gt;this&lt;/span&gt;.get();&lt;span&gt;//初始化时&lt;/span&gt;&lt;span&gt;将自己添加进订阅器&lt;/span&gt;
&lt;span&gt;};

Watcher.prototype &lt;/span&gt;=&lt;span&gt; {
    update: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.run();
    },
    run: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        const value &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.vm[this.exp];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log('me:'+value);&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cb.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.vm,value);
        }
    },
    get: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() { 
        Dep.target &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缓存自己&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; value = &lt;span&gt;this&lt;/span&gt;.vm[&lt;span&gt;this&lt;/span&gt;.exp]  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问自己,执行defineProperty里的get函数         &lt;/span&gt;
        Dep.target = &lt;span&gt;null&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 释放自己&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里列出Observe和Dep，方便理解&lt;/span&gt;
Observe.prototype =&lt;span&gt; {
    defineReactive: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data,key,value){
        let dep &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dep();
        Object.defineProperty(data,key,{
            enumerable: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可枚举&lt;/span&gt;
            configurable: &lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能再define&lt;/span&gt;
            get: &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                console.log(&lt;/span&gt;'你访问了' +&lt;span&gt; key);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;说明这是实例化Watcher时引起的，则添加进订阅器&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Dep.target){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log('访问了Dep.target');&lt;/span&gt;
&lt;span&gt;                    dep.addSub(Dep.target);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
            },
        })
    }
}

Dep.prototype &lt;/span&gt;=&lt;span&gt; {
    addSub: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(sub){&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subs.push(sub);
    },
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们知道在Observe()函数执行时，我们为每个属性都添加了一个订阅器dep，而&lt;span&gt;这个dep被闭包在属性的get/set函数内&lt;/span&gt;。所以，我们可以在实例化Watcher时调用this.get()函数访问data.name属性，这会触发defineProperty()函数内的get函数，&lt;code&gt;get&lt;/code&gt;方法执行的时候，就会在属性的订阅器&lt;code&gt;dep&lt;/code&gt;添加当前watcher实例，从而在属性值有变化的时候，watcher实例就能收到更新通知。&lt;/p&gt;
&lt;p&gt;那么Watcher()函数中的get()函数内&lt;span&gt;Dep.taeger = this又有什么特殊的含义呢？&lt;/span&gt;我们希望的是在实例化Watcher时将相应的Watcher实例添加一次进dep订阅器即可，而不希望在以后每次访问data.name属性时都加入一次dep订阅器。所以我们在实例化执行this.get()函数时用Dep.target = this来标识当前Watcher实例，当添加进dep订阅器后设置Dep.target=null。&lt;/p&gt;
&lt;h2&gt;实现VMVM&lt;/h2&gt;
&lt;p&gt;MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&amp;gt; 视图更新；视图交互变化(input) -&amp;gt; 数据model变更的双向绑定效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; MVVM(options) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$options = options ||&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;this&lt;/span&gt;._data = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$options.data;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _this = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据代理&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实现 vm._data.xxx -&amp;gt; vm.xxx &lt;/span&gt;
    Object.keys(data).forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(key) {
        _this._proxyData(key);
    });
    observe(data, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);
    &lt;span&gt;this&lt;/span&gt;.$compile = &lt;span&gt;new&lt;/span&gt; Compile(options.el || document.body, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以下是vue的分析文章，对我理解vue起到很大的帮助。感谢作者对自己知识的分享。&lt;/p&gt;
&lt;p id=&quot;articleTitle&quot; class=&quot;h1 post-topheader__info--title&quot; data-id=&quot;1190000004384515&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000004384515&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;vue 源码分析之如何实现 observer 和 watcher&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/DMQ/mvvm&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;剖析vue实现原理，自己动手实现mvvm&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;title&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/youngwind/blog&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;对vue早期源码的理解&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 04 Aug 2018 03:03:00 +0000</pubDate>
<dc:creator>余大彬</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuliangbin/p/9302721.html</dc:identifier>
</item>
<item>
<title>javascript基础修炼(3)—What's this(下) - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9410498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9410498.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;开发者的javascript造诣取决于对【动态】和【异步】这两个词的理解水平。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201807/20/0dfe42ec5affd6fb0c56f9a341e6ab7b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一期主要分析各种实际开发中各种复杂的&lt;code&gt;this&lt;/code&gt;指向问题。&lt;/p&gt;
&lt;h2 id=&quot;一.-严格模式&quot;&gt;一. 严格模式&lt;/h2&gt;
&lt;p&gt;严格模式是&lt;strong&gt;ES5&lt;/strong&gt;中添加的&lt;code&gt;javascript&lt;/code&gt;的另一种运行模式，它可以禁止使用一些语法上不合理的部分，提高编译和运行速度，但语法要求也更为严格，使用&lt;code&gt;use strict&lt;/code&gt;标记开启。&lt;/p&gt;
&lt;p&gt;严格模式中&lt;code&gt;this&lt;/code&gt;的默认指向不再为全局对象，而是默认指向&lt;code&gt;undefined&lt;/code&gt;。这样限制的好处是在使用构造函数而忘记写&lt;code&gt;new&lt;/code&gt;操作符时会报错，而不会把本来需要绑定在实例上的一堆属性全绑在&lt;code&gt;window&lt;/code&gt;对象上，在许多没有正确地绑定&lt;code&gt;this&lt;/code&gt;的场景中也会报错。&lt;/p&gt;
&lt;h2 id=&quot;二.-函数和方法的嵌套与混用&quot;&gt;二. 函数和方法的嵌套与混用&lt;/h2&gt;
&lt;p&gt;词法定义并不影响&lt;code&gt;this&lt;/code&gt;的指向 , 因为&lt;code&gt;this&lt;/code&gt;是运行时确定指向的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 函数定义的嵌套&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function outerFun(){
    function innerFun(){
        console.log('innerFun内部的this指向了：',this);
    }
    innerFun();
}
outerFun();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出的&lt;code&gt;this&lt;/code&gt;指向全局对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 对象属性的嵌套&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当调用的函数在对象结构上的定义具有一定深度时，&lt;code&gt;this&lt;/code&gt;指向&lt;strong&gt;这个方法所在的对象&lt;/strong&gt;，而不是最外层的对象。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var IronMan = {
    realname:'Tony Stark',
    rank:'1',
    ability:{
        total_types:100,
        fly:function(){
            console.log('IronMan.ability.fly ，作为方法调用时this指向：',this);
        },
        
    }
}
IronMan.ability.fly();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出的&lt;code&gt;this&lt;/code&gt;指向&lt;strong&gt;IronMan&lt;/strong&gt;的&lt;em&gt;ability&lt;/em&gt;属性所指向的对象，调用&lt;code&gt;fly( )&lt;/code&gt;这个方法的对象是&lt;code&gt;IronMan.ability&lt;/code&gt;所指向的对象，而不是&lt;code&gt;IronMan&lt;/code&gt;所指向的对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;作为对象方法调用时，标识着这个方法是如何被找到的。&lt;code&gt;IronMan&lt;/code&gt;这个标识符指向的对象信息并不能在运行时找到&lt;code&gt;fly( )&lt;/code&gt;这个方法的位置，因为&lt;em&gt;ability&lt;/em&gt;属性中只存了另一个对象的引用地址，而&lt;code&gt;IronMan.ability&lt;/code&gt;对象的&lt;em&gt;fly&lt;/em&gt;属性所记录的指向，才能让引擎在运行时找到这个匿名方法。&lt;/p&gt;
&lt;h2 id=&quot;三.-引用转换&quot;&gt;三. 引用转换&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;引用转换&lt;/em&gt;实际上并不会影响&lt;code&gt;this&lt;/code&gt;的指向，因为它是词法性质的，发生在定义时，而&lt;code&gt;this&lt;/code&gt;的指向是运行时确定的。只要遵循&lt;strong&gt;this指向的基本原则&lt;/strong&gt;就不难理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 标识符引用转换为对象方法引用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var originFun = function (){
    console.log('originFun内部的this为:',this);
}
var ironMan = {
    attack:originFun
};
ironMan.attack();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;this&lt;/code&gt;指向其调用者，也就是&lt;code&gt;ironMan&lt;/code&gt;引用的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2 对象方法转换为标识符引用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var ironMan = {
    attack:function(){
        console.log('对象方法中this指向了：',this);
    }
}
var originFun = ironMan.attack;
originFun();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;this&lt;/code&gt;指向全局对象，浏览器中也就是&lt;code&gt;window&lt;/code&gt;对象。3.2中的示例被认为是javascript语言的bug，即&lt;strong&gt;this指向丢失&lt;/strong&gt;的问题。同样的问题也可能在回调函数传参时发生，本文【第5章】将对这种情况进行详细说明。&lt;/p&gt;
&lt;h2 id=&quot;四.-回调函数&quot;&gt;四. 回调函数&lt;/h2&gt;
&lt;p&gt;javascript中的函数是可以被当做参数传递进另一个函数中的，也就有了&lt;strong&gt;回调函数&lt;/strong&gt;这样一个概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1 this在回调函数中的表现&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;  var IronMan = {
       attack:function(findEnemy){
           findEnemy();
       }
  }

  function findEnemy(){
     console.log('已声明的函数被当做回调函数调用，this指向:',this);
  }

  var attackAction = {
      findEnemy:function(){
        console.log('attackAction.findEnemy本当做回调函数调用时，this指向',this);
      },
      isArmed:function(){
        console.log('check whether the actor is Armed');
      }
  }

  //1.直接传入匿名函数
  IronMan.attack(function(){
      console.log(this);
  });

  //2.传入外部定义函数
  IronMan.attack(findEnemy);

  //3.传入外部定义的对象方法
  IronMan.attack(attackAction.findEnemy);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从控制台打印的结果来看，无论以哪种方式来传递回调函数，回调函数执行时的&lt;code&gt;this&lt;/code&gt;都指向了全局变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2 原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;javascript中函数传参全部都是值传递，也就是说如果调用函数时传入一个原始类型，则会把这个值赋值给对应的形参；如果传入一个引用类型，则会把其中保存的内存指向的地址赋值给对应的形参。所以在函数内部操作一个值为引用类型的形参时，会影响到函数外部作用域，因为它们均指向内存中的同一个函数。详细可参考&lt;a href=&quot;https://www.cnblogs.com/xiaohuochai/p/5706289.html&quot;&gt;[深入理解javascript函数系列第二篇——函数参数]&lt;/a&gt;这篇博文。&lt;/p&gt;
&lt;p&gt;理解了函数传参，就很容易理解回调函数中&lt;code&gt;this&lt;/code&gt;为何指向全局了，回调函数对应的形参是一个引用类型的标识符，其中保存的地址直接指向这个函数在内存中的真实位置，那么通过执行这个标识符来调用函数就等同于&lt;strong&gt;this基本指向规则&lt;/strong&gt;中的&lt;em&gt;作为函数来调用&lt;/em&gt;的情况，其&lt;code&gt;this&lt;/code&gt;指向全局对象也就不难理解了。&lt;/p&gt;
&lt;h2 id=&quot;五.-this指针丢失&quot;&gt;五. this指针丢失&lt;/h2&gt;
&lt;p&gt;在第三节和第四节中，通过原理分析就能够明白为何在一些特定的场合下&lt;code&gt;this&lt;/code&gt;会指向全局对象，但是从语言的角度来看，却很难理解&lt;code&gt;this&lt;/code&gt;为什么指向了全局对象，因为这个规则和语法的字面意思是有冲突的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.1 回调函数的字面语境&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var name = 'HanMeiMei';
var liLei = {
      name:'liLei',
      introduce:function () {
          console.log('My name is ', this.name);
         }
    };
var liLeiSay = liLei.introduce;
liLeiSay();//同第三节中的引用转换示例
setTimeout(liLei.introduce,2000);//同第四节中的回调函数示例&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码从字面上看意义是很明确的，就是希望&lt;strong&gt;liLei&lt;/strong&gt;立刻介绍一下自己，在2秒后再介绍一下他自己。但控制台输出的结果中，他却两次都说自己的名字是&lt;em&gt;HanMeiMei&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.2 this指针丢失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5.1中的示例，也称为&lt;strong&gt;this指针丢失问题&lt;/strong&gt;,被认为是Javascript语言的设计失误，因为这种设计在字面语义上造成了混乱。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.3 this指针修复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式1-使用bind&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了使代码的字面语境和实际执行保持一致，需要通过&lt;strong&gt;显示指定this&lt;/strong&gt;的方式对&lt;code&gt;this&lt;/code&gt;的指向进行修复。常用的方法是使用&lt;code&gt;bind( )&lt;/code&gt;生成一个确定了&lt;code&gt;this&lt;/code&gt;指向的新函数，将上述示例改为如下方式即可修复&lt;code&gt;this&lt;/code&gt;的指向:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var liLeiSay = liLei.introduce.bind(liLei);
setTimeout(liLei.introduce.bind(liLei),2000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bind( )&lt;/code&gt;的实现其实并不复杂，是闭包实现高阶函数的一个简单的实例，感兴趣的读者可以自行了解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式2-使用Proxy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Proxy是&lt;code&gt;ES6&lt;/code&gt;中才支持的方法。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//绑定This的函数
function fixThis (target) {
    const cache = new WeakMap();
    //返回一个新的代理对象
    return new Proxy(target, {
        get (target, key) {
          const value = Reflect.get(target, key);
          //如果要取的属性不是函数，则直接返回属性值
          if (typeof value !== 'function') {
            return value;
          }
          if (!cache.has(value)) {
            cache.set(value, value.bind(target));
          }
          return cache.get(value);
        }
    });
}

const toggleButtonInstance = fitThis(new ToggleButton());&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;两种修复&lt;code&gt;this&lt;/code&gt;指向的思路其实很类似，第一种方式相当于为调用的方法创建了一个&lt;code&gt;代理方法&lt;/code&gt;，第二种方式是为被访问的对象创建了一个&lt;code&gt;代理对象&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;六.-this的透传&quot;&gt;六. this的透传&lt;/h2&gt;
&lt;p&gt;实际开发过程中，往往需要在更深层次的函数中获取外层&lt;code&gt;this&lt;/code&gt;的指向。&lt;/p&gt;
&lt;p&gt;常规的解决方案是：将外层函数的&lt;code&gt;this&lt;/code&gt;赋值给一个局部变量，通会使用&lt;code&gt;_this&lt;/code&gt;,&lt;code&gt;that&lt;/code&gt;,&lt;code&gt;self&lt;/code&gt;,&lt;code&gt;_self&lt;/code&gt;等来作为变量名保存当前作用域中的&lt;code&gt;this&lt;/code&gt;。由于在&lt;code&gt;javascript&lt;/code&gt;中作用域链的存在，嵌套的内部函数可以调用外部函数的局部变量，标识符会去寻找距离作用域链末端最近的一个指向作为其值，示例如下:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;document.querySelector('#btn').onclick = function(){
    //保存外部函数中的this
    var _this = this;
    _.each(dataSet, function(item, index){
        //回调函数的this指向了全局，调用外部函数的this来操作DOM元素
        _this.innerHTML += item;
    });  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;七.-事件监听&quot;&gt;七. 事件监听&lt;/h2&gt;
&lt;p&gt;事件监听中&lt;code&gt;this&lt;/code&gt;的指向情况其实是几种情况的集合，与代码如何编写有很大关系。&lt;/p&gt;
&lt;h3 id=&quot;表现&quot;&gt;7.1 表现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 在html文件中使用事件监听相关的属性来触发方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;button onclick=&quot;someFun()&quot;&amp;gt;点击按钮&amp;lt;/button&amp;gt;
&amp;lt;button onclick=&quot;someObj.someFun()&quot;&amp;gt;点击按钮&amp;lt;/button&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果以第一种方式触发，则函数中的&lt;code&gt;this&lt;/code&gt;指向全局；&lt;/p&gt;
&lt;p&gt;如果以第二种方式触发,则函数中的&lt;code&gt;this&lt;/code&gt;指向&lt;em&gt;someObj&lt;/em&gt;这个对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 在js文件中直接为属性赋值&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//声明一个函数 
function callFromHTML() {
          console.log('callFromHTML,this指向：',this);
}
//定义一个对象方法
var obj = {
        callFromObj:function () {
            console.log('callFromObj',this);
        }
      }
//注册事件监听-方式1 
document.querySelector('#btn').onclick = function (event) {
          console.log(this);
} 
//注册事件监听-方式2
document.querySelector('#btn').onclick = callFromHTML;

//注册事件监听-方式3
document.querySelector('#btn').onclick = obj.callFromObj;
 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上三种注册的事件监听响应函数，其&lt;code&gt;this&lt;/code&gt;均指向&lt;code&gt;id=&quot;btn&quot;&lt;/code&gt;的DOM元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 使用&lt;code&gt;addEventListener&lt;/code&gt;方法注册响应函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//低版本IE浏览器中需要使用另外的方法
document.querySelector('#btn').addEventListener('click',function(event){
    console.log(this);
});
//也可以将函数名或对象方法作为回调函数传入
document.querySelector('#btn').addEventListener('click',callFromHTML);
document.querySelector('#btn').addEventListener('click',obj.callFromObj);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式注册的响应函数，其&lt;code&gt;this&lt;/code&gt;与&lt;strong&gt;场景2&lt;/strong&gt;相同，均指向&lt;code&gt;id=&quot;btn&quot;&lt;/code&gt;的DOM元素。区别在于使用&lt;code&gt;addEventListener&lt;/code&gt;方法添加的响应函数会依次执行，而采用&lt;strong&gt;场景2&lt;/strong&gt;的方式时，只有最后一次赋值的函数会被调用。&lt;/p&gt;
&lt;h3 id=&quot;基本原理&quot;&gt;7.2 基本原理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 通过标签属性注册&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;button id=&quot;btn&quot; onclick=&quot;callFromHTML()&quot;&amp;gt;点我&amp;lt;/button&amp;gt;
&amp;lt;script&amp;gt;
   function callFromHTML() {
          console.log(document.querySelector('#btn').onclick);
   }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在html中绑定事件处理程序，然后当按钮点击时，在控制台打印出DOM对象的&lt;code&gt;onclick&lt;/code&gt;属性,可以看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201807/20/c1391a7e56f2e6af999163dbb64540cc.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种绑定方式其实是将监听方法包裹在另一个函数中去执行，相当于:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;document.querySelector('#btn').onclick = function(event){
    callFromHTML();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样上述的表现就不难理解了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 通过元素对象属性注册&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;document&lt;/code&gt;在javascript中是一个对象，通过其暴露的查找方法返回的节点也是一个对象，那么方式二绑定的监听函数在运行时，实际上就是在执行指定节点的&lt;code&gt;onclick&lt;/code&gt;方法，根据&lt;strong&gt;this指向的基本规则&lt;/strong&gt;可知其函数体中的&lt;code&gt;this&lt;/code&gt;应该指向调用对象，也就是&lt;code&gt;onclick&lt;/code&gt;这个方法所在的节点对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 通过&lt;code&gt;addEventListener&lt;/code&gt;方法注册&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种方式是在DOM2事件模型中扩展的，用于支持多个监听器绑定的场景。DOM2事件模型的描述中规定了通过这种方式添加的监听函数执行时的&lt;code&gt;this&lt;/code&gt;指向所在的节点对象，不同内核的浏览器实现方式有区别。&lt;/p&gt;
&lt;h3 id=&quot;使用建议&quot;&gt;7.3 使用建议&lt;/h3&gt;
&lt;p&gt;不同的使用方式实质上是伴随着DOM事件模型升级而发生改变的，现代浏览器对于以上几种模式都是支持的，只有需要兼容老版本浏览器时需要考虑对DOM事件模型的支持程度。开发中DOM2级事件模型中&lt;code&gt;addEventListener()&lt;/code&gt;和&lt;code&gt;removeEventListener()&lt;/code&gt;来管理事件监听函数是最为推荐的方法。&lt;/p&gt;
&lt;h2 id=&quot;八.-异步函数&quot;&gt;八. 异步函数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. setTimeout( )和setInterval( )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里的情况相当于上文中的回调函数的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 事件监听&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;详见第7章。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. ajax&lt;/strong&gt;请求&lt;/p&gt;
&lt;p&gt;几乎没有遇到过。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Promise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里的情况相当于上文中的回调函数的情况。&lt;/p&gt;
&lt;h2 id=&quot;九.-箭头函数和this&quot;&gt;九. 箭头函数和this&lt;/h2&gt;
&lt;p&gt;箭头函数是&lt;code&gt;ES6&lt;/code&gt;标准中支持的语法，它的诞生不仅仅是因为表达方式简洁，也是为了更好地支持&lt;strong&gt;函数式编程&lt;/strong&gt;。箭头函数内部不绑定&lt;code&gt;this&lt;/code&gt;,&lt;code&gt;arguments&lt;/code&gt;,&lt;code&gt;super&lt;/code&gt;,&lt;code&gt;new.target&lt;/code&gt;，所以由于作用域链的机制，箭头函数的函数体中如果使用到&lt;code&gt;this&lt;/code&gt;,则执行引擎会沿着作用域链去获取外层的&lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;十.-nodejs中的this&quot;&gt;十. Nodejs中的&lt;strong&gt;this&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Nodejs&lt;/code&gt;是一种脱离浏览器环境的&lt;code&gt;javascript&lt;/code&gt;运行环境，&lt;code&gt;this&lt;/code&gt;的指向规则上与浏览器环境在全局对象的指向上存在一定差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 全局对象global&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Nodejs&lt;/code&gt;的运行环境并不是浏览器，所以程序里没有&lt;code&gt;DOM&lt;/code&gt;和&lt;code&gt;BOM&lt;/code&gt;对象，&lt;code&gt;Nodejs&lt;/code&gt;中也存在全局作用域，用来定义一些不需要通过任何模块的加载即可使用的变量、函数或类，全局对象中多为一些系统级的信息或方法，例如获取当前模块的路径，操作进程，定时任务等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 文件级this指向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Nodejs&lt;/code&gt;是支持模块作用域的，每一个文件都是一个模块，可通过&lt;code&gt;require( )&lt;/code&gt;的方式同步引入，通过&lt;code&gt;module.exports&lt;/code&gt;来暴露接口供其他模块调用。在一个文件中最顶级的&lt;code&gt;this&lt;/code&gt;指向当前这个文件模块对外暴露的接口对象，也就是&lt;code&gt;module.exports&lt;/code&gt;指向的对象。示例:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var IronMan = {
    name:'Tony Stark',
    attack: function(){
        
    }
}
exports.IronMan = IronMan;
console.log(this);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在控制台即可看到，&lt;code&gt;this&lt;/code&gt;指向一个对象，对象中只有一个属性&lt;code&gt;IronMan&lt;/code&gt;,属性值为文件中定义的&lt;code&gt;IronMan&lt;/code&gt;这个对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 函数级this指向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;this的基本规则&lt;/strong&gt;中有一条—&lt;em&gt;当作为函数调用时，函数中的&lt;code&gt;this&lt;/code&gt;指向全局对象&lt;/em&gt;，这一条在&lt;code&gt;nodejs&lt;/code&gt;中也是成立的，这里的&lt;code&gt;this&lt;/code&gt;指向了全局对象（此处的全局对象Global对象是有别于模块级全局对象的）。&lt;/p&gt;
&lt;h2 id=&quot;思考题-react组件中为什么要bindthis&quot;&gt;思考题— React组件中为什么要bind(this)&lt;/h2&gt;
&lt;p&gt;如果你尝试使用过&lt;code&gt;React&lt;/code&gt;进行前端开发，一定见过下面这样的代码：&lt;/p&gt;
&lt;pre class=&quot;jsx&quot;&gt;
&lt;code&gt;//假想定义一个ToggleButton开关组件
class ToggleButton extends React.Component{
    constructor(props){
        super(props);
        this.state = {isToggleOn: true};
        this.handleClick = this.handleClick.bind(this); 
        this.handleChange = this.handleChange.bind(this);
    }
    handleClick(){
        this.setState(prevState =&amp;gt; ({
            isToggleOn: !preveState.isToggleOn
        }));
    }
    handleChange(){
        console.log(this.state.isToggleOn);
    }
    render(){
        return(
           &amp;lt;button onClick={this.handleClick} onChange={this.handleChange}&amp;gt;
                {this.state.isToggleOn ? 'ON':'OFF'}
            &amp;lt;/button&amp;gt;
        )
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;思考题：构造方法中为什么要给所有的实例方法绑定this呢？&lt;/strong&gt;（强烈建议读者先自己思考再看笔者分析）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 代码执行的细节&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上例仅仅是一个组件类的定义，当在其他组件中调用或是使用&lt;code&gt;ReactDOM.render( )&lt;/code&gt;方法将其渲染到界面上时会生成一个组件的实例，因为组件是可以复用的，面向对象的编程方式非常适合它的定位。根据&lt;strong&gt;this指向的基本规则&lt;/strong&gt;就可以知道，这里的&lt;code&gt;this&lt;/code&gt;最终会指向组件的实例。&lt;/p&gt;
&lt;p&gt;组件实例生成的时候，构造器&lt;code&gt;constructor&lt;/code&gt;会被执行，此处着重分析一下下面这行代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;this.handleClick = this.handleClick.bind(this);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时的&lt;code&gt;this&lt;/code&gt;指向新生成的实例，那么赋值语句右侧的表达式先查找&lt;code&gt;this.handleClick( )&lt;/code&gt;这个方法，由对象的属性查找机制（沿原型链由近及远查找）可知此处会查找到&lt;strong&gt;原型方法&lt;code&gt;this.handleClick( )&lt;/code&gt;&lt;/strong&gt;,接着执行&lt;code&gt;bind(this)&lt;/code&gt;，此处的&lt;code&gt;this&lt;/code&gt;指向新生成的实例，所以赋值语句右侧的表达式计算完成后，会生成一个指定了&lt;code&gt;this&lt;/code&gt;的新方法，接着执行赋值操作，将新生成的函数赋值给实例的&lt;code&gt;handleClick&lt;/code&gt;属性，由对象的赋值机制可知，此处的&lt;code&gt;handleClick&lt;/code&gt;会直接作为实例属性生成。总结一下，上面的语句做了一件这样的事情：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;把原型方法&lt;code&gt;handleClick( )&lt;/code&gt;改变为实例方法&lt;code&gt;handleClick( )&lt;/code&gt;,并且强制指定这个方法中的&lt;code&gt;this&lt;/code&gt;指向当前的实例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 绑定this的必要性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在组件上绑定事件监听器，是为了响应用户的交互动作，特定的交互动作触发事件时，监听函数中往往都需要操作组件某个状态的值，进而对用户的点击行为提供响应反馈，对开发者来说，这个函数触发的时候，就需要能够拿到这个组件专属的状态合集（例如在上面的开关组件&lt;code&gt;ToggleButton&lt;/code&gt;例子中，它的内部状态属性&lt;code&gt;state.isToggleOn&lt;/code&gt;的值就标记了这个按钮应该显示&lt;em&gt;ON&lt;/em&gt;或者&lt;em&gt;OFF&lt;/em&gt;），所以此处强制绑定监听器函数的&lt;code&gt;this&lt;/code&gt;指向当前实例的也很容易理解。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;React构造方法中的bind会将响应函数与这个组件Component进行绑定以确保在这个处理函数中使用this时可以时刻指向这一组件的实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;3. 如果不绑定this&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果类定义中没有绑定&lt;code&gt;this&lt;/code&gt;的指向,当用户的点击动作触发&lt;code&gt;this.handleClick( )&lt;/code&gt;这个方法时，实际上执行的是&lt;strong&gt;原型方法&lt;/strong&gt;，可这样看起来并没有什么影响，如果当前组件的构造器中初始化了&lt;code&gt;state&lt;/code&gt;这个属性，那么原型方法执行时，&lt;code&gt;this.state&lt;/code&gt;会直接获取实例的&lt;code&gt;state&lt;/code&gt;属性，如果构造其中没有初始化&lt;code&gt;state&lt;/code&gt;这个属性（比如React中的UI组件），说明组件没有自身状态，此时即使调用原型方法似乎也没什么影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事实上的确是这样，这里的&lt;code&gt;bind(this)&lt;/code&gt;所希望提前规避的，就是第五章中的this指针丢失的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例如使用&lt;em&gt;解构赋值&lt;/em&gt;的方式获取某个属性方法时，就会造成引用转换丢失this的问题:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const toggleButton = new ToggleButton();

import {handleClick} = toggleButton;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中解构赋值获取到的&lt;code&gt;handleClick&lt;/code&gt;这个方法在执行时就会报错，Class的内部是强制运行在&lt;em&gt;严格模式&lt;/em&gt;下的，此处的&lt;code&gt;this&lt;/code&gt;在赋值中丢失了原有的指向，在运行时指向了&lt;code&gt;undefined&lt;/code&gt;，而&lt;code&gt;undefined&lt;/code&gt;是没有属性的。&lt;/p&gt;
&lt;p&gt;另一个存在的限制，是没有绑定&lt;code&gt;this&lt;/code&gt;的响应函数在异步运行时可能会出问题，当它作为回调函数被传入一个异步执行的方法时，同样会因为丢失了&lt;code&gt;this&lt;/code&gt;的指向而引发错误。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果没有强制指定组件实例方法的&lt;code&gt;this&lt;/code&gt;，在将来的使用中就无法安心使用&lt;strong&gt;引用转换&lt;/strong&gt;或&lt;strong&gt;作为回调函数传递&lt;/strong&gt;这样的方式，对于后续使用和协作开发而言都是不方便的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;[1]《javascript高级程序设计（第三版）》&lt;/p&gt;
&lt;p&gt;[2]《深入理解javascript函数系列第二篇》&lt;a href=&quot;https://www.cnblogs.com/xiaohuochai/p/5706289.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/xiaohuochai/p/5706289.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3]《ES6-Class基本语法》&lt;a href=&quot;https://www.cnblogs.com/ChenChunChang/p/8296350.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/ChenChunChang/p/8296350.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 03:02:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9410498.html</dc:identifier>
</item>
<item>
<title>系统优化怎么做-Tomcat优化 - 昌松</title>
<link>http://www.cnblogs.com/changsong/p/9417879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/changsong/p/9417879.html</guid>
<description>&lt;p&gt;大家好，这里是「聊聊系统优化 」，并在下列地址同步更新&lt;/p&gt;
&lt;p&gt;在这里我会从基于J2EE系统及互联网架构方面,来谈谈系统优化的各个方面,干货满满,欢迎订阅及关注!&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;Tomcat作为Web应用的服务器，目前绝大多数公司都是用其作为应用服务器的，应用服务器的执行效率会影响系统执行，这里会讲Tomcat怎样进行配置能提高处理性能。另外必须提到对应的JVM参数的优化的一些经验。&lt;/p&gt;
&lt;h2&gt;Tomcat运行模式&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;分3种模式: bio,nio,apr 一般使用nio模式&lt;br/&gt;bio效率低,apr对系统配置有一些比较高的要求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;确认Tomcat的运行模式&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置文件 server.xml&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Executor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;tomcatThreadPool&quot;&lt;/span&gt;&lt;span&gt; 
namePrefix&lt;/span&gt;&lt;span&gt;=&quot;catalina-exec-&quot;&lt;/span&gt;&lt;span&gt; 
maxThreads&lt;/span&gt;&lt;span&gt;=&quot;1024&quot;&lt;/span&gt;&lt;span&gt; 
minSpareThreads&lt;/span&gt;&lt;span&gt;=&quot;512&quot;&lt;/span&gt;&lt;span&gt; 
prestartminSpareThreads&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2&gt;关键配置&lt;/h2&gt;
&lt;p&gt;maxThreads&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最大线程数, 默认是200&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;minSpareThread&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最小活跃线程数, 默认是25&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;maxQueueSize&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最大的等待队列个数，超过则请求拒绝默认值是Integer.MAX_VALUE ，一般不改变。在某些紧急状态修复问题需要调整&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;连接器（Connector）优化&lt;/h2&gt;
&lt;p&gt;Connector是连接器，负责接收客户的请求，以及向客户端回送响应的消息。所以Connector的优化是重要部分。默认情况下 Tomcat只支持200线程访问，超过这个数量的连接将被等待甚至超时放弃，所以我们需要提高这方面的处理能力。&lt;/p&gt;
&lt;p&gt;nio配置- server.xml&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Connector &lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;=&quot;14081&quot;&lt;/span&gt;&lt;span&gt; protocol&lt;/span&gt;&lt;span&gt;=&quot;org.apache.coyote.http11.Http11NioProtocol&quot;&lt;/span&gt;&lt;span&gt;
connectionTimeout&lt;/span&gt;&lt;span&gt;=&quot;20000&quot;&lt;/span&gt;&lt;span&gt;
executor&lt;/span&gt;&lt;span&gt;=&quot;tomcatThreadPool&quot;&lt;/span&gt;&lt;span&gt; 
URIEncoding&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt; 
compression&lt;/span&gt;&lt;span&gt;=&quot;on&quot;&lt;/span&gt;&lt;span&gt;   
useBodyEncodingForURI&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; 
enableLookups&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; 
redirectPort&lt;/span&gt;&lt;span&gt;=&quot;14443&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;影响性能配置&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;org.apache.coyote.http11.Http11Protocol&lt;/code&gt; - 阻塞式的Java连接器&lt;br/&gt;&lt;code&gt;org.apache.coyote.http11.Http11NioProtocol&lt;/code&gt; - 不阻塞Java连接器&lt;br/&gt;&lt;code&gt;org.apache.coyote.http11.Http11AprProtocol&lt;/code&gt; - APR / native 连接器&lt;br/&gt;选择不阻塞ava连接器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;enableLookups&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;若是你想request.getRemoteHost()的调用履行，以便返回的长途客户端的实际主机名的DNS查询，则设置为true。设置为false时跳过DNS查找，并返回字符串的IP地址（从而提高性能）。默认场景下，禁用DNS查找&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;compression&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;设置成on,开启压缩&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;禁用AJP链接器&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用Nginx+tomcat的架构，用不着AJP协议，所以把AJP连接器禁用&lt;br/&gt;server.xml注释掉一下配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Connector &lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;=&quot;8019&quot;&lt;/span&gt;&lt;span&gt; protocol&lt;/span&gt;&lt;span&gt;=&quot;AJP/1.3&quot;&lt;/span&gt;&lt;span&gt; redirectPort&lt;/span&gt;&lt;span&gt;=&quot;8443&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;优化JVM&lt;/h2&gt;
&lt;p&gt;/bin/catalina.sh&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;修改JAVA_OPTS参数&lt;br/&gt;这里需要参照机器配置，对JVM进行参数优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JDK1.7&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
JAVA_OPTS=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms512m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=1024M -XX:PermSize=1024m -XX:MaxPermSize=1024m -XX:+DisableExplicitGC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JDK1.8&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
JAVA_OPTS=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Djava.awt.headless=true -Dfile.encoding=UTF-8 -server -Xms1024m -Xmx1024m -XX:NewSize=512m -XX:MaxNewSize=1024M -XX:+DisableExplicitGC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;1.8 版本中已经没有PermSize、MaxPermSize&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;JAVA8里对metaspace可以在小范围自动扩展永生代避免溢出。&lt;/p&gt;
&lt;h2&gt;参数说明&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;-Djava.awt.headless&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;没有设备、键盘或鼠标的模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-Dfile.encoding&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;设置字符集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;vm的server工作模式，对应的有client工作模式。使用“java -version”可以查看当前工作模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;初始Heap大小，使用的最小内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Java heap最大值，使用的最大内存&lt;br/&gt;经验: 设置Xms大小等于Xmx大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:NewSize=512m&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;表示新生代初始内存的大小，应该小于 -Xms的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:MaxNewSize=1024M&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;表示新生代可被分配的内存的最大上限，应该小于 -Xmx的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:PermSize=1024m&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;设定内存的永久保存区域,内存的永久保存区域，VM 存放Class 和 Meta 信息，JVM在运行期间不会清除该区域&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;程序加载很多class情况下，超出PermSize情况下&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;JDK1.7会抛出java.lang.OutOfMemoryError: PermGen space异常&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;JDK1.8下会抛出 ERROR: java.lang.Out&lt;/em&gt;OfMemoryError&lt;em&gt;: Metadata space 异常&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-XX:MaxPermSize=1024m&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;设定最大内存的永久保存区域&lt;br/&gt;经验: 设置PermSize大小等于MaxPermSize大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:+DisableExplicitGC&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;自动将System.gc()调用转换成一个空操作，即应用中调用System.gc()会变成一个空操作,避免程序员在代码里进行System.gc()这种危险操作。System.gc() 除非是到了万不得也的情况下不使用，都交给JVM吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;其他优化参数&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;-XX:SurvivorRatio=2&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;年轻代中Eden区与Survivor区的大小比值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:ReservedCodeCacheSize=256m&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;保留代码占用的内存容量，无大的影响&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;单个线程堆栈大小值，减少这个值可以生成更多线程，操作系统对于一个进程内的线程数是有限制的，经验值在3000-5000左右&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:+CMSParallelRemarkEnabled&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;CMS 垃圾回收算法，对响应时间的重要性需求 大于 对吞吐量的要求，能够承受垃圾回收线程和应用线程共享处理器资源，并且应用中存在比较多的长生命周期的对象的应用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:+UseCMSCompactAtFullCollection&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;在使用concurrent gc 的情况下, 防止 memoryfragmention, 对live object 进行整理, 使 memory 碎片减少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:+UseCMSInitiatingOccupancyOnly&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在FULL GC的时候， 对年老代的压缩。CMS是不会移动内存的， 因此这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。可能会影响性能,但是可以消除碎片。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:CMSInitiatingOccupancyFraction=60&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用cms作为垃圾回收, 使用60％后开始CMS收集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:+UseGCOverheadLimit&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;用来限制使用内存，如果不做控制，可能会报出&lt;br/&gt;java.lang.OutOfMemoryError: GC overhead limit exceeded&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:+UseConcMarkSweepGC&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;使用CMS内存收集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:+UseParNewGC&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;设置年轻代为并行收集&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/li&gt;
&lt;li&gt;-XX:HeapDumpPath=/x/dump_tomcat.hprof&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;JVM会在遇到OutOfMemoryError时拍摄一个“堆转储快照”，并将其保存在一个文件中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-Xloggc:/xx/gc_tomcat.log&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;gc的日志，如果该日志中出现频繁的Full GC就是有相关的系统问题，如果很少，说明暂时还算正常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:+PrintGCDateStamps&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输出GC的时间戳（以基准时间的形式）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-XX:+PrintGCDetails&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;输出GC的日志格式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-Dnetworkaddress.cache.ttl=60&lt;/li&gt;
&lt;li&gt;-Dsun.net.inetaddr.ttl=60&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;设置DNS缓存时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-DautoStartup=false&lt;/li&gt;
&lt;li&gt;-Dsun.net.client.defaultConnectTimeout=60000&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;连接建立超时时间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-Dsun.net.client.defaultReadTimeout=60000&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;内容获取超时设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-Djmagick.systemclassloader=no&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;是否生成缩略图的一个框架的配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;-Djava.security.egd=file:/dev/./urandom&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;最佳实践&lt;/h2&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
export JAVA_OPTS=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-server -showversion -Xms2000m -Xmx2000m -Xmn500m -XX:PermSize=256m -XX:MaxPermSize=256m -XX:SurvivorRatio=2 -XX:ReservedCodeCacheSize=256m -Xss1024k -Djava.awt.headless=true -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=60 -XX:+UseGCOverheadLimit -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tomcat_path/logs/dump_tomcat.hprof -Xloggc:/tomcat_path/logs/gc_tomcat.log -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCDetails -Dnetworkaddress.cache.ttl=60 -Dsun.net.inetaddr.ttl=60 -DautoStartup=false -Dsun.net.client.defaultConnectTimeout=60000 -Dsun.net.client.defaultReadTimeout=60000 -Djmagick.systemclassloader=no -Djava.security.egd=file:/dev/./urandom -Dfile.encoding=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;常见JVM异常&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;java.lang.OutOfMemoryError: Java heap space —-JVM Heap（堆）溢出&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JVM 在启动的时候会自动设置 JVM Heap 的值，其初始空间（即-Xms）是物理内存的1/64，最大空间（-Xmx）不可超过物理内存。可以利用 JVM提供的 -Xmn -Xms -Xmx 等选项可进行设置。Heap 的大小是 Young Generation 和 Tenured Generaion 之和。在 JVM 中如果 98％ 的时间是用于 GC，且可用的 Heap size 不足 2％ 的时候将抛出此异常信息。&lt;/p&gt;
&lt;p&gt;解决方法：手动设置 JVM Heap（堆）的大小。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java.lang.OutOfMemoryError: PermGen space —- PermGen space溢出。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;jdk1.8 抛出 ERROR: java.lang.OutOfMemoryError: Metadata space 异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PermGen space 的全称是 Permanent Generation space，是指内存的永久保存区域。为什么会内存溢出，这是由于这块内存主要是被 JVM 存放Class 和 Meta 信息的，Class 在被 Load 的时候被放入 PermGen space 区域，它和存放 Instance 的 Heap 区域不同，sun 的 GC 不会在主程序运行期对 PermGen space 进行清理，所以如果你的 APP 会载入很多 CLASS 的话，就很可能出现 PermGen space 溢出。&lt;/p&gt;
&lt;p&gt;解决方法： 手动设置 MaxPermSize 大小&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java.lang.StackOverflowError —- 栈溢出&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;栈溢出了，JVM 依然是采用栈式的虚拟机。函数的调用过程都体现在堆栈和退栈上了。调用构造函数的 “层”太多了，以致于把栈区溢出了。通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K 的空间（这个大约相当于在一个 C 函数内声明了 256 个 int 类型的变量），那么栈区也不过是需要 1MB 的空间。通常栈的大小是 1－2MB 的。&lt;br/&gt;通常递归也不要递归的层次过多，很容易溢出。&lt;/p&gt;
&lt;h2&gt;思考题&lt;/h2&gt;
&lt;p&gt;1. 线上应用系统出现问题，怎么快速定位系统哪块资源问题&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 02:57:00 +0000</pubDate>
<dc:creator>昌松</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/changsong/p/9417879.html</dc:identifier>
</item>
<item>
<title>【设计模式】建造者模式 Builder Pattern - 蓝之风</title>
<link>http://www.cnblogs.com/vaiyanzi/p/9417860.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vaiyanzi/p/9417860.html</guid>
<description>&lt;p&gt;前面学习了&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/9336554.html&quot;&gt;简单工厂模式&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/9359474.html&quot;&gt;工厂方法模式&lt;/a&gt;以及&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/9388665.html&quot;&gt;抽象工厂模式&lt;/a&gt;，这些都是创建类的对象所使用的一些常用的方法和套路， 那么如果我们创建一个很复杂的对象可上面的三种方法都不太适合，那么“专业的事交给专业人去做”，23设计模式总有一个模式是适合这种复杂对象的创建。比如现在的智能手机组成, 它包括一个屏幕，摄像头，耳机接口，USB接口，CPU， RAM，主板等等, 但是每一个型号的手机的屏幕又不一样，有的是刘海的，有的是全屏的，有的是全面屏的，CUP 也不一样，有骁龙820 的，有 660的还有麒麟920 的等等，手机的组成图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105328870-858804143.png&quot;&gt;&lt;img title=&quot;image_thumb4&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105331909-1222406053.png&quot; alt=&quot;image_thumb4&quot; width=&quot;737&quot; height=&quot;673&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105340433-1162984452.png&quot;&gt;&lt;img title=&quot;image_thumb6&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105343069-1156153538.png&quot; alt=&quot;image_thumb6&quot; width=&quot;739&quot; height=&quot;442&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;那么要创建一个这样的复杂对象, 该怎么创建呢？ 那么该建造者模式闪亮登场了。&lt;/p&gt;
&lt;h2&gt;一、建造者模式定义&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;二、建造者模式结构图&lt;/h2&gt;
&lt;p&gt; &lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105350397-1622998081.png&quot;&gt;&lt;img title=&quot;image_thumb18&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105351295-603946796.png&quot; alt=&quot;image_thumb18&quot; width=&quot;900&quot; height=&quot;463&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1、AbstractBuilder（抽象建造者）：&lt;/h3&gt;
&lt;p&gt;它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是GetResult()，它们用于返回复杂对象。AbstractBuilder既可以是抽象类，也可以是接口。&lt;/p&gt;
&lt;h3&gt;2、ConcreteBuilder（具体建造者）：&lt;/h3&gt;
&lt;p&gt;它实现了AbstractBuilder接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。&lt;/p&gt;
&lt;h3&gt;3、Product（产品角色）：&lt;/h3&gt;
&lt;p&gt;它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。&lt;/p&gt;
&lt;h3&gt;4、Director（导演）：&lt;/h3&gt;
&lt;p&gt;负责安排复杂对象的建造次序，导演与抽象建造者之间存在关联关系，可以在其Construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数将该对象传入指挥者类中。&lt;/p&gt;
&lt;h2&gt;三、建造者模式典型代码结构&lt;/h2&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Product
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PartA { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PartB { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PartC { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractBuilder
{
    &lt;span&gt;protected&lt;/span&gt; Product product = &lt;span&gt;new&lt;/span&gt; Product();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildPartA();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildPartB();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildPartC();
    &lt;span&gt;public&lt;/span&gt;  Product GetResult()
    {          
        &lt;span&gt;return&lt;/span&gt; product;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConreteBuilder : AbstractBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildPartA()
    {
        &lt;span&gt;this&lt;/span&gt;.product.PartA = &quot;&lt;span&gt;PartA&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildPartB()
    {
        &lt;span&gt;this&lt;/span&gt;.product.PartB = &quot;&lt;span&gt;PartB&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildPartC()
    {
        &lt;span&gt;this&lt;/span&gt;.product.PartC = &quot;&lt;span&gt;PartC&lt;/span&gt;&quot;;
    }   
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Director
{
    &lt;span&gt;private&lt;/span&gt; AbstractBuilder builder;
    &lt;span&gt;public&lt;/span&gt; Director(AbstractBuilder builder)
    {
        &lt;span&gt;this&lt;/span&gt;.builder = builder;
    }

    &lt;span&gt;public&lt;/span&gt; Product Construct()
    {
        builder.BuildPartA();
        builder.BuildPartB();
        builder.BuildPartC();
        &lt;span&gt;return&lt;/span&gt; builder.GetResult();
    }
}
&lt;/pre&gt;
&lt;p&gt;客户端调用：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;[] args)
{
    AbstractBuilder builder = &lt;span&gt;new&lt;/span&gt; ConreteBuilder();
    Director director = &lt;span&gt;new&lt;/span&gt; Director(builder);
    Product product = director.Construct();

    Console.WriteLine(product.PartA);
    Console.WriteLine(product.PartB);
    Console.WriteLine(product.PartC);

    Console.ReadKey();
}
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105352036-1432052476.png&quot;&gt;&lt;img title=&quot;image_thumb12[4]&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105352563-1287697213.png&quot; alt=&quot;image_thumb12[4]&quot; width=&quot;543&quot; height=&quot;116&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;四、建造者模式实例&lt;/h2&gt;
&lt;p&gt;我们用本文开头提出的手组成的例子来挑选几个核心部件来构造几个型号的手机，使用建造者模式。&lt;/p&gt;
&lt;p&gt;1、X1型手机：CUP 骁龙 835， RAM 6GB ，屏幕 刘海全屏, 硬盘 64GB。&lt;/p&gt;
&lt;p&gt;2、X2 型手机： CUP 麒麟 930, RAM 8G, 屏幕 全面屏, 硬盘 128GB。&lt;/p&gt;
&lt;p&gt;3、X3型手机： CPU  骁龙 960 RAM 10G，屏幕 超清全面屏 256GB。&lt;/p&gt;
&lt;p&gt;UML 图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105353428-1420028750.png&quot;&gt;&lt;img title=&quot;image_thumb34&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105354216-1489751921.png&quot; alt=&quot;image_thumb34&quot; width=&quot;900&quot; height=&quot;474&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mobile
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CPU { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Screen { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; RAM { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Disk { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MobileBuilder
{
    &lt;span&gt;protected&lt;/span&gt; Mobile mobile = &lt;span&gt;new&lt;/span&gt; Mobile();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk();
    &lt;span&gt;public&lt;/span&gt; Mobile GetMobile()
    {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.mobile;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X1Builder:MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X1]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X1]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X1]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X1]:Disk had been built.&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X2Builder:MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X2]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X2]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X2]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X2]:Disk had been built.&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X3Builder:MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X3]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X3]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X3]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X3]:Disk had been built.&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MobileDirector
{
    &lt;span&gt;private&lt;/span&gt; MobileBuilder builder;
    &lt;span&gt;public&lt;/span&gt; MobileDirector(MobileBuilder builder)
    {
      &lt;span&gt;this&lt;/span&gt;.builder=builder;
    }

    &lt;span&gt;public&lt;/span&gt; Mobile GetMobile(){
     &lt;span&gt;this&lt;/span&gt;.builder.BuildCPU();
     &lt;span&gt;this&lt;/span&gt;.builder.BuildRAM();
     &lt;span&gt;this&lt;/span&gt;.builder.BuildScreen();
     &lt;span&gt;this&lt;/span&gt;.builder.BuildDisk();
     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.builder.GetMobile();
    }
}
&lt;/pre&gt;
&lt;p&gt;调用代码如下：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;[] args)
{
    MobileBuilder builder=&lt;span&gt;new&lt;/span&gt; X1Builder();
    MobileDirector mobileDrector = &lt;span&gt;new&lt;/span&gt; MobileDirector(builder);
    Mobile mobile = mobileDrector.GetMobile();
    Console.WriteLine(mobile.CPU);
    Console.WriteLine(mobile.Screen);
    Console.WriteLine(mobile.RAM);
    Console.WriteLine(mobile.Disk);
    Console.ReadKey();
}
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105354919-418262716.png&quot;&gt;&lt;img title=&quot;image_thumb20&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105355486-1284110134.png&quot; alt=&quot;image_thumb20&quot; width=&quot;539&quot; height=&quot;115&quot; border=&quot;0&quot;/&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;如果想生产X2型号的手机，只需要将具体建造者代码修改一下就可以了，即将下面的一行代码：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
MobileBuilder builder=&lt;span&gt;new&lt;/span&gt; X1Builder();
&lt;/pre&gt;
&lt;p&gt;改成：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
MobileBuilder builder=&lt;span&gt;new&lt;/span&gt; X2Builder();
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105356270-1290732502.png&quot;&gt;&lt;img title=&quot;image_thumb22&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105357055-351627442.png&quot; alt=&quot;image_thumb22&quot; width=&quot;543&quot; height=&quot;105&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也可以将具体建造者类配置在配置文件中，通过反射来创建建造者对象进而创建出新的型号的手机。&lt;/p&gt;
&lt;p&gt;在配置文件中加入如下配置：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;appSettings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;=&lt;span&gt;&quot;Builder&quot;&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;&quot;DesignPattern.Builder.MobileInstance.X3Builder&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;appSettings&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;客户端调用代码如下：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;[] args)
{
    MobileBuilder builder;
    var setting = ConfigurationSettings.AppSettings[&quot;&lt;span&gt;Builder&lt;/span&gt;&quot;];
    var obj = Type.GetType(setting);
    &lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;
    builder = Activator.CreateInstance(obj) &lt;span&gt;as&lt;/span&gt; MobileBuilder;

    &lt;span&gt;if&lt;/span&gt; (builder == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;
    
    MobileDirector mobileDrector = &lt;span&gt;new&lt;/span&gt; MobileDirector(builder);
    Mobile mobile = mobileDrector.GetMobile();
    Console.WriteLine(mobile.CPU);
    Console.WriteLine(mobile.Screen);
    Console.WriteLine(mobile.RAM);
    Console.WriteLine(mobile.Disk);
    Console.ReadKey();
}
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105357588-570782957.png&quot;&gt;&lt;img title=&quot;image_thumb24&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105358298-1836452495.png&quot; alt=&quot;image_thumb24&quot; width=&quot;544&quot; height=&quot;108&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;五、建造者模式的优点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。&lt;/li&gt;
&lt;li&gt;每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合“&lt;a href=&quot;http://www.cnblogs.com/vaiyanzi/p/6894636.html&quot;&gt;开闭原则（OCP）&lt;/a&gt;“&lt;/li&gt;
&lt;li&gt;可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;六、建造者模式的缺点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分都不相同，不适合使用建造者模式，因此其使用范围受到一定的限制。&lt;/li&gt;
&lt;li&gt;如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加系统的理解难度和运行成本。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;七、建造者模式的使用场景&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。&lt;/li&gt;
&lt;li&gt;需要生成的产品对象的属性相互依赖，需要指定其生成顺序。&lt;/li&gt;
&lt;li&gt;对象的创建过程独立于创建该对象的类。在建造者模式中通过引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。&lt;/li&gt;
&lt;li&gt;隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;八、扩展 &lt;/h2&gt;
&lt;p&gt;Director在建造者模式中扮演着重要的角色，Director类看似简单但是作用却非常大，它决定复杂对象各个部分的创建顺序并且将构建对象的过程和具体建造者隔离，比如创建一个房子，首先肯定要做的事情是打地基，然后是磊墙，然后是封顶，最后是装修，这个过程是有顺序的且必须是这个顺序，其它过程不无法完成房子的建造。&lt;/p&gt;
&lt;p&gt;Director'就好像是拍电影导演一样，导演要拍一部电影，需要拍摄若干影像片段，最后由剪辑师做剪接拼接，导演最后会进行最终的剪辑排版合成一个长片-- 电影。那么电影就充当了建造者模式中的复杂产品，拍摄的影像片段就是产片的各个部分，剪辑就是建造者模式的具体具体建造者，剧本是建造者模式的抽象建造者，导演就是Director。那么在在这个过程中，编剧是不可以兼任导演？ 剪辑师是不是也可以兼任导演呢？答案是肯定的。&lt;/p&gt;
&lt;h3&gt;1.抽象建造者干了Director的活&lt;/h3&gt;
&lt;p&gt;那上面手机建造的实例，删除掉Diretor， 将创建复杂对象的逻辑放到抽象建造者中，并且使子类方法不能重写父类中的建造产品的方法，引用之前的配置代码演变成如下：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mobile
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CPU { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Screen { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; RAM { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Disk { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MobileBuilder
{
    &lt;span&gt;protected&lt;/span&gt; Mobile mobile = &lt;span&gt;new&lt;/span&gt; Mobile();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Mobile GetMobile(MobileBuilder builder)
    {
        builder.BuildCPU();
        builder.BuildScreen();
        builder.BuildRAM();
        builder.BuildDisk();
        &lt;span&gt;return&lt;/span&gt; builder.mobile;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X1Builder : MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X1]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X1]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X1]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X1]:Disk had been built.&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X2Builder : MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X2]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X2]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X2]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X2]:Disk had been built.&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X3Builder : MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X3]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X3]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X3]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X3]:Disk had been built.&lt;/span&gt;&quot;;
    }
}
&lt;/pre&gt;
&lt;p&gt;调用代码：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;[] args)
{
    MobileBuilder builder;
    var setting = ConfigurationSettings.AppSettings[&quot;&lt;span&gt;Builder&lt;/span&gt;&quot;];
    var obj = Type.GetType(setting);
    &lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;
    builder = Activator.CreateInstance(obj) &lt;span&gt;as&lt;/span&gt; MobileBuilder;

    &lt;span&gt;if&lt;/span&gt; (builder == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;

    Mobile mobile = builder.GetMobile();
    Console.WriteLine(mobile.CPU);
    Console.WriteLine(mobile.Screen);
    Console.WriteLine(mobile.RAM);
    Console.WriteLine(mobile.Disk);
    Console.ReadKey();
}
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105358812-237892215.png&quot;&gt;&lt;img title=&quot;image_thumb26&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105359830-580876629.png&quot; alt=&quot;image_thumb26&quot; width=&quot;544&quot; height=&quot;132&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这种在抽象建造者中使用了一个静态方法来创建产品的做法的好处是产品创建出来的一致性很好，创建产品流程被统一封装，一般不会有差异，这种方式抽象类控制了产品建造的顺序，并且所有的产品的创建顺序都不能改变了（如造房子的流程），对于要求创建顺序一致，并且产品部件的创建都路程一致的产品来说这是一个优点。&lt;/p&gt;
&lt;p&gt;但是如果想创建出来的产品有差异，每一个产品的顺序都不一样那该怎么办呢？比如现在这种方法创建出来的顺序是： &lt;em&gt;CPU=》Screen=》RAM=》Disk&lt;/em&gt;， 那么我要想X3型号的手机创建顺序变成：CPU=》RAM=》Disk=》Screen。 这种方法就显得不灵活了，没有办法做到个性化了。处理典型的将建造过程的控制权交给Director外，还可以不用Director来完成吗？&lt;/p&gt;
&lt;h3&gt;2、具体建造者和抽象建造者都可以干Director的活&lt;/h3&gt;
&lt;p&gt;这里我们依然删掉Director， 将抽象方法中的创建方法变成子类可以重写的虚方法就可以了，然后在具体建造者中重写抽象建造者的创建方法就可以了。&lt;/p&gt;
&lt;p&gt;现在我们创建X1，X2，X3型号的手机的顺序分别是这样的：&lt;/p&gt;
&lt;p&gt;X1： CPU=》Screen=》RAM=》Disk&lt;/p&gt;
&lt;p&gt;X2：CPU=》RAM=》Disk=》Screen&lt;/p&gt;
&lt;p&gt;X3：CPU=》Disk=》RAM=》Screen&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mobile
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CPU { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Screen { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; RAM { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Disk { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MobileBuilder
{
    &lt;span&gt;protected&lt;/span&gt; Mobile mobile = &lt;span&gt;new&lt;/span&gt; Mobile();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Mobile GetMobile()
    {
        &lt;span&gt;this&lt;/span&gt;.BuildCPU();
        &lt;span&gt;this&lt;/span&gt;.BuildScreen();
        &lt;span&gt;this&lt;/span&gt;.BuildRAM();
        &lt;span&gt;this&lt;/span&gt;.BuildDisk();
        Console.WriteLine(mobile.CPU);
        Console.WriteLine(mobile.Screen);
        Console.WriteLine(mobile.RAM);
        Console.WriteLine(mobile.Disk);
       
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.mobile;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X1Builder : MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X1]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X1]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X1]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X1]:Disk had been built.&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X2Builder : MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X2]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X2]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X2]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X2]:Disk had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Mobile GetMobile()
    {
        BuildCPU();
        BuildRAM();
        BuildDisk();
        BuildScreen();
        Console.WriteLine(mobile.CPU);       
        Console.WriteLine(mobile.RAM);
        Console.WriteLine(mobile.Disk);
        Console.WriteLine(mobile.Screen);
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.mobile;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X3Builder : MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X3]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X3]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X3]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X3]:Disk had been built.&lt;/span&gt;&quot;;
    }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Mobile GetMobile()
    {
        BuildCPU();        
        BuildDisk();
        BuildRAM();
        BuildScreen();
        Console.WriteLine(mobile.CPU);
        Console.WriteLine(mobile.Disk);
        Console.WriteLine(mobile.RAM);       
        Console.WriteLine(mobile.Screen);
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.mobile;
    }
}
&lt;/pre&gt;
&lt;p&gt;调用代码：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;[] args)
{
    MobileBuilder builder;
    var setting = ConfigurationSettings.AppSettings[&quot;&lt;span&gt;Builder&lt;/span&gt;&quot;];
    var obj = Type.GetType(setting);
    &lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;
    builder = Activator.CreateInstance(obj) &lt;span&gt;as&lt;/span&gt; MobileBuilder;

    &lt;span&gt;if&lt;/span&gt; (builder == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;

    Mobile mobile = builder.GetMobile();

    Console.ReadKey();
}
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105400437-427177161.png&quot;&gt;&lt;img title=&quot;image_thumb28&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105401158-214772910.png&quot; alt=&quot;image_thumb28&quot; width=&quot;546&quot; height=&quot;151&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3.  控制某些部件不用被创建&lt;/h3&gt;
&lt;p&gt;假如要造一个X4型号的手机，这个手机支持NFC，我们知道X1，X2，X3中都不支持NFC，那怎么办呢？，我们可以给抽象建造者类加一个方法，叫 HasNFC（）并且返回bool值，并将其设置成默认值为false。 修改抽象建造者的GetMobile（） 方法，只有当HasNFC（）返回 true是才创建NFC模块，并且在X4Builder的具体建造者类中重写HasNFC（）方法使其返回true就可以了。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Mobile
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CPU { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Screen { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; RAM { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Disk { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MobileBuilder
{
    &lt;span&gt;protected&lt;/span&gt; Mobile mobile = &lt;span&gt;new&lt;/span&gt; Mobile();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk();
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildNFC()
    {
        Console.WriteLine(&quot;&lt;span&gt;NFC had been built.&lt;/span&gt;&quot;);
    }
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasNFC()
    {
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;
    }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Mobile GetMobile()
    {
        &lt;span&gt;this&lt;/span&gt;.BuildCPU();
        &lt;span&gt;this&lt;/span&gt;.BuildScreen();
        &lt;span&gt;this&lt;/span&gt;.BuildRAM();
        &lt;span&gt;this&lt;/span&gt;.BuildDisk();
        &lt;span&gt;if&lt;/span&gt;(HasNFC())
        {
            &lt;span&gt;this&lt;/span&gt;.BuildNFC();
        }
        Console.WriteLine(mobile.CPU);
        Console.WriteLine(mobile.Screen);
        Console.WriteLine(mobile.RAM);
        Console.WriteLine(mobile.Disk);
       
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.mobile;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X1Builder : MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X1]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X1]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X1]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X1]:Disk had been built.&lt;/span&gt;&quot;;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X2Builder : MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X2]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X2]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X2]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X2]:Disk had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Mobile GetMobile()
    {
        BuildCPU();
        BuildRAM();
        BuildDisk();
        BuildScreen();
        Console.WriteLine(mobile.CPU);       
        Console.WriteLine(mobile.RAM);
        Console.WriteLine(mobile.Disk);
        Console.WriteLine(mobile.Screen);
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.mobile;
    }
}

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X3Builder : MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X3]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X3]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X3]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X3]:Disk had been built.&lt;/span&gt;&quot;;
    }
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Mobile GetMobile()
    {
        BuildCPU();        
        BuildDisk();
        BuildRAM();
        BuildScreen();
        Console.WriteLine(mobile.CPU);
        Console.WriteLine(mobile.Disk);
        Console.WriteLine(mobile.RAM);       
        Console.WriteLine(mobile.Screen);
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.mobile;
    }
}
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; X4Builder : MobileBuilder
{
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildCPU()
    {
        mobile.CPU = &quot;&lt;span&gt;[X4]:CPU had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildScreen()
    {
        mobile.Screen = &quot;&lt;span&gt;[X4]:Screen had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildRAM()
    {
        mobile.RAM = &quot;&lt;span&gt;[X4]:RAM had been built.&lt;/span&gt;&quot;;
    }

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BuildDisk()
    {
        mobile.Disk = &quot;&lt;span&gt;[X4]:Disk had been built.&lt;/span&gt;&quot;;
    }
    
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; HasNFC()
    {
             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;
    }
}
&lt;/pre&gt;
&lt;p&gt;App.Config 配置：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&amp;lt;appSettings&amp;gt;
    &amp;lt;add key=&quot;&lt;span&gt;Builder&lt;/span&gt;&quot; &lt;span&gt;value&lt;/span&gt;=&quot;&lt;span&gt;DesignPattern.Builder.MobileInstance.X3Builder&lt;/span&gt;&quot;/&amp;gt;
&amp;lt;/appSettings&amp;gt;
&lt;/pre&gt;
&lt;p&gt;客户端代码：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;[] args)
{
    MobileBuilder builder;
    
    var setting = ConfigurationSettings.AppSettings[&quot;&lt;span&gt;Builder&lt;/span&gt;&quot;];
    var obj = Type.GetType(setting);
    &lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;
    builder = Activator.CreateInstance(obj) &lt;span&gt;as&lt;/span&gt; MobileBuilder;

    &lt;span&gt;if&lt;/span&gt; (builder == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;;

    Mobile mobile = builder.GetMobile();

    Console.ReadKey();
}
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105401763-1846275576.png&quot;&gt;&lt;img title=&quot;image_thumb30&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105402533-1359776730.png&quot; alt=&quot;image_thumb30&quot; width=&quot;543&quot; height=&quot;150&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改配置文件，使其造一台X4 如下，调用代码不变：&lt;/p&gt;
&lt;pre class=&quot;code&quot;&gt;
&amp;lt;appSettings&amp;gt;
    &amp;lt;add key=&quot;&lt;span&gt;Builder&lt;/span&gt;&quot; &lt;span&gt;value&lt;/span&gt;=&quot;&lt;span&gt;DesignPattern.Builder.MobileInstance.X4Builder&lt;/span&gt;&quot;/&amp;gt;
&amp;lt;/appSettings&amp;gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105403213-1934405495.png&quot;&gt;&lt;img title=&quot;image_thumb32&quot; src=&quot;https://images2018.cnblogs.com/blog/15278/201808/15278-20180804105403803-151772658.png&quot; alt=&quot;image_thumb32&quot; width=&quot;547&quot; height=&quot;158&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了建造者模式就探讨到这里。&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 02:54:00 +0000</pubDate>
<dc:creator>蓝之风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vaiyanzi/p/9417860.html</dc:identifier>
</item>
<item>
<title>SpringBoot环境属性占位符解析和类型转换 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/9417827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/9417827.html</guid>
<description>&lt;p&gt;前面写过一篇关于Environment属性加载的源码分析和扩展，里面提到属性的占位符解析和类型转换是相对复杂的，这篇文章就是要分析和解读这两个复杂的问题。关于这两个问题，选用一个比较复杂的参数处理方法&lt;code&gt;PropertySourcesPropertyResolver#getProperty&lt;/code&gt;，解析占位符的时候依赖到&lt;code&gt;PropertySourcesPropertyResolver#getPropertyAsRawString&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected String getPropertyAsRawString(String key) {
    return getProperty(key, String.class, false);
}

protected &amp;lt;T&amp;gt; T getProperty(String key, Class&amp;lt;T&amp;gt; targetValueType, boolean resolveNestedPlaceholders) {
    if (this.propertySources != null) {
        for (PropertySource&amp;lt;?&amp;gt; propertySource : this.propertySources) {
            if (logger.isTraceEnabled()) {
                logger.trace(&quot;Searching for key '&quot; + key + &quot;' in PropertySource '&quot; +
                            propertySource.getName() + &quot;'&quot;);
            }
            Object value = propertySource.getProperty(key);
            if (value != null) {
                if (resolveNestedPlaceholders &amp;amp;&amp;amp; value instanceof String) {
                    //解析带有占位符的属性
                    value = resolveNestedPlaceholders((String) value);
                }
                logKeyFound(key, propertySource, value);
                //需要时转换属性的类型
                return convertValueIfNecessary(value, targetValueType);
            }
        }
    }
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Could not find key '&quot; + key + &quot;' in any property source&quot;);
    }
    return null;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;属性占位符的解析方法是PropertySourcesPropertyResolver的父类&lt;code&gt;AbstractPropertyResolver#resolveNestedPlaceholders&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected String resolveNestedPlaceholders(String value) {
    return (this.ignoreUnresolvableNestedPlaceholders ?
        resolvePlaceholders(value) : resolveRequiredPlaceholders(value));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ignoreUnresolvableNestedPlaceholders属性默认为false，可以通过&lt;code&gt;AbstractEnvironment#setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders)&lt;/code&gt;设置，当此属性被设置为true，解析属性占位符失败的时候(并且没有为占位符配置默认值)不会抛出异常，返回属性原样字符串，否则会抛出IllegalArgumentException。我们这里只需要分析&lt;code&gt;AbstractPropertyResolver#resolveRequiredPlaceholders&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//AbstractPropertyResolver中的属性：
//ignoreUnresolvableNestedPlaceholders=true情况下创建的PropertyPlaceholderHelper实例
@Nullable
private PropertyPlaceholderHelper nonStrictHelper;

//ignoreUnresolvableNestedPlaceholders=false情况下创建的PropertyPlaceholderHelper实例
@Nullable
private PropertyPlaceholderHelper strictHelper;

//是否忽略无法处理的属性占位符，这里是false，也就是遇到无法处理的属性占位符且没有默认值则抛出异常
private boolean ignoreUnresolvableNestedPlaceholders = false;

//属性占位符前缀，这里是&quot;${&quot;
private String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX;

//属性占位符后缀，这里是&quot;}&quot;
private String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX;

//属性占位符解析失败的时候配置默认值的分隔符，这里是&quot;:&quot;
@Nullable
private String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR;


public String resolveRequiredPlaceholders(String text) throws IllegalArgumentException {
    if (this.strictHelper == null) {
        this.strictHelper = createPlaceholderHelper(false);
    }
    return doResolvePlaceholders(text, this.strictHelper);
}

//创建一个新的PropertyPlaceholderHelper实例，这里ignoreUnresolvablePlaceholders为false
private PropertyPlaceholderHelper createPlaceholderHelper(boolean ignoreUnresolvablePlaceholders) {
    return new PropertyPlaceholderHelper(this.placeholderPrefix, this.placeholderSuffix, this.valueSeparator, ignoreUnresolvablePlaceholders);
}

//这里最终的解析工作委托到PropertyPlaceholderHelper#replacePlaceholders完成
private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) {
    return helper.replacePlaceholders(text, this::getPropertyAsRawString);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终只需要分析&lt;code&gt;PropertyPlaceholderHelper#replacePlaceholders&lt;/code&gt;，这里需要重点注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注意到这里的第一个参数text就是属性值的源字符串，例如我们需要处理的属性为myProperties: ${server.port}-${spring.application.name}，这里的text就是${server.port}-${spring.application.name}。&lt;/li&gt;
&lt;li&gt;replacePlaceholders方法的第二个参数placeholderResolver，这里比较巧妙，这里的方法引用this::getPropertyAsRawString相当于下面的代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//PlaceholderResolver是一个函数式接口
@FunctionalInterface
public interface PlaceholderResolver {
  @Nullable
  String resolvePlaceholder(String placeholderName);  
}
//this::getPropertyAsRawString相当于下面的代码
return new PlaceholderResolver(){
    
    @Override
    String resolvePlaceholder(String placeholderName){
        //这里调用到的是PropertySourcesPropertyResolver#getPropertyAsRawString，有点绕
        return getPropertyAsRawString(placeholderName);
    }
}       &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着看&lt;code&gt;PropertyPlaceholderHelper#replacePlaceholders&lt;/code&gt;的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//基础属性
//占位符前缀，默认是&quot;${&quot;
private final String placeholderPrefix;
//占位符后缀，默认是&quot;}&quot;
private final String placeholderSuffix;
//简单的占位符前缀，默认是&quot;{&quot;，主要用于处理嵌套的占位符如${xxxxx.{yyyyy}}
private final String simplePrefix;

//默认值分隔符号，默认是&quot;:&quot;
@Nullable
private final String valueSeparator;
//替换属性占位符
public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {
    Assert.notNull(value, &quot;'value' must not be null&quot;);
    return parseStringValue(value, placeholderResolver, new HashSet&amp;lt;&amp;gt;());
}

//递归解析带占位符的属性为字符串
protected String parseStringValue(
        String value, PlaceholderResolver placeholderResolver, Set&amp;lt;String&amp;gt; visitedPlaceholders) {
    StringBuilder result = new StringBuilder(value);
    int startIndex = value.indexOf(this.placeholderPrefix);
    while (startIndex != -1) {
        //搜索第一个占位符后缀的索引
        int endIndex = findPlaceholderEndIndex(result, startIndex);
        if (endIndex != -1) {
            //提取第一个占位符中的原始字符串，如${server.port}-&amp;gt;server.port
            String placeholder = result.substring(startIndex + this.placeholderPrefix.length(), endIndex);
            String originalPlaceholder = placeholder;
            //判重
            if (!visitedPlaceholders.add(originalPlaceholder)) {
                throw new IllegalArgumentException(
                        &quot;Circular placeholder reference '&quot; + originalPlaceholder + &quot;' in property definitions&quot;);
            }
            // Recursive invocation, parsing placeholders contained in the placeholder key.
            // 递归调用，实际上就是解析嵌套的占位符，因为提取的原始字符串有可能还有一层或者多层占位符
            placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);
            // Now obtain the value for the fully resolved key...
            // 递归调用完毕后，可以确定得到的字符串一定是不带占位符，这个时候调用getPropertyAsRawString获取key对应的字符串值
            String propVal = placeholderResolver.resolvePlaceholder(placeholder);
            // 如果字符串值为null，则进行默认值的解析，因为默认值有可能也使用了占位符，如${server.port:${server.port-2:8080}}
            if (propVal == null &amp;amp;&amp;amp; this.valueSeparator != null) {
                int separatorIndex = placeholder.indexOf(this.valueSeparator);
                if (separatorIndex != -1) {
                    String actualPlaceholder = placeholder.substring(0, separatorIndex);
                    // 提取默认值的字符串
                    String defaultValue = placeholder.substring(separatorIndex + this.valueSeparator.length());
                    // 这里是把默认值的表达式做一次解析，解析到null，则直接赋值为defaultValue
                    propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);
                    if (propVal == null) {
                        propVal = defaultValue;
                    }
                }
            }
            // 上一步解析出来的值不为null，但是它有可能是一个带占位符的值，所以后面对值进行递归解析
            if (propVal != null) {
                // Recursive invocation, parsing placeholders contained in the
                // previously resolved placeholder value.
                propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);
                // 这一步很重要，替换掉第一个被解析完毕的占位符属性，例如${server.port}-${spring.application.name} -&amp;gt; 9090--${spring.application.name}
                result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal);
                if (logger.isTraceEnabled()) {
                    logger.trace(&quot;Resolved placeholder '&quot; + placeholder + &quot;'&quot;);
                }
                // 重置startIndex为下一个需要解析的占位符前缀的索引，可能为-1，说明解析结束
                startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length());
            }
            else if (this.ignoreUnresolvablePlaceholders) {
                // 如果propVal为null并且ignoreUnresolvablePlaceholders设置为true，直接返回当前的占位符之间的原始字符串尾的索引，也就是跳过解析
                // Proceed with unprocessed value.
                startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length());
            }
            else {
                // 如果propVal为null并且ignoreUnresolvablePlaceholders设置为false，抛出异常
                throw new IllegalArgumentException(&quot;Could not resolve placeholder '&quot; +
                            placeholder + &quot;'&quot; + &quot; in value \&quot;&quot; + value + &quot;\&quot;&quot;);
            }
            // 递归结束移除判重集合中的元素
            visitedPlaceholders.remove(originalPlaceholder);
        }
        else {
            // endIndex = -1说明解析结束
            startIndex = -1;
        }
    }
    return result.toString();
}

//基于传入的起始索引，搜索第一个占位符后缀的索引，兼容嵌套的占位符
private int findPlaceholderEndIndex(CharSequence buf, int startIndex) {
    //这里index实际上就是实际需要解析的属性的第一个字符，如${server.port}，这里index指向s
    int index = startIndex + this.placeholderPrefix.length();
    int withinNestedPlaceholder = 0;
    while (index &amp;lt; buf.length()) {
        //index指向&quot;}&quot;，说明有可能到达占位符尾部或者嵌套占位符尾部
        if (StringUtils.substringMatch(buf, index, this.placeholderSuffix)) {
            //存在嵌套占位符，则返回字符串中占位符后缀的索引值
            if (withinNestedPlaceholder &amp;gt; 0) {
                withinNestedPlaceholder--;
                index = index + this.placeholderSuffix.length();
            }
            else {
                //不存在嵌套占位符，直接返回占位符尾部索引
                return index;
            }
        }
        //index指向&quot;{&quot;，记录嵌套占位符个数withinNestedPlaceholder加1，index更新为嵌套属性的第一个字符的索引
        else if (StringUtils.substringMatch(buf, index, this.simplePrefix)) {
            withinNestedPlaceholder++;
            index = index + this.simplePrefix.length();
        }
        else {
            //index不是&quot;{&quot;或者&quot;}&quot;，则进行自增
            index++;
        }
    }
    //这里说明解析索引已经超出了原字符串
    return -1;
}

//StringUtils#substringMatch，此方法会检查原始字符串str的index位置开始是否和子字符串substring完全匹配
public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {
    if (index + substring.length() &amp;gt; str.length()) {
        return false;
    }
    for (int i = 0; i &amp;lt; substring.length(); i++) {
        if (str.charAt(index + i) != substring.charAt(i)) {
            return false;
        }
    }
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的过程相对比较复杂，因为用到了递归，我们举个实际的例子说明一下整个解析过程，例如我们使用了四个属性项，我们的目标是获取server.desc的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;application.name=spring
server.port=9090
spring.application.name=${application.name}
server.desc=${server.port-${spring.application.name}}:${description:&quot;hello&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://pazkqls86.bkt.clouddn.com/spec-1.png&quot; alt=&quot;spec-1&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在上一步解析属性占位符完毕之后，得到的是属性字符串值，可以把字符串转换为指定的类型，此功能由&lt;code&gt;AbstractPropertyResolver#convertValueIfNecessary&lt;/code&gt;完成：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected &amp;lt;T&amp;gt; T convertValueIfNecessary(Object value, @Nullable Class&amp;lt;T&amp;gt; targetType) {
    if (targetType == null) {
        return (T) value;
    }
    ConversionService conversionServiceToUse = this.conversionService;
    if (conversionServiceToUse == null) {
        // Avoid initialization of shared DefaultConversionService if
        // no standard type conversion is needed in the first place...
        // 这里一般只有字符串类型才会命中
        if (ClassUtils.isAssignableValue(targetType, value)) {
            return (T) value;
        }
        conversionServiceToUse = DefaultConversionService.getSharedInstance();
    }
    return conversionServiceToUse.convert(value, targetType);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上转换的逻辑是委托到DefaultConversionService的父类方法&lt;code&gt;GenericConversionService#convert&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public &amp;lt;T&amp;gt; T convert(@Nullable Object source, Class&amp;lt;T&amp;gt; targetType) {
    Assert.notNull(targetType, &quot;Target type to convert to cannot be null&quot;);
    return (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType));
}

public Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {
    Assert.notNull(targetType, &quot;Target type to convert to cannot be null&quot;);
    if (sourceType == null) {
        Assert.isTrue(source == null, &quot;Source must be [null] if source type == [null]&quot;);
        return handleResult(null, targetType, convertNullSource(null, targetType));
    }
    if (source != null &amp;amp;&amp;amp; !sourceType.getObjectType().isInstance(source)) {
        throw new IllegalArgumentException(&quot;Source to convert from must be an instance of [&quot; +
                    sourceType + &quot;]; instead it was a [&quot; + source.getClass().getName() + &quot;]&quot;);
    }
    // 从缓存中获取GenericConverter实例，其实这一步相对复杂，匹配两个类型的时候，会解析整个类的层次进行对比
    GenericConverter converter = getConverter(sourceType, targetType);
    if (converter != null) {
        // 实际上就是调用转换方法
        Object result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);
        // 断言最终结果和指定类型是否匹配并且返回
        return handleResult(sourceType, targetType, result);
    }
    return handleConverterNotFound(source, sourceType, targetType);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面所有的可用的GenericConverter的实例可以在DefaultConversionService的&lt;code&gt;addDefaultConverters&lt;/code&gt;中看到，默认添加的转换器实例已经超过20个，有些情况下如果无法满足需求可以添加自定义的转换器，实现GenericConverter接口添加进去即可。&lt;/p&gt;

&lt;p&gt;SpringBoot在抽象整个类型转换器方面做的比较好，在SpringMVC应用中，采用的是org.springframework.boot.autoconfigure.web.format.WebConversionService，兼容了Converter、Formatter、ConversionService等转换器类型并且对外提供一套统一的转换方法。&lt;/p&gt;
&lt;p&gt;（本文完）&lt;/p&gt;
</description>
<pubDate>Sat, 04 Aug 2018 02:46:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/throwable/p/9417827.html</dc:identifier>
</item>
<item>
<title>MySQL——索引基础 - 撸码那些事</title>
<link>http://www.cnblogs.com/songwenjie/p/9410009.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/9410009.html</guid>
<description>&lt;p&gt;本篇文章，我们将从索引基础开始，介绍什么是索引以及索引的几种类型，然后学习如何创建索引以及索引设计的基本原则。&lt;/p&gt;
&lt;p&gt;本篇文章中用于测试索引创建的user表的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/H927ahbK4F.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是索引&quot;&gt;什么是索引&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;索引（在 MySQL 中也叫“键key”）是存储引擎快速找到记录的一种数据结构&lt;/p&gt;
&lt;p&gt;——《高性能MySQL》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们需要知道索引其实是一种数据结构，其功能是帮助我们快速匹配查找到需要的数据行，是数据库性能优化最常用的工具之一。其作用相当于超市里的导购员、书本里的目录。&lt;/p&gt;
&lt;h2 id=&quot;索引类型&quot;&gt;索引类型&lt;/h2&gt;
&lt;p&gt;可以使用&lt;code&gt;SHOW INDEX FROM table_name;&lt;/code&gt;查看索引详情&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/Eif26fJiEc.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;11&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;主键索引 PRIMARY KEY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。&lt;/p&gt;
&lt;p&gt;注意：一个表只能有一个主键&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/1c7D2F0f76.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;唯一索引 UNIQUE&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;ALTER TABLE table_name ADD UNIQUE (column);&lt;/code&gt;创建唯一索引&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/DBdFeKE8Fk.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/L2jl91b6J6.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;ALTER TABLE table_name ADD UNIQUE (column1,column2);&lt;/code&gt;创建唯一组合索引&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/mihd7Hm5i6.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/bJbdFA9AcL.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;普通索引 INDEX&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最基本的索引，它没有任何限制。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;ALTER TABLE table_name ADD INDEX index_name (column);&lt;/code&gt;创建普通索引&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/17CmJIIJhD.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/4fA7L6kBBm.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;组合索引 INDEX&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;组合索引，即一个索引包含多个列。多用于避免回表查询。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);&lt;/code&gt;创建组合索引&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/CLGIKiAC6J.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/295B9bGi67.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;全文索引 FULLTEXT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;ALTER TABLE table_name ADD FULLTEXT (column);&lt;/code&gt;创建全文索引&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/AjfLLkhdH1.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180802/bA1a1m49cL.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;索引一经创建不能修改，如果要修改索引，只能删除重建。可以使用&lt;code&gt;DROP INDEX index_name ON table_name;&lt;/code&gt;删除索引。&lt;/p&gt;
&lt;h2 id=&quot;索引设计的原则&quot;&gt;索引设计的原则&lt;/h2&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;适合索引的列是出现在where子句中的列，或者连接子句中指定的列&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;基数较小的类，索引效果较差，没有必要在此列建立索引&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;《深入浅出MySQL》&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;content&quot; readability=&quot;27.151515151515&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;

&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div&gt;&lt;strong&gt;微信公众号：&lt;br/&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180511/AFdec5f65k.jpg?imageslim&quot; title=&quot;关注公众号，获取最新更新&quot;/&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div readability=&quot;7.9328063241107&quot;&gt;&lt;strong&gt;来源：&lt;a href=&quot;http://songwenjie.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;http://songwenjie.cnblogs.com/&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;p&gt;&lt;strong&gt;声明：本文为博主学习感悟总结，水平有限，如果不当，欢迎指正。如果您认为还不错，不妨点击一下下方的&lt;span onclick=&quot;Digg();&quot;&gt;【&lt;span&gt;推荐&lt;/span&gt;】&lt;/span&gt;按钮，谢谢支持。转载与引用请注明出处。&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;



</description>
<pubDate>Sat, 04 Aug 2018 01:00:00 +0000</pubDate>
<dc:creator>撸码那些事</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/9410009.html</dc:identifier>
</item>
</channel>
</rss>