<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Gradle 常用配置总结 - 叶应是叶</title>
<link>http://www.cnblogs.com/leavesC/p/9624397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leavesC/p/9624397.html</guid>
<description>&lt;p&gt;这里分享下我在日常开发中对 Gradle 的常用配置规则&lt;/p&gt;
&lt;h5 id=&quot;一版本号配置&quot;&gt;一、版本号配置&lt;/h5&gt;
&lt;p&gt;当项目逐渐演进的过程中，主工程依赖的 &lt;code&gt;Module&lt;/code&gt; 可能会越来越多，此时就需要统一配置各个 &lt;code&gt;Module&lt;/code&gt; 的编译参数了&lt;/p&gt;
&lt;p&gt;在工程的根目录下新建一个 &lt;code&gt;gradle&lt;/code&gt; 文件，命名为 &lt;code&gt;config.gradle&lt;/code&gt;，在此文件中统一声明工程的编译属性和依赖库的版本号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-f793b47cdd01752c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ext {
    compileSdkVersion = 28
    minSdkVersion = 15
    targetSdkVersion = 28
    versionCode = 1
    versionName = '1.0'

    dependencies = [
            appcompatV7     : 'com.android.support:appcompat-v7:28.0.0-rc02',
            constraintLayout: 'com.android.support.constraint:constraint-layout:1.1.3',
            junit           : 'junit:junit:4.12',
            testRunner      : 'com.android.support.test:runner:1.0.2',
            espressoCore    : 'com.android.support.test.espresso:espresso-core:3.0.2'
    ]

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，&lt;code&gt;App Module&lt;/code&gt; 的 &lt;code&gt;build.gradle&lt;/code&gt; 文件的默认配置如下所示&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;apply plugin: 'com.android.application'

android {
    compileSdkVersion 28
    defaultConfig {
        applicationId &quot;leavesc.hello.gradlesamples&quot;
        minSdkVersion 15
        targetSdkVersion 28
        versionCode 1
        versionName &quot;1.0&quot;
        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'com.android.support:appcompat-v7:28.0.0-rc02'
    implementation 'com.android.support.constraint:constraint-layout:1.1.3'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'com.android.support.test:runner:1.0.2'
    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里将其改为引用 &lt;code&gt;config.gradle&lt;/code&gt; 文件的形式&lt;/p&gt;
&lt;p&gt;首先，需要在根目录下的 &lt;code&gt;build.gradle&lt;/code&gt; 文件中应用 &lt;code&gt;config.gradle&lt;/code&gt; 文件，这样在 &lt;code&gt;Module&lt;/code&gt; 配置文件中才引用得到当中的属性值&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-83324b77c34c3c26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时就可以修改应用版本号以及依赖库的声明方式了&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;apply plugin: 'com.android.application'

def globalConfiguration = rootProject.ext
def presentationDependencies = globalConfiguration.dependencies

android {
    compileSdkVersion globalConfiguration[&quot;compileSdkVersion&quot;]
    defaultConfig {
        applicationId &quot;leavesc.hello.gradlesamples&quot;
        minSdkVersion globalConfiguration[&quot;minSdkVersion&quot;]
        targetSdkVersion globalConfiguration[&quot;targetSdkVersion&quot;]
        versionCode globalConfiguration[&quot;versionCode&quot;]
        versionName globalConfiguration[&quot;versionName&quot;]
        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}

dependencies {
    implementation fileTree(include: ['*.jar'], dir: 'libs')
    implementation presentationDependencies.appcompatV7
    implementation presentationDependencies.constraintLayout
    testImplementation presentationDependencies.junit
    androidTestImplementation presentationDependencies.testRunner
    androidTestImplementation presentationDependencies.espressoCore
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，即使以后工程中包含多个 &lt;code&gt;Module&lt;/code&gt; ，只要配置的属性都是来自于 &lt;code&gt;config.gradle&lt;/code&gt; 文件，就可以做到统一修改编译属性与依赖库版本了&lt;/p&gt;
&lt;h5 id=&quot;二签名属性配置&quot;&gt;二、签名属性配置&lt;/h5&gt;
&lt;p&gt;通常，应用的签名类型会分为 &lt;code&gt;release&lt;/code&gt; 和 &lt;code&gt;debug&lt;/code&gt; 两类，并分别使用不同的签名文件&lt;br/&gt;为了安全考虑以及实现自动化打包，可以通过 &lt;code&gt;gradle&lt;/code&gt; 来声明签名配置，包括签名文件路径、签名别名、签名密码等&lt;br/&gt;在 &lt;code&gt;local.properties&lt;/code&gt; 文件中声明签名文件路径以及签名密码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;sdk.dir=C\:\\Software\\SDK
key.keyStorePath=..\\doc\\key.jks
key.keyAlias=leavesC
key.keyPassword=987654321
key.storePassword=123456789&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据配置可知，签名文件是放在工程的 &lt;code&gt;doc&lt;/code&gt; 文件夹内&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-6f2725bd181534ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过代码获取到签名的各个配置项&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Properties properties = new Properties()
properties.load(project.rootProject.file('local.properties').newDataInputStream())
def keyStorePath_ = properties.getProperty(&quot;key.keyStorePath&quot;)
def storePassword_ = properties.getProperty(&quot;key.storePassword&quot;)
def keyAlias_ = properties.getProperty(&quot;key.keyAlias&quot;)
def keyPassword_ = properties.getProperty(&quot;key.keyPassword&quot;)
def storeFile_ = file(keyStorePath_)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置不同的签名属性以及 &lt;code&gt;build&lt;/code&gt; 类型&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    signingConfigs {
        release {
            storeFile storeFile_
            storePassword storePassword_
            keyAlias keyAlias_
            keyPassword keyPassword_
            v1SigningEnabled true
            v2SigningEnabled true
        }
        debug {
            storeFile storeFile_
            storePassword storePassword_
            keyAlias keyAlias_
            keyPassword keyPassword_
            v1SigningEnabled true
            v2SigningEnabled true
        }
    }

    buildTypes {
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.debug
        }
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处，我配置了两种不同的 &lt;code&gt;buildType&lt;/code&gt;：&lt;code&gt;debug&lt;/code&gt;、&lt;code&gt;release&lt;/code&gt;，并对应不同的签名文件&lt;/p&gt;
&lt;p&gt;以后只要选定不同的 &lt;code&gt;Build Variant&lt;/code&gt;，即可打包具体签名的 Apk 文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-74fd70312681a619.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;local.properties&lt;/code&gt; 文件可以保存到服务器来实现远程打包，从而保证了隐私安全&lt;/p&gt;
&lt;h5 id=&quot;三多渠道打包&quot;&gt;三、多渠道打包&lt;/h5&gt;
&lt;p&gt;有时候，为了方便进行精准营销，会有生成不同渠道包的要求，此时就需要在同个应用上打上不同的渠道ID（channelId），这可以通过 &lt;code&gt;productFlavors&lt;/code&gt; 来实现&lt;br/&gt;先在 &lt;code&gt;AndroidManifest.xml&lt;/code&gt; 文件中配置占位符，&lt;code&gt;appKey&lt;/code&gt; 即对应各个渠道的 ID 值&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;meta-data
            android:name=&quot;APP_KEY&quot;
            android:value=&quot;${appKey}&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;gradle.properties&lt;/code&gt; 文件中声明需要的 &lt;code&gt;ChannelId&lt;/code&gt;以及对应的 &lt;code&gt;ApplicationId&lt;/code&gt;，在此文件中声明的属性可以直接在 &lt;code&gt;build.gradle&lt;/code&gt; 中直接获取到&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;#默认配置
defaultApplicationId=leavesc.hello.gradlesamples
##各个渠道的配置
#应用宝
yingyongbaoChannelId=&quot;yingyongbao&quot;
yingyongbaoApplicationId=leavesc.hello.gradlesamples.yingyongbao
yingyongbaoAppKey=appKey_yingyongbao
#豌豆荚
wandoujiaChannelId=&quot;wandoujia&quot;
wandoujiaApplicationId=leavesc.hello.gradlesamples.wandoujia
wandoujiaAppKey=appKey_wandoujia
#小米
xiaomiChannelId=&quot;xiaomi&quot;
xiaomiApplicationId=leavesc.hello.gradlesamples.xiaomi
xiaomiAppKey=appKey_xiaomi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;productFlavors&lt;/code&gt; 可以理解为是对同个产品的不同“风味要求”，可以根据配置项生成特定风味的产品（App）&lt;br/&gt;例如，此处就为不同渠道设定了不同的 &lt;code&gt;applicationId&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;buildConfigField&lt;/code&gt; 属性则用于在 &lt;code&gt;BuildConfig.java&lt;/code&gt; 文件中生成特定类型的字段，此处就生成了一个类型为 &lt;code&gt;String&lt;/code&gt; ，名为 &lt;code&gt;channelId&lt;/code&gt; 的字段，用于方便在应用运行过程中判断当前应用的渠道类型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;manifestPlaceholders&lt;/code&gt; 就是用于替换 &lt;code&gt;AndroidManifest.xml&lt;/code&gt; 文件中的指定占位符了&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    productFlavors {
        yingyongbao {
            applicationId yingyongbaoApplicationId
            buildConfigField &quot;String&quot;, &quot;channelId&quot;, yingyongbaoChannelId
            manifestPlaceholders = [appKey: yingyongbaoAppKey]
        }
        wandoujia {
            applicationId wandoujiaApplicationId
            buildConfigField &quot;String&quot;, &quot;channelId&quot;, wandoujiaChannelId
            manifestPlaceholders = [appKey: wandoujiaAppKey]
        }
        xiaomi {
            applicationId xiaomiApplicationId
            buildConfigField &quot;String&quot;, &quot;channelId&quot;, xiaomiChannelId
            manifestPlaceholders = [appKey: xiaomiAppKey]
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-1dd2dda4d620ece3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在主布局文件中展示当前应用的各项属性值&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;ApplicationId: &quot;);
        sb.append(getApplicationInfo().packageName);
        sb.append(&quot;\n&quot;);
        sb.append(&quot;ApplicationName: &quot;);
        sb.append(getString(getApplicationInfo().labelRes));
        sb.append(&quot;\n&quot;);
        sb.append(&quot;ChannelId: &quot;);
        sb.append(BuildConfig.channelId);
        sb.append(&quot;\n&quot;);
        try {
            ApplicationInfo appInfo = getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
            String appKey = appInfo.metaData.getString(&quot;APP_KEY&quot;);
            sb.append(&quot;AppKey: &quot;);
            sb.append(appKey);
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
        }
        TextView tv_appInfo = findViewById(R.id.tv_appInfo);
        tv_appInfo.setText(sb);
        ImageView iv_log = findViewById(R.id.iv_log);
        iv_log.setImageResource(getApplicationInfo().icon);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-f087781650af9a92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;四打包时指定-apk-名字&quot;&gt;四、打包时指定 Apk 名字&lt;/h5&gt;
&lt;p&gt;为了方便标识各个测试包的版本已经打包时间，可以通过 &lt;code&gt;Gradle&lt;/code&gt; 来指定生成的 Apk 文件的命名规则&lt;/p&gt;
&lt;p&gt;例如，以下配置就根据 &lt;code&gt;buildType、flavorName&lt;/code&gt; 和 &lt;strong&gt;编译时间&lt;/strong&gt; 来命名 Apk 文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    applicationVariants.all { variant -&amp;gt;
        def buildType = variant.buildType.name
        def flavorName = variant.flavorName
        def createTime = new Date().format(&quot;YYYY-MM-dd_hh_mm_ss&quot;, TimeZone.getTimeZone(&quot;GMT+08:00&quot;))
        variant.outputs.all {
            outputFileName = flavorName + &quot;_&quot; + buildType + &quot;_v&quot; + defaultConfig.versionName + &quot;_&quot; + createTime + &quot;.apk&quot;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-b91ac47afb58f39b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;五生成属性字段与资源文件值&quot;&gt;五、生成属性字段与资源文件值&lt;/h5&gt;
&lt;p&gt;上边讲过，&lt;code&gt;buildConfigField&lt;/code&gt; 属性可用于在 &lt;code&gt;BuildConfig.java&lt;/code&gt; 文件中生成特定类型的字段，此处可以利用其来记录应用的编译时间&lt;/p&gt;
&lt;p&gt;此外，也可以利用 &lt;code&gt;resValue&lt;/code&gt; 来生成一个 ID 引用类型的 &lt;code&gt;string&lt;/code&gt; 字符串&lt;/p&gt;
&lt;p&gt;首先，声明两个方法，分别用于获取当前时间以及当前电脑的用户信息&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;static def buildTime() {
    return new Date().format(&quot;yyyy-MM-dd HH:mm:ss&quot;)
}

static def hostName() {
    return System.getProperty(&quot;user.name&quot;) + &quot;@&quot; + InetAddress.localHost.hostName
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    defaultConfig {
        applicationId defaultApplicationId
        minSdkVersion globalConfiguration[&quot;minSdkVersion&quot;]
        targetSdkVersion globalConfiguration[&quot;targetSdkVersion&quot;]
        versionCode globalConfiguration[&quot;versionCode&quot;]
        versionName globalConfiguration[&quot;versionName&quot;]
        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
        flavorDimensions '1'
        resValue &quot;string&quot;, &quot;build_host&quot;, hostName()
        buildConfigField &quot;String&quot;, &quot;build_time&quot;, &quot;\&quot;&quot; + buildTime() + &quot;\&quot;&quot;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用代码来获取这两个属性值&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;ApplicationId: &quot;);
        sb.append(getApplicationInfo().packageName);
        sb.append(&quot;\n&quot;);
        sb.append(&quot;ApplicationName: &quot;);
        sb.append(getString(getApplicationInfo().labelRes));
        sb.append(&quot;\n&quot;);
        sb.append(&quot;ChannelId: &quot;);
        sb.append(BuildConfig.channelId);
        sb.append(&quot;\n&quot;);
        sb.append(&quot;BuildTime: &quot;);
        sb.append(BuildConfig.build_time);
        sb.append(&quot;\n&quot;);
        sb.append(&quot;BuildUser: &quot;);
        sb.append(getString(R.string.build_host));
        sb.append(&quot;\n&quot;);
        try {
            ApplicationInfo appInfo = getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
            String appKey = appInfo.metaData.getString(&quot;APP_KEY&quot;);
            sb.append(&quot;AppKey: &quot;);
            sb.append(appKey);
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
        }
        TextView tv_appInfo = findViewById(R.id.tv_appInfo);
        tv_appInfo.setText(sb);
        ImageView iv_log = findViewById(R.id.iv_log);
        iv_log.setImageResource(getApplicationInfo().icon);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-db2763edb4deb986.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;六替换资源文件&quot;&gt;六、替换资源文件&lt;/h5&gt;
&lt;p&gt;在多渠道打包时，除了需要在应用中打上特定的标签外，也可能需要使之使用不同的资源文件，例如应用图标和应用名称&lt;/p&gt;
&lt;p&gt;此时可以以各个 &lt;code&gt;productFlavor&lt;/code&gt; 的名称来命名相应的文件夹，并在其中放置相应的图标文件以及声明了应用名称的 &lt;code&gt;string.xml&lt;/code&gt; 文件，这样在多渠道打包时，Gradle 就会自动引用相应的资源文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-717c6ff61425a07f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2552605-496f4b5c470677b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上述所有的示例代码可以在这里获取：&lt;a href=&quot;https://github.com/leavesC/GradleSamples&quot;&gt;GradleSamples&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多的读书笔记可以看这里：&lt;a href=&quot;https://github.com/leavesC/Java_Kotlin_Android_Learn&quot;&gt;一份关于 Java 、Kotlin 、 Android 的学习笔记&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 15:50:00 +0000</pubDate>
<dc:creator>叶应是叶</dc:creator>
<og:description>这里分享下我在日常开发中对 Gradle 的常用配置规则 一、版本号配置 当项目逐渐演进的过程中，主工程依赖的 可能会越来越多，此时就需要统一配置各个 的编译参数了 在工程的根目录下新建一个 文件，命</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leavesC/p/9624397.html</dc:identifier>
</item>
<item>
<title>19届瓜子测试开发工程师校招-编程题 - heart_fox</title>
<link>http://www.cnblogs.com/lijuanhu321/p/9624346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijuanhu321/p/9624346.html</guid>
<description>&lt;p&gt;选择题涵盖面比较广，包括数据库的设计模式，结构型模式有哪几种，排序中的稳定排序，用户拨号认证的协议，TCP/IP对应OSI网络协议哪一层，Java与C++，数据库联合查询等。&lt;/p&gt;
&lt;h2&gt;编程题1：给出两个数，输出最大公约数与最大公倍数&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;stdio.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m,n,a;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;((cin&amp;gt;&amp;gt;m&amp;gt;&amp;gt;n)!=&lt;span&gt;NULL)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(m&amp;gt;&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;n&amp;gt;&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;m==&lt;span&gt;n)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             cout&amp;lt;&amp;lt;&lt;span&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             cout&amp;lt;&amp;lt;m&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(m&amp;gt;&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;n&amp;gt;&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;m!=&lt;span&gt;n)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=m*n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(m%i==&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;n%i==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     cout&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     cout&amp;lt;&amp;lt;m*n/i&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;return 0;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;编程题2：数字和为sum的方法数&lt;/h2&gt;
&lt;p&gt;题目：给定一个有n个正整数的数组A和一个整数sum，，求选择数组中部分数字和为sum的方案数。当两种选取方案有一个数字的下标不一样，我们就认为是不同的组成方案。&lt;/p&gt;
&lt;p&gt;输入：第一行为两个正整数n（1&amp;lt;=n&amp;lt;=1000），sum（1&amp;lt;=sum&amp;lt;=1000）；&lt;/p&gt;
&lt;p&gt;第二行为n个正整数Ai，以空格隔开&lt;/p&gt;
&lt;p&gt;输出：输出所求的方案数&lt;/p&gt;
&lt;p&gt;例1：输入&lt;/p&gt;
&lt;p&gt;5 15&lt;/p&gt;
&lt;p&gt;5 5 10 2 3&lt;/p&gt;
&lt;p&gt;输出： 4&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; typedef &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; LL;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; LL dp[&lt;span&gt;1000&lt;/span&gt;][&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,sum;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;sum);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; array[&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++) cin&amp;gt;&amp;gt;&lt;span&gt;array[i];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(n&amp;gt;=&lt;span&gt;1&lt;/span&gt;&amp;amp;&amp;amp;n&amp;lt;=&lt;span&gt;1000&lt;/span&gt;&amp;amp;&amp;amp;sum&amp;gt;=&lt;span&gt;1&lt;/span&gt;&amp;amp;&amp;amp;sum&amp;lt;=&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++) dp[&lt;span&gt;0&lt;/span&gt;][j]=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         dp[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;=sum;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 dp[i][j]=dp[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;][j];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(j&amp;gt;=array[i-&lt;span&gt;1&lt;/span&gt;]) dp[i][j] +=dp[i-&lt;span&gt;1&lt;/span&gt;][j-array[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         cout&amp;lt;&amp;lt;dp[n][sum]&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;编程题3：&lt;/h2&gt;
&lt;p&gt;题目：有一堆石子共有N个。A B两个人轮流拿，A先拿。每次最少拿1颗，最多拿K颗，拿到最后1颗石子的人获胜。假设A，B都非常聪明，拿石子的过程不会出现失误。给出N和K，问最后谁能赢得比赛。假如N=3，K=2.无论A如何拿，B都可以拿到最后1颗石子。&lt;/p&gt;
&lt;p&gt;输入：第1行：一个数T，表示后面用作输入测试的数的数量。（1&amp;lt;=T&amp;lt;=10000）&lt;/p&gt;
&lt;p&gt;第2-T+1行：每行2个数N，K。中间用空格分隔。&lt;/p&gt;
&lt;p&gt;输出：共T行，如果A获胜输出A，如果B获胜输出B。&lt;/p&gt;
&lt;p&gt;例1：输入&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;3 2&lt;/p&gt;
&lt;p&gt;4 2&lt;/p&gt;
&lt;p&gt;7 3&lt;/p&gt;
&lt;p&gt;8 3&lt;/p&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;B&lt;/p&gt;
&lt;p&gt;A&lt;/p&gt;
&lt;p&gt;A&lt;/p&gt;
&lt;p&gt;B&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     cin&amp;gt;&amp;gt;&lt;span&gt;t;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; array[&lt;span&gt;10000&lt;/span&gt;][&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;t;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;&lt;span&gt;2&lt;/span&gt;;j++) cin&amp;gt;&amp;gt;&lt;span&gt;array[i][j];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;t;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(array[i][&lt;span&gt;0&lt;/span&gt;]&amp;lt;=array[i][&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             array[i][&lt;span&gt;0&lt;/span&gt;]%=(array[i][&lt;span&gt;1&lt;/span&gt;]+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(array[i][&lt;span&gt;0&lt;/span&gt;]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 10 Sep 2018 15:38:00 +0000</pubDate>
<dc:creator>heart_fox</dc:creator>
<og:description>考试时长：90分钟 考试题型：选择题15道（包括单选与多选），编程题3道。 考试范围： 选择题涵盖面比较广，包括数据库的设计模式，结构型模式有哪几种，排序中的稳定排序，用户拨号认证的协议，TCP/IP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijuanhu321/p/9624346.html</dc:identifier>
</item>
<item>
<title>Solr7.4.0的API操作Solrj - Frankdeng</title>
<link>http://www.cnblogs.com/frankdeng/p/9615856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/frankdeng/p/9615856.html</guid>
<description>&lt;h2&gt;一.SolrJ的概念&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;a href=&quot;https://lucene.apache.org/solr/7_4_0//solr-solrj/&quot;&gt;SolrJ&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;是一个API，它使用Java（或任何基于JVM的语言）编写的应用程序可以轻松地与Solr交谈。&lt;/span&gt;&lt;span&gt;SolrJ隐藏了许多连接到Solr的细节，并允许您的应用程序通过简单的高级方法与Solr交互。&lt;/span&gt;&lt;span&gt;SolrJ支持大多数Solr API，并且具有高度可配置性。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;官方API参考文档： &lt;a href=&quot;http://lucene.apache.org/solr/guide/7_4/using-solrj.html#using-solrj&quot; target=&quot;_blank&quot;&gt;http://lucene.apache.org/solr/guide/7_4/using-solrj.html#using-solrj&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;这里使用Maven构建项目，请将以下内容放入&lt;code&gt;pom.xml&lt;/code&gt;：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot; readability=&quot;31.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.solr&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;solr-solrj&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;7.4.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1385722/201809/1385722-20180910101605076-450652236.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;为了方便测试，导入单元测试依赖和日志依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;&lt;span&gt;4.12&lt;/span&gt;&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;slf4j-nop&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;1.7.25&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二.SolrJ的单机连接&lt;/h2&gt;
&lt;div class=&quot;listingblock&quot; readability=&quot;7.8014184397163&quot;&gt;
&lt;div class=&quot;content&quot; readability=&quot;38.519503546099&quot;&gt;
&lt;p&gt;&lt;code&gt;SolrClient是一个抽象类，下边有很多被实现的子类，&lt;a href=&quot;https://lucene.apache.org/solr/7_4_0//solr-solrj/org/apache/solr/client/solrj/impl/HttpSolrClient.html&quot;&gt;HttpSolrClient&lt;/a&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; - 面向以查询为中心的工作负载，但也是一个很好的通用客户端。&lt;/span&gt;&lt;span&gt;直接与单个Solr节点通信。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不同solr版本solrj 的创建方式有所不同&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;solr4创建方式&lt;/span&gt;
SolrServer solrServer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpSolrServer(solrUrl); &lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;solr5创建方式,在url中指定core名称：core1 &lt;br/&gt;HttpSolrClient solrClient = new HttpSolrClient(&lt;/span&gt;&lt;span&gt;solrUrl); &lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;solr7创建方式,在url中指定core名称：core1 &lt;br/&gt;HttpSolrClient solrClient = new HttpSolrClient.Builder(&lt;/span&gt;&lt;span&gt;solrUrl).build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.xyg.solr;

import org.apache.solr.client.solrj.impl.HttpSolrClient;
import org.junit.Test;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Author: Mr.Deng
 * Date: 2018/9/10
 * Desc: 测试连接客户端
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; testConnectionClient {

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testConnectionClient(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置solr客户端url地址&lt;/span&gt;
        String solrUrl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://node21:8080/solr/new_core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建solrClient同时指定超时时间，不指定走默认配置&lt;/span&gt;
        HttpSolrClient solrClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpSolrClient.Builder(solrUrl)
                .withConnectionTimeout(&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;)
                .withSocketTimeout(&lt;/span&gt;&lt;span&gt;60000&lt;/span&gt;&lt;span&gt;)
                .build();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(solrClient);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1385722/201809/1385722-20180910140310658-1697111360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三.SolrJ的集群连接&lt;/h2&gt;
&lt;p&gt; &lt;a href=&quot;https://lucene.apache.org/solr/7_4_0//solr-solrj/org/apache/solr/client/solrj/impl/CloudSolrClient.html&quot;&gt;&lt;code&gt;CloudSolrClient&lt;/code&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt; - 面向与SolrCloud部署的通信。&lt;/span&gt;&lt;span&gt;使用已记录的ZooKeeper状态来发现并将请求路由到健康的Solr节点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.xyg.solrCloud;

import org.apache.solr.client.solrj.impl.CloudSolrClient;
import org.junit.Test;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Author: Mr.Deng
 * Date: 2018/9/10
 * Desc: 测试连接客户端
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConnectionCloudSolrClient {

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; connectionCloudSolrClient(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一种方式：使用运行中的某一台solr节点
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;final String solrUrl = &quot;&lt;/span&gt;&lt;span&gt;http://192.168.100.21&lt;/span&gt;&lt;span&gt;:8983/solr&quot;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CloudSolrClient solrClient = new CloudSolrClient.Builder().withSolrUrl(solrUrl).build();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二种方式：使用zookeeper节点连接（推荐）&lt;/span&gt;
        final String zkHost = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;node21:2181,node22:2181,node23:2181/solr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        CloudSolrClient solrClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CloudSolrClient.Builder().withZkHost(zkHost).build();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(solrClient);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1385722/201809/1385722-20180910201203017-1727805042.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四.SolrJ的增删改查&lt;/h2&gt;
&lt;p&gt;这里测试单机版APi操作&lt;/p&gt;
&lt;h2&gt;1.创建索引&lt;/h2&gt;
&lt;h3&gt;1）指定id单条创建索引 &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
@Test&lt;br/&gt;public void addIndexById() throws IOException, SolrServerException {&lt;br/&gt;String solrUrl = &quot;http://node21:8080/solr/new_core&quot;;&lt;br/&gt;HttpSolrClient solrClient = new HttpSolrClient.Builder(solrUrl).build();&lt;br/&gt;//创建索引文档对象&lt;br/&gt;SolrInputDocument doc = new SolrInputDocument();&lt;br/&gt;// 第一个参数：域的名称，域的名称必须是在schema.xml中定义的&lt;br/&gt;// 第二个参数：域的值,注意：id的域不能少&lt;br/&gt;doc.addField(&quot;id&quot;,&quot;1&quot;);&lt;br/&gt;doc.addField(&quot;name&quot;,&quot;红豆&quot;);&lt;br/&gt;doc.addField(&quot;price&quot;,&quot;1.2&quot;);&lt;br/&gt;//3.将文档写入索引库中&lt;br/&gt;solrClient.add(doc);&lt;br/&gt;solrClient.commit();&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2）批量创建索引 &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
@Test&lt;br/&gt;public void addIndexByListId() throws Exception {&lt;br/&gt;String solrUrl = &quot;http://node21:8080/solr/new_core&quot;;&lt;br/&gt;HttpSolrClient solrClient = new HttpSolrClient.Builder(solrUrl).build();&lt;br/&gt;//创建索引文档对象&lt;br/&gt;SolrInputDocument doc1 = new SolrInputDocument();&lt;br/&gt;doc1.addField( &quot;id&quot;, &quot;2&quot;);&lt;br/&gt;doc1.addField( &quot;name&quot;, &quot;绿豆&quot;);&lt;br/&gt;doc1.addField( &quot;price&quot;, 1.8 );&lt;br/&gt;SolrInputDocument doc2 = new SolrInputDocument();&lt;br/&gt;doc2.addField( &quot;id&quot;, &quot;3&quot; );&lt;br/&gt;doc2.addField( &quot;name&quot;, &quot;黑豆&quot; );&lt;br/&gt;doc2.addField( &quot;price&quot;, 2.6 );&lt;br/&gt;Collection&amp;lt;SolrInputDocument&amp;gt; docs = new ArrayList&amp;lt;SolrInputDocument&amp;gt;();&lt;br/&gt;docs.add(doc1);&lt;br/&gt;docs.add(doc2);&lt;br/&gt;//3.将文档写入索引库中&lt;br/&gt;solrClient.add(docs);&lt;br/&gt;solrClient.commit();&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.查询索引&lt;/h2&gt;
&lt;h3&gt;1）匹配查询&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; findIndex1() throws IOException, SolrServerException {
        String solrUrl &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://node21:8080/solr/new_core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        HttpSolrClient solrClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpSolrClient.Builder(solrUrl).build();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建搜索对象&lt;/span&gt;
        SolrQuery query = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SolrQuery();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置搜索条件&lt;/span&gt;
        query.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;q&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*:*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置每页显示多少条&lt;/span&gt;
        query.setRows(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发起搜索请求&lt;/span&gt;
        QueryResponse response =&lt;span&gt; solrClient.query(query);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询结果&lt;/span&gt;
        SolrDocumentList docs =&lt;span&gt; response.getResults();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询结果总数&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; cnt =&lt;span&gt; docs.getNumFound();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;总条数为&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+cnt+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;条&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (SolrDocument doc : docs) {
          System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+ doc.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,name:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+ doc.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,price:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+ doc.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        }
        solrClient.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1385722/201809/1385722-20180910233445611-1038212656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2）条件过滤查询&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; findIndex2() throws IOException, SolrServerException {
        String solrUrl &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://node21:8080/solr/new_core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        HttpSolrClient solrClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpSolrClient.Builder(solrUrl).build();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2 封装查询参数&lt;/span&gt;
        Map&amp;lt;String, String&amp;gt; queryParamMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
        queryParamMap.put(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;q&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*:*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3 添加到SolrParams对象,SolrParams 有一个 SolrQuery 子类，它提供了一些方法极大地简化了查询操作&lt;/span&gt;
        MapSolrParams queryParams = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MapSolrParams(queryParamMap);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4 执行查询返回QueryResponse&lt;/span&gt;
        QueryResponse response =&lt;span&gt; solrClient.query(queryParams);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5 获取doc文档&lt;/span&gt;
        SolrDocumentList docs =&lt;span&gt; response.getResults();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询结果总数&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; cnt =&lt;span&gt; docs.getNumFound();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;总条数为&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + cnt + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;条&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[6]内容遍历&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (SolrDocument doc : docs) {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + doc.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,name:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + doc.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,price:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + doc.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        }
        solrClient.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1385722/201809/1385722-20180910231413622-985987843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.更新索引&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; updateIndex() throws IOException, SolrServerException {
        String solrUrl &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://node21:8080/solr/new_core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        HttpSolrClient solrClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpSolrClient.Builder(solrUrl).build();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建索引文档对象&lt;/span&gt;
        SolrInputDocument doc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SolrInputDocument();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把红豆价格修改为1.5&lt;/span&gt;
        doc.addField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        doc.addField(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;红豆&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        doc.addField(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.将文档写入索引库中&lt;/span&gt;
&lt;span&gt;        solrClient.add(doc);
        solrClient.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交&lt;/span&gt;
&lt;span&gt;        solrClient.commit();

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.删除索引 &lt;/h2&gt;
&lt;h3&gt;1）单一条件删除&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteIndexById() throws IOException, SolrServerException {
        String solrUrl &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://node21:8080/solr/new_core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        HttpSolrClient solrClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpSolrClient.Builder(solrUrl).build();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;全删
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;solrClient.deleteByQuery(&quot;*:*&quot;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模糊匹配删除（带有分词效果的删除）&lt;/span&gt;
        solrClient.deleteByQuery(&lt;span&gt;&quot;name:&lt;/span&gt;&lt;span&gt;红&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定id删除
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;solrClient.deleteById(&quot;1&quot;);&lt;/span&gt;
&lt;span&gt;        solrClient.commit();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2）批量条件删除&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deleteIndexByListId() throws IOException, SolrServerException {
        String solrUrl &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://node21:8080/solr/new_core&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        HttpSolrClient solrClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpSolrClient.Builder(solrUrl).build();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过id删除&lt;/span&gt;
        ArrayList&amp;lt;String&amp;gt; ids = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        ids.add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        ids.add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        solrClient.deleteById(ids);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[3]提交&lt;/span&gt;
&lt;span&gt;        solrClient.commit();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[4]关闭资源&lt;/span&gt;
&lt;span&gt;        solrClient.close();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五.代码报错问题&lt;/h2&gt;
&lt;h3&gt;1.代码添加索引报405问题&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1385722/201809/1385722-20180910180349067-774227343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;在使用Tomcat部署Solr后，new_core的地址为：http://node21:8080/solr/#/new_core，但使用SolrJ进行索引的时候，应该使用http://node21:8080/solr/new_core，即无中间的#号。&lt;/p&gt;
&lt;h3&gt;2.自定义索引字段&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1385722/201809/1385722-20180910181746451-78515325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图报错提示未识别索引字段&lt;/p&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3cschool.cn/solr_doc/solr_doc-g1az2fmd.html&quot; target=&quot;_blank&quot;&gt;https://www.w3cschool.cn/solr_doc/solr_doc-g1az2fmd.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/gaogaoyanjiu/p/7815558.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/gaogaoyanjiu/p/7815558.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/11fb9cfdb2fd&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/11fb9cfdb2fd&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 15:36:00 +0000</pubDate>
<dc:creator>Frankdeng</dc:creator>
<og:description>一.SolrJ的概念 SolrJ是一个API，它使用Java（或任何基于JVM的语言）编写的应用程序可以轻松地与Solr交谈。SolrJ隐藏了许多连接到Solr的细节，并允许您的应用程序通过简单的高级</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/frankdeng/p/9615856.html</dc:identifier>
</item>
<item>
<title>依赖状态的线程任务的等待方式之忙等待 - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/9624286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/9624286.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;引入：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;有时候我们执行一个操作，需要一个前提条件，只有在条件满足的情况下，才能继续执行。在单线程程序中，如果某个状态变量不满足条件，则基本上可以直接返回。但是，在并发程序中，基于状态的条件可能会由于其他线程的操作而改变。而且存在这种需要，即某个操作一定要完成，如果当前条件不满足，没关系，我可以等，等到条件满足的时候再执行。今天，我们就来&lt;span&gt;聊一聊等待的几种方式。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;忙等待 / 自旋等待。&lt;/li&gt;
&lt;li&gt;让权等待 / 轮询与休眠&lt;/li&gt;
&lt;li&gt;条件队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;情景条件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们要实现一个有界缓存，其中&lt;span&gt;用不同的等待方式处理前提条件失败的问题&lt;/span&gt;。在每种实现中都扩展了BaseBoundedBuffer，这个类中实现了一个基于数组的循环缓存，其中各个缓存状态变量（buf、head、tail和count）均由缓存的内置锁来保护。它还提供了同步的doPut和doTake方法，并在子类中通过这些方法来实现put和take操作，底层的状态将对子类隐藏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1313132/201809/1313132-20180910204700083-1052171559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此段代码来自《Java Concurrency in Practice》&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseBoundedBuffer&amp;lt;V&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; V[] buf;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓冲数组&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tail;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓冲数据尾部索引&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; head;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头部索引&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储的数据量&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; BaseBoundedBuffer(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.buf = (V[]) &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[capacity];
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doPut(V v) {
        buf[tail] &lt;/span&gt;=&lt;span&gt; v;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++tail ==&lt;span&gt; buf.length)
            tail &lt;/span&gt;= 0&lt;span&gt;;
        &lt;/span&gt;++&lt;span&gt;count;
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; V doTake() {
        V v &lt;/span&gt;=&lt;span&gt; buf[head];
        buf[head] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (++head ==&lt;span&gt; buf.length)
            head &lt;/span&gt;= 0&lt;span&gt;;
        &lt;/span&gt;--&lt;span&gt;count;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isFull() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; count ==&lt;span&gt; buf.length;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; count == 0&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;忙等待：反复检查条件是否为真，直到条件达到，继而完成后续任务。&lt;/p&gt;
&lt;p&gt;我们来看看，忙等待的实现方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BusyWaitBoundedBuffer&amp;lt;V&amp;gt; &lt;span&gt;extends&lt;/span&gt; BaseBoundedBuffer&amp;lt;V&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BusyWaitBoundedBuffer(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(size);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put(V v) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;isFull()) {
                    doPut(v);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; V take() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;isEmpty())
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; doTake();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的两个方法在访问缓存时都采用&quot;&lt;strong&gt;先检查，再运行&lt;/strong&gt;&quot;的逻辑策略，非线程安全，因为条件可能在&quot;&lt;strong&gt;检查之后，运行之前&lt;/strong&gt;&quot;的中间时刻，被其他线程修改，以至于，在运行的时候，前提条件已经不满足了，故需要对put和take两个方法都进行同步，共用同一个锁以确保实现对缓冲状态的&lt;span&gt;独占访问&lt;/span&gt;，即某一时刻只能有一个线程可以访问操作缓冲数组。也就是说，在put方法执行的一次尝试中，take方法不能被调用，不能改变缓冲数组状态。&lt;/p&gt;
&lt;p&gt;还有一点，值得注意的是，while循环并不在同步块内，而是同步块在while循环内，也就是每执行一次条件检查，如果不满足，需要释放掉锁。不然另一个方法就拿不到锁，也就不能改变状态，条件就永远不能发生改变，这个方法就变成了&lt;span&gt;&lt;strong&gt;死等待&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这样做，虽然在逻辑上实现了功能要求，但是在性能上却可能消耗过多的CPU时间，因为它占据着CPU，不做计算，而只是等待。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;“尚未解决的疑惑”：&lt;/strong&gt;&lt;/span&gt;线程等待锁的时候是否会被JVM挂起，调出CPU？如果是这样的话，那么上下文切换的开销也会很大，因为每检查一次条件，需要进出CPU两次。&lt;/p&gt;

</description>
<pubDate>Mon, 10 Sep 2018 15:33:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>引入： 有时候我们执行一个操作，需要一个前提条件，只有在条件满足的情况下，才能继续执行。在单线程程序中，如果某个状态变量不满足条件，则基本上可以直接返回。但是，在并发程序中，基于状态的条件可能会由于其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/9624286.html</dc:identifier>
</item>
<item>
<title>MySql 执行计划 - 精品唯居</title>
<link>http://www.cnblogs.com/liyasong/p/mysql_zhixingjihua.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liyasong/p/mysql_zhixingjihua.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　mysql执行计划是sql语句经过查询优化器后，查询优化器会根据用户的sql语句所包含的字段和内容数量等统计信息，选择出一个执行效率最优（mysql系统认为最优）的执行计划，然后根据执行计划，调用存储引擎提供的接口，获取数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是，在mysql执行的时候，到底使用了一个什么样的执行计划，有没有用到索引。当数据规模比较大的时候，sql执行的时候，执行计划不同，会直接影响sql的执行速度。这个时候，就需要对sql语句执行进行调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　mysql我们在调试sql语句的时候，不会像我们写java或者其他语言代码那样通过打断点的方式进行代码调试。这个时候，我们就需要通过查看执行计划来调试我们的sql了。Mysql通过EXPLAIN来查看执行计划，我们写sql语句的时候，在语句之前加一个EXPLAIN就可以了。EXPLAIN可以用在SELECT、DELETE、INSERT、PEPLACE以及UPDATE等语句中，如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_b8ea79b6-0b14-4125-9fd0-587885432577&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b8ea79b6-0b14-4125-9fd0-587885432577&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b8ea79b6-0b14-4125-9fd0-587885432577&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; EXPLAIN &lt;span&gt;SELECT&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;*&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    school
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     school_nick &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;县第一小学&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;EXPLAIN SQL&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　执行后，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1104082/201809/1104082-20180910171930245-1249058099.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里介绍下每个字段以及每个字段的含义：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　&lt;strong&gt;id&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　id是执行计划的标识符，是SELECT 查询的序号。如果结果集会跟其他表的结果用UNION关键字相结合，那么id可能为空。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　id是否为空，对执行计划的影响不大，如果有兴趣可以看另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/liyasong/p/mysql_UNION.html&quot; target=&quot;_blank&quot;&gt;mysql执行计划id为空—UNION关键字&lt;/a&gt;，这里不再赘述。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　&lt;strong&gt;select_type&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　select_type表示sql语句查询的类型。具体表示如下表：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;2&quot;&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;select_type的值          &lt;/td&gt;
&lt;td&gt;含义&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SIMPLE&lt;/td&gt;
&lt;td&gt;简单的select查询，没有使用关联和子查询。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PRIMARY&lt;/td&gt;
&lt;td&gt;最外层select，包含子查询的时候，最外层的查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UNION&lt;/td&gt;
&lt;td&gt;在一个UNION查询中，第二次或以后的子查询操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;DEPENDENT UNION&lt;/td&gt;
&lt;td&gt;在一个UNION查询中，第二次子查询或以后的SELECT查询的时候需要依赖外部的查询                          &lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UNION RESULT&lt;/td&gt;
&lt;td&gt;UNION的返回结果集&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SUBQUERY&lt;/td&gt;
&lt;td&gt;子查询语句的第一个select语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;DEPENDENT SUBQUERY                                 &lt;/td&gt;
&lt;td&gt;依赖外部查询的第一个子查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DERIVED&lt;/td&gt;
&lt;td&gt;派生表——该临时表是从子查询派生出来的，位于form中的子查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MATERIALIZED&lt;/td&gt;
&lt;td&gt;物化子查询（不确定啥意思，以后研究后再回来补充，或者大神指教）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;UNCACHEABLE SUBQUERY     &lt;/td&gt;
&lt;td&gt;无法缓存结果的子查询，必须为外部查询的每一行重新计算&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;UNCACHEABLE UNION&lt;/td&gt;
&lt;td&gt;UNION中的第二个或以后的不可缓存的子查询。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;&lt;span&gt;　　table&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　输出行引用的表的名称。一般为表格名称或别名，也可能为如下值：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.UNION的并集结果集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.derivedN当前行指向派生结果集。可能是一个派生表，例如来自FROM子句的结果集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.subqueryN 当前行指向一个子查询的结果集。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　type&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　连接类型。该列输出表示如何连接表。下面的类型表示从最好的到最坏的类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.&lt;strong&gt;system &lt;/strong&gt;该表只有一行（=系统表）。这是&lt;code class=&quot;literal&quot;&gt;const&lt;/code&gt;连接类型的特例 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.&lt;strong&gt;const &lt;/strong&gt;最多只有一行匹配，在查询开始的时候，计算出常量对应的地址，直接访问，例如：select * from test where  name ='zhang' 当name是唯一索引的时候，就有可能出现const。&lt;code class=&quot;literal&quot;&gt;const&lt;/code&gt;非常快，因为它只读一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.&lt;strong&gt;eq_ref &lt;/strong&gt;除了 &lt;code class=&quot;literal&quot;&gt;system&lt;/code&gt;和 &lt;code class=&quot;literal&quot;&gt;const&lt;/code&gt;类型之外，这是最好的连接类型。当两个表联查时使用索引的所有部分（针对的是组合索引），且索引是 主键或唯一索引时使用它。使用“=”运算符来进行索引列的比较。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.&lt;strong&gt;ref &lt;/strong&gt;非唯一索引扫描，返回某个匹配值的所有行。常用语非唯一索引。这里对于eq_ref 和ref不熟悉的同学，可以看以下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;　　&lt;img id=&quot;code_img_closed_49d1e671-acb4-4908-afa4-9a666a3c9a6d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_49d1e671-acb4-4908-afa4-9a666a3c9a6d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_49d1e671-acb4-4908-afa4-9a666a3c9a6d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 给test表的name字段加唯一索引，test2 的job 行添加非唯一索引。&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 这个代码执行后，首先执行test2 的查询，查出job = ‘teacher’ 的所有集合。&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 所以test2 的typ是ref 表示的是匹配job = ‘teacher’ 的一个结果集。&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 然后从结果集中取出name的集合，去匹配test1.name的结果。因为test1.name是唯一索引，所以一个name最多匹配到一条记录，所以test的type是ref&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; EXPLAIN &lt;span&gt;SELECT&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;*&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    test,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    test2
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;WHERE&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     test. NAME &lt;span&gt;=&lt;/span&gt;&lt;span&gt; test2. NAME
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; test2.job &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;test ref and eq_ref&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　执行结果如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1104082/201809/1104082-20180910220419792-222645894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.&lt;strong&gt;fulltext &lt;/strong&gt;使用fulltext 索引进行查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6.&lt;strong&gt;ref_or_null &lt;/strong&gt;这种链接类型类似于ref，但是，除了ref之外，还对包含null的值进行了搜索。常用于解析子查询。代码示例如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_3f1fbeec-2fc8-4244-b315-26e512de35f4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3f1fbeec-2fc8-4244-b315-26e512de35f4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3f1fbeec-2fc8-4244-b315-26e512de35f4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; ref_table
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;WHERE&lt;/span&gt; key_column&lt;span&gt;=&lt;/span&gt;expr &lt;span&gt;OR&lt;/span&gt; key_column &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ref_or_null&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　7.&lt;strong&gt;index_merge &lt;/strong&gt;这个链接类型表示使用索引合并优化。输出内容包含在索引列表中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　8.&lt;strong&gt;unique_subquery&lt;/strong&gt; 索引查找，替换子查询，以提高效率。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_a75eb0c0-0a09-432f-b8ca-b5d8ff9098f0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a75eb0c0-0a09-432f-b8ca-b5d8ff9098f0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a75eb0c0-0a09-432f-b8ca-b5d8ff9098f0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
value &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; primary_key &lt;span&gt;FROM&lt;/span&gt; single_table &lt;span&gt;WHERE&lt;/span&gt; some_expr)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;unique_subquery&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　9. &lt;strong&gt;index_subquery&lt;/strong&gt; 类似于unique_subquery 但是替换in子查询，适用于非唯一索引，代码： &lt;span class=&quot;cnblogs_code&quot;&gt;value &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; key_column &lt;span&gt;FROM&lt;/span&gt; single_table &lt;span&gt;WHERE&lt;/span&gt; some_expr)&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　10.&lt;strong&gt;range &lt;/strong&gt;扫描部分索引，对索引的扫描从某一点开始，返回的是某个索引区域的值。常见的有基于索引的 &amp;lt; ,&amp;gt; 等的查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　11. &lt;strong&gt;index &lt;/strong&gt;扫描全部索引，对索引进行整体扫描。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　12.&lt;strong&gt;all &lt;/strong&gt;全表扫描，最慢的查询 。应该避免&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt; 　possible_keys&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　可能使用的key，指出当前查询涉及到的行都含有那些索引。如果有索引就会列出，但是不一定会被使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　key&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　实际使用的索引。如果没有使用索引，显示null。&lt;/p&gt;
&lt;h2&gt;　 key_len&lt;/h2&gt;
&lt;p&gt;　　表中对应的索引最大可能长度。可以通过设置索引长度改变该值。例如：一个varchar（255）的索引长度为255，可是我们使用不到那么长，我们可以取字符串的前五位作为索引。这时key_len 就是5.这里关于索引值的长度的选取规则，以后有机会再写一篇博客详细介绍。&lt;/p&gt;
&lt;h2&gt;　　&lt;span&gt;ref&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　哪些字段和key一起被使用。没用过。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　rows&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　受影响的行数。不是特别精确的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;　　Extra&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　解释额外的信息。包含mysql对于query优化的时候的一些附加信息。&lt;strong&gt;非常有用&lt;/strong&gt;。可能出现的结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;const row not found 该表为空&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Deleting all rows   表格内数据被标记删除，正在删除中（某些存储引擎支持一种方法，以简单快捷的方式删除所有行，这时查询就会出现这个提示）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Distinct  MySQL正在寻找不同的值，因此它在找到第一个匹配行后停止为当前行组合搜索更多行。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code class=&quot;literal&quot;&gt;FirstMatch(&lt;em class=&quot;replaceable&quot;&gt;&lt;code&gt;tbl_name&lt;/code&gt;&lt;/em&gt;)&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;半连接FirstMatch连接快捷方式策略用于&lt;/span&gt;&lt;/span&gt;&lt;em class=&quot;replaceable&quot;&gt;&lt;code&gt;tbl_name&lt;/code&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Full scan on NULL key当优化程序无法使用索引查找访问方法时，子查询优化将作为回退策略发生。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Impossible HAVING&lt;span&gt;&lt;span&gt;该&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;HAVING&lt;/code&gt;&lt;span&gt;&lt;span&gt;子句始终为false，无法选择任何行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Impossible WHERE &lt;span&gt;&lt;span&gt;该&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;WHERE&lt;/code&gt;&lt;span&gt;&lt;span&gt;子句始终为false，无法选择任何行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Impossible WHERE noticed after reading const tables &lt;span&gt;&lt;span&gt;MySQL已经读取了所有 &lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;const&lt;/code&gt;&lt;span&gt;&lt;span&gt;（和 &lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;system&lt;/code&gt;&lt;span&gt;&lt;span&gt;）表，并注意到该&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;WHERE&lt;/code&gt;&lt;span&gt;&lt;span&gt;子句始终为false。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;No matching min/max row 没有行满足查询的条件的行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;no matching row in const table  对于具有连接的查询，有一个空表或没有满足唯一索引条件的行的表。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;No matching rows after partition pruning  &lt;span&gt;&lt;span&gt;对于&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;DELETE&lt;/code&gt;&lt;span&gt;&lt;span&gt;或 &lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;UPDATE&lt;/code&gt;&lt;span&gt;&lt;span&gt;，优化器在分区修剪后发现没有删除或更新的内容。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;No tables used &lt;span&gt;&lt;span&gt;查询没有&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;FROM&lt;/code&gt;&lt;span&gt;&lt;span&gt;子句&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Not exists 查询的内容不存在 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;code class=&quot;literal&quot;&gt;Plan isn't ready yet&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;span&gt;优化程序尚未完成为在命名连接中执行的语句创建执行计划时，&lt;/span&gt;&lt;span&gt; 会出现此值&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Range checked for each record MySQL发现没有好的索引可以使用，但发现在前面的表的列值可能会使用某些索引。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Recursive  递归&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;code class=&quot;literal&quot;&gt;Skip_open_table&lt;/code&gt;&lt;span&gt;&lt;span&gt;， &lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;Open_frm_only&lt;/code&gt;&lt;span&gt;&lt;span&gt;， &lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;Open_full_table  &lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;ul class=&quot;itemizedlist&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;listitem&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;Skip_open_table&lt;/code&gt;&lt;span&gt;&lt;span&gt;：表文件不需要打开。&lt;/span&gt;&lt;span&gt;该信息已从数据字典中获得。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;Open_frm_only&lt;/code&gt;&lt;span&gt;：只需要读取表信息的数据字典。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;listitem&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code class=&quot;literal&quot;&gt;Open_full_table&lt;/code&gt;&lt;span&gt;&lt;span&gt;：未优化的信息查找。&lt;/span&gt;&lt;span&gt;必须从数据字典中读取表信息并读取表文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;unique row not found  &lt;span&gt;对于查询&lt;/span&gt;&lt;span&gt;，没有行满足&lt;/span&gt;&lt;span&gt; 索引或&lt;/span&gt;&lt;span&gt;表的条件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Using filesort  使用文件排序。&lt;span&gt;&lt;span&gt;MySQL必须执行额外的传递以找出如何按排序顺序检索行。&lt;/span&gt;&lt;span&gt;排序是通过根据连接类型遍历所有行并将排序键和指针存储到与该&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;WHERE&lt;/code&gt;&lt;span&gt;&lt;span&gt;子句&lt;/span&gt;&lt;span&gt;匹配的所有行的行来完成的&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;然后对键进行排序，并按排序顺序检索行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;code class=&quot;literal&quot;&gt;Using index &lt;span&gt;仅使用索引树中的信息从表中检索列信息，而不必另外寻找读取实际行。&lt;/span&gt;&lt;span&gt;当查询仅使用属于单个索引的列时，可以使用此策略。&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Using index condition  通过首先访问索引，确定是否可以读取完整的表行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Using index for group-by  使用索引分组。&lt;span&gt;&lt;span&gt;表示MySQL找到了一个索引，可用于检索&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;GROUP BY&lt;/code&gt;&lt;span&gt;&lt;span&gt;或 &lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;DISTINCT&lt;/code&gt;&lt;span&gt;&lt;span&gt;查询的&lt;/span&gt;&lt;span&gt;所有列，&lt;/span&gt;&lt;span&gt;而无需对实际表进行任何额外的磁盘访问。&lt;/span&gt;&lt;span&gt;此外，索引以最有效的方式使用，因此对于每个组，只读取少数索引条目。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Using index for skip scan  使用索引跳过扫描范围&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Using join buffer  将表数据读入缓存，然后从缓存中读数据来执行操作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Using MRR 使用多范围读取优化策略读取表。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Using temporary&lt;/strong&gt; 使用临时表，&lt;span&gt;&lt;span&gt;MySQL需要创建一个临时表来保存结果。&lt;/span&gt;&lt;span&gt;如果查询包含以&lt;/span&gt;&lt;span&gt;不同方式列出列的&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;GROUP BY&lt;/code&gt;&lt;span&gt;&lt;span&gt;和 &lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;ORDER BY&lt;/code&gt;&lt;span&gt;&lt;span&gt;子句，&lt;/span&gt;&lt;span&gt;则通常会发生这种情况&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Using where&lt;/strong&gt;  使用上了where限制，表示MySQL服务器在存储引擎受到记录后进行“后过滤”（Post-filter），如果查询未能使用索引，Using where的作用只是提醒我们MySQL将用where子句来过滤结果集。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Zero limit  &lt;span&gt;&lt;span&gt;查询有一个&lt;/span&gt;&lt;/span&gt;&lt;code class=&quot;literal&quot;&gt;LIMIT 0&lt;/code&gt;&lt;span&gt;&lt;span&gt;子句，不能选择任何行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;listitem&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Only index  这意味着信息只用索引树中的信息检索出的，这比扫描整个表要快。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 10 Sep 2018 15:19:00 +0000</pubDate>
<dc:creator>精品唯居</dc:creator>
<og:description>MySql执行计划详解。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liyasong/p/mysql_zhixingjihua.html</dc:identifier>
</item>
<item>
<title>一步一步学Python(3) 基础补充 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9623971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9623971.html</guid>
<description>&lt;p&gt;最近在系统学习Python，以MOOC上面的一套Python3的课程为基础。本文主要总结一下基础部分的关键点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1297823/o_1-data-type.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding: utf-8 -*-  

#空对象的类型验证
print('空对象的类型验证:')
print(type(0))
print(type(''))
print(type([]))
print(type(()))
print(type(set()))
print(type({}))

#所有空的对象都是False
print('所有空的对象都是False:')
print(bool(0))
print(bool(''))
print(bool([]))
print(bool(()))
print(bool(set()))
print(bool({}))

#与之对应，所有非空的对象都是True
print('与之对应，所有非空的对象都是True:')
print(bool(-7))
print(bool('Alfred'))
print(bool([1, 2, 3]))
print(bool((4, 5)))
print(bool({1, 3, 7}))
print(bool({1:'a', 2:'b', 3:'c'}))&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1297823/o_2-operator.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;练习题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 1
b = c = 2
x = (not a or b + 2 == c)

print(x)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用括号完整描述优先级:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(not a) or ((b + 2) == c)
最终代码运行结果为：False。&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我这里暂时使用的是Mac平台的 Sublime Text + Python 3.7 + Package Control + SublimeCodeIntel。&lt;br/&gt;对于python3的环境构建(Tools -&amp;gt; Build System -&amp;gt; New Build System),可参考python3.sublime-build：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;cmd&quot;: [&quot;/usr/local/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;],
    &quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,
    &quot;selector&quot;: &quot;source.python&quot;

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面语句可以“command + b”打印出Hello，确认python3可以使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print('Hello',end='')

#编译运行结果：
Hello[Finished in 0.1s]&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;包对应的是文件夹；包下面包含有__init__.py这个文件，本身也是一个模块；子包可以和模块平级；&lt;br/&gt;模块对应的文件；模块下写的最多应该是类；&lt;br/&gt;类包含了函数和变量；函数和变量可以理解为类本身的一些特性。&lt;/p&gt;
&lt;p&gt;类（面向对象三大特征）：封装、继承、多态。&lt;br/&gt;这一部分有很多面向对象的知识完全是通用的，对于面向对象的语言都是类似的思路方法。&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/1297823/o_3-python-class.jpg&quot;/&gt;&lt;br/&gt;对面向对象的充分理解以及对函数的深入学习是后续的重点方向。&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 15:15:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>最近在系统学习Python，以MOOC上面的一套Python3的课程为基础。本文主要总结一下基础部分的关键点。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9623971.html</dc:identifier>
</item>
<item>
<title>Javascript数组系列一之栈与队列 - Modenng</title>
<link>http://www.cnblogs.com/beevesnoodles/p/9623924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/beevesnoodles/p/9623924.html</guid>
<description>&lt;p&gt;所谓数组（英语：Array），是有序的元素序列。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。 组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。 －－－百度百科&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单理解，数组就是数据的有序列表。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Array 在 Javascript 中属于最常用的数据类型之一了，与其它语言一样 Javascript 中的数组也是数据的有序列表，但是与其他语言有所不同的是，它可以用于保存任何数据类型，而且数组的长度是可以动态调整的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var elements = [&lt;span class=&quot;hljs-string&quot;&gt;'first', &lt;span class=&quot;hljs-number&quot;&gt;2, {age: &lt;span class=&quot;hljs-number&quot;&gt;14}];&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h&quot;&gt;创建数组&lt;/h3&gt;
&lt;p&gt;既然认识了数组，那我们先看怎么创建一个数组吧！Javascript 提供两种创建数组的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.通过构造函数创建&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var arr1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-built_in&quot;&gt;Array(); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;看到上面的结果简直蒙逼，因此可以看出参数传递的不同产生的结果也会不一样，而且结果令人惊讶，不过我们可以总结为：如果传入一位数值类型的参数时，则创建给一个定项的数组（例如 arr2 ），如果传入其他类型的参数时，则会创建一个包含当前参数的数组（例如 arr4， arr5），&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们这个方法比较坑，所以一般不会使用这个方法去创建数组，那么我们继续看下一个方法如何创建数组的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.通过字面量创建&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var arr1 = [];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var arr2 = [&lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;2];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var arr3 = [&lt;span class=&quot;hljs-string&quot;&gt;'1', &lt;span class=&quot;hljs-string&quot;&gt;'3'];&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;就是这么简单，粗暴，明了；是我们创建数组最常用的方法，而且这种方法创建还非常高效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h-1&quot;&gt;如何访问和设置数组&lt;/h3&gt;
&lt;p&gt;上面说到我们是如何创建一个数组，数组创建出来之后我们需要对数组中的元素进行访问或修改吧？下面我们就来看看吧&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;访问数组，通过索引访问数组中的元素，&lt;strong&gt;索引从 0 开始&lt;/strong&gt;，如果访问的索引大于数组中元素的个数怎么办呢？结果肯定是找不到的，所以会返回 undefined 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说到数组元素的个数我们不能不提到数组的一个属性了，那就是 length 属性，它会返回当前数组元素的个数，&lt;br/&gt;而且 length 属性不是只读属性，它还可以去修改，因此我们利用 length 属性即可以添加数组的元素，还可以删除数组的元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs javascript&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var arr = [&lt;span class=&quot;hljs-string&quot;&gt;'first', &lt;span class=&quot;hljs-string&quot;&gt;'second', &lt;span class=&quot;hljs-string&quot;&gt;'three'];&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(arr[&lt;span class=&quot;hljs-number&quot;&gt;0]); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-2&quot;&gt;如何表现的和「栈」一样&lt;/h3&gt;
&lt;p&gt;想要知道数组怎么表现的和「栈」一样，首先我们先来了解一下什么是「栈」。&lt;/p&gt;
&lt;p&gt;在这里我们不深究「栈」，如果深究下去一时半会我们也说不清楚，也不是我们本文的重点。&lt;/p&gt;
&lt;p&gt;简单来说，「栈」是一种数据结构，一种 LIFO (Last-In-First-Out)的数据结构，也就是后进先出，最新添加进来的元素最早被移出。&lt;br/&gt;在 「栈」中添加数据和删除数据也被称为推入和弹出，而且推入和弹出只会发生在「栈」的顶部。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;stack 图片&quot; src=&quot;http://pd9zyk72v.bkt.clouddn.com/stack.png&quot; alt=&quot;stack 图片&quot;/&gt;stack 图片&lt;/p&gt;
&lt;p&gt;Javascript 提供为数组提供了两个方法以便于我们实现「栈」的行为，下面我们就来看看吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;push : 向数组的末尾添加元素，可以传入任意数量的参数&lt;/li&gt;
&lt;li&gt;pop：从数组的末尾删除最后一项，返回删除的元素，使数组的 length-1&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;var arr = [&lt;span class=&quot;hljs-string&quot;&gt;'A', &lt;span class=&quot;hljs-string&quot;&gt;'B', &lt;span class=&quot;hljs-string&quot;&gt;'C'];&lt;br/&gt;arr.push(&lt;span class=&quot;hljs-string&quot;&gt;'D');&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(arr); &lt;span class=&quot;hljs-regexp&quot;&gt;//[&lt;span class=&quot;hljs-string&quot;&gt;'A', &lt;span class=&quot;hljs-string&quot;&gt;'B', &lt;span class=&quot;hljs-string&quot;&gt;'C', &lt;span class=&quot;hljs-string&quot;&gt;'D']&lt;br/&gt;var rem = arr.pop();&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(arr);&lt;span class=&quot;hljs-regexp&quot;&gt;//[&lt;span class=&quot;hljs-string&quot;&gt;'A', &lt;span class=&quot;hljs-string&quot;&gt;'B', &lt;span class=&quot;hljs-string&quot;&gt;'C']&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(rem); &lt;span class=&quot;hljs-regexp&quot;&gt;// &lt;span class=&quot;hljs-string&quot;&gt;'D'&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-3&quot;&gt;如何表现的和 「队列」一样&lt;/h3&gt;
&lt;p&gt;上回我们说到 Javascript 中的数组可以有「栈」一样的行为，那么它也可以表现出和「队列」一样的行为。&lt;/p&gt;
&lt;p&gt;「栈」是一种 LIFO 数据结构，而「队列」则是一种 FIFO（First In First Out）的数据结构，即先进先出。&lt;/p&gt;
&lt;p&gt;数据在「队列」的末尾添加元素，在前端移出元素，上面说到我们可以利用 push 方法在数组的末尾添加元素，那么什么方法在数组的前端去移出元素呢？答案就是 shift() 方法。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;队列&quot; src=&quot;http://pd9zyk72v.bkt.clouddn.com/queue.jpg&quot; alt=&quot;队列&quot;/&gt;队列&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;shift：删除数组的第一个元素，返回删除的元素，使数组的 length-1&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可以看出它与pop()方法刚好相反&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;var arr = [&lt;span class=&quot;hljs-string&quot;&gt;'A', &lt;span class=&quot;hljs-string&quot;&gt;'B', &lt;span class=&quot;hljs-string&quot;&gt;'C'];&lt;br/&gt;arr.push(&lt;span class=&quot;hljs-string&quot;&gt;'D');&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(arr); &lt;span class=&quot;hljs-regexp&quot;&gt;//[&lt;span class=&quot;hljs-string&quot;&gt;'A', &lt;span class=&quot;hljs-string&quot;&gt;'B', &lt;span class=&quot;hljs-string&quot;&gt;'C', &lt;span class=&quot;hljs-string&quot;&gt;'D']&lt;br/&gt;var rem = arr.shift();&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(arr);&lt;span class=&quot;hljs-regexp&quot;&gt;//[&lt;span class=&quot;hljs-string&quot;&gt;'B', &lt;span class=&quot;hljs-string&quot;&gt;'C', &lt;span class=&quot;hljs-string&quot;&gt;'D']&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(rem); &lt;span class=&quot;hljs-regexp&quot;&gt;// &lt;span class=&quot;hljs-string&quot;&gt;'A'&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到上面我们是在末尾添加元素，前端删除元素，但是我们可以不可以在前端添加元素，在末尾删除元素呢？也就是说我们能不能反向模拟「队列」。&lt;/p&gt;
&lt;p&gt;Javascript 中为我们提供了一个方法然后我们配合pop()方法我们就可以实现反向的模拟。那就是 unshift()。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;队列2&quot; src=&quot;http://pd9zyk72v.bkt.clouddn.com/queue2.png&quot; alt=&quot;队列2&quot;/&gt;队列2&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;unshift()：在数组的开头添加任意个数的元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;var arr = [&lt;span class=&quot;hljs-string&quot;&gt;'A', &lt;span class=&quot;hljs-string&quot;&gt;'B', &lt;span class=&quot;hljs-string&quot;&gt;'C'];&lt;br/&gt;arr.unshift(&lt;span class=&quot;hljs-string&quot;&gt;'D');&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(arr); &lt;span class=&quot;hljs-regexp&quot;&gt;//[ &lt;span class=&quot;hljs-string&quot;&gt;'D', &lt;span class=&quot;hljs-string&quot;&gt;'A', &lt;span class=&quot;hljs-string&quot;&gt;'B', &lt;span class=&quot;hljs-string&quot;&gt;'C']&lt;br/&gt;var rem = arr.pop();&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(arr);&lt;span class=&quot;hljs-regexp&quot;&gt;//[&lt;span class=&quot;hljs-string&quot;&gt;'D', &lt;span class=&quot;hljs-string&quot;&gt;'A', &lt;span class=&quot;hljs-string&quot;&gt;'B']&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;console.log(rem); &lt;span class=&quot;hljs-regexp&quot;&gt;// &lt;span class=&quot;hljs-string&quot;&gt;'C'&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h-4&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;「数组」在 Javascript 中是最为常见的引用类型的数据结构，其重要性是不言而喻的，因此「数组」也拥有比较多的方法，如果一个篇幅写下来会非常非常的长，这样不仅不利于阅读而且也非常考验读者对耐性，细水长流，所以我们分两篇文章去介绍，如果你对文章感兴趣，可以持续关注，如果喜欢呢，你也可以转发，点赞，对作者也是一种支持！&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 15:08:00 +0000</pubDate>
<dc:creator>Modenng</dc:creator>
<og:description>所谓数组（英语：Array），是有序的元素序列。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。 组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。 －－－百度百科</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/beevesnoodles/p/9623924.html</dc:identifier>
</item>
<item>
<title>Docker 基础 - Docker 遇见前端（二） - kelsen</title>
<link>http://www.cnblogs.com/kelsen/p/9608578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kelsen/p/9608578.html</guid>
<description>&lt;h2 id=&quot;一docker-系统架构&quot;&gt;一、Docker 系统架构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;守护进程&lt;/strong&gt;&lt;br/&gt;负责容器的创建、运行和监控，还负责镜像的构建和存储。&lt;code&gt;docker demon&lt;/code&gt; 命令可启动 Docker 守护进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker 客户端&lt;/strong&gt;&lt;br/&gt;通过http与 docker 守护进程通信。与docker守护进程通信的 API 有非常清晰的定义和文档，开发者也可以利用 API 直接和守护进程通信，而不通过 docker 客户端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Docker 镜像仓库&lt;/strong&gt;&lt;br/&gt;默认的寄存服务为 Docker Hub, 负责镜像的存储和发布。根据实际需要，我们也可以构建和运营自己的docker服务。&lt;/p&gt;
&lt;h3 id=&quot;底层技术&quot;&gt;底层技术&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;cgroups&lt;/strong&gt;&lt;br/&gt;负责管理容器使用的资源，如内存和CPU；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;namespaces&lt;/strong&gt;&lt;br/&gt;负责容器之间的隔离；确保系统的其他部分与容器的文件系统、主机名、用户、网络和进程都是分开的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UFS (union file system)&lt;/strong&gt;&lt;br/&gt;负责存储容器的镜像层。&lt;/p&gt;
&lt;h3 id=&quot;周边技术&quot;&gt;周边技术&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;swarm&lt;/strong&gt;&lt;br/&gt;docker 集群解决方案&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;compose&lt;/strong&gt;&lt;br/&gt;负责构建和运行多个docker容器所组成的应用程序的工具。主要用于开发和测试环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;machine&lt;/strong&gt;&lt;br/&gt;非Linux系统（Windows、MacOS）上的GUI，用于运行和管理docker容器；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker trusted registry&lt;/strong&gt;&lt;br/&gt;管理和存储docker镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络连接&lt;/strong&gt;&lt;br/&gt;overlay&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务发现&lt;/strong&gt;&lt;br/&gt;consul、skyDNS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务编排及集群管理&lt;/strong&gt;&lt;br/&gt;kubernetes,swarm等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专门用于托管容器的操作系统&lt;/strong&gt;&lt;br/&gt;虽然docker在大部分的Linux发行版本上 都运行的很好，但还是出现了一些新的发行版项目，他们只考虑需要运行容器的环境，希望做出体积小二容易管理的发行版，尤其是针对数据中心或集群的使用场景。&lt;/p&gt;
&lt;h2 id=&quot;二镜像是如何生成的&quot;&gt;二、镜像是如何生成的&lt;/h2&gt;
&lt;p&gt;创建镜像的主要方法是通过 &lt;code&gt;Dockerfile&lt;/code&gt; 和 &lt;code&gt;docker build&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;构建环境的上下文&quot;&gt;构建环境的上下文&lt;/h3&gt;
&lt;p&gt;命令 &lt;code&gt;docker build&lt;/code&gt;需要 &lt;code&gt;Dockerfile&lt;/code&gt;和&lt;code&gt;build context&lt;/code&gt;。 build context 是一组本地文件和目录，他可以被 Dockerfile 的 &lt;code&gt;ADD&lt;/code&gt; 和 &lt;code&gt;COPY&lt;/code&gt; 指令引用，通常以目录路径的形式指定。&lt;/p&gt;
&lt;p&gt;如果提供的URL以http开头，它会被假定位直接指向 dockerfile ，这样做没什么用，因为该 &lt;code&gt;Dockerfile&lt;/code&gt;没有与任何上下文关联。&lt;/p&gt;
&lt;p&gt;也可以将git仓库作为构建环境上下文。这种情况下，docker客户端会将Git仓库colone到本地，然后传递给守护进程作为构建环境上下文。&lt;/p&gt;
&lt;p&gt;还可以通过stdin输入构建环境的上下文，方法是在需要输入上下文的地方使用 &lt;code&gt;-&lt;/code&gt;参数。该输入可以是一个归档文件，支持 tar.gz / xz / bzip2 格式。&lt;/p&gt;
&lt;p&gt;从构建环境的上下文中排除不必要的文件，可以使用&lt;code&gt;.dockerignore&lt;/code&gt;文件，该文件类似 &lt;code&gt;.gitignore&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;镜像&quot;&gt;镜像&lt;/h3&gt;
&lt;p&gt;Dockerfile 中的每个指令执行后都会生成一个镜像层，这个镜像层可以用来启动容器。一个新的镜像层的建立，使用上一个镜像层启动容器，然后执行dockerfile中的指令，再把它保存为一个新镜像。&lt;/p&gt;
&lt;p&gt;当dockerfile 执行成功后，中间的那些容器会被删掉，除非提供 &lt;code&gt;--rm=false&lt;/code&gt; 参数。&lt;/p&gt;
&lt;p&gt;由于每个指令的最终结果都只是个静态的镜像，本质上是一个文件系统以及一些元数据，因此即使指令中的持久进程，最终都会被停掉。比如你在一条指令中开启一个数据库服务的进程，但到了下一条指令，或启动容器的时候，它就已经不存在了。&lt;/p&gt;
&lt;p&gt;如果你需要在启动容器的时候同事运行一个进程或服务，他必须从&lt;code&gt;ENTRYPOINT&lt;/code&gt; 或 &lt;code&gt;CMD&lt;/code&gt; 指令中启动。&lt;/p&gt;
&lt;p&gt;Docker 为了加快镜像构建的速度，会将每一个镜像层缓存下来。 Docker的缓存特性能大大提高工作效率。&lt;/p&gt;
&lt;h3 id=&quot;基础镜像&quot;&gt;基础镜像&lt;/h3&gt;
&lt;p&gt;基于镜像分层的特点，当我们需要一个环境时，无需重头开始去构建一个镜像。最理想的做法是完全不用创建镜像，直接使用某个现有的镜像，然后把配置文件和数据挂在上去即可。对于常用软件，比如数据库、web服务器，这是非常可行的。一般情况下使用官方镜像比自己创建一个镜像好得多，因为其他人已经找到使得该软件以最佳方式运行在容器中的方法。&lt;/p&gt;
&lt;p&gt;如果你需要使用一个基础镜像以运行应用程序，那么应该先检查一下，应用程序所使用的编程语言或框架是否已提供了官方的镜像。如果只是需要一个小而完整的Linux 发行版本，可以选择 &lt;code&gt;alpine&lt;/code&gt;,他的大小仅仅5MB多一点，但仍提供了一个包管理器，可以轻松安装大量应用和工具。&lt;/p&gt;
&lt;h3 id=&quot;dockerfile&quot;&gt;Dockerfile&lt;/h3&gt;
&lt;h4 id=&quot;exec-与-shell-的对比&quot;&gt;Exec 与 Shell 的对比&lt;/h4&gt;
&lt;p&gt;一些指令（&lt;code&gt;RUN&lt;/code&gt;、&lt;code&gt;CMD&lt;/code&gt;、&lt;code&gt;ENTRYPOINT&lt;/code&gt;）能够接受 shell 和 exec 这两种格式。exec 格式需要用到一个JSON数组，如：[&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]，其中第一个元素是可执行文件，其他元素是他执行时所使用的参数。shell格式使用的是自由形式的字符串，字符串会传给 &lt;code&gt;/bin/sh -c&lt;/code&gt; 执行。exec格式适用于需要规避 shell 对字符串做出错误解析的情况，或者当径向力没有包含 &lt;code&gt;/bin/sh&lt;/code&gt; 时。&lt;/p&gt;
&lt;h4 id=&quot;常用指令&quot;&gt;常用指令&lt;/h4&gt;
&lt;p&gt;这些指令在 docker 网站上都可以找到非常详细的说明文档，随着docker的持续发展，文档也会有调整，下列指令描述如果与官方文档不一致，请以官网文档为准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ADD&lt;/strong&gt;&lt;br/&gt;从构建环境上下文或远程URL将文件复制至镜像。如果是从一个本地路径添加一个压缩文件，他会被自动解压。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CMD&lt;/strong&gt;&lt;br/&gt;当容器启动执行时执行特定的指令。如果还定义了 ENTRYPOINT , 该指令将被解释为 ENTRYPOINT 的参数（这时候请确保使用的是 exec 格式）。CMD指令也会被 docker run 命令中镜像名称后面的参数覆盖。加入定义了多个CMD，只有最后一个会生效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;COPY&lt;/strong&gt;&lt;br/&gt;从构建环境上下文复制文件至镜像。它有两种形式，COPY src dest 或 COPY [&quot;SRC&quot;,&quot;DEST&quot;]，如果路径中有空格的话，必须使用第二种格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ENTRYPOINT&lt;/strong&gt;&lt;br/&gt;设置一个在容器启动时运行的可执行文件（以及默认参数）。任何CMD指令或docker run 命令中镜像名称之后的参数，将作为参数传递给这个可执行文件。 ENTRYPOINT 指令通常用于提供“启动”脚本，目的是在解析参数之前，对变量和服务进行初始化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ENV&lt;/strong&gt;&lt;br/&gt;设置镜像内的环境变量。这些变量可以被随后的指令应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EXPOSE&lt;/strong&gt;&lt;br/&gt;向 Docker 表示该容器将会有一个进程监听所指定的端口。提供这个信息的目的是用于连接容器或在执行 docker run 命令式通过 -p 参数把端口发布出来； EXPOSE 本身不会对网络有实质性的改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FROM&lt;/strong&gt;&lt;br/&gt;设置 Dockerfile 使用的基础镜像；随后的指令将基于该镜像之上。 FROM 必须为 Dockerfile 的第一条指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAINTAINER&lt;/strong&gt;&lt;br/&gt;设置镜像维护者的姓名和联系方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ONBUILD&lt;/strong&gt;&lt;br/&gt;指定当镜像被用作另一个镜像的基础镜像时将会执行的指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RUN&lt;/strong&gt;&lt;br/&gt;在容器内执行指定的指令，并把结果保存下来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;USER&lt;/strong&gt;&lt;br/&gt;设置任何后续的RUN、CMD或ENTRYPOINT指令执行时所用的用户（用户名或UID）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;VOLUME&lt;/strong&gt;　&lt;br/&gt;指定为数据卷的文件或目录。如果该文件或目录已经在镜像中存在，那么当容器启动时，他就会被复制到这个卷。如果提供了多个参数，那么就将被解释成多个数据卷。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WORKDIR&lt;/strong&gt;&lt;br/&gt;对任何后续的 RUN、CMD、ENTRYPOINT、ADD、COPY指令设置的工作目录。这个指令可多次使用。&lt;/p&gt;
&lt;h2 id=&quot;三外部可访问-端口转发&quot;&gt;三、外部可访问 &amp;amp;&amp;amp; 端口转发&lt;/h2&gt;
&lt;p&gt;假设你在容器中运行一个 Nginx web服务器，你如何使外界可以访问他呢？通过 &lt;code&gt;-p&lt;/code&gt; 或 &lt;code&gt;-P&lt;/code&gt; 选项来发布端口。比如：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$docker run -d -p 8000:80 nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;容器启动后，我们可以通过 &lt;code&gt;localhost:8000&lt;/code&gt; 访问到容器内的 web 服务。其中 &lt;code&gt;-p 8000:80&lt;/code&gt; 参数告诉 docker 将主机的 8000 端口转发到容器的 80 端口。或者可以使用 &lt;code&gt;-P&lt;/code&gt; 参数来告诉 Docker 自动选择一个主机上未使用的端口。&lt;/p&gt;
&lt;h2 id=&quot;四数据卷-数据容器&quot;&gt;四、数据卷 &amp;amp;&amp;amp; 数据容器&lt;/h2&gt;
&lt;p&gt;数据卷，是一个目录，但并不属于UFS的一部分，它只是在主机上被绑定挂在到容器的一个普通目录。有三种方式可以挂载数据卷：&lt;/p&gt;
&lt;p&gt;执行 Docker 时，通过 &lt;code&gt;-v&lt;/code&gt; 选项来指定数据卷&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it --name test -v /data debian /bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 Dockerfile 的 VOLUME 命令&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;FROM debian
VOLUME /data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定数据卷要绑定的主机目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -v /home/data:/data debian ls /data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子把主机的 /home/data 目录绑定到容器的 /data 目录，容器能够使用主机 /home/data 目录下的文件。&lt;/p&gt;
&lt;p&gt;在执行 docker run 命令时，我们通过传入 &lt;code&gt;--volumes-from container&lt;/code&gt; 参数可以实现容器间的数据共享。一个常用的做法是，创建数据容器，这种容器的唯一目的就是与其他容器分享数据。&lt;/p&gt;
&lt;h2 id=&quot;五docker-常用命令&quot;&gt;五、Docker 常用命令&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;docker build&lt;/strong&gt; 从dockerfile构建镜像。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker images&lt;/strong&gt; 列出所有本地镜像。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker run&lt;/strong&gt; 这是一个相对复杂的命令，支持非常多参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker attach&lt;/strong&gt; 查看容器内主进程，并与之交互&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker create&lt;/strong&gt; 创建容器但不启动运行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker exec&lt;/strong&gt; 在同期中运行一个命令&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;docker rm&lt;/strong&gt; 删除一个或多个容器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实经常用到的命令还有很多，可以在 &lt;code&gt;http://docs.docker.com&lt;/code&gt; 查阅完整的释义，也可以在命令行通过 &lt;code&gt;--help&lt;/code&gt;参数查看具体使用说明。&lt;/p&gt;
&lt;h2 id=&quot;写在后面&quot;&gt;写在后面&lt;/h2&gt;
&lt;p&gt;本文地址：&lt;a href=&quot;https://www.cnblogs.com/kelsen/p/9608578.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/kelsen/p/9608578.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于本文如果您有任何建议或疑问请在下面留言交流，也可通过 &lt;a href=&quot;http://jq.qq.com/?_wv=1027&amp;amp;k=eNlNes&quot;&gt;Web前端高级工程师&lt;/a&gt; 群进行线上沟通。&lt;a href=&quot;http://jq.qq.com/?_wv=1027&amp;amp;k=eNlNes&quot;&gt;&lt;img src=&quot;http://pub.idqqimg.com/wpa/images/group.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 15:03:00 +0000</pubDate>
<dc:creator>kelsen</dc:creator>
<og:description>Docker 相关的基础知识点非常多，比如基本概念，镜像管理，数据卷（容器）管理，常用命令，周边生态等等。在这里梳理出个大概框架，方便后续学习使用。《Docker 遇见前端》系列文章，旨在分享学习如何</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kelsen/p/9608578.html</dc:identifier>
</item>
<item>
<title>论文阅读 | Clustrophile 2: Guided Visual Clustering Analysis - basasuya</title>
<link>http://www.cnblogs.com/Basasuya/p/9623270.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Basasuya/p/9623270.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.mastercava.it/publications/2018_Cavallo_VIS.pdf&quot;&gt;论文地址&lt;/a&gt; &lt;a href=&quot;https://www.youtube.com/watch?v=UJzgrG1KMMI&quot;&gt;论文视频&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201809/1324872-20180910213143132-1936456659.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;左侧边栏可以导入数据，或者打开以及前保存的结果。右侧显示了所有的日志，可以轻松回到之前的状态，视图的主区域上半部分是数据，下半部分是聚类视图。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;introduction&quot;&gt;INTRODUCTION&lt;/h3&gt;
&lt;p&gt;数据聚类对于处理无标签数据，高维数据是非常有效的工具。聚类算法中如何确定最好的聚类方法和参数比较困难，需要可视化系统的帮助。Clustrophile 2，这是一种用于引导聚类分析的新型交互式工具，引导用户进行基于聚类的探索性分析，调整用户反馈以改进聚类效果，并帮助快速推理群集之间的差异。为此，Clustrophile 2提供了一个新颖的功能，clustering tour，帮助用户选择聚类参数，并评估与当前分析目标和用户期望的差距。我们通过12位数据科学家的user study评估这个系统。结果表明，Clustrophile 2提高了专家和非专家的探索性聚类分析的速度和有效性。&lt;/p&gt;
&lt;h3 id=&quot;design-criteria&quot;&gt;DESIGN CRITERIA&lt;/h3&gt;
&lt;p&gt;Clustrophile 2总结了9个设计标准：&lt;/p&gt;
&lt;p&gt;Show variation within clusters(快速显示聚类效果)，Allow quick iteration over parameters （实时更新参数），Represent clustering instances compactly（多视图显示），Facilitate interpretable naming（数据簇重命名和分离），Support analysis of large datasets（大型数据支持），Support reasoning about clusters and clustering instances（支持对于聚类结果的推断和评估），Promote multiscale exploration（多尺度探索聚类），Keep a stateful representation of the current analysis（保存当前探索状态），Guide users in clustering analysis（指导用户聚类分析）。&lt;/p&gt;
&lt;p&gt;论文中作者这样描述本文的贡献：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在Clustrophile系统的基础上，增加丰富的聚类算法，参数，评估指标以及可视化工具。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;开发出引导用户进行聚类分析的一体化程序，Clustering Tour。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定义了更合理的聚类质量衡量指标，考虑了用户反馈，可解释性等方面&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;user-interface-and-interactions&quot;&gt;USER INTERFACE AND INTERACTIONS&lt;/h3&gt;
&lt;p&gt;可视化系统的主视图包括，聚类视图，调参推荐界面，聚类之旅(clusting tour) 三个部分&lt;/p&gt;
&lt;h5 id=&quot;visualization-views&quot;&gt;Visualization Views&lt;/h5&gt;
&lt;p&gt;在聚类视图中，散点图显示了数据降维后投影在2D平面上的数据聚类结果，其中距离编码数据点之间的相似性，而右侧的热力图中每列代表一个聚类，而行代表了不同的特征，颜色深浅代表了数据的相对大小。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201809/1324872-20180910213214024-1682076919.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，我们还可以通过观察数据表的界面对于数据进行观察和筛选&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201809/1324872-20180910213229048-1109307792.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;choosing-parameters-and-guiding-users-towards-a-better-clustering&quot;&gt;Choosing Parameters and Guiding Users Towards a Better Clustering&lt;/h5&gt;
&lt;p&gt;Clustrophile 2在调参与算法推荐的功能详尽，并提供了完备的聚类效果衡量标准：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Clustrophile2支持自动调参，删除具有低方差的特征，支持自定义采样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;根据数据特征推荐合适的聚类算法，根据分层聚类的树形图推荐合适的集群数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;将不同的投影方式进行比较，推荐能将聚类紧凑性和分离性尽量满足的投影(降维)算法。&lt;/li&gt;
&lt;li&gt;从偏斜分布程度，子簇密度，算法对噪声的鲁棒性，cost function的单调性等方面定量的衡量聚类结果&lt;/li&gt;
&lt;li&gt;通过将聚类结果放入决策树进行训练，这样可以推断不同集群中的数据点的主要特征&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持分析聚类分布中的异常点，删除它们后重新聚类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201809/1324872-20180910213301864-518874698.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;clustering-tour&quot;&gt;Clustering Tour&lt;/h5&gt;
&lt;p&gt;通过迭代地改变所有聚类参数，用户可以动态地探索可能的聚类解决方案的空间，直到找到满意的解决方案或数据集。但是，即使在参数选择的指导下，可能的参数组合和聚类解决方案的空间太大，无法完全手动探索。某些参数选择在很大程度上影响聚类结果，而其他参数对结果的影响最小。考虑到这一概念，我们引入了聚类游览功能，以帮助用户快速探索可能的聚类结果空间。下面的界面包含（a）先前探索的解决方案列表，（b，c）散点图和热图可视化当前的方案，（e）用户提供反馈的一组按钮，喜欢还是拒绝，（d）用户可以约束参数更新方式的模态选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201809/1324872-20180910213313747-57316014.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个类似模拟退火的过程。系统首先会按照每种聚类的相似性，找出差距较大的几种聚类结果。用户依次浏览这些解决方案，如果喜欢这个方案，系统会在这个方案基础上进行轻微的参数改动，相当于进入了一个叶子节点。如果不满意就会退回到父亲。直到探索时间和方案数等达到一个阖值为止。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201809/1324872-20180910213323968-362982727.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;user-study&quot;&gt;USER STUDY&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;实验对象，12位数据科学从业者&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;实验目标：：1）了解数据科学家如何根据数据领域的先验知识进行交互 2）如何在开放式分析任务中找到了令人满意的解决方案&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;实验数据：患有帕金森病的受试者数据集，该数据集具有8652行和37个特征&lt;/li&gt;
&lt;li&gt;实验任务：识别代表帕金森病的不同类型。我们要求参与者确定他们满意的一个聚类实例，为每个聚类分配名称和描述，最后口头解释他们获得这个结果的重要性。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们将候选人分为三类：黑客，脚本编写者和应用程序用户。每种4人，并且每个人中有2个人了解医学知识。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201809/1324872-20180910213404237-696846671.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1324872/201809/1324872-20180910213429852-1887244813.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从实验结果，我们证明Clustrophile 2证明不同类型的数据分析师。十二个用户中的三个（其中两个属于应用程序用户原型）倾向于使用ClusterCour来进行分析。最后，分析继续对聚类参数和所选特征进行迭代和循环修改，直到参与者意识到他们只能找到聚类基于受影响的一方或疾病严重程度的结果。这些聚类很容易从热图可视化中解释，热图可视化显然可以提供非常有效的信息。&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;CONCLUSION&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调参和算法选择是非常重要的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Clustering Tour 提高了用户自主性和创造力&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用户对结果的反馈加快了探索过程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;管理，缓存数据和过程方便了用户的探索&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外还有一些可以改进的点&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;增加可解释性的聚类研究&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;增加更多预计算与推荐功能&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;增加对于任意聚类算法接口的支持，增加代码接口，让用户可以在框架进行拓展&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 10 Sep 2018 13:35:00 +0000</pubDate>
<dc:creator>basasuya</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Basasuya/p/9623270.html</dc:identifier>
</item>
<item>
<title>深入学习卷积神经网络中卷积层和池化层的意义 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/9593364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/9593364.html</guid>
<description>&lt;h2&gt;为什么要使用卷积呢？&lt;/h2&gt;
&lt;p&gt;　　在传统的神经网络中，比如多层感知机（MLP），其输入通常是一个特征向量，需要人工设计特征，然后将这些特征计算的值组成特征向量，在过去几十年的经验来看，人工找到的特征并不是怎么好用，有时多了，有时少了，有时选择的特征根本就不起作用（真正起作用的特征在浩瀚的未知里面）。这就是为什么在过去卷积神经网络一直被SVM等完虐的原因。&lt;/p&gt;
&lt;p&gt;　　如果有人说，任何特征都是从图像中提取的，那如果把整副图像作为特征来训练神经网络不就行了，那肯定不会有任何信息丢失！那先不说一幅图像有多少冗余信息，单说着信息量就超级多。。。&lt;/p&gt;
&lt;p&gt;　　假如有一幅1000*1000的图像，如果把整幅图像作为向量，则向量的长度为1000000（10^6）。在假如隐含层神经元的个数和输入一样，也是1000000；那么，输入层到隐含层的参数数据量有10^12，妈呀，什么样的机器能训练这样的网络呢。所以，我们还得降低维数，同时得以整幅图像为输入（人类实在找不到好的特征了）。于是，牛逼的卷积来了。接下来看看卷积都干了些啥。&lt;/p&gt;
&lt;h2&gt;CNN卷积神经网络层级结构&lt;/h2&gt;
&lt;p&gt;CNN网络一共有5个层级结构：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;输入层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;卷积层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;激活层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;池化层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全连接FC层&lt;/strong&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h3&gt;1 输入层&lt;/h3&gt;
&lt;p&gt;与传统神经网络/机器学习一样，模型需要输入的进行预处理操作，常见的输入层中预处理方式有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;去均值&lt;/li&gt;
&lt;li&gt;归一化&lt;/li&gt;
&lt;li&gt;PCA/SVD降维等&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;卷积层&quot;&gt;2  卷积层&lt;/h3&gt;
&lt;p&gt;       &lt;strong&gt;局部感知&lt;/strong&gt;：人的大脑识别图片的过程中，并不是一下子整张图同时识别，而是对于图片中的每一个特征首先局部感知，然后更高层次对局部进行综合操作，从而得到全局信息。 （后面详解）&lt;/p&gt;
&lt;h3 id=&quot;激励层&quot;&gt;3  激励层&lt;/h3&gt;
&lt;p&gt;　　所谓&lt;strong&gt;激励&lt;/strong&gt;，实际上是对卷积层的输出结果做一次非线性映射。 &lt;br/&gt;　　如果不用激励函数（其实就相当于激励函数是f(x)=x），这种情况下，每一层的输出都是上一层输入的线性函数。容易得出，无论有多少神经网络层，输出都是输入的线性组合，与没有隐层的效果是一样的，这就是最原始的&lt;strong&gt;感知机&lt;/strong&gt;了。 &lt;br/&gt;常用的激励函数有：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Sigmoid函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Tanh函数&lt;/li&gt;
&lt;li&gt;ReLU&lt;/li&gt;
&lt;li&gt;Leaky ReLU&lt;/li&gt;
&lt;li&gt;ELU&lt;/li&gt;
&lt;li&gt;Maxout&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;　　激励层建议：首先ReLU，因为迭代速度快，但是有可能效果不加。如果ReLU失效的情况下，考虑使用Leaky ReLU或者Maxout，此时一般情况都可以解决。Tanh函数在文本和音频处理有比较好的效果。&lt;/p&gt;
&lt;h3 id=&quot;池化层&quot;&gt;4  池化层&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　池化&lt;/strong&gt;（Pooling）：也称为&lt;strong&gt;欠采样&lt;/strong&gt;或&lt;strong&gt;下采样&lt;/strong&gt;。主要用于特征降维，压缩数据和参数的数量，减小过拟合，同时提高模型的容错性。主要有：&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;Max Pooling：最大池化&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;Average Pooling：平均池化 &lt;br/&gt;&lt;div align=&quot;center&quot; readability=&quot;7&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201809/1226410-20180910194605414-874059268.png&quot; alt=&quot;&quot; width=&quot;597&quot; height=&quot;238&quot;/&gt;&lt;br/&gt;通过池化层，使得原本4*4的特征图压缩成了2*2，从而降低了特征维度。&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201809/1226410-20180910192623526-669462485.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;286&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　虽然人不太容易分辨出池化后的特征图，但是没关系，机器还是可以识别的。&lt;/p&gt;
&lt;h3 id=&quot;输出层&quot;&gt;5  输出层（全连接层）&lt;/h3&gt;
&lt;p&gt;　　经过前面若干次卷积+激励+池化后，终于来到了输出层，模型会将学到的一个高质量的特征图片全连接层。其实在全连接层之前，如果神经元数目过大，学习能力强，有可能出现过拟合。因此，可以引入dropout操作，来随机删除神经网络中的部分神经元，来解决此问题。还可以进行&lt;strong&gt;局部归一化&lt;/strong&gt;（LRN）、数据增强等操作，来增加鲁棒性。 &lt;br/&gt;　　当来到了全连接层之后，可以理解为一个简单的多分类神经网络（如：BP神经网络），通过softmax函数得到最终的输出。整个模型训练完毕。 &lt;br/&gt;　　两层之间所有神经元都有权重连接，通常全连接层在卷积神经网络尾部。也就是跟传统的神经网络神经元的连接方式是一样的： &lt;/p&gt;
&lt;div align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201809/1226410-20180910194649765-666983892.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;264&quot;/&gt;
&lt;/div&gt;
&lt;h2&gt;CNN卷积神经网络卷积层和池化层详解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　卷积神经网络&lt;/strong&gt;（Convolutional Neural Network，简称CNN），是一种前馈神经网络，人工神经元可以响应周围单元，可以进行大型图像处理。卷积神经网络包括卷积层和池化层。 &lt;br/&gt;       卷积神经网络是受到生物思考方式启发的MLPs（多层感知器），它有着不同的类别层次，并且各层的工作方式和作用也不同。这里提供一个较好的CNN教程（&lt;a href=&quot;http://cs231n.github.io/convolutional-networks/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://cs231n.github.io/convolutional-networks/&lt;/a&gt;）。文章中详细介绍了CNN的计算方式和数据的流动过程，这里只做简单的介绍。&lt;/p&gt;
&lt;p&gt;       卷积神经网络是人工神经网络的一种，已成为当前语音分析和图像识别领域的研究热点。它的权值共享网络结构使之更类似于生物神经网络，降低了网络模型的复杂度，减少了权值的数量。该优点在网络的输入是多维图像时表现的更为明显，使图像可以直接作为网络的输入，避免了传统识别算法中复杂的特征提取和数据重建过程。卷积网络是为识别二维形状而特殊设计的一个多层感知器，这种网络结构对平移、比例缩放、倾斜或者共他形式的变形具有高度不变性。&lt;/p&gt;
&lt;p&gt;       CNNs是受早期的延时神经网络（TDNN）的影响。延时神经网络通过在时间维度上共享权值降低学习复杂度，适用于语音和时间序列信号的处理。&lt;/p&gt;
&lt;p&gt;       CNNs是第一个真正成功训练多层网络结构的学习算法。它利用空间关系减少需要学习的参数数目以提高一般前向BP算法的训练性能。CNNs作为一个深度学习架构提出是为了最小化数据的预处理要求。在CNN中，图像的一小部分（局部感受区域）作为层级结构的最低层的输入，信息再依次传输到不同的层，每层通过一个数字滤波器去获得观测数据的最显著的特征。这个方法能够获取对平移、缩放和旋转不变的观测数据的显著特征，因为图像的局部感受区域允许神经元或者处理单元可以访问到最基础的特征，例如定向边缘或者角点。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;（1）卷积神经网络的历史&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;       1962年Hubel和Wiesel通过对猫视觉皮层细胞的研究，提出了感受野(receptive field)的概念，1984年日本学者Fukushima基于感受野概念提出的神经认知机(neocognitron)可以看作是卷积神经网络的第一个实现网络，也是感受野概念在人工神经网络领域的首次应用。神经认知机将一个视觉模式分解成许多子模式（特征），然后进入分层递阶式相连的特征平面进行处理，它试图将视觉系统模型化，使其能够在即使物体有位移或轻微变形的时候，也能完成识别。&lt;/p&gt;
&lt;p&gt;       通常神经认知机包含两类神经元，即承担特征抽取的S-元和抗变形的C-元。S-元中涉及两个重要参数，即感受野与阈值参数，前者确定输入连接的数目，后者则控制对特征子模式的反应程度。许多学者一直致力于提高神经认知机的性能的研究：在传统的神经认知机中，每个S-元的感光区中由C-元带来的视觉模糊量呈正态分布。如果感光区的边缘所产生的模糊效果要比中央来得大，S-元将会接受这种非正态模糊所导致的更大的变形容忍性。我们希望得到的是，训练模式与变形刺激模式在感受野的边缘与其中心所产生的效果之间的差异变得越来越大。为了有效地形成这种非正态模糊，Fukushima提出了带双C-元层的改进型神经认知机。&lt;/p&gt;
&lt;p&gt;       Van Ooyen和Niehuis为提高神经认知机的区别能力引入了一个新的参数。事实上，该参数作为一种抑制信号，抑制了神经元对重复激励特征的激励。多数神经网络在权值中记忆训练信息。根据Hebb学习规则，某种特征训练的次数越多，在以后的识别过程中就越容易被检测。也有学者将进化计算理论与神经认知机结合，通过减弱对重复性激励特征的训练学习，而使得网络注意那些不同的特征以助于提高区分能力。上述都是神经认知机的发展过程，而卷积神经网络可看作是神经认知机的推广形式，神经认知机是卷积神经网络的一种特例。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;（2）卷积神经网络的网络结构&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　先介绍卷积层遇到的几个名词：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       • 深度/depth（解释见下图）&lt;br/&gt;　　• 步长/stride （窗口一次滑动的长度）&lt;br/&gt;　　• 填充值/zero-padding&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201809/1226410-20180910194917186-1403911233.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;329&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　填充值是什么呢？以下图为例子，比如有这么一个5*5的图片（一个格子一个像素），我们滑动窗口取2*2，步长取2，那么我们发现还剩下1个像素没法滑完，那怎么办呢？&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1093303/201704/1093303-20170430194452615-1175169258.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;&lt;p&gt;　　那我们在原先的矩阵加了一层填充值，使得变成6*6的矩阵，那么窗口就可以刚好把所有像素遍历完。这就是填充值的作用。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1093303/201704/1093303-20170430194526537-1629104898.png&quot; alt=&quot;&quot; width=&quot;377&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      卷积神经网络是一个多层的神经网络，每层由多个二维平面组成，而每个平面由多个独立神经元组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226410/201809/1226410-20180910191025559-865156930.png&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如图所示，CNN网络工作时，会伴随着卷积并且不断转换着这些卷积。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.my.csdn.net/uploads/201304/10/1365562094_2229.jpg&quot; alt=&quot;&quot; width=&quot;588&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       图1：卷积神经网络的概念示范&lt;/p&gt;
&lt;p&gt;　　输入图像通过和三个可训练的滤波器和可加偏置进行卷积，滤波过程如图一，卷积后在C1层产生三个特征映射图，然后特征映射图中每组的四个像素再进行求和，加权值，加偏置。通过一个Sigmoid函数得到三个S2层的特征映射图。这些映射图再进过滤波得到C3层。这个层级结构再和S2一样产生S4。最终，这些像素值被光栅化，并连接成一个向量输入到传统的神经网络，得到输出。&lt;/p&gt;
&lt;p&gt;       一般地，C层为特征提取层，每个神经元的输入与前一层的局部感受野相连，并提取该局部的特征，一旦该局部特征被提取后，它与其他特征间的位置关系也随之确定下来；S层是特征映射层，网络的每个计算层由多个特征映射组成，每个特征映射为一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。&lt;/p&gt;
&lt;p&gt;       此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数，降低了网络参数选择的复杂度。卷积神经网络中的每一个特征提取层（C-层）都紧跟着一个用来求局部平均与二次提取的计算层（S-层），这种特有的两次特征提取结构使网络在识别时对输入样本有较高的畸变容忍能力。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;（3）关于参数减少与权值共享&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;      上面聊到，好像CNN一个厉害的地方就在于通过感受野和权值共享减少了神经网络需要训练的参数的个数。那究竟是啥的呢？&lt;/p&gt;
&lt;p&gt;　　卷积神经网络有两种神器可以降低参数数目，第一种神器叫做局部感知野。一般认为人对外界的认知是从局部到全局的，而图像的空间联系也是局部的像素联系较为紧密，而距离较远的像素相关性则较弱。因而，每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知，然后在更高层将局部的信息综合起来就得到了全局的信息。网络部分连通的思想，也是受启发于生物学里面的视觉系统结构。视觉皮层的神经元就是局部接受信息的（即这些神经元只响应某些特定区域的刺激）&lt;/p&gt;
&lt;h4&gt;局部感知&lt;/h4&gt;
&lt;p&gt;       下图左：如果我们有1000x1000像素的图像，有1百万个隐层神经元，那么他们全连接的话（每个隐层神经元都连接图像的每一个像素点），就有1000x1000x1000000=10^12个连接，也就是10^12个权值参数。然而图像的空间联系是局部的，就像人是通过一个局部的感受野去感受外界图像一样，每一个神经元都不需要对全局图像做感受，每个神经元只感受局部的图像区域，然后在更高层，将这些感受不同局部的神经元综合起来就可以得到全局的信息了。这样，我们就可以减少连接的数目，也就是减少神经网络需要训练的权值参数的个数了。如下图右：假如局部感受野是10x10，隐层每个感受野只需要和这10x10的局部图像相连接，所以1百万个隐层神经元就只有一亿个连接，即10^8个参数。比原来减少了四个0（数量级），这样训练起来就没那么费力了，但还是感觉很多的啊，那还有啥办法没？&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://img.my.csdn.net/uploads/201304/10/1365562155_9356.jpg&quot; alt=&quot;&quot; width=&quot;563&quot; height=&quot;210&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       我们知道，隐含层的每一个神经元都连接10x10个图像区域，也就是说每一个神经元存在10x10=100个连接权值参数。那如果我们每个神经元这100个参数是相同的呢？也就是说每个神经元用的是同一个卷积核去卷积图像。这样我们就只有多少个参数？？只有100个参数啊！！！亲！不管你隐层的神经元个数有多少，两层间的连接我只有100个参数啊！亲！这就是权值共享啊！亲！这就是卷积神经网络的主打卖点啊！亲！（有点烦了，呵呵）也许你会问，这样做靠谱吗？为什么可行呢？这个……共同学习。&lt;/p&gt;
&lt;p&gt;       好了，你就会想，这样提取特征也忒不靠谱吧，这样你只提取了一种特征啊？对了，真聪明，我们需要提取多种特征对不？假如一种滤波器，也就是一种卷积核就是提出图像的一种特征，例如某个方向的边缘。那么我们需要提取不同的特征，怎么办，加多几种滤波器不就行了吗？对了。所以假设我们加到100种滤波器，每种滤波器的参数不一样，表示它提出输入图像的不同特征，例如不同的边缘。这样每种滤波器去卷积图像就得到对图像的不同特征的放映，我们称之为Feature Map。所以100种卷积核就有100个Feature Map。这100个Feature Map就组成了一层神经元。到这个时候明了了吧。我们这一层有多少个参数了？100种卷积核x每种卷积核共享100个参数=100x100=10K，也就是1万个参数。才1万个参数啊！亲！（又来了，受不了了！）见下图右：不同的颜色表达不同的滤波器。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://img.my.csdn.net/uploads/201304/10/1365562217_2880.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       嘿哟，遗漏一个问题了。刚才说隐层的参数个数和隐层的神经元个数无关，只和滤波器的大小和滤波器种类的多少有关。那么隐层的神经元个数怎么确定呢？它和原图像，也就是输入的大小（神经元个数）、滤波器的大小和滤波器在图像中的滑动步长都有关！例如，我的图像是1000x1000像素，而滤波器大小是10x10，假设滤波器没有重叠，也就是步长为10，这样隐层的神经元个数就是(1000x1000 )/ (10x10)=100x100个神经元了，假设步长是8，也就是卷积核会重叠两个像素，那么……我就不算了，思想懂了就好。注意了，这只是一种滤波器，也就是一个Feature Map的神经元个数哦，如果100个Feature Map就是100倍了。由此可见，图像越大，神经元个数和需要训练的权值参数个数的贫富差距就越大。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://img.my.csdn.net/uploads/201304/10/1365562245_8389.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      需要注意的一点是，上面的讨论都没有考虑每个神经元的偏置部分。所以权值个数需要加1 。这个也是同一种滤波器共享的。&lt;/p&gt;
&lt;p&gt;      总之，卷积网络的核心思想是将：局部感受野、权值共享（或者权值复制）以及时间或空间亚采样这三种结构思想结合起来获得了某种程度的位移、尺度、形变不变性。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4）一个典型的例子说明&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;       一种典型的用来识别数字的卷积网络是LeNet-5（&lt;a href=&quot;http://yann.lecun.com/exdb/lenet/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;效果和paper等见这&lt;/a&gt;）。当年美国大多数银行就是用它来识别支票上面的手写数字的。能够达到这种商用的地步，它的准确性可想而知。毕竟目前学术界和工业界的结合是最受争议的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.my.csdn.net/uploads/201304/10/1365562301_9590.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      那下面咱们也用这个例子来说明下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.my.csdn.net/uploads/201304/10/1365562321_2400.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        LeNet-5共有7层，不包含输入，每层都包含可训练参数（连接权重）。输入图像为32*32大小。这要比&lt;a href=&quot;http://yann.lecun.com/exdb/mnist/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Mnist数据库&lt;/a&gt;（一个公认的手写数据库）中最大的字母还大。这样做的原因是希望潜在的明显特征如笔画断电或角点能够出现在最高层特征监测子感受野的中心。&lt;/p&gt;
&lt;p&gt;        我们先要明确一点：每个层有多个Feature Map，每个Feature Map通过一种卷积滤波器提取输入的一种特征，然后每个Feature Map有多个神经元。&lt;/p&gt;
&lt;p&gt;        C1层是一个卷积层（为什么是卷积？卷积运算一个重要的特点就是，通过卷积运算，可以使原信号特征增强，并且降低噪音），由6个特征图Feature Map构成。特征图中每个神经元与输入中5*5的邻域相连。特征图的大小为28*28，这样能防止输入的连接掉到边界之外（是为了BP反馈时的计算，不致梯度损失，个人见解）。C1有156个可训练参数（每个滤波器5*5=25个unit参数和一个bias参数，一共6个滤波器，共(5*5+1)*6=156个参数），共156*(28*28)=122,304个连接。&lt;/p&gt;
&lt;p&gt;       S2层是一个下采样层（为什么是下采样？利用图像局部相关性的原理，对图像进行子抽样，可以减少数据处理量同时保留有用信息），有6个14*14的特征图。特征图中的每个单元与C1中相对应特征图的2*2邻域相连接。S2层每个单元的4个输入相加，乘以一个可训练参数，再加上一个可训练偏置。结果通过sigmoid函数计算。可训练系数和偏置控制着sigmoid函数的非线性程度。如果系数比较小，那么运算近似于线性运算，亚采样相当于模糊图像。如果系数比较大，根据偏置的大小亚采样可以被看成是有噪声的“或”运算或者有噪声的“与”运算。每个单元的2*2感受野并不重叠，因此S2中每个特征图的大小是C1中特征图大小的1/4（行和列各1/2）。有6个14*14的特征图。特征图中的每个单元与C1中相对应特征图的2*2邻域相连接。S2层每个单元的4个输入相加，乘以一个可训练参数，再加上一个可训练偏置。每个单元的2*2感受野并不重叠，因此S2中每个特征图的大小是C1中特征图大小的1/4（行和列各1/2）。S2层有12（6*（1+1）=12）个可训练参数和5880（14*14*（2*2+1）*6=5880）个连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.my.csdn.net/uploads/201304/10/1365562371_3221.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图：卷积和子采样过程：卷积过程包括：用一个可训练的滤波器f&lt;sub&gt;x&lt;/sub&gt;去卷积一个输入的图像（第一阶段是输入的图像，后面的阶段就是卷积特征map了），然后加一个偏置b&lt;sub&gt;x&lt;/sub&gt;，得到卷积层C&lt;sub&gt;x&lt;/sub&gt;。子采样过程包括：每邻域四个像素求和变为一个像素，然后通过标量W&lt;sub&gt;x+1&lt;/sub&gt;加权，再增加偏置b&lt;sub&gt;x+1&lt;/sub&gt;，然后通过一个sigmoid激活函数，产生一个大概缩小四倍的特征映射图S&lt;sub&gt;x+1&lt;/sub&gt;。&lt;/p&gt;
&lt;p&gt;       所以从一个平面到下一个平面的映射可以看作是作卷积运算，S-层可看作是模糊滤波器，起到二次特征提取的作用。隐层与隐层之间空间分辨率递减，而每层所含的平面数递增，这样可用于检测更多的特征信息。&lt;/p&gt;
&lt;p&gt;       C3层也是一个卷积层，它同样通过5x5的卷积核去卷积层S2，然后得到的特征map就只有10x10个神经元，但是它有16种不同的卷积核，所以就存在16个特征map了。这里需要注意的一点是：C3中的每个特征map是连接到S2中的所有6个或者几个特征map的，表示本层的特征map是上一层提取到的特征map的不同组合（这个做法也并不是唯一的）。（看到没有，这里是组合，就像之前聊到的人的视觉系统一样，底层的结构构成上层更抽象的结构，例如边缘构成形状或者目标的部分）。&lt;/p&gt;
&lt;p&gt;       刚才说C3中每个特征图由S2中所有6个或者几个特征map组合而成。为什么不把S2中的每个特征图连接到每个C3的特征图呢？原因有2点。第一，不完全的连接机制将连接的数量保持在合理的范围内。第二，也是最重要的，其破坏了网络的对称性。由于不同的特征图有不同的输入，所以迫使他们抽取不同的特征（希望是互补的）。&lt;/p&gt;
&lt;p&gt;      例如，存在的一个方式是：C3的前6个特征图以S2中3个相邻的特征图子集为输入。接下来6个特征图以S2中4个相邻特征图子集为输入。然后的3个以不相邻的4个特征图子集为输入。最后一个将S2中所有特征图为输入。这样C3层有1516个可训练参数和151600个连接。&lt;/p&gt;
&lt;p&gt;       S4层是一个下采样层，由16个5*5大小的特征图构成。特征图中的每个单元与C3中相应特征图的2*2邻域相连接，跟C1和S2之间的连接一样。S4层有32个可训练参数（每个特征图1个因子和一个偏置）和2000个连接。&lt;/p&gt;
&lt;p&gt;       C5层是一个卷积层，有120个特征图。每个单元与S4层的全部16个单元的5*5邻域相连。由于S4层特征图的大小也为5*5（同滤波器一样），故C5特征图的大小为1*1：这构成了S4和C5之间的全连接。之所以仍将C5标示为卷积层而非全相联层，是因为如果LeNet-5的输入变大，而其他的保持不变，那么此时特征图的维数就会比1*1大。C5层有48120个可训练连接。&lt;/p&gt;
&lt;p&gt;        F6层有84个单元（之所以选这个数字的原因来自于输出层的设计），与C5层全相连。有10164个可训练参数。如同经典神经网络，F6层计算输入向量和权重向量之间的点积，再加上一个偏置。然后将其传递给sigmoid函数产生单元i的一个状态。&lt;/p&gt;
&lt;p&gt;      最后，输出层由欧式径向基函数（Euclidean Radial Basis Function）单元组成，每类一个单元，每个有84个输入。换句话说，每个输出RBF单元计算输入向量和参数向量之间的欧式距离。输入离参数向量越远，RBF输出的越大。一个RBF输出可以被理解为衡量输入模式和与RBF相关联类的一个模型的匹配程度的惩罚项。用概率术语来说，RBF输出可以被理解为F6层配置空间的高斯分布的负log-likelihood。给定一个输入模式，损失函数应能使得F6的配置与RBF参数向量（即模式的期望分类）足够接近。这些单元的参数是人工选取并保持固定的（至少初始时候如此）。这些参数向量的成分被设为-1或1。虽然这些参数可以以-1和1等概率的方式任选，或者构成一个纠错码，但是被设计成一个相应字符类的7*12大小（即84）的格式化图片。这种表示对识别单独的数字不是很有用，但是对识别可打印ASCII集中的字符串很有用。&lt;/p&gt;
&lt;p&gt;      使用这种分布编码而非更常用的“1 of N”编码用于产生输出的另一个原因是，当类别比较大的时候，非分布编码的效果比较差。原因是大多数时间非分布编码的输出必须为0。这使得用sigmoid单元很难实现。另一个原因是分类器不仅用于识别字母，也用于拒绝非字母。使用分布编码的RBF更适合该目标。因为与sigmoid不同，他们在输入空间的较好限制的区域内兴奋，而非典型模式更容易落到外边。&lt;/p&gt;
&lt;p&gt;        RBF参数向量起着F6层目标向量的角色。需要指出这些向量的成分是+1或-1，这正好在F6 sigmoid的范围内，因此可以防止sigmoid函数饱和。实际上，+1和-1是sigmoid函数的最大弯曲的点处。这使得F6单元运行在最大非线性范围内。必须避免sigmoid函数的饱和，因为这将会导致损失函数较慢的收敛和病态问题。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5）训练过程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;        神经网络用于模式识别的主流是有指导学习网络，无指导学习网络更多的是用于聚类分析。对于有指导的模式识别，由于任一样本的类别是已知的，样本在空间的分布不再是依据其自然分布倾向来划分，而是要根据同类样本在空间的分布及不同类样本之间的分离程度找一种适当的空间划分方法，或者找到一个分类边界，使得不同类样本分别位于不同的区域内。这就需要一个长时间且复杂的学习过程，不断调整用以划分样本空间的分类边界的位置，使尽可能少的样本被划分到非同类区域中。&lt;/p&gt;
&lt;p&gt;       卷积网络在本质上是一种输入到输出的映射，它能够学习大量的输入与输出之间的映射关系，而不需要任何输入和输出之间的精确的数学表达式，只要用已知的模式对卷积网络加以训练，网络就具有输入输出对之间的映射能力。卷积网络执行的是有导师训练，所以其样本集是由形如：（输入向量，理想输出向量）的向量对构成的。所有这些向量对，都应该是来源于网络即将模拟的系统的实际“运行”结果。它们可以是从实际运行系统中采集来的。在开始训练前，所有的权都应该用一些不同的小随机数进行初始化。“小随机数”用来保证网络不会因权值过大而进入饱和状态，从而导致训练失败；“不同”用来保证网络可以正常地学习。实际上，如果用相同的数去初始化权矩阵，则网络无能力学习。&lt;/p&gt;
&lt;p&gt;       训练算法与传统的BP算法差不多。主要包括4步，这4步被分为两个阶段：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段，向前传播阶段：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a）从样本集中取一个样本(X,Y&lt;sub&gt;p&lt;/sub&gt;)，将X输入网络；&lt;/p&gt;
&lt;p&gt;b）计算相应的实际输出O&lt;sub&gt;p&lt;/sub&gt;。&lt;/p&gt;
&lt;p&gt;      在此阶段，信息从输入层经过逐级的变换，传送到输出层。这个过程也是网络在完成训练后正常运行时执行的过程。在此过程中，网络执行的是计算（实际上就是输入与每层的权值矩阵相点乘，得到最后的输出结果）：&lt;/p&gt;
&lt;p&gt;          O&lt;sub&gt;p&lt;/sub&gt;=F&lt;sub&gt;n&lt;/sub&gt;（…（F&lt;sub&gt;2&lt;/sub&gt;（F&lt;sub&gt;1&lt;/sub&gt;（X&lt;sub&gt;p&lt;/sub&gt;W&lt;sup&gt;（1）&lt;/sup&gt;）W&lt;sup&gt;（2）&lt;/sup&gt;）…）W&lt;sup&gt;（n）&lt;/sup&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段，向后传播阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a）算实际输出O&lt;sub&gt;p&lt;/sub&gt;与相应的理想输出Y&lt;sub&gt;p&lt;/sub&gt;的差；&lt;/p&gt;
&lt;p&gt;b）按极小化误差的方法反向传播调整权矩阵。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;6）卷积神经网络的优点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;        卷积神经网络CNN主要用来识别位移、缩放及其他形式扭曲不变性的二维图形。由于CNN的特征检测层通过训练数据进行学习，所以在使用CNN时，避免了显式的特征抽取，而隐式地从训练数据中进行学习；再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度。&lt;/p&gt;
&lt;p&gt;        流的分类方式几乎都是基于统计特征的，这就意味着在进行分辨前必须提取某些特征。然而，显式的特征提取并不容易，在一些应用问题中也并非总是可靠的。卷积神经网络，它避免了显式的特征取样，隐式地从训练数据中进行学习。这使得卷积神经网络明显有别于其他基于神经网络的分类器，通过结构重组和减少权值将特征提取功能融合进多层感知器。它可以直接处理灰度图片，能够直接用于处理基于图像的分类。&lt;/p&gt;
&lt;p&gt;       卷积网络较一般神经网络在图像处理方面有如下优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a）输入图像和网络的拓扑结构能很好的吻合；&lt;/li&gt;
&lt;li&gt;b）特征提取和模式分类同时进行，并同时在训练中产生；&lt;/li&gt;
&lt;li&gt;c）权重共享可以减少网络的训练参数，使神经网络结构变得更简单，适应性更强。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;7）小结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;       CNNs中这种层间联系和空域信息的紧密关系，使其适于图像处理和理解。而且，其在自动提取图像的显著特征方面还表现出了比较优的性能。在一些例子当中，Gabor滤波器已经被使用在一个初始化预处理的步骤中，以达到模拟人类视觉系统对视觉刺激的响应。在目前大部分的工作中，研究者将CNNs应用到了多种机器学习问题中，包括人脸识别，文档分析和语言检测等。为了达到寻找视频中帧与帧之间的相干性的目的，目前CNNs通过一个时间相干性去训练，但这个不是CNNs特有的。&lt;/p&gt;

&lt;h2&gt;如何选择卷积核的大小？越大越好还是越小越好？&lt;/h2&gt;
&lt;div readability=&quot;40&quot;&gt;
&lt;p&gt;答案是&lt;strong&gt;小而深&lt;/strong&gt;，单独较小的卷积核也是不好的，只有堆叠很多小的卷积核，模型的性能才会提升。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;CNN的卷积核对应一个感受野，这使得每一个神经元不需要对全局图像做感受，每个神经元只感受局部的图像区域，然后在更高层，将这些感受不同局部的神经元综合起来就可以得到全局信息。这样做的一个好处就是可以减少大量训练的参数。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;VGG经常出现多个完全一样的3×3的卷积核堆叠在一起的情况，这些多个小型卷积核堆叠的设计其实是非常有效的。两个3×3的卷积层串联相当于1个5×5的卷积层，即一个像素会和周围5×5的像素产生关联，可以说感受野是5×5。同时，3个串联的3×3卷积层串联的效果相当于一个7×7的卷积层。除此之外，3个串联的3×3的卷积层拥有比一个7×7更少的参数量，只有后者的 (3×3×3) / (7×7) = 55%。最重要的是3个3×3的卷积层拥有比一个7×7的卷积层更多的非线性变换（前者可以使用三次ReLu激活，而后者只有一次）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;卷积神经网络池化后的特征图大小计算&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;卷积后的大小&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;W：矩阵宽，H：矩阵高，F：卷积核宽和高，P：padding（需要填充的0的个数），N：卷积核的个数，S：步长&lt;/p&gt;
&lt;p&gt;width：卷积后输出矩阵的宽，height：卷积后输出矩阵的高&lt;/p&gt;
&lt;p&gt;width = （W - F + 2P）/ S + 1&lt;/p&gt;
&lt;p&gt;height = （H - F + 2P） / S + 1&lt;/p&gt;
&lt;p&gt;当conv2d(), max_pool()中的padding=‘SAME’时，width=W，height=H，当padding=‘valid’时，P=0&lt;/p&gt;
&lt;p&gt;输出图像大小：（width，height，N）&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;池化后的大小&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;width = （W - F）/ S + 1&lt;/p&gt;
&lt;p&gt;height = （H - F） / S + 1&lt;/p&gt;
&lt;h2&gt;边界填充问题&lt;/h2&gt;
&lt;h3&gt;卷积操作有两个问题： &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 图像越来越小； &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2. 图像边界信息丢失，即有些图像角落和边界的信息发挥作用较少。因此需要padding。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;卷积核大小通常为奇数 &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;一方面是为了方便same卷积padding对称填充，左右两边对称补零； &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;n+2p-f+1=n &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;p=(f-1)/2 &lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;另一方面，奇数过滤器有中心像素，便于确定过滤器的位置。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;两种padding方式：&quot;same&quot;/&quot;valid&quot;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201803/1192699-20180317153753556-1591838372.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot; data-section=&quot;0&quot;&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;0&quot; data-group=&quot;0-0&quot; data-sentence=&quot;0&quot;&gt;“VALID”只会丢弃最右边无法扫描到的列（或者最底部无法扫描到的列）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;tgt&quot; data-section=&quot;1&quot;&gt;&lt;span class=&quot;tgt&quot; data-section=&quot;1&quot; data-group=&quot;1-0&quot; data-sentence=&quot;0&quot;&gt;“SAME”试图在左右添加padding，但如果列添加的数量是奇数,则将额外的添加到右侧（即保持双数时，左右padding相通，偶数时，右侧/底部 比 左侧/顶部 多1)，在垂直方向同理）。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 10 Sep 2018 13:14:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<og:description>为什么要使用卷积呢？ 在传统的神经网络中，比如多层感知机（MLP），其输入通常是一个特征向量，需要人工设计特征，然后将这些特征计算的值组成特征向量，在过去几十年的经验来看，人工找到的特征并不是怎么好用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/9593364.html</dc:identifier>
</item>
</channel>
</rss>