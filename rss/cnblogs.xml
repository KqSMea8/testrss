<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JPA核心类与使用（二） - Miya。</title>
<link>http://www.cnblogs.com/SimpleWu/p/9744096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/9744096.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;a title=&quot;JPA第一章环境配置&quot; href=&quot;https://www.cnblogs.com/SimpleWu/p/9743224.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;点击访问：JPA环境配置（一）&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Persistence：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Persistence用于获取EntityManagerFactory实例，这个类中包含一个名为&lt;span&gt;createEntityManagerFactory&lt;/span&gt;的静态方法。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个方法有两个重载的版本：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）带有一个参数的方法以JPA配置文件中的持久化单元名为参数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;persistence-unit &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;JpaDemo1&quot;&lt;/span&gt;&lt;span&gt; transaction-type&lt;/span&gt;&lt;span&gt;=&quot;RESOURCE_LOCAL&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是这个JpaDemo1&lt;/p&gt;
&lt;p&gt;2）带有两个参数的方法：第一个参数和第一种版本一样，第二个参数传下去的是个Map集合，这个集合可以用来设置JPA的配置。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;EntityManagerFactory:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个接口主要是用来创建EntityManager实例对象，这个接口中约束了4个方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;createEntityManager（）&lt;/strong&gt;：用于创建实体管理器对象的实例&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;createEntityManager（Map map）&lt;/strong&gt;：map参数用于提供EntityManager的属性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;isOpen（）&lt;/strong&gt;：用来检测EntityManagerFactory对象是否关闭，在工厂打开之后除非调用close（）才会关闭&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;close（）&lt;/strong&gt;：上面也说了，关闭工厂用的，关闭之后在使用抛出异常IllegalStateException&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;EntityManager：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在JPA规范中，ENtityManager是完成持久化操作的核心对象，实体作为普通Java对象，只有在调用EntityManager将它与数据库互交后变成持久化对象。EntityManager对象在一组实体类与底层数据源之间进行O/R映射的管理。它可以用来管理和更新Entity Bean，根据主键查找Entity Bean，还可以通过JPQL语句查询实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实体的状态分为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）新建状态：新创建的对象，还没拥有持久化主键&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）持久化状态：已经拥有持久性主键和持久化建立了上下文环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）游离状态：拥有持久化主键，但是没有与持久化建立上下文环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）删除状态：拥有持久化主键，已经和持久化建立上下文，但是数据库的已经被删除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在测试下这个类中的方法如何使用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;find（Class&amp;lt;T&amp;gt; entityClass , Object primaryKey）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一个参数 entityClass是持久化类的class对象，第二个参数是主键ID，同hibernate种get（）方法，一旦执行立即加载，立马发送语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取持久化对象,立即发送sql语句，没有查到对应的数据返回null&lt;/span&gt;
 Student student = entityManager.find(Student.&lt;span&gt;class&lt;/span&gt;, 1&lt;span&gt;);
 System.out.println(student);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;getReference(Class&amp;lt;T&amp;gt; entityClass , Object primaryKey)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个参数 entityClass是持久化类的class对象，第二个参数是主键ID。同hibernate中load（）方法，即使执行使用才加载，使用才发送语句&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取持久化对象，延迟加载使用才发送sql语句，没有查询到对应于的数据抛出异常&lt;/span&gt;
        Student student = entityManager.getReference(Student.&lt;span&gt;class&lt;/span&gt;,1&lt;span&gt;);
        System.out.println(student);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;persist（Object entity）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用于将新建对象纳入到EntitiyManager的管理，该方法执行后这个对象将变成持久化对象。如果对已经处于持久化的对象进行管理那么这个方法什么都不会做，将删除状态的对象传入会将这个对象给持久化。如果将游离状态的对象传入可以抛出异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新建对象转换为持久化对象&lt;/span&gt;
        Student student = &lt;span&gt;new&lt;/span&gt; Student(&quot;AA&quot;, &quot;AA-00&quot;, 11, &quot;13212341234&quot;, &quot;中国-未知-未知&quot;&lt;span&gt;);
        entityManager.persist(student);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;remove（Object entity）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;删除实例，只能删除持久化对象同Hibernate。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test5(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除一个持久化对象，数据库对应记录会对应删除&lt;/span&gt;
        Student student = entityManager.find(Student.&lt;span&gt;class&lt;/span&gt;,1&lt;span&gt;);
        entityManager.remove(student);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;createQuery（String hqString）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;创建一个查询对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createQuery(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个查询对象&lt;/span&gt;
        String hql = &quot;from Student&quot;&lt;span&gt;;
        Query query &lt;/span&gt;=&lt;span&gt; entityManager.createQuery(hql);
        List&lt;/span&gt;&amp;lt;Student&amp;gt; students =&lt;span&gt; query.getResultList();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Student student : students) {
            System.out.println(student);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;createNamedQuery（String nameString）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据命名的查询语句块创建查询对象。参数为命名的查询语句。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201810/1462123-20181004205206446-870606148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;createNativeQuery (String sqlString)：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用标准 SQL语句创建查询对象。参数为标准SQL语句字符串。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createNativeQuery(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用标准 SQL语句创建查询对象。参数为标准SQL语句字符串。&lt;/span&gt;
        String sql = &quot;select * from tal_student&quot;&lt;span&gt;;
        Query query &lt;/span&gt;= entityManager.createNativeQuery(sql,Student.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        List&lt;/span&gt;&amp;lt;Student&amp;gt; students =&lt;span&gt; query.getResultList();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Student student : students) {
            System.out.println(student);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;createNativeQuery (String sqls, String resultSetMapping)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用标准SQL语句创建查询对象，并指定返回结果集 Map的 名称。&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;merge（T entity）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同HIbernate saveOrUpdate方法，用于持久化对象同步如果没有就Insert 如果有就执行update&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;flush()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同步持久上下环境意思就是将持久上下文所有没有保存的数据更新到数据库&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;refresh()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用于更新实体记录的数据&lt;br/&gt;&lt;span&gt;&lt;strong&gt;contains(Object entity)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;判断一个对象是否是持久化对象&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;isOpen（）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;判断实体管理器是否打开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;getTransaction（）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回资源层事务对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;close（）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关闭这个实体管理器&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;EntityTransaction&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接口用来管理资源层实体管理器的事务操作。通过调用实体管理器的getTransaction方法 获得其实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里面有几个常用的方法和hibernate中Transaction都是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Begin（）&lt;/strong&gt;&lt;/span&gt;启动一个事务，如果这个事物已经启动抛出一个异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;commit（）&lt;/strong&gt;&lt;/span&gt;提交一个事物，提交之后将增删改操作更新至数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;rollback（）&lt;/strong&gt;&lt;/span&gt;回滚一个数据，回滚后所有的操作将失效。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;注意我上面那些操作代码使用的是单元测试，@Before中就已经初始化工厂与实体管理器，在@After中对事物进行过提交与资源关闭，没提交事务，上面那些增删改操作都是失效操作。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Oct 2018 23:49:00 +0000</pubDate>
<dc:creator>Miya。</dc:creator>
<og:description>点击访问：JPA环境配置（一） Persistence： Persistence用于获取EntityManagerFactory实例，这个类中包含一个名为createEntityManagerFact</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/9744096.html</dc:identifier>
</item>
<item>
<title>设计模式（六）：责任链模式 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/9743922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/9743922.html</guid>
<description>&lt;p&gt;责任链设计模式是行为设计模式之一。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181005001255384-1921929763.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;责任链模式用于在软件设计中实现松散耦合，其中来自客户端的请求被传递到对象链以处理它们。然后链中的对象将自己决定谁将处理请求以及是否需要将请求发送到链中的下一个对象。&lt;/p&gt;

&lt;p&gt;让我们看一下JDK中责任链模式的例子，然后我们将继续实现这种模式的真实例子。我们知道在try-catch块代码中我们可以有多个catch块。这里每个catch块都是处理该特定异常的处理器。&lt;/p&gt;
&lt;p&gt;因此当try块中发生任何异常时，它会发送到第一个catch块进行处理。如果catch块无法处理它，它会将请求转发到链中的下一个对象，即下一个catch块。如果即使最后一个catch块也无法处理它，那么异常将被抛出链接到调用程序。&lt;/p&gt;

&lt;p&gt;责任链模式的一个很好的例子是ATM分配机器。用户按照定义的货币账单输入要分配的金额和机器分配金额，例如50美元，20美元，10美元等。&lt;br/&gt;如果用户输入的数量不是10的倍数，则会引发错误。我们将使用Chain of Responsibility模式来实现此解决方案。链将以与下图相同的顺序处理请求。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181005001243531-390743795.png&quot;/&gt;&lt;br/&gt;请注意，我们可以在单应用程序中轻松实现此解决方案，但随后复杂性将增加，解决方案将紧密耦合。因此，我们将创建一系列分配系统，以分配50美元，20美元和10美元的账单。&lt;/p&gt;

&lt;p&gt;我们可以创建一个类Currency来存储分配和链实现使用的数量。&lt;br/&gt;&lt;strong&gt;Currency.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.journaldev.design.chainofresponsibility;

public class Currency {

    private int amount;
    
    public Currency(int amt){
        this.amount=amt;
    }
    
    public int getAmount(){
        return this.amount;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基接口应该有一个方法来定义链中的下一个处理器以及处理请求的方法。我们的ATM Dispense界面如下所示。&lt;br/&gt;&lt;strong&gt;DispenseChain.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.journaldev.design.chainofresponsibility;

public interface DispenseChain {

    void setNextChain(DispenseChain nextChain);
    
    void dispense(Currency cur);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我们需要创建不同的处理器类来实现DispenseChain接口并提供分配方法的实现。由于我们正在开发我们的系统以使用三种类型的货币账单--50美元，20美元和10美元，我们将创建三个具体实施。&lt;br/&gt;&lt;strong&gt;Dollar50Dispenser.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.journaldev.design.chainofresponsibility;

public class Dollar50Dispenser implements DispenseChain {

    private DispenseChain chain;
    
    @Override
    public void setNextChain(DispenseChain nextChain) {
        this.chain=nextChain;
    }

    @Override
    public void dispense(Currency cur) {
        if(cur.getAmount() &amp;gt;= 50){
            int num = cur.getAmount()/50;
            int remainder = cur.getAmount() % 50;
            System.out.println(&quot;Dispensing &quot;+num+&quot; 50$ note&quot;);
            if(remainder !=0) this.chain.dispense(new Currency(remainder));
        }else{
            this.chain.dispense(cur);
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Dollar20Dispenser.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.journaldev.design.chainofresponsibility;

public class Dollar20Dispenser implements DispenseChain{

    private DispenseChain chain;
    
    @Override
    public void setNextChain(DispenseChain nextChain) {
        this.chain=nextChain;
    }

    @Override
    public void dispense(Currency cur) {
        if(cur.getAmount() &amp;gt;= 20){
            int num = cur.getAmount()/20;
            int remainder = cur.getAmount() % 20;
            System.out.println(&quot;Dispensing &quot;+num+&quot; 20$ note&quot;);
            if(remainder !=0) this.chain.dispense(new Currency(remainder));
        }else{
            this.chain.dispense(cur);
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Dollar10Dispenser.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.journaldev.design.chainofresponsibility;

public class Dollar10Dispenser implements DispenseChain {

    private DispenseChain chain;
    
    @Override
    public void setNextChain(DispenseChain nextChain) {
        this.chain=nextChain;
    }

    @Override
    public void dispense(Currency cur) {
        if(cur.getAmount() &amp;gt;= 10){
            int num = cur.getAmount()/10;
            int remainder = cur.getAmount() % 10;
            System.out.println(&quot;Dispensing &quot;+num+&quot; 10$ note&quot;);
            if(remainder !=0) this.chain.dispense(new Currency(remainder));
        }else{
            this.chain.dispense(cur);
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要注意的重点是分配方法的实施。您会注意到每个实现都在尝试处理请求，并且根据数量，它可能会处理部分或全部部分。&lt;br/&gt;如果其中一个链不能完全处理它，它会将请求发送到链中的下一个处理器以处理剩余的请求。如果处理器无法处理任何内容，它只会将相同的请求转发到下一个链。&lt;/p&gt;

&lt;p&gt;这是非常重要的一步，我们应该仔细创建链，否则处理器可能根本没有得到任何请求。例如，在我们的实现中，如果我们将第一个处理器链保持为Dollar10Dispenser然后Dollar20Dispenser，那么请求将永远不会被转发到第二个处理器，并且链将变得无用。&lt;/p&gt;
&lt;p&gt;这是我们的ATM Dispenser实现，用于处理用户请求的数量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ATMDispenseChain.java&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.journaldev.design.chainofresponsibility;

import java.util.Scanner;

public class ATMDispenseChain {

    private DispenseChain c1;

    public ATMDispenseChain() {
        // initialize the chain
        this.c1 = new Dollar50Dispenser();
        DispenseChain c2 = new Dollar20Dispenser();
        DispenseChain c3 = new Dollar10Dispenser();

        // set the chain of responsibility
        c1.setNextChain(c2);
        c2.setNextChain(c3);
    }

    public static void main(String[] args) {
        ATMDispenseChain atmDispenser = new ATMDispenseChain();
        while (true) {
            int amount = 0;
            System.out.println(&quot;Enter amount to dispense&quot;);
            Scanner input = new Scanner(System.in);
            amount = input.nextInt();
            if (amount % 10 != 0) {
                System.out.println(&quot;Amount should be in multiple of 10s.&quot;);
                return;
            }
            // process the request
            atmDispenser.c1.dispense(new Currency(amount));
        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们运行上面的应用程序时，我们得到如下的输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Enter amount to dispense
530
Dispensing 10 50$ note
Dispensing 1 20$ note
Dispensing 1 10$ note
Enter amount to dispense
100
Dispensing 2 50$ note
Enter amount to dispense
120
Dispensing 2 50$ note
Dispensing 1 20$ note
Enter amount to dispense
15
Amount should be in multiple of 10s.&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;我们的ATM分配示例的责任链设计模式实现如下图所示。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201810/1162587-20181005001200611-428700999.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;客户端不知道链的哪个部分将处理请求，它将把请求发送到链中的第一个对象。例如，在我们的程序中，ATMDispenseChain不知道谁在处理分配输入金额的请求。&lt;/li&gt;
&lt;li&gt;链中的每个对象都有自己的实现来处理请求，全部或部分或将其发送到链中的下一个对象。&lt;/li&gt;
&lt;li&gt;链中的每个对象都应该引用链中的下一个对象来转发请求，它由java组成。&lt;/li&gt;
&lt;li&gt;仔细创建链非常重要，否则可能会出现请求永远不会转发到特定处理器或链中没有能够处理请求的对象的情况。在我的实现中，我添加了对用户输入数量的检查，以确保它被所有处理器完全处理，但是如果请求到达最后一个对象并且链中没有其他对象，我们可能不检查它并抛出异常将请求转发给。这是一个设计决定。&lt;/li&gt;
&lt;li&gt;责任链设计模式很好地实现了失去耦合，但如果大多数代码在所有实现中都很常见，那么它会带来很多实现类和维护问题的权衡。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;java.util.logging.Logger#log()&lt;/li&gt;
&lt;li&gt;javax.servlet.Filter#doFilter()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就是责任链设计模式的全部内容，我希望你喜欢它，并且能够清楚你对这种设计模式的理解。&lt;/p&gt;
&lt;p&gt;翻译：&lt;a href=&quot;https://www.journaldev.com/1617/chain-of-responsibility-design-pattern-in-java&quot;&gt;journaldev&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Oct 2018 16:21:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>责任链设计模式是行为设计模式之一。 责任链模式用于在软件设计中实现松散耦合，其中来自客户端的请求被传递到对象链以处理它们。然后链中的对象将自己决定谁将处理请求以及是否需要将请求发送到链中的下一个对象。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/9743922.html</dc:identifier>
</item>
<item>
<title>mybatis源码-解析配置文件（四-1）之配置文件Mapper解析(cache) - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9743921.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9743921.html</guid>
<description>&lt;p&gt;本文章主要讲解的是， &lt;strong&gt;xxxMapper.xml&lt;/strong&gt; 文件中， &lt;strong&gt;cache&lt;/strong&gt; 节点的源码。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;XMLMapperBuilder.cacheElement()&lt;/code&gt; 方法主要负责解析 &amp;lt;&lt;strong&gt;cache&lt;/strong&gt;&amp;gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  private void cacheElement(XNode context) throws Exception {
    if (context != null) {
      // 获取 type 节点的属性， 默认是 PERPETUAL
      String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);
      // 通过 type 值， 查找对应 Cache 接口的实现
      Class&amp;lt;? extends Cache&amp;gt; typeClass = typeAliasRegistry.resolveAlias(type);
      // eviction 属性， eviction 对应的是回收策略， 默认为 LRU。
      String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);
      // 解析 eviction 属性指定的 Cache 装饰器类型
      Class&amp;lt;? extends Cache&amp;gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);
      // flushInterval 对应刷新间隔， 单位毫秒， 默认值不设置， 即没有刷新间隔， 缓存仅仅在刷新语句时刷新。
      Long flushInterval = context.getLongAttribute(&quot;flushInterval&quot;);
      // size 对应为引用的数量，即最多的缓存对象数据。
      Integer size = context.getIntAttribute(&quot;size&quot;);
      // readOnly 为只读属性， 默认为 false, 即可读写
      boolean readWrite = !context.getBooleanAttribute(&quot;readOnly&quot;, false);
      // blocking 为阻塞， 默认值为 false。 当指定为 true 时将采用 BlockingCache 进行封装
      boolean blocking = context.getBooleanAttribute(&quot;blocking&quot;, false);
      // 获取 &amp;lt;cache&amp;gt; 属性节点下的子节点， 用于初始化二级缓存
      Properties props = context.getChildrenAsProperties();
      // 通过 MapperBuilderAssistant 创建 Cache 对象， 并将其添加到 COnfiguration 中
      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中， type 的对应类型 &lt;code&gt;PERPETUAL&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// PerpetualCache.class 为 org.apache.ibatis.cache.impl.PerpetualCache
typeAliasRegistry.registerAlias(&quot;PERPETUAL&quot;, PerpetualCache.class);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他的就是获取属性， 有的有对应的默认值。&lt;/p&gt;
&lt;p&gt;最后需要将这些属性， 通过 &lt;code&gt;MapperBuilderAssistant.useNewCache()&lt;/code&gt; 进行缓存设置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public Cache useNewCache(Class&amp;lt;? extends Cache&amp;gt; typeClass,
      Class&amp;lt;? extends Cache&amp;gt; evictionClass,
      Long flushInterval,
      Integer size,
      boolean readWrite,
      boolean blocking,
      Properties props) {
    // 建造者模式
    Cache cache = new CacheBuilder(currentNamespace)
        .implementation(valueOrDefault(typeClass, PerpetualCache.class))
        .addDecorator(valueOrDefault(evictionClass, LruCache.class))
        .clearInterval(flushInterval)
        .size(size)
        .readWrite(readWrite)
        .blocking(blocking)
        .properties(props)
        .build();
    // 将对象添加到 configuration 中
    configuration.addCache(cache);
    // 给当前命名空间的缓存成员变量赋值
    currentCache = cache;
    return cache;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该函数创建对应的 &lt;strong&gt;Cache&lt;/strong&gt; 对象， 该对象的 &lt;strong&gt;id&lt;/strong&gt; 为 &lt;strong&gt;currentNamespace(当前mapper.xml 的 namespace)&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public Cache build() {
    // 设置默认的实现， type 和 lru 对应的类不为空
    setDefaultImplementations();
    // 通过反射创建对象
    Cache cache = newBaseCacheInstance(implementation, id);
    // 根据&amp;lt;cache&amp;gt;节点的子节点&amp;lt;property&amp;gt;, 初始化Cache对象
    setCacheProperties(cache);
    // issue #352, do not apply decorators to custom caches
    // 如果是PerpetualCache类型， 使用 decorators 中的装饰器来包装cache, 并设置属性
    if (PerpetualCache.class.equals(cache.getClass())) {
      for (Class&amp;lt;? extends Cache&amp;gt; decorator : decorators) {
        cache = newCacheDecoratorInstance(decorator, cache);
        setCacheProperties(cache);
      }
      // mybatis 自己提供的标准装饰器
      cache = setStandardDecorators(cache);
    } else if (!LoggingCache.class.isAssignableFrom(cache.getClass())) {
      // 如果不是 LoggingCache 子类， 则添加 LoggingCache 装饰器
      cache = new LoggingCache(cache);
    }
    return cache;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将对象添加到 configuratin 中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public void addCache(Cache cache) {
    caches.put(cache.getId(), cache);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的成员变量为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  protected final Map&amp;lt;String, Cache&amp;gt; caches = new StrictMap&amp;lt;&amp;gt;(&quot;Caches collection&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是 &lt;code&gt;StrictMap&lt;/code&gt; 类型。该对象将 &lt;strong&gt;namespace&lt;/strong&gt; 与 缓存对象 &lt;strong&gt;Cache&lt;/strong&gt; 对应起来了。 而 &lt;strong&gt;namespace&lt;/strong&gt; 是 &lt;strong&gt;xxxMapper.xml&lt;/strong&gt; 的标识。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;StrictMap&lt;/code&gt; 有什么特殊的地方， 为什么不直接用 &lt;code&gt;HashMap&lt;/code&gt; 呢？&lt;/p&gt;
&lt;h2 id=&quot;区别hashmap键必须为string&quot;&gt;3.1 区别HashMap：键必须为String&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;protected static class StrictMap&amp;lt;V&amp;gt; extends HashMap&amp;lt;String, V&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;区别hashmap多了成员变量-name&quot;&gt;3.2 区别HashMap：多了成员变量 name&lt;/h2&gt;
&lt;p&gt;多了一个 &lt;strong&gt;name&lt;/strong&gt; 成员变量， 而且该变量是必须设置的&lt;/p&gt;
&lt;p&gt;所有的构造函数都需要&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public StrictMap(String name, int initialCapacity, float loadFactor) {
      super(initialCapacity, loadFactor);
      this.name = name;
    }

    public StrictMap(String name, int initialCapacity) {
      super(initialCapacity);
      this.name = name;
    }

    public StrictMap(String name) {
      super();
      this.name = name;
    }

    public StrictMap(String name, Map&amp;lt;String, ? extends V&amp;gt; m) {
      super(m);
      this.name = name;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;区别hashmapkey-的处理多了一些变化&quot;&gt;3.3 区别HashMap：key 的处理多了一些变化&lt;/h2&gt;
&lt;h3 id=&quot;put&quot;&gt;3.3.1 put&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;    public V put(String key, V value) {
      // 是否存在 key， 存在则直接报异常
      if (containsKey(key)) {
        throw new IllegalArgumentException(name + &quot; already contains value for &quot; + key);
      }
      // 获取 shortKey
      if (key.contains(&quot;.&quot;)) {
        // 将 key 以 . 分割， 并获取最后一项作为 shortKey
        final String shortKey = getShortName(key);
        if (super.get(shortKey) == null) {
          // 如果 shorKey 对应在 Map 中没有值， 则放入
          super.put(shortKey, value);
        } else {
          // 如果 shorKey 对应在 Map 中有值， 则放入一个 Ambiguity 类
          super.put(shortKey, (V) new Ambiguity(shortKey));
        }
      }
      // key 也会放一个 value
      return super.put(key, value);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;shortkey&quot;&gt;3.3.2 shortKey&lt;/h3&gt;
&lt;p&gt;关于 &lt;strong&gt;shortKey&lt;/strong&gt;， 其实就是我们以全限定名作为属性时， 它取得是分隔符分割后最后的一项。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 将 key 以 . 分割， 并获取最后一项作为 shortKey
private String getShortName(String key) {
  final String[] keyParts = key.split(&quot;\\.&quot;);
  return keyParts[keyParts.length - 1];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;shortKey&lt;/strong&gt; 它的作用就是类似一个模糊查询的功能， 比如说我们要调用的是 &lt;code&gt;com.mybatis.homejim.mapper.StudentMapper.selectAll&lt;/code&gt; 这个函数, 我们可以写&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;selectList(&quot;com.mybatis.homejim.mapper.StudentMapper.selectAll&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;strong&gt;mybatis&lt;/strong&gt; 中加入 &lt;strong&gt;shortKey&lt;/strong&gt; 之后， 我们只需要写&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;selectList(&quot;selectAll&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是， &lt;strong&gt;在实际使用时用处不大&lt;/strong&gt;， 很多函数基本都是会是二义性的， 不明白为何不取消。&lt;/p&gt;
&lt;h3 id=&quot;ambiguity&quot;&gt;3.3.3 Ambiguity&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Ambiguity&lt;/code&gt;是 &lt;code&gt;StrictMap&lt;/code&gt; 中的静态内部类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected static class Ambiguity {
  final private String subject;

  public Ambiguity(String subject) {
    this.subject = subject;
  }

  public String getSubject() {
    return subject;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其作用记录存在二义性的 key, 告诉使用者， 你的这个 key 是二义性的。&lt;/p&gt;
&lt;h3 id=&quot;get&quot;&gt;3.3.4 get&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;
public V get(Object key) {
  // value 为空则报错
  V value = super.get(key);
  if (value == null) {
    throw new IllegalArgumentException(name + &quot; does not contain value for &quot; + key);
  }
  // 二义性也报错
  if (value instanceof Ambiguity) {
    throw new IllegalArgumentException(((Ambiguity) value).getSubject() + &quot; is ambiguous in &quot; + name
        + &quot; (try using the full name including the namespace, or rename one of the entries)&quot;);
  }
  // 正常情况下应该是返回
  return value;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 04 Oct 2018 16:16:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>相关文章推荐 | | |</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9743921.html</dc:identifier>
</item>
<item>
<title>nginx+uwsgi启动Django项目 - Harvard_Fly</title>
<link>http://www.cnblogs.com/FG123/p/9707735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FG123/p/9707735.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.安装项目环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统环境：ubuntu16.04&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python环境：python3.5.2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Django版本：django1.11.7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nginx环境：nginx_1.10.3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虚拟环境：virtualenv15.1.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;uwsgi版本：uwsgi2.0.17.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装并进入项目虚拟环境：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo apt-&lt;span&gt;get install virtualenv
virtualenv &lt;/span&gt;-&lt;span&gt;p python3 env_my_project 
source env_my_project&lt;/span&gt;/bin/activate&lt;/span&gt;&lt;br/&gt;&lt;span&gt;pip install -r requirements.txt &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.项目配置及运行测试&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;修改项目配置文件：
cp my_project&lt;/span&gt;/settings_local.py.example my_project/&lt;span&gt;settings_local.py

修改es配置文件：
cp rs_es&lt;/span&gt;/es_settings.py.example rs_es/es_settings.py&lt;p&gt;wsgi.py:&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;import os&lt;br/&gt;&lt;/span&gt;&lt;span&gt;from django.core.wsgi import get_wsgi_application&lt;br/&gt;&lt;/span&gt;&lt;span&gt;os.environ.setdefault(&quot;DJANGO_SETTINGS_MODULE&quot;, &quot;my_project.settings_local&quot;)&lt;br/&gt;&lt;/span&gt;&lt;span&gt;application = get_wsgi_application()&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;项目运行测试：&lt;br/&gt;python manage.py collectstatic  # 收集静态文件&lt;br/&gt;python manage.py makemigrations&lt;br/&gt;&lt;/span&gt;&lt;span&gt;python manage.py migrate&lt;br/&gt;python manage.py runserver 0.0.0.0:8001&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201810/739231-20181004194138789-600412111.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.NGINX和UWSGI相关配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo cp /etc/nginx/sites-available/default /etc/nginx/sites-available/&lt;span&gt;my_project
sudo ln &lt;/span&gt;-s /etc/nginx/sites-available/my_project /etc/nginx/sites-enabled/&lt;span&gt;
sudo vim &lt;/span&gt;/etc/nginx/sites-enabled/&lt;span&gt;my_project

nginx配置：
upstream my_project{
    server unix:&lt;/span&gt;///var/run/&lt;span&gt;my_project.sock;
}

server {
    listen      &lt;/span&gt;8001;  //&lt;span&gt;服务的端口号   服务通过nginx与uwsgi通信来启动

    server_name &lt;/span&gt;192.168.xx.xx;  //&lt;span&gt;nginx代理的ip  
    charset     utf&lt;/span&gt;-8&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; max upload size&lt;/span&gt;
&lt;span&gt;    client_max_body_size 10M;

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; send all non-media requests to the Django server.&lt;/span&gt;
    location /&lt;span&gt; {
        uwsgi_pass  my_project;
        include     &lt;/span&gt;/etc/nginx/&lt;span&gt;uwsgi_params;
    }

    location &lt;/span&gt;/static/&lt;span&gt; {
        root &lt;/span&gt;/home/ubuntu/&lt;span&gt;my_project;
    }
}

Uwsgi配置:
sudo mkdir &lt;/span&gt;/var/log/&lt;span&gt;uwsgi
sudo chmod &lt;/span&gt;-R 777 /var/log/&lt;span&gt;uwsgi

uwsgi.ini:
[uwsgi]
chdir&lt;/span&gt;=/home/ubuntu/&lt;span&gt;my_project
home&lt;/span&gt;=/home/ubuntu/my_project/&lt;span&gt;env_my_project
module&lt;/span&gt;=&lt;span&gt;my_project.wsgi:application

socket&lt;/span&gt;=/var/run/&lt;span&gt;my_project.sock
chmod&lt;/span&gt;-socket = 666&lt;span&gt;

master&lt;/span&gt;=&lt;span&gt;True
processes &lt;/span&gt;= 5&lt;span&gt;
max&lt;/span&gt;-requests=5000

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; clear environment on exit&lt;/span&gt;
vacuum=&lt;span&gt;True

pidfile&lt;/span&gt;=/var/run/&lt;span&gt;my_project.pid
daemonize&lt;/span&gt;=/var/log/uwsgi/&lt;span&gt;my_project.log

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; git pull 自动重启服务&lt;/span&gt;
touch-reload=.git/index&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.配置Emperor mode监听和系统自动启动uwsgi&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;配置Emperor mode监听
sudo mkdir &lt;/span&gt;/etc/&lt;span&gt;uwsgi
sudo mkdir &lt;/span&gt;/etc/uwsgi/&lt;span&gt;vassals
sudo ln &lt;/span&gt;-s /home/ubuntu/my_project/uwsgi.ini /etc/uwsgi/vassals/&lt;span&gt;

系统自动启动uwsgi
sudo vim &lt;/span&gt;/etc/&lt;span&gt;rc.local
&lt;/span&gt;/usr/local/bin/uwsgi --emperor /etc/uwsgi/vassals&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5.通过uwsgi启动django服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;启动uwsgi
uwsgi &lt;/span&gt;--&lt;span&gt;ini uwsgi.ini

重启nginx
sudo service nginx restart

启动django服务
sudo uwsgi &lt;/span&gt;--reload /var/run/my_project.pid&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此时在浏览器通过ngnix代理出来的ip和端口即可访问服务&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Oct 2018 16:10:00 +0000</pubDate>
<dc:creator>Harvard_Fly</dc:creator>
<og:description>1.安装项目环境 系统环境：ubuntu16.04 python环境：python3.5.2 Django版本：django1.11.7 nginx环境：nginx_1.10.3 虚拟环境：virtu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FG123/p/9707735.html</dc:identifier>
</item>
<item>
<title>致十年后的自己 - 强风吹拂</title>
<link>http://www.cnblogs.com/Snail-1174158844/p/9743798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Snail-1174158844/p/9743798.html</guid>
<description>&lt;p&gt;            今天是2018年10月4号晚上十一点整，这时正在享受十月一长假带来的无聊，刷着抖音看到全国各地的路上堵啊景区堵啊.看着你们堵我心里就不赌了，哈哈。今天呢真是闲来无事写个心情吧也算是一种记录或者说是把时光留下，写给十年后的那个自己。科学家指出，在宇宙中的某个角落里，就会有一个跟你一模一样的人，而你跟他完全不会相遇，我是搞技术的，现在最流行的火的技术是，大数据及人工智能，不知道十年后AI会发生怎样的变化很好奇应该说是期待，真有可能会像电影里那样，每个人都有一个私人的助理不像现今这样一个语音助手还时灵时不灵真让脑瓜疼‘脑瓜疼’啊，现今的世界对人工智能分持正反两方的，当然我是保持中立的，因为都是存在，武林有正邪之分，人有好坏之别，且能保持均衡足以，就像武功到底有没有正邪呢，关键在于修炼人的本心，毕竟人之初性本善。&lt;/p&gt;
&lt;p&gt;       　 刚才是开个玩笑，我对于人工智能的定义，不像那些学院派的教授啊，用术语说出来，感觉很屌的样子用的都是高大上的名词，给外人看来。好牛啊一句都不懂讲的太高深了。中国的教授太居高临下了，我们年轻人都要仰望啊，还看不清教授您的相貌啊，但是我想说的是   &quot;苍天已死，黄天当立&quot;  我跟我朋友说的最多的一句话。永远不要看低自己，也不要看低他者，他能做到你一样能做到（本文的他没有性别之分），哈哈 不要太在意形容。&lt;/p&gt;
&lt;p&gt; ·　　　我对人生的的还是很追求随性的，但是还是分类的。工作和生活肯定要分开的，尤其是现在我是搞技术的，我真的恨外界对我们这个行业形容词，比如 程序员, IT男, 上班穿拖鞋那位，头发半年没洗的那位 等等。我真想说 我* ，我从来不承认自己是程序员，我是一名软件工程师，即使是夏天也不穿拖鞋上班凉鞋也不穿，别以为我穿一身正装，我长期一身休闲装，因为这个行业没有对服装的约束，但是我感觉对于职业的尊重和对公司的尊重，在家里的那一身行头，大裤衩 ,拖鞋, 工作期间最好别穿为好，这时想外界说的也没错，自己本身都不尊重自己，也不怪人说，（题外话：就像你去相亲，你会体体面面的把最好的一面展现给对方，而不是穿着大裤衩踏着拖鞋去相亲，明知却不做，能怪谁啊）声明：我并不高尚，也不是什么圣人，我才二十多岁的年纪，对职业道路不用太严肃。做一件事对其本身的兴趣才是最重要的，什么天才啊，大神啊，你迟早也会成为的，倘若你有自己的路，可能会被世人称之为鬼才也说不定。&lt;/p&gt;
&lt;p&gt;　　　　我对生活一直很执着，哪怕有不幸，对未来依然很憧憬。规划真的很重要，我是这么认为的，不管最后怎样起码你相信过，只因相信，还有还有最重要的一点，记住 不要因为别人的闲言碎语而放弃 你不是为了他们而活 虽做不到人生无憾 但过而无悔。&lt;/p&gt;
&lt;p&gt;　　　　我不知道十年后的你会是怎么样，你要记住，初心不变，归来仍是少年，永远不要考虑年龄层次上差越，虽然认知是跟随年龄增长，但并不相等，一群人总会有那么一个另类，&lt;/p&gt;
&lt;p&gt;　　　　对于爱情 我在网上见过这么一段话：不应该为了父母结婚，不应该在外面听到什么疯言疯语听多了就想着要结婚。应该想着跟自己喜欢的人，白头偕老的结婚，昂首挺胸的，特别硬气的，憧憬的，好像赢了一样。嗯，不因为什么到了该结婚的狗屁年纪，不应该你有千座金山，万亩良田，不因为一个人过于独孤，需要人陪，只是因为我要等到你。我相信那个对的人，他有一天一定会接收到我的讯号，只要我愿意等。请别再说我挑剔，真正挑剔的人，是你们啊，你们挑剔了年龄，挑剔了婚姻的条件，挑剔了外在长相，家庭背景，学历情况，而我只挑剔一个人而已，如果不是你，tiffany最大的钻戒，vera wang王限量的婚纱，我也不愿意。如果是你，其他的什么都没关系。因为在我看来啊，最贵的就是爱情。&lt;/p&gt;
&lt;p&gt;　　　　嗯...生活如此丰富，我还在路上。&lt;/p&gt;



</description>
<pubDate>Thu, 04 Oct 2018 15:21:00 +0000</pubDate>
<dc:creator>强风吹拂</dc:creator>
<og:description>今天是2018年10月4号晚上十一点整，这时正在享受十月一长假带来的无聊，刷着抖音看到全国各地的路上堵啊景区堵啊.看着你们堵我心里就不赌了，哈哈。今天呢真是闲来无事写个心情吧也算是一种记录或者说是把时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Snail-1174158844/p/9743798.html</dc:identifier>
</item>
<item>
<title>TCP协议学习总结（上） - wc的一些事一些情</title>
<link>http://www.cnblogs.com/wcd144140/p/9743618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wcd144140/p/9743618.html</guid>
<description>&lt;p&gt;&lt;span&gt;在计算机领域，数据的本质无非0和1，创造0和1的固然伟大，但真正百花齐放的还是基于0和1之上的各种层次之间的组合（数据结构）所带给我们人类各种各样的可能性。例如TCP协议，我们的生活无不无时无刻的站在TCP协议这个“巨人”的肩膀上，最简单的一个打开手机的动作。所以对TCP的认识和理解，可谓越来越常识化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004220528858-1910430766.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP/IP五层协议&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 虽然TCP是一种计算机网络协议，但本质还是人与人之间的一种约定，只不过由计算机去执行而已，把协议的细节与作用解耦，让我们人类只需专注于基于它的应用呈现之上即可。协议即“规则”，如果我们把光纤“横斜面”剖析，我们看到的就是数据的本质0和1，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004220607731-1904092429.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;0和1是点对点之间通信的信息“载体”，我们需要有一各规则去翻译这些“载体”，好比如小白和小黑之间的“敲声传话游戏”的约定，他们可以约定“敲一下”代表“是”，“敲两下”代表“不是”等。这些“敲声”跟光纤上的“0”和“1”都是承载着一样的任务——信息载体。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004220650269-227067063.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 从整个网络层次来看，TCP/IP协议体系是网络的一个核心协议组，有一点需要知道的是TCP/IP协议体系并非只有TCP协议和IP协议，而是包含了物理层、链路层、网络层、运输层、应用层，而每一层次又有不同的协议，例如运输层协议除了TCP协议还有UDP协议。当然这里我只是为了接下来学习TCP协议的一个宏观认识。从上图可以看出，从0和1的基本信息单元到TCP协议的数据结构还要经过链路层和网络层的层层分解，换句话说，也就是TCP协议的数据以“段”单元，封装在链路层的IP协议上，IP协议的数据是以“数据报”为单元，它同样封装在链路层的以太网标准协议里面。本文的重点在TCP协议的学习，了解了TCP的原理，其他协议的数据结构和逻辑大同小异了。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; TCP的首部&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004220727902-980699220.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从“TCP/IP五层协议体系图”可以看出，每一个协议都会有个“头部”，TCP也不例外，其实这个“头部”就是该协议的数据结构以及规则的说明，但无论协议的玩法如何变化，它还是离不开0和1的信息载体。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;源端口号：&lt;/strong&gt;我们都知道IP是跟主机相关，而每台主机又可以有不同的应用进程在运行，所以端口更多可以指运行在主机上的应用进程，所以源端口号也就是基于TCP协议传输数据的“发送方”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;目的端口：&lt;/strong&gt;就是等待TCP协议发送方数据的“接收方”，其实所谓的端口也就是应用进程与应用进程之间通信的监听出入口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;序列号：&lt;/strong&gt;这个数字是用来表示通信双方“单向”数据量流动数量表示，上面所介绍的0和1是最小的数据传输单元，我们称为“比特（bit）”。而这个序列号记录的是以“字节”为单位的计数器（1字节=8比特）。例如A要传输给B的512字节数据，假设初始序列号为1024（注意：每次初始化序号都会不一样，TCP有一个比较复杂的初始化算法），那么他们传输过程的序列号为1536。这个序列号会随着双方“交流”而不断的增加，因为序列号一共32比特，所以最大值也就是2^32-1，到达最大值后重新从0开始。因为TCP是一个可靠的协议，序列号的存在是其可靠的关键因素之一。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004220815556-1447131928.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;确认序列号：&lt;/strong&gt;既然每个传输的字节都被计数，确认序列号包含发送确认的一端所期望收到下一个序号。因此，确认序列号应当是上次已成功接收到数据字节序列号加1。只有ACK标识（下面会介绍）为1时确认序列号才生效。因为TCP为应用层提供双工服务，意味着数据能在两个方向上独立地进行传输，因此连接的每一端（客户端和服务端）必须保持每个方向上的传输序列号。例如A传送给B的序列号为1024（A维护），但B传送给A的有自己的序列号需要维护（B维护）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;首部长度：&lt;/strong&gt;TCP首部的“选项”不启用，那么TCP的头部就是20字节，但因为存在“选项”的部分，所以头部可能存在大于20字节的可能性。因为“首部长度标识”有4位，所以最大值为2^4-1=15，而这个标识维护头部的长度是以32比特为单元，所以头部最大长度为15*32比特（4字节）=60字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;标志：&lt;/strong&gt;每个标志占1比特，它们中的多个可同时被设置为1，每个标志的用法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;URG：紧急指针（urgent pointer）有效；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ACK：确认序号有效；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PSH：接收方应该尽快将这个报文段交给应用层；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;RST：重建连接；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SYN：同步序号用来发起一个连接；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FIN：发送端完成发送任务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;窗口大小：&lt;/strong&gt;TCP的流量控制由连接的每一端通过声明的窗口大小来提供（以字节为单位），窗口大小是一个16比特字段，因而窗口最大为65535字节。换个说法，窗口好比如“缓冲区”，TCP是一个双工单向传送的通信协议，双方都需要有自己的窗口（缓冲区）大小相互告知，如果接收到的应用处理速度慢（从缓冲区消费数据慢），那么它的窗口很容易就满了，发送方就会停止发送，等到接受方的窗口有“空余”了才继续发送。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;检验和：&lt;/strong&gt;检验和（类数据签名）覆盖了整个的TCP报文段：TCP首部和TCP数据，因为TCP是一个可靠的协议，所以这是强制性的字段，由发送方计算和设置，并由接收方进行验证，这就是可靠性保证的重要手段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;紧急指针：&lt;/strong&gt;只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个报文段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;选项：&lt;/strong&gt;就是TCP头部的不是“必须”的选项，例如常见的可选字段是“最长报文大小”，又称为MSS（Maximun Segment Size），每个连接方通常都在通信的第一个报文段中指明这个选项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据：&lt;/strong&gt;整个TCP报文段是又报文头部和报文数据组成的，除去了头部就是数据，但数据是可空的，例如创建连接（SYN）和结束传输（FIN）的TCP报文都是没有数据的。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; TCP连接的建立和终止&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004220947796-642544731.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP建立连接需要三次握手，分别如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）、客户端（请求方）发送一个SYN段指明客户打算连接的服务器端口，以及把初始化序号x附上，这就是大名鼎鼎的SYN报文段，在介绍头部的时候已经提过，SYN报文段是没有数据的，因为连接都没正式连接，发送数据没意义。但也提到了客户端会附上它的最大报文段，也就是告诉接收方它最大的一个报文段能接受多少数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）、服务端（处于监听状态）收到SYN请求后发回包含服务端的初始序号的SYN报文段作为应答（上文提到过客户端和服务端的初始序号都是各自维护的）。同时，将确认序号设置为客户的ISN加1（因为SYN将占用一个序号），以对客户的SYN报文段进行确认。在服务端想客户端响应SYN的时候同样可能会附上它接收的最大报文段，但记住，毕竟最大报文段是可选的，不一定会存在，不相互告知的话就会使用默认值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）、客户端必须将确认序号设置为服务器的ISN加1一对服务器的SYN报文段进行确认。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当以上三个报文段完成交互后就证明连接已经建立，这个过程也成为“三次握手”。接下来客户端就可以发送数据给服务端，服务端可以响应数据。其实很多时候，客户端在第三个报文段（也就是第三次握手）的时候就已经附带数据了。因为它已经不需要等待对方第四次握手的交互确认。正常连接的第四个报文段也是客户端发送数据的报文段，所以既然第三次和第四次都是客户端，为了省了一个交互，客户端可以直接从第三个报文段（应答服务端ack）附上数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建立一个连接需要三次握手，而终止一个连接需要经过4次握手，这是由于TCP的半关闭（half close）造成的。既然一个TCP连接是全双工的（即数据在两个方向上能同时传递），因此每个方向必须单独地进行关闭。当一端收到一个FIN，它必须通知应用层另一端已经终止了那个方向的数据传送。发送FIN通常是应用层进行关闭的结果。比较常见的还是客户端关闭，但服务端也可以设置主动关闭，例如Nginx相关策略配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004221030476-555816362.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP终止连接需要四次握手，分别如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）、首先关闭的一方（即发送第一个FIN）将执行主动关闭，上图显示主动关闭的一方是客户端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）、当服务端收到这个FIN报文段时，它将发回一个ACK，确认序号为收到的序号加1，就像上图的ack=u+1，因为FIN跟SYN一样也占用一个序号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）、服务端把收到的FIN的消息告诉应用程序（传送一个文件结束符），接着这个应用程序就会关闭它的连接（以上提过，建立和关闭都是由应用主动发起的），导致服务端的TCP端发送一个FIN给客户端。需要注意的是，毕竟TCP是双工的，客户端关闭连接不代表服务端就可以立刻关闭，如果客户端发起关闭的时候，服务端还没有响应完数据给客户端，服务端还是需要把数据发完了再去关闭的，而客户端主动发起了闭关也不会立刻罢工，它还是会进入“FIN_WAIT2”状态进行数据接收，直到服务端发送完了并最后发送结束连接报文段（FIN），才进入TIME_WAIT状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）、客户端收到服务端的FIN报文段时，它会立刻对此FIN进行ACK回复，服务端收到后就直接进入关闭状态（CLOSED）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为TCP是全双工的，双方都各种维护自己单向传送数据的连接，所以必然会存在双方同时主动关闭的情况，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004221105336-245651435.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当双方同时向对方发送FIN执行主动连接时，双方均从ESTABLISHED状态变为FIN_WAIT_1状态。双方都收到FIN后，状态由FIN_WAIT_1变迁至CLOSING，并发送最后的ACK。当收到ACK时，双方的状态变为TIME_WAIT。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;TCP的状态迁变&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 通过以上建立和终止连接可以看到，无论客户端还是服务端，无论是连接方还是结束方都存在许多“状态”，每个状态随着各种条件不断变化，具体状态的迁变可以通过下图来进行总结。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004221203332-901064127.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2MSL等待状态&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;从上图迁变状态可以看到，TCP主动关闭的一方都会进入TIME_WAIT状态，也称为2MSL（最大报文段生存时间）等待状态。之所以要等待，是因为关闭方要确认处于“CLOSE_WAIT”状态的被关闭方收到它最后的ACK报文，报文的在网络上单向传送的最大时间叫做MSL，那么等待确认报文来回的时间就是2MSL，如果被关闭方在2MSL内都没有收到ACK，它会继续发送FIN报文，而如果关闭方在2MSL内没有收到对方的报文就默认对方已经收到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;报文在网络上的生存时间并不只有TCP决定的，在网络层的IP协议对数据报同样存在着网络单向传送的时间限制，这个限制的约定叫TTL（Time To Live）。TTL的时间单位并非时间单位，而是“跳数”，数据包每经过一个路由就叫“一跳”，不同系统对IP数据包的跳数初始值都不一样，例如有些Linux默认值是255。每经过一个路由，总生命跳数就减1，直到为0都还没有到达目的地就丢弃。255跳到底是多少秒呢？其实这都是一个不确定数字。如果一个数据包经过255个路由都还没到达目的地，我想目的地可能是“火星”。并TCP是“坐”在IP协议之上的，所以TCP的MSL肯定不能比TTL短，RFC793[Postel 1981c]指出MSL为2分钟。然而，实现中的常用值是30秒，1分钟或2分钟。要知道，0和1在光纤上传送的速度是“光速（约300000km/s）”，30秒的时间跑了不知道多少趟地球了，所以正常情况下都会大于TTL了（除非部分路由十分磨蹭）。如果做过一些高并发系统的同学，多少会遇到一些诸如time_wait过多的现象，例如WEB服务器配置主动关闭连接策略或连接有效时间短而主动关闭，大量的time_wait会占用文件描述符，而很容易导致耗光系统默认的1024个最大文件打开数（fs.file-max）而无法正常服务。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;同时打开和同时关闭&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 有时候TCP建立连接不一定必须是三次握手，有时可能会是4次。没错，当双发同时进行请求主动打开连接的时候就是4次，如下图所示。这个时候，并没有谁是客户端谁是服务端之称，因为双方都有主动发送数据的权利。这种情况应该很少见，如果需要模拟还是可以的，把双方的网速通过某些手段把它降低，那么就有可能演示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758472/201810/758472-20181004221300701-711335146.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;学习总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 本次总结更多是对TCP协议的一个基础了解，包括TCP建立连接的正常三次握手和十分罕见的同步建立连接的4次握手，以及关闭连接的正常4次握手和同步关闭连接导致双方都进入TIME_WAIT状态的4次握手。最后总体学习了TCP客户端以及服务端各种状态迁变的概要图，十分清晰地对TCP各种概况的描述，以及为什么会有TIME_WAIT和2MSL的概念。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 04 Oct 2018 14:28:00 +0000</pubDate>
<dc:creator>wc的一些事一些情</dc:creator>
<og:description>在计算机领域，数据的本质无非0和1，创造0和1的固然伟大，但真正百花齐放的还是基于0和1之上的各种层次之间的组合（数据结构）所带给我们人类各种各样的可能性。例如TCP协议，我们的生活无不无时无刻的站在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wcd144140/p/9743618.html</dc:identifier>
</item>
<item>
<title>获取fork+exec启动的程序的PID值 - zxzhang</title>
<link>http://www.cnblogs.com/ZhaoxiCheung/p/9742718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhaoxiCheung/p/9742718.html</guid>
<description>&lt;h2 id=&quot;问题背景&quot;&gt;问题背景&lt;/h2&gt;
&lt;p&gt;    业务中有个场景需要自动起一个A程序（由于A程序与 sublime_text 启动后遇到的问题有相似之处，后文就用 sublime_text 来替代A程序，当A程序与 sublime_text 的现象有所差异的时候，恢复使用 A 程序），并在适当的场景下杀死它，自然而然想到 fork + exec 的方式来启动它。但是启动后，在获取程序 pid 的时候却遇到了一点问题。以下是启动的代码：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;

int create_process(char *name, char *argv[])
{
    int pid = fork();
    if (0 == pid)
    {
        execv(name, argv);
        exit(127);
    }
    else if (0 &amp;lt; pid)
    {
        return pid;
    }else
    {
        return -1;
    }
}

int main()
{
    
    char *name = &quot;/opt/sublime_text/sublime_text&quot;;
    char *argv[] = {&quot;/opt/sublime_text/sublime_text&quot;, (char *)0};

    int pid = create_process(name, argv);
    printf(&quot;pid = %d\n&quot;,pid);

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序执行结果如下，从下图我们可以清晰的看到通过 fork + exec 启动的程序的 pid 与最后通过 ps进程查看器查询得到的 pid 是不一致的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/885804/201810/885804-20181004175044545-1374949479.png&quot;/&gt;&lt;br/&gt;尽管它们的 pid 值只差了1，但是这个结果还是让我感到非常疑惑。&lt;/p&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;问题分析&lt;/h2&gt;
&lt;p&gt;    一般的，在子进程中使用 exec 函数并不会改变子进程的 pid 值，而得到的结果确确实实改变了。一开始怀疑是与 pid 的分配方式有关，因为多次得到的结果其 pid 都只差1（有兴趣的可以自行了解 pid 位图分配策略），但没有太多的信息进行佐证，最后怀疑是要启动的程序的问题。&lt;br/&gt;    通过&lt;code&gt;strace&lt;/code&gt;来跟踪 sublime_text 进程中的系统调用：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/885804/201810/885804-20181004181118442-1353602232.png&quot;/&gt;&lt;br/&gt;从上面的结果我们可以看出，sublime_text 的真实 pid 与 strace得到的结果中 clone 一行的结果相对应。从这个信息中，我们可以发现 sublime_text 内部通过 clone 自己创建了一个子进程来启动程序。因此推测通过 fork 得到的子进程在完成自己的任务后就退出了，启动程序的事情交给了 sublime_text 内部通过 clone 起的子进程去做。&lt;/p&gt;
&lt;h2 id=&quot;问题解决&quot;&gt;问题解决&lt;/h2&gt;
&lt;p&gt;    从上面的问题分析得知，sublime_text 真实的 pid 是 clone 创建的子进程的 pid，而这个 clone 创建的子进程是 sublime_text 内部启动的。那么如何获取启动的程序的 pid 呢。一开始想到方法如下：在启动程序A之前，记录下环境中已启动的程序A的 pid，然后启动 count 个A程序，扣除掉之前记录的就是现在启动的（sublime_text 启动多次只有一个程序实例，而 A 程序启动多次有多个程序实例，因此此处恢复为A程序的描述）；但是这种方法存在极小概率会出错，环境并不是只有一个用户，也就是我在记录完环境中已有的程序A的 pid 后，启动 n 个程序A，此时如果有另一个用户也起了 m 个程序A，那么我就会认为这 n + m 个A程序都是我起的，后期杀死的时候破坏了他人启动的程序。因此这种方式并不适用，在论坛与人讨论后查找资论发现可以使用&lt;code&gt;ptrace&lt;/code&gt;来解决，其实也就是模拟&lt;code&gt;strace&lt;/code&gt;来跟踪进程中的系统调用。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#define _POSIX_C_SOURCE 200112L

/* C standard library */
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stddef.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

/* POSIX */
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/user.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;

/* Linux */
#include &amp;lt;syscall.h&amp;gt;
#include &amp;lt;sys/ptrace.h&amp;gt;

#define FATAL(...) \
    do { \
        fprintf(stderr, &quot;strace: &quot; __VA_ARGS__); \
        fputc('\n', stderr); \
        exit(EXIT_FAILURE); \
    } while (0)

int
main(int argc, char **argv)
{
    if (argc &amp;lt;= 1)
        FATAL(&quot;too few arguments: %d&quot;, argc);

    pid_t pid = fork();
    switch (pid) {
        case -1: /* error */
            FATAL(&quot;%s&quot;, strerror(errno));
        case 0:  /* child */
            ptrace(PTRACE_TRACEME, 0, 0, 0);
            execvp(argv[1], argv + 1);
            FATAL(&quot;%s&quot;, strerror(errno));
    }

    /* parent */
    waitpid(pid, 0, 0); // sync with PTRACE_TRACEME
    ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_EXITKILL);

    for (;;) {
        /* Enter next system call */
        if (ptrace(PTRACE_SYSCALL, pid, 0, 0) == -1)
            FATAL(&quot;%s&quot;, strerror(errno));
        if (waitpid(pid, 0, 0) == -1)
            FATAL(&quot;%s&quot;, strerror(errno));

        /* Gather system call arguments */
        struct user_regs_struct regs;
        if (ptrace(PTRACE_GETREGS, pid, 0, &amp;amp;regs) == -1)
            FATAL(&quot;%s&quot;, strerror(errno));
        long syscall = regs.orig_rax;

        /* Print a representation of the system call */
        fprintf(stderr, &quot;%ld(%ld, %ld, %ld, %ld, %ld, %ld)&quot;,
                syscall,
                (long)regs.rdi, (long)regs.rsi, (long)regs.rdx,
                (long)regs.r10, (long)regs.r8,  (long)regs.r9);

        /* Run system call and stop on exit */
        if (ptrace(PTRACE_SYSCALL, pid, 0, 0) == -1)
            FATAL(&quot;%s&quot;, strerror(errno));
        if (waitpid(pid, 0, 0) == -1)
            FATAL(&quot;%s&quot;, strerror(errno));

        /* Get system call result */
        if (ptrace(PTRACE_GETREGS, pid, 0, &amp;amp;regs) == -1) {
            fputs(&quot; = ?\n&quot;, stderr);
            if (errno == ESRCH)
                exit(regs.rdi); // system call was _exit(2) or similar
            FATAL(&quot;%s&quot;, strerror(errno));
        }

        /* Print system call result */
        fprintf(stderr, &quot; = %ld\n&quot;, (long)regs.rax);

        /*clone 系统调用号的特判
        if (56 == syscall){
            printf(&quot;%ld\n&quot;, (long)regs.rax);
        }
        */
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序的主体主要是关于&lt;code&gt;ptrace&lt;/code&gt;的用法，本文不对&lt;code&gt;ptrace&lt;/code&gt;的用法进行详细阐述，具体可参见文末资料。上述程序是一个小型的&lt;code&gt;strace&lt;/code&gt;，它将拦截所有的系统调用，并输出相应的信息，如果取消代码尾处对于 clone 系统调用号的特判的注释，那么其打印出来的信息，就是 sublime_text 的 pid，此时我们的问题也得到了解决。对于系统调用号，可在&lt;code&gt;/usr/include/x86_64-linux-gnu/asm/unistd_64.h&lt;/code&gt;查找，也可查看文末资料，此处针对64位机器。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/885804/201810/885804-20181004211302949-1248481893.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://filippo.io/linux-syscall-table/&quot;&gt;Searchable Linux Syscall Table for x86 and x86_64&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/skeeto/ptrace-examples&quot;&gt;ptrace-examples&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://recursiveg.me/2014/04/programming-with-ptrace-part2/&quot;&gt;Programming with PTRACE, Part2 - 系统调用入门&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.anquanke.com/post/id/149409&quot;&gt;使用 Ptrace 拦截和模拟 Linux 系统调用&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 04 Oct 2018 13:25:00 +0000</pubDate>
<dc:creator>zxzhang</dc:creator>
<og:description>问题背景     业务中有个场景需要自动起一个A程序（由于A程序与 sublime_text 启动后遇到的问题有相似之处，后文就用 sublime_text 来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZhaoxiCheung/p/9742718.html</dc:identifier>
</item>
<item>
<title>Flutter 布局详解 - Q吹个大气球Q</title>
<link>http://www.cnblogs.com/holy-loki/p/9735034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/holy-loki/p/9735034.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文主要介绍了Flutter布局相关的内容，对相关知识点进行了梳理，并从实际例子触发，进一步讲解该如何去进行布局。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;在介绍Flutter布局之前，我们得先了解Flutter中的一些布局相关的特性。&lt;/p&gt;
&lt;h3 id=&quot;边界约束box-constraints&quot;&gt;1.1 边界约束（box constraints）&lt;/h3&gt;
&lt;p&gt;box constraints有人也翻译为盒约束、箱约束，我个人还是觉得边界约束可能更直观一些。&lt;/p&gt;
&lt;p&gt;Flutter中的边界约束，是指widget可以按照指定限定条件，来决定自身如何占用布局空间。Flutter借鉴了很多React相关的东西，包括一些布局思想，但是它自身没有抽离出布局样式，而是用不同的widget去实现不同的布局，将样式嵌入widget中，用户可以像搭积木一样写布局，写法上跟React很像，只不过没了样式的设定。&lt;/p&gt;
&lt;p&gt;这样做的好处，我觉得可能是为了统一的渲染。加入样式，会让布局复杂不少，在渲染层面会降低很多性能。因此，Flutter在大的方向上，加入不同类型的布局widget。在小的方向上，只给出很少的定制化的东西，将布局限定在有限的范围内，在完成布局的同时，让整个渲染能够统一，加快了更新和渲染。&lt;/p&gt;
&lt;p&gt;但是，缺点也是同样明显，少了很多灵活性，不同的布局方式都被抽离出了widget，大家需要了解的widget非常多，增加了学习成本。&lt;/p&gt;
&lt;h3 id=&quot;约束种类&quot;&gt;1.2 约束种类&lt;/h3&gt;
&lt;p&gt;在Flutter中，widget是由其底层的RenderBox渲染，渲染边界的约束（Constraints）由父级给出，widget在这些约束下调整自身尺寸。约束包括最小最大宽高，尺寸则是具体的宽高。&lt;/p&gt;
&lt;p&gt;在Android中，布局的宽高限定有三种，match_parent、wrap_content以及具体尺寸。在Flutter中，也有这三种约束。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽可能大的约束，例如Center、ListView等；&lt;/li&gt;
&lt;li&gt;跟随内容大小的约束，例如Transform、Opacity等；&lt;/li&gt;
&lt;li&gt;指定尺寸的约束，例如Image、Text等；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，Flutter并没有把widget处理的这么绝对，这些约束条件包含在widget里，不像Android可以在外面去指定。因此，一些widget，例如Container，会根据参数的不同，约束条件也不同。Container默认是尽可能大的，但是给定尺寸的话，就会优先使用具体值。不同的widget可能设置条件不同、其子widget不同，约束条件也会不一样。Flutter将每种widget限制在不同的约束范围里，实际布局的时候，还需要综合去考虑。&lt;/p&gt;
&lt;h2 id=&quot;分类&quot;&gt;2. 分类&lt;/h2&gt;
&lt;p&gt;按照约束条件来分类，很多widget不太好区分开来，官方也是根据其子元素的个数来分类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单个子元素（child）的布局，包括Container、Padding等&lt;code&gt;18&lt;/code&gt;种（目前是2018年5月25日，后续我想肯定会增加的，下面类似）；&lt;/li&gt;
&lt;li&gt;多个子元素（children）的布局，包括Row、Column等&lt;code&gt;11&lt;/code&gt;种；&lt;/li&gt;
&lt;li&gt;layout helper，例如ListView.Builder，在元素多的时候，用这种方式更加的高效，类似Android的RecyclerView，有自动的回收机制。这种严格意义上不能算是一个种类，我觉得这种helper会越来越多。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;优缺点&quot;&gt;2.1 优缺点&lt;/h3&gt;
&lt;p&gt;其中日常中用的多的，例如Container、Padding、Center、Align、Row、Column、Stack、ListView等也有上十种。&lt;/p&gt;
&lt;p&gt;Flutter提供接近30多种不同的布局widget，还是源于其对widget的定位（在此处不再阐述，想了解的，可以翻看笔者之前文章的介绍）。对比其他移动端的开发平台，可以看出Flutter的布局widget是巨多，这也是为什么Flutter现在学习曲线很长的一个原因。&lt;/p&gt;
&lt;p&gt;先来说下优点，统一渲染，更新效率更高。但是，对于普通开发者而言，是不会去太在乎这些的。性能高本来就是平台应该提供的最基本的能力，难道不是你应该提供的吗？&lt;/p&gt;
&lt;p&gt;然后说下缺点吧，掌握起来还是非常费事的，布局起来也是挺蛋疼的。常规的布局还好，一到复杂的布局，觉得这个也能实现，那个也能实现，最后不知道哪个可以实现。&lt;/p&gt;
&lt;h3 id=&quot;个人看法&quot;&gt;2.2 个人看法&lt;/h3&gt;
&lt;p&gt;Flutter对于性能的优化，把平台侧的一些成本转接到开发者身上，不过呢，现在也是Flutter的初期，可以看出，整体的设计思路还是非常好的，也只有谷歌这种轮子大厂才敢这么干。但是，很明显少了些人为关怀，不同widget间约束条件穿插着，也可以说Flutter布局控件种类的增加，是其不断的打补丁导致的，后续的各种helper，也是为了填坑，这一块儿Flutter显然没有处理的很好。&lt;/p&gt;
&lt;p&gt;但是，凡事都有个过程，不能说Flutter这些地方做的不好，只是目前看起来比较混乱，理想的架构设计，落地下来，可能就不是那么简单，开发者的需求千差万别，有了生态，什么都好说，当然这个过程，预计是会非常的缓慢。&lt;/p&gt;

&lt;p&gt;在Flutter中，我们平时自定义的widget，一般都是继承自StatefulWidget或StatelessWidget（并不是只有这两种），这两种widget也是目前最常用的两种。如果一个控件自身状态不会去改变，创建了就直接显示，不会有色值、大小或者其他属性的变化，这种widget一般都是继承自StatelessWidget，常见的有Container、ScrollView等。如果一个控件需要动态的去改变或者相应一些状态，例如点击态、色值、内容区域等，那么一般都是继承自StatefulWidget，常见的有CheckBox、AppBar、TabBar等。其实单纯的从名字也可以看出这两种widget的区别，这两种widget都是继承自Widget类。&lt;/p&gt;
&lt;h3 id=&quot;widget类&quot;&gt;3.1 Widget类&lt;/h3&gt;
&lt;p&gt;Widget类在Flutter中是非常重要的，继承自Widget类的有PreferredSizeWidget、ProxyWidget、RenderObjectWidget、StatefulWidget、StatelessWidget。我们日常使用的绝大部分widget都是继承自Widget类，&lt;/p&gt;
&lt;p&gt;查看Widget类源码，内部实现非常简单，构造函数如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const Widget({ this.key });
final Key key;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个key的作用，注视上写的很清楚，是用来控制在widget树中替换widget的时候使用的。其中Key类是Widget、Element以及SemanticsNode的唯一标识符，继承自Key的还有LocalKey以及GlobalKey。&lt;/p&gt;
&lt;h3 id=&quot;state&quot;&gt;3.2 State&lt;/h3&gt;
&lt;p&gt;在说到StatefulWidget之前，先说下State。State的作用有两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在widget构建的时候可以被同步读取；&lt;/li&gt;
&lt;li&gt;在widget的生命周期中可能会被改变。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;state生命周期&quot;&gt;3.2.1 State生命周期&lt;/h4&gt;
&lt;p&gt;State的生命周期有四种状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;created：当State对象被创建时候，State.initState方法会被调用；&lt;/li&gt;
&lt;li&gt;initialized：当State对象被创建，但还没有准备构建时，State.didChangeDependencies在这个时候会被调用；&lt;/li&gt;
&lt;li&gt;ready：State对象已经准备好了构建，State.dispose没有被调用的时候；&lt;/li&gt;
&lt;li&gt;defunct：State.dispose被调用后，State对象不能够被构建。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://whysodiao.com/images/State%20LifeCycle.png&quot; alt=&quot;State LifeCycle&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整生命周期如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个State对象时，会调用StatefulWidget.createState；&lt;/li&gt;
&lt;li&gt;和一个BuildContext相关联，可以认为被加载了（mounted）；&lt;/li&gt;
&lt;li&gt;调用initState；&lt;/li&gt;
&lt;li&gt;调用didChangeDependencies；&lt;/li&gt;
&lt;li&gt;经过上述步骤，State对象被完全的初始化了，调用build；&lt;/li&gt;
&lt;li&gt;如果有需要，会调用didUpdateWidget；&lt;/li&gt;
&lt;li&gt;如果处在开发模式，热加载会调用reassemble；&lt;/li&gt;
&lt;li&gt;如果它的子树（subtree）包含需要被移除的State对象，会调用deactivate；&lt;/li&gt;
&lt;li&gt;调用dispose,State对象以后都不会被构建；&lt;/li&gt;
&lt;li&gt;当调用了dispose,State对象处于未加载（unmounted），已经被dispose的State对象没有办法被重新加载（remount）。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;setstate&quot;&gt;3.2.2 setState&lt;/h4&gt;
&lt;p&gt;State中比较重要的一个方法是&lt;code&gt;setState&lt;/code&gt;，当修改状态时，widget会被更新。比方说点击CheckBox，会出现选中和非选中状态之间的切换，就是通过修改状态来达到的。&lt;/p&gt;
&lt;p&gt;查看setState源码，在一些异常的情况下将会抛出异常：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传入的为null；&lt;/li&gt;
&lt;li&gt;处在defunct阶段；&lt;/li&gt;
&lt;li&gt;created阶段还没有被加载（mounted）；&lt;/li&gt;
&lt;li&gt;参数返回一个Future对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;检查完一系列异常后，最后调用代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_element.markNeedsBuild();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;markNeedsBuild内部，则是通过标记element为diry，在下一帧的时候重建（rebuild）。可以看出setState并不是立即生效，它只是将widget进行了标记，真正的rebuild操作，则是等到下一帧的时候才会去进行。&lt;/p&gt;
&lt;h3 id=&quot;statefulwidget和statelesswidget&quot;&gt;3.3 StatefulWidget和StatelessWidget&lt;/h3&gt;
&lt;p&gt;StatefulWidget和StatelessWidget如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://whysodiao.com/images/StatefulWidget%E5%92%8CStatelessWidget.png&quot; alt=&quot;StatefulWidget和StatelessWidget&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个StatelessWidget可以用多个不同的BuildContext构建，而一个StatefulWidget会为每个BuildContext创建一个State对象。&lt;/p&gt;
&lt;h4 id=&quot;statelesswidget&quot;&gt;3.3.1 StatelessWidget&lt;/h4&gt;
&lt;p&gt;对于StatelessWidget，build方法会在如下三种情况下调用，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;widget第一次被插入到树中；&lt;/li&gt;
&lt;li&gt;widget的父节点更改了配置（configuration）；&lt;/li&gt;
&lt;li&gt;widget依赖的InheritedWidget改变了。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;class GreenFrog extends StatelessWidget {
  const GreenFrog({ Key key }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return new Container(color: const Color(0xFF2DBD3A));
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;statefulwidget&quot;&gt;3.3.2 StatefulWidget&lt;/h4&gt;
&lt;p&gt;StatefulWidget的两个主要类别：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在initState中创建资源，在dispose中销毁，但是不依赖于InheritedWidget或者调用setState方法，这类widget基本上用在一个应用或者页面的root；&lt;/li&gt;
&lt;li&gt;使用setState或者依赖于InheritedWidget，这种在营业生命周期中会被重建（rebuild）很多次。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;class YellowBird extends StatefulWidget {
  const YellowBird({ Key key }) : super(key: key);

  @override
  _YellowBirdState createState() =&amp;gt; new _YellowBirdState();
}

class _YellowBirdState extends State&amp;lt;YellowBird&amp;gt; {
  @override
  Widget build(BuildContext context) {
    return new Container(color: const Color(0xFFFFE306));
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何布局&quot;&gt;4. 如何布局&lt;/h2&gt;
&lt;p&gt;每个页面设计都不一样，相同页面可选择的布局方式也不一样，如果单纯的说应该如何去布局，我觉得不现实，大家可以参考下&lt;a href=&quot;https://flutterchina.club/tutorials/layout/#common-layout-widgets&quot;&gt;Flutter官方的布局教程&lt;/a&gt;。接下来，笔者，通过一个简单的页面，来一步一步的拆解布局的流程。整个过程，基本上按照拆解、组件封装、具体布局这三步来的。&lt;/p&gt;
&lt;h3 id=&quot;拆解&quot;&gt;4.1 拆解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://whysodiao.com/images/combine%20layout.jpg&quot; alt=&quot;拆解&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;整体拆解&quot;&gt;4.1.1 整体拆解&lt;/h4&gt;
&lt;p&gt;根据设计图，可以看出整体时分行展示的，因此最外层是一个Column元素&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一行为标题，涉及到不对称的布局，可以用一个Stack或者Row来进行，用Row的话，则需要右边填上一个空白的widget占位。也可能会使用AppBar，将底部阴影去掉也能实现相同效果；&lt;/li&gt;
&lt;li&gt;第二行可以看作一个Row，分两块布局。右边部分，涉及到叠加，会考虑Stack；&lt;/li&gt;
&lt;li&gt;第三行比较复杂，整体看，也是一行一行进行展示的，因此最外层时一个Column。中间的文本部分需要根据个数自动换行，因此考虑使用Wrap。预习这个地方涉及到叠加，考虑Stack实现；&lt;/li&gt;
&lt;li&gt;第四行可以看作一个Row，分三块进行布局；&lt;/li&gt;
&lt;li&gt;第五行可以看作一个Row，分两块布局。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每一行之间的间隔，则可以考虑用Padding或者Container来设置。&lt;/p&gt;
&lt;p&gt;通过上面这样一步一步的分析后，基本上对大致的布局有了一个了解，最外层的控件大致选对（只要能实现的话，就是复杂度以及效率的问题），然后一步一步的拆解每一行的元素，如果有重复的或者觉得可以封装出来的部分，则进行下一步。&lt;/p&gt;
&lt;h4 id=&quot;局部拆解&quot;&gt;4.1.2 局部拆解&lt;/h4&gt;
&lt;p&gt;每一行的拆解，大致也是按照这个思路来进行，因此笔者在这里就不做讲解了。&lt;/p&gt;
&lt;h3 id=&quot;组件封装&quot;&gt;4.2 组件封装&lt;/h3&gt;
&lt;p&gt;例如上面，笔者想对第四行的这种展示进行封装，觉得今后的布局可能会用到，因此在这一步，可以先把这一块儿抽离出一个控件。利用Row的mainAxisAlignment以及Expanded来实现这种效果，具体的实现笔者不再详细的描述了。&lt;/p&gt;
&lt;p&gt;经过这一步，整体的规划设计图已经有了，各个组件也都有了，接下来的工作就是组装了。&lt;/p&gt;
&lt;h3 id=&quot;具体布局&quot;&gt;4.3 具体布局&lt;/h3&gt;
&lt;p&gt;具体布局设计到一些细节的地方，例如间隔（Padding或者Container）、居左居右居中（Align）、点击事件（GestureDetector）以及圆角（ClipRRect）等一些特殊情况，基本上就是嵌套，一层一层去实现。&lt;/p&gt;
&lt;p&gt;在实际布局中，笔者实际使用的是Scaffold，顶部的AppBar将阴影直接去掉即可实现效果，body部分则实现2-5行的内容。最外层套一个Column也能实现，本质上都没什么区别，运行效果图如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://whysodiao.com/images/device%20run.png&quot; alt=&quot;实际运行效果&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;4.4 代码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yang7229693/flutter-study&quot;&gt;代码Github地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;后话&quot;&gt;5. 后话&lt;/h2&gt;
&lt;p&gt;笔者建了一个flutter学习相关的项目，&lt;a href=&quot;https://github.com/yang7229693/flutter-study&quot;&gt;Github地址&lt;/a&gt;，里面包含了笔者写的关于flutter学习相关的一些文章，会定期更新，也会上传一些学习demo，欢迎大家关注。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;6. 参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://flutter.io/widgets/layout/&quot;&gt;Layout Widgets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://flutter.io/layout/&quot;&gt;Dealing with box constraints in Flutter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000011949751&quot;&gt;Flutter样式和布局控件简析(一)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.flutter.io/flutter/widgets/widgets-library.html&quot;&gt;widgets library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://flutterchina.club/tutorials/layout/#common-layout-widgets&quot;&gt;在Flutter中构建布局&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 04 Oct 2018 13:25:00 +0000</pubDate>
<dc:creator>Q吹个大气球Q</dc:creator>
<og:description>本文主要介绍了Flutter布局相关的内容，对相关知识点进行了梳理，并从实际例子触发，进一步讲解该如何去进行布局。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/holy-loki/p/9735034.html</dc:identifier>
</item>
<item>
<title>java线程池ThreadPoolExecutor类使用详解 - bigfan</title>
<link>http://www.cnblogs.com/dafanjoy/p/9729358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dafanjoy/p/9729358.html</guid>
<description>&lt;p&gt;在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。&lt;/p&gt;
&lt;p&gt;下面我们就对ThreadPoolExecutor的使用方法进行一个详细的概述。&lt;/p&gt;
&lt;p&gt;首先看下ThreadPoolExecutor的构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
                              &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
                              &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue&lt;/span&gt;&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (corePoolSize &amp;lt; 0 ||&lt;span&gt;
            maximumPoolSize &lt;/span&gt;&amp;lt;= 0 ||&lt;span&gt;
            maximumPoolSize &lt;/span&gt;&amp;lt; corePoolSize ||&lt;span&gt;
            keepAliveTime &lt;/span&gt;&amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workQueue == &lt;span&gt;null&lt;/span&gt; || threadFactory == &lt;span&gt;null&lt;/span&gt; || handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.acc = System.getSecurityManager() == &lt;span&gt;null&lt;/span&gt; ?
                &lt;span&gt;null&lt;/span&gt;&lt;span&gt; :
                AccessController.getContext();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.corePoolSize =&lt;span&gt; corePoolSize;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maximumPoolSize =&lt;span&gt; maximumPoolSize;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.workQueue =&lt;span&gt; workQueue;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.keepAliveTime =&lt;span&gt; unit.toNanos(keepAliveTime);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.threadFactory =&lt;span&gt; threadFactory;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handler =&lt;span&gt; handler;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造函数的参数含义如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;corePoolSize:指定了线程池中的线程数量，它的数量决定了添加的任务是开辟新的线程去执行，还是放到&lt;/strong&gt;workQueue任务队列中去；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;maximumPoolSize:指定了线程池中的最大线程数量，这个参数会根据你使用的&lt;/strong&gt;workQueue任务队列的类型，决定线程池会开辟的最大线程数量；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;keepAliveTime:当线程池中线程数量超过corePoolSize时，多余的线程会在多长时间内被销毁；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;unit:keepAliveTime的单位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;workQueue:任务队列，被添加到线程池中，但尚未被执行的任务；它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列几种；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;threadFactory:线程工厂，用于创建线程，一般用默认即可；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;handler:拒绝策略；当任务太多来不及处理时，如何拒绝任务；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我们对其中比较重要参数做进一步的了解：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、&lt;strong&gt;workQueue任务队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面我们已经介绍过了，&lt;strong&gt;它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;直接提交队列&lt;/strong&gt;：设置为SynchronousQueue队列，SynchronousQueue是一个特殊的BlockingQueue，它没有容量，没执行一个插入操作就会阻塞，需要再执行一个删除操作才会被唤醒，反之每一个删除操作也都要等待对应的插入操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPool {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService pool;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maximumPoolSize设置为2 ，拒绝策略为AbortPolic策略，直接抛出异常&lt;/span&gt;
        pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(),Executors.defaultThreadFactory(),&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor.AbortPolicy());
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;3;i++&lt;span&gt;) {
            readPool.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadTask());
        }   
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ThreadTask() {
        
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        System.out.println(Thread.currentThread().getName());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
pool-1-thread-1&lt;span&gt;
pool&lt;/span&gt;-1-thread-2&lt;span&gt;
Exception in thread &lt;/span&gt;&quot;main&quot; java.util.concurrent.RejectedExecutionException: Task com.hhxx.test.ThreadTask@55f96302 rejected from java.util.concurrent.ThreadPoolExecutor@3d4eac69[Running, pool size = 2, active threads = 0, queued tasks = 0, completed tasks = 2&lt;span&gt;]
    at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor.reject(Unknown Source)
    at java.util.concurrent.ThreadPoolExecutor.execute(Unknown Source)
    at com.hhxx.test.ThreadPool.main(ThreadPool.java:&lt;/span&gt;17)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，当任务队列为SynchronousQueue，创建的线程数大于maximumPoolSize时，直接执行了拒绝策略抛出异常。&lt;/p&gt;
&lt;p&gt;使用SynchronousQueue队列，提交的任务不会被保存，总是会马上提交执行。如果用于执行任务的线程数量小于maximumPoolSize，则尝试创建新的进程，如果达到maximumPoolSize设置的最大值，则根据你设置的handler执行拒绝策略。因此这种方式你提交的任务不会被缓存起来，而是会被马上执行，在这种情况下，你需要对你程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量，否则很容易就会执行拒绝策略；&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;有界的任务队列&lt;/strong&gt;：有界的任务队列可以使用ArrayBlockingQueue实现，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(10&lt;span&gt;),Executors.defaultThreadFactory(),&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.AbortPolicy());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用ArrayBlockingQueue有界任务队列，若有新的任务需要执行时，线程池会创建新的线程，直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，则继续创建线程，直到线程数量达到maximumPoolSize设置的最大线程数量，若大于maximumPoolSize，则执行拒绝策略。在这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界队列初始容量较大或者没有达到超负荷的状态，线程数将一直维持在corePoolSize以下，反之当任务队列已满时，则会以maximumPoolSize为最大线程数上限。&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;无界的任务队列&lt;/strong&gt;：有界任务队列可以使用LinkedBlockingQueue实现，如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(),Executors.defaultThreadFactory(),&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.AbortPolicy());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用无界任务队列，线程池的任务队列可以无限制的添加新的任务，而线程池创建的最大线程数量就是你corePoolSize设置的数量，也就是说在这种情况下maximumPoolSize这个参数是无效的，哪怕你的任务队列中缓存了很多未执行的任务，当线程池的线程数达到corePoolSize后，就不会再增加了；若后续有新的任务加入，则直接进入队列等待，当使用这种任务队列模式时，一定要注意你任务提交与处理之间的协调与控制，不然会出现队列中的任务由于无法及时处理导致一直增长，直到最后资源耗尽的问题。&lt;/p&gt;
&lt;p&gt;4&lt;strong&gt;、优先任务队列：&lt;/strong&gt;优先任务队列通过PriorityBlockingQueue实现，下面我们通过一个例子演示下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPool {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService pool;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;优先任务队列&lt;/span&gt;
        pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, &lt;span&gt;new&lt;/span&gt; PriorityBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(),Executors.defaultThreadFactory(),&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor.AbortPolicy());
          
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;20;i++&lt;span&gt;) {
            pool.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadTask(i));
        }    
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadTask &lt;span&gt;implements&lt;/span&gt; Runnable,Comparable&amp;lt;ThreadTask&amp;gt;&lt;span&gt;{
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; priority;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPriority() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; priority;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPriority(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; priority) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.priority =&lt;span&gt; priority;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ThreadTask() {
        
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ThreadTask(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; priority) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.priority =&lt;span&gt; priority;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前对象和其他对象做比较，当前优先级大就返回-1，优先级小就返回1,值越小优先级越高&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(ThreadTask o) {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;  &lt;span&gt;this&lt;/span&gt;.priority&amp;gt;o.priority?-1:1&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让线程阻塞，使后续任务进入缓存队列&lt;/span&gt;
            Thread.sleep(1000&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;priority:&quot;+&lt;span&gt;this&lt;/span&gt;.priority+&quot;,ThreadName:&quot;+&lt;span&gt;Thread.currentThread().getName());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }
    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来看下执行的结果情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
priority:0,ThreadName:pool-1-thread-1&lt;span&gt;
priority:&lt;/span&gt;9,ThreadName:pool-1-thread-1&lt;span&gt;
priority:&lt;/span&gt;8,ThreadName:pool-1-thread-1&lt;span&gt;
priority:&lt;/span&gt;7,ThreadName:pool-1-thread-1&lt;span&gt;
priority:&lt;/span&gt;6,ThreadName:pool-1-thread-1&lt;span&gt;
priority:&lt;/span&gt;5,ThreadName:pool-1-thread-1&lt;span&gt;
priority:&lt;/span&gt;4,ThreadName:pool-1-thread-1&lt;span&gt;
priority:&lt;/span&gt;3,ThreadName:pool-1-thread-1&lt;span&gt;
priority:&lt;/span&gt;2,ThreadName:pool-1-thread-1&lt;span&gt;
priority:&lt;/span&gt;1,ThreadName:pool-1-thread-1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家可以看到除了第一个任务直接创建线程执行外，其他的任务都被放入了优先任务队列，按优先级进行了重新排列执行，且线程池的线程数一直为corePoolSize，也就是只有一个。&lt;/p&gt;
&lt;p&gt;通过运行的代码我们可以看出PriorityBlockingQueue它其实是一个特殊的无界队列，它其中无论添加了多少个任务，线程池创建的线程数也不会超过corePoolSize的数量，只不过其他队列一般是按照先进先出的规则处理任务，而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、拒绝策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般我们创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列，但种模式下如果出现任务队列已满且线程池创建的线程数达到你设置的最大线程数时，这时就需要你指定ThreadPoolExecutor的RejectedExecutionHandler参数即合理的拒绝策略，来处理线程池&quot;超载&quot;的情况。ThreadPoolExecutor自带的拒绝策略如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、CallerRunsPolicy策略：如果线程池的线程数量达到上限，该策略会把任务队列中的任务放在调用者线程当中运行；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、DiscardOledestPolicy策略：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的，马上要被执行的那个任务，并尝试再次提交；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、DiscardPolicy策略：该策略会默默丢弃无法处理的任务，不予任何处理。当然使用此策略，业务场景中需允许任务的丢失；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上内置的策略均实现了&lt;/strong&gt;RejectedExecutionHandler接口，当然你也可以自己扩展RejectedExecutionHandler接口，定义自己的拒绝策略，我们看下示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPool {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService pool;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义拒绝策略&lt;/span&gt;
        pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(5&lt;span&gt;),
                Executors.defaultThreadFactory(), &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RejectedExecutionHandler() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
                System.out.println(r.toString()&lt;/span&gt;+&quot;执行了拒绝策略&quot;&lt;span&gt;);
                
            }
        });
          
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;) {
            pool.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadTask());
        }    
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让线程阻塞，使后续任务进入缓存队列&lt;/span&gt;
            Thread.sleep(1000&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;ThreadName:&quot;+&lt;span&gt;Thread.currentThread().getName());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }
    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;com.hhxx.test.ThreadTask@33909752执行了拒绝策略
com.hhxx.test.ThreadTask@55f96302执行了拒绝策略
com.hhxx.test.ThreadTask@3d4eac69执行了拒绝策略
ThreadName:pool&lt;/span&gt;-1-thread-2&lt;span&gt;
ThreadName:pool&lt;/span&gt;-1-thread-1&lt;span&gt;
ThreadName:pool&lt;/span&gt;-1-thread-1&lt;span&gt;
ThreadName:pool&lt;/span&gt;-1-thread-2&lt;span&gt;
ThreadName:pool&lt;/span&gt;-1-thread-1&lt;span&gt;
ThreadName:pool&lt;/span&gt;-1-thread-2&lt;span&gt;
ThreadName:pool&lt;/span&gt;-1-thread-1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到由于任务加了休眠阻塞，执行需要花费一定时间，导致会有一定的任务被丢弃，从而执行自定义的拒绝策略；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、ThreadFactory自定义线程创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 线程池中线程就是通过ThreadPoolExecutor中的ThreadFactory，线程工厂创建的。那么通过自定义ThreadFactory，可以按需要对线程池中创建的线程进行一些特殊的设置，如命名、优先级等，下面代码我们通过ThreadFactory对线程池中创建的线程进行记录与命名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPool {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService pool;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args )
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义线程工厂&lt;/span&gt;
        pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(2, 4, 1000, TimeUnit.MILLISECONDS, &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(5&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactory() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
                System.out.println(&lt;/span&gt;&quot;线程&quot;+r.hashCode()+&quot;创建&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程命名&lt;/span&gt;
                Thread th = &lt;span&gt;new&lt;/span&gt; Thread(r,&quot;threadPool&quot;+&lt;span&gt;r.hashCode());
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; th;
            }
        }, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor.CallerRunsPolicy());
          
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;) {
            pool.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadTask());
        }    
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出执行线程的名称&lt;/span&gt;
        System.out.println(&quot;ThreadName:&quot;+&lt;span&gt;Thread.currentThread().getName());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看下输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;线程118352462创建
线程1550089733创建
线程865113938创建
ThreadName:threadPool1550089733
ThreadName:threadPool118352462
线程1442407170创建
ThreadName:threadPool1550089733
ThreadName:threadPool1550089733
ThreadName:threadPool1550089733
ThreadName:threadPool865113938
ThreadName:threadPool865113938
ThreadName:threadPool118352462
ThreadName:threadPool1550089733
ThreadName:threadPool1442407170&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到线程池中，每个线程的创建我们都进行了记录输出与命名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、ThreadPoolExecutor扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor扩展主要是围绕beforeExecute()、afterExecute()和terminated()三个接口实现的，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、beforeExecute：线程池中任务运行前执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、afterExecute：线程池中任务运行完毕后执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、terminated：线程池退出后执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过这三个接口我们可以监控每个任务的开始和结束时间，或者其他一些功能。下面我们可以通过代码实现一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPool {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService pool;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main( String[] args ) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现自定义接口&lt;/span&gt;
        pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(2, 4, 1000, TimeUnit.MILLISECONDS, &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;Runnable&amp;gt;(5&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactory() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
                System.out.println(&lt;/span&gt;&quot;线程&quot;+r.hashCode()+&quot;创建&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程命名&lt;/span&gt;
                Thread th = &lt;span&gt;new&lt;/span&gt; Thread(r,&quot;threadPool&quot;+&lt;span&gt;r.hashCode());
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; th;
            }
        }, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor.CallerRunsPolicy()) {
    
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeExecute(Thread t,Runnable r) {
                System.out.println(&lt;/span&gt;&quot;准备执行：&quot;+&lt;span&gt; ((ThreadTask)r).getTaskName());
            }
            
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterExecute(Runnable r,Throwable t) {
                System.out.println(&lt;/span&gt;&quot;执行完毕：&quot;+&lt;span&gt;((ThreadTask)r).getTaskName());
            }
            
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; terminated() {
                System.out.println(&lt;/span&gt;&quot;线程池退出&quot;&lt;span&gt;);
            }
        };
          
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;) {
            pool.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ThreadTask(&quot;Task&quot;+&lt;span&gt;i));
        }    
        pool.shutdown();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadTask &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String taskName;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getTaskName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; taskName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTaskName(String taskName) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.taskName =&lt;span&gt; taskName;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ThreadTask(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setTaskName(name);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出执行线程的名称&lt;/span&gt;
        System.out.println(&quot;TaskName&quot;+&lt;span&gt;this&lt;/span&gt;.getTaskName()+&quot;---ThreadName:&quot;+&lt;span&gt;Thread.currentThread().getName());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我看下输出结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;线程118352462创建
线程1550089733创建
准备执行：Task0
准备执行：Task1
TaskNameTask0&lt;/span&gt;---&lt;span&gt;ThreadName:threadPool118352462
线程865113938创建
执行完毕：Task0
TaskNameTask1&lt;/span&gt;---&lt;span&gt;ThreadName:threadPool1550089733
执行完毕：Task1
准备执行：Task3
TaskNameTask3&lt;/span&gt;---&lt;span&gt;ThreadName:threadPool1550089733
执行完毕：Task3
准备执行：Task2
准备执行：Task4
TaskNameTask4&lt;/span&gt;---&lt;span&gt;ThreadName:threadPool1550089733
执行完毕：Task4
准备执行：Task5
TaskNameTask5&lt;/span&gt;---&lt;span&gt;ThreadName:threadPool1550089733
执行完毕：Task5
准备执行：Task6
TaskNameTask6&lt;/span&gt;---&lt;span&gt;ThreadName:threadPool1550089733
执行完毕：Task6
准备执行：Task8
TaskNameTask8&lt;/span&gt;---&lt;span&gt;ThreadName:threadPool1550089733
执行完毕：Task8
准备执行：Task9
TaskNameTask9&lt;/span&gt;---&lt;span&gt;ThreadName:threadPool1550089733
准备执行：Task7
执行完毕：Task9
TaskNameTask2&lt;/span&gt;---&lt;span&gt;ThreadName:threadPool118352462
TaskNameTask7&lt;/span&gt;---&lt;span&gt;ThreadName:threadPool865113938
执行完毕：Task7
执行完毕：Task2
线程池退出&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到通过对beforeExecute()、afterExecute()和terminated()的实现，我们对线程池中线程的运行状态进行了监控，在其执行前后输出了相关打印信息。另外使用shutdown方法可以比较安全的关闭线程池， 当线程池调用该方法后，线程池中不再接受后续添加的任务。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、线程池线程数量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程吃线程数量的设置没有一个明确的指标，根据实际情况，只要不是设置的偏大和偏小都问题不大，结合下面这个公式即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
             * Nthreads=CPU数量
             * Ucpu=目标CPU的使用率，0&amp;lt;=Ucpu&amp;lt;=1
             * W/C=任务等待时间与任务计算时间的比率
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            Nthreads &lt;/span&gt;= Ncpu*Ucpu*(1+W/C)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上就是对ThreadPoolExecutor类从构造函数、拒绝策略、自定义线程创建等方面介绍了其详细的使用方法，从而我们可以根据自己的需要，灵活配置和使用线程池创建线程，其中如有不足与不正确的地方还望指出与海涵。&lt;/p&gt;
</description>
<pubDate>Thu, 04 Oct 2018 13:05:00 +0000</pubDate>
<dc:creator>bigfan</dc:creator>
<og:description>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dafanjoy/p/9729358.html</dc:identifier>
</item>
<item>
<title>MathJax: 让前端支持数学公式 - GodBMW</title>
<link>http://www.cnblogs.com/geyouneihan/p/9743302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geyouneihan/p/9743302.html</guid>
<description>&lt;p&gt;&lt;strong&gt;文章图片存储在&lt;code&gt;GitHub&lt;/code&gt;，网速不佳的朋友，请看&lt;a href=&quot;https://godbmw.com/passage/61&quot;&gt;《MathJax：让前端支持数学公式》&lt;/a&gt; 或者 来我的技术小站 &lt;a href=&quot;https://godbmw.com/&quot;&gt;godbmw.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;必须要说&quot;&gt;1. 必须要说&lt;/h2&gt;
&lt;h3 id=&quot;开发背景&quot;&gt;1.1 开发背景&lt;/h3&gt;
&lt;p&gt;博主使用&lt;code&gt;Vue&lt;/code&gt;开发的&lt;a href=&quot;https://godbmw.com/&quot;&gt;个人博客&lt;/a&gt;，博文使用&lt;code&gt;markdown&lt;/code&gt;语法编写，然后交给前端渲染。为了更方便的进行说明和讲解，&lt;strong&gt;需要前端支持&lt;code&gt;LaTex&lt;/code&gt;的数学公式，并且渲染好看的样式&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;效果展示&quot;&gt;1.2 效果展示&lt;/h3&gt;
&lt;p&gt;数学公式分为行内公式和跨行公式，当然都需要支持和渲染。&lt;/p&gt;
&lt;p&gt;我准备了3条公式，分别是行内公式、跨行公式和超长的跨行公式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$\alpha+\beta=\gamma$

$$\alpha+\beta=\gamma$$

$$\int_{0}^{1}f(x)dx \sum_{1}^{2}\int_{0}^{1}f(x)dx \sum_{1}^{2}\int_{0}^{1}f(x)dx \sum_{1}^{2}\int_{0}^{1}f(x)dx \sum_{1}^{2}\int_{0}^{1}f(x)dx \sum_{1}^{2}\int_{0}^{1}f(x)dx \sum_{1}^{2}\int_{0}^{1}f(x)dx \sum_{1}^{2}\int_{0}^{1}f(x)dx \sum_{1}^{2}\int_{0}^{1}f(x)dx \sum_{1}^{2}\int_{0}^{1}f(x)dx \sum_{1}^{2}$$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这篇测试文章的地址是:&lt;a href=&quot;https://godbmw.com/passage/12&quot;&gt;&lt;code&gt;https://godbmw.com/passage/12&lt;/code&gt;&lt;/a&gt;。效果图如下所示：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%90%A5/MathJax%EF%BC%9A%E8%AE%A9%E5%89%8D%E7%AB%AF%E6%94%AF%E6%8C%81%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/1.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用mathjax&quot;&gt;2. 使用MathJax&lt;/h2&gt;
&lt;h3 id=&quot;引入cdn&quot;&gt;2.1 引入CDN&lt;/h3&gt;
&lt;p&gt;在使用MathJax之前，需要通过CDN引入, 在&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;标签中添加：&lt;br/&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;配置mathjax&quot;&gt;2.2 配置MathJax&lt;/h3&gt;
&lt;p&gt;将MathJax的配置封装成一个函数：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let isMathjaxConfig = false; // 防止重复调用Config，造成性能损耗

const initMathjaxConfig = () =&amp;gt; {
  if (!window.MathJax) {
    return;
  }
  window.MathJax.Hub.Config({
    showProcessingMessages: false, //关闭js加载过程信息
    messageStyle: &quot;none&quot;, //不显示信息
    jax: [&quot;input/TeX&quot;, &quot;output/HTML-CSS&quot;],
    tex2jax: {
      inlineMath: [[&quot;$&quot;, &quot;$&quot;], [&quot;\\(&quot;, &quot;\\)&quot;]], //行内公式选择符
      displayMath: [[&quot;$$&quot;, &quot;$$&quot;], [&quot;\\[&quot;, &quot;\\]&quot;]], //段内公式选择符
      skipTags: [&quot;script&quot;, &quot;noscript&quot;, &quot;style&quot;, &quot;textarea&quot;, &quot;pre&quot;, &quot;code&quot;, &quot;a&quot;] //避开某些标签
    },
    &quot;HTML-CSS&quot;: {
      availableFonts: [&quot;STIX&quot;, &quot;TeX&quot;], //可选字体
      showMathMenu: false //关闭右击菜单显示
    }
  });
  isMathjaxConfig = true; // 
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用mathjax渲染&quot;&gt;2.3 使用MathJax渲染&lt;/h3&gt;
&lt;p&gt;MathJax提供了&lt;code&gt;window.MathJax.Hub.Queue&lt;/code&gt;来执行渲染。在执行完文本获取操作后，进行渲染操作：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;if (isMathjaxConfig === false) { // 如果：没有配置MathJax
  initMathjaxConfig();
}

// 如果，不传入第三个参数，则渲染整个document
// 因为使用的Vuejs，所以指明#app，以提高速度
window.MathJax.Hub.Queue([&quot;Typeset&quot;, MathJax.Hub, document.getElementById('app')]);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改默认样式&quot;&gt;2.4 修改默认样式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MathJax&lt;/code&gt;默认样式在被鼠标&lt;code&gt;focus&lt;/code&gt;的时候，会有蓝色边框出现。对于超长的数学公式，x方向也会溢出。&lt;/p&gt;
&lt;p&gt;添加以下样式代码，覆盖原有样式，从而解决上述问题：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* MathJax v2.7.5 from 'cdnjs.cloudflare.com' */
.mjx-chtml {
  outline: 0;
}
.MJXc-display {
  overflow-x: auto;
  overflow-y: hidden;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;3. 注意事项&lt;/h2&gt;
&lt;h3 id=&quot;不要使用npm&quot;&gt;3.1 不要使用&lt;code&gt;npm&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;不要使用npm，会有报错，google了一圈也没找到解决方案，github上源码地址有对应的&lt;code&gt;issue&lt;/code&gt;还没解决&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;博主多次尝试也没有找到解决方法，坐等版本更新和大神指点。&lt;/p&gt;
&lt;h3 id=&quot;动态数据&quot;&gt;3.2 动态数据&lt;/h3&gt;
&lt;p&gt;在SPA单页应用中，数据是通过&lt;code&gt;Ajax&lt;/code&gt;获取的。此时，&lt;strong&gt;需要在数据获取后，再执行渲染&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果习惯&lt;code&gt;es5&lt;/code&gt;，可以在回调函数中调用&lt;code&gt;window.MathJax.Hub.Queue&lt;/code&gt;。但是更推荐&lt;code&gt;es6&lt;/code&gt;，配合&lt;code&gt;Promise&lt;/code&gt;和&lt;code&gt;async/await&lt;/code&gt;来避免“回调地域”。&lt;/p&gt;
&lt;h3 id=&quot;版本问题&quot;&gt;3.3 版本问题&lt;/h3&gt;
&lt;p&gt;对于不同版本或者不同CDN的&lt;code&gt;MathJax&lt;/code&gt;，第二部分的样式覆盖的&lt;code&gt;class&lt;/code&gt;名称不同。比如在&lt;code&gt;cdnboot&lt;/code&gt;的&lt;code&gt;v2.7.0&lt;/code&gt;版本中，样式覆盖的代码应该是下面这段：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* MathJax v2.7.0 from 'cdn.bootcss.com' */
.MathJax {
  outline: 0;
}
.MathJax_Display {
  overflow-x: auto;
  overflow-y: hidden;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;更多资料&quot;&gt;4. 更多资料&lt;/h2&gt;
</description>
<pubDate>Thu, 04 Oct 2018 12:33:00 +0000</pubDate>
<dc:creator>GodBMW</dc:creator>
<og:description>文章图片存储在 ，网速不佳的朋友，请看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geyouneihan/p/9743302.html</dc:identifier>
</item>
</channel>
</rss>