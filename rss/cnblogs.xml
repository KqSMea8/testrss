<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Netty Bootstrap（图解）|秒懂 - 疯狂创客圈</title>
<link>http://www.cnblogs.com/crazymakercircle/p/9998643.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crazymakercircle/p/9998643.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;&lt;span&gt;疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之18 【 &lt;span&gt;博客园 总入口&lt;/span&gt; 】&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;源码工程&quot;&gt;源码工程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;源码IDEA工程获取链接&lt;/strong&gt;：&lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;Java 聊天室 实战 源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;​ 大家好，我是作者尼恩。&lt;/p&gt;
&lt;p&gt;​ 今天是百万级流量 Netty 聊天器 打造的系列文章的第18篇，这是一个基础篇，介绍Bootstrap。&lt;/p&gt;
&lt;p&gt;​ 力争以图文并茂的形式，做到非常的易懂。&lt;/p&gt;
&lt;h2 id=&quot;图解几个重要概念&quot;&gt;图解几个重要概念&lt;/h2&gt;
&lt;p&gt;下面的几个概念，非常重要。&lt;/p&gt;
&lt;p&gt;之前没有认真介绍，下面图解说明一下。&lt;/p&gt;
&lt;h3 id=&quot;父子-channel&quot;&gt;父子 channel&lt;/h3&gt;
&lt;p&gt;​ 在 Netty 中, Channel 是一个 Socket 连接的抽象, 它为用户提供了关于底层 Socket 状态(是否是连接还是断开) 以及对 Socket 的读写等操作。&lt;/p&gt;
&lt;p&gt;​ 每当 Netty 建立了一个连接后, 都会有一个对应的 Channel 实例。&lt;/p&gt;
&lt;p&gt;​ 并且，有父子channel 的概念。 服务器连接监听的channel ，也叫 parent channel。 对应于每一个 Socket 连接的channel，也叫 child channel。&lt;/p&gt;
&lt;h3 id=&quot;eventloop-线程与线程组&quot;&gt;EventLoop 线程与线程组&lt;/h3&gt;
&lt;p&gt;在看本文之前，如果不明白 reactor 线程和reactor模式，请 查看 疯狂创客圈的专门文章：&lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9833847.html&quot;&gt;Reactor模式&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;在Netty 中，每一个 channel 绑定了一个thread 线程。&lt;/p&gt;
&lt;p&gt;一个 thread 线程，封装到一个 EventLoop ， 多个EventLoop ，组成一个线程组 EventLoopGroup。&lt;/p&gt;
&lt;p&gt;反过来说，EventLoop 这个相当于一个处理线程，是Netty接收请求和处理IO请求的线程。 EventLoopGroup 可以理解为将多个EventLoop进行分组管理的一个类，是EventLoop的一个组。&lt;/p&gt;
&lt;p&gt;他们的对应关系，大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181121232904955.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通道与reactor线程组&quot;&gt;通道与Reactor线程组&lt;/h3&gt;
&lt;p&gt;​ 这里主要是涉及的是服务器端。&lt;/p&gt;
&lt;p&gt;​ 服务器端，一般有设置两个线程组，监听连接的 parent channel 工作在一个独立的线程组，这里名称为boss线程组（有点像负责招人的包工头）。&lt;/p&gt;
&lt;p&gt;​ 连接成功后，负责客户端连接读写的 child channel 工作在另一个线程组，这里名称为 worker 线程组，专门负责搬数据（有点儿像搬砖）。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181121232932923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;channel-通道的类型&quot;&gt;Channel 通道的类型&lt;/h3&gt;
&lt;p&gt;​ 除了 TCP 协议以外, Netty 还支持很多其他的连接协议, 并且每种协议还有 NIO(异步 IO) 和 OIO(Old-IO, 即传统的阻塞 IO) 版本的区别。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;不同协议不同的阻塞类型的连接都有不同的 Channel 类型与之对应，下面是一些常用的 Channel 类型:&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;NioSocketChannel, 代表异步的客户端 TCP Socket 连接.&lt;/li&gt;
&lt;li&gt;NioServerSocketChannel, 异步的服务器端 TCP Socket 连接.&lt;/li&gt;
&lt;li&gt;NioDatagramChannel, 异步的 UDP 连接&lt;/li&gt;
&lt;li&gt;NioSctpChannel, 异步的客户端 Sctp 连接.&lt;/li&gt;
&lt;li&gt;NioSctpServerChannel, 异步的 Sctp 服务器端连接.&lt;/li&gt;
&lt;li&gt;OioSocketChannel, 同步的客户端 TCP Socket 连接.&lt;/li&gt;
&lt;li&gt;OioServerSocketChannel, 同步的服务器端 TCP Socket 连接.&lt;/li&gt;
&lt;li&gt;OioDatagramChannel, 同步的 UDP 连接&lt;/li&gt;
&lt;li&gt;OioSctpChannel, 同步的 Sctp 服务器端连接.&lt;/li&gt;
&lt;li&gt;OioSctpServerChannel, 同步的客户端 TCP Socket 连接.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;启动器初步介绍&quot;&gt;启动器初步介绍&lt;/h2&gt;
&lt;p&gt;Bootstrap 是 Netty 提供的一个便利的工厂类，可以通过它来完成 Netty 的客户端或服务器端的 Netty 初始化。&lt;/p&gt;
&lt;p&gt;当然，Netty 的官方解释说，可以不用这个启动器。&lt;/p&gt;
&lt;p&gt;但是，一点点去手动创建channel 并且完成一些的设置和启动，会非常麻烦。还是使用这个便利的工具类，会比较好。&lt;/p&gt;
&lt;p&gt;有两个启动器，分别应用在服务器和客户端。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201811212329558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个启动器大致的配置，都是相同的。&lt;/p&gt;
&lt;p&gt;下面以服务器serverBootstrap 启动类为主要的介绍对象。&lt;/p&gt;
&lt;h2 id=&quot;图解-bootstrap执行流程&quot;&gt;图解 Bootstrap执行流程&lt;/h2&gt;
&lt;p&gt;​ 首先，创建了一个引导器 ServerBootstrap 实例，这个专门用于引导服务端的启动工作，直接new 创建即可。（客户端的引导器差不多，不过是创建Bootstrap 实例）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 启动引导器
private static ServerBootstrap b = new ServerBootstrap();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 启动一个Bootstrap，大致有8步，如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181121233015647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    try {   //1 设置reactor 线程
            b.group(bossLoopGroup, workerLoopGroup);
            //2 设置nio类型的channel
            b.channel(NioServerSocketChannel.class);
            //3 设置监听端口
            b.localAddress(new InetSocketAddress(port));
            //4 设置通道选项
            b.option(ChannelOption.SO_KEEPALIVE, true);
            b.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);

            //5 装配流水线
            b.childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;()
            {
                //有连接到达时会创建一个channel
                protected void initChannel(SocketChannel ch) throws Exception
                {
                    ch.pipeline().addLast(new ProtobufDecoder());
                    ch.pipeline().addLast(new ProtobufEncoder());
                    // pipeline管理channel中的Handler
                    // 在channel队列中添加一个handler来处理业务
                    ch.pipeline().addLast(&quot;serverHandler&quot;, serverHandler);
                }
            });
            // 6 开始绑定server
            // 通过调用sync同步方法阻塞直到绑定成功

            ChannelFuture channelFuture = b.bind().sync();
            LOGGER.info(ChatServer.class.getName() +
                    &quot; started and listen on &quot; + 
                    channelFuture.channel().localAddress());

            // 7 监听通道关闭事件
            // 应用程序会一直等待，直到channel关闭
            ChannelFuture closeFuture=  channelFuture.channel().closeFuture();
            closeFuture.sync();
        } catch (Exception e)
        {
            e.printStackTrace();
        } finally
        {
            // 8 优雅关闭EventLoopGroup，
            // 释放掉所有资源包括创建的线程
            workerLoopGroup.shutdownGracefully();
            bossLoopGroup.shutdownGracefully();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;strong&gt;接下来就是精彩的8个步骤&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;设置reactor-线程组&quot;&gt;1：设置reactor 线程组&lt;/h3&gt;
&lt;p&gt;​ 在设置 reactor 反应器线程组之前，创建了两个 NioEventLoopGroup 线程组：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;bossLoopGroup 表示服务器连接监听线程组，专门接受 accept 新的客户端client 连接&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;workerGroup 表示处理每一条连接的数据收发的线程组&lt;/p&gt;
&lt;p&gt;在线程组和启动器都创建完成后，就可以开始设置线程组：通过 b.group(bossGroup, workerGroup) 方法，给引导器配置两大线程组。&lt;/p&gt;
&lt;p&gt;配置完成之后，整个引导类的 reactor 线程正式确定。这里确定的工作模式，为父子线程的模型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;也可以不设置两个线程组，只设置一个线程组。&lt;/p&gt;
&lt;p&gt;如果只设置一个线程组，具体的方法为 —— b.group( workerGroup) 。&lt;/p&gt;
&lt;p&gt;配置完成一个线程组，则所有的 channel ，包括服务监听通道父亲channel 和所有的子channel ，都工作在同一个线程组中。&lt;/p&gt;
&lt;p&gt;说明一下，一个线程组，可不止一条线程哈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018112123303877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置通道的io类型&quot;&gt;2 ：设置通道的IO类型&lt;/h3&gt;
&lt;p&gt;Netty 不止支持 Java NIO ，也支持阻塞式的 BIO （在Netty 中 叫做OIO）。&lt;/p&gt;
&lt;p&gt;这里配置的是NIO，方法如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//2 设置nio类型的channel
b.channel(NioServerSocketChannel.class);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想指定 IO 模型为 BIO，那么这里配置上Netty的 OioServerSocketChannel.class 类型即可。由于NIO 的优势巨大，通常不会在Netty中使用BIO。&lt;/p&gt;
&lt;h3 id=&quot;设置监听端口&quot;&gt;3：设置监听端口&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; //3 设置监听端口
 b.localAddress(new InetSocketAddress(port));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是最为简单的一步操作。&lt;/p&gt;
&lt;h3 id=&quot;设置通道参数&quot;&gt;4：设置通道参数&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;childOption() 方法&lt;/p&gt;
&lt;p&gt;给每条child channel 连接设置一些TCP底层相关的属性，比如上面，我们设置了两种TCP属性，其中 ChannelOption.SO_KEEPALIVE表示是否开启TCP底层心跳机制，true为开&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;option() 方法&lt;/p&gt;
&lt;p&gt;对于server bootstrap而言，这个方法，是给parent channel 连接设置一些TCP底层相关的属性。&lt;/p&gt;
&lt;p&gt;TCP连接的参数详细介绍如下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;option设置的参数&quot;&gt;option设置的参数：&lt;/h3&gt;
&lt;p&gt;SO_RCVBUF ，SO_SNDBUF&lt;/p&gt;
&lt;p&gt;这两个选项就是来设置TCP连接的两个buffer尺寸的。&lt;/p&gt;
&lt;p&gt;每个TCP socket在内核中都有一个发送缓冲区和一个接收缓冲区，TCP的全双工的工作模式以及TCP的滑动窗口便是依赖于这两个独立的buffer以及此buffer的填充状态。&lt;/p&gt;
&lt;p&gt;SO_SNDBUF&lt;br/&gt;  Socket参数，TCP数据发送缓冲区大小。该缓冲区即TCP发送滑动窗口，linux操作系统可使用命令：cat /proc/sys/net/ipv4/tcp_smem 查询其大小。&lt;/p&gt;
&lt;p&gt;TCP_NODELAY&lt;br/&gt;  TCP参数，立即发送数据，默认值为Ture（Netty默认为True而操作系统默认为False）。该值设置Nagle算法的启用，改算法将小的碎片数据连接成更大的报文来最小化所发送的报文的数量，如果需要发送一些较小的报文，则需要禁用该算法。Netty默认禁用该算法，从而最小化报文传输延时。&lt;/p&gt;
&lt;p&gt;​ 这个参数，与是否开启Nagle算法是反着来的，true表示关闭，false表示开启。通俗地说，如果要求高实时性，有数据发送时就马上发送，就关闭，如果需要减少发送次数减少网络交互，就开启。&lt;/p&gt;
&lt;p&gt;SO_KEEPALIVE&lt;br/&gt;  底层TCP协议的心跳机制。Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。可以将此功能视为TCP的心跳机制，需要注意的是：默认的心跳间隔是7200s即2小时。Netty默认关闭该功能。&lt;/p&gt;
&lt;p&gt;SO_REUSEADDR&lt;br/&gt;  Socket参数，地址复用，默认值False。有四种情况可以使用：&lt;br/&gt;(1).当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你希望启动的程序的socket2要占用该地址和端口，比如重启服务且保持先前端口。&lt;br/&gt;(2).有多块网卡或用IP Alias技术的机器在同一端口启动多个进程，但每个进程绑定的本地IP地址不能相同。&lt;br/&gt;(3).单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。(4).完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。&lt;/p&gt;
&lt;p&gt;SO_LINGER&lt;br/&gt;  Socket参数，关闭Socket的延迟时间，默认值为-1，表示禁用该功能。-1表示socket.close()方法立即返回，但OS底层会将发送缓冲区全部发送到对端。0表示socket.close()方法立即返回，OS放弃发送缓冲区的数据直接向对端发送RST包，对端收到复位错误。非0整数值表示调用socket.close()方法的线程被阻塞直到延迟时间到或发送缓冲区中的数据发送完毕，若超时，则对端会收到复位错误。&lt;/p&gt;
&lt;p&gt;SO_BACKLOG&lt;br/&gt;  Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。&lt;/p&gt;
&lt;pre class=&quot;//如下设置&quot;&gt;
&lt;code&gt; b.option(ChannelOption.SO_BACKLOG, 1024) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示系统用于临时存放已完成三次握手的请求的队列的最大长度，如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数.&lt;/p&gt;
&lt;p&gt;SO_BROADCAST&lt;br/&gt;  Socket参数，设置广播模式。&lt;/p&gt;
&lt;h3 id=&quot;装配流水线&quot;&gt;5: 装配流水线&lt;/h3&gt;
&lt;p&gt;​ ChannelPipeline 这是Netty处理请求的责任链，这是一个ChannelHandler的链表，而ChannelHandler就是用来处理网络请求的内容的。&lt;/p&gt;
&lt;p&gt;​ 每一个channel ，都有一个处理器流水线。&lt;/p&gt;
&lt;p&gt;​ 装配 child channel 流水线，调用 childHandler()方法，传递一个ChannelInitializer 的实例。&lt;/p&gt;
&lt;p&gt;​ 在 child channel 创建成功，开始通道初始化的时候，在bootstrap启动器中配置的 ChannelInitializer 实例就会被调用。&lt;/p&gt;
&lt;p&gt;​ 这个时候，才真正的执行去执行 initChannel 初始化方法，开始通道流水线装配。&lt;/p&gt;
&lt;p&gt;​ 流水线装配，主要是在流水线pipeline 的后面，增加负责数据读写、处理业务逻辑的handler。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; b.childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;()
            {
                //有连接到达时会创建一个channel
                protected void initChannel(SocketChannel ch) throws Exception
                {
                    ch.pipeline().addLast(new ProtobufDecoder());
                    ch.pipeline().addLast(new ProtobufEncoder());
                    // pipeline管理channel中的Handler
                    // 在channel队列中添加一个handler来处理业务
                    ch.pipeline().addLast(&quot;serverHandler&quot;, serverHandler);
                }
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明一下，ChannelInitializer这个类中，有一个泛型参数 SocketChannel，这里的类型，需要和前面的Channel类型对应上。&lt;/p&gt;
&lt;p&gt;顺便说一下处理器。&lt;/p&gt;
&lt;p&gt;处理器 ChannelHandler 用来处理网络请求内容，有ChannelInboundHandler和ChannelOutboundHandler两种，ChannlPipeline会从头到尾顺序调用ChannelInboundHandler处理网络请求内容，从尾到头调用ChannelOutboundHandler 处理网络请求内容。&lt;/p&gt;
&lt;p&gt;pipeline 流水线的图，大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180330-154727.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何装配parent 通道呢？&lt;/p&gt;
&lt;p&gt;使用serverBootstrap.handler() 方法 。 handler()方法，可以和前面分析的childHandler()方法对应起来。childHandler()用于指定处理新连接数据的读写处理逻辑。 handler()方法装配parent 通道。&lt;/p&gt;
&lt;p&gt;比方说：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;serverBootstrap.handler(new ChannelInitializer() 
 { 
    protected void initChannel(NioServerSocketChannel ch) 
    {
        System.out.println(&quot;服务端启动中&quot;); 
     } 
 }
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;handler()用于指定在服务端启动过程中的一些逻辑，通常情况下呢，我们用不着这个方法。&lt;/p&gt;
&lt;h3 id=&quot;开始绑定server&quot;&gt;6： 开始绑定server&lt;/h3&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 通过调用sync同步方法阻塞直到绑定成功
    ChannelFuture channelFuture = b.bind().sync();
        LOGGER.info(ChatServer.class.getName() +
                &quot; started and listen on &quot; + 
                channelFuture.channel().localAddress());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个也很简单。&lt;/p&gt;
&lt;h3 id=&quot;channelfuture&quot;&gt;7： ChannelFuture&lt;/h3&gt;
&lt;p&gt;ChannelFuture 在Netty中的所有的I/O操作都是异步执行的，这就意味着任何一个I/O操作会立刻返回，不保证在调用结束的时候操作会执行完成。因此，会返回一个ChannelFuture的实例，通过这个实例可以获取当前I/O操作的状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            // 7 监听通道关闭事件
            // 应用程序会一直等待，直到channel关闭
            ChannelFuture closeFuture=  channelFuture.channel().closeFuture();
            closeFuture.sync();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于客户端来说，Bootstrap是开发netty客户端的基础,通过Bootstrap的connect方法来连接服务器端。该方法返回的也是ChannelFuture。&lt;/p&gt;
&lt;h3 id=&quot;优雅关闭eventloopgroup&quot;&gt;8 优雅关闭EventLoopGroup&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        // 8 优雅关闭EventLoopGroup，
        // 释放掉所有资源包括创建的线程
        workerLoopGroup.shutdownGracefully();
        bossLoopGroup.shutdownGracefully();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个，会关闭所有的child channel，这是非常重要的。&lt;/p&gt;
&lt;p&gt;关闭之后，会释放掉底层的资源，如TCP Socket 文件描述符，等等。&lt;/p&gt;
&lt;h2 id=&quot;疯狂创客圈-java-死磕系列&quot;&gt;疯狂创客圈 Java 死磕系列&lt;/h2&gt;
&lt;ul readability=&quot;-0.85082872928177&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Java (Netty) 聊天程序【 亿级流量】实战 开源项目实战&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Netty 源码、原理、JAVA NIO 原理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java 面试题 一网打尽&lt;/strong&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.37209302325581&quot;&gt;
&lt;p&gt;疯狂创客圈 &lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;&lt;strong&gt;【 博客园 总入口 】&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;</description>
<pubDate>Wed, 21 Nov 2018 15:34:00 +0000</pubDate>
<dc:creator>疯狂创客圈</dc:creator>
<og:description>Netty Bootstrap（图解） 疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之18 【 博客园 总入口 】 [toc] 源码工程 源码IDEA工程获取链接 ：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crazymakercircle/p/9998643.html</dc:identifier>
</item>
<item>
<title>深入浅出Android单元测试（一）：单元测试基础 - 程序引力</title>
<link>http://www.cnblogs.com/chengxuyinli/p/9998637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxuyinli/p/9998637.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/21/5bf57844a4872.jpg&quot; alt=&quot;安卓机器人&quot;/&gt;&lt;br/&gt;想学习单元测试无从下手，本文对以最易懂的方式介绍单元测试。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;若有错漏，烦请斧正。转载请注明出处。欢迎关注程序引力&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作者：程序引力 | 谢一 （Evan Xie）&lt;/li&gt;
&lt;li&gt;邮箱：evanyixie@gmail.com&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;软件测试作为软件质量的保障，有着十分重要的意义。按照不同的层次划分，测试也有着诸多的种类。按照测试方式分，有白盒测试、黑盒测试、灰盒测试。按照测试范围或流程来分，有单元测试、集成测试与系统测试等。其中，应用覆盖面最广、也是最为基础的就是单元测试。&lt;/p&gt;
&lt;h3 id=&quot;何为单元测试&quot;&gt;何为单元测试&lt;/h3&gt;
&lt;p&gt;单元测试（Unit Test）又被称为模块测试，是针对程序中最小可测试单元来进行测试的活动。一般来讲，在如今的软件开发工程中，是指对程序中方法（或称函数）的测试。通过为这个方法构造初始化的条件，并运行这个方法，看这个方法的行为是否与预期的一致，以此来决定该方法是否正常。&lt;/p&gt;
&lt;h3 id=&quot;单元测试的意义&quot;&gt;单元测试的意义&lt;/h3&gt;
&lt;h4 id=&quot;快速定位问题&quot;&gt;快速定位问题&lt;/h4&gt;
&lt;p&gt;单元测试的主要作用，就是将原本人工检查程序行为的方式，在最小可测单元范围内，用程序检测程序的方法来代替。为此，单元测试的主要作用就是定位问题。同时，由于单元测试的执行效率较高，可以大批量快速执行。这对于对于单元测试覆盖率较高的工程，若代码工程有任何问题，则可以快速执行全部单元测试，能够帮助开发者快速定位或排除问题。&lt;/p&gt;
&lt;h4 id=&quot;持续集成&quot;&gt;持续集成&lt;/h4&gt;
&lt;p&gt;目前的软件交付要求快速迭代与持续集成，在这样的团队中每一天都有代码合入，并且定期都会有新版本发布。在这一过程中，若使用单元测试覆盖软件各部分，在开发与集成的过程中不对代码进行测试，发现问题就立即告警，则可以提高软件质量与开发效率。&lt;/p&gt;
&lt;h4 id=&quot;优化软件设计与架构&quot;&gt;优化软件设计与架构&lt;/h4&gt;
&lt;p&gt;单元测试并不是在代码开发完毕才开始撰写的，一般情况下都是与开发过程并行或者先与开发过程的。在这个过程中，为了构造可测试的接口与参数，自然会让开发者在软件设计时让程序趋于模块化，并且接口明确，层次清晰。这也就在无形中优化了软件的设计与架构。&lt;/p&gt;
&lt;h4 id=&quot;重构的保障&quot;&gt;重构的保障&lt;/h4&gt;
&lt;p&gt;在重构代码时，可能会影响既有业务和功能，常常会为了解决一个问题而不慎引入更多问题。若有单元测试的覆盖，在重构时则有所保障，能够帮助开发者快速发现问题，提高重构效率。&lt;/p&gt;
&lt;h3 id=&quot;单元测试思路&quot;&gt;单元测试思路&lt;/h3&gt;
&lt;p&gt;开发者在未接触单元测试之前，往往无从下手。其实，单元测试代码的开发与普通程序的开发没有本质的差别。它的核心逻辑是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确认待测试的方法或对象&lt;/li&gt;
&lt;li&gt;为待测试的方法构造初始化条件&lt;/li&gt;
&lt;li&gt;调用（运行）该测试方法&lt;/li&gt;
&lt;li&gt;比较被测试方法的行为（结果）与预期的是否一致&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过这样一个模板或思路去理解单元测试，那就非常简单了。在现行的软件测试实践中，为了提高测试代码的开发效率，业界有着许多测试框架，利用这些测试框架，可以帮助开发者快速开发测试代码。为此，在进行单元测试前，需要根据自身的情况，对单元测试框架做一定的学习。但不管测试框架是怎样的，其核心思路都与上文讨论的一致。&lt;/p&gt;
&lt;h3 id=&quot;单元测试原则&quot;&gt;单元测试原则&lt;/h3&gt;
&lt;p&gt;单元测试原则常被概括为：FIRST，分别是：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;快速（Fast）&lt;br/&gt;单元测试应该能够被快速地执行完毕，执行效率低会让开发者不愿意运行。同时，单元测试需要在整个开发过程中执行很多次，过慢的运行速度会影响开发效率&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;用例独立（Independent）:&lt;br/&gt;单元测试用例之间应该相互独立，最好不要有关联，也不要有执行顺序的要求。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可重复（Repeatable）：&lt;br/&gt;单元测试不应该依赖于环境中的数据，它应该有自己的初始化数据或条件，每一次单元测试都是可重复的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可自验证的（Self-Validating）：&lt;br/&gt;单元测试应该不用人工检查，而是可以自验证的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;全面完整的（Thorough）：&lt;br/&gt;单元测试不应该追求每一个方法都覆盖到，而是应该追求所有的使用场景都全面完整的覆盖到。例如对边界条件，错误输入，大数据量的情况都要覆盖到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;android单元测试分类&quot;&gt;Android单元测试分类&lt;/h3&gt;
&lt;p&gt;按照单元测试运行的环境区分，可以分为本地测试以及设备测试.&lt;/p&gt;
&lt;h4 id=&quot;本地测试&quot;&gt;本地测试&lt;/h4&gt;
&lt;p&gt;本地测试(Local unit test)运行在JVM中，一般适用于对于没有Android依赖的测试。该部分测试代码一般放置于安卓工程的&amp;lt;模块名&amp;gt;/src/test/java中。&lt;/p&gt;
&lt;h4 id=&quot;设备测试&quot;&gt;设备测试&lt;/h4&gt;
&lt;p&gt;设备测试（Instrumented test)运行在手机或模拟器中，一般适用于需要Android依赖的测试。该部分测试代码一般放置于安卓工程的&amp;lt;模块名&amp;gt;/src/androidTest/java中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：测试代码直接支持对Android的依赖。&lt;/li&gt;
&lt;li&gt;缺点：需要真机或模拟器配合，运行速度较本地测试稍慢。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，在这类测试过程中是编译了一个额外的Apk，并安装到手机或模拟器中运行的。&lt;/p&gt;
&lt;h3 id=&quot;测试框架选择&quot;&gt;测试框架选择&lt;/h3&gt;
&lt;p&gt;目前流行的Android测试框架较多，按照对Android依赖的强弱情况，可以分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无依赖：JUnit&lt;/li&gt;
&lt;li&gt;弱依赖：AndroidJUnitRunner、Mockito&lt;/li&gt;
&lt;li&gt;强依赖：Espresso&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;开发者可以根据自身情况来对测试框架进行选择，若仅仅测试无安卓依赖的Java代码，可以仅仅使用JUnit框架。若待测试的代码对安卓库有一定的弱依赖，则可以选择AndroidJUnitRunner、Mockito。若待测试代码对安卓库有着非常强的依赖，可以选择Espresso。&lt;/p&gt;
&lt;p&gt;这些框架除了可以满足待测试代码对安卓库的不同依赖情况，还有各自不同的特点，如运行环境与条件均可能存在差异。开发者可以对所需要的框架有一个大致了解后，再选择进行学习。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;若你喜欢本文或觉得有所帮助，请点赞或关注。&lt;br/&gt;你的支持是对笔者最大的鼓励与肯定。比芯~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/21/5bf579f822a3f.png&quot; alt=&quot;底部关注二维码：小&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 15:33:00 +0000</pubDate>
<dc:creator>程序引力</dc:creator>
<og:description>想学习单元测试无从下手，本文对以最易懂的方式介绍单元测试。 若有错漏，烦请斧正。转载请注明出处。欢迎关注程序引力 作者：程序引力 | 谢一 （Evan Xie） 邮箱：evanyixie@gmail.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxuyinli/p/9998637.html</dc:identifier>
</item>
<item>
<title>聊聊RPC原理二 - 黄青石</title>
<link>http://www.cnblogs.com/huangqingshi/p/9998404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangqingshi/p/9998404.html</guid>
<description>&lt;p&gt;　　之前写了一篇关于RPC的文章，浏览量十分感人:)，但是感觉&lt;a href=&quot;https://www.cnblogs.com/huangqingshi/p/7803642.html&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;写得有些粗，觉得很多细节没有讲出来，这次把里边的细节再次补充和说明。&lt;/p&gt;
&lt;p&gt;　　这次主要说的内容分为：&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1. RPC的主要结构图。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.分析结构图的中的细节和步骤。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　关于RPC，大家都不陌生，其简写和介绍什么的我就不过多介绍了，可以从我上篇文章中看到，下面直接上我画的图，简单粗暴：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236784/201811/1236784-20181121220619042-1395610606.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　RPC的主要目的是将一个庞大的系统分离成不同的子系统，按照不同的功能，比如读库功能，记录日志等可以单独出来的功能单独出来，这样的好处是，不会像以前那样庞大的系统部署的时候每次都要整个系统进行重启，可以修改单独的模块，并且自己独立部署，这样大大提升效率。但是如果拆分的过细的话，可能需要维护很多的小项目，代码工程由一个大工程，拆分成很多小工程，而且启动功能并且进行测试的话一般至少启动两个服务，一个server和一个client，同时相应的zookeeper也要启动。&lt;/p&gt;
&lt;p&gt;　　下面来说一下上图中每个模块的功能。&lt;/p&gt;
&lt;p&gt;　　先来说一下zookeeper, 可能有些同学已经很熟悉zookeeper使用了，当然我也在博客中写过zookeepr实现的锁&lt;a href=&quot;https://www.cnblogs.com/huangqingshi/p/9650837.html&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;，它非常强大，但是这里不过多解释它强大之处，这次说它的作用。在RPC中zookeeper承担着服务的注册，心跳检测，记录client的相关信息，最关键的是要记录server的IP和端口号以及它提供service信息，版本号等信息。每个client在调用之前都要从zookeeper那里获取存活server的相关信息及提供服务的版本。这样client拿到这些信息后可以直接和server进行通信了。&lt;/p&gt;
&lt;p&gt;　　里边有一个细节就是client和server在zookeeper中注册的znode是临时的ephemral的，这样的目的是在心跳检测的时候发现client或者server已经down了，需要从zk中剔除，这样client连接server失败的情况下重新从zookeeper中获取有效的server及service信息。&lt;/p&gt;
&lt;p&gt;　　接下来就是server，在一些大型系统中，其实server是由很多台机器构成的，这里我为了简化就画了一台机器，当server和其中部署的service启动之后需要到zookeeper中进行注册，这样client就可以发现新部署的service了，通过zookeeper实现了动态的service上线和下线，是不是很厉害。在server中，由service声明和implementation实现，同时还有在使用过程中对应的bean对象。当然在server中还部署着netty服务，这个一会儿咱们就说。&lt;/p&gt;
&lt;p&gt;　　继续看client，client在这里边充当着的是consumer，就是消费service所produce的服务。client应该也是多台的。client其实就相对比较简单，因为是调用方，所以只需要声明对应的service接口和相应的bean对象就行了。&lt;/p&gt;
&lt;p&gt;　　然后就是netty服务了，这次咱们不说netty的详细内容，大家知道它是用来进行通信的，拥有高吞吐量，高并发，多协议实现，并且支持NIO，AIO的工具。有兴趣的同学可以读一些关于netty的文章。netty在这里扮演的角色就是通信，将调用的service以及相关的bean对象和参数进行序列化，找到从zookeeper获取的service所在的主机、IP、端口号、服务及版本等信息后进行TCP连接，发送给server后，在server中也有一个netty在对应的端口进行接口，接收后进行反序列化，然后通过动态代理实现接口调用，关于动态代理的实现可以参考我之前写过的&lt;a href=&quot;https://www.cnblogs.com/huangqingshi/p/7651376.html&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;。调用之后获取到执行结果后再以相反的顺序返回去。这就是netty实现的功能了。&lt;/p&gt;
&lt;p&gt;　　这块基本就是RPC的主要核心实现细节，当然里边可能还会有一些细节我没有提到，因为RPC的功能也在不断完善中，所以还有一些新增的一些功能没有提及，比如server机器的比重等，这些在用到的工程中一看应该就会明白。&lt;/p&gt;
&lt;p&gt;　　好了，希望你们能从这篇文章中获得收获。&lt;/p&gt;
&lt;p&gt;　　欢迎转载，但转载请署名黄青石，谢谢。&lt;/p&gt;



</description>
<pubDate>Wed, 21 Nov 2018 14:43:00 +0000</pubDate>
<dc:creator>黄青石</dc:creator>
<og:description>之前写了一篇关于RPC的文章，浏览量十分感人:)，但是感觉文章写得有些粗，觉得很多细节没有讲出来，这次把里边的细节再次补充和说明。 这次主要说的内容分为： 1. RPC的主要结构图。 2.分析结构图的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangqingshi/p/9998404.html</dc:identifier>
</item>
<item>
<title>两个星期，用Flutter撸个APP - Game_over</title>
<link>http://www.cnblogs.com/game-over/p/9998392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/game-over/p/9998392.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Flutter是Google推出的跨平台的解决方案，Slogan是“Design beautiful apps”，国内也有知名企业在使用和推广，例如阿里、美团都有在尝试。&lt;/p&gt;
&lt;p&gt;个人对其中的一些特性，比如JIT、Material Design、快速开发等很感兴趣，于是决定尝试一下。&lt;/p&gt;
&lt;h3 id=&quot;诗词汇&quot;&gt;诗词汇&lt;/h3&gt;
&lt;p&gt;于是诞生了诗词汇APP，首先看一下是个什么样的APP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/15038736-01c04a047b8dacdc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们一步步从不同方面说说Flutter的开发。&lt;/p&gt;
&lt;h3 id=&quot;开始&quot;&gt;开始&lt;/h3&gt;
&lt;p&gt;FLutter可以在Windows、Linux、Mac上进行开发，开发工具可以使用VS Code、Android Studio、IDEA等，本文推荐使用Android Studio，主要在于Android Studio提供了FLutter Inspector工具，可以实时审查元素，解决界面的显示适配问题。&lt;/p&gt;
&lt;h4 id=&quot;搭建开发环境&quot;&gt;搭建开发环境&lt;/h4&gt;
&lt;p&gt;搭建环境的主要步骤：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-0.55555555555556&quot;&gt;
&lt;p&gt;下载SDK，&lt;a href=&quot;https://flutter.io/docs/get-started/install&quot;&gt;下载地址&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置PATH，如果使用Mac或者Linux系统，一定要将&lt;code&gt;bin&lt;/code&gt;目录添加到系统PATH。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置依赖源镜像，这一步很重要，并且需要将脚本放到启动shell中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;
export PUB_HOSTED_URL=https://pub.flutter-io.cn

export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;-0.875&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行&lt;code&gt;flutter doctor&lt;/code&gt;，这一步耗时会很长，需要耐心等耐。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.6875&quot;&gt;
&lt;p&gt;安卓开发工具及插件，&lt;a href=&quot;https://flutter.io/docs/get-started/editor&quot;&gt;配置编辑器&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;配置编辑器&quot;&gt;配置编辑器&lt;/h4&gt;
&lt;p&gt;主要是给编辑器安装相应的插件。&lt;/p&gt;
&lt;p&gt;VS Code安装&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter&quot;&gt;flutter插件&lt;/a&gt;，Android Studio和IDEA需要安装Flutter和Darter插件。&lt;/p&gt;
&lt;p&gt;其中Android Studio和IDEA基本一样，跟VS Code的主要区别在于：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;VS Code提供了更好的代码提示功能&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IDEA提供了Flutter Inspector，可实时审查页面元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可根据个人喜好、习惯选择使用。&lt;/p&gt;
&lt;h4 id=&quot;推荐网站&quot;&gt;推荐网站&lt;/h4&gt;
&lt;p&gt;在安装、配置过程中，可参考以下中文资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://flutter-io.cn/&quot;&gt;Flutter中国&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://doc.flutter-dev.cn/docs/&quot;&gt;Flutter中文文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;主要技术点&quot;&gt;主要技术点&lt;/h3&gt;
&lt;h4 id=&quot;dart&quot;&gt;Dart&lt;/h4&gt;
&lt;p&gt;Flutter项目的开发语言是Dart，Dart 是由 Google 开发的一种面向对象语言，可以编译成 ARM 和 x86 代码直接运行在 iOS、Android 设备上。&lt;/p&gt;
&lt;p&gt;推荐先学习Dart语言&lt;a href=&quot;https://www.dartlang.org/guides/language/language-tour&quot;&gt;官方教程&lt;/a&gt;，对Dart有初步了解之后再进行Flutter的学习和开发。&lt;/p&gt;
&lt;h4 id=&quot;界面开发&quot;&gt;界面开发&lt;/h4&gt;
&lt;p&gt;终于可以进入Flutter本身了。&lt;/p&gt;
&lt;h5 id=&quot;widget&quot;&gt;Widget&lt;/h5&gt;
&lt;p&gt;Flutter中页面所有元素都是Widget，又分为StatelessWidget和StatefulWidget。&lt;/p&gt;
&lt;p&gt;顾名思义，StatelessWidget 就是指无可变状态的 Widget，这类 Widget 的状态只由创建 Widget 时传入的参数决定，一旦创建，其状态、在页面上的展示效果也就不再改变。&lt;/p&gt;
&lt;p&gt;而 StatefulWidget 内部则存在着可变状态。当通过setState改变这些状态时，Flutter 会重新渲染该 Widget。&lt;/p&gt;
&lt;h5 id=&quot;布局&quot;&gt;布局&lt;/h5&gt;
&lt;p&gt;在实际开发中，主要使用了Row、Column、Container、Expanded、Stack等。&lt;/p&gt;
&lt;p&gt;Row、Column提供了水平、垂直方向的布局，Stack提供了堆叠方式的布局，各种容器有不同的特性，可根据实际页面需求选择搭配不同的布局。&lt;/p&gt;
&lt;p&gt;推荐学习 &lt;a href=&quot;https://flutter.io/docs&quot;&gt;官方文档&lt;/a&gt; 及 &lt;a href=&quot;https://flutterchina.club/docs/&quot;&gt;国内维护的中文翻译&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;主要插件&quot;&gt;主要插件&lt;/h4&gt;
&lt;p&gt;话题切回到诗词汇APP，本APP收集了4000余位诗人的30多万首诗词，提供了古诗词的查询、收藏、朗诵功能，并且实现了初步的社区功能。&lt;/p&gt;
&lt;p&gt;项目目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/15038736-41bee798c8cfa7a9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开发这个APP大概用了一个月的业余时间，每天抽出一两个小时，这样折算为工作日，大概是两个星期左右，开发效率还是很高的。&lt;/p&gt;
&lt;p&gt;下面跟大家分享一下主要功能及所使用的一些插件。&lt;/p&gt;
&lt;h5 id=&quot;切换主题&quot;&gt;切换主题&lt;/h5&gt;
&lt;p&gt;为了实现实时切换主题颜色，使用了状态管理插件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/flutter_redux&quot;&gt;flutter_redux&lt;/a&gt; 。&lt;/p&gt;
&lt;h5 id=&quot;极光推送&quot;&gt;极光推送&lt;/h5&gt;
&lt;p&gt;在国内厂商中，极光是少有的对Flutter提供了技术支持的，这里给极光大大的👍。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/jpush_flutter&quot;&gt;jpush_flutter&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;qq&quot;&gt;QQ&lt;/h5&gt;
&lt;p&gt;QQ的Flutter插件提供了基本的登录、分享功能。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/flutter_qq&quot;&gt;flutter_qq&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;微信&quot;&gt;微信&lt;/h5&gt;
&lt;p&gt;微信的Flutter插件提供的功能稍微丰富，包含了支付、登录、分享、启动小程序的功能。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/fluwx&quot;&gt;fluwx&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;事件总线event-bus&quot;&gt;事件总线Event Bus&lt;/h5&gt;
&lt;p&gt;大名鼎鼎的event_bus也提供了对Flutter的支持。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/event_bus&quot;&gt;event_bus&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;音频&quot;&gt;音频&lt;/h5&gt;
&lt;p&gt;录音及播放音频也有很好的支持。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/audio_recorder&quot;&gt;audio_recorder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pub.flutter-io.cn/packages/audioplayer2&quot;&gt;audioplayer2&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;其它&quot;&gt;其它&lt;/h5&gt;
&lt;p&gt;其它诸如加载HTML、Toast提示、图片选择器、图片加载等也有较好的插件支持。&lt;/p&gt;
&lt;p&gt;可在 &lt;a href=&quot;https://pub.flutter-io.cn/&quot;&gt;官方插件库&lt;/a&gt; 查询相关的插件。&lt;/p&gt;
&lt;h3 id=&quot;坑&quot;&gt;坑&lt;/h3&gt;
&lt;h4 id=&quot;安装升级&quot;&gt;安装、升级&lt;/h4&gt;
&lt;p&gt;FLutter的安装、升级会经常遇到卡死的问题，主要原因就是使用了Google的源，但是莫名的，即使使用了科学上网、设置了国内镜像后，也会遇到同样的问题。只能通过反复的&lt;code&gt;flutter doctor&lt;/code&gt; 或 &lt;code&gt;flutter upgrade&lt;/code&gt;直到解决问题。&lt;/p&gt;
&lt;h4 id=&quot;开发&quot;&gt;开发&lt;/h4&gt;
&lt;p&gt;由于笔者最近一段时间Android项目做得较多，习惯了Android的XML布局方式，对于在代码中编写页面的形式一开始还有些不习惯，但是在按照官方例子实践了几个页面后，用代码写页面的优势就体现出来了。&lt;/p&gt;
&lt;p&gt;在页面已经设计好的情况下，开发的时候脑海中就构思出一个Widget树，从根节点到每一个节点一级一级嵌套下去，自然而然的布局就写好了。&lt;/p&gt;
&lt;h4 id=&quot;dialog弹出框&quot;&gt;Dialog弹出框&lt;/h4&gt;
&lt;p&gt;使用Dialog的时候，弹出Dialog的Context及Dialog本身都会压入栈中，所以让Dialog消失的方法是&lt;code&gt;Navigator.of(ctx).pop()&lt;/code&gt;，这样的设计既不同于Android也不同于iOS，也许跟Flutter本身所有元素都是Widget的设计有关。&lt;/p&gt;
&lt;h4 id=&quot;编译&quot;&gt;编译&lt;/h4&gt;
&lt;p&gt;在编译Android版本的时候很顺畅，没有遇到任何问题。但是在编译iOS版本的时候，遇到了很多问题，直到现在也没有解决。&lt;/p&gt;
&lt;p&gt;问题在于使用了&lt;code&gt;audio_recorder&lt;/code&gt;和&lt;code&gt;flutter_qq&lt;/code&gt;两个插件，而这两个插件一个要求编译选项需要设置&lt;code&gt;!use_framework&lt;/code&gt;，一个要求不能设置，造成了冲突，在实际编译中一直编译不通过。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;开发结束，最终打包了Release版本的APK，安装到手机后，发现惊喜。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;竟然如丝般顺滑，这是我始料未及的，转场效果、页面相应速度不输原生APP。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总而言之，个人对Flutter的前景相当看好，毕竟是Google大厂出品，并且项目本身的迭代速度很快，目前已经是0.11版本，期望在不远的将来发布正式的1.0版本，更期望国内厂商加大对Flutter的支持力度。&lt;/p&gt;
&lt;p&gt;**顺便推广一下笔者的诗词汇APP，欢迎大家 &lt;a href=&quot;https://android.myapp.com/myapp/detail.htm?apkName=com.liuzb.allpoems&quot;&gt;下载试用&lt;/a&gt; ，或者访问 &lt;a href=&quot;https://52gushici.cn/&quot;&gt;诗词汇&lt;/a&gt; 体验下Flutter如丝般的顺滑。^_^**&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/15038736-59805a7508bf3e5b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 14:42:00 +0000</pubDate>
<dc:creator>Game_over</dc:creator>
<og:description>前言 Flutter是Google推出的跨平台的解决方案，Slogan是“Design beautiful apps”，国内也有知名企业在使用和推广，例如阿里、美团都有在尝试。 个人对其中的一些特性，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/game-over/p/9998392.html</dc:identifier>
</item>
<item>
<title>IOS免越狱虚拟定位修改工具共享 Jocation - 董侨</title>
<link>http://www.cnblogs.com/jonneydong/p/9998324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jonneydong/p/9998324.html</guid>
<description>
&lt;p&gt;Jocation IOS虚拟定位修改器 具体使用方法可以按照 location cleaned软件相同的操作.&lt;/p&gt;
&lt;p&gt;主要是因为本人有一部 IphoneX 和Iphone Xs Max 网上的location cleaned破解软件只支持 Xs以下设备. 而作者最新版本的软件虽说支持了xs 但是会对系统进行老版本的删除操作, 具有病毒的式的操作.&lt;/p&gt;
&lt;p&gt;因为原location cleaned作者对软件进行收费,并且软件有病毒式操作,因此萌生自己开发一个工具自己用.&lt;/p&gt;
&lt;p&gt;经过查阅相关文档,发现实现功能并不难, 因此花了两个小时将功能实现了. 后因朋友推荐不如做成成品软件供需要的人使用. 特此将软件做成跟location cleaned相同的界面以供大家使用.相同的功能,相同的界面,相同的体验.&lt;/p&gt;
&lt;p&gt;Jocation下载地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/jonneydong/JocationRelease/raw/master/Jocation_v1.0(IOS%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D).zip&quot;&gt;https://gitee.com/jonneydong/JocationRelease/raw/master/Jocation_v1.0(IOS%E8%99%9A%E6%8B%9F%E5%AE%9A%E4%BD%8D).zip&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 14:30:00 +0000</pubDate>
<dc:creator>董侨</dc:creator>
<og:description>Jocation IOS虚拟定位修改器 具体使用方法可以按照 location cleaned软件相同的操作. 主要是因为本人有一部 IphoneX 和Iphone Xs Max 网上的locatio</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jonneydong/p/9998324.html</dc:identifier>
</item>
<item>
<title>Dora.Interception，为.NET Core度身打造的AOP框架 [2]：以约定的方式定义拦截器 - Artech</title>
<link>http://www.cnblogs.com/artech/p/dora-interception-02.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/dora-interception-02.html</guid>
<description>&lt;p&gt;上一篇《&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-01.html&quot;&gt;更加简练的编程体验&lt;/a&gt;》提供了最新版本的Dora.Interception代码的AOP编程体验，接下来我们会这AOP框架的编程模式进行详细介绍，本篇文章着重关注的是拦截器的定义。采用“&lt;strong&gt;&lt;span&gt;基&lt;/span&gt;&lt;span&gt;于约定&lt;/span&gt;&lt;/strong&gt;”的Interceptor定义方式是Dora.Interception区别于其他AOP框架的一个显著特征，要了解拦截器的编程约定，就得先来了解一下Dora.Interception中针对方法调用的拦截是如何实现的。&lt;/p&gt;

&lt;p&gt;总地来说，Dora.Interception针对方法调用的拦截机制分为两种类型，我将它称为“&lt;span&gt;&lt;strong&gt;针对实例的拦截&lt;/strong&gt;&lt;/span&gt;”和“&lt;strong&gt;&lt;span&gt;针对类型&lt;/span&gt;&lt;/strong&gt;”的拦截。针对实例的拦截应用于针对接口的方法调用，其原理如下所示：类型Foobar实现了接口IFoobar，如果需要拦截以接口的方式调用Foobar对象的某个方法，我们可以动态生成另一个用来封装Foobar对象的FoobarProxy类型，FoobarProxy同样实现IFoobar接口，我们在实现的方法中实现对Interceptor链的调用。我们最终将原始提供的Foobar对象封装成FoobarProxy对象，那么针对Foobar的方法调用将转换成针对FoobarProxy对象的调用，拦截得以实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201811/19327-20181121220630063-1654522377.png&quot;&gt;&lt;img width=&quot;530&quot; height=&quot;108&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201811/19327-20181121220630404-1845661468.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果Foobar并未实现任何接口，或者针对它的调用并非以接口的方式进行，那么我们只能采用“针对类型的拦截”，其原理如下：我们动态创建Foobar的派生类型FoobarProxy，并重写其需要被拦截的虚方法来实现对Interceptor链的调用。我们最终创建FoobarProxy对象来替换掉原始的Foobar对象，那么针对Foobar的方法调用将转换成针对FoobarProxy对象的调用，拦截得以实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201811/19327-20181121220630621-1780814130.png&quot;&gt;&lt;img width=&quot;545&quot; height=&quot;125&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201811/19327-20181121220630880-440969547.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于这种拦截方式会直接创建代理对象，无法实现针对目标对象的封装，当我们进行DI服务注册的时候，只能指定注册服务的实现类型，不能指定一个现有的Singleton实例或者提供一个创建实例的Factory。&lt;/p&gt;

&lt;p&gt;要理解Dora.Interception的设计，先得从如下这两个特殊的Delegate类型（&lt;strong&gt;InterceptDelegate&lt;/strong&gt;和&lt;strong&gt;InterceptorDelegate&lt;/strong&gt;）说起。InterceptDelegate代表针对方法的拦截操作，作为输入参数的InvocationContext提供了当前方法调用的所有上下文信息，返回类型被设置为Task意味着Dora.Interception提供了针对基于Task的异步编程的支持。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt; Task InterceptDelegate(InvocationContext context);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt; InterceptDelegate InterceptorDelegate(InterceptDelegate next);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InvocationContext
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] Arguments { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; MethodBase Method { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; InterceptDelegate Next { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;;  }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Proxy { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; ReturnValue { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Target { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MethodBase TargetMethod { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; IDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; ExtendedProperties { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task ProceedAsync();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;InterceptDelegate表示的是“拦截操作”，即表示作用于InvocationContext上下文上的一个Task，但它并不能表示一个拦截器对象。原因很简单，因为注册到同一个方法上的多个拦截器对象会构成一个链条，最终决定是否调用后一个拦截器或者目标方法（对于链条尾部的Interceptor）是由当前拦截器决定的，所以如果将Interceptor也表示成委托对象，它的输入应该是一个InterceptDelegate对象，表示针对后一个拦截器或者目标方法的调用，它返回的同样也是一个InterceptDelegate对象，表示将自身纳入拦截器链之后，新的拦截器链条（包括调用目标方法）所执行的操作。&lt;/p&gt;
&lt;p&gt;所以一个Interceptor在Dora.Interception中应该表示成一个Func&amp;lt;InterceptDelegate, InterceptDelegate&amp;gt;对象，这与ASP.NET Core的中间件管道其实是一回事。简单起见，我们为它专门定义了一个委托类型InterceptorDelegate。&lt;/p&gt;

&lt;p&gt;虽然Dora.Interception总是将Interceptor对象表示成上面介绍的InterceptorDelegate类型的委托，但是为了更好的编程体验，我们可以选择采用POCO类型的方法来定义Interceptor。为了提供更好的灵活性，能够在方法中动态注入任意依赖服务，我们并不打算为这样的Interceptor类型定义一个接口。接口是一个契约，同时也是一个&lt;strong&gt;&lt;span&gt;限制&lt;/span&gt;&lt;/strong&gt;。如果类型实现某个接口，意味着必需按照规定的声明实现其方法，针对方法的服务注入将无法实现，所以Dora.Interception采用“基于约定”的方式来定义Interceptor类型。具体的约定如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Interceptor只需要定义一个普通的&lt;span&gt;&lt;strong&gt;实例类型&lt;/strong&gt;&lt;/span&gt;即可。&lt;/li&gt;
&lt;li&gt;Interceptor类型必须具有一个&lt;span&gt;&lt;strong&gt;公共构造函数&lt;/strong&gt;&lt;/span&gt;，它可以包含任意的参数，并支持&lt;span&gt;&lt;strong&gt;构造器注入&lt;/strong&gt;&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;拦截功能实现在约定的&lt;span&gt;&lt;strong&gt;InvokeAsync&lt;/strong&gt;&lt;/span&gt;的方法中，这是一个返回类型为&lt;span&gt;&lt;strong&gt;Task&lt;/strong&gt;&lt;/span&gt;的异步方法，它的第一个参数类型为&lt;span&gt;&lt;strong&gt;InvocationContext&lt;/strong&gt;&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;除了表示当前执行上下文的参数之外， 任何可以注入的服务于对象都可以定义成InvokeAsync方法的参数。&lt;/li&gt;
&lt;li&gt;当前Interceptor针对后续的Interceptor或者目标方法的调用通过调用InvocationContext的&lt;span&gt;&lt;strong&gt;ProceedAsync&lt;/strong&gt;&lt;/span&gt;方法来实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下所示的就是一个典型的Interceptor，它提供了针对构造函数和方法的注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarInterceptor
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IFoo Foo { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Baz { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FoobarInterceptor(IFoo foo, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; baz)
    {
        Foo &lt;/span&gt;=&lt;span&gt; foo;
        Baz &lt;/span&gt;=&lt;span&gt; baz;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync(InvocationContext context, IBar bar)
    {
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Foo.DoSomethingAsync();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; bar.DoSomethingAsync();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.ProceedAsync();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-01.html&quot;&gt;[1]：更加简练的编程体验&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-02.html&quot;&gt;[2]：基于约定的拦截器定义方式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-03.html&quot;&gt;[3]：多样性的拦截器应用方式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-04.html&quot;&gt;[4]：与依赖注入框架的深度整合&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/dora-interception-05.html&quot;&gt;[5]：对拦截机制的灵活定制&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 14:07:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>上一篇《更加简练的编程体验》提供了最新版本的Dora.Interception代码的AOP编程体验，接下来我们会这AOP框架的编程模式进行详细介绍，本篇文章着重关注的是拦截器的定义。采用“基于约定”的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/artech/p/dora-interception-02.html</dc:identifier>
</item>
<item>
<title>.NET Core实战项目之CMS 第三章 入门篇-源码解析配置文件及依赖注入 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9998021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9998021.html</guid>
<description>&lt;blockquote readability=&quot;2.125&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9998021.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9998021.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;上篇文章我给大家讲解了ASP.NET Core的概念及为什么使用它，接着带着你一步一步的配置了.NET Core的开发环境并创建了一个ASP.NET Core的mvc项目，同时又通过一个实战教你如何在页面显示一个Content的列表。不知道你有没有跟着敲下代码，千万不要做眼高手低的人哦。这篇文章我们就会设计一些复杂的概念了，因为要对ASP.NET Core的启动及运行原理、配置文件的加载过程进行分析，依赖注入，控制反转等概念的讲解等。俗话说，授人以鱼不如授人以渔，所以文章旨在带着大家分析源码，让大家能知其然更能知其所以然。为了偷懒，继续使用上篇文章的例子了！有兴趣的朋友可以加群637326624相互交流！&lt;br/&gt;再次感谢张队的审稿！&lt;/p&gt;
&lt;h2 id=&quot;asp.net-core启动源码解析&quot;&gt;ASP.NET Core启动源码解析&lt;/h2&gt;
&lt;p&gt;这部分我就带着大家一起看下asp.net core项目的运行流程吧！顺带着了解下asp.net core的运行原理，说的不好的话，希望大家给以指正，从而能够正确的帮助更多的人。&lt;/p&gt;
&lt;ol readability=&quot;44.706723073405&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;首先上一下上篇文章的项目结构吧，如下所示，熟悉C#的朋友应该知道，要找程序的入库，那么就应该找到Main方法。而asp.net core的main方法就在Program.cs文件中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213438879-1797210540.png&quot; alt=&quot;1542771232412&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;打开后看到如下的代码，我加了注释，大伙将就看下，下面我们来一步一步的分析&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
        /// Main方法，程序的入口方法
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static void Main(string[] args)
        {
            CreateWebHostBuilder(args)//调用下面的方法，返回一个IWebHostBuilder对象
                .Build()//用上面返回的IWebHostBuilder对象创建一个IWebHost
                .Run();//运行上面创建的IWebHost对象从而运行我们的Web应用程序换句话说就是启动一个一直运行监听http请求的任务
        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)//使用默认的配置信息来初始化一个新的IWebHostBuilder实例
                .UseStartup&amp;lt;Startup&amp;gt;();// 为Web Host指定了Startup类&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到asp.net core程序实际上就是一个控制台程序，运行一个webhost对象从而启动一个一直运行的监听http请求的任务。所以我们的重点就是分析一下这个WebHost创建的过程：&lt;br/&gt;创建IWebHostBuilder-》创建IWebHost-》然后运行创建的IWebHost。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这里我们从IWebHostBuilder的&lt;strong&gt;Build&lt;/strong&gt;分析下创建的过程，有兴趣的朋友可以看下，没兴趣的朋友可以直接跳到下一个步骤继续阅读。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;16.7&quot;&gt;&lt;li readability=&quot;1.7461024498886&quot;&gt;
&lt;p&gt;首先到aspnetcore的github开源地址https://github.com/aspnet/AspNetCore/tree/release/2.1 上去下载源码（我们使用的是2.1）。然后使用vscode打开解压后的文件夹。至于vscode如何加载文件，你可以看我这篇文章&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9926078.html&quot;&gt;使用Visual Studio Code开发.NET Core看这篇就够了&lt;/a&gt; 当然你也可以在上面的网页上直接找到相应的目录浏览也是可以的。（看结构好像是使用vscode进行开发的）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;根据IWebHostBuilder的命名空间我们找到了它的实现，路径为src/Hosting/Hosting/src/WebHostBuilder.cs&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213438602-229104760.png&quot; alt=&quot;1542782994757&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;通过上面的代码我们可以看到首先是通过BuildCommonServices来构建一个ServiceCollection。为什么说这么说呢，先让我们我们跳转到BuidCommonServices方法中看下吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213438244-1309490072.png&quot; alt=&quot;1542784242634&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，&lt;code&gt;var services = new ServiceCollection();&lt;/code&gt;首先new一个ServiceCollection然后往services里面注入很多内容，比如：WebHostOptions ，IHostingEnvironment ，IHttpContextFactory ，IMiddlewareFactory 等等（其实这里已经设计到依赖注入的概念了，先思考下吧），然后我们在后续就可以使用了！最后这个BuildCommonServices就返回了这个services对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在上面的依赖注入中有一个方法，不知道大家注意到没有，因为我们在步骤2贴出的代码里面有一个&lt;code&gt;UseStartup&amp;lt;Startup&amp;gt;()&lt;/code&gt; 其实在上面的BuildCommonServices方法中也有对&lt;code&gt;IStartup&lt;/code&gt;的注入的。首先，判断Startup类是否继承于IStartup接口，如果是继承的，那么就可以直接加入在services 里面去，如果不是继承的话，就需要通过ConventionBasedStartup(methods)把method转换成IStartUp后注入到services里面去。结合上面我们的代码，貌似我们平时用的时候注入的方式都是采用后者。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我们再回到build方法拿到了BuildCommonServices方法构建的ServiceCollection实例后，通过GetProviderFromFactory(hostingServices) 方法构造出了IServiceProvider 对象。到目前为止，IServiceCollection和IServiceProvider都拿到了。然后根据IServiceCollection和IServiceProvider对象构建WebHost对象。构造了WebHost实例还不能直接返回，还需要通过Initialize对WebHost实例进行初始化操作。那我们看看在初始化函数&lt;strong&gt;Initialize中&lt;/strong&gt;，都做了什么事情吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213437947-1485998.png&quot; alt=&quot;1542786448255&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这里我们把代码导航到src/Hosting/Hosting/src/Internal/WebHost.cs找到Initialize方法。如下图所示：主要就是一个EnsureApplicationServices 方法。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213437665-169962483.png&quot; alt=&quot;1542787078949&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们继续导航查看这个方法的内容如下：就是拿到Startup 对象，然后把_applicationServiceCollection 中的对象注入进去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213437379-1519205760.png&quot; alt=&quot;1542787219703&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;至此我们build中注册的对象以及StartUp中注册的对象都已经加入到依赖注入容器中了，接下来就是Run起来了。这个run的代码在src\Hosting\Hosting\src\WebHostExtensions.cs中，代码如下：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213436983-885259821.png&quot; alt=&quot;1542787884205&quot;/&gt;WebHost执行RunAsync运行web应用程序并返回一个只有在触发或关闭令牌时才完成的任务（这里又涉及到异步编程的知识了，咱们以后再详细讲解） 。这就是我们运行ASP.Net Core程序的时候，看到的那个命令行窗口了，如果不关闭窗口或者按Ctrl+C的话是无法结束的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;至此启动的过程的源码分析完成了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;配置文件&quot;&gt;配置文件&lt;/h2&gt;
上面给大家介绍了ASP.NET Core的启动过程，中间牵扯到了一些依赖注入的概念。关于依赖注入的概念呢，我们后面再说，这里先给大家讲解下配置文件的加载过程。&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;打开上篇文章我们创建的项目，并在appsettings.json里面加入如下内容：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Warning&quot;
    }
  },
  &quot;Content&quot;: {
    &quot;Id&quot;: 1,
    &quot;title&quot;: &quot;title1&quot;,
    &quot;content&quot;: &quot;content1&quot;,
    &quot;status&quot;: 1,
    &quot;add_time&quot;: &quot;2018-11-21 16:29&quot;,
    &quot;modify_time&quot;: null
  },
  &quot;AllowedHosts&quot;: &quot;*&quot;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;然后在Startup类中ConfigureServices中注册TOptions对象如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; services.Configure&amp;lt;Content&amp;gt;(Configuration.GetSection(&quot;Content&quot;));//注册TOption实例对象&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码也就是从appsettings.json这个配置文件中的&lt;code&gt;Content&lt;/code&gt;这个节点匹配到Content这个对象上。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;修改下ContentController这个控制器代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private readonly Content contents;
        public ContentController(IOptions&amp;lt;Content&amp;gt; option)
        {
            contents = option.Value;
        }
        /// &amp;lt;summary&amp;gt;
        /// 首页显示
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public IActionResult Index()
        {

            return View(new ContentViewModel { Contents=new List&amp;lt;Content&amp;gt; { contents} });
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;按下F5运行下，然后导航到Content目录看到如下页面：说明成功从appsettings.json这个文件中加载了内容。这一切是怎么发生的呢？下面我们就一步一步的来分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213436707-1008587323.png&quot; alt=&quot;1542792298052&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们回过头来看我们的Main方法，发现里面有一个CreateDefaultBuilder方法，就是这个方法里面为我们做了一些默认的设置，然后加载我们的配置文件的！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213436434-453312146.png&quot; alt=&quot;1542801612869&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我们在源码里面找到CreateDefaultBuilder 的源码（反正我找了半天，起初在Hosting下面找，实际上在MetaPackages下面的），位置在src\MetaPackages\src\Microsoft.AspNetCore\WebHost.cs 有的人可能找不到哦，可以看到这个方法会在ConfigureAppConfiguration 的时候默认加载&lt;code&gt;appsetting&lt;/code&gt;文件，并做一些初始的设置，所以我们不需要任何操作，就能加载&lt;code&gt;appsettings&lt;/code&gt; 的内容了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213436128-559978156.png&quot; alt=&quot;1542801370627&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;既然知道了原理后，我们就试着重写下这个&lt;code&gt;ConfigureAppConfiguration&lt;/code&gt; 然后加载我们自定义的json文件吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;鼠标右键新建一个Content.json文件，然后输入如下的内容：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;{
  &quot;ContentList&quot;: 
    {
      &quot;Id&quot;: 1,
      &quot;title&quot;: &quot;title1 from diy json&quot;,
      &quot;content&quot;: &quot;content1 from diy json&quot;,
      &quot;status&quot;: 1,
      &quot;add_time&quot;: &quot;2018-11-21 16:29&quot;,
      &quot;modify_time&quot;: null
    }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;然后打开Program.cs。按如下代码进行改造：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
        /// Main方法，程序的入口方法
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public static void Main(string[] args)
        {
            CreateWebHostBuilder(args)//调用下面的方法，返回一个WebHostBuilder对象
                .Build()//用上面返回的WebHostBuilder对象创建一个WebHost
                .Run();//运行上面创建的WebHost对象从而运行我们的Web应用程序换句话说就是启动一个一直运行监听http请求的任务
        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)//使用默认的配置信息来初始化一个新的IWebHostBuilder实例
            .ConfigureAppConfiguration((hostingContext, config) =&amp;gt;
            {
                var env = hostingContext.HostingEnvironment;

                config.AddJsonFile(&quot;appsettings.json&quot;, optional: true, reloadOnChange: true)
                      .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;, optional: true, reloadOnChange: true)
                      .AddJsonFile(&quot;Content.json&quot;,optional:false,reloadOnChange:false)
                      .AddEnvironmentVariables();

            })
            .UseStartup&amp;lt;Startup&amp;gt;();// 为Web Host指定了Startup类&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213435838-1502421717.png&quot; alt=&quot;1542804422257&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;然后Startup里面ConfigureServices中的代码修改如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213435497-1179687345.png&quot; alt=&quot;1542804670714&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;然后按下F5运行下代码吧，如下图所示，从我们最新添加的json文件中加载出来数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213435187-340881669.png&quot; alt=&quot;1542804899927&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;这里多讲一点，传统asp.net的web.config文件如果有更改的话是必须要重启站点才能使，配置文件生效的，但是asp.net core的配置文件是支持热更新的，及不重启网站也能加载更新，只需要设置一下属性即可，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213434825-470174909.png&quot; alt=&quot;1542805102992&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置文件的源码解读这块就到这里了。下面开始依赖注入的讲解。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;依赖注入与控制反转&quot;&gt;依赖注入与控制反转&lt;/h2&gt;
&lt;p&gt;如果大家仔细阅读文章的话，相信已经看出来了，我上面提到过好几次依赖注入的概念。那么究竟什么是依赖注入呢？下面我们就拿我们上面的ContentController来好好的来理解下。&lt;br/&gt;依赖注入：当一个对象ContentController需要另一个对象Content来协同完成任务的时候，那么这个ContentController就对这个Content对象产生了依赖关系。那么在这个ContentController中，是怎么注入的呢？就是从控制器中注入的了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181121213434373-1598413045.png&quot; alt=&quot;1542805959559&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从asp.net 转过来的你是不是想起了之前的千篇一律的new对象啊。没对象自己new（要是女朋友也能new多好啊……）当然除了单例对象，静态哈。&lt;/p&gt;
&lt;p&gt;这里又设计一个概念就是控制反转。&lt;/p&gt;
&lt;p&gt;那么什么是控制反转呢？你上面看到没有，你自己new对象就是整转，因为你自己创建自己所要使用的对象，。那么这种不需要你自己new对象，而是直接传进来就是控制反转了。（不知道比喻的恰不恰当哈）&lt;/p&gt;
&lt;p&gt;依赖注入与控制反转你是否已经了解了呢，喜欢思考的朋友可能会问了，那这个构造函数里面的&lt;code&gt;IOptions&amp;lt;Content&amp;gt; option&lt;/code&gt; 又是怎么出来的？这里就要引入一个容器的概念了。&lt;/p&gt;
&lt;p&gt;什么是容器呢？&lt;/p&gt;
&lt;p&gt;这里创建&lt;code&gt;IOptions&amp;lt;Content&amp;gt; option&lt;/code&gt; 这个对象的东西就是容器。还记得上面我们分析源码的时候，IServiceCollection 里面注入了很多东西吗？其实就是往IServiceCollection 这个容器里面注入方法，这样其他地方使用的时候就能自动注入了。&lt;/p&gt;
&lt;p&gt;这就是容器的好处，由容器来统一管理实例的创建和销毁，你只需要关心怎么用就行了，不需要关系怎么创建跟销毁。&lt;/p&gt;
&lt;p&gt;当然容器创建的实例都是有生命周期的，。下面罗列一下，就不过多的讲解了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Transient： 每一次访问都会创建一个新的实例&lt;/li&gt;
&lt;li&gt;Scoped： 在同一个Scope内只初始化一个实例 ，可以理解为（ 每一个request级别只创建一个实例，同一个http request会在一个 scope内）&lt;/li&gt;
&lt;li&gt;Singleton ：整个应用程序生命周期以内只创建一个实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用的方式也很简单，我会在接下来的课程中详细的通过实例来进行讲解!因为现在的例子还没发演示。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文一步一步带着你先分析了ASP.NET Core的启动过程及运行的原理，紧接着给你讲了配置文件的加载过程及原理，并通过示例代码演示了如何加载自定义的配置文件，最后引出了依赖注入以及控制反转的概念，并通过对我们上面例子的分析来紧身对依赖注入以及控制反转的理解。至此让你知其然更知其所以然。对ASP.NET Core的原理相信你已经了然于胸了！有问题的小伙伴可以加群&lt;code&gt;637326624&lt;/code&gt;讨论。那么接下来让我们再准备下dapper,vue以及git的快速入门就开始我们的asp.net core cms的实战课程吧！还是那句话基础很重要，基础打好，后面才能事半功倍。谢谢大家。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 13:41:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>作者：依乐祝 原文链接：https://www.cnblogs.com/yilezhu/p/9998021.html 写在前面 上篇文章我给大家讲解了ASP.NET Core的概念及为什么使用它，接着</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9998021.html</dc:identifier>
</item>
<item>
<title>Docker &amp; ASP.NET Core (2)：定制Docker镜像 - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/9997124.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/9997124.html</guid>
<description>&lt;p&gt;在Docker的世界里，我们可以通过一个叫Dockerfile的文件来创建Docker镜像，随后可以运行容器。&lt;/p&gt;
&lt;p&gt;Dockerfile就是一个文本文件，里面写着一些指令。通过Docker Client，并使用docker build这个命令，docker build命令会读取该文件里面的指令，生成一层文件系统，然后就生产出了一个docker的镜像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121190503078-1708760710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Dockerfile的文件名就是Dockerfile，当然了也可以叫别的名，但是通常就叫Dockerfile。&lt;/p&gt;
&lt;p&gt;Dockerfile里面包含着各种指令，这些指令会创建一个中间层镜像，这个中间层镜像可以被缓存，这样的话以后构建的时候速度就很快了。&lt;/p&gt;

&lt;p&gt;Dockerfile的主要指令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FROM。通常情况下，你要创建的镜像是基于另外一个镜像的，这就需要使用FROM，当然也可以完全从头创建。&lt;/li&gt;
&lt;li&gt;MAINTAINER。该镜像的维护人。&lt;/li&gt;
&lt;li&gt;RUN。这里可以定义一些需要运行的命令。例如npm install，dotnet restore等等。&lt;/li&gt;
&lt;li&gt;COPY。开发的时候，可以把源码放在Volumes里。而在生产环境下，经常需要把源码复制到容器里面，使用COPY就可以做到这点。&lt;/li&gt;
&lt;li&gt;ENTRYPOINT。它可以定义容器的入口，把容器配置成像exe一样的运行文件。通常是一些例如dotnet 命令，node命令等等。&lt;/li&gt;
&lt;li&gt;CMD。设置容器运行的默认命令和参数。当容器运行的时候，这个可以在命令行被覆盖。&lt;/li&gt;
&lt;li&gt;WORKDIR。设定容器运行的工作目录。&lt;/li&gt;
&lt;li&gt;EXPOSE。暴露端口。&lt;/li&gt;
&lt;li&gt;ENV。设定环境变量。&lt;/li&gt;
&lt;li&gt;VOLUME。定义Volume，并控制如何在宿主中进行存储。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是官网的一个Dockerfile的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121191845773-1855968420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;FROM python:27.-slim，说明该镜像要基于python:2.7-slim这个镜像构建。这将会是一层。&lt;/p&gt;
&lt;p&gt;COPY . /app，是指在构建镜像的时候，从当前目录把源码复制到/app目录下。这又是一层。&lt;/p&gt;
&lt;p&gt;RUN xxx，是指在WORKDIR（/app）下执行pip install xxx这行命令。&lt;/p&gt;
&lt;p&gt;EXPOSE 80，是指把容器的80端口暴露给外界。&lt;/p&gt;
&lt;p&gt;ENV，定义了环境变量。&lt;/p&gt;
&lt;p&gt;CMD [&quot;python&quot;, &quot;app.py&quot;]，里定义了容器运行的默认命令和参数。&lt;/p&gt;


&lt;p&gt;在Docker hub里找到aspnetcore：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121193829759-80312437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面第一个microsoft/aspnetcore 只有运行时，所以只能dotnet run，适用于生产环境。&lt;/p&gt;
&lt;p&gt;第二个microsoft/aspnetcore-build里有完整的dotnet sdk，可以执行dotnet restore, dotnet build, dotnet run等等。&lt;/p&gt;

&lt;p&gt;使用VSCode打开我上篇文章建立的ASP.NET Core项目（或者新建一个也可以）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121194327242-1951127834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后我们这样来创建Dockerfile，首先点击Extensions，搜索docker：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121194445103-1240462074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以找到一个Docker扩展，是由微软开发的。安装它即可。&lt;/p&gt;

&lt;p&gt;安装完后，点击Docker按个图标：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121194619630-1203081838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就可以看到本机上的Docker镜像，容器，注册信息等等。&lt;/p&gt;

&lt;p&gt;然后按Ctrl+Shift+P，然后输入docker：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121194742213-1650954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到有很多可用的命令。&lt;/p&gt;
&lt;p&gt;选择Add Docker Files to Workspace，然后选择ASP.NET Core：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121194853613-638868801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后选择操作系统，这里我选Linux：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121194943098-622206989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后填写内部的端口，我这个项目是5001：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121195029246-603060848.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后按回车，就会生成Dockerfile，同时还有一个.dockerignore文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121195119559-745853650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（在编辑Dockerfile文件的时候还有智能提示的）。&lt;/p&gt;
&lt;p&gt;看一下这个文件：&lt;/p&gt;
&lt;p&gt;FROM microsoft/dotnet:2.1-aspnetcore-runtime AS base，就是把前面的镜像起了一个别名，叫做base。&lt;/p&gt;
&lt;p&gt;WORKDIR /app，工作目录是 /app。&lt;/p&gt;
&lt;p&gt;端口5001。&lt;/p&gt;
&lt;p&gt;下面几句类似，然后：&lt;/p&gt;
&lt;p&gt;COPY [&quot;VolumeSample.csproj&quot;, &quot;./&quot;]，就是把VolumeSample.csproj复制到当前工作的目录。&lt;/p&gt;
&lt;p&gt;RUN dotnet restore &quot;./VolumeSample.csproj&quot;，执行dotnet restore。&lt;/p&gt;
&lt;p&gt;COPY . .，然后把所有的源码也复制到当前的工作目录。&lt;/p&gt;
&lt;p&gt;WORKDIR &quot;/src/.&quot;，切换工作目录到/src。&lt;/p&gt;
&lt;p&gt;RUN dotnet build &quot;VolumeSample.csproj&quot; -c Release -o /app，再执行dotnet build命令，并把结果放在/app目录下。&lt;/p&gt;

&lt;p&gt;后边几句也是类似：&lt;/p&gt;
&lt;p&gt;COPY --from=publish /app .，是指从publish目录复制，具体是从publish/app目录复制，到当前的工作目录。&lt;/p&gt;
&lt;div readability=&quot;41.899632802938&quot;&gt;
&lt;p&gt;ENTRYPOINT [&quot;dotnet&quot;, &quot;VolumeSample.dll&quot;]，就是运行该镜像会执行的命令dotnet VolumeSample.dll。&lt;/p&gt;

&lt;p&gt;（一个项目里可以有多个Dockerfile，例如区分开发和生产环境，但是文件名最好使用dockerfile后缀，因为这样在VSCode里有智能提示）。&lt;/p&gt;


&lt;p&gt;其实上面使用VSCode生成的Dockerfile并不是我需要的，我需要的Dockerfile还是按照官方文档来吧：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/aspnet/aspnet-docker/blob/master/README.aspnetcore-build.md&quot; target=&quot;_blank&quot;&gt;https://github.com/aspnet/aspnet-docker/blob/master/README.aspnetcore-build.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121203557520-973599185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也是多个Stage的。&lt;/p&gt;

&lt;p&gt;然后执行这个命令来构建镜像：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker build -t solenovex/aspnetcore .&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用docker build，-t表示tag，然后是用户名和要起的镜像名，镜像名后边可以跟着具体的tag，例如solenovex/aspnetcore:1.0，如果不加的话就是latest。最后一个.表示当前这个含有Dockerfile目录是我要进行构建的内容。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;执行的时候会遇到.net sdk版本不匹配的问题，也就是microsoft/aspnetcore-build这个镜像的.net sdk版本有点低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121203924273-1614535074.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以，我只好改为使用microsoft/dotnet:2.1-sdk这个镜像了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121203959115-364740148.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;再次执行：&lt;strong&gt;docker build -t solenovex/aspnetcore .&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个构建的过程还是挺快的，过程大概如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121204141535-1963642947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功了。&lt;/p&gt;

&lt;p&gt;然后从VSCode的docker扩展里就可以看到我刚刚创建的镜像：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121202037529-122370967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后在Powershell里面创建/运行一个容器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121204225056-1511132757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;执行docker ps -a：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121204258606-1647758063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到该容器运行后就马上退出了，查看一下日志看看原因：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121204328905-1515386642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;错误信息是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181121213407690-757779588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这个错误信息感觉并不明确。&lt;/p&gt;

&lt;p&gt;具体怎么解决这个错误，且听下回分解。。&lt;/p&gt;


&lt;/div&gt;
</description>
<pubDate>Wed, 21 Nov 2018 13:36:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<og:description>Dockerfile 在Docker的世界里，我们可以通过一个叫Dockerfile的文件来创建Docker镜像，随后可以运行容器。 Dockerfile就是一个文本文件，里面写着一些指令。通过Doc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/9997124.html</dc:identifier>
</item>
<item>
<title>操作系统：一个老汉的无声告白 - 了不起的厂长</title>
<link>http://www.cnblogs.com/enochzzg/p/9997978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enochzzg/p/9997978.html</guid>
<description>&lt;p&gt;老夫生于上世纪五十年代，作为八零后的大叔，九零后的老伯，同时也是你们动辄就要重装的操作系统，我的学名是“计算机管理控制程序”，英译“operating system”，小老弟们常喊我“OS”。虽说是老弟，目的却都不怎么单纯，大部分人只想玩我，剩下一小撮人却钟爱探索我的身体，他们沉迷于当下，但真正愿意了解我过去的所剩无几。今儿个趁机会给你们介绍一下我的过去。&lt;/p&gt;

&lt;h3 id=&quot;2899-1542638334018&quot;&gt;&lt;strong&gt;人工操作&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在我幼年时期，虽然跟我打交道的绝大部分都是精英程序员，但做的事还是很基础的，想执行一段程序必须先把代码写到卡片上，塞到我身体里，打开开关，等我对数据进行计算，计算完毕后再把卡片卸下来，这才把控制权交给下一个人，这就叫做“人工操作方式”。但是很明显，我的处理能力是有目共睹的，本来几秒钟就能处理完的作业，偏偏人工操作就等了几分钟，不仅我心急，后面排队的人也很容易跟他干架，可如果把浪费的时间用来处理其它作业，效率一定会蹭蹭的往上涨。&lt;/p&gt;

&lt;h3 id=&quot;2811-1542639378385&quot;&gt;&lt;strong&gt;单道批处理系统&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为了解决等待人工操作的问题，绝顶聪明的我想到了一个好方法，首先准备一个磁带作为存储设备，程序员将作业聚在一起塞给我，然后我成批的将作业读入磁带，这时候程序员们就可以走开做别的事了。showtime！接下来只需依次将作业装入内存，计算数据并输出结果即可。因我引以为傲的处理能力自然而然的就省下了等待人工操作的时间。&lt;/p&gt;

&lt;p&gt;虽然有了批量处理的能力，但还是有很大的缺陷，因为我一次只能执行一个作业，所以作业执行时是独占我所有资源的。这意味着当我进行I/O时，我的CPU是无事可做的，非常浪费资源，如果让空闲的CPU去处理其它作业，理论上就能做到同时处理两个作业了。&lt;/p&gt;

&lt;h3 id=&quot;1228-1542641417698&quot;&gt;&lt;strong&gt;多道批处理系统&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;说干就干，接下来我进行了一些改造，目的就是“谁闲给谁活干”——当一个作业在使用CPU时，另一个作业可以进行I/O，反之亦然。这样不仅实现了多个作业的同时处理，还提高了老夫的资源利用率和吞吐能力。与此同时，我不再严格按照顺序装载作业，而是由我的作业调度程序负责分配作业的装载，并由进程调度程序分配CPU，这样权责分明，更有利于日后调度策略的优化和调整。&lt;/p&gt;

&lt;p&gt;现在的作业已经不同以往，不再独占全机，但它们却面临着共享CPU、内存、设备等问题。有共享就会有资源归属权的冲突，既然可预见到冲突就得提前预防，怎么预防呢？这就需要有专门的模块来管理规避由共享产生的冲突问题，比如CPU管理、内存管理、设备管理等，这些模块是我的灵魂，也是以后主要围绕的发展方向。&lt;/p&gt;

&lt;p&gt;虽然比起单道时期的我性能得到极大提升，但人嘛毕竟是不知足的，机器也一样。我的平均周转时间还有很大的改善空间，周转时间呢，是指从作业提交给系统到执行完毕所花费的时间，而平均周转时间是指“所有作业的时间总和与作业总数的比值”，平均周转时间越小意味着性能越高。减少该时间最有效的方式就是调整调度策略，让所有作业尽可能快的执行完毕，调度策略相对复杂，以后的章节再给大家讲解。除平均周转时间外，与用户交互能力的提升也是我的重中之重，现在的我只能同时与一个程序员进行交流，但这是远远不够的，要和人类长期打交道，他们的满意度才是我迈向成功的最高准则。&lt;/p&gt;

&lt;h3 id=&quot;76kbsl1542690453164&quot;&gt;&lt;strong&gt;分时操作系统&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;为解决人类强烈的交互欲望，努力修炼的我终于练就了一套绝世武功——时间片轮转法。这是一套极强的掌法，用户可以通过若干个终端连接到我这里，我按一定时间间隔轮流的为各个终端服务，由于我极快的处理速度，用户完全无法感知我做了什么手脚，以至于他们认为我只为他们本人服务，而现在每天打游戏的你仍然在走着我的套路/滑稽，正所谓“天下武功唯快不破”，而这种戏弄你们的感觉让我奇爽无比。&lt;/p&gt;

&lt;h3 id=&quot;39pxsq1542761000619&quot;&gt;&lt;strong&gt;实时操作系统&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;如果说分时的我一定要有缺陷的话，那么在某些场景下公平的分时就是我的缺陷。刚才讲到分时是用时间片轮转法轮流的为每个用户服务，虽能诓得了小白，但在高精尖领域不太适用，比如航空航天、海底探测，丝毫的处理延迟可能会导致无法挽回的后果，想要解决延迟，时间片就不能过于均衡，优先级高的要先执行，但总执行优先级高的又会导致低权重的一直得不到执行，或是两个同样高优先级的作业因互抢资源发生死锁，听起来很复杂吧，但这就是调度策略的艺术之处。不过我一时半会也解释不清楚，要不就先到这里吧，我要关机了，以下是我为你们整理的思维导图，拜拜。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1471773/201811/1471773-20181121212558040-868949722.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 21 Nov 2018 13:29:00 +0000</pubDate>
<dc:creator>了不起的厂长</dc:creator>
<og:description>老夫生于上世纪五十年代，作为八零后的大叔，九零后的老伯，同时也是你们动辄就要重装的操作系统，我的学名是“计算机管理控制程序”，英译“operating system”，小老弟们常喊我“OS”。虽说是老</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enochzzg/p/9997978.html</dc:identifier>
</item>
<item>
<title>数据库（三） - Eurekaa</title>
<link>http://www.cnblogs.com/zuanzuan/p/9997948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuanzuan/p/9997948.html</guid>
<description>&lt;p&gt;本篇博客主要内容为表之间的关系、多表关联、复制表；查询如单表查询、多表关联查询&lt;/p&gt;

&lt;h2 id=&quot;为什么要分表&quot;&gt;为什么要分表？&lt;/h2&gt;
&lt;p&gt;假如现在有两种数据，一种是部门数据一种是员工数据，如果两中数据放在同一张表中则会造成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据重复&lt;/li&gt;
&lt;li&gt;结构混乱&lt;/li&gt;
&lt;li&gt;扩展维护性差&lt;/li&gt;
&lt;li&gt;需要分表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以需要把表中会造成混乱的数据分出来，分成两张表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table dept(id int primary key auto_increment,name char(20),job char(20));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table emp(id int primary key auto_increment,name char(20),gender char,age int,salary float,d_id int);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么时候需要分表？&lt;/p&gt;
&lt;p&gt;当出现大量重复数据时，当一条记录中的数据不属于同一类时需要分表。&lt;/p&gt;
&lt;p&gt;分表之后产生的问题，员工表可以存储一个不存在的部门编号，这样的数据是不完整的无效数据，必须找到一种方法可以在物理层面建立关联关系。&lt;/p&gt;
&lt;p&gt;以上建表语句可以建立逻辑上的关联关系，这有建表的人才明白其中的关系，而 mysql 并不知道关系，所以需要通过外键来进行约束，说明这两张表的关联关系。&lt;/p&gt;
&lt;h2 id=&quot;外键的使用&quot;&gt;外键的使用&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table 表名(字段名 类型(长度),foreign key(外键的字段名) references 要关联表名(主键名));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用外键时必须分清主从关系，也就是要分清先键那张表，因为在使用外键关联表时，需要知道对方表的表名，所以要关联的表应该是主表，应该先建主表，这样才能关联起来。&lt;/p&gt;
&lt;h3 id=&quot;外键的第一个约束&quot;&gt;外键的第一个约束&lt;/h3&gt;
&lt;p&gt;先键主表，再建从表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table dept(id int primary key auto_increment,name char(20),job char(20));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table emp(id int primary key auto_increment,name char(20),d_id int,foreign key(d_id) references dept(id));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;外键的第二个约束&quot;&gt;外键的第二个约束&lt;/h3&gt;
&lt;p&gt;数据先插入主表，再插入从表数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; insert into dept values(1,'hr','招聘');&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; insert into emp values(1,'张无忌',1);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;外键的第三个约束&quot;&gt;外键的第三个约束&lt;/h3&gt;
&lt;p&gt;删除数据时先删从表，再删主表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; delete from emp where name = '张无忌';&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; delete from dept where id = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;外键的第四个约束&quot;&gt;外键的第四个约束&lt;/h3&gt;
&lt;p&gt;从表更新外键时必须保证外键是存在的。&lt;/p&gt;
&lt;h3 id=&quot;外键的第五个约束&quot;&gt;外键的第五个约束&lt;/h3&gt;
&lt;p&gt;更新主表的 id 时，要么先删除从表关联的数据，或者把关联数据关联到其他的主表 id。&lt;/p&gt;
&lt;p&gt;有了这几种约束后，可以保证数据的完整性。相应的受到外键约束，主表的删除和更新操作受到限制，很多情况下，删除主表某个数据需要至少两条sql 语句，会很麻烦。&lt;/p&gt;
&lt;h3 id=&quot;外键的第六个约束&quot;&gt;外键的第六个约束&lt;/h3&gt;
&lt;p&gt;删除主表时，要先删除从表。&lt;/p&gt;
&lt;h3 id=&quot;级联操作&quot;&gt;级联操作&lt;/h3&gt;
&lt;h4 id=&quot;删除级联&quot;&gt;删除级联&lt;/h4&gt;
&lt;p&gt;当主表删除时，从表相关联的记录同步删除&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table emp(id int primary key auto_increment,name char(20),d_id int,foreign key(d_id) references dept(id) on delete cascade);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;更新级联&quot;&gt;更新级联&lt;/h4&gt;
&lt;p&gt;当主表 id 时，从表相关联的记录通步更新&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table emp(id int primary key auto_increment,name char(20),d_id int,foreign key(d_id) references dept(id) on update cascade);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;级联方向只能是主表级联从表，可以在操作主表时自动操作从表。（单箱操作，主表变化是级联操作从表，从表的变化不会影响主表）&lt;/p&gt;
&lt;h2 id=&quot;一对一关系&quot;&gt;一对一关系&lt;/h2&gt;
&lt;p&gt;一对一的关系只需要加一个外键来关联即可，但是需要给外键加上唯一约束。有主从关系的都需要先建主表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create customer(c_id int primary key auto_increment,name char(20),phonenum char(11),addr char(20));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create student(s_id int primary key auto_increment,name char(20),class char(11),number char(20),housenum char(20),c_id int unique,foreign key(c_id) references customer(c_id)); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一对一的另一种使用场景，当一个表的字段太多，而常用的字段不多时，可以采取垂直分表的方式来提高效率，比如个人信息有身份证、性别、年龄、地址等，可以拆分为基础信息和细节信息；也有另一种提升效率的方式，水平分表，当一个表中的数据记录太多时，效率会降低，可以采取水平分表，字段完全相同。&lt;/p&gt;
&lt;h2 id=&quot;多对多关系&quot;&gt;多对多关系&lt;/h2&gt;
&lt;p&gt;假如有两张表，一张表存的是老师，另一张表存的是学生。因为一个老师可以教多个学生，一个学生也可以有多个老师，所以这是双向多对一的关系，也就是多对多的关系。那么应该怎么存储数据呢？&lt;/p&gt;
&lt;p&gt;可以通过增加一个中间表来存储两张表的关系，然后其他两张表分别用一个字段作为外键来关联中间表。（只要是多对多关系都是靠中间表来存储两张表之间的关系）除了中间表，另外两张都是主表，具体先建哪种主表没有先后顺序。多对多关系至少需要三张表。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table stu(id int primary key auto_increment,name char(20));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table tea(id int primary key auto_increment,name char(20));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table tsr(id int primary key auto_increment，t_id int,s_id int,foreign key(t_id) references tea(id),foreign key(s_id) references stu(id));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为老师和学生都是主表，关系表是从表，所以需要先插入老师和学生的数据，接着插入中间表的数据。&lt;/p&gt;
&lt;p&gt;多对多关系表中因为已经有了 id 为主键，所以可以重复存入相同的学生和老师关系数据，可以通过联合主键改变。&lt;/p&gt;
&lt;h2 id=&quot;多对一关系&quot;&gt;多对一关系&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table dept(id int primary key auto_increment,name char(20),job char(20));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table emp(id int primary key auto_increment,name char(20),d_id int,foreign key(d_id) references dept(id));&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table 新表名 select * from 被复制的表名;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意不会复制主键和约束条件，数据结构都可以复制。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create table 新表名 select * from 源表名 where 1 = 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当where 后面条件不成立时，只会复制表结构。&lt;/p&gt;
&lt;h2 id=&quot;蠕虫复制&quot;&gt;蠕虫复制&lt;/h2&gt;
&lt;p&gt;自我复制。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; insert into 表名 select * from 表名;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果有主键&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; insert into 表名(其他字段) select 其他字段 from 表名;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在日常开发中，如果对性能要求很高，不应该使用外键&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;效率降低&lt;/li&gt;
&lt;li&gt;耦合 关系多起来会造成管理麻烦&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这时候关系只是逻辑关系很有可能产生错误数据。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Nov 2018 13:24:00 +0000</pubDate>
<dc:creator>Eurekaa</dc:creator>
<og:description>前言 本篇博客主要内容为表之间的关系、多表关联、复制表；查询如单表查询、多表关联查询 表之间关系 为什么要分表？ 假如现在有两种数据，一种是部门数据一种是员工数据，如果两中数据放在同一张表中则会造成：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuanzuan/p/9997948.html</dc:identifier>
</item>
</channel>
</rss>