<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring源码情操陶冶#task:scheduled-tasks解析器 - 南柯问天</title>
<link>http://www.cnblogs.com/question-sky/p/8733461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/question-sky/p/8733461.html</guid>
<description>&lt;blockquote readability=&quot;4.5538461538462&quot;&gt;
&lt;p&gt;承接前文&lt;a href=&quot;http://www.cnblogs.com/question-sky/p/8709929.html&quot;&gt;Spring源码情操陶冶#task:executor解析器&lt;/a&gt;，在前文基础上解析我们常用的spring中的定时任务的节点配置。&lt;strong&gt;备注：此文建立在spring的4.2.3.RELEASE版本&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;附例&quot;&gt;附例&lt;/h3&gt;
&lt;p&gt;Spring中的定时任务基本配置样例如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!--create schedule thread pool--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;task:scheduler&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;baseScheduler&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; pool-size=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;5&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/task:scheduler&amp;gt;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;&amp;lt;!--define bean for schedule task--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;taskBean&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.jing.test.spring.task.TaskBean&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;&amp;lt;!--apply schedule action to above taskBean--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;task:scheduled-tasks&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; scheduler=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;baseScheduler&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;task:scheduled&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;taskBean&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;doInit&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; cron=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0 0 0 ? * *&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/task:scheduled&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;task:scheduled&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;taskBean&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;doClear&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; cron=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0 0 23 ? * *&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/task:scheduled&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/task:scheduled-tasks&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;task:scheduler&lt;/code&gt;的配置是不必须的，并且由上述配置可知Spring配置的定时任务可细化到具体的类方法，有更好的扩展性&lt;/p&gt;
&lt;h3 id=&quot;taskscheduler节点配置的作用&quot;&gt;task:scheduler节点配置的作用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;task:scheduler&lt;/code&gt;的节点配置与前文所提及的&lt;code&gt;task:executor&lt;/code&gt;节点类似，均是创建线程池，那么有什么不同呢，我们可以稍微简单的看下其解析类&lt;code&gt;org.springframework.scheduling.config.SchedulerBeanDefinitionParser&lt;/code&gt;的两个方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getBeanClassName&lt;/span&gt;(Element element) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler&quot;&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doParse&lt;/span&gt;(Element element, BeanDefinitionBuilder builder) {
        String poolSize = element.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;pool-size&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;hasText&lt;/span&gt;(poolSize)) {
            builder.&lt;span class=&quot;fu&quot;&gt;addPropertyValue&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;poolSize&quot;&lt;/span&gt;, poolSize);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;恩，也就是我们直接关注&lt;code&gt;ThreadPoolTaskScheduler&lt;/code&gt;这个类即可。看下其是如何创建线程池的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Create a new &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{@link ScheduledExecutorService}&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; instance.&lt;/span&gt;
&lt;span class=&quot;er&quot;&gt;     * &amp;lt;p&amp;gt;The default implementation creates a {@link ScheduledThreadPoolExecutor}.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Can be overridden in subclasses to provide custom &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;{@link ScheduledExecutorService}&lt;/span&gt;&lt;span class=&quot;co&quot;&gt; instances.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param poolSize &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the specified pool size&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param threadFactory &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the ThreadFactory to use&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param rejectedExecutionHandler &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;the RejectedExecutionHandler to use&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@return &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;a new ScheduledExecutorService instance&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@see #afterPropertiesSet()&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@see java.util.concurrent.ScheduledThreadPoolExecutor&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; ScheduledExecutorService &lt;span class=&quot;fu&quot;&gt;createExecutor&lt;/span&gt;(
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; poolSize, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) {

        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ScheduledThreadPoolExecutor(poolSize, threadFactory, rejectedExecutionHandler);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即默认创建的是&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;线程池，创建核心线程个数为&lt;code&gt;pool-size&lt;/code&gt;指定的大小(默认为1)，最大线程为&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，队列为&lt;code&gt;DelayedWorkQueue&lt;/code&gt;，拒绝策略为&lt;code&gt;AbortPolicy&lt;/code&gt;。详情读者可自行阅读&lt;/p&gt;
&lt;h3 id=&quot;tasksheduled-tasks解析器&quot;&gt;task:sheduled-tasks解析器&lt;/h3&gt;
&lt;p&gt;配置相应的定时任务，细化到任何bean的方法可直接关联定时器。我们同样观察其主要的两个方法&lt;code&gt;getBeanClassName()&lt;/code&gt;和&lt;code&gt;doParse()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getBeanClassName&lt;/span&gt;(Element element) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;org.springframework.scheduling.config.ContextLifecycleScheduledTaskRegistrar&quot;&lt;/span&gt;;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即实例化并启动定时任务由&lt;code&gt;ContextLifecycleScheduledTaskRegistrar&lt;/code&gt;类来执行，我们稍后再谈&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doParse&lt;/span&gt;(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
        builder.&lt;span class=&quot;fu&quot;&gt;setLazyInit&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// lazy scheduled tasks are a contradiction in terms -&amp;gt; force to false&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 存放不同类型定时任务集合&lt;/span&gt;
        ManagedList&amp;lt;RuntimeBeanReference&amp;gt; cronTaskList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ManagedList&amp;lt;RuntimeBeanReference&amp;gt;();
        ManagedList&amp;lt;RuntimeBeanReference&amp;gt; fixedDelayTaskList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ManagedList&amp;lt;RuntimeBeanReference&amp;gt;();
        ManagedList&amp;lt;RuntimeBeanReference&amp;gt; fixedRateTaskList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ManagedList&amp;lt;RuntimeBeanReference&amp;gt;();
        ManagedList&amp;lt;RuntimeBeanReference&amp;gt; triggerTaskList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ManagedList&amp;lt;RuntimeBeanReference&amp;gt;();
        &lt;span class=&quot;co&quot;&gt;// 解析子节点task:scheduled&lt;/span&gt;
        NodeList childNodes = element.&lt;span class=&quot;fu&quot;&gt;getChildNodes&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; childNodes.&lt;span class=&quot;fu&quot;&gt;getLength&lt;/span&gt;(); i++) {
            Node child = childNodes.&lt;span class=&quot;fu&quot;&gt;item&lt;/span&gt;(i);
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isScheduledElement&lt;/span&gt;(child, parserContext)) {
                &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;
            }
            Element taskElement = (Element) child;
            String ref = taskElement.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ref&quot;&lt;/span&gt;);
            String method = taskElement.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;method&quot;&lt;/span&gt;);

            &lt;span class=&quot;co&quot;&gt;// ref 和 method属性必须同时指定，表示对哪个方法关联定时器&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!StringUtils.&lt;span class=&quot;fu&quot;&gt;hasText&lt;/span&gt;(ref) || !StringUtils.&lt;span class=&quot;fu&quot;&gt;hasText&lt;/span&gt;(method)) {
                parserContext.&lt;span class=&quot;fu&quot;&gt;getReaderContext&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Both 'ref' and 'method' are required&quot;&lt;/span&gt;, taskElement);
                &lt;span class=&quot;co&quot;&gt;// Continue with the possible next task element&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;;
            }

            String cronAttribute = taskElement.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;cron&quot;&lt;/span&gt;);
            String fixedDelayAttribute = taskElement.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;fixed-delay&quot;&lt;/span&gt;);
            String fixedRateAttribute = taskElement.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;fixed-rate&quot;&lt;/span&gt;);
            String triggerAttribute = taskElement.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;trigger&quot;&lt;/span&gt;);
            String initialDelayAttribute = taskElement.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;initial-delay&quot;&lt;/span&gt;);

            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; hasCronAttribute = StringUtils.&lt;span class=&quot;fu&quot;&gt;hasText&lt;/span&gt;(cronAttribute);
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; hasFixedDelayAttribute = StringUtils.&lt;span class=&quot;fu&quot;&gt;hasText&lt;/span&gt;(fixedDelayAttribute);
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; hasFixedRateAttribute = StringUtils.&lt;span class=&quot;fu&quot;&gt;hasText&lt;/span&gt;(fixedRateAttribute);
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; hasTriggerAttribute = StringUtils.&lt;span class=&quot;fu&quot;&gt;hasText&lt;/span&gt;(triggerAttribute);
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; hasInitialDelayAttribute = StringUtils.&lt;span class=&quot;fu&quot;&gt;hasText&lt;/span&gt;(initialDelayAttribute);
            
            &lt;span class=&quot;co&quot;&gt;// 必须指定cron/fixed-delay/fixed-rate/trigger属性&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!(hasCronAttribute || hasFixedDelayAttribute || hasFixedRateAttribute || hasTriggerAttribute)) {
                parserContext.&lt;span class=&quot;fu&quot;&gt;getReaderContext&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(
                        &lt;span class=&quot;st&quot;&gt;&quot;one of the 'cron', 'fixed-delay', 'fixed-rate', or 'trigger' attributes is required&quot;&lt;/span&gt;, taskElement);
                &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// with the possible next task element&lt;/span&gt;
            }

            &lt;span class=&quot;co&quot;&gt;//initial-delay属性不与cron/trigger属性搭配&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hasInitialDelayAttribute &amp;amp;&amp;amp; (hasCronAttribute || hasTriggerAttribute)) {
                parserContext.&lt;span class=&quot;fu&quot;&gt;getReaderContext&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;error&lt;/span&gt;(
                        &lt;span class=&quot;st&quot;&gt;&quot;the 'initial-delay' attribute may not be used with cron and trigger tasks&quot;&lt;/span&gt;, taskElement);
                &lt;span class=&quot;kw&quot;&gt;continue&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// with the possible next task element&lt;/span&gt;
            }

            &lt;span class=&quot;co&quot;&gt;// 将bean类下的method方法包装成ScheduledMethodRunnable.class实体类&lt;/span&gt;
            String runnableName =
                    &lt;span class=&quot;fu&quot;&gt;runnableReference&lt;/span&gt;(ref, method, taskElement, parserContext).&lt;span class=&quot;fu&quot;&gt;getBeanName&lt;/span&gt;();

            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hasFixedDelayAttribute) {
                &lt;span class=&quot;co&quot;&gt;// 包装成IntervalTask类&lt;/span&gt;
                fixedDelayTaskList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;intervalTaskReference&lt;/span&gt;(runnableName,
                        initialDelayAttribute, fixedDelayAttribute, taskElement, parserContext));
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hasFixedRateAttribute) {
                &lt;span class=&quot;co&quot;&gt;// 包装成IntervalTask类&lt;/span&gt;
                fixedRateTaskList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;intervalTaskReference&lt;/span&gt;(runnableName,
                        initialDelayAttribute, fixedRateAttribute, taskElement, parserContext));
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hasCronAttribute) {
                &lt;span class=&quot;co&quot;&gt;// 包装成CronTask类&lt;/span&gt;
                cronTaskList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;cronTaskReference&lt;/span&gt;(runnableName, cronAttribute,
                        taskElement, parserContext));
            }
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (hasTriggerAttribute) {
                &lt;span class=&quot;co&quot;&gt;// 包装成TriggerTask类&lt;/span&gt;
                String triggerName = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RuntimeBeanReference&lt;/span&gt;(triggerAttribute).&lt;span class=&quot;fu&quot;&gt;getBeanName&lt;/span&gt;();
                triggerTaskList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;triggerTaskReference&lt;/span&gt;(runnableName, triggerName,
                        taskElement, parserContext));
            }
        }
        &lt;span class=&quot;co&quot;&gt;// scheduler属性&lt;/span&gt;
        String schedulerRef = element.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;scheduler&quot;&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;hasText&lt;/span&gt;(schedulerRef)) {
            builder.&lt;span class=&quot;fu&quot;&gt;addPropertyReference&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;taskScheduler&quot;&lt;/span&gt;, schedulerRef);
        }
        builder.&lt;span class=&quot;fu&quot;&gt;addPropertyValue&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;cronTasksList&quot;&lt;/span&gt;, cronTaskList);
        builder.&lt;span class=&quot;fu&quot;&gt;addPropertyValue&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;fixedDelayTasksList&quot;&lt;/span&gt;, fixedDelayTaskList);
        builder.&lt;span class=&quot;fu&quot;&gt;addPropertyValue&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;fixedRateTasksList&quot;&lt;/span&gt;, fixedRateTaskList);
        builder.&lt;span class=&quot;fu&quot;&gt;addPropertyValue&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;triggerTasksList&quot;&lt;/span&gt;, triggerTaskList);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;代码过长，此处作下小总结&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;定时任务的初始化与实例是由&lt;code&gt;org.springframework.scheduling.config.ContextLifecycleScheduledTaskRegistrar&lt;/code&gt;类来加载执行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;task:scheduled-tasks&lt;/code&gt;的子节点名为&lt;code&gt;task:scheduled&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;task:scheduled&lt;/code&gt;中的&lt;code&gt;ref&lt;/code&gt;和&lt;code&gt;method&lt;/code&gt;属性是必填项；必须指定&lt;code&gt;cron/fixed-delay/fixed-rate/trigger&lt;/code&gt;其中之一属性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;task-scheduled&lt;/code&gt;中&lt;code&gt;initial-delay&lt;/code&gt;属性不必填，但其不和&lt;code&gt;cron/trigger&lt;/code&gt;属性搭配使用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;task:scheduled&lt;/code&gt;中的&lt;code&gt;cron&lt;/code&gt;代表cron表达式，为字符串形式；&lt;code&gt;fixed-delay&lt;/code&gt;和&lt;code&gt;fixed-rate&lt;/code&gt;可与&lt;code&gt;initial-delay&lt;/code&gt;搭配使用，一般选择其中一种即可，为数字形式；&lt;code&gt;trigger&lt;/code&gt;代表的是触发器，其关联bean，字符串形式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;根据第五点，具体的任务包装类分别为&lt;code&gt;CronTask&lt;/code&gt;、&lt;code&gt;IntervalTask&lt;/code&gt;、&lt;code&gt;TriggerTask&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;contextlifecyclescheduledtaskregistrar-定时任务初始化&quot;&gt;ContextLifecycleScheduledTaskRegistrar-定时任务初始化&lt;/h3&gt;
&lt;p&gt;其默认实现了&lt;code&gt;SmartInitializingSingleton&lt;/code&gt;的&lt;code&gt;afterSingletonsInstantiated()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;afterSingletonsInstantiated&lt;/span&gt;() {
        &lt;span class=&quot;fu&quot;&gt;scheduleTasks&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接查看父类的&lt;code&gt;schduleTasks()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;scheduleTasks&lt;/span&gt;() {
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; now = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// 如果不指定scheduler属性，则默认使用单线程池模型&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;taskScheduler&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;localExecutor&lt;/span&gt; = Executors.&lt;span class=&quot;fu&quot;&gt;newSingleThreadScheduledExecutor&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;taskScheduler&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConcurrentTaskScheduler&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;localExecutor&lt;/span&gt;);
        }
        &lt;span class=&quot;co&quot;&gt;// trigger集合和cron集合统一调用任务定时器的schedule()方法&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;triggerTasks&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (TriggerTask task : &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;triggerTasks&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledFutures&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;taskScheduler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(
                        task.&lt;span class=&quot;fu&quot;&gt;getRunnable&lt;/span&gt;(), task.&lt;span class=&quot;fu&quot;&gt;getTrigger&lt;/span&gt;()));
            }
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;cronTasks&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (CronTask task : &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;cronTasks&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledFutures&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;taskScheduler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(
                        task.&lt;span class=&quot;fu&quot;&gt;getRunnable&lt;/span&gt;(), task.&lt;span class=&quot;fu&quot;&gt;getTrigger&lt;/span&gt;()));
            }
        }
        &lt;span class=&quot;co&quot;&gt;// fixedRate集合和fixedDelayTasks集合则分别调用任务定时器的scheduleAtFixedRate()和scheduleAtFixedDelay()方法&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;fixedRateTasks&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (IntervalTask task : &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;fixedRateTasks&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (task.&lt;span class=&quot;fu&quot;&gt;getInitialDelay&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                    Date startTime = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date(now + task.&lt;span class=&quot;fu&quot;&gt;getInitialDelay&lt;/span&gt;());
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledFutures&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;taskScheduler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduleAtFixedRate&lt;/span&gt;(
                            task.&lt;span class=&quot;fu&quot;&gt;getRunnable&lt;/span&gt;(), startTime, task.&lt;span class=&quot;fu&quot;&gt;getInterval&lt;/span&gt;()));
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledFutures&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;taskScheduler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduleAtFixedRate&lt;/span&gt;(
                            task.&lt;span class=&quot;fu&quot;&gt;getRunnable&lt;/span&gt;(), task.&lt;span class=&quot;fu&quot;&gt;getInterval&lt;/span&gt;()));
                }
            }
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;fixedDelayTasks&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (IntervalTask task : &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;fixedDelayTasks&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (task.&lt;span class=&quot;fu&quot;&gt;getInitialDelay&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                    Date startTime = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date(now + task.&lt;span class=&quot;fu&quot;&gt;getInitialDelay&lt;/span&gt;());
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledFutures&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;taskScheduler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduleWithFixedDelay&lt;/span&gt;(
                            task.&lt;span class=&quot;fu&quot;&gt;getRunnable&lt;/span&gt;(), startTime, task.&lt;span class=&quot;fu&quot;&gt;getInterval&lt;/span&gt;()));
                }
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledFutures&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;taskScheduler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduleWithFixedDelay&lt;/span&gt;(
                            task.&lt;span class=&quot;fu&quot;&gt;getRunnable&lt;/span&gt;(), task.&lt;span class=&quot;fu&quot;&gt;getInterval&lt;/span&gt;()));
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由上述代码可以得出，如果&lt;code&gt;task:scheduled-tasks&lt;/code&gt;不指定&lt;code&gt;scheduler&lt;/code&gt;属性，则默认会采用&lt;code&gt;org.springframework.scheduling.concurrent.ConcurrentTaskScheduler&lt;/code&gt;任务定时器来管理任务集合，反之一般则是由&lt;code&gt;org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler&lt;/code&gt;任务定时器来管理任务集合&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;本文则是解析了&lt;code&gt;task:scheduled-task&lt;/code&gt;与&lt;code&gt;task:scheduler&lt;/code&gt;节点的配置，具体的任务是如何被执行的，怎么控制定时任务，请见下文针对&lt;code&gt;org.springframework.scheduling.concurrent.ConcurrentTaskScheduler&lt;/code&gt;和&lt;code&gt;org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler&lt;/code&gt;两个任务定时器分别做详细的解读&lt;/p&gt;
</description>
<pubDate>Sat, 07 Apr 2018 07:35:00 +0000</pubDate>
<dc:creator>南柯问天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/question-sky/p/8733461.html</dc:identifier>
</item>
<item>
<title>解决yii2中 Class yii/web/JsonParser does not exist, ReflectionException问题 - 勾践</title>
<link>http://www.cnblogs.com/goujian/p/8733469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goujian/p/8733469.html</guid>
<description>&lt;p&gt;最近在调试RESTful API示例时，出现以下错误：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &quot;name&quot;: &quot;Exception&quot;,
&lt;span&gt; 3&lt;/span&gt;     &quot;message&quot;: &quot;Class yii/web/JsonParser does not exist&quot;,
&lt;span&gt; 4&lt;/span&gt;     &quot;code&quot;: -1,
&lt;span&gt; 5&lt;/span&gt;     &quot;type&quot;: &quot;ReflectionException&quot;,
&lt;span&gt; 6&lt;/span&gt;     &quot;file&quot;: &quot;/Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/di/Container.php&quot;,
&lt;span&gt; 7&lt;/span&gt;     &quot;line&quot;: 426,
&lt;span&gt; 8&lt;/span&gt;     &quot;stack-trace&quot;:&lt;span&gt; [
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &quot;#0 /Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/di/Container.php(426): ReflectionClass-&amp;gt;__construct('yii/web/JsonPar...')&quot;,
&lt;span&gt;10&lt;/span&gt;         &quot;#1 /Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/di/Container.php(364): yii\\di\\Container-&amp;gt;getDependencies('yii/web/JsonPar...')&quot;,
&lt;span&gt;11&lt;/span&gt;         &quot;#2 /Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/di/Container.php(156): yii\\di\\Container-&amp;gt;build('yii/web/JsonPar...', Array, Array)&quot;,
&lt;span&gt;12&lt;/span&gt;         &quot;#3 /Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/BaseYii.php(345): yii\\di\\Container-&amp;gt;get('yii/web/JsonPar...', Array)&quot;,
&lt;span&gt;13&lt;/span&gt;         &quot;#4 /Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/web/Request.php(531): yii\\BaseYii::createObject('yii/web/JsonPar...')&quot;,
&lt;span&gt;14&lt;/span&gt;         &quot;#5 /Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/rest/CreateAction.php(51): yii\\web\\Request-&amp;gt;getBodyParams()&quot;,
&lt;span&gt;15&lt;/span&gt;         &quot;#6 [internal function]: yii\\rest\\CreateAction-&amp;gt;run()&quot;,
&lt;span&gt;16&lt;/span&gt;         &quot;#7 /Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/base/Action.php(94): call_user_func_array(Array, Array)&quot;,
&lt;span&gt;17&lt;/span&gt;         &quot;#8 /Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/base/Controller.php(157): yii\\base\\Action-&amp;gt;runWithParams(Array)&quot;,
&lt;span&gt;18&lt;/span&gt;         &quot;#9 /Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/base/Module.php(528): yii\\base\\Controller-&amp;gt;runAction('create', Array)&quot;,
&lt;span&gt;19&lt;/span&gt;         &quot;#10 /Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/web/Application.php(103): yii\\base\\Module-&amp;gt;runAction('deptinfo/create', Array)&quot;,
&lt;span&gt;20&lt;/span&gt;         &quot;#11 /Users/Desktop/workspaces/php/yii2-ims/vendor/yiisoft/yii2/base/Application.php(386): yii\\web\\Application-&amp;gt;handleRequest(Object(yii\\web\\Request))&quot;,
&lt;span&gt;21&lt;/span&gt;         &quot;#12 /Users/Desktop/workspaces/php/yii2-ims/api/web/index.php(10): yii\\base\\Application-&amp;gt;run()&quot;,
&lt;span&gt;22&lt;/span&gt;         &quot;#13 {main}&quot;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    ]
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实，这是自己给自己挖的一个坑，结果把自己给陷进去了，下面是配置文件的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
'request' =&amp;gt;&lt;span&gt; [
            &lt;/span&gt;'class' =&amp;gt; 'yii\web\Request',
            'parsers' =&amp;gt;&lt;span&gt; [
                &lt;/span&gt;'application/json' =&amp;gt; 'yii/web/JsonParser',&lt;span&gt;
            ]&lt;/span&gt;,&lt;span&gt;
        ]&lt;/span&gt;,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题就在于配置时将 “yii/web/JsonParser”写错了，正确的是 “yii\web\JsonParser”，命名空间应以反斜杠“\”分割，看似很小的问题，结果调试了很长时间才找到原因，所以在写代码配置的时候一定要认真仔细，以免被自己误导，浪费宝贵的时间。 &lt;/p&gt;

</description>
<pubDate>Sat, 07 Apr 2018 07:35:00 +0000</pubDate>
<dc:creator>勾践</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goujian/p/8733469.html</dc:identifier>
</item>
<item>
<title>使用JavaScript实现一个俄罗斯方块 - 贾顺名</title>
<link>http://www.cnblogs.com/jiasm/p/8733356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiasm/p/8733356.html</guid>
<description>&lt;p class=&quot;post-title&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;5.0931034482759&quot;&gt;
&lt;p&gt;清明假期期间，闲的无聊，就做了一个小游戏玩玩，目前游戏逻辑上暂未发现bug，只不过样子稍微丑了一些-.-&lt;br/&gt;项目地址：&lt;a href=&quot;https://github.com/Jiasm/tetris&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;https://github.com/Jiasm/tetris&lt;/a&gt;&lt;br/&gt;在线Demo：&lt;a href=&quot;http://blog.jiasm.org/tetris/?width=16&amp;amp;height=40&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;http://blog.jiasm.org/tetris/?width=16&amp;amp;height=40&lt;/a&gt; (修改URL参数可以调整难度)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整体分成三块进行开发，使用面向对象式编程进行开发（其实我更喜欢用函数式编程，但苦于游戏的一些状态用对象来存储会更直观一些）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Game&lt;/code&gt;：
&lt;ol&gt;&lt;li&gt;负责生成新的方块&lt;/li&gt;
&lt;li&gt;负责方块移动的处理&lt;/li&gt;
&lt;li&gt;方块触底的判断&lt;/li&gt;
&lt;li&gt;移除满足清除条件的行&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Render&lt;/code&gt;：
&lt;ol&gt;&lt;li&gt;负责用&lt;code&gt;Game&lt;/code&gt;的数据来渲染整个游戏界面&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Controller&lt;/code&gt;：
&lt;ol&gt;&lt;li&gt;负责接受用户输入（上下左右各种操作）并处理&lt;/li&gt;
&lt;li&gt;向用户反馈当前游戏的状态&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样分层带来了一个好处，我们游戏的逻辑&lt;code&gt;Game&lt;/code&gt;模块并不依赖于当前程序运行的环境，而&lt;code&gt;Render&lt;/code&gt;可以是&lt;code&gt;Canvas&lt;/code&gt;、&lt;code&gt;DOM&lt;/code&gt;，甚至是控制台输出。我们要移植到其他平台，只需要修改&lt;code&gt;Render&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&quot;项目结构&quot;&gt;项目结构&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;忽略了一些与游戏没有直接关系的结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.
├── model
│   ├── Brick.js
│   ├── Game.js
│   └── index.js
├── utils
│   ├── buildEnum.js
│   ├── deepCopy.js
│   ├── getShape.js
│   ├── index.js
│   ├── lineIndex.js
│   ├── matrixString.js
│   └── rotateArray.js
├── enum
│   ├── gameType.js
│   ├── index.js
│   └── pointType.js
├── data
│   └── shapes.js
├── controller
│   └── index.js
└── view
    ├── RenderCanvas.js
    └── index.js&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote readability=&quot;9.5&quot;&gt;
&lt;p&gt;各目录下的index.js是为了方便同时引用多个文件，大致长这个样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
export { &lt;span&gt;default&lt;/span&gt; as model1 } from './model1'&lt;span&gt;
export { &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; as model2 } from './model2'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后我们就可以在用到的地方写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import { model1, model2 } from './XXX'
&lt;/pre&gt;&lt;/div&gt;

&lt;/blockquote&gt;
&lt;h2 id=&quot;model&quot;&gt;model&lt;/h2&gt;
&lt;p&gt;这里是游戏的核心逻辑所在位置。&lt;/p&gt;
&lt;p&gt;像俄罗斯方块这种的矩阵类游戏，存储数据最合适的方法就是一个二维数组了。&lt;br/&gt;为了更直观一些，我们选择了游戏的高度作为第一层数组的长度：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
matrix = &lt;span&gt;new&lt;/span&gt; Array(height).fill(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array(width))

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; width: 2 height: 4&lt;/span&gt;
&lt;span&gt;[
  [ &lt;/span&gt;1, 1&lt;span&gt;],
  [ &lt;/span&gt;1, 1&lt;span&gt;],
  [ &lt;/span&gt;1, 1&lt;span&gt;],
  [ &lt;/span&gt;1, 1&lt;span&gt;]
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而且这样选择在一些逻辑处理上也会更方便一些：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下移操作时，我们只需改变元素的第一层下标&lt;/li&gt;
&lt;li&gt;判断是否触底时，我们只需将当前下标 + 1 判断是否有元素即可&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们对数组中的元素进行了定义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;0&lt;/code&gt;: 空，表示当前坐标为空白&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt;: 新的方块，表示当前活动的方块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2&lt;/code&gt;: 老的方块，已经触底固定的方块&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，我们就遇到了一个问题，如何处理方块的放置。&lt;br/&gt;我们知道，游戏会不停的向棋盘中加载新的方块。&lt;br/&gt;如果我们每次处理下移的时候，都将当前二维数组中对应的方块元素移除，然后在塞入到新的位置，未免太过繁琐了。&lt;/p&gt;
&lt;p&gt;所以我们在初始化数据时，初始化两个二维数组。&lt;br/&gt;当我们加载一个新的方块后，将方块对应的元素塞入其中的一个二维数组。&lt;br/&gt;然后等到我们有进行其他的操作时，比如左右移动，向下之类的。&lt;br/&gt;我们直接使用第二个二维数组覆盖到当前的数组中去，然后再将更改下标后的方块塞入数组。&lt;br/&gt;这样在数据上，我们就完成了方块的移动。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Game {
  init () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化两个矩阵&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.matrix =&lt;span&gt; [[], []]
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.oldMatrix =&lt;span&gt; [[], []]
  }
  move () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重置当前矩阵数据&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.matrix = deepCopy(&lt;span&gt;this&lt;/span&gt;.oldMatrix) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解除引用&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载方块数据&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.matrix[y][x1] = 1
    &lt;span&gt;this&lt;/span&gt;.matrix[y][x2] = 1&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;左右移动的处理&quot;&gt;左右移动的处理&lt;/h3&gt;
&lt;p&gt;左右的移动不能像向下移动一样，单纯的下标+1。&lt;br/&gt;我们需要判断当前的操作是否有效。&lt;br/&gt;比如右侧如果遇到了障碍物或者到达边缘，我们肯定是不能够再进行移动的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; blend 为活动砖块的形状描述 [[1, 1, 1], [0, 1, 0]] 类似这样的结构&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (
  x &lt;/span&gt;&amp;gt;= width - brickWidth ||&lt;span&gt;
  blend.some((row, rowIndex) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    let _pos &lt;/span&gt;= oldMatrix[y +&lt;span&gt; rowIndex]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; row &amp;amp;&amp;amp; row[brickWidth - 1] &amp;amp;&amp;amp; _pos &amp;amp;&amp;amp; _pos[x +&lt;span&gt; brickWidth]
  })
)
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右侧有障碍物，无法移动&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用类似这样的逻辑进行判断，保证当前方块向右移动后不会覆盖之前的方块。&lt;/p&gt;
&lt;h3 id=&quot;快速向下的处理&quot;&gt;快速向下的处理&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我看有些游戏实现的，貌似下降触发只是加速下降而已（这种情况只需要改变定时下降的速度即可）-.-这里的实现是，直接触底&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以就会遇到一个问题，当前砖块最多可以下降到什么位置？&lt;/p&gt;
&lt;pre class=&quot; language-javascript&quot;&gt;
&lt;code class=&quot; language-javascript&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token number&quot;&gt;1&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;1&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;1&lt;span class=&quot;token punctuation&quot;&gt;]
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token number&quot;&gt;0&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;0&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;0&lt;span class=&quot;token punctuation&quot;&gt;]
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token number&quot;&gt;0&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;2&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;0&lt;span class=&quot;token punctuation&quot;&gt;]
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token number&quot;&gt;2&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;2&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;2&lt;span class=&quot;token punctuation&quot;&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就像这样的一个数据，&lt;code&gt;0|2&lt;/code&gt;这两列都可以向下移动两列，但是这样就会导致中间一列的重叠。&lt;br/&gt;我们一定要取出下降幅度最小的那个值。&lt;br/&gt;所以我们就要算出&lt;strong&gt;最后一行1&lt;/strong&gt;的下标以及&lt;strong&gt;第一行2&lt;/strong&gt;的下标，将这两个下标进行相减，最小值即为我们当前方块可下降的距离。&lt;/p&gt;
&lt;h3 id=&quot;旋转方块的处理&quot;&gt;旋转方块的处理&lt;/h3&gt;
&lt;p&gt;旋转方块应该是游戏中比较复杂的一块逻辑了。&lt;br/&gt;绝不是仅仅简单的将方块的二维数组由行改为列，在有些时候，我们还需要判断方块是否可以进行旋转。&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/tetris/tetris-pic-3.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;就像这样的，中间的绿色长条是不能够进行旋转的。&lt;br/&gt;所以我们要先拿到旋转后的数据，来与当前游戏中的数据进行比较，检验是否会出现重叠的情况，如果出现了，则表示不能够进行旋转。&lt;/p&gt;
&lt;h3 id=&quot;触底检测&quot;&gt;触底检测&lt;/h3&gt;
&lt;p&gt;每完成一个移动的动作后，我们都需要进行方块的触底检测。&lt;br/&gt;也就是判断当前方块下，是否已经有元素占位，如果有的话，则表示已经触底了，当前元素就会被固定进矩阵数组中。&lt;br/&gt;同样的，我们在判断时，不需要将方块所有的下标都检查一遍，只需要检查最底部一层的有效元素即可。&lt;/p&gt;
&lt;pre class=&quot; language-javascript&quot;&gt;
&lt;code class=&quot; language-javascript&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token number&quot;&gt;1&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;1&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token punctuation&quot;&gt;,
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token number&quot;&gt;0&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;1&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token punctuation&quot;&gt;,
&lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token number&quot;&gt;0&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token number&quot;&gt;1&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token punctuation&quot;&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;像这样的一个方块，我们仅需要判断第一列的第二行&amp;amp;第二列的第四行是否有元素即可完成检查。&lt;/p&gt;
&lt;h3 id=&quot;移除行&quot;&gt;移除行&lt;/h3&gt;
&lt;p&gt;当某一行被填满元素后，我们就要将它进行移除。&lt;br/&gt;在触底检测触发后，如果有方块被固定进数组，此时我们再进行移除行的操作。&lt;br/&gt;因为如果没有新的方块进入，移除行的这步操作就不是必要的。&lt;br/&gt;同时，得分的计数也应该在此处进行，我们将移除的行数进行记录，获取到的行数便是得分了。&lt;/p&gt;
&lt;p&gt;至此，所有有关矩阵数据的操作就结束了。&lt;br/&gt;&lt;code&gt;Game&lt;/code&gt;对象只去维护这么一个二维数组，对象本身不包含任何游戏相关的操作，只会在被调用时进行对应的处理。&lt;br/&gt;然后生成新的二维数组。&lt;/p&gt;
&lt;h2 id=&quot;utils&quot;&gt;utils&lt;/h2&gt;
&lt;p&gt;这里放置了一些比较通用的方法，用来提高开发效率使用。&lt;br/&gt;比如获取方块最底部一层的下标之类的工具函数。&lt;/p&gt;
&lt;h2 id=&quot;enum&quot;&gt;enum&lt;/h2&gt;
&lt;p&gt;存放了一些状态的枚举，游戏状态以及方块所对应的状态，类似这样的数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  empty: &lt;/span&gt;0&lt;span&gt;,
  newBrick: &lt;/span&gt;1&lt;span&gt;,
  oldBrick: &lt;/span&gt;2&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;data&quot;&gt;data&lt;/h2&gt;
&lt;p&gt;存放了游戏中各种使用到的方块信息。&lt;br/&gt;正方形，梯形之类的方块在二维数组中所对应的描述。&lt;/p&gt;
&lt;h2 id=&quot;controller&quot;&gt;controller&lt;/h2&gt;
&lt;p&gt;就是上边我们所说的，用来与用户交互的模块，由&lt;code&gt;Controller&lt;/code&gt;来获取游戏相关的信息，并调用&lt;code&gt;Render&lt;/code&gt;进行渲染。&lt;br/&gt;监听键盘事件，在页面中渲染一些控制按钮。&lt;br/&gt;以及定时触发&lt;code&gt;Game&lt;/code&gt;的下落方法。&lt;/p&gt;
&lt;h2 id=&quot;view&quot;&gt;view&lt;/h2&gt;
&lt;p&gt;游戏界面的渲染部分，目前选定的是使用&lt;code&gt;canvas&lt;/code&gt;，所以只写了&lt;code&gt;RenderCanvas&lt;/code&gt;。&lt;br/&gt;在渲染的这部分，稍微做了一些优化处理，将活动中的方块与固定的方块进行分开渲染。&lt;br/&gt;这样在用户操作上下左右移动时，并不会重新渲染整个游戏布局，而只是渲染活动方块的&lt;code&gt;canvas&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;小记&quot;&gt;小记&lt;/h2&gt;
&lt;p&gt;两天多的时间进行开发，其中有半天时间在修复&lt;code&gt;FlowType&lt;/code&gt;的Warning提示。。。&lt;br/&gt;搞完了以后，觉得实现这个的主要难点就在于方块旋转&amp;amp;触底的判断这里了。&lt;br/&gt;能够清晰的管理游戏对应的二维数组，这个游戏开发起来就会很顺畅。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;界面还有待优化。&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Apr 2018 07:02:00 +0000</pubDate>
<dc:creator>贾顺名</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiasm/p/8733356.html</dc:identifier>
</item>
<item>
<title>Spring Boot整合Spring Security - 156庄威龙</title>
<link>http://www.cnblogs.com/lger/p/8729511.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lger/p/8729511.html</guid>
<description>&lt;p&gt;Spring Boot对于该家族的框架支持良好，但是当中本人作为小白配置还是有一点点的小问题，这里分享一下。这个项目是使用之前发布的&lt;a href=&quot;https://blog.csdn.net/lger_pro/article/details/79181044&quot;&gt;Spring Boot会员管理系统&lt;/a&gt;重新改装，将之前filter登录验证改为Spring Security&lt;br/&gt;　　&lt;/p&gt;
&lt;h3 id=&quot;配置依赖&quot;&gt;&lt;strong&gt;1. 配置依赖&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　Spring Boot框架整合Spring Security只需要添加相应的依赖即可，其后都是配置Spring Security。&lt;br/&gt;　　这里使用Maven开发，依赖如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-security&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;配置spring-security&quot;&gt;&lt;strong&gt;2. 配置Spring Security&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&quot;定制websecurityconfigureradapter&quot;&gt;&lt;strong&gt;2.1 定制WebSecurityConfigurerAdapter&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;下面通过Java配置Spring Security不拦截静态资源以及需要登录验证等各种信息&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@EnableWebSecurity&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@EnableGlobalMethodSecurity&lt;/span&gt;(prePostEnabled = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;//开启方法上的认证&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SecurityConfig &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; WebSecurityConfigurerAdapter {

    &lt;span class=&quot;fu&quot;&gt;@Resource&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; CustomerUserDetailsService userDetailsService;
    &lt;span class=&quot;fu&quot;&gt;@Resource&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; CustomerLoginSuccessHandler successHandler;
    &lt;span class=&quot;fu&quot;&gt;@Resource&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; BCryptPasswordEncoder encoder;

    &lt;span class=&quot;fu&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; BCryptPasswordEncoder &lt;span class=&quot;fu&quot;&gt;encoder&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BCryptPasswordEncoder&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;configure&lt;/span&gt;(WebSecurity web) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        web.&lt;span class=&quot;fu&quot;&gt;ignoring&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;antMatchers&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/assets/**&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//不过滤静态资源&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;configure&lt;/span&gt;(web);
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;configure&lt;/span&gt;(AuthenticationManagerBuilder auth) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        auth.&lt;span class=&quot;fu&quot;&gt;userDetailsService&lt;/span&gt;(userDetailsService) &lt;span class=&quot;co&quot;&gt;//注册自己定制的UserDetailsService&lt;/span&gt;
                .&lt;span class=&quot;fu&quot;&gt;passwordEncoder&lt;/span&gt;(encoder); &lt;span class=&quot;co&quot;&gt;// 配置密码加密器&lt;/span&gt;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;configure&lt;/span&gt;(HttpSecurity http) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {

        http
                .&lt;span class=&quot;fu&quot;&gt;authorizeRequests&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;//获取请求方面的验证器&lt;/span&gt;
                    .&lt;span class=&quot;fu&quot;&gt;antMatchers&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;/error&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;permitAll&lt;/span&gt;()&lt;span class=&quot;co&quot;&gt;// 访问当前配置的路径可通过认证&lt;/span&gt;
                    &lt;span class=&quot;co&quot;&gt;//访问其他路径需要认证和角色权限&lt;/span&gt;
                    .&lt;span class=&quot;fu&quot;&gt;anyRequest&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;hasAnyAuthority&lt;/span&gt;(AdminRole.&lt;span class=&quot;fu&quot;&gt;G_ADMIN&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;(), AdminRole.&lt;span class=&quot;fu&quot;&gt;S_ADMIN&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;())
                    .&lt;span class=&quot;fu&quot;&gt;anyRequest&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;authenticated&lt;/span&gt;()
                    .&lt;span class=&quot;fu&quot;&gt;and&lt;/span&gt;()
                .&lt;span class=&quot;fu&quot;&gt;formLogin&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;//获取登录认证验证器&lt;/span&gt;
                    .&lt;span class=&quot;fu&quot;&gt;loginPage&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/login&quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;//注册自定义的登录页面URL&lt;/span&gt;
                    .&lt;span class=&quot;fu&quot;&gt;failureForwardUrl&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/login&quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;//登录失败后以登录时的请求转发到该链接&lt;/span&gt;
                    .&lt;span class=&quot;fu&quot;&gt;successHandler&lt;/span&gt;(successHandler) &lt;span class=&quot;co&quot;&gt;//登录成功后调用该处理器&lt;/span&gt;
                    .&lt;span class=&quot;fu&quot;&gt;permitAll&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;//登录请求给予通过认证&lt;/span&gt;
                    .&lt;span class=&quot;fu&quot;&gt;and&lt;/span&gt;()
                .&lt;span class=&quot;fu&quot;&gt;logout&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;//推出登录&lt;/span&gt;
                    .&lt;span class=&quot;fu&quot;&gt;logoutSuccessUrl&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/login&quot;&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;//退出后访问URL&lt;/span&gt;
                    .&lt;span class=&quot;fu&quot;&gt;and&lt;/span&gt;()
                .&lt;span class=&quot;fu&quot;&gt;csrf&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;disable&lt;/span&gt;(); &lt;span class=&quot;co&quot;&gt;//关闭csrf，默认开启&lt;/span&gt;

    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的类是用于配置Spring Security框架的，这里有关于几个东西要说明下：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;@EnableGlobalMethodSecurity&lt;br/&gt;　　这是用于配置类 / 方法上的安全认证，它默认关闭了，我们现在配置了&lt;code&gt;@EnableGlobalMethodSecurity(prePostEnabled = true)&lt;/code&gt;这将使得可以在方法上使用注解&lt;code&gt;@PreAuthorize(&quot;hasAnyAuthority('S_ADMIN')&quot;)&lt;/code&gt;（使用范例可看&lt;code&gt;AdminController&lt;/code&gt;）在没调用注解下的方法时判断当前认证用户有没有&lt;em&gt;S_ADMIN&lt;/em&gt;角色权限操作该方法。&lt;br/&gt;　　这个注解可以使得在开发非Web项目时起到作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;configure(AuthenticationManagerBuilder auth)&lt;/strong&gt;&lt;br/&gt;　　这里可以配置该项目与用户的关联，也称作认证。我们需要构建自己的登录验证器，这里我们自定义了一个&lt;code&gt;UserDetailsService&lt;/code&gt;和一个密码加密器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;configure(HttpSecurity http)&lt;/strong&gt;&lt;br/&gt;　　这里可以配置我们对于一个HttpSecurity需要通过什么样子的安全认证。代码中还包含了&lt;code&gt;csrf().disable()&lt;/code&gt;，这是因为框架默认开启了csrf，这样我们的ajax和表单提交等都需要提供一个&lt;code&gt;token&lt;/code&gt;，为了偷懒，所以，你懂的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有就是一个小tip，这是一个配置，相当于xml，Spring只会加载一次，所以以上的方法Spring是初始化一次的&lt;/p&gt;
&lt;h4 id=&quot;定制userdetailsservice&quot;&gt;&lt;strong&gt;2.2 定制UserDetailsService&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　在上面中我们注册了一个自定义的&lt;code&gt;UserDetailsService&lt;/code&gt;，这是用于当用户认证时我们需要提供一个可被框架识别的&lt;code&gt;UserDetails&lt;/code&gt;，用这个&lt;code&gt;UserDetails&lt;/code&gt;和我们的登录用户实体类建立起一个关联，让框架可以处理我们的用户信息，框架所提供的只是&lt;code&gt;username&lt;/code&gt;和&lt;code&gt;password&lt;/code&gt;，它只是帮助我们认证我们的用户和密码是否匹配。定制&lt;code&gt;UserDetailsService&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//注册为Spring组件&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomerUserDetailsService &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; UserDetailsService{

    &lt;span class=&quot;fu&quot;&gt;@Resource&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; AdminDao adminDao;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; UserDetails &lt;span class=&quot;fu&quot;&gt;loadUserByUsername&lt;/span&gt;(String username) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; UsernameNotFoundException {
        &lt;span class=&quot;co&quot;&gt;//通过dao查找当前用户名对应的用户&lt;/span&gt;
        Admin admin = adminDao.&lt;span class=&quot;fu&quot;&gt;findAdminByUsername&lt;/span&gt;(username);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (admin == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;){
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;UsernameNotFoundException&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;This username: &quot;&lt;/span&gt;+username+&lt;span class=&quot;st&quot;&gt;&quot;is not exist&quot;&lt;/span&gt;);
        }
        &lt;span class=&quot;co&quot;&gt;//返回一个定制的UserDetails&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//AuthorityUtils.createAuthorityList(admin.getRole())就是将我们该用户所有的权限（角色）生成一个集合&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CustomerUserDetails&lt;/span&gt;(admin, AuthorityUtils.&lt;span class=&quot;fu&quot;&gt;createAuthorityList&lt;/span&gt;(admin.&lt;span class=&quot;fu&quot;&gt;getRole&lt;/span&gt;()));
        
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当我们登录时，&lt;code&gt;org.springframework.security.authentication.dao.DaoAuthenticationProvider&lt;/code&gt;会调用&lt;code&gt;loadUserByUsername&lt;/code&gt;方法并且把当前需要认证的用户名传入，我们需要的就是放回一个通过该用户名得出的拥有密码信息的&lt;code&gt;UserDetails&lt;/code&gt;，这样，框架就可以帮助我们验证需要认证的密码与查出的密码是否匹配。&lt;/p&gt;
&lt;h4 id=&quot;定制userdetails&quot;&gt;&lt;strong&gt;2.3 定制UserDetails&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　要让Spring Security能够识别我们定制的&lt;code&gt;UserDetails&lt;/code&gt;，那就需要按照它的标准来写，所以，我们需要实现一个&lt;code&gt;UserDetails&lt;/code&gt;接口，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomerUserDetails &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; UserDetails {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Admin admin = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;//存放权限的集合&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Collection&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; GrantedAuthority&amp;gt; authorities;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; accountNonExpired;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; accountNonLocked;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; credentialsNonExpired;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; enabled;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CustomerUserDetails&lt;/span&gt;(Admin admin, Collection&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; GrantedAuthority&amp;gt; authorities) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;(admin, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;,&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;,authorities);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;CustomerUserDetails&lt;/span&gt;(Admin admin, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; enabled, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; accountNonExpired, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; credentialsNonExpired, &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; accountNonLocked, Collection&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; GrantedAuthority&amp;gt; authorities) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(admin.&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;() != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(admin.&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;()) &amp;amp;&amp;amp; admin.&lt;span class=&quot;fu&quot;&gt;getPassword&lt;/span&gt;() != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;admin&lt;/span&gt; = admin;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;enabled&lt;/span&gt; = enabled;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;accountNonExpired&lt;/span&gt; = accountNonExpired;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;credentialsNonExpired&lt;/span&gt; = credentialsNonExpired;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;accountNonLocked&lt;/span&gt; = accountNonLocked;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;authorities&lt;/span&gt; = authorities;
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Cannot pass null or empty values to constructor&quot;&lt;/span&gt;);
        }
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Admin &lt;span class=&quot;fu&quot;&gt;getAdmin&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; admin;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setAdmin&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;@NotNull&lt;/span&gt; Admin admin) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;admin&lt;/span&gt; = admin;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(Object rhs) {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; rhs &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; CustomerUserDetails &amp;amp;&amp;amp; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(((CustomerUserDetails) rhs).&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;());
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Collection&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; GrantedAuthority&amp;gt; &lt;span class=&quot;fu&quot;&gt;getAuthorities&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;authorities&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getPassword&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;admin&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getPassword&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;admin&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;();
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isAccountNonExpired&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;accountNonExpired&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isAccountNonLocked&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;accountNonLocked&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isCredentialsNonExpired&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;credentialsNonExpired&lt;/span&gt;;
    }

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isEnabled&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;enabled&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　关于以上的写法是参照Spring Security所提供的User类来改写的，具体代码可看&lt;code&gt;org.springframework.security.core.userdetails.User&lt;/code&gt;源码。&lt;br/&gt;　　在&lt;code&gt;org.springframework.security.core.userdetails.User&lt;/code&gt;中重写&lt;code&gt;hashCode&lt;/code&gt;和&lt;code&gt;equals&lt;/code&gt;可能是为了判断重复登录的问题，当然了，这只是个人意淫，纯属瞎猜。为了安全起见我也跟着重写了那两个方法了。&lt;br/&gt;　　在定制&lt;code&gt;UserDetails&lt;/code&gt;我加入了一个成员变量&lt;code&gt;admin&lt;/code&gt;，这是因为之前的开发中没有使用该框架，只是使用了&lt;code&gt;filter&lt;/code&gt;登录验证，将登录信息存放到 &lt;code&gt;session&lt;/code&gt;，所以，为了不大改之前的旧东西，所以我还将会从这里获取&lt;code&gt;admin&lt;/code&gt;存于&lt;code&gt;session&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;定制authenticationsuccesshandler&quot;&gt;&lt;strong&gt;2.4 定制AuthenticationSuccessHandler&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　定制&lt;code&gt;AuthenticationSuccessHandler&lt;/code&gt;不是直接继承接口，而是继承一个实现类&lt;code&gt;SavedRequestAwareAuthenticationSuccessHandler&lt;/code&gt;，因为这里保存了我们的登录前请求信息，我们可以不用获取&lt;code&gt;RequestCache&lt;/code&gt;就可实现直接从登录页面重定向到登录前访问的URL，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CustomerLoginSuccessHandler &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; SavedRequestAwareAuthenticationSuccessHandler {

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onAuthenticationSuccess&lt;/span&gt;(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; IOException, ServletException {
        &lt;span class=&quot;co&quot;&gt;//SecurityContextHolder是Spring Security的核心组件，可获取框架爱内的一些信息&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//这里我得到登录成功后的UserDetails&lt;/span&gt;
        Object principal = SecurityContextHolder.&lt;span class=&quot;fu&quot;&gt;getContext&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getAuthentication&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getPrincipal&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (principal &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; UserDetails) {
            request.&lt;span class=&quot;fu&quot;&gt;getSession&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;setAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;admin&quot;&lt;/span&gt;, ((CustomerUserDetails) principal).&lt;span class=&quot;fu&quot;&gt;getAdmin&lt;/span&gt;());
        }
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onAuthenticationSuccess&lt;/span&gt;(request, response, authentication);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　关于上面代码中的框架核心组件，可以到官方文档中的此&lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/5.0.3.RELEASE/reference/htmlsingle/#core-components&quot;&gt;链接&lt;/a&gt;查看&lt;br/&gt;　　定制这个处理器的主要目的是因为我想要偷懒，因为我模板引擎需要访问&lt;code&gt;admin&lt;/code&gt;来获取用户名，当然了也可以使用该表达式&lt;code&gt;${session.SPRING_SECURITY_CONTEXT.authentication.principal.username}&lt;/code&gt;来获取&lt;code&gt;UserDetails&lt;/code&gt;的用户名&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;strong&gt;3. 总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　写到这里就差不多该结束了，这里我就做下个人总结。这次整合Spring Security中途不是像这篇文章那样如此下来的，中间磕磕碰碰，所以呢，我就在想，是不是我只是停留在了应用层面才导致的这么个结果，如果了解源码多一点就可能不会出现这些问题了。&lt;/p&gt;
&lt;p&gt;以上的代码已上传&lt;a href=&quot;https://github.com/Mr-Pro/membership&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.48165137614679&quot;&gt;
&lt;p&gt;可参考链接&lt;br/&gt;&lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/5.0.3.RELEASE/reference/htmlsingle/&quot; class=&quot;uri&quot;&gt;https://docs.spring.io/spring-security/site/docs/5.0.3.RELEASE/reference/htmlsingle/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/u283056051/article/details/55803855&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/u283056051/article/details/55803855&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.tianshouzhi.com/api/tutorials/spring_security_4/250&quot; class=&quot;uri&quot;&gt;http://www.tianshouzhi.com/api/tutorials/spring_security_4/250&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 07 Apr 2018 06:47:00 +0000</pubDate>
<dc:creator>156庄威龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lger/p/8729511.html</dc:identifier>
</item>
<item>
<title>Spring Cache扩展：注解失效时间+主动刷新缓存(二) - min.jiang</title>
<link>http://www.cnblogs.com/ASPNET2008/p/8733087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ASPNET2008/p/8733087.html</guid>
<description>&lt;p&gt;之前在github上找了一个开源的项目，改了改缓存的扩展，让其支持在缓存注解上控制缓存失效时间以及多长时间主动在后台刷新缓存以防止缓存失效( &lt;a href=&quot;http://www.cnblogs.com/ASPNET2008/p/6511500.html&quot;&gt;Spring Cache扩展：注解失效时间+主动刷新缓存&lt;/a&gt; )。示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/17071/201804/17071-20180407133652172-396891744.jpg&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;473&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.cnblogs.com/ASPNET2008/p/spring-cache-refresh.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那篇文章存在两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有的配置是建立在修改缓存容器的名称基础上，与传统缓存注解的写法有所区别，后续维护成本会增加；&lt;/li&gt;
&lt;li&gt;后台刷新缓存时会存在并发更新的问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，当时项目是基于springboot 1.x，现在springboot2.0对缓存这块有所调整，需要重新适配。&lt;/p&gt;

&lt;h2 id=&quot;toc_2&quot;&gt;RedisCacheManager&lt;/h2&gt;
&lt;p&gt;看看下面的构造函数，与1.x有比较大的改动，这里就不贴代码了。&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public RedisCacheManager(RedisCacheWriter cacheWriter, RedisCacheConfiguration defaultCacheConfiguration) {
    this(cacheWriter, defaultCacheConfiguration, true);
}

public RedisCacheManager(RedisCacheWriter cacheWriter, RedisCacheConfiguration defaultCacheConfiguration, String... initialCacheNames) {
    this(cacheWriter, defaultCacheConfiguration, true, initialCacheNames);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;RedisCache&lt;/h2&gt;
&lt;p&gt;既然上层的RedisCacheManager变动了，这里也就跟着变了。&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected RedisCache(String name, RedisCacheWriter cacheWriter, RedisCacheConfiguration cacheConfig) {
    super(cacheConfig.getAllowCacheNullValues());
    Assert.notNull(name, &quot;Name must not be null!&quot;);
    Assert.notNull(cacheWriter, &quot;CacheWriter must not be null!&quot;);
    Assert.notNull(cacheConfig, &quot;CacheConfig must not be null!&quot;);
    this.name = name;
    this.cacheWriter = cacheWriter;
    this.cacheConfig = cacheConfig;
    this.conversionService = cacheConfig.getConversionService();
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;针对上述的三个问题，分别应对。&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;将缓存配置从注解上转移到初始化缓存的地方&lt;/h2&gt;
&lt;p&gt;创建一个类用来描述缓存配置，避免在缓存注解上通过非常规手段完成特定的功能。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CacheItemConfig implements Serializable {

    /**
     * 缓存容器名称
     */
    private String name;
    /**
     * 缓存失效时间
     */
    private long expiryTimeSecond;
    /**
     * 当缓存存活时间达到此值时，主动刷新缓存
     */
    private long preLoadTimeSecond;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体的应用参见下面两步。&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;适配springboot 2.0&lt;/h2&gt;
&lt;h3 id=&quot;toc_7&quot;&gt;修改CustomizedRedisCacheManager&lt;/h3&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public CustomizedRedisCacheManager(
        RedisConnectionFactory connectionFactory,
        RedisOperations redisOperations,
        List&amp;lt;CacheItemConfig&amp;gt; cacheItemConfigList) &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;connectionFactory，这是一个redis连接工厂，用于后续操作redis&lt;/li&gt;
&lt;li&gt;redisOperations,这个一个redis的操作实例，具体负责执行redis命令&lt;/li&gt;
&lt;li&gt;cacheItemConfigList,这是缓存的配置，比如名称，失效时间，主动刷新时间，用于取代在注解上个性化的配置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体实现如下：核心思路就是调用RedisCacheManager的构造函数。&lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
private RedisCacheWriter redisCacheWriter;
private RedisCacheConfiguration defaultRedisCacheConfiguration;
private RedisOperations redisOperations;

public CustomizedRedisCacheManager(
        RedisConnectionFactory connectionFactory,
        RedisOperations redisOperations,
        List&amp;lt;CacheItemConfig&amp;gt; cacheItemConfigList) {

    this(
            RedisCacheWriter.nonLockingRedisCacheWriter(connectionFactory),
            RedisCacheConfiguration.defaultCacheConfig().entryTtl(Duration.ofSeconds(30)),
            cacheItemConfigList
                    .stream()
                    .collect(Collectors.toMap(CacheItemConfig::getName,cacheItemConfig -&amp;gt; {
                        RedisCacheConfiguration cacheConfiguration =
                                RedisCacheConfiguration
                                        .defaultCacheConfig()
                                        .entryTtl(Duration.ofSeconds(cacheItemConfig.getExpiryTimeSecond()))
                                        .prefixKeysWith(cacheItemConfig.getName());
                        return cacheConfiguration;
                    }))
    );
    this.redisOperations=redisOperations;
    CacheContainer.init(cacheItemConfigList);

}
public CustomizedRedisCacheManager(
        RedisCacheWriter redisCacheWriter
        ,RedisCacheConfiguration redisCacheConfiguration,
        Map&amp;lt;String, RedisCacheConfiguration&amp;gt; redisCacheConfigurationMap) {
    super(redisCacheWriter,redisCacheConfiguration,redisCacheConfigurationMap);
    this.redisCacheWriter=redisCacheWriter;
    this.defaultRedisCacheConfiguration=redisCacheConfiguration;
}
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于我们需要主动刷新缓存，所以需要重写getCache方法：主要就是将RedisCache构造函数所需要的参数传递过去。&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public Cache getCache(String name) {

    Cache cache = super.getCache(name);
    if(null==cache){
        return cache;
    }
    CustomizedRedisCache redisCache= new CustomizedRedisCache(
            name,
            this.redisCacheWriter,
            this.defaultRedisCacheConfiguration,
            this.redisOperations
    );
    return redisCache;
}    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_8&quot;&gt;修改CustomizedRedisCache&lt;/h3&gt;
&lt;p&gt;核心方法就一个，getCache:当获取到缓存时，实时获取缓存的存活时间，如果存活时间进入缓存刷新时间范围即调起异步任务完成缓存动态加载。ThreadTaskHelper是一个异常任务提交的工具类。下面方法中的参数key，并不是最终存入redis的key，是@Cacheable注解中的key，要想获取缓存的存活时间就需要找到真正的key，然后让redisOptions去调用ttl命令。在springboot 1.5下面好像有个RedisCacheKey的对象，但在springboot2.0中并未发现，取而代之获取真正key是通过函数this.createCacheKey来完成。&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public ValueWrapper get(final Object key) {

    ValueWrapper valueWrapper= super.get(key);
    if(null!=valueWrapper){
        CacheItemConfig cacheItemConfig=CacheContainer.getCacheItemConfigByCacheName(key.toString());
        long preLoadTimeSecond=cacheItemConfig.getPreLoadTimeSecond();
        String cacheKey=this.createCacheKey(key);
        Long ttl= this.redisOperations.getExpire(cacheKey);
        if(null!=ttl&amp;amp;&amp;amp; ttl&amp;lt;=preLoadTimeSecond){
            logger.info(&quot;key:{} ttl:{} preloadSecondTime:{}&quot;,cacheKey,ttl,preLoadTimeSecond);
            ThreadTaskHelper.run(new Runnable() {
                    @Override
                    public void run() {
                           logger.info(&quot;refresh key:{}&quot;, cacheKey);
                           CustomizedRedisCache.this.getCacheSupport()
                           .refreshCacheByKey(CustomizedRedisCache.super.getName(), key.toString());
                    }
                });        
        }
    }
    return valueWrapper;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;CacheContainer,这是一个辅助数据存储，将前面设置的缓存配置放入容器以便后面的逻辑获取。其中包含一个默认的缓存配置，防止 在未设置的情况导致缓存获取异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class CacheContainer {

    private static final String DEFAULT_CACHE_NAME=&quot;default&quot;;

    private static final Map&amp;lt;String,CacheItemConfig&amp;gt; CACHE_CONFIG_HOLDER=new ConcurrentHashMap(){
        {
            put(DEFAULT_CACHE_NAME,new CacheItemConfig(){
                @Override
                public String getName() {
                    return DEFAULT_CACHE_NAME;
                }

                @Override
                public long getExpiryTimeSecond() {
                    return 30;
                }

                @Override
                public long getPreLoadTimeSecond() {
                    return 25;
                }
            });
        }
    };

    public static void init(List&amp;lt;CacheItemConfig&amp;gt; cacheItemConfigs){
        if(CollectionUtils.isEmpty(cacheItemConfigs)){
            return;
        }
        cacheItemConfigs.forEach(cacheItemConfig -&amp;gt; {
            CACHE_CONFIG_HOLDER.put(cacheItemConfig.getName(),cacheItemConfig);
        });

    }

    public static CacheItemConfig getCacheItemConfigByCacheName(String cacheName){
        if(CACHE_CONFIG_HOLDER.containsKey(cacheName)) {
            return CACHE_CONFIG_HOLDER.get(cacheName);
        }
        return CACHE_CONFIG_HOLDER.get(DEFAULT_CACHE_NAME);
    }

    public static List&amp;lt;CacheItemConfig&amp;gt; getCacheItemConfigs(){
        return CACHE_CONFIG_HOLDER
                .values()
                .stream()
                .filter(new Predicate&amp;lt;CacheItemConfig&amp;gt;() {
                    @Override
                    public boolean test(CacheItemConfig cacheItemConfig) {
                        return !cacheItemConfig.getName().equals(DEFAULT_CACHE_NAME);
                    }
                })
                .collect(Collectors.toList());
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_9&quot;&gt;修改CacheManager加载方式&lt;/h3&gt;
&lt;p&gt;由于主动刷新缓存时需要用缓存操作，这里需要加载RedisTemplate，其实就是后面的RedisOptions接口。序列化机制可心随意调整。&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
public RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate(RedisConnectionFactory connectionFactory) {
    RedisTemplate&amp;lt;Object, Object&amp;gt; template = new RedisTemplate&amp;lt;&amp;gt;();
    template.setConnectionFactory(connectionFactory);

    Jackson2JsonRedisSerializer serializer = new Jackson2JsonRedisSerializer(Object.class);

    ObjectMapper mapper = new ObjectMapper();
    mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
    mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
    serializer.setObjectMapper(mapper);

    template.setValueSerializer(serializer);

    template.setKeySerializer(new StringRedisSerializer());
    template.afterPropertiesSet();
    return template;
}
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加载CacheManager,主要是配置缓存容器，其余的两个都是redis所需要的对象。&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
public CacheManager cacheManager(RedisConnectionFactory connectionFactory,RedisTemplate&amp;lt;Object, Object&amp;gt; redisTemplate) {

    CacheItemConfig productCacheItemConfig=new CacheItemConfig();
    productCacheItemConfig.setName(&quot;Product&quot;);
    productCacheItemConfig.setExpiryTimeSecond(10);
    productCacheItemConfig.setPreLoadTimeSecond(5);

    List&amp;lt;CacheItemConfig&amp;gt; cacheItemConfigs= Lists.newArrayList(productCacheItemConfig);

    CustomizedRedisCacheManager cacheManager = new CustomizedRedisCacheManager(connectionFactory,redisTemplate,cacheItemConfigs);

    return cacheManager;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;toc_10&quot;&gt;解决并发刷新缓存的问题&lt;/h2&gt;
&lt;p&gt;CustomizedRedisCache的get方法，当判断需要刷新缓存时，后台起了一个异步任务去更新缓存，此时如果有N个请求同时访问同一个缓存，就是发生类似缓存击穿的情况。为了避免这种情况的发生最好的方法就是加锁，让其只有一个任务去做更新的事情。Spring Cache提供了一个同步的参数来支持并发更新控制，这里我们可以模仿这个思路来处理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将正在进行缓存刷新的KEY放入一个容器，其它线程访问时如果发现KEY已经存在就直接跳过；&lt;/li&gt;
&lt;li&gt;缓存刷新完成后从容器中删除对应的KEY&lt;/li&gt;
&lt;li&gt;在容器中未发现正在进行缓存刷新的KEY时，利用锁机制确保只有一个任务执行刷新，类似双重检查&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ValueWrapper get(final Object key) {
    ValueWrapper valueWrapper= super.get(key);
    if(null!=valueWrapper){
        CacheItemConfig cacheItemConfig=CacheContainer.getCacheItemConfigByCacheName(key.toString());
        long preLoadTimeSecond=cacheItemConfig.getPreLoadTimeSecond();
        ;
        String cacheKey=this.createCacheKey(key);
        Long ttl= this.redisOperations.getExpire(cacheKey);
        if(null!=ttl&amp;amp;&amp;amp; ttl&amp;lt;=preLoadTimeSecond){
            logger.info(&quot;key:{} ttl:{} preloadSecondTime:{}&quot;,cacheKey,ttl,preLoadTimeSecond);
            if(ThreadTaskHelper.hasRunningRefreshCacheTask(cacheKey)){
                logger.info(&quot;do not need to refresh&quot;);
            }
            else {
                ThreadTaskHelper.run(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            REFRESH_CACKE_LOCK.lock();
                            if(ThreadTaskHelper.hasRunningRefreshCacheTask(cacheKey)){
                                logger.info(&quot;do not need to refresh&quot;);
                            }
                            else {
                                logger.info(&quot;refresh key:{}&quot;, cacheKey);
                                CustomizedRedisCache.this.getCacheSupport().refreshCacheByKey(CustomizedRedisCache.super.getName(), key.toString());
                                ThreadTaskHelper.removeRefreshCacheTask(cacheKey);
                            }

                        }
                        finally {
                            REFRESH_CACKE_LOCK.unlock();
                        }
                    }
                });
            }
        }
    }
    return valueWrapper;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;以上方案是在单机情况下，如果是多机也会出现执行多次刷新，但这种代码是可接受的，如果做到严格意义的一次刷新就需要引入分布式锁，但同时会带来系统复杂度以及性能消耗，有点得不尝失的感觉，所以建议单机方式即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里不需要在缓存容器名称上动刀子了，像正规使用Cacheable注解即可。&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Cacheable(value = &quot;Product&quot;,key =&quot;#id&quot;)
@Override
public Product getById(Long id) {
    this.logger.info(&quot;get product from db,id:{}&quot;,id);
    Product product=new Product();
    product.setId(id);
    return product;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文中代码是依赖上述项目的，如果有不明白的可下载源码&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 07 Apr 2018 05:46:00 +0000</pubDate>
<dc:creator>min.jiang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ASPNET2008/p/8733087.html</dc:identifier>
</item>
<item>
<title>【概率论与数理统计】小结9 - 点估计 - 昕-2008</title>
<link>http://www.cnblogs.com/Belter/p/8410382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Belter/p/8410382.html</guid>
<description>&lt;p&gt;&lt;span&gt;注&lt;/span&gt;：点估计是参数估计中的一种。点估计常用的方法有两种：矩估计和最大似然估计。之所以要做估计，最本质的问题是我们能获得的信息量（样本的数量）有限，因此只能在有限的信息中，用合理的方法、在可接受的精度或置信度下做近似计算，以便对总体有一个大概的认识，也就是将某种在有限样本下中获得的规律，泛化到更大的样本量上。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;0. 矩估计&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;h4&gt;0.1 引例&lt;/h4&gt;
&lt;p&gt;某大学新生有4000人参加第一学期的《微积分》考试。现随机选出100名同学，计算得到他们的平均成绩为68.5分，标准差为12.2分，试估计全体同学的平均成绩。&lt;/p&gt;
&lt;p&gt;如果我们使用这100名同学的平均成绩来估计全体同学的平均成绩，那么我们就完成了一次矩估计。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;记总体（所有4000名学生）的平均成绩为$\mu$，此时的$\mu$就是总体的一阶原点矩$\alpha_1$；&lt;/li&gt;
&lt;li&gt;100名学生的平均成绩就是样本的一阶原点矩$A_1$；&lt;/li&gt;
&lt;li&gt;用样本的一阶原点矩估计总体的一阶原点矩，得到$\hat{\mu} = 68.5$.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据&lt;a href=&quot;http://www.cnblogs.com/Belter/p/7629105.html&quot; target=&quot;_blank&quot;&gt;小结5&lt;/a&gt;中的约定，我们使用以下符号表示不同的矩：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;$\alpha_k$: 总体k阶原点矩；&lt;/li&gt;
&lt;li&gt;$\beta_k$: 总体k阶中心矩；&lt;/li&gt;
&lt;li&gt;$A_k$: 样本k阶原点矩；&lt;/li&gt;
&lt;li&gt;$B_k$: 样本k阶中心矩.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;0.2 统计思想&lt;/h4&gt;
&lt;p&gt;矩估计是英国统计学家卡尔·皮尔逊于1894年提出的。是基于一种简单的 “替换” 思想建立起来的一种估计方法。其基本思想是以样本矩估计总体矩，以样本矩的函数估计总体矩的函数。&lt;/p&gt;

&lt;h4&gt;0.3 理论依据&lt;/h4&gt;
&lt;p&gt;辛钦大数定律和依概率收敛的性质。&lt;/p&gt;
&lt;p&gt;假设$\alpha_j = E(X^j)$存在，其中$j = 1, 2, ..., k$. 则&lt;/p&gt;
&lt;p&gt;$$\hat{\alpha_j} = A_j = \frac{1}{n}\sum_{i=1}^{n}{X_i^j}, \ j = 1, 2, ..., k, \  \to \ \alpha_j \ with \ probability \ p , \ j = 1, 2, ..., k$$&lt;/p&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;p&gt;$$h(\hat{\alpha_1}, \ \hat{\alpha_2}, \ ..., \ \hat{\alpha_k}) = h(A_1, \ A_2, \ ..., \ A_k) \ \to \ h(\alpha_1, \ \alpha_2, \ ..., \ \alpha_k) \ with \ probability \ p$$&lt;/p&gt;
&lt;p&gt;上面用公式表示了用样本的原点矩估计总体的原点矩或用样本原点矩的函数估计总体原点矩的函数，将原点矩换成中心矩也同样成立。&lt;/p&gt;

&lt;h4&gt;0.4 建立矩估计的步骤&lt;/h4&gt;
&lt;p&gt;简单来说，只要可以将一个待估计的参数用总体矩（单个矩或不同矩的函数）表示出来，然后用对应的样本矩替换总体矩就可以了。&lt;/p&gt;
&lt;p&gt;设总体有k个未知参数，$\theta_1, \theta_2, ..., \theta_k$, $X_1, X_2, ..., X_n$是来自总体$X$的样本，假设总体的前k阶矩存在。&lt;/p&gt;
&lt;p&gt;矩估计步骤：&lt;/p&gt;
&lt;p&gt;（1）建立$(\theta_1, ..., \theta_k)$与$(\alpha_1, .., \alpha_k)$的联系：求总体前$k$阶原点矩关于$k$个参数的函数(即，用未知参数表示总体矩)，&lt;/p&gt;
&lt;p&gt;$$\alpha_i = E(X^{(i)}) = h_i(\theta_1, ..., \theta_k), i = 1, ..., k.$$&lt;/p&gt;
&lt;p&gt;（2）求各参数关于$k$阶原点矩的反函数(即，用总体距表示未知参数)，&lt;/p&gt;
&lt;p&gt;$$\theta_i = g_i(\alpha_1, ..., \alpha_k), i = 1, ..., k$$&lt;/p&gt;
&lt;p&gt;（3）以样本各阶矩$A_1, ..., A_k$代替总体$X$各阶矩$\alpha_1, ..., \alpha_k$，得到各参数的矩估计：&lt;/p&gt;
&lt;p&gt;$$\hat{\theta_i} = g_i(A_1, ..., A_k)$$&lt;/p&gt;
&lt;p&gt;在实际应用时，为求解方便，也可用总体中心矩$\beta_i$替换总体原点矩$\alpha_i$，相应的，以样本中心矩$B_i$估计总体中心矩$\beta_i$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Notice:&lt;/strong&gt; 采用的矩不同，得出的矩估计也可能不同。&lt;/p&gt;

&lt;h3&gt;0.5 常见的矩估计量&lt;/h3&gt;
&lt;p&gt;参考&lt;a href=&quot;http://www.cnblogs.com/Belter/p/8029712.html&quot; target=&quot;_blank&quot;&gt;小结7&lt;/a&gt;，part2部分，总结了常见的统计量（所有的样本矩都是统计量，有些统计量本身也是样本矩）以及使用样本矩估计总体矩的例子。&lt;/p&gt;

&lt;h3&gt;0.6 总体方差的估计&lt;/h3&gt;
&lt;p&gt;总体方差的估计是一个比较特殊的例子，值得单独拿出来说一说。这是因为总体方差与总体的二阶中心矩相同，但是样本方差的计算公式与样本的二阶中心矩并不相同。&lt;/p&gt;
&lt;p&gt;设$X$是一个随机变量，且方差存在，总体和样本的均值分别为$\mu, \ \bar{X}$. 则下面是该随机变量四种不同的4个数字特征的计算方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;总体方差用$\sigma^2$表示，按照方差的定义可得$\sigma^2 = E[X - E(X)]^2 = \frac{1}{n}\sum_{i=1}^{n}{(X_i - \mu)^2}$;&lt;/li&gt;
&lt;li&gt;按照中心矩的定义可得，总体二阶中心矩$\beta_2 = E[X - E(X)]^2 = \frac{1}{n}\sum_{i=1}^{n}{(X_i - \mu)^2}$，同$\sigma^2$;&lt;/li&gt;
&lt;li&gt;同样，样本二阶中心矩$B_2 = E[X - \bar{X}]^2 = \frac{1}{n}\sum_{i=1}^{n}{(X_i - \bar{X})^2}$;&lt;/li&gt;
&lt;li&gt;样本方差$S^2 = \frac{1}{n - 1}\sum_{i=1}^{n}{(X_i - \bar{X})^2}$，参考&lt;a href=&quot;http://www.cnblogs.com/Belter/p/7629105.html&quot; target=&quot;_blank&quot;&gt;小结5&lt;/a&gt;中，2.3 样本方差的计算.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此时我们有两种方式来对总体方差进行估计，样本的二阶中心矩（矩估计）或样本方差（非矩估计）。那么哪一个估计更好呢？此时可以使用&lt;a href=&quot;http://www.cnblogs.com/Belter/p/8337992.html&quot; target=&quot;_blank&quot;&gt;小结9&lt;/a&gt;中&quot;点估计的评价&quot;来比较这两种方法。参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Bias_of_an_estimator#Sample_variance&quot; target=&quot;_blank&quot;&gt;wiki&lt;/a&gt;中的证明过程，我们可以知道：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用样本的二阶中心矩估计总体方差时，估计量的期望$E(B_2) = (1 - \frac{1}{n})\sigma^2 \leq \sigma^2$，由此可以看到该方法的估计始终是偏小的，存在系统性误差；&lt;/li&gt;
&lt;li&gt;使用样本的方差估计总体方差时，估计量的期望$E(S^2) = \sigma^2 = \sigma^2$，因此样本的方差是总体方差的无偏估计，比样本的二阶中心矩更优。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;样本二阶中心矩与样本方差之间，只有分母上有差别，当n比较小的时候，$n$与$(n-1)$之间的差别对结果的影响很大，但是当$n \to +\infty$时，这种差异就可以忽略了。以上就是我们为什么使用样本方差而不是样本二阶中心矩来估计总体方差的原因（此时并不是矩估计）。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;1. 最大似然估计&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;h4&gt;1.1 引例（基本原理）&lt;/h4&gt;
&lt;p&gt;考察以下例子：假设一个罐中放着许多白球和黑球，并假定已经知道两种球的数目之比是$1 : 3$，但不知道哪种颜色的球多。如果采用有放回抽样方法从罐中取5个球，观察结果为：黑、白、黑、黑、黑，估计取到黑球的概率$p$.&lt;/p&gt;
&lt;p&gt;在该题目中，总体服从参数为p的伯努利分布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：设$X = 1, 取到黑球; X = 0, 取到白球$, 则$X \sim B(1, p)$.&lt;/p&gt;
&lt;p&gt;        p为取到黑球的概率，未知，$p = 1/4 或 3/4$.&lt;/p&gt;
&lt;p&gt;        抽取容量为5的样本$X_1, ..., X_5$，观察值为$1, 0, 1, 1, 1$.&lt;/p&gt;
&lt;p&gt;        当$p = 1/4$时，出现本次观察结果的概率为$(\frac{1}{4})^4(\frac{3}{4}) = \frac{3}{1024}$;&lt;/p&gt;
&lt;p&gt;        当$p = 3/4$时，出现本次观察结果的概率为$(\frac{3}{4})^4(\frac{1}{4}) = \frac{81}{1024}$.&lt;/p&gt;
&lt;p&gt;        由于$3/1024 &amp;lt; 81/1024$, 因此认为$p = 3/4$比$p = 1/4$更有可能，于是$\bar{p} = 3/4$更为合理.&lt;/p&gt;
&lt;p&gt;由上面的求解过程可以看到，我们尝试了所有可能的取值（$p = 1/4$或$p = 3/4$），然后选择了一个最有可能产生出观察到的样本（$1, 0, 1, 1, 1$）的取值（$p = 3/4$）。&lt;/p&gt;

&lt;h4&gt;1.2 定义&lt;/h4&gt;
&lt;p&gt;设离散型总体$X \sim p(x; \theta), \theta 未知$. $X_1, ..., X_n$为样本，其观察值为$x_1, ..., x_n$，则事件$\{X_1 = x_1, ..., X_n = x_n\}$发生的概率为：&lt;/p&gt;
&lt;p&gt;$$p(X_1,X_2, ..., X_n) = L(\theta) = \prod_{i=1}^{n}p(x_i; \theta)  \quad  \cdots \ (1-1)$$&lt;/p&gt;
&lt;p&gt;式1-1表示所有观察值$x_1, ..., x_n$同时发生的概率（所有单个观察值发生概率的乘积）. 这个乘积有一个专门的名字：&lt;strong&gt;似然函数&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;参考1.1中的例子，我们希望参数$\theta$的估计值$\hat{\theta}$能够使得所有观察值同时发生的概率最大，也就是似然函数取到最大值：&lt;/p&gt;
&lt;p&gt;$$L(\hat{\theta}(x_1, ..., x_n)) = max L(\theta) \quad  \cdots \ (1-2)$$&lt;/p&gt;
&lt;p&gt; 式子1-2就是&lt;strong&gt;极大似然估计的基本原理&lt;/strong&gt;：将似然函数取到最大值时参数的取值作为最优的估计值；反过来也可以尝试参数所有可能的取值，使得似然函数取到最大值的取值就是最优估计值。&lt;/p&gt;
&lt;p&gt;上面的不同思路也反映了求解的两种方式：第一种是直接求似然函数的极大值；第二种是带入所有参数比较函数值的大小。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;1.3 求最大似然估计的一般步骤（以下以离散总体为例）&lt;/strong&gt;&lt;/h4&gt;
&lt;h5&gt;&lt;strong&gt;1.3.1 写出似然函数&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;$L = L(\theta_1, \theta_2, ..., \theta_m) = L(x_1, x_2, ..., x_n; \theta_1, \theta_2, ..., \theta_m) = \prod_{i=1}^{n}p(X_i = x_i; \theta_1, \theta_2, ..., \theta_m) $&lt;/p&gt;
&lt;p&gt;由于每个样本之间都是独立同分布的，因此这些样本的联合概率密度函数就是所有单个样本概率密度函数的乘积（即，这些样本所代表的事件同时发生）&lt;/p&gt;
&lt;h5&gt;1.3.2 对似然函数取对数&lt;/h5&gt;
&lt;p&gt;$ln L = \sum_{i=1}^{n}{ln P(X_i = x_i; \theta_1, \theta_2, ..., \theta_m)}$&lt;/p&gt;
&lt;p&gt;取对数是为了计算方便（对多项式加法求导比对多项连乘求导简单）&lt;/p&gt;
&lt;h5&gt;1.3.3 建立似然方程&lt;/h5&gt;
&lt;p&gt;$$\frac{\partial lnL(\theta_1, ..., \theta_m)}{\partial \theta_j} = 0, (j = 1, ..., m)$$&lt;/p&gt;
&lt;p&gt;对各个参数求偏导，令偏导数等于0.&lt;/p&gt;
&lt;h5&gt;1.3.4 解似然方程&lt;/h5&gt;
&lt;p&gt;解上面的方程，就可以求出参数$\theta_j$的最大似然估计。若似然函数不可微，需要用定义求。&lt;/p&gt;

&lt;h4&gt;1.4 几点说明&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt; 极大似然估计值是一个数值，极大似然估计量是一个随机变量（同时也是一个统计量）；&lt;/li&gt;
&lt;li&gt;似然函数是能够反映试验结果发生的概率大小的函数；&lt;/li&gt;
&lt;li&gt;从极大似然估计的定义可以看出来，使用该方法时总体的概率密度函数形式是明确的（包含未知参数）；&lt;/li&gt;
&lt;li&gt;未知参数可能不止一个，设为$\theta = (\theta_1, \theta_2, ..., \theta_k)$；&lt;/li&gt;
&lt;li&gt;若$L(\theta)$关于某个$\theta_i$是单调递增(减)函数，则$\theta_i$的极大似然估计为$\theta_i$的最大(小)值(与样本无关)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.5 经典例题&lt;/h4&gt;
&lt;h5&gt;例1&lt;/h5&gt;
&lt;p&gt;设$X$的概率密度为$f(x, \theta) = \sqrt{\theta} x^{\sqrt{\theta} - 1}, 0 \leq x \leq 1; f(x, \theta) = 0, 其他$. $X_1, ..., X_n$是样本，求$\theta$的极大似然估计量.&lt;/p&gt;
&lt;p&gt;若已获得$n = 10$的样本值如下：&lt;/p&gt;
&lt;p&gt;0.43, 0.01, 0.30, 0.04, 0.54, 0.14, 0.99, 0.18, 0.98, 0.02&lt;/p&gt;
&lt;p&gt;求$\theta$的极大似然估计值.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：$L(\theta) = \prod_{i=1}^{n} f(x_i; \theta) = \prod_{i=1}^{n} \sqrt{\theta} x_i^{\sqrt{\theta} - 1} = \theta^{\frac{n}{2}} (\prod_{i=1}^{n} x_i)^{\sqrt{\theta} - 1}$&lt;/p&gt;
&lt;p&gt;取对数后，$ln \ L(\theta) = \frac{n}{2} ln \ \theta + (\sqrt{\theta} - 1) \sum_{i=1}^{n}{ln \ x_i}$&lt;/p&gt;
&lt;p&gt;建立似然方程，$\frac{d \ ln \ L(\theta)}{d \theta} = \frac{n}{2} \cdot \frac{1}{\theta} + \frac{1}{2 \sqrt{\theta}} \sum_{i=1}^{n}{ln \ x_i} = 0$&lt;/p&gt;
&lt;p&gt;$\Rightarrow \frac{n}{\sqrt{\theta}} = - \sum_{i=1}^{n}{ln \ x_i} \Rightarrow \sqrt{\theta} = -n / \sum_{i=1}^{n}{ln \ x_i}$ &lt;/p&gt;
&lt;p&gt;最终可以得到参数$\theta$的&lt;em&gt;极大似然估计量&lt;/em&gt;为：$\hat{\theta} = \frac{n^2}{(\sum_{i=1}^{n}{ln \ X_i})^2}$&lt;/p&gt;
&lt;p&gt;将上面的样本值带入估计量，可以得到$\theta$的极大似然估计值为：$\hat{\theta} = 0.305$&lt;/p&gt;
&lt;h5&gt;例2&lt;/h5&gt;
&lt;p&gt;设总体$X \sim N(\mu, \sigma^2) $, $X_1, ..., X_n$是样本，$\mu, \sigma^2$均未知. 求$\mu, \sigma^2$的极大似然估计.&lt;/p&gt;
&lt;p&gt;解：$L(\mu, \sigma^2) = (\frac{1}{\sqrt{2\pi\sigma^2}})^n \cdot e^{- \sum_{i=1}^{n}{\frac{(x_i - \mu)^2}{2\sigma^2}}}$&lt;/p&gt;
&lt;p&gt;取对数得，$ln \ L(\mu, \sigma^2) = n \ ln\frac{1}{\sqrt{2\pi}} - \frac{n}{2}ln \ \sigma^2 - \sum_{i=1}^{n}{\frac{(x_i - \mu)^2}{2\sigma^2}}$&lt;/p&gt;
&lt;p&gt;建立似然方程，$\frac{\partial }{\partial \mu}\ ln \ L(\mu, \sigma^2) = \frac{1}{\sigma^2} \sum_{i=1}^{n}(x_i - \mu) = 0$, &lt;/p&gt;
&lt;p&gt;$\frac{\partial }{\partial \sigma^2}\ ln \ L(\mu, \sigma^2) = \frac{n}{2\sigma^2}  + \frac{1}{2\sigma^4} \sum_{i=1}^{n}(x_i - \mu)^2 = 0$&lt;/p&gt;
&lt;p&gt;解方程得，$\hat{\mu} = \bar{X}, \hat{\sigma^2} = B_2$&lt;/p&gt;
&lt;p&gt;这里利用最大似然估计得到的结果与矩估计得到的结果相同。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2. 矩估计与最大似然估计的比较&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;矩估计和最大似然估计是两个不同的点估计方法。有时候这两种方法得到的结果相同，有时候不同。&lt;/p&gt;
&lt;p&gt;使用矩估计时，不需要知道随机变量的概率密度函数（有些情况可以假设为正态分布），需要将未知参数表示为总体距的函数；&lt;/p&gt;
&lt;p&gt;使用最大似然估计时，需要知道随机变量概率密度函数的确定形式（可以包含参数），然后通过求似然函数的极值的方式得到最优解。&lt;/p&gt;
&lt;p&gt;从它们的定义和求解过程来看，矩估计更简单一些但是使用范围也比较窄（无法表示为总体矩的函数就无法使用该方法）；最大似然估计需要的条件更多，适用范围也更广一些。&lt;/p&gt;

&lt;p&gt; 欢迎阅读“&lt;a href=&quot;http://www.cnblogs.com/Belter/p/8330773.html&quot; target=&quot;_blank&quot;&gt;概率论与数理统计及Python实现&lt;/a&gt;”系列文章&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;https://en.wikipedia.org/wiki/Bias_of_an_estimator#Sample_variance&lt;/p&gt;
&lt;p&gt;https://zh.wikipedia.org/wiki/%E7%9F%A9%E4%BC%B0%E8%AE%A1&lt;/p&gt;
&lt;p&gt;中国大学MOOC：浙江大学&amp;amp;哈工大，概率论与数理统计 &lt;/p&gt;

</description>
<pubDate>Sat, 07 Apr 2018 05:09:00 +0000</pubDate>
<dc:creator>昕-2008</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Belter/p/8410382.html</dc:identifier>
</item>
<item>
<title>【ASP.NET Core】依赖注入高级玩法——如何注入多个服务实现类 - 东邪独孤</title>
<link>http://www.cnblogs.com/tcjiaan/p/8732848.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tcjiaan/p/8732848.html</guid>
<description>&lt;p&gt;依赖注入在 ASP.NET Core 中起中很重要的作用，也是一种高大上的编程思想，它的总体原则就是：俺要啥，你就给俺送啥过来。服务类型的实例转由容器自动管理，无需我们在代码中显式处理。&lt;/p&gt;
&lt;p&gt;因此，有了依赖注入后，你的编程思维就得变一变了。在过去，许多功能性的类型（比如一个加密解密的类），我们都喜欢将其定义为静态（static），而有了依赖注入，你就要避免使用静态类型，应该交由服务容器帮你管理，只要你用好了，你会发现依赖注入是很方便的。&lt;/p&gt;
&lt;p&gt;依赖注入的初级玩法，也是比较标准的玩法，此种玩法有两种模式：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、十代单传模式：一个接口对应一个类，比如先定义接口 IA、IB，随后，类A实现 IA，类B 实现 IB。一对一。也可以是抽象类（或基类）E，然后 F 继承 E 类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、断子绝孙模式：直接就写一个类，不考虑派生，直接就添加到服务容器中。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;来，看个例子。&lt;/p&gt;
&lt;p&gt;我先定义个接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IPlayGame
    {
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Play();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，写一个类来实现它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; NBPlayGame : IPlayGame
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Play()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;全民打麻药。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们知道，所谓服务类，其实就是普通类，这些类一般用于完成某些功能，比如计算 MD5 值。接着呢，还记得 Startup 类有个 ConfigureServices 方法吧，对，就在这厮里面把我们刚刚那个服务进行注册（就是添加到 ServiceCollection 集合中）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddTransient&lt;/span&gt;&amp;lt;IPlayGame, NBPlayGame&amp;gt;&lt;span&gt;();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加的时候很简单，类型一对一，IPlayGame 接口与 NBPlayGame 类对应。添加时有三种方法你可以调用，实际上对应着，服务类在容器中的生命周期。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AddSingleton：单个实例，这是寿命最长的，与天同寿。整个应用程序中仅用一个实例。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AddTransient：这个是最短命的，可能是天天晚上加班熬夜，死得很快。此种情况下，服务类的实例是用的时候创建，用完后直接销毁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AddScoped：这个比较难理解。它的生命周期在单个请求内，包括客户端与服务器之间随后产生的子请求，反正只要请求的会话结束了，就会清理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;然后，你就可以进行注入了，比如在中间件，在控制器，或者在其他服务类的构造函数上（中间件是在 Invoke / InvokeAsync 方法上）进行实例接收。&lt;/p&gt;
&lt;p&gt;现在来用一下，写一个中间件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestMiddleware
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestMiddleware(RequestDelegate next) { }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context, &lt;em&gt;&lt;strong&gt;IPlayGame game&lt;/strong&gt;&lt;/em&gt;)
        {
            game.Play();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;已注册的服务会注入到 InvokeAsync 方法的参数中。注意第一个参数是 HttpContext，这是必须参数，后面的是注入的参数。&lt;/p&gt;
&lt;p&gt;最后，在 Startup 类的 Configure 方法中就可以 use 这个中间件了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app)
        {
            app.UseMiddleware&lt;/span&gt;&amp;lt;TestMiddleware&amp;gt;&lt;span&gt;();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行后，Play 方法调用，在控制台中输出以下结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/367389/201804/367389-20180407114912660-686376061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; “断子绝孙”模式，不使用接口规范，直接写功能类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DoSomething
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetMessage() =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你好，刚才 Boss 找你。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注册服务时更简单。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddScoped&lt;/span&gt;&amp;lt;DoSomething&amp;gt;&lt;span&gt;();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 Configure 方法中进行注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, &lt;span&gt;&lt;em&gt;&lt;strong&gt;DoSomething thing&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;)
        {
            Console.WriteLine(thing.GetMessage());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行后，输出结果如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/367389/201804/367389-20180407115519315-1890259077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在容器中，使用 ServiceDescriptor 类来存储服务类型相关的信息。其中，ServiceType 表示的是服务的类型，如果服务是有接口与实现类的，那么这个属性指的是接口的类型，实现类的类型信息由 ImplementationType 属性存储。如果没有接口，直接只定义类型，那么这个类型的信息就存到 ServiceType 属性上，ImplementationType 属性不使用。&lt;/p&gt;
&lt;p&gt;上面这些例子中，ServiceType 是 IPlayGame 接口相关信息，ImplementationType 是 NBPlayGame 类的信息。如果像上面 DoSomething 类的情况，则 ServiceType 为 DoSomething 相关的信息，ImplementationType 为空。&lt;/p&gt;


&lt;p&gt;接下来，咱们看高级玩法。&lt;/p&gt;
&lt;p&gt;定义一个接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IDemoService
    {
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; Version { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Run();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，有两个类实现这个接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoService1 : IDemoService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Version =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Run()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第一个服务实现类。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoService2 : IDemoService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Version =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Run()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第二个服务实现类。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后，我们注册服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddTransient&lt;/span&gt;&amp;lt;IDemoService, DemoService1&amp;gt;&lt;span&gt;();
            services.AddTransient&lt;/span&gt;&amp;lt;IDemoService, DemoService2&amp;gt;&lt;span&gt;();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们照例，接收注入，咱们依旧使用中间件的方法参数接收。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoMiddleware
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DemoMiddleware(RequestDelegate next)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于程序约定，此构造函数必须提供。&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context, &lt;span&gt;&lt;em&gt;&lt;strong&gt;IDemoService sv&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.Response.WriteAsync(sv.Version);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，在 Startup.Configure 方法中使用该中间件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, DoSomething thing)
        {
            app.UseMiddleware&lt;/span&gt;&amp;lt;DemoMiddleware&amp;gt;&lt;span&gt;();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行之后，你发现问题了，看看输出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/367389/201804/367389-20180407120852463-1253271273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 出事了，参数仅能接收到最后注册的实现类型实例，也就是 DemoService2 类。所以就看到网上有不少朋友发贴问了，.NET Core 是不是不支持多个服务实现类的注入？这难倒了很多人。&lt;/p&gt;
&lt;p&gt;实话告诉你，Core Core 兄是支持注入多个实现类的实例的。&lt;/p&gt;
&lt;p&gt;下面，老周介绍两种解决方法（其实有三种，还有一种不太好弄，尤其是你对 Core 兄不熟的时候，所以我说两种，基本够用）。&lt;/p&gt;
&lt;p&gt;方法一、接收 IServiceProvider 类型的注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context, &lt;span&gt;&lt;em&gt;&lt;strong&gt;IServiceProvider provider&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;)
        {
            StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; sv &lt;span&gt;in&lt;/span&gt; &lt;em&gt;&lt;strong&gt;provider.GetServices&amp;lt;IDemoService&amp;gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;()&lt;/strong&gt;&lt;/em&gt;)
            {
                sb.Append($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{sv.Version}&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.Response.WriteAsync(sb.ToString());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只要能接收到 IServiceProvider 所引用的实例，就能通过 GetServices 方法获取多个服务实例。&lt;/p&gt;

&lt;p&gt;方法二，这种方法老周很推荐，更简单，直接注入 IEnumerable&amp;lt;T&amp;gt; 类型，本例中就是 IEnumerable&amp;lt;IDemoService&amp;gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task InvokeAsync(HttpContext context, &lt;span&gt;&lt;em&gt;&lt;strong&gt;IEnumerable&amp;lt;IDemoService&amp;gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt; svs&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;)
        {
            StringBuilder sb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; sv &lt;span&gt;in&lt;/span&gt;&lt;span&gt; svs)
            {
                sb.Append($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{sv.Version}&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.Response.WriteAsync(sb.ToString());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IEnumerable&amp;lt;T&amp;gt; 的妙处就是可以 foreach ，这样你也能访问多个实例，而且必要时还可以联合 LINQ 一起耍。&lt;/p&gt;
&lt;p&gt;运行结果如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/367389/201804/367389-20180407122153564-455070736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;不要问我是怎么发现的，反正我告诉你了，你用就是了。&lt;/p&gt;
&lt;p&gt;好了，今天的话题就到这儿了，3166。&lt;/p&gt;

</description>
<pubDate>Sat, 07 Apr 2018 04:22:00 +0000</pubDate>
<dc:creator>东邪独孤</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tcjiaan/p/8732848.html</dc:identifier>
</item>
<item>
<title>STM32读取温湿度传感器DHT11和DHT21（AM2301）系列问题 - kkzhang</title>
<link>http://www.cnblogs.com/lemonzhang/p/8732658.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lemonzhang/p/8732658.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、DHT11和DHT21传感器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    这两种传感器都是奥松公司的产品，具体的传感器说明书在其官网上有（www.aosong.com）。&lt;/p&gt;
&lt;p&gt;    DHT11 数字温湿度传感器是一款含有已校准数字信号输出的温湿度复合传感器。它应用专用的数 字模块采集技术和温湿度传感技术，确保产品具有枀高的可靠性与卓越的长期稳定性。传感器包括一 个电容式感湿元件和一个 NTC 测温元件，并与一个高性能 8 位单片机相连接。&lt;/p&gt;
&lt;p&gt;    DHT21（AM2301）湿敏电容数字温湿度模块是一款含有己校准数字信号输出的温湿度复合传感器。它应用专用的数字模块采集技术和温湿度传感技术，确保产品具有极高的可靠性与卓越的长期稳定性。传感器包括一个电容式感湿元件和一个高精度测温元件，并与一个高性能 8 位单片机相连接。因此该产品具有品质卓越、超快响应、抗干扰能力强、性价比极高等优点。每个传感器都在极为精确的湿度校验室中进行校准。校准系数以程序的形式储存在单片机中，传感器内部在检测信号的处理过程中要调用这些校准系数。标准单总线接口，使系统集成变得简易快捷。超小的体积、极低的功耗，信号传输距离可达 20 米以上，使其成为各类应用甚至最为苛刻的应用场合的最佳选择。产品为 3 引线（单总线接口）连接方便。特殊封装形式可根据用户需求而提供。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、温湿度读取方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    两种传感器均采用简化的单总线通信。单总线即只有一根数据线，系统中的数据交换、控制均由单总线完 成。设备（主机或从机）通过一个漏极开路或三态端口连至该数据线，以允许设备在不发送数据时能够释 放总线，而让其它设备使用总线；单总线通常要求外接一个约 4.7kΩ的上拉电阻，这样，当总线闲置时， 其状态为高电平。由于它们是主从结构，只有主机呼叫从机时，从机才能应答，因此主机访问器件都必须 严格遵循单总线序列，如果出现序列混乱，器件将不响应主机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、两种传感器的主要区别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   包括两点，分别是&lt;span&gt;单总线起始信号的数据总线拉低时间&lt;/span&gt;和&lt;span&gt;温湿度高低位数据含义&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;   DHT11的单总线格式定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070495/201804/1070495-20180407105844968-1719120366.png&quot; alt=&quot;&quot; width=&quot;783&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   DHT21的单总线格式定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1070495/201804/1070495-20180407110001893-308796152.png&quot; alt=&quot;&quot; width=&quot;786&quot; height=&quot;270&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、微秒级延时函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    根据上面的介绍我们现在需要一个微秒级的精确延时函数，否则就不能成功的读取传感器数据。STM32单片机的滴答定时器可以满足。&lt;/p&gt;
&lt;p&gt;  （1）保证滴答定时器的时钟频率为72MHz&lt;/p&gt;
&lt;p&gt;    STM32F103内部8M的内部震荡，经过倍频后最高可以达到72M。在固件库3.0以上，只需要通过两步就可以完成对时钟频率的选择。&lt;/p&gt;
&lt;p&gt;   ①修改system_stm32f10x.c开头的时钟宏定义，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; #define SYSCLK_FREQ_HSE    HSE_VALUE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; #define SYSCLK_FREQ_24MHz  24000000 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; #define SYSCLK_FREQ_36MHz  36000000 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; #define SYSCLK_FREQ_48MHz  48000000 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; #define SYSCLK_FREQ_56MHz  56000000 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; SYSCLK_FREQ_72MHz  72000000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   ②在主函数main中调用SystemInit()函数。&lt;/p&gt;
&lt;p&gt;   ③如果没有成功，需要检查单片机的晶振是否起振。简单的检测方法：&lt;/p&gt;
&lt;p&gt;       有示波器的可以查看晶振的输出波形，正常应为正弦波。没有示波器的可以利用万用表分别测量晶振的管脚电平，正常应在1/2*VCC左右。&lt;/p&gt;
&lt;p&gt;  （2）程序编写&lt;/p&gt;
&lt;p&gt;    ①在main()函数中添加：SysTick_Config(72000000 / 1000000);&lt;span&gt;//除以1000000微秒级（100000十微秒级，1000毫秒级），指进入中断的间隔时间&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{      
    SystemInit();
    SysTick_Config(&lt;/span&gt;&lt;span&gt;72000000&lt;/span&gt; / &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    ②Delay.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stm32f10x.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Delay.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;int&lt;/span&gt; TimingDelay=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; delay_us(u32 n)
{
    TimingDelay&lt;/span&gt;=&lt;span&gt;n;
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(TimingDelay!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;); 
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; delay_ms(u32 n)
{
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(n--&lt;span&gt;)
    {
     delay_us(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      Delay.h&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef _DELAY__H_
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; _DELAY__H_

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; delay_us(u32 n);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; delay_ms(u32 n);

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    ③stm32f10x_it.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;extern&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; TimingDelay;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SysTick_Handler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(TimingDelay!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        TimingDelay&lt;/span&gt;--&lt;span&gt;;    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、编写读传感器数据程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    ①DHxx.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stm32f10x.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DHxx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Delay.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sys.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
u8 tdata[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;]={&lt;span&gt;0x00&lt;/span&gt;,&lt;span&gt;0x00&lt;/span&gt;,&lt;span&gt;0x00&lt;/span&gt;,&lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;};
u8 sbuf,check;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;***************************************************************************/
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;uchar       i;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      uchar    U8FLAG,k;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      uchar    U8count,U8temp;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      uchar    U8T_data_H,U8T_data_L,U8RH_data_H,U8RH_data_L,U8checkdata;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      uchar    U8T_data_H_temp,U8T_data_L_temp,U8RH_data_H_temp,U8RH_data_L_temp,U8checkdata_temp;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      uchar    U8comdata;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      uint   ReceiveHighByte;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;      uint   ReceiveLowByte;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;***************Global defination for DHT11 end****&lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
&lt;span&gt;void&lt;/span&gt; DHT_PortIN(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin &lt;/span&gt;=&lt;span&gt; GPIO_Pin_1 ;
    GPIO_InitStructure.GPIO_Speed &lt;/span&gt;=&lt;span&gt; GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode &lt;/span&gt;=&lt;span&gt; GPIO_Mode_IN_FLOATING;     
    GPIO_Init(GPIOB,&lt;/span&gt;&amp;amp;&lt;span&gt;GPIO_InitStructure);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; DHT_PortOUT(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    GPIO_InitStructure.GPIO_Pin &lt;/span&gt;=&lt;span&gt; GPIO_Pin_1 ;
    GPIO_InitStructure.GPIO_Speed &lt;/span&gt;=&lt;span&gt; GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode &lt;/span&gt;= GPIO_Mode_Out_PP;     
    GPIO_Init(GPIOB,&amp;amp;&lt;span&gt;GPIO_InitStructure);
}
unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; StartDHT11(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
   DHT_PortOUT();
   DHT_Out &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   delay_ms(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DHT11&amp;gt;18ms&lt;/span&gt;
&lt;span&gt;  
   DHT_Out &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;    
     DHT_PortIN();
   delay_us(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);  

   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;DHT_In)
   {
           &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;DHT_In);
           &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(DHT_In);
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
   }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; StartDHT21(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
   DHT_PortOUT();
   DHT_Out &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   delay_ms(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DHT21&amp;gt;80us&lt;/span&gt;
&lt;span&gt;  
   DHT_Out &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
     DHT_PortIN();
   delay_us(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);  

   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;DHT_In)
   {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;DHT_In);
           &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(DHT_In);
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
   }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; com(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    u8 i,tt;
    tt &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;8&lt;/span&gt;;i++&lt;span&gt;)
    {
        sbuf &lt;/span&gt;&amp;lt;&amp;lt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        delay_us(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;DHT_In);
        delay_us(&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;);
        tt &lt;/span&gt;= &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(tt++&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(DHT_In)
        {
             sbuf &lt;/span&gt;|= &lt;span&gt;0x01&lt;/span&gt;&lt;span&gt;;
             delay_us(&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            sbuf &lt;/span&gt;&amp;amp;= &lt;span&gt;0xfe&lt;/span&gt;&lt;span&gt;;
        }
    }
}
u8 ReadDHT11(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    u8 sum;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(StartDHT11())    
    {
        com();
        tdata[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;sbuf;
        com();
        tdata[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;sbuf;
        com();
        tdata[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;]=&lt;span&gt;sbuf;        
        com();
        tdata[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;]=&lt;span&gt;sbuf;
        com();
        check &lt;/span&gt;=&lt;span&gt; sbuf;
        sum &lt;/span&gt;= (tdata[&lt;span&gt;0&lt;/span&gt;]+tdata[&lt;span&gt;1&lt;/span&gt;]+tdata[&lt;span&gt;2&lt;/span&gt;]+tdata[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(check ==&lt;span&gt; sum)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;    
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

u8 ReadDHT21(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    u8 sum;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(StartDHT21())    
    {
        com();
        tdata[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;sbuf;
        com();
        tdata[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;sbuf;
        com();
        tdata[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;]=&lt;span&gt;sbuf;        
        com();
        tdata[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;]=&lt;span&gt;sbuf;
        com();
        check &lt;/span&gt;=&lt;span&gt; sbuf;
        sum &lt;/span&gt;= (tdata[&lt;span&gt;0&lt;/span&gt;]+tdata[&lt;span&gt;1&lt;/span&gt;]+tdata[&lt;span&gt;2&lt;/span&gt;]+tdata[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;]);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(check ==&lt;span&gt; sum)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;    
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    DHxx.h                     //（注意：我这边定义的DATA管脚为PB1）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef _DHXX__H_
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; _DHXX__H&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sys.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; DHT_Out PBout(1)
&lt;span&gt;#define&lt;/span&gt; DHT_In  PBin(1)

&lt;span&gt;#define&lt;/span&gt; uchar unsigned char 
&lt;span&gt;#define&lt;/span&gt; uint  unsigned int&lt;span&gt;

unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; StartDHT11(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; StartDHT21(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; DHT_PortIN(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; DHT_PortOUT(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
u8 ReadDHT11(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
u8 ReadDHT21(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; com(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;**********************************

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;**********************************&lt;/span&gt;

&lt;span&gt;extern&lt;/span&gt; u8 tdata[&lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;extern&lt;/span&gt;&lt;span&gt; u8 sbuf;
&lt;/span&gt;&lt;span&gt;extern&lt;/span&gt;&lt;span&gt; u8 check;

&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    ②sys.h&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stm32f10x.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;///////////////////////////////////////////////////////////////&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; BITBAND(addr, bitnum) ((addr &amp;amp; 0xF0000000)+0x2000000+((addr &amp;amp;0xFFFFF)&amp;lt;&amp;lt;5)+(bitnum&amp;lt;&amp;lt;2)) 
&lt;span&gt;#define&lt;/span&gt; MEM_ADDR(addr)  *((volatile unsigned long  *)(addr)) 
&lt;span&gt;#define&lt;/span&gt; BIT_ADDR(addr, bitnum)   MEM_ADDR(BITBAND(addr, bitnum)) 
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IO地址映射&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOA_ODR_Addr    (GPIOA_BASE+12) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x4001080C &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOB_ODR_Addr    (GPIOB_BASE+12) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x40010C0C &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOC_ODR_Addr    (GPIOC_BASE+12) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x4001100C &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOD_ODR_Addr    (GPIOD_BASE+12) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x4001140C &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOE_ODR_Addr    (GPIOE_BASE+12) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x4001180C &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOF_ODR_Addr    (GPIOF_BASE+12) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x40011A0C    &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOG_ODR_Addr    (GPIOG_BASE+12) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x40011E0C    &lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; GPIOA_IDR_Addr    (GPIOA_BASE+8) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x40010808 &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOB_IDR_Addr    (GPIOB_BASE+8) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x40010C08 &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOC_IDR_Addr    (GPIOC_BASE+8) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x40011008 &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOD_IDR_Addr    (GPIOD_BASE+8) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x40011408 &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOE_IDR_Addr    (GPIOE_BASE+8) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x40011808 &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOF_IDR_Addr    (GPIOF_BASE+8) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x40011A08 &lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; GPIOG_IDR_Addr    (GPIOG_BASE+8) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0x40011E08 &lt;/span&gt;
 
&lt;span&gt;//IO口操作，只针对单一的IO口&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;n的值小于16&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; PAout(n)   BIT_ADDR(GPIOA_ODR_Addr,n)  &lt;span&gt;//输出&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; PAin(n)    BIT_ADDR(GPIOA_IDR_Addr,n)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入&lt;/span&gt;

&lt;span&gt;#define&lt;/span&gt; PBout(n)   BIT_ADDR(GPIOB_ODR_Addr,n)  &lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; PBin(n)    BIT_ADDR(GPIOB_IDR_Addr,n)  

&lt;span&gt;#define&lt;/span&gt; PCout(n)   BIT_ADDR(GPIOC_ODR_Addr,n) 
&lt;span&gt;#define&lt;/span&gt; PCin(n)    BIT_ADDR(GPIOC_IDR_Addr,n)  

&lt;span&gt;#define&lt;/span&gt; PDout(n)   BIT_ADDR(GPIOD_ODR_Addr,n) 
&lt;span&gt;#define&lt;/span&gt; PDin(n)    BIT_ADDR(GPIOD_IDR_Addr,n) 

&lt;span&gt;#define&lt;/span&gt; PEout(n)   BIT_ADDR(GPIOE_ODR_Addr,n)  
&lt;span&gt;#define&lt;/span&gt; PEin(n)    BIT_ADDR(GPIOE_IDR_Addr,n)  

&lt;span&gt;#define&lt;/span&gt; PFout(n)   BIT_ADDR(GPIOF_ODR_Addr,n)  
&lt;span&gt;#define&lt;/span&gt; PFin(n)    BIT_ADDR(GPIOF_IDR_Addr,n)  

&lt;span&gt;#define&lt;/span&gt; PGout(n)   BIT_ADDR(GPIOG_ODR_Addr,n)  
&lt;span&gt;#define&lt;/span&gt; PGin(n)    BIT_ADDR(GPIOG_IDR_Addr,n) 
&lt;span&gt;///////////////////////////////////////////////////////////////&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    ③main.c&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Includes ------------------------------------------------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stm32f10x.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;system.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sys.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DHxx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Delay.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{      
    SystemInit();
    SysTick_Config(&lt;/span&gt;&lt;span&gt;72000000&lt;/span&gt; / &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        ReadDHT11();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ReadDHT21();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取的信息在DHxx.c的tdata[]数组中&lt;/span&gt;
        delay_ms(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        delay_ms(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意读取间隔应该在2秒以上 &lt;/span&gt;
&lt;span&gt;        }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、参考&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【1】单片机stm32时钟频率 http://www.elecfans.com/dianzichangshi/20171113578546.html&lt;/p&gt;
&lt;p&gt;【2】https://wenku.baidu.com/view/6306fbf484254b35eefd3428.html&lt;/p&gt;
&lt;p&gt;【3】http://www.aosong.com/products-28.html&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;人不曾老去，直至悔恨取代了梦想！---约翰.巴里摩&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;











</description>
<pubDate>Sat, 07 Apr 2018 04:20:00 +0000</pubDate>
<dc:creator>kkzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lemonzhang/p/8732658.html</dc:identifier>
</item>
<item>
<title>java 零基础搭建dubbo运行环境 - 喝着啤酒写bug</title>
<link>http://www.cnblogs.com/cq-jiang/p/8732831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cq-jiang/p/8732831.html</guid>
<description>&lt;h2&gt;一：简介&lt;/h2&gt;
&lt;p&gt;　　    以前做项目时，分布式环境都是其它同事在搭建，自己也没参与分布式环境搭建，只负责开发，由于近段时间工作重心转到android，java后台有一段时间没有接触了，刚好这几天有空，决定自己动手亲自搭建一次spring+dubbo+zookeeper的运行环境,方便以后在工作中使用，如有描述错误的地方，请指正，谢谢。&lt;/p&gt;
&lt;h3&gt;　　   1 dubbo描述&lt;/h3&gt;
&lt;p&gt;　　　Dubbo是一个分布式服务框架，如果是一个小的erp系统，一台服务器足够支撑项目运行，项目就不会用Dubbo，如果是一个大的商城项目，用户访问量比较大，一台无法器根本无法支撑运行时，我们可以把订单模块，支付模块，静态页面等独立出来，放置在同一个局域网，不同服务器运行，这时我们就需要使用Dubbo, Dubbo原理图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1128579/201804/1128579-20180407095628114-1238569804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    节点角色说明：&lt;/p&gt;
&lt;p&gt;Provider: 暴露服务的服务提供方，比如支付系统实现支付接口，供订单系统调用&lt;/p&gt;
&lt;p&gt;Consumer: 调用远程服务的服务消费方，比如订单系统调用支付系统提供的服务进行付款操作。&lt;/p&gt;
&lt;p&gt;        Registry: 服务注册与发现的注册中心。&lt;/p&gt;
&lt;p&gt;        Monitor: 统计服务的调用次调和调用时间的监控中心。&lt;/p&gt;
&lt;p&gt;        Container: 服务运行容器。&lt;/p&gt;
&lt;p&gt;    各个角色之间的调用关系：&lt;/p&gt;
&lt;p&gt;        1 服务容器负责启动，加载，运行服务提供者。2 &lt;span&gt;服务提供者在启动时，向注册中心注册自己提供的服务。3 &lt;/span&gt;服务消费者在启动时，向注册中心订阅自己所需的服务。4注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。5 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。6 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心(此段描述来自网络)。&lt;/p&gt;
&lt;p&gt;　　2&lt;a href=&quot;http://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.3.6/&quot; target=&quot;_blank&quot;&gt; &lt;span&gt;zookeeper下载地址,http://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.3.6/&lt;/span&gt;&lt;/a&gt;   下载后直接解压即可&lt;/p&gt;
&lt;h2&gt;二：环境搭建&lt;/h2&gt;
&lt;h3&gt;　　1 测试环境&lt;/h3&gt;
&lt;p&gt;         我本地测试环境是 Window 7 64,Eclipse 4.4,jdk1.8,tomcat 8,zookeeper-3.3.6,apache-maven-3.5.0&lt;/p&gt;
&lt;h3&gt;        2 创建项目&lt;/h3&gt;
&lt;p&gt;         现在我们模拟一个商城环境，将支付模块和订单模块独立出来，在不同服务器上运行，然后相互之前调用，由于两个系统需要相互调用，即支付模块是服务提供者，又是消费者，订单模块也是服务提供者，又是消费者.&lt;/p&gt;
&lt;p&gt;        创建父工程shopping,创建完成后，设置父工程的Packaging为pom&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1128579/201804/1128579-20180407102648448-1253667951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　创建子工程,shopping-api(用于定义公共接口，公共实体类等),shopping-order(订单模块，需要依赖shopping-api,实现订单的service接口),shopping-pay(订单模块，需要依赖shopping-api,实现支付的service接口).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1128579/201804/1128579-20180407103003351-2071931892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　3：service的定义及实现&lt;/h3&gt;
&lt;p&gt;　　所有接口定义在shopping-api中，订单接口定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义订单读接口&lt;/span&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.service.order;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bean.OrderBean;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 订单查询
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; OrderReadService {
    List&lt;/span&gt;&amp;lt;OrderBean&amp;gt;&lt;span&gt; listQuery();
    OrderBean getOrder(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; oId);
}&lt;/span&gt;&lt;span/&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      支付接口定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.service.pay;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 订单支付
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; PayService {
    String pay(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; orderId); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;订单接口需要在shopping-order项目中实现，代码如下:
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.order.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Vector;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.bean.OrderBean;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.service.order.OrderReadService;
  
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 订单查询实现类
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OrderReadServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; OrderReadService {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;OrderBean&amp;gt;&lt;span&gt; listQuery() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        List&amp;lt;OrderBean&amp;gt; list = &lt;span&gt;new&lt;/span&gt; Vector&amp;lt;OrderBean&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;5;i++&lt;span&gt;){
            OrderBean bean &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderBean();
            bean.setoId(i&lt;/span&gt;+10&lt;span&gt;);
            bean.setoMoney(&lt;/span&gt;100+&lt;span&gt;new&lt;/span&gt; Random().nextInt(50&lt;span&gt;));
            bean.setoUserId(&lt;/span&gt;500+&lt;span&gt;new&lt;/span&gt; Random().nextInt(50&lt;span&gt;));
            list.add(bean);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; OrderBean getOrder(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; oId) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        OrderBean bean = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderBean();
        bean.setoId(oId);
        bean.setoMoney(&lt;/span&gt;100+&lt;span&gt;new&lt;/span&gt; Random().nextInt(50&lt;span&gt;));
        bean.setoUserId(&lt;/span&gt;500+&lt;span&gt;new&lt;/span&gt; Random().nextInt(50&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　支付接口需要在shopping-pay项目中实现，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.pay.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.service.pay.PayService;
 

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PayServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; PayService {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String pay(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; orderId) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; orderId + &quot;支付成功.&quot;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4:项目之间的依赖关系&lt;/h3&gt;
&lt;p&gt;　　由于shopping-api定义了完整的接口，shopping-order,shopping-pay实现了shopping-api项目下的接口，所以需要在shopping-order,shopping-pay项目中配置依赖关系，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;shopping-api&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;shopping-api&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5:配置Dubbo提供者和消费者的xml&lt;/h3&gt;
&lt;p&gt;　　由于两个项目之前需要相互调用，所以两个项目都需要配置服务提供者，和消费者，代码如下：&lt;/p&gt;
&lt;p&gt;　　shopping-order订单项目的xml配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;定义了提供方应用信息，用于计算依赖关系；在 dubbo-admin 或 dubbo-monitor 会显示这个名字，方便辨识 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:application &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;shopping-order&quot;&lt;/span&gt;&lt;span&gt; owner&lt;/span&gt;&lt;span&gt;=&quot;programmer&quot;&lt;/span&gt;&lt;span&gt; organization&lt;/span&gt;&lt;span&gt;=&quot;dubbox&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;向 zookeeper 订阅 provider 的地址，由 zookeeper 定时推送 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:registry &lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;=&quot;zookeeper://localhost:2181&quot;&lt;/span&gt;&lt;span&gt; check&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 用dubbo协议在20880端口暴露服务 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:protocol &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dubbo&quot;&lt;/span&gt;&lt;span&gt; port&lt;/span&gt;&lt;span&gt;=&quot;20880&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; (配置订单服务提供者 )提供支付方的接口 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:service &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;orderReadService&quot;&lt;/span&gt;&lt;span&gt; protocol&lt;/span&gt;&lt;span&gt;=&quot;dubbo&quot;&lt;/span&gt;&lt;span&gt; interface&lt;/span&gt;&lt;span&gt;=&quot;com.service.order.OrderReadService&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dubbo:service&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;orderReadService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.order.impl.OrderReadServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:service &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;orderWriterService&quot;&lt;/span&gt;&lt;span&gt; protocol&lt;/span&gt;&lt;span&gt;=&quot;dubbo&quot;&lt;/span&gt;&lt;span&gt; interface&lt;/span&gt;&lt;span&gt;=&quot;com.service.order.OrderWriterService&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dubbo:service&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;orderWriterService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.order.impl.OrderWriterServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置消费者 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;使用 dubbo 协议调用定义好的 api.PermissionService 接口 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:reference &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;payService&quot;&lt;/span&gt;&lt;span&gt; interface&lt;/span&gt;&lt;span&gt;=&quot;com.service.pay.PayService&quot;&lt;/span&gt;&lt;span&gt; check&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dubbo:reference&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　shopping-pay支付项目的xml配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　&amp;lt;!--&lt;/span&gt;&lt;span&gt;定义了提供方应用信息，用于计算依赖关系；在 dubbo-admin 或 dubbo-monitor 会显示这个名字，方便辨识 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:application &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;shopping-pay&quot;&lt;/span&gt;&lt;span&gt; owner&lt;/span&gt;&lt;span&gt;=&quot;programmer&quot;&lt;/span&gt;&lt;span&gt; organization&lt;/span&gt;&lt;span&gt;=&quot;dubbox&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;向 zookeeper 订阅 provider 的地址，由 zookeeper 定时推送 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:registry &lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;=&quot;zookeeper://localhost:2181&quot;&lt;/span&gt;&lt;span&gt;  check&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 用dubbo协议在20880端口暴露服务,由于订单设置的端口是20880，此处设置20881，不然tomcat启动后，会冲突报错 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:protocol &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dubbo&quot;&lt;/span&gt;&lt;span&gt; port&lt;/span&gt;&lt;span&gt;=&quot;20881&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; (配置支付服务提供者)提供给订单项目调用 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:service &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;=&quot;com.service.pay.PayService&quot;&lt;/span&gt;&lt;span&gt;  ref&lt;/span&gt;&lt;span&gt;=&quot;payService&quot;&lt;/span&gt;&lt;span&gt; protocol&lt;/span&gt;&lt;span&gt;=&quot;dubbo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dubbo:service&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;payService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.pay.impl.PayServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; (配置消费者) &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:reference &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;=&quot;com.service.order.OrderReadService&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;orderReadService&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dubbo:reference&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:reference &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;=&quot;com.service.order.OrderWriterService&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;orderWriterService&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dubbo:reference&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三：创建tomcat运行环境&lt;/h2&gt;
&lt;p&gt;　　    我将不同的项目，放置在不同的tomcat下，创建过程：File-new-Other,弹出如下窗体&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1128579/201804/1128579-20180407112356882-1143085026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1128579/201804/1128579-20180407112422406-1772278739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　添加完成，将项目导入tomcat，效果图如下&lt;/p&gt;
&lt;p&gt;　　shopping-pay将端口号设置为：8081,&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1128579/201804/1128579-20180407113054234-184298490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　shopping-order将端口号设置为：8082&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1128579/201804/1128579-20180407113136070-1917246135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四：启动项目，调用接口测试&lt;/h2&gt;
&lt;p&gt;　　启动tomcat前，需要先启动zookeeper,先进入之前解压的zookeeper/bin目录，运行zkServer.cmd，然后再启动tomcat，两个项目不分先后启动，但测试前，需要保证两个项目正常启动.&lt;/p&gt;
&lt;p&gt;　　直接在浏览器中输入如下地址测试,控制层的代码，没有贴出来，完整代码在文章最后有下载地址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;http://127.0.0.1:8081/shopping-pay/pay/orderList.do?id=10

http://127.0.0.1:8082/shopping-order/order/pay.do?id=123&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五：注意事项&lt;/h2&gt;
&lt;p&gt; 　　因为两个项目，需要相互调用，所以配置服务端口暴露服务时，记得将两个端口设置为不一样，不然会出错，此处配置我也不是很熟悉，如配置不对，请指正，谢谢，配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 用dubbo协议在20880端口暴露服务 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:protocol &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dubbo&quot;&lt;/span&gt;&lt;span&gt; port&lt;/span&gt;&lt;span&gt;=&quot;20880&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 用dubbo协议在20880端口暴露服务,由于订单设置的端口是20880，此处设置20881，不然tomcat启动后，会冲突报错 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:protocol &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dubbo&quot;&lt;/span&gt;&lt;span&gt; port&lt;/span&gt;&lt;span&gt;=&quot;20881&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另外还需要注意：向 zookeeper 订阅 provider 的地址,以及配置dubbo:service，需要把check设置为false,不然项目无法启动，&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:registry &lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;=&quot;zookeeper://localhost:2181&quot;&lt;/span&gt;&lt;span&gt;  check&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dubbo:service &lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt;=&quot;com.service.pay.PayService&quot;&lt;/span&gt;&lt;span&gt;  ref&lt;/span&gt;&lt;span&gt;=&quot;payService&quot;&lt;/span&gt;&lt;span&gt; protocol&lt;/span&gt;&lt;span&gt;=&quot;dubbo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dubbo:service&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        由于两个项目依赖于，shopping-api，虽然在pom.xml中引入了对shopping-api的依赖，我本地tomcat启动时，仍然报错，找不到shopping-api下的公共类，所以我将shopping-api打包成jar包，放置在shopping-order和shopping-pay项目中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1128579/201804/1128579-20180407120557443-1188672405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考文献：&lt;/p&gt;
&lt;p&gt;分布式系统架构实战demo:SSM+Dubbo&lt;br/&gt;https://my.oschina.net/liughDevelop/blog/1480061#0-sqq-1-469-9737f6f9e09dfaf5d3fd14d775bfee85&lt;/p&gt;
&lt;p&gt;dubbo 既是提供方又是消费方的问题&lt;br/&gt;https://blog.csdn.net/q596333033/article/details/78573741&lt;/p&gt;
&lt;p&gt;Dubbo架构&lt;/p&gt;
&lt;p&gt;http://dubbo.apache.org/books/dubbo-dev-book/design.html&lt;/p&gt;
&lt;p&gt; dubbo 知识总结 dubbo配置参考&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/abcde474524573/article/details/53026110&lt;/p&gt;

&lt;p&gt; 这是本人第一次搭建dubbo环境，本文可能有错误的地方，希望大家指正，谢谢，&lt;span&gt;&lt;a href=&quot;https://github.com/jlq023/dubbo-shopping&quot; target=&quot;_blank&quot;&gt;完整代码下载地址：https://github.com/jlq023/dubbo-shopping&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h4&gt; &lt;/h4&gt;
</description>
<pubDate>Sat, 07 Apr 2018 04:09:00 +0000</pubDate>
<dc:creator>喝着啤酒写bug</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cq-jiang/p/8732831.html</dc:identifier>
</item>
<item>
<title>漫谈版本控制系统 - 木可大大</title>
<link>http://www.cnblogs.com/neal-ke/p/8732830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neal-ke/p/8732830.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;我想大家都给文件起过这些名称：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;HelloWorld&lt;span class=&quot;hljs-selector-class&quot;&gt;.java
&lt;span class=&quot;hljs-selector-tag&quot;&gt;HelloWorld_2018_04_05&lt;span class=&quot;hljs-selector-class&quot;&gt;.java
&lt;span class=&quot;hljs-selector-tag&quot;&gt;HelloWorld_2018_04_06&lt;span class=&quot;hljs-selector-class&quot;&gt;.java
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们单独使用这些文件时，按照上述方式可以很好的管理文件，但是，如果现在有两个人同时修改这份文件，那么，其中一人对文件修改的内容会被另一人的内容所覆盖，这是我们不希望看到的。譬如下面代码中，不能简简单单地用李四写的HelloWorld覆盖张三写的HelloWorld。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;h2&gt;v1.0--悲观锁&lt;/h2&gt;
&lt;p&gt;基于此，版本控制系统（Version Control System，VCS）就应用而生了，此时的VCS(v1.0)通过悲观锁将并发执行转换成顺序执行，它具有如下功能：首先，应该把文件放在一个服务器上，方便使用者上传或下载文件；其次，任何人想对文件修改时，需要先把这个文件加锁，通过&lt;code&gt;checkout&lt;/code&gt;指令，使得其他人无法修改；最后，当修改完成之后，需要释放锁，通过&lt;code&gt;checkin&lt;/code&gt;指令，形成一个新的版本，存放到服务器端。&lt;br/&gt;使用v1.0之后，张三和李四需要争夺锁，假设张三抢到锁，张三首先将HelloWorld.java上传到服务器端，形成一个新的版本并释放锁，接着，李四获得锁，上传代码到服务器端进行比较合并，最后上传，最终形成如下代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;HelloWorld{
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;methodA&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int arg){
    System.out.print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;hi &quot; + arg);
  }
  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;methodB&lt;span class=&quot;hljs-params&quot;&gt;(){
    &lt;span class=&quot;hljs-keyword&quot;&gt;int a = &lt;span class=&quot;hljs-number&quot;&gt;1;
    &lt;span class=&quot;hljs-keyword&quot;&gt;int b = &lt;span class=&quot;hljs-number&quot;&gt;2;
    System.out.print(a+b);
  }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;v2.0--乐观锁&lt;/h2&gt;
&lt;p&gt;基于悲观锁的VCS也存在一些问题，譬如：王五只想学习下HelloWorld，并不会对该文件进行修改，当王五向VCS服务器拉取最新代码也需要进行锁操作；张三在提交完最新代码之后，忘记了释放锁，导致其他想修改代码的人无法修改。针对这些问题，我们将乐观锁替换成悲观锁，VCS演进到v2.0版本。乐观锁通常的做法是在每个表中增加一个version版本字段，事务修改数据之前先读数据，当然版本也顺势读取出来，然后把这个读取出来的版本号加入到更新语句的条件中，比如，读取出来的版本号是1，我们修改数据的语句可以这样写，update table set column = xx where id = 1 and version =1 ,那如果更新失败了，说明以后其他事务已经修改过数据了，那系统需要抛出异常给客户端，让客户端自行处理，客户端可以选择重试。&lt;br/&gt;还是以HelloWorld为例，张三修改了HelloWorld.java，并且成功提交到VCS服务器中。与此同时，李四也修改了HelloWorld.java，提交的时候，系统就会提示&quot;版本已更新，请重新下载最新版本！&quot;。这时的李四需要重服务器拉取最新代码，然后把本地代码和服务器最新代码进行Merge。&lt;/p&gt;
&lt;h2&gt;v3.0--多分支并行&lt;/h2&gt;
&lt;p&gt;我们知道每一款软件都会潜藏一些Bug，并且用户在使用软件的过程中会提出一些新的需求，这就要求我们不仅要修改这些Bug，还要完成新增功能模块，而往往修改Bug的进度比较快，而新增功能模块的周期比较长，这就导致我们不能在一个代码库中进行工作，如果这么做，那么修正了Bug以后就没法发布，因为包含新功能的代码还没有完成！&lt;br/&gt;基于此，VCS演进到v3.0版本，支持多分支并行开发。举例来说，以刚刚发布的产品代码在Master分支，修改Bug团队创建branch-bug分支，而新增功能团队创建branch-new分支，两个团队在完成各自任务之后，将各自分支Merge到Master分支中。&lt;/p&gt;
&lt;h2&gt;v4.0--分布式&lt;/h2&gt;
&lt;p&gt;伴随着软件功能的不断增加，越来越多的团队加入进来，与此同时，出现了一些新的问题，由于VCS的服务器是集中式的，时不时出现宕机情况，导致开发人员无法提交代码；还有就是有些开发人员没有对代码进行好好测试就提交了，带出了很多bug，为了保证代码质量，能不能在代码提交之前有人对提交的代码进行审查。&lt;br/&gt;基于上述两方面的考虑，VCS演进到v4.0版本，支持分布式，即每个开发人员本地都有代码仓库，它的架构图如下。首先，开发人员1和开发人员2从官方代码库中克隆，然后进行修改；修改完成之后，并不是将代码推送到官方代码库，而是推送到自己本地仓库；项目维护人员从开发人员代码仓库拉取修改过的代码，然后决定是否接受这个修改；最后项目维护人员将修改完成的代码推送到官方代码仓库。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-101519dc60ba4d37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/10175366-101519dc60ba4d37.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-c5019c4af30667e9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/10175366-c5019c4af30667e9?imageMogr2/auto-orient/strip&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;p&gt;欢迎关注微信公众号：木可大大，所有文章都将同步在公众号上。&lt;/p&gt;
</description>
<pubDate>Sat, 07 Apr 2018 03:56:00 +0000</pubDate>
<dc:creator>木可大大</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/neal-ke/p/8732830.html</dc:identifier>
</item>
</channel>
</rss>