<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>学习定制自己的博文1 - 可达鸭要进化</title>
<link>http://www.cnblogs.com/Aries-rong/p/8047607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Aries-rong/p/8047607.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;目录：&lt;/p&gt;
&lt;p&gt;正文：&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/Aries-rong/p/8047607.html#Top&quot;&gt;返回顶部&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　每次浏览到博客园中很多漂亮的博文的时候都是由衷的羡慕，偷懒以为博客园会在后台设置的有，但是有的没的试了两次后就知道是各位大神自己重新设计的代码了，作为一个前端小白，我只能望洋兴叹（其实就是懒地去学）。&lt;/p&gt;
&lt;p&gt;　　最近终于忍受不了我的博文了，所以开始学习如何解决拖延症晚期病症了，emmmmmmmmm，其实真正学起来没有那么难，前端真的算起来入门比较简单了，只要你想，真的是随时都能入门。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/924627/201712/924627-20171216203630671-489877128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　看吧，前后也就半个月的时间，我都能让博文能见人了。所以越来越觉得：&lt;code&gt;&lt;strong&gt;消除恐惧唯一的办法就是面对恐惧！&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　当然，在学习过程中看到一个网友说的：前端入门容易，学精难。真的特别赞同这句话，越了解前端越觉得好玩，也越觉得不好学，而我目前最大的梦想是就优化我的博文（好像有点目光短浅的样子，嘻嘻），所以对于前端我暂时没有更大的追求，当然，现在看见起来像屎一样的后台代码也不是我的终点（惨o(╥﹏╥)o），我会慢慢记录我学习的过程，也慢慢一步一步优化我的后台代码，由于是自己傻学，我猜很多地方都是用的傻的办法的，希望各位前端大神偶尔指点一二O(∩_∩)O。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/Aries-rong/p/8047607.html#Top&quot;&gt;回到顶部&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　目前我学习的是HTML/HTML5/XTML/CSS这四样，但是我学的也真的是了解一个大概的程度，想起了学一点了解一点，然后……忘很多（o(╥﹏╥)o），忘了就忘了吧，然后在实践中慢慢又重新了解吧。真的，实践才是最重要的，实验室的练习和实地的操作真的不是不同档次的，你要学习一门语言，最好的方法就是立马能用上来做一件事，不然很多东西都容易浮于表面，这样至少对我来说，学了和没学是一样的效果（惨）。&lt;/p&gt;
&lt;p&gt;　　我是通过网站&lt;a href=&quot;http://www.w3school.com.cn/&quot;&gt;http://www.w3school.com.cn/&lt;/a&gt;学习的，推荐给和我一样的小白。&lt;/p&gt;
&lt;p&gt;　　学习了解到一些基础知识后就是看博客园中那些好看博文的源代码了，我电脑是win10，自带的Edge，每次看到那些好看的博文，就用右键“检查元素”，就能看到那页的源代码了，我的目标暂时只是优化博文，但是开始的时候还是很懵逼，分不清哪一块是哪一块，所以就一个一个找吧，然后好看的博文看多了，能大概加估计猜到博文是哪一个块了，所以多看多练多找找就好了。（也是因为我的目的单纯简单吧，哈哈哈）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/924627/201712/924627-20171216203703030-573210156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;code&gt;念念不忘，必有回响。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/Aries-rong/p/8047607.html#Top&quot;&gt;回到顶部&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;3.1 我想要的效果&lt;/h2&gt;
&lt;p&gt;　　我想优化的效果大约分为这几部分：1.一级标题放大并居中显示；2.二级标题加边框、边框背景图，二级放大显示，达到完全分开文章的明显效果；3.三级标题三级放大显示；4.文章开头添加目录，可链接到对应部分；5.添加小链接：“回到顶部”；6.颜色搭配合适博客本身背景色。&lt;/p&gt;
&lt;h2&gt;3.2 基础知识如何实现&lt;/h2&gt;
&lt;p&gt;　　下面来聊聊这些功能在理论情况的实现吧。&lt;/p&gt;
&lt;p&gt;　　首先确定一件事：只能用css文件来修改我的博文，html好像没办法直接修改哈，所以需要设计出我自己的css文件。&lt;/p&gt;
&lt;h3&gt;3.2.1 一级标题&lt;/h3&gt;
&lt;p&gt;　　想实现的效果：放大并居中显示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;h1&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    text-align&lt;/span&gt;:&lt;span&gt;center&lt;/span&gt;;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;h1文本实现居中显示&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    color&lt;/span&gt;:&lt;span&gt;#075db3&lt;/span&gt;;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;文本颜色&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    font-weight&lt;/span&gt;:&lt;span&gt;bold&lt;/span&gt;;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;加粗&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　h1本身在我自己理论期间看起来都比较大，所以就直接让他实现居中显示就好了。&lt;/p&gt;
&lt;h3&gt;3.2.2 二级标题&lt;/h3&gt;
&lt;p&gt;　　想要实现的效果：加边框、边框背景图，二级放大显示，达到完全分开文章的明显效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;h2&lt;/span&gt;{
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    background&lt;/span&gt;:&lt;span&gt; #aa7a53&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置背景色 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    border-radius&lt;/span&gt;:&lt;span&gt;6px 6px 6px 6px&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;给边框的四个角添加圆角边框，看着柔软一点，好看！&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    box-shadow&lt;/span&gt;:&lt;span&gt;0px 0px 0px 1px #5f5a4b, 1px 1px 6px 1px rgba(10,10,0,0.5)&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 向框添加一个或者多个阴影，看着立体一点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    color&lt;/span&gt;:&lt;span&gt;#ffffff&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;字体颜色 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    font-family&lt;/span&gt;:&lt;span&gt;” 微软雅黑”,” 宋体”,” 黑体”, Arial&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 字体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    font-size&lt;/span&gt;:&lt;span&gt;17px&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;字体大小&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    height&lt;/span&gt;:&lt;span&gt;25px&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;段落高度&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    line-height&lt;/span&gt;:&lt;span&gt;25px&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;行高&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    margin&lt;/span&gt;:&lt;span&gt;15px 0&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;等价于15px 0px 15px 0px; 设定外边距&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    padding&lt;/span&gt;:&lt;span&gt;5px 0 5px 20px&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;内边距&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    text-shadow&lt;/span&gt;:&lt;span&gt;2px 2px 3px #222222&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;文本阴影效果&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一段h2其实是我在边浏览别人网页的时候找到的，也实现了我所需要的效果，所以就记录了下来，效果如图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/924627/201712/924627-20171216203837655-1526982653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里再补充一下css框模型（Box Model）规定了元素框处理元素内容、内边距、外框和外边距的方式：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/924627/201712/924627-20171216203851843-2088264246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　元素框的最内部部分是实际的内容，直接包围内容的是内边距。内边距呈现了元素的背景。内边距的边缘是边框。边框以外是外边距，外边距默认是透明的，因此不会遮挡其后的任何元素。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　内边距、边框和外边距都是可选的，默认值是零。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　在css中，width和height指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　Ps：内边距、外框和外边距（外边距可以是负数）可以应用于一个元素的所有边，也可以应用于单独的边。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　备注：因为我本身特别喜欢金黄色，所以我在博客园中选的主题是coffee主题，然后我通过后台代码找到了主题的相关颜色，所以我选到了#aa7a53这个颜色，每个人喜好不同，而且一个界面我觉得主题色不要超过三种的好。&lt;/p&gt;
&lt;h3&gt;3.2.3 三级标题&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;h3&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    text-indent&lt;/span&gt;:&lt;span&gt;15px&lt;/span&gt;;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;文本块中首行文本的缩进&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    color&lt;/span&gt;:&lt;span&gt; #aa7a53&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;字体颜色 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2.4 目录&lt;/h3&gt;
&lt;p&gt;　　目录部分我是在HTML上面直接修改的，暂时还没有想到在css文件中添加的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=”#什么是备忘录模式？”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;什么是备忘录模式？&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=”#备忘录模式的组成”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;备忘录模式的组成&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=”#备忘录模式具体实现”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;备忘录模式具体实现&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=”#适配器模式的结构”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;适配器模式的结构&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=”#适配器模式的实现”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;适配器模式的实现&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=”#实例解析”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;实例解析&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=”#具体实现”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;具体实现&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=”#备忘录模式的优缺点”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;备忘录模式的优缺点&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=”#备注”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;备注&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对应的我在h2的地方必须将其命名为对应的名字：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=”什么是备忘录模式？”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;什么是备忘录模式？&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2.5 添加小链接&lt;/h3&gt;
&lt;p&gt;       实现：回到顶部。&lt;/p&gt;
&lt;p&gt;　　这个功能就和4一样了，我将目录的名字设置为“_labelTop”,然后“回到顶部”直接链接到_labelTop就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=”_labelTop”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;目录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=”text-align:right”&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=”#_labelTop”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;回到顶部&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Ps:HTML与CSS写法类似，但是完全不同，被绕晕了好多次_(¦3)∠)_。&lt;/p&gt;
&lt;h2&gt;3.3 博客园中具体分块&lt;/h2&gt;
&lt;p&gt;　　看了好多的博客才慢慢分清楚博客园中的博文分类：&lt;/p&gt;
&lt;h3&gt;3.3.1 整体部分&lt;/h3&gt;
&lt;p&gt;　　 &lt;img src=&quot;http://images2017.cnblogs.com/blog/924627/201712/924627-20171216204119827-470691888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Head部分我没研究，也暂时研究不懂，就不研究了，我主要看的是body部分。&lt;/p&gt;
&lt;h3&gt;3.3.2 body部分&lt;/h3&gt;
&lt;p&gt;　　 &lt;img src=&quot;http://images2017.cnblogs.com/blog/924627/201712/924627-20171216204145639-928978497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这就如图所示了，分为三块：&lt;code&gt;header&lt;/code&gt;、&lt;code&gt;main&lt;/code&gt;、&lt;code&gt;footer&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　Header部分：放我们博客的那些信息。&lt;/p&gt;
&lt;p&gt;　　Main部分：就放我们的博文、各种评论、旁边的小控件（sideBar）那些我们看的主要部分了。也是我需要研究的主要部分了。&lt;/p&gt;
&lt;p&gt;　　Footer部分：放copyright。&lt;/p&gt;
&lt;h3&gt;3.3.3 博文部分&lt;/h3&gt;
&lt;p&gt;　　 &lt;img src=&quot;http://images2017.cnblogs.com/blog/924627/201712/924627-20171216204154296-186347911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一步一步细化下去就直接找到博文主体了。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;http://images2017.cnblogs.com/blog/924627/201712/924627-20171216204200311-2131646330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看见我们的博文在这个叫做&lt;code&gt;cnblogs_post_body&lt;/code&gt;这个选择器里。&lt;/p&gt;
&lt;p&gt;　　补充一波&lt;code&gt;id选择器&lt;/code&gt;知识：&lt;/p&gt;
&lt;h4&gt;3.3.3.1 id选择&lt;/h4&gt;
&lt;p&gt;　　id选择器可以为标有特定id的HTML元素指定特定的样式。&lt;/p&gt;
&lt;p&gt;　　id选择器以“#”来定义。&lt;/p&gt;
&lt;h4&gt;3.3.3.2 id选择器和派生选择器&lt;/h4&gt;
&lt;p&gt;　　在现代布局中，id选择器常常用于建立派生选择器。&lt;/p&gt;
&lt;p&gt;　　例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#sidebar p&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;         font-style&lt;/span&gt;:&lt;span&gt;italic&lt;/span&gt;;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;         text-align&lt;/span&gt;:&lt;span&gt;right&lt;/span&gt;;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;         margin-top&lt;/span&gt;:&lt;span&gt;0.5em&lt;/span&gt;;
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的样式只会应用于出现在id是sidebar的元素内的段落。这个元素很可能是div或者是标的单元，尽管它也可能是一个表格或者其他块级元素。它甚至可以是一个内联元素，比如&amp;lt;em&amp;gt;&amp;lt;/em&amp;gt;或者&amp;lt;span&amp;gt;&amp;lt;/span&amp;gt;,不过这样的用法是非法的，因为不可以在内联元素&amp;lt;span&amp;gt;中嵌入&amp;lt;p&amp;gt;。&lt;/p&gt;
&lt;h4&gt;3.3.3.3 一个选择器，多种用法&lt;/h4&gt;
&lt;p&gt;　　id选择器作为派生选择器可以被使用很多次。&lt;/p&gt;
&lt;p&gt;　　例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#sidebar p&lt;/span&gt;{
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;         font-style&lt;/span&gt;:&lt;span&gt;italic&lt;/span&gt;;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;         text-align&lt;/span&gt;:&lt;span&gt;right&lt;/span&gt;;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;         margin-top&lt;/span&gt;:&lt;span&gt;0.5em&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; }
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#sidebar h2&lt;/span&gt;{
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;         font-size&lt;/span&gt;:&lt;span&gt;1em&lt;/span&gt;;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;         font-weight&lt;/span&gt;:&lt;span&gt;normal&lt;/span&gt;;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;         font-style&lt;/span&gt;:&lt;span&gt;italic&lt;/span&gt;;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;         margin&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;         line-height&lt;/span&gt;:&lt;span&gt;1.5&lt;/span&gt;;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;         text-align&lt;/span&gt;:&lt;span&gt;right&lt;/span&gt;;
&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.4 结合博客园定制博文&lt;/h2&gt;
&lt;p&gt;　　直接把css文件写好，放到后台就好了，我这里用的是id选择器派生的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#cnblogs_post_body h2&lt;/span&gt;{
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  background&lt;/span&gt;:&lt;span&gt;#aa7a53&lt;/span&gt;;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  border-radius&lt;/span&gt;:&lt;span&gt; 6px 6px 6px 6px &lt;/span&gt;;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  box-shadow&lt;/span&gt;:&lt;span&gt;0px 0px 0px 1px #5f5a4b, 1px 1px 6px 1px rgba(10,10,0,0.5)&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  color&lt;/span&gt;:&lt;span&gt;#ffffff&lt;/span&gt;;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;  font-family&lt;/span&gt;:&lt;span&gt;&quot;微软雅黑&quot;,&quot;宋体&quot;,&quot;黑体&quot;,Arial&lt;/span&gt;;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  font-size&lt;/span&gt;:&lt;span&gt;17px&lt;/span&gt;;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  font-weight&lt;/span&gt;:&lt;span&gt;bold&lt;/span&gt;;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  height&lt;/span&gt;:&lt;span&gt;25px&lt;/span&gt;;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  line-height&lt;/span&gt;:&lt;span&gt;25px&lt;/span&gt;;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  margin&lt;/span&gt;:&lt;span&gt;15px 0&lt;/span&gt;;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  padding&lt;/span&gt;:&lt;span&gt;5px 0 5px 20px&lt;/span&gt;;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  text-shadow&lt;/span&gt;:&lt;span&gt;text-shadow: 2px 2px 3px #222222&lt;/span&gt;;
&lt;span&gt;14&lt;/span&gt; }
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#cnblogs_post_body h3&lt;/span&gt;{
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;  text-indent&lt;/span&gt;:&lt;span&gt;15px&lt;/span&gt;;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;  color&lt;/span&gt;:&lt;span&gt;#aa7a53&lt;/span&gt;;
&lt;span&gt;19&lt;/span&gt; }
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#cnblogs_post_body p code&lt;/span&gt;{
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;  font-family&lt;/span&gt;:&lt;span&gt; Menlo,Monaco,Consolas,&quot;Andale Mono&quot;,&quot;lucida console&quot;,&quot;Courier New&quot;,monospace&lt;/span&gt;;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;  border&lt;/span&gt;:&lt;span&gt;1px solid gray&lt;/span&gt;;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  background-color&lt;/span&gt;:&lt;span&gt;#f5f5f5&lt;/span&gt;;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;  border&lt;/span&gt;:&lt;span&gt;1px solid #ccc&lt;/span&gt;;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;  padding&lt;/span&gt;:&lt;span&gt;5px&lt;/span&gt;;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;  overflow&lt;/span&gt;:&lt;span&gt;auto&lt;/span&gt;;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;  margin&lt;/span&gt;:&lt;span&gt;5px 0&lt;/span&gt;;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;  border-radius&lt;/span&gt;:&lt;span&gt;3px&lt;/span&gt;;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;  color&lt;/span&gt;:&lt;span&gt;#c7254e&lt;/span&gt;;
&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.5 额外补充:&lt;/h2&gt;
&lt;h3&gt;3.5.1 &lt;code&gt;类选择器&lt;/code&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;.center&lt;/span&gt;{&lt;span&gt;text-align&lt;/span&gt;:&lt;span&gt;center&lt;/span&gt;;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上面的例子中，所有用于center类的HTML元素均为居中。&lt;/p&gt;
&lt;p&gt;　　在下面的HTML代码中，h1和p元素都有center类。这意味着两者都将遵守”.center”选择器中的规则：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;h1 class=”center”&amp;gt;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;This heading will be center-aligned.
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;&amp;lt;/h1&amp;gt;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&amp;lt;p class=”center”&amp;gt;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;This paragraph will also be center-aligned.
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　和id&lt;/strong&gt;&lt;strong&gt;一样，class&lt;/strong&gt;&lt;strong&gt;也可以被用作派生选择器：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;.fancy td&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;         color&lt;/span&gt;:&lt;span&gt;#f60&lt;/span&gt;;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;         background&lt;/span&gt;:&lt;span&gt;#666&lt;/span&gt;;
&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另外一种写法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;td.fancy&lt;/span&gt;{
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;         color&lt;/span&gt;:&lt;span&gt;#f60&lt;/span&gt;;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;         background&lt;/span&gt;:&lt;span&gt;#666&lt;/span&gt;;
&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上面的例子中，类名为fancy的表格单元将是带有灰色背景的橙色。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;td class=”fancy”&amp;gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.5.2 &lt;code&gt;属性选择器&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;　　对带有指定属性的HTML元素设置样式。&lt;/p&gt;
&lt;p&gt;　　可以为拥有指定属性的HTML元素设置样式，而不仅限于class和id属性。&lt;/p&gt;
&lt;p&gt;　　注释：只有在规定了!DOCTYPE时，IE7和IE8才支持属性选择器。在IE6及更低版本中，不支持属性选择器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;[title]&lt;/span&gt;{&lt;span&gt;color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面的例子为带有包含指定值的lang属性的所有元素设置样式。适用于由连字符分隔的属性值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;[lang|=en]&lt;/span&gt;{&lt;span&gt;color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;right&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/Aries-rong/p/8047607.html#Top&quot;&gt;回到顶部&lt;/a&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;　　消除恐惧唯一的办法就是面对恐惧。&lt;/p&gt;
&lt;p&gt;　　喜欢就去追求，别让来日的自己有任何后悔的机会。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;strong&gt;备注&lt;/strong&gt;：博文弄好看了，我总结的心情都是愉悦的，想要学习然后总结的积极性都被调动了，嘻嘻。&lt;/p&gt;
&lt;p&gt;　　　　　当初最开始设计的时候是在文档中的，所以文章本身就直接用的二级标题，后面发现博文中是可以有一级标题的，所以文章中对应的标题在实际应用中都向上提高了一级。（h2在实际中是h1的）&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 07:14:00 +0000</pubDate>
<dc:creator>可达鸭要进化</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Aries-rong/p/8047607.html</dc:identifier>
</item>
<item>
<title>Reminders在电商推荐中的价值 - 笨兔勿应</title>
<link>http://www.cnblogs.com/bentuwuying/p/8051529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bentuwuying/p/8051529.html</guid>
<description>&lt;p&gt;原论文在UMAP'16。文章并没有太高深的模型，比较接地气；但其观点与结论很独到，并且在工业界具有很强的实际操作价值。&lt;/p&gt;
&lt;p&gt;针对推荐系统的研究大多关注在挖掘用户并不知道但是却与其兴趣相关的物品。不过每个推荐系统所在的领域都有其各自的特点，本文所讨论的是电商领域的推荐系统，在电商领域中，给用户适当地推荐其过去曾经浏览过（或者消费过）的物品（reminders）同样具有一定的价值。&lt;/p&gt;
&lt;p&gt;实验证明，在推荐结果中同时包含有reminders以及协同过滤（CF）等推荐方式的结果时，具有最好的效果。但是在推荐reminders时候也有很多需要改进的点：（1）如何避免太过明显的重复浏览的商品，避免已经无效商品（下架等）；（2）如何推荐与用户当前购物需求相关的reminders。&lt;/p&gt;
&lt;p&gt;首先，文章分析了用户对于电商网站的推荐内容中的reminders的接受度。以Zalando网站（一家欧洲的在线购物网站）为例，抽样了3000个重度用户，他们对18w+的商品有过310w量级左右的商品浏览记录，以及10w+的购买记录。对于这些用户，从日志中分析出有一下几个重要点：&lt;/p&gt;
&lt;p&gt;1. 一个用户的购物session中平均有9次商品的浏览行为；平均每3次购物session会转化为一次购买行为。&lt;/p&gt;
&lt;p&gt;2. 在推荐的商品中，有约1/10的商品是reminders，即用户之前已经浏览过这些商品；有约1/4的推荐列表中包含有至少一个reminders。&lt;/p&gt;
&lt;p&gt;3. 在成功推荐的商品（在同一次session中，用户对该商品的点击浏览行为最终转化为购买行为）中，有约40%的商品为reminders。&lt;/p&gt;
&lt;p&gt;4. 在用户最终转化成购买行为的reminders中，用户对这些商品在此前有过若干次的浏览行为。如下图所示：有成功推荐商品数与用户距离对该商品首次浏览时候的天数间隔的关系；以及成功推荐商品数与用户对该商品的浏览次数的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/995611/201712/995611-20171217133625468-1643969516.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;204&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/995611/201712/995611-20171217133700452-1425372785.png&quot; alt=&quot;&quot; width=&quot;349&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5. 在一次购物session中，用户平均浏览的商品类目约为2.7个，说明用户在一次session中的意图还是比较有目的性的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;reminders的推荐策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个通用的流程是：&lt;/p&gt;
&lt;p&gt;1. 获取用户在过去时间内有过浏览行为的商品集合，并从中筛选出哪些商品可以用作reminders。&lt;/p&gt;
&lt;p&gt;2. 对这些reminders进行一定规则的过滤，并进行排序得到最终的reminders推荐结果。&lt;/p&gt;
&lt;p&gt;排序的策略有：&lt;/p&gt;
&lt;p&gt;1. Interaction Recency（IRec）&lt;/p&gt;
&lt;p&gt;对某商品的浏览行为发生的时刻越接近，排序分越高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/995611/201712/995611-20171217135441171-1377635825.png&quot; alt=&quot;&quot; width=&quot;199&quot; height=&quot;38&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2. Interaction Intensity（IInt）&lt;/p&gt;
&lt;p&gt;对某商品的浏览行为发生的次数越多，排序分越高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/995611/201712/995611-20171217141230530-899150609.png&quot; alt=&quot;&quot; width=&quot;135&quot; height=&quot;29&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3. Item Similarity（ISim）&lt;/p&gt;
&lt;p&gt;有过浏览行为的商品，与当前用户的购物意图（以当前实时浏览的商品来表示）越接近，排序分越高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/995611/201712/995611-20171217141413327-927887049.png&quot; alt=&quot;&quot; width=&quot;224&quot; height=&quot;41&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. Session Similarity（SSim）&lt;/p&gt;
&lt;p&gt;有过浏览行为的session，与当前用户的购物意图（以当前实时浏览的session来表示）越接近，排序分越高。然后再对排序较高的session中的商品进行IInt策略的重排序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/995611/201712/995611-20171217141600436-424318000.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;42&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Feature-based Category Filtering&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在电商领域，用户一般很少对相同类目下的商品进行重复购买，所以至少在一定时间间隔内，不应该给用户推荐与其之前已经购买过的商品属于相同类目的商品。&lt;/p&gt;
&lt;p&gt;维护一个blacklist，对用户已经购买过的商品，将其类目加入到这个blacklist中，直至其又重新开始浏览该类目的商品再将其移出blacklist。&lt;/p&gt;

&lt;p&gt;为了防止推荐商品太过于obvious，增加一个obvious gap的时间间隔，对于与当前时刻过近的时间段内用户浏览过的商品 ，我们不应当将其看作reminders。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;版权声明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   本文由&lt;a href=&quot;http://www.cnblogs.com/bentuwuying&quot; target=&quot;_blank&quot;&gt;笨兔勿应&lt;/a&gt;所有，发布于&lt;a href=&quot;http://www.cnblogs.com/bentuwuying&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/bentuwuying&lt;/a&gt;。如果转载，请注明出处，在未经作者同意下将本文用于商业用途，将追究其法律责任。&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 06:35:00 +0000</pubDate>
<dc:creator>笨兔勿应</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bentuwuying/p/8051529.html</dc:identifier>
</item>
<item>
<title>啊，我的程序为啥卡住啦 - xybaby</title>
<link>http://www.cnblogs.com/xybaby/p/8025435.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xybaby/p/8025435.html</guid>
<description>&lt;p&gt;　　服务器程序员最怕的就是程序crash，不过有时候程序没有crash，但是“不工作”了也是够吓人的。所谓“不工作”就是指程序不再响应新的请求，处在了某种自娱自乐的状态，英语有一个很形象但的单词“hung”，但我不知道怎么翻译，姑且称之为“卡住”吧。本人遇到过的有两种情况，一种是卡在系统调用，如常见的磁盘IO或者网络、多线程锁；另一种就是代码进入了死循环。&lt;/p&gt;
&lt;p&gt;　　在《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/7954610.html&quot; target=&quot;_blank&quot;&gt;日志的艺术&lt;/a&gt;》一文中，讨论了日志的重要性，如果日志恰当，也能帮助我们分许程序卡住的问题。如果狂刷重复的日志，那么很可能就是死循环，从日志内容就能分析出死循环的位置，甚至是死循环的原因。如果没有日志输出了，那么看看最后一条日志的内容，也许就会告诉我们即将进行IO操作，当然也可能是即将进入死循环。&lt;/p&gt;
&lt;p&gt;　　如果日志无法提供充足的信息，那就得求助于其他的手段，在Linux下当仁不让的自然是&lt;a href=&quot;http://www.gnu.org/software/gdb/documentation/&quot; target=&quot;_blank&quot;&gt;gdb&lt;/a&gt;，gdb的功能很强大，陈皓大牛的&lt;a href=&quot;http://blog.csdn.net/haoel/article/details/2879&quot; target=&quot;_blank&quot;&gt;用GDB调试程序&lt;/a&gt;系列是我见过的讲解gdb最好的中文文章。CPython是用C语言实现的，自然也是可以用gdb来调试的，只不过，默认只显示C栈，凡人如我是无法脑补出python栈来的，这个时候就需要使用到&lt;a href=&quot;https://wiki.python.org/moin/DebuggingWithGdb&quot; target=&quot;_blank&quot;&gt;python－dbg&lt;/a&gt;与&lt;a href=&quot;https://github.com/python/cpython/blob/master/Tools/gdb/libpython.py&quot; target=&quot;_blank&quot;&gt;libpython&lt;/a&gt;了，前者帮助显示Python源码的符号信息，后者能让我们能在Python语言这个层面调试程序，比如打印Python调用栈。&lt;/p&gt;
&lt;p&gt;　　本文简答介绍在linux环境下如何利用gdb来分析卡住的程序，本文使用的Python为Cpython2.7，操作系统为Debian。&lt;/p&gt;
&lt;p&gt;　　本文地址：&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/8025435.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/xybaby/p/8025435.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　程序被卡住，很可能是程序被阻塞了，即在等待（wait）等个系统调用的结束，比如磁盘IO与网络IO、多线程，默认的情况下很多系统调用都是阻塞的。多线程的问题复杂一下，后面专门介绍。下面举一个UDP Socket的例子（run_forever_block.py）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; socket
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; simple_server():
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         address = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 40000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         s =&lt;span&gt; socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        s.bind(address)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             data, addr = s.recvfrom(2048&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; data:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client has exist&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;received:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, data, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, addr
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         simple_server()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一个简单的UDP程序，代码在（0.0.0.0， 40000）这个地址上等待接收数据，核心就是第10行的&lt;a href=&quot;https://linux.die.net/man/2/recvfrom&quot; target=&quot;_blank&quot;&gt;recvfrom&lt;/a&gt;函数，这就是一个阻塞（blocking）的系统调用，只有当读到数据之后才会返回，因此程序会卡在第10行。当然，也可以通过fcntl设置该函数为非阻塞（non-blocking）。&lt;/p&gt;
&lt;p&gt;　　我们来看看阻塞的情况，运行程序，然后通过top查看这个进程的状态&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1089769/201712/1089769-20171212091207024-1284274386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到这个进程的pid是26466，进程状态为S(Sleep)，CPU为0.0。进程状态和CPU都暗示我们，当前进程正阻塞在某个系统调用。这个时候，有一个很好使的命令：&lt;a href=&quot;https://linux.die.net/man/1/strace&quot; target=&quot;_blank&quot;&gt;strace&lt;/a&gt;，可以跟踪进程的所有系统调用，我们来看看&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;~$ strace -T -tt -e trace=all -p 26466&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Process 26466 attached&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19:21:34.746019 recvfrom(3,&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　可以看到，进程卡在了recvfrom这个系统调用，对应的文件描述符（file descriptor）是3，其实通过recvfrom这个名字，大致也能定位问题。关于文件描述符，还有一个更实用的命令，&lt;a href=&quot;https://linux.die.net/man/8/lsof&quot; target=&quot;_blank&quot;&gt;lsof（list open file）&lt;/a&gt;，可以看到当前进程打开的所有文件，在linux下，一切皆文件，自然也就包括了socket。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;lsof -p 26466&lt;/span&gt;&lt;br/&gt;&lt;span&gt;COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;python 26466 xxxxxxx &lt;span&gt;&lt;strong&gt;3u&lt;/strong&gt;&lt;/span&gt; IPv4 221871586 0t0 UDP *:40000&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　从上面可以看出这个文件描述符（3U）更详细的信息，比如是IPV4 UDP，监听在40000端口等等。&lt;/p&gt;

&lt;p&gt;　　上面这个例子非常的简单，简单到我们直接从系统调用就能看出问题，但是实际的情况下可能更加复杂，即无法通过系统调用直接定位到处问题的代码。这个时候就可以使用gdb了，关于如何用gdb来调试python程序，可以参考了&lt;a href=&quot;http://simple-is-better.com/news/747&quot; target=&quot;_blank&quot;&gt;使用gdb调试Python进程&lt;/a&gt;这篇文章。以上面的代码为例，首先得做好准备条件&lt;/p&gt;
&lt;p&gt;　　首先，参考&lt;a href=&quot;https://wiki.python.org/moin/DebuggingWithGdb&quot; target=&quot;_blank&quot;&gt;DebuggingWithGdb&lt;/a&gt;，根据自己的Linux系统安装好python-dbg，在我的平台（Debian）上即 &lt;em&gt;sudo apt-get install gdb python2.7-dbg&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　然后，下载&lt;a href=&quot;https://github.com/python/cpython/blob/master/Tools/gdb/libpython.py&quot; target=&quot;_blank&quot;&gt;libpython&lt;/a&gt;，放在自己的HOME目录下&lt;/p&gt;
&lt;p&gt;　　接下来就可以使用gdb进行分析了：&lt;em&gt;gdb -p 26466&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　在gdb的交互式环境中，使用bt命令，看到的是C栈，意义不大，我们直接来看Python栈&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;(gdb) python&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;import sys&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;sys.path.insert(0, '/home/xxx')&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;import libpython&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;end&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;(gdb) py-bt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Traceback (most recent call first):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　File &quot;run_forever_block.py&quot;, line 10, in simple_server&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　data, addr = s.recvfrom(2048)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　File &quot;run_forever_block.py&quot;, line 17, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　simple_server()&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　可以看到，通过py-bt就能显示出完整的python调用栈，能帮助我们定位问题。还有很多py开头的命令，具体可见libpython.py中（所有gdb.Command的子类都是一个命令），&lt;a href=&quot;http://www.cnblogs.com/sting2me/p/7745551.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;中总结了几个常用的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;py-list 　　查看当前python应用程序上下文&lt;/li&gt;
&lt;li&gt;py-bt 　　 查看当前python应用程序调用堆栈&lt;/li&gt;
&lt;li&gt;py-bt-full 　　 查看当前python应用程序调用堆栈，并且显示每个frame的详细情况&lt;/li&gt;
&lt;li&gt;py-print 　　 查看python变量&lt;/li&gt;
&lt;li&gt;py-locals　　 查看当前的scope的变量&lt;/li&gt;
&lt;li&gt;py-up 　　 查看上一个frame&lt;/li&gt;
&lt;li&gt;py-down 　　 查看下一个frame&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;


&lt;p&gt;　　死循环很令人讨厌，死循环是预期之外的无限循环。最典型的预期之内的无限循环是socketserver，进程不死，服务不止。而死循环看起来很忙（CPU100%），但是没有任何实质的作用。死循环有不同的粒度，最粗的粒度是两个进程之间的相互调用，比如RPC；其次是函数级别，较为常见的是没有边界条件的递归调用，或者在多个函数之间的相互调用；最小的粒度是在一个函数内部，某一个代码块（code block）的死循环，最为常见的就是for，while语句。在Python中，函数级别是不会造成无限循环的，如代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    func()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    func1()
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     func()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行代码，很快就会抛出一个异常：&lt;em&gt;RuntimeError: maximum recursion depth exceeded&lt;/em&gt;。显然，python内部维护了一个调用栈，限制了最大的递归深度，默认约为1000层，也可以通过&lt;em&gt;sys.setrecursionlimit(limit)&lt;/em&gt;来修改最大递归深度。在Python中，虽然出现这种函数级别的死循环不会导致无限循环，但是也会占用宝贵的CPU，也是决不应该出现的。&lt;/p&gt;
&lt;p&gt;　　而代码块级别的死循环，则会让CPU转到飞起，如下面的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     func()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这种情况，通过看CPU还是很好定位的&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1089769/201712/1089769-20171212093447087-2007483527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　从进程状态R（run），以及100%的CPU，基本上就能确定是死循环了，当然也不排除是CPU密集型，这个跟代码的具体逻辑相关。这个时候，也是可以通过gdb来看看当前调用栈的，具体的准备工作如上，这里直接给出py-bt结果&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;(gdb) py-bt&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Traceback (most recent call first):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　File &quot;run_forever.py&quot;, line 5, in func&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　File &quot;run_forever.py&quot;, line 8, in &amp;lt;module&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(gdb)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　在《&lt;a href=&quot;http://www.cnblogs.com/xybaby/p/6343285.html&quot; target=&quot;_blank&quot;&gt;无限“递归”的python程序&lt;/a&gt;》一文中，提到过使用协程greenlet能产生无限循环的效果，而且看起来非常像函数递归，其表现和gdb调试结果与这里的死循环是一样的&lt;/p&gt;

&lt;p&gt;　　由于Python的GIL，在我们的项目中使用Python多线程的时候并不多。不过多线程死锁是一个非常普遍的问题，而且一般来说又是一个低概率的事情，复现不容易，多出现在高并发的线上环境。这里直接使用《&lt;a href=&quot;http://blog.csdn.net/handsomekang/article/details/39855759&quot; target=&quot;_blank&quot;&gt;飘逸的python - 演示一种死锁的产生&lt;/a&gt;》中的代码，然后分析这个死锁的多线程程序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('cf944877-f75d-449f-8302-d32794c46db1')&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_cf944877-f75d-449f-8302-d32794c46db1&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cf944877-f75d-449f-8302-d32794c46db1&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('cf944877-f75d-449f-8302-d32794c46db1',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cf944877-f75d-449f-8302-d32794c46db1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Account:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, _id, balance, lock):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         self.id =&lt;span&gt; _id
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.balance =&lt;span&gt; balance
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         self.lock =&lt;span&gt; lock
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; withdraw(self, amount):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self.balance -=&lt;span&gt; amount
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; deposit(self, amount):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         self.balance +=&lt;span&gt; amount
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; transfer(_from, to, amount):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; _from.lock.acquire():&lt;span&gt;#&lt;/span&gt;&lt;span&gt;锁住自己的账户&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        _from.withdraw(amount)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         time.sleep(1)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;让交易时间变长，2个交易线程时间上重叠，有足够时间来产生死锁&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wait for lock...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; to.lock.acquire():&lt;span&gt;#&lt;/span&gt;&lt;span&gt;锁住对方的账户&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            to.deposit(amount)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            to.lock.release()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        _from.lock.release()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;finish...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; a = Account(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1000&lt;span&gt;, threading.Lock())
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; b = Account(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1000&lt;span&gt;, threading.Lock())
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; threading.Thread(target = transfer, args = (a, b, 100&lt;span&gt;)).start()
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; threading.Thread(target = transfer, args = (b, a, 200)).start()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;线程死锁代码实例&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　运行代码，可以看见，该进程（进程编号26143）也是出于Sleep状态，因为本质上进程也是阻塞在了某个系统调用，因此，同样可以使用strace&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;p$ strace -T -tt -e trace=all -p 26143&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Process 26143 attached&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19:29:29.289042 futex(0x1286060, FUTEX_WAIT_PRIVATE, 0, NULL&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　可以看见，进程阻塞在&lt;a href=&quot;http://man7.org/linux/man-pages/man2/futex.2.html&quot; target=&quot;_blank&quot;&gt;futex&lt;/a&gt;这个系统调用，参数的意义可以参见manpage。&lt;/p&gt;

&lt;p&gt;　　gdb也非常适用于调试多线程程序，对于多线程，有几个很使用的命名&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　info thread：　　列出所有的线程，以及所在线程&lt;/li&gt;
&lt;li&gt;　　thread x：　　切换到第X号线程&lt;/li&gt;
&lt;li&gt;　　thread apply all bt：　　打印所有线程的调用栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　下面是简化后的结果&lt;/p&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;&lt;span&gt;(gdb) info thread&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Id Target Id Frame&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3 Thread 0x7fb6b2119700 (LWP 26144) &quot;python&quot; 0x00007fb6b38d8050 in sem_wait () from /lib/x86_64-linux-gnu/libpthread.so.0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2 Thread 0x7fb6b1918700 (LWP 26145) &quot;python&quot; 0x00007fb6b38d8050 in sem_wait () from /lib/x86_64-linux-gnu/libpthread.so.0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;* 1 Thread 0x7fb6b3cf8700 (LWP 26143) &quot;python&quot; 0x00007fb6b38d8050 in sem_wait () from /lib/x86_64-linux-gnu/libpthread.so.0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(gdb) thread apply all bt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thread 3 (Thread 0x7fb6b2119700 (LWP 26144)):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#0 0x00007fb6b38d8050 in sem_wait () from /lib/x86_64-linux-gnu/libpthread.so.0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#1 0x000000000057bd20 in PyThread_acquire_lock (waitflag=1, lock=0x126c2f0) at ../Python/thread_pthread.h:324&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#2 lock_PyThread_acquire_lock.lto_priv.2551 () at ../Modules/threadmodule.c:52&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thread 2 (Thread 0x7fb6b1918700 (LWP 26145)):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#0 0x00007fb6b38d8050 in sem_wait () from /lib/x86_64-linux-gnu/libpthread.so.0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#1 0x000000000057bd20 in PyThread_acquire_lock (waitflag=1, lock=0x131b3d0) at ../Python/thread_pthread.h:324&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thread 1 (Thread 0x7fb6b3cf8700 (LWP 26143)):&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#0 0x00007fb6b38d8050 in sem_wait () from /lib/x86_64-linux-gnu/libpthread.so.0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#1 0x000000000057bd20 in PyThread_acquire_lock (waitflag=1, lock=0x1286060) at ../Python/thread_pthread.h:324&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#2 lock_PyThread_acquire_lock.lto_priv.2551 () at ../Modules/threadmodule.c:52&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 　　这里推荐一篇非常不错的文章，&lt;a href=&quot;http://www.cnblogs.com/sting2me/p/7745551.html&quot; target=&quot;_blank&quot;&gt;用gdb调试python多线程代码-记一次死锁的发现&lt;/a&gt;，记录了一个在真实环境中遇到的多线程死锁问题，感兴趣的同学可以细读。&lt;/p&gt;

&lt;p&gt;　　当进程被卡主，我们需要尽快恢复服务，被卡主的原因可能是偶然的，也有可能是必然的，而且实际中导致进程卡主的真正原因不一定那么清晰明了。在我们分析卡主的具体原因的时候，我们可能需要先尽快重启服务，这个时候就需要保留现场了，那就是coredump。&lt;/p&gt;
&lt;p&gt;　　按照我的经验，有两种方式。&lt;/p&gt;
&lt;p&gt;　　第一种，kill -11 pid，11代表信号SIGSEGV，在kill这个进程的同时产生coredump，这样就可以迅速重启程序，然后慢慢分析&lt;/p&gt;
&lt;p&gt;　　第二种，在gdb中使用&lt;a href=&quot;https://sourceware.org/gdb/onlinedocs/gdb/Core-File-Generation.html&quot; target=&quot;_blank&quot;&gt;gcore（generate-core-file）&lt;/a&gt;，这个也很有用，一些bug我们是可以通过gdb线上修复的，但问题还是需要时候继续查看，这个时候就可以用这个命令先产生coredump，然后退出gdb，让修复后的程序继续执行。&lt;/p&gt;

&lt;p&gt;　　当一个进程不再响应新的请求时，首先看日志，很多时候日志里面会包含足够的信息。&lt;/p&gt;
&lt;p&gt;　　其次，看进程的信息，Sleep状态，以及100%的CPU都能给我们很多信息，也可以用pidstat查看进程的各种信息&lt;/p&gt;
&lt;p&gt;　　如果怀疑进程被阻塞了，那么可以使用strace确认&lt;/p&gt;
&lt;p&gt;　　linux下，gdb是很好的调试武器，建议平时多试试，coredump也是一定会遇到的&lt;/p&gt;
&lt;p&gt;　　linux下运行的Python程序，可以配合使用python-dbg和libpython分析程序。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wiki.python.org/moin/DebuggingWithGdb&quot; target=&quot;_blank&quot;&gt;DebuggingWithGdb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.gnu.org/software/gdb/documentation/&quot; target=&quot;_blank&quot;&gt;GDB: The GNU Project Debugger&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/python/cpython/blob/master/Tools/gdb/libpython.py&quot; target=&quot;_blank&quot;&gt;libpython.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;https&quot; href=&quot;https://fedoraproject.org/wiki/Features/EasierPythonDebugging&quot;&gt;EasierPythonDebugging&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/haoel/article/details/2879&quot; target=&quot;_blank&quot;&gt;用GDB调试程序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://simple-is-better.com/news/747&quot; target=&quot;_blank&quot;&gt;使用gdb调试Python进程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/sting2me/p/7745551.html&quot; target=&quot;_blank&quot;&gt;用gdb调试python多线程代码-记一次死锁的发现&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 05:25:00 +0000</pubDate>
<dc:creator>xybaby</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xybaby/p/8025435.html</dc:identifier>
</item>
<item>
<title>nuget服务器搭建，以及如何发布一个Nuget包 - 小龙女先生</title>
<link>http://www.cnblogs.com/cqhaibin/p/8051834.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cqhaibin/p/8051834.html</guid>
<description>&lt;p&gt;本文章主要介绍如何将本地dll打包成为一个Nuget包，并如何发布到自己的nuget服务器，&lt;span&gt;&lt;a href=&quot;https://files.cnblogs.com/files/cqhaibin/nuget-example.rar&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;示例代码下载&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。章节如下&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/cqhaibin/p/8051834.html#sectionone&quot;&gt;&lt;span&gt;本地dll如何打包，以及版本的更新&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/cqhaibin/p/8051834.html#sectiontwo&quot;&gt;&lt;span&gt;在linux上搭建nuget.server&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/cqhaibin/p/8051834.html#sectionthree&quot;&gt;&lt;span&gt;在windows上搭建nuget.server&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/cqhaibin/p/8051834.html#sectionfour&quot;&gt;&lt;span&gt;nuget常用命令&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;sectionone&quot;&gt;一、本地dll如何打包，以及版本的更新&lt;/h2&gt;
&lt;p&gt;本小节主要介绍两种方式将本地dll打包为Nuget包，&lt;/p&gt;
&lt;h3&gt;1.1 利用nuget.exe进行打包（应用于.net framework）&lt;/h3&gt;
&lt;h5&gt;1. 下载nuget.exe&lt;/h5&gt;
&lt;p&gt;nuget.exe下载地址:&lt;a href=&quot;https://www.nuget.org/downloads%E3%80%82&quot;&gt;https://www.nuget.org/downloads。&lt;/a&gt;&lt;br/&gt;下载完成后，不需要安装。请将nuget.exe复制到需要打包的项目文件夹中&lt;/p&gt;
&lt;h5&gt;2. 打包成.nupkg包&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nuget-packages-init.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先运行&lt;code&gt;.\nuget sepc&lt;/code&gt; 生成.nuspec配置文件，用于nuget的配置项&lt;/li&gt;
&lt;li&gt;然后运行&lt;code&gt;.\nuget pack packageName&lt;/code&gt; 发布成nuget包&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;3. 注意&lt;/h4&gt;
&lt;p&gt;此类库更新版本之后，再打包成.nuget文件，是不会重新生成.nuspec文件。&lt;/p&gt;
&lt;h3&gt;1.2 使用dotnet 进行打包（应用于.net core )&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;运行 &lt;code&gt;dotnet pack&lt;/code&gt;即可对当前项目打包，必须在当前项目文件夹中支持（还有.csproj文件的目录）&lt;/li&gt;
&lt;li&gt;对项目进行版本行，可以配置.csprojc文件，如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;Project Sdk=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.NET.Sdk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netstandard2.&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&amp;lt;/TargetFramework&amp;gt;
    &amp;lt;Version&amp;gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&amp;lt;/Version&amp;gt;
    &amp;lt;AssemblyVersion&amp;gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&amp;lt;/AssemblyVersion&amp;gt;
    &amp;lt;FileVersion&amp;gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&amp;lt;/FileVersion&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处需要注意的时候，默认创建的dll是没Version， AssemblyVersion, FileVersion节点，需要自己手动添加；以及在更新版本后 .nuspec文件会根据版本重新创建一个:&lt;br/&gt;&lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nuget-version.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.3 配置nuget源&lt;/h3&gt;
&lt;h4&gt;1. 本地文件包的方式&lt;/h4&gt;
&lt;p&gt;配置本地Nuget源。在工具 nuget包管理器 -&amp;gt; 程序包源，做如下配置&lt;br/&gt;&lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nuget-packages-source.png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;然后把发布的.nupkg包放在此文件夹即可&lt;/p&gt;
&lt;h4&gt;2. 配置自己服务器的源&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nuget-vs-import-forwin.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，如果用的是linux版本，测源地址中不需要加nuget子目录。&lt;/p&gt;
&lt;h3&gt;1.4 使用&lt;/h3&gt;
&lt;p&gt;引入界面如下：&lt;br/&gt;&lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nuget-packages-use.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;sectiontwo&quot;&gt;二、在linux上搭建nuget.server&lt;/h2&gt;
&lt;p&gt;本小节介绍如何使用docker来搭建属于自己的Nuget仓库&lt;/p&gt;
&lt;h3&gt;2.1. 运行docker镜像&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run -d  -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; -v $PWD/nuget/db:/var/www/db -v $PWD/nuget/packages:/var/www/packagefiles  -e NUGET_API_KEY=ee28314c-f7fe-&lt;span&gt;2550&lt;/span&gt;-bd77-e09eda3d0119  sunside/simple-nuget-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-v nuget：当前目录下nuget文件夹映射为 nuget-server的包，其中要有packages文件夹。他也有映射&lt;br/&gt;nuget_api_key：表示此Nuget仓库的索引Key。push的要用的&lt;/p&gt;
&lt;h3&gt;2.2 创建一项目打包和发布&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建一个 classlib 库文件（web，或者webapi是不能打包的）&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet &lt;span&gt;new&lt;/span&gt; classlib -n Nu.Common
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;打包 进入到项目根目录，也就是包含.csproj文件的目录&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
dotnet pack
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令成功后，会在bin/Debug目录下创建.nupkg文件&lt;br/&gt;&lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nuget-pack.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发布包 必须进入到.nupkg包所在位置&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
..\..\nuget.exe push -Source http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8080 -ApiKey ee28314c-f7fe-2550-bd77-e09eda3d0119 Nu.Common.1.0.0.nupkg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nuget-push-docker.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.3. 引用包&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在vs中的引用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nuget-vs-import.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在vscode中的引用&lt;br/&gt;配置nuget.config配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;
&amp;lt;configuration&amp;gt;
 &amp;lt;packageSources&amp;gt; 
    &amp;lt;&lt;/span&gt;&lt;span&gt;add&lt;/span&gt; key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mySource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; /&amp;gt;
 &amp;lt;/packageSources&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行&lt;code&gt;dotnet add package Nu.Common(包名)&lt;/code&gt;即可.&lt;br/&gt;&lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nuget-vscode-import.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;sectionthree&quot;&gt;三、在windows上搭建&lt;/h2&gt;
&lt;p&gt;此方式更为简单，因为nuget上有现在的nuget.server这包，就是用于做这件事情的。步骤如下（&lt;a href=&quot;http://xn--nuget-si1hx01aml7aqde1vs.net&quot;&gt;此nuget包不支持.net&lt;/a&gt; core版本）:&lt;/p&gt;
&lt;h3&gt;3.1  搭建项目&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建一个mvc 项目（空） &lt;a href=&quot;http://xn--35tp2xf2icma489koa.net&quot;&gt;此项目必须的.net&lt;/a&gt; Framework版本必须&amp;gt;=4.6。&lt;br/&gt;&lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nugetserver-win-stepone.png&quot; alt=&quot;image&quot;/&gt;&lt;/li&gt;
&lt;li&gt;引入nuget.server这个nuget包 &lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nugetserver-win-steptwo.png&quot; alt=&quot;image&quot;/&gt;&lt;/li&gt;
&lt;li&gt;更改配置&lt;/li&gt;
&lt;/ul&gt;&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;121&quot;&gt;节点名&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;396&quot;&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;121&quot;&gt;apiKey&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;396&quot;&gt;nuget.server的密钥配置，用于Push和delete包&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;121&quot;&gt;packagesPath&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;396&quot;&gt;nuget.server中的包存放路径&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;配置节点都在appSettings节点下&lt;/p&gt;
&lt;h3&gt;3.2  运行此项目&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;解决一个错误，如果在运行时提示如下错误，请按照提示删除相应的节点&lt;br/&gt;&lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nugetserver-win-stepthree.png&quot; alt=&quot;image&quot;/&gt;&lt;/li&gt;
&lt;li&gt;运行成功&lt;br/&gt;&lt;img src=&quot;http://ov1e3fd5m.bkt.clouddn.com/nuget/nugetserver-win-stepfour.png&quot; alt=&quot;image&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;发布和移除包 因为Nuget的客户端只有一个，可以参考docker搭建章节的push和delele&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;sectionfour&quot;&gt;四、常用命令&lt;/h2&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;84&quot;&gt;命令&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;说明&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;465&quot;&gt;示例&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;84&quot;&gt;push&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;发布一个包到nuget.server，包名 apikey, -Source是必须的&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;465&quot;&gt;.\nuget.exe push .\ClassLibrary1.1.2.0.nupkg samlong -Source http://localhost:56546/nuget&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;84&quot;&gt;delete&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;从指定 -Source上移除一个包，必须指定版本&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;465&quot;&gt;..\..\nuget.exe delete Nu.Common 1.0.0 samlong -Source http://localhost:56981/nuget&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;84&quot;&gt;list&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;357&quot;&gt;查看服务器上有那些nuget 包&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;465&quot;&gt;.\nuget.exe list -Source http://localhost:56546/nuget&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当然dotnet 也是一样的&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 05:10:00 +0000</pubDate>
<dc:creator>小龙女先生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cqhaibin/p/8051834.html</dc:identifier>
</item>
<item>
<title>【Keras】从两个实际任务掌握图像分类 - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/8051705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/8051705.html</guid>
<description>&lt;p&gt;我们一般用深度学习做图片分类的入门教材都是MNIST或者CIFAR-10，因为数据都是别人准备好的，有的甚至是一个函数就把所有数据都load进来了，所以跑起来都很简单，但是跑完了，好像自己还没掌握图片分类的完整流程，因为他们没有经历数据处理的阶段，所以谈不上走过一遍深度学习的分类实现过程。今天我想给大家分享两个比较贴近实际的分类项目，从数据分析和处理说起，以Keras为工具，彻底掌握图像分类任务。&lt;/p&gt;
&lt;p&gt;这两个分类项目就是：交通标志分类和票据分类。交通标志分类在无人驾驶或者与交通相关项目都有应用，而票据分类任务就更加贴切生活了，同时该项目也是我现在做的一个大项目中的子任务。这两个分类任务都是很贴近实际的练手好项目，希望经过这两个实际任务可以掌握好Keras这个工具,并且搭建一个用于图像分类的通用框架，以后做其他图像分类项目也可以得心应手。&lt;/p&gt;
&lt;p&gt;先说配置环境：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Python 3.5&lt;/li&gt;
&lt;li&gt;Keras==2.0.1,TesnsorFlow后端，CPU训练&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;一交通标志分类&quot;&gt;一、交通标志分类&lt;/h2&gt;
&lt;p&gt;首先是观察数据，看看我们要识别的交通标志种类有多少，以及每一类的图片有多少。打开一看，这个交通标志的数据集已经帮我们分出了训练集和数据集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120459499-451597130.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个文件夹的名字就是其标签。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120510843-1401421107.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一类的标志图片数量在十来张到数十张，是一个小数据集，总的类别是62。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120527843-285894728.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120539546-1218860439.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120551499-1743277361.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我们开始以Keras为工具搭建一个图片分类器通用框架。&lt;/p&gt;
&lt;h3 id=&quot;搭建cnn&quot;&gt;搭建CNN&lt;/h3&gt;
&lt;p&gt;用深度学习做图片分类选的网络肯定是卷积神经网络，但是现在CNN的种类这么多，哪一个会在我们这个标志分类任务表现最好？在实验之前，没有人会知道。一般而言，先选一个最简单又最经典的网络跑一下看看分类效果是的策略是明智的选择，那么LeNet肯定是最符合以上的要求啦，实现简单，又相当经典。那我们先单独写一个lenet.py的文件，然后实现改进版的LeNet类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120605061-1278701160.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# import the necessary packages
from keras.models import Sequential
from keras.layers.convolutional import Conv2D
from keras.layers.convolutional import MaxPooling2D
from keras.layers.core import Activation
from keras.layers.core import Flatten
from keras.layers.core import Dense
from keras import backend as K
 
class LeNet:
    @staticmethod
    def build(width, height, depth, classes):
        # initialize the model
        model = Sequential()
        inputShape = (height, width, depth)
        # if we are using &quot;channels last&quot;, update the input shape
        if K.image_data_format() == &quot;channels_first&quot;:   #for tensorflow
            inputShape = (depth, height, width)
        # first set of CONV =&amp;gt; RELU =&amp;gt; POOL layers
        model.add(Conv2D(20, (5, 5),padding=&quot;same&quot;,input_shape=inputShape))
        model.add(Activation(&quot;relu&quot;))
        model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))
        #second set of CONV =&amp;gt; RELU =&amp;gt; POOL layers
        model.add(Conv2D(50, (5, 5), padding=&quot;same&quot;))
        model.add(Activation(&quot;relu&quot;))
        model.add(MaxPooling2D(pool_size=(2, 2), strides=(2, 2)))
        # first (and only) set of FC =&amp;gt; RELU layers
        model.add(Flatten())
        model.add(Dense(500))
        model.add(Activation(&quot;relu&quot;))

        # softmax classifier
        model.add(Dense(classes))
        model.add(Activation(&quot;softmax&quot;))

        # return the constructed network architecture
        return model&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中conv2d表示执行卷积，maxpooling2d表示执行最大池化，Activation表示特定的激活函数类型，Flatten层用来将输入“压平”，用于卷积层到全连接层的过渡，Dense表示全连接层（500个神经元）。&lt;/p&gt;
&lt;h3 id=&quot;参数解析器和一些参数的初始化&quot;&gt;参数解析器和一些参数的初始化&lt;/h3&gt;
&lt;p&gt;首先我们先定义好参数解析器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# set the matplotlib backend so figures can be saved in the background
import matplotlib
matplotlib.use(&quot;Agg&quot;)
 
# import the necessary packages
from keras.preprocessing.image import ImageDataGenerator
from keras.optimizers import Adam
from sklearn.model_selection import train_test_split
from keras.preprocessing.image import img_to_array
from keras.utils import to_categorical
from imutils import paths
import matplotlib.pyplot as plt
import numpy as np
import argparse
import random
import cv2
import os
import sys
sys.path.append('..')
from net.lenet import LeNet



def args_parse():
    # construct the argument parse and parse the arguments
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;-dtest&quot;, &quot;--dataset_test&quot;, required=True,
        help=&quot;path to input dataset_test&quot;)
    ap.add_argument(&quot;-dtrain&quot;, &quot;--dataset_train&quot;, required=True,
        help=&quot;path to input dataset_train&quot;)
    ap.add_argument(&quot;-m&quot;, &quot;--model&quot;, required=True,
        help=&quot;path to output model&quot;)
    ap.add_argument(&quot;-p&quot;, &quot;--plot&quot;, type=str, default=&quot;plot.png&quot;,
        help=&quot;path to output accuracy/loss plot&quot;)
    args = vars(ap.parse_args()) 
    return args&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还需要为训练设置一些参数，比如训练的epoches，batch_szie等。这些参数不是随便设的，比如batch_size的数值取决于你电脑内存的大小，内存越大，batch_size就可以设为大一点。又比如norm_size（图片归一化尺寸）是根据你得到的数据集，经过分析后得出的，因为我们这个数据集大多数图片的尺度都在这个范围内，所以我觉得32这个尺寸应该比较合适，但是不是最合适呢？那还是要通过实验才知道的，也许64的效果更好呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# initialize the number of epochs to train for, initial learning rate,
# and batch size
EPOCHS = 35
INIT_LR = 1e-3
BS = 32
CLASS_NUM = 62
norm_size = 32&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;载入数据&quot;&gt;载入数据&lt;/h3&gt;
&lt;p&gt;接下来我们需要读入图片和对应标签信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def load_data(path):
    print(&quot;[INFO] loading images...&quot;)
    data = []
    labels = []
    # grab the image paths and randomly shuffle them
    imagePaths = sorted(list(paths.list_images(path)))
    random.seed(42)
    random.shuffle(imagePaths)
    # loop over the input images
    for imagePath in imagePaths:
        # load the image, pre-process it, and store it in the data list
        image = cv2.imread(imagePath)
        image = cv2.resize(image, (norm_size, norm_size))
        image = img_to_array(image)
        data.append(image)

        # extract the class label from the image path and update the
        # labels list
        label = int(imagePath.split(os.path.sep)[-2])       
        labels.append(label)
    
    # scale the raw pixel intensities to the range [0, 1]
    data = np.array(data, dtype=&quot;float&quot;) / 255.0
    labels = np.array(labels)

    # convert the labels from integers to vectors
    labels = to_categorical(labels, num_classes=CLASS_NUM)                         
    return data,labels&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数返回的是图片和其对应的标签。&lt;/p&gt;
&lt;h3 id=&quot;训练&quot;&gt;训练&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def train(aug,trainX,trainY,testX,testY,args):
    # initialize the model
    print(&quot;[INFO] compiling model...&quot;)
    model = LeNet.build(width=norm_size, height=norm_size, depth=3, classes=CLASS_NUM)
    opt = Adam(lr=INIT_LR, decay=INIT_LR / EPOCHS)
    model.compile(loss=&quot;categorical_crossentropy&quot;, optimizer=opt,
        metrics=[&quot;accuracy&quot;])

    # train the network
    print(&quot;[INFO] training network...&quot;)
    H = model.fit_generator(aug.flow(trainX, trainY, batch_size=BS),
        validation_data=(testX, testY), steps_per_epoch=len(trainX) // BS,
        epochs=EPOCHS, verbose=1)

    # save the model to disk
    print(&quot;[INFO] serializing network...&quot;)
    model.save(args[&quot;model&quot;])
    
    # plot the training loss and accuracy
    plt.style.use(&quot;ggplot&quot;)
    plt.figure()
    N = EPOCHS
    plt.plot(np.arange(0, N), H.history[&quot;loss&quot;], label=&quot;train_loss&quot;)
    plt.plot(np.arange(0, N), H.history[&quot;val_loss&quot;], label=&quot;val_loss&quot;)
    plt.plot(np.arange(0, N), H.history[&quot;acc&quot;], label=&quot;train_acc&quot;)
    plt.plot(np.arange(0, N), H.history[&quot;val_acc&quot;], label=&quot;val_acc&quot;)
    plt.title(&quot;Training Loss and Accuracy on traffic-sign classifier&quot;)
    plt.xlabel(&quot;Epoch #&quot;)
    plt.ylabel(&quot;Loss/Accuracy&quot;)
    plt.legend(loc=&quot;lower left&quot;)
    plt.savefig(args[&quot;plot&quot;])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里我们使用了Adam优化器，由于这个任务是一个多分类问题，可以使用类别交叉熵（categorical_crossentropy）。但如果执行的分类任务仅有两类，那损失函数应更换为二进制交叉熵损失函数（binary cross-entropy）&lt;/p&gt;
&lt;h3 id=&quot;主函数&quot;&gt;主函数&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;
#python train.py --dataset_train ../../traffic-sign/train --dataset_test ../../traffic-sign/test --model traffic_sign.model
if __name__=='__main__':
    args = args_parse()
    train_file_path = args[&quot;dataset_train&quot;]
    test_file_path = args[&quot;dataset_test&quot;]
    trainX,trainY = load_data(train_file_path)
    testX,testY = load_data(test_file_path)
    # construct the image generator for data augmentation
    aug = ImageDataGenerator(rotation_range=30, width_shift_range=0.1,
        height_shift_range=0.1, shear_range=0.2, zoom_range=0.2,
        horizontal_flip=True, fill_mode=&quot;nearest&quot;)
    train(aug,trainX,trainY,testX,testY,args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在正式训练之前我们还使用了数据增广技术（ImageDataGenerator）来对我们的小数据集进行数据增强（对数据集图像进行随机旋转、移动、翻转、剪切等），以加强模型的泛化能力。&lt;/p&gt;
&lt;p&gt;训练代码已经写好了，接下来开始训练（图片归一化尺寸为32，batch_size为32，epoches为35）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python train.py --dataset_train ../../traffic-sign/train --dataset_test ../../traffic-sign/test --model traffic_sign.model&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;训练过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120629639-884652553.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Loss和Accuracy:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120638905-700184140.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从训练效果看来，准确率在94%左右，效果不错了。&lt;/p&gt;
&lt;h3 id=&quot;预测单张图片&quot;&gt;预测单张图片&lt;/h3&gt;
&lt;p&gt;现在我们已经得到了我们训练好的模型traffic_sign.model，然后我们编写一个专门用于预测的脚本predict.py。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# import the necessary packages
from keras.preprocessing.image import img_to_array
from keras.models import load_model
import numpy as np
import argparse
import imutils
import cv2

norm_size = 32

def args_parse():
# construct the argument parse and parse the arguments
    ap = argparse.ArgumentParser()
    ap.add_argument(&quot;-m&quot;, &quot;--model&quot;, required=True,
        help=&quot;path to trained model model&quot;)
    ap.add_argument(&quot;-i&quot;, &quot;--image&quot;, required=True,
        help=&quot;path to input image&quot;)
    ap.add_argument(&quot;-s&quot;, &quot;--show&quot;, action=&quot;store_true&quot;,
        help=&quot;show predict image&quot;,default=False)
    args = vars(ap.parse_args())    
    return args

    
def predict(args):
    # load the trained convolutional neural network
    print(&quot;[INFO] loading network...&quot;)
    model = load_model(args[&quot;model&quot;])
    
    #load the image
    image = cv2.imread(args[&quot;image&quot;])
    orig = image.copy()
     
    # pre-process the image for classification
    image = cv2.resize(image, (norm_size, norm_size))
    image = image.astype(&quot;float&quot;) / 255.0
    image = img_to_array(image)
    image = np.expand_dims(image, axis=0)
     
    # classify the input image
    result = model.predict(image)[0]
    #print (result.shape)
    proba = np.max(result)
    label = str(np.where(result==proba)[0])
    label = &quot;{}: {:.2f}%&quot;.format(label, proba * 100)
    print(label)
    
    if args['show']:   
        # draw the label on the image
        output = imutils.resize(orig, width=400)
        cv2.putText(output, label, (10, 25),cv2.FONT_HERSHEY_SIMPLEX,
            0.7, (0, 255, 0), 2)       
        # show the output image
        cv2.imshow(&quot;Output&quot;, output)
        cv2.waitKey(0)


#python predict.py --model traffic_sign.model -i ../2.png -s
if __name__ == '__main__':
    args = args_parse()
    predict(args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;预测脚本中的代码编写思路是：参数解析器-》载入训练好的模型-》读入图片信息-》预测-》展示预测效果。值得注意的是，参数-s是用于可视化结果的，加上他的话我们就可以看出我们输入的图片以及模型预测的分类结果，很直观。如果只需要得到分类结果，不加-s就可以了。&lt;/p&gt;
&lt;p&gt;单张图片的预测：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python predict.py --model traffic_sign.model -i ../2.png -s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120702280-594870590.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120711561-754597342.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，交通分类任务完成。&lt;/p&gt;
&lt;p&gt;这里分享一下这个项目的数据集来源：&lt;br/&gt;你可以点击&lt;a href=&quot;http://btsd.ethz.ch/shareddata/&quot;&gt;这里&lt;/a&gt;下载数据集。在下载页面上面有很多的数据集，但是你只需要下载 BelgiumTS for Classification (cropped images) 目录下面的两个文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BelgiumTSC_Training (171.3MBytes)&lt;/li&gt;
&lt;li&gt;BelgiumTSC_Testing (76.5MBytes)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得注意的是，原始数据集的图片格式是ppm，这是一种很老的图片保存格式，很多的工具都已经不支持它了。这也就意味着，我们不能很方便的查看这些文件夹里面的图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120723639-890227013.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我用opencv重新将这些图片转换为png格式，这样子我们就能很直观地看到数据图片了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120734061-642796775.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转换脚本在&lt;a href=&quot;https://github.com/AstarLight/Keras-image-classifer-framework/blob/master/traffic-sign-code/ppm2png.py&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时我也把转换好的数据集传到&lt;a href=&quot;https://pan.baidu.com/s/1o8uZ9k2&quot;&gt;百度云&lt;/a&gt;了，不想自己亲自转换的童鞋可以自行获取。&lt;/p&gt;
&lt;h2 id=&quot;二票据分类&quot;&gt;二、票据分类&lt;/h2&gt;
&lt;p&gt;先分析任务和观察数据。我们这次的分类任务是票据分类，现在我们手头上的票据种类一共有14种，我们的任务就是训练一个模型将他们一一分类。先看看票据的图像吧。&lt;/p&gt;
&lt;p&gt;票据种类一共14种，其图片名字就是其label。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120749186-1148954885.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;票据是以下面所示的文件夹排布存储的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120759108-1607799868.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们再看一下每类图片数据的情况，看一下可利用的数据有多少。&lt;/p&gt;
&lt;p&gt;有的票据数据比较少，也就十来张&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120807921-1174222267.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有的票据比较多，有上百张&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120816264-1870149615.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的数据分布直接拿去去训练的话，效果可能不会太好（这就是不平衡问题），但是这是后期模型调优时才需要考虑的问题，现在先放一边。那我们继续使用上面的图片分类框架完成本次的票据分类任务。&lt;/p&gt;
&lt;p&gt;这次的数据集的存储方式与交通标志分类任务的数据存储不太一样，这个数据集没有把数据分成train和test两个文件夹，所以我们在代码中读取数据时写的函数应作出相应修改：我们先读取所有图片，再借助sklearn的“train_test_split”函数将数据集以一定比例分为训练集和测试集。&lt;/p&gt;
&lt;p&gt;我写了个load_data2()函数来适应这种数据存储。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def load_data2(path):
    print(&quot;[INFO] loading images...&quot;)
    data = []
    labels = []
    # grab the image paths and randomly shuffle them
    imagePaths = sorted(list(paths.list_images(path)))
    random.seed(42)
    random.shuffle(imagePaths)
    # loop over the input images
    for imagePath in imagePaths:
        # load the image, pre-process it, and store it in the data list
        image = cv2.imread(imagePath)
        image = cv2.resize(image, (norm_size, norm_size))
        image = img_to_array(image)
        data.append(image)

        # extract the class label from the image path and update the
        # labels list
        label = int(imagePath.split(os.path.sep)[-2])       
        labels.append(label)  
        
    # scale the raw pixel intensities to the range [0, 1]
    data = np.array(data, dtype=&quot;float&quot;) / 255.0
    labels = np.array(labels)


    # partition the data into training and testing splits using 75% of
    # the data for training and the remaining 25% for testing
    (trainX, testX, trainY, testY) = train_test_split(data,
            labels, test_size=0.25, random_state=42)

    # convert the labels from integers to vectors
    trainY = to_categorical(trainY, num_classes=CLASS_NUM)
    testY = to_categorical(testY, num_classes=CLASS_NUM)   
    return trainX,trainY,testX,testY&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们使用了sklearn中的神器train_test_split做了数据集的切分，非常方便。可以看出，load_data2()的返回值就是训练集图片和标注+测试集图片和标注。&lt;/p&gt;
&lt;p&gt;在主函数也只需做些许修改就可以完成本次票据分类任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if __name__=='__main__':
    args = args_parse()
    file_path = args[&quot;dataset&quot;]
    trainX,trainY,testX,testY = load_data2(file_path)
    # construct the image generator for data augmentation
    aug = ImageDataGenerator(rotation_range=30, width_shift_range=0.1,
        height_shift_range=0.1, shear_range=0.2, zoom_range=0.2,
        horizontal_flip=True, fill_mode=&quot;nearest&quot;)
    train(aug,trainX,trainY,testX,testY,args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后设定一些参数，比如图片归一化尺寸为64*64，训练35个epoches。设定完参数后我们开始训练。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python train.py --dataset ../../invoice_all/train  --model invoice.model&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;训练的过程不算久，大概十来分钟。训练过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120833827-2009591811.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绘制出Loss和Accuracy曲线，可以看出，我们训练后的模型的准确率可以达到97%。直接使用一个LeNet网络就可以跑出这个准确率还是让人很开心的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120848483-930050503.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后再用训练好的模型预测单张票据，看看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120858139-169279696.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201712/1093303-20171217120909093-777549037.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;预测正确，deep learning 票据分类任务完成！&lt;/p&gt;
&lt;h2 id=&quot;三总结&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;我们使用了Keras搭建了一个基于LeNet的图片分类器的通用框架，并用它成功完成两个实际的分类任务。最后再说说我们现有的模型的一些改进的地方吧。第一，图片归一化的尺寸是否合适？比如票据分类任务中，图片归一化为64，可能这个尺寸有点小，如果把尺寸改为128或256，效果可能会更好；第二，可以考虑更深的网络，比如VGG,GoogLeNet等；第三，数据增强部分还可以再做一做。&lt;/p&gt;
&lt;p&gt;完整代码和测试图片可以在&lt;a href=&quot;https://github.com/AstarLight/Keras-image-classifer-framework&quot;&gt;我的github&lt;/a&gt;上获取。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pyimagesearch.com/2017/12/11/image-classification-with-keras-and-deep-learning/&quot; class=&quot;uri&quot;&gt;https://www.pyimagesearch.com/2017/12/11/image-classification-with-keras-and-deep-learning/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/3c7f329b29ee&quot; class=&quot;uri&quot;&gt;http://www.jianshu.com/p/3c7f329b29ee&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 04:10:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/8051705.html</dc:identifier>
</item>
<item>
<title>while(true)应用 之 实现自己的消息队列 - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/8051618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/8051618.html</guid>
<description>&lt;p&gt;　　早些时候，一直有个疑问，就是比如你从前端发一个操作之后，后台为什么能够及时处理你的东西呢？当然了，我说的不是，服务器为什么能够立即接收到你的请求之类高大上的东西。而是，假设你用异步去做一个事情，而后台有一个处理程序在处理你的申请，你的目的自然是不想让操作阻塞，所以处理肯定是处理程序主动触发的过程。那么怎样做能够让其能够及时处理问题呢？ 确实也困惑了我许久。（我相信也有不少同学会有类似疑问）&lt;/p&gt;
&lt;p&gt;　　所以我觉得有必要解解惑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　需求示例1： 用户请求某操作时，需要与此同时给用户发个邮件，但是这个邮件可能会很耗时，在不使用异步线程的情况下（事实上不是所有的语言都支持多线程），怎么样让用户得到快速响应，且邮件稍后即可送达？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　需求示例2：在高并发情况下，需要对某数据进行减操作（比如商品库存，如果超出了库存值，则将无货可发），怎样保证用户先到先得，后到就没有？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　针对这两个问题，解决办法自然是多的。但是本文只说一个思路，那就是主题，消息队列！&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;当需要给用户发送邮件时，只需将该请求发送到后台进程中，后台进程进行逐个发送即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　当大量用户进来抢商品时，将该请求放入队列中，后台进程逐个相减，减到0时，后续用户将提示抢不到了。（当然，这有很多后续问题要处理，也看起来不一定是个好方案，但并不影响咱们发挥）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　看起来，前面的解决方案很合理。但是，具体怎么样做呢？前台申请，与后台处理之间，总得有个什么东西联系起来吧。没错，就是消息队列了。消息队列自然需要消息中间件，简单的，咱们就使用redis做中间件吧，简单快速搞得定。&lt;/p&gt;
&lt;p&gt;　　具体实施方案就是：&lt;strong&gt;1. 各处的用户进行相应的操作请求，然后顺便将消息写入redis，（以list形式写入，天然的队列）； 2. 后台进程依次从redis中读取消息，进行相应数据处理（注意如何依次处理是关键）。 3. 将结果通知给用户或者不通知。（本处将不通知）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　示例代码如下（php实现）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; send 请求方，写入消息&lt;/span&gt;
&lt;span&gt;$redis&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Redis();
&lt;/span&gt;&lt;span&gt;$redis&lt;/span&gt;-&amp;gt;connect(&quot;127.0.0.1&quot;, &quot;6379&quot;, 3&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;$msgKey&lt;/span&gt; = &quot;my.test.msgKey&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$value&lt;/span&gt; = &quot;hello,world.&quot; . &lt;span&gt;rand&lt;/span&gt;(0, 99999999&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;$redis&lt;/span&gt;-&amp;gt;lPush(&lt;span&gt;$msgKey&lt;/span&gt;, &lt;span&gt;$value&lt;/span&gt;);           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将请求送入队列中，等后台消费&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; &quot;lPush {&lt;span&gt;$msgKey&lt;/span&gt;} -&amp;gt; {&lt;span&gt;$value&lt;/span&gt;}&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　后台进程进行依次处理，一般来说有两个方案： &lt;strong&gt;1. 通过系统进行定时调度，每次调度，则执行一段消息处理（此种方案的缺点明显，需依赖系统处理，且将会是不及时的）； 2. 通过自身调度，使自己一直处理运行中状态，当发现有新消息到来时，立即进行处理（本处讨论的是此种方案）&lt;/strong&gt;。处理代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; recieve 处理程序&lt;/span&gt;
&lt;span&gt;$redis&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Redis();
&lt;/span&gt;&lt;span&gt;$redis&lt;/span&gt;-&amp;gt;connect(&quot;127.0.0.1&quot;, &quot;6379&quot;, 3&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;$msgKey&lt;/span&gt; = &quot;my.test.msgKey&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;$stackTop&lt;/span&gt; = &lt;span&gt;$redis&lt;/span&gt;-&amp;gt;rPop(&lt;span&gt;$msgKey&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$stackTop&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do sth useful&lt;/span&gt;
        &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$stackTop&lt;/span&gt; . &quot;\r\n&quot;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;usleep&lt;/span&gt;(200000);         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有消息需要处理，则睡眠0.2秒等待&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　写好后，只要在命令行将该脚本跑起来即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
php  recieve.php &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实原理很简单，就是一个while死循环，然后一直在查询 消息状态，有就处理，没有就稍微等一下再查。&lt;/p&gt;
&lt;p&gt;　　如果启动多个后台程序，那么，就相当于有多个消费者了，从而加快了处理速度。（生产者 -&amp;gt; 消费者 简单模型）&lt;/p&gt;
&lt;p&gt;　　那么，问题在哪里？为什么刚开始的时候没想到这样处理呢？&lt;/p&gt;
&lt;p&gt;　　我有两个疑问：&lt;/p&gt;
&lt;p&gt;　　　　 &lt;strong&gt;1. 用户while死循环不会导致死机吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　 2. 我想修改代码里的东西，怎样才能生效？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　针对第一个问题，&lt;strong&gt;如果是没有 sleep 限制的话，机器是有可能死机的。在调用 sleep后，cpu会转到其他进程上进行事务处理，从而不会有问题。&lt;/strong&gt;sleep时间过长，则会有明显的时间停顿现象，即用户操作无法得到及时响应。sleep时间过短，则会导致cpu占用过高，从而引发其他一系列问题。因此设置一个合适的sleep时间是有必要的。本处设置的0.2秒，经查看cpu状态，占用为0%，所以没问题。而且0.2秒在用户看来，是没有什么影响的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/830731/201712/830731-20171217110150139-1280509793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第二个问题，修改了代码，如何生效？重启就好了嘛。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ps&lt;/span&gt; -ef | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; php      # 找出运行代码的pid
&lt;/span&gt;&lt;span&gt;kill&lt;/span&gt; -&lt;span&gt;9&lt;/span&gt; &lt;span&gt;123&lt;/span&gt;&lt;span&gt;            # 将进程kill掉
php recieve.php        # 重新运行代码即可&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过该种自身轮询的方式，从而达到了及时处理任务的方式。 &lt;/p&gt;
&lt;p&gt;　　死循环广泛应用于各服务中，只是我们都没发现。&lt;/p&gt;
&lt;p&gt;　　这也换一个现实的问题角度理解，只有自己一直活着，才有可能服务于别人。&lt;/p&gt;
&lt;p&gt;　　那么，假如每个程序跑起来后，都一直存活着，CPU不就完蛋了？ 是的，这就是计算机所能运行的服务有限的原因。CPU可以调度各进程的执行，当然进程数是有限的，只要在这有限有量以内，提供几个死循环还是可以的。（注意，死循环是保持自身活跃的一种方式，但并非所有的服务都是靠死循环来保持自身的活跃的）&lt;/p&gt;
&lt;p&gt;　　信号量？是一种有效地处理本机通知的一种机制，且听下回分解。&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 03:32:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yougewe/p/8051618.html</dc:identifier>
</item>
<item>
<title>小随笔：利用Shader实现模型爆炸和沙粒化的效果 - 慕容小匹夫</title>
<link>http://www.cnblogs.com/murongxiaopifu/p/7965962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/murongxiaopifu/p/7965962.html</guid>
<description>&lt;h2 id=&quot;x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;上一篇小随笔&lt;a href=&quot;http://www.cnblogs.com/murongxiaopifu/p/7887614.html&quot;&gt;《小随笔：利用Shader给斯坦福兔子长毛和实现雪地效果》&lt;/a&gt;中，我和大家聊了聊著名的斯坦福兔子和利用geometry shader实现的一些效果。这篇文章继续沿用了同样来自斯坦福的另一个模型Armadillo，同样也使用了geometry shader来实现效果的表现。&lt;/p&gt;
&lt;h2 id=&quot;x01-凶恶的怪物和爆炸&quot;&gt;0x01 凶恶的怪物和爆炸&lt;/h2&gt;
&lt;p&gt;当然，用之前的斯坦福兔子的模型做爆炸的效果也是可以的，但是考虑到要让一个那么可爱的模型变成沙砾总觉得不太好，所以长相自带怪物属性的模型Armadillo就成了一个不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686199/201712/686199-20171203162949460-270366175.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过另一个让我选择Armadillo的原因其实是因为它的面数和顶点数相对来说更多，可以看到它有106289个顶点和212574个多边形组成，所以用来做爆炸成为沙砾的效果要更好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686199/201712/686199-20171203163002882-2124446216.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ok，现在让我们把Armadillo的obj文件导入到Unity内，可以看到这个怪物已经站立在我们的场景内了。接下来我们就要利用geometry shader来实现我们想要的爆炸沙粒化的效果了。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686199/201712/686199-20171203163031007-96640713.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前提到Geometry Shader的时候，往往是利用它来生成更多新的顶点和多边形来实现我们期望的效果，例如利用它在GPU上生成草体，实现真实草的实时渲染。&lt;br/&gt;但是Geometry Shader不仅可以生成新的图元，同时它还可以减少顶点和多边形的输出，以实现一些有趣的效果，比如这篇小文章的例子，利用Geometry Shader来实现怪兽的爆炸和沙粒化效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686199/201712/686199-20171203163100913-2026885005.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而我们要做的也很简单，就是在Geometry Shader内将输入的由3个顶点组成的三角形图元修改为只有一个顶点组成的点图元。而输出的这个点的坐标我们可以很简单的使用三角形的中心点坐标。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            float3 tempPos = (IN[0].vertex + IN[1].vertex + IN[2].vertex) / 3;
            o.vertex = UnityObjectToClipPos(tempPos);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，组成怪兽的网格就由三角形图元变成了点图元，而且顶点数量也随之减少，至于怪物本身也变成了下面这个样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686199/201712/686199-20171203163117319-1234934428.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是这个时候的模型是静止的，因此也看不出爆炸甚至是沙砾的效果。所以接下来我们就要让怪物的模型随着时间运动起来。&lt;br/&gt;而一个大家都知道的运动学公式就可以用来实现这个效果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686199/201712/686199-20171203163141179-491744471.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的S就是顶点的最新位置，v0和a的值可以作为一个uniform变量传入shader，运动方向可以是沿着三角形的法线方向，而t的来源则是Unity内置的变量_Time的y分量。&lt;br/&gt;这样，需要的几个变量我们就有了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            //速度的值加速度的值
            float _Speed;
            float _AccelerationValue;
            float _StartTime

            //法线
            float3 v1 = IN[1].vertex - IN[0].vertex;
            float3 v2 = IN[2].vertex - IN[0].vertex;
            float3 norm = normalize(cross(v1, v2));
            ...
            //时间
            float realTime = _Time.y - _StartTime;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后只要带入运动学公式就好了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            tempPos += norm * (_Speed * realTime + .5 * _AccelerationValue * pow(realTime, 2));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后的效果就变成了这样：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/686199/201712/686199-20171203163200272-1602021093.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Demo地址：&lt;a href=&quot;https://github.com/chenjd/Unity-Miscellaneous-Shaders&quot;&gt;chenjd/Unity-Miscellaneous-Shaders&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;x02-后记&quot;&gt;0x02 后记&lt;/h2&gt;
&lt;p&gt;ok，以上就是我这周的小随笔。希望大家能有所收获。哦，对了，我用的obj文件各位可以到这里下载：&lt;a href=&quot;http://www.prinmath.com/csci5229/OBJ/index.html&quot; class=&quot;uri&quot;&gt;http://www.prinmath.com/csci5229/OBJ/index.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;br/&gt;最后打个广告，欢迎支持我的书&lt;a href=&quot;https://item.jd.com/12035114.html&quot;&gt;《Unity 3D脚本编程》&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1372105-49722d71ab6308d4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎大家关注我的公众号慕容的游戏编程：chenjd01&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1372105-3fde40ffd9897a75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 03:00:00 +0000</pubDate>
<dc:creator>慕容小匹夫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/murongxiaopifu/p/7965962.html</dc:identifier>
</item>
<item>
<title>Java VS .NET：Java与.NET的特点对比 - ken-io</title>
<link>http://www.cnblogs.com/ken-io/p/java-vs-dotnet.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ken-io/p/java-vs-dotnet.html</guid>
<description>&lt;div readability=&quot;90.555678517084&quot;&gt;
&lt;h4 id=&quot;h4--&quot;&gt;一、前言&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为什么要写Java跟.NET对比？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;.NET出生之后就带着Java的影子。从模仿到创新，.NET平台也越来越成熟。他们不同的支持者也经常因为孰弱孰强的问题争论不休。但是本文并不是为了一分高下。而是针对Java平台跟.NET平台做一些对比。主要围绕项目构建、Web框架、项目部署展开讨论。相信经过这些讨论可以让Java/.NET工程师对Java平台、.NET平台有更好的了解。&lt;/p&gt;
&lt;h4 id=&quot;h4--&quot;/&gt;
&lt;ul&gt;&lt;li&gt;项目构建工具&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;工欲善其事必先利其器。开发环境配置+工具使用当然要先讲了。&lt;/p&gt;
&lt;p&gt;1、表面上的工具&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;平台&lt;/th&gt;
&lt;th&gt;工具&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;http://ken.io/&quot; target=&quot;_blank&quot;&gt;ken.io&lt;/a&gt;的解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;.NET&lt;/td&gt;
&lt;td&gt;Visual Studio&lt;/td&gt;
&lt;td&gt;微软官方IDE，它具备了开发.NET应用程序的几乎所有工具&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;Idea/Eclipse&lt;/td&gt;
&lt;td&gt;IDE，负责管理项目以及代码的运行调试等，依赖于JDK&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;Maven&lt;/td&gt;
&lt;td&gt;负责管理项目模板、打包(jar包等)，依赖于JDK&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;JDK&lt;/td&gt;
&lt;td&gt;JRE（Java项目运行环境），Java工具（编译器等）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;.NET工程师要开展工作，安装Visual Studio（后面简称：VS）就可以进行开发了。但是Java开发，只安装IDE是不行的，就算某些IDE会自动安装JDK，甚至是Maven，但是这些还是需要自己配置，不然还可能会踩坑。从开发环境的配置来说，.NET工程师操作上确实简单一些，一直下一步，等待安装完成即可。Java工程师就先要了解下工具，以及各个工具的职责。然后逐一配置。&lt;/p&gt;
&lt;p&gt;从这个点上来说，Java的入门曲线会稍陡一些，但是Java工程师也会比.NET工程师更早关注到项目构建的重要环节。&lt;/p&gt;
&lt;p&gt;2、实际上的工具&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;职责&lt;/th&gt;
&lt;th&gt;.NET平台&lt;/th&gt;
&lt;th&gt;Java平台&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;http://ken.io/&quot; target=&quot;_blank&quot;&gt;ken.io&lt;/a&gt;的解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;项目管理&lt;/td&gt;
&lt;td&gt;VS&lt;/td&gt;
&lt;td&gt;IDEA/Eclips&lt;/td&gt;
&lt;td&gt;.NET只有微软官方IDE，Java没有官方的IDE，没有VS好用，但是有多个选择&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;项目模板&lt;/td&gt;
&lt;td&gt;VS+MSBuild&lt;/td&gt;
&lt;td&gt;IDE+Maven&lt;/td&gt;
&lt;td&gt;.NET项目的模板是VS自带的，是直接符合MSBuild（编译器）标准的，项目由sln+csproj文件组织，Java平台编译器的标准是公开的，目前主流项目都是基于Maven模板来创建，项目由pom.xml文件组织。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;编译&amp;amp;调试&lt;/td&gt;
&lt;td&gt;VS+MSBuild+SDK&lt;/td&gt;
&lt;td&gt;IDE+Maven+SDK&lt;/td&gt;
&lt;td&gt;.NET平台的编译器是独立的，Java平台的编译器是集成在JDK中，Maven模板的项目是由pom.xml文件组织，但是编译器并不是认识pom.xml，所以编译需要Maven的参与&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Package管理&lt;/td&gt;
&lt;td&gt;NuGet&lt;/td&gt;
&lt;td&gt;Maven&lt;/td&gt;
&lt;td&gt;Nuget是微软官方开源的VS插件，Maven是Apache下的开源项目。ken.io觉得Maven更灵活、强大。NuGet容易上手。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;打包/发布&lt;/td&gt;
&lt;td&gt;VS+MSBuild+SDK&lt;/td&gt;
&lt;td&gt;IDE+Maven+SDK&lt;/td&gt;
&lt;td&gt;.NET平台的编译器是独立的，Java平台的编译器是集成在JDK中，Maven模板的项目是由pom.xml文件组织的，但是编译器并不是认识pom.xml，所以打包需要Maven的参与。IDE主要是提供图形化界面替代命令操作&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从项目管理上说。VS这个IDE更好用一些，项目模板上，.NET项目模板简单易用，Java平台的Maven模板灵活强大。&lt;/p&gt;
&lt;p&gt;其实大部分差异都是编译器跟模板带来的差异。.NET平台的编译器虽然是独立的，但是编译器要求是必须用.sln文件+csproj文件组织项目。并且官方提供了丰富好用的项目模板，虽然内容格式也是xml，但是没有那么灵活。&lt;/p&gt;
&lt;p&gt;Java平台的编译器的编译配置是xml文档，由于Java官方没有项目模板，IDE只负责帮你组织项目，但是并没有模板，你可以将任意目录指定为SourceRoot（代码根目录），ResourceRoot（资源文件根目录：比如配置文件）也可以任意指定，编译的时候，IDE会将你的项目代码，以及编译器所需要的编译描述/配置xml文档告诉编译器该如何编译你的项目。确实非常灵活，但是也增加了项目管理的成本。包的管理也非常麻烦，还好有Maven结束了这个混沌的Java世界。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编码特点&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;—&lt;/th&gt;
&lt;th&gt;.NET&lt;/th&gt;
&lt;th&gt;Java&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;类的组织&lt;/td&gt;
&lt;td&gt;namespace：命名空间，name跟目录无关&lt;/td&gt;
&lt;td&gt;Package：name跟目录名一致&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;类&lt;/td&gt;
&lt;td&gt;.cs文件：类名跟文件名无关&lt;/td&gt;
&lt;td&gt;.java文件，类名跟文件名无关，但一个类文件只能定义一个public类&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;编译产出&lt;/td&gt;
&lt;td&gt;.dll，.exe文件&lt;/td&gt;
&lt;td&gt;.jar，.war文件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;h4--&quot;/&gt;
&lt;p&gt;.NET的Web框架基本上都是微软官方的，官方的框架也最为流行，而Java平台，除了官方提供的Servlet API（相当于.NET的System.Web）其他的基本都由&lt;a href=&quot;http://spring.io/&quot; target=&quot;_blank&quot;&gt;Spring大家族&lt;/a&gt;统治了。本次我们主要对比目前Web开发最常用的MVC框架以及持久层框架&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能&lt;/th&gt;
&lt;th&gt;.NET&lt;/th&gt;
&lt;th&gt;Java&lt;/th&gt;
&lt;th&gt;&lt;a href=&quot;http://ken.io/&quot; target=&quot;_blank&quot;&gt;ken.io&lt;/a&gt;的说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;Web核心&lt;/td&gt;
&lt;td&gt;ASP.NET&lt;/td&gt;
&lt;td&gt;Servlet&lt;/td&gt;
&lt;td&gt;—&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Web框架&lt;/td&gt;
&lt;td&gt;ASP.NET MVC&lt;/td&gt;
&lt;td&gt;Spring MVC&lt;/td&gt;
&lt;td&gt;ASP.NET MVC是微软官方框架，Srping MVC框架隶属于Spring大家族，依赖于Spring&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;视图引擎&lt;/td&gt;
&lt;td&gt;Razor&lt;/td&gt;
&lt;td&gt;Thymeleaf/FreeMarker&lt;/td&gt;
&lt;td&gt;Razor是微软官方的视图引擎，非常好用，Spring MVC并没有视图引擎，但是有Thymeleaf，FreeMarker。ken.io更喜欢Razor的风格&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;持久层&lt;/td&gt;
&lt;td&gt;Entity Framework&lt;/td&gt;
&lt;td&gt;MyBatis&lt;/td&gt;
&lt;td&gt;EF是微软官方的持久层框架，易上手但侵入性强。MyBatis配置灵活，强大，无侵入性。这一点ken.io更喜欢MyBatis&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;.NET平台的框架由于都是微软官方的，比较好组织，上手容易。Java平台的框架，灵活可配置。这也是Java平台一贯的风格。但是ken.io不得不吐槽的是，Spring MVC作为一个MVC框架，竟然没有自己的视图引擎，那MVC种的View去哪了？&lt;br/&gt;可能是因为Java作为Web后端的主力平台，确实很少关注视图层，但是Spring MVC没有View层引擎，还是感觉不合适。Thymeleaf跟FreeMarker，&lt;a href=&quot;http://ken.io/&quot; target=&quot;_blank&quot;&gt;ken.io&lt;/a&gt;更推荐FreeMarker。因为&lt;a href=&quot;http://ken.io/&quot; target=&quot;_blank&quot;&gt;ken.io&lt;/a&gt;更喜欢FreeMaker的语法。可能是用惯了Razor的缘故。&lt;/p&gt;
&lt;h4 id=&quot;h4--&quot;/&gt;
&lt;p&gt;对于项目部署。.NET平台貌似没得选，只能选Windows+IIS，虽然有Mono，但毕竟不是支持所有的类库。而Java平台既可以选择Windows+Tomcat，也可以选择Linux+Tomcat。但是通常会选择Linux+Tomcat毕竟成本低。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;职责&lt;/th&gt;
&lt;th&gt;.NET&lt;/th&gt;
&lt;th&gt;Java&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;操作系统&lt;/td&gt;
&lt;td&gt;Windows Server&lt;/td&gt;
&lt;td&gt;Windows Server、Linux Server&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Web服务器&lt;/td&gt;
&lt;td&gt;IIS&lt;/td&gt;
&lt;td&gt;Tomcat（Tomcat是目前最主流的，也有其他的Servlet容易例如：JBoss）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;不过Java平台的特性，Java项目的部署会比.NET项目部署偏麻烦一些。&lt;br/&gt;IIS图形化界面一直下一步，再调整下应用程序池的版本就行了。而Tomcat不论是在Windows，还是在Linux，都通过修改配置文件完成站点配置。&lt;/p&gt;
&lt;h4 id=&quot;h4--&quot;/&gt;
&lt;p&gt;不管是Java平台还是.NET平台都有各自的优势。平台只是一个工具，我们了解平台都是为了做出更好的选择。但不得不说，Java开源生态的发展势头迅猛，非其他平台可比，不过.NET平台也在弥补自己的短板而推出了.NET Core。期望以后不论是Java还是.NET都能欣欣向荣。&lt;/p&gt;
&lt;p&gt;.NET程序猿，如果要学习Java，可以看看&lt;a href=&quot;http://ken.io/&quot; target=&quot;_blank&quot;&gt;ken.io&lt;/a&gt;写的教程&lt;/p&gt;
&lt;p&gt;Java快速入门系列教程：&lt;a href=&quot;https://ken.io/serie/java-quickstart&quot; target=&quot;_blank&quot;&gt;https://ken.io/serie/java-quickstart&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot入门教程：&lt;a href=&quot;https://ken.io/serie/springboot-course-basic&quot; target=&quot;_blank&quot;&gt;https://ken.io/serie/springboot-course-basic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;如果想一起交流技术可以访问连接扫码加入QQ群：&lt;a href=&quot;https://ken.io/home/about&quot; target=&quot;_blank&quot;&gt;https://ken.io/home/about&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文无意引战，这个在开篇的时候也做过说明。另外，本人.NET，.NET Core，Java均在使用，没有黑任何一个平台的意图。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果有朋友不同意本文的观点，欢迎评论交流，默默的点了反对，我也不知道您为什么反对，是吧？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div readability=&quot;27.648648648649&quot;&gt;
&lt;hr/&gt;&lt;p&gt;本文由 &lt;a href=&quot;https://ken.io/home/about&quot;&gt;ken.io&lt;/a&gt; 创作，采用&lt;a href=&quot;http://creativecommons.org/licenses/by/3.0/cn&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;CC BY 3.0 CN协议&lt;/a&gt; 进行许可。 可自由转载、引用、甚至修改，但需署名作者且注明出处。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 17 Dec 2017 02:53:00 +0000</pubDate>
<dc:creator>ken-io</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ken-io/p/java-vs-dotnet.html</dc:identifier>
</item>
<item>
<title>如何判断一个人的能力 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/8051447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/8051447.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/672506/201712/672506-20171217101155952-1531007459.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一个人的能力，源自于他的行事作风、处事习惯以及思考方式。想知道他的能力，就不能只是简单地考察他在某个具体任务上的完成情况，而是需要去了解他的习惯——做事习惯和思考习惯。&lt;/p&gt;
&lt;p&gt;从这个角度讲，很多公司的面试设计不太合理。生硬地抛出一堆智力题目，让候选人现场做解答，美其名曰考察候选人解答高难度问题的思考过程。但这样的设计，其实有很多弊端。&lt;/p&gt;
&lt;p&gt;首先，短时间地考察对困难问题的解答，会让候选人一下子卡壳。似乎这个过程考察更多的是抗压能力和刷题能力。而在现实工作中要解决的大问题，都不可能会在短短几个小时的时间内出成果。真正的大项目，往往需要耗时数月，甚至数年才能开花结果。&lt;/p&gt;
&lt;p&gt;其次，就算这个问题能够被快速解答，你所能考察到的部分也仅仅是候选人短时间的思辨能力。这就涉及到所谓的聪明与智慧的问题了。在古人看来，聪明并不等同于智慧，聪明只是浮灵，是昙花一现的局部最优。而智慧，需要更多的积淀和思考，是总揽全局的宏观最优决策。仅仅给候选人这么一点时间，如何去判断他的长线思考能力？如何考察他能够将一个问题挖掘多深？&lt;/p&gt;
&lt;p&gt;另外，如果这些智力难题的特点就是“不能够被一眼看出结果”，但又要求候选人在短时间做出正确解答，那么一个直接的应对方式便是预先的刷题，通过题海战术，希望将“待考察问题”纳入“已知答案”的范围之内。但现实中真正遇到的硬骨头问题，几乎都是未知的，甚至连这个问题本身的定义和提法都是模糊的。试问，这番考察筛选出来的是一批记忆已知问题解答方式的强人，还是解决未知问题的强人？&lt;/p&gt;
&lt;p&gt;要能够真正考察一个人的能力，就得回到开头说的那两个点：做事习惯和思考习惯。&lt;/p&gt;
&lt;p&gt;既然一个猛然间蹦出来的问题无法考察，那能不能换一个思路，从候选人熟悉的问题开始考察，甚至，你自己根本就不用去构思一个题目，让候选人自己去挑选一个题目，可不可以？&lt;/p&gt;
&lt;p&gt;在这样的提法下，立马会被反问到的是：如果题目本身都是候选人自己选择的，那还考察什么呢？自己设定的题目，回答自己知道的答案，这样的方式不是比作弊还流氓么？！&lt;/p&gt;
&lt;p&gt;我想，这可能是把上面那个方法想简单了。候选人自己选择的题目，或者更准确的说是候选人自己选择的一块最熟悉、最有把握的领域，只是作为一个媒介，它并不是考察的主菜。它是一个切口，通过它，可以望见你想看到的东西。&lt;/p&gt;
&lt;p&gt;在这样的视角下，反倒很考验面试官的能力。&lt;/p&gt;
&lt;p&gt;例如，当候选人选择了自己熟悉的一个项目，那么可以直接拓展的问题列表有：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;8&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;能否清晰地叙述出整个项目的流程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;问题的解决过程是怎样的？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为什么会想到这样去解决？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;有没有可以改进的地方？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;它对你的别的项目有没有启发？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;这个项目的需求提得是否合理？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果让你提需求，你会从何入手？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果让你重头再来，你会认为从哪里切入会更好？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你的作品这样设计的理由是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;它还存在的问题是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在更大的数据量的冲击下，你的产品是否依然能够承受？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些延拓出来的问题，才是主菜。考察候选人的做事风格和思维习惯：他是否具备一颗好奇而又锲而不舍的心，去将各个细节弄懂弄透。他又是否善于思考，是否具备出色的洞察力以至于他能够在生活的点滴中发现问题、发现机遇。&lt;/p&gt;
&lt;p&gt;小的问题更能够展现一个人的能力。因为能够从日常所见、从每个人的眼皮下溜过的平常小事中发现不同一般的东西，需要更多的洞见。而从本来就没有多少人了解的东西中做发现，不过是自欺欺人。因为你所做的，无非是“未知”中宣称发现了“未知”，这没什么了不起。真正困难且让人惊喜的，是在人人都看在眼里的“已知”中去发现“未知”。&lt;/p&gt;
&lt;p&gt;而要考察这种能力，当然就需要把考察的范围圈定在候选人熟悉的领域，或者平常的生活细节中。因为这个范围内，对于候选人来说就是所谓的“已知”。你需要进一步问的问题便是：在这个候选人熟悉的领域里，他是否提出了正确的问题，是否做了足够的思考，又是否在关节要害点，做过探索和改进。&lt;/p&gt;
&lt;p&gt;甚至，在生活中，面对那些熟悉的日常，是否有一种习惯和本能，&lt;strong&gt;不满足于只是接受现成的解决方案，而是有进一步的好奇心去做更多的探索，或者最起码，对这些现成解决方案提出了自己的问题&lt;/strong&gt;。例如，&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;移动运营商如何做到在网页或者App里面加入广告的？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PP助手如何做到不需要iPhone密码直接安装软件的？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;百度云盘、阿里巴巴等，如何保证某台电脑登录之后的记忆，不用再次验证的？是简单的Cookie存储么？如果是，能否有办法将这台电脑的认证拷贝到其它电脑上？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Gravatar是如何实现仅仅依靠邮箱就能够改变相应网站的账户头像的？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当我们在复制HTML的内容时，我们在复制什么？包含它相应的标记语言代码吗？为什么可以将一部分的效果复制走，而另一部分不行，差别是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;北欧出现（极昼极夜中的）极夜现象时，还有植被生存吗？不是没有阳光吗？如何光合作用？人、动物又吃什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;路标的反光效果不佳，是材料问题还是上面有一层灰？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为什么公众号的未公布文章搜索不到，必须要依靠关键字传播？其背后的机制是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;越是平常的东西，越是关乎一种习惯、一种几乎化为个人本能的固有模式。而这些固有的模式，决定了一个人的潜力。任何人都无法保证自己一定可以得到惊人的发现和不错的成果。但至少，一个人可以让自己具备一种良好的做事风格和思考方法。它们是孕育惊人成果的土壤。&lt;/p&gt;
&lt;p&gt;按照同样的思路，如果你要提高自己深层次的能力，不要去找一个新的项目开始。因为新项目的次要因素，如对环境的陌生、对规则的不熟悉，会浪费你大量的时间和精力。并且，你会因为这些时间与精力的耗费造成一种自以为进步了多少的错觉。&lt;/p&gt;
&lt;p&gt;要提高自己的硬实力，恰恰要从手头熟悉的东西开始做起。训练自己在熟悉的领域里，对“常见”去做改进、做思考。逼迫自己看到更深入的东西，而不是在表面浅尝辄止。要将一个平凡的项目，通过你的细心思考、探索和改进，把它变得不同凡响。&lt;/p&gt;
&lt;p&gt;从这个角度来看，所谓的聪明和智慧，其实是一种习惯。你是习惯于对问题大而化之，还是更习惯于对每一个细节都抱有高度的好奇心和责任感，时刻留心周围的问题，努力地提出自己的改进方案？&lt;/p&gt;
&lt;p&gt;所谓优秀的人在哪里都是优秀的，源自于他有一套运转良好的方法论、思考问题的方式。如果一个人善于学习、具备出色的洞察力，那么，并不是说非要在特殊领域才会突然“能力”附身。而是，这一习惯可以浸润在他生活的方方面面，不自觉地将他所在领域的事情做得更好。&lt;/p&gt;
&lt;p&gt;这些被内化为习惯的东西，才是一个人的根本，是他真正可以稳定输出的东西。因而才是你真正可以指望、依靠这个人的核心价值。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484076&amp;amp;idx=1&amp;amp;sn=ab1073241b614d34b3c63c62e0ae4eae&amp;amp;chksm=ec20e510db576c06bd7136d32e4f302bc3510eee4ec5b1c5f7e09b5b13e825648be1b48536ab&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;2017年11月写字总结&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484072&amp;amp;idx=1&amp;amp;sn=8e3a812f52d3b008ca75e8b345ee3650&amp;amp;chksm=ec20e514db576c02ec860bfc0bac3b52a1af4da271162fda9763a3eb5e00bb66dfb515e0d196&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;Edison Chen在纽约大学的演讲&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484068&amp;amp;idx=1&amp;amp;sn=16d2761120a71589dcfe01f9a40596b6&amp;amp;chksm=ec20e518db576c0e474cbe8cc2c3f31c196d5a65583293e61f3e1133826cfa5bde0ef5a92278&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;如何清除大脑中潜伏的进程&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxP3dF3128SFSX3d1ibNI3p3EtW7GlJMg16fpgoicNcmYuqgF8EOYccZqqMx1R82utgKOhkk4h3cQuhQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxP3dF3128SFSX3d1ibNI3p3EtW7GlJMg16fpgoicNcmYuqgF8EOYccZqqMx1R82utgKOhkk4h3cQuhQ/0?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;   &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;VIP赞赏专区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxP3dF3128SFSX3d1ibNI3p3EIoAxSR3bBfRrCkIkS08xiadWtS71JtPDryGfudo8Ve9BOpqgmMmWI9w/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; width=&quot;57%&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxP3dF3128SFSX3d1ibNI3p3EIoAxSR3bBfRrCkIkS08xiadWtS71JtPDryGfudo8Ve9BOpqgmMmWI9w/0?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1152&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 02:05:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/8051447.html</dc:identifier>
</item>
<item>
<title>Common Data Service (CDS) 初探 - 陈希章</title>
<link>http://www.cnblogs.com/chenxizhang/p/8051368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxizhang/p/8051368.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：陈希章 发表于 2017年12月16日&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Common Data Service（以下简称为CDS），通用数据服务是一个创新性的基础功能，这是微软试图打造一个全新的基于SaaS模式的数据服务平台，一方面整合Office 365和Dynamics 365的数据（虽然现在还没有做到），与此同时，支撑以PowerApps，Microsoft Flow，Power BI为核心的商业应用服务。下面这个图可以清晰地看出它们之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/businessplatformarc.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/businessplatformarc.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CDS最早是作为PowerApps的一部分进行开发的，所以到目前为止，CDS的管理界面都是集成在PowerApps中的，每个PowerApps的环境可以对应一个CDS数据库。&lt;/p&gt;
&lt;blockquote readability=&quot;3.3134328358209&quot;&gt;
&lt;p&gt;CDS正式GA的时间是2016年10月份。请参考当时的官方文档：&lt;a href=&quot;https://powerapps.microsoft.com/en-us/blog/powerapps-cds-ga/&quot;&gt;https://powerapps.microsoft.com/en-us/blog/powerapps-cds-ga/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-21-22-42.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-21-22-42.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了数据库，CDS还有几个主要概念，分别如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实体（Entity）&lt;/li&gt;
&lt;li&gt;关系（Relationship）&lt;/li&gt;
&lt;li&gt;选项值（Picklist）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;CDS定义了一套可以在不同的组织通用的实体，以及它们的关系。绝大部分情况下，你应该直接使用这些实体，而不需要创建自定义实体。&lt;/p&gt;

&lt;p&gt;要创建一个CDS数据库，你可以尝试登录 &lt;a href=&quot;https://preview.admin.powerapps.com/environments&quot;&gt;https://preview.admin.powerapps.com/environments&lt;/a&gt; ，先要创建一个Environment（环境）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-22-24-21.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-22-24-21.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;成功创建环境后，会提示你是否要创建数据库&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-22-25-51.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-22-25-51.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果选择创建，则可以设置权限，然后稍等片刻即可完成数据库的创建&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-22-26-30.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-22-26-30.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对于广大的Excel用户来说，还有一个好消息就是，CDS的数据支持在Excel中直接支持。这在需要批量更新数据的时候，可能更加有用。你需要做的是，定位到你要编辑的实体，然后点击“Open in excel”按钮&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-21-30-26.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-21-30-26.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载得到一个Excel文件，双击打开后，除了看到一个表格结构外，还会自动加载一个Office Add-in&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-21-27-15.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-21-27-15.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;按照提示，Trust this add-in，然后在下一界面中输入你的Office 365账号和密码登录后，稍等片刻即可刷新读取到所有这个实体的数据&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-21-33-20.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-21-33-20.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当选择某一列时，这个插件会自动检测到数据类型，如果是有选项值的话，还会自动列出来。这样的话，你可以在Excel中修改某个数据，然后点击“Publish”即可完成更新。&lt;/p&gt;

&lt;p&gt;除了Excel的集成，CDS还提供了一个与Outlook集成的工具，要启动该功能，需要在CDS的界面上点击“Productivity Settings”，然后按照提示下载一个清单文件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-21-45-47.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-21-45-47.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这将下载一个XML文件，其实是一个Outlook Add-in的清单文件（manifest）。接下来我们可以利用这个文件在Outlook中加载一个Add-in。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-21-48-14.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-21-48-14.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Outlook的主界面上，点击“Store”这个按钮&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-21-49-01.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-21-49-01.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Add-ins的界面，选择“Add from File...”&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-21-49-59.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-21-49-59.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选择Install&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-21-50-50.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-21-50-50.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个插件很有意思，你安装完之后，在Outlook主界面上面并看不到任何变化，它是对邮件窗口的一个扩展。目前我发现的功能是这样的：在任意一封邮件中，会多出来一个按钮“Common Data Service”的按钮，点击后，会展开一个面板，它会检测到这个邮件中涉及到联系人，然后去跟CDS中的Contact这个实体对比，如果不存在，则可以添加为Contact，如果存在，则会尝试查找该联系人相关的Case记录。例如下面这个例子&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-22-16-04.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-22-16-04.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;目前该插件是在Preview的阶段，仅开放极少数的实体整合，准确地说，只有Case这个实体可用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我在文章开始已经提到了CDS与PowerApps的渊源，应该说PowerApps是跟CDS结合得最好的一个应用。对于PowerApps来说，CDS是一种更加好的数据源，在实体之间定义的关系能被自动识别出来，并且生成对应的下拉框。&lt;/p&gt;
&lt;p&gt;Common Data Service是PowerApps中一个默认的连接器&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-22-44-27.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-22-44-27.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登录成功后，可以在实体列表中选择你希望在当前应用使用的实体&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-16-22-45-54.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-16-22-45-54.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击“Connect”后，接下来可以在界面上使用这些实体的数据，例如下面这个表单&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-17-08-21-16.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-17-08-21-16.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里特别提一下CDS的优势，我选中的这个字段叫CurrentContact，它的类型其实是一个复杂类型（Contact），透过CDS，PowerApps其实知道这是要读取另外一个实体的信息，所以它会自动生成一个下拉框，而且可以自由设定要显示这个实体里面的什么属性。&lt;/p&gt;
&lt;p&gt;至于更多的细节，这里就不展开了。如果大家对于PowerApps还不太熟悉，欢迎阅读下面两篇文章&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/powerapps.md&quot;&gt;PowerApps 入门篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/powerappsadv.md&quot;&gt;PowerApps 进阶篇&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来要谈一下的是在Microsoft Flow中如何跟CDS进行集成和交互。你可以将CDS理解为一种数据源，那么在Microsoft Flow中，一方面可以根据CDS的数据变化触发流程（例如新增了一个Case时进行触发），也可以在其他流程中，往CDS的实体中写入数据。下图可以看到跟Common data service相关的模板就有18个。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-17-08-27-32.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-17-08-27-32.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Common Data Service的触发器共有两个，可以监听新增记录和更新记录两个行为&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-17-08-29-35.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-17-08-29-35.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Common Data Service的操作共有九个&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-17-08-30-27.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-17-08-30-27.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于Microsoft Flow的细节，同样不是本文的重点，如果你还不太熟悉，欢迎阅读下面这篇文章&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/microsoftflow.md&quot;&gt;Microsoft Flow 概览&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们几乎可以断定，CDS将在日后的数据服务这个领域发挥重大作用，它整合Office 365和Dynamics 365的数据（虽然现在还没有做到），与此同时，支撑以PowerApps，Microsoft Flow，Power BI为核心的商业应用服务。有了这么多数据，接下来当然就是怎么利用它们，让它们发挥更大作用。这个时候，Power BI就是一个非常不错的选择。&lt;/p&gt;
&lt;p&gt;讨论Power BI的细节，很明显超出了本文的范围，不过，我此前也写好了相关的文章，请参考 &lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/powerbi.md&quot;&gt;观未见，行不止 —— Power BI 两周年技术和方案交流圆桌会议纪实&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;根据&lt;a href=&quot;https://powerapps.microsoft.com/en-us/blog/cdsconnectortopowerbi/&quot;&gt;二月份的官方说明&lt;/a&gt;，Common Data Service已经可以直接在Power BI中使用了，但目前只是Preview，而且仅限于美国用户才能使用。&lt;/p&gt;
&lt;p&gt;我在自己的Power BI Desktop中其实是能看到这方面的界面，但实际无法操作，可能还是需要等一段时间吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-17-08-38-47.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-17-08-38-47.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在数据源中搜索Common Data Service，然后点击下一步&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-17-08-39-33.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-17-08-39-33.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;选择对应的数据库之后，点击Ok，很不幸，目前为止，你可能也会收到下面这个类似的提示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-17-08-40-31.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-17-08-40-31.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我检查过Admin Center，确实没有发现下图提到的那个“Enable”按钮，这可能是导致我无法使用的原因吧，目前来说，我们能做的估计只有等了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-17-08-40-57.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-17-08-40-57.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作为一个开发人员，我很自然还会想到，Common Data Service是否有开放的接口，可以让我自己开发的应用程序可以与之交互呢？答案是肯定的，这部分功能目前也只是在前期的研发中，但我相信它将成为CDS成功的关健。&lt;/p&gt;
&lt;p&gt;下面这篇文章有基本的介绍，目前产品组提供了C# SDK的Sample，最好的情况是，他们正在跟Microsoft Graph团队合作，未来应该有望直接通过统一的接口就能访问到CDS，这真是太酷了！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/common-data-service/entity-reference/cds-sdk-get-started&quot;&gt;https://docs.microsoft.com/en-us/common-data-service/entity-reference/cds-sdk-get-started&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 17 Dec 2017 00:56:00 +0000</pubDate>
<dc:creator>陈希章</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxizhang/p/8051368.html</dc:identifier>
</item>
</channel>
</rss>