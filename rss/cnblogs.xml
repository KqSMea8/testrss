<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深度图像特征在推荐和广告中的应用（一） - daniel-D</title>
<link>http://www.cnblogs.com/daniel-D/p/8037977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daniel-D/p/8037977.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt; &lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;一直对图像有浓厚的兴趣，最近在关注：如何通过深度学习抽取图像特征，用于广告和推荐。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;CNN 是一个简单的网络结构，初学者一般从MNIST入手，提及CNN第一印象可能只有经典的图像分类的那个model。深入了解才会发现，学术圈和工业界是如何通过稍稍改变 Feature Map 之后的结构和目标函数等实现各种复杂任务，这其中迸发的想象力让人激动。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;“Image Feature Learning for Cold Start Problem in Display Advertising“ 这篇文章发表在ijcai15，是腾讯把图像特征应用到广告ctr预估的总结，同时也解答了广告中什么区域对点击率影响较大。这篇文章是较早把图像的深度特征用于点击率预估的工作之一，2015年的时候，推荐学术界里在深度学习方面起到重要影响的文章 Wide and Deep 、Youtube Rec with DNN 和一些 RNN 做推荐的方法尚未出现，高维稀疏特征的one hot encode embedding 成低维稠密特征的方法尚未被大众熟悉，所以这篇文章的做法并不是直接端到端的结构，而是通过CNN 抽取图像特征，然后用到 Logistic Regression（LR） 等常见的CTR模型中使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;下面进入广告时间，猜猜什么因素导致左边点击率高，文末有答案。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/533521/201712/533521-20171214151939748-1921012527.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;349&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/Users/dailiang/Documents/my_notes/pics/i_samples.png&quot;&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;文章主要想法分为两步，第一步，利用卷积神经网络，实现从原始像素到用户点击反馈的 end-to-end 的图像特征学习。第二步，训练好的CNN可以抽取与点击率相关的图像特征，外加广告属性的特征，这些特征综合起来训练LR等模型来预估最终点击率。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;抽取图像特征的网络结构如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/533521/201712/533521-20171214152026404-1454577970.png&quot; alt=&quot;&quot; width=&quot;632&quot; height=&quot;289&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/Users/dailiang/Documents/my_notes/pics/i_cnn1.png&quot;&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;100&lt;span&gt;*&lt;span&gt;100像素图像输入 =&amp;gt; 4层conv+pool =&amp;gt; 3层FC =&amp;gt; 二分类softmax（点击率）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;视觉元素的位置重要性&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;传统的图像分类只关心是否包含某个视觉元素，而不关心该视觉元素在图像中的位置。对于展示面积比较大的广告图片，因为用户的视觉焦点一般在图像中心，关键的视觉元素在图像中的位置对于点击率有明显影响，因此设计的卷积神经网络的最后一层卷积输出层的feature map应该稍大，以传递原图的位置信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;数据集&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;样本规模：470亿样本，样本来源于腾讯在线广告日志，包含5种类别，5 种展示位置。样本数据量太大，直接用CNN训练在时间上不可接受，因此作者吧相同的图片聚合一起，形成二维样本&amp;lt;未点击数，点击数&amp;gt;。文章没有提到的一点是，&lt;span class=&quot;md-tag&quot;&gt;&amp;lt;1000,10&amp;gt; &lt;span&gt;和 &lt;span class=&quot;md-tag&quot;&gt;&amp;lt;100, 1&amp;gt; &lt;span&gt;从统计上来说点击率相同，训练的时候有什么区别？我猜测对梯度应该有一定影响，样本数量越大，步长越长。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;数据增强：25万张广告图片，划分为22万张训练集和3.3万张测试集。训练集缩放裁剪到 128 &lt;span&gt;* &lt;span&gt;128像素大小，然后随机裁剪 100 &lt;span&gt;* &lt;span&gt;100 子图作为卷积网络的输入。测试集随机裁剪 10 次，用输出概率的平均值作为最后的预测结果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;单机GPU训练 2 天&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;实验结果&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;做了两种版本的比较，第一种只用图像特征，第二种包括广告id、类目id和展示位置id三个额外特征，分别用LR模型预测ctr，用AUC离线评测：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/533521/201712/533521-20171214152118498-2056921350.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;245&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;/Users/dailiang/Documents/my_notes/pics/i_p1_t1.png&quot;&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;什么影响点击率&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;用可视化方法，可以观察d奥图片&lt;span&gt;&lt;strong&gt;模特人脸区域和文字区域&lt;/strong&gt;&lt;span&gt;对点击率影响比较大：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/533521/201712/533521-20171214152157545-669792860.png&quot; alt=&quot;&quot; width=&quot;522&quot; height=&quot;343&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;附：公众号 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/533521/201711/533521-20171124120146937-461666382.jpg&quot; alt=&quot;&quot; width=&quot;130&quot; height=&quot;130&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 14 Dec 2017 07:28:00 +0000</pubDate>
<dc:creator>daniel-D</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daniel-D/p/8037977.html</dc:identifier>
</item>
<item>
<title>【数据结构】字典的诞生：有序数组 PK 无序链表 - 外婆的彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/8037856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/8037856.html</guid>
<description>&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《算法（java）》                           — — Robert Sedgewick， Kevin Wayne&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《数据结构》                                  — — 严蔚敏&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这篇文章主要介绍实现字典的两种方式&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;有序数组&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;无序链表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;（二叉树的实现方案将在下一篇文章介绍）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【注意】 &lt;span&gt;&lt;span&gt;为了让代码尽可能简单&lt;/span&gt;， 我将字典的Key和Value的值也设置为int类型，而不是对象， 所以在下面代码中， 处理“操作失败”的情况的时候，是返回 -1 而不是返回 null 。 &lt;span&gt;所以代码默认不能选择 -1作为 Key或者Value&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(在实际场景中，我们会将int类型的Key替换为实现Compare接口的类的对象，同时将“失败”时的返回值从-1设为null，这时是没有这个问题的)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;字典的定义和相关操作&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;字典&lt;/strong&gt;&lt;/span&gt;又叫&lt;strong&gt;&lt;span&gt;查找表&lt;/span&gt;&lt;/strong&gt;（Search Table）, 是由同一类型的数据元素构成的集合， 由于集合中的数据元素存在着完全松散的关系， 因此查找表是一种非常灵便的数据结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对查找表经常进行的操作有：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查询某个特定的数据是否在查找表中&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;检索某个特定的数据元素的各种属性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在查找表中插入一个数据元素&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;从查找表中删除某个数据元素&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;若对查找表只做1,2两种查找的操作， 这样的查找表被称为“&lt;span&gt;&lt;strong&gt;静态查找表&lt;/strong&gt;&lt;/span&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若在查找过程中同时还进行了3,4操作， 这样的查找表被称为“&lt;strong&gt;&lt;span&gt;动态查找表&lt;/span&gt;&lt;/strong&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;有序数组实现字典&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;有序数组实现字典思路&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;字典，有最关键的两个类型的值： &lt;span&gt;&lt;strong&gt;Key&lt;/strong&gt;&lt;/span&gt;和&lt;strong&gt;&lt;span&gt;Value&lt;/span&gt;&lt;/strong&gt;。 但是一个数组显然只能存储一个类型的值呀， 正因如此：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;首先&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;我们需要预备两个数组;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;   &lt;/strong&gt; &lt;strong&gt;&lt;span&gt;其次&lt;/span&gt;&lt;/strong&gt;，我们&lt;strong&gt;&lt;span&gt;要在每次操作中同步两个数组的状态&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 预备两个数组，一个存储Key,  一个存储Value&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/a57296e9e174460588fbb23fe245cf06/nstxakwz%2529%2525hl%255Bv%255Bz1%2560ud%257B7d.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;A839E0B3A9B944EA9DB3C868821AD6C4&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214144758810-2141316793.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2. 在每次操作中同步两个数组的状态&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;以有序数组的插入键值对的操作为例（put）&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/6682b4933eb44dbfa30f79e3616f9986/%255B%257Er%257D%255Byj2_kc%2524x5bs0%2560208%2528o.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;3691D47464C043FFA7C73909A4FF662A&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214144811420-768588887.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（int类型的数组初始化后，默认值是0）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Key和Value的位置是相同的&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;双数组实现字典功能的核心在于： 每一步操作里，Key和Value在两个数组里的位置是相同的&lt;/strong&gt;&lt;/span&gt;， 这意为着你查找出Key的位置时， 也一并查找出了Value的位置。 例如删除操作时， 假设Key和Value的数组分别为a1和a2,  通过对Key的查找得出Key的位置是x, 那么接下来只要对a1[x]和a2[x] 同时进行操作就可以了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;字典长度和数组长度&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;同时要注意一个简单却容易搞混的点：&lt;span&gt;&lt;strong&gt;&lt;span&gt;字典长度和数组长度是两个不一样的概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数组长度是创建后固定不变的，例如一开始就是N&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;字典的长度是可变的， 开始是0， 逐渐递增到N。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以有序数组为例&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/9d5bc0e5c2f544309554205b2f89a1ec/m@lfj%2529%255Bnlmybcwy_2g3g%2524%2525n.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;24A9C736EF07481AB79B6F5533C436A6&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214144836123-1638632278.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【注意】这里的“数组长度固定不变”是相对而言的， &lt;span&gt;&lt;strong&gt;下面我会介绍当字典满溢时扩建数组的操作（resize）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;选择有序数组的原因&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;要实现字典， 使用有序数组和无序数组当然都可以, 让我们思考下： 为什么要选择有序数组呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;有序数组相对于无序数组的性能优势&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实现上，&lt;span&gt;&lt;strong&gt;无序数组&lt;/strong&gt;&lt;/span&gt;和&lt;strong&gt;&lt;span&gt;有序数组&lt;/span&gt;&lt;/strong&gt;的&lt;strong&gt;&lt;span&gt;性能差异&lt;/span&gt;&lt;/strong&gt;， 本质上是&lt;span&gt;&lt;strong&gt;顺序查找&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;二分查找&lt;/strong&gt;&lt;/span&gt;的&lt;strong&gt;&lt;span&gt;性能差异&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为二分查找是基于有序数组的，所以&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;选择无序数组实现字典， 也就意味着选择了顺序查找。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;而选择有序数组实现字典， 代表着你可以选择二分查找&lt;/span&gt;&lt;/strong&gt;（或插值查找等）， &lt;span&gt;&lt;strong&gt;并享受查找性能上的巨大提升&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于顺序查找和二分查找的区别可以看下我的上一篇博客&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;三个成员变量，一个核心方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们使用的有序数组类的代码结构如下图所示：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（二分查找字典）&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BinarySearchST {
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; [] keys;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储key&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt; [] vals;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储value &lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt; N = 0;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算字典长度&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt;  BinarySearchST (&lt;span&gt;int&lt;/span&gt; n) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据输入的数组长度初始化keys和vals&lt;/span&gt;
    keys = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
    vals &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; rank (&lt;span&gt;int&lt;/span&gt; key) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找Key的位置并返回
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 核心方法&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put (&lt;span&gt;int&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过一些方式调用rank&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过一些方式调用rank&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; delete (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过一些方式调用rank&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三个成员变量&lt;/span&gt;&lt;/strong&gt;: keys, vals, N&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;一个核心方法&lt;/strong&gt;&lt;/span&gt;: rank （查找Key的位置），我们下面介绍的大多数方法都要依赖于调用rank去实现。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;无序链表实现的字典API&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. rank方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;几乎所有基础的方法，例如get,  put, delete都要依赖rank的调用来实现&lt;/strong&gt;&lt;/span&gt;， 所以首先让我来介绍下rank的实现&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;rank方法的代码和普通的二分查找的代码基本相同， 但有一点区别。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;普通的二分查找&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;查找成功，返回Key的位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;查找失败（Key不存在），返回 &lt;span&gt;&lt;strong&gt;- 1&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;对应rank方法的实现&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;查找成功，返回Key的位置&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;查找失败（Key不存在），返回&lt;span&gt;&lt;strong&gt;小于给定Key的元素数量&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么比起普通的二分查找，rank方法在后一点不是返回 -1 而是返回小于给定Key的元素数量呢？ &lt;span&gt;&lt;strong&gt;因为对于某些调用rank方法，例如put方法来说，在Key不存在的时候也需要提供插入的位置信息， 所以当然不能只返回 -1了。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; rank (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; mid;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; low= 0,high = N-1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (low&amp;lt;=&lt;span&gt;high) {
      mid &lt;/span&gt;= (low + high)/2&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(key&amp;lt;&lt;span&gt;keys[mid]) {
        high &lt;/span&gt;= mid - 1&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(key&amp;gt;&lt;span&gt;keys[mid]) {
        low &lt;/span&gt;= mid + 1&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; mid;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找成功，返回Key的位置&lt;/span&gt;
&lt;span&gt;      }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; low;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  返回小于给定Key的元素数量&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于普通二分查找的代码可以看下我的上一篇文章&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. put方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;put方法的参数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接收两个参数key和val, 表示要插入的键值对&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;put方法的实现思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;调用rank方法返回位置下标 i， 然后根据给定的key判断key == keys[i]是否成立&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;如果key等于keys[i]，说明查找成功， 那么只要替换vals数组中的vals[i]为新的val就可以了，如&lt;strong&gt;图A&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果key不等于keys[i]，那么在字典中插入新的 key-val键值对，具体操作是将数组keys和vals中大于给定key和val的元素全部右移一位， 然后使keys[i]=key; vals[i] = val; 如&lt;strong&gt;图B&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图所示：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;图A&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/b59502ff7edd4c719cc9cc2500ac19b6/%2540s1c%257E6p%257B@gs%257Becf2%257E__%2529b%2529g.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;8D32C692A38445E0B2EDDB56B15E54EE&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214144926576-1269178735.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图B&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214144936810-523973801.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/25780e1630e244699d7cde88479fc2e8/_3%257Bfh2tp6gy78ggdwx6is%2528x.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;63E68801D4CD476DB89C42AFDFB2FD52&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put (&lt;span&gt;int&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; rank(key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;N&amp;amp;&amp;amp;key == keys[i]) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找到Key, 替换vals[i]为val&lt;/span&gt;
      vals[i] =&lt;span&gt; val;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=N;j&amp;gt;i;j-- ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未查找到Key&lt;/span&gt;
      keys[j] = keys[j-1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将keys数组中小于key的值全部右移一位&lt;/span&gt;
      vals[j] = vals[j-1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将vals数组中小于val的值全部右移一位&lt;/span&gt;
&lt;span&gt;    }
    keys[i] &lt;/span&gt;= key; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入给定的key&lt;/span&gt;
    vals[i] = val; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入给定的val&lt;/span&gt;
    N++&lt;span&gt;;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;if(i&amp;lt;N&amp;amp;&amp;amp;key == keys[i])  里的 i&amp;lt;N的作用是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个问题等价于： &lt;span&gt;&lt;strong&gt;&lt;span&gt;不能直接用key == keys[i]作为判定条件吗。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据上面rank方法中二分查找的代码可知， low和high交叉的时候，即刚好使low&amp;gt;high的时候，查找结束，&lt;span&gt;&lt;strong&gt;所以查找结束时，low和high的关系可能是下面这种情况：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214144957982-355808123.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/18711de645dd43e19b5a63d71e16ae26/zsr@%2524ug%257B0%2525lc7p%2524jdac%257B%257Dzi.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;C9003D11F1324A16BB48CE4C99BE5A84&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;红色部分表示现有字典的长度， 图中low刚好 “越界”了，也即使low=N。（这里的N是字典的长度）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;keys[0] ~ keys[N-1]是存储key的元素， 而keys[N]则是尚未存储key的元素， 所以被默认初始化为0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在上面的前提下， 如果这时key又刚好是0的话&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;， key == keys[i]  (i =N)将判定为 true， &lt;span&gt;&lt;strong&gt;这样就会对处在字典之外的vals[N]执行 vals[N] = 0的操作， 这显然是不正确的。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所以要添加i&amp;lt;N这个判断条件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;for循环里的判断条件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;for循环里执行的操作是： 将数组keys和vals中大于给定key和val的元素&lt;span&gt;&lt;strong&gt;全部右移一位&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是要注意， &lt;span&gt;&lt;strong&gt;&lt;span&gt;右移一位的顺序是“从右到左”， 而不是“从左到右”&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; ，这意味着，我们不能把&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=N;j&amp;gt;i;j--&lt;span&gt; ) {
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;写成：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=i + 1;j&amp;lt;=N;j++&lt;span&gt; ) {
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;因为这样做会导致key/val右边的元素变得完全一样的错误结果,如图&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/2e84a67b0e7f4ebaa96710e6970ebc7e/5onmglxg8_5%257D2qceoe@zwgr.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;89425F7FF22B4354B1C5ACDDB5766CBF&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214145018138-1793578748.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;3. get方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入参数为给定的key, 返回值是给定key对应的value值， 如果没有查找到key，则返回 -1， 提示操作失败。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要注意一点： &lt;span&gt;&lt;strong&gt;当 N = 0即字典为空的时候，显然不需要进行查找了， 可以直接返回 -1&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; N == 0&lt;span&gt;;
  } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断字典是否为空（不是数组！）&lt;/span&gt;
 
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isEmpty()) &lt;span&gt;return&lt;/span&gt; -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当字典为空时，不需要进行查找，提示操作失败&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; rank(key); 
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;N&amp;amp;&amp;amp;keys[i] ==&lt;span&gt; key) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vals[i]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当查找成功时候， 返回和key对应的value值&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有查找到给定的key，提示操作失败&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4. delete方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;delete方法的实现结合了get方法和put方法部分思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;和get方法一样， 查找前要通过isEmpty判断字典是否为空，是则无需删除&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;和put方法类似， 删除要将keys/vals中大于key/value的元素全部“左移一位”&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; delete (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isEmpty()) &lt;span&gt;return&lt;/span&gt; -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字典为空， 无需删除&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; rank(key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;N&amp;amp;&amp;amp;keys[i] == key) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当给定key存在时候，删除该key-value对&lt;/span&gt;
      &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=i;j&amp;lt;=N-1;j++&lt;span&gt;) {
        keys[j] &lt;/span&gt;= keys[j+1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除key&lt;/span&gt;
        vals[j] = keys[j+1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除value&lt;/span&gt;
&lt;span&gt;      }
      N&lt;/span&gt;--; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字典长度减1&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; key; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除成功，返回被删除的key&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未查找到给定key，删除失败&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;将keys/vals中大于key/value的元素全部“左移一位”的时候， delete方法和put方法的for循环的遍历方向是相反的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不是&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=N;j&amp;gt;i;j-- ) { }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;而是&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=i;j&amp;lt;=N-1;j++) { }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;不要写错了， 不然会造成之前提到的“右边元素变得完全一样”的问题（这一点前面已经提过类似的点， 就不赘述了）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;5. floor方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;输入key,  返回&lt;span&gt;keys数组&lt;/span&gt;中&lt;span&gt;小于等于&lt;/span&gt;给定key的&lt;span&gt;最大值&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;floor意为“地板”， 它指的是在字典中小于或等于给定值的最大值， 这听起来可能有点绕， 例如对字典1,2,3,4,5。 输入key为4，则对应的floor值是4； 而输入key为3.5，则对应的floor值为3。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;实现的思路&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先要确认的是key是否存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1. 如果输入的key存在， 则返回等于该key的keys元素即可&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2. 若输入的key不存在， 则返回小于key的最大值: keys[rank(key)-1]&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;3. 在2中要注意一种特殊情况： 输入的key比字典中所有的元素都小， 这时显然找不到它的floor值，所以返回 -1, 表示操作失败&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(假设rank = rank(key) ,三种情况如下图所示   )&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/1df7ba3a6eb4486397981e4f0c47d8ce/%2560d15jh68j4z00%255Bc48iaft%25248.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;C11F5859BBCB4392A9A1DF78D6BFCB8F&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214145102342-1316920077.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; floor (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k  = get(key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找key， 返回其value&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; rank = rank(key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回给定key的位置&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(k!=-1) &lt;span&gt;return&lt;/span&gt; key; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找成功，返回值为key&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(k==-1&amp;amp;&amp;amp;rank&amp;gt;0) &lt;span&gt;return&lt;/span&gt; keys[rank-1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未查找到key,同时给定key并没有排在字典最左端，则返回小于key的前一个值&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未查找到key，给定Key排在字典最左端，没有floor值&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;6. ceiling方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;输入key,  返回&lt;span&gt;keys数组&lt;/span&gt;中&lt;span&gt;大于等于&lt;/span&gt;给定key的&lt;span&gt;最小值&lt;/span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ceiling方法的实现思路和floor方法类似&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;实现的思路&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先要确认的是key是否存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 如果输入的key存在， 则返回等于该key的keys元素即可, 即keys[rank(key)];&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 若输入的key不存在， 则返回大于key的最大值: keys[rank(key)];&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 在2中要注意一种特殊情况： 输入的key比字典中所有的元素都大， 这时显然找不到它的ceiling值，所以返回 -1, 表示操作失败&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;【注意】1,2中情况虽然不同，返回值却可以用同一个表达式，这和rank函数的编码有关&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(假设rank = rank(key) ,三种情况如下图所示   )&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;6&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214145114076-353334689.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;p&gt;代码&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ceiling (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k =&lt;span&gt; rank(key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(k==N) &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; keys[k];
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/d8d1c8d4c615487eafed316eb7549541/nxa%257Dia%2525%257E%257Bz%2528_l7y_5mnv%252580.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;90B16F9BD8C046C184E4CF4E63380E5A&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;7. size方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;返回字典的大小， 即N&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码很简单：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size () { &lt;span&gt;return&lt;/span&gt; N; }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;之所以能直接返回，是因为我们在更改字典的操作时， 也相应地维护着N的状态&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在声明N的时候初始化了: int N = 0;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;put操作完成时执行了N++&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;delete操作完成时执行了N--;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;8. max, min,select方法&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;7&quot;&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; max () { &lt;span&gt;return&lt;/span&gt; keys[N-1]; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回最大的key&lt;/span&gt;
 
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; min () { &lt;span&gt;return&lt;/span&gt; keys[0]; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回最小的key&lt;/span&gt;
 
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; select (&lt;span&gt;int&lt;/span&gt; k) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据下标返回key&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(k&amp;lt;0||k&amp;gt;N) &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; keys[k];
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;9. resize&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在我们的代码里， 字典长度是不断增长的，而数组长度是固定的， 那么这不由得让我们心生忧虑：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果数组满了怎么办呢？ 换句话说，从0增长的字典长度赶上了当前数组的长度。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为java的数组长度在创建后不可调&lt;span&gt;&lt;strong&gt;，所以我们要新建一个更大的数组，将原来的数组元素拷贝到新数组里面去。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为字典涉及两个数组： keys和vals,  所以这里新建了两个新的临时数组tempKeys和tempVals， 转移完成后， 使得&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    keys =&lt;span&gt; tempKeys;
    vals &lt;/span&gt;= tempVals;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;就可以了&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; resize (&lt;span&gt;int&lt;/span&gt; max) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调整数组大小&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; [] tempKeys = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[max];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; [] tempVals = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[max];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;N;i++&lt;span&gt;) {
      tempKeys[i] &lt;/span&gt;=&lt;span&gt; keys[i];
      tempVals[i] &lt;/span&gt;=&lt;span&gt; vals[i];
    }
    keys &lt;/span&gt;=&lt;span&gt; tempKeys;
    vals &lt;/span&gt;=&lt;span&gt; tempVals;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后在put方法里加上：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字典长度赶上了数组长度，将数组长度扩大为原来的2倍&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(N == keys.length) { resize(2*keys.length) }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有序数组实现字典的全部代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: HuWan Peng
 * @Date Created in 11:54 2017/12/10
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BinarySearchST {
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; [] keys;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; [] vals;
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; N = 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  BinarySearchST (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
    keys &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
    vals &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size () { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; N; }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; max () { &lt;span&gt;return&lt;/span&gt; keys[N-1]; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回最大的key&lt;/span&gt;
 
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; min () { &lt;span&gt;return&lt;/span&gt; keys[0]; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回最小的key&lt;/span&gt;
 
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; select (&lt;span&gt;int&lt;/span&gt; k) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据下标返回key&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(k&amp;lt;0||k&amp;gt;N) &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; keys[k];
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; rank (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; mid;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; low= 0,high = N-1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (low&amp;lt;=&lt;span&gt;high) {
      mid &lt;/span&gt;= (low + high)/2&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(key&amp;lt;&lt;span&gt;keys[mid]) {
        high &lt;/span&gt;= mid - 1&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(key&amp;gt;&lt;span&gt;keys[mid]) {
        low &lt;/span&gt;= mid + 1&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid;
      }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; low;
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put (&lt;span&gt;int&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; val) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; rank(key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;N&amp;amp;&amp;amp;key == keys[i]) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找到Key, 替换vals[i]为val&lt;/span&gt;
      vals[i] =&lt;span&gt; val;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=N;j&amp;gt;i;j-- ) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未查找到Key&lt;/span&gt;
      keys[j] = keys[j-1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将keys数组中小于key的值全部右移一位&lt;/span&gt;
      vals[j] = vals[j-1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将vals数组中小于val的值全部右移一位&lt;/span&gt;
&lt;span&gt;    }
    keys[i] &lt;/span&gt;= key; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入给定的key&lt;/span&gt;
    vals[i] = val; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入给定的val&lt;/span&gt;
    N++&lt;span&gt;;
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; N == 0&lt;span&gt;;
  } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断字典是否为空（不是数组！）&lt;/span&gt;
 
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isEmpty()) &lt;span&gt;return&lt;/span&gt; -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当字典为空时，不需要进行查找，提示操作失败&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; rank(key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;N&amp;amp;&amp;amp;keys[i] ==&lt;span&gt; key) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; vals[i]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当查找成功时候， 返回和key对应的value值&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有查找到给定的key，提示操作失败&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; delete (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isEmpty()) &lt;span&gt;return&lt;/span&gt; -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字典为空， 无需删除&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; rank(key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;N&amp;amp;&amp;amp;keys[i] == key) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当给定key存在时候，删除该key-value对&lt;/span&gt;
      &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=i;j&amp;lt;=N-1;j++&lt;span&gt;) {
        keys[j] &lt;/span&gt;= keys[j+1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除key&lt;/span&gt;
        vals[j] = keys[j+1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除value&lt;/span&gt;
&lt;span&gt;      }
      N&lt;/span&gt;--; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字典长度减1&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; key; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除成功，返回被删除的key&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未查找到给定key，删除失败&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ceiling (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k =&lt;span&gt; rank(key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(k==N) &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; keys[k];
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; floor (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k  = get(key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找key， 返回其value&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; rank = rank(key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回给定key的位置&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(k!=-1) &lt;span&gt;return&lt;/span&gt; key; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找成功，返回值为key&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(k==-1&amp;amp;&amp;amp;rank&amp;gt;0) &lt;span&gt;return&lt;/span&gt; keys[rank-1]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未查找到key,同时给定key并没有排在字典最左端，则返回小于key的前一个值&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 未查找到key，给定Key排在字典最左端，没有floor值&lt;/span&gt;
&lt;span&gt;  }
 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;无序链表&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;字典类的结构&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;9&quot;&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SequentialSearchST {
  Node first; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头节点&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt; N = 0;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表长度&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 内部Node类&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; key;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
    Node next; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指向下一个节点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Node (&lt;span&gt;int&lt;/span&gt; key,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value,Node next) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
    }
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put (&lt;span&gt;int&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value) {  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;链表的组成单元是节点&lt;/strong&gt;&lt;/span&gt;， 所以在 SequentialSearchST 类里面定义了一个&lt;span&gt;&lt;strong&gt;匿名内部Node类,&lt;/strong&gt;&lt;/span&gt; 以便在外部类里能够实例化节点对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;节点对象有三个实例变量：  key，value和next&lt;/strong&gt;&lt;/span&gt;,  key和value分别用来存储字典的键和值， 而next用于建立节点和节点间的引用联系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从头节点first开始， 依次将本节点的next实例变量指向下一个节点， 从而建立一条字典链表。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/d008819dedf444258e7391d106d3c832/r%257D%255B5ctv%255Dj%257Dxnqcq%2529%2528u%2525bjzo.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;AE785CF7EEBD4BB4B10A0760589AD0A3&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214145159154-2023133344.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;链表和数组在实现字典的不同点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 链表节点本身自带键和值属性， 所以用一条链表就能实现字典， 而数组要使用两个数组才可以&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 数组通过增减下标值遍历元素， 而链表是依赖前后节点的引用关系进行迭代，从而实现节点的遍历&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;无序链表实现的字典API&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. put 方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put (&lt;span&gt;int&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Node n=first;n!=&lt;span&gt;null&lt;/span&gt;;n=n.next) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历链表节点&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(n.key == key) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找到给定的key，则更新相应的value&lt;/span&gt;
        n.value =&lt;span&gt; value;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历完所有的节点都没有查找到给定key
   
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 创建新节点，并和原first节点建立“next”的联系，从而加入链表
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 将first变量修改为新加入的节点&lt;/span&gt;
    first = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(key,value,first);
    N&lt;/span&gt;++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加字典（链表）的长度&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要理解&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
first = &lt;span&gt;new&lt;/span&gt; Node(key,value,first);
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这一句代码， 可以把它拆分成两段代码来看：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Node newNode = &lt;span&gt;new&lt;/span&gt; Node(key,value,first);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 创建新节点，并和原first节点建立“next”的联系&lt;/span&gt;
first = newNode  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 将first变量修改为新加入的节点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如图所示&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214145226060-1682244541.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/7e1c0a0528e54965ba612a02078dd7a7/j4jcm%2525ipin%257D%255D@%255Dvyo_p0r%257Dj.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;1FC918B467BE418381F70AF8AF8D8188&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. get方法&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Node n=first;n!=&lt;span&gt;null&lt;/span&gt;;n=&lt;span&gt;n.next) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n.key==key) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; n.value;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;3. delete方法&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Node n =first;n!=&lt;span&gt;null&lt;/span&gt;;n=&lt;span&gt;n.next) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n.next.key==&lt;span&gt;key) {
        n.next &lt;/span&gt;=&lt;span&gt; n.next.next;
        N&lt;/span&gt;--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关键代码&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;if&lt;/span&gt;(n.next.key==&lt;span&gt;key) {
        n.next &lt;/span&gt;=&lt;span&gt; n.next.next;
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的逻辑图示如下：&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214145237342-1051545844.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/7f89421889444eb887aea579be1829f6/v%255Dbbq32%25242o47%257Dfdh2%25608ngor.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;D6EE5D80BCB44A4FA0E4BDF4613F9B8B&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;全部代码：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: HuWan Peng
 * @Date Created in 17:26 2017/12/10
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SequentialSearchST {
  Node first; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 头节点&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt; N = 0;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表长度&lt;/span&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
    Node next; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指向下一个节点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Node (&lt;span&gt;int&lt;/span&gt; key,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value,Node next) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
    }
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; N;
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; put (&lt;span&gt;int&lt;/span&gt; key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Node n=first;n!=&lt;span&gt;null&lt;/span&gt;;n=n.next) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历链表节点&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(n.key == key) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找到给定的key，则更新相应的value&lt;/span&gt;
        n.value =&lt;span&gt; value;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
      }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历完所有的节点都没有查找到给定key
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 创建新节点，并和原first节点建立“next”的联系，从而加入链表
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 将first变量修改为新加入的节点&lt;/span&gt;
    first = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(key,value,first);
    N&lt;/span&gt;++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加字典（链表）的长度&lt;/span&gt;
&lt;span&gt;  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Node n=first;n!=&lt;span&gt;null&lt;/span&gt;;n=&lt;span&gt;n.next) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n.key==key) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; n.value;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
  }
 
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; key) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Node n =first;n!=&lt;span&gt;null&lt;/span&gt;;n=&lt;span&gt;n.next) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n.next.key==&lt;span&gt;key) {
        n.next &lt;/span&gt;=&lt;span&gt; n.next.next;
        N&lt;/span&gt;--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
      }
    }
  }
 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;有序数组和无序链表实现字典的性能差异&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;有序数组和无序链表的性能差异， 本质上还是顺序查找和二分查找的性能差异。 正因如此， 有序数组的性能表现远好于无序链表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面展示的是《算法》书中的测试结果，&lt;span&gt;&lt;strong&gt;成本模型是对小说文本tale.txt中5737个不同的键执行put操作时，所用的总比较次数&lt;/strong&gt;&lt;/span&gt;。（键是不同的单词，值是每个单词出现的次数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无序链表实现的成本&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214145248435-245065278.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/256da92c116b478785a33a8936bb14bc/qpvc345y8%2524jllb8kbwzah7i.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;58361C972DDD40A787104BE0F00641E7&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有序数组实现的成本&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/0c84e2d2370b451e915ea326c19a2fe3/9edo%2529r%2525j8%2529o5t3lxn6wmjri.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;E0EC6C0B3B1D4DD691545FD5D9E0DF0A&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214145256498-556562461.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;作为测试模型的tale.text的性质如下：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214145304685-550932249.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;

&lt;/div&gt;
&lt;p&gt; 【完】&lt;/p&gt;

&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1060770/201712/1060770-20171214154749013-1448602029.jpg&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;383&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;file:///C:/Users/lenovo/AppData/Local/YNote/data/qq558635343CE3D787D7910E2E25B05D68/c7acd23712114099b7e03a377b7ccf1f/wdmddr6sb3pvwybh1@8%25299ve.png&quot; alt=&quot;&quot; data-attr-org-src-id=&quot;FDC8A90DB448489B8CDD467C80A4BA0A&quot; data-media-type=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Dec 2017 07:08:00 +0000</pubDate>
<dc:creator>外婆的彭湖湾</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/penghuwan/p/8037856.html</dc:identifier>
</item>
<item>
<title>Pyhton爬虫实战 - 抓取BOSS直聘职位描述 和 数据清洗 - jtahstu</title>
<link>http://www.cnblogs.com/jtahstu/p/8037678.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jtahstu/p/8037678.html</guid>
<description>&lt;h2 id=&quot;零致谢&quot;&gt;零、致谢&lt;/h2&gt;
&lt;p&gt;感谢BOSS直聘相对权威的招聘信息，使本人有了这次比较有意思的研究之旅。&lt;/p&gt;
&lt;p&gt;由于爬虫持续爬取 www.zhipin.com 网站，以致产生的服务器压力，本人深感歉意，并没有 DDoS 和危害贵网站的意思。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;2017-12-14 更新&lt;br/&gt;在跑了一夜之后，服务器 IP 还是被封了，搞得本人现在家里、公司、云服务器三线作战啊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一抓取详细的职位描述信息&quot;&gt;一、抓取详细的职位描述信息&lt;/h2&gt;
&lt;h3 id=&quot;前提数据&quot;&gt;1.1 前提数据&lt;/h3&gt;
&lt;p&gt;这里需要知道页面的 id 才能生成详细的链接，在 &lt;a href=&quot;http://www.jtahstu.com/blog/scrapy_zhipin_spider.html&quot;&gt;Python爬虫框架Scrapy实战 - 抓取BOSS直聘招聘信息&lt;/a&gt; 中，我们已经拿到招聘信息的大部分信息，里面有个 &lt;code&gt;pid&lt;/code&gt; 字段就是用来唯一区分某条招聘，并用来拼凑详细链接的。&lt;/p&gt;
&lt;p&gt;是吧，明眼人一眼就看出来了。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;详情页分析&quot;&gt;1.2 详情页分析&lt;/h3&gt;
&lt;p&gt;详情页如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.jtup.cc/blog/image/20171213_1541.png&quot; alt=&quot;P2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在详情页中，比较重要的就是&lt;code&gt;职位描述&lt;/code&gt;和&lt;code&gt;工作地址&lt;/code&gt;这两个&lt;/p&gt;
&lt;p&gt;由于在页面代码中&lt;code&gt;岗位职责&lt;/code&gt;和&lt;code&gt;任职要求&lt;/code&gt;是在一个 div 中的，所以在抓的时候就不太好分，后续需要把这个连体婴儿，分开分析。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;爬虫用到的库&quot;&gt;1.3 爬虫用到的库&lt;/h3&gt;
&lt;p&gt;使用的库有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;requests&lt;/li&gt;
&lt;li&gt;BeautifulSoup4&lt;/li&gt;
&lt;li&gt;pymongo&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应的安装文档依次如下，就不细说了&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;python-代码&quot;&gt;1.4 Python 代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&quot;&quot;&quot;
@author: jtahstu
@contact: root@jtahstu.com
@site: http://www.jtahstu.com
@time: 2017/12/10 00:25
&quot;&quot;&quot;
# -*- coding: utf-8 -*-
import requests
from bs4 import BeautifulSoup
import time
from pymongo import MongoClient

headers = {
    'x-devtools-emulate-network-conditions-client-id': &quot;5f2fc4da-c727-43c0-aad4-37fce8e3ff39&quot;,
    'upgrade-insecure-requests': &quot;1&quot;,
    'user-agent': &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&quot;,
    'accept': &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;,
    'dnt': &quot;1&quot;,
    'accept-encoding': &quot;gzip, deflate&quot;,
    'accept-language': &quot;zh-CN,zh;q=0.8,en;q=0.6&quot;,
    'cookie': &quot;__c=1501326829; lastCity=101020100; __g=-; __l=r=https%3A%2F%2Fwww.google.com.hk%2F&amp;amp;l=%2F; __a=38940428.1501326829..1501326829.20.1.20.20; Hm_lvt_194df3105ad7148dcf2b98a91b5e727a=1501326839; Hm_lpvt_194df3105ad7148dcf2b98a91b5e727a=1502948718; __c=1501326829; lastCity=101020100; __g=-; Hm_lvt_194df3105ad7148dcf2b98a91b5e727a=1501326839; Hm_lpvt_194df3105ad7148dcf2b98a91b5e727a=1502954829; __l=r=https%3A%2F%2Fwww.google.com.hk%2F&amp;amp;l=%2F; __a=38940428.1501326829..1501326829.21.1.21.21&quot;,
    'cache-control': &quot;no-cache&quot;,
    'postman-token': &quot;76554687-c4df-0c17-7cc0-5bf3845c9831&quot;
}
conn = MongoClient('127.0.0.1', 27017)
db = conn.iApp  # 连接mydb数据库，没有则自动创建


def init():
    items = db.jobs_php.find().sort('pid')
    for item in items:
        if 'detail' in item.keys(): # 在爬虫挂掉再此爬取时，跳过已爬取的行
            continue
        detail_url = &quot;https://www.zhipin.com/job_detail/%s.html?ka=search_list_1&quot; % item['pid']
        print(detail_url)
        html = requests.get(detail_url, headers=headers)
        if html.status_code != 200: # 爬的太快网站返回403，这时等待解封吧
            print('status_code is %d' % html.status_code)
            break
        soup = BeautifulSoup(html.text, &quot;html.parser&quot;)
        job = soup.select(&quot;.job-sec .text&quot;)
        if len(job) &amp;lt; 1:
            continue
        item['detail'] = job[0].text.strip()  # 职位描述
        location = soup.select(&quot;.job-sec .job-location&quot;)
        item['location'] = location[0].text.strip()  # 工作地点
        item['updated_at'] = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())  # 实时爬取时间
        res = save(item) # 保存数据
        print(res)
        time.sleep(40) # 停停停


# 保存数据到 MongoDB 中
def save(item):
    return db.jobs_php.update_one({&quot;_id&quot;: item['_id']}, {&quot;$set&quot;: item})


if __name__ == &quot;__main__&quot;:
    init()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码 easy，初学者都能看懂。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;再啰嗦几句&quot;&gt;1.5 再啰嗦几句&lt;/h3&gt;
&lt;p&gt;在 &lt;a href=&quot;http://www.jtahstu.com/blog/scrapy_zhipin_spider.html&quot;&gt;上一篇文章&lt;/a&gt; 中只是爬了 &lt;code&gt;上海-PHP&lt;/code&gt; 近300条数据，后续改了代码，把12个城市的 PHP 相关岗位的数据都抓下来了，有3500+条数据，慢慢爬吧，急不来。&lt;/p&gt;
&lt;p&gt;像这样&lt;br/&gt;&lt;img src=&quot;http://cdn.jtup.cc/blog/image/QQ20171213-163313@2x.png&quot; alt=&quot;P7&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://cdn.jtup.cc/blog/image/QQ20171213-163553@2x.png&quot; alt=&quot;P8&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二数据清洗&quot;&gt;二、数据清洗&lt;/h2&gt;
&lt;h3 id=&quot;校正发布日期&quot;&gt;2.1 校正发布日期&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&quot;time&quot; : &quot;发布于03月31日&quot;,
&quot;time&quot; : &quot;发布于昨天&quot;,
&quot;time&quot; : &quot;发布于11:31&quot;,&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里拿到的都是这种格式的，所以简单处理下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import datetime

from pymongo import MongoClient

db = MongoClient('127.0.0.1', 27017).iApp

def update(data):
    return db.jobs_php.update_one({&quot;_id&quot;: data['_id']}, {&quot;$set&quot;: data})
    
# 把时间校正过来
def clear_time():
    items = db.jobs_php.find({})
    for item in items:
        if not item['time'].find('布于'):
            continue
        item['time'] = item['time'].replace(&quot;发布于&quot;, &quot;2017-&quot;)
        item['time'] = item['time'].replace(&quot;月&quot;, &quot;-&quot;)
        item['time'] = item['time'].replace(&quot;日&quot;, &quot;&quot;)
        if item['time'].find(&quot;昨天&quot;) &amp;gt; 0:
            item['time'] = str(datetime.date.today() - datetime.timedelta(days=1))
        elif item['time'].find(&quot;:&quot;) &amp;gt; 0:
            item['time'] = str(datetime.date.today())
        update(item)
    print('ok')&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;校正薪水以数字保存&quot;&gt;2.2 校正薪水以数字保存&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&quot;salary&quot; : &quot;5K-12K&quot;,

#处理成下面的格式
&quot;salary&quot; : {
    &quot;low&quot; : 5000,
    &quot;high&quot; : 12000,
    &quot;avg&quot; : 8500.0
},&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;# 薪水处理成数字
def clear_salary():
    items = db.jobs_php.find({})
    for item in items:
        if type(item['salary']) == type({}):
            continue
        salary_list = item['salary'].replace(&quot;K&quot;, &quot;000&quot;).split(&quot;-&quot;)
        salary_list = [int(x) for x in salary_list]
        item['salary'] = {
            'low': salary_list[0],
            'high': salary_list[1],
            'avg': (salary_list[0] + salary_list[1]) / 2
        }
        update(item)
    print('ok')&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;根据-工作经验年限-划分招聘等级&quot;&gt;2.3 根据 工作经验年限 划分招聘等级&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# 设置招聘的水平
def set_level():
    items = db.jobs_php.find({})
    for item in items:
        if item['workYear'] == '应届生':
            item['level'] = 1
        elif item['workYear'] == '1年以内':
            item['level'] = 2
        elif item['workYear'] == '1-3年':
            item['level'] = 3
        elif item['workYear'] == '3-5年':
            item['level'] = 4
        elif item['workYear'] == '5-10年':
            item['level'] = 5
        elif item['workYear'] == '10年以上':
            item['level'] = 6
        elif item['workYear'] == '经验不限':
            item['level'] = 10
        update(item)
    print('ok')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有点坑的就是，一般要求&lt;code&gt;经验不限&lt;/code&gt;的岗位，需求基本都写在&lt;code&gt;任职要求&lt;/code&gt;里了，所以为了统计的准确性，这个等级的数据，后面会被舍弃掉。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;2017-12-14 更新：&lt;br/&gt;从后续的平均数据来看，这里的&lt;code&gt;经验不限&lt;/code&gt;，一般要求的是&lt;code&gt;1-3年&lt;/code&gt;左右，但是还是建议舍弃掉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h3 id=&quot;区分开和&quot;&gt;2.4 区分开&amp;lt;岗位职责&amp;gt;和&amp;lt;任职要求&amp;gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;对于作者这个初学者来说，这里还没有什么好的方法，知道的同学，请务必联系作者，联系方式在&lt;a href=&quot;http://blog.jtahstu.com/&quot;&gt;个人博客&lt;/a&gt;里&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;so , i'm sorry.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么这两个不好划分出来呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为这里填的并不统一，可以说各种花样，有的要求在前，职责在后，有的又换个名字区分。目前看到的关于要求的有&lt;code&gt;['任职条件', '技术要求', '任职要求', '任职资格', '岗位要求']&lt;/code&gt;这么多说法。然后顺序还不一样，有的要求在前，职责在后，有的又反之。&lt;/p&gt;
&lt;p&gt;举个栗子&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;会基本的php编程！能够修改简单的软件！对云服务器和数据库能够运用！懂得微信公众账号对接和开放平台对接！我们不是软件公司，是运营公司！想找好的公司学习的陕西基本没有，要到沿海城市去！但是我们是实用型公司，主要是软件应用和更适合大众！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;啥也不说的，这里可以认为这是一条&lt;code&gt;脏数据&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;不行，再举个栗子&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;PHP中级研发工程师（ERP/MES方向）&lt;br/&gt;1、计算机或相关学科本科或本科以上学历；&lt;br/&gt;2、php和Java script的开发经验。&lt;br/&gt;3、Linux和MySQL数据库的开发经验；&lt;br/&gt;5、有ERP、MES相关开发经验优先；&lt;br/&gt;6、英语的读写能力；&lt;br/&gt;7、文化的开放性；&lt;br/&gt;我们提供&lt;br/&gt;1、有趣的工作任务；&lt;br/&gt;2、多元的工作领域；&lt;br/&gt;3、与能力相关的收入；&lt;br/&gt;4、年轻、开放并具有创造力的团队和工作氛围；&lt;br/&gt;5、不断接触最新科技（尤其是工业4.0相关）；&lt;br/&gt;6、可适应短期出差（提供差补）；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个只有要求，没职责，还多了个提供，我乐个趣 ╮(╯▽╰)╭&lt;/p&gt;
&lt;p&gt;所以，气的想骂人。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;ok ，现在我们的数据基本成这样了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;_id&quot; : ObjectId(&quot;5a30ad2068504386f47d9a4b&quot;),
    &quot;city&quot; : &quot;苏州&quot;,
    &quot;companyShortName&quot; : &quot;蓝海彤翔&quot;,
    &quot;companySize&quot; : &quot;100-499人&quot;,
    &quot;education&quot; : &quot;本科&quot;,
    &quot;financeStage&quot; : &quot;B轮&quot;,
    &quot;industryField&quot; : &quot;互联网&quot;,
    &quot;level&quot; : 3,
    &quot;pid&quot; : &quot;11889834&quot;,
    &quot;positionLables&quot; : [ 
        &quot;PHP&quot;, 
        &quot;ThinkPHP&quot;
    ],
    &quot;positionName&quot; : &quot;php研发工程师&quot;,
    &quot;salary&quot; : {
        &quot;avg&quot; : 7500.0,
        &quot;low&quot; : 7000,
        &quot;high&quot; : 8000
    },
    &quot;time&quot; : &quot;2017-06-06&quot;,
    &quot;updated_at&quot; : &quot;2017-12-13 18:31:15&quot;,
    &quot;workYear&quot; : &quot;1-3年&quot;,
    &quot;detail&quot; : &quot;1、处理landcloud云计算相关系统的各类开发和调研工作；2、处理coms高性能计算的各类开发和调研工作岗位要求：1、本科学历，两年以上工作经验，熟悉PHP开发，了解常用的php开发技巧和框架；2、了解C++，python及Java开发；3、有一定的研发能力和钻研精神；4、有主动沟通能力和吃苦耐劳的精神。&quot;,
    &quot;location&quot; : &quot;苏州市高新区科技城锦峰路158号101park8幢&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于还没到数据展示的时候，所以现在能想到的就是先这样处理了&lt;/p&gt;
&lt;p&gt;项目开源地址：&lt;a href=&quot;http://git.jtahstu.com/jtahstu/Scrapy_zhipin&quot; class=&quot;uri&quot;&gt;http://git.jtahstu.com/jtahstu/Scrapy_zhipin&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;三展望和设想&quot;&gt;三、展望和设想&lt;/h3&gt;
&lt;p&gt;首先这个小玩意数据量并不够多，因为爬取时间短，站点唯一，再者广度局限在 PHP 这一个岗位上，以致存在一定的误差。&lt;/p&gt;
&lt;p&gt;所以为了数据的丰富和多样性，这个爬虫是一定要持续跑着的，至少要&lt;code&gt;抓几个月的数据&lt;/code&gt;才算可靠吧。&lt;/p&gt;
&lt;p&gt;然后准备再去抓下&lt;code&gt;拉勾网&lt;/code&gt;的招聘数据，这也是个相对优秀的专业 IT 招聘网站了，数据也相当多，想当初找实习找正式工作，都是在这两个 APP 上找的，其他的网站几乎都没看。&lt;/p&gt;
&lt;p&gt;最后，对于科班出身的学弟学妹们，过来人说一句，编程相关的职业就不要去志连、钱尘乌有、five eight桐城了，好吗？那里面都发的啥呀，看那些介绍心里没点数吗？&lt;/p&gt;
&lt;h3 id=&quot;四help&quot;&gt;四、help&lt;/h3&gt;
&lt;p&gt;这里完全就是作者本人依据个人微薄的见识，主观臆断做的一些事情，所以大家有什么点子和建议，都可以联系作者，多交流交流嘛。&lt;/p&gt;
&lt;p&gt;后续会公开所有数据，大家自己可以弄着玩玩吧。&lt;/p&gt;
&lt;p&gt;我们太年轻，以致都不知道以后的时光，竟然那么长，长得足够让我们把一门技术研究到顶峰，乱花渐欲迷人眼，请不要忘了根本好吗。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;生活总是让我们遍体鳞伤，但到后来，那些受伤的地方一定会变成我们最强壮的地方。 —海明威 《永别了武器》&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 14 Dec 2017 06:48:00 +0000</pubDate>
<dc:creator>jtahstu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jtahstu/p/8037678.html</dc:identifier>
</item>
<item>
<title>ABP module-zero +AdminLTE+Bootstrap Table+jQuery权限管理系统第十七节--Quartz与ABP框架Abp.Quartz及扩展 - 安于生</title>
<link>http://www.cnblogs.com/anyushengcms/p/8037569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anyushengcms/p/8037569.html</guid>
<description>&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/anyushengcms/p/7325126.html&quot;&gt;ABP+AdminLTE+Bootstrap Table权限管理系统一期&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/Jimmey-Jiang/ABP-ASP.NET-Boilerplate-Project-CMS&quot;&gt;Github:https://github.com/Jimmey-Jiang/ABP-ASP.NET-Boilerplate-Project-CMS&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Quartz.NET是一个开源的作业调度框架，是 &lt;code&gt;OpenSymphony&lt;/code&gt; 的 &lt;code&gt;Quartz API&lt;/code&gt; 的.NET移植，它用C#写成，可用于&lt;code&gt;winform&lt;/code&gt;和&lt;code&gt;asp.net&lt;/code&gt;应用中。它提供了巨大的灵活性而不牺牲简单性。你能够用它来为执行一个作业而创建简单的或复杂的调度。它有很多特征，如：数据库支持，集群，插件，支持&lt;code&gt;cron-like&lt;/code&gt;表达式等等。非常适合在平时的工作中，定时轮询数据库同步，定时邮件通知，定时处理数据等.&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;对Quartz.NET不熟悉的可以先看下&lt;br/&gt;官方学习文档：&lt;a href=&quot;http://www.quartz-scheduler.net/documentation/index.html&quot; class=&quot;uri&quot;&gt;http://www.quartz-scheduler.net/documentation/index.html&lt;/a&gt;&lt;br/&gt;使用实例介绍：&lt;a href=&quot;http://www.quartz-scheduler.net/documentation/quartz-2.x/quick-start.html&quot; class=&quot;uri&quot;&gt;http://www.quartz-scheduler.net/documentation/quartz-2.x/quick-start.html&lt;/a&gt;&lt;br/&gt;官方的源代码下载：&lt;a href=&quot;http://sourceforge.net/projects/quartznet/files/quartznet/&quot; class=&quot;uri&quot;&gt;http://sourceforge.net/projects/quartznet/files/quartznet/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;br/&gt;它一些很好的特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;支持集群，作业分组，作业远程管理。&lt;/li&gt;
&lt;li&gt;自定义精细的时间触发器，使用简单，作业和触发分离。&lt;/li&gt;
&lt;li&gt;数据库支持，可以寄宿&lt;code&gt;Windows&lt;/code&gt;服务，&lt;code&gt;WebSite&lt;/code&gt;，&lt;code&gt;winform&lt;/code&gt;等。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Quartz框架的一些&lt;strong&gt;基础概念&lt;/strong&gt;解释：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Scheduler&lt;/td&gt;
&lt;td&gt;作业调度器。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;　IJob&lt;/td&gt;
&lt;td&gt;作业接口，继承并实现Execute， 编写执行的具体作业逻辑。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;JobBuilder&lt;/td&gt;
&lt;td&gt;根据设置，生成一个详细作业信息(JobDetail)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;TriggerBuilder&lt;/td&gt;
&lt;td&gt;根据规则，生产对应的Trig&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;实战&quot;&gt;实战&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Web.config配置&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基础概念我就懒得讲了，你也懒得听了，直接上代码吧。&lt;br/&gt;首先配置一下&lt;code&gt;Web.config&lt;/code&gt;，其实这步可有可无，可以直接跳过，只是为了配置一些常量，获取固定的时间，但是不是必要的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;sectionGroup name=&quot;JobList&quot;&amp;gt;
      &amp;lt;section name=&quot;Job&quot; type=&quot;System.Configuration.NameValueSectionHandler, System, Version=1.0.5000.0,Culture=neutral, PublicKeyToken=b77a5c561934e089&quot;/&amp;gt;
    &amp;lt;/sectionGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;JobList&amp;gt;
    &amp;lt;Job&amp;gt;
      &amp;lt;!--这里是一个任务节点--&amp;gt;
      &amp;lt;add key=&quot;Url&quot; value=&quot;http://www.baidu.com&quot; /&amp;gt;
      &amp;lt;!--需要访问的Url--&amp;gt;
      &amp;lt;add key=&quot;Hour&quot; value=&quot;10&quot; /&amp;gt;
      &amp;lt;!--开始时间小时--&amp;gt;
      &amp;lt;!--开始时间小时,注意：这里的小时为0-23，如果是1点的话就是1，而不是01--&amp;gt;
      &amp;lt;add key=&quot;Minute&quot; value=&quot;30&quot; /&amp;gt;
      &amp;lt;!--开始时间分钟--&amp;gt;
      &amp;lt;!--开始时间分钟，注意：同上0-59--&amp;gt;
    &amp;lt;/Job&amp;gt;
  &amp;lt;/JobList&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;创建service&lt;/strong&gt;&lt;br/&gt;创建&lt;code&gt;ISystemSchedulerService&lt;/code&gt;以及&lt;code&gt;SystemSchedulerService&lt;/code&gt;,代码上面都有详细的注释，我就不重复了。&lt;br/&gt;接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public  interface ISystemSchedulerService: IApplicationService
{
    void StartScheduler();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;service： &lt;code&gt;SystemSchedulerService&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public class SystemSchedulerService : ISystemSchedulerService
    {
        private IScheduler _scheduler;
        public ILogger _Logger { get; set; }
        public SystemSchedulerService()
        {
            _Logger = NullLogger.Instance;
        }

        public void StopScheduler()
        {
            _scheduler.Shutdown();
        }

        public void StartScheduler()
        {
            try
            {

                //这里读取配置文件中的任务开始时间
                int hour = int.Parse(((NameValueCollection)ConfigurationManager.GetSection(&quot;JobList/Job&quot;))[&quot;Hour&quot;]);
                int minute = int.Parse(((NameValueCollection)ConfigurationManager.GetSection(&quot;JobList/Job&quot;))[&quot;Minute&quot;]);


                ISchedulerFactory schedulerFactory = new StdSchedulerFactory();//内存调度
                _scheduler = schedulerFactory.GetScheduler();

                //创建一个Job来执行特定的任务
                IJobDetail myLogJob = new JobDetailImpl(&quot;myLogJob&quot;, typeof(MyLogJob));
                //创建并定义触发器的规则（每天执行一次时间为：时：分）
               ITrigger trigger =
                   TriggerBuilder.Create()
                       .WithDailyTimeIntervalSchedule(
                          a =&amp;gt; a.WithIntervalInHours(24).OnEveryDay().StartingDailyAt(TimeOfDay.HourAndMinuteOfDay(hour, minute))).Build();
  
                _scheduler.Clear();
                //将创建好的任务和触发规则加入到Quartz中
                _scheduler.ScheduleJob(myLogJob, trigger);
                //开始
                _scheduler.Start();

            }
            catch (Exception ex)
            {
                _Logger.Info(ex.Message);
            }
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;quartz-api&quot;&gt;Quartz API&lt;/h2&gt;
&lt;p&gt;Quartz API的关键接口和类是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IScheduler&lt;/code&gt; - 与调度程序交互的主要API。&lt;br/&gt;-&lt;code&gt;IJob&lt;/code&gt;- 您希望由调度程序执行的组件实现的接口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IJobDetail&lt;/code&gt; - 用于定义作业的实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ITrigger&lt;/code&gt;- 定义执行给定Job的时间表的组件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JobBuilder&lt;/code&gt; - 用于定义/构建&lt;code&gt;obDetail&lt;/code&gt;实例，它定义了&lt;code&gt;Jobs&lt;/code&gt;的实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TriggerBuilder&lt;/code&gt;- 用于定义/构建触发器实例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个调度程序的生命周期是由它为界的创作，通过&lt;code&gt;SchedulerFactory&lt;/code&gt;和其有关方法的调用。一旦创建了&lt;code&gt;IScheduler&lt;/code&gt;接口，就可以使用添加，删除和列出作业和触发器，并执行其他与调度相关的操作（例如暂停触发器）。但是，调度程序不会实际上对任何触发器（执行作业）执行操作，直到使用&lt;code&gt;Start（）&lt;/code&gt;方法启动它。&lt;/p&gt;
&lt;p&gt;构建作业定义的代码块使用使用流畅接口的&lt;code&gt;JobBuilder&lt;/code&gt;创建产品&lt;code&gt;IJobDetail&lt;/code&gt;。同样，构建触发器的代码块使用&lt;code&gt;TriggerBuilder&lt;/code&gt;流畅的接口和特定于触发器类型的扩展方法。可能的时间延长方法是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;WithCalendarIntervalSchedule&lt;/li&gt;
&lt;li&gt;WithCronSchedule&lt;/li&gt;
&lt;li&gt;WithDailyTimeIntervalSchedule&lt;/li&gt;
&lt;li&gt;WithSimpleSchedule&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-8a2edc64f677db79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例中的&lt;code&gt;ITrigger&lt;/code&gt;其实可以不读取配置信息的。这就是我说的不用配置&lt;code&gt;Web.config&lt;/code&gt;也可以。效果如下，每隔10秒执行一次。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  ITrigger trigger =
                TriggerBuilder.Create()
                    .WithDailyTimeIntervalSchedule(
                        a =&amp;gt; a.WithIntervalInSeconds(10)).Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;工作和触发器&quot;&gt;工作和触发器&lt;/h2&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public class MyLogJob : JobBase, ITransientDependency
    {
        public ILogger _Logger { get; set; }
        public MyLogJob()
        {
            _Logger = NullLogger.Instance;

        }

        public override void Execute(IJobExecutionContext context)
        {
            try
            {
                _Logger.Info(&quot;QuartzJob 任务开始运行&quot;);

                for (int i = 0; i &amp;lt; 10; i++)
                {
                    _Logger.InfoFormat(&quot;QuartzJob 正在运行{0}&quot;, i);
                }

                _Logger.Info(&quot;QuartzJob任务运行结束&quot;);
            }
            catch (Exception ex)
            {
                _Logger.Error(&quot;运行异常:&quot;+ex.Message, ex);
            }

        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当作业的触发器触发，&lt;code&gt;Execute（..）&lt;/code&gt;方法由调度程序的工作线程之一调用。传递给此方法的&lt;code&gt;JobExecutionContext&lt;/code&gt;对象为作业实例提供有关其“运行时”环境的信息 （ 调度程序执行的逻辑），触发执行的触发器的逻辑。&lt;br/&gt;&lt;code&gt;JobDetail&lt;/code&gt;对象是在&lt;code&gt;Job&lt;/code&gt;添加到调度器时由&lt;code&gt;Quartz.NET&lt;/code&gt;客户端创建的。它包含Job的各种属性设置，以及一个&lt;code&gt;JobDataMap&lt;/code&gt;，它可以用来存储作业类的给定实例的状态信息&lt;br/&gt;触发器对象用于触发作业的执行（或“触发”）。当你想安排一个工作，你实例化一个触发器并“调整”它的属性来提供你想要的调度。触发器也可能有一个与它们相关的&lt;code&gt;JobDataMap&lt;/code&gt;- 这对于传递参数到一个特定于触发器的触发的&lt;code&gt;Job&lt;/code&gt;是很有用的。&lt;code&gt;Quartz&lt;/code&gt;提供了一些不同的触发器类型，但最常用的类型是&lt;code&gt;SimpleTrigger&lt;/code&gt;（接口&lt;code&gt;ISimpleTrigger&lt;/code&gt;）和&lt;code&gt;CronTrigger&lt;/code&gt;（接口&lt;code&gt;ICronTrigger&lt;/code&gt;）。&lt;br/&gt;如果您需要“一次性”执行（在某个特定时间只执行一项作业），或者您需要在给定时间开始工作，并且重复执行N次，&lt;code&gt;SimpleTrigger&lt;/code&gt;会很方便的T之间执行。如果您希望基于类似日历的时间表（例如“每个星期五，中午”或“每个月的第10天的10:15”）触发，则&lt;code&gt;CronTrigger&lt;/code&gt;非常有用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class UserInfoController : ABPCMSControllerBase
    {

        private readonly ISystemSchedulerService _iSystemSchedulerService;
        public UserInfoController(ISystemSchedulerService iSystemSchedulerService)
        {

            _iSystemSchedulerService = iSystemSchedulerService;
        }

        [HttpGet]
        [DontWrapResult]
        public async Task&amp;lt;ActionResult&amp;gt; GetUserInfo()
        {
            _iSystemSchedulerService.StartScheduler();
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们在前台控制器里面调用&lt;code&gt;ISystemSchedulerService&lt;/code&gt;的&lt;code&gt;StartScheduler()&lt;/code&gt;方法。然后运行项目。&lt;br/&gt;然后我们打开日志&lt;code&gt;Web\App_Data\Logs\Logs.txt&lt;/code&gt;，看下效果：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-93584f921001cbfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;每隔十秒钟执行一次。&lt;/p&gt;

&lt;p&gt;ABP有內建的持久化后台job队列和后台&lt;code&gt;worker&lt;/code&gt;系统。如果对于后台workers你有更高级的计划安排需求，&lt;code&gt;Quartz&lt;/code&gt;会是一个更好的选择。对于持久化后台job队列，&lt;code&gt;Hangfire&lt;/code&gt;也是一个好的选择。&lt;br/&gt;ABP中Quartz应用其实蛮简单的。&lt;/p&gt;
&lt;ol readability=&quot;10.41935483871&quot;&gt;&lt;li&gt;首先&lt;a href=&quot;https://www.nuget.org/packages/Abp.Quartz&quot;&gt;Abp.Quartz&lt;/a&gt; nuget包&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;然后加上引入到项目中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   [DependsOn(
 typeof(AbpQuartzModule)
    )]
  public class ABPCMSWebModule : AbpModule
{ 
 }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;创建Jobs&lt;br/&gt;　这里我们就用上面例子中的job,当然创建一个新job，你可以实现&lt;code&gt;Quartz&lt;/code&gt;的&lt;code&gt;IJob&lt;/code&gt;接口，或者继承&lt;code&gt;JobBase&lt;/code&gt;类（定义在Abp.Quartz包），这个类包含一些帮助属性和方法（例如日志和本地化）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyLogJob : JobBase, ITransientDependency
{
public override void Execute(IJobExecutionContext context)
{
    Logger.Info(&quot;Executed MyLogJob :)&quot;);
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.创建调度作业&lt;br/&gt;&lt;code&gt;IQuartzScheduleJobManager&lt;/code&gt;接口被用来创建调度作业。你可以在类中注入该接口(或者你可以在你的模块的&lt;code&gt;PostInitialize&lt;/code&gt;方法中解析和使用它)来调度作业。这里我们把之前创建的MyLogJob引用进来。&lt;br/&gt;效果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public async Task&amp;lt;ActionResult&amp;gt; ScheduleJob()
    {
        await _jobManager.ScheduleAsync&amp;lt;MyLogJob&amp;gt;(
            job =&amp;gt;
            {
                job.WithIdentity(&quot;MyLogJobIdentity&quot;, &quot;MyGroup&quot;)
                    .WithDescription(&quot;A job to simply write logs.&quot;);
            },
            trigger =&amp;gt;
            {
                trigger.StartNow()
                    .WithSimpleSchedule(schedule =&amp;gt;
                    {
                        schedule.RepeatForever()
                            .WithIntervalInSeconds(5)
                            .Build();
                    });
            });
        _jobManager.Start();
        return Content(&quot;OK, scheduled!&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果一样。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-cac10edec023c2c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;经过上面四步，就完成Abp.Quartz运用，是挺简单的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;p&gt;####SimpleTrigger&lt;/p&gt;
&lt;p&gt;说一下&lt;code&gt;SimpleTrigger&lt;/code&gt;，&lt;code&gt;WithCronSchedule（）&lt;/code&gt;这里有三种方式，&lt;strong&gt;一种就是上面说到的&lt;code&gt;Web.config&lt;/code&gt;配置，一种是&lt;code&gt;WithCronSchedule&lt;/code&gt;设置时间参数。还有一种是&lt;code&gt;WithCronSchedule(&quot;&quot;)&lt;/code&gt; 拥有强大的&lt;code&gt;Cron&lt;/code&gt;时间表达式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SimpleTrigge&lt;/code&gt;r应满足你的日程安排需求，如果你需要在某个特定时刻及时执行一次作业，或者在特定时间执行一次，然后在特定时间间隔重复执行。如果你想让触发器在2018年1月13日上午11点23分54秒执行，然后再执行5次，每10秒执行一次。&lt;/p&gt;
&lt;p&gt;通过这个描述，你可能不会觉得奇怪的是，&lt;code&gt;SimpleTrigger&lt;/code&gt;的属性包括：开始时间和结束时间，重复计数和重复间隔。所有这些属性都与您所期望的完全相同，只有一些与结束时间属性相关的特殊注释。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SimpleTrigger&lt;/code&gt;实例是使用&lt;code&gt;TriggerBuilder&lt;/code&gt;（用于触发器的主属性）和&lt;code&gt;WithSimpleSchedule&lt;/code&gt;扩展方法（用于&lt;code&gt;SimpleTrigger&lt;/code&gt;特有的属性）构建的。&lt;/p&gt;
&lt;p&gt;在特定的时刻建立一个触发器，不要重复：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// trigger builder creates simple trigger by default, actually an ITrigger is returned
ISimpleTrigger trigger = (ISimpleTrigger) TriggerBuilder.Create()
    .WithIdentity(&quot;trigger1&quot;, &quot;group1&quot;)
    .StartAt(myStartTime) // some Date 
    .ForJob(&quot;job1&quot;, &quot;group1&quot;) // identify job with name, group strings
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立一个特定时刻的触发器，然后每十秒钟重复十次：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trigger = TriggerBuilder.Create()
    .WithIdentity(&quot;trigger3&quot;, &quot;group1&quot;)
    .StartAt(myTimeToStartFiring) // if a start time is not given (if this line were omitted), &quot;now&quot; is implied
    .WithSimpleSchedule(x =&amp;gt; x
        .WithIntervalInSeconds(10)
        .WithRepeatCount(10)) // note that 10 repeats will give a total of 11 firings
    .ForJob(myJob) // identify job with handle to its JobDetail itself                   
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立一个触发器，将在未来五分钟内触发一次：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trigger = (ISimpleTrigger) TriggerBuilder.Create()
    .WithIdentity(&quot;trigger5&quot;, &quot;group1&quot;)
    .StartAt(DateBuilder.FutureDate(5, IntervalUnit.Minute)) // use DateBuilder to create a date in the future
    .ForJob(myJobKey) // identify job with its JobKey
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立一个触发器，现在会触发，然后每隔五分钟重复一次，直到22:00：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trigger = TriggerBuilder.Create()
    .WithIdentity(&quot;trigger7&quot;, &quot;group1&quot;)
    .WithSimpleSchedule(x =&amp;gt; x
        .WithIntervalInMinutes(5)
        .RepeatForever())
    .EndAt(DateBuilder.DateOf(22, 0, 0))
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立一个触发器，将在下一个小时的顶部执行，然后每2小时重复一次：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trigger = TriggerBuilder.Create()
    .WithIdentity(&quot;trigger8&quot;) // because group is not specified, &quot;trigger8&quot; will be in the default group
    .StartAt(DateBuilder.EvenHourDate(null)) // get the next even-hour (minutes and seconds zero (&quot;00:00&quot;))
    .WithSimpleSchedule(x =&amp;gt; x
        .WithIntervalInHours(2)
        .RepeatForever())
    // note that in this example, 'forJob(..)' is not called 
    //  - which is valid if the trigger is passed to the scheduler along with the job  
    .Build();

await scheduler.scheduleJob(trigger, job);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外一些常用的停止作业的指令常量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MisfireInstruction.IgnoreMisfirePolicy&lt;/li&gt;
&lt;li&gt;MisfirePolicy.SimpleTrigger.FireNow&lt;/li&gt;
&lt;li&gt;MisfirePolicy.SimpleTrigger.RescheduleNowWithExistingRepeatCount&lt;/li&gt;
&lt;li&gt;MisfirePolicy.SimpleTrigger.RescheduleNowWithRemainingRepeatCount&lt;/li&gt;
&lt;li&gt;MisfirePolicy.SimpleTrigger.RescheduleNextWithRemainingCount&lt;/li&gt;
&lt;li&gt;MisfirePolicy.SimpleTrigger.RescheduleNextWithExistingCount&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在构建SimpleTriggers时，可以将简单的时间表（通过SimpleSchedulerBuilder）指定为停止作业指令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trigger = TriggerBuilder.Create()
    .WithIdentity(&quot;trigger7&quot;, &quot;group1&quot;)
    .WithSimpleSchedule(x =&amp;gt; x
        .WithIntervalInMinutes(5)
        .RepeatForever()
        .WithMisfireHandlingInstructionNextWithExistingCount())
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cron时间表达式&quot;&gt;Cron时间表达式。&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Cron-Expressions&lt;/code&gt;用于配置&lt;code&gt;CronTrigger&lt;/code&gt;的实例。&lt;code&gt;Cron-Expressions&lt;/code&gt;是由七个子表达式组成的字符串，它们描述了计划的各个细节。这些子表达式用空格分隔，表示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Seconds&lt;/li&gt;
&lt;li&gt;Minutes&lt;/li&gt;
&lt;li&gt;Hours&lt;/li&gt;
&lt;li&gt;Day-of-Month&lt;/li&gt;
&lt;li&gt;Month&lt;/li&gt;
&lt;li&gt;Day-of-Week&lt;/li&gt;
&lt;li&gt;Year (optional field)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例Cron表达式&lt;br/&gt;下面是一些表达式及其含义的例子 - 你可以在&lt;code&gt;CronTrigger&lt;/code&gt;的API文档中找到更多的例子&lt;br/&gt;CronTrigger示例1 - 创建一个触发器的表达式，每5分钟触发一次&lt;br/&gt;&lt;code&gt;&quot;0 0/5 * * * ?&quot;&lt;/code&gt;&lt;br/&gt;CronTrigger示例2 - 一个表达式，用于创建在分钟后10秒（即上午10:00:10，上午10:05:10等）每5分钟触发一次的触发器。&lt;br/&gt;&lt;code&gt;&quot;10 0/5 * * * ?&quot;&lt;/code&gt;&lt;br/&gt;CronTrigger示例3 - 一个表达式，用于在每个星期三和星期五的10:30，11:30，12:30和13:30创建一个触发器。&lt;br/&gt;&lt;code&gt;&quot;0 30 10-13 ? * WED,FRI&quot;&lt;/code&gt;&lt;br/&gt;CronTrigger示例4 - 一个表达式，用于创建一个触发器，在每个月的第5天和第20天的上午8点到上午10点之间每隔半小时触发一次。请注意，触发器不会在上午10点，仅在8点，8点，9点和9点30分&lt;br/&gt;&lt;code&gt;&quot;0 0/30 8-9 5,20 * ?&quot;&lt;/code&gt;&lt;br/&gt;请注意，一些调度要求过于复杂，无法用一个触发器来表示 - 例如“上午9点至上午10点之间每5分钟一次，下午1点至10点之间每20分钟一次”。在这种情况下解决方案是简单地创建两个触发器，并注册他们两个运行相同的工作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CronTrigger&lt;/code&gt;实例使用&lt;code&gt;TriggerBuilder&lt;/code&gt;（用于触发器的主属性）和&lt;code&gt;WithCronSchedule&lt;/code&gt;扩展方法（用于&lt;code&gt;CronTrigger&lt;/code&gt;特定的属性）构建。&lt;br/&gt;您也可以使用&lt;code&gt;CronScheduleBuilder&lt;/code&gt;的静态方法来创建计划。&lt;br/&gt;建立一个触发器，每隔上午8点到下午5点，每隔一分钟一次：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trigger = TriggerBuilder.Create()
    .WithIdentity(&quot;trigger3&quot;, &quot;group1&quot;)
    .WithCronSchedule(&quot;0 0/2 8-17 * * ?&quot;)
    .ForJob(&quot;myJob&quot;, &quot;group1&quot;)
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立一个触发器，每天在上午10:42开始：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// we use CronScheduleBuilder's static helper methods here
trigger = TriggerBuilder.Create()
    .WithIdentity(&quot;trigger3&quot;, &quot;group1&quot;)
    .WithSchedule(CronScheduleBuilder.DailyAtHourAndMinute(10, 42))
    .ForJob(myJobKey)
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要么 -&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trigger = TriggerBuilder.Create()
    .WithIdentity(&quot;trigger3&quot;, &quot;group1&quot;)
    .WithCronSchedule(&quot;0 42 10 * * ?&quot;)
    .ForJob(&quot;myJob&quot;, &quot;group1&quot;)
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立一个触发器，将在星期三上午10:42，在系统默认的时区以外的其他时间触发：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trigger = TriggerBuilder.Create()
    .WithIdentity(&quot;trigger3&quot;, &quot;group1&quot;)
    .WithSchedule(CronScheduleBuilder
        .WeeklyOnDayAndHourAndMinute(DayOfWeek.Wednesday, 10, 42)
        .InTimeZone(TimeZoneInfo.FindSystemTimeZoneById(&quot;Central America Standard Time&quot;)))
    .ForJob(myJobKey)
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要么 -&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trigger = TriggerBuilder.Create()
    .WithIdentity(&quot;trigger3&quot;, &quot;group1&quot;)
    .WithCronSchedule(&quot;0 42 10 ? * WED&quot;, x =&amp;gt; x
        .InTimeZone(TimeZoneInfo.FindSystemTimeZoneById(&quot;Central America Standard Time&quot;)))
    .ForJob(myJobKey)
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下指令可用于通知&lt;code&gt;Quartz&lt;/code&gt;在&lt;code&gt;CronTrigger&lt;/code&gt;发生停止作业时应该执行的操作。（本教程的“更多关于触发器”部分介绍了停止作业情况）。这些指令被定义为常量（并且API文档具有对其行为的描述）。说明包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MisfireInstruction.IgnoreMisfirePolicy&lt;/li&gt;
&lt;li&gt;MisfireInstruction.CronTrigger.DoNothing&lt;/li&gt;
&lt;li&gt;MisfireInstruction.CronTrigger.FireOnceNow&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所有触发器都有&lt;code&gt;MisfireInstrution.SmartPolicy&lt;/code&gt;指令可供使用，并且此指令也是所有触发器类型的默认值。&lt;code&gt;CronTrigger&lt;/code&gt;将“智能策略”指令解释为&lt;code&gt;MisfireInstruction.CronTrigger.FireOnceNow。CronTrigger.UpdateAfterMisfire（）&lt;/code&gt;方法的API文档解释了此行为的确切详细信息。&lt;br/&gt;在构建CronTriggers时，您可以将缺火指令指定为cron时间表的一部分（通过WithCronSchedule扩展方法）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;trigger = TriggerBuilder.Create()
    .WithIdentity(&quot;trigger3&quot;, &quot;group1&quot;)
    .WithCronSchedule(&quot;0 0/2 8-17 * * ?&quot;, x =&amp;gt; x
        .WithMisfireHandlingInstructionFireAndProceed())
    .ForJob(&quot;myJob&quot;, &quot;group1&quot;)
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;我们可以看一下，源码中对&lt;code&gt;IQuartzScheduleJobManager&lt;/code&gt;的&lt;code&gt;ScheduleAsync&lt;/code&gt;方法的封装，其实就是&lt;code&gt;Scheduler.ScheduleJob&lt;/code&gt;处理了一下。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-f37fdcf1904e3997.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果要使用模块的&lt;code&gt;PostInitialize&lt;/code&gt;方法中解析和使用它来调度作业，也是可以的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using System.Reflection;
using Abp.Dependency;
using Abp.Modules;
using Abp.Quartz.Configuration;
using Abp.Threading.BackgroundWorkers;
using Quartz;

namespace Abp.Quartz
{
    [DependsOn(typeof (AbpKernelModule))]
    public class AbpQuartzModule : AbpModule
    {
        public override void PreInitialize()
        {
            IocManager.Register&amp;lt;IAbpQuartzConfiguration, AbpQuartzConfiguration&amp;gt;();

            Configuration.Modules.AbpQuartz().Scheduler.JobFactory = new AbpQuartzJobFactory(IocManager);
        }

        public override void Initialize()
        {
            IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
        }

        public override void PostInitialize()
        {
            IocManager.RegisterIfNot&amp;lt;IJobListener, AbpQuartzJobListener&amp;gt;();

            Configuration.Modules.AbpQuartz().Scheduler.ListenerManager.AddJobListener(IocManager.Resolve&amp;lt;IJobListener&amp;gt;());

            if (Configuration.BackgroundJobs.IsJobExecutionEnabled)
            {
                IocManager.Resolve&amp;lt;IBackgroundWorkerManager&amp;gt;().Add(IocManager.Resolve&amp;lt;IQuartzScheduleJobManager&amp;gt;());
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;JobBase&lt;/code&gt;封装的一些方法，继承自&lt;code&gt;IJob&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6855212-6d7f0e34543a7b3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/anyushengcms/p/7325126.html&quot;&gt;ABP+AdminLTE+Bootstrap Table权限管理系统一期&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/Jimmey-Jiang/ABP-ASP.NET-Boilerplate-Project-CMS&quot;&gt;Github:https://github.com/Jimmey-Jiang/ABP-ASP.NET-Boilerplate-Project-CMS&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 14 Dec 2017 06:34:00 +0000</pubDate>
<dc:creator>安于生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/anyushengcms/p/8037569.html</dc:identifier>
</item>
<item>
<title>掌握NIO，程序人生 - 一面千人</title>
<link>http://www.cnblogs.com/Evsward/p/nio.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Evsward/p/nio.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;就像新IO为java带来的革新那样，让我们也开启一段新的程序人生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关键字：NIO，BIO，伪IO，AIO，多路复用选择器，通道，缓冲区，jdk研究，回调函数，高并发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;java.nio-概述&quot;&gt;java.nio 概述&lt;/h2&gt;
&lt;h3 id=&quot;历史背景&quot;&gt;历史背景&lt;/h3&gt;
&lt;p&gt;在java nio出现之前，java网络IO是只有输入输出流操作的基于同步阻塞的Socket编程，这在实际应用中效率低下，因此当时高性能服务器开发领域一直被拥有更接近UNIX操作系统的Channel概念的C++和C长期占据。我们知道现代操作系统的根源都是来自于UNIX系统，它代表了操作系统层面底层的平台支撑，在UNIX网络编程中，它的IO模型包括阻塞IO，非阻塞IO，IO复用，信号驱动IO以及异步IO，对于他们的具体解释这里不便展开，未来如果有机会介绍UNIX网络编程再来详叙。总之，平台底层是支持多种IO模型的，而当时的java只有阻塞IO这么一种，这也是编码最容易实现的一种，但却极大的限制了java在服务端的发展。java为了获得更高的性能表现，在jdk1.4版本增加了对异步IO模型的支持，提高了java的高性能IO处理能力，今天java已经逐渐取代C++成为了企业服务端应用开发的首选语言。java新增的这部分类库就是java nio。&lt;/p&gt;
&lt;h3 id=&quot;jdk1.6的nio源码结构&quot;&gt;jdk1.6的nio源码结构&lt;/h3&gt;
&lt;p&gt;java.nio.*包中引入了新的java io类库，旨在提高速度，实际上旧的IO已经使用nio重新实现过，以便充分利用这种速度的提高，因此，即使我们不显式地用nio编写代码，也能获得受益效果。速度的提高在文件IO和网络IO中都有可能发生，概述部分结束以后我们会分别介绍。首先我们来看jdk 1.6的源码，分析一下java.nio相关的结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.nio 
java.nio.channels 
~~java.nio.channels.spi ~~
java.nio.charset 
~~java.nio.charset.spi ~~&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;spi&quot;&gt;spi&lt;/h3&gt;
&lt;p&gt;那两个spi结尾的都是相关的提供者服务类，可以参考&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/localizer.html#%E6%8F%90%E4%BE%9B%E8%80%85%E6%A8%A1%E5%BC%8F&quot;&gt;前面讲解提供者模式的文章&lt;/a&gt;，简单来说就是，java.nio.channels.spi包是用于服务/决定/改变java.nio.channels对象的，同样的，java.nio.charset.spi包是用于服务/决定/改变java.nio.charset对象的。我们在官方文档上也能够看到，这两个spi包都是&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;java.nio.channels.spi: 只有那些定义新的选择器提供者的开发人员才应直接使用此包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;java.nio.charset.spi: 只有定义新charset的开发人员才需要直接使用此包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们没有开发新的charset和selector的需求，因此spi包可以忽略掉。&lt;/p&gt;
&lt;h3 id=&quot;nio包&quot;&gt;nio包&lt;/h3&gt;
&lt;h4 id=&quot;缓冲区&quot;&gt;①缓冲区&lt;/h4&gt;
&lt;p&gt;nio包定义了作为数据容器的缓冲区，以及作为其他nio包的父类。主要是java.nio.Buffer类，以及它的子类。再加上一个java.nio.ByteOrder，它是一个字节顺序的类型安全枚举。（TODO:接下来会有专门介绍枚举的文章）&lt;/p&gt;
&lt;p&gt;Buffer是一个对象，它包含一些写入或要读出的数据，这与旧IO最大的不同在于旧IO将数据直接读写到流对象中，少了这一个中间层。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在NIO中所有数据读写都用Buffer处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;缓冲区实质上是一个数组，通常它是一个字节数组——ByteBuffer，也可以是其他数据类型的数组。同时缓冲区还提供了对数据结构化访问以及维护读写位置等信息。对于这些不同数据类型的Buffer类，他们都有相同的操作，只有ByteBuffer提供了更多的一些直接操作通道的方法。&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;这些Buffer类（Buffer类以及它的子类）定义了一个用于通过IO发送特定基本类型具体数据的有序线性表结构的容器，除了boolean，覆盖了：byte, short, int, long, float, double 和 char。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特别的是，ByteBuffer类存在一个单独的子类：MappedByteBuffer类。此类用特定于内存映射文件区域的操作扩展了ByteBuffer类，可用于内存映射文件的I/O 操作。&lt;/p&gt;
&lt;h3 id=&quot;channels包&quot;&gt;channels包&lt;/h3&gt;
&lt;p&gt;该包定义了各种通道，这些通道表示到能够执行I/O操作的实体（如文件和套接字）的连接；定义了用于多路复用的、非阻塞I/O操作的选择器。&lt;/p&gt;
&lt;h4 id=&quot;通道&quot;&gt;①通道&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;NIO所有网络IO都是通过Channel。举例来讲，如果通道是一条传送带，那上面的不同形状的箱子就是缓冲区Buffer，而箱子内部装有的才是真正的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本上，所有的NIO都是从一个Channel开始，数据可以从缓冲区传输到通道，也可以从通道传输到缓冲区。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;全双工：通道与流的不同之处在于流是定向的，半双工的，InputStream只能是输入流，只可以读取数据；OutputStream是输出流，只能写入数据。没有一种既能写又能读的，但是通道可以，通道是双向的。Channels的设计更接近底层操作系统，因为操作系统的通道就是全双工的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是包中的通道相关类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Channels：针对信道和流的实用工具方法。&lt;/li&gt;
&lt;li&gt;DatagramChannel：基于UDP数据报的网络IO通道&lt;/li&gt;
&lt;li&gt;FileChannel：读取、写入、映射和操作文件IO通道&lt;/li&gt;
&lt;li&gt;FileChannel.MapMode：文件映射模式的类型安全的枚举。&lt;/li&gt;
&lt;li&gt;FileLock：表示文件区域锁定的标记。&lt;/li&gt;
&lt;li&gt;Pipe：实现单向管道传送的通道对，一个可写入的sink通道和一个可读取的source通道。&lt;/li&gt;
&lt;li&gt;Pipe.SinkChannel：一个可写入的sink通道。&lt;/li&gt;
&lt;li&gt;Pipe.SourceChannel：一个可读取的source通道。&lt;/li&gt;
&lt;li&gt;ServerSocketChannel：类似于ServerSocket的基于TCP流的网络IO编程的服务端通道&lt;/li&gt;
&lt;li&gt;SocketChannel：类似于Socket的基于TCP流的网络IO编程的客户端通道&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通道总体上来讲，可以分为两大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;网络IO：SelectableChannel&lt;/li&gt;
&lt;li&gt;文件IO：FileChannel&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据上一篇&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/socket.html&quot;&gt;介绍TCP和UDP的socket编程&lt;/a&gt;，我们可以看出这些通道有着自己的一套基于TCP和UDP的Socket编程。其实Socket虽然没有在IO包中，但它是网络IO，也属于IO总范畴，通道中还有一个在&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/io.html#%E4%B8%80file-%E6%96%87%E4%BB%B6%E6%B5%81-randomaccessfile&quot;&gt;IO中介绍过的用于文件IO&lt;/a&gt;的通道FileChannel。所以，以上内容除了管道以外，我们在之前的IO或Socket中都有过研究，可以作为我们在nio包中继续研究他们的基础。&lt;/p&gt;
&lt;p&gt;至于管道，这是我们&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/io.html#java-io%E5%9F%BA%E7%A1%80%E7%9A%84%E6%80%BB%E7%BB%93&quot;&gt;在IO中留的坑&lt;/a&gt;，本篇文章来填。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们之前说管道处理的是进程间的通信，实际上网络编程中客户端和服务端也是通过端口进行端到端通信，也属于两个进程间的通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;选择器&quot;&gt;②选择器&lt;/h4&gt;
&lt;p&gt;选择器Selector是NIO编程的基础，它是多路复用的、支持非阻塞IO操作的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;多路复用器提供选择已就绪任务的能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Selector会不断地监听（通过轮询的手段）注册在其上的Channel，如果某个Channel上面发生事件（比如：连接打开，数据到达），这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可获取就绪Channel的集合，进行后续IO操作。一个Selector可以同时轮询多个Channel，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是包中的选择器相关类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SelectableChannel：可通过Selector实现多路复用的通道。&lt;/li&gt;
&lt;li&gt;SelectionKey：表示SelectableChannel在Selector中的注册的标记。&lt;/li&gt;
&lt;li&gt;Selector：SelectableChannel对象的多路复用器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们来分别认识一下多路复用和非阻塞IO：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多路复用：在IO编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者IO多路复用技术进行处理。简单来说多路复用技术是与多线程同级的，解决差不多问题的技术，它通过把多个IO的阻塞复用到同一个select的阻塞上，使得系统在单线程的情况下可同时处理多个客户端请求。与传统的多线程/多进程相比，IO多路复用的优势是系统开销小，不需要创建和维护新的线程。&lt;/li&gt;
&lt;li&gt;非阻塞IO：nio之前，io操作都是同步阻塞IO（BIO），上面也讲过了，存在性能和可靠性的瓶颈。
&lt;ul&gt;&lt;li&gt;BIO最主要的问题在于每当有一个新客户端请求接入时，服务端必须创建一个新的线程处理新接入的客户端链路，线程与客户端连接是一对一的关系，当有线程处于阻塞状态，cpu就要频繁使用上下文切换去更换到有效线程，然而上下文切换是一个比较消耗资源的操作，它要将当前线程的所有的上下文环境基础复制到另外一个有效的线程上去继续执行新的IO请求，而当多个线程阻塞时，cpu会无意义的在多个线程直接做上下文切换，在高性能服务器应用领域，往往要面向成千上万个客户端的并发连接，这种模型显然无法满足高性能、高并发接入的场景。&lt;/li&gt;
&lt;li&gt;伪异步IO，我们&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/socket.html#%E9%AB%98%E7%BA%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0&quot;&gt;在IO中介绍的线程池&lt;/a&gt;虽然限制了线程的最大连接数，但是底层仍旧是基于BIO实现的，所以被称为伪异步IO。&lt;/li&gt;
&lt;li&gt;BIO源码的阻塞，我们知道ServerSocket的accept方法会阻塞一个线程直到新的客户端连入，除此之外，流操作中的InputStream的read方法和OutputStream的write方法在读取操作过程中都会引发同步阻塞问题，阻塞的时间取决于对方IO线程的处理速度和网络IO的处理速度，本质上讲，这些对方的环境问题我们并没办法去保证。&lt;/li&gt;
&lt;li&gt;非阻塞IO（Non-block IO），它的缩写也为NIO，这与New IO其实并无区别，因为New IO就是增加的对Non-block IO的支持，因此我们说NIO可以是New IO，也可以是Non-block IO，不要太在意这方面的困惑。NIO通过对通道的阻塞行为的配置，可以实现非阻塞的通道，使得线程在等待时（旧IO中的阻塞）可以同时做其他事情，实现了线程的异步操作。
&lt;ul&gt;&lt;li&gt;NIO相对于BIO来讲，虽然提供了高性能，高并发的支持，但是它也带来了较高的编程复杂度。&lt;/li&gt;
&lt;li&gt;如果是低负载、低并发的应用程序大可使用BIO，而不要一味赶NIO的时髦。&lt;/li&gt;
&lt;li&gt;由一个专门的线程来负责处理分发所有的IO事件。&lt;/li&gt;
&lt;li&gt;把整个IO任务切换成多个小任务，通过任务间协作完成。&lt;/li&gt;
&lt;li&gt;事务驱动：只有IO事件到的时候才去处理，而不是时刻保持监视事件。&lt;/li&gt;
&lt;li&gt;线程通讯：通过notify和wait等方式通信，保证每次的上下文切换是有意义的，减少无意义的切换。&lt;/li&gt;
&lt;li&gt;通过增加Pipe、Channel、Buffer和Selector等很多UNIX网络编程的概念，NIO实现了非阻塞IO，所以这是一个递归，在这里引用回了我们本篇博文的主题——NIO。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;nio概述部分就算结束了，继续多说就太浮于表面了，下面针对NIO的几个主要特性进行代码实例的演示。&lt;/p&gt;
&lt;h2 id=&quot;基于tcp的nio实例&quot;&gt;基于TCP的NIO实例&lt;/h2&gt;
&lt;p&gt;下面我们先分别介绍一下基于TCP的NIO的服务端和客户端的编写流程。&lt;/p&gt;
&lt;h3 id=&quot;基于tcp的nio服务端的编写流程&quot;&gt;基于TCP的NIO服务端的编写流程&lt;/h3&gt;
&lt;p&gt;直接通过代码来展示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * nio服务端与io的ServerSocket的编写流程极为相似，nio包已经封装好相关方法。
     */
    public void seqNio() throws IOException {
        // 1，open服务端Socket通道。
        ServerSocketChannel ssc = ServerSocketChannel.open();
        // 2，服务端通道绑定端口。
        ssc.bind(new InetSocketAddress(ipAddress, port));
        ssc.configureBlocking(false);// 设置通道为非阻塞
        // 3，open一个多路复用选择器
        Selector selector = Selector.open();
        new Thread().start();// 开启一个线程用于维护选择器
        // 4，将服务端通道注册到选择器，监听接入操作
        ssc.register(selector, SelectionKey.OP_ACCEPT);
        // 5，选择器轮询它身上的keys
        Set&amp;lt;?&amp;gt; selectKeys = selector.selectedKeys();
        Iterator&amp;lt;?&amp;gt; it = selectKeys.iterator();
        while (it.hasNext()) {
            SelectionKey key = (SelectionKey) it.next();
            System.out.println(key);
            // deal with the I/O event.
        }
        // 6，服务端通道accept处理新客户端请求
        SocketChannel channel = ssc.accept();
        // 7，设置客户端通道属性
        channel.configureBlocking(false);
        channel.socket().setReuseAddress(true);
        // 8，注册客户端通道到选择器，监听读操作。
        channel.register(selector, SelectionKey.OP_READ);
        // 9，直接操作客户端通多进行异步读操作
        ByteBuffer bb = ByteBuffer.allocateDirect(1024);
        channel.read(bb);
        // 10，解码decode读取的信息
        // 11，异步写响应信息回客户端通道
        channel.write(bb);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基于tcp的nio客户端的编写流程&quot;&gt;基于TCP的NIO客户端的编写流程&lt;/h3&gt;
&lt;p&gt;同样直接通过代码来展示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     * 列出大致的TCPNIO客户端的执行顺序
     * 
     * @throws IOException
     */
    public void seqClient() throws IOException {
        // 1,open创建一个客户端通道实例
        SocketChannel sc = SocketChannel.open();
        // 2,设置通道关于TCP的属性
        sc.configureBlocking(false);
        sc.socket().setReuseAddress(true);// 关闭TCP连接时，该连接可能在关闭后的一段时间内保持超时状态
        sc.socket().setSendBufferSize(1024);// 将此Socket的SO_SNDBUF选项设置为指定的值。
        sc.socket().setReceiveBufferSize(1024);// 将此Socket的SO_RCVBUF选项设置为指定的值。
        // 3,open创建一个选择器的实例
        Selector selector = Selector.open();
        // 4,客户端连接服务端（远程主机端口）
        boolean connected = sc.connect(new InetSocketAddress(ipAddress, port));
        if (connected) {
            // 5, 判断连接如果成功，则注册到选择器的读操作位
            sc.register(selector, SelectionKey.OP_READ);
        } else {
            // 6,如果连接不成功，则注册到选择器的连接操作位，监听服务端的TCP的ACK应答
            sc.register(selector, SelectionKey.OP_CONNECT);
        }
        // 7,轮询选择器的keys
        Set&amp;lt;SelectionKey&amp;gt; set = selector.selectedKeys();
        Iterator&amp;lt;SelectionKey&amp;gt; it = set.iterator();
        SelectionKey key = null;
        while (it.hasNext()) {
            key = it.next();
            // 处理io event
            // 8，处理连接
            if (key.isConnectable()) {
                sc.register(selector, SelectionKey.OP_READ);// 连接成功以后就将读操作注册到多路复用选择器上
            } else if (key.isReadable()) {
                // 9，处理数据
                ByteBuffer bb = ByteBuffer.allocate(1024);// 分配1MB缓冲区。
                SocketChannel socketChannel = (SocketChannel) key.channel();
                int readBytes = socketChannel.read(bb);
                if (readBytes &amp;gt; 0) {
                    // 10，解码
                }
                // 11, 将客户端请求写回通道。
                socketChannel.write(bb);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重新构建基于tcp的nio实例&quot;&gt;重新构建基于TCP的NIO实例&lt;/h3&gt;
&lt;p&gt;上面给出了大致的基于TCP的NIO编程的流程，大家不必过于研究他们，下面我们构建实例来说明，会得到更好的学习效果。本打算在之前写过的&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/socket.html#%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%9E%8B&quot;&gt;java TCP socket实例&lt;/a&gt;的基础上进行改造，然而由于客户端等待标准输入就是一个阻塞的过程，这与异步非阻塞的NIO是相悖的，我确实做过尝试，发现一旦客户端阻塞在等待用户输入的位置，整个线程都被迫等待，那么依赖于线程的Selector就不能更好的发挥作用，服务端的响应消息也就永远无法给出。&lt;/p&gt;
&lt;p&gt;换句话说，服务端的响应是无法像socket编程那样写在客户端发送消息以后，同步接收服务端数据，然后再阻塞等待用户新的输入，NIO是通过对key的轮询，这是异步的行为，也就是说客户端发送请求消息与服务端返回响应消息是完全解耦的，不存在同步的顺序执行的关系，所以当我们的线程被客户端的标准输入阻塞，key的轮询异步操作也就完全run不起来了。&lt;/p&gt;
&lt;p&gt;因此，我们采用去掉客户端阻塞代码的方式，重新构建基于TCP的NIO实例：指定客户端请求消息，服务端接收以后返回当前时间作为响应。下面看代码：&lt;/p&gt;
&lt;p&gt;我们在Base里面定义了一些常量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Base {
  protected final static Logger logger = LogManager.getLogger();
  protected static String ipAddress = &quot;127.0.0.1&quot;;
  protected static int port = 23451;
  protected static String TIMEQUERY = &quot;query time&quot;;
  protected final static int BUFFER_SIZE = 1024;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端和服务端的入口都非常简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NIOTCPClient extends Base {
  public static void main(String[] args) {
    new Thread(new ReactorClientHandler(), &quot;nio-client-reactor-001&quot;).start();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class NIOTCPServer extends Base {
  public static void main(String[] args) {
    new Thread(new ReactorServerHandler(), &quot;nio-server-reactor-001&quot;).start();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面分别介绍ReactorClientHandler和ReactorServerHandler。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.IO.nioS;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

import javaS.IO.socketS.Base;

public class ReactorClientHandler extends Base implements Runnable {
  private Selector selector;
  private SocketChannel sc;// 定义一个客户端通道
  private volatile boolean stop;

  /**
   * 构造期间初始化对象，客户端构造函数不做事务操作
   * 
   * @param ip
   * @param port
   */
  public ReactorClientHandler() {
    try {
      selector = Selector.open();
      sc = SocketChannel.open();
      // 设置客户端通道属性以及TCP参数
      sc.configureBlocking(false);
      sc.socket().setSendBufferSize(BUFFER_SIZE);
      sc.socket().setReceiveBufferSize(BUFFER_SIZE);
    } catch (IOException e) {
      e.printStackTrace();
      System.exit(1);
    }

  }

  @Override
  public void run() {
    try {
      // TODO: 连接成功，未考虑重连操作
      doConnect();
    } catch (IOException e) {
      e.printStackTrace();
    }
    while (!stop) {
      try {
        selector.select(1000);
        Set&amp;lt;SelectionKey&amp;gt; set = selector.selectedKeys();
        Iterator&amp;lt;SelectionKey&amp;gt; it = set.iterator();
        SelectionKey key = null;
        // 异步非阻塞单线程轮询多路复用器选择器keys
        while (it.hasNext()) {
          key = it.next();
          it.remove();// 处理一个Key就移除一个，然而在handleInput中还会注册进来读操作
          try {
            handleInput(key);
          } catch (Exception e) {
            if (key != null) {
              // 关闭key
              key.cancel();
              // 关闭在handleInput方法中打开的key的通道
              if (key.channel() != null) {
                key.channel().close();
              }
            }
          }
        }
      } catch (IOException e) {
        e.printStackTrace();
        System.exit(1);
      }
    }

    /**
     * 多路复用器关闭后，所有注册在上面的Channel和Pipe等资源都会被自动去关闭，不需要重复释放资源。
     */
    if (selector != null) {
      try {
        selector.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }

  /**
   * 通过轮询key来处理通道的数据（包括发送请求和接收响应）
   * 
   * @param key
   * @throws IOException
   */
  private void handleInput(SelectionKey key) throws IOException {
    if (key.isValid()) {// 首先判断key是否有效
      SocketChannel sc = (SocketChannel) key.channel();// 用一个客户端通道来接收key的通道
      if (key.isConnectable()) {// 判断是否是连接状态，说明服务端已返回ACK应答消息，但是连接还没有最终建立
        if (sc.finishConnect()) {// 判断是否连接成功，建立成功
          // 注册该客户端通道到多路复用器上，注册读操作位，监听网络读操作
          sc.register(selector, SelectionKey.OP_READ);
          // 发送请求消息给服务端。
          sendReq(sc, TIMEQUERY);
        } else {// 连接失败
          System.exit(1);
        }
      } // 格外注意这里的判断终止符,key的状态如果是Read就不是Connect了，要分开判断。
      if (key.isReadable()) {
        // 读取服务器的应答响应消息，如果客户端接收到了服务端的响应消息，则SocketChannel是可读的。
        ByteBuffer readBuffer = ByteBuffer.allocate(BUFFER_SIZE);// 无法事先判断码流大小，开辟一个1MB的缓冲区
        int readBytes = sc.read(readBuffer);// 此时read为异步非阻塞的，因为我们已经为该通道设置为非阻塞。
        /**
         * 只要涉及异步读，就要判断读取的结果
         */
        if (readBytes &amp;gt; 0) {// 读到了字节，对字节进行编解码。
          readBuffer.flip();// 将缓冲区当前limit设置为position，position设置为0，用于后续对缓冲区的读取操作。
          byte[] bytes = new byte[readBuffer.remaining()];
          readBuffer.get(bytes);
          String body = new String(bytes, &quot;UTF-8&quot;);// 使用UTF-8解码
          logger.info(&quot;服务端的响应消息：&quot; + body);
          this.stop = true;// 得到服务端响应则断开连接线程（线程断了，jvm上面所有的通道，key等资源都自动没了，所以不必去重复释放资源）。
        } else if (readBytes &amp;lt; 0) {// 返回值为-1，链路已关闭，需要手动关闭SocketChannel
          key.cancel();
          sc.close();
        } else {// 没有读到字节，多数情况，忽略。
          ;
        }
      }
    }
  }

  /**
   * 客户端发起连接的操作
   * 
   * @throws IOException
   */
  private void doConnect() throws IOException {
    if (sc.connect(new InetSocketAddress(ipAddress, port))) {
      // 如果已连接，则注册客户端通道的读操作到选择器
      sc.register(selector, SelectionKey.OP_READ);
    } else {
      /**
       * 如果未连接，不代表连接失败，可能还在等待服务端返回TCP握手应答消息， 所以此时注册客户端通道的连接操作到选择器，等候轮询执行连接操作, 当服务端返回TCP
       * syn-ack消息后，Selector就能够轮询到这个SocketChannel处于连接就绪状态
       */
      sc.register(selector, SelectionKey.OP_CONNECT);
    }
  }

  /**
   * 客户端通道发送消息
   * 
   * @param sc
   *          客户端通道
   * @param strReq
   *          待发送消息
   * @throws IOException
   */
  private void sendReq(SocketChannel sc, String strReq) throws IOException {
    byte strBytes[] = strReq.getBytes();
    // 构造请求消息体ByteBuffer，只有通过ByteBuffer才能操作通道发送消息
    ByteBuffer reqBuffer = ByteBuffer.allocate(strBytes.length);// 由于已知码流大小为strBytes.length，所以建立一个一样大的缓冲区
    reqBuffer.put(strBytes);// 将请求的数据放入发送缓冲区（以字节数组的形式）
    reqBuffer.flip();
    sc.write(reqBuffer);
    /**
     * 由于发送请求是异步的，不会一次性全部发送成功，会存在“写半包”的问题， 所以要通过hasRemaining方法对发送结果进行判断，如果缓冲区中消息全部发送完成，则打印发送成字样提示用户。
     */
    if (!reqBuffer.hasRemaining()) {
      logger.info(&quot;客户端请求发送成功！&quot;);
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.IO.nioS;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Date;
import java.util.Iterator;
import java.util.Set;

import javaS.IO.socketS.Base;

/**
 * 基于TCP的NIO服务端多路复用类（多路是基于单线程实现的&quot;多线程&quot;）
 * 
 * 该类实现了Runnable接口，是一个独立的线程，负责轮询多路复用器Selector，可以处理多个客户端的并发接入。
 * 
 * @author Evsward
 *
 */
public class ReactorServerHandler extends Base implements Runnable {
  private Selector selector;
  private ServerSocketChannel servChannel;// 定义一个服务端通道
  private volatile boolean stop;

  /**
   * 初始化多路复用选择器，绑定监听端口。
   * 
   * @param port
   *          监听的端口
   */
  public ReactorServerHandler() {
    try {
      // 初始化对象
      selector = Selector.open();// 通过静态方法open创建一个Selector实例。
      servChannel = ServerSocketChannel.open();// 通过静态方法open创建一个ServerSocketChannel实例，
      servChannel.configureBlocking(false);// 设置ServerSocketChannel通道为非阻塞。
      // 开始事务操作
      servChannel.socket().bind(new InetSocketAddress(ipAddress, port), BUFFER_SIZE);// 通道绑定并监听IP和端口，允许接入最多1024个连接。
      servChannel.register(selector, SelectionKey.OP_ACCEPT);// 服务器通道注册到多路复用选择器上。
      logger.info(&quot;server is listening in port: &quot; + port);
    } catch (IOException e) {
      e.printStackTrace();
      System.exit(1);
    }
  }

  // 向外部提供一个停止监听的方法。
  public void stop() {
    this.stop = true;
  }

  @Override
  public void run() {
    while (!stop) {
      try {
        selector.select(1000);// 设置休眠时间1s，每隔1s运行一次，也可以无参，当有就绪Channel时触发执行，从而实现网络的异步读写操作
        // 多路复用器轮询Keys
        Set&amp;lt;SelectionKey&amp;gt; selectedKeys = selector.selectedKeys();
        Iterator&amp;lt;SelectionKey&amp;gt; it = selectedKeys.iterator();
        SelectionKey key = null;
        while (it.hasNext()) {
          key = it.next();
          it.remove();// 处理key以后，移除该key
          try {
            handleInput(key);
          } catch (IOException e) {
            if (key != null) {
              key.cancel();
              if (key.channel() != null) {
                key.channel().close();
              }
            }
          }
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }

  /**
   * 通过SelectionKey来处理客户端请求以及响应。
   * 
   * @param key
   *          通道注册在选择器上的key
   */
  private void handleInput(SelectionKey key) throws IOException {
    if (key.isValid()) {
      // 处理新接入的请求消息
      if (key.isAcceptable()) {
        // 用一个服务端通道来接收key的通道
        ServerSocketChannel ssc = (ServerSocketChannel) key.channel();
        // accept 新连接（创建新通道相当于TCP三次握手，建立TCP物理链路，但并不创建新线程）
        SocketChannel sc = ssc.accept();
        sc.configureBlocking(false);
        // 增加客户端通道到选择器，注意：服务端通道都是OP_ACCEPT操作位，客户端通道都是OP_READ操作位。
        sc.register(selector, SelectionKey.OP_READ);
      }
      if (key.isReadable()) {
        // 读取客户端的请求消息
        SocketChannel sc = (SocketChannel) key.channel();
        ByteBuffer readBuffer = ByteBuffer.allocate(BUFFER_SIZE);// 开辟一个1MB的缓冲区
        int readBytes = sc.read(readBuffer);// 此时read为非阻塞的，因为我们已经为该通道设置为非阻塞。
        if (readBytes &amp;gt; 0) {// 读到了字节，对字节进行编解码。
          readBuffer.flip();// 将缓冲区当前limit设置为position，position设置为0，用于后续对缓冲区的读取操作。
          byte[] bytes = new byte[readBuffer.remaining()];
          readBuffer.get(bytes);
          String body = new String(bytes, &quot;UTF-8&quot;);// 使用UTF-8解码
          logger.info(&quot;客户端请求信息：&quot; + body);
          // TODO: 简单处理请求，直接返回当前时间作为响应消息。
          doWrite(sc, new Date().toString());
        } else if (readBytes &amp;lt; 0) {// 返回值为-1，链路已关闭，需要手动关闭SocketChannel
          key.cancel();
          sc.close();
        } else {// 没有读到字节，多数情况，忽略。
          ;
        }
      }
    }
  }

  /**
   * 将响应消息异步发送回客户端
   * 
   * @param channel
   *          客户端通道
   * @param response
   *          响应消息的内容
   * @throws IOException
   */
  private void doWrite(SocketChannel channel, String response) throws IOException {
    if (response != null &amp;amp;&amp;amp; response.trim().length() &amp;gt; 0) {
      byte[] bytes = response.getBytes();
      ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);
      writeBuffer.put(bytes);
      writeBuffer.flip();
      channel.write(writeBuffer);// 将缓冲区内容写入通道，发送出去
      /**
       * TODO 由于SocketChannel是异步非阻塞的，所以写消息发送时不会一下子全部发送完毕，所以会出现“写半包”的问题。
       * 我们需要注册写操作，不断轮询Selector，将没有发送完的ByteBuffer发送完毕。 然后可以通过ByteBuffer的hasRemain方法判断消息是否完整发送完毕。
       */
      if (!writeBuffer.hasRemaining()) {
        logger.info(&quot;服务端响应发送成功！&quot;);
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bytebuffer的flip操作解析&quot;&gt;ByteBuffer的flip操作解析&lt;/h3&gt;
&lt;p&gt;上面代码中总会出现关于ByteBuffer对象调用的flip方法，它的解释是&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;将缓冲区当前limit设置为position，position设置为0，用于后续对缓冲区的读取操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而仍是一头雾水，下面从ByteBuffer的属性来解析这个flip方法的含义。首先来看ByteBuffer的几个属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;capacity：定义了ByteBuffer对象的容量。&lt;/li&gt;
&lt;li&gt;limit：定义了ByteBuffer在读写操作中的界限，读操作中limit代表有效数据的长度（肯定是小于等于capacity），写操作中等于capacity。&lt;/li&gt;
&lt;li&gt;position：读写操作的当前下标。&lt;/li&gt;
&lt;li&gt;mark：一个临时存放的下标，用来在ByteBuffer对象的中间进行读写操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上属性可以通过以下方法进行设定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;clear()：把position设为0，把limit设为capacity，一般在把数据写入Buffer前调用。&lt;/li&gt;
&lt;li&gt;flip()：把limit设为当前position，把position设为0，一般在从Buffer读出数据前调用。意思是将当前position即有效数据长度赋值给limit，然后将当前position调整到0，从0开始读取，一直读到limit。&lt;/li&gt;
&lt;li&gt;rewind()：把position设为0，limit不变，一般在把数据重写入Buffer前调用。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;以上关于该实例的所有代码都已经完整给出，至于内部的具体执行方式，我直接在代码行间做了充足的注释说明，我想比在这里用文字长篇累牍的效果要好得多。不过下面我还是要对该实例展现出的NIO特性以及该实例的局限性进行一个分析总结。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是该实例展现的NIO特性，无论服务端还是客户端，同一时间只需要唯一一个线程启动，由它维持着多路复用器的轮询工作，而实际上原来的多线程工作都转交给了这个多路复用器，通过多路复用器将通道上的每个IO操作注册进来，然后多路复用器有个休眠时间，selector.select(1000);每隔1s就会轮询一遍。实际上，整个selector的轮询工作本身是对当前线程的阻塞，但这是线程层面的阻塞，是为了保持多路复用器的轮询工作得以持续开展，而涉及到具体业务io操作的工作不会被阻塞，原Socket的工作方式是将这些业务操作都做了阻塞同步操作，而NIO将线程与多路复用器做了分层，在多路复用器层面，我们达到了对业务IO操作的异步非阻塞的目标。&lt;/li&gt;
&lt;li&gt;接下来是分析该实例的局限性，就本例而言，最主要的问题还是异步请求的结果问题，正如上面我们分析过的，无法用该实例实现标准输入返回回声的基本业务需求，由于无法外部更新客户端的请求，客户端无法保持与服务端的连接，只能是发送请求以后则关闭，否则该通道就会完全阻塞废弃在那里。该实例只是为了展示NIO的使用方式，总结下来来看，相较于原Socket编程，即使是“简配版本”的NIO操作，也称不上方便。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;新nio&quot;&gt;新NIO&lt;/h2&gt;
&lt;p&gt;我们都知道NIO本就是新IO了，怎么又蹦出来一个新NIO。其实是这样的，上面的实例中我们也体会到了NIO对异步操作处理的力不从心，所以针对以上的问题，JDK1.7升级了NIO的类库，我们可以叫它为新NIO，也可以是NIO 2.0，java正式提供了对异步IO的支持，解决了我们上面实例中提到的关于异步结果无法读取的问题，客户端与服务端的通道可以随时不断地发送请求和返回响应，实现真正的客户端和服务端的长连接通道。对于新NIO中这部分支持异步通信的，我们称他们为AIO（Asynchronous IO)。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;AIO主要是通过回调函数解决了对异步操作结果的处理。该回调函数是通过实现CompletionHandler接口的completed方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;jdk1.7的nio源码结构&quot;&gt;jdk1.7的nio源码结构&lt;/h3&gt;
&lt;p&gt;下面我们来看一下jdk1.7的nio源码架构:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.nio
java.nio.channels
java.nio.channels.spi
java.nio.charset
java.nio.charset.spi
java.nio.file
java.nio.file.attribute
java.nio.file.spi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟上面介绍过的jdk1.6版本的相同，spi包的可以去掉。那么增加的是java.nio.file类，于此同时，channels包中也发生了变化，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;*AsynchronousChannelGroup
*AsynchronousFileChannel
*AsynchronousServerSocketChannel：
*AsynchronousSocketChannel
Channels
DatagramChannel
FileChannel
FileChannel.MapMode
FileLock
*MembershipKey
Pipe
Pipe.SinkChannel
Pipe.SourceChannel
SelectableChannel
SelectionKey
Selector
ServerSocketChannel
SocketChannel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上开头带*的类是我标示出来的jdk7新增加的类。其中MembershipKey是代表互联网协议中多路广播组的一员，我们暂且不管它，重点研究Asynchrounous开头的异步支持类。先看他们的定义，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AsynchronousChannelGroup：对异步通道进行分组，达到资源共享的目的。&lt;/li&gt;
&lt;li&gt;AsynchronousFileChannel：一个可以对文件读写操作的异步通道。&lt;/li&gt;
&lt;li&gt;AsynchronousServerSocketChannel：一个异步通道用作流导向的监听套接字，说白了就是服务端Socket通道。&lt;/li&gt;
&lt;li&gt;AsynchronousSocketChannel：一个异步通道用作流导向的连接套接字，就是客户端Socket通道。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我想对新nio中Client-Server架构进行一下理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实在NIO中，因为全双工的缘故，服务端客户端的定义界限没有原始Socket那么严格，服务端在NIO中的体现在它是监听，而客户端是连接，通过这条通道，他们都可以给对方发送消息，我们通常称服务端发送给客户端的消息为响应，而客户端发送给服务端的消息为请求。&lt;/p&gt;
&lt;p&gt;接着说回我们的新NIO，除了新增的AIO部分，其他内容都是微调整，下面我们主要针对AIO部分进行代码实例的学习。&lt;/p&gt;
&lt;h3 id=&quot;aio编程&quot;&gt;AIO编程&lt;/h3&gt;
&lt;p&gt;AIO编程中最大的不同就是取消了多路复用器，它不再使用多路复用器的“多线程”的实现方式，而是完全通过对一条线程的非阻塞高效使用来实现多任务并发，这就归功于它对操作结果的异步处理。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为异步操作的回调函数本身就是一个额外的jvm底层的线程池启动的新线程负责回调并驱动读写操作返回结果，当结果处理完毕，它也就自动销毁了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以没有了多路复用器，又增加了真正异步的实现，AIO无论从编码上还是功能上都比旧的NIO要好很多。下面闲言少叙，先看代码：&lt;/p&gt;
&lt;p&gt;服务端启动一个线程，Handler改为新增加的AsyncServerHandler类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NIOTCPServer extends Base {
  public static void main(String[] args) {
    new Thread(new AsyncServerHandler(), &quot;nio-server-reactor-001&quot;).start();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是AsyncServerHandler类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.IO.nioS.aioS;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.AsynchronousServerSocketChannel;
import java.util.concurrent.CountDownLatch;

import javaS.IO.socketS.Base;

/**
 * 异步非阻塞服务器处理类
 * 
 * @author Evsward
 *
 */
public class AsyncServerHandler extends Base implements Runnable {

  AsynchronousServerSocketChannel asyncServerChannel;// 服务端异步套接字通道
  CountDownLatch latch;// 倒计时门闩

  /**
   * 构造器对象初始化
   */
  public AsyncServerHandler() {
    try {
      // 与NIO相同的操作，通过open静态方法创建一个AsynchronousServerSocketChannel的实例。
      asyncServerChannel = AsynchronousServerSocketChannel.open();
      asyncServerChannel.bind(new InetSocketAddress(ipAddress, port), 1024);// 一样的操作，绑定IP端口。
      logger.info(&quot;server is listening in address -&amp;gt; &quot; + ipAddress + &quot;:&quot; + port);
    } catch (IOException e) {
      e.printStackTrace();
      System.exit(1);
    }
  }

  @Override
  public void run() {
    latch = new CountDownLatch(1);// 初始化倒计时次数为1
    doAccept();
    try {
      latch.await();// 倒计时门闩开始阻塞，知道倒计时为0，如果在这期间线程中断，则抛异常：InterruptedException。
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
  }

  public void doAccept() {
    /**
     * 开始接收客户端连接，将当前服务端异步套接字通道对象作为附件传入保存，
     * 
     * 同时传入一个 CompletionHandler&amp;lt;AsynchronousSocketChannel, ? super A&amp;gt;的实现类对象接收accept成功的消息。
     */
    asyncServerChannel.accept(this, new AcceptCompletionHandler());
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它依赖一个AcceptCompletionHandler类，用来回调处理结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.IO.nioS.aioS;

import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;

import javaS.IO.socketS.Base;

/**
 * accept方法的回调操作
 * 
 * 泛型参数1：IO操作的回调结果的类型 泛型参数2：IO操作的附件对象的类型
 * 
 * 这两个参数对应的也就是回调函数completed的参数类型
 * 
 * @author Evsward
 *
 */
public class AcceptCompletionHandler extends Base
    implements CompletionHandler&amp;lt;AsynchronousSocketChannel, AsyncServerHandler&amp;gt; {

  @Override
  /**
   * 传入一个客户端异步套接字通道作为accept操作结果的接收者，一个异步非阻塞服务器处理类对象作为附件存储
   */
  public void completed(AsynchronousSocketChannel result, AsyncServerHandler attachment) {
    /**
     * 为什么要再次执行相同的accept方法，他们甚至参数都一样？
     * 
     * 因为上一个类中asyncServerChannel的accept方法执行以后，新的客户端连接结果会调用当前completed方法。
     * 但是服务端是支持多个客户端连接的，不能只有一个客户端连接成功以后，调用回调函数completed就结束了。
     * 因此我们要在第一个客户端连接结果的回调函数中再次开启一个accept方法以接收第二个客户端连接，递归调用，就可以支持accept无数个客户端连接了。
     */
    attachment.asyncServerChannel.accept(attachment, this);
    // 开辟一个1MB的临时缓冲区，将用于从异步套接字通道中读取数据包
    ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);
    /**
     * 回调函数对accept结果进行异步读操作，读取客户端请求，放入buffer容器中
     * 
     * 其中attachment依然作为其回调时的入参：读数据的时候，是通过ByteBuffer容器，无论是数据源还是结果存放，因此attachment也应该传入一个ByteBuffer对象
     * 
     * 最后一个参数为异步读操作的回调函数。
     */
    result.read(buffer, buffer, new ReadCompletionHandler(result));
  }

  @Override
  public void failed(Throwable exc, AsyncServerHandler attachment) {
    exc.printStackTrace();
    attachment.latch.countDown();// 倒计时一次，由于我们定义的初始化次数为1，所以当前线程直接往下运行，脱离阻塞状态。
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类又依赖着ReadCompletionHandler类，用来做读操作的回调处理结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.IO.nioS.aioS;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.util.Date;

import javaS.IO.socketS.Base;

public class ReadCompletionHandler extends Base implements CompletionHandler&amp;lt;Integer, ByteBuffer&amp;gt; {
  private AsynchronousSocketChannel channel;

  /**
   * 通过构造器传入关联的AsynchronousSocketChannel实例作为成员变量，我们在回调要始终针对这个通道进行IO操作。
   * 
   * 其实从
   * 
   * @param channel
   */
  public ReadCompletionHandler(AsynchronousSocketChannel channel) {
    this.channel = channel;
  }

  @Override
  /**
   * attachment什么时候被赋的值？
   * 
   **** 答：回调的时候数据被填充到了attachment，返回结果是一个状态码存储与Integer result对象中。
   */
  public void completed(Integer result, ByteBuffer attachment) {
    attachment.flip();// 为读取数据做准备
    byte[] body = new byte[attachment.remaining()];// 创建一个与附件缓冲区大小相同的字节数组。
    attachment.get(body);// 将缓冲区内数据读到字节数组中去。
    try {
      String req = new String(body, &quot;UTF-8&quot;);
      logger.info(&quot;客户端请求信息：&quot; + req);
      if (TIMEQUERY.equals(req)) {
        doWrite(new Date().toString());// 将当前时间作为响应消息返回客户端
      } else {
        doWrite(req);
      }
    } catch (UnsupportedEncodingException e) {
      e.printStackTrace();
    }
  }

  /**
   * 服务端写响应信息
   * 
   * @param rep
   */
  private void doWrite(String rep) {
    if (rep != null &amp;amp;&amp;amp; rep.trim().length() &amp;gt; 0) {
      byte[] bytes = rep.getBytes();
      ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);
      writeBuffer.put(bytes);
      writeBuffer.flip();
      /**
       * 开始向服务端异步套接字通道中写入数据，同样的任何出现异步IO操作的都要有CompletionHandler的实现来来做回调的处理。
       * 直接采用匿名内部类实现CompletionHandler接口
       */
      channel.write(writeBuffer, writeBuffer, new CompletionHandler&amp;lt;Integer, ByteBuffer&amp;gt;() {

        @Override
        public void completed(Integer result, ByteBuffer attachment) {
          if (attachment.hasRemaining()) {
            channel.write(writeBuffer, attachment, this);// 递归调用自己直到数据全部写入通道。
            /**
             * 这里的数据全部写入通道的控制与“写半包”并不相同，写半包是由于传输容器本身的大小限制正好对数据进行了分割导致，
             * 
             * 处理起来会更加复杂一些，这部分研究现在并不准备展开讨论。
             */
          }
        }

        @Override
        public void failed(Throwable exc, ByteBuffer attachment) {// 对异常的处理
          try {
            channel.close();
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

      });
    }
  }

  @Override
  public void failed(Throwable exc, ByteBuffer attachment) {
    try {
      // 失败则关闭当前通道
      this.channel.close();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端我们就写完了，比较复杂，但其实原理都一样，就是做回调的结果处理类，下面我们来写客户端，同样的，客户端启动一个线程，Handler改为新增加的AsyncClientHandler类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NIOTCPClient extends Base {
  public static void main(String[] args) {
    new Thread(new AsyncClientHandler(), &quot;nio-client-reactor-001&quot;).start();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，继续写AsyncClientHandler类，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package javaS.IO.nioS.aioS;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.CompletionHandler;
import java.util.concurrent.CountDownLatch;

import javaS.IO.socketS.Base;

/**
 * 异步非阻塞客户端处理类
 * 
 * 本类大量使用匿名内部类来处理回调，好处是客户端处理类只有本类一个，并无生成如服务端处理类相关的那么多类文件，
 * 
 * 坏处是本类层次结构较复杂，可读性差。
 * 
 * 注意：Void作为类型要首字母大写，就好像只有Integer可以作为泛型类型而不是int一样，但Void不是引用类型，这里只是一种表示void类型的情况。
 * 
 * @author Evsward
 *
 */
public class AsyncClientHandler extends Base
    implements CompletionHandler&amp;lt;Void, AsyncClientHandler&amp;gt;, Runnable {
  private AsynchronousSocketChannel asyncClientChannel;// 客户端异步套接字通道，成员变量
  private CountDownLatch latch;// 用倒计时门闩来控制线程阻塞等待的状态，而不是让线程自己中断退出

  public AsyncClientHandler() {
    try {
      asyncClientChannel = AsynchronousSocketChannel.open();
    } catch (IOException e) {
      e.printStackTrace();
    }

  }

  @Override
  public void run() {
    latch = new CountDownLatch(1);
    // 对象是本类，回调函数也是本类
    asyncClientChannel.connect(new InetSocketAddress(ipAddress, port), this, this);
    try {
      latch.await();
    } catch (InterruptedException e) {
      e.printStackTrace();
    }
    try {
      asyncClientChannel.close();// 客户端在请求完毕以后要关闭掉
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  @Override
  public void completed(Void result, AsyncClientHandler attachment) {
    // 客户端输入
    BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
    boolean flag = true;
    String str = null;
    while (flag) {
      logger.info(&quot;客户端&amp;gt;输入信息：&quot;);
      try {
        str = input.readLine();
      } catch (IOException e1) {
        e1.printStackTrace();
      }
      if (str == null || &quot;&quot;.equals(str)) {
        logger.info(&quot;请不要输入空字符！&quot;);
        continue;
      }
      /**
       * 不fail的情况下，只有客户端输入bye，才会主动断开连接。
       */
      if (&quot;bye&quot;.equals(str)) {
        logger.info(&quot;客户端终止请求，断开连接。&quot;);
        try {
          asyncClientChannel.close();
          latch.countDown();// 客户端通道写异常，释放线程，执行完毕。
        } catch (IOException e) {
          e.printStackTrace();
        }
        break;
      }
      // 客户端发起请求
      byte[] req = str.getBytes();
      ByteBuffer reqBuffer = ByteBuffer.allocate(req.length);
      reqBuffer.put(req);
      reqBuffer.flip();
      // 通道读取到缓冲区成功以后开始写请求
      asyncClientChannel.write(reqBuffer, reqBuffer, new CompletionHandler&amp;lt;Integer, ByteBuffer&amp;gt;() {

        @Override
        public void completed(Integer result, ByteBuffer attachment) {
          if (reqBuffer.hasRemaining()) {
            asyncClientChannel.write(reqBuffer, reqBuffer, this);
          } else {
            // 写完请求以后，开始接收响应消息，并对进行结果回调处理
            ByteBuffer readBuffer = ByteBuffer.allocate(BUFFER_SIZE);
            asyncClientChannel.read(readBuffer, readBuffer,
                new CompletionHandler&amp;lt;Integer, ByteBuffer&amp;gt;() {

                  @Override
                  public void completed(Integer result, ByteBuffer attachment) {
                    attachment.flip();
                    byte[] bytes = new byte[attachment.remaining()];
                    attachment.get(bytes);// 将缓冲区读到字节数组
                    try {
                      String body = new String(bytes, &quot;UTF-8&quot;);
                      logger.info(&quot;服务端的响应消息：&quot; + body);
                      logger.info(&quot;---------------------&quot;);
                      // 由于无法保持长连接通信，一次请求响应以后就无法再继续通信，所以接收服务端响应以后，就断开连接。
                      asyncClientChannel.close();
                      latch.countDown();
                    } catch (UnsupportedEncodingException e) {
                      e.printStackTrace();
                    } catch (IOException e) {
                      e.printStackTrace();
                    }
                  }

                  @Override
                  public void failed(Throwable exc, ByteBuffer attachment) {
                    try {
                      asyncClientChannel.close();
                      latch.countDown();// 客户端通道读异常，释放线程，执行完毕。
                    } catch (IOException e) {
                      e.printStackTrace();
                    }
                  }

                });
          }
        }

        @Override
        public void failed(Throwable exc, ByteBuffer attachment) {
          try {
            asyncClientChannel.close();
            latch.countDown();// 客户端通道写异常，释放线程，执行完毕。
          } catch (IOException e) {
            e.printStackTrace();
          }
        }

      });
    }
  }

  @Override
  public void failed(Throwable exc, AsyncClientHandler attachment) {
    try {
      asyncClientChannel.close();
      latch.countDown();// 客户端通道IO操作异常，释放线程，执行完毕。
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类很长，因为我们没有单独创建回调类，而是直接采用匿名内部类的方式实现了CompletionHandler接口。下面我们来看输出结果，然后再来分析与总结。&lt;/p&gt;
&lt;p&gt;首先，让我们先启动NIOTCPServer，&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;13:11:11[&amp;lt;init&amp;gt;][main]: server is listening in address -&amp;gt; 127.0.0.1:23451&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，我们先启动一个NIOTCPClient，就将它编号为1吧，&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;13:11:16[completed][Thread-10]: 客户端&amp;gt;输入信息：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在客户端1中输入a回车，客户端控制台输出为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;13:11:16[completed][Thread-10]: 客户端&amp;gt;输入信息：
a
13:11:18[completed][Thread-10]: 客户端&amp;gt;输入信息：
13:11:18[completed][Thread-2]: 服务端的响应消息：a
13:11:18[completed][Thread-2]: ---------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们切换到服务端的控制台，发现也发生了变化：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;13:11:11[&amp;lt;init&amp;gt;][main]: server is listening in address -&amp;gt; 127.0.0.1:23451
13:11:18[completed][Thread-2]: 客户端请求信息：a&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;保持长连接的方法&quot;&gt;保持长连接的方法&lt;/h4&gt;
&lt;p&gt;这里，我曾设法继续在客户端1中输入字符，发送请求，但是我们可以看到“客户端&amp;gt;输入信息”这一行已经被异步读取的响应信息拦住了，此时在Thread-10上继续输入信息并没有响应信息传回，再次输入信息回车会发生报错。我设法去修改ReadCompletionHandler，让它在发送完响应信息以后，能够继续调用AsynchronousSocketChannel的read方法，然后继续读取客户端的请求信息，因为ReadCompletionHandler类本身就是read方法的回调处理类，让它在处理完相应信息以后相当于在内部调用外部的read方法，再用自己来处理。按照这个思想，我对ReadCompletionHandler的响应写入部分增加了一段代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;      // 开辟一个1MB的临时缓冲区，将用于从异步套接字通道中读取数据包
      ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);
      channel.read(buffer, buffer, this);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们仍旧要再开辟一个临时缓冲区，用来给这条通道上下一个请求数据的处理做容器，然后用我们通过构造方法保存的AsynchronousSocketChannel对象channel，继续调用它的read方法，并将自身作为回调处理类的入参。重新测试，与上面相同的内容我不再写，重启服务端和客户端以后，接着上面的操作，我们继续在客户端1中输入字符回车，控制台输出为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;13:30:23[completed][Thread-10]: 客户端&amp;gt;输入信息：
a
13:30:25[completed][Thread-10]: 客户端&amp;gt;输入信息：
13:30:25[completed][Thread-3]: 服务端的响应消息：a
13:30:25[completed][Thread-3]: ---------------------
a
13:30:26[completed][Thread-10]: 客户端&amp;gt;输入信息：
13:30:26[completed][Thread-5]: 服务端的响应消息：a
13:30:26[completed][Thread-5]: ---------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再继续输入关键字“query time”用来请求服务端返回当前时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
13:30:31[completed][Thread-7]: ---------------------
query time
13:30:34[completed][Thread-10]: 客户端&amp;gt;输入信息：
13:30:34[completed][Thread-8]: 服务端的响应消息：Thu Dec 14 13:30:34 CST 2017
13:30:34[completed][Thread-8]: ---------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前为止，我们想要的功能均实现了，下面我们再启动一个NIOTCPClient，继续测试，仍旧成功。到现在为止，一个服务端已经连接了两个客户端，均可以正常工作，下面我又连着启动了5个客户端继续测试仍旧稳定运行。回到服务端的控制台，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;13:30:18[&amp;lt;init&amp;gt;][main]: server is listening in address -&amp;gt; 127.0.0.1:23451
13:30:25[completed][Thread-2]: 客户端请求信息：a
13:30:26[completed][Thread-3]: 客户端请求信息：a
13:30:28[completed][Thread-4]: 客户端请求信息：afd
13:30:29[completed][Thread-5]: 客户端请求信息：ads
13:30:30[completed][Thread-6]: 客户端请求信息：adf
13:30:31[completed][Thread-7]: 客户端请求信息：adf
13:30:34[completed][Thread-8]: 客户端请求信息：query time
13:30:43[completed][Thread-10]: 客户端请求信息：hey
13:30:46[completed][Thread-2]: 客户端请求信息：heyyou
13:30:49[completed][Thread-3]: 客户端请求信息：query time&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们使用AIO编程成功实现了回声加时间访问的服务器客户端模型！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;继续优化&quot;&gt;继续优化&lt;/h4&gt;
&lt;p&gt;我能够改造成功，是源自AcceptCompletionHandler类的重写completed方法中的&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;attachment.asyncServerChannel.accept(attachment, this);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这行代码我在以上粘贴的源码部分已经写下了详实的注释介绍了它出现第二次的理由。因为我们的服务端要想继续支持其他的客户端连入，就必须在第一个客户端连入成功以后的回调函数里继续为其他客户端开启accept通道。相似的，我们的服务端在返回响应消息以后，如果想继续处理客户端的请求，此时它与该客户端仍旧保持连接状态，只是失去了继续处理该客户端请求的能力，因此，我们将这个能力赋予给它就可以了。有些朋友说那只是支持了第二个客户端连接，或者只是支持了当前连接的客户端第二次请求而已，那第三个客户端或者第三个请求呢？（这个问题的两个主语因为是使用相同的手段实现的，所以我把他们放在一起来解释，希望大家不要困扰。）原因就是我们新加的用于继续处理新客户端或者新请求的代码中，调用的回调处理类是当前类本身，这就是递归的调用，无论再连入多少个客户端，或者当前客户端发送多少次请求，都可以稳定处理。&lt;/p&gt;
&lt;p&gt;如果我们保持程序这样，客户端与服务端的通道是没有主动断开机制的，除非发生异常（例如你把整个jvm关掉了）。这是程序比较大的bug，如果用CheckStyle等源码检查工具来检查的话会给你标示出来。那么我现在对它进行进一步修改。&lt;/p&gt;
&lt;p&gt;我想的是直接在客户端输入时判断输入信息是否为关键字“bye”，如果是的话直接关闭通道，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;      /**
       * 不fail的情况下，只有客户端输入bye，才会主动断开连接。
       */
      if (&quot;bye&quot;.equals(str)) {
        logger.info(&quot;客户端终止请求，断开连接。&quot;);
        try {
          asyncClientChannel.close();
          latch.countDown();// 客户端通道写异常，释放线程，执行完毕。
        } catch (IOException e) {
          e.printStackTrace();
        }
        break;
      }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但经过测试，我发现客户端控制台输入“bye”以后，客户端可以正常关闭，但是服务端发生异常：不断的循环客户端的输入为空的情况。&lt;/p&gt;
&lt;p&gt;好，下面我们对服务端进行调整：我们在服务端ReadCompletionHandler类读取客户端请求以后在输出请求字符前首先判断：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;      // 如果接收到客户端空字符的情况，说明客户端已断开连接，那么服务端也自动断开通道即可。
      if (req == null || &quot;&quot;.equals(req)) {
        channel.close();
        return;
      } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过仔细测试，这个方法可行，我们的程序距离健壮性又近了一步。&lt;/p&gt;
&lt;h4 id=&quot;关于回调&quot;&gt;关于回调&lt;/h4&gt;
&lt;p&gt;在测试过程中，我们发现每一个请求或者响应的异步回调消息都是通过一个新的线程打印出来的，我们先来看服务端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;14:01:27[&amp;lt;init&amp;gt;][main]: server is listening in address -&amp;gt; 127.0.0.1:23451
14:01:33[completed][Thread-3]: 客户端请求信息：1
14:01:33[completed][Thread-2]: 客户端请求信息：2
14:01:34[completed][Thread-5]: 客户端请求信息：3
14:01:35[completed][Thread-6]: 客户端请求信息：4
14:01:35[completed][Thread-4]: 客户端请求信息：5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，再来看客户端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;14:01:31[completed][Thread-10]: 客户端&amp;gt;输入信息：
1
14:01:33[completed][Thread-10]: 客户端&amp;gt;输入信息：
14:01:33[completed][Thread-2]: 服务端的响应消息：1
14:01:33[completed][Thread-2]: ---------------------
2
14:01:33[completed][Thread-10]: 客户端&amp;gt;输入信息：
14:01:33[completed][Thread-4]: 服务端的响应消息：2
14:01:33[completed][Thread-4]: ---------------------
3
14:01:34[completed][Thread-10]: 客户端&amp;gt;输入信息：
14:01:34[completed][Thread-5]: 服务端的响应消息：3
14:01:34[completed][Thread-5]: ---------------------
4
14:01:35[completed][Thread-10]: 客户端&amp;gt;输入信息：
14:01:35[completed][Thread-6]: 服务端的响应消息：4
14:01:35[completed][Thread-6]: ---------------------
5
14:01:35[completed][Thread-10]: 客户端&amp;gt;输入信息：
14:01:35[completed][Thread-7]: 服务端的响应消息：5
14:01:35[completed][Thread-7]: ---------------------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现了，服务端处理请求和客户端处理响应的新线程并不具备任何关系，例如服务端打印请求为2的线程为Thread-2，然而客户端返回处理请求2的响应线程为Thread-4，它们并不想等，也就是说这个线程的编号是独立的。因为这些回调线程是由jdk实现的。&lt;/p&gt;
&lt;h2 id=&quot;总结-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们终于完成了AIO实例的编程与测试和结果分析，下面我来总结一下。关于网络编程，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基础是最普通的IO操作&lt;/li&gt;
&lt;li&gt;然后涉及到网络IO，有了&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/socket.html&quot;&gt;Socket&lt;/a&gt;来帮我们做这一层的工作&lt;/li&gt;
&lt;li&gt;我们不满足于它阻塞的表现，增加了NIO，这部分的研究在本篇第一大部分进行了详细的介绍，我们主要依赖对多路复用器Selector的轮询来在单线程中实现“多线程”&lt;/li&gt;
&lt;li&gt;我们又不满足与NIO的“假异步”的实现，增加了AIO，形成NIO 2.0，我们上面刚刚完成它的研究，我们是通过异步处理结果以后继续接收新任务的方式来在单线程中实现“多线程”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实本篇文章的内容不是真正意义的多线程知识，这个“多线程”是假的，是通过技术手段来合理的分配单一线程处理不同工作的方法，或者是依赖jdk实现过的稳定的回调线程的方式，但这种方式恰恰符合计算机系统中对线程的定义，我们知道cpu只有通过真的多核处理才是“真并发”，而线程多是通过合理分配资源的方式来实现并发的，然而我们也知道，有些cpu厂商也在做“假多核”，实际上这里面的思想是一致的。&lt;/p&gt;
&lt;p&gt;本篇我们做的这些研究的工作都是针对TCP的，也就是基于流的，基于长连接的，长连接有个重要的特性就是，不仅可以处理客户端的请求，它还可以主动给客户端发送消息，这是长连接最大的优势。&lt;/p&gt;
&lt;p&gt;最后，我们的研究之路是随着jdk的不断发展来的，所以最新的AIO的方式肯定是超越旧版的，我们在未来的实际应用中可以选择使用。接下来，我要趁热打铁，介绍多线程的知识，以及NIO开源框架Netty的知识，还有JVM，总之，知识是越研究越多，因为你的视野被逐渐打开了。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;《netty权威指南》&lt;/li&gt;
&lt;li&gt;《java编程思想》&lt;/li&gt;
&lt;li&gt;jdk 1.6 document api&lt;/li&gt;
&lt;li&gt;jdk 1.7 document api&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;源码位置&quot;&gt;&lt;a href=&quot;https://github.com/evsward/mainbase/tree/master/src/main/java/javaS/IO/nioS&quot;&gt;源码位置&lt;/a&gt;&lt;/h3&gt;
&lt;h3 id=&quot;其他更多内容请转到醒者呆的博客园&quot;&gt;其他更多内容请转到&lt;a href=&quot;http://www.cnblogs.com/Evsward/&quot;&gt;醒者呆的博客园&lt;/a&gt;&lt;/h3&gt;
</description>
<pubDate>Thu, 14 Dec 2017 06:32:00 +0000</pubDate>
<dc:creator>一面千人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Evsward/p/nio.html</dc:identifier>
</item>
<item>
<title>【ASP.NET Core】运行原理[3]:认证 - Never、C</title>
<link>http://www.cnblogs.com/neverc/p/8037477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neverc/p/8037477.html</guid>
<description>&lt;p&gt;本系列将分析ASP.NET Core运行原理&lt;/p&gt;
&lt;p&gt;本节将分析Authentication&lt;/p&gt;
&lt;p&gt;源代码参考.NET Core 2.0.0&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;认证
&lt;ol&gt;&lt;li&gt;AddAuthentication
&lt;ol&gt;&lt;li&gt;IAuthenticationService&lt;/li&gt;
&lt;li&gt;IAuthenticationHandlerProvider&lt;/li&gt;
&lt;li&gt;IAuthenticationSchemeProvider&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;UseAuthentication&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;Authentication.Cookies&lt;/li&gt;
&lt;li&gt;模拟一个Cookie认证&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;认证&quot;&gt;认证&lt;/h2&gt;
&lt;p&gt;认证已经是当前Web必不可缺的组件。看看ASP.NET Core如何定义和实现认证。&lt;br/&gt;在Startup类中，使用认证组件非常简单。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication();
}

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseAuthentication();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;addauthentication&quot;&gt;AddAuthentication&lt;/h3&gt;
&lt;p&gt;先来分析AddAuthentication：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static IServiceCollection AddAuthenticationCore(this IServiceCollection services)
{
    services.TryAddScoped&amp;lt;IAuthenticationService, AuthenticationService&amp;gt;();
    services.TryAddScoped&amp;lt;IAuthenticationHandlerProvider, AuthenticationHandlerProvider&amp;gt;();
    services.TryAddSingleton&amp;lt;IAuthenticationSchemeProvider, AuthenticationSchemeProvider&amp;gt;();
    return services;
}

public static AuthenticationBuilder AddAuthentication(this IServiceCollection services)
{
    services.AddAuthenticationCore();
    return new AuthenticationBuilder(services);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;iauthenticationservice&quot;&gt;IAuthenticationService&lt;/h4&gt;
&lt;p&gt;在AddAuthentication方法中注册了IAuthenticationService、IAuthenticationHandlerProvider、IAuthenticationSchemeProvider3个服务。&lt;br/&gt;首先分析下&lt;code&gt;IAuthenticationService&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IAuthenticationService
{
    Task&amp;lt;AuthenticateResult&amp;gt; AuthenticateAsync(HttpContext context, string scheme);

    Task ChallengeAsync(HttpContext context, string scheme, AuthenticationProperties properties);

    Task ForbidAsync(HttpContext context, string scheme, AuthenticationProperties properties);

    Task SignInAsync(HttpContext context, string scheme, ClaimsPrincipal principal, AuthenticationProperties properties);

    Task SignOutAsync(HttpContext context, string scheme, AuthenticationProperties properties);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AuthenticateAsync：验证用户身份，并返回AuthenticateResult对象。&lt;br/&gt;ChallengeAsync：通知用户需要登录。在默认实现类&lt;code&gt;AuthenticationHandler&lt;/code&gt;中，返回401。&lt;br/&gt;ForbidAsync：通知用户权限不足。在默认实现类&lt;code&gt;AuthenticationHandler&lt;/code&gt;中，返回403。&lt;br/&gt;SignInAsync：登录用户。(该方法需要与AuthenticateAsync配合验证逻辑)&lt;br/&gt;SignOutAsync：退出登录。&lt;/p&gt;
&lt;p&gt;而IAuthenticationService的默认实现类为：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class AuthenticationService : IAuthenticationService
{
    public virtual async Task&amp;lt;AuthenticateResult&amp;gt; AuthenticateAsync(HttpContext context, string scheme)
    {
        if (scheme == null)
        {
            var defaultScheme = await Schemes.GetDefaultAuthenticateSchemeAsync();
            scheme = defaultScheme?.Name;
        }

        var handler = await Handlers.GetHandlerAsync(context, scheme);
        var result = await handler.AuthenticateAsync();
        if (result != null &amp;amp;&amp;amp; result.Succeeded)
            return AuthenticateResult.Success(new AuthenticationTicket(result.Principal, result.Properties, result.Ticket.AuthenticationScheme));
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在AuthenticateAsync代码中，先查询Scheme，然后根据SchemeName查询Handle，再调用handle的同名方法。&lt;br/&gt;解释一下&lt;code&gt;GetDefaultAuthenticateSchemeAsync&lt;/code&gt;会先查&lt;code&gt;DefaultAuthenticateScheme&lt;/code&gt;，如果为null，再查&lt;code&gt;DefaultScheme&lt;/code&gt;。&lt;br/&gt;实际上，AuthenticationService的其他方法都是这样的模式，最终调用的都是handle的同名方法。&lt;/p&gt;
&lt;h4 id=&quot;iauthenticationhandlerprovider&quot;&gt;IAuthenticationHandlerProvider&lt;/h4&gt;
&lt;p&gt;因此，我们看看获取Handle的&lt;code&gt;IAuthenticationHandlerProvider&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IAuthenticationHandlerProvider
{
    Task&amp;lt;IAuthenticationHandler&amp;gt; GetHandlerAsync(HttpContext context, string authenticationScheme);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该接口只有一个方法，根据schemeName查找Handle:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class AuthenticationHandlerProvider : IAuthenticationHandlerProvider
{
    public AuthenticationHandlerProvider(IAuthenticationSchemeProvider schemes)
    {
        Schemes = schemes;
    }

    public IAuthenticationSchemeProvider Schemes { get; }

    public async Task&amp;lt;IAuthenticationHandler&amp;gt; GetHandlerAsync(HttpContext context, string authenticationScheme)
    {
        if (_handlerMap.ContainsKey(authenticationScheme))
            return _handlerMap[authenticationScheme];

        var scheme = await Schemes.GetSchemeAsync(authenticationScheme);
        if (scheme == null)
            return null;
        var handler = (context.RequestServices.GetService(scheme.HandlerType) ??
            ActivatorUtilities.CreateInstance(context.RequestServices, scheme.HandlerType)) as IAuthenticationHandler;
        if (handler != null)
        {
            await handler.InitializeAsync(scheme, context);
            _handlerMap[authenticationScheme] = handler;
        }
        return handler;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在GetHandlerAsync方法中，我们看到是先从IAuthenticationSchemeProvider中根据schemeName获取scheme，然后通过scheme的HandleType来创建IAuthenticationHandler。&lt;br/&gt;创建Handle的时候，是先从ServiceProvider中获取，如果不存在则通过ActivatorUtilities创建。&lt;br/&gt;获取到Handle后，将调用一次handle的InitializeAsync方法。&lt;br/&gt;当下次获取Handle的时候，将直接从缓存中获取。&lt;/p&gt;
&lt;p&gt;需要补充说明的是一共有3个Handle：&lt;br/&gt;IAuthenticationHandler、IAuthenticationSignInHandler、IAuthenticationSignOutHandler。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IAuthenticationSignInHandler : IAuthenticationSignOutHandler, IAuthenticationHandler{}
public interface IAuthenticationSignOutHandler : IAuthenticationHandler{}
public interface IAuthenticationHandler{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以接口拆分，应该是考虑到大部分的系统的登录和退出是单独一个身份系统处理。&lt;/p&gt;
&lt;h4 id=&quot;iauthenticationschemeprovider&quot;&gt;IAuthenticationSchemeProvider&lt;/h4&gt;
&lt;p&gt;通过IAuthenticationHandlerProvider代码，我们发现最终还是需要IAuthenticationSchemeProvider来提供Handle类型：&lt;br/&gt;这里展示IAuthenticationSchemeProvider接口核心的2个方法。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IAuthenticationSchemeProvider
{
    void AddScheme(AuthenticationScheme scheme);
    Task&amp;lt;AuthenticationScheme&amp;gt; GetSchemeAsync(string name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认实现类&lt;code&gt;AuthenticationSchemeProvider&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class AuthenticationSchemeProvider : IAuthenticationSchemeProvider
{
    private IDictionary&amp;lt;string, AuthenticationScheme&amp;gt; _map = new Dictionary&amp;lt;string, AuthenticationScheme&amp;gt;(StringComparer.Ordinal);

    public virtual void AddScheme(AuthenticationScheme scheme)
    {
        if (_map.ContainsKey(scheme.Name))
        {
            throw new InvalidOperationException(&quot;Scheme already exists: &quot; + scheme.Name);
        }
        lock (_lock)
        {
            if (_map.ContainsKey(scheme.Name))
            {
                throw new InvalidOperationException(&quot;Scheme already exists: &quot; + scheme.Name);
            }
            _map[scheme.Name] = scheme;
        }
    }

    public virtual Task&amp;lt;AuthenticationScheme&amp;gt; GetSchemeAsync(string name)
            =&amp;gt; Task.FromResult(_map.ContainsKey(name) ? _map[name] : null);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，整个认证逻辑最终都回到了Scheme位置。也就说明要认证，则必须先注册Scheme。&lt;/p&gt;
&lt;h3 id=&quot;useauthentication&quot;&gt;UseAuthentication&lt;/h3&gt;
&lt;p&gt;AddAuthentication实现了注册Handle，UseAuthentication则是使用Handle去认证。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static IApplicationBuilder UseAuthentication(this IApplicationBuilder app)
{
    return app.UseMiddleware&amp;lt;AuthenticationMiddleware&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用了&lt;code&gt;AuthenticationMiddleware&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class AuthenticationMiddleware
{
    private readonly RequestDelegate _next;
    public IAuthenticationSchemeProvider Schemes { get; set; }

    public AuthenticationMiddleware(RequestDelegate next, IAuthenticationSchemeProvider schemes)
    {
        _next = next;
        Schemes = schemes;
    }

    public async Task Invoke(HttpContext context)
    {
        var handlers = context.RequestServices.GetRequiredService&amp;lt;IAuthenticationHandlerProvider&amp;gt;();
        foreach (var scheme in await Schemes.GetRequestHandlerSchemesAsync())
        {
            var handler = await handlers.GetHandlerAsync(context, scheme.Name) as IAuthenticationRequestHandler;
            if (handler != null &amp;amp;&amp;amp; await handler.HandleRequestAsync())
            {
                return;
            }
        }

        var defaultAuthenticate = await Schemes.GetDefaultAuthenticateSchemeAsync();
        if (defaultAuthenticate != null)
        {
            var result = await context.AuthenticateAsync(defaultAuthenticate.Name);
            if (result?.Principal != null)
            {
                context.User = result.Principal;
            }
        }

        await _next(context);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Invoke代码中，我们看到先查询出所有的&lt;code&gt;AuthenticationRequestHandler&lt;/code&gt;。如果存在，则立即调用其HandleRequestAsync方法，并返回。&lt;br/&gt;(RequestHandler一般是处理第三方认证响应的OAuth / OIDC等远程认证方案。)&lt;br/&gt;如果不存在RequestHandler，将调用默认的&lt;code&gt;AuthenticateHandle&lt;/code&gt;的AuthenticateAsync方法。同时会对context.User赋值。&lt;/p&gt;
&lt;h2 id=&quot;authentication.cookies&quot;&gt;Authentication.Cookies&lt;/h2&gt;
&lt;p&gt;Cookies认证是最常用的一种方式，这里我们分析一下Cookie源码：&lt;/p&gt;
&lt;h3 id=&quot;addcookie&quot;&gt;AddCookie&lt;/h3&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static class CookieExtensions
{
    public static AuthenticationBuilder AddCookie(this AuthenticationBuilder builder)
        =&amp;gt; builder.AddCookie(CookieAuthenticationDefaults.AuthenticationScheme);

    public static AuthenticationBuilder AddCookie(this AuthenticationBuilder builder, string authenticationScheme)
        =&amp;gt; builder.AddCookie(authenticationScheme, configureOptions: null);

    public static AuthenticationBuilder AddCookie(this AuthenticationBuilder builder, Action&amp;lt;CookieAuthenticationOptions&amp;gt; configureOptions)
        =&amp;gt; builder.AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, configureOptions);

    public static AuthenticationBuilder AddCookie(this AuthenticationBuilder builder, string authenticationScheme, Action&amp;lt;CookieAuthenticationOptions&amp;gt; configureOptions)
        =&amp;gt; builder.AddCookie(authenticationScheme, displayName: null, configureOptions: configureOptions);

    public static AuthenticationBuilder AddCookie(this AuthenticationBuilder builder, string authenticationScheme, string displayName, Action&amp;lt;CookieAuthenticationOptions&amp;gt; configureOptions)
    {
        builder.Services.TryAddEnumerable(ServiceDescriptor.Singleton&amp;lt;IPostConfigureOptions&amp;lt;CookieAuthenticationOptions&amp;gt;, PostConfigureCookieAuthenticationOptions&amp;gt;());
        return builder.AddScheme&amp;lt;CookieAuthenticationOptions, CookieAuthenticationHandler&amp;gt;(authenticationScheme, displayName, configureOptions);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;AddCookie(this AuthenticationBuilder builder, Action&amp;lt;CookieAuthenticationOptions&amp;gt; configureOptions)&lt;/code&gt;可能是我们最常用的&lt;br/&gt;该方法将注册CookieAuthenticationHandler用于处理认证相关。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class CookieAuthenticationHandler : AuthenticationHandler&amp;lt;CookieAuthenticationOptions&amp;gt;,IAuthenticationSignInHandler
{
    public async virtual Task SignInAsync(ClaimsPrincipal user, AuthenticationProperties properties)
    {
        var signInContext = new CookieSigningInContext(
                Context,
                Scheme,
                Options,
                user,
                properties,
                cookieOptions);
        var ticket = new AuthenticationTicket(signInContext.Principal, signInContext.Properties, signInContext.Scheme.Name);
        var cookieValue = Options.TicketDataFormat.Protect(ticket, GetTlsTokenBinding());
        Options.CookieManager.AppendResponseCookie(
                Context,
                Options.Cookie.Name,
                cookieValue,
                signInContext.CookieOptions);
    }
    protected override async Task&amp;lt;AuthenticateResult&amp;gt; HandleAuthenticateAsync()
    {
        var cookie = Options.CookieManager.GetRequestCookie(Context, Options.Cookie.Name);
        var ticket = Options.TicketDataFormat.Unprotect(cookie, GetTlsTokenBinding());
        return AuthenticateResult.Success(ticket);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们用Cookie示例：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication(options =&amp;gt; options.DefaultScheme = CookieAuthenticationDefaults.AuthenticationScheme).AddCookie(options =&amp;gt; options.Cookie.Path = &quot;/&quot;);
}
public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.Map(&quot;/login&quot;, app2 =&amp;gt; app2.Run(async context =&amp;gt;
    {
        var claimIdentity = new ClaimsIdentity();
        claimIdentity.AddClaim(new Claim(ClaimTypes.Name, Guid.NewGuid().ToString(&quot;N&quot;)));
        await context.SignInAsync(new ClaimsPrincipal(claimIdentity));
    }));

    app.UseAuthentication();

    app.Run(context =&amp;gt; context.Response.WriteAsync(context.User?.Identity?.IsAuthenticated ?? false ? context.User.Identity.Name : &quot;No Login!&quot;));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当访问login的时候，将返回Cookie。再访问除了login以外的页面时则返回一个guid。&lt;/p&gt;
&lt;h2 id=&quot;模拟身份认证&quot;&gt;模拟身份认证&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class DemoHandle : IAuthenticationSignInHandler
{
    private HttpContext _context;
    private AuthenticationScheme _authenticationScheme;
    private string _cookieName = &quot;user&quot;;

    public Task InitializeAsync(AuthenticationScheme scheme, HttpContext context)
    {
        _context = context;
        _authenticationScheme = scheme;
        return Task.CompletedTask;
    }

    public Task&amp;lt;AuthenticateResult&amp;gt; AuthenticateAsync()
    {
        var cookie = _context.Request.Cookies[_cookieName];
        if (string.IsNullOrEmpty(cookie))
        {
            return Task.FromResult(AuthenticateResult.NoResult());
        }
        var identity = new ClaimsIdentity(_authenticationScheme.Name);
        identity.AddClaim(new Claim(ClaimTypes.Name, cookie));
        var ticket = new AuthenticationTicket(new ClaimsPrincipal(identity), _authenticationScheme.Name);
        return Task.FromResult(AuthenticateResult.Success(ticket));
    }

    public Task SignInAsync(ClaimsPrincipal user, AuthenticationProperties properties)
    {
        _context.Response.Cookies.Append(_cookieName, user.Identity.Name);
        return Task.CompletedTask;
    }
}

public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication(options =&amp;gt;
    {
        options.DefaultScheme = &quot;cookie&quot;;
        options.AddScheme&amp;lt;DemoHandle&amp;gt;(&quot;cookie&quot;, null);
    });
}

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.Map(&quot;/login&quot;, app2 =&amp;gt; app2.Run(async context =&amp;gt;
    {
        var claimIdentity = new ClaimsIdentity();
        claimIdentity.AddClaim(new Claim(ClaimTypes.Name, Guid.NewGuid().ToString(&quot;N&quot;)));
        await context.SignInAsync(new ClaimsPrincipal(claimIdentity));
        context.Response.Redirect(&quot;/&quot;);
    }));

    app.UseAuthentication();

    app.Run(context =&amp;gt; context.Response.WriteAsync(context.User?.Identity?.IsAuthenticated ?? false ? context.User.Identity.Name : &quot;No Login!&quot;));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认访问根目录的时候，显示“No Login”&lt;br/&gt;当用户访问login路径的时候，会跳转到根目录，并显示登录成功。&lt;br/&gt;这里稍微补充一下Identity.IsAuthenticated =&amp;gt; !string.IsNullOrEmpty(_authenticationType);&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.cnblogs.com/neverc/p/8037477.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/neverc/p/8037477.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Dec 2017 06:20:00 +0000</pubDate>
<dc:creator>Never、C</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/neverc/p/8037477.html</dc:identifier>
</item>
<item>
<title>javascript设计模式——发布订阅模式 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8031564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8031564.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　发布—订阅模式又叫观察者模式，它定义对象间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在javascript开发中，一般用事件模型来替代传统的发布—订阅模式。本文将详细介绍发布订阅模式&lt;/p&gt;

&lt;h3&gt;现实事例&lt;/h3&gt;
&lt;p&gt;　　不论是在程序世界里还是现实生活中，发布—订阅模式的应用都非常广泛&lt;/p&gt;
&lt;p&gt;　　比如，小明最近看上了一套房子，到了售楼处之后才被告知，该楼盘的房子早已售罄。好在售楼处工作人员告诉小明，不久后还有一些尾盘推出，开发商正在办理相关手续，手续办好后便可以购买。但到底是什么时候，目前还没有人能够知道。于是小明记下了售楼处的电话，以后每天都会打电话过去询问是不是已经到了购买时间。除了小明，还有小红、小强、小龙也会每天向售楼处咨询这个问题。一个星期过后，该工作人员决定辞职，因为厌倦了每天回答1000个相同内容的电话&lt;/p&gt;
&lt;p&gt;　　当然现实中没有这么笨的销售公司，实际上故事是这样的：小明离开之前，把电话号码留在了售楼处。售楼处工作人员答应他，新楼盘一推出就马上发信息通知小明。小红、小强和小龙也是一样，他们的电话号码都被记在售楼处的花名册上，新楼盘推出的时候，售楼处工作人员会翻开花名册，遍历上面的电话号码，依次发送一条短信来通知他们&lt;/p&gt;
&lt;p&gt;　　在上面的例子中，发送短信通知就是一个典型的发布—订阅模式，小明、小红等购买者都是订阅者，他们订阅了房子开售的消息。售楼处作为发布者，会在合适的时候遍历花名册上的电话号码，依次给购房者发布消息&lt;/p&gt;
&lt;p&gt;　　使用发布—订阅模式有着显而易见的优点：购房者不用再天天给售楼处打电话咨询开售时间，在合适的时间点，售楼处作为发布者会通知这些消息订阅者；购房者和售楼处之间不再强耦合在一起，当有新的购房者出现时，他只需把手机号码留在售楼处，售楼处不关心购房者的任何情况，不管购房者是男是女还是一只猴子。而售楼处的任何变动也不会影响购买者，比如售楼处工作人员离职，售楼处从一楼搬到二楼，这些改变都跟购房者无关，只要售楼处记得发短信这件事情&lt;/p&gt;

&lt;h3&gt;DOM事件&lt;/h3&gt;
&lt;p&gt;　　发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，可以订阅ajax请求的error、succ等事件。或者如果想在动画的每一帧完成之后做一些事情，可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布—订阅模式，就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点&lt;/p&gt;
&lt;p&gt;　　发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们&lt;/p&gt;
&lt;p&gt;　　实际上，只要在DOM节点上面绑定过事件函数，那就使用过发布—订阅模式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
document.body.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(){
  alert(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
document.body.click();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟用户点击&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在这里需要监控用户点击document.body的动作，但是没办法预知用户将在什么时候点击。所以订阅document.body上的click事件，当body节点被点击时，body节点便会向订阅者发布这个消息&lt;/p&gt;
&lt;p&gt;　　当然还可以随意增加或者删除订阅者，增加任何订阅者都不会影响发布者代码的编写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
document.body.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(){
  alert(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
document.body.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(){
  alert(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
document.body.addEventListener(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(){
  alert(&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
document.body.click();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟用户点击&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　[注意]手动触发事件更好的做法是IE下用fireEvent，标准浏览器下用dispatchEvent实现&lt;/p&gt;

&lt;h3&gt;自定义事件&lt;/h3&gt;
&lt;p&gt;　　除了DOM事件，还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布—订阅模式可以用于任何javascript代码中&lt;/p&gt;
&lt;p&gt;　　下面是实现发布—订阅模式的步骤：&lt;/p&gt;
&lt;p&gt;　　1、先要指定好谁充当发布者（比如售楼处）&lt;/p&gt;
&lt;p&gt;　　2、然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者（售楼处的花名册）&lt;/p&gt;
&lt;p&gt;　　3、最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）&lt;/p&gt;
&lt;p&gt;　　另外，还可以往回调函数里填入一些参数，订阅者可以接收这些参数。这是很有必要的，比如售楼处可以在发给订阅者的短信里加上房子的单价、面积、容积率等信息，订阅者接收到这些信息之后可以进行各自的处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; salesOffices = {}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义售楼处&lt;/span&gt;
salesOffices.clientList = []; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缓存列表，存放订阅者的回调函数&lt;/span&gt;
salesOffices.listen = function( fn ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 增加订阅者&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.clientList.push( fn ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅的消息添加进缓存列表&lt;/span&gt;
&lt;span&gt;};
salesOffices.trigger &lt;/span&gt;= function(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布消息&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, fn; fn = &lt;span&gt;this&lt;/span&gt;.clientList[ i++&lt;span&gt; ]; ){
        fn.apply( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, arguments ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (2) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; arguments 是发布消息时带上的参数&lt;/span&gt;
&lt;span&gt;    }
};&lt;/span&gt;
salesOffices.listen( function( price, squareMeter ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小明订阅消息&lt;/span&gt;
    console.log( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;价格= &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; price );
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter= &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; squareMeter );
});

salesOffices.listen( function( price, squareMeter ){ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小红订阅消息&lt;/span&gt;
    console.log( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;价格= &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; price );
    console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter= &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; squareMeter );
});

salesOffices.trigger( &lt;/span&gt;&lt;span&gt;2000000&lt;/span&gt;, &lt;span&gt;88&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：200 万，88 平方米&lt;/span&gt;
salesOffices.trigger( &lt;span&gt;3000000&lt;/span&gt;, &lt;span&gt;110&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：300 万，110 平方米&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，已经实现了一个最简单的发布—订阅模式，但这里还存在一些问题。看到订阅者接收到了发布者发布的每个消息，虽然小明只想买88平方米的房子，但是发布者把110平方米的信息也推送给了小明，这对小明来说是不必要的困扰。所以有必要增加一个标示key，让订阅者只订阅自己感兴趣的消息。改写后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; salesOffices = {}; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义售楼处&lt;/span&gt;
salesOffices.clientList = []; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缓存列表，存放订阅者的回调函数&lt;/span&gt;
&lt;span&gt;
salesOffices.listen &lt;/span&gt;=&lt;span&gt; function( key, fn ){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;this&lt;/span&gt;.clientList[ key ] ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果还没有订阅过此类消息，给该类消息创建一个缓存列表&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.clientList[ key ] =&lt;span&gt; [];
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clientList[ key ].push( fn ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅的消息添加进消息缓存列表&lt;/span&gt;
&lt;span&gt;};

salesOffices.trigger &lt;/span&gt;= function(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布消息&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; key = Array.prototype.shift.call( arguments ), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出消息类型&lt;/span&gt;
    fns = &lt;span&gt;this&lt;/span&gt;.clientList[ key ]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出该消息对应的回调函数集合&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ( !fns || fns.length === &lt;span&gt;0&lt;/span&gt; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有订阅该消息，则返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, fn; fn = fns[ i++&lt;span&gt; ]; ){
        fn.apply( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, arguments ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (2) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; arguments 是发布消息时附送的参数&lt;/span&gt;
&lt;span&gt;    }
};

salesOffices.listen( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter88&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function( price ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小明订阅88 平方米房子的消息&lt;/span&gt;
    console.log( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;价格= &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + price ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： 2000000&lt;/span&gt;
&lt;span&gt;});

salesOffices.listen( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter110&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function( price ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小红订阅110 平方米房子的消息&lt;/span&gt;
    console.log( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;价格= &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + price ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出： 3000000&lt;/span&gt;
&lt;span&gt;});

salesOffices.trigger( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter88&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2000000&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布88 平方米房子的价格&lt;/span&gt;
salesOffices.trigger( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter110&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;3000000&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发布110 平方米房子的价格&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　很明显，现在订阅者可以只订阅自己感兴趣的事件了&lt;/p&gt;

&lt;h3&gt;通用实现&lt;/h3&gt;
&lt;p&gt;　　有没有办法可以让所有对象都拥有发布—订阅功能呢？有的，javascript作为一门解释执行的语言，给对象动态添加职责是理所当然的事情。所以把发布—订阅的功能提取出来，放在一个单独的对象内：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; =&lt;span&gt; {
    clientList: [],
    listen: function( key, fn ){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientList[ key ] ){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clientList[ key ] =&lt;span&gt; [];
        }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clientList[ key ].push( fn ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订阅的消息添加进缓存列表&lt;/span&gt;
&lt;span&gt;        },
        trigger: function(){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = Array.prototype.shift.call( arguments ), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (1);&lt;/span&gt;
            fns = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientList[ key ];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !fns || fns.length === &lt;span&gt;0&lt;/span&gt; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有绑定对应的消息&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, fn; fn = fns[ i++&lt;span&gt; ]; ){
                fn.apply( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, arguments ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (2) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; arguments 是trigger 时带上的参数&lt;/span&gt;
&lt;span&gt;            }
        }
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再定义一个installEvent函数，这个函数可以给所有的对象都动态安装发布—订阅功能：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; installEvent =&lt;span&gt; function( obj ){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; ){
        obj[ i ] &lt;/span&gt;= &lt;span&gt;event&lt;/span&gt;&lt;span&gt;[ i ];
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面给售楼处对象salesOffices动态增加发布—订阅功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; salesOffices =&lt;span&gt; {};
installEvent( salesOffices );
salesOffices.listen( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter88&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function( price ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小明订阅消息&lt;/span&gt;
    console.log( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;价格= &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; price );
});
salesOffices.listen( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter100&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function( price ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小红订阅消息&lt;/span&gt;
    console.log( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;价格= &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; price );
});
salesOffices.trigger( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter88&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2000000&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：2000000&lt;/span&gt;
salesOffices.trigger( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter100&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;3000000&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：3000000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【取消订阅】&lt;/p&gt;
&lt;p&gt;　　有时候，也许需要取消订阅事件的功能。比如小明突然不想买房子了，为了避免继续接收到售楼处推送过来的短信，小明需要取消之前订阅的事件。现在给event对象增加remove方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;event&lt;/span&gt;.remove =&lt;span&gt; function( key, fn ){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fns = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clientList[ key ];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !fns ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果key 对应的消息没有被人订阅，则直接返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !fn ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有传入具体的回调函数，表示需要取消key 对应消息的所有订阅&lt;/span&gt;
        fns &amp;amp;&amp;amp; ( fns.length = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; );
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; l = fns.length - &lt;span&gt;1&lt;/span&gt;; l &amp;gt;=&lt;span&gt;0&lt;/span&gt;; l-- ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反向遍历订阅的回调函数列表&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; _fn =&lt;span&gt; fns[ l ];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( _fn ===&lt;span&gt; fn ){
                fns.splice( l, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除订阅者的回调函数&lt;/span&gt;
&lt;span&gt;            }
        }
    }
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; salesOffices =&lt;span&gt; {};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; installEvent =&lt;span&gt; function( obj ){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; ){
        obj[ i ] &lt;/span&gt;= &lt;span&gt;event&lt;/span&gt;&lt;span&gt;[ i ];
    }
}
installEvent( salesOffices );

salesOffices.listen( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter88&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fn1 = function( price ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小明订阅消息&lt;/span&gt;
    console.log( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;价格= &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; price );
});

salesOffices.listen( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter88&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fn2 = function( price ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小红订阅消息&lt;/span&gt;
    console.log( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;价格= &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; price );
});

salesOffices.remove( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter88&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, fn1 ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除小明的订阅&lt;/span&gt;
salesOffices.trigger( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter88&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2000000&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：2000000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;网站登录&lt;/h3&gt;
&lt;p&gt;　　假如正在开发一个商城网站，网站里有header头部、nav导航、消息列表、购物车等模块。这几个模块的渲染有一个共同的前提条件，就是必须先用ajax异步请求获取用户的登录信息。这是很正常的，比如用户的名字和头像要显示在header模块里，而这两个字段都来自用户登录后返回的信息。至于ajax请求什么时候能成功返回用户信息，这点没有办法确定&lt;/p&gt;
&lt;p&gt;　　但现在还不足以说服在此使用发布—订阅模式，因为异步的问题通常也可以用回调函数来解决。更重要的一点是，不知道除了header头部、nav导航、消息列表、购物车之外，将来还有哪些模块需要使用这些用户信息。如果它们和用户信息模块产生了强耦合，比如下面这样的形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;login.succ(function(data){
    header.setAvatar( data.avatar); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置header 模块的头像&lt;/span&gt;
    nav.setAvatar( data.avatar ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置导航模块的头像&lt;/span&gt;
    message.refresh(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新消息列表&lt;/span&gt;
    cart.refresh(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新购物车列表&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在必须了解header模块里设置头像的方法叫setAvatar、购物车模块里刷新的方法叫refresh，这种耦合性会使程序变得僵硬，header模块不能随意再改变setAvatar的方法名，它自身的名字也不能被改为header1、header2。这是针对具体实现编程的典型例子，针对具体实现编程是不被赞同的&lt;/p&gt;
&lt;p&gt;　　等到有一天，项目中又新增了一个收货地址管理的模块，在最后部分加上这行代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;login.succ(function(data){
    header.setAvatar( data.avatar); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置header 模块的头像&lt;/span&gt;
    nav.setAvatar( data.avatar ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置导航模块的头像&lt;/span&gt;
    message.refresh(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新消息列表&lt;/span&gt;
    cart.refresh(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新购物车列表&lt;/span&gt;
&lt;span&gt;    address.refresh();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用发布—订阅模式重写之后，对用户信息感兴趣的业务模块将自行订阅登录成功的消息事件。当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟要做什么，也不想去了解它们的内部细节。改进后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$.ajax(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://xx.com?login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,function(data){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录成功&lt;/span&gt;
  login.trigger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;loginSucc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布登录成功的消息&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　各模块监听登录成功的消息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; header = (function(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; header 模块&lt;/span&gt;
    login.listen( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;loginSucc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function( data){
        header.setAvatar( data.avatar );
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        setAvatar: function( data ){
            console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;设置header 模块的头像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        }
    }
})();

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nav = (function(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; nav 模块&lt;/span&gt;
    login.listen( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;loginSucc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function( data ){
        nav.setAvatar( data.avatar );
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        setAvatar: function( avatar ){
            console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;设置nav 模块的头像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        }
    }
})();&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上所述，随时可以把setAvatar的方法名改成setTouxiang。如果有一天在登录完成之后，又增加一个刷新收货地址列表的行为，那么只要在收货地址模块里加上监听消息的方法即可，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; address = (function(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; nav 模块&lt;/span&gt;
    login.listen( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;loginSucc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function( obj ){
        address.refresh( obj );
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        refresh: function( avatar ){
            console.log( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;刷新收货地址列表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        }
    }
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;全局发布订阅对象&lt;/h3&gt;
&lt;p&gt;　　刚刚实现的发布—订阅模式，给售楼处对象和登录对象都添加了订阅和发布的功能，这里还存在两个小问题：1、给每个发布者对象都添加了listen和trigger方法，以及一个缓存列表clientList，这其实是一种资源浪费；2、小明跟售楼处对象还是存在一定的耦合性，小明至少要知道售楼处对象的名字是salesOffices，才能顺利的订阅到事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
salesOffices.listen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter100&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,function(price){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小明订阅消息&lt;/span&gt;
  console.log(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;价格=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;price);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果小明还关心300平方米的房子，而这套房子的卖家是salesOffices2，这意味着小明要开始订阅salesOffices2对象。见如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
salesOffices2.listen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter300&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,function(price){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小明订阅消息&lt;/span&gt;
  console.log(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;价格=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;price);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实在现实中，买房子未必要亲自去售楼处，只要把订阅的请求交给中介公司，而各大房产公司也只需要通过中介公司来发布房子信息。这样一来，不用关心消息是来自哪个房产公司，在意的是能否顺利收到消息。当然，为了保证订阅者和发布者能顺利通信，订阅者和发布者都必须知道这个中介公司&lt;/p&gt;
&lt;p&gt;　　同样在程序中，发布—订阅模式可以用一个全局的Event对象来实现，订阅者不需要了解消息来自哪个发布者，发布者也不知道消息会推送给哪些订阅者，Event作为一个类似“中介者”的角色，把订阅者和发布者联系起来。见如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Event =&lt;span&gt; (function(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; clientList =&lt;span&gt; {},
    listen,
    trigger,
    remove;
    listen &lt;/span&gt;=&lt;span&gt; function( key, fn ){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;clientList[ key ] ){
            clientList[ key ] &lt;/span&gt;=&lt;span&gt; [];
        }
        clientList[ key ].push( fn );
    };
    trigger &lt;/span&gt;=&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key =&lt;span&gt; Array.prototype.shift.call( arguments ),
        fns &lt;/span&gt;=&lt;span&gt; clientList[ key ];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !fns || fns.length === &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, fn; fn = fns[ i++&lt;span&gt; ]; ){
            fn.apply( &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
        }
    };
    remove &lt;/span&gt;=&lt;span&gt; function( key, fn ){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fns =&lt;span&gt; clientList[ key ];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;fns ){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;fn ){
            fns &lt;/span&gt;&amp;amp;&amp;amp; ( fns.length = &lt;span&gt;0&lt;/span&gt;&lt;span&gt; );
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; l = fns.length - &lt;span&gt;1&lt;/span&gt;; l &amp;gt;=&lt;span&gt;0&lt;/span&gt;; l--&lt;span&gt; ){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _fn =&lt;span&gt; fns[ l ];
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( _fn ===&lt;span&gt; fn ){
                    fns.splice( l, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; );
                }
            }
        }
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
        listen: listen,
        trigger: trigger,
        remove: remove
    }
})();

Event.listen( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter88&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, function( price ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小红订阅消息&lt;/span&gt;
    console.log( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;价格= &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + price ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出：'价格=2000000'&lt;/span&gt;
&lt;span&gt;});

Event.trigger( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;squareMeter88&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2000000&lt;/span&gt; ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 售楼处发布消息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【模块间通信】&lt;/p&gt;
&lt;p&gt;　　上面实现的发布—订阅模式的实现，是基于一个全局的Event对象，利用它可以在两个封装良好的模块中进行通信，这两个模块可以完全不知道对方的存在&lt;/p&gt;
&lt;p&gt;　　比如现在有两个模块，a模块里面有一个按钮，每次点击按钮之后，b模块里的div中会显示按钮的总点击次数，用全局发布—订阅模式完成下面的代码，使得a模块和b模块可以在保持封装性的前提下进行通信&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;button id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;点我&amp;lt;/button&amp;gt;
&amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/JavaScript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &lt;span&gt;var&lt;/span&gt; a =&lt;span&gt; (function(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; button = document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );&lt;/span&gt;&lt;span&gt;
        button.onclick &lt;/span&gt;=&lt;span&gt; function(){
            Event.trigger( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, count++&lt;span&gt; );
        }
    })();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; (function(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; div = document.getElementById( &lt;span&gt;'&lt;/span&gt;&lt;span&gt;show&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; );
        Event.listen( &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function( count ){
            div.innerHTML &lt;/span&gt;=&lt;span&gt; count;
        });
    })();
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但要留意一个问题，模块之间如果用了太多的全局发布—订阅模式来通信，那么模块与模块之间的联系就被隐藏到了背后。最终会搞不清楚消息来自哪个模块，或者消息会流向哪些模块，这又会给维护带来一些麻烦，也许某个模块的作用就是暴露一些接口给其他模块调用&lt;/p&gt;
&lt;p&gt;【先发布后订阅】&lt;/p&gt;
&lt;p&gt;　　常见的发布—订阅模式，都是订阅者必须先订阅一个消息，随后才能接收到发布者发布的消息。在某些情况下，需要先将这条消息保存下来，等到有对象来订阅它的时候，再重新把消息发布给订阅者。就如同QQ中的离线消息一样，离线消息被保存在服务器中，接收人下次登录上线之后，可以重新收到这条消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************先发布后订阅*******************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Event.trigger(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
Event.listen(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(a){
  console.log(a);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：1&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种需求在实际项目中是存在的，比如在商城网站中，获取到用户信息之后才能渲染用户导航模块，而获取用户信息的操作是一个ajax异步请求。当ajax请求成功返回之后会发布一个事件，在此之前订阅了此事件的用户导航模块可以接收到这些用户信息&lt;/p&gt;
&lt;p&gt;　　但是这只是理想的状况，因为异步的原因，不能保证ajax请求返回的时间，有时候它返回得比较快，而此时用户导航模块的代码还没有加载好（还没有订阅相应事件），特别是在用了一些模块化惰性加载的技术后，这是很可能发生的事情。也许还需要一个方案，使得的发布—订阅对象拥有先发布后订阅的能力&lt;/p&gt;
&lt;p&gt;　　为了满足这个需求，要建立一个存放离线事件的堆栈，当事件发布的时候，如果此时还没有订阅者来订阅这个事件，暂时把发布事件的动作包裹在一个函数里，这些包装函数将被存入堆栈中，等到终于有对象来订阅此事件的时候，将遍历堆栈并且依次执行这些包装函数，也就是重新发布里面的事件。当然离线事件的生命周期只有一次，就像QQ的未读消息只会被重新阅读一次，所以刚才的操作只能进行一次&lt;/p&gt;
&lt;p&gt;【全局事件的命名冲突】&lt;/p&gt;
&lt;p&gt;　　全局的发布—订阅对象里只有一个clinetList来存放消息名和回调函数，大家都通过它来订阅和发布各种消息，久而久之，难免会出现事件名冲突的情况，所以还可以给Event对象提供创建命名空间的功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*************使用命名空间*******************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Event.create(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;namespace1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).listen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(a){
  console.log(a);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：1&lt;/span&gt;
&lt;span&gt;});
Event.create(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;namespace1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).trigger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
Event.create(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;namespace2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).listen(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(a){
  console.log(a);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：2&lt;/span&gt;
&lt;span&gt;});
Event.create(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;namespace2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).trigger(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面是完整代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;99&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Event =&lt;span&gt; (function(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
    Event,
    _default &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    Event &lt;/span&gt;=&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; _listen,
        _trigger,
        _remove,
        _slice &lt;/span&gt;=&lt;span&gt; Array.prototype.slice,
        _shift &lt;/span&gt;=&lt;span&gt; Array.prototype.shift,
        _unshift &lt;/span&gt;=&lt;span&gt; Array.prototype.unshift,
        namespaceCache &lt;/span&gt;=&lt;span&gt; {},
        _create,
        find,
        each &lt;/span&gt;=&lt;span&gt; function( ary, fn ){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; ret;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;, l = ary.length; i &amp;lt; l; i++&lt;span&gt; ){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; n =&lt;span&gt; ary[i];
                ret &lt;/span&gt;=&lt;span&gt; fn.call( n, i, n);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
        };
        _listen &lt;/span&gt;=&lt;span&gt; function( key, fn, cache ){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !&lt;span&gt;cache[ key ] ){
                cache[ key ] &lt;/span&gt;=&lt;span&gt; [];
            }
            cache[key].push( fn );
        };
        _remove &lt;/span&gt;=&lt;span&gt; function( key, cache ,fn){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( cache[ key ] ){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;( fn ){
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i = cache[ key ].length; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt; ){
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( cache[ key ] ===&lt;span&gt; fn ){
                            cache[ key ].splice( i, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt; );
                        }
                    }
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    cache[ key ] &lt;/span&gt;=&lt;span&gt; [];
                }
            }
        };
        _trigger &lt;/span&gt;=&lt;span&gt; function(){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cache =&lt;span&gt; _shift.call(arguments),
            key &lt;/span&gt;=&lt;span&gt; _shift.call(arguments),
            args &lt;/span&gt;=&lt;span&gt; arguments,
            _self &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
            ret,
            stack &lt;/span&gt;=&lt;span&gt; cache[ key ];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( !stack || !&lt;span&gt;stack.length ){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; each( stack, function(){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.apply( _self, args );
            });
        };
        _create &lt;/span&gt;= function( &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt; = &lt;span&gt;namespace&lt;/span&gt; ||&lt;span&gt; _default;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cache =&lt;span&gt; {},
            offlineStack &lt;/span&gt;= [], &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 离线事件&lt;/span&gt;
            ret =&lt;span&gt; {
                listen: function( key, fn, last ){
                    _listen( key, fn, cache );
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( offlineStack === &lt;span&gt;null&lt;/span&gt;&lt;span&gt; ){
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( last === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;last&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ){
                    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                        each( offlineStack, function(){
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
                        });
                    }
                    offlineStack &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                },
                one: function( key, fn, last ){
                    _remove( key, cache );
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.listen( key, fn ,last );
                },
                remove: function( key, fn ){
                    _remove( key, cache ,fn);
                },
                trigger: function(){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; fn,
                    args,
                    _self &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
                    _unshift.call( arguments, cache );
                    args &lt;/span&gt;=&lt;span&gt; arguments;
                    fn &lt;/span&gt;=&lt;span&gt; function(){
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _trigger.apply( _self, args );
                    };
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( offlineStack ){
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; offlineStack.push( fn );
                    }
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fn();
                }
            };
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt; ?&lt;span&gt;
            ( namespaceCache[ &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt; ] ? namespaceCache[ &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ] :
                namespaceCache[ &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt; ] =&lt;span&gt; ret )
            : ret;
        };
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            create: _create,
            one: function( key,fn, last ){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.create( );
                &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;&lt;span&gt;.one( key,fn,last );
            },
            remove: function( key,fn ){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.create( );
                &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;&lt;span&gt;.remove( key,fn );
            },
            listen: function( key, fn, last ){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.create( );
                &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;&lt;span&gt;.listen( key, fn, last );
            },
            trigger: function(){
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;event&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.create( );
                &lt;/span&gt;&lt;span&gt;event&lt;/span&gt;.trigger.apply( &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments );
            }
        };
    }();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Event;
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　发布—订阅模式，也就是常说的观察者模式，它的优点非常明显，一为时间上的解耦，二为对象之间的解耦。应用也非常广泛，既可以用在异步编程中，也可以帮助完成更松耦合的代码编写。发布—订阅模式还可以用来帮助实现一些别的设计模式，比如中介者模式。从架构上来看，无论是MVC还是MVVM，都少不了发布—订阅模式的参与，而且javascript本身也是一门基于事件驱动的语言&lt;/p&gt;
&lt;p&gt;　　当然，发布—订阅模式也不是完全没有缺点。创建订阅者本身要消耗一定的时间和内存，而且订阅一个消息后，也许此消息最后都未发生，但这个订阅者会始终存在于内存中。另外，发布—订阅模式虽然可以弱化对象之间的联系，但如果过度使用的话，对象和对象之间的必要联系也将被深埋在背后，会导致程序难以跟踪维护和理解。特别是有多个发布者和订阅者嵌套到一起的时候，要跟踪一个bug不是件轻松的事情&lt;/p&gt;

</description>
<pubDate>Thu, 14 Dec 2017 05:18:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8031564.html</dc:identifier>
</item>
<item>
<title>网络虚拟化 - bakari</title>
<link>http://www.cnblogs.com/bakari/p/8037105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bakari/p/8037105.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;网络虚拟化相对计算、存储虚拟化来说是比较抽象的，以我们在学校书本上学的那点网络知识来理解网络虚拟化可能是不够的。&lt;/p&gt;
&lt;p&gt;在我们的印象中，网络就是由各种网络设备（如交换机、路由器）相连组成的一个网状结构，世界上的任何两个人都可以通过网络建立起连接。&lt;/p&gt;
&lt;p&gt;带着这样一种思路去理解网络虚拟化可能会感觉云里雾里——这样一个庞大的网络如何实现虚拟化？&lt;/p&gt;
&lt;p&gt;其实，网络虚拟化更多关注的是数据中心网络、主机网络这样比较「细粒度」的网络，所谓细粒度，是相对来说的，是深入到某一台物理主机之上的网络结构来谈的。&lt;/p&gt;
&lt;p&gt;如果把传统的网络看作「宏观网络」的话，那网络虚拟化关注的就是「微观网络」。网络虚拟化的目的，是要节省物理主机的网卡设备资源。从资源这个角度去理解，可能会比较好理解一点。&lt;/p&gt;
&lt;h2 id=&quot;传统网络架构&quot;&gt;传统网络架构&lt;/h2&gt;
&lt;p&gt;在传统网络环境中，一台物理主机包含一个或多个网卡（NIC），要实现与其他物理主机之间的通信，需要通过自身的 NIC 连接到外部的网络设施，如交换机上，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171214124122201-325159441.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种架构下，为了对应用进行隔离，往往是将一个应用部署在一台物理设备上，这样会存在两个问题，1）是某些应用大部分情况可能处于空闲状态，2）是当应用增多的时候，只能通过增加物理设备来解决扩展性问题。不管怎么样，这种架构都会对物理资源造成极大的浪费。&lt;/p&gt;
&lt;h2 id=&quot;虚拟化网络架构&quot;&gt;虚拟化网络架构&lt;/h2&gt;
&lt;p&gt;为了解决这个问题，可以借助虚拟化技术对一台物理资源进行抽象，将一张物理网卡虚拟成多张虚拟网卡（vNIC），通过虚拟机来隔离不同的应用。&lt;/p&gt;
&lt;p&gt;这样对于上面的问题 1），可以利用虚拟化层 Hypervisor 的调度技术，将资源从空闲的应用上调度到繁忙的应用上，达到资源的合理利用；针对问题 2），可以根据物理设备的资源使用情况进行横向扩容，除非设备资源已经用尽，否则没有必要新增设备。这种架构如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171214124154982-781297498.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中虚拟机与虚拟机之间的通信，由虚拟交换机完成，虚拟网卡和虚拟交换机之间的链路也是虚拟的链路，整个主机内部构成了一个虚拟的网络，如果虚拟机之间涉及到三层的网络包转发，则又由另外一个角色——虚拟路由器来完成。&lt;/p&gt;
&lt;p&gt;一般，这一整套虚拟网络的模块都可以独立出去，由第三方来完成，如其中比较出名的一个解决方案就是 Open vSwitch（OVS）。&lt;/p&gt;
&lt;p&gt;OVS 的优势在于它基于 SDN 的设计原则，方便虚拟机集群的控制与管理，另外就是它分布式的特性，可以「透明」地实现跨主机之间的虚拟机通信，如下是跨主机启用 OVS 通信的图示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171214124231185-514213579.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结下来，网络虚拟化主要解决的是虚拟机构成的网络通信问题，完成的是各种网络设备的虚拟化，如网卡、交换设备、路由设备等。&lt;/p&gt;
&lt;h2 id=&quot;linux-下网络设备虚拟化的几种形式&quot;&gt;Linux 下网络设备虚拟化的几种形式&lt;/h2&gt;
&lt;p&gt;为了完成虚拟机在同主机和跨主机之间的通信，需要借助某种“桥梁”来完成用户态到内核态（Guest 到 Host）的数据传输，这种桥梁的角色就是由虚拟的网络设备来完成，上面介绍了一个第三方的开源方案——OVS，它其实是一个融合了各种虚拟网络设备的集大成者，是一个产品级的解决方案。&lt;/p&gt;
&lt;p&gt;但 Linux 本身由于虚拟化技术的演进，也集成了一些虚拟网络设备的解决方案，主要有以下几种：&lt;/p&gt;
&lt;h3 id=&quot;taptunveth&quot;&gt;（1）TAP/TUN/VETH&lt;/h3&gt;
&lt;p&gt;TAP/TUN 是 Linux 内核实现的一对虚拟网络设备，TAP 工作在二层，TUN 工作在三层。Linux 内核通过 TAP/TUN 设备向绑定该设备的用户空间程序发送数据，反之，用户空间程序也可以像操作物理网络设备那样，向 TAP/TUN 设备发送数据。&lt;/p&gt;
&lt;p&gt;基于 TAP 驱动，即可实现虚拟机 vNIC 的功能，虚拟机的每个 vNIC 都与一个 TAP 设备相连，vNIC 之于 TAP 就如同 NIC 之于 eth。&lt;/p&gt;
&lt;p&gt;当一个 TAP 设备被创建时，在 Linux 设备文件目录下会生成一个对应的字符设备文件，用户程序可以像打开一个普通文件一样对这个文件进行读写。&lt;/p&gt;
&lt;p&gt;比如，当对这个 TAP 文件执行 write 操作时，相当于 TAP 设备收到了数据，并请求内核接受它，内核收到数据后将根据网络配置进行后续处理，处理过程类似于普通物理网卡从外界收到数据。当用户程序执行 read 请求时，相当于向内核查询 TAP 设备是否有数据要发送，有的话则发送，从而完成 TAP 设备的数据发送。&lt;/p&gt;
&lt;p&gt;TUN 则属于网络中三层的概念，数据收发过程和 TAP 是类似的，只不过它要指定一段 IPv4 地址或 IPv6 地址，并描述其相关的配置信息，其数据处理过程也是类似于普通物理网卡收到三层 IP 报文数据。&lt;/p&gt;
&lt;p&gt;VETH 设备总是成对出现，一端连着内核协议栈，另一端连着另一个设备，一个设备收到内核发送的数据后，会发送到另一个设备上去，这种设备通常用于容器中两个 namespace 之间的通信。&lt;/p&gt;
&lt;h3 id=&quot;bridge&quot;&gt;（2）Bridge&lt;/h3&gt;
&lt;p&gt;Bridge 也是 Linux 内核实现的一个工作在二层的虚拟网络设备，但不同于 TAP/TUN 这种单端口的设备，Bridge 实现为多端口，本质上是一个虚拟交换机，具备和物理交换机类似的功能。&lt;/p&gt;
&lt;p&gt;Bridge 可以绑定其他 Linux 网络设备作为从设备，并将这些从设备虚拟化为端口，当一个从设备被绑定到 Bridge 上时，就相当于真实网络中的交换机端口上插入了一根连有终端的网线。&lt;/p&gt;
&lt;p&gt;如下图所示，Bridge 设备 br0 绑定了实际设备 eth0 和 虚拟设备设备 tap0/tap1，当这些从设备接收到数据时，会发送给 br0 ，br0 会根据 MAC 地址与端口的映射关系进行转发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171214124456982-1971018216.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为 Bridge 工作在二层，所以绑定到它上面的从设备 eth0、tap0、tap1 均不需要设 IP，但是需要为 br0 设置 IP，因为对于上层路由器来说，这些设备位于同一个子网，需要一个统一的 IP 将其加入路由表中。&lt;/p&gt;
&lt;p&gt;这里有人可能会有疑问，Bridge 不是工作在二层吗，为什么会有 IP 的说法？其实 Bridge 虽然工作在二层，但它只是 Linux 网络设备抽象的一种，能设 IP 也不足为奇。&lt;/p&gt;
&lt;p&gt;对于实际设备 eth0 来说，本来它是有自己的 IP 的，但是绑定到 br0 之后，其 IP 就生效了，就和 br0 共享一个 IP 网段了，在设路由表的时候，就需要将 br0 设为目标网段的地址。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;传统网络架构到虚拟化的网络架构，可以看作是宏观网络到微观网络的过渡&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;TAP/TUN/VETH、Bridge 这些虚拟的网络设备是 Linux 为了实现网络虚拟化而实现的网络设备模块，很多的云开源项目的网络功能都是基于这些技术做的，比如 Neutron、Docker network 等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;OVS 是一个开源的成熟的产品级分布式虚拟交换机，基于 SDN 的思想，被大量应用在生产环境中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;PSS：&lt;/strong&gt;&lt;br/&gt;我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：&lt;a href=&quot;https://cloud.tencent.com/developer/support-plan&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/support-plan&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;另外，对云计算感兴趣的小伙伴可以关注我的微信公众号：云计算小白，专注云计算领域，坚持分享干货。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/431521/201712/431521-20171214124936404-1971489142.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Dec 2017 04:51:00 +0000</pubDate>
<dc:creator>bakari</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bakari/p/8037105.html</dc:identifier>
</item>
<item>
<title>【学习的艺术】钱会不会来？ - 张泰峰</title>
<link>http://www.cnblogs.com/ztfjs/p/8036863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ztfjs/p/8036863.html</guid>
<description>&lt;h2 id=&quot;w1&quot; class=&quot;wtitle&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;　&lt;span&gt;　读过 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/JavaArchitect/p/8031080.html&quot;&gt;累和加班多没时间都不是理由，再不挣钱就老啦&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后，脑子里一些想法蹭的生长出来。此文说不出是反对还是支持吧，就有觉得，或许可以从另一个角度阐述这个问题，作者总结的挺不错的，但是这不全是我们真正需要的。 金钱驱动下的学习势必不会过于深入，从金钱这个出发点去开始学习，是一种比较危险的行为，这怎么说呢，如果你需要达到更高的境界，这种观念是必须要摈弃的，当然你也可以挣点小钱，进一家好一点的公司，这也不能说没有追求，大部分的我们也就到这个点差不多了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是...但是...请不要这么快的放弃，你要相信，钱总会来的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（图片来自网络，如有版权问题，立删）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/893115/201712/893115-20171214114941482-1501639067.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;w1&quot; class=&quot;wtitle&quot;&gt;钱总会来的&lt;/h2&gt;
&lt;p&gt;　　是的，钱总是会来的，钱为什么一定会来，因为你的学习到位了，技术到位了，情商智商到位了。&lt;/p&gt;
&lt;p&gt;引用一段文中的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;工作满3年，发展好的人可以进大公司，在里面至少稳定，衣食无忧。或者可以进好的互联网公司了，开始双倍经验模式。

工作满5年，这个真就不好说，一般比较好的（还不算也别好的），就可以成为架构师了，按目前流行的技术，Spring Cloud，Hystrix，Kafka这些技术就很溜了。这些人按当前市面上的工资，估计至少3万一个月。

工作满7年，一般比较好的就可以在公司里做技术总监了，有些甚至可以在著名互联网公司的大型团队里成为技术骨干，这些人按当前工资，至少5万一个月。

工作满8到10年，技术好的人估计就有价无市了，比如某个互联网公司要招个技术总监，要求是，钱随便出，服务器随便买，软件框架自己定，但只有一条，搭建一套能应付类似双11并发流量的网站，这些人我前一阵听说，80万一年也不算多。

台上一分钟，台下十年功。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我觉得可以换一种方式表述，&lt;/p&gt;
&lt;p&gt;工作满三年，发展好的人，通过不断的学习，进入了想进的大公司，得到了更好的学习环境，以后更是顺风顺水。&lt;/p&gt;
&lt;p&gt;工作满五年，架构师，也不知作者哪里听到的，首先一个合格的架构师五年的经验是绝记不够的，其次架构需要的产品感知能力，业务能力，也不是敲五年代码能够得到的。起码你敲完五年代码，还有几年了解一些业务吧。Kafka玩的很溜，可知道它具体体现的业务流程，解决了哪些问题，对产品有什么帮助？仅仅是技术玩的溜离架构师还有很远的距离。&lt;/p&gt;
&lt;p&gt;七、八、十年的无需表述了，能坚持这么多年的哥们，要么已经封神，要么还在徘徊，这是两个极端，也是大家的宿命。&lt;/p&gt;
&lt;p&gt;这里面重要的是什么？嗯。。。。&lt;/p&gt;
&lt;p&gt;作者后面提到了他以前浑沌度日，没有目标，不会学习，然后他就定了一些关于金钱的目标，嗯，这确实是我们需要的，我们需要规划我们的生活，需要不断的学习，不断的积累。但是作者的目光可以说比较狭窄。再引用一段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 后来怎么恢复正常的？给自己制定一个目标，最好是和钱有关的目标。我制定过的目标。

    &lt;/span&gt;1 学习完Spring MVC+&lt;span&gt;Hibernate框架，然后跳槽挣更多的钱。这是很多年前，这个框架还流行。

    &lt;/span&gt;2&lt;span&gt; 周末到一个培训学校讲课，能挣点钱，但更能提升自己的表达能力，还能拓展人脉。

    &lt;/span&gt;3&lt;span&gt; 出一本书，名利双周，而且能不断积累，对换工作很有帮助。

    &lt;/span&gt;4&lt;span&gt; 实在不行，去做家教（比如可以到一些培训学校较初中高中语数外等课程），这个我当时计划过，但没做，有更好的挣钱计划了。

    &lt;/span&gt;5&lt;span&gt; 到技术论坛上发文，推广自己的书或其它东西。

    &lt;/span&gt;6 加了很多群，到各群里发软文推广我的书，java web轻量级开发面试教程 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;出书确实能获得名利，但出书如果就是冲着名利去，一定是写不好书的。学习框架，为了挣更多钱，注定了学的不够深入，不够了解原理，为什么？找到工作能干下去就行了嘛，来 下一个目标，下一个框架！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你真的喜爱编程，喜爱工作，或者说喜爱生活，请不要模仿。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为这些都冲着一个字：钱，&lt;/p&gt;
&lt;p&gt;钱者，利也，世人唯利而往。我也爱钱，我工作的目的也是为了钱，但是，学习的过程，写书的过程，写书的结果，这些应该是跟钱关系不大的。&lt;strong&gt;钱对等的是学习的结果 学习的结果对等的是一颗热爱的心，一颗坚定的心。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最容易的学习都是那些自己感兴趣的东西是吧？ &lt;/p&gt;
&lt;p&gt;你学习的时候对钱感兴趣，为什么不去炒股？&lt;/p&gt;
&lt;p&gt;出书为了名利，那书中的知识点，恐怕大部分都是不需要钻研的罢，拿着前人分享的一个个经验，汇聚成一本你名利的书本，而不是那学习的结晶，这一点我想，总有人懂得，所以总会有一些好的、创新的作品，指引我们前进。&lt;/p&gt;
&lt;p&gt;总之，名利无错，为了名利而名利。为了名利而学习，为了名利而写书。。。。。错也许就全盘皆输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;非淡泊无以明志,非宁静无以致远。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;best-text mb-10&quot; readability=&quot;31&quot;&gt;
&lt;span&gt;渊明辞弃官职，居住在一个宁静的村庄，因此有了“采菊东篱下，悠然见南山”的独立人格；&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;周敦颐拒绝官场腐败，才有了“出淤泥而不染”的洁身自好；&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;王冕淡泊名利，留下了“不要人夸好颜色，只留清气满乾坤”的佳话。&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;他们都学会了拒绝名利与金钱的诱惑，他们是我们的楷模，因此流芳千古。 &lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;范仲淹 《岳阳楼记》 不以物喜，不以己悲。  &lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;span readability=&quot;6&quot;&gt;岳飞 《满江红》三十功名尘与土，八千里路云和月。&lt;p&gt;当然我们不可能和他们一样淡泊名利。但是好的学习，好的作品，好的成长，和名利无关。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;热爱是学习的第一动力。不热爱？不喜欢？或者没兴趣？醒醒，换个你喜欢的职业。开发不适合你。&lt;br/&gt;&lt;/strong&gt;&lt;span&gt;（图片来自网络，如有版权问题，立删）&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/893115/201712/893115-20171214114953482-1868455652.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;w1&quot; class=&quot;wtitle&quot;&gt;加班？不加班&lt;/h2&gt;
&lt;p&gt;　　好的学习首先要不加班。&lt;/p&gt;
&lt;p&gt;　　既然反驳了这位作者，拿我就需拿出我自己的观点，也许对，也许不对，至少在我的实践中，我对了一半。&lt;/p&gt;
&lt;p&gt;　　先浅述一下楼主的状况，&lt;/p&gt;
&lt;p&gt;　　从事公安大数据行业，前端+nodejs+可视化，薪资总在15。工作三年。 目前也就算是个高级一点的开发吧，平时项目都是从产品到设计到前端到后端包办，数据嘛，几千个亿数据几百个人处理，so，开发公司需要走全栈。&lt;/p&gt;
&lt;p&gt;　　我很少加班。&lt;/p&gt;
&lt;p&gt;　　一个关于数据云搜的h5应用，设计加前端，三个页面两天完成，无加班（我还能更快）。&lt;/p&gt;
&lt;p&gt;　　不加班秘诀在于，&lt;strong&gt;这里我要抛干货了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;规划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;做到对第二天工作内容的掌控。&lt;/p&gt;
&lt;p&gt;　　首先对项目做一个功能切割，根据经验分配对应的，自己需要的时间，然后分配每一天完成小任务。   这个完成就像是对客户的产品交付，这是给你自己的产品交付。&lt;/p&gt;
&lt;p&gt;　　①功能切割&lt;/p&gt;
&lt;p&gt;　　　　这一点很重要，怎么切割，切割哪些，权重要分配。&lt;/p&gt;
&lt;p&gt;　　②时间分配&lt;/p&gt;
&lt;p&gt;　　　　权重高的放前，低的后，低的可以顺势插入某个权重高的做完之后。&lt;/p&gt;
&lt;p&gt;　　　   例如系统有三个大功能，好那就按三个大功能分，&lt;/p&gt;
&lt;p&gt;　　　　功能3最复杂，权重最高，功能2可有可无，功能3权重中间。&lt;/p&gt;
&lt;p&gt;　　　　现在要你三天完成，定目标 ，1.5天完成功能3。1天完成功能1。半天完成功能2。&lt;/p&gt;
&lt;p&gt;　　③技术渣，分配的时间完不成。&lt;/p&gt;
&lt;p&gt;　　　　 一般来说，只要你技术不是太渣，预估的时间不会太离谱，是能完成的，即使不能完成，在你规划好的时候，脑子里或多或少已经有了一些思路，完成的时间肯定也会提前，但是始终的原则，应该是，&lt;strong&gt;规划时间，做好事件，严格执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么这会有用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;第一次你会觉得吃力，多了会越来越轻松，&lt;/p&gt;
&lt;p&gt;　　这中间有几个要点&lt;/p&gt;
&lt;p&gt;　　　　时间有了规划，你能分清楚娱乐时间、工作时间、学习时间、这几个生活维度都有了，人也就感到愉悦。&lt;/p&gt;
&lt;p&gt;　　　　拒绝加班，即使没完成既定的任务，停下来，该干什么干什么，没完成是为什么？问题想不通。问题想不通的时候，停下来是最好的选择，好的点子往往出现在白光笼罩的时候。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中间还有很多的问题，灵活运用，久之对工作生活有巨大的影响。&lt;/strong&gt;&lt;/p&gt;




&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot; readability=&quot;57&quot;&gt;
&lt;div class=&quot;para&quot; readability=&quot;9&quot;&gt;
&lt;h2 id=&quot;w5&quot; class=&quot;wtitle&quot;&gt;结束&lt;/h2&gt;
&lt;p&gt;　　传达一些想法，表示一些逻辑，实属不易，若笔头略有顿挫，诸君见谅，若观点也有偏差，望各位海涵，然君指出后，言出必思，思之必改，谢谢大家。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 14 Dec 2017 03:39:00 +0000</pubDate>
<dc:creator>张泰峰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ztfjs/p/8036863.html</dc:identifier>
</item>
<item>
<title>docker、oci、runc以及kubernetes梳理 - XuXinkun</title>
<link>http://www.cnblogs.com/xuxinkun/p/8036832.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuxinkun/p/8036832.html</guid>
<description>&lt;p&gt;容器无疑是近年来云计算中最火热的关键词。随着docker的大热，docker、oci、runc、containerd等等名词也逐渐传播开来。这么多的名词，也容易让人混淆。本文对相关名词和其之间的联系进行一下梳理和总结，方便大家更好地理解。&lt;/p&gt;
&lt;h2 id=&quot;container&quot;&gt;container&lt;/h2&gt;
&lt;p&gt;首先说的是&lt;strong&gt;container&lt;/strong&gt;容器。随着docker的大热，docker的经典图标，一条鲸鱼拖着若干个集装箱的经典形象已经深入人心。docker中container的翻译是译为容器还是集装箱，中文社区做过一次小小的讨论。&lt;a href=&quot;http://dockone.io/question/408&quot;&gt;讨论参见http://dockone.io/question/408&lt;/a&gt;。在这次讨论中，笔者的意见是container并不是docker出现了才有的，而在之前，linux container就已经翻译为linux容器并被大家接受。而从含义来看，一开始选定把“容器”作为container的翻译，也应该是准确的。而随着docker出现，container的概念深入人心，而其与原来的linux container中的container，含义应该说是一致的。所以沿用容器的翻译，笔者认为是比较合适的。&lt;/p&gt;
&lt;p&gt;那么何为容器。容器本质上是受到资源限制，彼此间相互隔离的若干个linux进程的集合。这是有别于基于模拟的虚拟机的。对于容器和虚拟机的区别的理解，大家可以参考《京东基础架构建设之路》中的阐释，这里不再赘述。一般来说，容器技术主要指代用于资源限制的cgroup，用于隔离的namespace，以及基础的linux kernel等。&lt;/p&gt;
&lt;h2 id=&quot;oci&quot;&gt;OCI&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Open Container Initiative&lt;/strong&gt;，也就是常说的&lt;strong&gt;OCI&lt;/strong&gt;，是由多家公司共同成立的项目，并由linux基金会进行管理，致力于container runtime的标准的制定和runc的开发等工作。&lt;/p&gt;
&lt;p&gt;所谓&lt;strong&gt;container runtime&lt;/strong&gt;，主要负责的是容器的生命周期的管理。oci的runtime spec标准中对于容器的状态描述，以及对于容器的创建、删除、查看等操作进行了定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;runc&lt;/strong&gt;，是对于OCI标准的一个参考实现，是一个可以用于创建和运行容器的CLI(command-line interface)工具。runc直接与容器所依赖的cgroup/linux kernel等进行交互，负责为容器配置cgroup/namespace等启动容器所需的环境，创建启动容器的相关进程。&lt;/p&gt;
&lt;p&gt;为了兼容oci标准，docker也做了架构调整。将容器运行时相关的程序从docker daemon剥离出来，形成了&lt;strong&gt;containerd&lt;/strong&gt;。Containerd向docker提供运行容器的API，二者通过grpc进行交互。containerd最后会通过runc来实际运行容器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xuxinkun.github.io/img/docker-oci-runc-k8s/containerd.png&quot; alt=&quot;containerd&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;容器引擎&quot;&gt;容器引擎&lt;/h2&gt;
&lt;p&gt;容器引擎，或者说容器平台，不仅包含对于容器的生命周期的管理，还包括了对于容器生态的管理，比如对于镜像等。现在的docker、rkt以及阿里推出的pouch均可属于此范畴。&lt;/p&gt;
&lt;p&gt;docker，笔者认为可以分为两个阶段来理解。在笔者接触docker之初，docker版本为1.2，当时的docker的主要作用是容器的生命周期管理和镜像管理，当时的docker在功能上更趋近于现在的container runtime。而后来，随着docker的发展，docker就不再局限于容器的管理，还囊括了存储(volume)、网络(net)等的管理，因此后来的docker更多的是一个容器及容器生态的管理平台。&lt;/p&gt;
&lt;h2 id=&quot;kubernetes与容器&quot;&gt;kubernetes与容器&lt;/h2&gt;
&lt;p&gt;kubernetes在初期版本里，就对多个容器引擎做了兼容，因此可以使用docker、rkt对容器进行管理。以docker为例，kubelet中会启动一个docker manager，通过直接调用docker的api进行容器的创建等操作。&lt;/p&gt;
&lt;p&gt;在k8s 1.5版本之后，kubernetes推出了自己的运行时接口api--&lt;strong&gt;CRI&lt;/strong&gt;(container runtime interface)。cri接口的推出，隔离了各个容器引擎之间的差异，而通过统一的接口与各个容器引擎之间进行互动。&lt;/p&gt;
&lt;p&gt;与oci不同，cri与kubernetes的概念更加贴合，并紧密绑定。cri不仅定义了容器的生命周期的管理，还引入了k8s中pod的概念，并定义了管理pod的生命周期。在kubernetes中，pod是由一组进行了资源限制的，在隔离环境中的容器组成。而这个隔离环境，称之为&lt;strong&gt;PodSandbox&lt;/strong&gt;。在cri开始之初，主要是支持docker和rkt两种。其中kubelet是通过cri接口，调用docker-shim，并进一步调用docker api实现的。&lt;/p&gt;
&lt;p&gt;如上文所述，docker独立出来了containerd。kubernetes也顺应潮流，孵化了&lt;strong&gt;cri-containerd&lt;/strong&gt;项目，用以将containerd接入到cri的标准中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xuxinkun.github.io/img/docker-oci-runc-k8s/cri-containerd.png&quot; alt=&quot;cri-containerd&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了进一步与oci进行兼容，kubernetes还孵化了&lt;strong&gt;cri-o&lt;/strong&gt;，成为了架设在cri和oci之间的一座桥梁。通过这种方式，可以方便更多符合oci标准的容器运行时，接入kubernetes进行集成使用。可以预见到，通过cri-o，kubernetes在使用的兼容性和广泛性上将会得到进一步加强。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://xuxinkun.github.io/img/docker-oci-runc-k8s/kubelet.png&quot; alt=&quot;kubelet&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Thu, 14 Dec 2017 03:33:00 +0000</pubDate>
<dc:creator>XuXinkun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuxinkun/p/8036832.html</dc:identifier>
</item>
</channel>
</rss>