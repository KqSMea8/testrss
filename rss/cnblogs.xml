<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JDBC详解系列（二）之加载驱动 - 人不学习枉少年</title>
<link>http://www.cnblogs.com/homejim/p/8076481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/8076481.html</guid>
<description>&lt;p&gt;---[来自我的CSDN博客](http://blog.csdn.net/weixin_37139197/article/details/78838091)---&lt;/p&gt;
&lt;p&gt;  在&lt;a href=&quot;http://blog.csdn.net/weixin_37139197/article/details/78838091&quot;&gt;JDBC详解系列（一）之流程&lt;/a&gt;中，我将数据库的连接分解成了六个步骤。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;JDBC流程：&lt;br/&gt;第一步：加载Driver类，注册数据库驱动；&lt;br/&gt;第二步：通过DriverManager,使用url，用户名和密码建立连接(Connection)；&lt;br/&gt;第三步：通过Connection，使用sql语句打开Statement对象；&lt;br/&gt;第四步：执行语句，将结果返回resultSet；&lt;br/&gt;第五步：对结果resultSet进行处理；&lt;br/&gt;第六步：倒叙释放资源resultSet-》preparedStatement-》connection。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  接着将第一步的加载数据库驱动讲解一下。加载驱动就是这一句代码啦：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;
Class.forName(JDBC_DRIVER);
//以上也可以直接替换为 new com.mysql.jdbc.Driver();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  Class.forName(String className)返回的是一个类，在这个过程中，会把该类加载到jvm中，即这个类的静态代码会执行。为什么不使用new com.mysql.jdbc.Driver()这种方式呢？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果使用new com.mysql.jdbc.Driver()这种方式，会对这个具体的类产生依赖。后续如果你要更换数据库驱动，就得重新修改代码。而使用反射的方式，只需要在配置文件中，更改相应的驱动和url即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  加载驱动的过程中，发生了什么？我们来看一下mysql的驱动类代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Driver extends NonRegisteringDriver implements java.sql.Driver {
    //
    // Register ourselves with the DriverManager
    //
    static {
        try {
            java.sql.DriverManager.registerDriver(new Driver());
        } catch (SQLException E) {
            throw new RuntimeException(&quot;Can't register driver!&quot;);
        }
    }

    /**
     * Construct a new driver and register it with DriverManager
     * 
     * @throws SQLException
     *             if a database error occurs.
     */
    public Driver() throws SQLException {
        // Required for Class.forName().newInstance()
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  ok，就是说其实起作用的是这一句代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; java.sql.DriverManager.registerDriver(new Driver());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  查看了一下registerDriver的源码，大致是如果DriverManager中没有这个类，就将这个类添加到到DriverManager的list中。在实际的使用过程中，我们完全可以用上面这一句代码将下面加载驱动的代码替换掉，但也会对具体的类产生依赖，导致后续更改不便。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Class.forName(JDBC_DRIVER);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  到此，我想测试一下把加载驱动的代码去掉，然后看会报什么错误。结果竟然没问题。这是在逗我吗？书里面不是这么教的。只能进行google了，原因如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;JDBC4.0以后新增了新特性：JDBC4.0不再需要显示调用class.forName()注册驱动，DriverManager初始化中会通过ServiceLoader类，在我们classpath中jar（数据库驱动包）中查找，使用META-INF\services\java.sql.Driver文本中的类名称去注册。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  也就说，在启动的时候，通过jar包下面的java.sql.Driver里的文本内容，帮你把驱动给加载了。&lt;br/&gt;  OK,明白了这个之后，我将mysql驱动jar包中java.sql.Driver中的文本内容删除了，然后就将Class.forName(JDBC_DRIVER)注释掉，果然报错了：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;java.sql.SQLException: No suitable driver found for jdbc:mysql://localhost:3306/jdbc_test&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;---[来自我的CSDN博客](http://blog.csdn.net/weixin_37139197/article/details/78838091)---&lt;/p&gt;
</description>
<pubDate>Wed, 20 Dec 2017 16:30:00 +0000</pubDate>
<dc:creator>人不学习枉少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/8076481.html</dc:identifier>
</item>
<item>
<title>Solr服务在Linux上的搭建详细教程 - dijia478</title>
<link>http://www.cnblogs.com/dijia478/p/8075638.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dijia478/p/8075638.html</guid>
<description>&lt;p&gt;注：欢迎大家转载，非商业用途请在醒目位置注明本文链接和作者名dijia478即可，商业用途请联系本人dijia478@163.com。&lt;/p&gt;
&lt;p&gt;CentOS-6.7-i386-bin-DVD1&lt;/p&gt;
&lt;p&gt;jdk-8u151-linux-i586&lt;/p&gt;
&lt;p&gt;apache-tomcat-8.5.24.tar&lt;/p&gt;
&lt;p&gt;solr-7.1.0&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：solr6.0以上，官方建议使用jdk8，tomcat8。和solr4部署流程有略微差别&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;第一步：上传并解压solr&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171220152827412-339309506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第二步：上传并解压tomcat，复制一份出来&lt;/h2&gt;
&lt;p&gt;我这里已经解压过了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171220231532443-419720057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我先切换下root用户啊，然后创建solr目录，将tomcat复制重命名到/usr/local/solr/tomcat&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171220231953818-775419157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第三步：把solr部署到tomcat下&lt;/h2&gt;
&lt;p&gt;注意，这里因为我用的是solr7.1最新版，所以跟网上很多solr4的版本要拷贝*.war文件，然后再启动tomcat解压的操作是不一样的。（这里直接就是解压好的）&lt;/p&gt;
&lt;p&gt;复制并重命名solr目录里的server/solr-webapp/webapp文件夹到/usr/local/solr/tomcat/webapps/solr&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171220232440131-1775661675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第四步：把server/lib/目录下的部分&lt;span&gt;jar&lt;/span&gt;包，添加到刚才部署的&lt;span&gt;solr&lt;/span&gt;工程中。&lt;/h2&gt;
&lt;p&gt;server/lib/ext/下的所有jar复制到 /usr/local/solr/tomcat/webapps/solr/WEB-INF/lib/下，都是些日志相关的jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171220232631459-185337389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;server/lib/metrics* 开头的5个jar复制到 /usr/local/solr/tomcat/webapps/solr/WEB-INF/lib/下（solr4部署没有这个）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171221000215459-1272557571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第五步：把server/resources/目录下的log4j.properties，添加到刚才部署的solr工程中&lt;/h2&gt;
&lt;p&gt;注意要创建一个classes的目录（solr4部署没有第五步）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171220234338365-1191472255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;第六步：创建一个solrhome&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;将servier/solr目录复制到之前创建的solr目录下，重命名为solrhome，现在/usr/local/solr目录下就有两个文件夹了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171220233407053-234370508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第七步：关联solr及solrhome&lt;/h2&gt;
&lt;p&gt;需要修改tomcat里&lt;span&gt;solr&lt;/span&gt;工程的&lt;span&gt;web.xml&lt;/span&gt;文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171221001804475-204484121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到这个，是被注释的，需要修改value那项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171220233701553-2027674202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开注释，修改为上面自己创建的solrhome目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171220233818959-1054819931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后到最下方，将这一段注释掉，不然会报403错误，完成后保存退出（solr4部署不用注释这个）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171221001640068-1532218783.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;第八步：启动tomcat&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171220233943959-899017088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;去自己的电脑上访问下服务器的solr服务&lt;/p&gt;
&lt;p&gt;注意下访问地址，直接访问192.168.25.128:8080/solr会报404，需要在后面加上/index.xml&lt;/p&gt;
&lt;p&gt;如果出现下面的页面，就是solr服务搭建ok了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171221002854834-1943109731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果要关闭solr服务，直接关闭tomcat就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1267939/201712/1267939-20171221002317725-1701006425.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Dec 2017 16:28:00 +0000</pubDate>
<dc:creator>dijia478</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dijia478/p/8075638.html</dc:identifier>
</item>
<item>
<title>AspNet Core Api Restful +Swagger  实现微服务之旅 （三） - 乐途</title>
<link>http://www.cnblogs.com/szlblog/p/8076466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/szlblog/p/8076466.html</guid>
<description>&lt;p&gt;       （1）  访问Rest ful接口时 Token验证  返回数据格式封装&lt;/p&gt;
&lt;p&gt;（一）访问时Token验证  返回数据格式封装&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;&lt;strong&gt;1.1访问Api接口 方法 实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        1.1.1 创建访问Restful Api帮助类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_4c7352dd-0416-4bb5-b3a5-f4487b6a6575&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4c7352dd-0416-4bb5-b3a5-f4487b6a6575&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4c7352dd-0416-4bb5-b3a5-f4487b6a6575&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MyGet = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MyPost = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MyPut = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PUT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MyDELETE = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DELETE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  访问接口信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;JsonString&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;抛送的字符串&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;achieveUrl&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;访问的路径&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;PublishKey&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;密钥Token&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;Method&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;访问方法&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SendService(&lt;span&gt;string&lt;/span&gt; JsonString, &lt;span&gt;string&lt;/span&gt; achieveUrl, &lt;span&gt;string&lt;/span&gt; PublishKey, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Method)
        {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于返回信息的记录&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; responseValue = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(achieveUrl))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基于http协议的请求响应&lt;/span&gt;
                HttpWebRequest request = WebRequest.Create(achieveUrl) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; HttpWebRequest;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提交方法&lt;/span&gt;
                request.Method =&lt;span&gt; Method;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置Http标头信息&lt;/span&gt;
                request.UserAgent = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置请求超时时间&lt;/span&gt;
                request.Timeout = &lt;span&gt;1000&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置读取/写入超时时间&lt;/span&gt;
                request.ReadWriteTimeout = &lt;span&gt;1000&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;30&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;request.Headers.Add(&quot;&quot;, &quot;&quot;);&lt;/span&gt;
                request.Headers.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, PublishKey);
                request.ContentType &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断访问方法&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (Method != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp; Method != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PUT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    request.ContentLength &lt;/span&gt;=&lt;span&gt; Encoding.UTF8.GetByteCount(JsonString);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(JsonString))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果传送的数据不为空，并且方法是put  &lt;/span&gt;
&lt;span&gt;                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; encoding = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UTF8Encoding();
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bytes = Encoding.GetEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).GetBytes(JsonString);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;
                        request.ContentLength =&lt;span&gt; bytes.Length;
                        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; writeStream =&lt;span&gt; request.GetRequestStream())
                        {
                            writeStream.Write(bytes, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, bytes.Length);
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;http请求的返回状态&lt;/span&gt;
                &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; response =&lt;span&gt; (HttpWebResponse)request.GetResponse())
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取来自 服务器或接口的响应信息&lt;/span&gt;
                    &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; responseStream =&lt;span&gt; response.GetResponseStream())
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (responseStream != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(responseStream))
                            {
                                responseValue &lt;/span&gt;=&lt;span&gt; reader.ReadToEnd();
                            }
                        }
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseValue;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;        &lt;strong&gt;1.1.2  Token 加密方法&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_d36f5a1c-adb0-4c7c-9830-630b9edfb51e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d36f5a1c-adb0-4c7c-9830-630b9edfb51e&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d36f5a1c-adb0-4c7c-9830-630b9edfb51e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Base64加密 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;codeName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;加密采用的编码方式&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;source&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;待加密的明文&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; EncodeBase64(Encoding encode, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; source)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; Result = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes =&lt;span&gt; encode.GetBytes(source);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Result &lt;/span&gt;=&lt;span&gt; Convert.ToBase64String(bytes);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
            {
                Result &lt;/span&gt;=&lt;span&gt; source;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Result;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Base64加密，采用utf8编码方式加密
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;source&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;待加密的明文&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;加密后的字符串&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; EncodeBase64(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; source)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; EncodeBase64(Encoding.UTF8, source);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;     &lt;strong&gt;   1.1.3 获取本地IP 进行加密 用作Token&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_53874002-b64d-4f74-b4ae-bbfce1cac12b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_53874002-b64d-4f74-b4ae-bbfce1cac12b&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_53874002-b64d-4f74-b4ae-bbfce1cac12b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetAddressIP()
        {
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;获取本地的IP地址&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; AddressIP = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (IPAddress _IPAddress &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Dns.GetHostEntry(Dns.GetHostName()).AddressList)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_IPAddress.AddressFamily.ToString() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InterNetwork&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    AddressIP &lt;/span&gt;=&lt;span&gt; _IPAddress.ToString();
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; AddressIP;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;     &lt;strong&gt;   1.1.4  读取Json文件 用作 访问接口抛送的内容&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_c8d153ac-e84c-4d90-b7c2-daea57418bff&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c8d153ac-e84c-4d90-b7c2-daea57418bff&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c8d153ac-e84c-4d90-b7c2-daea57418bff&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetFileJson(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; filepath)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; json = &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(filepath, FileMode.Open, System.IO.FileAccess.Read, FileShare.ReadWrite))
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (StreamReader sr = &lt;span&gt;new&lt;/span&gt; StreamReader(fs, Encoding.GetEncoding(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gb2312&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
                {
                    json &lt;/span&gt;=&lt;span&gt; sr.ReadToEnd().ToString();
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; json;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;        &lt;strong&gt;1.1.5 Json文件内容&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_8c5a674c-b85f-4da7-9460-4789a6023be6&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8c5a674c-b85f-4da7-9460-4789a6023be6&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8c5a674c-b85f-4da7-9460-4789a6023be6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Szl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;河南&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XXXXXX&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试数据&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;      &lt;span&gt;1.1.6 调用接口&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_123a6556-f891-4516-94c4-331148ee2dbe&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_123a6556-f891-4516-94c4-331148ee2dbe&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_123a6556-f891-4516-94c4-331148ee2dbe&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Home&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; serviceURL = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;http://10.118.4.1x8:8082/szl/SzlAPI/Post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; JsonString = GetFileJson(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;D:\VS2015Demo\RestServiceTest\UI\json.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; PublishKey =&lt;span&gt; GetAddressIP();
            ViewBag.Data &lt;/span&gt;= SendService(JsonString, serviceURL, EncodeBase64(PublishKey), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;  1.2 Rest Api 接口声明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;span&gt;    1.2.1接口方法&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_c4895ad6-53a1-4511-982c-a6e6b8715ce9&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c4895ad6-53a1-4511-982c-a6e6b8715ce9&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c4895ad6-53a1-4511-982c-a6e6b8715ce9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; AspNet Core  Post请求
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;User类&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;访问参数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;     POST 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;     {  
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;        &quot;value&quot;: &quot;0e7ad584-7788-4ab1-95a6-ca0a5b444cbb&quot;,  
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;     }  
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;   
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;response code=&quot;201&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;返回新创建项&lt;/span&gt;&lt;span&gt;&amp;lt;/response&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;response code=&quot;400&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;如果为空时&lt;/span&gt;&lt;span&gt;&amp;lt;/response&amp;gt;&lt;/span&gt; 
&lt;span&gt;
        [HttpPost]
        [ProducesResponseType(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(User), &lt;span&gt;201&lt;/span&gt;&lt;span&gt;)]
        [ProducesResponseType(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(User), &lt;span&gt;400&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User Post([FromBody] User value)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种接收值得方法
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Stream stream = HttpContext.Request.Body;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;byte[] buffer = new byte[HttpContext.Request.ContentLength.Value];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;stream.Read(buffer, 0, buffer.Length);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;string content = Encoding.UTF8.GetString(buffer);&lt;/span&gt;
            &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/然后Json转换&lt;/span&gt;
            User Users = &lt;span&gt;new&lt;/span&gt; User() { UserAddress = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, UserAge = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;身体健康无颈椎病&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, UserName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Szl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, XXXXXX = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;注意大小写&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Users;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;       1.2.2 User类&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_bb41cf97-58d1-4056-a24a-1f83ddb8c8a0&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bb41cf97-58d1-4056-a24a-1f83ddb8c8a0&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bb41cf97-58d1-4056-a24a-1f83ddb8c8a0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 名称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;; 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 年龄
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserAge { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 地址
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserAddress { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 测试字段
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; XXXXXX { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;  1.3 添加 帮助类 WebApiAuthorizationFilter 对接口访问者身份Token 解密 获取访问者IP 进行验证，对返回结果进行封装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_1f254af7-0fc8-499b-84c6-b6b0e43c3255&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1f254af7-0fc8-499b-84c6-b6b0e43c3255&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1f254af7-0fc8-499b-84c6-b6b0e43c3255&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; 
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebApiAuthorizationFilter : IAuthorizationFilter
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;  调用者的身份验证
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnAuthorization(AuthorizationFilterContext context)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;string IP = ((Microsoft.AspNetCore.Http.Internal.DefaultConnectionInfo)context.HttpContext.Connection).LocalIpAddress.ToString();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取客户端IP地址&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; clientIP =&lt;span&gt; ((Microsoft.AspNetCore.Http.Internal.DefaultConnectionInfo)context.HttpContext.Connection).RemoteIpAddress.ToString();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Token信息&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; Token = context.HttpContext.Request.Headers[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].FirstOrDefault();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证Token&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (Token == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                context.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectResult(&lt;span&gt;new&lt;/span&gt; { Success = &lt;span&gt;false&lt;/span&gt;, code = &lt;span&gt;404&lt;/span&gt;, msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请查看令牌是否包含！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, data = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }); 
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (clientIP ==&lt;span&gt; DecodeBase64(Token))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                context.Result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObjectResult(&lt;span&gt;new&lt;/span&gt; { Success = &lt;span&gt;false&lt;/span&gt;, code = &lt;span&gt;404&lt;/span&gt;, msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请查看令牌是否正确！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, data = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Base64解密
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;codeName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;解密采用的编码方式，注意和加密时采用的方式一致&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;result&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;待解密的密文&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;解密后的字符串&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DecodeBase64(Encoding codeName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; result)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; decode = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes =&lt;span&gt; Convert.FromBase64String(result);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                decode &lt;/span&gt;=&lt;span&gt; codeName.GetString(bytes);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
            {
                decode &lt;/span&gt;=&lt;span&gt; result;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decode;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Base64解密，采用utf8编码方式解密
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;result&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;待解密的密文&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;解密后的字符串&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DecodeBase64(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; result)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DecodeBase64(Encoding.UTF8, result);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;   &lt;span&gt;1.4 在Startup.cs中注册服务启用 WebApiAuthorizationFilter文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_3fee93d2-865b-448a-b630-700548525801&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3fee93d2-865b-448a-b630-700548525801&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3fee93d2-865b-448a-b630-700548525801&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
           services.AddMvc(options =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;身份验证不通过是返回结果统一化&lt;/span&gt;
                options.Filters.Add(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(WebApiAuthorizationFilter));
                options.RespectBrowserAcceptHeader &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;不加Token的结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171221000150256-1262567324.png&quot; alt=&quot;&quot; width=&quot;696&quot; height=&quot;132&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;访问正确结果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171220235859443-11983163.png&quot; alt=&quot;&quot; width=&quot;442&quot; height=&quot;171&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意 返回结果中的data的字段名 大小写的变化  前边的四位默认小写了 这是框架本身Json序列化的结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方法  在&lt;strong&gt;&lt;span&gt;Startup.cs&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;中注册服务&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_3fd762ee-6772-47c2-92eb-ee49df76e238&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3fd762ee-6772-47c2-92eb-ee49df76e238&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3fd762ee-6772-47c2-92eb-ee49df76e238&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;services.AddMvc()
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认返回值 大小写不变&lt;/span&gt;
           .AddJsonOptions(op =&amp;gt; op.SerializerSettings.ContractResolver =&lt;span&gt;new&lt;/span&gt; Newtonsoft.Json.Serialization.DefaultContractResolver()); 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;



&lt;p&gt; 今天结束 本来下面的也要说说的太晚了留着明天吧&lt;/p&gt;
&lt;p&gt;      （2）  程序错误时  返回数据格式封装&lt;/p&gt;
&lt;p&gt;      （3）  返回结果包装&lt;/p&gt;
&lt;p&gt;      （4）  访问方法时 参数必填与非必填的声明&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;    代码中有不对的或者有更好的方法希望大家告之 相互学习 谢谢，&lt;span&gt;转载注明出处&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;





</description>
<pubDate>Wed, 20 Dec 2017 16:14:00 +0000</pubDate>
<dc:creator>乐途</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/szlblog/p/8076466.html</dc:identifier>
</item>
<item>
<title>利用vmware搭建分布式集群 - 不打妖怪的葫芦娃</title>
<link>http://www.cnblogs.com/sj-max/p/8076455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sj-max/p/8076455.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     我们需要至少3台服务器来实现分布式，鉴于没那么多钱买真机器，从学习和开发的角度看，只有虚拟机一条路了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件选择：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    虚拟机使用VMware软件，因为主流而且资料比较多，学习成本较低。软件百度自己找。&lt;/p&gt;
&lt;p&gt;    虚拟OS毫无疑问是linux，鉴于centos开源，下载方便又不需要破解，故而采用之。【‪CentOS-7-x86_64-Minimal-1708.iso】&lt;/p&gt;
&lt;p&gt;    可以自己去官网下载。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OS安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    新建虚拟机，一步一步默认安装就行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置网络（静态ip、为了方便连接外网，采用NAT方式而非桥接）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;1.VMware的虚拟网络编辑器：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     在编辑中选择虚拟网络编辑器，如果没有，就新增一条，连接方式为NAT，不使用DHCP自动分配ip，保持ip不变&lt;/p&gt;
&lt;div&gt;      &lt;img src=&quot;http://images2017.cnblogs.com/blog/1298675/201712/1298675-20171220234930178-1711197572.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;22.364312267658&quot;&gt;      在NAT设置里，设置正确的ip、网关、子网掩码&lt;br/&gt;&lt;div&gt;      &lt;img src=&quot;http://images2017.cnblogs.com/blog/1298675/201712/1298675-20171220234924990-1665119801.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;      端口映射应该是设置一些特殊的端口，这里暂时不用。这样，这个虚拟网络就设置好了。后面需要将这个虚拟网络添加到虚拟OS中去。&lt;/p&gt;
&lt;div&gt;      &lt;img src=&quot;http://images2015.cnblogs.com/blog/1000039/201611/1000039-20161117170513623-1570684167.png&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/div&gt;
&lt;p&gt;     &lt;strong&gt;2.虚拟OS的设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      通过以上的设置，外部环境已经设置好了，下面需要设置一下虚拟机的网卡。参考：&lt;/p&gt;

&lt;p&gt;      步骤：&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre readability=&quot;5&quot;&gt;
ifconfig -a 如果命令不可用，就用ip addr
在结果中找到网卡名称，如ens33、eth0等等格式，我这里是ens33。以及mac地址&lt;br/&gt;修改 /etc/sysconfig/network-scripts/ifcfg-ens33文件
修改 /etc/sysconfig/network文件&lt;p&gt;重启network &lt;br/&gt;service network restart
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1298675/201712/1298675-20171221000108818-151634465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1298675/201712/1298675-20171221000115490-894932276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;实测可以主机能够ping通虚拟机，虚拟机可以ping通baidu，设置完毕。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1298675/201712/1298675-20171221000250990-2115715569.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;14&quot;&gt;&lt;strong&gt;搭建集群&lt;/strong&gt;
&lt;p&gt;   虚拟机基本软件安装好之后，关闭电源，选择完全克隆虚拟机。&lt;/p&gt;
&lt;p&gt;   克隆虚拟机之后，按照之前的网络设置：&lt;/p&gt;
&lt;p&gt;   ip addr 查看网卡和MAC地址 ，然后再网卡设置里，vi /etc/sysconfig/network-scripts/ifcfg-之前的网卡名，主要修改IPADDR地址和HWADDR。&lt;/p&gt;
&lt;p&gt;   之后重启network即可。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1298675/201712/1298675-20171221000720709-142910395.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;p&gt;参考地址：【https://www.cnblogs.com/opensesame/p/6074544.html】&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 20 Dec 2017 16:11:00 +0000</pubDate>
<dc:creator>不打妖怪的葫芦娃</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sj-max/p/8076455.html</dc:identifier>
</item>
<item>
<title>ettercap的中间人欺骗 - 方方和圆圆</title>
<link>http://www.cnblogs.com/diligenceday/p/8076412.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/diligenceday/p/8076412.html</guid>
<description>&lt;p&gt;　　因为kali系统自带ettercap，比较方便， 不需要安装&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;ifcofing&lt;/strong&gt;命令查看当前网关 ，当前的IP是: &lt;strong&gt;172.16.42.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/497865/201712/497865-20171220231803381-1369653907.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;360&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　通过netdiscover获取到当前目标IP：172.16.42.131  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/497865/201712/497865-20171220232321256-1097923763.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;367&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　启动ettercap ， wlan0为网卡端口， -T为文字显示， -M art:remote为双向arp欺骗， /172.16.42.131//为攻击的目标机器IP ， /172.16.42.1//为网关地址（注， 在不同系统和不同的ettercap版本中， 参数可能不一样， 具体要看你的环境和ettercap版本）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ettercap -i wlan0 -T -M arp:remote /&lt;span&gt;172.16&lt;/span&gt;.&lt;span&gt;42.131&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; /172.16.42.1&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/497865/201712/497865-20171220232728943-1100851918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　执行arp欺骗以后， 目标机器所有的流量都会走我们的主机， 通过监听wlan0网卡， 我们可以获取和篡改目标机器的所有http请求数据和内容&lt;/p&gt;
&lt;p&gt;　　启动driftnet监听wlan0端口， 查看所有的浏览图片数据， 所有的浏览图片，尽收眼底：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
driftnet -i wlan0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/497865/201712/497865-20171220234201068-1029751426.png&quot; alt=&quot;&quot; width=&quot;786&quot; height=&quot;477&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ettercap还有一些自带的dnsspoof插件， 图片替换模块， 文字替换插件， 参考：&lt;a href=&quot;https://github.com/Ettercap/ettercap/tree/master/plug-ins&quot; target=&quot;_blank&quot;&gt;https://github.com/Ettercap/ettercap/tree/master/plug-ins&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　本来以为ettercap项目过时了， 但是github的ettercap项目居然有更新， 挺好的&lt;/p&gt;
&lt;p id=&quot;mySignature&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/497865/201708/497865-20170822213048964-1075012817.jpg&quot; alt=&quot;&quot; width=&quot;110&quot;/&gt;&lt;span&gt;作者：&lt;/span&gt; &lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/diligenceday/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;NONO&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;出处：&lt;/span&gt;&lt;a href=&quot;http://www.cnblogs.com/diligenceday/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/diligenceday/&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;企业网站：&lt;a href=&quot;http://www.idrwl.com/&quot; target=&quot;_blank&quot;&gt;http://www.idrwl.com/&lt;/a&gt;&lt;br/&gt;开源博客：&lt;a href=&quot;http://www.github.com/sqqihao&quot; target=&quot;_blank&quot;&gt;http://www.github.com/sqqihao&lt;/a&gt;&lt;br/&gt;&lt;span&gt;QQ：&lt;/span&gt;&lt;span&gt;287101329&lt;/span&gt;&lt;br/&gt;&lt;span&gt;微信：&lt;/span&gt;&lt;span&gt;18101055830&lt;/span&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 20 Dec 2017 16:00:00 +0000</pubDate>
<dc:creator>方方和圆圆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/diligenceday/p/8076412.html</dc:identifier>
</item>
<item>
<title>vmware 上ubuntu server连接外网 - chengxiansheng</title>
<link>http://www.cnblogs.com/chengxiansheng/p/8076375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxiansheng/p/8076375.html</guid>
<description>&lt;p&gt;  　　最近在自己的电脑上搞了个ubuntu server，自己做点小demo，当需要连接网络时问题来了，没法连接网络，网上有一些资料都是一笔带过，并不符合自己的情况，现在将我解决的过程记录下：&lt;/p&gt;
&lt;p&gt;        首先，在自己的windows电脑上cmd下输入ipconfig&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220223218084-1736747161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    注意这个ip，要在linux网络配置中ip网段要一样，然后在vmware 中打开虚拟网络编辑器界面，在“”编辑“”菜单下&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220223453943-1979221711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为我的虚拟机设置中网络适配器选的是NAT模式如下图，这个信息是在vmware左边栏中右键安装的虚拟机，选择设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220223756475-283360429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所以选中虚拟网络编辑器中的VMnet8，并修改子网ip信息，满足ip的ip段和windows相同，我的windows是192.168.199.115，所以这里设置为了192.168.199.0，只有这里设置里，下一步的DCH IP区段和网关ip才能设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220224205084-1673071166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后进行NAT设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220233035334-1853431681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里设置的网关ip和我windows电脑的网关ip相同，点击确定之后回到虚拟网络编辑器界面，再进行DCH设置，设置起始ip和结束ip，这个范围设置网段也要和windows的ip是一个网段&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220225341521-156407833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击确认，再回到虚拟网络编辑器界面点击确认，重启虚拟机，ping www.baidu.com 已经可以ping通，说明外网已经开通&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220225858959-969985638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果还不可以的检查下 /etc/network/ interfaces 是否正确设置，下图圆圈是网卡名称，方框里是dhcp是自动获取ip，static是配置静态ip，就要设置address等信息，指定ip地址&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220230634084-425748149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有dns设置，在/etc/resolv.conf 这里我设置的是网关地址，也可以设置成114.114.114.114等，dns服务器地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1049413/201712/1049413-20171220231009115-1295433116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ping windows ip也是可以ping通的，&lt;/p&gt;

</description>
<pubDate>Wed, 20 Dec 2017 15:32:00 +0000</pubDate>
<dc:creator>chengxiansheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxiansheng/p/8076375.html</dc:identifier>
</item>
<item>
<title>vue2的keep-alive的总结 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/8076245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/8076245.html</guid>
<description>&lt;p&gt;vue2的keep-alive的总结&lt;/p&gt;
&lt;p&gt;keep-alive 是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM。结合vue-router中使用，可以缓存某个view&lt;br/&gt;的整个内容。&lt;br/&gt;基本使用如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;keep-alive&amp;gt;
  &amp;lt;component&amp;gt;
    &amp;lt;!-- 该组件将被缓存！ --&amp;gt;
  &amp;lt;/component&amp;gt;
&amp;lt;/keep-alive&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般有这样的需求，当我们第一次进入列表页需要请求一下数据，当我从列表页进入详情页，详情页不缓存也需要请求下数据，然后返回列表页&lt;br/&gt;有两个情况：&lt;br/&gt;1. 直接点击浏览器的后退返回按钮。&lt;br/&gt;2. 点击导航栏中的 /list的链接返回。&lt;/p&gt;
&lt;p&gt;那么针对第一种情况下，我们直接通过后退按钮时，返回到列表页(/list) 是不需要请求数据。&lt;br/&gt;针对第二种情况下，我们通过链接返回到列表页是需要请求数据。&lt;/p&gt;
&lt;p&gt;所以这边有三种情况：&lt;br/&gt;1. 默认进来列表页需要请求数据。&lt;br/&gt;2. 进入详情页后，通过浏览器默认后退按钮返回，是不需要ajax的请求的。&lt;br/&gt;3. 进入详情页后，通过点击链接返回到列表页后，也是需要发ajax请求的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;配置如下：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;1. 入口文件 app.vue 的配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 缓存所有的页面 --&amp;gt;
&amp;lt;keep-alive&amp;gt;
  &amp;lt;router-view v-&lt;span&gt;if&lt;/span&gt;=&quot;$route.meta.keep_alive&quot;&amp;gt;&amp;lt;/router-view&amp;gt;
&amp;lt;/keep-alive&amp;gt;
&amp;lt;router-view v-&lt;span&gt;if&lt;/span&gt;=&quot;!$route.meta.keep_alive&quot;&amp;gt;&amp;lt;/router-view&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 在router中设置meta属性，设置 keepAlive: true 表示需要使用缓存，false的话表示不需要使用缓存。且添加滚动行为 scrollBehavior&lt;br/&gt;router/index.js 的配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;;
import Router from &lt;/span&gt;'vue-router'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; import HelloWorld from '@/views/HelloWorld';&lt;/span&gt;
&lt;span&gt;Vue.use(Router);
const router &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Router({
  mode: &lt;/span&gt;'history', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问路径不带井号  需要使用 history模式，才能使用 scrollBehavior&lt;/span&gt;
  base: '/page/app',  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置单页应用的基路径&lt;/span&gt;
&lt;span&gt;  routes: [
    {
      path: &lt;/span&gt;'/'&lt;span&gt;,
      name: &lt;/span&gt;'list'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/list'], resolve),  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;      meta: {
        keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存&lt;/span&gt;
&lt;span&gt;      }
    },
    {
      path: &lt;/span&gt;'/list'&lt;span&gt;,
      name: &lt;/span&gt;'list'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/list'], resolve), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;      meta: {
        keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存  false表示不需要被缓存&lt;/span&gt;
&lt;span&gt;      }
    },
    {
      path: &lt;/span&gt;'/detail'&lt;span&gt;,
      name: &lt;/span&gt;'detail'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/detail'], resolve) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;    }
  ],
  scrollBehavior (to, from, savedPosition) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存到 meta 中，备用&lt;/span&gt;
    to.meta.savedPosition =&lt;span&gt; savedPosition;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (savedPosition) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; { x: 0, y: 0&lt;span&gt; };
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {};
  }
});
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; router;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. list.vue 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;hello&quot;&amp;gt;
    &amp;lt;h1&amp;gt;vue&amp;lt;/h1&amp;gt;
    &amp;lt;h2&amp;gt;{{msg}}&amp;lt;/h2&amp;gt;
    &amp;lt;router-link to=&quot;/detail&quot;&amp;gt;跳转到detail页&amp;lt;/router-link&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'helloworld'&lt;span&gt;,
  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      msg: &lt;/span&gt;'Welcome to Your Vue.js App'&lt;span&gt;
    };
  },
  methods: {
    ajaxRequest() {
      const obj &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;'aa': 1&lt;span&gt;
      };
      Promise.all([&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.dispatch('testUrl', obj)]).then((res) =&amp;gt;&lt;span&gt; {
        console.log(res);
      });
    }
  },
  beforeRouteEnter(to, from, next) {
    next(vm &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
       如果 to.meta.savedPosition === undefined 说明是刷新页面或可以叫第一次进入页面 需要刷新数据
       如果savedPosition === null, 那么说明是点击了导航链接;
       此时需要刷新数据，获取新的列表内容。
       否则的话 什么都不做，直接使用 keep-alive中的缓存
       &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (to.meta.savedPosition ===&lt;span&gt; undefined) {
        vm.ajaxRequest();
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (to.meta.savedPosition === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        vm.ajaxRequest();
      }
    })
  }
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. detail.vue 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;list&quot;&amp;gt;
    &amp;lt;h1&amp;gt;{{msg}}&amp;lt;/h1&amp;gt;
    &amp;lt;router-link to=&quot;/list&quot;&amp;gt;返回列表页&amp;lt;/router-link&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'list'&lt;span&gt;,
  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      msg: &lt;/span&gt;'Welcome to Your Vue.js App'&lt;span&gt;
    };
  },
  created() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ajaxRequest();
  },
  methods: {
    ajaxRequest() {
      const obj &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;'aa': 1&lt;span&gt;
      };
      Promise.all([&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.dispatch('withdary', obj)]).then((res) =&amp;gt;&lt;span&gt; {
        console.log(res);
      });
    }
  }
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二：使用router.meta 扩展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;假设现在有3个页面，需求如下：&lt;br/&gt;1. 默认有A页面，A页面进来需要一个请求。&lt;br/&gt;2. B页面跳转到A页面，A页面不需要重新请求。&lt;br/&gt;3. C页面跳转到A页面，A页面需要重新请求。&lt;/p&gt;
&lt;p&gt;实现方式如下：&lt;br/&gt;在 A 路由里面设置 meta 属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  path: &lt;/span&gt;'/a'&lt;span&gt;,
  name: &lt;/span&gt;'A'&lt;span&gt;,
  component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/a'&lt;span&gt;], resolve),
  meta: {
    keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以router/index下的所有代码变为如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;;
import Router from &lt;/span&gt;'vue-router'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; import HelloWorld from '@/views/HelloWorld';&lt;/span&gt;
&lt;span&gt;
Vue.use(Router);

const router &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Router({
  mode: &lt;/span&gt;'history', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 访问路径不带井号  需要使用 history模式，才能使用 scrollBehavior&lt;/span&gt;
  base: '/page/app',  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置单页应用的基路径&lt;/span&gt;
&lt;span&gt;  routes: [
    {
      path: &lt;/span&gt;'/'&lt;span&gt;,
      name: &lt;/span&gt;'list'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/list'], resolve),  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;      meta: {
        keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存&lt;/span&gt;
&lt;span&gt;      }
    },
    {
      path: &lt;/span&gt;'/list'&lt;span&gt;,
      name: &lt;/span&gt;'list'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/list'], resolve), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;      meta: {
        keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存  false表示不需要被缓存&lt;/span&gt;
&lt;span&gt;      }
    },
    {
      path: &lt;/span&gt;'/detail'&lt;span&gt;,
      name: &lt;/span&gt;'detail'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/detail'], resolve) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用懒加载&lt;/span&gt;
&lt;span&gt;    },
    {
      path: &lt;/span&gt;'/a'&lt;span&gt;,
      name: &lt;/span&gt;'A'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/a'&lt;span&gt;], resolve),
      meta: {
        keepAlive: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true 表示需要使用缓存&lt;/span&gt;
&lt;span&gt;      }
    },
    {
      path: &lt;/span&gt;'/b'&lt;span&gt;,
      name: &lt;/span&gt;'B'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/b'&lt;span&gt;], resolve)
    },
    {
      path: &lt;/span&gt;'/c'&lt;span&gt;,
      name: &lt;/span&gt;'C'&lt;span&gt;,
      component: resolve &lt;/span&gt;=&amp;gt; require(['@/views/c'&lt;span&gt;], resolve)
    }
  ],
  scrollBehavior (to, from, savedPosition) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存到 meta 中，备用&lt;/span&gt;
    to.meta.savedPosition =&lt;span&gt; savedPosition;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (savedPosition) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; { x: 0, y: 0&lt;span&gt; };
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {};
  }
});
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; router;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 B 组件里面设置 beforeRouteLeave&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;beforeRouteLeave(to, from, next) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下一个路由meta&lt;/span&gt;
  to.meta.keepAlive = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让A缓存，不请求数据&lt;/span&gt;
  next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳转到A页面&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;B组件所有代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;list&quot;&amp;gt;
    &amp;lt;h1&amp;gt;{{msg}}&amp;lt;/h1&amp;gt;
    &amp;lt;router-link to=&quot;/a&quot;&amp;gt;返回a页面&amp;lt;/router-link&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'list'&lt;span&gt;,
  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      msg: &lt;/span&gt;'Welcome to B Page'&lt;span&gt;
    };
  },
  created() {},
  methods: {
  },
  beforeRouteLeave(to, from, next) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下一个路由meta&lt;/span&gt;
    to.meta.keepAlive = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让A缓存，不请求数据&lt;/span&gt;
    next(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳转到A页面&lt;/span&gt;
&lt;span&gt;  }
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 C 组件里面设置 beforeRouteLeave：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;beforeRouteLeave(to, from, next) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下一个路由meta&lt;/span&gt;
  to.meta.keepAlive = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让A不缓存，重新请求数据&lt;/span&gt;
&lt;span&gt;  console.log(to)
  next(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳转到A页面&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c组件所有代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;list&quot;&amp;gt;
    &amp;lt;h1&amp;gt;{{msg}}&amp;lt;/h1&amp;gt;
    &amp;lt;router-link to=&quot;/a&quot;&amp;gt;返回a页面&amp;lt;/router-link&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'list'&lt;span&gt;,
  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      msg: &lt;/span&gt;'Welcome to B Page'&lt;span&gt;
    };
  },
  created() {},
  methods: {
  },
  beforeRouteLeave(to, from, next) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置下一个路由meta&lt;/span&gt;
    to.meta.keepAlive = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让A不缓存，重新请求数据&lt;/span&gt;
&lt;span&gt;    console.log(to)
    next(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳转到A页面&lt;/span&gt;
&lt;span&gt;  }
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a组件内的所有的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;hello&quot;&amp;gt;
    &amp;lt;h1&amp;gt;vue&amp;lt;/h1&amp;gt;
    &amp;lt;h2&amp;gt;{{msg}}&amp;lt;/h2&amp;gt;
    &amp;lt;router-link to=&quot;/b&quot;&amp;gt;跳转到b页面&amp;lt;/router-link&amp;gt;
    &amp;lt;router-link to=&quot;/c&quot;&amp;gt;跳转到c页面&amp;lt;/router-link&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  name: &lt;/span&gt;'helloworld'&lt;span&gt;,
  data () {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      msg: &lt;/span&gt;'Welcome to A Page'&lt;span&gt;
    };
  },
  methods: {
    ajaxRequest() {
      const obj &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;'aa': 1&lt;span&gt;
      };
      Promise.all([&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$store.dispatch('testUrl', obj)]).then((res) =&amp;gt;&lt;span&gt; {});
    }
  },
  beforeRouteEnter(to, from, next) {
    next(vm &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
       如果 to.meta.savedPosition === undefined 说明是刷新页面或可以叫第一次进入页面 需要刷新数据
       如果to.meta.keepAlive === false, 那么说明是需要请求的;
       此时需要刷新数据，获取新的列表内容。
       否则的话 什么都不做，直接使用 keep-alive中的缓存
       &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (to.meta.savedPosition ===&lt;span&gt; undefined) {
        vm.ajaxRequest();
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;to.meta.keepAlive) {
        vm.ajaxRequest();
      }
    })
  }
};
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意 b组件到a组件不重新请求数据 (包括点击链接和浏览器后退按钮)，c组件到a组件请求数据(包括点击链接和浏览器后退按钮).&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/vue-keep-alive&quot; target=&quot;_blank&quot;&gt;查看github上的代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Dec 2017 14:52:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/8076245.html</dc:identifier>
</item>
<item>
<title>Scala入门系列（十二）：隐式转换 - 小丑进场</title>
<link>http://www.cnblogs.com/LiCheng-/p/8076090.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LiCheng-/p/8076090.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-12486&quot; readability=&quot;18&quot;&gt;
&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;Scala提供的隐式转换和隐式参数功能，是非常有特色的功能。是Java等编程语言所没有的功能。它可以允许你手动指定，将某种类型的对象转换成其他类型的对象。通过这些功能可以实现非常强大而且特殊的功能。&lt;/p&gt;
&lt;p&gt;Scala的隐式转换，其实&lt;strong&gt;最核心的就是定义隐式转换函数&lt;/strong&gt;，即&lt;code&gt;implicit conversion function&lt;/code&gt;。定义的隐式转换函数，只要在编写的程序内引入，就会被Scala自动使用。&lt;strong&gt;在程序中使用到隐式转换函数参数类型定义的对象时，会自动将其传入隐式转换函数，转换为另外一种类型的对象并返回&lt;/strong&gt;。这就是“隐式转换”。&lt;/p&gt;
&lt;p&gt;隐式转换函数叫什么名字是无所谓的，因为通常不会由用户手动调用，而是由Scala进行调用。但是如果要使用隐式转换，则需要对隐式转换函数进行导入。因此通常建议将隐式转换函数的名称命名为“one2one”的形式。&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12503&quot; readability=&quot;13&quot;&gt;
&lt;h2&gt;隐式转换&lt;/h2&gt;
&lt;p&gt;要实现隐式转换，只要程序可见的范围内定义隐式转换函数即可。Scala会自动调用隐式转换函数。&lt;/p&gt;
&lt;p&gt;隐式转换函数与普通函数唯一的区别就是要以&lt;code&gt;implicit&lt;/code&gt;开头，而且最好要定义函数返回类型。&lt;/p&gt;
&lt;p&gt;案例：特殊售票窗口（只接受特殊人群：比如学生、老人等）&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12392&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SpecialPerson&lt;/span&gt;(&lt;span&gt;val name: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;(&lt;span&gt;val name: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Older&lt;/span&gt;(&lt;span&gt;val name: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 我们想通过隐式转化把学生和老人转化为特殊人群，这样他们就可以在特殊窗口买票。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;object2SpecialPerson&lt;/span&gt;&lt;/span&gt;(obj: &lt;span&gt;Object&lt;/span&gt;): &lt;span&gt;SpecialPerson&lt;/span&gt; = {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if&lt;/span&gt;(obj.getClass == classOf[&lt;span&gt;Student&lt;/span&gt;]){ &lt;span&gt;val&lt;/span&gt; stu = obj.asInstanceOf[&lt;span&gt;Student&lt;/span&gt;]; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;SpecialPerson&lt;/span&gt;(stu.name) }&lt;/p&gt;
&lt;p&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (obj.getClass == classOf[&lt;span&gt;Older&lt;/span&gt;]) { &lt;span&gt;val&lt;/span&gt; older = obj.asInstanceOf[&lt;span&gt;Older&lt;/span&gt;]; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;SpecialPerson&lt;/span&gt;(&lt;/p&gt;
&lt;p&gt;older.name) }&lt;/p&gt;
&lt;p&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;Nil&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;var&lt;/span&gt; ticketNumber = &lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 只接受特殊人群的买票服务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;buySpecialTicket&lt;/span&gt;&lt;/span&gt;(p: &lt;span&gt;SpecialPerson&lt;/span&gt;) = {&lt;/p&gt;
&lt;p&gt;ticketNumber += &lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;T-&quot;&lt;/span&gt; + ticketNumber&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; stu = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;stu: &lt;span&gt;Student&lt;/span&gt; = &lt;span&gt;Student&lt;/span&gt;@&lt;span&gt;388623&lt;/span&gt;ad&lt;/p&gt;

&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; old = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Older&lt;/span&gt;(&lt;span&gt;&quot;leo&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;old: &lt;span&gt;Older&lt;/span&gt; = &lt;span&gt;Older&lt;/span&gt;@&lt;span&gt;3453&lt;/span&gt;acd2&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 学生和老人通过隐式转换后均可买特殊票&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; buySpecialTicket(stu)&lt;/p&gt;
&lt;p&gt;res9: &lt;span&gt;String&lt;/span&gt; = &lt;span&gt;T&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;scala&amp;gt; buySpecialTicket(old)&lt;/p&gt;
&lt;p&gt;res10: &lt;span&gt;String&lt;/span&gt; = &lt;span&gt;T&lt;/span&gt;&lt;span&gt;-2&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13097&quot; readability=&quot;10&quot;&gt;
&lt;h2&gt;使用隐式转换加强现有类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;隐式转换非常强大的一个功能，就是可以在不知不觉中加强现有类型的功能&lt;/strong&gt;。也就是说，可以为某个类定义一个加强版的类，并定义互相之间的隐式转换函数，从而让源类在使用加强版类的方法时，由Scala自动进行隐式转换，然后再调用加强类中特有的方法。 &lt;br/&gt;  &lt;br/&gt;案例：超人变身&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12394&quot; readability=&quot;27&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Man&lt;/span&gt;(&lt;span&gt;val name: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;// 定义超人类，具有发射激光方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Superman&lt;/span&gt;(&lt;span&gt;val name: &lt;span&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;{&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;emitLaser&lt;/span&gt;&lt;/span&gt; = println(&lt;span&gt;&quot;emit a laster!&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 定义隐式转换函数，将普通人转为超人&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;man2superman&lt;/span&gt;&lt;/span&gt;(man: &lt;span&gt;Man&lt;/span&gt;): &lt;span&gt;Superman&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Superman&lt;/span&gt;(man.name)&lt;/p&gt;

&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Man&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Superman&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;man2superman: (man: &lt;span&gt;Man&lt;/span&gt;)&lt;span&gt;Superman&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 创建普通人类对象sparks&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; sparks = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Man&lt;/span&gt;(&lt;span&gt;&quot;leo&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;sparks: &lt;span&gt;Man&lt;/span&gt; = &lt;span&gt;Man&lt;/span&gt;@&lt;span&gt;75&lt;/span&gt;c56eb9&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// sparks通过隐式转换变身超人，拥有发射激光方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; sparks.emitLaser&lt;/p&gt;
&lt;p&gt;emit a laster!&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12587&quot; readability=&quot;14&quot;&gt;
&lt;h2&gt;隐式转化函数的作用域与导入&lt;/h2&gt;
&lt;p&gt;Scala默认会使用两种隐式转换，&lt;strong&gt;一种是源类型或目标类型的伴生对象内的的隐式转化函数；一种是当前程序作用域内的可以用唯一标识符表示的隐式转换函数&lt;/strong&gt;。（上面两个例子都属于第二种情况）&lt;/p&gt;
&lt;p&gt;如果隐式转换函数不在上述两种情况下的话，那么就必须手动使用import语法导入，例如：&lt;code&gt;import test._&lt;/code&gt; 。通常建议，仅仅在需要进行隐式转换的地方，比如某个函数或者方法内，用import导入隐式转换函数，这样可以缩小隐式转换函数的作用域，避免不需要的隐式转换。&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13084&quot; readability=&quot;7&quot;&gt;
&lt;h2&gt;隐式转换触发条件&lt;/h2&gt;
&lt;ol&gt;&lt;li rel=&quot;1&quot;&gt;调用某个函数，但是给函数传入的参数类型与函数定义的接收类型不匹配。（案例：特殊售票窗口） &lt;br/&gt; &lt;/li&gt;
&lt;li rel=&quot;2&quot;&gt;使用某个类型的对象，调用某个方法，而这个方法并不存在于该类型时。（案例：超人变身） &lt;br/&gt; &lt;/li&gt;
&lt;li rel=&quot;3&quot;&gt;使用某个类型的对象，调用该类中的某个方法，虽然该类型有这个方法，但是给方法传入的参数类型与定义接收类型不匹配（案例：特殊售票窗口加强版）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  &lt;br/&gt;案例：特殊售票窗口加强版&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12397&quot; readability=&quot;21&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 定义售票窗口类&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TicketHouse&lt;/span&gt;&lt;/span&gt; {&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;var&lt;/span&gt; ticketNumber = &lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;buySpecialTicket&lt;/span&gt;&lt;/span&gt;(p: &lt;span&gt;SpecialPerson&lt;/span&gt;) = {&lt;/p&gt;
&lt;p&gt;ticketNumber += &lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;T-&quot;&lt;/span&gt; + ticketNumber&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TicketHouse&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; ticketHouse = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;TicketHouse&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ticketHouse: &lt;span&gt;TicketHouse&lt;/span&gt; = &lt;span&gt;TicketHouse&lt;/span&gt;@&lt;span&gt;522&lt;/span&gt;b2631&lt;/p&gt;

&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; spark = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;spark: &lt;span&gt;Student&lt;/span&gt; = &lt;span&gt;Student&lt;/span&gt;@&lt;span&gt;588&lt;/span&gt;ffeb&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 当传入一个学生对象时，触发第三种隐式转换条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; ticketHouse.buySpecialTicket(spark)&lt;/p&gt;
&lt;p&gt;res2: &lt;span&gt;String&lt;/span&gt; = &lt;span&gt;T&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13038&quot; readability=&quot;12&quot;&gt;
&lt;h2&gt;隐式参数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;隐式参数指的是在函数或者方法中，定义一个用implicit修饰的参数，此时Scala会尝试找到一个指定类型的，用implicit修饰的对象即隐式值，如果找到就将其注入参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Scala会在两个范围内查找：一种是当前作用域内可见的val或var定义的隐式变量；一种是隐式参数类型的伴生对象内的隐式值。 &lt;br/&gt; &lt;/p&gt;
&lt;p&gt;案例：考试签到&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13055&quot; readability=&quot;26&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SignPen&lt;/span&gt;&lt;/span&gt;{&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;/span&gt;(content: &lt;span&gt;String&lt;/span&gt;) =println(content)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 定义隐式参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;val&lt;/span&gt; signPen = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;SignPen&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 函数中使用隐式参数，此时scala会尝试找到一个指定SignPen类型的用implicit修饰的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;signForExam&lt;/span&gt;&lt;/span&gt;(name: &lt;span&gt;String&lt;/span&gt;) (&lt;span&gt;implicit&lt;/span&gt; signPen: &lt;span&gt;SignPen&lt;/span&gt;) {&lt;/p&gt;
&lt;p&gt;signPen.write(name + &lt;span&gt;&quot; come to exam in time.&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;defined &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SignPen&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;signPen: &lt;span&gt;SignPen&lt;/span&gt; = &lt;span&gt;SignPen&lt;/span&gt;@&lt;span&gt;773&lt;/span&gt;dab28&lt;/p&gt;
&lt;p&gt;signForExam: (name: &lt;span&gt;String&lt;/span&gt;)(&lt;span&gt;implicit&lt;/span&gt; signPen: &lt;span&gt;SignPen&lt;/span&gt;)&lt;span&gt;Unit&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 测试：当同学sparks来签到时，函数调用隐式参数的值完成签到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; signForExam(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;sparks come to exam in time.&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-12400&quot; readability=&quot;10&quot;&gt;
&lt;h2&gt;Java数组与Scala数组的隐式转换&lt;/h2&gt;
&lt;p&gt;我们知道在Scala代码中，是直接可以调用JDK（JAVA）API的，比如调用一个Java数组类的方法，势必可能会传入Java类型的ArrayList，但是Scala中构造出来的其实是ArrayBuffer，你直接把Scala的ArrayBuffer传入Java接收ArrayList的方法，肯定不行。所以这时候隐式转换就派上用场了！&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13121&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 导入隐式转换函数，将scala的buffer类型转换为javalist类型&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.&lt;span&gt;JavaConversions&lt;/span&gt;.bufferAsJavaList&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.mutable.&lt;span&gt;ArrayBuffer&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;// 测试&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; command = &lt;span&gt;ArrayBuffer&lt;/span&gt;(&lt;span&gt;&quot;javac&quot;&lt;/span&gt;, &lt;span&gt;&quot;C:\\Users\\Administrator\\Desktop\\Hello.java&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; processBuilder = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ProcessBuilder&lt;/span&gt;(command)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; process = processBuilder.start()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 转换成功&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; res = process.waitFor()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;res: &lt;span&gt;Int&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;&lt;span&gt;// 导入隐式转换函数，将javalist类型转换为scala的buffer类型&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.&lt;span&gt;JavaConversions&lt;/span&gt;.asScalaBuffer&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.mutable.&lt;span&gt;Buffer&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;// 转换成功&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; cmd: &lt;span&gt;Buffer&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;] = processBuilder.command()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;cmd: scala.collection.mutable.&lt;span&gt;Buffer&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;] = &lt;span&gt;ArrayBuffer&lt;/span&gt;(javac, &lt;span&gt;C&lt;/span&gt;:\&lt;span&gt;Users&lt;/span&gt;\&lt;span&gt;Administrator&lt;/span&gt;\&lt;span&gt;Desktop&lt;/span&gt;\&lt;span&gt;Hel&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;lo.java)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt; &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;&lt;code&gt;Java Map与Scala Map的隐式转换&lt;/code&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-12403&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// Java Map转换为Scala Map&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.&lt;span&gt;JavaConversions&lt;/span&gt;.mapAsScalaMap&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 创建Java.util.HashMap对象&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; javaScores = &lt;span&gt;new&lt;/span&gt; java.util.&lt;span&gt;HashMap&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Int&lt;/span&gt;]()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;javaScores.put(&lt;span&gt;&quot;Alice&quot;&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;javaScores.put(&lt;span&gt;&quot;Bob&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;javaScores.put(&lt;span&gt;&quot;Cindy&quot;&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;// 转换成功&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; scalaScorces: scala.collection.mutable.&lt;span&gt;Map&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Int&lt;/span&gt;] = javaScores&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scalaScorces: scala.collection.mutable.&lt;span&gt;Map&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;,&lt;span&gt;Int&lt;/span&gt;] = &lt;span&gt;Map&lt;/span&gt;(&lt;span&gt;Bob&lt;/span&gt; -&amp;gt; &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;Alice&lt;/span&gt; -&amp;gt; &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;Cindy&lt;/span&gt; -&amp;gt; &lt;span&gt;8&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;


&lt;p&gt;&lt;code&gt;&lt;span&gt;// Scala Map转换为Java Map&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; scala.collection.&lt;span&gt;JavaConversions&lt;/span&gt;.mapAsJavaMap&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.awt.font.&lt;span&gt;TextAttribute&lt;/span&gt;._&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; scalaAttrMap = &lt;span&gt;Map&lt;/span&gt;(&lt;span&gt;FAMILY&lt;/span&gt; -&amp;gt; &lt;span&gt;&quot;Sermi&quot;&lt;/span&gt;, &lt;span&gt;SIZE&lt;/span&gt; -&amp;gt; &lt;span&gt;12&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scalaAttrMap: scala.collection.immutable.&lt;span&gt;Map&lt;/span&gt;[java.awt.font.&lt;span&gt;TextAttribute&lt;/span&gt;,&lt;span&gt;Any&lt;/span&gt;] = &lt;span&gt;Map&lt;/span&gt;(java.awt.font.&lt;span&gt;Te&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;xtAttribute(family) -&amp;gt; &lt;span&gt;Sermi&lt;/span&gt;, java.awt.font.&lt;span&gt;TextAttribute&lt;/span&gt;(size) -&amp;gt; &lt;span&gt;12&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;// 转换成功&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; font = &lt;span&gt;new&lt;/span&gt; java.awt.&lt;span&gt;Font&lt;/span&gt;(scalaAttrMap)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;font: java.awt.&lt;span&gt;Font&lt;/span&gt; = java.awt.&lt;span&gt;Font&lt;/span&gt;[family=&lt;span&gt;Dialog&lt;/span&gt;,name=&lt;span&gt;Sermi&lt;/span&gt;,style=plain,size=&lt;span&gt;12&lt;/span&gt;]&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 20 Dec 2017 14:10:00 +0000</pubDate>
<dc:creator>小丑进场</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LiCheng-/p/8076090.html</dc:identifier>
</item>
<item>
<title>SLAM入门笔记(1)：特征点的匹配 - Brook_icv</title>
<link>http://www.cnblogs.com/wangguchangqing/p/8076061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangguchangqing/p/8076061.html</guid>
<description>&lt;p&gt;SLAM 主要分为两个部分：前端和后端，前端也就是视觉里程计（VO），它根据相邻图像的信息粗略的估计出相机的运动，给后端提供较好的初始值。VO的实现方法可以根据是否需要提取特征分为两类：基于特征点的方法，不使用特征点的直接方法。 基于特征点的VO运行稳定，对光照、动态物体不敏感。&lt;/p&gt;
&lt;p&gt;图像特征点的提取和匹配是计算机视觉中的一个基本问题，在视觉SLAM中就需要首先找到相邻图像对应点的组合，根据这些匹配的点对计算出相机的位姿（相对初始位置，相机的旋转和平移）。&lt;br/&gt;本文对这段时间对特征点的学习做一个总结，主要有以下几方面的内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特征点概述&lt;/li&gt;
&lt;li&gt;常用的特征点算法，如SIFT,SURF，FAST等&lt;/li&gt;
&lt;li&gt;OpenCV3中特征点的提取和匹配&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;特征点概述&quot;&gt;特征点概述&lt;/h3&gt;
&lt;p&gt;如何高效且准确的匹配出两个不同视角的图像中的同一个物体，是许多计算机视觉应用中的第一步。虽然图像在计算机中是以灰度矩阵的形式存在的，但是利用图像的灰度并不能准确的找出两幅图像中的同一个物体。这是由于灰度受光照的影响，并且当图像视角变化后，同一个物体的灰度值也会跟着变化。所以，就需要找出一种能够在相机进行移动和旋转（视角发生变化），仍然能够保持不变的特征，利用这些不变的特征来找出不同视角的图像中的同一个物体。&lt;/p&gt;
&lt;p&gt;为了能够更好的进行图像匹配，需要在图像中选择具有代表性的区域，例如：图像中的角点、边缘和一些区块，但在图像识别出角点是最容易，也就是说角点的辨识度是最高的。所以，在很多的计算机视觉处理中，都是提取交掉作为特征，对图像进行匹配，例如SFM，视觉SLAM等。&lt;/p&gt;
&lt;p&gt;但是，单纯的角点并不能很好的满足我们的需求，例如：相机从远处得到的是角点，但是在近处就可能不是角点；或者，当相机旋转后，角点就发生了变化。为此，计算机视觉的研究者们设计了许多更为稳定的的特征点，这些特征点不会随着相机的移动，旋转或者光照的变化而变化。例如：SIFT,SURF,ORB等&lt;/p&gt;
&lt;p&gt;一个图像的特征点由两部分构成：关键点（Keypoint）和描述子（Descriptor）。 关键点指的是该特征点在图像中的位置，有些还具有方向、尺度信息；描述子通常是一个向量，按照人为的设计的方式，描述关键点周围像素的信息。通常描述子是按照&lt;strong&gt;外观相似的特征应该有相似的描述子&lt;/strong&gt;设计的。因此，在匹配的时候，只要两个特征点的描述子在向量空间的距离相近，就可以认为它们是同一个特征点。&lt;/p&gt;
&lt;p&gt;特征点的匹配通常需要以下三个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提取图像中的关键点，这部分是查找图像中具有某些特征（不同的算法有不同的）的像素&lt;/li&gt;
&lt;li&gt;根据得到的关键点位置，计算特征点的描述子&lt;/li&gt;
&lt;li&gt;根据特征点的描述子，进行匹配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里先介绍下特征点的描述子，一个好的描述子是准确匹配的基础，关键点的提取和特征点的匹配，在后面介绍。&lt;/p&gt;
&lt;h3 id=&quot;特征点描述子&quot;&gt;特征点描述子&lt;/h3&gt;
&lt;p&gt;从图像中提取到特征的关键点信息，通常只是其在图像的位置信息（有可能包含尺度和方向信息），仅仅利用这些信息无法很好的进行特征点的匹配，所以就需要更详细的信息，将特征区分开来，这就是特征描述子。另外，通过特征描述子可以消除视角的变化带来图像的尺度和方向的变化，能够更好的在图像间匹配。&lt;/p&gt;
&lt;p&gt;特征的描述子通常是一个精心设计的向量，描述了关键点及其周围像素的信息。为了能够更好的匹配，一个好的描述子通常要具有以下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不变性 指特征不会随着图像的放大缩小旋转而改变。&lt;/li&gt;
&lt;li&gt;鲁棒性 对噪声、光照或者其他一些小的形变不敏感&lt;/li&gt;
&lt;li&gt;可区分性 每一个特征描述子都是独特的，具有排他性，尽可能减少彼此间的相似性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中描述子的可区分性和其不变性是矛盾的，一个具有众多不变性的特征描述子，其区分局部图像内容的能力就比较稍弱；而如果一个很容易区分不同局部图像内容的特征描述子，其鲁棒性往往比较低。所以，在设计特征描述子的时候，就需要综合考虑这三个特性，找到三者之间的平衡。&lt;/p&gt;
&lt;p&gt;特征描述子的不变性主要体现在两个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;尺度不变性 Scale Invarient&lt;/strong&gt;&lt;br/&gt;指的是同一个特征，在图像的不同的尺度空间保持不变。匹配在不同图像中的同一个特征点经常会有图像的尺度问题，不同尺度的图像中特征点的距离变得不同，物体的尺寸变得不同，而仅仅改变特征点的大小就有可能造成强度不匹配。如果描述子无法保证尺度不变性，那么同一个特征点在放大或者缩小的图像间，就不能很好的匹配。为了保持尺度的不变性，在计算特征点的描述子的时候，通常将图像变换到统一的尺度空间，再加上尺度因子。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;旋转不变性 Rotation Invarient&lt;/strong&gt;&lt;br/&gt;指的是同一个特征，在成像视角旋转后，特征仍然能够保持不变。和尺度不变性类似，为了保持旋转不变性，在计算特征点描述子的时候，要加上关键点的方向信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了有个更直观的理解，下面给出SIFT,SURF,BRIEF描述子计算方法对比&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/439761/201712/439761-20171220215116521-1110847369.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上表可以看出，SIFT,SURF和BRIEF描述子都是一个向量，只是维度不同。其中，SIFT和SURF在构建特征描述子的时候，保存了特征的方向和尺度特征，这样其特征描述子就具有尺度和旋转不变性；而BRIEF描述子并没有尺度和方向特征，不具备尺度和旋转不变性。&lt;/p&gt;
&lt;h3 id=&quot;常用的特征点算法&quot;&gt;常用的特征点算法&lt;/h3&gt;
&lt;p&gt;上面提到图像的特征点包含两个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特征点的提取，在图像检测到特征点的位置&lt;/li&gt;
&lt;li&gt;特征点的描述，也就是描述子。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在图像中提取到关键点的位置信息后，为了能够更有效的匹配（主要是保证尺度和旋转不变性），通常使用一个向量来描述关键点及其周围的信息。特征的描述子，在特征点的匹配中是非常重要的，上一小节中对其应该具有的性质做了介绍。但具体到一个算法来说，可能其既有特征点的提取算法也有特征点描述子的算法，也有可能其仅仅是一个特征点提取算法或者是特征点的描述子算法。在本小节就常用的特征点算法做一个简要的说明。&lt;/p&gt;
&lt;h4 id=&quot;sift&quot;&gt;SIFT&lt;/h4&gt;
&lt;p&gt;提到特征点算法，首先就是大名鼎鼎的SIFT算法了。SIFT的全称是Scale Invariant Feature Transform，尺度不变特征变换，2004年由加拿大教授David G.Lowe提出的。SIFT特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。&lt;br/&gt;SIFT算法主要有以下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高斯差分金字塔的构建&lt;br/&gt;使用组和层的结构构建了一个具有线性关系的金字塔（尺度空间），这样可以在连续的高斯核尺度上查找图像的特征点；另外，它使用一阶的高斯差分来近似高斯的拉普拉斯核，大大的减少了运算量。&lt;/li&gt;
&lt;li&gt;尺度空间的极值检测及特征点的定位&lt;br/&gt;搜索上一步建立的高斯尺度空间，通过高斯差分来识别潜在的对尺度和旋转不变的特征点。但是，在离散空间中，局部极值点可能并不是真正意义的极值点，真正的极值点有可能落在离散点的间隙中，SIFT通过尺度空间DoG函数进行曲线拟合寻找极值点。&lt;/li&gt;
&lt;li&gt;特征方向赋值&lt;br/&gt;基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向，后续的所有操作都是对于关键点的方向、尺度和位置进行变换，从而提供这些特征的不变性。&lt;/li&gt;
&lt;li&gt;特征描述子的生成&lt;br/&gt;通过上面的步骤已经找到的SIFT特征点的位置、方向、尺度信息，最后使用一组向量来描述特征点及其周围邻域像素的信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SIFT算法中及包含了特征点的提取算法，也有如何生成描述子的算法，更进一步的SIFT算法介绍可参看&lt;a href=&quot;http://www.cnblogs.com/wangguchangqing/p/4853263.html&quot; title=&quot;SIFT特征详解&quot;&gt;SIFT特征详解&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;surf&quot;&gt;SURF&lt;/h4&gt;
&lt;p&gt;SURF全称 Speeded Up Robust Features，是在SIFT算法的基础上提出的，主要针对SIFT算法运算速度慢，计算量大的缺点进行了改进。&lt;br/&gt;SURF的流程和SIFT比较类似，这些改进体现在以下几个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特征点检测是基于Hessian矩阵，依据Hessian矩阵行列式的极值来定位特征点的位置。并且将Hession特征计算与高斯平滑结合在一起，两个操作通过近似处理得到一个核模板。&lt;/li&gt;
&lt;li&gt;在构建尺度空间时，使用box filter与源图像卷积，而不是使用DoG算子。&lt;/li&gt;
&lt;li&gt;SURF使用一阶Haar小波在x、y两个方向的响应作为构建特征向量的分布信息。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;fast特征点提取算法&quot;&gt;FAST特征点提取算法&lt;/h4&gt;
&lt;p&gt;SIFT和SURF是非常好的，稳定的特征点算法，但运算速度是其一大弊端，无法做到实时的特征提取和匹配，其应用就有了很大的局限性。FAST特征提取算法弥补了这一局限，&lt;strong&gt;检测局部像素灰度变化明显的地方&lt;/strong&gt;，以速度快而著称，其全称为：Features From Accelerated Segment Test。在FAST算法的思想很简单：如果一个像素与周围邻域的像素差别较大（过亮或者过暗），那么可以认为该像素是一个角点。和其他的特征点提取算法相比，FAST算法只需要比较像素和其邻域像素的灰度值大小，十分便捷。&lt;br/&gt;FAST算法提取角点的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在图像中选择像素p，假设其灰度值为：&lt;span class=&quot;math inline&quot;&gt;\(I_p\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;设置一个阈值T，例如：&lt;span class=&quot;math inline&quot;&gt;\(I_p\)&lt;/span&gt;的20%&lt;/li&gt;
&lt;li&gt;选择p周围半径为3的圆上的16个像素，作为比较像素&lt;/li&gt;
&lt;li&gt;假设选取的圆上有连续的N个像素大于&lt;span class=&quot;math inline&quot;&gt;\(I_p + T\)&lt;/span&gt;或者&lt;span class=&quot;math inline&quot;&gt;\(I_p - T\)&lt;/span&gt;，那么可以认为像素p就是一个特征点。（N通常取12，即为FAST-12；常用的还有FAST-9,FAST-11）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FAST算法只检测像素的灰度值，其运算速度极快，同时不可避免的也有一些缺点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检测到的特征点过多并且会出现“扎堆”的现象。这可以在第一遍检测完成后，使用非最大值抑制（Non-maximal suppression），在一定区域内仅保留响应极大值的角点，避免角点集中的情况。&lt;/li&gt;
&lt;li&gt;FAST提取到的角点没有方向和尺度信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的介绍的SIFT和SURF算法都包含有各自的特征点描述子的计算方法，而FAST不包含特征点描述子的计算，仅仅只有特征点的提取方法，这就需要一个特征点描述方法来描述FAST提取到的特征点，以方便特征点的匹配。下面介绍一个专门的特征点描述子的计算算法。&lt;/p&gt;
&lt;h4 id=&quot;brief描述子&quot;&gt;BRIEF描述子&lt;/h4&gt;
&lt;p&gt;BRIEF是一种二进制的描述子，其描述向量是0和1表示的二进制串。0和1表示特征点邻域内两个像素（p和q）灰度值的大小：如果p比q大则选择1，反正就取0。在特征点的周围选择128对这样的p和q的像素对，就得到了128维由0，1组成的向量。那么p和q的像素对是怎么选择的呢？通常都是按照某种概率来随机的挑选像素对的位置。&lt;br/&gt;BRIEF使用随机选点的比较，速度很快，而且使用二进制串表示最终生成的描述子向量，在存储以及用于匹配的比较时都是非常方便的，其和FAST的搭配起来可以组成非常快速的特征点提取和描述算法。&lt;/p&gt;
&lt;h4 id=&quot;orb算法&quot;&gt;ORB算法&lt;/h4&gt;
&lt;p&gt;ORB的全称是Oriented FAST and Rotated BRIEF，是目前来说非常好的能够进行的实时的图像特征提取和描述的算法，它改进了FAST特征提取算法，并使用速度极快的二进制描述子BRIEF。&lt;br/&gt;针对FAST特征提取的算法的一些确定，ORB也做了相应的改进。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用非最大值抑制，在一定区域内仅仅保留响应极大值的角点，避免FAST提取到的角点过于集中。&lt;/li&gt;
&lt;li&gt;FAST提取到的角点数量过多且不是很稳定，ORB中可以指定需要提取到的角点的数量N，然后对FAST提取到的角点分别计算Harris响应值，选择前N个具有最大响应值的角点作为最终提取到的特征点集合。&lt;/li&gt;
&lt;li&gt;FAST提取到的角点不具有尺度信息，在ORB中使用图像金字塔，并且在每一层金字塔上检测角点，以此来保持尺度的不变性。&lt;/li&gt;
&lt;li&gt;FAST提取到的角点不具有方向信息，在ORB中使用灰度质心法(Intensity Centroid)来保持特征的旋转不变性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;opencv3中特征点的提取和匹配&quot;&gt;OpenCV3中特征点的提取和匹配&lt;/h3&gt;
&lt;p&gt;OpenCV中封装了常用的特征点算法（如SIFT,SURF，ORB等），提供了统一的接口，便于调用。 下面代码是OpenCV中使用其feature 2D 模块的示例代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    Mat img1 = imread(&quot;F:\\image\\1.png&quot;);
    Mat img2 = imread(&quot;F:\\image\\2.png&quot;);

    // 1. 初始化
    vector&amp;lt;KeyPoint&amp;gt; keypoints1, keypoints2;
    Mat descriptors1, descriptors2;
    Ptr&amp;lt;ORB&amp;gt; orb = ORB::create();

    // 2. 提取特征点
    orb-&amp;gt;detect(img1, keypoints1);
    orb-&amp;gt;detect(img2, keypoints2);

    // 3. 计算特征描述符
    orb-&amp;gt;compute(img1, keypoints1, descriptors1);
    orb-&amp;gt;compute(img2, keypoints2, descriptors2);
    
    // 4. 对两幅图像的BRIEF描述符进行匹配，使用BFMatch，Hamming距离作为参考
    vector&amp;lt;DMatch&amp;gt; matches;
    BFMatcher bfMatcher(NORM_HAMMING);
    bfMatcher.match(descriptors1, descriptors2, matches);&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;获取检测器的实例&lt;br/&gt;在OpenCV3中重新的封装了特征提取的接口，可统一的使用&lt;code&gt;Ptr&amp;lt;FeatureDetector&amp;gt; detector = FeatureDetector::create()&lt;/code&gt;来得到特征提取器的一个实例，所有的参数都提供了默认值，也可以根据具体的需要传入相应的参数。&lt;/li&gt;
&lt;li&gt;在得到特征检测器的实例后，可调用的&lt;code&gt;detect&lt;/code&gt;方法检测图像中的特征点的具体位置，检测的结果保存在&lt;code&gt;vector&amp;lt;KeyPoint&amp;gt;&lt;/code&gt;向量中。&lt;/li&gt;
&lt;li&gt;有了特征点的位置后，调用&lt;code&gt;compute&lt;/code&gt;方法来计算特征点的描述子，描述子通常是一个向量，保存在&lt;code&gt;Mat&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;得到了描述子后，可调用匹配算法进行特征点的匹配。上面代码中，使用了opencv中封装后的&lt;em&gt;暴力匹配算法&lt;/em&gt;&lt;code&gt;BFMatcher&lt;/code&gt;，该算法在向量空间中，将特征点的描述子一一比较，选择距离（上面代码中使用的是Hamming距离）较小的一对作为匹配点。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面代码匹配后的结果如下：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/439761/201712/439761-20171220215154240-855351628.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;特征点的匹配后的优化&quot;&gt;特征点的匹配后的优化&lt;/h4&gt;
&lt;p&gt;特征的匹配是针对特征描述子的进行的，上面提到特征描述子通常是一个向量，两个特征描述子的之间的距离可以反应出其相似的程度，也就是这两个特征点是不是同一个。根据描述子的不同，可以选择不同的距离度量。如果是浮点类型的描述子，可以使用其欧式距离；对于二进制的描述子（BRIEF）可以使用其汉明距离（两个不同二进制之间的汉明距离指的是两个二进制串不同位的个数）。&lt;/p&gt;
&lt;p&gt;有了计算描述子相似度的方法，那么在特征点的集合中如何寻找和其最相似的特征点，这就是特征点的匹配了。最简单直观的方法就是上面使用的：暴力匹配方法(Brute-Froce Matcher)，计算某一个特征点描述子与其他所有特征点描述子之间的距离，然后将得到的距离进行排序，取距离最近的一个作为匹配点。这种方法简单粗暴，其结果也是显而易见的，通过上面的匹配结果，也可以看出有大量的错误匹配，这就需要使用一些机制来过滤掉错误的匹配。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;汉明距离小于最小距离的两倍&lt;br/&gt;选择已经匹配的点对的汉明距离小于最小距离的两倍作为判断依据，如果小于该值则认为是一个错误的匹配，过滤掉；大于该值则认为是一个正确的匹配。其实现代码也很简单，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 匹配对筛选
double min_dist = 1000, max_dist = 0;
// 找出所有匹配之间的最大值和最小值
for (int i = 0; i &amp;lt; descriptors1.rows; i++)
{
    double dist = matches[i].distance;
    if (dist &amp;lt; min_dist) min_dist = dist;
    if (dist &amp;gt; max_dist) max_dist = dist;
}
// 当描述子之间的匹配大于2倍的最小距离时，即认为该匹配是一个错误的匹配。
// 但有时描述子之间的最小距离非常小，可以设置一个经验值作为下限
vector&amp;lt;DMatch&amp;gt; good_matches;
for (int i = 0; i &amp;lt; descriptors1.rows; i++)
{
    if (matches[i].distance &amp;lt;= max(2 * min_dist, 30.0))
        good_matches.push_back(matches[i]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/439761/201712/439761-20171220215245146-476222421.jpg&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对比只是用暴力匹配的方法，进行过滤后的匹配效果好了很多。&lt;/p&gt;
&lt;ul readability=&quot;22.348325258058&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;交叉匹配&lt;br/&gt;针对暴力匹配，可以使用交叉匹配的方法来过滤错误的匹配。交叉过滤的是想很简单，再进行一次匹配，反过来使用被匹配到的点进行匹配，如果匹配到的仍然是第一次匹配的点的话，就认为这是一个正确的匹配。举例来说就是，假如第一次特征点A使用暴力匹配的方法，匹配到的特征点是特征点B；反过来，使用特征点B进行匹配，如果匹配到的仍然是特征点A，则就认为这是一个正确的匹配，否则就是一个错误的匹配。OpenCV中&lt;code&gt;BFMatcher&lt;/code&gt;已经封装了该方法，创建&lt;code&gt;BFMatcher&lt;/code&gt;的实例时，第二个参数传入&lt;code&gt;true&lt;/code&gt;即可，&lt;code&gt;BFMatcher bfMatcher(NORM_HAMMING,true)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;KNN匹配&lt;br/&gt;K近邻匹配，在匹配的时候选择K个和特征点最相似的点，如果这K个点之间的区别足够大，则选择最相似的那个点作为匹配点，通常选择K = 2，也就是最近邻匹配。对每个匹配返回两个最近邻的匹配，如果第一匹配和第二匹配距离比率足够大（向量距离足够远），则认为这是一个正确的匹配，比率的阈值通常在2左右。&lt;br/&gt;OpenCV中的匹配器中封装了该方法，上面的代码可以调用&lt;code&gt;bfMatcher-&amp;gt;knnMatch(descriptors1, descriptors2, knnMatches, 2);&lt;/code&gt;具体实现的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const float minRatio = 1.f / 1.5f;
const int k = 2;

vector&amp;lt;vector&amp;lt;DMatch&amp;gt;&amp;gt; knnMatches;
matcher-&amp;gt;knnMatch(leftPattern-&amp;gt;descriptors, rightPattern-&amp;gt;descriptors, knnMatches, k);

for (size_t i = 0; i &amp;lt; knnMatches.size(); i++) {
    const DMatch&amp;amp; bestMatch = knnMatches[i][0];
    const DMatch&amp;amp; betterMatch = knnMatches[i][1];

    float  distanceRatio = bestMatch.distance / betterMatch.distance;
    if (distanceRatio &amp;lt; minRatio)
        matches.push_back(bestMatch);
}const  float minRatio =  1.f  /  1.5f;
const  int k =  2;

vector&amp;lt;vector&amp;lt;DMatch&amp;gt;&amp;gt; knnMatches;
matcher-&amp;gt;knnMatch(leftPattern-&amp;gt;descriptors, rightPattern-&amp;gt;descriptors, knnMatches, 2);

for (size_t i =  0; i &amp;lt; knnMatches.size(); i++) {
    const DMatch&amp;amp; bestMatch = knnMatches[i][0];
    const DMatch&amp;amp; betterMatch = knnMatches[i][1];
    float distanceRatio = bestMatch.distance  / betterMatch.distance;
    if (distanceRatio &amp;lt; minRatio)
        matches.push_back(bestMatch);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将不满足的&lt;strong&gt;最近邻的匹配之间距离比率大于设定的阈值（1/1.5）&lt;/strong&gt;匹配剔除。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;20.726272912424&quot;&gt;
&lt;p&gt;RANSAC&lt;br/&gt;另外还可采用随机采样一致性（RANSAC）来过滤掉错误的匹配，该方法利用匹配点计算两个图像之间&lt;strong&gt;单应矩阵&lt;/strong&gt;，然后利用重投影误差来判定某一个匹配是不是正确的匹配。OpenCV中封装了求解单应矩阵的方法&lt;code&gt;findHomography&lt;/code&gt;,可以为该方法设定一个&lt;strong&gt;重投影误差的阈值&lt;/strong&gt;，可以得到一个向量mask来指定那些是符合该重投影误差的匹配点对，以此来剔除错误的匹配，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const int minNumbermatchesAllowed = 8;
if (matches.size() &amp;lt; minNumbermatchesAllowed)
    return;

//Prepare data for findHomography
vector&amp;lt;Point2f&amp;gt; srcPoints(matches.size());
vector&amp;lt;Point2f&amp;gt; dstPoints(matches.size());

for (size_t i = 0; i &amp;lt; matches.size(); i++) {
    srcPoints[i] = rightPattern-&amp;gt;keypoints[matches[i].trainIdx].pt;
    dstPoints[i] = leftPattern-&amp;gt;keypoints[matches[i].queryIdx].pt;
}

//find homography matrix and get inliers mask
vector&amp;lt;uchar&amp;gt; inliersMask(srcPoints.size());
homography = findHomography(srcPoints, dstPoints, CV_FM_RANSAC, reprojectionThreshold, inliersMask);

vector&amp;lt;DMatch&amp;gt; inliers;
for (size_t i = 0; i &amp;lt; inliersMask.size(); i++){
    if (inliersMask[i])
        inliers.push_back(matches[i]);
}
matches.swap(inliers);const  int minNumbermatchesAllowed =  8;
if (matches.size() &amp;lt; minNumbermatchesAllowed)
    return;

//Prepare data for findHomography
vector&amp;lt;Point2f&amp;gt;  srcPoints(matches.size());
vector&amp;lt;Point2f&amp;gt;  dstPoints(matches.size());

for (size_t i =  0; i &amp;lt; matches.size(); i++) {
    srcPoints[i] = rightPattern-&amp;gt;keypoints[matches[i].trainIdx].pt;
    dstPoints[i] = leftPattern-&amp;gt;keypoints[matches[i].queryIdx].pt;
}

//find homography matrix and get inliers mask
vector&amp;lt;uchar&amp;gt;  inliersMask(srcPoints.size());
homography =  findHomography(srcPoints, dstPoints, CV_FM_RANSAC, reprojectionThreshold, inliersMask);

vector&amp;lt;DMatch&amp;gt; inliers;
for (size_t i =  0; i &amp;lt; inliersMask.size(); i++){
    if (inliersMask[i])
        inliers.push_back(matches[i]);
}
matches.swap(inliers);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之前写过一篇OpenCV的特征点匹配及一些剔除错误匹配的文章，&lt;a href=&quot;http://www.cnblogs.com/wangguchangqing/p/4333873.html&quot; title=&quot;OpenCV2:特征匹配及其优化&quot;&gt;OpenCV2:特征匹配及其优化&lt;/a&gt;，使用的是OpenCV2，在OpenCV3中更新了特征点检测和匹配的接口，不过大体还是差不多的。上一篇的文末附有练习代码的下载链接，不要直接打开sln或者project文件，有可能vs版本不一样打不开，本文的测试代码还没有整理，等有时间好好打理下github，练习的代码随手都丢了，到想用的时候又找不到了。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;翻了下，上一篇博客还是6月30号发布的，而今已是12月底，半年6个月时间就这样过去了。而我，好像没有什么成长啊，工资还是那么多，调试bug的技术倒是积累了很多，知道多线程程序调试;多进程通信;学会了用Windebug:分析dump文件，在无代码环境中attach到执行文件中分析问题或者拿着pdb文件和源代码在现场环境中进行调试...;实实在在的感受到了C++的内存泄漏和空指针导致的各种奇葩问题；知道了使用未初始化的变量的不稳定性；知道了项目设计中扩展性的重要的...&lt;br/&gt;写之前觉得自己虚度了半年，总结下来，这半年下来时间还是成长了不少的，心里的愧疚感降低了不少。不过以后还是要坚持写博客记录下学习的过程...&lt;/p&gt;
</description>
<pubDate>Wed, 20 Dec 2017 14:01:00 +0000</pubDate>
<dc:creator>Brook_icv</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangguchangqing/p/8076061.html</dc:identifier>
</item>
<item>
<title>深入浅出了解frame和bounds - zhanggui</title>
<link>http://www.cnblogs.com/zhanggui/p/8076051.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggui/p/8076051.html</guid>
<description>&lt;h5 id=&quot;frame&quot;&gt;frame&lt;/h5&gt;
&lt;p&gt;frame的官方解释如下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;The frame rectangle, which describes the view’s location and size in its superview’s coordinate system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;This rectangle defines the size and position of the view in its superview’s coordinate system. Use this rectangle during layout operations to set the size and position the view. Setting this property changes the point specified by the center property and changes the size in the bounds rectangle accordingly. The coordinates of the frame rectangle are always specified in points.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它定义了一个view相对于父视图坐标系的位置和大小，它会影响center属性和bounds属性的size。&lt;br/&gt;先看一下它究竟是什么？&lt;br/&gt;它是一个CGRect类型,如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CGRect {
    CGPoint origin;
    CGSize size;
};
&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CG_BOXABLE CGRect CGRect;

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CGPoint {
    CGFloat x;
    CGFloat y;
};
&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CG_BOXABLE CGPoint CGPoint;

&lt;span class=&quot;co&quot;&gt;/* Sizes. */&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CGSize {
    CGFloat width;
    CGFloat height;
};
&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; CG_BOXABLE CGSize CGSize;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的origin就是该view的位置，它是一个CGPoint类型，也是一个结构体，包含了我们熟知的常用二维坐标系的x、y。根据x、y可以在坐标系里面唯一确定一个点。如下图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/frame.jpeg&quot; alt=&quot;frame&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个坐标系和我们平时接触的还不太一样，它是向右向下为正方向。所以对于window来说，其原点是左上角，比如现在的头像的起始坐标就是（200，40）。按照原来常规的坐标系来说，应该是（200，-40）。&lt;br/&gt;在设置一个CGRect的时候，用到的方法是CGRectMake,其实现如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;CG_INLINE CGRect
CGRectMake(CGFloat x, CGFloat y, CGFloat width, CGFloat height)
{
  CGRect rect;
  rect.origin.x = x; rect.origin.y = y;
  rect.size.width = width; rect.size.height = height;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; rect;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是自己在实现部分创建了一个rect，然后逐个赋值。&lt;br/&gt;关于frame，这里要注意的一点就是：frame是相对于父视图的坐标系来定位的。如果你这样设置frame:(0,0,100,200),也就是在父视图左上角添加了一个宽100，高200的子视图（前提是没有改变父视图的bounds，接下来会有介绍bounds）。&lt;/p&gt;
&lt;h5 id=&quot;bounds&quot;&gt;bounds&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;The bounds rectangle, which describes the view’s location and size in its own coordinate system.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;The default bounds origin is (0,0) and the size is the same as the size of the rectangle in the frame property. Changing the size portion of this rectangle grows or shrinks the view relative to its center point. Changing the size also changes the size of the rectangle in the frame property to match. The coordinates of the bounds rectangle are always specified in points.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Changing the bounds rectangle automatically redisplays the view without calling its drawRect: method. If you want UIKit to call the drawRect: method, set the contentMode property to UIViewContentModeRedraw.&lt;br/&gt;Changes to this property can be animated.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它也是描述的是视图的位置和大小，只不过是在自己的坐标系上。也就是说它描述的是当前视图相对于自身坐标系的位置和大小。&lt;br/&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)viewDidLoad {
    [&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt; viewDidLoad];
   
    CGRect rect  = &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view.frame;
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView = [[ParentView alloc] initWithFrame:CGRectMake(&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt;, rect.size.width&lt;span class=&quot;dv&quot;&gt;-120&lt;/span&gt;, rect.size.height - &lt;span class=&quot;dv&quot;&gt;160&lt;/span&gt;)];
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.backgroundColor = [UIColor redColor];
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view addSubview:_parentView];
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;bounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.center));
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;frame:{{60, 80}, {200, 408}}
bounds:{{0, 0}, {200, 408}}
center:{160, 284}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，如果我们没有去更改bounds的值，它默认的位置坐标点是(0,0)。&lt;/p&gt;
&lt;h5 id=&quot;center&quot;&gt;center&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;The center point of the view's frame rectangle.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;The center point is specified in points in the coordinate system of its superview. Setting this property updates the origin of the rectangle in the frame property appropriately.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Use this property, instead of the frame property, when you want to change the position of a view. The center point is always valid, even when scaling or rotation factors are applied to the view's transform.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Changes to this property can be animated.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;center是view的中点。该属性是想归于父类的坐标系确定的。从bounds小节里面的例子可以看到center的值，其计算方法为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;center.x = frame.origin.x + frame.size.width/2&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;center.y = frame.origin.y + frame.size.height/2&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;transform&quot;&gt;transform&lt;/h5&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Specifies the transform applied to the view, relative to the center of its bounds.&lt;br/&gt;Use this property to scale or rotate the view's frame rectangle within its superview's coordinate system. (To change the position of the view, modify the center property instead.) The default value of this property is CGAffineTransformIdentity.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Transformations occur relative to the view's anchor point. By default, the anchor point is equal to the center point of the frame rectangle. To change the anchor point, modify the anchorPoint property of the view's underlying CALayer object.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Changes to this property can be animated.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;In iOS 8.0 and later, the transform property does not affect Auto Layout. Auto layout calculates a view’s alignment rectangle based on its untransformed frame.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它用于指定视图的变换。使用这个属性可以放大或者旋转视图，它的frame会因此改变，是以中心点为变换的。看例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)viewDidLoad {
    [&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt; viewDidLoad];
   
    CGRect rect  = &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view.frame;
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView = [[ParentView alloc] initWithFrame:CGRectMake(&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt;, rect.size.width&lt;span class=&quot;dv&quot;&gt;-120&lt;/span&gt;, rect.size.height - &lt;span class=&quot;dv&quot;&gt;160&lt;/span&gt;)];
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.backgroundColor = [UIColor redColor];
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view addSubview:_parentView];
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;bounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.center));
    
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.transform = CGAffineTransformMakeRotation(&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;);
   
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;after change transform,frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;after change transform,bounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;after change transform,center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.center));
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看输出的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;frame:{{60, 80}, {200, 408}}
bounds:{{0, 0}, {200, 408}}
center:{160, 284}
after change transform,frame:{{2.5773352536321568, 59.226689885086444}, {314.84532949273569, 449.54662022982711}}
after change transform,bounds:{{0, 0}, {200, 408}}
after change transform,center:{160, 284}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/transform.jpeg&quot; alt=&quot;transform&quot;/&gt;&lt;br/&gt;可以看出，当我们对图像通过旋转,旋转后的图片的frame已经变成了{{2.5773352536321568, 59.226689885086444}, {314.84532949273569, 449.54662022982711}},此时的起始位置为图上旋转后标的（2.58,59.2）,大小也变成了双箭头黑线标注的大小。&lt;br/&gt;因此得出结论：进行了transform变换，其frame改变了，但是其bounds和center并没有修改。此时bounds的size和frame的size已经没有关系了。当没有进行任何transform时，frame的size总是和bounds相等。&lt;/p&gt;
&lt;p&gt;以上便是对frame、bounds、center和transform做了一个简单的介绍。&lt;/p&gt;
&lt;h5 id=&quot;bounds的使用&quot;&gt;bounds的使用&lt;/h5&gt;
&lt;p&gt;接下来看一个例子（例子A）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
   
    CGRect rect  = self.view.frame;
    self.parentView = [[ParentView alloc] initWithFrame:CGRectMake(60, 80, rect.size.width-120, rect.size.height - 160)];
    self.parentView.backgroundColor = [UIColor redColor];
    [self.view addSubview:_parentView];
    NSLog(@&quot;frame:%@&quot;,NSStringFromCGRect(self.parentView.frame));
    NSLog(@&quot;bounds:%@&quot;,NSStringFromCGRect(self.parentView.bounds));
    NSLog(@&quot;center:%@&quot;,NSStringFromCGPoint(self.parentView.center));
 
    self.parentView.bounds = CGRectMake(-40, -40, self.parentView.frame.size.width, self.parentView.frame.size.height);
    NSLog(@&quot;parent change bound ,frame:%@&quot;,NSStringFromCGRect(self.parentView.frame));
    NSLog(@&quot;parent change bound ,bounds:%@&quot;,NSStringFromCGRect(self.parentView.bounds));
    NSLog(@&quot;parent change bound ,center:%@&quot;,NSStringFromCGPoint(self.parentView.center));

    self.childView = [[ChildView alloc] initWithFrame:CGRectMake(20, 20, 100, 100)];
    self.childView.backgroundColor = [UIColor yellowColor];
    [self.parentView addSubview:_childView];
   
    NSLog(@&quot;childView frame:%@&quot;,NSStringFromCGRect(self.childView.frame));
    NSLog(@&quot;childView ounds:%@&quot;,NSStringFromCGRect(self.childView.bounds));
    NSLog(@&quot;childView center:%@&quot;,NSStringFromCGPoint(self.childView.center));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里在parentView上添加了一个childView,然后对parentView的bounds进行修改和不修改进行了测试，结果如下：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/changebounds.jpeg&quot; alt=&quot;change bounds&quot;/&gt;&lt;br/&gt;你会发现当修改了parentView的bounds之后，发现childView缺向右向下做了偏移。这里设置parentView的bounds的origin为（-40,-40）为何会发生这种情况呢？接下来先看一下下面这张图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/coordient_system.jpeg&quot; alt=&quot;坐标系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;+代表正方向，-代表负方向。&lt;/p&gt;
&lt;p&gt;如果此时我们没有改变图中O的坐标，那么此时A的坐标是(20,20)，如果我们更改了O的坐标为（-20,-20），那么原来A点的坐标就成了A'（0,0）,但是A坐标是不变的，所以它会到黑色A处。所以你改变了原点坐标为负之后，A点会移动到黑色A。相反如果你设置了坐标原点为（20,20），那么A点就会和坐标原点重合。&lt;br/&gt;这就是为什么childView会向右向下移动的原因。&lt;br/&gt;接下来再做如下操作（例子B）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)viewDidLoad {
    [&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt; viewDidLoad];
   
    CGRect rect  = &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view.frame;
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView = [[ParentView alloc] initWithFrame:CGRectMake(&lt;span class=&quot;dv&quot;&gt;60&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt;, rect.size.width&lt;span class=&quot;dv&quot;&gt;-120&lt;/span&gt;, rect.size.height - &lt;span class=&quot;dv&quot;&gt;160&lt;/span&gt;)];
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.backgroundColor = [UIColor redColor];
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.view addSubview:_parentView];
     
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;parent change bound ,frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;parent change bound ,bounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;parent change bound ,center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.center));

    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView = [[ChildView alloc] initWithFrame:CGRectMake(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame.origin.x, &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame.origin.y+&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame.size.height&lt;span class=&quot;dv&quot;&gt;-200&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;)];
    &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.backgroundColor = [UIColor yellowColor];
    [&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView addSubview:_childView];
   
    
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;childView frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.frame));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;childView ounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.bounds));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;childView center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.center));
    NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;--------&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);
    CGRect parentBounds = &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds;
    [UIView animateWithDuration:&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; animations:^{
        
        &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds = CGRectMake(parentBounds.origin.x, &lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;, parentBounds.size.width, parentBounds.size.height);
    } completion:^(BOOL finished) {
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,parentView frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.frame));
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,parentView ounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.bounds));
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,parentView center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.parentView.center));
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,childView frame:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.frame));
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,childView bounds:%@&quot;&lt;/span&gt;,NSStringFromCGRect(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.bounds));
        NSLog(&lt;span class=&quot;st&quot;&gt;@&quot;anim finished,childView center:%@&quot;&lt;/span&gt;,NSStringFromCGPoint(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.childView.center));
    }];
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;parent change bound ,frame:{{60, 80}, {200, 408}}
parent change bound ,bounds:{{0, 0}, {200, 408}}
parent change bound ,center:{160, 284}
childView frame:{{60, 288}, {100, 100}}
childView ounds:{{0, 0}, {100, 100}}
childView center:{110, 338}
--------
anim finished,parentView frame:{{60, 80}, {200, 408}}
anim finished,parentView ounds:{{0, 400}, {200, 408}}
anim finished,parentView center:{160, 284}
anim finished,childView frame:{{60, 288}, {100, 100}}
anim finished,childView bounds:{{0, 0}, {100, 100}}
anim finished,childView center:{110, 338}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果是childView向上移动，然后停止。结果前后对比图如下：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/animationbounds.jpeg&quot; alt=&quot;animation bounds&quot;/&gt;&lt;br/&gt;直观来看，按说childView的frame改变了，但是从console输出的结果来看，childView的frame/bounds/center都没有改变，但是直观来看其位置却改变了。再看一下parentView,只有bounds改变了，frame和center却没变，从直观来看parentView没有任何更改。所以很有可能是parentView的bounds修改引起了childView的位置更改。这是为什么呢？这里先不说明为什么，再看一下最常用的UIScrollView:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- (void)viewDidLoad {
    [super viewDidLoad];
    self.scrollView = [[ZGUIScrolLView alloc] initWithFrame:self.view.frame];
    self.scrollView.delegate = self;
    [self.view addSubview:_scrollView];
    NSLog(@&quot;scrollview frame:%@&quot;,NSStringFromCGRect(_scrollView.frame));
    NSLog(@&quot;scrollview bounds:%@&quot;,NSStringFromCGRect(_scrollView.bounds));
    NSLog(@&quot;scrollview center:%@&quot;,NSStringFromCGPoint(_scrollView.center));
    self.scrollView.contentSize = CGSizeMake(800, 800);
    self.parentView = [[ParentView alloc] initWithFrame:CGRectMake(20, 100, 250, 300)];
    self.parentView.backgroundColor = [UIColor redColor];
    [self.scrollView addSubview:_parentView];
    NSLog(@&quot;parentView frame:%@&quot;,NSStringFromCGRect(_parentView.frame));
    NSLog(@&quot;parentView bounds:%@&quot;,NSStringFromCGRect(_parentView.bounds));
    NSLog(@&quot;parentView center:%@&quot;,NSStringFromCGPoint(_parentView.center));
    
}
- (void)scrollViewDidScroll:(UIScrollView *)scrollView {
    NSLog(@&quot;didScroll scrollview frame:%@&quot;,NSStringFromCGRect(_scrollView.frame));
    NSLog(@&quot;didScroll scrollview bounds:%@&quot;,NSStringFromCGRect(_scrollView.bounds));
    NSLog(@&quot;didScroll scrollview center:%@&quot;,NSStringFromCGPoint(_scrollView.center));
    NSLog(@&quot;didScroll parentView frame:%@&quot;,NSStringFromCGRect(_parentView.frame));
    NSLog(@&quot;didScroll parentView bounds:%@&quot;,NSStringFromCGRect(_parentView.bounds));
    NSLog(@&quot;didScroll parentView center:%@&quot;,NSStringFromCGPoint(_parentView.center));
    printf(&quot;\n-------------------------------------------\n&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当滚动视图的时候，console输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;scrollview frame:{{0, 0}, {320, 568}}
scrollview bounds:{{0, 0}, {320, 568}}
scrollview center:{160, 284}
parentView frame:{{20, 100}, {250, 300}}
parentView bounds:{{0, 0}, {250, 300}}
parentView center:{145, 250}
didScroll scrollview frame:{{0, 0}, {320, 568}}
didScroll scrollview bounds:{{0, -20}, {320, 568}}
didScroll scrollview center:{160, 284}
didScroll parentView frame:{{20, 100}, {250, 300}}
didScroll parentView bounds:{{0, 0}, {250, 300}}
didScroll parentView center:{145, 250}
-------------------------------------------
didScroll scrollview frame:{{0, 0}, {320, 568}}
didScroll scrollview bounds:{{8.5, 31.5}, {320, 568}}
didScroll scrollview center:{160, 284}
didScroll parentView frame:{{20, 100}, {250, 300}}
didScroll parentView bounds:{{0, 0}, {250, 300}}
didScroll parentView center:{145, 250}
-------------------------------------------
didScroll scrollview frame:{{0, 0}, {320, 568}}
didScroll scrollview bounds:{{25.5, 162}, {320, 568}}
didScroll scrollview center:{160, 284}
didScroll parentView frame:{{20, 100}, {250, 300}}
didScroll parentView bounds:{{0, 0}, {250, 300}}
didScroll parentView center:{145, 250}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据输出结果可以看到，parentView的center、frame、bounds在滚动过程中都没有作出更改，但是我们看到的它的位置的确改变了。而对于scrollView来说，其frame和center也没有更改，但是bounds更改了。&lt;br/&gt;这种现象和上面提到的（例子B）的现象一样，都是对bounds进行了修改。然后子视图从新进行了布局。说道子视图重新布局，让我想到了一个方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)layoutSubviews;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从字面意思看就是布局某个视图的子视图，那么会不会和这个方法有关呢？因此我在自定义的ZGUIScrollView里面实现了该方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- (void)layoutSubviews {
    NSLog(@&quot;scrollview's layoutSubViews called&quot;);
    [super layoutSubviews];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次滚动界面，发现每次滚动都会调用scrollview的layoutSubViews方法。苹果官方文档介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lays out subviews.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;You should not call this method directly. If you want to force a layout update, call the setNeedsLayout method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它的作用就是布局一个视图上的子视图。确定子视图的大小和位置。如果你想强制布局更新，你不能直接去调用这个方法，而是在下次更新图形之前调用setNeedsLayout方法，如果你要立即更新视图布局，调用layoutIfNeeded方法。&lt;/p&gt;
&lt;p&gt;由此可知，&lt;strong&gt;UIScrollView的实现就是通过bounds来实现的。contentOffset是bounds的origin。然后当bounds修改之后，会在layoutSubviews方法里面对子视图进行布局。对子类进行更新&lt;/strong&gt;。&lt;br/&gt;另外，我们还可以用bounds实现如下效果：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ScottZg/MarkDownResource/master/bounds%2Bframe/boundstocell.jpeg&quot; alt=&quot;bounds to set cell&quot;/&gt;&lt;br/&gt;图上右侧便是使用了bounds实现的效果。实现方式就是在自定义cell中重写drawReact:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode objectivec&quot;&gt;
&lt;code class=&quot;sourceCode objectivec&quot;&gt;- (&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;)drawRect:(CGRect)rect {
     &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.bounds = CGRectMake(&lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.bounds.origin.x, &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.bounds.origin.y, &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.frame.size.width&lt;span class=&quot;dv&quot;&gt;-20&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;self&lt;/span&gt;.frame.size.height - &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;);
    [&lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt; drawRect:rect];
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实UITableView(它是UIScrollView)的实现也是类似，更改了bounds,来实现滚动加载cell。&lt;/p&gt;
&lt;h5 id=&quot;总结&quot;&gt;总结&lt;/h5&gt;
&lt;p&gt;对bounds和frame的理解就是这些，其实系统用bounds的地方还是很多的。例如UIScrollView的实现就用到了。有疑问的话可以留言交流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：转赞请标明来源：&lt;a href=&quot;http://www.cnblogs.com/zhanggui/p/8076051.html&quot;&gt;张贵的博客&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Dec 2017 13:58:00 +0000</pubDate>
<dc:creator>zhanggui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanggui/p/8076051.html</dc:identifier>
</item>
</channel>
</rss>