<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>IntelliJ IDEA（十一） ：Debug的使用 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/9410844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/9410844.html</guid>
<description>&lt;p&gt;Debug模式是开发人员必会的一项调试程序的技能，用来追踪代码的运行流程，线上问题追踪，程序运行异常定位调试，以及在运行过程中参数的变化。IDEA的debug对于新手如何快速上手呢？&lt;/p&gt;
&lt;h2&gt;一、基本介绍&lt;/h2&gt;
&lt;p&gt;本篇文章是基于IntelliJ IDEA2018.1.6版本，最新的版本2018.2已经出来了，支持Java11，Debug模式的图标设计虽有微调改动，但是功能大体相通。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180803231019274-1651073388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图爬虫的图标就是Debug模式运行键，绿色三角形图标是正常的Run模式，长框中可以设置Debug运行配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180803231617748-16401659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打断点方法和Eclipse类似，只需要在自己想要调试的代码左边行号栏单击左键就可以，或者快捷键Ctrl+F8 打上/取消断点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804003149253-1071492017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Debug启动后，程序会停顿在第一个断点上，debug视图主要界面如下，各个按键分别是什么意思呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804005011435-797690365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt; 先来看下最左侧的各个按键，自上而下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt; 重启项目，快捷键Ctrl + F5，一般在你的代码有改动后可执行这个功能，意味重新启动项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;/strong&gt; 恢复程序，快捷键F9，在有多个断点的情况下，会直接跳到下一个断点，如果当前断点为最后一个则直接运行结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;/strong&gt; 暂停项目&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;/strong&gt; 停止当前启动的项目。快捷键Ctrl + F2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.&lt;/strong&gt; View Breakpoints 查看所有断点。快捷键Ctrl + Shift + F8&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804010501103-301822735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们打过的断点都可以在此窗口显示，如果想删除某个断点，则可以选中列表中的该断点，点击红色的减号来进行删除。或者也可以通过不选中该断点来使断点失效。另外，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804011926417-1379926315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个是针对单个断点定制的，亦可以在项目中断点处右击调出该界面。&lt;/p&gt;
&lt;p&gt;   * Java Line Breakpoints 显示了所有的断点，在右边勾选Condition，设置断点的条件。&lt;/p&gt;
&lt;p&gt;   * 勾选Log message to console，则会将当前断点行输出到控制台。&lt;/p&gt;
&lt;p&gt;   * 勾选Evaluate and log，可以在执行这行代码是计算表达式的值，并将结果输出到控制台。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.&lt;/strong&gt; 静哑断点，使所有断点无效，类似于无断点运行。选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。&lt;/p&gt;
&lt;p&gt;例如：加入断点过多，我们在其中某一个断点已经找到问题想要的答案，后面的断点不想继续了，可以点击一下该功能，就可以直接运行到程序结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt; 接下来是实际调试过程中常用用到的几个功能自左右向分别为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804012451344-1844586936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1. Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。&lt;/p&gt;
&lt;p&gt;2. Step Over (F8)：越过，一行一行地往下走，如果这一行上有方法不会进入方法。&lt;/p&gt;
&lt;p&gt;3. Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法。&lt;/p&gt;
&lt;p&gt;4. Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。&lt;/p&gt;
&lt;p&gt;5. Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。&lt;/p&gt;
&lt;p&gt;6. Drop Frame (默认无)：回退断点，后面章节详细说明。&lt;/p&gt;
&lt;p&gt;7. Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。&lt;/p&gt;
&lt;p&gt;8. Evaluate Expression (Alt + F8)：计算表达式。&lt;/p&gt;

&lt;h2&gt;二、快捷键说明&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Run                 Shift +&lt;span&gt; F10         运行最近一次运行的函数
Debug               Shift &lt;/span&gt;+&lt;span&gt; F9          运行debug最近一次运行的函数
Run                 Alt &lt;/span&gt;+ Shift +&lt;span&gt; F10   初次运行指定的函数
Debug               Alt &lt;/span&gt;+ Shift +&lt;span&gt; F9    初次debug运行指定的函数
Stop                Ctrl &lt;/span&gt;+&lt;span&gt; F2           停止项目
Step Over           F8                  越过当前函数
Forcce Step Over    Alt &lt;/span&gt;+ Shift +&lt;span&gt; F8    强制越过
Step Into           F7                  步入当前函数
Force Step Into     Alt &lt;/span&gt;+ Shift +&lt;span&gt; F7    强行进入当前函数
Smart Step Into     Shift &lt;/span&gt;+&lt;span&gt; F7          只能进入当前函数
Step out            Shift &lt;/span&gt;+&lt;span&gt; F8          步出
Resume Program      F9                  恢复程序
Evaluate Expression Alt &lt;/span&gt;+ F8            计算表达式
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、变量查看&lt;/h2&gt;
&lt;p&gt;在Debug过程中，跟踪查看变量的变化是非常必要的，这里就简单说下IDEA中可以查看变量的几个地方&lt;/p&gt;
&lt;p&gt;1、在IDEA中，参数所在行后面会显示当前变量的值。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804014812819-1572742549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、光标悬停到参数上，显示当前变量信息，快捷方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804014921750-1568519089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、在Variables里查看，这里显示当前方法里的所有变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804015004661-1487908636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、在Watches里，点击New Watch，输入需要查看的变量。或者可以从Variables里拖到Watche里查看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804015112825-2133997725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四、计算表达式&lt;/h2&gt;
&lt;p&gt;计算表达式，Evaluate Expression (Alt + F8) 。可以使用这个操作在调试过程中计算某个表达式的值，而不用再去打印信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804015227147-129889945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、点击计算表达式按钮或快捷键Alt + F8，你也可以选中某个表达式再Alt + F8，弹出计算表达式的窗口，如下，回车或点击Evaluate计算表达式的值。&lt;/p&gt;
&lt;p&gt;这个表达式不仅可以是一般变量或参数，也可以是方法，当你的一行代码中调用了几个方法时，就可以通过这种方式查看查看某个方法的返回值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804015558431-646752628.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、设置变量，在计算表达式的框里，可以改变变量的值，这样有时候就能很方便我们去调试各种值的情况了。 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804015743956-75357293.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;五、调试技巧&lt;/h2&gt;
&lt;p&gt;鼠标右键点击断点，调出如下窗口，当然也可以通过快捷键Ctrl + Shift + F8&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804020207854-313161748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1、断点条件设置&lt;/h3&gt;
&lt;p&gt;如上图通过设置Conditionn内容设置断点条件，通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。&lt;/p&gt;
&lt;p&gt;如遍历集合或者数组的时候，我们只想当下标等于某个值的时候才进入断点调试。如下数组，我希望当 i=5时才进入断点，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804020823371-45451282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;则可以这样设置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804021128883-2091242984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、多线程调试&lt;/h3&gt;
&lt;p&gt;一般debug都是单线程调试，但是开发过多线程应用，有些时候，为了观察多个线程间变量的不同状态，以及锁的获取等，就会想到在代码里加个断点debug一下。在IDE里断点停下来的时候，可以切换到另外的线程中，跑其他的代码，不会互相影响。但是在IntelliJ IDEA里默认是没有开启的。也就是说如果你在IDEA里代码里加断点，虽然一个线程的断了下来，但其他线程的已经执行过了。此处勾选上Suspend，并选择Thread，设置make default之后，也可以开始多线程应用的调试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804022118402-982045234.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个线程断下来之后，可以通过在线程窗口切换，到其它线程中继续运行。IntelliJ IDEA里在这儿切换&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804022235289-592231594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、回退断点&lt;/h3&gt;
&lt;p&gt;在调试的时候如果点击过快，错过了自己想要关注的那一行，如何能跳回到上一步呢？依靠后退执行的功能，可以后退，就像下棋时悔棋那种功能一样。&lt;/p&gt;
&lt;p&gt;所谓的断点回退，其实就是回退到上一个方法调用的开始处，在IDEA里测试无法一行一行地回退或回到到上一个断点处，而是回到上一个方法。回退的方式有两种：&lt;/p&gt;
&lt;p&gt;第一种是Drop Frame按钮，按调用的方法逐步回退，包括三方类库的其它方法(取消Show All Frames按钮会显示三方类库的方法)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804022934393-1043945040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二种方式，在调用栈方法上选择要回退的方法，右键选择Drop Frame，回退到该方法的上一个方法调用处，此时再按F9(Resume Program)，可以看到程序进入到该方法的断点处了。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;但有一点需要注意，断点回退只能重新走一下流程，之前的某些参数/数据的状态已经改变了的是无法回退到之前的状态的，如对象、集合、更新了数据库数据等等。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804023038457-1626826833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1162587/201808/1162587-20180804023121898-712648025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;六、JRebel热部署&lt;/h2&gt;
&lt;p&gt; 后续补充&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 18:32:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/9410844.html</dc:identifier>
</item>
<item>
<title>浅析java中的语法糖 - qingshanli</title>
<link>http://www.cnblogs.com/qingshanli/p/9375040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingshanli/p/9375040.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;编译器是一种计算机程序, 它主要的目的是将便于人编写、阅读、维护的高级计算机语言所写的源代码程序, 翻译为计算机能解读、运行的低阶机器语言的程序, 即可执行文件。而 javac 就是java语言中的编译器, 它用于将 .java 文件转换成JVM能识别的 .class 字节码文件, 反编译则是将 .class 文件转换成 .java 文件。&lt;/p&gt;
&lt;p&gt;语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。&lt;/p&gt;
&lt;p&gt;java中的语法糖只存在于编译期, 在编译器将 .java 源文件编译成 .class 字节码时, 会进行解语法糖操作, 还原最原始的基础语法结构。这些语法糖包含条件编译、断言、Switch语句与枚举及字符串结合、可变参数、自动装箱/拆箱、枚举、内部类、泛型擦除、增强for循环、lambda表达式、try-with-resources语句、JDK10的局部变量类型推断等等。&lt;/p&gt;
&lt;p&gt;关于反编译工具, 其实在JDK中自带了一个javap命令, 在以前的文章&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/qingshanli/p/9315649.html&quot;&gt;JDK的命令行工具系列 (二) javap、jinfo、jmap&lt;/a&gt;中也有提及到, 但是日常中很少会用到javap, 所以这次我们借助另一个&lt;a href=&quot;http://www.benf.org/other/cfr/&quot; target=&quot;_blank&quot;&gt;反编译工具 CFR&lt;/a&gt; 来分析java中的语法糖, 这里我下载的是最新的&lt;span&gt;cfr_0_132.jar&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;字符串拼接&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 字符串拼接
 * option: --stringbuilder false
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; stringBuilderTest(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; end) {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] foo = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[]{'@', 'a', '*'&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((ch = foo[++x]) != '*'&lt;span&gt;) {
        System.out.println(&lt;/span&gt;&quot;&quot; + x + &quot;: &quot; +&lt;span&gt; ch);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行: &lt;span&gt;java -jar cfr_0_132.jar CFRDecompilerDemo.class --stringbuilder false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803120016044-486497178.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;从反编译后的代码中能看出, 当我们使用+号进行字符串拼接操作时, 编译时会自动创建一个&lt;span&gt;StringBuilder&lt;/span&gt;对象。所以当在循环中拼接字符串时, 应避免使用+号操作, 否则每次循环都会创建一个&lt;span&gt;StringBuilder&lt;/span&gt;对象再回收, 造成较大的开销。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;条件编译&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 条件编译
 * option: 不需要参数
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ifCompilerTest() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
        System.out.println(&lt;/span&gt;&quot;false if&quot;&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        System.out.println(&lt;/span&gt;&quot;true else&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行: &lt;span&gt;java -jar cfr_0_132.jar CFRDecompilerDemo.class&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803142423489-682039451.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显, javac编译器在编译时期的解语法糖阶段, 会将条件分支不成立的代码进行消除。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;断言&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 断言, JDK1.4开始支持
 * option: --sugarasserts false
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; assertTest(String s) {
    &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; (!s.equals(&quot;Fred&quot;&lt;span&gt;));
    System.out.println(s);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行: &lt;span&gt;java -jar cfr_0_132.jar CFRDecompilerDemo.class --sugarasserts false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803145913175-818304986.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上, 当断言结果为true时, 程序继续正常执行, 当断言结果为false时, 则抛出AssertionError异常来打断程序的执行。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;枚举与Switch语句&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 枚举与Switch语句
 * option: --decodeenumswitch false
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; switchEnumTest(EnumTest e) {
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (e) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FOO:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; BAP:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 2&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 枚举, JDK1.5开始支持
 * option: --sugarenums false
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; EnumTest {
    FOO,
    BAR,
    BAP
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行: &lt;span&gt;java -jar cfr_0_132.jar CFRDecompilerDemo.class --decodeenumswitch false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803143426977-947258293.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;switch支持枚举是通过调用枚举类默认继承的父类Enum中的&lt;span&gt;ordinal()&lt;/span&gt;方法来实现的, 这个方法会返回枚举常量的序数。由于笔者的经验尚浅, 具体的实现细节还不是很清楚(比如枚举常量FOO的序数是0, 而case FOO语句编译后的 case 1, 这个1是什么? 另外switchEnumTest()方法传入一个FOO, 调用ordinal()方法得到的序数为0, 那么他又是如何与case 1进行匹配的呢?), 欢迎读者在留言区一起讨论。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;字符串与Switch语句&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
 * 字符串与Switch语句
 * option: --decodestringswitch false
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; switchStringTest(String s) {
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (s) {
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            System.out.println(&lt;/span&gt;&quot;Test&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;BB&quot;:  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BB and Aa have the same hashcode.&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; 12&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;Aa&quot;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;FRED&quot;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 13&lt;span&gt;;
    }
    System.out.println(&lt;/span&gt;&quot;Here&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行: &lt;span&gt;java -jar cfr_0_132.jar CFRDecompilerDemo.class --decodestringswitch false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803143605821-951143227.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;switch支持字符串是通过&lt;span&gt;hashCode()&lt;/span&gt;和&lt;span&gt;equals()&lt;/span&gt;方法来实现的, 先通过&lt;span&gt;hashCode()&lt;/span&gt;返回的哈希值进行switch, 然后通过&lt;span&gt;equals()&lt;/span&gt;方法比较进行安全检查, 调用&lt;span&gt;equals()&lt;/span&gt;是为了防止可能发生的哈希碰撞。&lt;/p&gt;
&lt;p&gt;另外switch还支持&lt;span&gt;byte&lt;/span&gt;、&lt;span&gt;short&lt;/span&gt;、&lt;span&gt;int&lt;/span&gt;、&lt;span&gt;char&lt;/span&gt;这几种基本数据类型, 其中支持&lt;span&gt;char&lt;/span&gt;类型是通过比较它们的ascii码(ascii码是整型)来实现的。所以switch其实只支持一种数据类型, 也就是整型, 其他诸如String、枚举类型都是转换成整型之后再使用switch的。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;可变参数&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 可变参数
 * option: --arrayiter false
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; varargsTest(String ... arr) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String s : arr) {
        System.out.println(s);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行: &lt;span&gt;java -jar cfr_0_132.jar CFRDecompilerDemo.class --arrayiter false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803143827363-1860208236.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可变参数其实就是一个不定长度的数组, 数组长度随传入方法的对应参数个数来决定。可变参数只能在参数列表的末位使用。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;自动装箱/拆箱&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 自动装箱/拆箱
 * option: --sugarboxing false
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Double autoBoxingTest(Integer i, Double d) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; d +&lt;span&gt; i;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行: &lt;span&gt;java -jar cfr_0_132.jar CFRDecompilerDemo.class --sugarboxing false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803144041276-2054980101.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们知道, 基本类型与包装类型在某些操作符的作用下, 包装类型调用&lt;code&gt;valueOf()&lt;/code&gt;方法的过程叫做装箱, 调用&lt;code&gt;xxxValue()方法&lt;/code&gt;的过程叫做拆箱。所以上面的结果很容易看出, 先对两个包装类进行拆箱, 再对运算结果进行装箱。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;枚举&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 枚举, JDK1.5开始支持
 * option: --sugarenums false
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; EnumTest {
    FOO,
    BAR,
    BAP
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行: &lt;span&gt;java -jar cfr_0_132.jar CFRDecompilerDemo.class --sugarenums false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803144547865-634089140.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们自定义一个枚举类型时, 编译器会自动创建一个被final修饰的枚举类来继承&lt;span&gt;Enum&lt;/span&gt;, 所以自定义枚举类型是无法继承和被继承的。当枚举类初始化时, 枚举字段引用该枚举类的一个静态常量对象, 并且所有的枚举字段都用常量数组&lt;span&gt;$VALUES&lt;/span&gt;来存储。&lt;span&gt;values()&lt;/span&gt;方法内则调用Object的&lt;span&gt;clone()&lt;/span&gt;方法, 参照&lt;span&gt;$VALUES&lt;/span&gt;数组对象复制一个新的数组, 新数组会有所有的枚举字段。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;内部类&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CFRDecompilerDemo {

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = 3&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部类
     * option: --removeinnerclasssynthetics false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; innerClassTest() {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; InnerClass().getSum(6&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getSum(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
            x &lt;/span&gt;+=&lt;span&gt; y;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        }
    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行:&lt;span&gt; java -jar cfr_0_132.jar CFRDecompilerDemo.class --removeinnerclasssynthetics false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803150827020-401588426.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们要明确, 上述innerClassTest()方法中的&lt;span&gt;this&lt;/span&gt;是外部类当前对象的引用, 而InnerClass类中的&lt;span&gt;this&lt;/span&gt;则是内部类当前对象的引用。编译过程中, 编译器会自动在内部类定义一个外部类的常量引用&lt;span&gt;this$0&lt;/span&gt;, 并且在内部类的构造器中初始化&lt;span&gt;this$0&lt;/span&gt;, 当外部类访问内部类时, 会把当前外部类的对象引用&lt;span&gt;this&lt;/span&gt;传给内部类的构造器用于初始化, 这样内部类就能通过所持有的外部类的对象引用, 来访问外部类的所有公有及私有成员。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;泛型擦除&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 泛型擦除
 * option: 
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; genericEraseTest() {
    List&lt;/span&gt;&amp;lt;String&amp;gt; list =  &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行: &lt;span&gt;java -jar cfr_0_132.jar CFRDecompilerDemo.class&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803145253168-1402875032.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在JVM中没有泛型这一概念,  只有普通方法和普通类, 所有泛型类的泛型参数都会在编译时期被擦除, 所以泛型类并没有自己独有的Class类对象比如List&amp;lt;Integer&amp;gt;.class, 而只有&lt;span&gt;List.class&lt;/span&gt;对象。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;增强for循环&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 增强for循环
 * option: --collectioniter false
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; forLoopTest() {
    String[] qingshanli &lt;/span&gt;= {&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&lt;span&gt;};  
    List&lt;/span&gt;&amp;lt;String&amp;gt; list =&lt;span&gt;  Arrays.asList(qingshanli);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object s : list) {
        System.out.println(s);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行: &lt;span&gt;java -jar cfr_0_132.jar CFRDecompilerDemo.class --collectioniter false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803151155842-1294559378.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显, 增强for循环的底层其实还是通过迭代器来实现的, 这也就解释了为什么增强for循环中不能进行增删改操作。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;lambda表达式&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * lambda表达式
 * option: --decodelambdas false
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lambdaTest() {
    String[] qingshanli &lt;/span&gt;= {&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&lt;span&gt;};  
    List&lt;/span&gt;&amp;lt;String&amp;gt; list =&lt;span&gt;  Arrays.asList(qingshanli);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用lambda表达式以及函数操作&lt;/span&gt;
    list.forEach((str) -&amp;gt; System.out.print(str + &quot;; &quot;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在JDK8中使用双冒号操作符&lt;/span&gt;
&lt;span&gt;    list.forEach(System.out::println);  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行:&lt;span&gt; java -jar cfr_0_132.jar CFRDecompilerDemo.class --decodelambdas false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803160951039-1629659950.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里笔者经验尚浅, 关于lambda表达式的实现原理暂不做阐述, 以免误人子弟, 欢迎有兴趣的读者在留言区一起讨论。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;try-with-resources语句&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * try-with-resources语句
 * option: --tryresources false
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tryWithResourcesTest() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; StringWriter writer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringWriter();
         &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; StringWriter writer2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringWriter()) {
        writer.write(&lt;/span&gt;&quot;This is qingshanli1&quot;&lt;span&gt;);
        writer2.write(&lt;/span&gt;&quot;this is qingshanli2&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令行:&lt;span&gt; java -jar cfr_0_132.jar CFRDecompilerDemo.class --tryresources false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803152324539-1851079267.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在JDK7之前, 如IO流、数据库连接等资源用完后, 都是通过finally代码块来释放资源。而try-with-resources语法糖则帮我们省去了释放资源这一操作, 编译器在解语法糖阶段时会将它还原成原始的语法结构。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;JDK10的局部变量类型推断&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 局部变量类型推断, JDK10开始支持
 * option: 不需要参数
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; varTest() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化局部变量  &lt;/span&gt;
    var string = &quot;qingshanli&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化局部变量  &lt;/span&gt;
    var stringList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
    stringList.add(&lt;/span&gt;&quot;九幽阴灵，诸天神魔，以我血躯，奉为牺牲。&quot;&lt;span&gt;);
    stringList.add(&lt;/span&gt;&quot;三生七世，永堕阎罗，只为情故，虽死不悔！&quot;&lt;span&gt;);
    stringList.add(&lt;/span&gt;&quot;blog:http://www.cnblogs.com/qingshanli/&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增强for循环的索引&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (var s : stringList){
        System.out.println(s);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传统for循环的局部变量定义&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (var i = 0; i &amp;lt; stringList.size(); i++&lt;span&gt;){
        System.out.println(stringList.get(i));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;JDK10环境下编译:&lt;span&gt; /home/qingshanli/Downloads/jdk-10.0.2/bin/javac CFRDecompilerDemo.java&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;命令行: &lt;span&gt;java -jar cfr_0_132.jar CFRDecompilerDemo.class --collectioniter false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180803153228437-1297024872.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出, 局部变量类型推断其实也是一个语法糖。在编译过程的解语法糖阶段, 会使用变量真正的类型来替代var类型。所以java由始至终是一种强类型语言, java中的var和弱类型语言JavaScript中的var是完全不一样的, 例如下图 &lt;span&gt;var i = &quot;10&quot; - 6&lt;/span&gt; 这样的语法运算在JavaScript中可以的, 而在Java语言中则不被允许。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1278884/201808/1278884-20180804004353391-1540412177.png&quot; alt=&quot;&quot; width=&quot;820&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外目前已知的允许使用var声明变量的几个场景有初始化局部变量、增强for循环的索引、传统for循环的局部变量定义。而诸如方法的形参、构造器的形参、方法的返回值类型、对象的成员变量、只进行定义而不初始化的变量等则不支持这种用法。对于后面的几种不支持, 我的猜想是因为它们会被外部访问而导致充满了不确定性, 举个栗子, 比如对象的成员变量X, 被对象A访问并赋值ArrayList类型, 被对象B访问并赋值HashMap类型, 那么问题来了, 对象A和对象B都是同一个类的实例, 这就产生了冲突, 此时虚拟机又如何区分这个对象的成员变量X到底是什么类型呢? &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;源代码&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('723b83fa-810c-482c-a015-dbb56bd5bf80')&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_723b83fa-810c-482c-a015-dbb56bd5bf80&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_723b83fa-810c-482c-a015-dbb56bd5bf80&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('723b83fa-810c-482c-a015-dbb56bd5bf80',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_723b83fa-810c-482c-a015-dbb56bd5bf80&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CFRDecompilerDemo {

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = 3&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 字符串拼接
     * option: --stringbuilder false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; stringBuilderTest(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; end) {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] foo = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[]{'@', 'a', '*'&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; ch;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((ch = foo[++x]) != '*'&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;&quot; + x + &quot;: &quot; +&lt;span&gt; ch);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 条件编译
     * option: 不需要参数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ifCompilerTest() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;false if&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;true else&quot;&lt;span&gt;);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 断言, JDK1.4开始支持
     * option: --sugarasserts false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; assertTest(String s) {
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; (!s.equals(&quot;Fred&quot;&lt;span&gt;));
        System.out.println(s);
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 枚举与Switch语句
     * option: --decodeenumswitch false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; switchEnumTest(EnumTest e) {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (e) {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; FOO:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; BAP:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 2&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
     * 字符串与Switch语句
     * option: --decodestringswitch false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; switchStringTest(String s) {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (s) {
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                System.out.println(&lt;/span&gt;&quot;Test&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;BB&quot;:  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BB and Aa have the same hashcode.&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; 12&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;Aa&quot;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &quot;FRED&quot;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 13&lt;span&gt;;
        }
        System.out.println(&lt;/span&gt;&quot;Here&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 可变参数
     * option: --arrayiter false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; varargsTest(String ... arr) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String s : arr) {
            System.out.println(s);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 自动装箱/拆箱
     * option: --sugarboxing false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Double autoBoxingTest(Integer i, Double d) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; d +&lt;span&gt; i;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 枚举, JDK1.5开始支持
     * option: --sugarenums false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; EnumTest {
        FOO,
        BAR,
        BAP
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部类
     * option: --removeinnerclasssynthetics false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; innerClassTest() {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; InnerClass().getSum(6&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InnerClass {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getSum(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; y) {
            x &lt;/span&gt;+=&lt;span&gt; y;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        }
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 泛型擦除
     * option: 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; genericEraseTest() {
        List&lt;/span&gt;&amp;lt;String&amp;gt; list =  &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 增强for循环
     * option: --collectioniter false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; forLoopTest() {
        String[] qingshanli &lt;/span&gt;= {&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&lt;span&gt;};  
        List&lt;/span&gt;&amp;lt;String&amp;gt; list =&lt;span&gt;  Arrays.asList(qingshanli);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object s : list) {
            System.out.println(s);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * lambda表达式
     * option: --decodelambdas false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lambdaTest() {
        String[] qingshanli &lt;/span&gt;= {&quot;haha&quot;, &quot;qingshan&quot;, &quot;helloworld&quot;, &quot;ceshi&quot;&lt;span&gt;};  
        List&lt;/span&gt;&amp;lt;String&amp;gt; list =&lt;span&gt;  Arrays.asList(qingshanli);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用lambda表达式以及函数操作&lt;/span&gt;
        list.forEach((str) -&amp;gt; System.out.print(str + &quot;; &quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在JDK8中使用双冒号操作符&lt;/span&gt;
&lt;span&gt;        list.forEach(System.out::println);  
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * try-with-resources语句
     * option: --tryresources false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tryWithResourcesTest() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; StringWriter writer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringWriter();
             &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; StringWriter writer2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringWriter()) {
            writer.write(&lt;/span&gt;&quot;This is qingshanli1&quot;&lt;span&gt;);
            writer2.write(&lt;/span&gt;&quot;this is qingshanli2&quot;&lt;span&gt;);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 局部变量类型推断, JDK10开始支持
     * option: 不需要参数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; varTest() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化局部变量  &lt;/span&gt;
        var string = &quot;qingshanli&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化局部变量  &lt;/span&gt;
        var stringList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
        stringList.add(&lt;/span&gt;&quot;九幽阴灵，诸天神魔，以我血躯，奉为牺牲。&quot;&lt;span&gt;);
        stringList.add(&lt;/span&gt;&quot;三生七世，永堕阎罗，只为情故，虽死不悔！&quot;&lt;span&gt;);
        stringList.add(&lt;/span&gt;&quot;blog:http://www.cnblogs.com/qingshanli/&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增强for循环的索引&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (var s : stringList){
            System.out.println(s);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传统for循环的局部变量定义&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (var i = 0; i &amp;lt; stringList.size(); i++&lt;span&gt;){
            System.out.println(stringList.get(i));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;参数资料&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/qingshanli/p/9281760.html&quot; target=&quot;_blank&quot;&gt;Java的编译原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Java代码的编译与反编译那些事儿-HollisChuang's Blog&quot; href=&quot;http://www.hollischuang.com/archives/58&quot; target=&quot;_blank&quot;&gt;Java代码的编译与反编译那些事儿-HollisChuang's Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;我反编译了Java 10的本地变量类型推断-HollisChuang's Blog&quot; href=&quot;http://www.hollischuang.com/archives/2187&quot; target=&quot;_blank&quot;&gt;我反编译了Java 10的本地变量类型推断-HollisChuang's Blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;Java中的Switch对整型、字符型、字符串型的具体实现细节-HollisChuang's Blo...&quot; href=&quot;http://www.hollischuang.com/archives/61&quot; target=&quot;_blank&quot;&gt;Java中的Switch对整型、字符型、字符串型的具体实现细节-HollisChuang's Blo...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_35038153/article/details/78054085&quot; target=&quot;_blank&quot;&gt;一些防止java代码被反编译的方法&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 17:37:00 +0000</pubDate>
<dc:creator>qingshanli</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingshanli/p/9375040.html</dc:identifier>
</item>
<item>
<title>LeetCode20——有效的括号 - tosser</title>
<link>http://www.cnblogs.com/tosser/p/9417049.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tosser/p/9417049.html</guid>
<description>&lt;p&gt;　　在记事本中写算法题和在纸上写其实感觉差不多，反正是不能进行调试。想起某高手的话，写代码要做到“人机合一”，写高级语言时（指的是 C 和 C++）脑海中要知道当前写的代码对应的反汇编代码，也就是要深入了解编译器对高级语言的处理。什么时候能达到这样的境界呢？&lt;/p&gt;

&lt;p&gt;LeetCode 题库的第 20 题——有效的括号&lt;/p&gt;
&lt;p&gt;　　我做题的习惯跟考试的习惯差不多，先找会做的，然后再慢慢啃不会的。本着一个原则，不用编译器，不去找答案，不会说明基础不牢固，继续补基础。&lt;/p&gt;
&lt;p&gt;　　题目我截图过来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/892439/201808/892439-20180804002119793-84694178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/892439/201808/892439-20180804002133605-1681069682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面的图是题目和给出的示例，示例是用来补充题目的，看着示例就知道什么时候应该返回 true ，什么时候返回 false 了。&lt;/p&gt;

&lt;p&gt;解题思路&lt;/p&gt;
&lt;p&gt;　　LeetCode 都会给出每个题的函数定义，比如这个题的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; isValid(&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; s) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我选择的是 C 语言来答题。&lt;/p&gt;
&lt;p&gt;　　这个题中告诉我们：&lt;/p&gt;
&lt;p&gt;　　1、正确的括号包括 括弧、方括号 和 花括号；&lt;/p&gt;
&lt;p&gt;　　2、括号需要 成对 出现；&lt;/p&gt;
&lt;p&gt;　　3、函数传递过来的是字符串。&lt;/p&gt;

&lt;p&gt;　　那么，我的思路是：&lt;/p&gt;
&lt;p&gt;　　1、获得字符串的长度，用来 申请一块 堆空间 和 遍历括号；&lt;/p&gt;
&lt;p&gt;　　2、申请一块同样大小的 堆内存空间 做数组，用来模拟 堆栈 数据结构；&lt;/p&gt;
&lt;p&gt;　　3、用一个变量来记录栈顶的位置，其实就是数组当前的下标；&lt;/p&gt;
&lt;p&gt;　　4、然后遍历括号，如果是 ( [ { ，那么就进入 堆栈，并修改栈顶的位置；&lt;/p&gt;
&lt;p&gt;　　5、如果是 ) ] } 那么就去和当前数组位置的前一个值进行比较，如果能够闭合，那么就让前一个出栈，并且修改栈顶的位置；&lt;/p&gt;
&lt;p&gt;　　6、如果无法闭合，那么就返回假；&lt;/p&gt;
&lt;p&gt;　　7、循环完成后，如果 堆栈 为空，说明括号都可以闭合，就返回 1，C 语言中 非0 为真；&lt;/p&gt;
&lt;p&gt;　　8、如果 堆栈 不为空，说明有尚未闭合的括号，就返回0， C 语言中 0 为假。&lt;/p&gt;

&lt;p&gt;解题答案&lt;/p&gt;
&lt;p&gt;　　这个题就是 数据结构 中堆栈的应用，还是比较简单的。完整代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; isValid(&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; s) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; strlen(s);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; pos = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; *pArr = (&lt;span&gt;char&lt;/span&gt;*)&lt;span&gt;malloc&lt;/span&gt;(len * &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len; i ++&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (s[i] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; || s[i] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; || s[i] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             pArr[pos ++] =&lt;span&gt; s[i];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (s[i] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ( pArr[pos - &lt;span&gt;1&lt;/span&gt;] != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 pos--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s[i] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ( pArr[pos - &lt;span&gt;1&lt;/span&gt;] != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 pos--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s[i] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ( pArr[pos - &lt;span&gt;1&lt;/span&gt;] != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 pos--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ( pos != &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　代码写的好不好就不管了，很多题都是 主调函数 释放空间，所以答题时，没有将 堆空间 释放掉，同样的 申请堆空间后，也没有判断内存是否申请成功。有很多地方写的不严谨，以后改正。&lt;/p&gt;

</description>
<pubDate>Fri, 03 Aug 2018 16:38:00 +0000</pubDate>
<dc:creator>tosser</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tosser/p/9417049.html</dc:identifier>
</item>
<item>
<title>操作系统中的同步互斥（锁与信号量） - miao_zheng</title>
<link>http://www.cnblogs.com/miachel-zheng/p/9351833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miachel-zheng/p/9351833.html</guid>
<description>&lt;p&gt;操作系统的同步与互斥可以从线程和进程两个角度进行理解。如果从线程的角度理解，这里本文以两个线程为例，需要考虑这两个线程是否属于同一个进程，对于不同进程的线程来说，它们本质上和从两个进程的角度进行理解是一样的，在之后讨论两个进程间的同步互斥时会详细说明。对于同一进程的两个线程，假设有这样一段代码。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;int res, temp=0;
res = temp++;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上文的代码是通过C语言编写的，需要经过编译、链接之后才能执行，经过编译后，“res=temp++;”可能被翻译成如下的汇编指令。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;load temp, reg1
store reg1, res
inc reg1
store temp, reg1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果两个线程同时执行这样一段代码，在执行过程中，可能发生线程切换，导致一个线程没有全部执行完这4条指令，就将执行权限交到另一个线程的情况。考虑这样一种情况，线程1在执行完inc reg1之后发生线程切换，第二个线程开始执行，如果第二个线程正常执行完毕，将temp置为1，然后切回线程1，再次将temp置为1。其实这已经和我们的初衷不符，因为正常情况下，我们通常认为temp应该等于2，而且更重要的是，这个代码带有不确定性，如果两个线程执行时，temp可能为1也可能为2，res的值也不确定。&lt;/p&gt;
&lt;p&gt;一种简单的做法是加锁，还是看一段代码。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;int res,temp=0;
LOCK(p);
res = temp++;
UNLOCK(p);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里假设p是一个全局变量，初始化为1，函数LOCK(p)可以理解为读取p的值，如果p&amp;gt;0则p执行自减操作，如果p=0则将当前线程睡眠一个固定的时间，然后再来查询p的值，这个过程可以表示为如下代码。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;void LOCK(int p)
{
    while(1)
    {
        if(p &amp;gt; 0)
        {
            p--;
            return;
        }
        sleep(10);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UNLOCK的代码同理，这里不详细写了。看到这里读者可能会发现，这段代码看似解决了以前的问题，但是带来了两个新的问题：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;这段代码并不能真正让多线程正确工作，比如线程1执行时，假设p=1，那么(p&amp;gt;0)是成立的，但是如果恰巧执行完p&amp;gt;0以后线程切换，线程1让出执行权限给线程2，那么线程2在判断p&amp;gt;0时也是成立的，这时两个线程仍然同时进入到临界区（我们把不允许多线程同时执行的区域称为临界区或互斥区，下同)，因此不能解决上述问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第二个问题是，即使多个线程不会同时进入到临界区，也会导致忙等待的问题。具体来说，如果线程1进入到临界区，这时切换到线程2，线程2可能也执行这段代码，当它试图执行LOCK(p)时，它会一直轮询p的状态，此时线程1没有执行，那么它这个时间片(线程2的执行时间)事实上是浪费了，如果线程2的优先级高于线程1，而且线程的调度算法是优先级高的线程总是先执行，那将产生可怕的后果，线程1永远也不能执行，因此永远也不会释放锁，而线程2永远在轮询，永远在浪费时间片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;显然，上述两个问题是不能回避的，这两个问题必须得到解决。针对第一个问题，事实上我们采用硬件提供的方法，由硬件确保查询和更改操作是原子操作，简单来说，就是判断(p&amp;gt;0)和执行p--这两个操作是原子操作，要么都做要么都不做，我记得C库会提供一个大致叫CompareAndChange的函数来完成这个操作。&lt;br/&gt;针对第二个问题，要解决起来就复杂的多。首先，操作系统将线程分为三种状态，分别是就绪（Ready）、挂起（Suspend）、执行（Execute），事实上这三种状态在很多地方都会用到，这里只考虑在访问临界区时的应用。首先介绍一下这三种状态，就绪态的线程是指一个线程已经就绪，简单来说就是可以被调度执行，需要注意，同一时刻可能存在多个就绪态的线程，如果当前执行的线程执行完毕后，会从当前多个就绪线程中选取一个线程（一般选择优先级最高的）切换到执行态。执行态的线程在同一时刻只有一个（事实上执行态的线程个数取决于CPU核的个数，但又不仅仅取决于CPU核的个数，这里不详细讨论），挂起态比较特殊，这类线程往往是由于资源得不到满足而挂起，等到资源满足以后再被唤醒切换到就绪态。举个简单的挂起态的例子，比如一个线程想要读磁盘，那么它只需要发一个系统调用告诉内核，再由内核告诉磁盘读取指定区域的数据，但是这个读取是需要时间的，此时这个线程就被阻塞了，因此给它时间片也没用，所以它会被os挂起，当磁盘读取完成后，可以告诉内核，然后由内核再将上述挂起线程唤醒。&lt;/p&gt;
&lt;p&gt;回到这个问题，当线程1执行了LOCK(p)之后进入到临界区以后，如果这时线程1让出执行权限，由线程2开始执行，那么当它执行到LOCK(p)时，它不会再去轮询p到状态，而是会将自己从执行态（因为此时线程2在执行，所以必然处于执行态）变为挂起状态。需要注意的是，无论线程2的优先级多么高，此时线程2再也没有执行的可能了。接下来，如果线程1执行完毕后，它会执行UNLOCK(p)，那么此时UNLOCK(p)也不能仅仅做p++了，它需要唤醒线程2，也就是唤醒等待p的线程。此时p已经不仅仅是一个整数那么简单了，准备的说，p已经是一个信号量了，信号量肯定比一个整数要复杂很多，但从原理上讲，也不需要很复杂。那么一个信号量需要什么呢？我想它应该需要两样东西：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一个整数记录当前信号量的值，信号量的值不总是1，比如临界区的代码是操作打印机，而此时存在十个打印机，那么允许十个线程同时进入到临界区，因此信号量可以是10，当然大多数情况下信号量只有0、1两个取值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;应该有一个队列作为信号量的等待队列，简单来说，如果线程1在临界区中执行时让出执行权限，在线程1再次被调度执行以前，有线程2、线程3两个线程都试图进入临界区，因此这两个线程会进入到一个队列中，当信号量被线程1释放时，我们一般会唤醒先等待信号量的线程，假设线程2先试图访问这个临界区，那么就先唤醒线程2，等线程2再次执行完毕后再唤醒线程3.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如此，一个简单的信号量就设计完成了，对于信号量的操作，一般称为P和V操作，P相当于LOCK、V相当于UNLOCK。当然，现在的操作系统对于信号量的设计远没有这么简单，考虑的情况也要复杂很多，这只是一个简单的分析，如果有读者在这方面想要交流，欢迎发邮件给我。&lt;/p&gt;

&lt;p&gt;上述考虑的是互斥的情况，下面考虑同步的情况。首先，操作系统为什么要有同步操作？举个例子，福特是汽车行业的先驱，尽管汽车的发明者是benz（关于汽车的发明者，现在仍然争论不休，这里不详细说了），但是福特真正把汽车带进了千家万户，他最大的贡献就是发明了流水线作业，大幅度降低了汽车制造的成本。流水线作业的本质是每个人只负责一小部分，整个工厂像流水线一样完成汽车制造。对于计算机来说，我们考虑这样一种情况，假设一个音乐播放软件，首先需要有一个线程负责告诉磁盘把音乐读到内存中，然后另一个线程负责把内存中的数据发送到声卡处理。那么整个音乐播放就是一个同步问题，首先需要将数据读到内存，才能将数据发送给声卡，播放出我们可以听见的声音。如果将这个问题抽象一下，可以认为有A、B、C、D四个操作，需要按照A、B、C、D的顺序执行，对于这类问题，应用上述信号量的机制就可以很好解决。比如设计三个信号量，这里分别记为a，b，c。线程B等待信号量a，线程C等待信号量b，线程D等待信号量c，初始化阶段将三个信号量都设置为0，因此线程B、C、D都会阻塞。当线程A执行完毕后，唤醒B，然后依次唤醒就可以让四个线程严格按照顺序执行。&lt;/p&gt;
&lt;p&gt;当然，这里考虑的仍然是非常简单的情况，读者可以考虑按照这种思路会出现哪些无法解决的问题？？或者仍有哪些问题没有考虑到？？&lt;/p&gt;
&lt;p&gt;欢迎留言以及邮件交流。&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 15:31:00 +0000</pubDate>
<dc:creator>miao_zheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/miachel-zheng/p/9351833.html</dc:identifier>
</item>
<item>
<title>MySQL-备份与还原 - 一入IT深似海·</title>
<link>http://www.cnblogs.com/xsuid/p/9416593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xsuid/p/9416593.html</guid>
<description>
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对于我们运维来说，在mysql数据库领域，别的不说，最起码要会两大技能！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一大技能：备份与还原&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二大技能：主从异步&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于这两大技能我们先来说说第一个&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;备份与还原&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;备份：我们按时定点来备份数据，当下数据最值钱，所以我们要确保数据的安全。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;平常我们都是7天一大备，三天两头一小备，也就是说，一周来一个完全备份，1、2、天来一个增量或差异备份。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;确保那天服务器宕机或误操作，能恢复过来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还原：当服务器负重过量会导致宕机，或有时候我们误操作，删除了某张重要的数据表等等，这时候就要用到我们之前备份的数据来恢复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单说下备份的类型，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;冷备：读写操作均不可进行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;温备：读操作可执行；但写操作不可执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;热备：读写操作均可执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MyISAM：温备，不支持热备&lt;br/&gt;InnoDB: 都支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单说下常用的备份工具，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LVM的快照：先加锁，做快照后解锁，几乎热备；借助文件系统工具进行备份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysqldump：逻辑备份工具，适用所有存储引擎，温备；支持完全或部分备份；对InnoDB存储引擎支持热备，结合binlog的增量备份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;xtrabackup：由Percona提供支持对InnoDB做热备(物理备份)的工具，支持完全备份、增量备份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：以上除了xtrabackup，都是基于完整备份包以及二进制日志来恢复数据库的，二进制日志记录了增删改语句的操作指令，拿过来重放，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;建议：建议二进制日志和数据文件分开存放 --&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、关闭网络链接，只监听本地端口访问，(在备份还原的时候用)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;skip-networking=1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、禁止主机名解析，ip地址访问的时候，禁止反向解析（建议加上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;skip_name_resolve = on&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、每个表单独使用一个表空间存储表的数据和索引（建议加上）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;innodb_file_per_table = on&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、开启并指定二进制文件存放位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;log_bin=/...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。。。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;准备&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、准备两台主机，我用.17充当mysql主服务器，.57来还原用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、17主mysql数据库有以下几个表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222145643-2046072471.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222145958-2113440543.png&quot; alt=&quot;image&quot; width=&quot;565&quot; height=&quot;270&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/data/mysq/：下存放数据库数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/app/logs/：下存放二进制日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;h2&gt;实战&lt;/h2&gt;
&lt;h3&gt;备份阶段&lt;/h3&gt;
&lt;h4&gt;1、完全备份&lt;/h4&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysqldump -pcentos -A -F --master-data=2 --single-transaction |gzip &amp;gt; /data/all-`date +%F`.sql.gz
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-A：备份全部数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-F：切换二进制日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--master-data=2：记录了基于二进制那个位置备份的，这个点之后是新数据，备份结束点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;--single-transaction：保证数据的一致性&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;2、解压并查看&lt;/h4&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
gzip -d all-2018-08-03.sql.gz
less all-2018-08-03.sql
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222146322-1801452241.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222146658-1546290035.png&quot; alt=&quot;image&quot; width=&quot;1113&quot; height=&quot;186&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：记住这个文件以及数字，一会还原的时候要用&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3、修改students表（新数据和日志）&lt;/h4&gt;
&lt;p&gt;1）没修改前&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222147085-67617119.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222147447-1574011042.png&quot; alt=&quot;image&quot; width=&quot;569&quot; height=&quot;595&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）加记录&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
insert students (name,age)values('gaoda1hao',20);
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222147790-1299839807.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222148145-2142196695.png&quot; alt=&quot;image&quot; width=&quot;571&quot; height=&quot;614&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）查看现在的二进制变化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222148537-1583064080.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222148955-1576042839.png&quot; alt=&quot;image&quot; width=&quot;1152&quot; height=&quot;163&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）假设现在这台mysql服务器宕机崩溃了，下面开始还原&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。。。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;还原阶段&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;上面规划的是用57这台主机来还原，首先这台主机必须是干净的mysql数据库&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;1、scp传送&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1）传送完全备份文件到目标主机&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
scp all-2018-08-03.sql 192.168.43.57:
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;2）传送上面图中00005文件以及之后的二进制文件到目标主机&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
scp mysql-bin.000005 192.168.43.57:
&lt;/pre&gt;
&lt;h4&gt;2、57主机来还原&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;注意：还原的时候要禁止除了你之外的所有用户的访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;停止mysql服务，在my.cnf配置文件中可以加上上面说到一项&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）开启服务前提下并完全备份数据包&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysql &amp;lt; all-2018-08-03.sql
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：现在只还原到了，备份时的状态，下面再次还原备份后到宕机这段时候发生的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）导入二进制日志&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysqlbinlog  --start-position=385 /root/mysql-bin.000005 &amp;gt; /app/binlog.sql
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：把00005中从385开始的指令语句导入到一个文件中&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysql &amp;lt; /app/binlog.sql
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：导入二进制记录的指令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;h2&gt;验证&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、看表存在不&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222149320-1880267645.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222149631-552964432.png&quot; alt=&quot;image&quot; width=&quot;518&quot; height=&quot;271&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、看表数据正不正确&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222149930-1146816210.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222150273-31162997.png&quot; alt=&quot;image&quot; width=&quot;578&quot; height=&quot;614&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK 还原成功&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;下面再来演示一个案例-误删除表的恢复&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;比如我们在某天的12点中做了完全备份，在下一次做完全备份中间有一天执行了删除某张表，删除后等了几个小时才发现表删除了，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这种场景下，来恢复数据，下面来模拟下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模拟顺序：完全备份--用户对表的数据修改--删除某张表--未发现用户继续对其他表操作--当访问被删除的表时发现--&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备工作和上面一样，下面进入正题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前几步和前面一样&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1、完全备份&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysqldump -pcentos -A -F --master-data=2 --single-transaction |gzip &amp;gt; /data/all-`date +%F`.sql.gz
&lt;/pre&gt;
&lt;h3&gt;2、模拟误删除表前的修改&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
insert students (name,age)values('gaoda1hao',20);
&lt;/pre&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：这期间加了好多数据，可能二进制文件已经满了，进行了切换&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3、模拟二进制文件的切换&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
flush logs;
#
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;接着增加几条记录&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
insert students (name,age)values('gaoda2hao',22);
&lt;/pre&gt;
&lt;h3&gt;4、模拟误删除数据表&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
drop table students;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：删除后还么有发现，接着增加其他表的数据&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
insert teachers (name,age)values('gaoda3',30);
&lt;/pre&gt;
&lt;h3&gt;5、发现问题并及时禁止用户写权限（只能读）&lt;/h3&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
flush tables with read lock;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;备注：现在只能root用户可以读写其他用户是不能修改数据的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222150532-504193403.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222150813-1442568093.png&quot; alt=&quot;image&quot; width=&quot;809&quot; height=&quot;116&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;h3&gt;6、干净系统还原&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1）停止服务&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
systemctl stop mairadb
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;2）删除所有mysql数据库数据&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
rm -rf /var/lib/mysql/
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;3）确保用户不能访问服务器 配置文件加上&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
skip-networking
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;4）启动服务&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;7、还原完全备份&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1）解压完全备份包&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
gzip -d all-2018-08-03.sql.gz
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;2）查看解压的文件确定位置&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
less all-2018-08-03.sql
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222151187-1212919439.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222151722-949715581.png&quot; alt=&quot;image&quot; width=&quot;1069&quot; height=&quot;184&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）把完整备份传送到57目标主机还原&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysql &amp;lt;all-2018-08-03.sql
&lt;/pre&gt;
&lt;h3&gt;8、还原增量备份&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1）合并00004以及之后的二进制日志文件&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysqlbinlog  --start-position=385 mysql-bin.000004 &amp;gt; /data/binlogs.sql
mysqlbinlog   mysql-bin.000005 &amp;gt;&amp;gt; /data/binlogs.sql
mysqlbinlog   mysql-bin.000006 &amp;gt;&amp;gt; /data/binlogs.sql
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;2）从合并的二进制日志文件中找到误操作的指令删除或注释&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222152103-557850186.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222152598-869911048.png&quot; alt=&quot;image&quot; width=&quot;1109&quot; height=&quot;241&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）scp传送到57目标主机还原&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;brush: bash;html-script: false;quick-code: true;smart-tabs: true;auto-links: false;toolbar: false;gutter; true;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
mysql &amp;lt;binlogs.sql
&lt;/pre&gt;
&lt;p&gt;。。。&lt;/p&gt;
&lt;h2&gt;验证&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、删除的表看看有了没&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222152985-1438580326.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222153410-1119901566.png&quot; alt=&quot;image&quot; width=&quot;617&quot; height=&quot;652&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在表删除后其他的表改的记录还在不&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222153672-173900761.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1432750/201808/1432750-20180803222153976-667808280.png&quot; alt=&quot;image&quot; width=&quot;630&quot; height=&quot;221&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还原成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欢迎补充--&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 14:28:00 +0000</pubDate>
<dc:creator>一入IT深似海&amp;#183;</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xsuid/p/9416593.html</dc:identifier>
</item>
<item>
<title>聊聊 JDK 非阻塞队列源码（CAS实现） - haifeiWu</title>
<link>http://www.cnblogs.com/haifeiWu/p/9416596.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haifeiWu/p/9416596.html</guid>
<description>&lt;p&gt;正如上篇文章&lt;a href=&quot;http://www.hchstudio.cn/article/2018/22ff/&quot;&gt;聊聊 JDK 阻塞队列源码（ReentrantLock实现）&lt;/a&gt;所说，队列在我们现实生活中队列随处可见，最经典的就是去银行办理业务，超市买东西排队等。今天楼主要讲的就是JDK中安全队列的另一种实现使用CAS算法实现的安全队列。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jdk-中的队列&quot;&gt;JDK 中的队列&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;JDK&lt;/strong&gt;中的队列都实现了 &lt;strong&gt;java.util.Queue&lt;/strong&gt; 接口，下面就是楼主要说的无锁版本的队列实现：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;LinkedTransferQueue&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;链表&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ConcurrentLinkedQueue&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;链表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;linkedtransferqueue-源码分析&quot;&gt;LinkedTransferQueue 源码分析&lt;/h2&gt;
&lt;p&gt;LinkedTransferQueue 的原理就是通过使用原子变量compare and swap（简称“CAS”）这种不加锁的方式来实现的进行并发控制，LinkedTransferQueue是一个无界的安全队列，其长度可以无限延伸，当然其带来的问题也是显而易见的。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;主要方法源码实现&quot;&gt;主要方法源码实现&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;add：添加元素到队列里，添加成功返回true；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;offer：添加元素到队列里，添加成功返回true，添加失败返回false；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;put：添加元素到队列里，如果容量满了会阻塞直到容量不满；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;poll：删除队列头部元素，如果队列为空，返回null。否则返回元素；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;take：删除队列头部元素，如果队列为空，一直阻塞到队列有元素并删除。&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;add&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean add(E e) {
    xfer(e, true, ASYNC, 0);
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;offer&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean offer(E e) {
    xfer(e, true, ASYNC, 0);
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;poll&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E poll() {
    return xfer(null, false, NOW, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;take&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E take() throws InterruptedException {
    E e = xfer(null, false, SYNC, 0);
    if (e != null)
        return e;
    Thread.interrupted();
    throw new InterruptedException();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码中可以看出，这些方法最终都指向了 &lt;code&gt;xfer&lt;/code&gt; 方法，只不过传入的不同的参数。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Implements all queuing methods. See above for explanation.
 *
 * @param e the item or null for take
 * @param haveData true if this is a put, else a take
 * @param how NOW, ASYNC, SYNC, or TIMED
 * @param nanos timeout in nanosecs, used only if mode is TIMED
 * @return an item if matched, else e
 * @throws NullPointerException if haveData mode but e is null
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从源码的 doc 注释中可以知道&lt;br/&gt;第一个参数，如果是 put 类型，就是实际的值，反之就是 null。&lt;br/&gt;第二个参数，是否包含数据，put 类型就是 true，take 就是 false。&lt;br/&gt;第三个参数，执行类型，有立即返回的NOW，有异步的ASYNC，有阻塞的SYNC， 有带超时的 TIMED。&lt;br/&gt;第四个参数，只有在 TIMED类型才有作用。&lt;/p&gt;
&lt;p&gt;接下来我们来看看 &lt;code&gt;xfer&lt;/code&gt; 到底是何方神圣&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private E xfer(E e, boolean haveData, int how, long nanos) {
    if (haveData &amp;amp;&amp;amp; (e == null))
        throw new NullPointerException();
    Node s = null;                        // the node to append, if needed

    retry:
    for (;;) {                            // restart on append race
        // 从  head 开始
        for (Node h = head, p = h; p != null;) { // find &amp;amp; match first node
            // head 的类型。
            boolean isData = p.isData;
            // head 的数据
            Object item = p.item;
            // item != null 有 2 种情况,一是 put 操作, 二是 take 的 itme 被修改了(匹配成功)
            // (itme != null) == isData 要么表示 p 是一个 put 操作, 要么表示 p 是一个还没匹配成功的 take 操作
            if (item != p &amp;amp;&amp;amp; (item != null) == isData) { 
                // 如果当前操作和 head 操作相同，就没有匹配上，结束循环，进入下面的 if 块。
                if (isData == haveData)   // can't match
                    break;
                // 如果操作不同,匹配成功, 尝试替换 item 成功,
                if (p.casItem(item, e)) { // match
                    // 更新 head
                    for (Node q = p; q != h;) {
                        Node n = q.next;  // update by 2 unless singleton
                        if (head == h &amp;amp;&amp;amp; casHead(h, n == null ? q : n)) {
                            h.forgetNext();
                            break;
                        }                 // advance and retry
                        if ((h = head)   == null ||
                            (q = h.next) == null || !q.isMatched())
                            break;        // unless slack &amp;lt; 2
                    }
                    // 唤醒原 head 线程.
                    LockSupport.unpark(p.waiter);
                    return LinkedTransferQueue.&amp;lt;E&amp;gt;cast(item);
                }
            }
            // 找下一个
            Node n = p.next;
            p = (p != n) ? n : (h = head); // Use head if p offlist
        }
        // 如果这个操作不是立刻就返回的类型    
        if (how != NOW) {                 // No matches available
            // 且是第一次进入这里
            if (s == null)
                // 创建一个 node
                s = new Node(e, haveData);
            // 尝试将 node 追加对队列尾部，并返回他的上一个节点。
            Node pred = tryAppend(s, haveData);
            // 如果返回的是 null, 表示不能追加到 tail 节点,因为 tail 节点的模式和当前模式相反.
            if (pred == null)
                // 重来
                continue retry;           // lost race vs opposite mode
            // 如果不是异步操作(即立刻返回结果)
            if (how != ASYNC)
                // 阻塞等待匹配值
                return awaitMatch(s, pred, e, (how == TIMED), nanos);
        }
        return e; // not waiting
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码有点长，其实逻辑很简单。就是找到 &lt;code&gt;head&lt;/code&gt; 节点,如果 &lt;code&gt;head&lt;/code&gt; 节点是匹配的操作,就直接赋值,如果不是,添加到队列中。&lt;br/&gt;注意：队列中永远只有一种类型的操作,要么是 &lt;code&gt;put&lt;/code&gt; 类型, 要么是 &lt;code&gt;take&lt;/code&gt; 类型.&lt;/p&gt;
&lt;h2 id=&quot;concurrentlinkedqueue-源码分析&quot;&gt;ConcurrentLinkedQueue 源码分析&lt;/h2&gt;
&lt;p&gt;与 &lt;code&gt;LinkedTransferQueue&lt;/code&gt; 一样，ConcurrentLinkedQueue 一样是采用原子变量实现的并发控制，&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt; 是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现。&lt;/p&gt;
&lt;h3 id=&quot;主要方法源码实现-1&quot;&gt;主要方法源码实现&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;add：添加元素到队列里，添加成功返回true；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;offer：添加元素到队列里，添加成功返回true，添加失败返回false；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;put：添加元素到队列里，如果容量满了会阻塞直到容量不满；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;poll：删除队列头部元素，如果队列为空，返回null。否则返回元素；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;remove：基于对象找到对应的元素，并删除。删除成功返回true，否则返回false；&lt;br/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;add&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean add(E e) {
    return offer(e);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;offer&lt;/code&gt;方法：&lt;/p&gt;&lt;p&gt;&lt;code&gt;ConcurrentLinkedQueue&lt;/code&gt;是无界的，所以&lt;code&gt;offer&lt;/code&gt;永远返回true，不能通过返回值来判断是否入队成功，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean offer(E e) {
    // 校验是否为空
    checkNotNull(e);
    //入队前，创建一个入队节点
    final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;E&amp;gt;(e);

    //循环CAS直到入队成功。
    // 1、根据tail节点定位出尾节点（last node）；
    // 2、将新节点置为尾节点的下一个节点，
    // 3、更新尾节点casTail。
    for (Node&amp;lt;E&amp;gt; t = tail, p = t;;) {
        Node&amp;lt;E&amp;gt; q = p.next;
        //判断p是不是尾节点，tail节点不一定是尾节点，判断是不是尾节点的依据是该节点的next是不是null
        if (q == null) { 
            // p is last node
            if (p.casNext(null, newNode)) {
                 //设置P节点的下一个节点为新节点，如果p的next为null，说明p是尾节点，casNext返回true；
                 // 如果p的next不为null，说明有其他线程更新过队列的尾节点，casNext返回false。
                // Successful CAS is the linearization point
                // for e to become an element of this queue,
                // and for newNode to become &quot;live&quot;.
                if (p != t) // hop two nodes at a time
                    casTail(t, newNode);  // Failure is OK.
                return true;
            }
            // Lost CAS race to another thread; re-read next
        }
        else if (p == q)
            //p节点是null的head节点刚好被出队，更新head节点时h.lazySetNext(h)把旧的head节点指向自己
            // We have fallen off list.  If tail is unchanged, it
            // will also be off-list, in which case we need to
            // jump to head, from which all live nodes are always
            // reachable.  Else the new tail is a better bet.
            p = (t != (t = tail)) ? t : head;
        else
            // Check for tail updates after two hops.
            //判断tail节点有没有被更新，如果没被更新，1）p=q：p指向p.next继续寻找尾节点;
            //如果被更新了，2)p=t:P赋值为新的tail节点
            p = (p != t &amp;amp;&amp;amp; t != (t = tail)) ? t : q;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;poll&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public E poll() {
    restartFromHead:
    //两层循环
    for (;;) {
        for (Node&amp;lt;E&amp;gt; h = head, p = h, q;;) {
            E item = p.item;

            if (item != null &amp;amp;&amp;amp; p.casItem(item, null)) {
                // Successful CAS is the linearization point
                // for item to be removed from this queue.
                if (p != h) // hop two nodes at a time
                    updateHead(h, ((q = p.next) != null) ? q : p);
                return item;
            }
            //队列为空，更新head节点
            else if ((q = p.next) == null) {
                updateHead(h, p);
                return null;
            }
            else if (p == q)
                //p节点是null的head节点刚好被出队，更新head节点时h.lazySetNext(h);把旧的head节点指向自己。
                //重新从head节点开始
                continue restartFromHead;
            else
                p = q;    //将p执行p的下一个节点
        }
    }
}

//更新head节点
final void updateHead(Node&amp;lt;E&amp;gt; h, Node&amp;lt;E&amp;gt; p) {
    //通过CAS将head更新为P
    if (h != p &amp;amp;&amp;amp; casHead(h, p))
        h.lazySetNext(h);//把旧的head节点指向自己
}

void lazySetNext(Node&amp;lt;E&amp;gt; val) {
    UNSAFE.putOrderedObject(this, nextOffset, val);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;remove&lt;/code&gt;方法：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean remove(Object o) {
    if (o != null) {
        Node&amp;lt;E&amp;gt; next, pred = null;
        // 循环CAS直到删除节点
        for (Node&amp;lt;E&amp;gt; p = first(); p != null; pred = p, p = next) {
            boolean removed = false;
            E item = p.item;
            if (item != null) {
                if (!o.equals(item)) {
                    next = succ(p);
                    continue;
                }
                // 通过CAS删除节点
                removed = p.casItem(item, null);
            }

            next = succ(p);
            if (pred != null &amp;amp;&amp;amp; next != null) // unlink
                pred.casNext(p, next);
            if (removed)
                return true;
        }
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文主要介绍了两种CAS算法实现的安全队列，然而稳定性要较高的系统中，为了防止生产者速度过快，导致内存溢出，通常是不建议选择无界队列的。当然楼主水平有限，文章中不免有纰漏，望小伙伴谅解并指出，在技术的道路上一起成长。&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
</description>
<pubDate>Fri, 03 Aug 2018 14:23:00 +0000</pubDate>
<dc:creator>haifeiWu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haifeiWu/p/9416596.html</dc:identifier>
</item>
<item>
<title>Net Core平台灵活简单的日志记录框架NLog+Mysql组合初体验 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9416439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9416439.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前几天分享的&quot;[Net Core集成Exceptionless分布式日志功能以及全局异常过滤][https://www.cnblogs.com/yilezhu/p/9339017.html]&quot; 有人说比较重量，生产环境部署也比较麻烦。因此就有了今天的这篇文章。如果你的项目（网站或者中小型项目）不是很大，日志量也不多的话可以考虑NLog+Mysql的组合。因为NLog具有高性能，易于使用，易于扩展和灵活配置的特点能够让你快速集成日志记录功能。&lt;br/&gt;作者：yilezhu&lt;br/&gt;本文链接 ：https://www.cnblogs.com/yilezhu/p/9416439.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;nlog是什么&quot;&gt;NLog是什么？&lt;/h3&gt;
&lt;p&gt;这里还是简单介绍一下吧，为了让小白也知道。NLog是一个灵活的免费日志记录平台，适用于各种.NET平台，包括.NET Core。NLog可以通过简单地配置就可以可以很方便的写入多个日志仓库中（数据库，文件，控制台）。&lt;/p&gt;
&lt;h3 id=&quot;nlog在net-core中怎么用啊&quot;&gt;NLog在Net Core中怎么用啊？&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;用之前你得新建一个asp.net core项目吧。这里以net core api为例吧。如下图所示是博主刚刚创建的net core api项目。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180803214801905-1166916829.png&quot; alt=&quot;net core api项目&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;35&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;建好项目之后干什么呢、当然得添加引用了。你可以随心所欲的使用Nuget或者命令进行安装&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Install-Package NLog -Version 4.5.7
Install-Package NLog.Web.AspNetCore -Version 4.5.4&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;上面说了，NLog只需要简单地修改配置就可以使用，那接下来就是新建一个NLog配置文件了。你可以通过Nuget或者程序包控制台进行安装，也可以自己新建一个NLog.config文件。这里还是通过程序包控制台进行安装吧&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Install-Package NLog -Version 4.5.7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装后看到项目目录多了一个NLog.config文件。这里需要注意，右键设置一下这个NLog.config的属性为“始终复制”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180803214801467-1670483707.png&quot; alt=&quot;1532873688872&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;25&quot;&gt;
&lt;p&gt;打开Nlog.config文件，看看里面的结构，发现有两个重要节点，一个是&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;nlog xmlns=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;
      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       autoReload=&quot;true&quot;
      throwExceptions=&quot;true&quot;
      internalLogLevel=&quot;Off&quot;&amp;gt;
  &amp;lt;targets&amp;gt;
    &amp;lt;target xsi:type=&quot;Null&quot; name=&quot;blackhole&quot; /&amp;gt;
    &amp;lt;target name=&quot;database&quot; xsi:type=&quot;Database&quot;
              dbProvider=&quot;MySql.Data.MySqlClient.MySqlConnection, MySql.Data&quot;
              connectionString=&quot;server=127.0.0.1;Database=nlog;user id=root;password=123456;SslMode=none&quot;
             &amp;gt;
      &amp;lt;!--
CREATE TABLE `log` (
  `Id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `Application` varchar(50) DEFAULT NULL,
  `Logged` datetime DEFAULT NULL,
  `Level` varchar(50) DEFAULT NULL,
  `Message` varchar(512) DEFAULT NULL,
  `Logger` varchar(250) DEFAULT NULL,
  `Callsite` varchar(512) DEFAULT NULL,
  `Exception` varchar(512) DEFAULT NULL,
  PRIMARY KEY (`Id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

--&amp;gt;
      &amp;lt;commandText&amp;gt;
        insert into nlog.log (
        Application, Logged, Level, Message,
        Logger, CallSite, Exception
        ) values (
        @Application, @Logged, @Level, @Message,
        @Logger, @Callsite, @Exception
        );
      &amp;lt;/commandText&amp;gt;
      &amp;lt;parameter name=&quot;@application&quot; layout=&quot;NLogTestDemo&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@logged&quot; layout=&quot;${date}&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@level&quot; layout=&quot;${level}&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@message&quot; layout=&quot;${message}&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@logger&quot; layout=&quot;${logger}&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@callSite&quot; layout=&quot;${callsite:filename=true}&quot; /&amp;gt;
      &amp;lt;parameter name=&quot;@exception&quot; layout=&quot;${exception:tostring}&quot; /&amp;gt;
    &amp;lt;/target&amp;gt;

  &amp;lt;/targets&amp;gt;

  &amp;lt;rules&amp;gt;
    &amp;lt;!--Skip Microsoft logs and so log only own logs--&amp;gt;
    &amp;lt;logger name=&quot;Microsoft.*&quot; minlevel=&quot;Trace&quot; writeTo=&quot;blackhole&quot; final=&quot;true&quot; /&amp;gt;
    &amp;lt;logger name=&quot;NLogTestDemo.*&quot; minlevel=&quot;Info&quot; writeTo=&quot;database&quot; /&amp;gt;
  &amp;lt;/rules&amp;gt;
&amp;lt;/nlog&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;上面的代码中我是以写入mysql为例进行的NLog配置。下面就可以进行简单地使用了。首先需要在。首先在Startup中的Configure中来加入中间件：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            //使用NLog作为日志记录工具
            loggerFactory.AddNLog();
            //引入Nlog配置文件
            env.ConfigureNLog(&quot;Nlog.config&quot;);
            //app.AddNLogWeb();
            app.UseMvc();
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在Program中进行如下配置：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Program
    {
        public static void Main(string[] args)
        {
            CreateWebHostBuilder(args).Build().Run();
        }

        public static IWebHostBuilder CreateWebHostBuilder(string[] args) =&amp;gt;
            WebHost.CreateDefaultBuilder(args)
            .UseNLog()
                .UseStartup&amp;lt;Startup&amp;gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;下面就可以在代码中愉快的玩耍了，&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private readonly Logger nlog = LogManager.GetCurrentClassLogger(); //获得日志实;

        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;string&amp;gt; Get()
        {
            nlog.Log(NLog.LogLevel.Debug, $&quot;yilezhu测试Debug日志&quot;);
            nlog.Log(NLog.LogLevel.Info, $&quot;yilezhu测试Info日志&quot;);
            try
            {
                throw new Exception($&quot;yilezhu故意抛出的异常&quot;);
            }
            catch (Exception ex)
            {

                nlog.Log(NLog.LogLevel.Error, ex, $&quot;yilezhu异常的额外信息&quot;);
            }
            return &quot;yilezhu的返回信息&quot;;
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;下面运行起来项目，然到数据库里面就可以看到记录的日志信息如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180803214800844-711521626.png&quot; alt=&quot;1533303655993&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里大家可能会问，为什么没有Debug信息输出呢，这是因为我们上面NLog配置设置的记录日志的最低级别为Info.所以比Info级别小的Debug信息不会记录。如果想记录的话就把这个级别设置成Debug或者比Debug小的Trace就可以记录了。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201808/1377250-20180803214800211-816318726.png&quot; alt=&quot;1533303848950&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文开头讲述了分布式日志记录框架Exceptionless部署困难说起，然后引出轻量级简单易用的NLog日志框架，并通过一个简单地api项目讲述了NLog如何在Net Core中使用。并且给出了NLog日志记录在mysql中的使用配置。以及mysql的建表语句。希望能对大家有所参考！&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 13:51:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9416439.html</dc:identifier>
</item>
<item>
<title>基于Win10极简SonarQube C#代码质量分析 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/9416376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/9416376.html</guid>
<description>&lt;p&gt;博客有些好些时间未更新了，这几个月的时间里，离开了实习的公司、大学毕了业、来了新公司、转了户口，有点忙，最近总算稍微闲下来了，打算重新拾起博客，坚持写下去。&lt;/p&gt;
&lt;p&gt;言归正转，什么是SonarQube ?&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;SonarQube&lt;/strong&gt;（曾用名&lt;strong&gt;Sonar&lt;/strong&gt;（声纳））是一个优秀的开源代码分析系统管理系统，支持超过25+种编程语言，对.Net Core当然也是支持的。&lt;/p&gt;
&lt;p&gt;最近公司做的项目是用的Framework开发的，久仰SonarQube大名，今天在本地搭建SonarQube之后对项目进行分析，效果惊人。揪出了系统中潜藏的若干Bug,功不可没，所以在这里搭建的方法分享给大家，希望对大家有所帮助。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213552776-1906527707.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213553399-1517244704.png&quot; alt=&quot;image&quot; width=&quot;782&quot; height=&quot;518&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在网上找一些资料，关于Sonar的介绍在Linux平台下较多，所以我下面的介绍主要是基于Win平台的，其他平台大同小异。&lt;/p&gt;
&lt;p&gt;安装Sonar主要有以下几步：&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;Sonar是一款基于JAVA开发的工具，安装JAVA SDK的过程在此不再叙述，建议安装好之后配置好JAVA_HOME的环境变量，以下是下载地址。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;首先到官网下载安装包，值得注意的是，该安装包是不分平台的，下载下来之后，选择Windows的文件夹中StartSonar.bat文件运行即可。&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://www.sonarqube.org/#downloads&quot; href=&quot;https://www.sonarqube.org/#downloads&quot;&gt;https://www.sonarqube.org/#downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213553957-761521924.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213554170-86375700.png&quot; alt=&quot;image&quot; width=&quot;541&quot; height=&quot;232&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果java环境安装正常，Sonar应该是能正常启动的，启动后浏览。启动效果如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213554927-1364544695.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213555198-1095559429.png&quot; alt=&quot;image&quot; width=&quot;559&quot; height=&quot;279&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;刚刚装好是英文的，我是安装了中文包，如何安装中文包，后面会叙述。&lt;/p&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;我们需要对Sonar进行简单配置，使其能连接上MySQL数据库。&lt;/p&gt;
&lt;p&gt;打开MySQL数据库，执行以下指令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;DATABASE&lt;/span&gt; sonar &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt;&lt;span&gt; utf8 COLLATE utf8_general_ci; 
&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;USER&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;GRANT&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; sonar.&lt;span&gt;*&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;GRANT&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt; &lt;span&gt;ON&lt;/span&gt; sonar.&lt;span&gt;*&lt;/span&gt; &lt;span&gt;TO&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sonar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
FLUSH &lt;/span&gt;&lt;span&gt;PRIVILEGES&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该操作是为Sonar创建数据库并添加该数据库的用户，数据库名称是sonar ,用户名是sonar，密码是sonar。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213555414-113925061.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213555634-237342991.png&quot; alt=&quot;image&quot; width=&quot;594&quot; height=&quot;147&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打开sonar.properties将内容替换成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sonar.jdbc.username=sonar
sonar.jdbc.password=sonar
sonar.jdbc.url=jdbc:mysql://localhost:3306/sonar?useUnicode=true&lt;/span&gt;&lt;span&gt;&amp;amp;characterEncoding&lt;/span&gt;=utf8&lt;span&gt;&amp;amp;rewriteBatchedStatements&lt;/span&gt;=true&lt;span&gt;&amp;amp;useConfigs&lt;/span&gt;=maxPerformance&lt;span&gt;&amp;amp;useSSL&lt;/span&gt;=false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中sonar.jbc.url是mysql数据库的连接字符串。&lt;/p&gt;
&lt;p&gt;重新启动Sonar(关闭运行startsonar.bat控制台，并在任务管理器中关闭所有和java有关的进程，重新运行startsonor.bat),使用管理员账户登录（admin/admin）。&lt;/p&gt;
&lt;p&gt;登录之后，安装中文包，如下，安装之后需要点击重新启动，启动之后，Sonar就变成中文的了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213555882-253619850.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213556137-1448221060.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;200&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;下载并解压SonarQube Scanner for MSBuild，它是C# Framework的分析插件。&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.3.1.1372/sonar-scanner-msbuild-4.3.1.1372-net46.zip&quot; href=&quot;https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.3.1.1372/sonar-scanner-msbuild-4.3.1.1372-net46.zip&quot;&gt;https://github.com/SonarSource/sonar-scanner-msbuild/releases/download/4.3.1.1372/sonar-scanner-msbuild-4.3.1.1372-net46.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压之后，设置SonarQube Scanner for MSBuild的环境变量，如我的解压路径是：C:\MyWorkSpace\Tools\sonar-scanner-msbuild-4.3.1.1372-net46，则把该路径添加到path下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213556399-1080920025.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213558019-846940078.png&quot; alt=&quot;image&quot; width=&quot;799&quot; height=&quot;507&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;修改SonarQube.Analysis.xml文件&lt;/p&gt;
&lt;p&gt;要修改的地方只是关于sonarQube服务器的一些配置，关于服务器URL、USER、PASSWORD等，修改如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
  This file defines properties which would be understood by the SonarQube Scanner for MSBuild, if not overridden (see below)
  By default the SonarScanner.MSBuild.exe picks-up a file named SonarQube.Analysis.xml in the folder it
  is located (if it exists). It is possible to use another properties file by using the /s:filePath.xml flag

  The overriding strategy of property values is the following:
  - A project-specific property defined in the MSBuild *.*proj file (corresponding to a SonarQube module) can override:
  - A property defined in the command line (/d:propertyName=value) has which can override:
  - A property defined in the SonarQube.Analysis.xml configuration file [this file] which can override:
  - A property defined in the SonarQube User Interface at project level which can override:
  - A property defined in the SonarQube User Interface at global level which can't override anything.

  Note that the following properties cannot be set through an MSBuild project file or an SonarQube.Analysis.xml file:
  sonar.projectName, sonar.projectKey, sonar.projectVersion
  The following flags need to be used to set their value: /n:[SonarQube Project Name] /k:[SonarQube Project Key] /v:[SonarQube Project Version]

&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SonarQubeAnalysisProperties  &lt;/span&gt;&lt;span&gt;xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsd&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema&quot;&lt;/span&gt;&lt;span&gt; xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.sonarsource.com/msbuild/integration/2015/1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.host.url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;http://localhost:9000&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;admin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;admin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 

  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Required only for versions of SonarQube prior to 5.2 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.jdbc.url&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jdbc:mysql://localhost:3306/sonar?useUnicode=true;characterEncoding=utf8;rewriteBatchedStatements=true;useConfigs=maxPerformance;useSSL=false&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.jdbc.username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sonar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Property &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;sonar.jdbc.password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;sonar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;SonarQubeAnalysisProperties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，重要的一步，找到你电脑中的MSBuild.exe并添加到path环境变量，便于后面在命令行中调用MSBuild,我的是在vs 2017的安装目录下&lt;/p&gt;
&lt;p&gt;C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\15.0\Bin\amd64&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213558976-629642874.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213559410-932387153.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;657&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;CMD进入C#项目所在的&lt;span&gt;根目录&lt;/span&gt;，依此执行以下三条命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MSBuild.SonarQube.Runner.exe begin /k:&quot;xxh.xzc.api&quot; /n:&quot;xhh.xzc.api&quot; /v:&quot;1.0&quot;
MSBuild.exe /t:Rebuild
MSBuild.SonarQube.Runner.exe end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;p&gt;/key(简写k)：对应projectKey即项目的唯一代码，如两套源代码使用同一个projectKey那扫描的结果将混在一起，所以一个项目需要有一个单独的projectKey&lt;/p&gt;
&lt;p&gt;/name(简写n)：对应projectName即项目的名称，为项目的一个显示的名称，建立使用完整的项目名称&lt;/p&gt;
&lt;p&gt;/version(简写v)：对应projectVersion即项目的版本，项目在不同的时期版本也是不一样的，如果方便，可以在sonarQube的服务器中查看到不同的版本代码其中问题的变化&lt;/p&gt;
&lt;p&gt;三条命令分别是分析的前期准备，MSBuild编译，将报告上传给SonarQube。&lt;/p&gt;

&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213601096-1965043271.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213601366-74949686.png&quot; alt=&quot;image&quot; width=&quot;751&quot; height=&quot;486&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，进入&lt;a title=&quot;http://localhost:9000/projects&quot; href=&quot;http://localhost:9000/projects&quot;&gt;http://localhost:9000/projects&lt;/a&gt;  查看分析结果吧，惊喜不惊喜？&lt;/p&gt;
&lt;p&gt;界面中功能强大，很多认为绝对发现不了的Bug都展现出来了，还可以查看单元测试的覆盖率，相信如果坚持使用该工具，一定会对编码习惯有很大帮助。&lt;/p&gt;
&lt;p&gt;快快搭建一个SonarQube看看自己的代码有没有BUG!! &lt;img class=&quot;wlEmoticon wlEmoticon-openmouthedsmile&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180803213601614-1899774408.png&quot; alt=&quot;大笑&quot;/&gt;&lt;/p&gt;



&lt;p&gt;参考文献：&lt;a title=&quot;https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild&quot; href=&quot;https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild&quot;&gt;https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+MSBuild&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 13:36:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/9416376.html</dc:identifier>
</item>
<item>
<title>AQS(AbstractQueuedSynchronizer)同步器的底层解析 - 上帝爱吃苹果-Soochow</title>
<link>http://www.cnblogs.com/keeya/p/9416094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keeya/p/9416094.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch等等&lt;strong&gt;是用来构建锁或者其他同步组件的基础框架&lt;/strong&gt;，它使用了一个volatile int state 成员变量表示&lt;strong&gt;同步状态&lt;/strong&gt;，通过内置的FIFO队列来完成资源获取线程的排队工作，该队列就是&lt;strong&gt;CLH同步队列&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其核心思想是，&lt;strong&gt;如果被请求的共享资源空闲&lt;/strong&gt;，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么&lt;strong&gt;就需要一套线程阻塞等待以及被唤醒时锁分配的机制&lt;/strong&gt;，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CLH&lt;/strong&gt;(Craig,Landin,and Hagersten)队列是一个&lt;strong&gt;虚拟的双向队列&lt;/strong&gt;（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。&lt;strong&gt;AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/721070/201705/721070-20170504110246211-10684485.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;state的访问方式有三种:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getState()&lt;/li&gt;
&lt;li&gt;setState()&lt;/li&gt;
&lt;li&gt;compareAndSetState()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。&lt;/p&gt;
&lt;p&gt;自定义同步器实现时主要实现以下几种方法：&lt;/p&gt;
&lt;p&gt;同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入CLH同步队列，&lt;strong&gt;同时会阻塞当前线程(自旋判断自己是否要阻塞)&lt;/strong&gt;，当同步状态释放时，会把首节点中的线程唤醒（公平锁），使其再次尝试获取同步状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chuantu.biz/t6/338/1530782590x-1404817575.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chuantu.biz/t6/339/1530861936x-1404817575.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点。置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，&lt;strong&gt;因此设置头节点的方法并不需要使用CAS来保证&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://chuantu.biz/t6/339/1530861980x-1404817575.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;独占式状态获取&quot;&gt;独占式状态获取&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;独占式，同一时刻仅有一个线程持有同步状态。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在AQS中维护着一个FIFO的同步队列，当线程获取同步状态失败后，则会加入到这个CLH同步队列的队尾并一直保持着自旋。&lt;strong&gt;在CLH同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果为首节点则不断尝试获取同步状态&lt;/strong&gt;，获取成功则退出CLH同步队列。当线程执行完逻辑后，会释放同步状态，释放后会唤醒其后继节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;获得同步状态操作&quot;&gt;获得同步状态操作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;tryAcquire：去尝试获取锁，获取成功则设置锁状态并返回true，否则返回false。&lt;strong&gt;该方法自定义同步组件自己实现&lt;/strong&gt;，该方法必须要保证线程安全的获取同步状态。&lt;/li&gt;
&lt;li&gt;addWaiter：如果tryAcquire返回FALSE（获取同步状态失败），则调用该方法将当前线程加入到CLH同步队列尾部。&lt;/li&gt;
&lt;li&gt;acquireQueued：当前线程会根据公平性原则来进行阻塞等待（自旋）,直到获取锁为止；并且返回当前线程在等待过程中有没有中断过。&lt;/li&gt;
&lt;li&gt;selfInterrupt：产生一个中断。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;acquire(int arg)方法为AQS提供的模板方法，该方法为独占式获取同步状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;amp;&amp;amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;acquireQueued方法为一个自旋的过程，也就是说当前线程（Node）进入同步队列后，就会进入一个自旋的过程，每个节点都会自省地观察，当条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        //中断标志
        boolean interrupted = false;
        //自旋过程——死循环
        for (;;) {
            //获得当前线程的前驱节点
            final Node p = node.predecessor();
            //如果当前线程的前驱节点是头节点，同步状态成功了
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                setHead(node);//设置头节点为自己（非CAS方法）
                p.next = null; // help GC
                failed = false;
                return interrupted;//在此处返回
            }
            //如果前驱节点不是首结点，或者同步失败，则判断是否阻塞当前线程
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在线程获取同步状态时如果获取失败，则加入CLH同步队列，通过通过自旋的方式不断获取同步状态，但是在自旋的过程中则需要判断当前线程是否需要阻塞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    //获得前驱节点的状态
    int ws = pred.waitStatus;
    //如果前驱节点的等待状态是SIGNAL，表示当前节点将来可以被唤醒，那么当前节点就可以安全的挂起了，返回true
    if (ws == Node.SIGNAL)
        return true;
    //如果前驱结点状态大于0，表明节点已经超时或者被中断，需要移出队列
    if (ws &amp;gt; 0) {
        //移出队列逻辑并返回false
        do {
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &amp;gt; 0);
        pred.next = node;
    } else {
        //上述条件都不符合则通过CAS将前驱节点设置为signal
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;shouldParkAfterFailedAcquire(Node pred, Node node)方法返回true，则调用parkAndCheckInterrupt()方法阻塞当前线程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);//停止自旋,等待将来被唤醒
    return Thread.interrupted();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当前线程在“死循环”中尝试获取同步状态，而只有前驱节点是头节点才能够尝试获取同步状态，这是为什么？原因有两个，如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态之后，将会唤醒其后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。&lt;/li&gt;
&lt;li&gt;第二，维护同步队列的FIFO原则。&lt;br/&gt;&lt;img src=&quot;http://chuantu.biz/t6/339/1530863186x-1404817575.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;释放同步状态操作&quot;&gt;释放同步状态操作&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当线程释放同步状态后，则需要唤醒该线程的后继节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
            //唤醒后继节点
            unparkSuccessor(h);
        return true;
    }
    return false;
}

private void unparkSuccessor(Node node) {
    //当前节点状态
    int ws = node.waitStatus;
    if (ws &amp;lt; 0)
        compareAndSetWaitStatus(node, ws, 0);
    //当前节点的后继节点
    Node s = node.next;
    //后继节点超时或者中断了
    if (s == null || s.waitStatus &amp;gt; 0) {
        s = null;
        //从tail尾节点回溯找到第一个可用节点
        for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
            if (t.waitStatus &amp;lt;= 0)
                s = t;
    }
    //唤醒后继节点
    if (s != null)
        LockSupport.unpark(s.thread);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;共享式状态获取&quot;&gt;共享式状态获取&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状态。&lt;/strong&gt; 以文件的读写为例，如果一个程序在对文件进行读操作，那么这一时刻对于该文件的写操作均被阻塞，而读操作能够同时进行。写操作要求对资源的独占式访问，而读操作可以是共享式访问。这部分其实要看读写锁是怎么实现的，AQS只是提供了一个模板，具体共享是怎么实现的可以看读写锁的源码！&lt;br/&gt;&lt;img src=&quot;http://chuantu.biz/t6/350/1532867301x-1404817491.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;tryAcquireShared(int)：&lt;strong&gt;共享方式&lt;/strong&gt;。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;AQS提供acquireShared(int arg)方法共享式获取同步状态，方法首先是调用tryAcquireShared(int arg)方法尝试获取同步状态，如果获取失败则调用doAcquireShared(int arg)自旋方式获取同步状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &amp;lt; 0)
        //获取失败则自旋获取同步状态
        doAcquireShared(arg);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;private void doAcquireShared(int arg) {
    //共享式节点
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            //前驱节点
            final Node p = node.predecessor();
            //如果是前驱节点则尝试获取同步状态
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;aqs应用举例&quot;&gt;AQS应用举例&lt;/h2&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;以ReentrantLock为例&lt;/strong&gt;，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;再以&lt;strong&gt;CountDownLatch&lt;/strong&gt;以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如&lt;strong&gt;ReentrantReadWriteLock&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;参考：&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 12:12:00 +0000</pubDate>
<dc:creator>上帝爱吃苹果-Soochow</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/keeya/p/9416094.html</dc:identifier>
</item>
<item>
<title>redux源码解读（二） - 渔歌</title>
<link>http://www.cnblogs.com/yugege/p/9416059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yugege/p/9416059.html</guid>
<description>&lt;p&gt;之前，已经写过一篇&lt;a href=&quot;https://github.com/zhanyuzhang/chess-blogs/issues/3&quot;&gt;redux源码解读（一）&lt;/a&gt;，主要分析了 &lt;code&gt;redux&lt;/code&gt; 的核心思想，并用100多行代码实现一个简单的 &lt;code&gt;redux&lt;/code&gt; 。但是，那个实现还不具备合并 &lt;code&gt;reducer&lt;/code&gt; 和添加 &lt;code&gt;middleware&lt;/code&gt; 的功能。&lt;/p&gt;
&lt;p&gt;今天我们一起来看看合并 &lt;code&gt;reducer&lt;/code&gt; （即 &lt;code&gt;combineReducers&lt;/code&gt;） 的原理和实现。&lt;/p&gt;
&lt;p&gt;在分析原理之前，先来看看&lt;code&gt;combineReducers&lt;/code&gt; 的用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { createStore, combineReducers } from 'redux';
const addScore = (state, action) =&amp;gt; {};
const deleteScore = (state, action) =&amp;gt; {};
const rootReducer = combineReducers({addStore, deleteScore});
const store = createStore(rootReducer);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的例子可以看出，&lt;code&gt;combineReducers&lt;/code&gt; 接收的参数类型是一个原生对象，其中这个对象的每个键值都是一个 &lt;code&gt;reducer&lt;/code&gt; 纯函数。另外，因为 &lt;code&gt;combineReducer()&lt;/code&gt; 返回的结果可以传递给&lt;code&gt;createStore&lt;/code&gt;作为参数，可以推出它返回的结果也是一个 &lt;code&gt;reducer&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;了解了 &lt;code&gt;combineReducer&lt;/code&gt; 用法之后 ，那开始一步一步的用代码来实现其功能吧。&lt;/p&gt;
&lt;p&gt;首先，需要先声明 &lt;code&gt;combineReducers&lt;/code&gt; 的参数，然后判断传进来的参数是不是原生对象类型（ &lt;code&gt;plain object&lt;/code&gt; ），如果不是，则抛出异常，如果是，则需要获取该对象的所有属性（key）并存放到变量 &lt;code&gt;reducerKeys&lt;/code&gt; 里面，然后对这些key进行遍历，过滤掉那些不是函数的值，并将结果放到 &lt;code&gt;finalReducerKeys&lt;/code&gt; 里面。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default function combineReducers(reducers) {
  // 判断参数reducers是否为对象
  if(Object.prototype.toString.call(reducer) !== '[object Object]') {
    throw new Error('combineReducers expected plain object params');
  }

  const reducerKeys = Object.keys(reducers);
  let finalReducerKeys = [];
  // 过滤掉value不是Function类型的键名，然后将结果放到fianlReducerKeys里面
  reducerKeys.forEach((key, i) =&amp;gt; {
    if(typeof reducers[key] === 'function') {
      finalReducerKeys.push(key);
    }
  });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面已经提到过了 &lt;code&gt;combineReducers&lt;/code&gt; 返回的结果是一个纯函数。那这个返回的函数需要处理些什么逻辑呢？因为他合并了其他的 &lt;code&gt;reducers&lt;/code&gt;，所以需要遍历这些 &lt;code&gt;reducer&lt;/code&gt; 并执行他们。然后，并对比一下执行 &lt;code&gt;reducer&lt;/code&gt; 之后的数据有没有变化 ，如果有变化则返回新的 &lt;code&gt;state&lt;/code&gt;， 否则直接返回之前的 &lt;code&gt;state&lt;/code&gt;。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default function combineReducers(reducers) {
  // 省略和前面相同的部分

  // 返回一个新的、经过组合的reducer函数
  return function(state = {}, action) {
    let hasChanged = false;
    const nextState = {};
    // 遍历finalReducerKeys，并调用对应的reducer。
    finalReducerKeys.forEach((key, i) =&amp;gt; {
      const stateForKey = state[key];
      const nextStateForKey = reducers[key](stateForKey, action);
      nextState[key] = nextStateForKey;
      // 如果前后状态不一样，则hasChanged设为true
      if(stateForKey !== nextStateForKey) {
        hasChanged = true;
      }
    });
    // 如果有变化，则返回新的state，否则返回旧的
    return hasChanged ? nextState : state;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK，《&lt;code&gt;redux&lt;/code&gt; 源码解读（二）》就写到这里，今天周五啦，祝大家周末愉快哈！如果对 &lt;code&gt;combineReducer&lt;/code&gt;还有不明白的地方，欢迎留言讨论哈。另外，可能有些地方我分析得不到位的，建议到我的github去下载代码自己再好好研究一下。重要的事情说三遍：&lt;a href=&quot;https://github.com/zhanyuzhang/redux-with-combine-reducers&quot;&gt;代码在这里下载&lt;/a&gt;! &lt;a href=&quot;https://github.com/zhanyuzhang/redux-with-combine-reducers&quot;&gt;代码在这里下载&lt;/a&gt;! &lt;a href=&quot;https://github.com/zhanyuzhang/redux-with-combine-reducers&quot;&gt;代码在这里下载&lt;/a&gt;!&lt;/p&gt;
</description>
<pubDate>Fri, 03 Aug 2018 12:03:00 +0000</pubDate>
<dc:creator>渔歌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yugege/p/9416059.html</dc:identifier>
</item>
</channel>
</rss>