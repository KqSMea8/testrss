<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python 中的函数 - YJK923</title>
<link>http://www.cnblogs.com/YJK923/p/9534405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YJK923/p/9534405.html</guid>
<description>&lt;p&gt;学了 Python 中的数据类型，语句，接下来就来说一下 Python 中的函数，函数是结构化编程的核心。我们使用函数可以增加程序的可读性。自定义函数时使用关键字&lt;code&gt;def&lt;/code&gt; 函数由多条语句组成。在定义函数的时候我们可以使用如下的方式给函数定义一个解释文档。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; square(x):
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;This is comment of this method !&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; x *&lt;span&gt; x

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取方法注释信息&lt;/span&gt;
square.&lt;span&gt;__doc__&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;上面定义的函数我们就可以通过&lt;code&gt;函数名.__doc__&lt;/code&gt;的方式获取方法的文档字符串。&lt;/p&gt;
&lt;p&gt;另外，所有的函数都有返回值，如果你没有显示的告诉它返回什么，则返回&lt;code&gt;None&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个函数怎么能少得了参数的部分呢，一不留神可能就会搞错，这里大概说一下，若传递的参数为不可变的参数，则不会修改参数的值，像是 数字，字符串，元组，但若是引用值的话，就可能会将原来的值改变。比方说 列表，字典。可以采用切片的方式避免对传入列表的修改，如：&lt;code&gt;change(names[:])&lt;/code&gt; 这样的话我们传入的是names列表的一个复制版本，而对 names 本身没有影响。&lt;/p&gt;
&lt;p&gt;关键字参数和默认值，举例说明&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; hello(greeting = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;{},{}!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(greeting,name))

hello()
Hello,world!

hello(name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;YJK923&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Hello,YJK923!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;可变参数：允许用户提供任意数量的参数。使用 &lt;code&gt;*&lt;/code&gt; 号将提供的所有参数收集到一个元组中。这种用法在赋值的时候也遇到过。举例&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; print_params(*&lt;span&gt;param):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(param)

print_param(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Testing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Testing

print_param(&lt;/span&gt;1,2,3&lt;span&gt;)
(&lt;/span&gt;1,2,3)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;星号的参数最好放在最后，不然在调用方法的时候需要指出星号参数后面的参数的值是多少。 &lt;br/&gt;还有一种使用两个星号，是用于收集带有关键字参数的方法，得到的值是一个字典而不是一个元组。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; print_dict(**&lt;span&gt;params):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(params)

print_dict(x &lt;/span&gt;= 1,y = 2,z = 3&lt;span&gt;)
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;z&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;上面两个都是在定义函数的时候使用了 * ，那我们在调用的函数的时候也可以使用星号，这也就是分配参数，像这样&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(x,y)：
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y


param &lt;/span&gt;= (1,2) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个元组，用做参数&lt;/span&gt;
add(*param) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用 * 来分配参数&lt;/span&gt;
3 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结果为 3 ,这就是分配参数之后的结果&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;Python 中的作用域的概念类似于 Java，所以理解起来没有问题，但是 Python 好像都不是老老实实的，我们知道在方法里的变量是局部变量，我们在方法里使用时，全局变量不受影响，但是 Python 社区的小伙伴就是想改变全局变量的值，该怎么操作呢？发明了一个关键字&lt;code&gt;global&lt;/code&gt;用于指定某个方法里的值为全局变量。&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
x = 1
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; change(x):
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt; x &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此时的x就是指向全局变量x&lt;/span&gt;
    x = x + 1&lt;span&gt;

change(x)
此时 x &lt;/span&gt;= 2
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;递归 ： 函数之间的相互调用是很正常的，存在这么一种情况，那就是自己调用自己，这就是递归调用。 &lt;br/&gt;举例说明&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算数字n的阶乘 n ！ = n * (n-1) * (n -2) * ... * 1&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 分析：1 的阶乘为 1，大于 1 的数 n 的阶乘等于 n-1 的阶乘 * n&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; factorial(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1&lt;span&gt; :
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt; :
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n * factorial(n-1)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;递归函数通常包含两部分内容，一是基线条件，满足条件函数将直接放回一个值，像上面的&lt;code&gt;n = 1 return 1&lt;/code&gt; 二是包含一个或多个调用，这些调用旨在解决问题的一部门。这里的关键是，通过将问题分解为较小的部门，可避免递归没完没了，因为问题终将被分解成基线条件可以解决的最小问题。（抽象啊，多看看，体会体会吧！）&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算某一个数的幂&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 分析：power(x,n) 表示计算 x 的 n 次幂。也就是将数 x 自乘 n-1 次。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 对于任意数来说，n 为 0 的时候结果都为 1，n &amp;gt; 0 的时候，power(x,n) = x * power(x,n-1) ,是不是感觉可以用递归做点什么！&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; power(x,n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n ==&lt;span&gt; 0 :
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt; :
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x * power(x,n-1)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;好吧，上面两个递归运算还没有理解递归的概念，没关系，还有一个！&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用python递归实现二分法查找&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 介绍：在有序的列表中，所要查找数据和中间数据比较。依次拆分，比较中间的数。&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; search(list,number,lower,upper):
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;使用二分法查找指定数据的索引，list 是排好序的列表，number 是查找的数据 lower，upper 指定查找的起始位置&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; lower ==&lt;span&gt; upper:
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; number ==&lt;span&gt; list[upper]
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; upper
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; :
        middle &lt;/span&gt;= (lower + upper) // 2  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  // 表示不留小数除&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; number &amp;gt;&lt;span&gt; list[middle] :
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; search(list,number,middle+1&lt;span&gt;,upper)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; :
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; search(list,number,lower,middle)
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;说了以上这么多，对函数式编程的理解也是马马虎虎，用函数来编写程序 ？可能看到了 Python 中提供的这几个函数，能对函数式编程加深一下感觉。&lt;code&gt;map filter reduce&lt;/code&gt; 给几个例子看一下&lt;/p&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;18&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
list(map(str,range(5))) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与[srt(i) for i in range(5)] 等价&lt;/span&gt;
[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以使用 filter根据布尔函数的返回值对元素进行过滤&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 首先你得有一个可以返回布尔值的函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x.isalnum() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; isalnum 方法检测字符串是否由字母或数字组成&lt;/span&gt;
&lt;span&gt;
seq &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x41&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;***&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;?!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
list(filter(func,seq))
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x41&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 同样的实现可以这么来&lt;/span&gt;
[x &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; seq &lt;span&gt;if&lt;/span&gt;&lt;span&gt; x.isalnum()]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 还有一种叫 lambda 表达式的玩意，是这样写的&lt;/span&gt;
filter(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x : x.isalnum(),seq)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; lambda 表达式是一个匿名的函数，简单的理解，冒号前面是参数，冒号后面是方法体（返回值）&lt;/span&gt;
&lt;span&gt;lambda&lt;/span&gt; x , y : x + y &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这就是表示有两个参数返回值是参数和的匿名函数呗！&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用指定的函数将序列的前两个元素和二为一，再将结构与第三个元素和二为一，最终处理完序列得到一个结果。&lt;/span&gt;
numbers = [72,42,7,9,23,67,97,245&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; reduce
reduce(&lt;/span&gt;&lt;span&gt;lambda&lt;/span&gt; x,y:x+&lt;span&gt;y,numbers)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当然，就这个案例来说，倒不如使用内置函数 sum 求和。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;好吧，以上就是 Python 中函数相关的问题，至此，我们已经学习了 Python 的数据类型以及数据类型的常用操作，后便是语句，语句中牵扯到一些循环和条件判断语句的使用，而函数可以看成是对语句的简单抽象与封装，而真正的面向对象的思想还在下一节类的相关概念中。&lt;/p&gt;

&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/YJK923/p/9487222.html&quot; target=&quot;_blank&quot;&gt;Python 学习经历分享&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/YJK923/p/9491838.html&quot;&gt;Python 入门之基本数据类型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/YJK923/p/9504318.html&quot; target=&quot;_blank&quot;&gt;Python 中的语句&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Aug 2018 07:52:00 +0000</pubDate>
<dc:creator>YJK923</dc:creator>
<og:description>学了 Python 中的数据类型，语句，接下来就来说一下 Python 中的函数，函数是结构化编程的核心。我们使用函数可以增加程序的可读性。自定义函数时使用关键字def 函数由多条语句组成。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YJK923/p/9534405.html</dc:identifier>
</item>
<item>
<title>Python中print()函数不换行的方法 - Bil369</title>
<link>http://www.cnblogs.com/Bil369/p/9534399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Bil369/p/9534399.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、让print()函数不换行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在Python中，print()函数默认是换行的。但是，在很多情况下，我们需要不换行的输出（比如在算法竞赛中）。那么，在Python中如何做到这一点呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实很简单。只要指定print()函数的end参数为空就可以了。（默认是’\n’）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, end=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;!!!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出为：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1381257/201808/1381257-20180825153258901-136500878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、print()函数浅析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然，print()函数不止有end这个参数，还有其它几个参数。下面我们来看一看这些参数对输出分别起到什么作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先来看一下print()函数的原型：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;/code&gt;(&lt;em&gt;*objects&lt;/em&gt;, &lt;em&gt;sep='  '&lt;/em&gt;, &lt;em&gt;end='\n'&lt;/em&gt;, &lt;em&gt;file=sys.stdout&lt;/em&gt;, &lt;em&gt;flush=False&lt;/em&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;以下摘自官方文档：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Print &lt;em&gt;objects&lt;/em&gt; to the text stream &lt;em&gt;file&lt;/em&gt;, separated by &lt;em&gt;sep&lt;/em&gt; and followed by &lt;em&gt;end&lt;/em&gt;. &lt;em&gt;sep&lt;/em&gt;, &lt;em&gt;end&lt;/em&gt;, &lt;em&gt;file&lt;/em&gt; and &lt;em&gt;flush&lt;/em&gt;, if present, must be given as keyword arguments.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;All non-keyword arguments are converted to strings like &lt;a title=&quot;str&quot; href=&quot;https://docs.python.org/3/library/stdtypes.html#str&quot;&gt;str()&lt;/a&gt; does and written to the stream, separated by &lt;em&gt;sep&lt;/em&gt; and followed by &lt;em&gt;end&lt;/em&gt;. Both &lt;em&gt;sep&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; must be strings; they can also be None, which means to use the default values. If no &lt;em&gt;objects&lt;/em&gt; are given, &lt;a title=&quot;print&quot; href=&quot;https://docs.python.org/3/library/functions.html#print&quot;&gt;print()&lt;/a&gt; will just write &lt;em&gt;end&lt;/em&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;The &lt;em&gt;file&lt;/em&gt; argument must be an object with a write(string) method; if it is not present or None, &lt;a title=&quot;sys.stdout&quot; href=&quot;https://docs.python.org/3/library/sys.html#sys.stdout&quot;&gt;sys.stdout&lt;/a&gt; will be used. Since printed arguments are converted to text strings, &lt;a title=&quot;print&quot; href=&quot;https://docs.python.org/3/library/functions.html#print&quot;&gt;print()&lt;/a&gt; cannot be used with binary mode file objects. For these, use file.write(...) instead.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Whether output is buffered is usually determined by &lt;em&gt;file&lt;/em&gt;, but if the &lt;em&gt;flush&lt;/em&gt; keyword argument is true, the stream is forcibly flushed.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;Changed in version 3.3: &lt;/em&gt;Added the &lt;em&gt;flush&lt;/em&gt; keyword argument.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　也就是说，print()将objects转换成strings输出到流中，用sep分隔，以end结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面通过几个例子，来具体的看一看print()函数各参数的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一个参数objects就不多说了，要是不知道干啥的可以考虑从头学起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二个参数sep，表示objects参数连接时使用的字符，默认是空格。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, sep=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出为：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1381257/201808/1381257-20180825153528121-1713550439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第三个参数end，表示输出完后的结束符，默认是换行。例子前面有了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第四个参数file，表示输出到哪里，默认是sys.stdout。必须是file-like对象，即有write方法，不可以用二进制模式。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;print.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, file=f)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;程序运行结束后，打开文件可以看到：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1381257/201808/1381257-20180825154059507-1678811667.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第五个参数flush，表示是否立即输出到file所指定的对象中。当为True时，立即输出，当为False时，则取决于file对象（一般是不立即输出）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面的例子，如果加个暂停，可以发现，数据没有被立即写入，只有在f.close()后才被写入。如果没有写f.close()，那就在程序运行结束以后写入。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;print.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, file=&lt;span&gt;f)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; s = input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;f.close()? (Y/N)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; s == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     f.close()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;如果flush为True时，则会被立即写入。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;print.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, file=f, flush=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; s = input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;f.close()? (Y/N)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; s == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     f.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;以上就是对Python中print()函数的浅析，鉴于本人的水平有限，有不妥之处，还请指出。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不换行&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, end=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;!!!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;print.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; f1 = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;print1.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, sep=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, file=&lt;span&gt;f)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, file=f1, flush=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; s = input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;f.close()? (Y/N)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; s == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    f.close()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果输入为N，此处暂停观察print.txt中的内容是否为空&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; s = input()
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 25 Aug 2018 07:50:00 +0000</pubDate>
<dc:creator>Bil369</dc:creator>
<og:description>一、让print()函数不换行 在Python中，print()函数默认是换行的。但是，在很多情况下，我们需要不换行的输出（比如在算法竞赛中）。那么，在Python中如何做到这一点呢？ 其实很简单。只</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Bil369/p/9534399.html</dc:identifier>
</item>
<item>
<title>Kubernetes(k8s)集群部署（k8s企业级Docker容器集群管理）系列之部署master/node节点组件（四） - LouieGuo</title>
<link>http://www.cnblogs.com/guolianyu/p/9532047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guolianyu/p/9532047.html</guid>
<description>&lt;hr/&gt;&lt;p&gt; 整体架构目录：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/guolianyu/p/9473676.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Core分布式项目实战-目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;k8s架构目录：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/guolianyu/p/9477028.html&quot; target=&quot;_blank&quot;&gt;Kubernetes(k8s)集群部署（k8s企业级Docker容器集群管理）系列目录&lt;/a&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;p&gt;master 服务器的组件有：kube-apiserver、kube-controller-manager、kube-scheduler&lt;/p&gt;
&lt;p&gt;因此需要下载k8s master，下载地址：https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.9.md ，当然大家可以下载更高版本的。&lt;/p&gt;
&lt;p&gt;这边需要准备这几个文件&lt;/p&gt;
&lt;p&gt;kubectl（用于运行集群命令的管理工具）：具体可参考：http://docs.kubernetes.org.cn/61.html   中文文档。&lt;/p&gt;
&lt;p&gt;kubeconfig.sh(用来生成适用于node节点的配置文件以及证书的)、master服务器的k8s组件&lt;/p&gt;
&lt;h3&gt;第一步：解压缩包 unzip master.zip&lt;/h3&gt;
&lt;p&gt;把里面的kube-apiserver、 kube-controller-manager、 kube-scheduler   复制到 /opt/kubernetes/bin 里面，并且把bin文件夹下面的文件设置为可执行权限，chmod +x /ops/kubernetes/bin/*&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180825152639921-533805735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;第二步：已把各个组件放到对应的目录后，进入我刚才的解压出来的文件夹中，把后缀为.sh的文件设置为可执行权限因为我们要开始启动master组件&lt;/h3&gt;
&lt;p&gt;chmod +x *.sh&lt;/p&gt;
&lt;h3&gt;第三步：&lt;/h3&gt;
&lt;p&gt;把上面说到的 kubectl 管理工具放到 /ops/kubernetes/bin，一样的也设置可执行权限。&lt;/p&gt;
&lt;p&gt;然后把kubeconfig.sh 放到  之前文章介绍中的 /home/ssl  目录下，然后执行以下里面的内容，会生成如下的文件及证书，主要用于node组件&lt;/p&gt;
&lt;p&gt;token.csv、bootstrap.kubeconfig、kube-proxy-key.pem、kube-proxy.kubeconfig kube-proxy.pem&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180825152722886-1316114385.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;第四步：把生成的token.csv 文件复制到 /opt/kubernetes/cfg/  ，因为在运行 master组件sh文件需要用到。&lt;/h3&gt;
&lt;h3&gt;第五步：终于可以了运行啦&lt;/h3&gt;
&lt;p&gt;./apiserver.sh 192.168.161.151 https://192.168.161.151:2379,https://192.168.161.152:2379,https://192.168.161.153:2379&lt;/p&gt;
&lt;p&gt;./scheduler.sh 127.0.0.1&lt;/p&gt;
&lt;p&gt;./controller-manager.sh 127.0.0.1&lt;/p&gt;

&lt;p&gt;然后运行以查看一下运行状态   ps -ef |grep kube ,可以看到 都在运行，至此master组件已经全部运行了。&lt;/p&gt;
&lt;p&gt;运行以下查看集群etcd的健康状态啦 kubectl get cs&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180825152309213-1783605019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;&lt;h3&gt; 第一步：把上面的ssl中创建的文件&lt;/h3&gt;
&lt;p&gt;bootstrap.kubeconfig、&lt;em id=&quot;__mceDel&quot;&gt;kube-proxy.kubeconfig &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;copy 到node节点上&lt;/p&gt;
&lt;p&gt;scp -r *kubeconfig root@192.168.161.152:/opt/kubernetes/cfg&lt;br/&gt;scp -r *kubeconfig root@192.168.161.153:/opt/kubernetes/cfg&lt;/p&gt;

&lt;h3&gt;第二步：在下载的k8s中找到node服务器需要的k8s文件组件复制到服务器上。&lt;/h3&gt;
&lt;p&gt;然后进入到 文件夹中，然后把后缀为 sh 的文件添加可执行权限 chmod +x  *sh&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180825151141642-1179915184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把kubelet、kube-proxy都加上可执行权限，然后把这两个文件copy到/ops/kubernetes/bin 中&lt;/p&gt;
&lt;p&gt;cp kubelet kube-proxy /opt/kubernetes/bin/&lt;br/&gt;chmod +x /opt/kubernetes/bin/*&lt;/p&gt;

&lt;h3&gt;第三步：运行kubelet.sh  kube-proxy.sh（节点node2也按照相同的部署）&lt;/h3&gt;
&lt;p&gt;./kubelet.sh 192.168.161.152 10.10.10.2&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;./proxy.sh 192.168.161.152&lt;/p&gt;

&lt;h3&gt;第四步：运行kubelet 和kube-proxy &lt;/h3&gt;
&lt;p&gt;发现运行报错，好吧，发现没有权限&lt;/p&gt;
&lt;p&gt;解决方案：需要在 master节点里面为 请求的用户即bootstrap.kubeconfig  里面的 user 用户创建角色(kubelet-bootstrap)&lt;/p&gt;
&lt;p&gt;切换到master 上，执行以下命令即可。&lt;/p&gt;
&lt;p&gt;kubectl create clusterrolebinding kubelet-bootstrap --clusterrole=system:node-bootstrapper --user=kubelet-bootstrap&lt;/p&gt;

&lt;h3&gt;第五步：在node服务器上启动kubelet，在master 上面即可以查看 csr 证书&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180825152355933-682417496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;证书生成后，就需允许 证书&lt;/p&gt;

&lt;p&gt;kubectl certificate approve 证书名（即上面截图的name值）&lt;/p&gt;
&lt;p&gt;然后就可以查看 集群状态了&lt;br/&gt;kubectl get node&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180825152441432-1218955786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，k8s集群部署结束。&lt;/p&gt;

&lt;p&gt;接下来就要测试一下部署webUI啦。&lt;/p&gt;
&lt;p&gt;看下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180825152607692-1422784913.png&quot; alt=&quot;&quot; width=&quot;1100&quot; height=&quot;567&quot;/&gt;&lt;/p&gt;


&lt;p&gt;需要三个文件&lt;/p&gt;
&lt;p&gt;dashboard-rbac.yaml ：rbac 权限&lt;br/&gt;dashboard-deployment.yaml ：部署pod&lt;br/&gt;dashboard-service.yaml ：发布服务&lt;/p&gt;
&lt;p&gt;分别执行：&lt;/p&gt;
&lt;p&gt;kubectl create -f dashboard-rbac.yaml&lt;br/&gt;kubectl create -f dashboard-deployment.yaml&lt;br/&gt;kubectl create -f dashboard-service.yaml&lt;/p&gt;
&lt;p&gt;执行完后，我们来看一下pod，发现dashboard已经部署成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180825153124197-1439293694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们看一下发布服务的端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180825153232226-1094669958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 大公告成。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/651008/201808/651008-20180825153240427-480686809.png&quot; alt=&quot;&quot; width=&quot;1159&quot; height=&quot;645&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;github：&lt;a href=&quot;https://github.com/LouieGuo&quot; target=&quot;_blank&quot;&gt;fork me&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;asp.net Core 交流群：&lt;span&gt;787464275&lt;/span&gt; 欢迎加群交流&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;如果您认为这篇文章还不错或者有所收获，您可以点击右下角的【推荐】按钮精神支持，因为这种支持是我继续写作，分享的最大动力！&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8.7230769230769&quot;&gt;

&lt;p&gt;&lt;strong&gt;声明：原创博客请在转载时保留原文链接或者在文章开头加上本人博客地址，如发现错误，欢迎批评指正。凡是转载于本人的文章，不能设置打赏功能，如有特殊需求请与本人联系！&lt;/strong&gt; &lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 25 Aug 2018 07:36:00 +0000</pubDate>
<dc:creator>LouieGuo</dc:creator>
<og:description>0、前言 整体架构目录：ASP.NET Core分布式项目实战-目录 k8s架构目录：Kubernetes(k8s)集群部署（k8s企业级Docker容器集群管理）系列目录 1、部署master组件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guolianyu/p/9532047.html</dc:identifier>
</item>
<item>
<title>scala的多种集合的使用(6)之映射Map的操作方法 - IoT慧智星</title>
<link>http://www.cnblogs.com/zhaohadoopone/p/9534242.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaohadoopone/p/9534242.html</guid>
<description>&lt;h2&gt;&lt;span&gt;1.创建映射&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)创建不可变的映射&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map(1 -&amp;gt; &quot;a&quot;,2 -&amp;gt; &quot;b&quot;)
status: scala.collection.immutable.Map[Int,String] = Map(1 -&amp;gt; a, 2 -&amp;gt; b)

scala&amp;gt; val status = Map((1,&quot;a&quot;),(2,&quot;b&quot;))
status: scala.collection.immutable.Map[Int,String] = Map(1 -&amp;gt; a, 2 -&amp;gt; b)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)创建可变的映射，要么用导入的方式将其带入作用域中，要么就在创建实例时指定scala.collection.mutable.Map类的完整路径。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var status = collection.mutable.Map((1,&quot;a&quot;),(2,&quot;b&quot;))
status: scala.collection.mutable.Map[Int,String] = Map(2 -&amp;gt; b, 1 -&amp;gt; a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3)在创建的时候创建一空可变的Map，之后在添加元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var status = collection.mutable.Map[Int,String]()
status: scala.collection.mutable.Map[Int,String] = Map()

scala&amp;gt; status += ((1,&quot;a&quot;))
res38: scala.collection.mutable.Map[Int,String] = Map(1 -&amp;gt; a)

scala&amp;gt; status += ((3,&quot;c&quot;),(2,&quot;b&quot;))
res39: scala.collection.mutable.Map[Int,String] = Map(2 -&amp;gt; b, 1 -&amp;gt; a, 3 -&amp;gt; c)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;2.Map使用的场景&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)想要返回元素按照键有序的映射，请使用SortedMap。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;63&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; import scala.collection.SortedMap
import scala.collection.SortedMap

scala&amp;gt; val grades = SortedMap((&quot;kim&quot;,90),(&quot;al&quot;,86),(&quot;mes&quot;,88),(&quot;ema&quot;,78),(&quot;han&quot;,93))
grades: scala.collection.SortedMap[String,Int] = Map(al -&amp;gt; 86, ema -&amp;gt; 78, han -&amp;gt;93, kim -&amp;gt; 90, mes -&amp;gt; 88)

scala&amp;gt; val grades = SortedMap((1,90),(3,86),(2,88),(5,78),(4,93))
grades: scala.collection.SortedMap[Int,Int] = Map(1 -&amp;gt; 90, 2 -&amp;gt; 88, 3 -&amp;gt; 86, 4 -&amp;gt; 93, 5 -&amp;gt; 78)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)按插入时的顺序返回元素，只有可变的LinkedHashMap。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; import scala.collection.mutable.LinkedHashMap
import scala.collection.mutable.LinkedHashMap

scala&amp;gt; var status = LinkedHashMap((5,&quot;apple&quot;))
status: scala.collection.mutable.LinkedHashMap[Int,String] = Map(5 -&amp;gt; apple)

scala&amp;gt; status += ((3,&quot;orange&quot;))
res40: scala.collection.mutable.LinkedHashMap[Int,String] = Map(5 -&amp;gt; apple, 3 -&amp;gt; orange)

scala&amp;gt; status += ((6,&quot;banana&quot;))
res41: scala.collection.mutable.LinkedHashMap[Int,String] = Map(5 -&amp;gt; apple, 3 -&amp;gt;orange, 6 -&amp;gt; banana)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3)按插入时的相反顺序返回元素，可以是可变的或者不可变的ListMap。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; import scala.collection.mutable.ListMap
import scala.collection.mutable.ListMap

scala&amp;gt; var status = ListMap((1,&quot;a&quot;))
status: scala.collection.mutable.ListMap[Int,String] = Map(1 -&amp;gt; a)

scala&amp;gt; status += ((1,&quot;a&quot;))
res43: scala.collection.mutable.ListMap[Int,String] = Map(1 -&amp;gt; a)

scala&amp;gt; status += ((2,&quot;b&quot;))
res44: scala.collection.mutable.ListMap[Int,String] = Map(2 -&amp;gt; b, 1 -&amp;gt; a)

scala&amp;gt; status += ((3,&quot;c&quot;))
res45: scala.collection.mutable.ListMap[Int,String] = Map(3 -&amp;gt; c, 1 -&amp;gt; a, 2 -&amp;gt; b)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;3.可变映射的添加、更新和删除元素&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)通过给键指定值的方式为可变映射添加元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var status = scala.collection.mutable.Map[String,String]()
status: scala.collection.mutable.Map[String,String] = Map()

scala&amp;gt; status(&quot;a1&quot;) = &quot;a1a&quot;

scala&amp;gt; status
res47: scala.collection.mutable.Map[String,String] = Map(a1 -&amp;gt; a1a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)通过+=方法添加一个或者多个元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var status = scala.collection.mutable.Map[String,String]()
status: scala.collection.mutable.Map[String,String] = Map()

scala&amp;gt; status += ((&quot;a1&quot;,&quot;a1a&quot;))
res50: status.type = Map(a1 -&amp;gt; a1a)

scala&amp;gt; status
res51: scala.collection.mutable.Map[String,String] = Map(a1 -&amp;gt; a1a)

scala&amp;gt; status += ((&quot;a1&quot;,&quot;a1a&quot;),(&quot;a2&quot;,&quot;a2a&quot;))
res52: status.type = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a)

scala&amp;gt; status
res53: scala.collection.mutable.Map[String,String] = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3)用++=从另一个集合添加多个元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var status = scala.collection.mutable.Map[String,String]()
status: scala.collection.mutable.Map[String,String] = Map()

scala&amp;gt; status ++= List((&quot;a1&quot;,&quot;a1a&quot;),(&quot;a2&quot;,&quot;a2a&quot;))
res55: status.type = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4)用-=的方法通过指定元素的键从映射中删除一个或者多个元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; status ++= List((&quot;a1&quot;,&quot;a1a&quot;),(&quot;a2&quot;,&quot;a2a&quot;))
res56: status.type = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a)

scala&amp;gt; status -= &quot;a1&quot;
res57: status.type = Map(a2 -&amp;gt; a2a)

scala&amp;gt; status
res58: scala.collection.mutable.Map[String,String] = Map(a2 -&amp;gt; a2a)

scala&amp;gt; status -= (&quot;a1&quot;,&quot;a2&quot;)
res60: status.type = Map()

scala&amp;gt; status
res61: scala.collection.mutable.Map[String,String] = Map()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5)用--=删除集合里的指定的元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var status = scala.collection.mutable.Map[String,String]()
status: scala.collection.mutable.Map[String,String] = Map()

scala&amp;gt; status ++= List((&quot;a1&quot;,&quot;a1a&quot;),(&quot;a2&quot;,&quot;a2a&quot;))
res67: status.type = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a)

scala&amp;gt; status --= List(&quot;a1&quot;,&quot;a2&quot;)
res68: status.type = Map()

scala&amp;gt; status
res69: scala.collection.mutable.Map[String,String] = Map()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;6)通过赋值值给元素的键更新元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var status = scala.collection.mutable.Map[String,String]()
status: scala.collection.mutable.Map[String,String] = Map()

scala&amp;gt; status ++= List((&quot;a1&quot;,&quot;a1a&quot;),(&quot;a2&quot;,&quot;a2a&quot;))
res72: status.type = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a)

scala&amp;gt; status(&quot;a1&quot;) = &quot;hello world&quot;

scala&amp;gt; status
res74: scala.collection.mutable.Map[String,String] = Map(a1 -&amp;gt; hello world, a2 -&amp;gt; a2a)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;4.不可变映射的添加、更新和删除元素&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)用+个方法添加一个或者多个元素，在这个过程中将结果赋给一个新的变量。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val a = Map((&quot;a1&quot;,&quot;a1a&quot;))
a: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; a1a)

scala&amp;gt; val b = a + ((&quot;a2&quot;,&quot;a2a&quot;))
b: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a)

scala&amp;gt; val c = b + ((&quot;a3&quot;,&quot;a31&quot;),(&quot;a4&quot;,&quot;a4a&quot;))
c: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a, a3 -&amp;gt; a31, a4 -&amp;gt; a4a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)更新一个不可变映射的键值对，需要用+方法对键/值重新赋值，新值替换旧值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val a = Map((&quot;a1&quot;,&quot;a1a&quot;))
a: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; a1a)

scala&amp;gt; val b = a + ((&quot;a2&quot;,&quot;a2a&quot;))
b: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a)

scala&amp;gt; val c = b + ((&quot;a1&quot;,&quot;hello world&quot;))
c: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; hello world, a2 -&amp;gt; a2a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3)使用-方法删除一个或者多个元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val a = Map((&quot;a1&quot;,&quot;a1a&quot;))
a: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; a1a)

scala&amp;gt; val b = a + ((&quot;a2&quot;,&quot;a2a&quot;),(&quot;a3&quot;,&quot;a3a&quot;),(&quot;a4&quot;,&quot;a4a&quot;))
b: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a, a3
-&amp;gt; a3a, a4 -&amp;gt; a4a)

scala&amp;gt; val c = b - &quot;a1&quot; - &quot;a2&quot;
c: scala.collection.immutable.Map[String,String] = Map(a3 -&amp;gt; a3a, a4 -&amp;gt; a4a)

scala&amp;gt; val d = c - &quot;a4&quot;
d: scala.collection.immutable.Map[String,String] = Map(a3 -&amp;gt; a3a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当一个不可变的变量声明为var时，它仍然是一个不可变的映射，不能给映射中的元素重新赋值。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;5.映射值的访问&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)访问保存在映射中单独的值，如果键不存在，会抛出异常。为了避免这个问题，可以在创建映射时使用withDefaultValue的方法。该方法会创建一个默认值，如果键没有找到，映射会返回这个值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((1,&quot;a&quot;),(2,&quot;b&quot;),(3,&quot;c&quot;)).withDefaultValue(&quot;Not Found&quot;)
status: scala.collection.immutable.Map[Int,String] = Map(1 -&amp;gt; a, 2 -&amp;gt; b, 3 -&amp;gt; c)

scala&amp;gt; status(4)
res5: String = Not Found

scala&amp;gt; status(3)
res6: String = c
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)寻找键时可以使用getOrElse方法，当指定的键找不到时，会返回默认值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((1,&quot;a&quot;),(2,&quot;b&quot;),(3,&quot;c&quot;))
status: scala.collection.immutable.Map[Int,String] = Map(1 -&amp;gt; a, 2 -&amp;gt; b, 3 -&amp;gt; c)

scala&amp;gt; val s = status.getOrElse(6,&quot;Not such value&quot;)
s: String = Not such value
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3)可以使用get方法返回Option对象。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((1,&quot;a&quot;),(2,&quot;b&quot;),(3,&quot;c&quot;))
status: scala.collection.immutable.Map[Int,String] = Map(1 -&amp;gt; a, 2 -&amp;gt; b, 3 -&amp;gt; c)

scala&amp;gt; val s = status.get(5)
s: Option[String] = None

scala&amp;gt; val s = status.get(2)
s: Option[String] = Some(b)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;6.映射的遍历&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)for循环遍历所有的映射元素。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((1,&quot;a&quot;),(2,&quot;b&quot;),(3,&quot;c&quot;),(4,&quot;d&quot;))
status: scala.collection.immutable.Map[Int,String] = Map(1 -&amp;gt; a, 2 -&amp;gt; b, 3 -&amp;gt; c, 4 -&amp;gt; d)

scala&amp;gt; for((k,v) &amp;lt;- status) println(s&quot;key: $k, value: $v&quot;)
key: 1, value: a
key: 2, value: b
key: 3, value: c
key: 4, value: d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)匹配表达式配合foreach方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((1,&quot;a&quot;),(2,&quot;b&quot;),(3,&quot;c&quot;),(4,&quot;d&quot;))
status: scala.collection.immutable.Map[Int,String] = Map(1 -&amp;gt; a, 2 -&amp;gt; b, 3 -&amp;gt; c, 4 -&amp;gt; d)

scala&amp;gt; status.foreach{
         | case(k,v) =&amp;gt; println(s&quot;key: $k,value: $v&quot;)
         | }
key: 1,value: a
key: 2,value: b
key: 3,value: c
key: 4,value: d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3)使用Tuple语法访问键/值字段。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((1,&quot;a&quot;),(2,&quot;b&quot;),(3,&quot;c&quot;),(4,&quot;d&quot;))
status: scala.collection.immutable.Map[Int,String] = Map(1 -&amp;gt; a, 2 -&amp;gt; b, 3 -&amp;gt; c, 4 -&amp;gt; d)

scala&amp;gt; status.foreach(x =&amp;gt; println(s&quot;key: ${x._1},value: ${x._2}&quot;))
key: 1,value: a
key: 2,value: b
key: 3,value: c
key: 4,value: d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4)如果想要映射中所有的键，keys方法返回Iterable。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((1,&quot;a&quot;),(2,&quot;b&quot;),(3,&quot;c&quot;),(4,&quot;d&quot;))
status: scala.collection.immutable.Map[Int,String] = Map(1 -&amp;gt; a, 2 -&amp;gt; b, 3 -&amp;gt; c, 4 -&amp;gt; d)

scala&amp;gt; status.keys.foreach((key) =&amp;gt; println(key))
1
2
3
4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5)如果想要映射中所有的value的值，用values方法可以遍历映射中所有的值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((1,&quot;a&quot;),(2,&quot;b&quot;),(3,&quot;c&quot;),(4,&quot;d&quot;))
status: scala.collection.immutable.Map[Int,String] = Map(1 -&amp;gt; a, 2 -&amp;gt; b, 3 -&amp;gt; c, 4 -&amp;gt; d)

scala&amp;gt; status.values.foreach((value) =&amp;gt; println(value))
a
b
c
d
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;7.操作映射的值&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)如果要遍历映射并对每个值进行操作，mapValues是个不错的选择。它可以在每个映射值上执行一个函数，然后返回修改后的映射。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; var x = collection.mutable.Map((1,&quot;a&quot;),(2,&quot;b&quot;))
x: scala.collection.mutable.Map[Int,String] = Map(2 -&amp;gt; b, 1 -&amp;gt; a)

scala&amp;gt; val y = x.mapValues(_.toUpperCase)
y: scala.collection.Map[Int,String] = Map(2 -&amp;gt; B, 1 -&amp;gt; A)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)transform方法可以同时使用键/值实现一个变换方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val map = Map((1,10),(2,20),(3,30))
map: scala.collection.immutable.Map[Int,Int] = Map(1 -&amp;gt; 10, 2 -&amp;gt; 20, 3 -&amp;gt; 30)

scala&amp;gt; val newMap = map.transform((k,v) =&amp;gt; k + v)
newMap: scala.collection.immutable.Map[Int,Int] = Map(1 -&amp;gt; 11, 2 -&amp;gt; 22, 3 -&amp;gt; 33)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;8.从映射中获取所有的键和值&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)用keySet的方法将以集合的方式获取所有的键。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((&quot;a1&quot;,&quot;a1a&quot;),(&quot;a2&quot;,&quot;a2a&quot;),(&quot;a3&quot;,&quot;a3a&quot;))
status: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a, a3 -&amp;gt; a3a)

scala&amp;gt; status.keySet
res14: scala.collection.immutable.Set[String] = Set(a1, a2, a3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)用keys方法获得一个Iterable。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; status.keys
res16: Iterable[String] = Set(a1, a2, a3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3)用keysIterator方法获取所有作为迭代器的键。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; status.keysIterator
res17: Iterator[String] = non-empty iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4)使用values方法可以获取映射中所有的值，并将结果转化为Iterable对象。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; status.values
res18: Iterable[String] = MapLike(a1a, a2a, a3a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5)使用valuesIterator方法，返回Iterator对象。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; status.valuesIterator
res19: Iterator[String] = non-empty iterator
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;keysIterator和valuesIterator方法都会从映射数据返回一个迭代器。这些方法不会创建一个新的集合，仅仅是提供遍历已存在的迭代器。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;9.&lt;span&gt;反转键值&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;可以用for推导反转映射的键值，然后将结果赋给一个新的变量。但是映射中，key是不重复的，value是可以重复的，但是在反转时可能会丢掉数据。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((&quot;a1&quot;,&quot;a1a&quot;),(&quot;a2&quot;,&quot;a2a&quot;),(&quot;a3&quot;,&quot;a3a&quot;))
status: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a, a3 -&amp;gt; a3a)

scala&amp;gt; val newMap = for((k,v) &amp;lt;- status) yield (v,k)
newMap: scala.collection.immutable.Map[String,String] = Map(a1a -&amp;gt; a1, a2a -&amp;gt; a2, a3a -&amp;gt; a3)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;10.测试映射中键/值的存在&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)用contains方法测试映射中是否包含键。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((&quot;a1&quot;,&quot;a1a&quot;),(&quot;a2&quot;,&quot;a2a&quot;),(&quot;a3&quot;,&quot;a3a&quot;))
status: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a, a3 -&amp;gt; a3a)

scala&amp;gt; if (status.contains(&quot;a1&quot;)) println(&quot;found a1&quot;) else println(&quot;not found&quot;)
found a1

scala&amp;gt; if (status.contains(&quot;a5&quot;)) println(&quot;found a5&quot;) else println(&quot;not found&quot;)
not found
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)使用valuesIterator方法搜索值，结合exists和contains。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val status = Map((&quot;a1&quot;,&quot;a1a&quot;),(&quot;a2&quot;,&quot;a2a&quot;),(&quot;a3&quot;,&quot;a3a&quot;))
status: scala.collection.immutable.Map[String,String] = Map(a1 -&amp;gt; a1a, a2 -&amp;gt; a2a, a3 -&amp;gt; a3a)

scala&amp;gt; status.valuesIterator.exists(_.contains(&quot;a2a&quot;))
res22: Boolean = true

scala&amp;gt; status.valuesIterator.exists(_.contains(&quot;a2a2&quot;))
res23: Boolean = false
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;11.根据键或者值对映射排序&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)可以用sortBy方法对值(_2)/键(_1)从低到高进对映射进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val grade = Map((1,98),(2,89),(3,88),(4,93),(5,95))
grade: scala.collection.immutable.Map[Int,Int] = Map(5 -&amp;gt; 95, 1 -&amp;gt; 98, 2 -&amp;gt; 89, 3 -&amp;gt; 88, 4 -&amp;gt; 93)

scala&amp;gt; import scala.collection.immutable.ListMap
import scala.collection.immutable.ListMap

scala&amp;gt; ListMap(grade.toSeq.sortBy(_._2):_*)
res25: scala.collection.immutable.ListMap[Int,Int] = Map(3 -&amp;gt; 88, 2 -&amp;gt; 89, 4 -&amp;gt; 93, 5 -&amp;gt; 95, 1 -&amp;gt; 98)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)可以用sortWith方法对值(_2)/键(_1)按照升序或者降序对值进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
//按照值升序:
scala&amp;gt; ListMap(grade.toSeq.sortWith(_._2 &amp;lt; _._2):_*)
res28: scala.collection.immutable.ListMap[Int,Int] = Map(3 -&amp;gt; 88, 2 -&amp;gt; 89, 4 -&amp;gt;93, 5 -&amp;gt; 95, 1 -&amp;gt; 98)
//按照值降序:
scala&amp;gt; ListMap(grade.toSeq.sortWith(_._2 &amp;gt; _._2):_*)
res29: scala.collection.immutable.ListMap[Int,Int] = Map(1 -&amp;gt; 98, 5 -&amp;gt; 95, 4 -&amp;gt;93, 2 -&amp;gt; 89, 3 -&amp;gt; 88)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;关于_*:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;它的作用是将数据转换，然后将其作为多个参数传给ListMap。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;12.映射中键值的最值&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1)对键进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val grade = Map((1,98),(2,89),(3,88),(4,93),(5,95))
grade: scala.collection.immutable.Map[Int,Int] = Map(5 -&amp;gt; 95, 1 -&amp;gt; 98, 2 -3 -&amp;gt; 88, 4 -&amp;gt; 93)

scala&amp;gt; grade.max
res31: (Int, Int) = (5,95)

scala&amp;gt; grade.keysIterator.max
res32: Int = 5

scala&amp;gt; grade.keysIterator.reduceLeft((x,y) =&amp;gt; if(x &amp;gt; y) x else y)
res33: Int = 5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2)对值进行排序 。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:java;collapse:true;;gutter:true;&quot;&gt;
scala&amp;gt; val grade = Map((1,98),(2,89),(3,88),(4,93),(5,95))
grade: scala.collection.immutable.Map[Int,Int] = Map(5 -&amp;gt; 95, 1 -&amp;gt; 98, 2 -&amp;gt; 89,3 -&amp;gt; 88, 4 -&amp;gt; 93)

scala&amp;gt; grade.valuesIterator.max
res40: Int = 98

scala&amp;gt; grade.valuesIterator.reduceLeft((x,y) =&amp;gt; if(x &amp;gt; y) x else y)
res41: Int = 98

scala&amp;gt; grade.valuesIterator.reduceLeft(_ max _)
res42: Int = 98
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 25 Aug 2018 07:33:00 +0000</pubDate>
<dc:creator>IoT慧智星</dc:creator>
<og:description>1.创建映射 1)创建不可变的映射 2)创建可变的映射，要么用导入的方式将其带入作用域中，要么就在创建实例时指定scala.collection.mutable.Map类的完整路径。 3)在创建的时候</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaohadoopone/p/9534242.html</dc:identifier>
</item>
<item>
<title>数据分析 第六篇：聚类的评估（簇数确定和轮廓系数）和可视化 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/4578692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/4578692.html</guid>
<description>&lt;p&gt;在实际的聚类应用中，通常使用k-均值和k-中心化算法来进行聚类分析，这两种算法都需要输入簇数，为了保证聚类的质量，应该首先确定最佳的簇数，并使用轮廓系数来评估聚类的结果。&lt;/p&gt;
&lt;h2&gt;一，k-均值法确定最佳的簇数&lt;/h2&gt;
&lt;p&gt;通常情况下，使用肘方法（elbow）以确定聚类的最佳的簇数，肘方法之所以是有效的，是基于以下观察：增加簇数有助于降低每个簇的簇内方差之和，给定k&amp;gt;0，计算簇内方差和var(k)，绘制var关于k的曲线，曲线的第一个（或最显著的）拐点暗示正确的簇数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，使用sjc.elbow()函数计算肘值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sjPlot包中sjc.elbow()函数实现了肘方法，用于计算&lt;strong&gt;k-均值&lt;/strong&gt;聚类分析的肘值，以确定最佳的簇数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
library(sjPlot)
sjc.elbow(data, steps = 15, show.diff = FALSE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;steps：最大的肘值的数量&lt;/li&gt;
&lt;li&gt;show.diff：默认值是FALSE，额外绘制一个图，连接每个肘值，用于显示各个肘值之间的差异，改图有助于识别“肘部”，暗示“正确的”簇数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;sjc.elbow()函数用于绘制k-均值聚类分析的肘值，该函数在指定的数据框计算k-均值聚类分析，产生两个图形：一个图形具有不同的肘值，另一个图形是连接y轴上的每个“步”，即在相邻的肘值之间绘制连线，第二个图中曲线的拐点可能暗示“正确的”簇数。&lt;/p&gt;
&lt;p&gt;绘制k均值聚类分析的肘部值。 该函数计算所提供的数据帧上的k均值聚类分析，并产生两个图：一个具有不同的肘值，另一个图绘制在y轴上的每个“步”（即在肘值之间）之间的差异。 第二个图的增加可能表明肘部标准。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
library(effects)
library(sjPlot)
library(ggplot2)

sjc.elbow(data,show.diff = FALSE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从下面的肘值图中，可以看出曲线的拐点大致在5附近：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201808/628084-20180824150304194-159551025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，使用NbClust()函数来验证肘值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上面肘值图中，可以看到曲线的拐点是3，还可以使用NbClust包种的NbClust()函数，默认情况下，该函数提供了26个不同的指标来帮助确定簇的最终数目。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
NbClust(data = NULL, diss = NULL, distance = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;euclidean&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, min.nc = &lt;span&gt;2&lt;/span&gt;, max.nc = &lt;span&gt;15&lt;/span&gt;, method = NULL, index = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;all&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, alphaBeale = &lt;span&gt;0.1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;diss：相异性矩阵（dissimilarity matrix），默认值是NULL，如果diss参数不为NULL，那么忽略distance参数。&lt;/li&gt;
&lt;li&gt;distance：用于计算相异性矩阵的距离度量，有效值是： &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;, &quot;minkowski&quot; 和&quot;NULL&quot;。如果distance不是NULL，diss（相异性矩阵）参数必须为NULL。&lt;/li&gt;
&lt;li&gt;min.nc：最小的簇数&lt;/li&gt;
&lt;li&gt;max.nc：最大的簇数&lt;/li&gt;
&lt;li&gt;method：用于聚类分析的方法，有效值是：&quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot;, &quot;centroid&quot;, &quot;kmeans&quot;&lt;/li&gt;
&lt;li&gt;index：用于计算的指标，NbClust()函数提供了30个指数，默认值是&quot;all&quot;，是指除GAP、Gamma、Gplus 和 Tau之外的26个指标。&lt;/li&gt;
&lt;li&gt;alphaBeale：Beale指数的显著性值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;利用NbClust()函数来确定k-均值聚类的最佳簇数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
library(NbClust)

nc &amp;lt;- NbClust(data,min.nc = 2,max.nc = 15,method = &quot;kmeans&quot;)
barplot(table(nc$Best.nc[1,]),xlab=&quot;Number of Clusters&quot;,ylab=&quot;Number of Criteria&quot;,main=&quot;number of Clusters Chosen by 26 Criteria&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从条形图种，可以看到支持簇数为3的指标（Criteria）的数量是最多的，因此，基本上可以确定，k-均值聚类的簇数目是3。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201808/628084-20180823115334471-153382852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二，k-中心化确定最佳簇数&lt;/h2&gt;
&lt;p&gt;k-中心化聚类有两种实现方法，PAM和CLARA，PAM适合在小型数据集上运行，CLARA算法基于抽样，不考虑整个数据集，而是使用数据集的一个随机样本，然后使用PAM方法计算样本的最佳中心点。&lt;/p&gt;
&lt;p&gt;通过fpc包中的pamk()函数得到最佳簇数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
pamk(data,krange=&lt;span&gt;2&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;,criterion=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;asw&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, usepam=&lt;span&gt;TRUE,
     scaling&lt;/span&gt;=FALSE, alpha=&lt;span&gt;0.001&lt;/span&gt;, diss=inherits(data, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dist&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
     critout&lt;/span&gt;=FALSE, ns=&lt;span&gt;10&lt;/span&gt;, seed=NULL, ...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;krange：整数向量，用于表示簇的数量&lt;/li&gt;
&lt;li&gt;criterion：有效值是：&quot;asw&quot;（默认值）、 &quot;multiasw&quot; 和 &quot;ch&quot;&lt;/li&gt;
&lt;li&gt;usepam：逻辑值，如果设置为TRUE，那么使用pam算法，如果为FALSE，那么使用clara算法。&lt;/li&gt;
&lt;li&gt;scaling：逻辑值，是否对数据进行缩放（标准化），如果设置为FALSE，那么不对data参数做任何缩放；如果设置为TRUE，那么对data参数通过把（中间）变量除以它们的均方根来完成缩放。&lt;/li&gt;
&lt;li&gt;diss：逻辑值，如果设置为TRUE，表示data参数是相异性矩阵；如果设置为FALSE，那么data参数是观测矩阵。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用pamk()函数获得PAM或CLARA聚类的最佳簇数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(fpc)
pamk.best &lt;/span&gt;&amp;lt;-&lt;span&gt; pamk(dataset)
pamk.best$nc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过cluster包中的clusplot()函数来查看聚类的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(cluster)
clusplot(pam(dataset, pamk.best$nc))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三，评估聚类的质量（轮廓系数）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用数据集中对象之间的相似性度量来评估聚类的质量，&lt;strong&gt;轮廓系数&lt;/strong&gt;（silhouette coefficient）就是这种相似性度量，是簇的密集与分散程度的评价指标。轮廓系数的值在-1和1之间，该值越接近于1，簇越紧凑，聚类越好。当轮廓系数接近1时，簇内紧凑，并远离其他簇。&lt;/p&gt;
&lt;p&gt;如果轮廓系数sil 接近1，则说明样本聚类合理；如果轮廓系数sil 接近-1，则说明样本i更应该分类到另外的簇；如果轮廓系数sil 近似为0，则说明样本i在两个簇的边界上。所有样本的轮廓系数 sil的均值称为聚类结果的轮廓系数，是该聚类是否合理、有效的度量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，fpc包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包fpc中实现了计算聚类后的一些评价指标，其中就包括了轮廓系数：avg.silwidth（平均的轮廓宽度）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
library(fpc)
result &amp;lt;- kmeans(data,k)
stats &amp;lt;- cluster.stats(dist(data)^2, result$cluster)
sli &amp;lt;- stats$avg.silwidth
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，silhouette()函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包cluster中计算轮廓系数的函数silhouette()，返回聚类的平均轮廓宽度：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
silhouette(x, dist, dmatrix, ...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x：整数向量，是聚类算法的结果&lt;/li&gt;
&lt;li&gt;dist：相异性矩阵（是dist()函数计算的结果），如果dist参数不指定，那么dmatrix参数必须指定；&lt;/li&gt;
&lt;li&gt;dmatrix：对称性的相异性矩阵，用于代替dist参数，比dist参数更有效率&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用silhouette()计算轮廓系数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library (cluster)
library (vegan)

#pam
dis &lt;/span&gt;&amp;lt;-&lt;span&gt; vegdist(data)
res &lt;/span&gt;&amp;lt;- pam(dis,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;) 
sil &lt;/span&gt;&amp;lt;-&lt;span&gt; silhouette (res$clustering,dis)

#kmeans
dis &lt;/span&gt;&amp;lt;- dist(data)^&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
res &lt;/span&gt;&amp;lt;- kmeans(data,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
sil &lt;/span&gt;&amp;lt;- silhouette (res$cluster, dis)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四，聚类的可视化&lt;/h2&gt;
&lt;p&gt;聚类的结果，可以试用ggplot2来可视化，还可以使用的一些聚类包中特有的函数来实现：factoextra包，sjPlot包和cluster包&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，cluster包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;clusplot()函数&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2，sjPlot包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sjc.qclus()函数&lt;/p&gt;

&lt;h3&gt;3，factoextra包&lt;/h3&gt;
&lt;p&gt;该包中的两个函数十分有用，一个用于确定最佳的簇数，一个用于可视化聚类的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1），确定最佳的簇数fviz_nbclust()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数fviz_nbclust()，用于划分聚类分析中，使用轮廓系数，WSS（簇内平方误差和）确定和可视化最佳的簇数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
fviz_nbclust(x, FUNcluster = NULL, method = c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;silhouette&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;), diss = NULL, k.max = &lt;span&gt;10&lt;/span&gt;, ...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FUNcluster：用于聚类的函数，可用的值是： kmeans, cluster::pam, cluster::clara, cluster::fanny, hcut等&lt;/li&gt;
&lt;li&gt;method：用于评估最佳簇数的指标&lt;/li&gt;
&lt;li&gt;diss：相异性矩阵，由dist()函数产生的对象，如果设置为NULL，那么表示使用 dist(data, method=&quot;euclidean&quot;) 计算data参数，得到相异性矩阵；&lt;/li&gt;
&lt;li&gt;k.max：最大的簇数量，至少是2&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 例如，使用kmenas进行聚类分析，使用平均轮廓宽度来评估聚类的簇数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(factoextra)
fviz_nbclust(dataset, kmeans, method &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;silhouette&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（2），可视化聚类的结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fviz_cluster()函数用于可是化聚类的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
fviz_cluster(&lt;span&gt;object&lt;/span&gt;, data = NULL, choose.vars = NULL, stand =&lt;span&gt; TRUE,
  axes &lt;/span&gt;= c(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), geom = c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;point&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), repel =&lt;span&gt; FALSE,
  show.clust.cent &lt;/span&gt;= TRUE, ellipse = TRUE, ellipse.type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;convex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
  ellipse.level &lt;/span&gt;= &lt;span&gt;0.95&lt;/span&gt;, ellipse.alpha = &lt;span&gt;0.2&lt;/span&gt;, shape =&lt;span&gt; NULL,
  pointsize &lt;/span&gt;= &lt;span&gt;1.5&lt;/span&gt;, labelsize = &lt;span&gt;12&lt;/span&gt;, main = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cluster plot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, xlab =&lt;span&gt; NULL,
  ylab &lt;/span&gt;= NULL, outlier.color = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, outlier.shape = &lt;span&gt;19&lt;/span&gt;&lt;span&gt;,
  ggtheme &lt;/span&gt;= theme_grey(), ...)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;object：是聚类函数计算的结果&lt;/li&gt;
&lt;li&gt;data：原始对象数据集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用fviz_cluster()把聚类的结果显示出来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
km.res &amp;lt;- kmeans(dataset,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
fviz_cluster(km.res, data &lt;/span&gt;= dataset)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/think90/p/7133753.html&quot; target=&quot;_blank&quot;&gt;确定最佳聚类数目的10种方法&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Aug 2018 07:18:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>在实际的聚类应用中，通常使用k-均值和k-中心化算法来进行聚类分析，这两种算法都需要输入簇数，为了保证聚类的质量，应该首先确定最佳的簇数，并使用轮廓系数来评估聚类的结果。 一，k-均值法确定最佳的簇数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/4578692.html</dc:identifier>
</item>
<item>
<title>GC回收算法--当女友跟你提分手！ - 八月的思念</title>
<link>http://www.cnblogs.com/missOfAugust/p/9528166.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/missOfAugust/p/9528166.html</guid>
<description>&lt;p&gt;Java语言引入了垃圾回收机制，让C++语言中令人头疼的内存管理问题迎刃而解，使得我们Java狗每天开开心心地创建对象而不用管对象死活，这些都是Java的垃圾回收机制带来的好处。但是Java的垃圾回收机制的核心原理是什么呢？今天我们来聊聊GC回收算法吧。&lt;/p&gt;
&lt;p&gt;JVM的GC回收场景很复杂，不是单个算法就可以搞定的，大致可以分为&lt;strong&gt;可达性分析算法、标记-清除算法、标记-整理算法、分代回收算法、复制算法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;广场上，女朋友突然跟你闹分手，然后头也不回地一个人走了，留下你一个人站在树下，BGM缓缓响起“雪花飘飘 北风啸啸 天地 一片 苍茫~~~”树叶纷纷落下，这时的你仿佛被夏洛特里的元华附身，成了全世界最悲伤的人。当你沉浸在悲伤不可自拔，旁边的环卫大妈一脸嫌弃看着你“年轻人你挪一下，别挡到我扫地”。&lt;/p&gt;
&lt;p&gt;对你没猜错，地上的落叶，就是GC垃圾回收算法的核心--&lt;strong&gt;可达性分析算法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;轻风乍起，泛黄的树叶纷纷掉下，刚分手的你不禁长叹“&lt;strong&gt;叶子的离开是风的追求还是树的不挽留&lt;/strong&gt;”，当叶子从枝头掉落的那一刻，它跟树就再也没有任何关系。同样的，可达性分析算法的基本思路就是JVM内存中的对象以树的形式管理，我们称之为&quot;GC tree&quot;。GC tree的根节点叫做GC Roots,通过一些列GC Roots为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1421784/201808/1421784-20180824135046330-1541762035.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中的对象1、2、3、4不管哪个都可以找到与GC Roots相连的引用链，属于存活对象，而对象5、6、7虽然彼此相互有联系，但是他们到GC Roots是不可达的，所以属于死亡对象。&lt;/p&gt;
&lt;p&gt;有哪些对象可以作为GC Roots呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;虚拟机栈(栈桢中的本地变量表)中的引用的对象&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;方法区中的类静态属性引用的对象&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;方法区中的常量引用的对象&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;本地方法栈中JNI（Native方法）的引用的对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;二次标记&lt;/h2&gt;
&lt;p&gt;当女朋友跟你闹分手，她是真的要跟你分吗？太天真了少年！！！女人都是感性动物，刀子嘴豆腐心，她只是给你判了个死缓，如果你什么都不做，那我没话说，注孤生吧小伙子；如果你态度端正，那你还有得救！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同样的&lt;/strong&gt;，当GC线程遍历GC tree检测到无用对象的时候，并不是立马人道毁灭，只是先给它做个标记，告诉对象你已经上了枪毙名单。这里是&lt;strong&gt;第一次标记&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;挽留爱情该如何做？说情话哄她，拉她去心心念念的馆子吃顿好的，又或者去商场给她买向往已久的迪奥999口红······这些套路我就不说了，反正只要能让女朋友开心，什么付出都是值得的。&lt;/p&gt;
&lt;p&gt;当对象第一次被标记的时候，&lt;strong&gt;GC线程会去检查此对象是否有必要执行finalize()方法&lt;/strong&gt;。finalize()方法还记得吧？finalize()定义：&lt;strong&gt;finalize()&lt;/strong&gt;是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。什么意思？就是意味着如果我们重写该方法的话，那么在GC回收之前该方法会被执行。&lt;/p&gt;
&lt;p&gt;但是有两种情况GC线程会认为没有必要去执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.对象没有覆写finalize()的。女友跟你闹分手，你却像没事人一样回家继续撸游戏，小伙子你心可真大。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.finalize()已经被虚拟机执行过的。女友此时内心OS：上次吵架你送我一只迪奥999赔罪，这次你又送，你就不知道我这段时间一直想买萝卜丁吗？一定是在敷衍我！呵！男人！&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;生存还是死亡 要爱情还是要自由 That is a question!&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如果对象被判定需要执行finalize()方法，那么它将会放置在一个叫F-Queue的队列里面挨个等待执行，对象自我救赎的机会来了！如果对象想在finalize()中成功拯救自己，只要重新与GC Roots建立关联即可，比如把自己赋值给某个类对象或者对象的成员变量，那么在&lt;strong&gt;第二次标记&lt;/strong&gt;的时候它从“即将回收”的集合中中被移除；如果这时它还没有建立关联，那么它这次真的是GG了，我们用一首《凉凉》给它送别吧。&lt;/p&gt;
&lt;p&gt;图解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1421784/201808/1421784-20180825134910858-1498275111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是标记-清除算法，不过它有两点&lt;strong&gt;不足之处&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.效率问题，标记和清除过程的效率不高。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.空间问题，标记清除后会产生大量不连续的内存碎片，碎片太多可能会导致以后在程序中需要分配占用较大连续空间的对象（如数组）时，无法找到足够的连续内存而不得不提前触发下另一次垃圾收集动作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了解决这些问题，“复制算法”应运而生。&lt;/p&gt;

&lt;p&gt; 复制算法思路比较简单：将内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存空间满了，就将还活着的对象复制到另外一块，然后再将之前那块内存空间彻底清空。有点像《圣经》里的一个故事：大洪水要来了，生物纷纷逃上诺亚方舟以躲避灾难。这样玩的话每次都是对整个半区进行内存回收，内存分配的时候也不用考虑内存碎片的情况，简单粗暴让人喜欢！只不过这种算法将内存缩小为了原来的一半，代价太高昂了，我们要知道，内存是很宝贵的资源！&lt;/p&gt;
&lt;h2&gt;黄金比例 8:1:1&lt;/h2&gt;
&lt;p&gt;医学研究证明，感冒是由病毒引起的。咳咳开个玩笑！软件团队研究表明，内存中的绝大部分对象都是“朝生暮死”的，所以完全没必要非要按照1：1的比例来玩。而是把内存分成了一块较大的Eden区（伊甸区）和两块较小的Survivor区（幸存区），每次都使用伊甸区和其中一块幸存区（我们取个别名叫幸存者1号吧，另外一块取名幸存者2号）。当回收的时候，将伊甸区和幸存者1号区域里面的对象一次性复制到幸存者2号里面，最后对伊甸区和幸存者1号进行清算，里面的所有对象不管生存还是死亡彻底清除干净，比灭霸打个响指还厉害！&lt;/p&gt;
&lt;p&gt;图解：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1421784/201808/1421784-20180825135003233-96787256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在HotSpot虚拟机默认伊甸区和两块幸存区的比例大小为8:1:1，这样平时工作的时候，只有10%的内存会被浪费掉，这样是不是很划算呢？&lt;/p&gt;
&lt;p&gt;看到这里有人鞋会问，幸存区为什么要分为两块？比例9:1才是最完美吧？NO!NO!NO!，这里不得不引出另一个算法--&lt;strong&gt;分代收集算法&lt;/strong&gt;了。&lt;/p&gt;

&lt;p&gt;有没有发现，所谓的爱情其实都是要经历无数次的磨合，无数次的考验，在一起的两个人只有经受住了这些磨难，才会走进婚姻的殿堂，有了圆满的结局，而经受不住这些考验，那双方就只有各自安好，相忘江湖。&lt;/p&gt;
&lt;p&gt;在我们每次GC回收的时候，都会有一小部分对象活下来，然后一直活到下一次GC再次被检测。最近很火的吃鸡游戏，玩家不管用什么手段，刚枪也好苟也好，只求活下去成为最后的幸存者。而Java对象也是这样，经历GC的层层考验，最终成了打不死的小强。这时候该轮到GC不爽了，你丫的每次都浪费我的时间，小强内心OS&quot;就喜欢看你不爽我又干不掉我的样子！&quot;，对于这批顽固分子，GC作为执法者决定眼不见为净，于是委托JVM专门划分出一块区域给他们颐养天年，从此天涯是路人。而划分出的这块区域就是赫赫有名的“&lt;strong&gt;老年代&lt;/strong&gt;”了，而与之相对应的就是之前GC频繁的“新生代”。&lt;/p&gt;
&lt;p&gt;一个对象该如何从“新生代”跑到“老年代”去呢？&lt;/p&gt;
&lt;p&gt;我们创建一个对象，它的对象头里面会有一个GC分代标识，每经历一次GC如果能活下来该标识+1，当加到一定次数后，GC会判定该对象是个老流氓，于是乎把它从“新生代”转移到“老年代”了，安排！具体参考我的另一篇博客&lt;a href=&quot;https://www.cnblogs.com/missOfAugust/p/9524829.html&quot;&gt;《假如Java对象是个人······》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新生代每经历一次GC，幸存者2号区域活下来的对象年龄标识自动+1，然后判断是否满15岁（默认值15次），如果满15岁了，那么就从幸存者2号复制到“老年代”里面取颐养天年，如果没有的话，那么就复制到幸存者1号区域里面去，然后幸存者2号区域被清空。&lt;/p&gt;
&lt;p&gt;由于老年代对象存活率极高，用不着复制算法这一套。于是有人提出了另外一种算法叫做&lt;strong&gt;“标记-整理算法”&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;标记-整理算法其实基本过程跟“标记-删除”算法差不多，只不过后续的步骤不是对无用对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理到端边界以外的内存。这样就完美解决了“标记-清除算法”内存碎片化的问题。&lt;/p&gt;
&lt;p&gt;图解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1421784/201808/1421784-20180825134842399-1716886590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;讲到这里，JAVA的GC回收算法基本就差不多了。我们的GC就是针对内存中的不同区域，采取合理的算法从而达到自动清理的效果。&lt;strong&gt;新生代的对象大多数朝生暮死，就采用“复制算法”，老年代的对象存活率极高，就采用“标记-删除算法”或者“标记-整理算法”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在是不是觉得GC回收算法没有想象中那么神秘？希望我的理解能给你带来一点帮助，由于人懒，图片都是网上直接拿来用的。另外，如果现实中跟女友有摩擦，该服软还是得服软，男人就应该表现得大度一点，毕竟两个人相处不易，更何况她还是将和你共度余生的人，不要因为一时冲动而抱憾终生。额······我仿佛又闻到了爱情的酸臭味！&lt;/p&gt;

&lt;p&gt; 参考资料：《深入理解Java虚拟机——JVM高级特性与最佳实践(第2版)》&lt;/p&gt;
</description>
<pubDate>Sat, 25 Aug 2018 07:04:00 +0000</pubDate>
<dc:creator>八月的思念</dc:creator>
<og:description>Java语言引入了垃圾回收机制，让C++语言中令人头疼的内存管理问题迎刃而解，使得我们Java狗每天开开心心地创建对象而不用管对象死活，这些都是Java的垃圾回收机制带来的好处。但是Java的垃圾回收</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/missOfAugust/p/9528166.html</dc:identifier>
</item>
<item>
<title>web框架开发-Django模型层(2)-多表操作 - 游小刀</title>
<link>http://www.cnblogs.com/yxiaodao/p/9534108.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yxiaodao/p/9534108.html</guid>
<description>&lt;p&gt;很重要，都是精华&lt;/p&gt;

&lt;p&gt;一对一&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一旦确定表关系是一对一，在两张表中的任意一张表中建立关联字段+Unique&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一对多&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一旦确定表关系是一对多，创建关联字段在多的表中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;多对多&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一旦确定表关系是多对多，创建第三章关系表&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;假定下面这些概念，字段和关系&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者模型&lt;/strong&gt;：一个作者有姓名和年龄。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者详细模型&lt;/strong&gt;：把作者的详情放到详情表，包含生日，手机号，家庭住址等信息。作者详情模型和作者模型之间是一对一的关系（one-to-one）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;出版商模型&lt;/strong&gt;：出版商有名称，所在城市以及email。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书籍模型&lt;/strong&gt;： 书籍有书名和出版日期，一本书可能会有多个作者，一个作者也可以写多本书，所以作者和书籍的关系就是多对多的关联关系(many-to-many);一本书只应该由一个出版商出版，所以出版商和书籍是一对多关联关系(one-to-many)。&lt;/p&gt;
&lt;p&gt;模型建立如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create your models here.&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Author(models.Model):
    nid &lt;/span&gt;= models.AutoField(primary_key=&lt;span&gt;True)
    name&lt;/span&gt;=models.CharField( max_length=32&lt;span&gt;)
    age&lt;/span&gt;=&lt;span&gt;models.IntegerField()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与AuthorDetail建立一对一的关系&lt;/span&gt;
    authorDetail=models.OneToOneField(to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthorDetail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&lt;strong&gt;on_delete=models.CASCADE&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthorDetail(models.Model):

    nid &lt;/span&gt;= models.AutoField(primary_key=&lt;span&gt;True)
    birthday&lt;/span&gt;=&lt;span&gt;models.DateField()
    telephone&lt;/span&gt;=&lt;span&gt;models.BigIntegerField()
    addr&lt;/span&gt;=models.CharField( max_length=64&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Publish(models.Model):
    nid &lt;/span&gt;= models.AutoField(primary_key=&lt;span&gt;True)
    name&lt;/span&gt;=models.CharField( max_length=32&lt;span&gt;)
    city&lt;/span&gt;=models.CharField( max_length=32&lt;span&gt;)
    email&lt;/span&gt;=&lt;span&gt;models.EmailField()


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Book(models.Model):

    nid &lt;/span&gt;= models.AutoField(primary_key=&lt;span&gt;True)
    title &lt;/span&gt;= models.CharField( max_length=32&lt;span&gt;)
    publishDate&lt;/span&gt;=&lt;span&gt;models.DateField()
    price&lt;/span&gt;=models.DecimalField(max_digits=5,decimal_places=2&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与Publish建立一对多的关系,外键字段建立在多的一方&lt;/span&gt;
    publish=models.ForeignKey(to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Publish&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,to_field=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&lt;strong&gt;on_delete=models.CASCADE&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与Author表建立多对多的关系,ManyToManyField可以建在两个模型中的任意一个，自动创建第三张表&lt;span&gt;。而不是增加了一个字段&lt;/span&gt;。&lt;/span&gt;
    authors=models.ManyToManyField(to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,)
&lt;/pre&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意事项：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表的名称&lt;code&gt;myapp_modelName&lt;/code&gt;，是根据 模型中的元数据自动生成的，也可以覆写为别的名称　　&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; 字段是自动添加的&lt;/li&gt;
&lt;li&gt;对于外键字段，Django 会在字段名上添加&lt;tt&gt;&quot;_id&quot;&lt;/tt&gt; 来创建数据库中的列名&lt;/li&gt;
&lt;li&gt;这个例子中的&lt;code&gt;CREATE TABLE&lt;/code&gt; SQL 语句使用PostgreSQL 语法格式，要注意的是Django 会根据settings 中指定的数据库类型来使用相应的SQL 语句。&lt;/li&gt;
&lt;li&gt;定义好模型之后，你需要告诉Django _使用_这些模型。你要做的就是修改配置文件中的INSTALL_APPSZ中设置，在其中添加&lt;code&gt;models.py&lt;/code&gt;所在应用的名称。&lt;/li&gt;
&lt;li&gt;外键字段 ForeignKey 有一个 null=True 的设置(它允许外键接受空值 NULL)，你可以赋给它空值 None 。&lt;/li&gt;
&lt;li&gt;Django2.0 添加的外键中，要添加&lt;span&gt;&lt;strong&gt;on_delete=models.CASCADE&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;一对多&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;方式1:
   publish_obj&lt;/span&gt;=Publish.objects.get(nid=1&lt;span&gt;)
   book_obj&lt;/span&gt;=Book.objects.create(title=&lt;span&gt;&quot;三国演义&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,publishDate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2012-12-12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,price=100,publish=&lt;span&gt;publish_obj)
  &lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;
方式2:
   book_obj&lt;/span&gt;=Book.objects.create(title=&lt;span&gt;&quot;水浒传&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,publishDate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2012-12-12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,price=100,publish_id=1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;两种方法区别仅在于方式一的关联键添加的是一个对象，方式二添加的是一个id值，但是他们运行后的结果都是一样的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;即：都会生成一个字段publish_id，而且，都可以使用book_obj.publish得到一个&lt;span&gt;publish对象&lt;/span&gt;！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;多对多&lt;/h2&gt;
&lt;h3&gt;绑定方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    #&lt;/span&gt;&lt;span&gt; 当前生成的书籍对象&lt;/span&gt;
    book_obj=Book.objects.create(title=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;追风筝的人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,price=200,publishDate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2012-11-12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,publish_id=1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为书籍绑定的做作者对象&lt;/span&gt;
    yuan=Author.objects.filter(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).first() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在Author表中主键为2的纪录&lt;/span&gt;
    egon=Author.objects.filter(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).first() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在Author表中主键为1的纪录&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绑定多对多关系,即向关系表book_authors中添加纪录&lt;/span&gt;
  &lt;strong&gt;&lt;span&gt;  book_obj.authors.add(yuan,egon)&lt;/span&gt;&lt;/strong&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  将某些特定的 model 对象添加到被关联对象集合中。   =======    book_obj.authors.add(*[])或者使用键值（1,2）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：之前用authors=models.ManyToManyField(to=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,)，无法用一对多的方法添加，因为没有创建这个表的类，这个类是Django自己创建出来的&lt;/p&gt;

&lt;h3&gt;多对多关系其它常用API：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
book_obj.authors.remove()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将某个特定的对象从被关联对象集合中去除。    ======   book_obj.authors.remove(*[])&lt;/span&gt;
book_obj.authors.clear()       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;清空被关联对象集合&lt;/span&gt;
book_obj.authors.set()         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先清空再设置&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/yuanchenqi/articles/8978167.html&quot;&gt;more&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#####################绑定多对多的关系##############################################&lt;/span&gt;
&lt;span&gt;
    book_obj&lt;/span&gt;=Book.objects.create(title=&lt;span&gt;&quot;西游记&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,price=100,publishDate=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2012-12-12&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,publish_id=1&lt;span&gt;)

    egon&lt;/span&gt;=Author.objects.get(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    alex&lt;/span&gt;=Author.objects.get(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;绑定多对多关系的API&lt;/span&gt;
&lt;span&gt;    book_obj.authors.add(egon,alex)
    book_obj.authors.add(&lt;/span&gt;1,2,3&lt;span&gt;)
    book_obj.authors.add(&lt;/span&gt;*[1,2,3&lt;span&gt;])

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;解除多对多关系&lt;/span&gt;
&lt;span&gt;
    book&lt;/span&gt;=Book.objects.filter(nid=4&lt;span&gt;).first()
    book.authors.remove(&lt;/span&gt;2&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;book.authors.remove(*[1,2])&lt;/span&gt;
&lt;span&gt;
    book.authors.clear()


 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;book_obj.authors.all()&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    #&lt;/span&gt;&lt;span&gt;查询主键为4的书籍的所有作者的名字&lt;/span&gt;
    book=Book.objects.filter(nid=4&lt;span&gt;).first()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(book.authors.all()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; [obj1,obj2...] queryset: 与这本书关联的所有作者对象集合&lt;/span&gt;
    ret=book.authors.all().values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)


&lt;strong&gt;&lt;span&gt;    关键点:&lt;/span&gt;&lt;/strong&gt;

    一 book_obj.publish&lt;/span&gt;=Publish.objects.filter(id=&lt;span&gt;book_obj.publish_id).first()

    二 book_obj.authors.all()
       关键点:book.authors.all()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与这本书关联的作者集合&lt;/span&gt;

        1 book.id=3
        2&lt;span&gt; book_authors
            id  book_id  author_ID
            &lt;/span&gt;3      3             1
            4      3             2

        3&lt;span&gt;  author
           id   name
           &lt;/span&gt;1&lt;span&gt;   alex
           &lt;/span&gt;2&lt;span&gt;   egon

    book_obj.authors.all()    &lt;/span&gt;-------&amp;gt;   [alex,egon]
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;正向查询和反向查询的概念&lt;/h2&gt;
&lt;pre readability=&quot;5&quot;&gt;
A-B&lt;br/&gt;关联属性在A表中&lt;p&gt;正向查询: A------&amp;gt;B&lt;br/&gt;反向查询: B------&amp;gt;A
&lt;/p&gt;&lt;/pre&gt;
&lt;h2&gt;一对多&lt;/h2&gt;
&lt;pre&gt;
正向查询:按字段&lt;br/&gt;反向查询:表名小写_set.all()
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    #&lt;/span&gt;&lt;span&gt; 一对多查询的正向查询 : 查询西游记这本书的出版社的名字&lt;/span&gt;
&lt;span&gt;
    book_obj&lt;/span&gt;=Book.objects.filter(title=&lt;span&gt;&quot;西游记&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).first()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(book_obj.publish) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与这本书关联出版社对象&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(book_obj.publish.name)
    对应sql:
    select publish_id &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; Book where title=&lt;span&gt;&quot;西游记&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    select name &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; Publish where id=1


    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一对多查询的反向查询 : 查询人民出版社出版过的书籍名称&lt;/span&gt;
&lt;span&gt;
    publish&lt;/span&gt;=Publish.objects.filter(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;人民出版社&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).first()
    ret&lt;/span&gt;=&lt;span&gt;publish.book_set.all()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;多对多&lt;/h2&gt;
&lt;pre&gt;
正向查询:按字段&lt;br/&gt;反向查询:表名小写_set.all()
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 多对多查询的正向查询 : 查询西游记这本书的所有作者的名字&lt;/span&gt;
&lt;span&gt;
    book_obj&lt;/span&gt;=Book.objects.filter(title=&lt;span&gt;&quot;西游记&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).first()
    author_list&lt;/span&gt;=book_obj.authors.all() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; queryset对象  [author_obj1,...]&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; author &lt;span&gt;in&lt;/span&gt;&lt;span&gt; author_list:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(author.name)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 多对多查询的反向查询 : 查询alex出版过的所有书籍名称&lt;/span&gt;
&lt;span&gt;
    alex&lt;/span&gt;=Author.objects.filter(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).first()

    book_list&lt;/span&gt;=&lt;span&gt;alex.book_set.all()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; book &lt;span&gt;in&lt;/span&gt;&lt;span&gt; book_list:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(book.title)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;一对一&lt;/h2&gt;
&lt;pre&gt;
正向查询:按字段&lt;br/&gt;反向查询:表名小写
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    #&lt;/span&gt;&lt;span&gt; 一对一查询的正向查询 : 查询alex的手机号&lt;/span&gt;
&lt;span&gt;
    alex&lt;/span&gt;=Author.objects.filter(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).first()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(alex.authordetail.telephone)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一对一查询的反向查询 : 查询手机号为110的作者的名字和年龄&lt;/span&gt;
&lt;span&gt;
    ad&lt;/span&gt;=AuthorDetail.objects.filter(telephone=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).first()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ad.author.name)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ad.author.age)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;要点&lt;/h2&gt;
&lt;p&gt;要点一：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;双下划线代表跨表，使用双下划线，即通知内部引擎的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要点二:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;pre&gt;
正向查询按字段,
&lt;/pre&gt;
&lt;pre&gt;
反向查询按表名小写
&lt;/pre&gt;
&lt;pre&gt;
此要求是对于跨表的！分清楚是正向还是反向很重要
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;要点三：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;已知条件在哪张表，哪张表用字段，非那张表用双下划线跨表，匹配条件或者求值！&lt;/p&gt;

&lt;/blockquote&gt;
&lt;h2&gt;一对多&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一对多查询 : 查询西游记这本书的出版社的名字&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式1:&lt;/span&gt;
    ret=Book.objects.filter(title=&lt;span&gt;&quot;西游记&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publish__name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;QuerySet [{'publish__name': '南京出版社'}]&amp;gt;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式2:&lt;/span&gt;
    ret=Publish.objects.filter(book__title=&lt;span&gt;&quot;西游记&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;多对多&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 多对多查询 : 查询西游记这本书的所有作者的名字&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式1:&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需求: 通过Book表join与其关联的Author表,属于正向查询:按字段authors通知ORM引擎join book_authors与author&lt;/span&gt;
&lt;span&gt;
    ret&lt;/span&gt;=Book.objects.filter(title=&lt;span&gt;&quot;西游记&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authors__name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;QuerySet [{'authors__name': 'alex'}, {'authors__name': 'egon'}]&amp;gt;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式2:&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需求: 通过Author表join与其关联的Book表,属于反向查询:按表名小写book通知ORM引擎join book_authors与book表&lt;/span&gt;
    ret=Author.objects.filter(book__title=&lt;span&gt;&quot;西游记&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;QuerySet [{'name': 'alex'}, {'name': 'egon'}]&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;一对一&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一对一查询的查询 : 查询alex的手机号&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式1:&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需求: 通过Author表join与其关联的AuthorDetail表,属于正向查询:按字段authordetail通知ORM引擎join Authordetail表&lt;/span&gt;
&lt;span&gt;
    ret&lt;/span&gt;=Author.objects.filter(name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authordetail__telephone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;QuerySet [{'authordetail__telephone': 110}]&amp;gt;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; # 方式2:&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; # 需求: 通过AuthorDetail表join与其关联的Author表,属于反向查询:按表名小写author通知ORM引擎join Author表&lt;/span&gt;
    ret=AuthorDetail.objects.filter(author__name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;telephone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;QuerySet [{'telephone': 110}]&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;连续跨表查询&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 练习: 手机号以110开头的作者出版过的所有书籍名称以及书籍出版社名称&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式1:&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需求: 通过Book表join AuthorDetail表, Book与AuthorDetail无关联,所以必需连续跨表&lt;/span&gt;
    ret=Book.objects.filter(authors__authordetail__telephone__startswith=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;publish__name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)
    &lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 方式2:&lt;/span&gt;
    ret=Author.objects.filter(authordetail__telephone__startswith=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__publish__name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;related_name&lt;/h2&gt;
&lt;p&gt;反向查询时，如果定义了related_name ，则用related_name替换表名，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
publish = ForeignKey(Blog, related_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bookList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)



&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 练习: 查询人民出版社出版过的所有书籍的名字与价格(一对多)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反向查询 不再按表名:book,而是related_name:bookList&lt;/span&gt;
&lt;span&gt;

     queryResult&lt;/span&gt;=&lt;span&gt;Publish.objects
　　　　　　　　　　　　　　.filter(name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;人民出版社&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
　　　　　　　　　　　　　　.values_list(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookList__title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bookList__price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;&lt;tt&gt;aggregate&lt;/tt&gt;(*args, **kwargs) 聚合统计函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值是一个字典&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算所有图书的平均价格&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Avg

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; Book.objects.all().aggregate(Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price__avg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 34.35}
&lt;/pre&gt;&lt;/div&gt;

&lt;tt&gt;aggregate()&lt;/tt&gt;是&lt;tt&gt;QuerySet&lt;/tt&gt; 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。如果你想要为聚合值指定一个名称，可以向聚合子句提供它。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; Book.objects.aggregate(average_price=Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;average_price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 34.35}
&lt;/pre&gt;&lt;/div&gt;

如果你希望生成不止一个聚合，你可以向&lt;tt&gt;aggregate()&lt;/tt&gt;子句中添加另一个参数。所以，如果你也想知道所有图书价格的最大值和最小值，可以这样查询：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Avg, Max, Min，count

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; Book.objects.aggregate(Avg(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), Max(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), Min(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price__avg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 34.35, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;price__max&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: Decimal(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;81.20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), &lt;span&gt;'&lt;/span&gt;&lt;span&gt;price__min&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: Decimal(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;12.99&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;annotate()为调用的&lt;tt&gt;QuerySet&lt;/tt&gt;中每一个对象都生成一个独立的统计值（统计方法用聚合函数）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回值&lt;span&gt;是queryset&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;单表分组查询&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;emp:

5id  name age   salary    dep
  &lt;/span&gt;1   alex  12   2000&lt;span&gt;     销售部
  &lt;/span&gt;2   egon  22   3000&lt;span&gt;     人事部
  &lt;/span&gt;3   wen   22   5000     人事部
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 示例1&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询每一个部门的名称以及员工的平均薪水&lt;/span&gt;
&lt;span&gt;
    &lt;strong&gt;&lt;span&gt;SQL：&lt;/span&gt;&lt;/strong&gt;select dep,Avg(salary) &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; emp group by dep

    ret&lt;/span&gt;=Emp.objects.values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).annotate(avg_salary=Avg(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;QuerySet [{'avg_salary': 5000.0, 'dep': '保安部'}, {'avg_salary': 51000.0, 'dep': '教学部'}]&amp;gt;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &lt;strong&gt;&lt;span&gt;单表分组查询的ORM语法: 单表模型.objects.values(&quot;group by的字段&quot;).annotate(聚合函数(&quot;统计字段&quot;))&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 示例2&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询每一个省份的名称以及员工数&lt;/span&gt;
&lt;span&gt;
    ret&lt;/span&gt;=Emp.objects.values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;province&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).annotate(c=Count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;QuerySet [{'province': '山东省', 'c': 2}, {'province': '河北省', 'c': 1}]&amp;gt;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 补充知识点:&lt;/span&gt;
&lt;span&gt;
    ret&lt;/span&gt;=&lt;span&gt;Emp.objects.all()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; select * from emp&lt;/span&gt;
    ret=Emp.objects.values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; select name from emp&lt;/span&gt;
&lt;span&gt;
    Emp.objects.all().annotate(avg_salary&lt;/span&gt;=Avg(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) &lt;span&gt; # 在单表分组下，按照&lt;strong&gt;&lt;span&gt;主键&lt;/span&gt;&lt;/strong&gt;进行group by 没有意义。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;pre&gt;
&lt;span&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/blockquote&gt;

&lt;h2&gt;多表分组查询&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Book表

        id   title    date      price  publish_id
        &lt;/span&gt;1    红楼梦    2012-12-12    101       1
        2    西游记    2012-12-12    101       1
        3    三国演绎    2012-12-12    101       1
        4    水浒传    2012-12-12    301       2&lt;span&gt;


     Publish表
        id    name      addr   email
        &lt;/span&gt;1    人民出版社    北京       123&lt;span&gt;@qq.com
        &lt;/span&gt;2    南京出版社    南京       345@163.com
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 示例1 查询每一个出版社的名称以及出版的书籍个数&lt;/span&gt;
&lt;span&gt;
    ret &lt;/span&gt;= Publish.objects.values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).annotate(c=Count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;QuerySet [{'nid': 1, 'c': 3}, {'nid': 2, 'c': 1}]&amp;gt;&lt;/span&gt;
&lt;span&gt;
    ret &lt;/span&gt;= Publish.objects.values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;name&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).annotate(c=Count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;QuerySet [{'name': '人民出版社', 'c': 3}, {'name': '南京出版社', 'c': 1}]&amp;gt;&lt;/span&gt;
&lt;span&gt;
    ret &lt;/span&gt;= Publish.objects.values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).annotate(c=Count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).&lt;span&gt;&lt;strong&gt;values(&quot;name&quot;, &quot;c&quot;&lt;/strong&gt;&lt;strong&gt;) 通过value取值&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;QuerySet [{'name': '人民出版社', 'c': 3}, {'name': '南京出版社', 'c': 1}]&amp;gt;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;# 示例2 查询每一个作者的名字以及出版过的书籍的最高价格&lt;/span&gt;
    ret = Author.objects.values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).annotate(max_price=Max(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max_price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;总结 跨表的分组查询的模型:&lt;/strong&gt;&lt;strong&gt;
    #&lt;span&gt;&lt;span&gt; 每一个后表模型.objects.values(&quot;pk&quot;).annotate(聚合函数(关联表__统计字段))&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 示例3 查询每一个书籍的名称以及对应的作者个数&lt;/span&gt;
    ret = Book.objects.values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).annotate(c=Count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;authors__name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ret)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;################### 跨表分组查询的另一种玩法  ####################&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 示例1 查询每一个出版社的名称以及出版的书籍个数&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ret=Publish.objects.values(&quot;id&quot;).annotate(c=Count(&quot;book__title&quot;)).values(&quot;name&quot;,&quot;email&quot;,&quot;c&quot;) #ret是一个对象，里面有所有的字段信息&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ret=Publish.objects.all().annotate(c=Count(&quot;book__title&quot;)).values(&quot;name&quot;,&quot;c&quot;,&quot;city&quot;)  # all（）按照表publish的所有字段，结果一样&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
  # &lt;span&gt;ret=Publish.objects.all().annotate(c=Count(&quot;book__title&quot;))显示两个publish 对象，而且加all 和不加all也是一样的&lt;/span&gt;
    ret=Publish.objects.annotate(c=Count(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book__title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)).values(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 总结 跨表的分组查询的模型:&lt;/span&gt;
          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每一个后的表模型.objects.values(&quot;pk&quot;).annotate(聚合函数(关联表__统计字段)).values(&quot;表模型的所有字段以及统计字段&quot;)&lt;/span&gt;
          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每一个后的表模型.objects.annotate(聚合函数(关联表__统计字段)).values(&quot;表模型的所有字段以及统计字段&quot;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;直接在相应的类中添加新字段，&lt;/p&gt;
&lt;p&gt;然后必须要添加默认数据，否则会报错&lt;/p&gt;
&lt;p&gt;然后重新迁移数据。&lt;/p&gt;

&lt;p&gt;在上面所有的例子中，我们构造的过滤器都只是将字段值与某个常量做比较。如果我们要对&lt;strong&gt;&lt;span&gt;两个字段的值做比较&lt;/span&gt;&lt;/strong&gt;，那该怎么做呢？&lt;/p&gt;
&lt;p&gt;Django 提供 F() 来做这样的比较。F() 的实例可以在查询中引用字段，来比较同一个 model 实例中两个不同字段的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询评论数大于收藏数的书籍&lt;/span&gt;
 
   &lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; F
   Book.objects.filter(commnetNum__lt&lt;/span&gt;=F(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;keepNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Django 支持 F() 对象之间以及 F() 对象和常数之间的加减乘除和取模的操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查询评论数大于收藏数2倍的书籍&lt;/span&gt;
    Book.objects.filter(commnetNum__lt=F(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;keepNum&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)*2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改操作也可以使用F函数,比如将每一本书的价格提高30元：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Book.objects.all().update(price=F(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)+30)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;tt&gt;filter()&lt;/tt&gt; 等方法中的关键字参数查询都是一起进行“AND” 的。 如果你需要执行更复杂的查询（例如&lt;tt&gt;OR&lt;/tt&gt; 语句），你可以使用&lt;tt&gt;Q 对象&lt;/tt&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Q
Q(title__startswith&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Py&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;tt&gt;Q&lt;/tt&gt; 对象可以使用&lt;tt&gt;&amp;amp;&lt;/tt&gt; 和&lt;tt&gt;|&lt;/tt&gt; 操作符组合起来。当一个操作符在两个&lt;tt&gt;Q&lt;/tt&gt; 对象上使用时，它产生一个新的&lt;tt&gt;Q&lt;/tt&gt; 对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
bookList=Book.objects.filter(Q(authors__name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)|Q(authors__name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;等同于下面的SQL &lt;tt&gt;WHERE&lt;/tt&gt; 子句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
WHERE name =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; OR name =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;你可以组合&lt;tt&gt;&amp;amp;&lt;/tt&gt; 和&lt;tt&gt;|&lt;/tt&gt;  操作符以及使用括号进行分组来编写任意复杂的&lt;tt&gt;Q&lt;/tt&gt; 对象。同时，&lt;strong&gt;&lt;span&gt;&lt;tt&gt;Q&lt;/tt&gt; 对象可以使用&lt;tt&gt;~&lt;/tt&gt; 操作符取反&lt;/span&gt;&lt;/strong&gt;，这允许组合正常的查询和取反(&lt;tt&gt;NOT&lt;/tt&gt;) 查询：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
bookList=Book.objects.filter(Q(authors__name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;amp; ~Q(publishDate__year=2017)).values_list(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查询函数可以混合使用&lt;tt&gt;Q 对象&lt;/tt&gt;和关键字参数。所有提供给查询函数的参数（关键字参数或&lt;tt&gt;Q&lt;/tt&gt; 对象）都将&quot;AND”在一起。但是，&lt;span&gt;&lt;strong&gt;如果出现&lt;tt&gt;Q&lt;/tt&gt; 对象，它必须位于所有关键字参数的前面&lt;/strong&gt;&lt;/span&gt;。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
bookList=Book.objects.filter(Q(publishDate__year=2016) | Q(publishDate__year=2017&lt;span&gt;),
                              title__icontains&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 25 Aug 2018 06:41:00 +0000</pubDate>
<dc:creator>游小刀</dc:creator>
<og:description>很重要，都是精华多表关系模型一对一一旦确定表关系是一对一，在两张表中的任意一张表中建立关联字段+Unique一对多一旦确定表关系是一对多，创建关联字段在多的表中多对多一旦确定表关系是多对多，创建第三章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yxiaodao/p/9534108.html</dc:identifier>
</item>
<item>
<title>join和countDownLatch原理及区别详解 - 鹿丸不会多项式</title>
<link>http://www.cnblogs.com/hechao123/p/9533653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hechao123/p/9533653.html</guid>
<description>&lt;h2 id=&quot;先上结论&quot;&gt;先上结论&lt;/h2&gt;
&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;join 原理：在当前线程中调用另一个线程线程 thread 的 join() 方法时，会调用该 thread 的 wait() 方法，直到这个 thread 执行完毕(JVM在 run() 方法执行完后调用 exit() 方法，而 exit() 方法里调用了 notifyAll() 方法)会调用 notifyAll() 方法主动唤醒当前线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public final void join() throws InterruptedException {
            join(0);
        }

        /**
         *  注意这个方法是同步的 
         */
        public final synchronized void join(long millis)
                        throws InterruptedException {
            long base = System.currentTimeMillis();
            long now = 0;

            if (millis &amp;lt; 0) {
                throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
            }

            /**
             *  join方法默认参数为0，会直接阻塞当前线程
             */
            if (millis == 0) {
                while (isAlive()) {
                    wait(0);
                }
            } else {
                while (isAlive()) {
                    long delay = millis - now;
                    if (delay &amp;lt;= 0) {
                        break;
                    }
                    wait(delay);
                    now = System.currentTimeMillis() - base;
                }
            }
        }

        public final native boolean isAlive();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;countDownLatch 原理：可以理解为一个计数器。在初始化 CountDownLatch 的时候会在类的内部初始化一个int的变量，每当调用 countDownt() 方法的时候这个变量的值减1，而 await() 方法就是去判断这个变量的值是否为0，是则表示所有的操作都已经完成，否则继续等待。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;源码如下（源码比较少，直接全贴出来了，所有中文注释是我自己加上去的）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static class CountDownLatch {
        private static final class Sync extends AbstractQueuedSynchronizer {
            private static final long serialVersionUID = 4982264981922014374L;

            /**
             * 初始化state
             */
            Sync(int count) {
                setState(count);
            }

            int getCount() {
                return getState();
            }

            /**
             * 尝试获取同步状态
             *     只有当同步状态为0的时候返回1
             */
            protected int tryAcquireShared(int acquires) {
                return (getState() == 0) ? 1 : -1;
            }

            /**
             * 自旋+CAS的方式释放同步状态
             */
            protected boolean tryReleaseShared(int releases) {
                // Decrement count; signal when transition to zero
                for (;;) {
                    int c = getState();
                    if (c == 0)
                        return false;
                    int nextc = c-1;
                    if (compareAndSetState(c, nextc))
                        return nextc == 0;
                }
            }
        }

        private final Sync sync;

        /**
         *  初始化一个同步器
         */
        public CountDownLatch(int count) {
            if (count &amp;lt; 0) throw new IllegalArgumentException(&quot;count &amp;lt; 0&quot;);
            this.sync = new Sync(count);
        }

        /**
         * 调用同步器的acquireSharedInterruptibly方法，并且是响应中断的
         */
        public void await() throws InterruptedException {
            sync.acquireSharedInterruptibly(1);
        }

        /**
         * 调用同步器的releaseShared方法去让state减1
         */
        public void countDown() {
            sync.releaseShared(1);
        }

        /**
         * 获取剩余的count
         */
        public long getCount() {
            return sync.getCount();
        }

        public String toString() {
            return super.toString() + &quot;[Count = &quot; + sync.getCount() + &quot;]&quot;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;区别及注意事项&quot;&gt;区别及注意事项&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;join和countDownLatch都能实现让当前线程阻塞等待其他线程执行完毕，join使用起来更简便，不过countDownLatch粒度更细。&lt;/li&gt;
&lt;li&gt;由于CountDownLatch需要开发人员很明确需要等待的条件，否则容易造成await()方法一直阻塞。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何使用&quot;&gt;如何使用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;一个简单的小例子&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Test {
    private static final Logger logger = LoggerFactory.getLogger(Test.class);

    public static void main(String[] args) {
        long sleepTime = 5000;
        try {
            TestJoinThread joinThread1 = new TestJoinThread(&quot;joinThread1&quot;,sleepTime);
            TestJoinThread joinThrad2 = new TestJoinThread(&quot;joinThrad2&quot;,sleepTime);
            joinThread1.start();
            joinThrad2.start();
            joinThread1.join();
            joinThrad2.join();
            logger.info(&quot;主线程开始运行...&quot;);
        } catch (InterruptedException e) {
            logger.error(&quot;test join err!&quot;,e);
        }

        try {
            CountDownLatch count = new CountDownLatch(2);
            TestCountDownLatchThread countDownLatchThread1 = new TestCountDownLatchThread(count,&quot;countDownLatchThread1&quot;,sleepTime);
            TestCountDownLatchThread countDownLatchThread2 = new TestCountDownLatchThread(count,&quot;countDownLatchThread2&quot;,sleepTime);
            countDownLatchThread1.start();
            countDownLatchThread2.start();
            count.await();
            logger.info(&quot;主线程开始运行...&quot;);
        } catch (InterruptedException e) {
            logger.error(&quot;test countDownLatch err!&quot;,e);
        }
    }

    static class TestJoinThread extends Thread{

        private String threadName;
        private long sleepTime;

        public TestJoinThread(String threadName,long sleepTime){
            this.threadName = threadName;
            this.sleepTime = sleepTime;
        }

        @Override
        public void run() {
            try{
                logger.info(String.format(&quot;线程[%s]开始运行...&quot;,threadName));
                Thread.sleep(sleepTime);
                logger.info(String.format(&quot;线程[%s]运行结束 耗时[%s]s&quot;,threadName,sleepTime/1000));
            }catch (Exception e){
                logger.error(&quot;TestJoinThread run err!&quot;,e);
            }
        }
    }

    static class TestCountDownLatchThread extends Thread{

        private String threadName;
        private long sleepTime;
        private CountDownLatch countDownLatch;

        public TestCountDownLatchThread(CountDownLatch countDownLatch,String threadName,long sleepTime){
            this.countDownLatch = countDownLatch;
            this.threadName = threadName;
            this.sleepTime = sleepTime;
        }

        @Override
        public void run() {
            try{
                logger.info(String.format(&quot;线程[%s]开始运行...&quot;,threadName));
                Thread.sleep(sleepTime);
                logger.info(String.format(&quot;线程[%s]运行结束 耗时[%s]s&quot;,threadName,sleepTime/1000));
                countDownLatch.countDown();
            }catch (Exception e){
                logger.error(&quot;TestCountDownLatchThread run err!&quot;,e);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;11:18:01.985 [Thread-1] INFO com.sync.Test - 线程[joinThrad2]开始运行...
11:18:01.985 [Thread-0] INFO com.sync.Test - 线程[joinThread1]开始运行...
11:18:06.993 [Thread-1] INFO com.sync.Test - 线程[joinThrad2]运行结束...耗时[5]s
11:18:06.993 [Thread-0] INFO com.sync.Test - 线程[joinThread1]运行结束...耗时[5]s
11:18:06.993 [main] INFO com.sync.Test - 主线程开始运行...
11:18:06.995 [Thread-2] INFO com.sync.Test - 线程[countDownLatchThread1]开始运行...
11:18:06.995 [Thread-3] INFO com.sync.Test - 线程[countDownLatchThread2]开始运行...
11:18:11.996 [Thread-2] INFO com.sync.Test - 线程[countDownLatchThread1]运行结束...耗时[5]s
11:18:11.996 [Thread-3] INFO com.sync.Test - 线程[countDownLatchThread2]运行结束...耗时[5]s
11:18:11.996 [main] INFO com.sync.Test - 主线程开始运行...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到：joinThread1 和 joinThread2 同时开始执行，5s后主线程开始执行。countDownLatchThread1 和 countDownLatchThread2 也是一样的效果。&lt;/p&gt;
&lt;p&gt;那么我上面所说的粒度更细有怎样的应用场景呢？&lt;/p&gt;
&lt;p&gt;我对 TestCountDownLatchThread类 的 run() 方法做一点小改动：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override 
public void run() {
    try{
        logger.info(String.format(&quot;线程[%s]第一阶段开始运行...&quot;,threadName);
        Thread.sleep(sleepTime);
        logger.info(String.format(&quot;线程[%s]第一阶段运行结束耗时[%s]s&quot;,threadName,sleepTime/1000));
        countDownLatch.countDown();
        logger.info(String.format(&quot;线程[%s]第二阶段开始运行...&quot;,threadName);
        Thread.sleep(sleepTime);
        logger.info(String.format(&quot;线程[%s]第二阶段运行结束耗时[%s]s&quot;,threadName,sleepTime/1000));
    }catch (Exception e){
        logger.error(&quot;TestCountDownLatchThread run err!&quot;,e);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候日志输出会变成这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;12:59:35.912 [Thread-1] INFO com.sync.Test - 线程[countDownLatchThread2]第一阶段开始运行...
12:59:35.912 [Thread-0] INFO com.sync.Test - 线程[countDownLatchThread1]第一阶段开始运行...
12:59:40.916 [Thread-0] INFO com.sync.Test - 线程[countDownLatchThread1]第一阶段运行结束 耗时[5]s
12:59:40.916 [Thread-1] INFO com.sync.Test - 线程[countDownLatchThread2]第一阶段运行结束 耗时[5]s
12:59:40.916 [main] INFO com.sync.Test - 主线程开始运行...
12:59:40.916 [Thread-0] INFO com.sync.Test - 线程[countDownLatchThread1]第二阶段开始运行...
12:59:40.916 [Thread-1] INFO com.sync.Test - 线程[countDownLatchThread2]第二阶段开始运行...
12:59:45.917 [Thread-0] INFO com.sync.Test - 线程[countDownLatchThread1]第二阶段运行结束 耗时[5]s
12:59:45.917 [Thread-1] INFO com.sync.Test - 线程[countDownLatchThread2]第二阶段运行结束 耗时[5]s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说如果当前线程只需要等待其他线程一部分任务执行完毕的情况下就可以用 countDownLatch 来实现了，而 join 则实现不了这种粒度的控制。&lt;/p&gt;
</description>
<pubDate>Sat, 25 Aug 2018 05:08:00 +0000</pubDate>
<dc:creator>鹿丸不会多项式</dc:creator>
<og:description>先上结论 原理 join 原理：在当前线程中调用另一个线程线程 thread 的 join() 方法时，会调用该 thread 的 wait() 方法，直到这个 thread 执行完毕(JVM在 ru</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hechao123/p/9533653.html</dc:identifier>
</item>
<item>
<title>使用LSTM-RNN建立股票预测模型 - 牛云杰</title>
<link>http://www.cnblogs.com/NosenLiu/p/9533462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NosenLiu/p/9533462.html</guid>
<description>&lt;p&gt;　　硕士毕业之前曾经对基于LSTM循环神经网络的股价预测方法进行过小小的研究，趁着最近工作不忙，把其中的一部分内容写下来做以记录。&lt;/p&gt;

&lt;p&gt;　　此次股票价格预测模型仅根据股票的历史数据来建立，不考虑消息面对个股的影响。曾有日本学者使用深度学习的方法来对当天的新闻内容进行分析，以判断其对股价正面性/负面性影响，并将其与股票的历史数据相结合，各自赋予一定的权重来对近日的股价进行预测&lt;sup&gt;[1]&lt;/sup&gt;。该预测方法取得了一定的效果。&lt;/p&gt;
&lt;p&gt;　　而这里我没有引入消息面的影响，主要出于以下几点考虑：&lt;/p&gt;
&lt;p&gt;　　1.消息的及时性难以保证：很多时候，在一只股票的利好/利空消息出来之前，其股价已经有了较大幅度的增长/下跌。信息的不对称性导致普通群众缺乏第一手消息源。&lt;/p&gt;
&lt;p&gt;　　2.消息的准确性难以保证：互联网上信息传播速度极快，媒体之间经常会出现相互抄袭新闻的情况，而这种抄来的新闻(非原创新闻)往往没有经过严格的审核，存在着内容虚假，夸大宣传的可能性。一旦分析模型错用了某条谣言或真实性不高的新闻，很有可能得出错误的预测结果。&lt;/p&gt;
&lt;p&gt;　　3.语言的歧义性：一条新闻，其正面性/负面性往往存在着多种解读。例如“习主席宣布中国将裁军30万”——新华每日电讯2015.09.04。这条新闻一般意义上可以解读为：中央政府深入推进改革，精兵简政，大力发展国防军工事业。这是一种正面性的解读。而在使用机器学习模型时，如传统的奇异值分解算法(SVD)，很有可能会判定其与“去年五大行裁员近3万”这种新闻具有较高的相似度，因而将其划分为负面新闻。&lt;/p&gt;
&lt;p&gt;　　4.技术实现较为繁杂：这其实是一个非常重要的原因啦~，获取正确的信息并进行NLP操作，往往需要经过以下流程：人工浏览网页确定稳定可靠的信息源→设计爬虫实现有效信息的获取→设计新闻裁剪(填充)方案以应对不同长度的新闻→人工标注新闻的正/负性(也可以用当日股价涨跌来标注)→设计网络模型→训练及验证模型。其中的每一步都非常麻烦耗时，而且对于个股来说，并不是每天都会有新闻出现。&lt;/p&gt;

&lt;p&gt;　　上面说了这么多，还没有开始对我这个预测模型进行介绍，下面开始进入正题。在决定排除消息面的考量之后，我开始思考股价涨跌的本质，我认为股价就是资金博弈结果的体现。这次建立的预测模型，朴素的想法是通过深度学习模型来洞悉庄家的操作规律，对拉升、砸盘的情况进行预测。为了达到以下目的，我决定选取以下七个特征来构建网络模型，即：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;涨跌幅  最高涨幅  最低跌幅  大单净流入  中单净流入  小单净流入  换手率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用这七个特征来对股票的&lt;strong&gt;涨跌情况&lt;/strong&gt;以及&lt;strong&gt;资金的流动情况&lt;/strong&gt;建立适当的模型。此外，其他的指标类似MACD、均线等也是通过一些基础数据的运算得出，在构建模型时并没有将其纳入考量范围。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一.源数据及其预处理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过某股票交易软件，我获得的源数据约有20来个特征，包括：涨幅、现价、涨跌、买入、卖价、成交量等等。为了得到上面所述的七种特征，挑选出涨跌幅、大单净流入、中单净流入、小单净流入、换手率这5个特征，并计算最高涨幅、最高跌幅两个特征。通过下列公式计算获得。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1463653/201808/1463653-20180825113246494-423206675.png&quot; alt=&quot;&quot; width=&quot;253&quot; height=&quot;61&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过处理的股票特征数据存储在 股票名.csv文件中，类似下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1463653/201808/1463653-20180825113327877-691852977.png&quot; alt=&quot;&quot; width=&quot;639&quot; height=&quot;67&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中的特征顺序为：日期，大单净流入，中单净流入，小单净流入，涨跌幅，最高涨幅，最高跌幅，换手率，股价。股价在这里的用处是拼接训练样本输出时，计算多日的总涨跌幅。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/strong&gt;在对源数据进行处理的时候，经常会遇到空值问题：即，有些特征值为0的时候，系统给出的源数据为”-”或”“。需要进行特殊处理。(经常遇见新股第一天的涨跌幅为空，或某交易日大单净流入为空。)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; fin_temp.ix[day,12]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;or&lt;/span&gt;  fin_temp.ix[day,12]==&lt;span&gt;''&lt;/span&gt;:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 新股的涨跌幅一栏会出现'','-'，需要特殊处理&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         raise_value = 0.0
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         raise_value = float(fin_temp.ix[day,12])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;strong&gt;&lt;span&gt;二.训练样本拼接&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         首先设置一个滑动窗口，本次实验中将滑动窗口设置为50个交易日。每一个训练样本由50个连续的交易日组成，每个交易日的数据包含上述的七个特征，即一个50*7的矩阵，而一个样本的输出则是三个交易日之后的收盘价对比今日(即样本的输入中最后一个交易日)收盘价的涨跌幅，设置其上限为0.3，下限为-0.3(当然，连续三个涨停板的涨幅会超过0.3，这里将其统一视作0.3)。之所以选择三个交易日之后的涨跌幅作为训练样本的输出，是因为我国股市是T+1操作规则，当日买入不可卖出，预测的稍微靠后一些可留有操作空间；再有就是一天的拉升/砸盘偶然性太大，不易预测，对稍微长期一点的状况进行预测有着更高的稳定性。&lt;/p&gt;
&lt;p&gt;　　归一化相关工作：因为神经网络激活函数的限制，需要在训练前将数据映射到0~1区间。本次试验中，对近两年的数据，获取其各项特征的最大值与最小值。设置归一化与函数，在样本拼接的同时将数据进行归一化。&lt;/p&gt;
&lt;p&gt;样本 &lt;strong&gt;输入&lt;/strong&gt;的归一化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; normalize_oneday(stockN,fdata,day):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     max_min =&lt;span&gt; list(max_min_list[stockN])
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     in_1 = (fdata.ix[day,1]-max_min[1])/(max_min[0]-max_min[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     in_2 = (fdata.ix[day,2]-max_min[3])/(max_min[2]-max_min[3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     in_3 = (fdata.ix[day,3]-max_min[5])/(max_min[4]-max_min[5&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     in_4 = (fdata.ix[day,4]-max_min[7])/(max_min[6]-max_min[7&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     in_5 = (fdata.ix[day,5]-max_min[9])/(max_min[8]-max_min[9&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     in_6 = (fdata.ix[day,6]-max_min[11])/(max_min[10]-max_min[11&lt;span&gt;])
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     in_7 = (fdata.ix[day,7]-max_min[13])/(max_min[12]-max_min[13&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; [in_1,in_2,in_3,in_4,in_5,in_6,in_7]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;样本 &lt;strong&gt;输出&lt;/strong&gt;的归一化与反归一化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; normalize_raise(volume):
    norm_value &lt;/span&gt;= (volume+0.3)/0.6
    &lt;span&gt;if&lt;/span&gt; norm_value&amp;gt;1&lt;span&gt;:
        norm_value &lt;/span&gt;= 1   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;涨跌幅超过30%的都定义为 1或0&lt;/span&gt;
    &lt;span&gt;elif&lt;/span&gt; norm_value&amp;lt;&lt;span&gt;0:
        norm_value &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; norm_value
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; denormalize_raise(value):
    volume &lt;/span&gt;= value*0.6-0.3
    &lt;span&gt;return&lt;/span&gt; volume
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         设置滑动窗口sample_window = []，每次遍历一行特征数据，归一化后插入窗口末尾，当窗口大小满50时，计算3天后涨跌幅，拼接出一个训练样本，并将sample_window中第一个交易日的值弹出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; normalized_daily_sample =&lt;span&gt; normalize_oneday(stockN_list_str[i],fin_temp,day)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; TODO 给样本插入该日数据&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; sample_window.append(normalized_daily_sample)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存入一个样本list，特征数为7，全部归一化完毕&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; len(sample_window)==window_len:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 窗口大小满50&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;TODO 需要对涨幅进行归一化 暂定 30% TODO&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     raise_3days = normalize_raise(float(fin_temp.ix[day+3,8])/float(fin_temp.ix[day,8])-1.0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    samples.append([sample_window,raise_3days])
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     sample_window = sample_window[1:]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遍历完所有数据行后，获得数百个训练样本。并将训练样本转存为numpy.array格式以方便训练。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 注：&lt;/span&gt;&lt;/strong&gt;跳点问题，具体分为除权(涨跌幅超过10%)与停盘(相邻交易日间隔超过10天)。对于跳点问题，我们判断其是否发生，一旦发生跳点，就清空sample_window，从下一个交易日重新开始计算样本输入，以杜绝样本输入中有跳点数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 间隔日期大于10天，即day+3大于12天，判断为有停盘，不连续，或者涨跌幅异常(超过10.5%),不能作为训练样本序列, &lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; int(diff/(24*3600))&amp;gt;12 &lt;span&gt;or&lt;/span&gt; abs(raise_value)&amp;gt;10.5&lt;span&gt;:  
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     sample_window = []
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三.搭建模型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         这里使用keras深度学习框架对模型进行快速搭建。建立Sequential模型，向其中添加LSTM层，设定Dropout为0.2，加入Dense层将其维度聚合为1，激活函数使用relu，损失函数定为交叉熵函数。之前也使用过传统的sigmoid作为激活函数，但经实验感觉效果不如relu。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; model =&lt;span&gt; Sequential()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; model.add(LSTM(128, input_shape=(window_len,7), return_sequences=False))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; TODO: input_shape=(timesteps ,data_dim)&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; model.add(Dropout(0.2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; model.add(Dense(1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; model.add(Activation(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; model.compile(loss=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;binary_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,optimizer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rmsprop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,metrics=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　模型搭建完毕，使用之前获得的数百个训练样本展开训练，并保存模型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; hist = model.fit(trainX,trainY,batch_size=1,epochs=50&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; score = model.evaluate(trainX, trainY, batch_size=10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; os.path.exists(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./model/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+file_name[:-5&lt;span&gt;]):
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     model.save(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./model/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+file_name[:-5]+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/model_%s_%s.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(window_len,date))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; HDF5 保存模型&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     os.mkdir(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./model/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+file_name[:-5&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     model.save(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./model/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+file_name[:-5]+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/model_%s_%s.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(window_len,date)) 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四.效果展示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　最初的时候，我对所有的股票的训练样本堆叠到一起，训练出一个大模型(貌似当时有9万多个训练样本，整整训练了一天=，=)，之后对每个股票都进行预测，企图找出次日涨幅最高的前5支股票。后来发现根本做不到……每支股票的操作规律都不一样，使用单个模型无法有效的把握个股的涨跌趋势。&lt;/p&gt;
&lt;p&gt;　　之后，我单独选了中国软件这个股票(这个票看起来像庄家主导的那种)，对它单独进行分析。使用了一年半的交易数据作为训练集，共有293个训练样本，训练140个epoch。最后训练出模型对测试集中的60个测试样本进行验证。预测误差如下图。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1463653/201808/1463653-20180825115027559-143558227.png&quot; alt=&quot;&quot; width=&quot;769&quot; height=&quot;411&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其中前40个是训练集中的样本，我们使用其输入部分进行预测，发现预测结果贴合十分紧密；后60个是我们测试集的样本，我对其预测效果还是比较满意的，大跌、大涨基本都有预测到，除了第67到第75个点那一波大跌预测的不好。随后我使用模型进行模拟交易，设定初始资金两万元，在预测三天后会上涨时买入，预测三天后会下跌时卖出，均以收盘价为交易价格，买入时扣除万分之2.5的佣金。收益曲线如下，蓝色线条代表按模型进行交易的收益，绿色线条代表一直持有股票的收益。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1463653/201808/1463653-20180825115055084-1706244072.png&quot; alt=&quot;&quot; width=&quot;874&quot; height=&quot;469&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看出，模型的预测效果还是不错的。尤其是开始的20多个点，能够较为准确的避开一波回调下跌。&lt;/p&gt;
&lt;p&gt;　　但我也知道，对模型进行验证的样本数量还是太少，又过了一个月，在额外收集了20个交易日的数据之后，我又对该样本进行了测试。&lt;/p&gt;
&lt;p&gt;预测误差：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1463653/201808/1463653-20180825115202857-801914380.png&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;406&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看出，倒数20个交易日的这一波大涨幅，模型并没有能够预测到。&lt;/p&gt;
&lt;p&gt;收益曲线：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1463653/201808/1463653-20180825115512876-880243678.png&quot; alt=&quot;&quot; width=&quot;876&quot; height=&quot;480&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从上图可以看出，在紫色方框圈出来的地方，模型多次预测会有一波涨幅，但紧跟着又立马预测股价要跌，对股票进行了抛售，错过了这两次大涨的机会；在黄色方框圈出的地方，模型两次在顶点做出了准确的预测，精准抛售，躲过两次大跌。&lt;/p&gt;

&lt;p&gt;经过股票数据的验证，使用LSTM-RNN来对股票进行预测具有一定的可行性，但效果不佳（要是效果好的话我估计也不会分享到网上，自己闷声发大财啦，哈哈~~~）。&lt;/p&gt;

&lt;p&gt;[1]R. Akita, A. Yoshihara, T. Matsubara and K. Uehara, &quot;Deep learning for stock prediction using numerical and textual information,&quot; &lt;em&gt;2016 IEEE/ACIS 15th International Conference on Computer and Information Science (ICIS)&lt;/em&gt;, Okayama, 2016, pp. 1-6.      (https://ieeexplore.ieee.org/document/7550882)&lt;/p&gt;
</description>
<pubDate>Sat, 25 Aug 2018 04:00:00 +0000</pubDate>
<dc:creator>牛云杰</dc:creator>
<og:description>硕士毕业之前曾经对基于LSTM循环神经网络的股价预测方法进行过小小的研究，趁着最近工作不忙，把其中的一部分内容写下来做以记录。 此次股票价格预测模型仅根据股票的历史数据来建立，不考虑消息面对个股的影响</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NosenLiu/p/9533462.html</dc:identifier>
</item>
<item>
<title>HBase性能调优总结 - Frankdeng</title>
<link>http://www.cnblogs.com/frankdeng/p/9529044.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/frankdeng/p/9529044.html</guid>
<description>&lt;p&gt;即：这个参数的作用是当单个 HRegion 内所有的 Memstore 大小总和超过指定值时，flush&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;该 HRegion 的所有 memstore。RegionServer 的 flush 是通过将请求添加一个队列，模拟生产消费模型来异步处理的。那这里就有一个问题，当队列来不及消费，产生大量积压请求时，可能会导致内存陡增，最坏的情况是触发 OOM。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
hbase.regionserver.global.memstore.upperLimit：0.4 &lt;br/&gt;hbase.regionserver.global.memstore.lowerLimit：0.38
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即：当 MemStore 使用内存总量达到 hbase.regionserver.global.memstore.upperLimit 指定值时，将会有多个 MemStores flush 到文件中，MemStore flush 顺序是按照大小降序执行的，直到刷新到 MemStore 使用内存略小于 lowerLimit&lt;/p&gt;
&lt;h2 class=&quot;16&quot;&gt;三. &lt;strong&gt;HBase的写表&lt;/strong&gt;优化&lt;/h2&gt;
&lt;h3 id=&quot;blogTitle9&quot;&gt;&lt;strong&gt;1 多HTable并发写&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;创建多个HTable客户端用于写操作，提高写数据的吞吐量，一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; final Configuration conf =&lt;span&gt; HBaseConfiguration.create();
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; final String table_log_name =&lt;span&gt; “user_log”;
wTableLog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HTable[tableN];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; tableN; i++&lt;span&gt;) {
    wTableLog[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HTable(conf, table_log_name);
    wTableLog[i].setWriteBufferSize(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5MB&lt;/span&gt;
    wTableLog[i].setAutoFlush(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;blogTitle10&quot;&gt;&lt;strong&gt;2  HTable参数设置&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&quot;blogTitle11&quot;&gt;&lt;strong&gt;Auto Flush&lt;/strong&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;通过调用HTable.setAutoFlush(false)方法可以将HTable写客户端的自动flush关闭，这样可以批量写入数据到HBase，而不是有一条put就执行一次更新，只有当put填满客户端写缓存时，才实际向HBase服务端发起写请求。默认情况下auto flush是开启的。&lt;/p&gt;
&lt;h4 id=&quot;blogTitle12&quot;&gt;&lt;strong&gt;Write Buffer&lt;/strong&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;通过调用HTable.setWriteBufferSize(writeBufferSize)方法可以设置HTable客户端的写buffer大小，如果新设置的buffer小于当前写buffer中的数据时，buffer将会被flush到服务端。其中，writeBufferSize的单位是byte字节数，可以根据实际写入数据量的多少来设置该值。&lt;/p&gt;
&lt;h4 id=&quot;blogTitle13&quot;&gt;&lt;strong&gt;WAL Flag&lt;/strong&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;在HBae中，客户端向集群中的RegionServer提交数据时（Put/Delete操作），首先会先写WAL（Write Ahead Log）日志（即HLog，一个RegionServer上的所有Region共享一个HLog），只有当WAL日志写成功后，再接着写MemStore，然后客户端被通知提交数据成功；如果写WAL日志失败，客户端则被通知提交失败。这样做的好处是可以做到RegionServer宕机后的数据恢复。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;因此，对于相对不太重要的数据，可以在Put/Delete操作时，通过调用Put.setWriteToWAL(false)或Delete.setWriteToWAL(false)函数，放弃写WAL日志，从而提高数据写入的性能。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;值得注意的是：谨慎选择关闭WAL日志，因为这样的话，一旦RegionServer宕机，Put/Delete的数据将会无法根据WAL日志进行恢复。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;blogTitle14&quot;&gt;&lt;strong&gt;3 批量写&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;通过调用HTable.put(Put)方法可以将一个指定的row key记录写入HBase，同样HBase提供了另一个方法：通过调用HTable.put(List&amp;lt;Put&amp;gt;)方法可以将指定的row key列表，批量写入多行记录，这样做的好处是批量执行，只需要一次网络I/O开销，这对于对数据实时性要求高，网络传输RTT高的情景下可能带来明显的性能提升。&lt;/p&gt;
&lt;h3 id=&quot;blogTitle15&quot;&gt;&lt;strong&gt;4 &lt;/strong&gt;&lt;strong&gt;多线程并发写&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;在客户端开启多个HTable写线程，每个写线程负责一个HTable对象的flush操作，这样结合定时flush和写buffer（writeBufferSize），可以既保证在数据量小的时候，数据可以在较短时间内被flush（如1秒内），同时又保证在数据量大的时候，写buffer一满就及时进行flush。下面给个具体的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; threadN; i++&lt;span&gt;) {
    Thread th &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread() {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 second&lt;/span&gt;
                } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
synchronized (wTableLog[i]) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        wTableLog[i].flushCommits();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
}
    };
    th.setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    th.start();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;16&quot;&gt;四. &lt;strong&gt;HBase的读表&lt;/strong&gt;优化&lt;/h2&gt;
&lt;h3 id=&quot;blogTitle17&quot;&gt;&lt;strong&gt;1 多HTable并发读&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;创建多个HTable客户端用于读操作，提高读数据的吞吐量，一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; final Configuration conf =&lt;span&gt; HBaseConfiguration.create();
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; final String table_log_name =&lt;span&gt; “user_log”;&lt;br/&gt;rTableLog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HTable[tableN];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; tableN; i++&lt;span&gt;) {
    rTableLog[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HTable(conf, table_log_name);
    rTableLog[i].setScannerCaching(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;blogTitle18&quot;&gt;&lt;strong&gt;2  HTable参数设置&lt;/strong&gt;&lt;/h3&gt;
&lt;h4 id=&quot;blogTitle19&quot;&gt;&lt;strong&gt;Scanner Caching&lt;/strong&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;hbase.client.scanner.caching配置项可以设置HBase scanner一次从服务端抓取的数据条数，默认情况下一次一条。通过将其设置成一个合理的值，可以减少scan过程中next()的时间开销，代价是scanner需要通过客户端的内存来维持这些被cache的行记录。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;有三个地方可以进行配置：&lt;strong&gt;三者的优先级越来越高。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;1）在HBase的conf配置文件中进行配置；&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;2）通过调用HTable.setScannerCaching(int scannerCaching)进行配置；&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;3）通过调用Scan.setCaching(int caching)进行配置。&lt;/p&gt;
&lt;h4 id=&quot;blogTitle20&quot;&gt;&lt;strong&gt;Scan Attribute Selection&lt;/strong&gt;&lt;/h4&gt;
&lt;p class=&quot;pre&quot;&gt;scan时指定需要的Column Family，可以减少网络传输数据量，否则默认scan操作会返回整行所有Column Family的数据。&lt;/p&gt;
&lt;h4 id=&quot;blogTitle21&quot;&gt;&lt;strong&gt;Close ResultScanner&lt;/strong&gt;&lt;/h4&gt;
&lt;p class=&quot;pre&quot;&gt;通过scan取完数据后，记得要关闭ResultScanner，否则RegionServer可能会出现问题（对应的Server资源无法释放）。&lt;/p&gt;
&lt;h3 id=&quot;blogTitle22&quot;&gt;&lt;strong&gt;3 批量读&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;通过调用HTable.get(Get)方法可以根据一个指定的row key获取一行记录，同样HBase提供了另一个方法：通过调用HTable.get(List&amp;lt;Get&amp;gt;)方法可以根据一个指定的row key列表，批量获取多行记录，这样做的好处是批量执行，只需要一次网络I/O开销，这对于对数据实时性要求高而且网络传输RTT高的情景下可能带来明显的性能提升。&lt;/p&gt;
&lt;h3 id=&quot;blogTitle23&quot;&gt;&lt;strong&gt;4 多线程并发读&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;在客户端开启多个HTable读线程，每个读线程负责通过HTable对象进行get操作。下面是一个多线程并发读取HBase，获取店铺一天内各分钟PV值的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataReaderServer {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取店铺一天内各分钟PV值的入口函数&lt;/span&gt;
     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentHashMap&amp;lt;String, String&amp;gt; getUnitMinutePV(&lt;span&gt;long&lt;/span&gt; uid, &lt;span&gt;long&lt;/span&gt; startStamp, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; endStamp){
         &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; min =&lt;span&gt; startStamp;
         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = (&lt;span&gt;int&lt;/span&gt;)((endStamp - startStamp) / (&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;));
         List&lt;/span&gt;&amp;lt;String&amp;gt; lst = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
         &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= count; i++&lt;span&gt;) {
            min &lt;/span&gt;= startStamp + i * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
            lst.add(uid &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; min);
         }
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; parallelBatchMinutePV(lst);
     }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多线程并发查询，获取分钟PV值&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentHashMap&amp;lt;String, String&amp;gt; parallelBatchMinutePV(List&amp;lt;String&amp;gt;&lt;span&gt; lstKeys){
        ConcurrentHashMap&lt;/span&gt;&amp;lt;String, String&amp;gt; hashRet = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; parallel = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; lstBatchKeys  = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lstKeys.size() &amp;lt;&lt;span&gt; parallel ){
            lstBatchKeys  &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            lstBatchKeys.add(lstKeys);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            lstBatchKeys  &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;&lt;span&gt;(parallel);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; parallel; i++&lt;span&gt;  ){
                List&lt;/span&gt;&amp;lt;String&amp;gt; lst = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
                lstBatchKeys.add(lst);
            }

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; lstKeys.size() ; i ++&lt;span&gt; ){
                lstBatchKeys.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;(i%parallel).add(lstKeys.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(i));
            }
        }
        
        List&lt;/span&gt;&amp;lt;Future&amp;lt; ConcurrentHashMap&amp;lt;String, String&amp;gt; &amp;gt;&amp;gt; futures = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Future&amp;lt; ConcurrentHashMap&amp;lt;String, String&amp;gt; &amp;gt;&amp;gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
        
        ThreadFactoryBuilder builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactoryBuilder();
        builder.setNameFormat(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ParallelBatchQuery&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        ThreadFactory factory &lt;/span&gt;=&lt;span&gt; builder.build();
        ThreadPoolExecutor executor &lt;/span&gt;=&lt;span&gt; (ThreadPoolExecutor) Executors.newFixedThreadPool(lstBatchKeys.size(), factory);
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(List&amp;lt;String&amp;gt;&lt;span&gt; keys : lstBatchKeys){
            Callable&lt;/span&gt;&amp;lt; ConcurrentHashMap&amp;lt;String, String&amp;gt; &amp;gt; callable = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BatchMinutePVCallable(keys);
            FutureTask&lt;/span&gt;&amp;lt; ConcurrentHashMap&amp;lt;String, String&amp;gt; &amp;gt; future = (FutureTask&amp;lt; ConcurrentHashMap&amp;lt;String, String&amp;gt; &amp;gt;&lt;span&gt;) executor.submit(callable);
            futures.add(future);
        }
        executor.shutdown();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Wait for all the tasks to finish&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          boolean stillRunning &lt;/span&gt;= !&lt;span&gt;executor.awaitTermination(
              &lt;/span&gt;&lt;span&gt;5000000&lt;/span&gt;&lt;span&gt;, TimeUnit.MILLISECONDS);
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stillRunning) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                executor.shutdownNow();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;                e.printStackTrace();
            }
          }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
          &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
              Thread.currentThread().interrupt();
          } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e1) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e1.printStackTrace();
          }
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Look for any exception&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Future f : futures) {
          &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(f.&lt;span&gt;get&lt;/span&gt;() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
              {
                  hashRet.putAll((ConcurrentHashMap&lt;/span&gt;&amp;lt;String, String&amp;gt;)f.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;());
              }
          } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                 Thread.currentThread().interrupt();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e1) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;                e1.printStackTrace();
            }
          } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException e) {
            e.printStackTrace();
          }
        }
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashRet;
    }
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个线程批量查询，获取分钟PV值&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentHashMap&amp;lt;String, String&amp;gt; getBatchMinutePV(List&amp;lt;String&amp;gt;&lt;span&gt; lstKeys){
        ConcurrentHashMap&lt;/span&gt;&amp;lt;String, String&amp;gt; hashRet = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;Get&amp;gt; lstGet = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Get&amp;gt;&lt;span&gt;();
        String[] splitValue &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String s : lstKeys) {
            splitValue &lt;/span&gt;= s.split(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; uid = Long.parseLong(splitValue[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; min = Long.parseLong(splitValue[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] key = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;16&lt;/span&gt;&lt;span&gt;];
            Bytes.putLong(key, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, uid);
            Bytes.putLong(key, &lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;, min);
            Get g &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Get(key);
            g.addFamily(fp);
            lstGet.add(g);
        }
        Result[] res &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            res &lt;/span&gt;= tableMinutePV[rand.nextInt(tableN)].&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(lstGet);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e1) {
            logger.error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tableMinutePV exception, e=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e1.getStackTrace());
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; res.length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            hashRet &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, String&amp;gt;&lt;span&gt;(res.length);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Result re : res) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (re != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;re.isEmpty()) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] key =&lt;span&gt; re.getRow();
                        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] value =&lt;span&gt; re.getValue(fp, cp);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; value != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            hashRet.put(String.valueOf(Bytes.toLong(key,
                                    Bytes.SIZEOF_LONG)), String.valueOf(Bytes
                                    .toLong(value)));
                        }
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e2) {
                        logger.error(e2.getStackTrace());
                    }
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashRet;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用接口类，实现Callable接口&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; BatchMinutePVCallable implements Callable&amp;lt;ConcurrentHashMap&amp;lt;String, String&amp;gt;&amp;gt;&lt;span&gt;{
     &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; keys;

     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BatchMinutePVCallable(List&amp;lt;String&amp;gt;&lt;span&gt; lstKeys ) {
         &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.keys =&lt;span&gt; lstKeys;
     }

     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ConcurrentHashMap&amp;lt;String, String&amp;gt;&lt;span&gt; call() throws Exception {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DataReadServer.getBatchMinutePV(keys);
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;blogTitle24&quot;&gt;&lt;strong&gt;5 缓存查询结果&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;对于频繁查询HBase的应用场景，可以考虑在应用程序中做缓存，当有新的查询请求时，首先在缓存中查找，如果存在则直接返回，不再查询HBase；否则对HBase发起读请求查询，然后在应用程序中将查询结果缓存起来。至于缓存的替换策略，可以考虑&lt;span&gt;LRU&lt;/span&gt;等常用的策略。&lt;/p&gt;
&lt;h3 id=&quot;blogTitle25&quot;&gt;&lt;strong&gt;6 &lt;/strong&gt;&lt;strong&gt;Blockcache&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;HBase上Regionserver的内存分为两个部分，一部分作为Memstore，主要用来写；另外一部分作为BlockCache，主要用于读。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;写请求会先写入Memstore，Regionserver会给每个region提供一个Memstore，当Memstore满64MB以后，会启动 flush刷新到磁盘。当Memstore的总大小超过限制时（heapsize * hbase.regionserver.global.memstore.upperLimit * 0.9），会强行启动flush进程，从最大的Memstore开始flush直到低于限制。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;读请求先到Memstore中查数据，查不到就到BlockCache中查，再查不到就会到磁盘上读，并把读的结果放入BlockCache。由于BlockCache采用的是LRU策略，因此BlockCache达到上限(heapsize * hfile.block.cache.size * 0.85)后，会启动淘汰机制，淘汰掉最老的一批数据。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;一个Regionserver上有一个BlockCache和N个Memstore，它们的大小之和不能大于等于heapsize * 0.8，否则HBase不能启动。默认BlockCache为0.2，而Memstore为0.4。&lt;strong&gt;对于注重读响应时间的系统，可以将&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;BlockCache设大些，比如设置BlockCache=0.4，Memstore=0.39，以加大缓存的命中率。&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;有关BlockCache机制，请参考这里：&lt;a href=&quot;http://punishzhou.iteye.com/blog/1277141&quot; target=&quot;_blank&quot;&gt;HBase的Block cache&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/raymondshiquan/archive/2011/07/24/2115397.html&quot; target=&quot;_blank&quot;&gt;HBase的blockcache机制&lt;/a&gt;，&lt;a href=&quot;http://koven2049.iteye.com/blog/1002135&quot; target=&quot;_blank&quot;&gt;hbase中的缓存的计算与使用&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;五. HTable与&lt;/strong&gt;&lt;strong&gt;HTable &lt;/strong&gt;&lt;strong&gt;Pool&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/panfeng412/archive/2012/07/11/htable-and-htablepool-apply-notes.html&quot; target=&quot;_blank&quot;&gt;HTable和HTablePool使用注意事项&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;HTable和HTablePool都是HBase客户端API的一部分，可以使用它们对HBase表进行CRUD操作。下面结合在项目中的应用情况，对二者使用过程中的注意事项做一下概括总结。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Configuration conf =&lt;span&gt; HBaseConfiguration.create();
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (Connection connection =&lt;span&gt; ConnectionFactory.createConnection(conf)) {
  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; (Table table =&lt;span&gt; connection.getTable(TableName.valueOf(tablename)) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use table as needed, the table returned is lightweight&lt;/span&gt;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;strong&gt;HTable&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;HTable是HBase客户端与HBase服务端通讯的Java API对象，客户端可以通过HTable对象与服务端进行CRUD操作（增删改查）。它的创建很简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Configuration conf =&lt;span&gt; HBaseConfiguration.create();
HTable table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HTable(conf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tablename&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO CRUD Operation……&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 class=&quot;p&quot;&gt;&lt;strong&gt;HTable使用时的一些注意事项：&lt;/strong&gt;&lt;/h4&gt;
&lt;h4 id=&quot;blogTitle27&quot; class=&quot;p&quot;&gt;&lt;strong&gt;1.  &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;规避HTable对象的创建开销&lt;/strong&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;因为客户端创建HTable对象后，需要进行一系列的操作：检查.META.表确认指定名称的HBase表是否存在，表是否有效等等，整个时间开销比较重，可能会耗时几秒钟之长，因此最好在程序启动时一次性创建完成需要的HTable对象，如果使用Java API，一般来说是在构造函数中进行创建，程序启动后直接重用。&lt;/p&gt;
&lt;h4 id=&quot;blogTitle28&quot; class=&quot;p&quot;&gt;&lt;strong&gt;2.  &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;HTable对象不是线程安全的&lt;/strong&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;HTable对象对于客户端读写数据来说不是线程安全的，因此多线程时，要为每个线程单独创建复用一个HTable对象，不同对象间不要共享HTable对象使用，特别是在客户端auto flash被置为false时，由于存在本地write buffer，可能导致数据不一致。&lt;/p&gt;
&lt;h4 id=&quot;blogTitle29&quot; class=&quot;p&quot;&gt;&lt;strong&gt;3.  &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;HTable对象之间共享Configuration&lt;/strong&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt;HTable对象共享Configuration对象，这样的好处在于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共享ZooKeeper的连接：每个客户端需要与ZooKeeper建立连接，查询用户的table regions位置，这些信息可以在连接建立后缓存起来共享使用；&lt;/li&gt;
&lt;li&gt;共享公共的资源：客户端需要通过ZooKeeper查找-ROOT-和.META.表，这个需要网络传输开销，客户端缓存这些公共资源后能够减少后续的网络传输开销，加快查找过程速度。&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;p&quot;&gt;因此，与以下这种方式相比：&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;HTable table1 = new HTable(&quot;table1&quot;);&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;HTable table2 = new HTable(&quot;table2&quot;);&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;下面的方式更有效些：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Configuration conf =&lt;span&gt; HBaseConfiguration.create();
HTable table1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HTable(conf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
HTable table2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HTable(conf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt;备注：即使是高负载的多线程程序，也并没有发现因为共享Configuration而导致的性能问题；如果你的实际情况中不是如此，那么可以尝试不共享Configuration。&lt;/p&gt;
&lt;h3 id=&quot;blogTitle30&quot;&gt;&lt;strong&gt;2.  HTable  Pool&lt;/strong&gt;&lt;/h3&gt;
&lt;p class=&quot;p&quot;&gt;HTablePool可以解决HTable存在的线程不安全问题，同时通过维护固定数量的HTable对象，能够在程序运行期间复用这些HTable资源对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Configuration conf =&lt;span&gt; HBaseConfiguration.create();
HTablePool pool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HTablePool(conf, &lt;span&gt;10&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt;1.   HTablePool可以自动创建HTable对象，而且对客户端来说使用上是完全透明的，可以避免多线程间数据并发修改问题。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;2.   HTablePool中的HTable对象之间是公用Configuration连接的，能够可以减少网络开销。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;HTablePool的使用很简单：每次进行操作前，通过HTablePool的getTable方法取得一个HTable对象，然后进行put/get/scan/delete等操作，最后通过HTablePool的putTable方法将HTable对象放回到HTablePool中。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;下面是个使用HTablePool的简单例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createUser(String username, String firstName, String lastName, String email, String password, String roles) throws IOException {

　　HTable table &lt;/span&gt;=&lt;span&gt; rm.getTable(UserTable.NAME);
　　Put put &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Put(Bytes.toBytes(username));
　　put.add(UserTable.DATA_FAMILY, UserTable.FIRSTNAME,
　　Bytes.toBytes(firstName));
　　put.add(UserTable.DATA_FAMILY, UserTable.LASTNAME,Bytes.toBytes(lastName));
　　put.add(UserTable.DATA_FAMILY, UserTable.EMAIL, Bytes.toBytes(email));
　　put.add(UserTable.DATA_FAMILY, UserTable.CREDENTIALS,Bytes.toBytes(password));
　　put.add(UserTable.DATA_FAMILY, UserTable.ROLES, Bytes.toBytes(roles));
　　table.put(put);
　　table.flushCommits();
　　rm.putTable(table);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HBase和DBMS比较：&lt;/p&gt;
&lt;p&gt;查询数据不灵活：&lt;/p&gt;
&lt;p class=&quot;24&quot;&gt;1、 不能使用column之间过滤查询&lt;/p&gt;
&lt;p class=&quot;24&quot;&gt;2、 不支持全文索引。使用solr和hbase整合完成全文搜索。&lt;/p&gt;
&lt;p class=&quot;24&quot;&gt;a) 使用MR批量读取hbase中的数据，在solr里面建立索引（no  store）之保存rowkey的值。&lt;/p&gt;
&lt;p class=&quot;24&quot;&gt;b) 根据关键词从索引中搜索到rowkey（分页）&lt;/p&gt;
&lt;p class=&quot;24&quot;&gt;c) 根据rowkey从hbase查询所有数据&lt;/p&gt;
</description>
<pubDate>Sat, 25 Aug 2018 03:22:00 +0000</pubDate>
<dc:creator>Frankdeng</dc:creator>
<og:description>一. HBase的通用优化 1 高可用 在 HBase 中 Hmaster 负责监控 RegionServer 的生命周期，均衡&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/frankdeng/p/9529044.html</dc:identifier>
</item>
</channel>
</rss>