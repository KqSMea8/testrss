<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【译】单元测试最佳实践 - 雪飞鸿</title>
<link>http://www.cnblogs.com/Cwj-XFH/p/9501414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cwj-XFH/p/9501414.html</guid>
<description>&lt;p&gt;原文地址：&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Unit testing best practices&lt;/a&gt;&lt;br/&gt;PS:本文未翻译原文的全部内容，以下为译文。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;编写单元测试有如下好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利于回归测试&lt;/li&gt;
&lt;li&gt;提供文档&lt;/li&gt;
&lt;li&gt;改进代码设计&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，难以阅读和维护的测试代码则会适得其反。本文会提供一些编写单元测试的最佳实践以使得你的测试代码易于维护和理解。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;为什么要写单元测试？&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;1. 花更少的时间进行功能测试&lt;/h4&gt;
&lt;p&gt;功能测试成本相对较高，因为经常需要打开应用并执行一系列操作以验证结果是否符合预期。测试步骤所涉及领域未必是测试人员所熟知，导致需要其他人协助进行测试。对于细微变化，测试可能需几秒钟，亦或几分钟来测试较大的变更。最后，对于系统中的每处修改都需要进行重复测试。&lt;/p&gt;
&lt;p&gt;反观单元测试，仅需毫秒级别且无需对系统自身了解过多。单元测试通过与否取决于测试运行器（test runner），而不是某个人。&lt;/p&gt;
&lt;h4&gt;2. 避免回归测试&lt;/h4&gt;
&lt;p&gt;回归缺陷是在对应用程序进行更改时引入的缺陷。测试人员不仅要测试他们的新特性，还要测试以前存在的特性，以验证之前实现的特性是否仍然像预期的那样运行。&lt;/p&gt;
&lt;p&gt;通过单元测试，可以在每次构建之后，即便是只修改了一行代码，重新运行整个测试流程，以确保新代码不会破坏已有功能。&lt;/p&gt;
&lt;h4&gt;3. 可执行的文档&lt;/h4&gt;
&lt;p&gt;有时对于特定的参数，方法的预期输出难以确定。你或许会问，如果向方法中传入空字符串或者null会发生什么？&lt;/p&gt;
&lt;p&gt;当编写具有良好命名的测试用例时，每个用例可以清晰的说明对于给定的输入会有怎样的输出。此外，测试用例还应可以验证方法是否能够正常工作。&lt;/p&gt;
&lt;h4&gt;4. 低耦合代码&lt;/h4&gt;
&lt;p&gt;编写单元测试可以降低代码耦合度，因为高耦合的代码将会使得单元测试变得困难重重。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;良好的单元测试应具备以下特征&lt;/span&gt;&lt;/h2&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;快速&lt;br/&gt;对于大型成熟项目可能会有数千个测试用例。每个测试用例应尽可能快的运行，最好在毫秒级别。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;隔离&lt;br/&gt;单元测试是独立的，可以单独运行而不依赖外部元素，如文件系统或数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可重复&lt;br/&gt;在不改变输入的情况下，单元测试的输出结果应保持不变。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自检查&lt;br/&gt;单元测试应自动检测测试是否通过而无需人工干预。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;耗时少&lt;br/&gt;如果测试代码所花费的时间远超编写代码的时间，应当考虑重构代码以便于更好测试。即，确保编写测试所花费的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;最佳实践&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;命名&lt;/h4&gt;
&lt;p&gt;测试用例命名应包含以下几部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;待测试方法的名称&lt;/li&gt;
&lt;li&gt;测试场景&lt;/li&gt;
&lt;li&gt;预期结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么这么做&lt;/p&gt;
&lt;p&gt;良好的命名可以表达测试意图 。测试不仅仅是用来检测代码是否可以正常工作，还可以提供方法的文档说明。仅仅看一组测试用例，你应该可以推断出代码的行为而无需查看代码。此外，当测试失败时，应该可以清楚的知道哪些场景不符合预期。&lt;/p&gt;
&lt;p&gt;Bad:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Fact]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test_Single()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stringCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actual = stringCalculator.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    Assert.Equal(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, actual);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Better&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Fact]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add_SingleNumber_ReturnsSameNumber()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stringCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actual = stringCalculator.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    Assert.Equal(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, actual);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h4&gt;编排你的测试代码(Arranging your tests)&lt;/h4&gt;
&lt;p&gt;整理(Arrange)、执行、断言是单元测试的通用模式，主要包含以下三个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建符合测试条件的对象&lt;/li&gt;
&lt;li&gt;在对象上执行操作（行为）&lt;/li&gt;
&lt;li&gt;断言行为结果是否符合预期&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么这么做&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试步骤清晰&lt;/li&gt;
&lt;li&gt;避免断言与行为代码耦合在一起&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可读性是编写测试代码时的一个重要指标。清晰明了的测试步骤可以清楚标明被测代码的依赖项，及如何调用被测代码，和行为预期结果。与其合并测试步骤以减少代码量，不如保持测试代码具有良好的可读性。&lt;/p&gt;
&lt;p&gt;Bad&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Fact]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add_EmptyString_ReturnsZero()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Arrange&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; stringCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Assert&lt;/span&gt;
    Assert.Equal(&lt;span&gt;0&lt;/span&gt;, stringCalculator.Add(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Better:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Fact]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add_EmptyString_ReturnsZero()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stringCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actual = stringCalculator.Add(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);

    Assert.Equal(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, actual);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h4&gt;单元测试粒度尽可能细（Write minimally passing tests)&lt;/h4&gt;
&lt;p&gt;单元测试的输入应尽可能简单以便验证当前测试行为。&lt;/p&gt;
&lt;p&gt;为什么这么做&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试用例可以灵活的应对被测代码的变更&lt;/li&gt;
&lt;li&gt;更接近于测试代码行为而非实现细节&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试用例中包含过多信息会增加测试出错的概率以及使得测试用例的意图不那么明显。测试代码的关注点是行为，给模型设置额外的属性或者使用非零值是非必需的。&lt;/p&gt;
&lt;p&gt;Bad&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Fact]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add_SingleNumber_ReturnsSameNumber()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stringCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actual = stringCalculator.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    Assert.Equal(&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;&lt;span&gt;, actual);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Better&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Fact]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add_SingleNumber_ReturnsSameNumber()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stringCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actual = stringCalculator.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    Assert.Equal(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, actual);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h4&gt;避免使用魔法字符串(magic strings)&lt;/h4&gt;
&lt;p&gt;单元测试中的变量命名和生成代码中的变量命名同等重要，它们不应包含魔法字符串。&lt;/p&gt;
&lt;p&gt;为什么这么做&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要让阅读测试代码的人对某个特殊值产生疑惑而不得不去阅读生产代码&lt;/li&gt;
&lt;li&gt;显式的表明你要证明的东西&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;魔法字符串会让阅读测试代码的人产生疑问，某个特定值到底表示什么意思。这会导致他们去阅读代码的具体实现细节而非关注测试本身。尽可能使用常量或枚举来代替字面量。&lt;/p&gt;
&lt;p&gt;Bad&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Fact]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add_BigNumber_ThrowsException()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stringCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();

    Action actual &lt;/span&gt;= () =&amp;gt; stringCalculator.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    Assert.Throws&lt;/span&gt;&amp;lt;OverflowException&amp;gt;&lt;span&gt;(actual);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Better&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Fact]
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add_MaximumSumResult_ThrowsOverflowException()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stringCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MAXIMUM_RESULT = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    Action actual &lt;/span&gt;= () =&amp;gt;&lt;span&gt; stringCalculator.Add(MAXIMUM_RESULT);

    Assert.Throws&lt;/span&gt;&amp;lt;OverflowException&amp;gt;&lt;span&gt;(actual);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h3&gt;测试用例中不要包含逻辑判断&lt;/h3&gt;
&lt;p&gt;避免在测试代码中进行手动字符串拼接和使用逻辑条件，如：if,while,for,switch等等。&lt;/p&gt;
&lt;p&gt;为什么这么做&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;避免在测试用例中引入BUG&lt;/li&gt;
&lt;li&gt;关注测试结果而不是实现细节&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在测试用引入逻辑判断会增加测试出错的概率。你应当充分信任自己的测试用例，当测试失败时就应该判定被测试代码有错误，这是不容忽视的（不应因为有逻辑分支到而至某些方面未测试到）。&lt;/p&gt;
&lt;p&gt;如果一个测试用例中无法避免使用逻辑分支，那么可以考虑将用例拆分为多个。&lt;/p&gt;
&lt;p&gt;Bad&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Fact]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add_MultipleNumbers_ReturnsCorrectResults()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stringCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; expected = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testCases = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
    {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0,0,0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0,1,2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1,2,3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    };

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; test &lt;span&gt;in&lt;/span&gt;&lt;span&gt; testCases)
    {
        Assert.Equal(expected, stringCalculator.Add(test));
        expected &lt;/span&gt;+= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Better&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Theory]
[InlineData(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0,0,0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)]
[InlineData(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0,1,2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)]
[InlineData(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1,2,3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Add_MultipleNumbers_ReturnsSumOfNumbers(&lt;span&gt;string&lt;/span&gt; input, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expected)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stringCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actual =&lt;span&gt; stringCalculator.Add(input);

    Assert.Equal(expected, actual);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h4&gt;使用帮助方法来构建和销毁测试依赖项&lt;/h4&gt;
&lt;p&gt;如果你的多个测试用例需要相似的对象或者状态，请使用帮助方法而不是&lt;code&gt;Setup&lt;/code&gt;和&lt;code&gt;Teardown&lt;/code&gt;特性来获取它们。&lt;/p&gt;
&lt;p&gt;为什么这么做&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是测试代码清晰易读&lt;/li&gt;
&lt;li&gt;避免在测试用例中创建不必要（或少创建）对象或状态&lt;/li&gt;
&lt;li&gt;避免在不同的测试用例中共享状态以降低测试用例间的相互依赖&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在单元测试框架中，&lt;code&gt;Setup&lt;/code&gt;方法在所有测试用例运行前被调用。这让&lt;code&gt;Setup&lt;/code&gt;方法看起来很有用（如初始化一些测试依赖项），但很有可能导致测试代码难以阅读。不同的测试用例需要不同的测试条件，但&lt;code&gt;Setup&lt;/code&gt;强制不同的测试用例使用相同的测试条件。&lt;/p&gt;
&lt;p&gt;xUnit框架在2.0+版本已经移出了&lt;code&gt;SetUp&lt;/code&gt;和&lt;code&gt;TearDown&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;Bad&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; StringCalculator stringCalculator;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StringCalculatorTests()
{
    stringCalculator &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; more tests...&lt;/span&gt;
&lt;span&gt;
[Fact]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add_TwoNumbers_ReturnsSumOfNumbers()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = stringCalculator.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0,1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    Assert.Equal(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, result);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Better&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Fact]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add_TwoNumbers_ReturnsSumOfNumbers()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stringCalculator =&lt;span&gt; CreateDefaultStringCalcualtor();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actual = stringCalculator.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0,1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    Assert.Equal(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, actual);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; more tests...&lt;/span&gt;

&lt;span&gt;private&lt;/span&gt;&lt;span&gt; StringCalculator CreateDefaultStringCalcualtor()
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h3&gt;避免在同一个测试用例中使用多个断言&lt;/h3&gt;
&lt;p&gt;一个测试中应只使用一个断言。通用的只使用一个断言的方法包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为每个断言编写一个测试&lt;/li&gt;
&lt;li&gt;使用参数化的测试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么这么做&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果有多个断言，一个断言失败，剩余的断言也不会被计算&lt;/li&gt;
&lt;li&gt;确保在一个测试不对多种场景做断言&lt;/li&gt;
&lt;li&gt;可以清晰明了的知道测试失败的原因&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一种例外情况是，对一个对象进行断言。在这种场景下可以使用多个断言来判断对象的不同属性值是否符合预期。&lt;/p&gt;
&lt;p&gt;Bad&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Fact]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add_EdgeCases_ThrowsArgumentExceptions()
{
    Assert.Throws&lt;/span&gt;&amp;lt;ArgumentException&amp;gt;(() =&amp;gt; stringCalculator.Add(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
    Assert.Throws&lt;/span&gt;&amp;lt;ArgumentException&amp;gt;(() =&amp;gt; stringCalculator.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Better&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[Theory]
[InlineData(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)]
[InlineData(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Add_InputNullOrAlphabetic_ThrowsArgumentException(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; input)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stringCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCalculator();

    Action actual &lt;/span&gt;= () =&amp;gt;&lt;span&gt; stringCalculator.Add(input);

    Assert.Throws&lt;/span&gt;&amp;lt;ArgumentException&amp;gt;&lt;span&gt;(actual);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h4&gt;通过测试公共方法来验证私有方法&lt;/h4&gt;
&lt;p&gt;在多数情况下，无需对私有方法进行测试。私有方法属于实现细节，它从来都不是孤立存在的（要不也没存在的必要）。通常，公共方法会调用私有方法，因此我们可以通过对共有方法的测试来验证私有方法是否符合我们的预期。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ParseLogLine(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; input)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sanitizedInput =&lt;span&gt; TrimInput(input);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sanitizedInput;
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; TrimInput(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; input)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; input.Trim();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于上述代码，或许会有人想直接对&lt;code&gt;TrimInput&lt;/code&gt;方法进行测试以确保该方法可以正常工作。然而，&lt;code&gt;ParseLogLine&lt;/code&gt;方法可能会以某种意料之外的方式调用&lt;code&gt;TrimInput&lt;/code&gt;方法而导致整个运行结果有误。&lt;/p&gt;
&lt;p&gt;正确的测试方式是面向公共方法&lt;code&gt;ParseLogLine&lt;/code&gt;，确保该方法能够正常工作才是我们最终要关心的。一个私有方法返回了正确的结果并不能保证调用者能够正确的使用这个结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ParseLogLine_ByDefault_ReturnsTrimmedResult()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parser = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Parser();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = parser.ParseLogLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; a &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    Assert.Equals(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, result);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h4&gt;存根静态引用&lt;/h4&gt;
&lt;p&gt;测试的原则之一是要完全控制测试所依赖的外部条件。这对于含有静态引用的生产代码而言会有些困难。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GetDiscountedPrice(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; price)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(DateTime.Now ==&lt;span&gt; DayOfWeek.Tuesday) 
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; price / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; price;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于上述代码你可能会编写如下测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetDiscountedPrice_ByDefault_ReturnsFullPrice()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; priceCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PriceCalculator();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actual = priceCalculator.GetDiscountedPrice(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

    Assert.Equals(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, actual)
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetDiscountedPrice_OnTuesday_ReturnsHalfPrice()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; priceCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PriceCalculator();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actual = priceCalculator.GetDiscountedPrice(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

    Assert.Equals(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, actual);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但，你很快会意识到这里有两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是在周二(Tuesday)运行测试代码，第二个测试会通过而第一个会失败&lt;/li&gt;
&lt;li&gt;如果测试是在其它日期运行，那么第一个测试会通过而第二个则会失败&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了解决上述问题，需要在生产代码中开一个口子。一种方法是使用接口，让生产代码依赖于接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IDateTimeProvider
{
    DayOfWeek DayOfWeek();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; GetDiscountedPrice(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; price, IDateTimeProvider dateTimeProvider)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dateTimeProvider.DayOfWeek() ==&lt;span&gt; DayOfWeek.Tuesday) 
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; price / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; price;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在测试场景变成了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetDiscountedPrice_ByDefault_ReturnsFullPrice()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; priceCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PriceCalculator();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dateTimeProviderStub = &lt;span&gt;new&lt;/span&gt; Mock&amp;lt;IDateTimeProvider&amp;gt;&lt;span&gt;();
    dateTimeProviderStub.Setup(dtp &lt;/span&gt;=&amp;gt;&lt;span&gt; dtp.DayOfWeek()).Returns(DayOfWeek.Monday);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actual = priceCalculator.GetDiscountedPrice(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, dateTimeProviderStub);

    Assert.Equals(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, actual);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetDiscountedPrice_OnTuesday_ReturnsHalfPrice()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; priceCalculator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PriceCalculator();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dateTimeProviderStub = &lt;span&gt;new&lt;/span&gt; Mock&amp;lt;IDateTimeProvider&amp;gt;&lt;span&gt;();
    dateTimeProviderStub.Setup(dtp &lt;/span&gt;=&amp;gt;&lt;span&gt; dtp.DayOfWeek()).Returns(DayOfWeek.Tuesday);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actual = priceCalculator.GetDiscountedPrice(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;, dateTimeProviderStub);

    Assert.Equals(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, actual);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，我们可以在测试中模拟任意的日期值了（完全控制）。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;本文根据自己的理解进行翻译，部分内容与原文会有出入。&lt;/p&gt;
&lt;p&gt;单元测试关注行为是否符合预期而不是具体实现细节，这也是面向对象的特征体现。&lt;/p&gt;
&lt;p&gt;上述一些最佳实践不仅仅可以用于测试代码，也可以用于其他方面代码的编写，如：确保代码具有良好的可读性、方法或变量要有良好的命名、方法要职责单一（高内聚）等等。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;书籍推荐&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;《Clean C#》这本书讲述了一些C#编码的良好规范，但这些规范也可用于其它语言。&lt;/p&gt;
</description>
<pubDate>Sun, 19 Aug 2018 07:37:00 +0000</pubDate>
<dc:creator>雪飞鸿</dc:creator>
<og:description>原文地址：Unit testing best practicesPS:本文未翻译原文的全部内容，以下为译文。 编写单元测试有如下好处： 利于回归测试 提供文档 改进代码设计 但是，难以阅读和维护的测试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cwj-XFH/p/9501414.html</dc:identifier>
</item>
<item>
<title>.NET Core 使用RabbitMQ - 莫问今朝乄</title>
<link>http://www.cnblogs.com/yan7/p/9498685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yan7/p/9498685.html</guid>
<description>&lt;h3&gt;1.什么是RabbitMQ&lt;/h3&gt;
&lt;p&gt;　　RabbitMQ是一个开源的,基于AMQP(Advanced Message Queuing Protocol)协议的完整,可复用的企业级消息队列(Message Queue 一种应用程序与应用程序之间的一种通信方法)系统,RabbitMQ可以实现点对点,发布订阅等消息处理模式&lt;/p&gt;
&lt;h3&gt;2.安装RabbitMQ&lt;/h3&gt;
&lt;p&gt;　　网上有许多RabbitMQ的安装博客,所以在此不介绍   &lt;a href=&quot;https://blog.csdn.net/qq_22075041/article/details/78855708&quot;&gt;LINUX安装&lt;/a&gt; &lt;a href=&quot;https://www.cnblogs.com/ericli-ericli/p/5902270.html&quot;&gt;WINDOWS安装&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-value&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-value&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;3..NET Core中使用RabbitMQ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-value&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-value&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;　　RabbitMQ从&lt;strong&gt;信息接收者角度&lt;/strong&gt;可以看做三种&lt;strong&gt;模式,一对一,一对多(此一对多并不是发布订阅，而是每条信息只有一个接收者)&lt;/strong&gt;和&lt;strong&gt;发布订阅。&lt;/strong&gt;其中一对一是&lt;strong&gt;简单队列模式&lt;/strong&gt;，一对多是Worker模式，而发布订阅包括发布订阅模式，路由模式和通配符模式，为什么说发布订阅模式包含三种模式呢，其实发布订阅，路由，通配符三种模式都是使用只是交换机(Exchange)类型不一致&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-value&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-value&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;3.1 简单队列&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-value&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-name&quot;&gt;&lt;span class=&quot;html-attribute-value&quot;&gt;&lt;span class=&quot;html-tag&quot;&gt;　　首先,我们需要创建两个控制台项目.Send(发送者)和Receive(接收者),然后为两个项目安装RabbitMQ.Client驱动&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
install-package rabbitmq.client
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后在Send和Receive项目中编写我们的消息队列代码&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;发送者代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_12e440e3-afff-4774-b0e1-a36b89c583d2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_12e440e3-afff-4774-b0e1-a36b89c583d2&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_12e440e3-afff-4774-b0e1-a36b89c583d2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Send
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            IConnectionFactory conFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConnectionFactory&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接工厂对象&lt;/span&gt;
&lt;span&gt;            {
                HostName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;47.104.206.56&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IP地址&lt;/span&gt;
                Port = &lt;span&gt;5672&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口号&lt;/span&gt;
                UserName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户账号&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IConnection con = conFactory.CreateConnection())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接对象&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IModel channel = con.CreateModel())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接会话对象&lt;/span&gt;
&lt;span&gt;                {
                    String queueName &lt;/span&gt;=&lt;span&gt; String.Empty;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        queueName &lt;/span&gt;= args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        queueName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;queue1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个队列&lt;/span&gt;
&lt;span&gt;                    channel.QueueDeclare(
                      queue: queueName,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息队列名称&lt;/span&gt;
                      durable: &lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否缓存&lt;/span&gt;
                      exclusive: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                      autoDelete: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                      arguments: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                       );
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息内容:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        String message &lt;/span&gt;=&lt;span&gt; Console.ReadLine();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息内容&lt;/span&gt;
                        &lt;span&gt;byte&lt;/span&gt;[] body =&lt;span&gt; Encoding.UTF8.GetBytes(message);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送消息&lt;/span&gt;
                        channel.BasicPublish(exchange: &lt;span&gt;&quot;&quot;&lt;/span&gt;, routingKey: queueName, basicProperties: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, body: body);
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成功发送消息:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; message);
                    }
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到RabbitMQ使用了IConnectionFactory,IConnection和IModel来创建链接和通信管道,IConnection实例对象只负责与Rabbit的连接,而发送接收这些实际操作全部由会话通道进行,&lt;/p&gt;
&lt;p&gt;　　而后使用QueneDeclare方法进行创建消息队列,创建完成后可以在RabbitMQ的管理工具中看到此队列，QueneDelare方法需要一个消息队列名称的必须参数.后面那些参数则代表缓存,参数等信息.&lt;/p&gt;
&lt;p&gt;　　最后使用BasicPublish来发送消息,在一对一中&lt;strong&gt;routingKey&lt;/strong&gt;必须和 &lt;strong&gt;queueName&lt;/strong&gt;一致&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;接收者代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_b06e8055-0cd6-401a-a168-09ae77cc10fb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b06e8055-0cd6-401a-a168-09ae77cc10fb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b06e8055-0cd6-401a-a168-09ae77cc10fb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client.Events;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Receive1
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            IConnectionFactory connFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConnectionFactory&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接工厂对象&lt;/span&gt;
&lt;span&gt;            {
                HostName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;47.104.206.56&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IP地址&lt;/span&gt;
                Port = &lt;span&gt;5672&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口号&lt;/span&gt;
                UserName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户账号&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IConnection conn =&lt;span&gt; connFactory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IModel channel =&lt;span&gt; conn.CreateModel())
                {
                    String queueName &lt;/span&gt;=&lt;span&gt; String.Empty;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        queueName &lt;/span&gt;= args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        queueName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;queue1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个队列&lt;/span&gt;
&lt;span&gt;                    channel.QueueDeclare(
                      queue: queueName,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息队列名称&lt;/span&gt;
                      durable: &lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否缓存&lt;/span&gt;
                      exclusive: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                      autoDelete: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                      arguments: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                       );
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建消费者对象&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(channel);
                    consumer.Received &lt;/span&gt;+= (model, ea) =&amp;gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] message = ea.Body;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到的消息&lt;/span&gt;
                        Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到信息为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Encoding.UTF8.GetString(message));
                    };
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消费者开启监听&lt;/span&gt;
                    channel.BasicConsume(queue: queueName, autoAck: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, consumer: consumer);
                    Console.ReadKey();
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　在接收者中是定义一个EventingBasicConsumer对象的消费者(接收者),这个消费者与会话对象关联,&lt;/p&gt;
&lt;p&gt;　　然后定义接收事件,输出从消息队列中接收的数据,&lt;/p&gt;
&lt;p&gt;　　最后使用会话对象的BasicConsume方法来启动消费者监听.消费者的定义也是如此简单.&lt;/p&gt;
&lt;p&gt;　　不过注意一点,可以看到在接收者代码中也有声明队列的方法,其实这句代码可以去掉,但是如果去掉的话接收者在程序启动时监听队列,而此时这个队列还未存在,所以会出异常,所以往往会在消费者中也添加一个声明队列方法&lt;/p&gt;
&lt;p&gt;　　此时,简单消息队列传输就算写好了,我们可以运行代码就行测试&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819010210780-660428967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819010220581-1437422575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.2 Worker模式&lt;/h4&gt;
&lt;p&gt;　　Worker模式其实是一对多的模式,但是这个一对多并不是像发布订阅那种,而是信息以顺序的传输给每个接收者,我们可以使用上个例子来运行worker模式甚至,只需要运行多个接收者即可&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819010113228-630333946.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819010054764-1048420335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819010132783-2144320833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到运行两个接收者,然后发送者发送了1-5这五个消息,第一个接收者接收的是奇数,而第二个接收者接收的是偶数,但是现在的worker存在这很大的问题,&lt;/p&gt;
&lt;p&gt;　　　　1.丢失数据:一旦其中一个宕机,那么另外接收者的无法接收原本这个接收者所要接收的数据&lt;/p&gt;
&lt;p&gt;　　　　2.无法实现能者多劳:如果其中的接收者接收的较慢,那么便会极大的浪费性能,所以需要实现接收快的多接收&lt;/p&gt;
&lt;p&gt;　　下面针对上面的两个问题进行处理&lt;/p&gt;
&lt;p&gt;　　首先我们先来看一下所说的宕机丢失数据一说,我们在上个例子Receive接收事件中添加线程等待&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 consumer.Received += (model, ea) =&amp;gt;&lt;span&gt;
                    {
                        Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待1秒,&lt;/span&gt;
                        &lt;span&gt;byte&lt;/span&gt;[] message = ea.Body;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到的消息&lt;/span&gt;
                        Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到信息为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Encoding.UTF8.GetString(message));
                    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后再次启动两个接收者进行测试&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819010256895-123741110.png&quot; alt=&quot;&quot;/&gt;　　　　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819010323003-503189677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819001754315-76975242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到发送者发送了1-9的数字,第二个接收者在接收数据途中宕机,第一个接收者也并没有去接收第二个接收者宕机后的数据,有的时候我们会有当接收者宕机后,其余数据交给其它接收者进行消费,那么该怎么进行处理呢,解决这个问题得方法就是改变其消息确认模式&lt;/p&gt;
&lt;p&gt;　　在Rabbit中存在两种消息确认模式,&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;自动确认&lt;/strong&gt;:只要消息从队列获取,无论消费者获取到消息后是否成功消费,都认为是消息成功消费,也就是说上面第二个接收者其实已经消费了它所接收的数据&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;手动确认&lt;/strong&gt;:消费从队列中获取消息后,服务器会将该消息处于不可用状态,等待消费者反馈&lt;/p&gt;
&lt;p&gt;　　也就是说我们只要将消息确认模式改为手动即可,改为手动确认方式只需改两处,1.开启监听时将&lt;strong&gt;autoAck&lt;/strong&gt;参数改为false,2.消息消费成功后返回确认&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 consumer.Received += (model, ea) =&amp;gt;&lt;span&gt;
                    {
                        Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待1秒,&lt;/span&gt;
                        &lt;span&gt;byte&lt;/span&gt;[] message = ea.Body;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到的消息&lt;/span&gt;
                        Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到信息为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Encoding.UTF8.GetString(message));
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回消息确认&lt;/span&gt;
                        channel.BasicAck(ea.DeliveryTag, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    };
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消费者开启监听
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将autoAck设置false 关闭自动确认&lt;/span&gt;
                    channel.BasicConsume(queue: queueName, autoAck: &lt;span&gt;false&lt;/span&gt;, consumer: consumer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后再次测试便会出现下面结果&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819010420712-1280053384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819010437299-1983214341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　能者多劳是建立在手动确认基础上,下面修改一下代码中等待的时间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 consumer.Received += (model, ea) =&amp;gt;&lt;span&gt;
                    {
                        Thread.Sleep((&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Random().Next(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;))*&lt;span&gt;1000&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机等待,实现能者多劳,&lt;/span&gt;
                        &lt;span&gt;byte&lt;/span&gt;[] message = ea.Body;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到的消息&lt;/span&gt;
                        Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到信息为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Encoding.UTF8.GetString(message));
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回消息确认&lt;/span&gt;
                        channel.BasicAck(ea.DeliveryTag, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后只需要再添加&lt;strong&gt;BasicQos&lt;/strong&gt;方法即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个队列&lt;/span&gt;
&lt;span&gt;                    channel.QueueDeclare(
                      queue: queueName,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息队列名称&lt;/span&gt;
                      durable: &lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否缓存&lt;/span&gt;
                      exclusive: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                      autoDelete: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                      arguments: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                       );
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;告诉Rabbit每次只能向消费者发送一条信息,再消费者未确认之前,不再向他发送信息&lt;/span&gt;
                    channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819005028210-143832045.png&quot; alt=&quot;&quot;/&gt;　　　　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819010527828-924331460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到此时已实现能者多劳&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;worker模式接收者完整代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_3dbdb6a6-cdb4-445d-97f2-271455ebac08&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3dbdb6a6-cdb4-445d-97f2-271455ebac08&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3dbdb6a6-cdb4-445d-97f2-271455ebac08&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client.Events;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Receive1
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            IConnectionFactory connFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConnectionFactory&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接工厂对象&lt;/span&gt;
&lt;span&gt;            {
                HostName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;47.104.206.56&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IP地址&lt;/span&gt;
                Port = &lt;span&gt;5672&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口号&lt;/span&gt;
                UserName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户账号&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IConnection conn =&lt;span&gt; connFactory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IModel channel =&lt;span&gt; conn.CreateModel())
                {
                    String queueName &lt;/span&gt;=&lt;span&gt; String.Empty;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        queueName &lt;/span&gt;= args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        queueName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;queue1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个队列&lt;/span&gt;
&lt;span&gt;                    channel.QueueDeclare(
                      queue: queueName,&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息队列名称&lt;/span&gt;
                      durable: &lt;span&gt;false&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否缓存&lt;/span&gt;
                      exclusive: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                      autoDelete: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                      arguments: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
                       );
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;告诉Rabbit每次只能向消费者发送一条信息,再消费者未确认之前,不再向他发送信息&lt;/span&gt;
                    channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建消费者对象&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(channel);
                    consumer.Received &lt;/span&gt;+= (model, ea) =&amp;gt;&lt;span&gt;
                    {
                        Thread.Sleep((&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Random().Next(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;))*&lt;span&gt;1000&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;随机等待,实现能者多劳,&lt;/span&gt;
                        &lt;span&gt;byte&lt;/span&gt;[] message = ea.Body;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到的消息&lt;/span&gt;
                        Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到信息为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Encoding.UTF8.GetString(message));
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回消息确认&lt;/span&gt;
                        channel.BasicAck(ea.DeliveryTag, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    };
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消费者开启监听
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将autoAck设置false 关闭自动确认&lt;/span&gt;
                    channel.BasicConsume(queue: queueName, autoAck: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, consumer: consumer);
                    Console.ReadKey();
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;3.3 Exchange模式(发布订阅模式,路由模式,通配符模式)&lt;/h4&gt;
&lt;p&gt; 　　前面说过发布,路由,通配符这三种模式其实可以算为一种模式，区别仅仅是交互机类型不同.在这里出现了一个交换机的东西，发送者将消息发送发送到交换机，接收者创建各自的消息队列绑定到交换机，&lt;/p&gt;
&lt;p&gt;　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819134715685-537361999.png&quot; alt=&quot;&quot;/&gt;    发布订阅模式&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819134526075-725378345.png&quot; alt=&quot;&quot;/&gt;   路由模式        &lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819134546368-1304949252.png&quot; alt=&quot;&quot;/&gt;   通配符模式&lt;/p&gt;
&lt;p&gt;　　通过上面三幅图可以看出这三种模式本质就是一种订阅模式，路由，通配符模式只是订阅模式的变种模式。使其可以选择发送订阅者中的接收者。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;注意&lt;/strong&gt;：交换机本身并不存储数据，数据存储在消息队列中，所以如果向没有绑定消息队列的交换机中发送信息，那么信息将会丢失&lt;/p&gt;
&lt;p&gt;　　下面依次来看一下这三种模式&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;&lt;strong&gt;发布订阅模式(fanout)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;发送者代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_c9fa9b80-4399-420f-8681-3a00cebd0d02&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c9fa9b80-4399-420f-8681-3a00cebd0d02&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c9fa9b80-4399-420f-8681-3a00cebd0d02&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Send3
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            IConnectionFactory connFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConnectionFactory&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接工厂对象&lt;/span&gt;
&lt;span&gt;            {
                HostName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;47.104.206.56&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IP地址&lt;/span&gt;
                Port = &lt;span&gt;5672&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口号&lt;/span&gt;
                UserName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户账号&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IConnection conn =&lt;span&gt; connFactory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;(IModel channel =&lt;span&gt; conn.CreateModel())
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机名称&lt;/span&gt;
                    String exchangeName =&lt;span&gt; String.Empty;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        exchangeName &lt;/span&gt;= args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        exchangeName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exchange1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明交换机&lt;/span&gt;
                    channel.ExchangeDeclare(exchange: exchangeName, type: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fanout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息内容:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        String message &lt;/span&gt;=&lt;span&gt; Console.ReadLine();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息内容&lt;/span&gt;
                        &lt;span&gt;byte&lt;/span&gt;[] body =&lt;span&gt; Encoding.UTF8.GetBytes(message);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送消息&lt;/span&gt;
                        channel.BasicPublish(exchange: exchangeName, routingKey: &lt;span&gt;&quot;&quot;&lt;/span&gt;, basicProperties: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, body: body);
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成功发送消息:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; message);
                    }
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　发送者代码与上面没有什么差异，只是由上面的消息队列声明变成了交换机声明(交换机类型为fanout)，也就说发送者发送消息从原来的直接发送消息队列变成了发送到交换机&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;接收者代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_2b356241-4dd8-4c44-b7d3-667b77d9cd06&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2b356241-4dd8-4c44-b7d3-667b77d9cd06&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2b356241-4dd8-4c44-b7d3-667b77d9cd06&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client.Events;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Receive3
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个随机数,以创建不同的消息队列&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; random = &lt;span&gt;new&lt;/span&gt; Random().Next(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;random.ToString());
            IConnectionFactory connFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConnectionFactory&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接工厂对象&lt;/span&gt;
&lt;span&gt;            {
                HostName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;47.104.206.56&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IP地址&lt;/span&gt;
                Port = &lt;span&gt;5672&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口号&lt;/span&gt;
                UserName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户账号&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IConnection conn =&lt;span&gt; connFactory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IModel channel =&lt;span&gt; conn.CreateModel())
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机名称&lt;/span&gt;
                    String exchangeName =&lt;span&gt; String.Empty;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        exchangeName &lt;/span&gt;= args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        exchangeName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exchange1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明交换机&lt;/span&gt;
                    channel.ExchangeDeclare(exchange: exchangeName, type: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fanout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息队列名称&lt;/span&gt;
                    String queueName = exchangeName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; random.ToString();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明队列&lt;/span&gt;
                    channel.QueueDeclare(queue: queueName, durable: &lt;span&gt;false&lt;/span&gt;, exclusive: &lt;span&gt;false&lt;/span&gt;, autoDelete: &lt;span&gt;false&lt;/span&gt;, arguments: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将队列与交换机进行绑定&lt;/span&gt;
                    channel.QueueBind(queue: queueName, exchange: exchangeName,routingKey:&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明为手动确认&lt;/span&gt;
                    channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义消费者&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(channel);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收事件&lt;/span&gt;
                    consumer.Received += (model, ea) =&amp;gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] message = ea.Body;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到的消息&lt;/span&gt;
                        Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到信息为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Encoding.UTF8.GetString(message));
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回消息确认&lt;/span&gt;
                        channel.BasicAck(ea.DeliveryTag, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    };
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启监听&lt;/span&gt;
                    channel.BasicConsume(queue: queueName, autoAck: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, consumer: consumer);
                    Console.ReadKey();
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　可以看到接收者代码与上面有些差异&lt;/p&gt;
&lt;p&gt;　　首先是声明交换机(同上面一样，为了防止异常)&lt;/p&gt;
&lt;p&gt;　　然后声明消息队列并对交换机进行绑定，在这里使用了随机数，目的是声明不重复的消息队列，如果是同一个消息队列，则就变成worker模式，也就是说对于发布订阅模式有多少接收者就有多少个消息队列，而这些消息队列共同从一个交换机中获取数据&lt;/p&gt;
&lt;p&gt;　　然后同时开两个接收者，结果就如下&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819142932672-1940495149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819144339272-1988508466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819144401346-97945597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;em&gt;路由模式(direct)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;　　&lt;/em&gt;&lt;/strong&gt;上面说过路由模式是订阅模式的一个变种模式，以路由进行匹配发送，例如将消息1发送给A,B两个消息队列，或者将消息2发送给B,C两个消息队列，路由模式的交换机是&lt;strong&gt;direct&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　发送者代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_4c0737f3-849b-4a15-b46e-d4410683c84a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4c0737f3-849b-4a15-b46e-d4410683c84a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4c0737f3-849b-4a15-b46e-d4410683c84a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Send3
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.Length == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;args&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            IConnectionFactory connFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConnectionFactory&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接工厂对象&lt;/span&gt;
&lt;span&gt;            {
                HostName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;47.104.206.56&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IP地址&lt;/span&gt;
                Port = &lt;span&gt;5672&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口号&lt;/span&gt;
                UserName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户账号&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IConnection conn =&lt;span&gt; connFactory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt;(IModel channel =&lt;span&gt; conn.CreateModel())
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机名称&lt;/span&gt;
                    String exchangeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exchange2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由名称&lt;/span&gt;
                    String routeKey = args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明交换机   路由交换机类型direct&lt;/span&gt;
                    channel.ExchangeDeclare(exchange: exchangeName, type: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                    {
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息内容:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        String message &lt;/span&gt;=&lt;span&gt; Console.ReadLine();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息内容&lt;/span&gt;
                        &lt;span&gt;byte&lt;/span&gt;[] body =&lt;span&gt; Encoding.UTF8.GetBytes(message);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送消息  发送到路由匹配的消息队列中&lt;/span&gt;
                        channel.BasicPublish(exchange: exchangeName, routingKey: routeKey, basicProperties: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, body: body);
                        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成功发送消息:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; message);
                    }
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　发送者代码相比上面只改了两处&lt;/p&gt;
&lt;p&gt;　　　　1.将交换机类型改为了direct类型&lt;/p&gt;
&lt;p&gt;　　　　2.将运行时的第一个参数改成了路由名称，然后发送数据时由指定路由的消息队列进行获取数据&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;接收者代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_5d14c530-677f-4fc3-938f-ff290c3b08e4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5d14c530-677f-4fc3-938f-ff290c3b08e4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5d14c530-677f-4fc3-938f-ff290c3b08e4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; RabbitMQ.Client.Events;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Receive3
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args.Length == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;args&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个随机数,以创建不同的消息队列&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; random = &lt;span&gt;new&lt;/span&gt; Random().Next(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;random.ToString());
            IConnectionFactory connFactory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConnectionFactory&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接工厂对象&lt;/span&gt;
&lt;span&gt;            {
                HostName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;47.104.206.56&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IP地址&lt;/span&gt;
                Port = &lt;span&gt;5672&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口号&lt;/span&gt;
                UserName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户账号&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IConnection conn =&lt;span&gt; connFactory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (IModel channel =&lt;span&gt; conn.CreateModel())
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机名称&lt;/span&gt;
                    String exchangeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exchange2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明交换机&lt;/span&gt;
                    channel.ExchangeDeclare(exchange: exchangeName, type:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;direct&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息队列名称&lt;/span&gt;
                    String queueName = exchangeName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; random.ToString();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明队列&lt;/span&gt;
                    channel.QueueDeclare(queue: queueName, durable: &lt;span&gt;false&lt;/span&gt;, exclusive: &lt;span&gt;false&lt;/span&gt;, autoDelete: &lt;span&gt;false&lt;/span&gt;, arguments: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将队列与交换机进行绑定&lt;/span&gt;
                    &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; routeKey &lt;span&gt;in&lt;/span&gt;&lt;span&gt; args)
                    {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;匹配多个路由&lt;/span&gt;
&lt;span&gt;                        channel.QueueBind(queue: queueName, exchange: exchangeName, routingKey: routeKey);
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明为手动确认&lt;/span&gt;
                    channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义消费者&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(channel);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收事件&lt;/span&gt;
                    consumer.Received += (model, ea) =&amp;gt;&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] message = ea.Body;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到的消息&lt;/span&gt;
                        Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到信息为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Encoding.UTF8.GetString(message));
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回消息确认&lt;/span&gt;
                        channel.BasicAck(ea.DeliveryTag, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    };
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启监听&lt;/span&gt;
                    channel.BasicConsume(queue: queueName, autoAck: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, consumer: consumer);
                    Console.ReadKey();
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 　　在接收者代码中的改动点也是与发送者一致，但是&lt;strong&gt;一个接收者消息队列可以声明多个路由与交换机进行绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　运行情况如下&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819150606721-2057480812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819150714957-836484223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819150748938-1284815287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通配符模式(topic)&lt;/p&gt;
&lt;p&gt;　　通配符模式与路由模式一致，只不过通配符模式中的路由可以声明为模糊查询，RabbitMQ拥有两个通配符&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;#&lt;/span&gt;：匹配0-n个字符语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;&lt;span&gt;*&lt;/span&gt;：匹配一个字符语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;注意：RabbitMQ中通配符并不像正则中的单个字符，而是一个以“.”分割的字符串，如 ”topic1.*“匹配的规则以topic1开始并且&quot;.&quot;后只有一段语句的路由  例：“topic1.aaa”，“topic1.bb”&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;发送者代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_9b6d86e1-8f8a-4769-8163-593c817b4b49&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9b6d86e1-8f8a-4769-8163-593c817b4b49&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9b6d86e1-8f8a-4769-8163-593c817b4b49&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机名称&lt;/span&gt;
String exchangeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exchange3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由名称&lt;/span&gt;
String routeKey = args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明交换机   通配符类型为topic&lt;/span&gt;
channel.ExchangeDeclare(exchange: exchangeName, type: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;topic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
{
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息内容:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    String message &lt;/span&gt;=&lt;span&gt; Console.ReadLine();
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息内容&lt;/span&gt;
     &lt;span&gt;byte&lt;/span&gt;[] body =&lt;span&gt; Encoding.UTF8.GetBytes(message);
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送消息  发送到路由匹配的消息队列中&lt;/span&gt;
     channel.BasicPublish(exchange: exchangeName, routingKey: routeKey, basicProperties: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, body: body);
     Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成功发送消息:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; message);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 　　修改了两点：&lt;strong&gt;交换机名称&lt;/strong&gt;（每个交换机只能声明一种类型，如果还用exchang2的话就会出异常），交换机类型改为&lt;strong&gt;topic&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　接收者代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_90922789-8277-46da-8093-2c6d68b1d344&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_90922789-8277-46da-8093-2c6d68b1d344&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_90922789-8277-46da-8093-2c6d68b1d344&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换机名称&lt;/span&gt;
String exchangeName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exchange3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明交换机    通配符类型为topic&lt;/span&gt;
channel.ExchangeDeclare(exchange: exchangeName, type:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;topic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息队列名称&lt;/span&gt;
String queueName = exchangeName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; random.ToString();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明队列&lt;/span&gt;
channel.QueueDeclare(queue: queueName, durable: &lt;span&gt;false&lt;/span&gt;, exclusive: &lt;span&gt;false&lt;/span&gt;, autoDelete: &lt;span&gt;false&lt;/span&gt;, arguments: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将队列与交换机进行绑定&lt;/span&gt;
&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; routeKey &lt;span&gt;in&lt;/span&gt;&lt;span&gt; args)
{&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;匹配多个路由&lt;/span&gt;
&lt;span&gt;    channel.QueueBind(queue: queueName, exchange: exchangeName, routingKey: routeKey);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明为手动确认&lt;/span&gt;
channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义消费者&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(channel);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收事件&lt;/span&gt;
consumer.Received += (model, ea) =&amp;gt;&lt;span&gt;
{
   &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] message = ea.Body;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到的消息&lt;/span&gt;
   Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到信息为:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; Encoding.UTF8.GetString(message));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回消息确认&lt;/span&gt;
    channel.BasicAck(ea.DeliveryTag, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启监听&lt;/span&gt;
channel.BasicConsume(queue: queueName, autoAck: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, consumer: consumer);
Console.ReadKey();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　接收者修改与发送者一致&lt;/p&gt;
&lt;p&gt;　　运行结果如下&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819153523798-523366247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819153542337-117054363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1147658/201808/1147658-20180819153555692-293040659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;







</description>
<pubDate>Sun, 19 Aug 2018 07:36:00 +0000</pubDate>
<dc:creator>莫问今朝乄</dc:creator>
<og:description>1.什么是RabbitMQ RabbitMQ是一个开源的,基于AMQP(Advanced Message Queuing Protocol)协议的完整,可复用的企业级消息队列(Message Queu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yan7/p/9498685.html</dc:identifier>
</item>
<item>
<title>Refit在ASP.NET Core中的实践 - Catcher8</title>
<link>http://www.cnblogs.com/catcher1994/p/9501387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/catcher1994/p/9501387.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;声名式服务调用，己经不算是一个新鲜的话题了，毕竟都出来好些年了。&lt;/p&gt;
&lt;p&gt;下面谈谈，最近项目中用到一个这样的组件的简单实践。&lt;/p&gt;
&lt;p&gt;目前部分项目用到的是&lt;a href=&quot;https://github.com/reactiveui/refit&quot;&gt;Refit&lt;/a&gt;这个组件，都是配合HttpClientFactory来使用的。&lt;/p&gt;
&lt;p&gt;关于HttpClientFactory的一些简单介绍，可以参见官方文档，也可以看看前面的两篇比较粗略的相关介绍。&lt;/p&gt;
&lt;p&gt;也简单介绍一下背景，目前主要有两类的API接口：&lt;/p&gt;
&lt;p&gt;第一类是注册到Eureka中的，可以通过服务发现的方式来请求的，这里的都是新的接口。&lt;/p&gt;
&lt;p&gt;第二类是原始的接口，不能走服务发现，只能通过直连请求的方式来调用，这里的都是些老接口。&lt;/p&gt;
&lt;p&gt;换句话就是说，要同时兼容这两类接口。&lt;/p&gt;
&lt;p&gt;由于用HttpClientFactory集成服务发现十分简单，所以优先选了一个本身就带有HttpClientFactory的组件--Refit。&lt;/p&gt;
&lt;h2 id=&quot;什么是refit&quot;&gt;什么是Refit&lt;/h2&gt;
&lt;p&gt;Refit是一个自动类型安全的REST库，是RESTful架构的.NET客户端实现，&lt;/p&gt;
&lt;p&gt;它基于Attribute，提供了把REST API返回的数据转化为(Plain Ordinary C# Object,简单C#对象)，POCO to JSON，网络请求(POST，GET,PUT，DELETE等)封装，内部封装使用HttpClient,前者专注于接口的封装，后者专注于网络请求的高效，二者分工协作。&lt;/p&gt;
&lt;p&gt;我们的应用程序通过 refit请求网络，实际上是使用 refit接口层封装请求参数、Header、Url 等信息，之后由 HttpClient完成后续的请求操作，在服务端返回数据之后，HttpClient将原始的结果交给 refit，后者根据用户的需求对结果进行解析的过程。&lt;/p&gt;
&lt;p&gt;更多细节可以参考Refit的&lt;a href=&quot;https://reactiveui.github.io/refit/&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建一个可调用的api接口&quot;&gt;创建一个可调用的API接口&lt;/h2&gt;
&lt;p&gt;直接上控制器的代码了〜〜&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;// GET: api/persons
[HttpGet]
public IEnumerable&amp;lt;Person&amp;gt; Get()
{
    return new List&amp;lt;Person&amp;gt;
    {
        new Person{Id = 1 , Name = &quot;catcher wong&quot;, CreateTime = DateTime.Now},
        new Person{Id = 2 , Name = &quot;james li&quot;, CreateTime = DateTime.Now.AddDays(-2)}
    };
}

// GET api/persons/5
[HttpGet(&quot;{id}&quot;)]
public Person Get(int id)
{
    return new Person { Id = id, Name = &quot;name&quot; };
}

// POST api/persons
[HttpPost]
public Person Post([FromBody]Person person)
{
    if (person == null) return new Person();

    return new Person { Id = person.Id, Name = person.Name };
}

// PUT api/persons/5
[HttpPut]
public string Put([FromBody]int id)
{
    return $&quot;put {id}&quot;;
}

// DELETE api/persons/5
[HttpDelete(&quot;{id}&quot;)]
public string Delete(int id)
{
    return $&quot;del {id}&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;refit的使用&quot;&gt;Refit的使用&lt;/h2&gt;
&lt;p&gt;先通过Nuget安装Refit的包。&lt;/p&gt;
&lt;p&gt;然后就是定义我们的interface了&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public interface IPersonsApi
{
    [Get(&quot;/api/persons&quot;)]
    Task&amp;lt;List&amp;lt;Person&amp;gt;&amp;gt; GetPersonsAsync();

    [Get(&quot;/api/persons/{id}&quot;)]
    Task&amp;lt;Person&amp;gt; GetPersonAsync([AliasAs(&quot;id&quot;)]int personId);

    [Post(&quot;/api/persons&quot;)]
    Task&amp;lt;Person&amp;gt; AddPersonAsync([Body]Person person);

    [Put(&quot;/api/persons&quot;)]
    Task&amp;lt;string&amp;gt; EditPersonAsync([Body]int id);

    [Delete(&quot;/api/persons/{id}&quot;)]
    Task&amp;lt;string&amp;gt; DeletePersonAsync(int id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看看这个interface里面涉及到的部分内容。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Get,Post等特性就表明了接口的请求方式，后面的值就是请求的相对路径。&lt;/li&gt;
&lt;li&gt;相对路径中，可以使用占位符，来动态更新参数值。&lt;/li&gt;
&lt;li&gt;如果方法名和请求参数名不一致，需要用AliasAs指明。&lt;/li&gt;
&lt;li&gt;通过Body特性声明一个对象作为请求体发送到服务器&lt;/li&gt;
&lt;li&gt;返回值定义是Task或者IObservable&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后是配合HttpClientFactory&lt;/p&gt;
&lt;p&gt;再通过Nuget安装一下&lt;strong&gt;Refit.HttpClientFactory&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果PersonApi是注册到Euerka的，可以再添加Steeltoe的引用。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddRefitClient&amp;lt;IPersonsApi&amp;gt;()
            .ConfigureHttpClient(options =&amp;gt;
            {
                options.BaseAddress = new Uri(Configuration.GetValue&amp;lt;string&amp;gt;(&quot;personapi_url&quot;));
                //other settings of httpclient
            })
            //Steeltoe discovery
            //.AddHttpMessageHandler&amp;lt;DiscoveryHttpMessageHandler&amp;gt;()
            ;

    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面在定义IPersonApi的时候，我们只指定了相对路径，而请求IP并没有指定，这里是放到ConfigureHttpClient里面去指定了。&lt;/p&gt;
&lt;p&gt;同时根据不同环境，配置不同的appsettings.{env}.json，达到切换的效果。&lt;/p&gt;
&lt;p&gt;同样的，如果想走服务发现，只需要放开注释的AddHttpMessageHandler，同时修改BaseeAddress为服务名的形式就可以了。&lt;/p&gt;
&lt;p&gt;说了这么多，都还只是配置阶段，下面就来看看具体怎么用。&lt;/p&gt;
&lt;p&gt;为了演示方便，就不在建一个Service层了，直接在控制器调用一下。&lt;/p&gt;
&lt;p&gt;用法也很简单，直接在控制器注入一下就可以使用了。&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;[Route(&quot;api/[controller]&quot;)]
[ApiController]
public class ValuesController : ControllerBase
{
    private readonly IPersonsApi _api;
    public ValuesController(IPersonsApi api)
    {
        this._api = api;
    }

    // GET api/values
    [HttpGet]
    public async Task&amp;lt;List&amp;lt;Person&amp;gt;&amp;gt; GetAsync()
    {
        return await _api.GetPersonsAsync();                             
    }

    // GET api/values/5
    [HttpGet(&quot;{id}&quot;)]
    public async Task&amp;lt;Person&amp;gt; Get(int id)
    {
        return await _api.GetPersonAsync(id);
    }

    // POST api/values
    [HttpPost]
    public async Task&amp;lt;Person&amp;gt; Post([FromBody] Person value)
    {
        return await _api.AddPersonAsync(value);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，代码层面的东西已经处理完了。&lt;/p&gt;
&lt;p&gt;下面来看看使用Refit效果(这里只看两个Get请求的)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/558945/201808/558945-20180819152741307-1861114180.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/558945/201808/558945-20180819152726729-1025129100.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;都是能正常拿到我们期望的结果。&lt;/p&gt;
&lt;p&gt;最后再看看输出的日志，确认一下。&lt;/p&gt;
&lt;p&gt;首先是访问&lt;code&gt;/api/values&lt;/code&gt;的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/558945/201808/558945-20180819152707290-1364533722.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确确实实是向我们前面的PersonApi发起了请求。&lt;/p&gt;
&lt;p&gt;然后是访问&lt;code&gt;/api/values/5555&lt;/code&gt; 的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/558945/201808/558945-20180819152611854-1730767775.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见我们上面的别名(AliasAs)是起了效果的，能拼成正确的请求地址。&lt;/p&gt;
&lt;p&gt;至于其他类型的请求，这里就不演示了，让大家自己去尝试一下吧。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Refit用起来还是比较简单的，运行了一段时间也还表现正常！&lt;/p&gt;
&lt;p&gt;当然本文介绍的也只是一些基本的用法！它还具有不错的扩展性，可以让我们根据自身需求做一些定制化的东西。&lt;/p&gt;
&lt;p&gt;本文的示例代码&lt;a href=&quot;https://github.com/catcherwong/Demos/tree/master/src/CallAPIsDemo/RefitClientApi&quot;&gt;RefitClientApi&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Aug 2018 07:34:00 +0000</pubDate>
<dc:creator>Catcher8</dc:creator>
<og:description>使用Refit结合HttpClientFactory来进行API的调用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/catcher1994/p/9501387.html</dc:identifier>
</item>
<item>
<title>动手实现react Modal组件 - 陈陈jg</title>
<link>http://www.cnblogs.com/chenjg/p/9501333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenjg/p/9501333.html</guid>
<description>&lt;p&gt;长话不多说，接下来让我们来动手实现一个react Modal组件。&lt;/p&gt;
&lt;p&gt;我们先来看一下&lt;a href=&quot;https://chenjigeng.github.io/example/modal/index.html&quot;&gt;实际效果&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;modal的布局&quot;&gt;Modal的布局&lt;/h4&gt;
&lt;p&gt;首先，让我们先思考下一个Modal组件的布局是怎么样的。&lt;/p&gt;
&lt;p&gt;我们先拿一个基本的Modal样例来分析下。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/993343/201808/993343-20180819151138676-458196957.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，一个Modal组件可以分为mask、header、body和footer四部分，mask就不用说了，header主要是显示title和关闭按钮，body则是使用者自己传的内容，footer主要是按钮控件。&lt;/p&gt;
&lt;h4 id=&quot;modal组件的参数props&quot;&gt;Modal组件的参数(props)&lt;/h4&gt;
&lt;p&gt;我们确定了Modal组件的布局之后，我们来思考一下Modal组件可支持传递的参数。&lt;/p&gt;
&lt;p&gt;作为一个Modal组件，总要有标题(title)吧？要有用户自定义传入的内容(children)，还有一个确定按钮文案(okText)和一个取消按钮文案(cancelText)吧，并且允许用户传入点击确定按钮的回调函数(onOk)和点击取消按钮的回调函数(onCancel)。也需要有一个控制Modal是否显示的标志吧(visible)。所以，大体上有以下7个变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/993343/201808/993343-20180819151201540-1729083647.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;modal的样式&quot;&gt;Modal的样式&lt;/h4&gt;
&lt;p&gt;首先，根据Modal组件的布局和参数，我们可以确定react Modal的render函数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/993343/201808/993343-20180819151223560-190648545.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们都知道，Modal会覆盖在其他元素上面，并且主要分为两部分，一部分为mask阴影部分，一部分为主体内容，而且主体部分会覆盖在阴影部分上面。让我们一步步来实现这个效果。&lt;/p&gt;
&lt;ol readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;实现mask效果&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.modal-mask {
  // 让mask铺满整屏
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: black;
  opacity: 0.6;
  // 让mask覆盖在其他元素上面
  z-index: 1000;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;实现主体内容的样式，让其覆盖在其他元素(包括mask)上面,每一部分的作用可以看注释&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.modal-container {
  // 让Modal的主体内容全局居中，通过position: fix以及top和left的50%让主体内容的左上角居中，再通过transform:translate(-50%, -50%)来让主体内容正确居中。
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);

  background: white;
  min-width: 500px;
  border-radius: 4px;
  // 设置主体内容的z-index高于mask的，从而可以覆盖mask
  z-index: 1001;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;接下来是body、footer和header样式的实现，这个就直接贴代码了。&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.modal-title {
  padding: 30px;
  color: black;
  font-size: 20px;
  border-bottom: 1px solid #e8e8e8;
}

.modal-body {
  padding: 30px;
  font-size: 14px;
  border-bottom: 1px solid #e8e8e8;
}

.modal-footer {
  text-align: center;
  padding: 30px;
  display: flex;
}

.modal-footer .btn {
  flex: 1;
  height: 32px;
  text-align: center;
}

.modal-footer .modal-cancel-btn {
  background: white;
  margin-right: 30px;
  border-color: #d9d9d9;
  border-radius: 4px;
}

.modal-footer .modal-confirm-btn {
  background: #1890ff;
  color: white; 
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;modal的交互逻辑实现&quot;&gt;Modal的交互逻辑实现&lt;/h4&gt;
&lt;p&gt;实际上Modal的交互是很简单的，一般的调用方式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/993343/201808/993343-20180819151252164-1821146369.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由外部传递自定义的body内容以及一些自定义的属性(比如title,点击按钮的回调还有Modal的标题)&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我们先定义Modal组件里的props&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/993343/201808/993343-20180819151305816-1354444714.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;设置一些默认的props,当用户未传入参数的时候，则使用默认的props&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/993343/201808/993343-20180819151329472-1850782698.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;实现render函数，根据用户传入的参数以及默认参数来渲染Modal节点，如果用户传入的visible属性为false(Modal不可见)，则返回null,否则，返回Modal节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/993343/201808/993343-20180819151343279-793311299.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样，一个简单的react Modal组件就完成了，上面的代码可以在https://github.com/chenjigeng/empty 查看，并且可以直接看到一个demo例子。&lt;/p&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/993343/201808/993343-20180819151356316-422296757.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后再贴一下完整的Modal组件代码&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;// Modal.tsx
import * as React from 'react';
import './Modal.css';

interface IModalProps {
  children: React.ReactChild | React.ReactChildren |  React.ReactElement&amp;lt;any&amp;gt;[],
  title?: React.ReactChild,
  visible: boolean,
  onOk?: () =&amp;gt; void,
  onCancel?: () =&amp;gt; void,
  okText?: string,
  cancelText?: string,
} 

export default class Modal extends React.Component&amp;lt;IModalProps&amp;gt; {

  public static defaultProps = {
    cancelText: '取消',
    okText: '确定',
    visible: false,
  }
  
  public render() {
    const { title, visible, okText, cancelText, children, onOk, onCancel } = this.props;
    if (!visible)  {
      return null;
    };
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;div className=&quot;modal-mask&quot; onClick={onCancel}/&amp;gt;
        &amp;lt;div className=&quot;modal-container&quot;&amp;gt;
          &amp;lt;div className=&quot;modal-header&quot;&amp;gt;
            &amp;lt;div className=&quot;modal-title&quot;&amp;gt;{title}&amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
          &amp;lt;div className=&quot;modal-body&quot;&amp;gt;
            {children}
          &amp;lt;/div&amp;gt;
          &amp;lt;div className=&quot;modal-footer&quot;&amp;gt;
            &amp;lt;button className=&quot;modal-cancel-btn btn&quot; onClick={onCancel}&amp;gt;{cancelText}&amp;lt;/button&amp;gt;
            &amp;lt;button className=&quot;modal-confirm-btn btn&quot; onClick={onOk}&amp;gt;{okText}&amp;lt;/button&amp;gt;
          &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;// Moda.css
.modal-mask {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: black;
  opacity: 0.6;
  z-index: 1000;
}

.modal-container {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: white;
  min-width: 500px;
  border-radius: 4px;
  z-index: 1001;
}

.modal-title {
  padding: 30px;
  color: black;
  font-size: 20px;
  border-bottom: 1px solid #e8e8e8;
}

.modal-body {
  padding: 30px;
  font-size: 14px;
  border-bottom: 1px solid #e8e8e8;
}

.modal-footer {
  text-align: center;
  padding: 30px;
  display: flex;
}

.modal-footer .btn {
  flex: 1;
  height: 32px;
  text-align: center;
}

.modal-footer .modal-cancel-btn {
  background: white;
  margin-right: 30px;
  border-color: #d9d9d9;
  border-radius: 4px;
}

.modal-footer .modal-confirm-btn {
  background: #1890ff;
  color: white; 
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 19 Aug 2018 07:15:00 +0000</pubDate>
<dc:creator>陈陈jg</dc:creator>
<og:description>Modal组件 长话不多说，接下来让我们来动手实现一个react Modal组件。 我们先来看一下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenjg/p/9501333.html</dc:identifier>
</item>
<item>
<title>T-SQL:事务锁下的并发处理（十五） - 薛定谔家的猫</title>
<link>http://www.cnblogs.com/yuanzijian-ruiec/p/9501200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanzijian-ruiec/p/9501200.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在sql  servce 中 事务是一个工作单元 可能包含查询和修改数据以及修改数据定义等多个活动 也可以显示或隐式定义事务边界&lt;/p&gt;
&lt;p&gt;显示定义事务 BEGIN TRAN 开始  如果要提交事务 使用 COMMIT TRAN   撤销事务（回滚） ROLLBACK TRAN  如下示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; Sales.Orders
      (custid, empid, orderdate, requireddate, shippeddate, 
       shipperid, freight, shipname, shipaddress, shipcity,
       shippostalcode, shipcountry)
    &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;&lt;span&gt;
      (&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20090212&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20090301&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20090216&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;32.38&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ship to 85-B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;6789 rue de l&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;Abbaye&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Reims&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
       N&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10345&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;France&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;commit&lt;/span&gt; &lt;span&gt;tran&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个简单的显示事务    也可以是隐式事务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;GO&lt;/span&gt;
 &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; Sales.Orders
      (custid, empid, orderdate, requireddate, shippeddate, 
       shipperid, freight, shipname, shipaddress, shipcity,
       shippostalcode, shipcountry)
    &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;&lt;span&gt;
      (&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20090212&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20090301&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20090216&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;32.38&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ship to 85-B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;6789 rue de l&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;Abbaye&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Reims&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
       N&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10345&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;France&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过GO 在当前批执行完成时自动 提交事务   当然默认情况下SQL Server 将每个单独的语句作为一个事务 每个语句结束后SQL Server 会自动提交事务 也可通过设置会话来改变默认设置 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; IMPLICIT_TRANSACTIONS &lt;span&gt;ON&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置为ON 后不需要指定BEGIN TRAN 语句开始事务 但必须以COMMIT TRAN或 TOLLBACK TRAN 标记结束&lt;/p&gt;
&lt;p&gt;事务有4个属性-原子性，一致性，隔离性，持续性 首字母缩写为ACID&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原子性&lt;/strong&gt;（Atomicity）: 事务是一个原子工作单元，事务中的所有修改要么提交，要么撤销。在事务提交指令记录到事务日志之前 如果系统出现了故障，重新启动时，SQL Server 会撤销所做的修改。  如果事务中出现错误 默认会自动回滚   也可以通过 @@TRANCOUNT 检测事务事务完成 或者说是 当前环境是否在事务中 如果在就返回 1 没有就是0 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;    &lt;span&gt;@@TRANCOUNT&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;一致性（Consistency）&lt;/strong&gt;：指数据状态， 在隔离级别中  每个级别都要是 一致性级别 只有事务保持一致性级别才能访问。在约束中 也指 主外键 书屋会转换数据库的一致性状态到另一个一致性状态 保持一致性&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隔离性（Isolation）&lt;/strong&gt;：隔离是一种控制访问数据的机制，确保事务所范围数据是在其所期望的一致性级别中的数据。在SQL Server 中支持两种不同的模式来处理隔离：基于锁的传统模式和行版本控制(新模式) 但是默认的是 锁模式  而且当前加锁也是共享锁 ，如果数据状态不一致 读取数据就会被阻止 直到状态一致 。而改成行版本控制模式 读取就不需要等待 也不会加共享锁 在不需要及时显示的数据时 这种模式是提高并发的处理方式。 具体实现要看使用的隔离级别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持续性（Durability）&lt;/strong&gt;：数据修改在写入到数据库磁盘之前，总是先写入数据库的事务日志磁盘。提交后，指令记录在事务日志磁盘上，在尚未修改磁盘数据之前，事务是持续的，回滚也只是删除事务日志的所有修改记录。&lt;/p&gt;
&lt;p&gt;下面是一个完整的事务示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BEGIN&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; &lt;span&gt;@neworderid&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;INT&lt;/span&gt;&lt;span&gt;;


&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;&lt;span&gt; TRY
  &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; Sales.Orders
      (custid, empid, orderdate, requireddate, shippeddate, 
       shipperid, freight, shipname, shipaddress, shipcity,
       shippostalcode, shipcountry)
    &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;&lt;span&gt;
      (&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20090212&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20090301&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;20090216&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;32.38&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ship to 85-B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;6789 rue de l&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;Abbaye&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Reims&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
       N&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10345&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, N&lt;span&gt;'&lt;/span&gt;&lt;span&gt;France&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@neworderid&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;SCOPE_IDENTITY&lt;/span&gt;&lt;span&gt;();

  &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@neworderid&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; neworderid;

  &lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt;&lt;span&gt; Sales.OrderDetails(orderid, productid, unitprice, qty, discount)
    &lt;/span&gt;&lt;span&gt;VALUES&lt;/span&gt;(&lt;span&gt;@neworderid&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;14.00&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;0.000&lt;/span&gt;&lt;span&gt;),
          (&lt;/span&gt;&lt;span&gt;@neworderid&lt;/span&gt;, &lt;span&gt;42&lt;/span&gt;, &lt;span&gt;9.80&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;0.000&lt;/span&gt;&lt;span&gt;),
          (&lt;/span&gt;&lt;span&gt;@neworderid&lt;/span&gt;, &lt;span&gt;72&lt;/span&gt;, &lt;span&gt;34.80&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;0.000&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;COMMIT&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt; TRY
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;&lt;span&gt; CATCH
&lt;/span&gt;&lt;span&gt;ROLLBACK&lt;/span&gt; &lt;span&gt;TRAN&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt; CATCH
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁是事务保护数据资源而获得的控制资源，防止其他事务的冲突或不兼容访问。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁主要有两种锁模式 排他锁和共享锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你试图修改数据时 事务会请求数据资源的一个排他锁，它会一直到事务结束才会解除 期间任何其他事务请求都会被阻塞。对于单条语句事务 只要这条语句结束锁就会自动解除。对于多条语句事务 就只有当他完成所有语句执行并通过 COMMIT TRAN 或 ROLLBACK TRAN 命令时事务才会解除锁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;排他锁&lt;/strong&gt;：如果一个事务在修改行，直到事务完成，其他事务都不能修改相同的行。但是能不能读取相同行 取决于它的隔离级别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享锁&lt;/strong&gt;：在读取事务加锁是默认加的是共享锁  SQL读取的默认隔离级别 READ COMMITTED  因为此隔离级别 会让事务请求读取资源时默认加上共享锁  多个事务可以同时拥有相同数据资源共享锁。 此模式下也会因为并发造成幻读 虽然在修改数据时，无法修改锁和持续时间，但可以通过改变隔离级别 在读取数据时控制锁定的处理方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实锁的本质就是数据的隔离级别 在通过控制隔离级别也能达到加锁的效果 ，而且效果更好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SQL 中默认的隔离级别 READ COMMITTED SNAPSHOT 这种隔离依靠行版本控制，而不是锁，在此模式下 读取者不需要共享锁，因为不需要等待，依赖行版本控制技术提供隔离。   如果一个事务在READ COMMITTED隔离级别下 修改数据行 直到事务完成，另一个事务都不能读取相同行。这种并发控制称 “&lt;strong&gt;悲观式并发&lt;/strong&gt;”  如果一个事务在READ COMMITTED SNAPSHOT隔离级别下 修改数据行  此时另一个事务读取相同行 会获得最后一次提交的可用状态。这种并发控制称 “&lt;strong&gt;乐观式并发&lt;/strong&gt;” 在乐观并发中可以很好的解决修改和展示并发问题。&lt;/p&gt;
&lt;p&gt;  这种事务之间的并发处理已称为 &lt;strong&gt;锁兼容性&lt;/strong&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;请求锁模式&lt;/td&gt;
&lt;td&gt;请求排他锁&lt;/td&gt;
&lt;td&gt;请求共享锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;请求排他锁&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;请求共享锁&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;交叉的否代表不兼容 请求锁模式会被拒绝 交叉是 表示兼容 请求锁模式会被接收&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么锁都可以锁些什么资源呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;锁定的资源包括RID ，键，行，页，对象，表，数据库，范围，分配单元，堆，B树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锁请求流程规则是什么呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：获取一个行上的排他锁  事务必须首先获取一个行所在页的意向排他锁和一个拥有该页对象的意向排他锁， 同样的 共享锁也是此步骤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要申请意向锁？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了在更高级别有效的检测是否有锁不兼容请求，并防止授予这些锁请求，这就是为什么在排他锁请求相同数据行时被阻断的原因。&lt;/p&gt;
&lt;p&gt;例如：一个事务持有行上锁，而另一个事务在该行所在的页或者表请求不兼容锁比如排他锁 有第一个事务的行上锁 有一个 表意向锁  这个时候请求就被拒绝了&lt;/p&gt;
&lt;p&gt;但意向锁不会拒绝更低级别对象的锁请求  &lt;/p&gt;
&lt;p&gt;例如： 一个页上的意向锁不会阻断在该页的其他事务的排他锁  我们可以通过一个表来细致的了解这些锁的兼容性请求。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;请求锁模式&lt;/td&gt;
&lt;td&gt;请求排他锁&lt;/td&gt;
&lt;td&gt;请求共享锁&lt;/td&gt;
&lt;td&gt;请求意向排他锁&lt;/td&gt;
&lt;td&gt;请求意向共享锁&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;请求排它锁&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;请求共享锁&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;请求意向排他锁&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;td&gt;请求意向共享锁&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;通过这些锁得到我们最理想的并发处理 锁定所需要的内容，即受影响行数 。锁是需要内存资源和内部管理开销， 当需要锁时要考虑当前系统资源情况。&lt;/p&gt;
&lt;p&gt;有一个情况不得不说  在行锁中超过5000个时 会自动升级锁 到表锁 然后每加1250个锁都会触发默认的锁升级&lt;/p&gt;
&lt;p&gt;可以通过ALTER TABLE语句设置LOCK_ESCALATION 的表选项控制锁升级。 也可以禁用。 也可以更改升级方式 比如 分区级别( 把一个表物理的组织成小单元c成为分区）   锁到此语句结束了下次讲  如何优雅的排除并发导致的阻塞数据处理。&lt;/p&gt;

</description>
<pubDate>Sun, 19 Aug 2018 06:34:00 +0000</pubDate>
<dc:creator>薛定谔家的猫</dc:creator>
<og:description>1.事务 在sql servce 中 事务是一个工作单元 可能包含查询和修改数据以及修改数据定义等多个活动 也可以显示或隐式定义事务边界 显示定义事务 BEGIN TRAN 开始 如果要提交事务 使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanzijian-ruiec/p/9501200.html</dc:identifier>
</item>
<item>
<title>[一] java8 函数式编程入门 什么是函数式编程 函数接口概念 流和收集器基本概念 - noteless</title>
<link>http://www.cnblogs.com/noteless/p/9501195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/9501195.html</guid>
<description>
&lt;p&gt;&lt;span&gt;本文是针对于java8引入函数式编程概念以及stream流相关的一些简单介绍&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;什么是函数式编程?&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;java程序员第一反应可能会理解成类的成员方法一类的东西&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此处并不是这个含义,更接近是数学上的函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看一下百度百科中关于&lt;strong&gt;函数&lt;/strong&gt;的说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;函数的定义：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;11.5&quot;&gt;&lt;td readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;给定一个数集A，假设其中的元素为x。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现对A中的元素x施加对应法则f，记作f（x），得到另一数集B。假设B中的元素为y。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则y与x之间的等量关系可以用y=f（x）表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们把这个关系式就叫函数关系式，简称函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数概念含有三个要素：定义域A、值域C和对应法则f。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中核心是对应法则f，它是函数关系的本质特征。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143135012-2022437052.png&quot;&gt;&lt;img title=&quot;image_5b790d18_713d_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143135198-1111141400.png&quot; alt=&quot;image_5b790d18_713d_thumb[1]&quot; width=&quot;137&quot; height=&quot;294&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;对应于编程来说,当然不是完全的数学上的函数定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓函数式编程我们可以理解为:&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;通过对应法则f(x) 对指定的x 进行处理,映射成另外一个值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且不会对x本身产生变动&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所谓不会对x产生变动,你可以理解为无副作用,或者说副作用不会被察觉&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;副作用你可以理解为解题过程中对数据的修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说起来好像很啰嗦,但是如果有人告诉你 通过sin(x) 计算后, x的值被改变了,你不会觉得异常奇怪么&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;函数式编程就是把函数的一些特性应用于编程语言之中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;函数式编程不是某一种语言,也不是某个API&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他是一种方法论,是一种编程范式,有它自有的一些特性和规定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语言中引入函数式编程,也就是用语言本身定义了函数式编程的一些特性和规定&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;函数式编程最重要的基础是&lt;strong&gt;λ演算&lt;/strong&gt;，而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它一套用于研究函数定义、函数应用和递归的形式系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们只需要知道λ演算是一种形式的&lt;strong&gt;匿名函数&lt;/strong&gt;,并且&lt;strong&gt;接收一个参数作为输入&lt;/strong&gt; (可以柯里化进行参数转换多参数函数转换为单参数)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有兴趣的可以去探究下λ演算&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;函数式编程有下列特性&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;闭包和高阶函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包就是能够读取其他函数内部变量的函数,是个不太好理解的概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此处我们仅仅理解成 函数可以当做值进行传递并且可以使用变量保存 是&quot;第一等公民&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一等公民或者一等类型的含义就是指可以跟值一样的地位,作为参数传递或者存储于变量中 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高阶函数是指可以用另一个函数（间接地，用一个表达式） 作为其输入参数,比如 f(g(x))=g(x)+1 的形式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;惰性计算&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以理解为流水线上每一个节点都只是做了一系列的设置,并没有立刻去计算数值&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;没有副作用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;副作用是指在运算过程中,修改了函数内部局部变量以外的其他变量的状态,比如你修改了类成员变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有副作用也就意味着不产生运算以外的其他结果,不修改系统的变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;引用透明性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果提供同样的输入，那么函数总是返回同样的结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说表达式的值不依赖于可以改变值的全局状态,比如不依赖成员变量的值&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;为什么要使用函数式编程?&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关注做什么 更接近于自然语言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;任务分解后你的解题思路将是如何调用各个不同的函数,要&lt;strong&gt;做什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不在关注于函数内部的细节本身去思考怎么做&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;76&quot;&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;假设有这么一组Student学生类型的List数据,学生有性别男女&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果在Java代码中,你会如何解题?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;伪代码:&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
List&amp;lt;Student&amp;gt;&lt;span&gt; 男List ;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;studentList.length;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;studentList 为学生列表,其中有男有女&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(studentList[i].性别 ==&lt;span&gt; 男){
    男List.add(List[i])
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;你循环遍历列表,找到符合条件的学生,然后把他加入另外一个列表,这可能是一种常见的解题思路&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;假设有个Student 学生表,每条记录都有一个性别字段值为男女&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果是在数据库中查询呢,一种可能的解法是这样子的&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;
&lt;span&gt;*&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt;
student
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;
sex&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;男&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;他们的主要区别是什么?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个最直观的差别就是:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;java代码中是你自己去循环数据项,你自己处理每一项数据,找出符合你要求的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQL查询中,你只是传入通知条件where  sex='男';  ,数据库在自己内部进行了循环,帮我们找出来符合要求的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这就是外部循环和内部循环,这是一种思维方式的转变&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;外部循环,需要程序员自己去关注每一个数据项&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;内部循环,程序员只需要关注结果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;33&quot;&gt;
&lt;p&gt;&lt;span&gt;内部循环以及函数调用 也将我们从如何做中解放出来,让我们不再关注数据项循环的细节本身,仅仅关注于此次调用的结果&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;不管是什么方式进行思考编程,你都会将你的任务进行分解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;划分为更小的子任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是不同的是:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;strong&gt;如何做&lt;/strong&gt;的思维下,你还需要思考在每个子任务中,每一个细节是怎么处理的,比如循环中进行条件判断&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这其实还是往计算机的思维倾斜的一种思考方式,这是指令式或者命令式的编程模式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在&lt;strong&gt;做什么&lt;/strong&gt;的思维下,你不在关注每个子任务的内部细节,只在乎结果也就是&quot;做什么&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个子任务内部的细节是函数自己内部的事情,这更加符合人的思维习惯&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内部循环不也是函数式编程的一种表现形式么&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数本身如同一个黑盒一般,有输入有输出,我们不关心内部的实现细节,仅仅在乎输入和输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内部循环也是如此,我们告诉他我们想要的结果行为,他返回给我们结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如SQL中&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;35&quot;&gt;
&lt;p&gt;&lt;span&gt;where   sex='男';  这就是对我们行为的描述(不要把它理解成筛选条件)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将行为像参数一样传递给了数据库软件,数据库执行查询操作,根据的是我们给定的行为&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这就是&lt;strong&gt;行为参数化&lt;/strong&gt;的魅力所在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;行为参数化也是一种思维模式,只要能把行为像参数一样进行传递  就是行为参数化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;有人可能已经想到了匿名内部类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
System.out.println();
}
}).start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;的确这也是一种行为参数化,但是显然,这段代码还不够简洁纯粹,因为方法的外层还套了一层对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java8中的行为参数化,传递的将是更加纯粹的行为,而不再需要借助一个匿名对象的形式,而且,Lambda表达式不会像内部类一样生成一个类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;传递的是方法本身,方法中的代码本身&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那么行为参数化,不也就是函数式编程中的闭包特性么&lt;/span&gt;&lt;/p&gt;


&lt;div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更加易于并发编程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;span&gt;函数式编程的准则是没有副作用不依赖外部的数据，也不改变外部数据的值。&lt;/span&gt;&lt;/div&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;我们知道线程安全的根本在于共享数据,如果没有任何的数据共享,那么很多的并发/线程安全问题都将迎刃而解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说这一特性正好满足了多核并行程序设计的需求，所以很显然能够简化并行程序的开发&lt;/span&gt;&lt;/p&gt;


&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;函数式编程代码简洁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数式编程大量使用函数，减少了代码的重复，就如同你调用别人的方法一样不是么,一行就得到了结果&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;Java8 对于函数式编程的支持&lt;/strong&gt;&lt;/h3&gt;

&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;编程语言把函数式编程的概念引入,也就是使自身支持函数式编程的特性,换句话说也就是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在语言内部可以使用一系列的类型或者关键字或者符号组合等进行表示&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Java主要涉及这三个核心概念&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;函数接口(FunctionalInterface)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;流(Stream)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;收集器(Collector)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;函数接口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然函数式编程要求函数可以是同值一样的一等公民用于参数化传递,那么必须要有表示函数的类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先说一下函数式接口的注解&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;注解@FunctionalInterface  &lt;/strong&gt; 描述了什么是一个函数式接口&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt; FunctionalInterface {}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143135379-1326132818.png&quot;&gt;&lt;img title=&quot;image_5b790d18_4458_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143135652-909596164.png&quot; alt=&quot;image_5b790d18_4458_thumb[1]&quot; width=&quot;659&quot; height=&quot;399&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;上面的注释也就相当于是函数式接口的定义:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个函数式接口只能有一个抽象方法,default方法有实现,所以不是抽象方法 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个接口声明了一个覆盖Object  public公有方法的抽象方法,也不算是抽象方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说:&lt;strong&gt;函数式接口，有且仅有一个抽象方法，覆盖Object的public方法不计算在内&lt;/strong&gt;(如果是覆盖Object的protected那么会计数的) &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;java.lang.Runnable、java.util.Comparator是典型的函数式接口&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;函数接口是一个接口,有且只有一个唯一的抽象方法&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;接口上定义了函数的类型参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;抽象方法的方法签名限定了函数(&lt;span&gt;&lt;span&gt;函数式接口的抽象方法的签名称为函数描&lt;/span&gt;&lt;span&gt;述符&lt;/span&gt;&lt;/span&gt;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说一个函数接口,只能描述一种类型的函数&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;比如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Function&amp;lt;T, R&amp;gt;      这个函数接口&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143135835-17781411.png&quot;&gt;&lt;img title=&quot;image_5b790d18_5ba3_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143136065-1342657168.png&quot; alt=&quot;image_5b790d18_5ba3_thumb[1]&quot; width=&quot;494&quot; height=&quot;225&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;他表示形如&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;div&gt;
&lt;p&gt;&lt;span&gt;R function(T){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  return R&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;他的类型参数是T  R,调用方法apply 输入为T   输出为R&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用为转换一个对象为不同类型的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有这种形式的函数都是这个函数接口类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
Function&lt;/span&gt;&amp;lt;String,Boolean&amp;gt; function = (String x)-&amp;gt;x.equals(&quot;true&quot;&lt;span&gt;);
System.out.println(function.apply(&lt;/span&gt;&quot;1&quot;&lt;span&gt;));
System.out.println(function.apply(&lt;/span&gt;&quot;true&quot;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143136235-359004207.png&quot;&gt;&lt;img title=&quot;image_5b790d18_906_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143136448-723912422.png&quot; alt=&quot;image_5b790d18_906_thumb[1]&quot; width=&quot;463&quot; height=&quot;149&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;至此,Java中已经有了用于表示函数的类型了,也就是可以定义一个函数或者返回一个函数,或者把函数当做一个参数值进行传递了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以赋值运算符的形式来类比的话就是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int i = 1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等号左边的类型已经有了就是函数接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是右边,也就是行为参数化这个行为到底如何表示呢?也即是上面的1 的位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在java中可以使用&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Lambda表达式(&lt;/strong&gt;&lt;span&gt;(String x)-&amp;gt;x&lt;span&gt;.&lt;/span&gt;equals(&lt;span&gt;&quot;true&quot;&lt;/span&gt;)&lt;/span&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法引用(String::length)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;两种形式进行表示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
Function&lt;/span&gt;&amp;lt;String,Integer&amp;gt; function =&lt;span&gt; String::length;
System.out.println(function.apply(&lt;/span&gt;&quot;1&quot;&lt;span&gt;));
System.out.println(function.apply(&lt;/span&gt;&quot;true&quot;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143136598-479617062.png&quot;&gt;&lt;img title=&quot;image_5b790d18_316d_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143136782-100959945.png&quot; alt=&quot;image_5b790d18_316d_thumb[1]&quot; width=&quot;429&quot; height=&quot;104&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;既然每一种函数类型都需要存在指定形式的函数接口,想要使用Lambda-匿名函数或者方法引用,自然需要定义函数接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数类型的说法可能不太准确,&lt;span&gt;函数式接口的抽象方法的签名称为函数描&lt;/span&gt;&lt;span&gt;述符 其实说的也都还是方法签名  方法签名唯一的标识了一个函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Java8 也已经给我们预置了一些常用的函数接口类型  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;已经定义一套能够描述常见函数描述符的函数接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如上面提到的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;function  就是其中一种&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外还有其他一些,后面再说,我们已经可以在Java中表示一个函数,并且对函数进行调用&lt;/span&gt;&lt;/p&gt;


&lt;h4&gt;&lt;span&gt;&lt;strong&gt;流&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div readability=&quot;20.5&quot;&gt;
&lt;div readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;span&gt;流,流动,流水,java中早就已经有了IO流,形象的表达了数据在程序中的处理与流动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java8中的&lt;span&gt;Stream&lt;/span&gt;流则更倾向于流水线的含义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个节点有各自独立的功能目的,根据你的目的(&lt;strong&gt;做什么&lt;/strong&gt;),将各个独立的功能目的节点拼接成一整个的完整的流水线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据在此流水线上进行加工处理,最终得出结果&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过告知Stream &quot;&lt;strong&gt;做什么&lt;/strong&gt;&quot; 来进行数据操作和处理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你不在需要关注内部的细节,Stream通过内部迭代进行数据项的筛选查找,找到符合条件的数据 &lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;流（Stream）是Java8对函数式编程的重要支撑。大部分函数式工具都围绕Stream展开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也可以说Stream类是Java8 关于函数式编程定义的一些列函数集合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由此可以看得出来,Stream的重要性  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想要使用Java进行函数式编程,仅仅使用Lambda表达式是不够的,必须有足够的函数,Lambda表达式只有跟stream一起使用才能显示其真实的威力&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;集合是一种数据结构用于存储数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Stream不是一种数据结构,是对于数据的一种新的视图,用于数据的计算,提供了一系列的API用于调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;概括的说&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Stream就是函数式编程中编程语言提供出来的库方法集合,而参数基本上都是函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以才说,Lambda表达式只有跟stream一起使用才能显示其真实的威力&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143136963-959613460.png&quot;&gt;&lt;img title=&quot;image_5b790d18_3c54_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143137462-2100563131.png&quot; alt=&quot;image_5b790d18_3c54_thumb[1]&quot; width=&quot;606&quot; height=&quot;490&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;常用的Stream调用流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143137671-1520187936.png&quot;&gt;&lt;img title=&quot;image_5b790d18_5d3e_thumb[1]&quot; src=&quot;https://images2018.cnblogs.com/blog/897393/201808/897393-20180819143137905-1698597533.png&quot; alt=&quot;image_5b790d18_5d3e_thumb[1]&quot; width=&quot;664&quot; height=&quot;341&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;


&lt;div readability=&quot;69&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.获得Stream&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想要使用Stream的一些特性,显然你必须把你的数据集转换生成为Stream,这没有Stream何谈使用?&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.设置行为类型 也就是操作类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这句话有些模糊不清,其实就是你需要设置想干什么&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到底是筛选数据?转换数据?求和还是怎样?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以类比为SQL查询中到底是SELECT 还是UPDATE 或者DELETE? 这就是行为的类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了更快理解的话,你可以片面的理解为调用Stream类的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们举例说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如你经常让同学帮你买东西&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;买东西就是行为类型,是去买东西,既不是帮你开车也不是陪你看电影&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是行为的类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Stream中有一系列的API可以帮助我们达到这个目的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如 filter  map等等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 确定行为参数 也就是操作内容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;行为参数也就是基于已经设置的行为类型下,你具体要以什么样子的行为去执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你筛选数据筛选什么样子的数据?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;转换数据,转换为什么形式?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类比为SQL查询中就是查询条件,查询  男生?查询 女生? 这就是行为的具体方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是刚才的例子,你经常让同学帮你买东西,那到底买什么?买矿泉水还是买面包?这就是确定行为参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java8中使用方法引用或者Lambda-匿名函数  或者方法引用来表示行为参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.&lt;strong&gt;行为的属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然是流水线式的工作方式,那么当前的工作结束后或许结束了或许是进入到流水线的下一环节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然最终他肯定还是会结束掉的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就又涉及到绑定行为方法的属性种类  到底是中间的操作(可以继续传递给流水线下一步)  还是结束的终端操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中间操作的返回结果还是一个Stream  你仍旧可以对他进行上述类似的过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;终端操作则一般会将流进行收集整理成指定的数据结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这基本上是一个常用的Stream使用流程 &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;流程处理虽然很简单,但是强大之处在于中间操作处理后仍旧是流&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就意味着你可以按照需要进行无数的变换组合以达到你想要的效果&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;收集器&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;span&gt;Stream结合Lambda表达式可以对于数据进行各种各样的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是Stream 终归是Stream ,它并不是一种数据结构,不管经过了多少处理,他终归是再次返回到代码中具体的其他数据类型中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把Stream类比做数据项处理的流水线的话&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中间操作就是流水线上的一个个的功能操作节点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而收集器就是在某些结束操作中用于将数据进行转换的工具&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Java中关于收集器有几个关键的概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. Stream中的collect 方法是收集器的调用者&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;R, A&amp;gt; R collect(Collector&amp;lt;? &lt;span&gt;super&lt;/span&gt; T, A, R&amp;gt; collector);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. Collector 接口 定义了收集器&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Collector&amp;lt;T, A, R&amp;gt; {
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. 收集器工厂Collectors  用于预置一些收集器&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Collectors
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;比如   .....collect(Collectors.toList());  就是把一个处理后的流转换为List&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Java8 构建了三个主要概念,函数接口,流,收集器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了函数接口  函数拥有了类型也就是可以像值一样作为参数进行传递,作为返回值,或者使用变量进行表示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用Lambda-匿名函数或者方法引用来表示行为参数  也就是函数的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Stream是Java8 提供的函数式编程的&quot;库函数&quot; 预定了一些常用的操作模式,通过Lambda表达式结合使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;收集器用于把Stream处理后的数据进行打包整理成你需要的数据结构&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Sun, 19 Aug 2018 06:32:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>本文是针对于java8引入函数式编程概念以及stream流相关的一些简单介绍 什么是函数式编程? java程序员第一反应可能会理解成类的成员方法一类的东西 此处并不是这个含义,更接近是数学上的函数 看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/9501195.html</dc:identifier>
</item>
<item>
<title>Vue入门---常用指令详解 - 半指温柔乐</title>
<link>http://www.cnblogs.com/le220/p/9501071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/le220/p/9501071.html</guid>
<description>&lt;h2&gt;Vue&lt;span&gt;入门&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Vue&lt;/strong&gt;&lt;/span&gt;是一个&lt;strong&gt;MVVM&lt;/strong&gt;（Model / View / ViewModel）的前端框架，相对于Angular来说简单、易学上手快，近两年也也别流行，发展速度较快，已经超越Angular了。比较适用于移动端，轻量级的框架，文件小，运行速度快。最近，闲来无事，所以学习一下Vue这个流行的框架，以备后用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;一、指令&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-model&lt;/strong&gt; &lt;span&gt;多用于表单元素实现双向数据绑定（同&lt;/span&gt;&lt;span&gt;angular&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;ng-model&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-for&lt;/strong&gt; &lt;span&gt;格式：&lt;/span&gt; v-for=&quot;&lt;span&gt;字段名&lt;/span&gt; &lt;span&gt;in(of)&lt;/span&gt; &lt;span&gt;数组&lt;/span&gt;&lt;span&gt;json&quot;&lt;/span&gt;  &lt;span&gt;循环数组或&lt;/span&gt;json(&lt;span&gt;同&lt;/span&gt;&lt;span&gt;angular&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;ng-repeat),&lt;/span&gt;&lt;span&gt;需要注意从&lt;/span&gt;&lt;span&gt;vue2&lt;/span&gt;&lt;span&gt;开始取消了&lt;/span&gt;&lt;span&gt;$index&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-show&lt;/strong&gt; &lt;span&gt;显示内容 （同&lt;/span&gt;&lt;span&gt;angular&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;ng-show&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-hide&lt;/strong&gt;  &lt;span&gt;隐藏内容（同&lt;/span&gt;&lt;span&gt;angular&lt;/span&gt;&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;ng-hide&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-if    &lt;/strong&gt;&lt;span&gt;显示与隐藏&lt;/span&gt;  （dom元素的删除添加 &lt;span&gt;同&lt;/span&gt;angular中的ng-if 默认值为false&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-else-if&lt;/strong&gt;  &lt;span&gt;必须和&lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;连用&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-else&lt;/strong&gt;  &lt;span&gt;必须和&lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;连用  不能单独使用  否则报错   模板编译错误&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-bind&lt;/strong&gt;  &lt;span&gt;动态绑定  作用： 及时对页面的数据进行更改&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-on:click&lt;/strong&gt; &lt;span&gt;给标签绑定函数，可以缩写为&lt;/span&gt;@，例如绑定一个点击函数  &lt;span&gt;函数必须写在&lt;/span&gt;methods&lt;span&gt;里面&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-text&lt;/strong&gt;  &lt;span&gt;解析文本&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-html   &lt;/strong&gt;&lt;span&gt;解析&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;标签&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-bind:class&lt;/strong&gt;   &lt;span&gt;三种绑定方法  &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、对象型  &lt;/span&gt;&lt;span&gt;'{red:isred}'  2&lt;/span&gt;&lt;span&gt;、三&lt;/span&gt;元&lt;span&gt;型&lt;/span&gt;   'isred?&quot;red&quot;:&quot;blue&quot;'   3&lt;span&gt;、数组型  &lt;/span&gt;&lt;span&gt;'[{red:&quot;isred&quot;},{blue:&quot;isblue&quot;}]'&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-once&lt;/strong&gt;  &lt;span&gt;进入页面时  只渲染一次 不在进行渲染&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-cloak&lt;/strong&gt;  &lt;span&gt;防止闪烁&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;v-pre&lt;/strong&gt;  &lt;span&gt;把标签内部的元素原位输出&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;二、基本组件属性&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; Vue&lt;/strong&gt;&lt;/span&gt;({
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;strong&gt;el&lt;/strong&gt;,         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要绑定的 DOM element&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   &lt;strong&gt;template&lt;/strong&gt;,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要解析的模板，可以是 #id, HTML 或某個 DOM element&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;   &lt;strong&gt;data&lt;/strong&gt;,       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要绑定的数据&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;   &lt;strong&gt;computed&lt;/strong&gt;,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依赖于别的数据计算出来的数据, name = firstName + lastName&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;   &lt;strong&gt;watch&lt;/strong&gt;,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听方法, 监听到某一数据变化时, 需要做的对应操作&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;   &lt;strong&gt;methods&lt;/strong&gt;,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义可以在元件或模板內使用的方法&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;&lt;span&gt;三、基础使用&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.html&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{msg}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         el:'#app',&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标签的类名、id，用于获取元素&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以键值对的形式存放用到的数据成员&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        data:{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             msg:'显示的内容'       
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        },
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;包含要用到的函数方法&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        methods:{            
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样js中msg的内容就会在p标签内显示出来。&lt;/p&gt;
&lt;h3&gt;四、实例&lt;/h3&gt;
&lt;p&gt;利用bootstrap+vue实现简易留言板的功能，可以增加、删除，弹出模态框&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;简易留言板&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;apple-mobile-web-app-capable&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;yes&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;apple-mobile-web-app-status-bar-style&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;black&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;../../node_modules/bootstrap/dist/css/bootstrap.min.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../../node_modules/jquery/dist/jquery.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../../node_modules/bootstrap/dist/js/bootstrap.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;../../node_modules/vue/dist/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;      window.onload&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;          &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; Vue&lt;/strong&gt;&lt;/span&gt;({
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt;            el&lt;/strong&gt;&lt;/span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#box&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt;            data&lt;/strong&gt;&lt;/span&gt;:{
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;               myData:[],
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;               username:&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;               age:&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;               nowIndex:&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;            },
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;strong&gt;            methods&lt;/strong&gt;&lt;/span&gt;:{
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;               add:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;                   &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.myData.push({
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;                     name:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.username,
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;                     age:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;                  });
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;                   &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.username&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                   &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;               },
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;               deleteMsg:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(n){
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                   &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(n&lt;/span&gt;&lt;span&gt;==-&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                      &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.myData&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;                  }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;                      &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.myData.splice(n,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;                  }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;               }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;         });
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;      };
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;role&lt;/span&gt;&lt;span&gt;=&quot;form&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户名:&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;输入用户名&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年　龄:&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;输入年龄&quot;&lt;/span&gt;&lt;span&gt; v-model&lt;/span&gt;&lt;span&gt;=&quot;age&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;添加&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-primary&quot;&lt;/span&gt;&lt;span&gt; v-on:click&lt;/span&gt;&lt;span&gt;=&quot;add()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;reset&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;重置&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-danger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;table table-bordered table-hover&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;h3 text-info text-center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户信息表&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;text-danger&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;text-center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;序号&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;text-center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;名字&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;text-center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年龄&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;text-center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;操作&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;text-center&quot;&lt;/span&gt;&lt;span&gt; v-for&lt;/span&gt;&lt;span&gt;=&quot;(item,index) in myData&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{index+1}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{item.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{item.age}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-primary btn-sm&quot;&lt;/span&gt;&lt;span&gt; data-toggle&lt;/span&gt;&lt;span&gt;=&quot;modal&quot;&lt;/span&gt;&lt;span&gt; data-target&lt;/span&gt;&lt;span&gt;=&quot;#layer&quot;&lt;/span&gt;&lt;span&gt; v-on:click&lt;/span&gt;&lt;span&gt;=&quot;nowIndex=$index&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;删除&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;v-show&lt;/span&gt;&lt;span&gt;=&quot;myData.length!=0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;colspan&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;text-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-danger btn-sm&quot;&lt;/span&gt;&lt;span&gt; v-on:click&lt;/span&gt;&lt;span&gt;=&quot;nowIndex=-2&quot;&lt;/span&gt;&lt;span&gt; data-toggle&lt;/span&gt;&lt;span&gt;=&quot;modal&quot;&lt;/span&gt;&lt;span&gt; data-target&lt;/span&gt;&lt;span&gt;=&quot;#layer&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;删除全部&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr &lt;/span&gt;&lt;span&gt;v-show&lt;/span&gt;&lt;span&gt;=&quot;myData.length==0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;colspan&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;text-center text-muted&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;暂无数据....&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt;    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;模态框 弹出框&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;role&lt;/span&gt;&lt;span&gt;=&quot;dialog&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;modal fade bs-example-modal-sm&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;layer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;modal-dialog&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;modal-content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;modal-header&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h4 &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;modal-title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;确认删除么?&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h4&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;close&quot;&lt;/span&gt;&lt;span&gt; data-dismiss&lt;/span&gt;&lt;span&gt;=&quot;modal&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;amp;times;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;modal-body text-right&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;data-dismiss&lt;/span&gt;&lt;span&gt;=&quot;modal&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-primary btn-sm&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;取消&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;data-dismiss&lt;/span&gt;&lt;span&gt;=&quot;modal&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-danger btn-sm&quot;&lt;/span&gt;&lt;span&gt; v-on:click&lt;/span&gt;&lt;span&gt;=&quot;deleteMsg(nowIndex)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;确认&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;          &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt;    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;113&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;114&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1217233/201808/1217233-20180819134048688-1718249359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 19 Aug 2018 05:58:00 +0000</pubDate>
<dc:creator>半指温柔乐</dc:creator>
<og:description>Vue入门 Vue是一个MVVM（Model / View / ViewModel）的前端框架，相对于Angular来说简单、易学上手快，近两年也也别流行，发展速度较快，已经超越Angular了。比较</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/le220/p/9501071.html</dc:identifier>
</item>
<item>
<title>自学安卓练习作品单词APP(1)-安卓的hello word与有道字典防爬虫破解 - study的猫</title>
<link>http://www.cnblogs.com/lansehai/p/9500357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lansehai/p/9500357.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;1.前言&lt;/h2&gt;
&lt;p&gt;闲来无聊.手机每天又是都接触的东西.程序什么的最容易接触到.想到有些人说前后端都做就是全栈的说法.哦,你看html5全栈.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819101111396-351914247.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要我说多接触一些多有意思.天天写后端.还不是业务层.又不是什么高大上的算法.前端有意思的东西才多.当然我是那种比较old的.不会ag.vue,react.只会jq.拿起一把梭子就是干.哇.你看看这个前端的水果然深.&lt;/p&gt;
&lt;p&gt;接下来说app要完成那些目标了.&lt;/p&gt;
&lt;p&gt;1.查词(这个太简单了)&lt;/p&gt;
&lt;p&gt;2.翻译(调用有道的)&lt;/p&gt;
&lt;p&gt;3.句式分析(本来在想英语是不是有什么规律.后来一找有人做了.直接嵌入就行了.)&lt;/p&gt;
&lt;p&gt;4.单词匹配(就是根据一些乱七八糟的规则推荐一些相同的单词)&lt;/p&gt;
&lt;p&gt;5.爬虫文章(暂定)&lt;/p&gt;
&lt;p&gt;要用到的相关技术与内容&lt;/p&gt;
&lt;p&gt;1.sqlite本地数据库,(存放单词数据库)&lt;/p&gt;
&lt;p&gt;2.webView的使用&lt;/p&gt;
&lt;p&gt;3.http请求模拟&lt;/p&gt;
&lt;p&gt;4.三方工具navicat,用来数据传输msyql到sqlite,fiddler,用来抓包&lt;/p&gt;
&lt;p&gt;5.要会安卓的hello word&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819103423531-2055744880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.开工&lt;/h2&gt;
&lt;h3&gt;1.下载android studio&lt;/h3&gt;
&lt;p&gt;运行hello word&lt;/p&gt;
&lt;p&gt;android studio有个gradle build running时间特别长的问题很讨厌一开始就第一次快.后来就卡死了.百度的方法也用了.不怎么好使.后来清了清缓存莫名其妙的好了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819104817691-2117708913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;file:///C:/Users/TanHaiBing/Documents/Tencent%20Files/2974922536/Image/C2C/Image2/ZJWQ%7BC(_ZRU$U0H%7BR%60L42BX.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h3&gt;2.真机调试&lt;/h3&gt;
&lt;p&gt;刚开始最困难的就是有些选项不知道在哪里.一些常规的使用也不太会.真机这里就是报设备找不到.网上找的解决方案.那个按钮也没看到在哪里.后来点下面2个地方会好&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819104737213-340868173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;右边那个是我自己摸索出来的.下面的是别人告诉我的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819104536940-936428977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.布局&lt;/h3&gt;
&lt;p&gt;新手嘛.我就拖控件了.和winform差不多.textView拖得时候在中间.显示的时候就到了最上面了.这个问别人了.把截图里面的部分换成RelativeLayout.然后就正常了&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819104837857-12113121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819104912887-992361967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819104935280-1747072983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.获取控件,添加事件&lt;/h3&gt;
&lt;p&gt; 过程我都懂,代码不会,用嘴编程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819105751199-1724557166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而且坑爹的是.这个东西我没有百度到.其实这对于看视频学习的来说完全不是什么问题.我是直接上来硬干.还好可以问别人.于是别人帮我解决了.findViewById.会了不难.难了不会.....下图是获取控件和添加事件.好了拦路虎解决后.别的应该就不是什么问题了.我这样想.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819105937498-1249864291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819110033444-807167300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 5.获取文本框的值.填充的TextView中&lt;/h3&gt;
&lt;p&gt;这里无鸭梨,一开始我写复杂了.不知道这个CharSuquence就是文本框的值.我之前是重新获取了一遍.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819110240585-1592606631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6.研究SQLite&lt;/h3&gt;
&lt;p&gt;这个就简单了.到这里.网上教程一堆.想起一位朋友说的面向百度编程.百度看了下.有个抽象类.继承实现后就可以了.不过一开始想的问题是看到代码.这个数据库不会不能初始化吧.每次都需要创建.后来看到说是不存在才会创建.存在就不会了.才放心了.然后找到在本机的位置.copy出来.不过这个数据库的帮助类.这个初始化对我来说用处不大.我的数据是希望提前存储进去.这里只是查询就好了.不过这个SQLite的sql语句和mysql的不兼容.有些关键字不一样还有字段类型.&lt;/p&gt;
&lt;p&gt;这里多叨叨两句.百度的时候.看到有2个查询的方法.一个就是sql语句.一个是参数化的查询方法.把sql语句的这个位置的东西当做参数传进去.好像记得有7个参数之多......给不会sql的人用的.这里真的感觉多学点东西是有用的后台的东西.安卓也会用到.其实后面前端的东西也会用到.想到一个成语触类旁通.这个挺重要的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819110624817-200265633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7.SQLite数据初始化&lt;/h3&gt;
&lt;p&gt; 找到SQLlite的位置在data目录下面.自己的包名下面.copy出来后把mysql里面的单词数据copy进去.这个单词的数据源是之前没事的时候弄的.本来以为写了篇文章的.找了下.没想到没有.这个数据源的格式有点问题.显示的不是中文.是Unicode.记得当时解析这个东西还弄了半天.要准确的把里面的Unicode东西拿到.然后进行转换.当时用正则取的.然后就是数据传输了.这个sql语句不兼容.如果是用sql文件的话.也不能执行.好在navicat有个同步功能.可以完成.不过也有点小bug.sql估计使用单引号括起来的.然后如果字段里面有单引号就会报错.这里同步的时候.关掉事务.忽略错误.有10几个好像有问题.不过应该用不到.懒得用手处理了.传输的时间特别的长.用了快3个小时.然后SQLite的文件到了78MB.占空间还不小.有数据库后.剩下的就和后台差不多了.查询数据库.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819111956684-1734182190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819112433118-1048072954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;8.WebView研究&lt;/h3&gt;
&lt;p&gt;安卓的的这个东西小坑还不少.弄个的原因是因为找到了一个句式分析的网站.本来想接口接入的.不过他们那个接口太原始了.返回的html代码片段.没法用....还是直接嵌入网站算了.&lt;/p&gt;
&lt;p&gt;第一个小坑是loadUrl跳转浏览器.百度了一下.尝试了几个就解决了.反正就是设置一堆参数就是了.要不js什么的也不能用.js也是后面的一个坑&lt;/p&gt;
&lt;p&gt;第二个是页面load后是白屏.不显示.这个还真没找到.后来看到什么授权.我猜估计是https的原因.我一开始是访问的百度.有https.算了.我接入的也没有这个东西.换了一个就出来了.&lt;/p&gt;
&lt;p&gt;第三个网上的跳浏览器是点击链接.我的是一load就跳.这里应该是重定向的原因.相等于跳转了.又让我想到了融会贯通.这个是前端或者带点后的知识.页面重定向.&lt;/p&gt;
&lt;p&gt;第四个不是小坑就是正常的技术研究吧.执行js.首先让输入框获取焦点他会清空提示文字.这个很简单.他本来就有onclik事件.直接调用就是了.剩下的就是把传来的内容写入到页面中.这里需要一些前端的知识.&lt;/p&gt;
&lt;p&gt;第五个是个小坑.就是执行js的时候要在页面加载完后去执行.网上找了页面加载完事件.有个WebViewClient里面的事件.说是只会执行一次.有bug就没有用.不过这onProgressChanged也有bug.就是会多次被调用.而且还是百分百会执行三遍.也没找到解决办法.后来加了个标记变量.执行过后.就不在执行了.&lt;/p&gt;
&lt;p&gt;第六个用户登录信息问题.WebView自带用户信息保存.不用做模拟登录了.自己手动登录一次.完事.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819113020889-240181703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819113722482-1015253212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819113812554-1221677495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819115331956-1988015886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;9.网络请求和UI界面更新,网络权限&lt;/h3&gt;
&lt;p&gt; 这里应该是前面说的.不过没想起来.就是主线程里面不能进行网络请求.子线程不能进行界面操作.百度.这里也比较简单.不过感觉就是代码有点凌乱.3个关键字.Thread,Handler,Runnable.照猫画虎就行了.这里和winform差不多.不过winform里面没有安卓这么严格.安卓不这么做直接报错.对了还有一个权限的问题.就是网络权限.这个也需要配置一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819120359972-1247397766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;10.jar包引入&lt;/h3&gt;
&lt;p&gt;httpHelper需要用到一个 apache的包.用过maven.gradle这个使用上倒是感觉问题不大.不过不知道哪里抽风.死活引不进来.好在安卓对本地jar包的引用.可是比java Web对于本地jar包引用.友好太多了.java web得弄个私服.要不就是添加本地仓库.普通引用.打包各种问题.安卓直接丢进libs就好了.这个和.net差不多很方便.这个gradle坑先不管了.代码能跑就行.条条大道通罗马.这条不行.换一条&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819120739345-899075249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;11.activity研究&lt;/h3&gt;
&lt;p&gt; 这个百度内容也挺多的.主要就是如何创建.然后怎么显示还有参数的传递.也挺顺利的.没啥坑&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;12.有道接口研究&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 重点来了.这个小妖精有点磨人.截止我写这篇文章的时候.还没有调通.不过我相信我有办法能调通它.&lt;/p&gt;
&lt;p&gt;一开始我想简单了.以为就是一个普通的接口.结果返回errorCode:50.百度了一下.有人研究过了.也有文章.不过里面的方法没好使.我在重新梳理一遍吧.这个是百度到的文章.作者也是对这个挺清楚的.不过评论说照着文章已经不能用了.我看了下源码.好像那个盐值确实已经换了.出现问题不可怕.知道问题原因就行.我用手机调总是不行.所以第一步先不用手机调用.先自己模拟吧.&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;strong&gt;用Python破解有道翻译反爬虫机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; https://blog.csdn.net/nunchakushuang/article/details/75294947&lt;/p&gt;
&lt;p&gt;这里要用一下fiddler了.这可抓包可模拟.小神器一枚.其实在抓手机包的时候.我已经发现了一点问题.就是参数可能传错了.这里面的等于号已经被转义了.我找的那个httpHelper对参数的处理有点问题.正确的应该是a=b&amp;amp;这样之类的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819121915572-783386380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的文章知道这个接口是在本地加验证信息的.因为里面有时间.所以我的第一步猜想是这个验证信息会不会有过期时间.我用相同的header头发起了.好几次信息.并没有错误.看来是没有验证时间.只是用时间戳当验证信息了.&lt;/p&gt;
&lt;p&gt;那其实这里的salt是可以固定的.我们不需要每次去生成新的.然后就是根据文章里面的去找这个盐值了.首先下载js.然后像文章说的去格式化.保存成js.用idea打开.这个可以帮助分析语法结构.否则光靠搜索有些东西不太好找.&lt;/p&gt;
&lt;p&gt;我们根据浏览器的请求信息.直接搜索typoResult搜索.这个就一个关键字.直接就找到了.这里的压缩混淆.其实拦路的作用没有特别的大.然后看sign签名.里面有个D.这个就是放盐值的变量.如果光靠搜索.你知道是D但是这个字母太多了.你也不好搜索.放在idea.用ctrl加左键.直接就跳过去了.&lt;/p&gt;
&lt;p&gt;ok关键信息都拿到了.接下来就是模拟了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819122408770-520591498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819122501765-1800211002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819122801866-818680200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模拟部分就是找不同呗.首先先弄个正确的请求.就是浏览器发起的那个.通过body的大小.其实也可以直接去看.这个就是正确的.错误的是16.然后和手机发起的去比对.手机的少一些.经过尝试后.其中在header中有2个重要的信息一个是cookie和Referer这里没有的话.就会返回error.当然前提是body的参数要正确.这个用网页请求的那个行了.前面说过.里面的时间不会过期.可以一直用.其实http的这些header的检测都不是特别的可靠.都是可以伪造的.接下来让手机的发起的请求和浏览器一样就行了.把这两个参数补上.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819122933621-1063861144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819123037542-1934252180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看了看代码.在这个位置设置信息.于是加了个map用来传入header信息.额.....写完后才发现我说的那个必要信息上面就有..... &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819123901674-2137343002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819124301074-964089236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一运行.结果就好了........好了.我还在想会不会还有些别的坑.结果就好了...我把那个body被转义的地方改了下.盐值之前就替换好了.&lt;/p&gt;
&lt;p&gt;也不知道这个作者是怎么想的.要对body转义.要转也是我在外面转吧.你在里面一转.等于号也被你弄没了......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819125226404-1600832003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819125034795-126255542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; &lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/155324/1051D208.jpg&quot; alt=&quot;&quot;/&gt;13.结语&lt;/h2&gt;
&lt;p&gt;说实话那个有道的那个.我还说要花点时间呢.没想到下一步就是成功了.&lt;/p&gt;
&lt;p&gt;通过这个hello word的安卓程序.发现安卓的内容不是特别的多.和其它语言也有相通的地方.UI和网络请求.做过winform的会眼熟.sql数据和安卓后面的代码做过java的肯定眼熟.至于控件的属性.这个做过前端和winform都可以猜事件.httpHelper.这个后台语言都会遇到这个.c#.java.还有有道最后返回的数据JSON几乎就是通用的文本传输协议了.所以也不是什么大问题.然后这其中的主线就是&lt;strong&gt;&lt;span&gt;HTTP协议 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;这个才是融会贯通的主线.里面的requestHeader,requestBody.这个是重点.还有Cookie.要说模拟请求.一定绕不过去就是这个.cookie的domain,那个域名下面的.path.该域名下面那个路径要用.一般用/ .表示所有的路径都用.还有就是过期时间了.剩下几个header属性.需要注意Content-Type.表示我传的数据格式是什么.大家可以观察普通的post请求和上传文件的时候.这个是不一样的.还有Accept表示我想什么样的数据.不过一般不用理会.spring mvc在某些情况下会有bug.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个app剩下就是查询SQLite数据.做一下单词匹配规则.然后在抓一些英文的文章吧.可能是这些.不过说实话.安卓真的只是一个界面的承载,这后面的东西和安卓相关的真的感觉不会太多.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819130331404-1651357901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;我就是后台不精通.我就是不只写接口.我就是样样都会.样样都不行.&lt;/strong&gt; &lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/720424/201808/720424-20180819125349956-1574177539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/161104/0FD1DB5D.gif&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/161104/0FD1BDC3.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/161104/0FD172D0.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/161104/0FD1808B.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/161104/0FD182AE.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/161104/0FD185AC.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/161104/0FD18ADC.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/161104/0FD191B2.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/161104/0FD19607.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/161104/0FD197EC.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;file:///C:/Users/TANHAI~1/AppData/Local/Temp/SGPicFaceTpBq/161104/0FD199E0.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Aug 2018 05:12:00 +0000</pubDate>
<dc:creator>study的猫</dc:creator>
<og:description>1.前言 闲来无聊.手机每天又是都接触的东西.程序什么的最容易接触到.想到有些人说前后端都做就是全栈的说法.哦,你看html5全栈. 要我说多接触一些多有意思.天天写后端.还不是业务层.又不是什么高大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lansehai/p/9500357.html</dc:identifier>
</item>
<item>
<title>我的那些年(6)~在更大的学校当老师 - 张占岭</title>
<link>http://www.cnblogs.com/lori/p/9500944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lori/p/9500944.html</guid>
<description>&lt;h3 id=&quot;我的那些年6在更大的学校当老师&quot;&gt;&lt;span&gt;我的那些年(6)~在更大的学校当老师&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;开始找新的工作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;选择了八方永信学校&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;学生帮忙申请了新的email&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;酒桌上被点赞了&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;晚上下班给学生当家教&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;给育才时另一位老师讲asp&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;爷爷过世了&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;向学生购买了第一台笔记本电脑&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;平面设计学生的红牛&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;我订婚了&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;奶奶过世了&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;去唐山风岳父大人&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有了想离开的想法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;开始找新的工作&quot;&gt;&lt;span&gt;开始找新的工作&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在育才的1年多时间里，我学到了很多知识，同时这里也是我人生的起点，但人生没有有散的宴席，我是时候要选择离开了，去更大的舞台发展，在这里，我的女友也很支持我，不能一辈子在这里，我开始找新的工作了，把目标还是定在老师这个岗位上，因为这个岗位我轻车熟路！&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;选择了八方永信学校&quot;&gt;&lt;span&gt;选择了八方永信学校&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在面试的过程中，我去过金世纪，八维，前程还有几个不知名的小机构，但因为我的学历太低，没有得到机会，最后面试的八方永信，校长比较注重能力，我得到了机会，并且被录用了，那时可以拿到2000块了，自己很开心，也算是突破自我了，毕竟之前最高也就是1300元！&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;2005年挣2000块钱，和同学比起算是中等了，那时工厂的员工是1000多块钱&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;学生帮忙申请了新的email&quot;&gt;&lt;span&gt;学生帮忙申请了新的email&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;八方永信是个大学校，有很多分部，我被分到了红庙培训部，地址离CBD不太远，我是那里的主力，主要讲asp,cad,平面系列和网页系列等，记得那里有个15岁的小男孩和我学平面，很机灵，不过他已经上班了，他比较好学，自己研究了网页课程，还帮我申请了email，这个号我一直在用，就是bfyxzls@sina.com，为什么叫这样一个名字呢，小男孩说：这是八方永信张老师的第一个字母组成的，真是有心！&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;Ba Fang Yong Xing Zhang Lao Shi&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;酒桌上被点赞了&quot;&gt;&lt;span&gt;酒桌上被点赞了&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;记得我们红庙分部有一次拿了个第一，在收入方面远远领先其它分部，被总部表扬了，请我们吃了饭，在饭桌上，我被一个留学生说到：张老师，你绝非池中之物！这句话在一定程度上也鼓励了我，继续前进！&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;晚上下班给学生当家教&quot;&gt;&lt;span&gt;晚上下班给学生当家教&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在红庙上课时，有个学平面设计的男生，和我年纪差不多，南方人，私下和我说，要我单独教他，每小时给我50元，我觉得也是个挣钱的机会，就同意了，这一讲就是半年多，最后我们还成为了朋友，不过在他前几年回老家了，也没有音讯了，有时像这种朋友，在一起时没觉得怎么样，一离开后，心里还真有后酸酸的！&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;给育才时另一位老师讲asp&quot;&gt;&lt;span&gt;给育才时另一位老师讲asp&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在育才上班时，我有一位死党同事，刘阳老师，是个帅哥，他离开育才后去了金世纪，在那里呆了很多年，我在2006年八方永信时，他联系了我，叫我早上去他家，给他讲asp，这样他以后也可以为其它学生讲，多挣点薪资，我同意了，也是50元一小时，给他大概讲了有20节课，结束后也是没有联系了，事实上，在育才时，我和他相处的时间是最长的，差不多有一年，那时真的很美好，我和我女友还给他过了生日，挺开心的！&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;爷爷过世了&quot;&gt;&lt;span&gt;爷爷过世了&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;2005年5月，我家里来电话说爷爷病重，让我回去看最后一面，爷爷是个老红军，是家里的骄傲，当时也是村里唯种不多的老工人，有退休金，在爷爷奶奶的帮助下，我的童年过的很快乐，最起码比其它孩子要快乐的多，爷爷过世后，奶奶一个人了可怜多了，没有了经济收入，又没人说心里话，我又没时间回去，确实有天塌下来的感觉，那时我一周只休一天，正是谈恋爱的年纪，回去也没少，从电话里我可以听的出来，奶奶很想我，嗨，只要我一回家，奶奶想吃什么我就会骑着车去买，尽一点点孝心，其实，直到现在，我奶奶都过世12年了，我还是偶尔会梦到她老人家，想呀！&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;向学生购买了第一台笔记本电脑&quot;&gt;&lt;span&gt;向学生购买了第一台笔记本电脑&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;2005年，一个学生让我给修电脑，就是装系统，他说电脑是老板的，一个东芝的比较本，也是586，64M的内存，我帮他装上后，他拿走了，然后给我打电话说，他们老板买新电脑了，这破电脑想卖了，200块钱问我要不要，我一想怎么也是个笔记本，就买了下来，自己又装了个无线网卡，128K的速度，我开始在网上冲浪了！&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;那时的无线上网卡是个手机卡，还有个接收器，直接插在笔记本电脑，需要拨号，然后也有小猫的叫声！&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;平面设计学生的红牛&quot;&gt;&lt;span&gt;平面设计学生的红牛&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在红庙教平面时，有个女同学很客气，他总会为老师们带一罐红牛，只要你是她的老师，她一上课，准带你一罐红牛，我想这得花多少钱呀！当时记得红牛怎么也要5块，人家这么客气，咱们怎么也要多讲点知识点，这也许就是一句：拿人钱财，为人消灭吧！&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;我订婚了&quot;&gt;&lt;span&gt;我订婚了&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;2006年，我与交往快3年的女友订婚了，请了家里的亲戚朋友，一起吃了个饭，那时我们租了一个小平房，房子很小，老婆家来了爸爸，姨夫，哥哥等，记得当时坐公交到良乡，然后打了个车回家的，家里那里盖了个新房，我和我女友以后住西面的三间，我弟住中间两间，我父母住东面的三间，家里条件比较紧张，当然农村家都差不多，也没什么工作。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;奶奶过世了&quot;&gt;&lt;span&gt;奶奶过世了&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;2006年5月，我奶奶过世了，距离我爷爷过世整一年，两位老人都相继离开了我，现在和我心走的最近的就是我女朋友，希望两个人在以后的日子，相互扶持，共创自己的家园！&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;去唐山风岳父大人&quot;&gt;&lt;span&gt;去唐山风岳父大人&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;2006年春节，我去了唐山，就是我老婆的家，见我的岳父大人，我老婆母亲过世很早，我见到 岳父后，直接叫爸爸了，反正认定他闺女了，晚叫不如早叫！岳父把我让到了坑上，说和我喝两杯，我说不会喝酒，看着岳父失望的眼光我不如说会喝了，呵呵，晚上和岳父回他的住所休息了，多陪陪老爷子。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;有了想离开的想法&quot;&gt;&lt;span&gt;有了想离开的想法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;2006年11月，我在八方永信干了1年多了，突然有一种想要离开的想法，讲的课不少，薪资没有长，外面的世界很大，年青人应该出去看看，那时我的asp已经很熟练了，用dreamweaver写代码，那时感觉它是最好的IDE工具。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Aug 2018 04:39:00 +0000</pubDate>
<dc:creator>张占岭</dc:creator>
<og:description>我的那些年(6)~在更大的学校当老师 开始找新的工作 选择了八方永信学校 学生帮忙申请了新的email 酒桌上被点赞了 晚上下班给学生当家教 给育才时另一位老师讲asp 爷爷过世了 向学生购买了第一台</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lori/p/9500944.html</dc:identifier>
</item>
<item>
<title>前后端分离下如何登录 - 快乐八哥</title>
<link>http://www.cnblogs.com/liminjun88/p/frontend-backend-with-login.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liminjun88/p/frontend-backend-with-login.html</guid>
<description>&lt;h3 id=&quot;web登录涉及到知识点&quot;&gt;1 Web登录涉及到知识点&lt;/h3&gt;
&lt;h4 id=&quot;http无状态性&quot;&gt;1.1 HTTP无状态性&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;HTTP是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对于我们的应用来说，我们是靠用户来管理，而不是靠客户端。所以对我们的应用而言，它是需要有状态管理的，以便服务端能够准确的知道http请求是哪个用户发起的，从而判断该用户是否有权限继续这个请求。这个过程就是常说的&lt;strong&gt;会话管理&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;登录流程&quot;&gt;1.2 登录流程&lt;/h4&gt;
&lt;p&gt;登录的基本流程&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/59618/201808/59618-20180816092611781-493556035.png&quot; alt=&quot;web-login-flow&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;同域登录&quot;&gt;2 同域登录&lt;/h3&gt;
&lt;p&gt;目前大多数Web应用采用前后端分离方式进行开发。所以前端网站或应用都属于SPA（Single Page Application）。如果前端，后台API部署在同域下，不存在跨域的情况，登录方式相对简单。&lt;/p&gt;
&lt;h4 id=&quot;基于session登录&quot;&gt;2.1 基于Session登录&lt;/h4&gt;
&lt;p&gt;服务器端使用Session技术，浏览器端使用Cookie技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/459873/201611/459873-20161115231400951-1095594983.png&quot; alt=&quot;session-based-login&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;服务端session是用户第一次访问应用时，服务器就会创建的对象，代表用户的一次会话过程，可以用来存放数据。服务器为每一个session都分配一个唯一的sessionid，以保证每个用户都有一个不同的session对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;服务器在创建完session后，会把sessionid通过cookie返回给用户所在的浏览器，这样当用户第二次及以后向服务器发送请求的时候，就会通过cookie把sessionid传回给服务器，以便服务器能够根据sessionid找到与该用户对应的session对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;session通常有失效时间的设定，比如2个小时。当失效时间到，服务器会销毁之前的session，并创建新的session返回给用户。但是只要用户在失效时间内，有发送新的请求给服务器，通常服务器都会把他对应的session的失效时间根据当前的请求时间再延长2个小时。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;session在一开始并不具备会话管理的作用。它只有在用户登录认证成功之后，并且往sesssion对象里面放入了用户登录成功的凭证，才能用来管理会话。管理会话的逻辑也很简单，只要拿到用户的session对象，看它里面有没有登录成功的凭证，就能判断这个用户是否已经登录。当用户主动退出的时候，会把它的session对象里的登录凭证清掉。所以在用户登录前或退出后或者session对象失效时，肯定都是拿不到需要的登录凭证的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;基于token登录&quot;&gt;2.2 基于Token登录&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/459873/201611/459873-20161120210044154-648255641.png&quot; alt=&quot;token-based-login&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户在浏览器中输入用户和密码，后台服务器通过加密或者其他逻辑，生成一个Token。&lt;/li&gt;
&lt;li&gt;前端获取到Token，存储到cookie或者localStorage中，在接下来的请求中，将token通过url参数或者HTTP Header头部传入到服务器&lt;/li&gt;
&lt;li&gt;服务器获取token值，通过查找数据库判断当前token是否有效&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基于Token登录，而且可以用于第三方单点登录的OAuth2.0更适合。可以参考网址：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&quot;&gt;理解OAuth 2.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;token传入示例：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/59618/201808/59618-20180818023625525-463599259.png&quot; alt=&quot;by-cookie&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/59618/201808/59618-20180818023643013-2141566824.png&quot; alt=&quot;by-http-header&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cookie的传输&quot;&gt;3 Cookie的传输&lt;/h3&gt;
&lt;p&gt;简单地说，cookie 就是浏览器储存在用户电脑上的一小段文本文件。cookie 是纯文本格式，不包含任何可执行的代码。一个 Web 页面或服务器告知浏览器按照一定规范来储存这些信息，&lt;strong&gt;并在随后的请求中将这些信息发送至服务器&lt;/strong&gt;，Web 服务器就可以使用这些信息来识别不同的用户。大多数需要登录的网站在用户验证成功之后都会设置一个 cookie，只要这个 cookie 存在并可以，用户就可以自由浏览这个网站的任意页面。再次说明，cookie 只包含数据，就其本身而言并不有害。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同域情况下，Cookie会在随后的请求中携带&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;跨域登录&quot;&gt;4 跨域登录&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;跨越定义&lt;/strong&gt; :由于浏览器同源策略，凡是发送请求的url的协议(http和https)、域名（www.example.com,about.example.com）、端口(8010和8020)三者之间任意一个与当前页面地址不同则视为跨域。&lt;/p&gt;
&lt;h4 id=&quot;解决同源策略&quot;&gt;4.1 解决同源策略&lt;/h4&gt;
&lt;p&gt;基于Session和Token登录都要解决。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy&quot;&gt;浏览器的同源策略&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果使用同域的方法，那么浏览器会抛出如下错误。demo示例，前端运行在&lt;code&gt;http://localhost:8010/login.html&lt;/code&gt;，后台运行在&lt;code&gt;http://localhost:8020/api/login.php&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/59618/201808/59618-20180818025037687-514830877.png&quot; alt=&quot;Access-Control-Allow-Origin&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要在服务器端设置&lt;code&gt;Header&lt;/code&gt;，以PHP为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;header('Access-Control-Allow-Origin: http://localhost:8010');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置完成之后，可以发送请求了，登录成功之后跳转到&lt;code&gt;home.html&lt;/code&gt;还是显示未登录，会跳转到&lt;code&gt;login.html&lt;/code&gt;页面。效果如下图：&lt;/p&gt;
&lt;h4 id=&quot;解决请求带上cookie信息&quot;&gt;4.2 解决请求带上Cookie信息&lt;/h4&gt;
&lt;p&gt;基于Session登录才需要，因为相关信息是通过Cookie传入，如果是通过url传入，也不需要解决这个。基于Token，后续请求携带token都是通过header里面的字段，所以也不需要解决这个。&lt;/p&gt;
&lt;p&gt;跨越情况下，浏览器此时不会默认在后续请求里面携带上&lt;code&gt;Cookie&lt;/code&gt;信息，这个时候前后端都需要设置。以&lt;code&gt;jQuery&lt;/code&gt;和&lt;code&gt;PHP&lt;/code&gt;为列。&lt;/p&gt;
&lt;p&gt;前端&lt;code&gt;jQuery&lt;/code&gt;代码&lt;br/&gt;Ajax请求中药设置&lt;code&gt;xhrFields&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xhrFields: {
        withCredentials: true
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$.ajax({
    url: &quot;http://localhost:8020/api/login.php&quot;,
    type: &quot;POST&quot;,
    data: {
        username: $(&quot;#username&quot;).val(),
        password: $(&quot;#password&quot;).val()
    },
    dataType: &quot;json&quot;,
    xhrFields: {
        withCredentials: true
    }
}).done(function (response) {
    debugger;
    $(&quot;#log&quot;).html(response.message);
    window.location.href = &quot;home.html&quot;;
}).fail(function (jqXHR, textStatus) {
    console.log(&quot;Request failed: &quot; + textStatus);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后端&lt;code&gt;php&lt;/code&gt;代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*需要设置这一行，接收传入Credentials字段*/
header('Access-Control-Allow-Credentials: true');  
header('Access-Control-Allow-Origin: http://localhost:8010');&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Demo代码下载：&lt;a href=&quot;https://share.weiyun.com/5Nm46eU&quot; class=&quot;uri&quot;&gt;https://share.weiyun.com/5Nm46eU&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考链接&quot;&gt;参考链接：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000009518499&quot;&gt;HTTP无状态协议和cookie、session原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bubkoo.com/2014/04/21/http-cookies-explained/&quot;&gt;HTTP cookies 详解&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/lyzg/p/6067766.html&quot;&gt;3种web会话管理的方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://coolshell.cn/articles/5353.html&quot;&gt;你会做WEB上的用户登录功能吗？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://insights.thoughtworkers.org/web-app-authentication/&quot;&gt;登录工程：现代Web应用中的身份验证技术&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/e613a00510dd&quot;&gt;angular和jquery的 withCredentials用法&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Aug 2018 04:36:00 +0000</pubDate>
<dc:creator>快乐八哥</dc:creator>
<og:description>1 Web登录涉及到知识点 1.1 HTTP无状态性 HTTP是无状态的，一次请求结束，连接断开，下次服务器再收到请求，它就不知道这个请求是哪个用户发过来的。当然它知道是哪个客户端地址发过来的，但是对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liminjun88/p/frontend-backend-with-login.html</dc:identifier>
</item>
</channel>
</rss>