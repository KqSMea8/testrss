<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>大陆居民身份证、港澳台居民居住证 Composer 包：验证、获取基本信息以及生成假数据 - jxlwqq</title>
<link>http://www.cnblogs.com/jxlwqq/p/9620200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jxlwqq/p/9620200.html</guid>
<description>&lt;p&gt;&lt;strong&gt;中华人民共和国居民身份证&lt;/strong&gt;、&lt;strong&gt;中华人民共和国港澳居民居住证&lt;/strong&gt;以及&lt;strong&gt;中华人民共和国台湾居民居住证&lt;/strong&gt;号码验证工具（PHP Composer 版）支持 15 位与 18 位号码。基于 &lt;a href=&quot;https://github.com/mc-zone/IDValidator&quot;&gt;JavaScript 版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/jxlwqq/id-validator&quot;&gt;&lt;img src=&quot;https://travis-ci.org/jxlwqq/id-validator.svg?branch=master&quot; alt=&quot;Build Status&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://github.styleci.io/repos/147758862&quot;&gt;&lt;img src=&quot;https://github.styleci.io/repos/147758862/shield?branch=master&quot; alt=&quot;StyleCI&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://scrutinizer-ci.com/g/jxlwqq/id-validator/?branch=master&quot;&gt;&lt;img src=&quot;https://scrutinizer-ci.com/g/jxlwqq/id-validator/badges/quality-score.png?b=master&quot; alt=&quot;Scrutinizer Code Quality&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://app.fossa.io/projects/git%2Bgithub.com%2Fjxlwqq%2Fid-validator?ref=badge_shield&quot;&gt;&lt;img src=&quot;https://app.fossa.io/api/projects/git%2Bgithub.com%2Fjxlwqq%2Fid-validator.svg?type=shield&quot; alt=&quot;FOSSA Status&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;composer require &quot;jxlwqq/id-validator&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;440308199901101512&lt;/code&gt; 和 &lt;code&gt;610104620927690&lt;/code&gt; 示例大陆居民身份证均为随机生成的假数据，如撞车，请联系删除。&lt;br/&gt;&lt;code&gt;810000199408230021&lt;/code&gt; 和 &lt;code&gt;830000199201300022&lt;/code&gt; 示例港澳台居民居住证为北京市公安局公布的居住证样式号码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;验证身份证号合法性&quot;&gt;验证身份证号合法性&lt;/h3&gt;
&lt;p&gt;验证身份证号是否合法，合法返回 &lt;code&gt;true&lt;/code&gt;，不合法返回 &lt;code&gt;false&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;use Jxlwqq\IdValidator\IdValidator;

$idValidator = new IdValidator();
$idValidator-&amp;gt;isValid('440308199901101512'); // 大陆居民身份证 18 位
$idValidator-&amp;gt;isValid('610104620927690');    // 大陆居民身份证 15 位
$idValidator-&amp;gt;isValid('810000199408230021'); // 港澳居民居住证 18 位
$idValidator-&amp;gt;isValid('830000199201300022'); // 台湾居民居住证 18 位&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取身份证号信息&quot;&gt;获取身份证号信息&lt;/h3&gt;
&lt;p&gt;当身份证号合法时，返回分析信息（地区、出生日期、星座、生肖、性别、校验位），不合法返回 &lt;code&gt;false&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;use Jxlwqq\IdValidator\IdValidator;

$idValidator = new IdValidator();
$idValidator-&amp;gt;getInfo('440308199901101512'); // 18 位
$idValidator-&amp;gt;getInfo('610104620927690');    // 15 位&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回信息格式如下：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;[
'addressCode'   =&amp;gt; '440308',          // 地址码   
'abandoned'     =&amp;gt; 0,                 // 地址码是否废弃，1 为废弃的，0 为正在使用的
'address'       =&amp;gt; '广东省深圳市盐田区', // 地址
'birthdayCode'  =&amp;gt; '1999-01-10',      // 出生日期
'constellation' =&amp;gt; '水瓶座',           // 星座
'chineseZodiac' =&amp;gt; '卯兔',             // 生肖
'sex'           =&amp;gt; 1,                 // 性别，1 为男性，0 为女性
'length'        =&amp;gt; 18,                // 号码长度
'checkBit'      =&amp;gt; '2',               // 校验码
]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生成可通过校验的假数据&quot;&gt;生成可通过校验的假数据&lt;/h3&gt;
&lt;p&gt;伪造符合校验的身份证：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fakeId()&lt;/code&gt; 方法有 4 个可选参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;$eighteen&lt;/code&gt; 是否生成 18 位号码，默认为 &lt;code&gt;true&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$address&lt;/code&gt; 地址，即省市县三级地区官方全称，如&lt;code&gt;北京市&lt;/code&gt;、&lt;code&gt;台湾省&lt;/code&gt;、&lt;code&gt;香港特别行政区&lt;/code&gt;、&lt;code&gt;深圳市&lt;/code&gt;、&lt;code&gt;黄浦区&lt;/code&gt;等，默认或参数非法，则生成合法的随机地址；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$birthday&lt;/code&gt; 出生日期，如 &lt;code&gt;2000&lt;/code&gt;、&lt;code&gt;198801&lt;/code&gt;、&lt;code&gt;19990101&lt;/code&gt; 等，默认或参数非法，则生成合法的随机出生日期；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$sex&lt;/code&gt; 性别，1 为男性，0 为女性，默认或参数非法，则生成合法的随机性别；&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;use Jxlwqq\IdValidator\IdValidator;

$idValidator = new IdValidator();
$idValidator-&amp;gt;fakeId();                                    // 18 位
$idValidator-&amp;gt;fakeId(false);                               // 15 位
$idValidator-&amp;gt;fakeId(true, '上海市', '2000', 1);            // 生成出生于 2000 年上海市的男性居民身份证
$idValidator-&amp;gt;fakeId(true, '南山区', '1999', 0);            // 生成出生于 1999 年广东省深圳市南山区的女性居民身份证
$idValidator-&amp;gt;fakeId(true, '江苏省', '200001', 1));         // 生成出生于 2000 年 1 月江苏省的男性居民身份证
$idValidator-&amp;gt;fakeId(true, '厦门市', '199701', 0));         // 生成出生于 2000 年 1 月福建省厦门市的女性居民身份证
$idValidator-&amp;gt;fakeId(true, '台湾省', '20131010', 0);        // 生成出生于 2013 年 10 月 10 日台湾省的女性居民居住证
$idValidator-&amp;gt;fakeId(true, '香港特别行政区', '19970701', 0); // 生成出生于 1997 年 7 月 1 日香港特别行政区的女性居民居住证&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;h2 id=&quot;change-log&quot;&gt;Change Log&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;1.1.0 身份证号返回信息新增生肖和星座内容；&lt;/li&gt;
&lt;li&gt;1.2.0 支持港澳台居民居住证；&lt;/li&gt;
&lt;li&gt;1.3.0 行政区划代码（地址码）数据改由从中华人民共和国民政部官方网站获取；&lt;/li&gt;
&lt;li&gt;1.4.0 支持查询因行政区变更而废弃的地址码；&lt;/li&gt;
&lt;li&gt;1.4.2 &lt;code&gt;fakeId()&lt;/code&gt; 方法增加可选参数；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;license&quot;&gt;License&lt;/h2&gt;
&lt;p&gt;MIT&lt;/p&gt;
&lt;blockquote readability=&quot;2.2857142857143&quot;&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/jxlwqq/id-validator&quot; class=&quot;uri&quot;&gt;https://github.com/jxlwqq/id-validator&lt;/a&gt;，欢迎 Star。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 10 Sep 2018 07:50:00 +0000</pubDate>
<dc:creator>jxlwqq</dc:creator>
<og:description>IdValidator.php 中华人民共和国居民身份证 、 中华人民共和国港澳居民居住证 以及 中华人民共和国台湾居民居住证 号码验证工具（PHP Composer 版）支持 15 位与 18 位号</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jxlwqq/p/9620200.html</dc:identifier>
</item>
<item>
<title>MongoDB分片 在部署和维护管理 中常见事项的总结 - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9620163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9620163.html</guid>
<description>&lt;p&gt;&lt;strong&gt;分片（sharding&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;是MongoDB将大型集合分割到不同服务器（或者说集群）上所采用的方法，主要为应对高吞吐量与大数据量的应用场景提供了方法。&lt;/p&gt;
&lt;p&gt;和既有的分库分表、分区方案相比，MongoDB的最大区别在于它几乎能自动完成所有事情，只要告诉MongoDB要分配数据，它就能自动维护数据在不同服务器之间的均衡。&lt;/p&gt;

&lt;h2&gt;一. 分片的集群组件&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180910144559774-1856286967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.Mongos 【路由】  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作为请求的访问入口，所有的请求都由mongos来路由、分发、合并，这些动作对客户端driver透明，用户连接mongos就像连接mongod一样使用。Mongos会根据请求类型及shard key将请求路由到对应的Shard。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.Config Server  【配置服务器】&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt; 存储Sharding Cluster 的所有元数据，所有的元数据都存储在config数据库；&lt;/p&gt;
&lt;p&gt;*保存每个分片上的chunk的信息 * 保存chunk上的片键范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Shard  【分片】 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储应用数据记录。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;二. 分片&lt;/strong&gt;&lt;strong&gt;优势&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.对集群进行抽象，让集群“不可见”，分片对应用系统是透明的。&lt;/p&gt;
&lt;p&gt;Mongos是专有路由进程，其会将客户端发来的请求准确无误的路由到集群中的一个或者一组服务器上，同时会把接收到的响应拼装起来发回到客户端。&lt;/p&gt;
&lt;p&gt;2.保证集群总是可读写&lt;/p&gt;
&lt;p&gt;将MongoDB的分片和复制集功能结合使用，在确保数据分片到多台服务器的同时，也确保了每分数据都有相应的备份，可以确保有服务器坏掉时，其他的从库可以立即接替坏掉的部分继续工作。提高了集群的可用性和可靠性。&lt;/p&gt;
&lt;p&gt;3.使集群易于扩展&lt;/p&gt;
&lt;p&gt;当系统需要更多的空间和资源的时候，MongoDB使我们可以按需方便的扩充系统容量。&lt;/p&gt;

&lt;h2&gt; 三. 分片部署注意事项（常见错误）&lt;/h2&gt;

&lt;p&gt;1.配置可复制集作为分片节点与配置单独使用的可复制集基本一样。但启动参数中需指定—shardsvr参数。&lt;/p&gt;
&lt;p&gt;   否则，在启动数据库分片时报错：&lt;strong&gt;{&quot;code&quot; : 193,&quot;ok&quot; : 0, &quot;errmsg&quot; : &quot;Cannot accept sharding commands if not started with --shardsvr“}。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.创建配置服务器集群时，不能设置见证节点。&lt;/p&gt;
&lt;p&gt;   否则，报错 &lt;strong&gt;&quot;errmsg&quot; : &quot;Arbiters are not allowed in replica set configurations being used for config servers&quot;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.配置Mongos 实例时，请不要配置dbpath参数。&lt;/p&gt;
&lt;p&gt;   否则，设置dbpath参数，服务无法正常启动，报错：&lt;strong&gt;Error parsing INI config file: unrecognised option 'dbpath'。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4.配置Mongos 实例时，需设置Keyfile。&lt;/p&gt;
&lt;p&gt;   否则，不设置Keyfile，Service无法正常启动， 报错：2018-05-10T15:30:26.791+0800 W SHARDING [mongosMain] Error initializing sharding state, sleeping for 2 seconds and trying again :: caused by :: Unauthorized: Error loading clusterID :: caused by :: &lt;strong&gt;not authorized on config to execute command { find: “version”, readConcern: { level: “majority”, afterOpTime: { ts: Timestamp 1525937413000|2, t: 1 } }, maxTimeMS: 30000 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5.分片集合设置。&lt;/p&gt;
&lt;p&gt;   分片不会默认生成，需要先在数据库中启动分片（sh.enableSharding(“DBName”)），然后再设置集合分片（sh.shardCollection(“Collection”{片键})）&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;四. 分片管理的注意事项（常用命令）&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.检查shards 配置及状态  &lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.runCommand({listshards:1})&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180910150153488-194356443.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;2. 检查数据库主片的地址以及是否分区&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.getSiblingDB(&quot;config&quot;).databases.find()&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180910150335397-275212790.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;3. 检查数据块的数量&lt;/p&gt;
&lt;p&gt;&lt;em&gt;db.chunks.count()  --&lt;/em&gt;&lt;em&gt;需切换到配置数据库（config&lt;/em&gt;&lt;em&gt;）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180910150443065-734822680.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;4. 查看分片的详细信息，包括数据库信息和范围信息 &lt;/p&gt;
&lt;p&gt;&lt;em&gt;sh.status()&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180910150608605-1776236863.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;5. 索引是优化查询性能的重要手段。当在分片集合上声明索引时，每个分片都会为自己的集合部分定义单独的索引。分片集合只允许在_id字段和分片键上建立唯一索引。&lt;/p&gt;
&lt;p&gt;6. 分割和迁移 MongoDB底层依赖2个机制来保持集群的平衡：分割和迁移。&lt;/p&gt;
&lt;p&gt;分割是把一个大的数据块分割为2个更小的数据块的过程。迁移就是在分片之间移动数据块的过程。当某些分片服务器包含的数据块数据量大大超过其他分片服务器时就会触发迁移的过程，这个触发器叫做迁移回合（migration round）&lt;/p&gt;
&lt;p&gt;     6.1 迁移触发条件&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180910153002780-623916479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     6.2 查看Balancer 进程是否开启 &lt;em&gt;sh.getBalancerState()&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;     &lt;/em&gt;6.3 停Balancer 进程 &lt;em&gt;sh.stopBalancer()&lt;/em&gt;&lt;em&gt;和&lt;/em&gt;开启Balancer 进程&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180910153151084-1948250005.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;     6.4. 默认情况下 Balancer 进程一直在运行，为了降低Balancer进程对系统的运行，可以为Balancer进程设置运行时间窗口，让Balancer进程在指定的时间窗口操作。&lt;/p&gt;
&lt;p&gt;            6.4.1 例如设置Balancer进程在23:00到6:00时间窗口内执行。&lt;em&gt;db.settings.update({ _id : &quot;balancer&quot; }, { $set : { activeWindow : { start : &quot;23:00&quot;, stop : &quot;6:00&quot; } } }, true )  ;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;           &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180910153359439-1765809152.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;            6.4.2 删除Balancer进程运行时间窗口&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180910153500774-165254807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       6.5. 查看块的范围&lt;/p&gt;
&lt;p&gt;             6.5.1 如果集合数据量较小，可以直接通过sh.status()查看&lt;/p&gt;
&lt;p&gt;            6.5.2 如果集合数据量较大，sh.status()无法反应此集合的分块信息。此时，可通过执行以下命令查看printShardingStatus(db.getSisterDB(&quot;config&quot;),1);&lt;/p&gt;
&lt;p&gt;            6.5.3 也可将命令切换到config数据库下，执行db.chunks.find()查看。可以输入制定参数，例如，查看分片repsms2，集合cloud-docs.PushMessageRecord的块情况（cloud-docs为数据库名称）&lt;/p&gt;
&lt;p&gt;                    &lt;em&gt;db.chunks.find({&quot;shard&quot; : &quot;repsms2&quot;,&quot;ns&quot; : &quot;cloud-docs.PushMessageRecord&quot;}).pretty()&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;五. 备注&lt;/h2&gt;
&lt;p&gt;         分片集群管理的数据量比较大，并且分片的架构相对比较复杂。所以，一定在业务需求需要上分片时，再上分片，且不可准求“炫”的技术而上分片。另外，上线后，相关的监控一定要部署，逐渐完善。&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 07:45:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>分片（sharding）是MongoDB将大型集合分割到不同服务器（或者说集群）上所采用的方法，主要为应对高吞吐量与大数据量的应用场景提供了方法。 和既有的分库分表、分区方案相比，MongoDB的最大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9620163.html</dc:identifier>
</item>
<item>
<title>ElasticSearch实战 - 猿祖</title>
<link>http://www.cnblogs.com/programlearning/p/9619912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/programlearning/p/9619912.html</guid>
<description>&lt;p&gt;最近中美关系越来越紧张，国内经济下滑，股市一片惨淡，互联网行业越来越不景气，动不动都是跌掉几千亿市值，来写一些文档来抚慰这颗受伤的心吧。。。&lt;/p&gt;
&lt;p&gt;随着互联网的发展，数据越来越重要，每个公司保存的数据也是越来越多，不管做什么产品，存储和搜索这些数据都面临着一些挑战，很多数据在存储了之后，基本上都被雪藏了，找不到了，更谈不上从垃圾里面找黄金了（这可能设计数据分析了，暂且不讲），那我们    今天要解决的第一步是怎么从大海里面把某一个针找到，目前市场上活跃的搜索开源产品很多，例如coreseek，solr，ElasticSearch，我们今天就来讲讲目前用的最广泛的ElasticSearch。&lt;/p&gt;
&lt;p&gt;搜索基本上都是围绕几个方面来的：&lt;/p&gt;
&lt;p&gt;1.索引问题&lt;/p&gt;
&lt;p&gt;           按照什么策略来生成索引 （按照数据数量）&lt;/p&gt;
&lt;p&gt;           怎么合理的生成相关的mapping&lt;/p&gt;
&lt;p&gt;           每个索引包含多少个shard，replication&lt;/p&gt;
&lt;p&gt;           每个shard的大小应该是多少&lt;/p&gt;
&lt;p&gt;           数据flush和refresh设计多大才好呢&lt;/p&gt;
&lt;p&gt;           中文字段有什么分词，使搜索更准确&lt;/p&gt;
&lt;p&gt;           索引多久进行合并，多久合并一次        &lt;/p&gt;
&lt;p&gt;           如果数据源为数据库，那么多个表，每一个是生成一个type呢？还是生成一个索引&lt;/p&gt;
&lt;p&gt;2.搜索问题&lt;/p&gt;
&lt;p&gt;           数据越来越多，如何能保证搜索的速度&lt;/p&gt;
&lt;p&gt;           如果是中文，怎么保证搜索的相关性最强&lt;/p&gt;
&lt;p&gt;           搜索时，多个shard的数据怎么进行整合，返回给client方&lt;/p&gt;
&lt;p&gt;           搜索Client用那种方式&lt;/p&gt;
&lt;p&gt;           搜索内部用了什么算法来保证搜索速度&lt;/p&gt;
&lt;p&gt;           搜索时用query还是filter&lt;/p&gt;
&lt;p&gt;3.集群稳定性&lt;/p&gt;
&lt;p&gt;           master的选举用什么算法，怎么保证不会脑裂&lt;/p&gt;
&lt;p&gt;           大量生成mapping时，大量的网络传输，会不会造成，集群假死（不进行响应）&lt;/p&gt;
&lt;p&gt;           生成的mapping在集群中是怎么保存的  &lt;/p&gt;
&lt;p&gt;           部署集群是JVM应该怎么分配&lt;/p&gt;
&lt;p&gt;   上面一些问题，基本上在初学或者后面的使用中多多少少都会遇到，我们怎么能避免这些问题呢，且听后面文章一篇一篇详细的剖析，系统通过这一系列文档来帮助一些初学者或者有同样困惑的小伙伴们&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 07:18:00 +0000</pubDate>
<dc:creator>猿祖</dc:creator>
<og:description>最近中美关系越来越紧张，国内经济下滑，股市一片惨淡，互联网行业越来越不景气，动不动都是跌掉几千亿市值，来写一些文档来抚慰这颗受伤的心吧。。。 随着互联网的发展，数据越来越重要，每个公司保存的数据也是越</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/programlearning/p/9619912.html</dc:identifier>
</item>
<item>
<title>go微服务框架go-micro深度学习(二) 入门例子 - lpxxn</title>
<link>http://www.cnblogs.com/li-peng/p/9598879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/li-peng/p/9598879.html</guid>
<description>&lt;p&gt;    上一篇帖子简单介绍了go-micro的整体框架结构，这一篇主要写go-micro使用方式的例子，中间会穿插一些go-micro的源码，和调用流程图，帮大家更好的理解go-micro的底层。更详细更具体的调用流程和细节，会在以后的帖子里详细讲解。&lt;/p&gt;
&lt;p&gt;     例子的github地址： &lt;span&gt;&lt;a href=&quot;https://github.com/lpxxn/gomicrorpc&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;gomicrorpc&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;   跑一遍例子，也就会明白个大概。&lt;/p&gt;
&lt;h3&gt;安装所需要的环境&lt;/h3&gt;
&lt;p&gt;    go-micro服务发现默认使用的是&lt;a href=&quot;https://www.consul.io/downloads.html&quot; target=&quot;_blank&quot;&gt;consul&lt;/a&gt;，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;brew install consul
consul agent &lt;/span&gt;-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   或者直接使用使用docker跑&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run -p &lt;span&gt;8300&lt;/span&gt;:&lt;span&gt;8300&lt;/span&gt; -p &lt;span&gt;8301&lt;/span&gt;:&lt;span&gt;8301&lt;/span&gt; -p &lt;span&gt;8301&lt;/span&gt;:&lt;span&gt;8301&lt;/span&gt;/udp -p &lt;span&gt;8302&lt;/span&gt;:&lt;span&gt;8302&lt;/span&gt;/udp -p &lt;span&gt;8302&lt;/span&gt;:&lt;span&gt;8302&lt;/span&gt; -p &lt;span&gt;8400&lt;/span&gt;:&lt;span&gt;8400&lt;/span&gt; -p &lt;span&gt;8500&lt;/span&gt;:&lt;span&gt;8500&lt;/span&gt; -p &lt;span&gt;53&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;/udp consul
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    我个人更喜欢&lt;a href=&quot;https://github.com/etcd-io/etcd/tree/v3.2.17&quot; target=&quot;_blank&quot;&gt;etcdv3&lt;/a&gt;原因我上一篇也有提到过，gomicro服务发现不支持consul集群，我之前也写过&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/li-peng/p/9259793.html&quot; target=&quot;_blank&quot;&gt;etcdv3 集群的搭建和使用&lt;/a&gt;帖子，有时间大家可以看一下&lt;/p&gt;
&lt;p&gt;    安装go-micro框架&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
go &lt;span&gt;get&lt;/span&gt; github.com/micro/go-micro
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    安装protobuf和依赖 prtobuf的基础知识我这里就不讲了，如果不了解的可以看一下&lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;，就是一个跨平台，跨语言的数据序列化库，简单易学。&lt;/p&gt;
&lt;p&gt;    是go-micro用于帮助我们生成服务接口和一系列的调用代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;brew install protobuf
go &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; -u -v github.com/golang/protobuf/{proto,protoc-gen-&lt;span&gt;go}
go &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; -u -v github.com/micro/protoc-gen-micro
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    protobuf也可以直接从源码安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
wget https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/protocolbuffers/protobuf/releases/download/v3.6.1/protobuf-all-3.6.1.tar.gz&lt;/span&gt;
tar zxvf protobuf-all-&lt;span&gt;3.6&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.tar.gz
cd protobuf&lt;/span&gt;-&lt;span&gt;3.6&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;
.&lt;/span&gt;/&lt;span&gt;autogen.sh
.&lt;/span&gt;/&lt;span&gt;configure
 make
make install
protoc &lt;/span&gt;-h
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    安装micro工具包，这个安装是可选项，micro提供了一系列的工具来帮助我们更好的使用go-micro。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
go &lt;span&gt;get&lt;/span&gt; github.com/micro/micro
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;例子1&lt;/h3&gt;
&lt;p&gt;创建proto文件common.proto，这个文件包含了传入和返回的参数，参数包含了常用的基础类型、数组、map等。还有一个Say 服务，这个服务里有一个rpc方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
syntax = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;proto3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

package model;

message SayParam {
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; msg = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

message Pair {
    int32 key &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; values = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
}

message SayResponse {
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; msg = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数组&lt;/span&gt;
    repeated &lt;span&gt;string&lt;/span&gt; values = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; map&lt;/span&gt;
    map&amp;lt;&lt;span&gt;string&lt;/span&gt;, Pair&amp;gt; header = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
    RespType type &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; RespType {
    NONE &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    ASCEND &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    DESCEND &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 服务接口&lt;/span&gt;
&lt;span&gt;service Say {
    rpc Hello(SayParam) returns (SayResponse) {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在根目录下运行，生成两个模板文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  protoc --proto_path=$GOPATH/src:. --micro_out=. --go_out=. example1/proto&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.proto &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一个文件是proto的go 结构文件，还有一个go-micro rpc的接口文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/342595/201809/342595-20180907150405109-591572775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;server 端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
type Say &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {}

func (s &lt;/span&gt;*Say) Hello(ctx context.Context, req *model.SayParam, rsp *&lt;span&gt;model.SayResponse) error {
    fmt.Println(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;received&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, req.Msg)
    rsp.Header &lt;/span&gt;= make(map[&lt;span&gt;string&lt;/span&gt;]*&lt;span&gt;model.Pair)
    rsp.Header[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &amp;amp;model.Pair{Key: &lt;span&gt;1&lt;/span&gt;, Values: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}

    rsp.Msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    rsp.Values &lt;/span&gt;= append(rsp.Values, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    rsp.Type &lt;/span&gt;=&lt;span&gt; model.RespType_DESCEND

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
}


func main() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我这里用的etcd 做为服务发现，如果使用consul可以去掉&lt;/span&gt;
    reg := etcdv3.NewRegistry(func(op *&lt;span&gt;registry.Options){
        op.Addrs &lt;/span&gt;= []&lt;span&gt;string&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.3.34:2379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.3.18:2379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.3.110:2379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        }
    })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化服务&lt;/span&gt;
    service :=&lt;span&gt; micro.NewService(
        micro.Name(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lp.srv.eg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        micro.Registry(reg),
    )

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册 Handler&lt;/span&gt;
    model.RegisterSayHandler(service.Server(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(Say))

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; run server&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; err := service.Run(); err !=&lt;span&gt; nil {
        panic(err)
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务发现我使用的是etcdv3  替换了默认的consul&lt;/p&gt;
&lt;p&gt;micro.NewService 初始化服务，然后返回一个Service接口的实例，newService()方法的大概流程如下，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/342595/201809/342595-20180907170216034-815207293.png&quot; alt=&quot;&quot; width=&quot;997&quot; height=&quot;451&quot;/&gt;&lt;/p&gt;

&lt;p&gt;先是给各个接口初始化默认值，再使用传入的值替换默认值，这也是go-micro可替换插件的地方。&lt;/p&gt;
&lt;p&gt;service有一个Init()可选方法，这是一个单例方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
func (s *&lt;span&gt;service) Init(opts ...Option) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; process options&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; _, o :=&lt;span&gt; range opts {
        o(&lt;/span&gt;&amp;amp;&lt;span&gt;s.opts)
    }

    s.once.Do(func() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; save user action&lt;/span&gt;
        action :=&lt;span&gt; s.opts.Cmd.App().Action
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set service action&lt;/span&gt;
        s.opts.Cmd.App().Action = func(c *&lt;span&gt;cli.Context) {
                .........&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里就不把代码全显示出来了&lt;/span&gt;
&lt;span&gt;                .........
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;官方的例子中者有显示调用，其实是不必的，因为在替换默认值的时候都会调用Init方法&lt;/p&gt;
&lt;p&gt;比如micro.Name()方法，已经调用了Init()方法了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Name of the service&lt;/span&gt;
func Name(n &lt;span&gt;string&lt;/span&gt;&lt;span&gt;) Option {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(o *&lt;span&gt;Options) {
        o.Server.Init(server.Name(n))
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; service.Run()方法 调用流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/342595/201809/342595-20180907160423832-1369247551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   因为在初始化的时候没有指定端口，系统会自动分配一个端口号分给Server，并把这个server的信息注册到Register。&lt;/p&gt;
&lt;p&gt;   BeferStart和AfterStart也都是可以自定义的&lt;/p&gt;
&lt;p&gt;client 端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;func main() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我这里用的etcd 做为服务发现，如果使用consul可以去掉&lt;/span&gt;
    reg := etcdv3.NewRegistry(func(op *&lt;span&gt;registry.Options){
        op.Addrs &lt;/span&gt;= []&lt;span&gt;string&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.3.34:2379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.3.18:2379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.3.110:2379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        }
    })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化服务&lt;/span&gt;
    service :=&lt;span&gt; micro.NewService(
        micro.Registry(reg),
    )

    sayClent :&lt;/span&gt;= model.NewSayService(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lp.srv.eg1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, service.Client())


    rsp, err :&lt;/span&gt;= sayClent.Hello(context.Background(), &amp;amp;model.SayParam{Msg: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello server&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;})
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        panic(err)
    }

    fmt.Println(rsp)

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上面根据proto文件的生成的两个文件中有一个是rpc的接口文件，接口文件已经帮我们把调用方法的整个流程封装好了。&lt;/p&gt;
&lt;p&gt;  只需要给出服务名称和licent就可以。然后调用Hello方法&lt;/p&gt;
&lt;p&gt;  源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
func (c *sayService) Hello(ctx context.Context, &lt;span&gt;in&lt;/span&gt; *SayParam, opts ...client.CallOption) (*&lt;span&gt;SayResponse, error) {
    req :&lt;/span&gt;= c.c.NewRequest(c.name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Say.Hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;in&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;out&lt;/span&gt; := &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(SayResponse)
    err :&lt;/span&gt;= c.c.Call(ctx, req, &lt;span&gt;out&lt;/span&gt;&lt;span&gt;, opts...)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err !=&lt;span&gt; nil {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil, err
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;, nil
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 主要的流程里都在c.c.Call方法里。简单来说流程如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/342595/201809/342595-20180907165930746-905093013.png&quot; alt=&quot;&quot; width=&quot;841&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;

&lt;p&gt;就是得到节点信息address，根据address去查询 pool里是否有连接，如果有则取出来，如果没有则创建，然后进行数据传输，传输完成后把client放回到pool内。pool的大小也是可以控制的，这部分的代码读起来特别爽，具体的细节和处理流程会在以后的帖子里详细讲解&lt;/p&gt;
&lt;h3&gt; 例子2&lt;/h3&gt;
&lt;p&gt;    例子1，做了一个简单的服务，已经不能再简单了，只是为了能让大家熟悉一下go-micro。看完例子1后应该会有更多的想法，想使用更多的go-micro的功能，比如protobuf生成的类都在一起，如果想model和api分开怎么处理，怎么使用go-micro的双向流，怎么使用消息推送，等等。所以我就双做了一个小例子，这个例子里包含了一些东西。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/342595/201809/342595-20180910150343405-1783830623.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    这个例子我就只说一下组织结构，也没有多少代码，大家有时间看一下就ok了。&lt;/p&gt;
&lt;p&gt;    proto下的两个文件夹，一个model一个rpcapi，是把数据和api分开，api引用了model&lt;/p&gt;
&lt;p&gt;看一下rpcapi&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
syntax = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;proto3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

package rpcapi;
import &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;github.com/lpxxn/gomicrorpc/example2/proto/model/common.proto&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 服务接口&lt;/span&gt;
&lt;span&gt;service Say {
    rpc Hello(model.SayParam) returns (model.SayResponse) {}
    rpc Stream(model.SRequest) returns (stream model.SResponse) {}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    import了model里的common.proto&lt;/p&gt;
&lt;p&gt;在生成的时候一个只要go_out另一个只要micro_out就好了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  protoc --proto_path=$GOPATH/src:. --go_out=. example2/proto/model&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.proto 
  
  protoc --proto_path=$GOPATH/src:. --micro_out=. example2/proto/rpcapi/*.proto &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    订阅一个信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register Subscribers&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; err := server.Subscribe(server.NewSubscriber(common.Topic1, subscriber.Handler)); err !=&lt;span&gt; nil {
        panic(err)
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   当有信息发送时，所有订阅了lp.srv.eg2.topic1这个信息的服务都会收到信息&lt;/p&gt;
&lt;p&gt;   客户端发送信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    p :=&lt;span&gt; micro.NewPublisher(common.Topic1, service.Client())
    p.Publish(context.TODO(), &lt;/span&gt;&amp;amp;model.SayParam{Msg: lib.RandomStr(lib.Random(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;))})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   如果是生产环境一定不要用go-micro默认的信息发布和订阅处理方式，micro的插件plugin里是有很多成熟的插件。&lt;/p&gt;
&lt;p&gt;   使用双向流的小功能&lt;/p&gt;
&lt;p&gt;   这个方法只是每次向客户端发送一些数据，每次只发送一部分。比如我们给客户端推送的数据很大时，一次性全都推过去，是不太正确的做法，分批推送还是比较好的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
func (s *Say) Stream(ctx context.Context, req *&lt;span&gt;model.SRequest, stream rpcapi.Say_StreamStream) error {

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;int&lt;/span&gt;(req.Count); i++&lt;span&gt; {
        rsp :&lt;/span&gt;= &amp;amp;&lt;span&gt;model.SResponse{}
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j := lib.Random(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;); j &amp;lt; &lt;span&gt;10&lt;/span&gt;; j++&lt;span&gt; {
            rsp.Value &lt;/span&gt;= append(rsp.Value, lib.RandomStr(lib.Random(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)))
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; err := stream.Send(rsp); err !=&lt;span&gt; nil {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟处理过程&lt;/span&gt;
        time.Sleep(time.Microsecond * &lt;span&gt;50&lt;/span&gt;&lt;span&gt;)
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nil
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    希望这个小例子能让大家入门go-micro.&lt;/p&gt;

</description>
<pubDate>Mon, 10 Sep 2018 07:18:00 +0000</pubDate>
<dc:creator>lpxxn</dc:creator>
<og:description>上一篇帖子简单介绍了go-micro的整体框架结构，这一篇主要写go-micro使用方式的例子，中间会穿插一些go-micro的源码，和调用流程图，帮大家更好的理解go-micro的底层。更详细更具体</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/li-peng/p/9598879.html</dc:identifier>
</item>
<item>
<title>【原创】数据库优化的几个阶段 - 孤独烟</title>
<link>http://www.cnblogs.com/rjzheng/p/9619855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rjzheng/p/9619855.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;大家在面试的时候，是否遭遇过，面试官询问&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;你们是如何进行数据库优化的?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那这个问题应该怎么答呢？其实写这个题材的原因是我这几天看到各公众号转的一篇数据库调优的知识（不上链接了），我就稍微翻了几下，上面动不动就来说要对数据库进行&lt;strong&gt;水平拆分&lt;/strong&gt;，我就想反问各位读者，你们几个人经历过&lt;strong&gt;水平拆分&lt;/strong&gt;?现在很多文章，实践性实在太差，只能说纯理论分析。&lt;br/&gt;这篇文章最早来自知乎的一个提问，我在其基础上完善了一下。&lt;/p&gt;
&lt;h2 id=&quot;第一阶段-优化sql和索引&quot;&gt;第一阶段 优化sql和索引&lt;/h2&gt;
&lt;p&gt;这才是调优的第一阶段啊，&lt;strong&gt;为什么呢？&lt;/strong&gt;&lt;br/&gt;因为这一步成本最低啊，不需要加什么中间件。你没经过索引优化和SQL优化，就来什么&lt;strong&gt;水平拆分&lt;/strong&gt;，这不是坑人么。&lt;br/&gt;那&lt;strong&gt;步骤&lt;/strong&gt;是什么样呢?我说个大概&lt;br/&gt;(1)用慢查询日志定位执行效率低的&lt;code&gt;SQL&lt;/code&gt;语句&lt;br/&gt;(2)用&lt;code&gt;explain&lt;/code&gt;分析&lt;code&gt;SQL&lt;/code&gt;的执行计划&lt;br/&gt;(3)确定问题，采取相应的优化措施，建立索引啊，等&lt;br/&gt;我就不举例了，因为如何优化SQL的文章，一抓一大把，再贴过来，读者看着也累。&lt;/p&gt;
&lt;h2 id=&quot;第二阶段-搭建缓存&quot;&gt;第二阶段 搭建缓存&lt;/h2&gt;
&lt;p&gt;在优化sql无法解决问题的情况下，才考虑搭建缓存。毕竟你使用缓存的目的，就是将复杂的、耗时的、不常变的执行结果缓存起来，降低数据库的资源消耗。&lt;br/&gt;这里需要&lt;strong&gt;注意&lt;/strong&gt;的是:搭建缓存后，系统的复杂性增加了。你需要考虑很多问题，比如:&lt;/p&gt;
&lt;h2 id=&quot;第三阶段-读写分离&quot;&gt;第三阶段 读写分离&lt;/h2&gt;
&lt;p&gt;缓存也搞不定的情况下，搞主从复制，上读写分离。在应用层，区分读写请求。或者利用现成的中间件mycat或者altas等做读写分离。&lt;br/&gt;需要注意的是,只要你敢说你用了主从架构，有三个问题，你要准备:&lt;br/&gt;(1)主从的好处？&lt;br/&gt;回答:实现数据库备份，实现数据库负载均衡，提交数据库可用性&lt;br/&gt;(2)主从的原理?&lt;br/&gt;回答:如图所示（图片不是自己画的，偷懒了）&lt;br/&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SYoYmIOcI5rIULRDQY7qTsS0tuwibBmicygicicXxegYbgrFBFU4faJmRGUJ9rnia1meNnINJBtFRZ8jbN87NR3ZlWg/0?wx_fmt=png&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;主库有一个&lt;code&gt;log dump&lt;/code&gt;线程，将&lt;code&gt;binlog&lt;/code&gt;传给从库&lt;br/&gt;从库有两个线程，一个I/O线程，一个SQL线程，I/O线程读取主库传过来的&lt;code&gt;binlog&lt;/code&gt;内容并写入到&lt;code&gt;relay log&lt;/code&gt;,SQL线程从&lt;code&gt;relay log&lt;/code&gt;里面读取内容，写入从库的数据库。&lt;/p&gt;
&lt;p&gt;(3)如何解决主从一致性?&lt;br/&gt;回答:这个问题，我不建议在数据库层面解决该问题。根据CAP定理，主从架构本来就是一种高可用架构，是无法满足一致性的&lt;br/&gt;哪怕你采用同步复制模式或者半同步复制模式，都是弱一致性，并不是强一致性。所以，推荐还是利用缓存，来解决该问题。&lt;br/&gt;步骤如下:&lt;br/&gt;1、自己通过测试，计算主从延迟时间，建议mysql版本为5.7以后，因为mysql自5.7开始，多线程复制功能比较完善，一般能保证延迟在1s内。不过话说回来，mysql现在都出到8.x了，还有人用5.x的版本么。&lt;br/&gt;2、数据库的写操作，先写数据库，再写cache，但是有效期很短，就比主从延时的时间稍微长一点。&lt;br/&gt;3、读请求的时候，先读缓存，缓存不存在(这时主从同步已经完成)，再读数据库。&lt;/p&gt;
&lt;h2 id=&quot;第四阶段-利用分区表&quot;&gt;第四阶段 利用分区表&lt;/h2&gt;
&lt;p&gt;说句实在话，你们面试的时候，其实可以略过这个阶段。因为很多互联网公司都不建议用分区表，我自己也不太建议用分区表，采用这个分区表，坑太多。&lt;br/&gt;这里引用一下其他文章的回答:&lt;br/&gt;&lt;strong&gt;什么是mysql的分区表？&lt;/strong&gt;&lt;br/&gt;回答：所有数据还在一个表中，但物理存储根据一定的规则放在不同的文件中。这个是mysql支持的功能，业务代码不需要改动，但是sql语句需要改动，sql条件需要带上分区的列。&lt;br/&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;br/&gt;(1)分区键设计不太灵活，如果不走分区键，很容易出现全表锁&lt;br/&gt;(2)在分区表使用&lt;code&gt;ALTER TABLE&lt;/code&gt; … &lt;code&gt;ORDER BY&lt;/code&gt;，只能在每个分区内进行&lt;code&gt;order by&lt;/code&gt;。&lt;br/&gt;(3)分区表的分区键创建索引，那么这个索引也将被分区。分区键没有全局索引一说。&lt;br/&gt;(4)自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定该去哪个分区查，不太可控。&lt;br/&gt;...不列举了，不推荐&lt;/p&gt;
&lt;h2 id=&quot;第五阶段-垂直拆分&quot;&gt;第五阶段 垂直拆分&lt;/h2&gt;
&lt;p&gt;上面四个阶段都没搞定，就来垂直拆分了。垂直拆分的复杂度还是比水平拆分小的。将你的表，按模块拆分为不同的小表。大家应该都看过《大型网站架构演变之路》，这种类型的文章或者书籍，基本都有提到这一阶段。&lt;br/&gt;如果你有幸能够在什么运营商、银行等公司上班，你会发现他们一个表，几百个字段都是很常见的事情。所以，应该要进行拆分，拆分原则一般是如下三点:&lt;br/&gt;(1)把不常用的字段单独放在一张表。&lt;br/&gt;(2)把常用的字段单独放一张表&lt;br/&gt;(3)经常组合查询的列放在一张表中（联合索引）。&lt;/p&gt;
&lt;h2 id=&quot;第六阶段-水平拆分&quot;&gt;第六阶段 水平拆分&lt;/h2&gt;
&lt;p&gt;OK,水平拆分是最麻烦的一个阶段，拆分后会有很多的问题，我再强调一次，水平拆分一定是最最最最后的选择。从某种意义上，我觉得还不如垂直拆分。因为你用垂直拆分，分成不同模块后，发现单模块的压力过大，你完全可以给该模块单独做优化，例如提高该模块的机器配置等。如果是水平拆分，拆成两张表，代码需要变动，然后发现两张表还不行，再变代码，再拆成三张表的？水平拆分模块间耦合性太强，成本太大，不是特别推荐。&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 07:15:00 +0000</pubDate>
<dc:creator>孤独烟</dc:creator>
<og:description>引言 大家在面试的时候，是否遭遇过，面试官询问 你们是如何进行数据库优化的? 那这个问题应该怎么答呢？其实写这个题材的原因是我这几天看到各公众号转的一篇数据库调优的知识（不上链接了），我就稍微翻了几下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rjzheng/p/9619855.html</dc:identifier>
</item>
<item>
<title>css布局 - 常规上中下分左右布局的一百种实现方法（更新中...） - xing.org1^</title>
<link>http://www.cnblogs.com/padding1015/p/9577961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/padding1015/p/9577961.html</guid>
<description>&lt;h2&gt;一、 上中下左固定 - fixed+margin&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180910115218575-1645342289.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概括：&lt;/strong&gt;如图，此种布局就是顶部、底部和左侧固定不动，只有中间右侧超出可滚动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;html：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;header&amp;gt;我是头部position: fixed;z-index: 9;&amp;lt;/header&amp;gt;
    &amp;lt;section class=&quot;flexModal fixedLeft&quot;&amp;gt;
      &amp;lt;nav&amp;gt;
        &amp;lt;ul&amp;gt;
          &amp;lt;li&amp;gt;section.flexModal nav ul&amp;gt;li*5&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;栏目一&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;栏目二&amp;lt;/li&amp;gt;
          &amp;lt;li class=&quot;active&quot;&amp;gt;栏目三&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;栏目四&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;栏目五&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/nav&amp;gt;
      &amp;lt;article&amp;gt;
        &amp;lt;h3&amp;gt;
          内容区域 section.flexModal articel
        &amp;lt;/h3&amp;gt;
        &amp;lt;p&amp;gt;
          section{
            padding: 60px 0;
          }
        &amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt; 
          section.flexModal{
            display: flex;
          }
        &amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt; 
          section.flexModal nav{
            width: 200px;
          }
        &amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt; 
          section.flexModal article{
            flex: 1;
          }
        &amp;lt;/p&amp;gt;
      &amp;lt;/article&amp;gt;
    &amp;lt;/section&amp;gt;
    &amp;lt;footer&amp;gt;底部版权同头部 position: fixed;z-index: 9;&amp;lt;/footer&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;css：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:css;collapse:true;;gutter:true;&quot;&gt;
body,ul,li{
  /* position: relative; */
  margin: 0;
  padding: 0;
  font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
  list-style: none;
}
header,footer{
  position: fixed;
  z-index: 9;
  width: 100%;
  height: 60px;
  font-size: 24px;
  color: #333;
  font-weight: bold;
  text-align: center;
  line-height: 60px;
  background: #77d677;
}
footer{
  bottom: 0;
}
section{
  padding: 60px 0;
}
nav{
  background: #93f393;
  color: #333;
}
nav li{
  padding: 10px 20px;
}
nav li.active{
  background: #77d677;
}
article{
  padding: 20px;
  font-size: 24px;
  text-align: center;
  background: #d9ffd9;
  height: 2500px;
}
/* default */
section.default nav{
  position: absolute;
  top: 60px;
  bottom: 60px;
  /* float: left;
  height: 100%; */
  width: 200px;
}
section.default nav li{
  padding: 10px 20px;
}
section.default nav li.active{
  background: #77d677;
}
section.default article{
  padding-left: 220px;
}
/* flexModal */
section.flexModal{
  display: flex;
}
section.flexModal nav{
  width: 200px;
}
section.flexModal article{
  flex: 1;
}

/* fixedLeft */
section.fixedLeft nav{
  position: fixed;
  top: 60px;
  bottom: 60px;
}
section.fixedLeft article{
  margin-left: 200px;  
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上下部分就是普通处理，fixed固定布局&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;position: fixed;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;中间利用上下padding，留出上下部分的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180910131636426-1928869614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左侧nav栏目，要固定也要用fixed。不过固定定位的元素要想高度百分百，可以使用top+bottom对应方位值的拉伸效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;section.fixedLeft nav &lt;/span&gt;{&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; fixed&lt;/span&gt;;&lt;span&gt;
    top&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;&lt;span&gt;
    bottom&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之所以top:60;bottom:60;是因为header和footer的高度均为60px；&lt;/p&gt;

&lt;p&gt;这里，&lt;span&gt;&lt;strong&gt;section的flex布局可以不存在&lt;/strong&gt;&lt;/span&gt;，因为右边内容区域使用margin-left边距值留出了左侧nav的位置，作为block布局流体自适应占满右侧剩余空间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;section.fixedLeft article &lt;/span&gt;{&lt;span&gt;
    margin-left&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;fixed固定定位&lt;/li&gt;
&lt;li&gt;top+bottom方位值拉伸&lt;/li&gt;
&lt;li&gt;margin边距&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;二、上中下 左不固定 - flex&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180910115357425-701112897.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概括：&lt;/strong&gt;如图，此种布局大致同第一幅，顶部、底部固定不动，只有整个中间区域可滚动，包括左侧菜单栏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;html :&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;header&amp;gt;我是头部position: fixed;z-index: 9;&amp;lt;/header&amp;gt;
    &amp;lt;section class=&quot;flexModal&quot;&amp;gt;
      &amp;lt;nav&amp;gt;
        &amp;lt;ul&amp;gt;
          &amp;lt;li&amp;gt;section.flexModal nav ul&amp;gt;li*5&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;栏目一&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;栏目二&amp;lt;/li&amp;gt;
          &amp;lt;li class=&quot;active&quot;&amp;gt;栏目三&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;栏目四&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;栏目五&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/nav&amp;gt;
      &amp;lt;article&amp;gt;
        &amp;lt;h3&amp;gt;
          内容区域 section.flexModal articel
        &amp;lt;/h3&amp;gt;
        &amp;lt;p&amp;gt;
          section{
            padding: 60px 0;
          }
        &amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt; 
          section.flexModal{
            display: flex;
          }
        &amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt; 
          section.flexModal nav{
            width: 200px;
          }
        &amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt; 
          section.flexModal article{
            flex: 1;
          }
        &amp;lt;/p&amp;gt;
      &amp;lt;/article&amp;gt;
    &amp;lt;/section&amp;gt;
    &amp;lt;footer&amp;gt;底部版权同头部 position: fixed;z-index: 9;&amp;lt;/footer&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;css：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:css;collapse:true;;gutter:true;&quot;&gt;
body,ul,li{
  /* position: relative; */
  margin: 0;
  padding: 0;
  font-family: 'Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif;
  list-style: none;
}
header,footer{
  position: fixed;
  z-index: 9;
  width: 100%;
  height: 60px;
  font-size: 24px;
  color: #333;
  font-weight: bold;
  text-align: center;
  line-height: 60px;
  background: #77d677;
}
footer{
  bottom: 0;
}
section{
  padding: 60px 0;
}
nav{
  background: #93f393;
  color: #333;
}
nav li{
  padding: 10px 20px;
}
nav li.active{
  background: #77d677;
}
article{
  padding: 20px;
  font-size: 24px;
  text-align: center;
  background: #d9ffd9;
  height: 2500px;
}
/* default */
section.default nav{
  position: absolute;
  top: 60px;
  bottom: 60px;
  /* float: left;
  height: 100%; */
  width: 200px;
}
section.default nav li{
  padding: 10px 20px;
}
section.default nav li.active{
  background: #77d677;
}
section.default article{
  padding-left: 220px;
}
/* flexModal */
section.flexModal{
  display: flex;
}
section.flexModal nav{
  width: 200px;
}
section.flexModal article{
  flex: 1;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上中下同第一个，不再赘述。&lt;/p&gt;
&lt;p&gt;这里唯一不同的是左侧菜单栏要同内容区域一同滚动：&lt;/p&gt;
&lt;p&gt;去掉fixed固定定位即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180910132530981-1787041616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时，要想右侧全部展开，即占满出nav部分的右侧全部空间，可以使用flex布局：&lt;/p&gt;
&lt;p&gt;父元素section:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;section.flexModal &lt;/span&gt;{&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; flex&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;右侧内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;section.flexModal article &lt;/span&gt;{&lt;span&gt;
    flex&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者其他两列布局的方式，比如浮动、margin负边距实现。&lt;/p&gt;
&lt;p&gt;具体实现方法同三列布局的各种方法原理一致。链接：&lt;a href=&quot;http://www.cnblogs.com/padding1015/p/7479956.html&quot; target=&quot;_blank&quot;&gt;CSS-三栏响应式布局（左右固宽，中间自适应）的五种方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;fixed固定定位&lt;/p&gt;
&lt;p&gt;flex布局&lt;/p&gt;

&lt;h2&gt;三、上下固定的上中下单页布局 - flex实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180910115820299-67074543.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概括：&lt;/strong&gt;常见的三栏单页布局。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;html:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;body  class=&quot;container&quot;&amp;gt;
    &amp;lt;header&amp;gt;我是头部&amp;lt;/header&amp;gt;
    &amp;lt;article&amp;gt;我是中间文章主体部位&amp;lt;/article&amp;gt;
    &amp;lt;footer&amp;gt;我是尾部&amp;lt;/footer&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;css:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:css;collapse:true;;gutter:true;&quot;&gt;
    body{
      color: #333;
      font-weight: 600;
      font-size: 16px;
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      text-align: center;
    }
    header,footer{
      line-height: 66px;
      background: lightgreen;
    }
    article{
      padding: 20px;
    }
    /* 父元素设置flex，然后布局方向为主轴从上到下，那么header和footer就会在最上边和最下边 */
    html,body{
      height: 100%;
      margin: 0;
      /* 不设置100%，高度撑不开 */
    }
    .container{
      display: flex;
      display: -webkit-box;
      display: -webkit-flex;
      flex-direction: column;
      -ms-flex-direction: column;
    }
    article{
      flex: 1;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上中下要有一个外部盒子包裹。这里偷懒使用了body：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;body&lt;/span&gt;{&lt;span&gt;
     display&lt;/span&gt;:&lt;span&gt; flex&lt;/span&gt;;&lt;span&gt;
      display&lt;/span&gt;:&lt;span&gt; -webkit-box&lt;/span&gt;;&lt;span&gt;
      display&lt;/span&gt;:&lt;span&gt; -webkit-flex&lt;/span&gt;;&lt;span&gt;
      flex-direction&lt;/span&gt;:&lt;span&gt; column&lt;/span&gt;;&lt;span&gt;
      -ms-flex-direction&lt;/span&gt;:&lt;span&gt; column&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 上下设置自己的具体高度即可：&lt;/p&gt;
&lt;p&gt;因为是单行，所以偷懒只用了line-height。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;header,footer&lt;/span&gt;{&lt;span&gt;
      line-height&lt;/span&gt;:&lt;span&gt; 66px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 中间内容区域瓜分剩余空间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;article &lt;/span&gt;{&lt;span&gt;
    flex&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　flex布局&lt;/p&gt;
&lt;p&gt;　　垂直方向&lt;/p&gt;


&lt;h2&gt;四、上下固定中间分左右的单页布局 - flex实现，嵌套使用&lt;/h2&gt;
&lt;p&gt;在第三的基础上，中间还想分成左右两份，结合第二中section也flex的实现，就有了四。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180910134749421-1225408866.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hah&lt;/p&gt;
&lt;p&gt;很明显，露怯了。。。&lt;/p&gt;
&lt;p&gt;当我给artical赋了1000px的高度时，出现了bug就是上翻会露怯，底部跟随而上。&lt;/p&gt;
&lt;p&gt;所以，这种只适合不超出一屏的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;html:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
    &amp;lt;header&amp;gt;我是头部&amp;lt;/header&amp;gt;
    &amp;lt;section&amp;gt;
      &amp;lt;nav&amp;gt;
        &amp;lt;ul&amp;gt;
          &amp;lt;li&amp;gt;导航一&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;导航二&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;导航三&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;导航四&amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/nav&amp;gt;
      &amp;lt;article&amp;gt;我是中间文章主体部位&amp;lt;/article&amp;gt;
    &amp;lt;/section&amp;gt;
    &amp;lt;footer&amp;gt;我是尾部&amp;lt;/footer&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;css:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:css;collapse:true;;gutter:true;&quot;&gt;
body{
      color: #333;
      font-weight: 600;
      font-size: 16px;
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      text-align: center;
    }
    header,footer{
      line-height: 66px;
      background: lightgreen;
    }
    article{
      padding: 20px;
    }
    nav{
      background: green;
      color: #fff;
      padding: 20px;
    }
    ul,li{
      list-style: none;
      margin: 0;
      padding: 0;
      margin-bottom: 20px;
    }
    /* 父元素设置flex，然后布局方向为主轴从上到下，那么header和footer就会在最上边和最下边 */
    html,body{
      height: 100%;
      margin: 0;
      /* 不设置100%，高度撑不开 */
    }
    .container{
      display: flex;
      display: -webkit-box;
      display: -webkit-flex;
      flex-direction: column;
      -ms-flex-direction: column;
    }
    section{
      
      flex: 1;
      display: flex;
    }
    nav{
      width: 200px;
    }
    article{
      flex: 1;
      height: 3000px;//bug就是上翻会露怯，这种只适合不超出一屏的情况
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上中下要有一个外部盒子包裹。这里偷懒使用了body：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    .container&lt;/span&gt;{&lt;span&gt;
      display&lt;/span&gt;:&lt;span&gt; flex&lt;/span&gt;;&lt;span&gt;
      display&lt;/span&gt;:&lt;span&gt; -webkit-box&lt;/span&gt;;&lt;span&gt;
      display&lt;/span&gt;:&lt;span&gt; -webkit-flex&lt;/span&gt;;&lt;span&gt;
      flex-direction&lt;/span&gt;:&lt;span&gt; column&lt;/span&gt;;&lt;span&gt;
      -ms-flex-direction&lt;/span&gt;:&lt;span&gt; column&lt;/span&gt;;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;父元素设置flex，然后布局方向为主轴从上到下，那么header和footer就会在最上边和最下边。&lt;/p&gt;
&lt;p&gt;他们只需要设置自己的具体高度即可：&lt;/p&gt;
&lt;p&gt;因为是单行，所以偷懒只用了line-height。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;header, footer &lt;/span&gt;{&lt;span&gt;
    line-height&lt;/span&gt;:&lt;span&gt; 66px&lt;/span&gt;;&lt;span&gt;
    background&lt;/span&gt;:&lt;span&gt; lightgreen&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;中间内容区域瓜分剩余空间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;section &lt;/span&gt;{&lt;span&gt;
    flex&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但是，中间现在又分了nav和article两部分，需要两列布局，我还是使用flex实现：&lt;/p&gt;
&lt;p&gt;先在section加一句display&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;section &lt;/span&gt;{&lt;span&gt;
    flex&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt; flex&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;nav因为只需要固定的宽度：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;nav &lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 200px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;右侧内容占据nav以外的剩余区域即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;article&lt;/span&gt;{&lt;span&gt;
      flex&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　flex 套 flex&lt;/p&gt;

&lt;h2&gt;五、上下固定中间分左右的单页布局 - absolute实现&lt;/h2&gt;
&lt;p&gt;跟第四的效果一样，只是换魔鬼的儿子absolute来实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180910142602778-1571116407.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;html :&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
  &amp;lt;header&amp;gt;头部&amp;lt;/header&amp;gt;
  &amp;lt;section&amp;gt;
    &amp;lt;aside&amp;gt;侧边栏&amp;lt;/aside&amp;gt;
    &amp;lt;article&amp;gt;
      内容区域
    &amp;lt;/article&amp;gt;
  &amp;lt;/section&amp;gt;
  &amp;lt;footer&amp;gt;尾部&amp;lt;/footer&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;css :&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:css;collapse:true;;gutter:true;&quot;&gt;
    html,
    body {
      height: 100%;
    }
    body {
      margin: 0;
    }
    header,
    footer {
      position: absolute;
      line-height: 48px;
      left: 0;
      right: 0;
      z-index: 1;
      color: aquamarine;
      text-align: center;
      background: #333;
    }

    footer {
      bottom: 0;
    }

    aside {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      padding: 68px 0;
      width: 280px;
      text-align: center;
      background: #eee;
    }

    article {
      position: absolute;
      left: 280px;/*如果侧边栏有宽度*/
      right: 0;
      top: 0;
      bottom: 0;
      padding: 68px 20px;
      overflow: auto;/*超出滚动显示*/
      background: #f5f5f5;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;把整个body当作relative父元素外框&lt;/p&gt;
&lt;p&gt;上下结构是上下绝对定位：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;header, footer &lt;/span&gt;{&lt;span&gt;
    position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
    line-height&lt;/span&gt;:&lt;span&gt; 48px&lt;/span&gt;;&lt;span&gt;
    left&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    right&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    z-index&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;&lt;span&gt;
    color&lt;/span&gt;:&lt;span&gt; aquamarine&lt;/span&gt;;&lt;span&gt;
    text-align&lt;/span&gt;:&lt;span&gt; center&lt;/span&gt;;&lt;span&gt;
    background&lt;/span&gt;:&lt;span&gt; #333&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;footer &lt;/span&gt;{&lt;span&gt;
    bottom&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;中间的左、右结构同时使用absolute定位，并用top、bottom拉伸加持。这样可以使他们的高度100%绝对占据元素的高度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    position: absolute;
    top: 0;
    bottom: 0;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后左右的结构布局使用left和宽度配合&lt;/p&gt;
&lt;p&gt;比如左边aside直接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    left: 0;
    width: 280px;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;右边article用left躲过左边的宽度：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    left: 280px;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，左右再分别使用padding空出header和footer的位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;padding: 68px 20px;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（用top+bottom对应数值也可以）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt; position: absolute;
 top:60px;
 bottom: 60px;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　absolute + 方位值&lt;/p&gt;
&lt;p&gt;　　适合单页布局&lt;/p&gt;

&lt;h2&gt;六、上下固定中间滚动的移动单页结构- fixed定位实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180910143927824-1074388703.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;html：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;header&amp;gt;头部&amp;lt;/header&amp;gt;
  &amp;lt;section&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li&amp;gt;遇到这种布局，通常想到用fixed固定顶部和尾部，然后中间的有个和顶部尾部同值的上下padding，好让内容撑开与上下的距离。但是这种布局会有bug。&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项我是列表项我是列表项我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/section&amp;gt;
  &amp;lt;footer&amp;gt;底部&amp;lt;/footer&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;css：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:css;collapse:true;;gutter:true;&quot;&gt;
html,
    body {
      height: 100%;
    }
    body,ul {
      margin: 0;
    }
    header,
    footer {
      position: fixed;
      line-height: 48px;
      left: 0;
      right: 0;
      z-index: 1;
      color: aquamarine;
      text-align: center;
      background: #333;
    }
    header{
      top: 0;
    }
    footer {
      bottom: 0;
    }
    section{
      padding: 68px 0;
      /* position: absolute;
      top: 48px;
      right: 0;
      bottom: 48px;
      left: 0; 
      width: 100%;*/
      overflow: auto;
      background: #eee;
    }
    li{
      padding: 10px;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;header上固定定位&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;position: fixed;
top： 0；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;footer下固定定位&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;position:fixed;
bottom: 0;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上下均通过line-height实现固定高度，使用left+right横向拉伸实现宽度100%效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    line-height: 48px;
    left: 0;
    right: 0;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中间不定位。只是padding上下留出header和footer的高度占位，且overflow：hidden&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    padding: 68px 0;
    overflow: auto;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　上下 fixed&lt;/p&gt;
&lt;p&gt;　　中间 padding+overflow&lt;/p&gt;

&lt;h2&gt;七、上下固定中间滚动的移动单页结构- absolute定位实现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/956663/201809/956663-20180910115851239-579015764.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;html：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;collapse:true;;gutter:true;&quot;&gt;
&amp;lt;header&amp;gt;头部&amp;lt;/header&amp;gt;
  &amp;lt;section&amp;gt;
    &amp;lt;ul&amp;gt;
      &amp;lt;li&amp;gt;遇到这种布局，通常想到用fixed固定顶部和尾部，然后中间的有个和顶部尾部同值的上下padding，好让内容撑开与上下的距离。但是这种布局会有bug。&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项我是列表项我是列表项我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;我是列表项&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  &amp;lt;/section&amp;gt;
  &amp;lt;footer&amp;gt;底部&amp;lt;/footer&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;css：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:css;collapse:true;;gutter:true;&quot;&gt;
html,
    body {
      height: 100%;
    }
    body,ul {
      margin: 0;
    }
    header,
    footer {
      position: absolute;
      line-height: 48px;
      left: 0;
      right: 0;
      z-index: 1;
      color: aquamarine;
      text-align: center;
      background: #333;
    }
    header{
      top: 0;
    }
    footer {
      bottom: 0;
    }
    section{
      padding: 20px;
      position: absolute;
      top: 48px;
      right: 0;
      bottom: 48px;
      left: 0;
      overflow: auto;
    }
    li{
      padding: 10px 0;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;header上绝对定位&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
position: absolute;
top： 0；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;footer下绝对定位&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
position:absolute;
bottom: 0;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上下均通过line-height实现固定高度，使用left+right横向拉伸实现宽度100%效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    line-height: 48px;
    left: 0;
    right: 0;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中间绝对定位。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;position: absolute;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;左右方位值水平放向拉伸实现宽度100%效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    right: 0;
    left: 0;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中间的上、下方位值留出header、footer的高度占位值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    top: 48px;
    bottom: 48px;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;超出会出现滚动条，不超出就没有滚动条：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;overflow：auto&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　全屏三大块元素均使用absolute布局。&lt;/p&gt;

&lt;p&gt;平时遇到这种布局，通常想到用fixed固定顶部和尾部，然后中间的有个和顶部尾部同值的上下padding，好让内容撑开与上下的距离。但是这种布局会有bug。&lt;/p&gt;
&lt;p&gt; 如果中间内容不小心设置了过高的高度超出视图，会让底部跟随中间向上滑动。&lt;/p&gt;
&lt;p&gt;全屏使用absolute布局是个很好的方法。&lt;/p&gt;

&lt;p&gt;另一篇：&lt;a href=&quot;http://www.cnblogs.com/padding1015/p/7479956.html&quot; target=&quot;_blank&quot;&gt;CSS-三栏响应式布局（左右固宽，中间自适应）的五种方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2018-09-10 13:11:39&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 06:57:00 +0000</pubDate>
<dc:creator>xing.org1^</dc:creator>
<og:description>常规上中下分左右布局的一百种实现方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/padding1015/p/9577961.html</dc:identifier>
</item>
<item>
<title>Dynamic Programming 1：入门 - mozi_song</title>
<link>http://www.cnblogs.com/mozi-song/p/9615167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mozi-song/p/9615167.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;如果你常刷leetcode，会发现许多问题带有Dynamic Programming的标签。事实上带有dp标签的题目有115道，大部分为中等和难题，占所有题目的12.8%（2018年9月），是占比例第二大的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1154131/201809/1154131-20180910094537999-611702131.png&quot; alt=&quot;&quot; width=&quot;196&quot; height=&quot;369&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果能系统地对dp这个topic进行学习，相信会极大地提高解题速度，对今后解决实际问题也有思路上的帮助。&lt;/p&gt;
&lt;p&gt;本文以分杆问题为切入点，介绍动态规划的算法动机、核心思想和常用的两种实现方法。&lt;/p&gt;
&lt;h2&gt;分杆问题&lt;/h2&gt;
&lt;p&gt;The rod-cutting problem（分杆问题）是动态规划问题的一个典例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给出一根长度为n（n为整数）的杆，可以将杆切割为任意份长短不同的杆（其中包含完全不进行切割的情况），每一份的长度都为整数。给出一个整数数组p[]，p[i]表示长度为i的杆的价格，问如何对杆进行切割可以使利润最大。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;p[]数组的一个示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1154131/201809/1154131-20180910105613720-659253582.png&quot; alt=&quot;&quot; width=&quot;320&quot; height=&quot;38&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;在长度为n的杆上进行整数切割，共有&lt;strong&gt;2&lt;sup&gt;n-1&lt;/sup&gt;&lt;/strong&gt;种情况，因为有n-1个点可以选择是否切割。&lt;/p&gt;
&lt;p&gt;将这些可以切割的点编号为1,2,3, ..., n-1，如果先试着在1处切割，则杆变成了长度为1和n-1的两段；如果试着在2处切割，则杆变为了长度为2和n-2的两段，以此类推，共有n种切法（包含完全不作切割）。这样，我们迈出了递归的第一步，即把长为n的杆的最优切割分成两个子问题：长为i的杆的最优切割和长为n-i的杆的最优切割（i = 1,2,...,n）。最终的利润为两个子杆的利润和。&lt;/p&gt;
&lt;p&gt;如果用f&lt;sub&gt;n&lt;/sub&gt;表示长度为n的杆切割后能得到的最大利润，经过以上分析，我们求取两个子杆的利润和的最大值即可。即&lt;/p&gt;
&lt;p&gt;f&lt;sub&gt;n&lt;/sub&gt; = max(p&lt;sub&gt;n&lt;/sub&gt;, f&lt;sub&gt;1&lt;/sub&gt; + f&lt;sub&gt;n-1&lt;/sub&gt;, f&lt;sub&gt;2&lt;/sub&gt; + f&lt;sub&gt;n-2&lt;/sub&gt;, ..., f&lt;sub&gt;n-1&lt;/sub&gt; + f&lt;sub&gt;1&lt;/sub&gt;).&lt;/p&gt;
&lt;p&gt;这种思路是正确的，但不是太好，有心人可以注意到子问题之间有较大的重叠之处，比如计算f&lt;sub&gt;n-1&lt;/sub&gt;时会需要查看f&lt;sub&gt;1&lt;/sub&gt; + f&lt;sub&gt;n-2&lt;/sub&gt;，即f&lt;sub&gt;1&lt;/sub&gt; + f&lt;sub&gt;n-1&lt;/sub&gt;这个子问题需要查看f&lt;sub&gt;1&lt;/sub&gt; + f&lt;sub&gt;1&lt;/sub&gt; + f&lt;sub&gt;n-2&lt;/sub&gt;这个切法；而计算f&lt;sub&gt;2&lt;/sub&gt;时又需要查看f&lt;sub&gt;1&lt;/sub&gt; + f&lt;sub&gt;1&lt;/sub&gt;，即f&lt;sub&gt;2&lt;/sub&gt; + f&lt;sub&gt;n-2&lt;/sub&gt;这个子问题也会查看到f&lt;sub&gt;1&lt;/sub&gt; + f&lt;sub&gt;1&lt;/sub&gt; + f&lt;sub&gt;n-2&lt;/sub&gt;这个切法，相当于把一些可能性重复查看了多遍。&lt;/p&gt;
&lt;p&gt;一个更简洁合理的思路是：设定左边这个长为ｉ的杆不可再切割，只有右边长为n-i的杆可以再切割。则问题变为&lt;/p&gt;
&lt;p&gt;f&lt;sub&gt;n&lt;/sub&gt; = max(p&lt;sub&gt;i&lt;/sub&gt; + f&lt;sub&gt;n-i&lt;/sub&gt;), i = 1,2,...,n&lt;/p&gt;
&lt;h3&gt;传统递归实现&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;按照上面的分析，可以初步做一个递归实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cutRod(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] p){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(n == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; max =&lt;span&gt; Integer.MIN_VALUE; 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         max = Math.max(max, p[i] + cutRod(n -&lt;span&gt; i, p));
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;传统递归实现的复杂度&lt;/h3&gt;
&lt;p&gt;在节点n，算法的时间复杂度为&lt;/p&gt;
&lt;p&gt;T&lt;sub&gt;n&lt;/sub&gt; = 1 + ∑ T&lt;sub&gt;i&lt;/sub&gt; (i = 0,1, ..., n-1)&lt;/p&gt;
&lt;p&gt;(其中的1是在节点处做加法和max运算的常数复杂度)&lt;/p&gt;
&lt;p&gt;这个式子很好推算，只要将T&lt;sub&gt;i&lt;/sub&gt;的值以此从后往前代入即可：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;T&lt;sub&gt;n&lt;/sub&gt; = 1+T&lt;sub&gt;0&lt;/sub&gt;+T&lt;sub&gt;1&lt;/sub&gt;+ ... +T&lt;sub&gt;n-1 　　　　 　 &lt;/sub&gt;= 1+T&lt;sub&gt;0&lt;/sub&gt;+T&lt;sub&gt;1&lt;/sub&gt;+ ... +T&lt;sub&gt;n-2&lt;/sub&gt;+(1+T&lt;sub&gt;0&lt;/sub&gt;+T&lt;sub&gt;1&lt;/sub&gt;+ ... +T&lt;sub&gt;n-2&lt;/sub&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 = &lt;strong&gt;2 (1+T&lt;sub&gt;0&lt;/sub&gt;+T&lt;sub&gt;1&lt;/sub&gt;+ ... +T&lt;sub&gt;n-2&lt;/sub&gt;)&lt;/strong&gt;　&lt;sub&gt; &lt;/sub&gt;　=  2 (1+T&lt;sub&gt;0&lt;/sub&gt;+T&lt;sub&gt;1&lt;/sub&gt;+ ... +T&lt;sub&gt;n-3&lt;/sub&gt;+(1+T&lt;sub&gt;0&lt;/sub&gt;+T&lt;sub&gt;1&lt;/sub&gt;+ ... +T&lt;sub&gt;n-3&lt;/sub&gt;))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 = &lt;strong&gt;2&lt;sup&gt;2&lt;/sup&gt; (1+T&lt;sub&gt;0&lt;/sub&gt;+T&lt;sub&gt;1&lt;/sub&gt;+ ... +T&lt;sub&gt;n-3&lt;/sub&gt;)　&lt;sub&gt; &lt;/sub&gt;&lt;/strong&gt; =  ... （总结规律） = 2&lt;sup&gt;n-1&lt;/sup&gt; (1 + T&lt;sub&gt;0&lt;/sub&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 = &lt;strong&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即传统递归算法的时间复杂度为&lt;strong&gt;O(2&lt;sup&gt;n&lt;/sup&gt;)&lt;/strong&gt;，为指数级别。&lt;/p&gt;
&lt;p&gt;上一节中说到切割的可能性共有&lt;strong&gt;2&lt;sup&gt;n-1&lt;/sup&gt;&lt;/strong&gt;种，也就是说递归算法会将每种可能性都遍历到。是否还有优化的可能性呢？&lt;/p&gt;
&lt;h3&gt;优化&lt;/h3&gt;
&lt;p&gt;以n = 4为例，画出递归树结构（节点包含的数字为n的值）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1154131/201809/1154131-20180910135054449-1316227625.png&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本图摘自算法导论（英文版）3rd Ed. 15.1 P346&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看到子树之间存在重叠情况。最明显的是n = 2的子问题和n = 3的子问题调用的子树完全相同，进行了两遍同样的计算。而这个子树中又包含n = 1的子树，也就是说浪费的幅度是相乘的。&lt;/p&gt;
&lt;p&gt;一个优化思路是将每个子问题的计算结果记录下来，下一次再遇到同样的问题时直接使用记录值，这就是动态规划的核心思想。&lt;/p&gt;
&lt;h2&gt;动态规划&lt;/h2&gt;
&lt;p&gt;如上节所述的，动态规划是一种“以空间换时间”的思想，适用于&lt;strong&gt;子问题之间存在重叠情况的优化问题&lt;/strong&gt;。它的基本思想是将计算过的子问题的答案记录下来，从而达到每个子问题只计算一次的目的。&lt;/p&gt;
&lt;p&gt;动态规划的实现方法分为top-down和bottom-up两种，可以理解为前者从递归树的根节点向下递归调用，而后者从树的叶结点开始不停地向上循环。&lt;/p&gt;
&lt;h3&gt;top-down with memoization&lt;/h3&gt;
&lt;p&gt;top-down方法比较容易理解，就是在传统递归的基础上加入&lt;em&gt;memoization（&lt;/em&gt;注意与memorization的区&lt;em&gt;别&lt;/em&gt;。memoization来自memo，有备忘的意思），即用数组或表等结构缓存计算结果。在每次递归运算时，先判断想要的结果是否在缓存中，如果没有才进行运算并存入缓存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cutRod(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] p){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;[] memo = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n + 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; memo.length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         memo[i] = Integer.MIN_VALUE;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;initialization&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cutRod(n, p, memo);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cutRod(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt;[] p, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] memo){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;strong&gt; &lt;span&gt;if&lt;/span&gt;(memo[n] !=&lt;span&gt; Integer.MIN_VALUE)
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;10&lt;/span&gt;         &lt;strong&gt;&lt;span&gt;return&lt;/span&gt; memo[n];               &lt;/strong&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;return value directly if memoized&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(n == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; max =&lt;span&gt; Integer.MIN_VALUE; 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= n; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         max = Math.max(max, p[i] + cutRod(n -&lt;span&gt; i, p, memo));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;strong&gt;memo[n] = max;                    &lt;span&gt;//&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;memoize it&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;bottom-up with tabulation&lt;/h3&gt;
&lt;p&gt;相比于top-down，bottom-up的特点是使用循环而非递归，先解决子问题，再利用子问题的答案解决父问题。&lt;em&gt;tabulation&lt;/em&gt;也很好理解，即用一个表格存放子问题的答案，然后查表获得父问题需要的所有信息去解决父问题，解决后也填在表中，直至把表填满。&lt;/p&gt;
&lt;p&gt;事实上，dynamic programming这个令人费解的名字即来源于此。programming在数学界有“列表法”(tabular method)的意思，指的是为了求某函数的最大/最小值，将函数的所有变量的所有可能值列在表中并对表进行某些操作来获得结果。在这里，表格是“静态”的，每个格子中的信息是独立的；而在动态规划中，表格是“动态”的，一些格子中的信息依赖于另一些格子中的计算答案。所以，dynamic programming也可以理解为“&lt;strong&gt;动态列表法&lt;/strong&gt;”，也即此处的tabulation。&lt;/p&gt;
&lt;p&gt;top-down的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cutRod(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] p){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;[] table = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n + 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = 1; j &amp;lt;= n; j++){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fill table from j = 1 to n&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; max =&lt;span&gt; Integer.MIN_VALUE;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt;= j; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             max = Math.max(max, p[i] + table[j - i]);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;calculate f(j)&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         table[j] =&lt;span&gt; max;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; table[n];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;复杂度&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在bottom-up解法中，&lt;/span&gt;我们从&lt;span&gt;1至n填入表格，在填入table[j]时，需要查询table[j-1]到table[0]的所有元素，即要做j次查询。则填满表格共要做1+2+3+...+n = O(n&lt;sup&gt;2&lt;/sup&gt;)次查询。则bottom-up解法的时间复杂度为&lt;span&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在top-down解法中，可以这样分析复杂度：首先由于缓存机制，每个子问题只会被计算一次；为了解决大小为n的问题，我们需要计算大小为0，1，2，...，n-1的问题（第15行）；计算大小为n的问题又需要n次计算（第14行），因此top-down解法的复杂度也为&lt;span&gt;&lt;span&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;实际上，动态规划将前文图中的递归树做了简化，将互相重叠的子树合并，得到了一个子问题树。子问题树中的边和节点都减少了，意味着时间复杂度得到了优化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1154131/201809/1154131-20180910143718010-745721787.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;206&quot;/&gt;   &lt;span&gt;-&amp;gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/1154131/201809/1154131-20180910143702277-1746544103.png&quot; alt=&quot;&quot; width=&quot;188&quot; height=&quot;228&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;概念&lt;/h2&gt;
&lt;p&gt;看完例子，我们来总结一下动态规划算法的相关概念。&lt;/p&gt;
&lt;h3&gt;Dynamic Programming&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;dynamic programming （动态规划）是一类常用来解决&lt;strong&gt;优化问题&lt;/strong&gt;的算法。它的最大特点是&lt;strong&gt;使用子问题的信息帮助解决父问题&lt;/strong&gt;，使解题的难度减小。比如，求第1,000,002个斐波那契数这个问题看起来很复杂，但如果已知了第1,000,000和第1,000,001斐波那契数，事情就简单多了。&lt;/li&gt;
&lt;li&gt;动态规划问题有一个显著的特点，就是&lt;strong&gt;子问题之间存在相互重叠&lt;/strong&gt;。动态规划通过记录子问题的结果，保证每个子问题只计算一次，减少了时间浪费。动态规划的时间复杂度通常是多项式复杂度（即O(n&lt;sup&gt;k&lt;/sup&gt;)，k为非负常数），而不记录结果的算法由于重复计算，复杂度通常远高于动态规划，达到指数复杂度。&lt;/li&gt;
&lt;li&gt;dynamic programming这个英文名词有些让人难懂。实际上，这里的programming不是指编程，而是数学上的一种解决优化问题的方法，叫做列表法(tabular method)，大致过程是将函数的不同变量值在表中列出并对表进行各种操作来求得结果。如果列表法是静态（static）的，则动态规划算法中，表格是慢慢增长的，先解决相对简单的子问题，然后通过子问题的结合求取父问题，这样表格好像是“动态”的。这就是dynamic programming的意思。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Memoization vs. Tabulation 简介&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;动态规划通常有两种解法：&lt;strong&gt;top-down&lt;/strong&gt;和&lt;strong&gt;bottom-up&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;top-down通常以&lt;strong&gt;递归&lt;/strong&gt;形式出现，从父问题开始，递归地求解子问题。top-down的求解过程通常与&lt;em&gt;&lt;strong&gt;memoization&lt;/strong&gt;&lt;/em&gt;结合，即将计算过的结果缓存在数组或者哈希表等结构中。当进入递归求解问题时，先查看缓存中是否已有结果，如果有则直接返回缓存的结果。&lt;/li&gt;
&lt;li&gt;bottom-up通常以&lt;strong&gt;循环&lt;/strong&gt;形式出现。bottom-up的求解过程通常与&lt;em&gt;&lt;strong&gt;tabulation&lt;/strong&gt;&lt;/em&gt;结合，即先解最小的子问题，解决后将结果记录在表格中（通常是一维或二维数组），解决父问题时直接查表拿到子问题的结果，然后将父问题的结果也填在表中，直到把表格填满，最后填入的就是起始问题的结果。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dynamic_programming&quot; target=&quot;_blank&quot;&gt;dynamic programming -- wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://bayanbox.ir/view/4177858657730907268/introduction-to-algorithms-3rd-edition.pdf&quot; target=&quot;_blank&quot;&gt;算法导论（英文版）3rd Ed. 15.1&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;grid--cell fs-headline1 fl1&quot;&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1065433/what-is-dynamic-programming&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;question-hyperlink&quot;&gt;What is dynamic programming?&lt;/span&gt; -- Stackoverflow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ee.surrey.ac.uk/Projects/Labview/minimisation/tabular.html&quot; target=&quot;_blank&quot;&gt;Tabular Method of Minimisation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://content.saihs.edu.tw/chapter_htm/chapter4/4c/c_03.htm&quot; target=&quot;_blank&quot;&gt;數位邏輯之化簡（列表法）&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;grid--cell fs-headline1 fl1&quot;&gt;&lt;a class=&quot;question-hyperlink&quot; href=&quot;https://stackoverflow.com/questions/6164629/dynamic-programming-and-memoization-bottom-up-vs-top-down-approaches&quot;&gt;&lt;span class=&quot;question-hyperlink&quot;&gt;Dynamic programming and memoization: bottom-up vs top-down approaches&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 06:50:00 +0000</pubDate>
<dc:creator>mozi_song</dc:creator>
<og:description>简介 如果你常刷leetcode，会发现许多问题带有Dynamic Programming的标签。事实上带有dp标签的题目有115道，大部分为中等和难题，占所有题目的12.8%（2018年9月），是占</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mozi-song/p/9615167.html</dc:identifier>
</item>
<item>
<title>深度学习基础系列（一）| 如何看懂用kersa构建模型的各层含义（掌握输出尺寸和可训练参数数量的计算方法） - 可可心心</title>
<link>http://www.cnblogs.com/hutao722/p/9618426.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hutao722/p/9618426.html</guid>
<description>&lt;p&gt;　　我们在学习成熟网络模型时，如VGG、Inception、Resnet等，往往面临的第一个问题便是这些模型的各层参数是如何设置的呢？另外，我们如果要设计自己的网路模型时，又该如何设置各层参数呢？如果模型参数设置出错的话，其实模型也往往不能运行了。&lt;/p&gt;
&lt;p&gt;　　所以，我们需要首先了解模型各层的含义，比如输出尺寸和可训练参数数量。理解后，大家在设计自己的网路模型时，就可以先在纸上画出网络流程图，设置各参数，计算输出尺寸和可训练参数数量，最后就可以照此进行编码实现了。&lt;/p&gt;
&lt;p&gt;　　而在keras中，当我们构建模型或拿到一个成熟模型后，往往可以通过model.summary()来观察模型各层的信息。&lt;/p&gt;
&lt;p&gt;　　本文将通过一个简单的例子来进行说明。本例以keras官网的一个简单模型&lt;a href=&quot;https://keras.io/getting-started/sequential-model-guide/&quot; target=&quot;_blank&quot;&gt;VGG-like模型&lt;/a&gt;为基础，稍加改动代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; tensorflow &lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Sequential
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.keras.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dense, Dropout, Flatten
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; tensorflow.keras.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Conv2D, MaxPool2D


(train_data, train_labels), (test_data, test_labels) &lt;/span&gt;=&lt;span&gt; keras.datasets.mnist.load_data()
train_data &lt;/span&gt;= train_data.reshape(-1, 28, 28, 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;train data type:{}, shape:{}, dim:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(type(train_data), train_data.shape, train_data.ndim))
&lt;br/&gt;# 第一组
model &lt;/span&gt;=&lt;span&gt; Sequential()
model.add(Conv2D(filters&lt;/span&gt;=32, kernel_size=(3, 3), strides=(1, 1), padding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;valid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, input_shape=(28, 28, 1&lt;span&gt;)))
model.add(Conv2D(filters&lt;/span&gt;=32, kernel_size=(3, 3), strides=(1, 1), padding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;valid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
model.add(MaxPool2D(pool_size&lt;/span&gt;=(2, 2&lt;span&gt;)))
model.add(Dropout(&lt;/span&gt;0.25&lt;span&gt;))
&lt;br/&gt;# 第二组
model.add(Conv2D(filters&lt;/span&gt;=64, kernel_size=(3, 3), strides=(1, 1), padding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;valid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
model.add(Conv2D(filters&lt;/span&gt;=64, kernel_size=(3, 3), strides=(1, 1), padding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;valid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
model.add(MaxPool2D(pool_size&lt;/span&gt;=(2, 2&lt;span&gt;)))
model.add(Dropout(&lt;/span&gt;0.25&lt;span&gt;))
&lt;br/&gt;# 第三组
model.add(Flatten())
model.add(Dense(units&lt;/span&gt;=256, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
model.add(Dropout(&lt;/span&gt;0.5&lt;span&gt;))
model.add(Dense(units&lt;/span&gt;=10, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

model.summary()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　本例的数据来源于mnist，这是尺寸为28*28，通道数为1，也即只有黑白两色的图片。其中卷积层的参数含义为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　filters：表示过滤器的数量，每一个过滤器都会与对应的输入层进行卷积操作；&lt;/li&gt;
&lt;li&gt;　　kernel_size：表示过滤器的尺寸，一般为奇数值，如1,3,5，这里设置为3*3大小；&lt;/li&gt;
&lt;li&gt;　　strides：表示步长，即每一次过滤器在图片上移动的步数；&lt;/li&gt;
&lt;li&gt;　　padding：表示是否对图片边缘填充像素，一般有两个值可选，一是默认的valid，表示不填充像素，卷积后图片尺寸会变小；另一种是same，填充像素，使得输出尺寸和输入尺寸保持一致。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　   如果选择valid，假设输入尺寸为n * n，过滤器的大小为f * f，步长为s，则其输出图片的尺寸公式为：[(n - f)/s + 1] * [(n -f)/s + 1)]，若计算结果不为整数，则向下取整；&lt;/p&gt;
&lt;p&gt;　　　　  如果选择same，假设输入尺寸为n * n，过滤器的大小为f * f，要填充的边缘像素宽度为p，则计算p的公式为：n + 2p -f  +1 = n， 最后得 p = (f -1) /2。&lt;/p&gt;
&lt;p&gt;　　运行上述例子，可以看到如下结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
train data type:&amp;lt;class 'numpy.ndarray'&amp;gt;, shape:(60000, 28, 28, 1), dim:4
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
conv2d (Conv2D)              (None, 26, 26, 32)        320       
_________________________________________________________________
conv2d_1 (Conv2D)            (None, 24, 24, 32)        9248      
_________________________________________________________________
max_pooling2d (MaxPooling2D) (None, 12, 12, 32)        0         
_________________________________________________________________
dropout (Dropout)            (None, 12, 12, 32)        0         
_________________________________________________________________
conv2d_2 (Conv2D)            (None, 10, 10, 64)        18496     
_________________________________________________________________
conv2d_3 (Conv2D)            (None, 8, 8, 64)          36928     
_________________________________________________________________
max_pooling2d_1 (MaxPooling2 (None, 4, 4, 64)          0         
_________________________________________________________________
dropout_1 (Dropout)          (None, 4, 4, 64)          0         
_________________________________________________________________
flatten (Flatten)            (None, 1024)              0         
_________________________________________________________________
dense (Dense)                (None, 256)               262400    
_________________________________________________________________
dropout_2 (Dropout)          (None, 256)               0         
_________________________________________________________________
dense_1 (Dense)              (None, 10)                2570      
=================================================================
Total params: 329,962
Trainable params: 329,962
Non-trainable params: 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　让我们解读下，首先mnist为输入数据，尺寸大小为 (60000, 28, 28, 1)， 这是典型的NHWC结构，即（图片数量，宽度，高度，通道数）；&lt;/p&gt;
&lt;p&gt;　　其次我们需要关注表格中的&quot;output shape&quot;输出尺寸，其遵循mnist一样的结构，只不过第一位往往是None，表示图片数待定，后三位则按照上述规则进行计算；&lt;/p&gt;
&lt;p&gt;　　最后关注的是&quot;param&quot;可训练参数数量，不同的模型层计算方法不一样：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　对于卷积层而言，假设过滤器尺寸为f * f， 过滤器数量为n， 若开启了bias，则bias数固定为1，输入图片的通道数为c，则param计算公式= (f * f * c + 1) * n；&lt;/li&gt;
&lt;li&gt;　　对于池化层、flatten、dropout操作而言，是不需要训练参数的，所以param为0；&lt;/li&gt;
&lt;li&gt;　　对于全连接层而言，假设输入的列向量大小为i，输出的列向量大小为o，若开启bias，则param计算公式为=i * o + o&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　按照代码中划分的三组模型层次，其输出尺寸和可训练参数数量的计算方法可如下图所示：&lt;/p&gt;
&lt;p&gt;　　第一组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/891145/201809/891145-20180910143014751-1351972452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第二组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/891145/201809/891145-20180910143029534-612860177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第三组：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/891145/201809/891145-20180910143101205-1571268788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至此，模型各层的含义和相关计算方法已介绍完毕，希望此文能帮助大家更好地理解模型的构成和相关计算。&lt;/p&gt;




</description>
<pubDate>Mon, 10 Sep 2018 06:43:00 +0000</pubDate>
<dc:creator>可可心心</dc:creator>
<og:description>我们在学习成熟网络模型时，如VGG、Inception、Resnet等，往往面临的第一个问题便是这些模型的各层参数是如何设置的呢？另外，我们如果要设计自己的网路模型时，又该如何设置各层参数呢？如果模型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hutao722/p/9618426.html</dc:identifier>
</item>
<item>
<title>【翻译】JavaScript循环和作用域 - 婷风</title>
<link>http://www.cnblogs.com/jtjds/p/9619492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jtjds/p/9619492.html</guid>
<description>&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;3&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;举个例子:&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const operations = []

for (var i = 0; i &amp;lt; 5; i++) {
  operations.push(() =&amp;gt; {
    console.log(i)
  })
}

for (const operation of operations) {
  operation()
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;4&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;它基本是循环了5次，将一个函数添加到operations数组里面。这个函数可打印出循环变量索引值&lt;code&gt;i&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;运行这些函数后&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;6&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;期望的结果应该是:&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;7&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;但实际发生的是这样的:&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;8&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;为什么会有这种情况? 因为使用的是&lt;code&gt;var&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;9&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;由于提升了&lt;code&gt;var&lt;/code&gt;变量, 上面的代码等同于&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
var i;
const operations = []

for (i = 0; i &amp;lt; 5; i++) {
  operations.push(() =&amp;gt; {
    console.log(i)
  })
}

for (const operation of operations) {
  operation()
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;10&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;因此，在for-of循环中, &lt;code&gt;i&lt;/code&gt; 依然是可见的, 它等于5，并且每次在函数中涉及到&lt;code&gt;i&lt;/code&gt; ,都将使用这个值。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;11&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;那么我们应该如何做让其变成我们想的这样呢?&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;12&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;最简单的方案是用 &lt;code&gt;let&lt;/code&gt; 声明. 在ES2015中介绍到, 它们有很大的帮助，能避免关于使用&lt;code&gt;var&lt;/code&gt;声明的一些奇怪问题。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;13&quot; readability=&quot;9.5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;简单的在循环变量时将&lt;code&gt;var&lt;/code&gt; 变成 &lt;code&gt;let&lt;/code&gt; ,能够很好的运行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const operations = []

for (let i = 0; i &amp;lt; 5; i++) {
  operations.push(() =&amp;gt; {
    console.log(i)
  })
}

for (const operation of operations) {
  operation()
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;14&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;这是输出结果:&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;15&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;这是怎么实现的呢?这是因为每次循环重复的时候，都将重新创造&lt;code&gt;i&lt;/code&gt; ,同时每个函数添加&lt;code&gt;operations&lt;/code&gt;数组时，能获取它本身的&lt;code&gt;i&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;16&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;记住你不能使用 &lt;code&gt;const&lt;/code&gt;在这种情况下, 因为这会导致&lt;code&gt;for&lt;/code&gt;在第二次循环时， 尝试赋新值报错。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;17&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline highlighted active&quot;&gt;另外一个非常普遍的解决这个问题是使用pre-ES6代码, 同时它被称作即时调用函数表达式 (IIFE).&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;translate-block&quot; data-type=&quot;paragraph&quot; data-index=&quot;18&quot; readability=&quot;10.5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;translate-inline&quot;&gt;在这种情况下，你可以包装整个函数，并将&lt;code&gt;i&lt;/code&gt; 绑定在它上面。自这种方式，你正在创造一个能立即执行的函数，你从其返回的一个新的函数。因此我们可以稍后执行它。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const operations = []

for (var i = 0; i &amp;lt; 5; i++) {
  operations.push(((j) =&amp;gt; {
    return () =&amp;gt; console.log(j)
  })(i))
}

for (const operation of operations) {
  operation()
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 06:41:00 +0000</pubDate>
<dc:creator>婷风</dc:creator>
<og:description>我的翻译小站：https://www.zcfy.cc/article/javascript-loops-and-scope 翻译原文链接：https://flaviocopes.com/javascr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jtjds/p/9619492.html</dc:identifier>
</item>
<item>
<title>Java核心技术第八章——泛型程序设计（1） - Johnson木木</title>
<link>http://www.cnblogs.com/Johnson-lin/p/9580971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johnson-lin/p/9580971.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;1.泛型程序设计&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;泛型程序设计&lt;/strong&gt;意味着编写的代码可以被很多不同类型的对象所重用。例如：不希望为了聚集String和Integer对象分别设计不同的类。（个人觉得此处说的聚集译为：创建一个对象，属性可以为String和Integer类型。但是却有着相同的行为或属性）&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String age;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(String age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IntegerTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age=&lt;span&gt; age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看到上面两个类都有size属性和方法。只是他们的属性类型有所不同。那么我们则可以使用到泛型：例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericTest&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; T size;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getSize() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSize(T size) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size =&lt;span&gt; size;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后只需要如下调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        GenericTest&lt;/span&gt;&amp;lt;String&amp;gt; genericString= &lt;span&gt;new&lt;/span&gt; GenericTest&amp;lt;&amp;gt;&lt;span&gt;();
        GenericTest&lt;/span&gt;&amp;lt;Integer&amp;gt; genericInteger = &lt;span&gt;new&lt;/span&gt; GenericTest&amp;lt;&amp;gt;&lt;span&gt;();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就很好的解决了代码重用的问题，不是吗？看不懂？不急，我只是说了泛型的好处，让我们慢慢往下了解。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.定义简单的泛型类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;没接触过泛型的同学看到上面例子中的T可能会觉得一脸懵逼，其实&lt;strong&gt;T&lt;/strong&gt;只是一个类的类型变量（虽然你可以定义A、B、C...，但是我们还是要规范点的是吧），然后T需要使用尖括号括起来，当你定义多个类型变量时。可以看下面的Generic类，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Generic&amp;lt;T,U&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; T size;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; U length;
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当你传入Generic&amp;lt;Integer,String&amp;gt; 时，你可以把这个类想象成如下使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Generic {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer size;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String length;
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，泛型类其实可以看做普通的工厂类。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.泛型方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面介绍了一个简单的泛型类，让我们来看看泛型方法是怎么写吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ArrayAlg {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T getMiddle(T... a){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a[a.length/2&lt;span&gt;];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，ArrayAlg是一个普通类，并不是一个泛型类。说明：泛型方法可以定义在普通类和泛型类中。&lt;/p&gt;
&lt;p&gt;当我们调用getMiddle方法时，在方法名前的尖括号放入具体类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
String s = ArrayAlg.&amp;lt;String&amp;gt;getMiddle(&quot;John&quot;,&quot;Q&quot;,&quot;Min&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看起来是不是很别扭？其实可以省略&amp;lt;String&amp;gt;类型参数，编译器会使用&lt;strong&gt;String[ ]&lt;/strong&gt;数组与泛型&lt;strong&gt;T[ ]&lt;/strong&gt;进行匹配推断出一定是String，这个应该就是他们私下bilibili的规则了。变成：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
String s = ArrayAlg.getMiddle(&quot;John&quot;,&quot;Q&quot;,&quot;Min&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有的小伙伴可能会想到，酱紫的话，我能不能瞎比的传参数进去？例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Double&lt;/span&gt; middle2 = ArrayAlg.getMiddle(3.14,0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实当你这样写的时候编译器就已经提示错误了，因为第二个参数编译器会默认认为是Integer类型。解决方法有两种：&lt;/p&gt;
&lt;p&gt;1.把Double改成Number类型，因为Number类型为Double和Integer的父类。&lt;/p&gt;
&lt;p&gt;2.自己改代码去吧，谁让你瞎搞。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.类型变量的限定&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有时候，&lt;strong&gt;类或方法需要对类型变量加以约束&lt;/strong&gt;，假如，某个泛型方法需要使用到Comparable接口的compareTo方法，那我们则需要限制传进来的参数必须实现Comparable接口，例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T &lt;span&gt;extends&lt;/span&gt; Comparable&amp;gt; T&lt;span&gt; minmax(T[] a){ 
　　compareTo...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;传进来的参数a则必须实现Comparable接口。假如传进来参数需要实现Comparable和Serializable两个接口，则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T &lt;span&gt;extends&lt;/span&gt; Comparable&amp;amp;Serializable&amp;gt; Pair&amp;lt;T&amp;gt;&lt;span&gt; minmax(T[] a){
  compareTo...  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;叮咚！那么传进来的参数需要继承某个类怎么写？其实是一样的。传进来的参数需要继承某个类、实现某个接口都是使用extends关键字来控制。原因：&lt;strong&gt;选择关键字extends的原因是更接近子类的概念，并且Java的设计者也不打算在语言中再添加一个新的关键字&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.泛型代码和虚拟机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.1类型擦除&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; Java 的泛型在编译器有效，在运行期被删除，也就是说所有泛型参数类型在编译后都会被清除掉&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericClass&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; T first;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getFirst() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;擦除类型后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericClass&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object first;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getFirst() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，类型擦除后的GengericClass和没引用泛型没有什么两样。而且，当你使用GenericClass&amp;lt;String&amp;gt;后，也是变成原始的GenericClass类型。&lt;/p&gt;
&lt;p&gt;但是当我们使用限定类型变量后，类型擦除后将会使用限定类型。例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericClass&amp;lt;T &lt;span&gt;extends&lt;/span&gt; Comparable&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; T first;
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到限定了传进来的参数需要实现Comparable接口，那么类型擦除后如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GenericClass{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Comparable first;
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;当你限定了参数需要实现Comparable和Serializable接口，就是&lt;strong&gt;GenericClass&amp;lt;T extends Comparable&amp;amp;Serializable&amp;gt;&lt;/strong&gt;时，类型擦除后会变成怎样呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GenericClass{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Comparable first;
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虚拟机会把首位实现的接口（此处为Comparable），转为擦除后对象类型。当然，如果你这样写&lt;strong&gt;GenericClass&amp;lt;T extends Serializable&amp;amp;Comparable&amp;gt;&lt;/strong&gt; ，那么擦除后的类型为Serializable。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.2翻译泛型表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当程序调用泛型方法时，如果擦除返回类型， 编译器将插入强制类型转换。例如List集合源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; List&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; Collection&amp;lt;E&amp;gt;&lt;span&gt; {
    ...
    E get(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index);
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当不使用类型变量时，取出来的值是Object，而定义了String类型变量时，编译器将插入强制类型转换：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
List list1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();&lt;br/&gt;list1.add(&quot;1&quot;);
list1.get(&lt;/span&gt;0); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;
&lt;span&gt;
List&lt;/span&gt;&amp;lt;String&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();&lt;br/&gt;list2.add(&quot;1&quot;);
list2.get(&lt;/span&gt;0); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 但是在虚拟机中时，list2.get(0)在调用时翻译成了两条虚拟机命令：&lt;/p&gt;
&lt;p&gt;1.对原始方法List集合的get方法调用&lt;/p&gt;
&lt;p&gt;2.将返回的Object进行强制类型转换成String&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.3翻译泛型方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当GenericSubClass类继承了Generic类时，泛型方法会有什么变化？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Generic&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; T size;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T getSize() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
    }&lt;br/&gt;...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GenericSubclass &lt;span&gt;extends&lt;/span&gt; Generic&amp;lt;Integer&amp;gt;&lt;span&gt; {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getSize() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getSize();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此时的@Override真的是重写父类方法吗？到了运行期间，Generic被类型擦除后getSize方法返回类型变成Object：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Object getSize() { &lt;span&gt;return&lt;/span&gt; size; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而GenericSubclass的getSize方法的返回类型却是Integer：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Integer getSize() { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.getSize(); }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这并不是重写父类的方法，因为方法并不一样，所以导致GenericSubclass在虚拟机中却有了两个getSize方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getSize() {  ...  }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object getSize() {  ...  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导致的原因就是类型擦除与多态发生了冲突。要解决此问题，虚拟机自动在GenericSubclass中生成了一个桥方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Integer getSize() { &lt;span&gt;return&lt;/span&gt; (Integer)&lt;span&gt;super&lt;/span&gt;.getSize(); }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，虚拟机就会调用自己生成的桥方法来解决此冲突。&lt;/p&gt;

&lt;p&gt;若有不足之处，请各位大牛在下面留言指出，Thanks♪(･ω･)ﾉ&lt;/p&gt;
</description>
<pubDate>Mon, 10 Sep 2018 06:36:00 +0000</pubDate>
<dc:creator>Johnson木木</dc:creator>
<og:description>1.泛型程序设计 泛型程序设计意味着编写的代码可以被很多不同类型的对象所重用。例如：不希望为了聚集String和Integer对象分别设计不同的类。（个人觉得此处说的聚集译为：创建一个对象，属性可以为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Johnson-lin/p/9580971.html</dc:identifier>
</item>
</channel>
</rss>