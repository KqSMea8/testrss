<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>dotnet core在Task中使用依赖注入的Service/EFContext - 李国宝</title>
<link>http://www.cnblogs.com/liguobao/p/9992451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liguobao/p/9992451.html</guid>
<description>&lt;p&gt;dotnet core时代,依赖注入基本已经成为标配了,这就不多说了.&lt;/p&gt;
&lt;p&gt;前几天在做某个功能的时候遇到在Task中使用EF DbContext的问题,学艺不精的我被困扰了不短的一段时间,&lt;/p&gt;
&lt;p&gt;于是有了这个文章.&lt;/p&gt;
&lt;p&gt;先说一下代码结构和场景.&lt;/p&gt;
&lt;p&gt;首先有一个HouseDbContext,代码大概是下面这样:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class HouseDbContext : DbContext
{
    public HouseDbContext(DbContextOptions&amp;lt;HouseDbContext&amp;gt; options)
        : base(options)
    {
    }
    public DbSet&amp;lt;Notice&amp;gt; Notices { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着已经在StarUp.cs中初始化并注入了,注入代码是这样的:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
services.AddDbContextPool&amp;lt;HouseDbContext&amp;gt;(options =&amp;gt;
{
    options.UseLoggerFactory(loggerFactory);
    options.UseMySql(Configuration[&quot;MySQLString&quot;].ToString());
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一个NoticeService.cs 会用到HouseDbContext 进行增删查改&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class NoticeService
{

    private readonly HouseDbContext _dataContext;

    public NoticeService(HouseDbContext dataContext)
    {
        _dataContext = dataContext;
    }

    public Notice FindNotice(long id)
    {
        var notice = _dataContext.Notices.FirstOrDefault(n =&amp;gt;n.Id == id);
        return notice;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然我们也需要把NoticeService注入到容器中,类似这样&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
services.AddScoped&amp;lt;NoticeService,NoticeService&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在一切都是很美好的,也能正常查询出Notice&lt;/p&gt;
&lt;p&gt;然后某一天来了,有个需求是Update Notice之后需要把Notice同步到另外一个地方,例如Elasticsearch?&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
public class NoticeService
{

    private readonly HouseDbContext _dataContext;

    public NoticeService(HouseDbContext dataContext)
    {
        _dataContext = dataContext;
    }

    public Notice FindNotice(long id)
    {
        var notice = _dataContext.Notices.FirstOrDefault(n =&amp;gt;n.Id == id);
        return notice;
    }

    public void Save(Notice notice)
    {
        _dataContext.Notices.Add(notice);
        _dataContext.SaveChanges();
        Task.Run(() =&amp;gt;
        {
            try
            {
                var one = _dataContext.Notices.FirstOrDefault(n =&amp;gt;n.Id == notice.Id);
                // write to other
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.ToString());
            }
        });
    }
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后一跑...&lt;/p&gt;
&lt;p&gt;代码炸了...&lt;/p&gt;
&lt;p&gt;恭喜你获得跨线程使用EF DbContext导致上下文不同步的异常.&lt;/p&gt;
&lt;p&gt;错误大概长这样.&lt;/p&gt;
&lt;pre class=&quot;log&quot;&gt;
&lt;code&gt;
System.ObjectDisposedException: Cannot access a disposed object. A common cause of this error is disposing a context that was resolved from dependency injection and then later trying to use the same context instance elsewhere in your application. This may occur if you are calling Dispose() on the context, or wrapping the context in a using statement. If you are using dependency injection, you should let the dependency injection container take care of disposing context instances.
      Object name: 'HouseDbContext'.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;估计现在整个人都不好了.&lt;/p&gt;
&lt;p&gt;这个撒意思呢?&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;
无法访问被释放的对象。

这种错误的一个常见原因是使用从依赖注入中解决的上下文，然后在应用程序的其他地方尝试使用相同的上下文实例。

如果您在上下文上调用Dispose()，或者在using语句中包装上下文，可能会发生这种情况。如果使用依赖项注入，则应该让依赖项注入容器处理上下文实例。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用人话来说是什么意思呢?&lt;/p&gt;
&lt;p&gt;这里的HouseDbContext是依赖注入进来的,生命周期由容器本身管理;&lt;/p&gt;
&lt;p&gt;在Task.Run中再次使用HouseDbContext实例中由于已经切换了线程了,&lt;/p&gt;
&lt;p&gt;HouseDbContext实例已经被释放掉了,无法再继续使用同一个实例,我们应该自己初始化HouseDbContext来用.&lt;/p&gt;
&lt;p&gt;到这里的话,上次我做的时候心生一计:&lt;/p&gt;
&lt;p&gt;既然我们不能直接从构造函数注入的HouseDbContext实例的话,我们是不是可以直接从依赖注入容器中拿一个实例回来呢?&lt;/p&gt;
&lt;p&gt;那在dotnet core里面可以用个什么从容器中取出实例呢?&lt;/p&gt;
&lt;p&gt;答案是:IServiceProvider&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
public class NoticeService
    {

        private readonly HouseDbContext _dataContext;

        private readonly IServiceProvider _serviceProvider;

        public NoticeService(HouseDbContext dataContext,IServiceProvider serviceProvider)
        {
            _dataContext = dataContext;
            _serviceProvider = serviceProvider;
        }

        public Notice FindNotice(long id)
        {
            var notice = _dataContext.Notices.FirstOrDefault(n =&amp;gt; n.Id == id);
            Task.Run(() =&amp;gt;
            {
                try
                {
                    var context = _serviceProvider.GetService&amp;lt;HouseDbContext&amp;gt;();
                    var one = context.Notices.FirstOrDefault(n =&amp;gt; n.Id == notice.Id);
                    Console.WriteLine(notice.Id);
                    // write to other
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.ToString());
                }
            });
            return notice;
        }

        public void Save(Notice notice)
        {
            _dataContext.Notices.Add(notice);
            _dataContext.SaveChanges();
            Task.Run(() =&amp;gt;
            {
                try
                {
                    var one = _dataContext.Notices.FirstOrDefault(n =&amp;gt; n.Id == notice.Id);
                    // write to other
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.ToString());
                }
            });
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跑一下看看...&lt;/p&gt;
&lt;p&gt;然而事实告诉我,实例是能拿得到,然而还是会炸,错误是一样的.&lt;/p&gt;
&lt;p&gt;原因其实还是一样的,这里已经不受依赖注入托管了,人家的上下文你别想用了.&lt;/p&gt;
&lt;p&gt;那咋办呢...&lt;/p&gt;
&lt;p&gt;在EF6,还可以直接new HouseDbContext 一个字符串进去初始化,在EF Core这里,已经不能这样玩了.&lt;/p&gt;
&lt;p&gt;那可咋办呢?&lt;/p&gt;
&lt;p&gt;翻了好多资料都没看到有人介绍过咋办,最后居然还是在官网教程里面找到了样例.&lt;/p&gt;
&lt;p&gt;先看代码...&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; Task.Run(() =&amp;gt;
{
    try
    {
        var optionsBuilder = new DbContextOptionsBuilder&amp;lt;HouseDbContext&amp;gt;();
        // appConfiguration.MySQLString appConfiguration是配置类,MySQLString为连接字符串
        optionsBuilder.UseMySql(appConfiguration.MySQLString);
        using (var context = new HouseDbContext(optionsBuilder.Options))
        {
            var one = context.Notices.FirstOrDefault(n =&amp;gt; n.Id == notice.Id);
            // 当然你也可以直接初始化其他的Service
            var nService = new NoticeService(context,null);
            var one =nService.FindOne(notice.Id);
        }

    }catch (Exception ex)
    {
        Console.WriteLine(ex.ToString());
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;教程代码在:&lt;a href=&quot;https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext&quot;&gt;Configuring a DbContext&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大功告成...&lt;/p&gt;
</description>
<pubDate>Tue, 20 Nov 2018 15:13:00 +0000</pubDate>
<dc:creator>李国宝</dc:creator>
<og:description>C :在Task中使用依赖注入的Service/EFContext dotnet core时代,依赖注入基本已经成为标配了,这就不多说了. 前几天在做某个功能的时候遇到在Task中使用EF DbCon</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liguobao/p/9992451.html</dc:identifier>
</item>
<item>
<title>Netty聊天室（2）：从0开始实战100w级流量应用 - 疯狂创客圈</title>
<link>http://www.cnblogs.com/crazymakercircle/p/9992394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crazymakercircle/p/9992394.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;&lt;span&gt;疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之 17【 &lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;博客园 总入口&lt;/a&gt; 】&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;源码IDEA工程获取链接&lt;/strong&gt;：&lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;Java 聊天室 实战 源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;​ 大家好，我是作者尼恩。&lt;/p&gt;
&lt;p&gt;​ 前面，已经完成一个高性能的 Java 聊天程序的四件大事：&lt;/p&gt;
&lt;ol readability=&quot;4.0987012987013&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;完成了协议选型，选择了性能更佳的 &lt;strong&gt;Protobuf协议&lt;/strong&gt;。具体的文章为： &lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9926534.html&quot;&gt;Netty+Protobuf 整合一：实战案例，带源码&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;介绍了 &lt;strong&gt;通讯消息数据包的几条设计准则&lt;/strong&gt;。具体的文章为： &lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9937026.html&quot;&gt;Netty +Protobuf 整合二：protobuf 消息通讯协议设计的几个准则&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解决了一个非常基础的问题，这就是通讯的 &lt;strong&gt;粘包和半包问题。&lt;/strong&gt;具体的文章为：&lt;a href=&quot;https://blog.csdn.net/crazymakercircle/article/details/83957259&quot;&gt;Netty 粘包/半包 全解 | 史上最全解读&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.7076923076923&quot;&gt;
&lt;p&gt;前一篇文件，已经完成了 系统三大组成模块的组成介绍。 具体的文章为：&lt;a href=&quot;https://blog.csdn.net/crazymakercircle/article/details/83961247&quot;&gt;Netty聊天程序（实战一）：从0开始实战100w级流量应用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天介绍非常重要的一个内容：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端的通讯、登录请求和登录响应设计&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面，开启今天的 &lt;strong&gt;惊险和刺激实战之旅&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;客户端的会话管理&quot;&gt;客户端的会话管理&lt;/h2&gt;
&lt;p&gt;​ 什么是会话？&lt;/p&gt;
&lt;p&gt;​ 为了方便客户端的开发，管理与服务器的连接，这里引入一个非常重要的中间角色——Session （会话）。有点儿像Web开发中的Tomcat的服务器 Session，但是又有很大的不同。&lt;/p&gt;
&lt;p&gt;​ 客户端的会话概念图，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181120225319455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 客户端会话有两个很重的成员，一个是user，代表了拥有会话的用户。一个是channel，代表了连接的通道。两个成员的作用是：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过user，可以获得当前的用户信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;通过channel，可以向服务器发送消息&lt;/p&gt;
&lt;p&gt;所以，会话左拥右抱，左手用户资料，右手服务器的连接。在本例的开发中，会经常用到。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;客户端的逻辑构成&quot;&gt;客户端的逻辑构成&lt;/h2&gt;
&lt;p&gt;从逻辑上来说，客户端有三个子的功能模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181120225352646.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块一：Handler&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;入站处理器。&lt;/p&gt;
&lt;p&gt;在Netty 中非常重要，负责处理入站消息。比方，服务器发送过来登录响应，服务器发送过来的聊天消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块二：MsgBuilder&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消息组装器。&lt;/p&gt;
&lt;p&gt;将 Java 内部的 消息 Bean 对象，转成发送出去的 Protobuf 消息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模块三：Sender&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消息发送器。&lt;/p&gt;
&lt;p&gt;Handler 负责收的工作。Sender 则是负责将消息发送出去。&lt;/p&gt;
&lt;p&gt;三大子模块的类关系图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181120225416785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;介绍完成了主要的组成部分后，开始服务器的连接和Session 的创建。&lt;/p&gt;
&lt;h2 id=&quot;连接服务器与session-的创建&quot;&gt;连接服务器与Session 的创建&lt;/h2&gt;
&lt;p&gt;​ 通过bootstrap 帮助类，设置完成线程组、通道类型，向管道流水线加入处理器Handler后，就可以开始连接服务器的工作。&lt;/p&gt;
&lt;p&gt;​ 本小节需要重点介绍的，是连接成功之后，创建 Session，并且将 Session和 channel 相互绑定。&lt;/p&gt;
&lt;p&gt;​ 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.crazymakercircle.chat.client;
//...
@Data
@Service(&quot;EchoClient&quot;)
public class ChatClient
{
    static final Logger LOGGER =
            LoggerFactory.getLogger(ChatClient.class);
   //..
    private Channel channel;
    private ClientSender sender;

   public void doConnect(Bootstrap bootstrap, EventLoopGroup eventLoopGroup)
    {
        ChannelFuture f = null;
        try
        {
            if (bootstrap != null)
            {
                bootstrap.group(eventLoopGroup);
                bootstrap.channel(NioSocketChannel.class);
                bootstrap.option(ChannelOption.SO_KEEPALIVE, true);
                bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
                bootstrap.remoteAddress(host, port);

                // 设置通道初始化
                bootstrap.handler(
                        new ChannelInitializer&amp;lt;SocketChannel&amp;gt;()
                        {
                            public void initChannel(SocketChannel ch) throws Exception
                            {
                                ch.pipeline().addLast(new ProtobufDecoder());
                                ch.pipeline().addLast(new ProtobufEncoder());
                                ch.pipeline().addLast(chatClientHandler);

                            }
                        }
                );
                LOGGER.info(new Date() + &quot;客户端开始登录[疯狂创客圈IM]&quot;);

                f = bootstrap.connect().addListener((ChannelFuture futureListener) -&amp;gt;
                {
                    final EventLoop eventLoop = futureListener.channel().eventLoop();
                    if (!futureListener.isSuccess())
                    {
                        LOGGER.info(&quot;与服务端断开连接!在10s之后准备尝试重连!&quot;);
                        eventLoop.schedule(() -&amp;gt; doConnect(new Bootstrap(), eventLoop), 10, TimeUnit.SECONDS);

                        initFalg = false;
                    }
                    else
                    {
                        initFalg = true;
                    }
                    if (initFalg)
                    {
                        LOGGER.info(&quot;EchoClient客户端连接成功!&quot;);

                        LOGGER.info(new Date() + &quot;: 连接成功，启动控制台线程……&quot;);
                        channel = futureListener.channel();

                        // 创建会话
                        ClientSession session = new ClientSession(channel);
                        channel.attr(ClientSession.SESSION).set(session);
                        session.setUser(ChatClient.this.getUser());
                        startConsoleThread();
                    }

                });

                // 阻塞
                f.channel().closeFuture().sync();
            }
        } catch (Exception e)
        {
            LOGGER.info(&quot;客户端连接失败!&quot; + e.getMessage());
        }

    }

 //...

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;session和-channel-相互绑定&quot;&gt;Session和 channel 相互绑定&lt;/h2&gt;
&lt;p&gt;Session和 channel 相互绑定，再截取出来，分析一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ClientSession session = new ClientSession(channel);
channel.attr(ClientSession.SESSION).set(session);
session.setUser(ChatClient.this.getUser());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 为什么要Session和 channel 相互绑定呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发的时候， 需要从Session 写入 Channel ，这相当于正向的绑定。&lt;/li&gt;
&lt;li&gt;收的时候，是从Channel 过来的，需要找到 Session ，这相当于反向的绑定。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;​ Netty 中的 channel ，实现了AttributeMap接口 ，相当于一个 Map容器。 反向的绑定，利用了channel 的这个特点。&lt;/p&gt;
&lt;p&gt;​ 看一下AttributeMap接口 如何使用的？&lt;/p&gt;
&lt;h2 id=&quot;attributemap接口的使用&quot;&gt;AttributeMap接口的使用&lt;/h2&gt;
&lt;p&gt;​ AttributeMap 是一个接口，并且只有一个attr()方法，接收一个AttributeKey类型的key，返回一个Attribute类型的value。按照Javadoc，AttributeMap实现必须是线程安全的。&lt;/p&gt;
&lt;p&gt;​ AttributeMap内部结构看起来像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20140102093819875?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenhob28=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不要被吓着了，其实很简单。&lt;/p&gt;
&lt;p&gt;AttributeMap 的使用，主要是设置和取值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设值 Key-&amp;gt; Value&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;AttributeMap 的设值的方法，举例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.attr(ClientSession.SESSION).set(session);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个是链式调用，attr（） 方法中的是 Key， set（）方法中的是Value。 这样就完成了 Key-&amp;gt; Value 的设置。&lt;/p&gt;
&lt;p&gt;AttributeMap 的取值的方法，举例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ClientSession session =
        ctx.channel().attr(ClientSession.SESSION).get();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个是链式调用，attr（） 方法中的是 Key， get（）方法返回 的是Value。 这样就完成了 取值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键是，这个key比较特殊&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一般的Map，Key 的类型多半为字符串。但是这里的Key不行，有特殊的约定。&lt;/p&gt;
&lt;p&gt;Key的类型必须是 AttributeKey 类型，而且这是一个泛型类，它的优势是，不需要对值进行强制的类型转换。&lt;/p&gt;
&lt;p&gt;Key的例子如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static final AttributeKey&amp;lt;ClientSession&amp;gt; SESSION = AttributeKey.valueOf(&quot;session&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;客户端登录请求&quot;&gt;客户端登录请求&lt;/h2&gt;
&lt;p&gt;登录的请求，大致如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181120225458660.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ClientSender的 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.crazymakercircle.chat.client;

@Service(&quot;ClientSender&quot;)
public class ClientSender
{
    static final Logger LOGGER = LoggerFactory.getLogger(ClientSender.class);


    private User user;
    private ClientSession session;

    public void sendLoginMsg()
    {
        LOGGER.info(&quot;开始登陆&quot;);
        ProtoMsg.Message message = LoginMsgBuilder.buildLoginMsg(user);
        session.writeAndFlush(message);
    }

//...
    public boolean isLogin()
    {
        return  session.isLogin();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sender 首先通过 LoginMsgBuilder，构造一个protobuf 消息。然后调用session发送消息。&lt;/p&gt;
&lt;p&gt;session 会通过绑定的channel ，将消息发送出去。&lt;/p&gt;
&lt;p&gt;session的代码，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized void writeAndFlush(Object pkg)
{
    channel.writeAndFlush(pkg);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他的客户端请求流程，大致也是类似的。&lt;/p&gt;
&lt;p&gt;一个客户端的请求大致的流程有三步，分别从Sender 到session到channel。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181120225522473.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;处理登录成功的响应&quot;&gt;处理登录成功的响应&lt;/h2&gt;
&lt;p&gt;​ 这是从服务器过来的入站消息。 如果登录成功，服务器会发送一个登录成功的响应过来。 这个响应，会从channel 传递到Handler。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181120225547888.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;处理器 LoginResponceHandler 的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.crazymakercircle.chat.clientHandler;

//...

public class LoginResponceHandler extends ChannelInboundHandlerAdapter
{
    static final Logger LOGGER = LoggerFactory.getLogger(LoginResponceHandler.class);
    /**
     * 业务逻辑处理
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception
    {
        LOGGER.info(&quot;msg:{}&quot;, msg.toString());
        if (msg != null &amp;amp;&amp;amp; msg instanceof ProtoMsg.Message)
        {
            ProtoMsg.Message pkg = (ProtoMsg.Message) msg;
            ProtoMsg.LoginResponse info = pkg.getLoginResponse();
            ProtoInstant.ResultCodeEnum result =
                    ProtoInstant.ResultCodeEnum.values()[info.getCode()];

            if (result.equals(ProtoInstant.ResultCodeEnum.SUCCESS))
            {
                ClientSession session =
                        ctx.channel().attr(ClientSession.SESSION).get();

                session.setLogin(true);
                LOGGER.info(&quot;登录成功&quot;);
            }
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ LoginResponceHandler 对消息类型进行判断，如果是请求响应消息，并且登录成功。 则取出绑定的session，通过session，进一步完成登录成功后的业务处理。&lt;/p&gt;
&lt;p&gt;​ 比如设置成功的状态，完成一些成功的善后处理操作等等。&lt;/p&gt;
&lt;p&gt;​ 其他的客户端响应处理流程，大致也是类似的。&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img-blog.csdnimg.cn/20181120225618960.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;​ 至此为止，可以看到，客户端登录的完整流程。&lt;/p&gt;
&lt;p&gt;​ 下一篇：服务器的请求处理和通讯的全流程闭环介绍。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;疯狂创客圈-java-死磕系列&quot;&gt;疯狂创客圈 Java 死磕系列&lt;/h2&gt;
&lt;ul readability=&quot;-0.85082872928177&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Java (Netty) 聊天程序【 亿级流量】实战 开源项目实战&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Netty 源码、原理、JAVA NIO 原理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java 面试题 一网打尽&lt;/strong&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.37209302325581&quot;&gt;
&lt;p&gt;疯狂创客圈 &lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;&lt;strong&gt;【 博客园 总入口 】&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;</description>
<pubDate>Tue, 20 Nov 2018 14:59:00 +0000</pubDate>
<dc:creator>疯狂创客圈</dc:creator>
<og:description>客户端 Client 登录和响应处理 疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之 17【</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crazymakercircle/p/9992394.html</dc:identifier>
</item>
<item>
<title>孤荷凌寒自学python第十三天python代码的外部模块引用与基本赋值语句 - 孤荷凌寒</title>
<link>http://www.cnblogs.com/lhghroom/p/9992167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lhghroom/p/9992167.html</guid>
<description>&lt;p&gt;&lt;span&gt;孤荷凌寒自学python第十三天python代码的外部模块引用与基本赋值语句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（完整学习过程屏幕记录视频地址在文末，手写笔记在文末）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从结构化编程流行以来，代码便被分块存储，称之为模块或库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在python中仍然如其它编程语言一样，我们可以在一个文档中方便地引用一个模块，然后可以在当前文档的代码中使用外部模块的可用对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般来说，在python中一个外部模块也对应了一个以.py结尾的具体文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、引用模块中的全部内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要想使用一个模块中的全部内容，使用import关键字在文件的最顶端声明一下即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;import 模块名[,模块名2][,模块名3][……]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体示例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;import math&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上一代码表示，我们要使用pytho标准库目录下的math.py文件中的全部可用对象，包括数学常量，计算方法等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、只引用一个模块中部分内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果只是要使用一个模块中的部分内容，则没有必要引用整个模块，我们可以用import关键字声明要引用的那部分内容即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from 模块名  import 具体要引用的对象[,具体要引用的对象2][……]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体示例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;from math import pi&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上一代码表示 ，只引用了math.py文件中的一个常量pi&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、print语句同时输出多个内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;print语句的逗号输出法，使用逗号将多个要输出的对象分隔开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; strA='孤荷凌寒'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; lstB=list('QQ号码是：578652607')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; tplC=tuple('个人主页：www.lhghroom.cn')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(strA,lstB,tplC)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;孤荷凌寒 ['Q', 'Q', '号', '码', '是', '：', '5', '7', '8', '6', '5', '2', '6', '0', '7'] ('个', '人', '主', '页', '：', 'w', 'w', 'w', '.', 'l', 'h', 'g', 'h', 'r', 'o', 'o', 'm', '.', 'c', 'n')&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四、特殊的赋值方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般说来，python和其它高级语言一样，都使用=号来进行赋值操作，将=右边的对象或表达式或值赋予=左边的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;strA=’孤荷凌寒’&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表示将字符串‘孤荷凌寒’赋值给变量strA&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;普通的赋值语句只能一次给一个对象或变量赋值一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天学习到了python中非常高效的一些赋值语句的写法，其中有些是其它编程语言也有的习惯写法，而有一些确实是python独有的高效的写法，非常令我叹服。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 序列解包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在=号左边用逗号分隔多个变量或对象，然后在等号右边也用逗号分隔多个变量或对象或表达式。=两边的对象或变量总数一样多，这样就同时用一行语句进行了多个对象的赋值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; intA,intB,intC,intD=1,2,3,3+1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print('intA='+ str(intA),'intB='+ str(intB),'intC='+str(intC),'intD='+str(intD))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;intA=1 intB=2 intC=3 intD=4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2 稍微变化 的 序列解包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; tplNums=1,2,3,3+1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(tplNums)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1, 2, 3, 4)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; intA,intB,intC,intD=tplNums&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print('intA='+ str(intA),'intB='+ str(intB),'intC='+str(intC),'intD='+str(intD))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;intA=1 intB=2 intC=3 intD=4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3 链式赋值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链式赋值像电的传导一样，快速将一个内容传递给多个变量或对象：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; intA=intB=intC=intD=32-8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print('intA='+ str(intA),'intB='+ str(intB),'intC='+str(intC),'intD='+str(intD))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;intA=24 intB=24 intC=24 intD=24&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4 增量赋值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同多数编程语言一样，python支持简洁的增量赋值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓增量赋值是把正常的赋值语句：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;i=i+1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简写成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;i+=1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个语句的效果是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样的，将+号换成-*/都是可以的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但我发现python不支持&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;i++&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样的写法，是的，不支持！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（i++这样的写法在c系及J系等语言中表示 i=i+1）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; i=2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; i+=1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(i)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; i-=1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(i)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; i*=2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(i)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; i/=2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; print(i)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; i++  #python是不支持这种写法的，于是出错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SyntaxError: invalid syntax&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——————————&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天整理的学习笔记完成，最后例行说明下我的自学思路：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据过去多年我自学各种编程语言的经历，认为只有真正体验式，解决实际问题式的学习才会有真正的效果，即让学习实际发生。在2004年的时候我开始在一个乡村小学自学电脑 并学习vb6编程语言，没有学习同伴，也没有高师在上，甚至电脑都是孤岛（乡村那时还没有网络），有的只是一本旧书，在痛苦的自学摸索中，我找到适应自己零基础的学习方法：首先是每读书的一小节就作相应的手写笔记，第二步就是上机测试每一个笔记内容是否实现，其中会发现书中讲的其实有出入或错误，第三步就是在上机测试之后，将笔记改为电子版，形成最终的修订好的正确无误的学习笔记 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过反复尝试错误，在那个没有分享与交流的黑暗时期我摸黑学会了VB6，尔后接触了其它语言，也曾听过付费视频课程，结果发现也许自己学历果然太低，就算是零基础的入门课程，其实也难以跟上进度，讲师的教学多数出现对初学者的实际情况并不了解的情况，况且学习者的个体也存在差异呢？当然更可怕的是收费课程的价格往往是自己难以承受的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是我的所有编程学习都改为了自学，继续自己的三步学习笔记法的学习之路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然自学的最大问题是会走那么多的弯路，没有导师直接输入式的教学来得直接，好在网络给我们带来无限搜索的机会，大家在网络上的学习日志带给我们共享交流的机会，而QQ群等交流平台、网络社区的成立，我们可以一起自学，互相批评交流，也可以获得更有效，更自主的自学成果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是我以人生已过半的年龄，决定继续我的编程自学之路，开始学习python，只希望与大家共同交流，一个人的独行是可怕的，只有一群人的共同前进才是有希望的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;诚挚期待您的交流分享批评指点！&lt;strong&gt;欢迎联系我加入从零开始的自学联盟。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时代互联网成为了一种基础设施的存在，于是本来在孤独学习之路上的我们变得不再孤独，因为网络就是一个新的客厅，我们时刻都可以进行沙龙活动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非常乐意能与大家一起交流自己自学心得和发现，更希望大家能够对我学习过程中的错误给予指点——是的，这样我就能有许多免费的高师了——这也是分享时代，社区时代带来的好福利，我相信大家会的，是吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据完全共享的精神，开源互助的理念，我的个人自学录制过程是全部按4K高清视频录制的,从手写笔记到验证手写笔记的上机操作过程全程录制，但因为4K高清文件太大均超过5G以上，所以无法上传至网络，如有需要可联系我QQ578652607对传，乐意分享。上传分享到百度网盘的只是压缩后的720P的视频。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的学习过程录像百度盘地址分享如下：（清晰度：1280x720）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链接：&lt;a href=&quot;https://pan.baidu.com/s/18eebr89AcaipBZLv3KjJsw&quot;&gt;https://pan.baidu.com/s/18eebr89AcaipBZLv3KjJsw&lt;/a&gt;  密码：rm7d&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Bilibili:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.bilibili.com/video/av35837810/&quot;&gt;https://www.bilibili.com/video/av35837810/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜马拉雅语音笔记：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.ximalaya.com/keji/19103006/138203030&quot;&gt;https://www.ximalaya.com/keji/19103006/138203030&lt;/a&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1246771/201811/1246771-20181120222247171-219777484.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1246771/201811/1246771-20181120222256400-1305709746.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1246771/201811/1246771-20181120222314548-40214036.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Nov 2018 14:24:00 +0000</pubDate>
<dc:creator>孤荷凌寒</dc:creator>
<og:description>孤荷凌寒自学python第十三天python代码的外部模块引用与基本赋值语句 （完整学习过程屏幕记录视频地址在文末，手写笔记在文末） 从结构化编程流行以来，代码便被分块存储，称之为模块或库。 在pyt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lhghroom/p/9992167.html</dc:identifier>
</item>
<item>
<title>Python的串口通信（pyserial） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/9992083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/9992083.html</guid>
<description>&lt;p&gt;         串口通信是指外设和计算机间，通过数据信号线 、地线、控制线等，按位进行传输数据的一种通讯方式。这种通信方式使用的数据线少，在远距离通信中可以节约通信成本，但其传输速度比并行传输低。&lt;/p&gt;
&lt;p&gt;串口是计算机上一种非常通用的设备通信协议。pyserial模块封装了python对串口的访问，为多平台的使用提供了统一的接口。&lt;/p&gt;

&lt;p&gt;安装：&lt;/p&gt;
&lt;p&gt;pip3 install pyserial&lt;/p&gt;

&lt;p&gt;硬件要求：&lt;/p&gt;
&lt;p&gt;两个CH340 （TTL转串口模块）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201811/1485202-20181120220851214-2062653888.png&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;249&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;简单串口程序实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; serial &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入模块&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;端口，GNU / Linux上的/ dev / ttyUSB0 等 或 Windows上的 COM3 等&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;   portx=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;COM3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;波特率，标准值之一：50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   bps=115200
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;超时设置,None：永远等待操作，0为立即返回请求结果，其他值为等待超时时间(单位为秒）&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;   timex=5
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开串口，并得到串口对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;   ser=serial.Serial(portx,bps,timeout=&lt;span&gt;timex)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写数据&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   result=ser.write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是东小东&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;写总字节数:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,result)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;   ser.close()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭串口&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---异常---：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,e)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;获取可用串口列表：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; serial &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入模块&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; serial.tools.list_ports
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; port_list =&lt;span&gt; list(serial.tools.list_ports.comports())
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(port_list)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; len(port_list) ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;无可用串口&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(0,len(port_list)):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(port_list[i])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;十六进制处理：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; serial &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入模块&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   portx=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;COM3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;   bps=115200
&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;超时设置,None：永远等待操作，0为立即返回请求结果，其他值为等待超时时间(单位为秒）&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   timex=&lt;span&gt;None
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   ser=serial.Serial(portx,bps,timeout=&lt;span&gt;timex)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;串口详情参数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ser)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;十六进制的发送&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   result=ser.write(chr(0x06).encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;写数据&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;写总字节数:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,result)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;十六进制的读取&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;   &lt;span&gt;print&lt;/span&gt;(ser.read().hex())&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读一个字节&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   ser.close()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭串口&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---异常---：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,e)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;其他细节补充：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; serial &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入模块&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;端口，GNU / Linux上的/ dev / ttyUSB0 等 或 Windows上的 COM3 等&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;   portx=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;COM3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;波特率，标准值之一：50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;   bps=115200
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;超时设置,None：永远等待操作，0为立即返回请求结果，其他值为等待超时时间(单位为秒）&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   timex=5
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开串口，并得到串口对象&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;   ser=serial.Serial(portx,bps,timeout=&lt;span&gt;timex)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;串口详情参数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ser)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;   &lt;span&gt;print&lt;/span&gt;(ser.port)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取到当前打开的串口名&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;print&lt;/span&gt;(ser.baudrate)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取波特率&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;   result=ser.write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是东小东&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;写数据&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;   &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;写总字节数:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,result)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(ser.read())#读一个字节&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(ser.read(10).decode(&quot;gbk&quot;))#读十个字节&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(ser.readline().decode(&quot;gbk&quot;))#读一行&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(ser.readlines())#读取多行，返回列表，必须匹配超时（timeout)使用&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(ser.in_waiting)#获取输入缓冲区的剩余字节数&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;print(ser.out_waiting)#获取输出缓冲区的字节数&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;循环接收数据，此为死循环，可用线程实现&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;          &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ser.in_waiting:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;              str=ser.read(ser.in_waiting ).decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;              &lt;span&gt;if&lt;/span&gt;(str==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;退出标志&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                  &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;              &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;收到数据：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,str)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;   &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;   ser.close()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭串口&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---异常---：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,e)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;部分封装：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; serial &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入模块&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; threading
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; STRGLO=&lt;span&gt;&quot;&quot;&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取的数据&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; BOOL=True  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取标志位&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;读数代码本体实现&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; ReadData(ser):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; STRGLO,BOOL
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 循环接收数据，此为死循环，可用线程实现&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt; BOOL:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ser.in_waiting:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             STRGLO = ser.read(ser.in_waiting).decode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(STRGLO)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打开串口&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 端口，GNU / Linux上的/ dev / ttyUSB0 等 或 Windows上的 COM3 等&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 波特率，标准值之一：50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400,57600,115200&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 超时设置,None：永远等待操作，0为立即返回请求结果，其他值为等待超时时间(单位为秒）&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; DOpenPort(portx,bps,timeout):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     ret=&lt;span&gt;False
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开串口，并得到串口对象&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         ser = serial.Serial(portx, bps, timeout=&lt;span&gt;timeout)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断是否打开成功&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(ser.is_open):
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;            ret=&lt;span&gt;True
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;            threading.Thread(target=ReadData, args=&lt;span&gt;(ser,)).start()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---异常---：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ser,ret
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭串口&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; DColsePort(ser):
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; BOOL
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     BOOL=&lt;span&gt;False
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    ser.close()
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;写数据&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; DWritePort(ser,text):
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     result = ser.write(text.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写数据&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;读数据&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; DReadPort():
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;global&lt;/span&gt;&lt;span&gt; STRGLO
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     str=&lt;span&gt;STRGLO
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     STRGLO=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;清空当次读取&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; str
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     ser,ret=DOpenPort(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;COM6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,115200&lt;span&gt;,None)
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(ret==True):&lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断串口是否成功打开&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;          count=DWritePort(ser,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是东小东，哈哈&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;          &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;写入字节数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,count)
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;DReadPort() #读串口数据&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;DColsePort(ser)  #关闭串口&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;hr/&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wjcq8455/article/details/77981616&quot;&gt;https://blog.csdn.net/wjcq8455/article/details/77981616&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pythonhosted.org/pyserial/pyserial_api.html#serial.Serial.open&quot;&gt;https://pythonhosted.org/pyserial/pyserial_api.html#serial.Serial.open&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 20 Nov 2018 14:17:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>串口通信是指外设和计算机间，通过数据信号线 、地线、控制线等，按位进行传输数据的一种通讯方式。这种通信方式使用的数据线少，在远距离通信中可以节约通信成本，但其传输速度比并行传输低。 串口是计算机上一种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dongxiaodong/p/9992083.html</dc:identifier>
</item>
<item>
<title>使用PrefView监测.NET程序性能（一）：Event Trace for Windows - wyman25</title>
<link>http://www.cnblogs.com/lwhkdash/p/9949566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwhkdash/p/9949566.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;在日常项目开发中，我们时不时会遇到程序占用了很高CPU的情况，可能是程序里某些未经优化的代码或者Bug，或者是程序运行压力太大。无论是什么原因，我们总希望能看到到底是哪个方法占用了如此高的CPU。&lt;/p&gt;
&lt;p&gt;微软为我们提供了很多性能诊断工具来达到此目的。例如在Visual Studio 2017中的性能查探器，Windows SDK中的Windows Performance Recorder (WPR) 和Windows Performance Analyzer (WPA)，XPerf，当然，还有这篇博客介绍的PrefView。&lt;/p&gt;
&lt;p&gt;但在介绍PrefView的使用前，有一个在Windows系统及应用程序性能这个主题上扮演重要角色的技术必须被提及，这就是Event Trace for Windows (ETW)。事实上，上边提及到的性能分析工具都是基于ETW来实现的。&lt;/p&gt;
&lt;h2&gt;什么是ETW&lt;/h2&gt;
&lt;p&gt;在&lt;a href=&quot;https://docs.microsoft.com/en-us/windows-hardware/test/wpt/event-tracing-for-windows&quot; target=&quot;_blank&quot;&gt;微软上的解释&lt;/a&gt;中，ETW是自Windows 2000 推出的&quot;内核级&quot;的事件日志实现。通过记录系统及应用程序中各类事件日志，可以监测和分析系统及程序的运行细节，例如CPU使用率，.NET程序的GC状况等。ETW的日志里，包含着非常多的有用信息，例如进程/线程信息,上下文切换，各种I/O信息，程序执行时的时间节点，甚至是函数调用等信息。通过对日志数据进行实时采集,或者分析事件日志记录文件(.etl文件)，就能轻易地检测和分析系统和程序的运行状况和性能瓶颈，而更为难得的是，ETW的性能还非常的高，据说可以达到 每秒写入20W条记录，而仅占用5%的CPU。&lt;/p&gt;
&lt;p&gt;Windows除了在系统内核及系统组件自带了大量事件日志，ETW还为开发者提供编程接口（在 System.Diagnostics.Eventing 命名空间下），允许开发人员在项目中实现自己的事件跟踪，或者像使用log4net一样，将系统自定义的日志记录到ETW里面。这点不在这里展开了，有兴趣的可以参考Artech的文章：&lt;a href=&quot;http://www.cnblogs.com/artech/p/logging-via-etw.html&quot; target=&quot;_blank&quot;&gt;如何利用ETW（Event Tracing for Windows）记录日志&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但话说回来，我曾经也尝试过在项目了使用ETW，但感觉在一般项目开发中，还是使用Log4net和nlog这些日志框架较为合适，毕竟一般来说业务系统的日志是给人看的，而ETW的日志数据是二进制形式保存的，更偏向于给日志消费者用的，肉眼在看起来并不那么方便，而且log4net/nlog更合适系统的业务场景的日志使用。ETW还是作为系统性能分析手段比较适合。关于这个可以&lt;a href=&quot;https://github.com/Microsoft/perfview/blob/master/documentation/TraceEvent/TraceEventProgrammersGuide.md&quot; target=&quot;_blank&quot;&gt;参考这里&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;ETW VS 性能监视器&lt;/h2&gt;
&lt;p&gt; 或者有人会问，Windows里已经提供了强大的性能监视器(Perfmon.exe)，和资源监视器(顺便说下，资源监视器也是基于ETW实现的。&lt;a href=&quot;https://blogs.msdn.microsoft.com/ntdebugging/2009/08/27/part-1-etw-introduction-and-overview/&quot; target=&quot;_blank&quot;&gt;参考这里&lt;/a&gt;)，为什么还需要ETW和其他基于它的工具？例如使用性能监视器，添加各种性能计数器，也可以将系统在运行时的方方面面的性能数据呈现出来，那ETW及PrefView还有什么存在意义？&lt;/p&gt;
&lt;p&gt;一个非常明显的理由就是，ETW的日志存储着非常详细的程序运行数据。利用PrefView等工具，你可以看到具体一个进程加载信息，线程的执行信息，函数的调用树，和执行时间，执行堆栈，CPU执行时间等等信息，而性能监视器只能提供各个性能指标的数据，但并不能具体地展示哪个程序引起了具体的性能问题。通常我们可以配合性能监视器和ETW相关工具的使用，可以全方位的了解系统的性能状况，并且可以直观地看到具体是那些函数导致了性能问题，达到知其然同时知其所以然的效果。&lt;/p&gt;
&lt;p&gt;第二个理由便是，ETW日志的速度比性能监视器要快，可以在生产环境中自由地获取运行数据而不影响服务器运行。但性能监视器也是即开即用，所以我觉得这点对我来说意义不太大。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://img2018.cnblogs.com/blog/43206/201811/43206-20181115174535431-329299855.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201811/43206-20181115174535431-329299855.png&quot; alt=&quot;&quot; width=&quot;628&quot; height=&quot;311&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/43206/201811/43206-20181115174845127-385541301.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201811/43206-20181115174845127-385541301.jpg&quot; alt=&quot;&quot; width=&quot;458&quot; height=&quot;312&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;.ETL文件&lt;/h2&gt;
&lt;p&gt;.etl文件是ETW的日志文件扩。当使用PrefView等工具捕获系统日志后，便会生成此类文件。使用PrefView等ETW的分析工具，可以对文件内的日志进行各种统计与分析操作。而如果只想单纯地看日志内容，可以使用Microsoft Message Analyzer打开文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/43206/201811/43206-20181115172451494-108882103.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43206/201811/43206-20181115172451494-108882103.png&quot; alt=&quot;点击可放大&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;参考资料：&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/oanapl/2009/08/04/etw-event-tracing-for-windows-what-it-is-and-useful-tools/&quot; target=&quot;_blank&quot;&gt; ETW (Event Tracing For Windows) – what it is and useful tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/ntdebugging/2009/08/27/part-1-etw-introduction-and-overview/&quot; target=&quot;_blank&quot;&gt;ETW Introduction and Overview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.itprotoday.com/windows-78/inside-event-tracing-windows&quot; target=&quot;_blank&quot;&gt;Inside Event Tracing for Windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/vancem/2012/07/09/introduction-tutorial-logging-etw-events-in-c-system-diagnostics-tracing-eventsource/&quot; target=&quot;_blank&quot;&gt;Logging ETW events in C#: System.Diagnostics.Tracing.EventSource&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.codeproject.com/articles/570690/application-analysis-with-event-tracing-for-window&quot; target=&quot;_blank&quot;&gt;Application Analysis with Event Tracing for Windows (ETW)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/artech/p/logging-via-etw.html&quot; target=&quot;_blank&quot;&gt;如何利用ETW（Event Tracing for Windows）记录日志&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Nov 2018 13:50:00 +0000</pubDate>
<dc:creator>wyman25</dc:creator>
<og:description>Event Trace for Windows ETW</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwhkdash/p/9949566.html</dc:identifier>
</item>
<item>
<title>我不熟悉的list - 姓岳的</title>
<link>http://www.cnblogs.com/love-jelly-pig/p/9991863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/love-jelly-pig/p/9991863.html</guid>
<description>&lt;p&gt;其实在日常中，链表的题目做的比较多，但是使用STL自带链表的还是比较少，所以里面的一些API不大熟悉。这边也简要介绍一些。&lt;/p&gt;

&lt;p&gt;先列举的这些和上面几篇用法几乎一样，所以不再累述。&lt;/p&gt;
&lt;h2 id=&quot;赋值相关&quot;&gt;赋值相关&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;list(beg,end);//构造函数将[beg, end)区间中的元素拷贝给本身。
list(n,elem);//构造函数将n个elem拷贝给本身。
list(const list &amp;amp;lst);//拷贝构造函数。
assign(beg, end);//将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);//将n个elem拷贝赋值给本身。
list&amp;amp; operator=(const list &amp;amp;lst);//重载等号操作符
swap(lst);//将lst与本身的元素互换&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;插入删除相关&quot;&gt;插入、删除相关&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;push_back(elem);//在容器尾部加入一个元素
pop_back();//删除容器中最后一个元素
push_front(elem);//在容器开头插入一个元素
pop_front();//从容器开头移除第一个元素
insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。
clear();//移除容器的所有数据
erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);//删除pos位置的数据，返回下一个数据的位置。
remove(elem);//删除容器中所有与elem值匹配的元素。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;list提供了可以从头部或尾部直接加入元素，也可以在头部或尾部直接删除元素。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把remove函数拿出来讲一下，如何删除自定义数据。如果我们的数据是内置类型，那很好删除，找到该elem，用 == 比较，为真就表示找到了，进行删除。而自定义数据用 == 是不能直接比较的，我们应该先重载==，再进行删除。&lt;strong&gt;我们重载的时候，要注意，传入的参数都必须是const类型，否则编译不会通过，因为编译器发觉我们会有改变数据的风险，导致比较结果出错！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;大小操作&quot;&gt;大小操作&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;size();//返回容器中元素的个数
empty();//判断容器是否为空
resize(num);//重新指定容器的长度为num，
若容器变长，则以默认值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。
resize(num, elem);//重新指定容器的长度为num，
若容器变长，则以elem值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这边的size函数有个特殊点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GCC下时间复杂度为O(n).&lt;/li&gt;
&lt;li&gt;VC下时间复杂度为O(1).&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;在GCC下，size函数的复杂度为O(n),它是通过调用标准库的distance(begin(),end())算法来计算长度的。而在VC类的编译器下，维护了一个成员变量_Mysize，保存长度。就可以直接查出来，时间复杂度为O(1).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这其实是一种取舍，要先讲一下list::splice函数，这是让两个不同的链表进行拼接的函数。GCC为了维护这个函数，使拼接后长度更容易计算，因此没有给一个成员变量来保存大小，如果给了，那拼接后的长度是两个size相加吗？不一定，因为splice拼接方法有多种。所以没有给出。&lt;/p&gt;
&lt;h2 id=&quot;存取操作&quot;&gt;存取操作&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;front();//返回第一个元素。
back();//返回最后一个元素。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意是直接返回元素。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们用一段代码来证明它是一个双向循环链表：从头结点遍历2倍的长度单位，看是否会循环再打印一次。&lt;/p&gt;
&lt;p&gt;先说一下几个类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//链表结点类型
list&amp;lt;int&amp;gt;::_Nodeptr node;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而结点类有三个成员：下一节点指针，上一节点指针，数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node-&amp;gt;_Next;
node-&amp;gt;_Prev;
node-&amp;gt;_Myval;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int main(){

    list&amp;lt;int&amp;gt; myList;
    for (int i = 0; i &amp;lt; 10; i ++){
        myList.push_back(i);
    }

    list&amp;lt;int&amp;gt;::_Nodeptr node =  myList._Myhead-&amp;gt;_Next;

    for (int i = 0; i &amp;lt; myList._Mysize * 2;i++){
        cout &amp;lt;&amp;lt; &quot;Node:&quot; &amp;lt;&amp;lt; node-&amp;gt;_Myval &amp;lt;&amp;lt; endl;
        node = node-&amp;gt;_Next;
        if (node == myList._Myhead){
            node = node-&amp;gt;_Next;
        }
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们用一个for循环，将数据存进去。&lt;br/&gt;然后我们用一个节点指向头结点的的下一节点。&lt;strong&gt;list的头结点_Myhead是不存任何东西的，只是为了插入方便而已，所以这么整。所以我们要指向第一个有数据的节点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们遍历一次链表长度时，到达尾节点时，若是循环链表，则会再回到头部，看一下执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/037DBF2162A640F695C636306D388F56?method=download&amp;amp;shareKey=bbaabe3075645d427a487dbb5668d8f1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以清楚的看到，我循环了2倍长度，它遍历了两次。所以，list是一个循环链表。&lt;/p&gt;

&lt;h2 id=&quot;reverse和sort函数&quot;&gt;reverse和sort函数&lt;/h2&gt;
&lt;p&gt;reverse函数就是反转函数，较为简单，没什么特殊的。sort函数排序也是一样，默认从小到大排序。&lt;/p&gt;
&lt;p&gt;而我们可以是指定排序顺序的。有两种方法，一种是回调函数的方法，另一种是仿函数的方法。&lt;/p&gt;
&lt;p&gt;现在假设我们有一个链表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list&amp;lt;int&amp;gt; myList;
for (int i = 0; i &amp;lt; 5; i++){
    myList.push_back(i);
}
list.sort();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们执行完sort的结果，会是从小到大排序的链表。也就是说，当sort的参数为空时，会执行默认的排序，&lt;strong&gt;那现在我们就给它传递一个参数，改变排序规则。&lt;/strong&gt;&lt;br/&gt;现在就来介绍上述的两种方法。&lt;/p&gt;
&lt;h3 id=&quot;回调函数方法&quot;&gt;回调函数方法&lt;/h3&gt;
&lt;p&gt;先写出这个回调函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool mycmp(int a, int b)
{
    return a &amp;gt; b;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;返回值：bool。&lt;/li&gt;
&lt;li&gt;参数：int型(取决于你的链表存放的数据类型)。&lt;/li&gt;
&lt;li&gt;排序规则：从大到小，所以return a &amp;gt; b;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们针对整型进行大到小的排序，所以，我们要返回a &amp;gt; b即可。&lt;/p&gt;
&lt;p&gt;随后，我们再程序中执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mylist.sort(mycmp);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就行了，就可以从大到小排序了。&lt;/p&gt;
&lt;h3 id=&quot;仿函数方法&quot;&gt;仿函数方法&lt;/h3&gt;
&lt;p&gt;记住仿函数不是一个函数，是一个类。它通过重载()来生效。因为底层中使用了大量的cmp(a,b)这种形式来比较a和b的大小。来看一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyCmp
{
public:
    bool operator()(int a, int b)
    {
        return a &amp;gt; b;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的，仿函数里面重载()：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;返回值：bool。&lt;/li&gt;
&lt;li&gt;参数：int型(取决于你的链表存放的数据类型)。&lt;/li&gt;
&lt;li&gt;排序规则：从大到小，所以return a &amp;gt; b;&lt;br/&gt;可以看到，和回调函数的规则几乎一样。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用形式为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mylist.sort(MyCmp());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么多了一对小括号呢？我们需要传入的是一个对象，而回调函数传进去就直接是一个函数对象，仿函数是一个类，我们加一对括号生成一个匿名对象，从而传递正确的参数。&lt;/p&gt;
&lt;p&gt;下面看一个reverse和sort的使用例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int main()
{
    list&amp;lt;int&amp;gt; myList;
    for (int i = 0; i &amp;lt; 5; i++){
        myList.push_back(i);
    }

    //反转
    myList.reverse();
    list&amp;lt;int&amp;gt;::_Nodeptr node = myList._Myhead-&amp;gt;_Next;
    cout &amp;lt;&amp;lt; &quot;反转之后：&quot; &amp;lt;&amp;lt; endl;
    for (size_t i = 0; i &amp;lt; myList._Mysize; ++i)
    {
        cout &amp;lt;&amp;lt; node-&amp;gt;_Myval &amp;lt;&amp;lt; &quot; &quot;;
        node = node-&amp;gt;_Next;
    }

    //再排序(从小到大)
    myList.sort();
    node = myList._Myhead-&amp;gt;_Next;
    cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &quot;默认排序：&quot; &amp;lt;&amp;lt; endl;
    for (size_t i = 0; i &amp;lt; myList._Mysize; ++i)
    {
        cout &amp;lt;&amp;lt; node-&amp;gt;_Myval &amp;lt;&amp;lt; &quot; &quot;;
        node = node-&amp;gt;_Next;
    }
    //再排序(从大到小)
    //myList.sort(mycmp);   //使用回调函数方法，传入一个函数对象
    myList.sort(MyCmp());   //使用仿函数方法，传入一个匿名对象
    node = myList._Myhead-&amp;gt;_Next;
    cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &quot;从大到小排序：&quot; &amp;lt;&amp;lt; endl;
    for (size_t i = 0; i &amp;lt; myList._Mysize; ++i)
    {
        cout &amp;lt;&amp;lt; node-&amp;gt;_Myval &amp;lt;&amp;lt; &quot; &quot;;
        node = node-&amp;gt;_Next;
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/1952131A1F304744BB94EC8999102BF0?method=download&amp;amp;shareKey=49107c32e5b86ba4b2b993cc8bb947ae&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么不用标准库算法sort呢&quot;&gt;为什么不用标准库算法sort呢？&lt;/h2&gt;
&lt;p&gt;如果用系统提供的sort，那么参数就为迭代器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sort(mylist.begin(),mylist.end());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但实际上不能完成的。因为系统提供的sort函数对迭代器有要求：&lt;strong&gt;必须是可以随机访问的迭代器！&lt;/strong&gt; 而list容器不提供随机访问的能力，所以不能使用。但是往往这类东西都会自己实现一个sort，所以不用担心。&lt;/p&gt;
&lt;h2 id=&quot;一些复杂需求排序&quot;&gt;一些复杂需求排序&lt;/h2&gt;
&lt;p&gt;讲完刚刚指定排序规则的排序，现在我们可以有更复杂的排序需求了：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;若干学生，优先按照成绩大到小排序，成绩相同按照年龄小到大排序，年龄相同按照姓名升序排序，姓名相同按照班级降序排序。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这就是个不断比较的过程而已，没什么特殊的地方，回调函数如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool ComplicatedCmp(Stu &amp;amp;stu1, Stu &amp;amp;stu2)
{
    if (stu1._iScore == stu2._iScore)
    {
        if (stu1._iAge == stu2._iAge)
        {
            if (stu1._strName == stu2._strName)
            {
                return stu1._iClass &amp;gt; stu2._iClass;
            }
            else
            {
                return stu1._strName &amp;lt; stu2._strName;
            }
        }
        else
        {
            return stu1._iAge &amp;lt; stu2._iAge;
        }
    }
    else
    {
        return stu1._iScore &amp;gt; stu2._iScore;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int main()
{
    list&amp;lt;Stu&amp;gt; mylist;
    mylist.push_back(Stu(&quot;Tom&quot;, 4, 90, 13));
    mylist.push_back(Stu(&quot;Jerry&quot;, 5, 84, 11));
    mylist.push_back(Stu(&quot;Giao&quot;, 1, 99, 10));
    mylist.push_back(Stu(&quot;Fuck&quot;, 6, 35, 15));
    mylist.push_back(Stu(&quot;Bill&quot;, 2, 96, 17));
    mylist.push_back(Stu(&quot;Null&quot;, 2, 96, 16));
    mylist.push_back(Stu(&quot;Null&quot;, 0, 96, 17));
    mylist.sort(ComplicatedCmp);
    for (auto it = mylist.begin(); it != mylist.end(); ++it)
    {
        cout &amp;lt;&amp;lt; &quot;Score:&quot; &amp;lt;&amp;lt; it-&amp;gt;_iScore &amp;lt;&amp;lt; &quot;  Age:&quot; &amp;lt;&amp;lt; it-&amp;gt;_iAge &amp;lt;&amp;lt; &quot;  Name:&quot; &amp;lt;&amp;lt; it-&amp;gt;_strName &amp;lt;&amp;lt; &quot;  Class:&quot; &amp;lt;&amp;lt; it-&amp;gt;_iClass &amp;lt;&amp;lt; endl;
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/D89CF0A2E46E444FB7EF0DACDDA15C97?method=download&amp;amp;shareKey=793421de0babb71616632f5be4602f08&quot;/&gt;&lt;/p&gt;
&lt;p&gt;已经按照我们想要的排序进行排序了。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Nov 2018 13:45:00 +0000</pubDate>
<dc:creator>姓岳的</dc:creator>
<og:description>其实在日常中，链表的题目做的比较多，但是使用STL自带链表的还是比较少，所以里面的一些API不大熟悉。这边也简要介绍一些。 基本的一些API 先列举的这些和上面几篇用法几乎一样，所以不再累述。 赋值相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/love-jelly-pig/p/9991863.html</dc:identifier>
</item>
<item>
<title>学习Linux下的文件目录管理 - 蒙山一只鸽</title>
<link>http://www.cnblogs.com/SAM-CJM/p/9983774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SAM-CJM/p/9983774.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;                文件目录管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一.认识Linux文件系统的架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 在Linux中是没有盘符这个概念的，即Linux中没有C盘和D盘的分盘。那么我们直接通过对目录的操作实现对磁盘的读写，因为已经建立的文件系统分区被挂载到一个目录下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 我们可以注意到&lt;span&gt;&lt;strong&gt;Linux表示目录是使用&quot;/&quot;&lt;/strong&gt;&lt;/span&gt;而不是像Windows那样的&quot;\&quot;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么我们列出Linux文件系统中主要的目录并了解她们的含义：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在我的阿里云上在/目录下输入&lt;span&gt;&lt;strong&gt;ls&lt;/strong&gt;&lt;/span&gt;命令得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181119153317901-76193366.png&quot; alt=&quot;&quot; width=&quot;569&quot; height=&quot;145&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/bin    构建最小的系统所需要的命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/boot  内核和启动文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/dev   各种设备文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/etc    系统软件的启动和配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/home   用户的主目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/lib      C编译器的库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/media   可移动介质的安装点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/proc      进程的映像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/root      超级用户root的主目录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/sbin     和系统操作有关的命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/tmp      临时文件存放点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/usr       非系统的程序和命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/var       系统专用的数据和配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.创建一个工作组和共享文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然在团队开发中我们可以使用git和远程版本控制库但是我们创建一个共享的文件在本地开发时是有极大帮助的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们要知道怎么去创建一个新的用户：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下部分转载来自&lt;a href=&quot;https://www.cnblogs.com/clicli/&quot; target=&quot;_blank&quot;&gt;@信则成  &lt;/a&gt; 我对内容进行了图片填充和代码实验，原文地址：h&lt;a title=&quot;linux 新建用户、用户组 以及为新用户分配权限&quot; href=&quot;https://www.cnblogs.com/clicli/p/5943788.html&quot; target=&quot;_blank&quot;&gt;ttps://www.cnblogs.com/clicli/p/5943788.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;1、添加新的用户账号使用 useradd命令，其语法如下：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;useradd 选项 用户名&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其中各选项含义如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-c&lt;/span&gt;&lt;/strong&gt; comment 指定一段注释性描述。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-d&lt;/span&gt;&lt;/strong&gt; 目录 指定用户主目录，&lt;strong&gt;如果此目录不存在，则同时使用-m选项，可以创建主目录&lt;/strong&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-g&lt;/span&gt;&lt;/strong&gt; 用户组 指定用户所属的用户组。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-G&lt;/span&gt;&lt;/strong&gt; 用户组，用户组 指定用户所属的附加组。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-s&lt;/span&gt;&lt;/strong&gt; Shell文件 指定用户的登录Shell。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-u&lt;/span&gt;&lt;/strong&gt; 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;用户名 指定新账号的登录名。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;例1：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;# useradd –d /usr/sam -m sam&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;此命令创建了一个用户&lt;strong&gt;sam&lt;/strong&gt;，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其中-d和-m选项用来&lt;strong&gt;为登录名sam产生一个主目录/usr/sam&lt;/strong&gt;（/usr为默认的用户主目录所在的父目录）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在我们去输入这条命令之前，我们先进入user文件夹下查看所有的文件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181119203917319-849307081.png&quot; alt=&quot;&quot; width=&quot;625&quot; height=&quot;133&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入命令后查看usr文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181119204303813-1643021048.png&quot; alt=&quot;&quot;/&gt;在usr文件夹下就出现了一个新的文件夹名叫cjm和我们的用户名相同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么下载cjm这个用户的主目录就是在usr文件夹下的cjm文件夹&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;例2：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;# useradd -s /bin/sh -g group –G adm,root gem&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;此命令&lt;strong&gt;新建了一个用户gem&lt;/strong&gt;，&lt;strong&gt;该用户的登录Shell是/bin/sh&lt;/strong&gt;，&lt;strong&gt;它属于group用户组，同时又属于adm和root用户组（附加组）&lt;/strong&gt;，其中group用户组是其主组。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这里可能新建组：#groupadd group及groupadd adm　&lt;/span&gt;&lt;br/&gt;&lt;span&gt;增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们直接输入这一条命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181119205204094-1532733958.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他会报出这样的错误提示你group工作组不存在，那么我们首先来创建一个工作组group（root是已经存在的超级用户不用添加，adm也是存在的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181119205652671-1412155989.png&quot; alt=&quot;&quot;/&gt;添加用户组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后在输入添加用户语句，就没有问题了。&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;2、删除帐号&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;如果一个用户的账号不再使用，可以从系统中删除。&lt;span&gt;&lt;strong&gt;删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录&lt;/strong&gt;&lt;/span&gt;。删除一个已有的用户账号使用&lt;strong&gt;&lt;span&gt;userdel&lt;/span&gt;&lt;/strong&gt;命令，其格式如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;userdel 选项 用户名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;常用的选项是&lt;span&gt;&lt;strong&gt;-r&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;它的作用是把用户的主目录一起删除&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# userdel sam&lt;/span&gt;&lt;br/&gt;&lt;span&gt;此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181119210643769-1795063847.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们删除我们刚刚创建的cjm用户，并且去usr目录下发现我们创建的用户主目录已经删除&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;3、修改帐号&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;修改已有用户的信息使用&lt;strong&gt;&lt;span&gt;usermod&lt;/span&gt;&lt;/strong&gt;命令，其格式如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;usermod 选项 用户名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;常用的选项包括&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-c&lt;/span&gt;&lt;/strong&gt; comment 指定一段注释性描述。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-d&lt;/span&gt;&lt;/strong&gt; 目录 指定用户主目录，&lt;strong&gt;如果此目录不存在，则同时使用-m选项，可以创建主目录&lt;/strong&gt;。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-g&lt;/span&gt;&lt;/strong&gt; 用户组 指定用户所属的用户组。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-G&lt;/span&gt;&lt;/strong&gt; 用户组，用户组 指定用户所属的附加组。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-s&lt;/span&gt;&lt;/strong&gt; Shell文件 指定用户的登录Shell。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-u&lt;/span&gt;&lt;/strong&gt; 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。另外，有些系统可以使用如下选项：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-l&lt;/span&gt;&lt;/strong&gt; 新用户名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这个选项指定一个新的账号，即将原来的用户名改为新的用户名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先创建一个用户名为cjm，主目录在usr文件夹下的cjm文件夹，shell登录在bin目录下的sh，然后我们将shell改为在bin目录下的ksh，将主目录改为usr下的cjm1，名字也改为cjm1　　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建：　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181119213414978-1011074693.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更改后去查看文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181119213722856-745647084.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不难发现这个cjm文件夹已经更改cjm1&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;4、用户口令的管理&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;用户管理的一项重要内容是用户口令的管理。&lt;span&gt;&lt;strong&gt;用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;指定和修改用户口令的Shell命令是&lt;strong&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;/strong&gt;。&lt;span&gt;&lt;strong&gt;超级用户可以为自己和其他用户指定口令&lt;/strong&gt;，&lt;strong&gt;普通用户只能用它修改自己的口令&lt;/strong&gt;&lt;/span&gt;。命令的格式为：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;passwd 选项 用户名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;可使用的选项：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;-l&lt;/strong&gt;&lt;/span&gt; 锁定口令，即禁用账号。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-u&lt;/span&gt;&lt;/strong&gt; 口令解锁。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;-d&lt;/strong&gt;&lt;/span&gt; 使账号无口令，删除密码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;-f&lt;/span&gt;&lt;/strong&gt; 强迫用户下次登录时修改口令。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果默认用户名，则修改当前用户的口令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是超级用户，可以用下列形式指定&lt;span&gt;&lt;strong&gt;任何用户&lt;/strong&gt;&lt;/span&gt;的口令：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;# passwd sam&lt;/strong&gt;&lt;/span&gt; （注意开头提示符号为井号）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;New password:*******&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Re-enter new password:*******&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181119215753255-82104443.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在我就已经给我的cjm1用户创建了一个密码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们登录cjm1用户：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120143610786-19338392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，假设当前用户是cjm1，则下面的命令修改该用户自己的口令：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$ &lt;strong&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;/strong&gt;（注意开头提示符为美元符号，表示非超级用户）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Old password:******&lt;/span&gt;&lt;br/&gt;&lt;span&gt;New password:*******&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Re-enter new password:*******&lt;/span&gt;&lt;br/&gt;&lt;span&gt;普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;操作截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120144221086-1872153158.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;span&gt;为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;为用户指定空口令时，执行下列形式的命令：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;# passwd -d sam&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;此命令将用户sam的密码删除，但是下一次登录还是会询问密码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120144446646-140299785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们再去登录cjm1这个用户，是登录不进去的，即使密码为空。&lt;br/&gt;&lt;span&gt;passwd命令还可以用&lt;strong&gt;&lt;span&gt;-l(lock)&lt;/span&gt;&lt;/strong&gt;选项锁定某一用户，&lt;span&gt;&lt;strong&gt;使其不能登录&lt;/strong&gt;&lt;/span&gt;，例如：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;# passwd -l sam&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120150304077-2064883575.png&quot; alt=&quot;&quot;/&gt;修改后再去登录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120150428737-1527781744.png&quot; alt=&quot;&quot;/&gt;是登陆不上的&lt;br/&gt;&lt;span&gt;新建用户异常：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;useradd -d /usr/hadoop -u 586 -m hadoop -g hadoop&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1 Creating mailbox file: 文件已存在&lt;/span&gt;&lt;br/&gt;&lt;span&gt;删除即可 rm -rf /var/spool/mail/用户名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2 useradd: invalid numeric argument 'hadoop'&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这是由于hadoop组不存在 请先建hadoop组&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;通过cat /etc/passwd 可以查看用户的pass&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;cat /etc/shadow 可以查看用户名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;cat /etc/group 可以查看 组&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三.下面是去创建一个用户组&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。&lt;br/&gt;用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;&lt;span&gt;增加一个新的用户组使用&lt;/span&gt;&lt;span&gt;groupadd&lt;/span&gt;&lt;/strong&gt;命令。 其格式如下：&lt;/p&gt;
&lt;p&gt;代码:&lt;br/&gt;&lt;span&gt;&lt;strong&gt;groupadd 选项 用户组&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以使用的选项有：&lt;br/&gt;代码:&lt;br/&gt;&lt;strong&gt;&lt;span&gt;-g&lt;/span&gt;&lt;/strong&gt; GID 指定新用户组的组标识号（GID）。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;-o&lt;/span&gt;&lt;/strong&gt; 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。&lt;/p&gt;
&lt;p&gt;例1：&lt;/p&gt;
&lt;p&gt;代码:&lt;br/&gt;# groupadd group1&lt;/p&gt;
&lt;p&gt;此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。&lt;/p&gt;
&lt;p&gt;例2：&lt;/p&gt;
&lt;p&gt;代码:&lt;br/&gt;#groupadd -g 101 group2&lt;/p&gt;
&lt;p&gt;此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;&lt;span&gt;如果要删除一个已有的用户组&lt;/span&gt;&lt;/strong&gt;，使用&lt;strong&gt;&lt;span&gt;groupdel&lt;/span&gt;&lt;/strong&gt;命令， 其格式如下：&lt;/p&gt;
&lt;p&gt;代码:&lt;br/&gt;&lt;strong&gt;&lt;span&gt;groupdel 用户组&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;代码:&lt;br/&gt;#groupdel group1&lt;/p&gt;
&lt;p&gt;此命令从系统中删除组group1。&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;&lt;span&gt;修改用户组的属性使用&lt;/span&gt;&lt;span&gt;groupmod&lt;/span&gt;&lt;/strong&gt;命令。 其语法如下：&lt;/p&gt;
&lt;p&gt;代码:&lt;br/&gt;&lt;span&gt;&lt;strong&gt;groupmod 选项 用户组&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;常用的选项有：&lt;br/&gt;代码:&lt;br/&gt;&lt;strong&gt;&lt;span&gt;-g&lt;/span&gt;&lt;/strong&gt; GID 为用户组指定新的组标识号。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;-o&lt;/span&gt;&lt;/strong&gt; 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;-n&lt;/span&gt;&lt;/strong&gt;新用户组 将用户组的名字改为新名字&lt;/p&gt;
&lt;p&gt;例1：&lt;/p&gt;
&lt;p&gt;代码:&lt;br/&gt;# groupmod -g 102 group2&lt;/p&gt;
&lt;p&gt;此命令将组group2的组标识号修改为102。&lt;/p&gt;
&lt;p&gt;例2：&lt;/p&gt;
&lt;p&gt;代码:&lt;br/&gt;# groupmod –g 10000 -n group3 group2&lt;/p&gt;
&lt;p&gt;此命令将组group2的标识号改为10000，组名修改为group3。&lt;/p&gt;
&lt;p&gt;4、如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令&lt;strong&gt;&lt;span&gt;newgrp&lt;/span&gt;&lt;/strong&gt;切换到其他用户组，&lt;strong&gt;&lt;span&gt;这个命令的参数就是目的用户组&lt;/span&gt;&lt;/strong&gt;。 例如：&lt;/p&gt;
&lt;p&gt;代码:&lt;br/&gt;$ &lt;span&gt;newgrp root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。&lt;/strong&gt;&lt;/span&gt;类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四.创建一个文件夹和目录&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用命令&lt;span&gt;&lt;strong&gt;mkdir&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;创建一个或多个文件夹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;创建一个cjmuser文件夹在根目录下：&lt;span&gt;&lt;strong&gt;mkdir 文件夹名&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120151357089-312586929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一次创建两个文件夹cjmuser1、cjmuser2 ：&lt;strong&gt;&lt;span&gt;mkdir 文件夹1  文件夹2&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120151649826-1204379166.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在指定目录etc下面创建文件夹cjmuser3  ：&lt;strong&gt;&lt;span&gt;mkdir  /.../.../文件名&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120152415140-1574438580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;span&gt;&lt;strong&gt;mkdir&lt;/strong&gt;&lt;/span&gt;命令可以创建文件夹但是创建文件就需要使用&lt;strong&gt;&lt;span&gt;touch&lt;/span&gt;&lt;/strong&gt;命令&lt;/p&gt;
&lt;p&gt;在根目录下的test文件夹下创建一个hello.txt文件，并使用vim去修改他：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120153649800-904148374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在vim下我们首先进入输入模式，输入hello然后进入可视模式进行复制和粘贴。最后使用cat来查看我们的hello.txt得到hello文件的内容。&lt;/p&gt;
&lt;p&gt;使用&lt;span&gt;&lt;strong&gt;mv&lt;/strong&gt;&lt;/span&gt;移动文件夹，&lt;strong&gt;&lt;span&gt;mv 文件名 指定路&lt;/span&gt;&lt;span&gt;径&lt;/span&gt;&lt;/strong&gt; 我们将根目录下test文件夹下的hello文件移动到的根目录下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120160836834-777159397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里有一个非常重要的地方，就是说如果你的目标文件夹下有一个同名的文件，&lt;strong&gt;&lt;span&gt;那么他会询问你是否覆盖文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先在根目录下的test文件夹中创建一个空的hello.txt文件，然后移动到到我们刚才已经有了两个hello字符串的hello.txt文件的根目录下。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120163210222-1171656118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不同意覆盖就会创建一个名字相同但是在后面会有一个 ~号的文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120165832072-1526487481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;&lt;span&gt;cp&lt;/span&gt;&lt;/strong&gt;命令符复制文件和目录  &lt;strong&gt;&lt;span&gt;cp  文件名   指定复制到的路径&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们又将根目录下的hello.txx文件复制到test文件夹下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120164552829-237593817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;span&gt;&lt;strong&gt;rmdir&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;rm&lt;/strong&gt;&lt;/span&gt;删除文件和目录&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;rmdir&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;rm&lt;/strong&gt;&lt;/span&gt;的区别就是&lt;strong&gt;&lt;span&gt;rmdir&lt;/span&gt;&lt;/strong&gt;只能删除空文件夹，但是&lt;strong&gt;&lt;span&gt;rm&lt;/span&gt;&lt;/strong&gt;可以删除含有文件的文件夹。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120165253489-1781174174.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;rmdir&lt;/span&gt;&lt;/strong&gt;无法删除这个非空文件夹&lt;/p&gt;
&lt;p&gt;但是rm就可以。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120165931795-677776702.png&quot; alt=&quot;&quot; width=&quot;386&quot; height=&quot;20&quot;/&gt;，参数 &lt;span&gt;&lt;strong&gt;-rf&lt;/strong&gt;&lt;/span&gt; 就是表示扫描文件夹下的全部子目录并且强制删除不做任何的提示&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五.linux的文件权限&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.查看权限&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个用户去创建一个文件或者文件夹时，那么他就是这个文件或者文件夹的属主，那么和属主在一个group中的就是属组，除去这两个就是其他人了。&lt;/p&gt;
&lt;p&gt;对于一个文件来讲就是有三个权限可读（r）可写（w）可执行（x），那么我们来查看一个文件的三个权限通过&lt;span&gt;&lt;strong&gt;ls -l命令&lt;/strong&gt;&lt;/span&gt;查看详细信息来查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120200022915-162614115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一列是 - 表明他是一个普通文件&lt;/p&gt;
&lt;p&gt;我们可以看到这个hello.txt文件的详细信息的第二列，这一列就表明了这个文件的权限我们这么去读他：&lt;/p&gt;
&lt;p&gt;rw- （属主权限） r--（属组权限） r--（其他人权限）&lt;/p&gt;
&lt;p&gt;属主可以去读和写但是不能运行，txt文件当然不能运行。然后就是其他两个都是只能去读，所有被隔绝的权限都用 &lt;span&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/span&gt; 给代替了&lt;/p&gt;
&lt;p&gt;数字 1 代表着他有多少个文件&lt;span&gt;&lt;strong&gt;硬&lt;/strong&gt;&lt;/span&gt;链接数&lt;/p&gt;
&lt;p&gt;然后我们可以看到两个root表明了他的属主和属组，0代表为文件大小（字节），后面是上一次修改的时间&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.改变权限&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.使用&lt;span&gt;&lt;strong&gt;chown&lt;/strong&gt;&lt;/span&gt;改变文件的所有权 ，&lt;strong&gt;&lt;span&gt;chown  新的属主：新的属组 文件名&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 我们将hello.txt文件改为cjm1用户和group属组，如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120202150884-1896767602.png&quot; alt=&quot;&quot;/&gt;修改成功。&lt;/p&gt;
&lt;p&gt;当然你也可以省略：group只修改属主，但是你想要只修改属组就必须保留：或者你直接使用&lt;strong&gt;&lt;span&gt;chgrp&lt;/span&gt;&lt;/strong&gt;来修改属组 &lt;strong&gt;&lt;span&gt;chgrp  组名  文件名&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.使用&lt;span&gt;&lt;strong&gt;chmod&lt;/strong&gt;&lt;/span&gt;修改文件读写执行权限 &lt;span&gt;&lt;strong&gt;chmod 用户组+/-权限  &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用户组有   &lt;span&gt;&lt;strong&gt;u&lt;/strong&gt;&lt;/span&gt;文件属主     &lt;strong&gt;&lt;span&gt;g&lt;/span&gt;&lt;/strong&gt;文件属组      &lt;span&gt;&lt;strong&gt;a&lt;/strong&gt;&lt;/span&gt;其他人&lt;/p&gt;
&lt;p&gt;权限有      &lt;strong&gt;&lt;span&gt;r&lt;/span&gt;&lt;/strong&gt;写入             &lt;span&gt;&lt;strong&gt;w&lt;/strong&gt;&lt;/span&gt;写入           &lt;span&gt;&lt;strong&gt;x&lt;/strong&gt;&lt;/span&gt;执行&lt;/p&gt;
&lt;p&gt;我们对hello.txt这个文件来做一次修改，现在他的权限如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120210202046-1377223594.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们现在让他对属组和其他人都是可写入的，那么我们就要使用+来添加权限（-是减少权限）操作如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120210433019-1381193157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 发现现在hello这个文本文件对所有人都是可写可读的。&lt;/p&gt;
&lt;p&gt; 处理&lt;strong&gt;&lt;span&gt;+/-&lt;/span&gt;&lt;/strong&gt;还有&lt;span&gt;&lt;strong&gt;= &lt;/strong&gt;&lt;/span&gt; &lt;strong&gt;&lt;span&gt;用户1=用户2&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;那么&lt;strong&gt;用户1的权限就和用户2相同&lt;/strong&gt;了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;六.文件类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 除了在上面看到的 &lt;strong&gt;&lt;span&gt;-&lt;/span&gt;&lt;/strong&gt; 表示的&lt;span&gt;&lt;strong&gt;普通文件&lt;/strong&gt;&lt;/span&gt;以外，Linux还有以下几种:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; d  目录      s  本地套接口    c  字符设备文件     b   块设备文件    l   符号链接    p   有名管道&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;七.建立链接&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;链接分两种一种是软连接一种是硬连接&lt;/p&gt;
&lt;p&gt;软连接就是相当于取了一个别名当你删除这个别名时是没有任何影响的。软连接使用&lt;strong&gt;&lt;span&gt;ln -s  文件名 引用名&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我问对hello文件建立起一个软链接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201811/1433995-20181120213932555-1797607242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们现在打开hello和helloln是一样的效果&lt;/p&gt;
&lt;p&gt;硬链接直接使用&lt;span&gt;&lt;strong&gt;ln&lt;/strong&gt;&lt;/span&gt;命令没有参数，那么你去修改两个文件中的任何一个另外一个都会去改变。&lt;/p&gt;

</description>
<pubDate>Tue, 20 Nov 2018 13:45:00 +0000</pubDate>
<dc:creator>蒙山一只鸽</dc:creator>
<og:description>文件目录管理 一.认识Linux文件系统的架构 在Linux中是没有盘符这个概念的，即Linux中没有C盘和D盘的分盘。那么我们直接通过对目录的操作实现对磁盘的读写，因为已经建立的文件系统分区被挂载到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SAM-CJM/p/9983774.html</dc:identifier>
</item>
<item>
<title>Qt的内存管理机制 - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/9991845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/9991845.html</guid>
<description>&lt;p&gt;当我们在使用Qt时不可避免得需要接触到内存的分配和使用，即使是在使用Python，Golang这种带有自动垃圾回收器（GC）的语言时我们仍然需要对Qt的内存管理机制有所了解，以更加清楚的认识Qt对象的生命周期并在适当的时机加以控制或者避免进入陷阱。&lt;/p&gt;
&lt;p&gt;这篇文章里我们将学习QObject &amp;amp; parent对象管理机制，以及QWidget与内存管理这两点Qt的基础知识。&lt;/p&gt;

&lt;p&gt;在Qt中，我们可以大致把对象分为两类，一类是&lt;code&gt;QObject&lt;/code&gt;和它的派生类；另一类则是普通的C++类。&lt;/p&gt;
&lt;p&gt;对于第二种对象，它的生命周期与管理和普通的C++类基本没有区别，而&lt;code&gt;QObject&lt;/code&gt;和它的派生类则有以下的显著区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;QObject&lt;/code&gt;和其派生类可以使用SIGNAL/SLOT机制&lt;/li&gt;
&lt;li&gt;它们一般会有一个&lt;code&gt;parent&lt;/code&gt;父对象的指针，用于内存管理（后面重点说明）&lt;/li&gt;
&lt;li&gt;对于&lt;code&gt;QWidget&lt;/code&gt;和其派生类来说，内存管理要稍微复杂一些，因为&lt;code&gt;QWidget&lt;/code&gt;需要和eventloop高度配合才能工作（后面也会重点说明）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;signal和slot一般来说并不会对内存管理产生影响，但是对&lt;code&gt;close()&lt;/code&gt;槽的处理会对&lt;code&gt;QWidget&lt;/code&gt;产生一些影响，所以我们放在后面讲解。&lt;/p&gt;
&lt;p&gt;那么先来看一下QObject和parent机制。&lt;/p&gt;
&lt;h2 id=&quot;qobject的parent&quot;&gt;QObject的parent&lt;/h2&gt;
&lt;p&gt;我们时常能看到QWidget或者其他的控件的构造函数中有一项参数&lt;code&gt;parent&lt;/code&gt;，默认值都为NULL，例如：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;QLineEdit(const QString &amp;amp;contents, QWidget *parent = nullptr);
QWidget(QWidget *parent = nullptr, Qt::WindowFlags f = ...);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;parent&lt;/code&gt;的作用就在于使当前的对象实例加入parent指定的QObject及其派生类的children中，当一个QObject被delete或者调用了它的析构函数时，所有加入的children也会全部被析构。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;parent&lt;/code&gt;设置为NULL，会有如下的情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是构造时直接指定了NULL，那么当前实例不会有父对象存在，Qt也不能自动析构该实例除非实例超出作用域导致析构函数被调用，或者用户在恰当的实际使用&lt;code&gt;delete&lt;/code&gt;操作符或者使用&lt;code&gt;deleteLater&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;如果已经指定了非NULL的&lt;code&gt;parent&lt;/code&gt;，这时将它设置成了NULL，那么当前实例会从父对象的children中删除，不再受到QObject &amp;amp; parent机制的影响；&lt;/li&gt;
&lt;li&gt;对于&lt;code&gt;QWidget&lt;/code&gt;，&lt;code&gt;parent&lt;/code&gt;为NULL时代表其为一个顶层窗口，也可以就是独立于其他widget在系统任务栏单独出现的widget，对于永远都是顶层窗口的widget，例如&lt;code&gt;QDialog&lt;/code&gt;，当&lt;code&gt;parent&lt;/code&gt;不为NULL时他会显示在父widget中心区域的上层；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;QWidget&lt;/code&gt;的&lt;code&gt;parent&lt;/code&gt;为NULL或是其他值，在其加入布局管理器或者&lt;code&gt;QMainWindow&lt;/code&gt;设置widget时，会自动将&lt;code&gt;parent&lt;/code&gt;设置为相应的父widget，在父控件销毁时这些子控件以及布局管理器对象会一并销毁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以我们可以看出，QObject对象实际上拥有一颗类实例关系树，在树中保存了所有通过指定&lt;code&gt;parent&lt;/code&gt;注册的子对象，而子对象里又保存有其子对象的关系树，所以当一个父对象被销毁时，所有依赖或间接依赖于它的对象都会被正确的释放，使用者无需手动管理这些资源的释放操作。&lt;/p&gt;
&lt;p&gt;基于此原理，我们可以放心的让Qt管理资源，这里有几个建议：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对于QObject及其派生类，如果彼此之间存在一定联系，则应该尽量指定parent，对于&lt;code&gt;QWidget&lt;/code&gt;应该指定parent或者加入布局管理器由管理器自动设置parent。&lt;/li&gt;
&lt;li&gt;对象只需要在局部作用域存在时可以选择不进行内存分配，利用局部作用域变量的生命周期自动清理资源。&lt;/li&gt;
&lt;li&gt;对于非&lt;code&gt;QWidget&lt;/code&gt;的对象来说，如果不指定非NULL&lt;code&gt;parent&lt;/code&gt;，则需要自己管理对象资源。&lt;code&gt;QWidget&lt;/code&gt;比较特殊，我们在下一节讲解。&lt;/li&gt;
&lt;li&gt;对于在局部作用域上创建的父对象及其子对象，要注意对象销毁的顺序，因为父对象销毁时也会销毁子对象，当子对象会在父对象之后被销毁时会引发double free。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;QWidget&lt;/code&gt;也是&lt;code&gt;QObject&lt;/code&gt;的子类，所以在parent机制上是没有区别的，然而实际使用时我们更多的是使用“关闭”(close)而不是delete去删除控件，所以差异就出现了。&lt;/p&gt;
&lt;p&gt;先提一下widget关闭的流程，首先用户触发&lt;code&gt;close()&lt;/code&gt;槽，然后Qt向widget发送&lt;code&gt;QCloseEvent&lt;/code&gt;，默认的&lt;code&gt;QCloseEvent&lt;/code&gt;会做如下处理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将widget隐藏，也就是&lt;code&gt;hide()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;如果有设置&lt;code&gt;Qt::WA_DeleteOnClose&lt;/code&gt;，那么会接着调用widget的析构函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们可以看到，widget的关闭实际是将其隐藏，而没有释放内存，虽然我们有时会重写&lt;code&gt;closeEvent&lt;/code&gt;但也不会手动释放widget。&lt;/p&gt;
&lt;p&gt;看一个因为close机制导致的内存泄漏的例子，我们在button被单击后弹出某个自定义对话框：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;button.ConnectClicked(func (_ bool) {
  dialog := NewMyDialog()
  dialog.Exec()
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为dialog在close时会被隐藏，而且没有设置&lt;code&gt;DeleteOnClose&lt;/code&gt;，所以Qt不会去释放dialog，而用户也无法回收dialog的资源，也行你会说golang的GC不是能处理这种情况吗，然而遗憾的是GC并不能处理cgo分配的资源，所以如果你期望GC做善后的话恐怕要失望了，每次点击按钮后内存用量都会增加一点，没错，内存泄露了。&lt;/p&gt;
&lt;p&gt;那么给dialog设置一个parent，像这样，会如何呢？&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;dialog.SetParent(self)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遗憾的是，并没有什么区别，因为这样只是把dialog加入父控件的children，并没有删除dialog，只有父对象被销毁时内存才会真正释放。&lt;/p&gt;
&lt;p&gt;解决办法也有三个。&lt;/p&gt;
&lt;p&gt;第一种是使用&lt;code&gt;deleteLater&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;dialog.DeleteLater()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这会通知Qt的eventloop在下次进入主循环的时候析构dialog，这样一来确实解决了内存泄露，不过缺点是会有不可预测的延迟存在，有时候延迟是难以接受的。&lt;/p&gt;
&lt;p&gt;第二种是手动删除widget，适用于parent为NULL的场合：&lt;br/&gt;C++：&lt;/p&gt;
&lt;pre class=&quot;c++&quot;&gt;
&lt;code&gt;delete dialog;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;golang：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;dialog.DestroyMyDialog()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明一下，&lt;code&gt;DestroyType&lt;/code&gt;也是qtmoc生产的帮助函数，因为golang没有析构函数的概念，所以goqt使用生成的该帮助函数显示调用底层C++对象的析构函数。&lt;/p&gt;
&lt;p&gt;第三种比较简单，对于单纯显示而不需要和父控件做交互的widget，直接设置&lt;code&gt;DeleteOnClose&lt;/code&gt;即可，close时widget会被自动析构。&lt;/p&gt;
&lt;p&gt;当然对于PyQt5来说并不会存在如上的问题，sip库能很好的与python的GC一起工作。唯一需要注意的是有时底层C++对象已经被释放，但是上层python对象依然存在，这时使用该对象将导致抛错。&lt;/p&gt;

&lt;p&gt;Qt提供了一套方便的机制帮助我们进行内存和资源管理，使我们从繁重的劳动中得到了部分的解放，但同时也要注意到那些很容易坑，这样才能写出健壮的正确执行的程序。&lt;/p&gt;
&lt;p&gt;如有错误之处，欢迎批评指正。&lt;/p&gt;
&lt;h5 id=&quot;参考&quot;&gt;参考：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://doc.qt.io/qt-5/qwidget.html&quot; class=&quot;uri&quot;&gt;http://doc.qt.io/qt-5/qwidget.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://doc.qt.io/qt-5/qobject.html&quot; class=&quot;uri&quot;&gt;http://doc.qt.io/qt-5/qobject.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://doc.qt.io/qt-5/objecttrees.html&quot; class=&quot;uri&quot;&gt;http://doc.qt.io/qt-5/objecttrees.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/20164015/is-deletelater-necessary-in-pyqt-pyside&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/20164015/is-deletelater-necessary-in-pyqt-pyside&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Nov 2018 13:43:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>当我们在使用Qt时不可避免得需要接触到内存的分配和使用，即使是在使用Python，Golang这种带有自动垃圾回收器（GC）的语言时我们仍然需要对Qt的内存管理机制有所了解，以更加清楚的认识Qt对象的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apocelipes/p/9991845.html</dc:identifier>
</item>
<item>
<title>带着萌新看springboot源码8（spring ioc源码下） - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/9986294.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/9986294.html</guid>
<description>&lt;p&gt;　　继续接着上一节，到了第六步（温馨提醒，内容有点小多，不过看完ioc原理就差不多了）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.注册Bean后置处理器（registerBeanPostProcessors(beanFactory)）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119221604139-847722220.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119222403896-1867716807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119222921631-1704697387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119223615961-1615090977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119224108366-1679597707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　最后一步，添加一个后置处理器，打开这个后置处理器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119224930930-2037219985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181119225302247-1627515352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;7.initMessageSource();（主要是做国际化功能，消息绑定，emmm...不怎么了解这个）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;大概的意思就是先判断容器里有没有一个id=messageSource，类型为MessageSource的组件（用于解析国际化的配置文件），有的话直接用（就是去拿国际化配置文件的信息），没有的话就new 一个DelegatingMessageSource()，丢到容器里面，然后再接着用.....反正我对这个不怎么了解，有兴趣的小伙伴可以自己去看看别的教程或者自己去走走源码。我就跳过了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.初始化事件派发器（initApplicationEventMulticaster();）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　最好和下面的注册监听器一起看，在我以前发过知识小罐头的那个文章里大概说了一下事件派发器的原理，就是事件派发器会自动的收集所有的监听器，容器只需要发布消息，事件派发器就会将事件派发给所有监听器，让监听器都去执行。&lt;/p&gt;
&lt;p&gt;　　下面来大概看看源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120142235467-1936683662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;9.OnRefrsh&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;这又是一个空方法，加入我们继承本类（子容器），让我们在容器刷新的时候，可以自定义一些操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;10.注册监听器（registerListeners();）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120143925606-1419136459.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120144224892-354847522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至于怎么获取事件派发器，和怎么派发事件，这个很容易，自己点进去看看就ok了（也可以自己实现一个监听器，放到容器里，然后调试，可能看的更清楚点）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;11.完成BeanFactory的初始化（finishBeanFactoryInitialization(beanFactory);）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　这里是重点：&lt;/span&gt;&lt;/strong&gt;有没有前面都是为BeanFactory做的一些默认工作，往里面添加一些什么组件，监听器，消息派发器什么的，一直到这里，就是对其他的单实例Bean（是单实例，因为我们在往容器里添加我们定义的bean的时候，可以设置多例或者懒加载，单例的话实例化一次，然后给你丢缓存里，多例和懒加载是要在每次用的时候才去给你实例化一个）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120145728741-1843894943.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120145752872-1957445431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120150400585-273076184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120151040436-1986840361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120200204961-444135361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120151249792-1304118986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后再进去doGetBean（单实例的Bean，只要创建过就会缓存起来）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120152012095-1350189375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120152401572-544901082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120152736344-363381711.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120153105054-2060026590.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120155229086-1968689497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120155740144-596830032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　接着进入resolveBeforeInstantiation方法，下图的两个方法可以点进去自己看看（就是执行InstantiationAwareBeanPostProcessor里面的方法），很有意思。其实用注解开启事务跟这个有关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120161415026-1990799545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　上面是如果能返回代理对象的，假如不能返回代理对象的话，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120162349744-1242871167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　进入doCreatBean方法，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120162555326-1713004859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;继续进入createBeanInstance，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120162959894-1087056703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　实例创建完了，然后返回，再执行后置处理器的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120163512699-1262584579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;继续往下走（这里就是相当于核心了），两步，赋值，初始化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120163824215-424307699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;打开populateBean方法（&lt;span&gt;注意：先拿到所有的属性值，然后执行了两个后置处理器之后，再进行赋值&lt;/span&gt;）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120164424141-74105081.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120164831100-1647233603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120164906213-2108422094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　&lt;span&gt;　一直到&lt;strong&gt;populateBean方法的最后，才赋值（其实就是调用一些setXXX方法）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120165135564-1482635411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; ---------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;　　赋值结束，下面进行初始化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120203638300-1001790923.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　进入初始化Bean方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120204018088-575341526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而且可以进去看看有哪些xxxAware接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120204344185-320840354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　继续往下看，&lt;span&gt;&lt;strong&gt;执行初始化方法前后&lt;/strong&gt;&lt;/span&gt;，都要执行bean后置处理器（BeanPostProcessor）的xxxBeforexxx，xxxAfterxxx的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120204816524-1423188378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　下面我们还可以看看要执行哪些后置处理器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120205047562-966355551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　ok，初始化方法前后的操作都知道了，现在看看初始化方法内部了（还记不记得怎么设置初始化方法啊第一种：实现InitializingBean接口和DisposableBean接口；第二种：@Bean（initMethod=“初始化方法名” destroyMethod=“销毁方法名”；其他的的方法记不清了，嘿嘿...））&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120210410202-764819389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120210547632-1795802157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　到这里单实例Bean就创建出来了，返回出去&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120211019916-1790740120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　继续往下走，注册实现了Disposable接口的bean&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120211705305-347178658.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　到这里，单实例Bean就创建完了，然后就把这创建完的单实例bean放到缓存里去（其实我看了，就是一个map）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120212532194-1184533543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201811/1368608-20181120212741359-2007519988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　到这里，这一节就结束了，ioc说的差不多了，还有一小步，下一节收尾就ok了。&lt;/p&gt;
&lt;p&gt;　　而且，能看到最后的小伙伴，有没有发现，其实ioc容器本质上就是很多的map，map里面放了很多的组件，我们要用这些组件就是从这么多map里面去拿，所以不要把ioc容器想的太难了（咳咳，虽然我也很菜，ioc对新人确实有点难），多走走源码，其实还是挺有感觉的。哈哈哈@_@&lt;/p&gt;

</description>
<pubDate>Tue, 20 Nov 2018 13:37:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>继续接着上一节，到了第六步（温馨提醒，内容有点小多，不过看完ioc原理就差不多了） 6.注册Bean后置处理器（registerBeanPostProcessors(beanFactory)） 最后一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/9986294.html</dc:identifier>
</item>
<item>
<title>Docker &amp; ASP.NET Core (1)：把代码连接到容器 - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/9985656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/9985656.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181119194029082-441278011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和这种蛋糕一样，Docker的容器和镜像也是使用类似的分层文件系统构建而成的。&lt;/p&gt;
&lt;p&gt;这样做的好处就是可以节省硬盘空间，也利于复用等等。因为Docker基于镜像创建容器的时候，其镜像是共享的；而且镜像里面的层如果已存在，也无需再下载。&lt;/p&gt;

&lt;p&gt;下面拉取一个mongodb的镜像，拉取的过程中可以看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181119194439020-1363822347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中红框范围内的就是mongo镜像的不同分层，也就是镜像中的分层文件系统。&lt;/p&gt;

&lt;p&gt;然而这些镜像层是只读的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181119195114927-2086397557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的限制多少看起来有点严格，如果你想使用该镜像读写数据库怎么办？或者记录Log到文件，或者在容器运行的时候替换一些源代码该怎么办？&lt;/p&gt;

&lt;p&gt;幸运的时候使用该镜像的容器会有可用于读写的&quot;薄薄&quot;一层：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181119195627167-1995857370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中也可以看出容器和镜像的不同之处。&lt;/p&gt;

&lt;p&gt;你可以在容器层进行写入，但是如果容器被删除了，那么可读写的这一层也会被删除。&lt;/p&gt;
&lt;p&gt;这样就不太友好了，而这时我们可以使用&lt;span&gt;&lt;strong&gt;Volume（卷）&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;下面就是这个问题，如何把源码装进容器里？&lt;/p&gt;
&lt;p&gt;1.可以在制做镜像的时候把源码直接写入镜像。（这个先不考虑）&lt;/p&gt;
&lt;p&gt;2.把源码装进容器的可读写层。（这个是我要介绍的）&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;Volume（卷）是容器中一个特别种类的目录，通常叫做数据volume，顾名思义，里面可以放置各种类型的数据，例如代码、日志文件、数据文件等等。&lt;/li&gt;
&lt;li&gt;Volume可以在容器间被共享和复用。可以让多个容器对同一个volume进行读写，也可以让一个容器读写多个volume。&lt;/li&gt;
&lt;li&gt;对镜像的更新并不会影响volume。&lt;/li&gt;
&lt;li&gt;Volume是被持久化的，即使容器删除了，它仍然还在。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以这样去理解Volume，如果有一个容器，那么我们可以在这个容器里面定义一个Volume：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181119201132436-846805689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么想要写到哪里去呢？&lt;/p&gt;
&lt;p&gt;可以让Docker自己搞定，或者你也可以自定义。&lt;/p&gt;
&lt;h2&gt;让Docker决定写入的位置&lt;/h2&gt;
&lt;p&gt;先介绍第一种情况，当你写入到volume的时候，比如在Docker容器里的代码对/var/www做了一个写入的操作，那该目录其实就是你docker host里面的一个装载的文件夹（mounted folder）的别名。Docker host也就是容器的宿主，如果你使用的是Linux系统或Windows 2016及以上版本的系统，那么该宿主就是操作系统。容器也就是运行在该系统上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181119202735386-2031368053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么在这个例子里，我们写入的这个volume，它可以不是容器的可读写层，它实际上可以写入docker host的装载的文件夹，也就是操作系统的文件夹。即使你把容器删除了，docker host里的文件夹仍在健在。&lt;/p&gt;

&lt;p&gt;通常我们使用如下命令来运行容器：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;docker run -p 8000:80 microsoft/dotnet-samples:aspnetapp&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;而我们可以使用-v参数来指定volume：&lt;/p&gt;
&lt;p&gt;docker run -p 8000:80 &lt;span&gt;&lt;strong&gt;-v /var/www&lt;/strong&gt;&lt;/span&gt; microsoft/dotnet-samples:aspnetapp&lt;/p&gt;
&lt;p&gt;这样的话，/var/www只是容器Volume的别名，实际被写入的区域在Docker Host里，docker会自动的创建这个区域。&lt;/p&gt;

&lt;p&gt;可以使用&lt;span&gt;&lt;strong&gt;docker inspect 容器名&lt;/strong&gt;&lt;/span&gt;这个命令来查看相关的路径。&lt;/p&gt;
&lt;p&gt;执行该命令后的结果中会显示如下部分Mounts：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181119210802681-2037265064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中Destination是volume在容器里的地址（别名），而Source则是Volume在宿主中的地址。&lt;/p&gt;
&lt;p&gt;以上这部分介绍的就是让Docker来创建写入的目录。&lt;/p&gt;

&lt;h2&gt;自定义写入的位置&lt;/h2&gt;
&lt;p&gt;下面讲一下如何自定义这个目录的地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181119205553185-1042891722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就对我们开发写代码比较友好了，我的代码存放于Windows/Mac系统中，然后我们让Volume读写我们代码所在的区域。&lt;/p&gt;
&lt;p&gt;那么应该使用哪个Docker命令呢？&lt;/p&gt;
&lt;p&gt;docker run -p 8000:80 &lt;span&gt;&lt;strong&gt;-v ${PWD}:/var/www&lt;/strong&gt;&lt;/span&gt; microsoft/dotnet-samples:aspnetapp&lt;/p&gt;
&lt;p&gt;使用-v在容器里创建一个volume，它在容器的地址是/var/www，但是当你对它进行读写操作时，它实际上找的是宿主的地址，在这里也就是当前的工作目录(curent working directory)。&lt;/p&gt;

&lt;p&gt;如果你这时再执行docker inspect命令，其结果大概如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181119205249141-422135030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;首先使用dotnet cli或者VS建立一个ASP.NET Core项目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181120191143201-223104507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后使用dotnet run测试一下网站是否能正常运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181120191252526-1167852846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181120191323332-956394467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;接下来看看这个ASP.NET Core网站如何与Volume联系在一起。&lt;/p&gt;

&lt;p&gt;首先下载aspnetcore-build镜像：&lt;span&gt;&lt;strong&gt;docker pull microsoft/dotnet:2.1-sdk&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下载完镜像之后，就需要创建容器和Volume了，不过在此之前先打开命令行，进入ASP.NET Core项目源码的目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181120192634023-1686524436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后执行下面的命令(Windows 10 Powershell)：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;docker run -it -p 8080:5001 -v ${PWD}:/app --workdir &quot;/app&quot; microsoft/dotnet /bin/bash&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这句话里-it参数表示进入交互模式&lt;/p&gt;
&lt;p&gt;-p 8080:5001 表示把容器里的5001端口映射给宿主的8080端口。&lt;/p&gt;
&lt;p&gt;-v 表示创建volume&lt;/p&gt;
&lt;p&gt;${PWD}是指宿主当前的目录。&lt;/p&gt;
&lt;p&gt;${PWD}:/app就是把容器里的/app文件夹连接到了宿主系统里的当前文件夹，而容器里的/app目录就是应用程序将要运行的位置。&lt;/p&gt;
&lt;p&gt; --workdir &quot;/app&quot;表示容器里当前的工作目录是/app。&lt;/p&gt;
&lt;p&gt;然后使用microsoft/dotnet这个镜像。&lt;/p&gt;
&lt;p&gt;最后使用/bin/bash返回一个终端，以便让我与容器里进行交互。&lt;/p&gt;

&lt;p&gt;执行命令后，Docker可能会有提示需要共享一个目录，点击确认即可。&lt;/p&gt;
&lt;p&gt;然后我就会进入Container了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181120202257659-2091179331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进入容器之后，我就可以执行dotnet restore， dotnet build等等命令了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181120202439307-407783548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然了，可以执行dotnet run：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181120202526782-1167741863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然而这时候，我访问本机（宿主）的localhost:8080，确无法显式页面。&lt;/p&gt;
&lt;p&gt;首先为了简便，先把HTTPS重定向相关的内容去掉。&lt;/p&gt;
&lt;p&gt;然后要让应用监听任意地址的5001端口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181120204408797-654650099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后再次运行dotnet run。&lt;/p&gt;
&lt;p&gt;随后在宿主系统的浏览器打开http://localhost:8080即可打这个ASP.NET Core的web应用了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201811/986268-20181120204523379-822097827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 20 Nov 2018 12:47:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<og:description>和这种蛋糕一样，Docker的容器和镜像也是使用类似的分层文件系统构建而成的。 这样做的好处就是可以节省硬盘空间，也利于复用等等。因为Docker基于镜像创建容器的时候，其镜像是共享的；而且镜像里面的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/9985656.html</dc:identifier>
</item>
</channel>
</rss>