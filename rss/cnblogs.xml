<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何从编程的本质理解JVM内存模型 - 初开</title>
<link>http://www.cnblogs.com/wchukai/p/10062007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wchukai/p/10062007.html</guid>
<description>&lt;p&gt;一般聊JVM内存模型都是把图截出来，然后对着图，解释上面堆、栈之类的概念。这篇将分享下，如何从编程的本质上理解，JVM内存模型是什么样子，为什么是这个样子，不再死记硬背。&lt;/p&gt;
&lt;h2 id=&quot;编程的本质&quot;&gt;编程的本质&lt;/h2&gt;
&lt;p&gt;编程的本质是什么，有这么一句话，&lt;strong&gt;程序=算法+数据结构。&lt;/strong&gt;&lt;br/&gt;这里的&quot;算法&quot;其实相当宽泛，而平时理解的算法是指诸如排序、查找等操作，相对狭隘。所以换一个解释，我们把算法解释为对数据执行操作，简称执行。&lt;br/&gt;这样，程序的本质便是&lt;strong&gt;数据+执行&lt;/strong&gt;。&lt;br/&gt;而JVM作为JAVA程序的执行载体，必然从逻辑上与其相对应。&lt;/p&gt;
&lt;h2 id=&quot;jvm内存模型&quot;&gt;JVM内存模型&lt;/h2&gt;
&lt;p&gt;因此，JVM内存模型可以分为这么两部分：数据区、执行区。&lt;br/&gt;&lt;img src=&quot;http://img.chukai.pro/bitcron/2018-12-03-075006.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据区&quot;&gt;数据区&lt;/h3&gt;
&lt;p&gt;任何程序，无论实现语言，它的数据总是可分为两类：元数据和业务数据。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;元数据，指描述语言本身的数据，如类信息、指针、引用、即时编译代码等等。&lt;/li&gt;
&lt;li&gt;业务数据，是指功能需求的数据，比如人事系统中的人员、部门数据，在面向对象的语言中以对象的形式存在。&lt;br/&gt;而在JVM内存模型中，元数据对应方法区（Method Area），而业务数据对应着Java堆（Java Heap）。&lt;br/&gt;书中解释如下：&lt;br/&gt;Java堆：存放对象实例和数组。&lt;br/&gt;方法区：存储加载的类信息、常量、静态变量、即时编译代码等&lt;br/&gt;因此，图示如下。&lt;br/&gt;&lt;img src=&quot;http://img.chukai.pro/bitcron/2018-12-03-080106.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;执行区&quot;&gt;执行区&lt;/h2&gt;
&lt;p&gt;执行部分，首先我们得理解程序执行的基本单位是什么，是&lt;strong&gt;方法（或称函数）&lt;/strong&gt;。&lt;br/&gt;通常的程序入口是main方法，单元测试也是基于方法。&lt;br/&gt;平时交流时，也会说调下这个对象的方法，而不是调下这个对象。&lt;br/&gt;甚至还有专门的函数式编程。&lt;br/&gt;而在Java中，方法分为两种：Java方法和Native方法&lt;br/&gt;在内存模型中，Java方法对应Java虚拟机栈（Java Virtual Machine Stacks），Native方法对应本地方法栈（Native Method Stack）&lt;br/&gt;书中解释如下：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;Java虚拟机栈是方法执行的内存模型。&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;本地方法栈为虚拟机使用Native方法服务。&lt;br/&gt;除此之外，再加上程序计数器（Program Counter Register），为当前线程所执行的字节码的提供行号指示。&lt;br/&gt;主要的内存模型就画出来了。&lt;br/&gt;&lt;img src=&quot;http://img.chukai.pro/bitcron/2018-12-03-082640.png&quot;/&gt;&lt;br/&gt;其中，数据区是通用的，所以线程共有，而执行区是线程执行自己的，所以线程私有。&lt;/p&gt;
&lt;h2 id=&quot;jvm内存模型-1&quot;&gt;JVM内存模型&lt;/h2&gt;
&lt;p&gt;再加上真正去执行程序的执行引擎，链接本地方法库，JVM内存模型就很好理解了。&lt;br/&gt;&lt;img src=&quot;http://img.chukai.pro/bitcron/2018-12-03-083207.png&quot;/&gt;&lt;br/&gt;对比下书上的结构，逻辑上一致。&lt;br/&gt;&lt;img src=&quot;http://img.chukai.pro/bitcron/2018-11-30-120149.png&quot;/&gt;&lt;br/&gt;以上。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;《深入理解Java虚拟机》&lt;/p&gt;
&lt;h2 id=&quot;作者&quot;&gt;作者&lt;/h2&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 03 Dec 2018 23:04:00 +0000</pubDate>
<dc:creator>初开</dc:creator>
<og:description>如何从编程的本质理解JVM内存模型 一般聊JVM内存模型都是把图截出来，然后对着图，解释上面堆、栈之类的概念。这篇将分享下，如何从编程的本质上理解，JVM内存模型是什么样子，为什么是这个样子，不再死记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wchukai/p/10062007.html</dc:identifier>
</item>
<item>
<title>ReactNative之结合具体示例来看RN中的的Timing动画 - 青玉伏案</title>
<link>http://www.cnblogs.com/ludashi/p/9876610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ludashi/p/9876610.html</guid>
<description>&lt;p&gt;今天继续更新RN相关的博客。上篇博客详细的聊了RN中关于Flex布局的相关东西，具体请参见《&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/ludashi/p/9696158.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;ReactNative之参照具体示例来看RN中的FlexBox布局&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》。本篇博客继续更新RN的动画部分，博客中的内容依然是依托于具体的示例来进行的。&lt;/p&gt;
&lt;p&gt;下方是官网对RN动画的的一个综述，意思就是说在RN的组件中&lt;span&gt;View、Text、Image 和ScrollView&lt;/span&gt;是支持动画的，不过你可以使用Animated.createAnimatedComponent()这个方法来创建一个支持动画的组件稍后会介绍到。这些支持动画的组件在使用动画是都差不多，本篇博客中的示例主要以View为主，也会有Text、Image的部分动画。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;Animated&lt;/code&gt; exports four animatable component types: &lt;code&gt;View&lt;/code&gt;, &lt;code&gt;Text&lt;/code&gt;, &lt;code&gt;Image&lt;/code&gt;, and &lt;code&gt;ScrollView&lt;/code&gt;, but you can also create your own using &lt;code&gt;Animated.createAnimatedComponent()&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;span&gt;一、一个简单的Moving动画&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;第一部分我们先从一个简单的&lt;span&gt;Moving&lt;/span&gt;动画来入手。这个Moving动画是非常简单的，就是一个View，然后点击这个View，会从一个地方移动到另一个地方。然后再次点击会回归到原位。下方是效果实现的分析：&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;首先我们会为View添加一个点击事件，点击View时，从一个位置移到另一个位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;再次点击时，会回到上次的一个位置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在移动时我们加了一个Bounce的一个动画效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181104164744499-2010046768.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下方代码段是上述动画效果的部分代码。代码比较简单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先在State中定义了一个类型为 &lt;span&gt;Animated.Value&lt;/span&gt; 的动画值，该值就负责来记录动画路径的值。该值在组件的构造器中进行了初始化，其初始值为零。&lt;/li&gt;
&lt;li&gt;然后就是 pressView 方法了，该方法就是上述红色View点击时所执行的方法。为了点击反复移动，我们使用了 toValue来记录下次要运动的重点值。这个toValue值 0 和 1稍后会详细介绍。&lt;/li&gt;
&lt;li&gt;然后就是关键了，调用了Animated 的timing 方法，该方法是用来配置一些动画效果的，比如设置动画执行时间的duration（单位为ms）、设置目标值的 toValue属性，以及指定缓动效果的熟悉 easing。关于这个easing下方会有详细的Demo介绍到。&lt;/li&gt;
&lt;li&gt;设置完动画所执行的参数后，就调用了start() 方法来执行这个动画了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181104174105311-908940054.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;469&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面这段代码是动画设置的相关代码，下方这块代码是动画使用的相关代码片段。下方是对这段代码的解析：&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首先是从state中取出了动画值，我们将该值付给了moveValue。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;然后我们是根据这个 &lt;span&gt;moveValue&lt;/span&gt; 通过差值函数创建了一个 toValue的值，这个值就是我们动画的目标值，也是我们真正要使用的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这个 &lt;span&gt;interpolate()&lt;/span&gt; 差值函数负责用来指定 toValue的生成规则， 该函数可以把这个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181104175448117-214718657.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;545&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 完整代码片段：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_8c3f80d2-9d2b-45d9-ae58-2bd0f74d75c5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8c3f80d2-9d2b-45d9-ae58-2bd0f74d75c5&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8c3f80d2-9d2b-45d9-ae58-2bd0f74d75c5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; type States =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   moveValue: Animated.Value  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 存储动画的值&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; class MoveViewTestComponent extends Component&amp;lt;&lt;span&gt;null&lt;/span&gt;, States&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   toValue = 0
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  constructor (props) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    super(props)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       moveValue: &lt;span&gt;new&lt;/span&gt; Animated.Value(0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   pressView = () =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.toValue = &lt;span&gt;this&lt;/span&gt;.toValue === 0 ? 1 : 0
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    Animated.timing(
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.state.moveValue,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化从0开始&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         toValue: &lt;span&gt;this&lt;/span&gt;.toValue, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 目标值&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         duration: 1000,         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 时间间隔&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         easing: Easing.bounce &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缓动函数&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    ).start()
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;  render () {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     let { moveValue } = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     let toValue =&lt;span&gt; moveValue.interpolate({
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;       inputRange: [0,1&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;       outputRange: ['10%', '60%'&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;       &amp;lt;TouchableOpacity onPress={&lt;span&gt;this&lt;/span&gt;.pressView}&amp;gt;
&lt;span&gt;35&lt;/span&gt;         &amp;lt;Animated.View                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用专门的可动画化的View组件&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;           style=&lt;span&gt;{{
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             width: 100&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             height: 50&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             backgroundColor: 'red'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            left: toValue,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;          }}
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &amp;gt;
&lt;span&gt;43&lt;/span&gt;           &amp;lt;Text style={{ color: '#fff' }}&amp;gt; Tap Me Move &amp;lt;/Text&amp;gt;
&lt;span&gt;44&lt;/span&gt;         &amp;lt;/Animated.View&amp;gt;
&lt;span&gt;45&lt;/span&gt;       &amp;lt;/TouchableOpacity&amp;gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;上面设设置的left属性，我们还可以对上述代码进行修改，使用动画来改变每个角的弧度，具体动画效果如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181125180431389-623007422.gif&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;代码就比较简单了，就是把动画的值直接赋值给我们的 borderRadius 属性即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181125180600073-811213037.png&quot; alt=&quot;&quot; width=&quot;639&quot; height=&quot;270&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;二、使用Easing函数指定相关的动画效果&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在上面的示例中我们指定的移动动画的Bounce效果，下方我们将通过一个示例来看一下Easing中所有的效果，具体动画效果如下所示。从下方的示例中我们不难看出，每种效果的动画运动轨迹都不同，我们在平时开发中可以根据自己的需要来选择相关的效果。当然我们还可以通过矩阵来定义动画的变换路径，在此就不做过多赘述了。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181104112110396-1714278993.gif&quot; alt=&quot;&quot; width=&quot;220&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来我们来看一下上述动画实现的一个Demo的设计与实现。&lt;/p&gt;
&lt;p&gt;首先我们定义了一个&lt;span&gt;MoveView&lt;/span&gt;组件，也就是对应着上述Demo中的每个Button，上面可点击可移动的每个View就是一个MoveView。该View会从外部接收一个easing参数，该参数会被设置为该View的动画效果。具体代码如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181117161832872-1112579929.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;478&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后我们创建了一个 &lt;span&gt;TestMoveView&lt;/span&gt; 的一个组件，这个组件就是上述演示的内容。在 TestMoveView 中我们定义了两个数组，第一个数组用来存放每个按钮的Title， 第二个数组则用来存放相关按钮的动画类型。稍后会用到下方的这两个数组。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181117162248039-64835841.png&quot; alt=&quot;&quot; width=&quot;429&quot; height=&quot;514&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下方就是两个比较核心的方法了, 下方是对这两个方法的介绍&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;第一个 item 方法用来创建一个 &lt;span&gt;MoveView&lt;/span&gt;，该View对应的就是上述一个按钮。第一个参数Title就是按钮上的title, 二后边的easing则是动画效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在Item方法中我们给 MoveView 设置了一个ref的属性，该属性的Value值我们用的是按钮上的Title。设置完这个ref值后，我们可以使用 &lt;span&gt;this.refs&lt;/span&gt; 来获取相关key值的对象。稍后我们会用到。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;然后就是 &lt;span&gt;createItem&lt;/span&gt; 方法了，该方法负责调用 上面我们事先创建好的数组，从数组中取出相关的值，然后调用 item 方法创建一系列的 MoveView 放到相关的数组里并返回。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在 Render 方法中我们就可以调用下方的这个 &lt;span&gt;createItem&lt;/span&gt; 方法来创建相关的按钮了。上的图片中能动的按钮都是通过这个 &lt;span&gt;CreateItem&lt;/span&gt; 方法来创建的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181118153134683-1279271881.png&quot; alt=&quot;&quot; width=&quot;495&quot; height=&quot;325&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后部分我们就来看一下 点击&lt;span&gt;Tap Me&lt;/span&gt; 按钮所执行的相关方法了，下方的Click就是该方法。 在Click方法中主要做的就是调用 this.refs 方法获取所有可移动的MoveView的对象，然后调用该对象的pressView方法执行相关的动画。所有点击 Tap Me 按钮，下方所有的按钮都会运动。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181118161733797-1667929811.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;110&quot;/&gt; &lt;/p&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52.5&quot;&gt;&lt;img id=&quot;code_img_closed_539cc5bd-9a9c-430b-880a-7e039ea0669c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_539cc5bd-9a9c-430b-880a-7e039ea0669c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_539cc5bd-9a9c-430b-880a-7e039ea0669c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;100&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; import React,{ Component } from 'react'
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; import MoveView from './MoveView'&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; import { Animated, Easing, Text, TouchableOpacity, View } from 'react-native'
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; type EasingType = (value: number) =&amp;gt;&lt;span&gt; number
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; class TestMoveView extends Component {
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;   animatedKey: string[] =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     'linear'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     'quad'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     'cubic'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     'sin'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     'exp'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     'bounce'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     'poly-5'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     'elastic-2'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     'back-2'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     'bezier'
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;  ]
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;   animatedEasingType: EasingType[] =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;    Easing.linear,
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;    Easing.quad,
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;    Easing.cubic,
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;    Easing.sin,
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    Easing.exp,
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    Easing.bounce,
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     Easing.poly(5&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     Easing.elastic(2&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     Easing.back(2&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;     Easing.bezier(0,1.6, 1,-0.67&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;  ]
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;   click = () =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.animatedKey.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.refs[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.animatedKey[i]].pressView()
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;   item = (title: string, easing: EasingType) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;       &amp;lt;&lt;span&gt;MoveView
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;         easing=&lt;span&gt; {easing}
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         ref = {title}&amp;gt;
&lt;span&gt; 45&lt;/span&gt;         &amp;lt;Text style={{ fontSize: 17, textAlign: 'center' }}&amp;gt;
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;          {title}
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         &amp;lt;/Text&amp;gt;
&lt;span&gt; 48&lt;/span&gt;       &amp;lt;/MoveView&amp;gt;
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;   createItems = () =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     let items =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; &lt;span&gt;this&lt;/span&gt;.animatedKey.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;       items.push(&lt;span&gt;this&lt;/span&gt;.item(&lt;span&gt;this&lt;/span&gt;.animatedKey[i], &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.animatedEasingType[i]))
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; items
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;  render () {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;     console.log('lizelu'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;       &amp;lt;View style={{ flex: 1, justifyContent: 'center' }}&amp;gt;
&lt;span&gt; 64&lt;/span&gt;         &amp;lt;TouchableOpacity onPress={&lt;span&gt;this&lt;/span&gt;.click}&amp;gt;
&lt;span&gt; 65&lt;/span&gt;           &amp;lt;Text&amp;gt;Tap Me&amp;lt;/Text&amp;gt;
&lt;span&gt; 66&lt;/span&gt;         &amp;lt;/TouchableOpacity&amp;gt;
&lt;span&gt; 67&lt;/span&gt;         { &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.createItems() }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;       &amp;lt;/View&amp;gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MoveView&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; type MoveViewProps =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;   easing?: (value: number) =&amp;gt;&lt;span&gt; number
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; class MoveView extends Component&amp;lt;MoveViewProps&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;   toValue = 0
&lt;span&gt; 81&lt;/span&gt;   state =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     moveValue: &lt;span&gt;new&lt;/span&gt; Animated.Value(0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;   pressView = () =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.toValue = &lt;span&gt;this&lt;/span&gt;.toValue === 0 ? 1 : 0
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;    Animated.timing(
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;       &lt;span&gt;this&lt;/span&gt;.state.moveValue,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化从0开始&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;      {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;         toValue: &lt;span&gt;this&lt;/span&gt;.toValue, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 目标值&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;         duration: 1000,         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 时间间隔&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;         easing: &lt;span&gt;this&lt;/span&gt;.props.easing &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动画效果&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    ).start()
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;  render () {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     let { moveValue } = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     let toValue =&lt;span&gt; moveValue.interpolate({
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;       inputRange: [0,1&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;       outputRange: ['10%', '70%'&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;       &amp;lt;TouchableOpacity onPress={&lt;span&gt;this&lt;/span&gt;.pressView}&amp;gt;
&lt;span&gt;105&lt;/span&gt;         &amp;lt;Animated.View                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用专门的可动画化的View组件&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;           style=&lt;span&gt;{[{
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;             width: 80&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             height: 30&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;             backgroundColor: 'powderblue'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;             margin: 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;             left: toValue   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 动画的目标值&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;          }]}
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         &amp;gt;
&lt;span&gt;114&lt;/span&gt;           {&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.children}
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;         &amp;lt;/Animated.View&amp;gt;
&lt;span&gt;116&lt;/span&gt;       &amp;lt;/TouchableOpacity&amp;gt;
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;    )
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Easing&lt;/span&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span&gt;三、动画的插值函数及transform&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;1、插值函数&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;接下来我们通过一个Loading中经常使用的旋转动画，来看一下RN动画中的插值函数。下方的Loading动画本质上就是一张图片在不停的转圈，不过在转圈的时候我们设置了一个Circle的动画效果。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181118164940099-411568684.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要实现的效果就是上面这个效果，然后我们看一下代码实现以及插值函数的使用。首先我们来看一下上述动画启动时的相关代码：&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首先在 &lt;span&gt;ComponentDidMount&lt;/span&gt; 方法中调用了启动方法的函数 startAnimation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在 &lt;span&gt;startAnimation&lt;/span&gt; 函数中，我们通过 &lt;span&gt;Animation&lt;/span&gt;的 loop 方法来执行循环动画动画的值从 0 到 1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;并且我们设置了动画效果为 circle&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最后就是调用start方法启动动画了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181125173002231-197927509.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;270&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后就是Render方法中获取动画值，给相关的组件设置动画了，具体代码如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首先我们从state中获取到相关的动画值 &lt;span&gt;animationValue&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;然后调用该动画值的插值函数 &lt;span&gt;interpolate&lt;/span&gt;，将动画值中的 0~1的范围映射成角度 &lt;span&gt;0deg ~ 360deg&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最后就是将这个插值函数生成的值 &lt;span&gt;rotateZValue&lt;/span&gt;设置给 Image的transform即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181125173516827-1080686178.png&quot; alt=&quot;&quot; width=&quot;456&quot; height=&quot;348&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span&gt;2、Transform&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;经过上述步骤我们的图片就转起来了。插值函数在动画中还是比较常用的，上面是把 0 ~ 1映射成角度，我们还可以将该值映射成透明度、颜色等等，总之插值函数是RN动画中比较重要的角色。而且我们可以给一个RN元素设置多个插值动画，这样这个元素就会有多个动画效果。&lt;/p&gt;
&lt;p&gt;下方这个动画就由多个插值函数结合着多种变换方式组合而成的，分别是移动、旋转、放大这三种变换同时作用到一个View上所展示的效果，具体效果如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181125174752821-1711962682.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述效果是在第一个转圈的动画中丰富了一下而形成的，具体代码如下：&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前两个负责生成移动和缩放效果使用的值的插值函数和上面那个转圈的比较一致，只不过映射的值不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;然后看第三个旋转使用的插值函数就稍微有点不同了，该插值函数可以将 0 ~ 1 不同的区间的值映射成不同范围的值，&lt;span&gt;从这个旋转的插值函数的映射关系不难看出，上述View的旋转路径是先快后慢的，&lt;/span&gt;这一点在插值函数中也是比较常用的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最后就是将这三个插值函数所生成的结果设置在View的 &lt;span&gt;transform&lt;/span&gt; 的各个key中就可以了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181125175139341-928458853.png&quot; alt=&quot;&quot; width=&quot;706&quot; height=&quot;649&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面是缩放、移动、旋转的变换。下面我们来看一下斜切的变换。下方第一个是X方向上的斜切，第二个是Y轴方向上的斜切。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181125181410335-77034116.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181125181618131-1992961478.gif&quot; alt=&quot;&quot; width=&quot;105&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码也比较简单，下方是设置斜切的相关代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/545446/201811/545446-20181125181811697-183181820.png&quot; alt=&quot;&quot; width=&quot;368&quot; height=&quot;286&quot;/&gt;&lt;/p&gt;

&lt;p&gt;天不早了，今天博客就先到这儿，下篇博客继续RN动画的相关内容。下篇博客我们会通过一系列的“拉皮条”操作来看一下RN中的Spring动画。下篇的“拉皮条”的示例还是比较有意思的。稍后会更新。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 17:15:00 +0000</pubDate>
<dc:creator>青玉伏案</dc:creator>
<og:description>今天继续更新RN相关的博客。上篇博客详细的聊了RN中关于Flex布局的相关东西，具体请参见《ReactNative之参照具体示例来看RN中的FlexBox布局》。本篇博客继续更新RN的动画部分，博客中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ludashi/p/9876610.html</dc:identifier>
</item>
<item>
<title>可能是最简单的把C++Lib包装成C#可用dll的方法 - 黑山老雕</title>
<link>http://www.cnblogs.com/zzpbuaa/p/10061831.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzpbuaa/p/10061831.html</guid>
<description>&lt;p&gt;（想直接看结果的直接翻到最后）&lt;/p&gt;
&lt;p&gt;之前对C++接触不多，最近工作需要，第三方给了一个C++的lib库，我们需要把它封装一下在C#中调用。对方要是直接给Dll就省事了。。。&lt;/p&gt;
&lt;p&gt;研究了一下，基本有三个方向：&lt;/p&gt;
&lt;p&gt;1. 建立CLI类型的，或者叫Managed的基于.NET的dll，这样c#可以直接进行引用。&lt;/p&gt;
&lt;p&gt;2. 建立native的c++ dll，然后在C#用 dllimport的方式调用。&lt;/p&gt;
&lt;p&gt;3. 建立com组件。&lt;/p&gt;
&lt;p&gt;一开始感觉第一种很美好。直接加到reference中就能像引用一个C#的dll一样使用了。而且有一个好处是，我可以把这个dll工程和我的调用的C#工程放在一个solution中，然后在调试的时候，断点能直接进入到这个C++的工程中。这点要调试起来是很美好的哦。&lt;/p&gt;
&lt;p&gt;方法可以参考这个：&lt;a href=&quot;https://docs.microsoft.com/en-us/cpp/dotnet/how-to-wrap-native-class-for-use-by-csharp?view=vs-2017&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/en-us/cpp/dotnet/how-to-wrap-native-class-for-use-by-csharp?view=vs-2017&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个不错的C#使用CLI/CLR 调用native C++ 的例子：http://www.dorodnic.com/blog/2014/12/10/calling-cpp-by-example/&lt;/p&gt;
&lt;p&gt;基本上就是创建一个CLI类型的工程。注意工程的属性，选择一下CLR，以及Framework的版本。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1062&quot; data-height=&quot;845&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10458422-f23733a7908df343.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/10458422-f23733a7908df343.png&quot; data-original-width=&quot;1062&quot; data-original-height=&quot;845&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;72257&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在Header中引入头文件，在Resources中引入Lib文件。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;346&quot; data-height=&quot;374&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10458422-76a4e4bd344356b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/346/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/10458422-76a4e4bd344356b4.png&quot; data-original-width=&quot;346&quot; data-original-height=&quot;374&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;19286&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样在GoWrapper.cpp中就可以把需要的函数封装一下了。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1456&quot; data-height=&quot;740&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10458422-c80f230ac1b15777.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/10458422-c80f230ac1b15777.png&quot; data-original-width=&quot;1456&quot; data-original-height=&quot;740&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;122522&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里可以选择更好的封装方式，比如对于原有的C++函数使用指针来返回结果的方式，我们可以使用一个自定义的类来返回之类的。但是考虑到要包装很多的函数，为了简便，最好让包装好的函数看起来和原有的函数差不多，对于指针可以通过ref或者out的方式来调用。&lt;/p&gt;
&lt;p&gt;这样在调用的时候，就可以像下面这样调用：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;906&quot; data-height=&quot;492&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10458422-2434e0a440161459.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/906/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/10458422-2434e0a440161459.png&quot; data-original-width=&quot;906&quot; data-original-height=&quot;492&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;54584&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;注意如果想要用ref的方式调用的话，用下面这种来声明：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;779&quot; data-height=&quot;396&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10458422-f08902b980c092d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/779/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/10458422-f08902b980c092d9.png&quot; data-original-width=&quot;779&quot; data-original-height=&quot;396&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;25691&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;到现在，CLI的Managed dll方式基本已经完成了。可是想想如果要包装的时候，这一百多个函数的类型转换也将会是很大的一个工作量。我决定再尝试一下native dll的方式，虽然不能在同一个solution中debug，但是毕竟包装起来方便一些，只好忍忍了。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms235636.aspx&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://msdn.microsoft.com/en-us/library/ms235636.aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要就是要在native dll的函数前面加上 __declspec(dllexport) int __stdcall 的声明（__stdcall非必须），它就可以export了。&lt;/p&gt;
&lt;p&gt;MSDN的关于dllexport和dllimport的说明：https://msdn.microsoft.com/zh-cn/library/3y1sfaz2.aspx&lt;/p&gt;
&lt;p&gt;还有下面这个也不错：&lt;/p&gt;
&lt;p&gt;https://docs.microsoft.com/zh-cn/cpp/build/importing-into-an-application-using-declspec-dllimport?view=vs-2017&lt;/p&gt;
&lt;p&gt;为什么要写成 ifdef 就 export， 如果不，就import的方式，主要是为了便于同一个头文件可以同时应用于客户端和提供端。&lt;/p&gt;
&lt;p&gt;根据上面那个walkthrough，native 的dll还是很好创建的。要记得在工程属性里面，CLR不要选择，就是native 的dll，或者记得要在创建project的时候的模板就选择native的。&lt;/p&gt;
&lt;p&gt;不过，这样生成的dll，我在import的时候遇到了问题。import的代码如下：&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;805&quot; data-height=&quot;525&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10458422-fe2e76c29392450b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/805/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/10458422-fe2e76c29392450b.png&quot; data-original-width=&quot;805&quot; data-original-height=&quot;525&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;47594&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里我必须使用一个EntryPoint=“#1”来指定我这个函数的entrypoint，因为生成的dll里面，export的函数的entrypoint的名称后面有一串 @xxxx 的东西。这个entrypoint 可以使用depends打开查看，可以使用名称或者序号。这样很不方便对不对，我用过的dllimport没有哪个是要这么搞的。为了解决这个问题，我们需要用到一个DEF文件。在properties中可以指定所使用的DEF文件，不过如果你自己添加一个DEF文件的话，它会被自动添加到Properties的设置中的，其实你不需要手动去指定它。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1053&quot; data-height=&quot;837&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10458422-406d81dee86bff33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/10458422-406d81dee86bff33.png&quot; data-original-width=&quot;1053&quot; data-original-height=&quot;837&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;92624&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Def文件的作用就是告诉编译程序，我要把哪个函数用来export，用什么样的名称来export。当然，有了这个DEF文件，就可以不需要__declspec(dllexport) int的声明了。&lt;/p&gt;
&lt;p&gt;修改之后的头文件：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1013&quot; data-height=&quot;238&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10458422-30d2754f7fa344ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/10458422-30d2754f7fa344ac.png&quot; data-original-width=&quot;1013&quot; data-original-height=&quot;238&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;32238&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;修改之后的def文件：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;527&quot; data-height=&quot;242&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10458422-f46080c003b2738b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/527/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/10458422-f46080c003b2738b.png&quot; data-original-width=&quot;527&quot; data-original-height=&quot;242&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;18913&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;调用方：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1194&quot; data-height=&quot;620&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10458422-1b83c64a3cad0940.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/10458422-1b83c64a3cad0940.png&quot; data-original-width=&quot;1194&quot; data-original-height=&quot;620&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;82349&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;到现在，应该还比较圆满了。虽然我么有了调试C++库的便利，但是包装几百个函数也容易一些。只要直接把那个函数return回去就好了。&lt;/p&gt;
&lt;p&gt;正当这时，凝望着我可爱的头文件。我忽然想起，当用depends查看生成的dll的时候。在依赖中是可以看到第三方的函数的。它们貌似也都加过 __declspec的前缀。那么既然它都加过了。那我还再Wrap一遍干啥？？？试了一下。把DEF文件删掉，把我加的Wrapper删掉，把我加的头文件也删掉。试了一下，可以用！！！&lt;/p&gt;
&lt;p&gt;最终，其实就只是创建了一个native的dll，在resources里面加上了第三方的lib文件而已。别的自己的头文件和cpp文件一个都不用加的。有一种“慕然回首，那人却在灯火阑珊处”的感觉。虽然转了一圈，但是也算对于各种DLL的知识都有了了解，也算是有很多的收获了。而且这个方法适用的前提在于第三方已经把自己的函数都添加了 declspec的前缀。如果没有的话，可以简单的通过添加 DEF文件的方式来export出想要的方法。&lt;/p&gt;
&lt;p&gt;附一个DEF文件的文档：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/cpp/build/reference/module-definition-dot-def-files?view=vs-2017&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/cpp/build/reference/module-definition-dot-def-files?view=vs-2017&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明出处！！&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 15:57:00 +0000</pubDate>
<dc:creator>黑山老雕</dc:creator>
<og:description>（想直接看结果的直接翻到最后） 之前对C++接触不多，最近工作需要，第三方给了一个C++的lib库，我们需要把它封装一下在C#中调用。对方要是直接给Dll就省事了。。。 研究了一下，基本有三个方向：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzpbuaa/p/10061831.html</dc:identifier>
</item>
<item>
<title>Java字符串操作及与C#字符串操作的不同 - baidixing</title>
<link>http://www.cnblogs.com/jiagoushi/p/10061787.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiagoushi/p/10061787.html</guid>
<description>&lt;p&gt;每种语言都会有字符串的操作，因为字符串是我们平常开发使用频率最高的一种类型。今天我们来聊一下Java的字符串操作及在某些具体方法中与C#的不同，对于需要熟悉多种语言的人来说，作为一种参考。进行诫勉&lt;/p&gt;
&lt;p&gt;首先，什么是字符串？&lt;/p&gt;
&lt;p&gt;字符串是字符的序列，是作为一种对象而存在。说的直白点，字符串就是一些字符的组合，从而构成字符串，例如“abc”就是字符串，&quot;郭志奇&quot;也是一种赐福穿。&lt;/p&gt;
&lt;p&gt;我们知道，Java是一种面向对象的高级程序语言。所有事物均为对象，字符串也不例外，也是一种对象，其对应类型为String。&lt;/p&gt;
&lt;p&gt;下面，我们分几种情况来进行说明字符串：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;字符串的创建&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符串操作&lt;/strong&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;字符串连接&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符串长度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符串查找&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;获取指定索引的字符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;去重空格&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;判断相等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大小写转换&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符串分隔&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符串比较&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;字符串创建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;字符串必须先声明并进行初始化，才能使用，否则编译器会报出 变量未初始化错误。&lt;/p&gt;
&lt;p&gt;请注意：Java中字符串定义的类型为String(第一个字母大写)，对于C#程序员来说，看着不太舒服，因为c#中字符串定义为string （第一个字母小写），但C#中也是有String类的&lt;/p&gt;
&lt;p&gt;创建字符串也分几种方式，可以根据需求灵活组织：&lt;/p&gt;
&lt;p&gt;String(char a[])--Java代码 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; a[] = { 'a', 'b', 'c'&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         String source = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(a);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(source);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出结果为abc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;String(char a[],int offset,int length)--Java代码 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; a[] = { 'a', 'b', 'c'&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         String source = &lt;span&gt;new&lt;/span&gt; String(a, 1, 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(source);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出为bc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;字符串常量：&lt;/p&gt;
&lt;p&gt;String source=“郭志奇”;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         String source = &quot;郭志奇&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         String source1 = &quot;郭志奇&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(source == source1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出true&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         System.out.println(source.equals(source1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处简单提一下，Java中双等号== 表示的是引用是否相同，equals比较的是实际的字符串值。&lt;/p&gt;
&lt;p&gt;对应的C#代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; source = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;郭志奇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; source1 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;郭志奇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             Console.WriteLine(source==source1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出True&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;             Console.WriteLine(source.Equals(source1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出True&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;             Console.WriteLine(&lt;span&gt;string&lt;/span&gt;.ReferenceEquals(source,source1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出True&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;             Console.Read();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在C#中双等号以及equals比较的是实际的值，而refreshEquals比较的是引用是否相同。和Java略有不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;字符串操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;0.5&quot;&gt;&lt;strong&gt;字符串连接&lt;br/&gt;&lt;/strong&gt;通过加号+可以将两个字符串进行连接。请注意，字符串与其他类型连接，会自动调用其toString方法转换成字符串，然后进行拼接。&lt;br/&gt;Java代码：&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         String source = &quot;郭志奇&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         String source2 = &quot;郭语晨&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         String source3 = source +&lt;span&gt; source2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(source3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出郭志奇郭语晨&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         String source4 = source + 521;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字符串与数字拼接&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         System.out.println(source4);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出郭志奇521&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;concat:字符串拼接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         String source = &quot;郭志奇&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         String source2 = &quot;郭语晨&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         String source5 =&lt;span&gt; source.concat(source2);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(source5);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出郭志奇郭语晨&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;&lt;strong&gt;字符串长度&lt;br/&gt;&lt;/strong&gt;通过length()方法获取字符串长度。请注意：包含字符串中空格的长度。&lt;br/&gt;Java代码：&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         String source = &quot;     郭志奇 &quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前缀包含一个空格及一个tab 后缀包含一个空格&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         System.out.println(source.length());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;C#代码：&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;找茬：从C#输出的长度可以看到，Tab在Java中长度为1，而在C#长度为2. 英文tab&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;             string source = &quot;   郭志奇 &quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             Console.WriteLine(source.Length);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li readability=&quot;9.5&quot;&gt;&lt;strong&gt;字符串查找&lt;br/&gt;&lt;/strong&gt;两种字符串查找方法：&lt;br/&gt;indexOf():从字符串开始位置进行查找&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         String source = &quot;郭志奇&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         System.out.println(source.indexOf(&quot;郭&quot;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出0&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         System.out.println(source.indexOf(&quot;&quot;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lastIndexOf()方法：从字符串结束位置开始查找&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         String source = &quot;郭志奇&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         System.out.println(source.lastIndexOf(&quot;郭&quot;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出0&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         System.out.println(source.lastIndexOf(&quot;&quot;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;找茬：indexOf查找空字符串，返回值是0。lastIndexOf方法查找空格，返回值是3.等于字符串的长度。&lt;br/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;查看lastIndexOf对应的C#代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;             string source = &quot;郭志奇&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;            Console.WriteLine(source.Length);//输出3
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             Console.WriteLine(source.LastIndexOf(&quot;&quot;&lt;span&gt;));//输出2
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             Console.Read();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过对比lastIndexOf查找空字符串，可以发现C#和Java的不同，Java返回的是字符串的长度，而C#返回的是字符串长度-1。个人认为C#的处理更符合目的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;&lt;strong&gt;获取指定索引的字符&lt;br/&gt;&lt;/strong&gt;通过charAt方法获取指定索引的字符&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         String source = &quot;郭志奇&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         System.out.println(source.charAt(0&lt;span&gt;));//输出郭
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(source.charAt(source.length() - 1));//输出奇
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了学习，我们就要思考，假如我输入了负数或大于字符串长度的索引会出现什么呢？代码验证&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         String source = &quot;郭志奇&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         System.out.println(source.charAt(-1&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(source.charAt(source.length() + 11));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没错，代码执行出错了，抛出异常：java.lang.StringIndexOutOfBoundsException&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;&lt;strong&gt;去重空格&lt;br/&gt;&lt;/strong&gt;通过trim方法移除字符串前后空格(包含tab)&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         String source = &quot; 郭志奇  &quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前后都有空格&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         String source1 = &quot;    郭志奇    &quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        System.out.println(source.length());
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        System.out.println(source.trim().length());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        System.out.println(source1.length());
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         System.out.println(source1.trim().length());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;令人遗憾的是，Java没有提供只清空前缀空格或后缀空格的方法。而C#却有。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.5&quot;&gt;&lt;strong&gt;判断相等&lt;br/&gt;&lt;/strong&gt;两种判断字符串相等的方法，双等号及equals、equalsIgnoreCase&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;通过代码来进行说明：&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         String source = &lt;span&gt;new&lt;/span&gt; String(&quot;郭志奇A&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         String source1 = &lt;span&gt;new&lt;/span&gt; String(&quot;郭语晨&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         String source2 = &quot;郭志奇A&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         String source3 = &quot;郭语晨&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         String source4 = &quot;郭志奇a&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         System.out.println(source == source2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         System.out.println(source.equals(source2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         System.out.println(source1 == source3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         System.out.println(source1.equals(source3));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         System.out.println(source == source4);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         System.out.println(source.equals(source4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         System.out.println(source.equalsIgnoreCase(source4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;双等号代表的是字符串引用是否相同，对于不同对象的字符串，双等号比较是不同的。&lt;br/&gt;equals比较的是字符串的值，但区分大小写&lt;br/&gt;equalsIgnoreCase：比较的是字符串的值，不区分大小写&lt;br/&gt;进行字符串比较，尽量避免使用双等号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;大小写转换&lt;br/&gt;&lt;/strong&gt;toUpperCase转换成大写形式，toLowerCase转换成小写形式。但对于数字、空格则会忽略，不进行转换。比较简单&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符串分隔&lt;br/&gt;&lt;/strong&gt;通过split方法进行字符串分隔，split参数是分隔符，返回值是分割后的字符串数组。较简单。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符串比较&lt;br/&gt;通过compareTo方法进行字符串比较，&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         String source = &quot;ab&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         String source1 = &quot;ba&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         String source2 = &quot;ab&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        System.out.println(source.compareTo(source1));//返回值-1
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        System.out.println(source.compareTo(source2));//返回值0
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        System.out.println(source1.compareTo(source2));//返回值1
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        System.out.println(source.compareToIgnoreCase(source1));//返回值-1
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        System.out.println(source.compareToIgnoreCase(source2));//返回值0
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(source1.compareToIgnoreCase(source2));//返回值1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;compareTo方法会逐个字符进行比较，如果源字符串比目标字符串大，那么返回正整数；如果源字符串与目标字符串相同，那么返回0；如果源字符串比目标字符串小，那么返回负数。&lt;/p&gt;
&lt;p&gt;请注意：&lt;/p&gt;
&lt;p&gt;1、返回值为0，那么字符串通过equals比较会相同&lt;/p&gt;
&lt;p&gt;2、返回值正整数、负数，是源字符串不同的字符相减所得。&lt;/p&gt;
&lt;p&gt;字符串使我们日常开发使用频率最高的类型，因此要数量掌握字符串的各种操作，以及一些坑点，才能在编码中轻松、愉快的避免各种bug的出现。&lt;/p&gt;
&lt;p&gt;本次说明只介绍了字符串的冰山一角，对于更重要的字符串格式化，本次没有涉及，因为蛋蛋字符串格式化，就可以单独写一篇更长的博文才能说明。下次再聊。&lt;/p&gt;

</description>
<pubDate>Mon, 03 Dec 2018 15:39:00 +0000</pubDate>
<dc:creator>baidixing</dc:creator>
<og:description>每种语言都会有字符串的操作，因为字符串是我们平常开发使用频率最高的一种类型。今天我们来聊一下Java的字符串操作及在某些具体方法中与C#的不同，对于需要熟悉多种语言的人来说，作为一种参考。进行诫勉 首</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiagoushi/p/10061787.html</dc:identifier>
</item>
<item>
<title>通过vuepress管理项目文档(一) - qfstudy</title>
<link>http://www.cnblogs.com/qfstudy/p/10061771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qfstudy/p/10061771.html</guid>
<description>&lt;p&gt;这篇文章主要是记录自己在使用vuepress过程中所遇到的问题以及如何一步一步的解决问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;安装vuepress前，请确保你的 Node.js 版本 &amp;gt;= 8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;全局安装&quot;&gt;全局安装&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# 安装
yarn global add vuepress # 或者：npm install -g vuepress

# 新建一个 markdown 文件
echo '# Hello VuePress!' &amp;gt; README.md

# 开始写作
vuepress dev .

# 构建静态文件
vuepress build .&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;注意-vuepress-dev-.和vuepress-build-.后面的.&quot;&gt;注意 ：&lt;code&gt;vuepress dev .&lt;/code&gt;和&lt;code&gt;vuepress build .&lt;/code&gt;后面的&lt;code&gt;.&lt;/code&gt;。&lt;/h4&gt;
&lt;h2 id=&quot;在现有项目中安装&quot;&gt;在现有项目中安装&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# 将 VuePress 作为一个本地依赖安装
yarn add -D vuepress # 或者：npm install -D vuepress

# 新建一个 docs 文件夹
mkdir docs

# 新建一个 markdown 文件
echo '# Hello VuePress!' &amp;gt; docs/README.md

# 开始写作
npx vuepress dev docs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，在 &lt;code&gt;package.json&lt;/code&gt; 里加一些脚本:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;scripts&quot;: {
    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,
    &quot;docs:build&quot;: &quot;vuepress build docs&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开始写作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yarn docs:dev # 或者：npm run docs:dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个坑：我的项目就是依赖&lt;code&gt;webpack 3.6.0&lt;/code&gt;同时也是用npm安装依赖，然后继续使用npm安装vuepress，然后执行&lt;code&gt;npx vuepress dev docs&lt;/code&gt;的时候报错了，上网查了好久也没有解决问题，最后使用yarn安装vuepress成功了。&lt;/p&gt;
&lt;p&gt;如果你的现有项目依赖了 webpack 3.x，推荐使用 yarn而不是 npm 来安装 VuePress。&lt;/p&gt;
&lt;p&gt;要生成静态的 HTML 文件，运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yarn docs:build # 或者：npm run docs:build&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，文件将会被生成在 &lt;code&gt;.vuepress/dist&lt;/code&gt;，也可以通过 &lt;code&gt;.vuepress/config.js&lt;/code&gt; 中的 &lt;code&gt;dest&lt;/code&gt; 字段来修改.&lt;/p&gt;
&lt;p&gt;以上步骤都成功以后，就可以在浏览器总看到页面了，接下来就是对页面进行布局&lt;/p&gt;
&lt;h2 id=&quot;主题配置&quot;&gt;主题配置&lt;/h2&gt;
&lt;p&gt;本文是根据vuepress默认主题配置&lt;/p&gt;
&lt;h3 id=&quot;首页&quot;&gt;1.首页&lt;/h3&gt;
&lt;p&gt;在docs文件夹下创建&lt;code&gt;.vuepress文件夹&lt;/code&gt;和&lt;code&gt;README.md文件&lt;/code&gt;。(如果以及有了就不要再新建)&lt;br/&gt;根目录下的README.md文件可以当作首页，在文件中加入下面文字：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;---
home: true
heroImage: /hero.png
actionText: 快速上手 →
actionLink: /zh/guide/
features:
- title: 简洁至上
  details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。
- title: Vue驱动
  details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。
- title: 高性能
  details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。
footer: MIT Licensed | Copyright © 2018-present Evan You
---&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以根据自己的需要添加、删除、修改，这就完成了首页的布局&lt;br/&gt;&lt;code&gt;actionLink/zh/guide/&lt;/code&gt;就是首页后要显示的下一个页面&lt;/p&gt;
&lt;p&gt;接下来在docs文件夹中创建&lt;code&gt;guide文件夹&lt;/code&gt;(根据自己的需要命名)。这个文件夹中放的是&lt;code&gt;markdown&lt;/code&gt;文件，每一个&lt;code&gt;markdown&lt;/code&gt;文件对应一个页面。至于页面之间的跳转和页面导航栏和侧边栏布局在&lt;code&gt;config.js&lt;/code&gt;文件中设置。&lt;br/&gt;VuePress 网站必要的配置文件是 &lt;code&gt;.vuepress/config.js&lt;/code&gt;，它应该导出一个 JavaScript 对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  title: 'Hello VuePress',
  description: 'Just playing around'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上述的配置，如果你运行起 dev server，你应该能看到一个页面，它包含一个页头，里面包含一个标题和一个搜索框。&lt;/p&gt;
&lt;h3 id=&quot;导航栏&quot;&gt;2.导航栏&lt;/h3&gt;
&lt;p&gt;可以通过 &lt;code&gt;themeConfig.nav&lt;/code&gt; 增加一些导航栏链接:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// .vuepress/config.js
module.exports = {
  themeConfig: {
    nav: [       
           {text: '指南',link:'/guide/install/install'}
        ]
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你提供了一个 &lt;code&gt;items&lt;/code&gt; 数组而不是一个单一的 &lt;code&gt;link&lt;/code&gt; 时，它将显示为一个 &lt;code&gt;下拉列表&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  themeConfig: {
    nav: [
      {
        text: 'Languages',
        items: [
          { text: 'Chinese', link: '/language/chinese/' },
          { text: 'Japanese', link: '/language/japanese/' }
        ]
      }
    ]
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;侧边栏&quot;&gt;3.侧边栏&lt;/h3&gt;
&lt;p&gt;想要使侧边栏（Sidebar）生效，需要配置 &lt;code&gt;themeConfig.sidebar&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// .vuepress/config.js
module.exports = {
  themeConfig: {
    sidebar: [
        {
            title: '开发指南',
            collapsable: false, //是否展开
        },
        ['./guide/install/install','安装'],
        ['./guide/started/started','快速上手'],
        {
            title: '组件',
            collapsable: false
        },
        ['./guide/icon/icon','icon'],
        ['./guide/button/button','button'],
    ]
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以省略 &lt;code&gt;.md&lt;/code&gt; 拓展名，同时以 &lt;code&gt;/&lt;/code&gt; 结尾的路径将会被视为 &lt;code&gt;*/README.md&lt;/code&gt;&lt;br/&gt;如果想要显示地指定链接的文字，使用一个格式为 &lt;code&gt;[link, text]&lt;/code&gt; 的数组。&lt;br/&gt;具体配置可以根据官网配置：&lt;a href=&quot;https://vuepress.vuejs.org/zh/theme/default-theme-config.html#%E4%BE%A7%E8%BE%B9%E6%A0%8F&quot;&gt;默认主题配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在页面基本也搭建完成，可以在页面之间进行切换。下一步是如何在&lt;code&gt;markdown&lt;/code&gt;中使用vue组件，也就是在页面中展示自己的项目。&lt;/p&gt;
&lt;h2 id=&quot;在markdown中使用vue&quot;&gt;在markdown中使用Vue&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;.vuepress&lt;/code&gt;中创建&lt;code&gt;components&lt;/code&gt;文件夹。&lt;br/&gt;所有在 &lt;code&gt;.vuepress/components&lt;/code&gt; 中找到的 &lt;code&gt;*.vue&lt;/code&gt; 文件将会自动地被注册为全局的异步组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.
└─ .vuepress
   └─ components
      ├─ demo-1.vue
      └─ Foo
         └─ demo-2.vue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以直接使用这些组件在任意的 Markdown 文件中（组件名是通过文件名取到的）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;demo-1/&amp;gt;
&amp;lt;Foo-demo-2/&amp;gt; //文件名和组件名之间同`-`连接&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成这一步以后就可以在页面中看到自己的组件在页面中展示了，但是在运行下面命令的时候会报错：&lt;br/&gt;报错原因参考官网文档&lt;a href=&quot;https://vuepress.vuejs.org/zh/guide/using-vue.html#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84-api-%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6&quot;&gt;## 浏览器的 API 访问限制&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yarn docs:build # 或者：npm run docs:build&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决这个问题只需要在&lt;code&gt;markdown&lt;/code&gt;文件中使用&lt;code&gt;&amp;lt;ClientOnly&amp;gt;&amp;lt;/ClientOnly&amp;gt;&lt;/code&gt;将组件包裹起来。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;ClientOnly&amp;gt;
  &amp;lt;Foo-demo-2/&amp;gt;
&amp;lt;/ClientOnly&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：在markdown文件中如果需要给组件名缩进，不要用&lt;code&gt;tab&lt;/code&gt;键，会被当做&lt;code&gt;markdown&lt;/code&gt;语法解析。&lt;/p&gt;
&lt;p&gt;到这一步，基本上可以在页面中展示自己的组件。下一篇将继续写如何通过vue组件实现跟&lt;a href=&quot;http://element-cn.eleme.io/#/zh-CN/component/icon&quot;&gt;Element&lt;/a&gt;相似的效果。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 15:30:00 +0000</pubDate>
<dc:creator>qfstudy</dc:creator>
<og:description>这篇文章主要是记录自己在使用vuepress过程中所遇到的问题以及如何一步一步的解决问题。 安装vuepress前，请确保你的 Node.js 版本 = 8 全局安装 注意 ： 和`vuepress</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qfstudy/p/10061771.html</dc:identifier>
</item>
<item>
<title>HBase之Table.put客户端流程 - letsfly</title>
<link>http://www.cnblogs.com/letsfly/p/10061630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/letsfly/p/10061630.html</guid>
<description>&lt;p&gt;　　首先，让我们从HTable.put方法开始。由于这一节有很多方法只是简单的参数传递，我就简单略过，但是，关键的方法我还是会截图讲解，所以希望大家尽可能对照源码进行流程分析。另外，在这一节，我单单介绍put操作在客户端的流程，毕竟，这个内容已经很多了。至于具体服务端的流程，我会在后面的章节中介绍到，欢迎大家到时候阅读。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　由于这一节的方法还是比较复杂的，我特地画了一张思维导图，大家可以先通过思维导图来对本节的内容有一个大概的了解，置于具体的流程，我在下面将对照源码的贴图一一为大家讲解(在这里声明一点，我在这一节只介绍单个put操作的流程，至于put批处理，大家有兴趣可以自己研究一下)。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203223950803-1101287935.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;32&quot;&gt;　　首先，让我们来到HTable.put方法，如下图所示：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224019895-640461177.png&quot; alt=&quot;&quot;/&gt;　　这里我先讲一下这一节的最后调用流程，也同时让大家明确一下在本节我着重要讲解的流程是哪块。在上图中我已经表示出来了，后面方法的调用最后调用到了上面新创建的ClientServiceCallable中覆写的rpcCall方法，也就是调用到了ClientServiceCallable.doMutate。关于这个方法中具体与服务端的交互流程在本节我就略过，但是，在后面的内容中，我会谈到类似的情况，如果大家感兴趣的话，可以继续后面的内容。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224034790-1129904396.png&quot; alt=&quot;&quot;/&gt;　　接下来让我们回到本节的重点。首先是RpcRetryingCallerFactory.newCaller方法的调用，该方法使用RpcRetryingCallerFactory的成员参数创建了RpcRetryingCaller，用于后面对于RetryingCallable的调用(该方法在后面也会多次调用，在后面我就不贴图了)。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224054171-625211579.png&quot; alt=&quot;&quot;/&gt;　　接下来让我们来到RpcRetryingCallerImpl.callWithRetries。这个方法是本节中最为重要的方法，在后面也会多次用到。方法虽然比较长，但大多是异常的情况的解决，在本节中我们就单单介绍callable.prepare与callable.call两个方法。至于interceptor.intercept，由于在构造RpcRetryingCallerFactory时默认的interceptor类型为RetryingCallerInterceptorFactory.NO_OP_INTERCEPTOR，在本节并不会有其它影响，所以我们暂时不需要关注。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224129088-1486469391.png&quot; alt=&quot;&quot;/&gt;　　上面的方法调用的callable具体类型为覆写了rpcCall方法的ClientServiceCallable，下面让我们来到ClientServiceCallable类的内部。ClientServiceCallable继承自RegionServerCallable，因此，上面方法实际调用的是RegionServerCallable.prepare与RegionServerCallable.call。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224157918-57704934.png&quot; alt=&quot;&quot;/&gt;　　首先让我们来到RegionServerCallable.prepare方法。这里比较重要的方法我已经框选出来了。需要大家特别留意的是最后的setStubByServiceName，一是因为他比较重要，二是我在后面的内容才会介绍，大家到时候可能忘记了，所以在这里特别提醒一下大家。&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;　　容易看到，首先调用了connection.getRegionLocator获得一个新构建的HRegionLocator(这里就不截图了，因为实在是没有什么内容需要讲)，不过大家需要注意的是，这里的tableName是我们实际要查询到tableName，而后面会用到META_TABLE_NAME，容易混淆，我在这里简单提一下。接下来调用了HRegionLocator.getRegionLocation。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224257809-532710579.png&quot; alt=&quot;&quot;/&gt;　　在调用HRegionLocator.getRegionLocation时，这里会有一系列简单方法的调用，由于在上面的导图中我并没有画出，在这里我就一一贴图描述。&lt;img src=&quot;http://note.youdao.com/src/94CA36BA08FC4267AD31586EA79680B2&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203231418016-2087475422.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203231429823-1258301774.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://note.youdao.com/src/53A742038BB0468A8ABD9A4E49DD0F6F&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224403420-1331295672.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224416637-1068350022.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224425841-1732532478.png&quot; alt=&quot;&quot;/&gt;　　一系列方法走下来，到这里就到了比较重要的方法。由于这个是长图，没有办法框选除重点，我就在文字中一一介绍该方法中调用的比较好重要的方法。&lt;/div&gt;
&lt;p&gt;　　1.getCachedLocation，该方法简介调用到了metaCache.getCachedLocation，但此时，由于我们是第一次调用该表的信息，并没有放到缓存中，因此，这里返回的locations = null。&lt;/p&gt;
&lt;p&gt;　　2.然后我们来到RegionInfo.createRegionName，需要注意的是，其入参row就是我们put操作创建的rowKey，也就是我们常说的行键。另外，在metaStartKey中传入的id为HConstants.NINES(NINES = &quot;99999999999999&quot;)，而在metaStopKey中传入的id为空字符串。&lt;/p&gt;
&lt;p&gt;　　3.接着构造了Scan。其中withStartRow与withStopRow中的inclusive入参都为true。将reversed设置为true，并且将catalog family设置为&quot;info&quot;(CATALOG_FAMILY_STR = &quot;info&quot;)。大家可能注意到了，这里的info列族在我们的表中并不一定存在。到了这里，大家可能就猜到我在前面埋的伏笔了。没错，这里构建的Scan是为了后面的查询后面的META_TABLE_NAME做准备。&lt;/p&gt;
&lt;p&gt;　　4.紧接着来到fro循环中，这里连着调用了两次getCachedLocation，后面的那次调用加了锁，类似我们在单例设计模式中流程，加锁以确保对象不会重复。&lt;/p&gt;
&lt;p&gt;　　5.然后构建了ReversedClientScanner对象。(鉴于之前经验，贴太多图容易扰乱大家的思维，我在这里尽量用文字来介绍)。ReversedClientScanner是ClientScanner的子类，另外，大家需要注意的是，在构造ReversedClientScanner时传入的tableName为TableName.META_TABLE_NAME。在ReversedClientScanner的构造过程中，虽然有一些需要注意的地方，不过，我还是放在后面来描述，以便大家能够更好的理解整个流程。&lt;/p&gt;
&lt;p&gt;　　6.接下来调用了ReversedClientScanner.next，大家千万不要小看这个方法，这个方法里面的一系列调用时非常复杂的，也是本节的另外一个重点，我将在后面详细介绍。&lt;/p&gt;
&lt;p&gt;　　7.然后调用了MetaTableAccessor.getRegionLocations，其入参为ReversedClientScanner.next的返回值。这个方法的详细流程也比较重要，同样，我放到后面为大家讲解。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　8.最后调用了cacheLocation，也就是将当前tableName放到缓存中。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224538615-1525187294.png&quot; alt=&quot;&quot;/&gt;　　上面，我将ConnectionImplementation.locateRegionInMeta方法中调用的各个流程都简单介绍了一下，下面，我就选择其中比较重要的方法来详细描述。&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;　　首先让我们来到ReversedClientScanner.next。这个方法调用了ClientScanner.nextWithSyncCache,如下图所示：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224610676-765780531.png&quot; alt=&quot;&quot;/&gt;　　上图框选的两个方法都比较重要，让我们首先介绍比较复杂的loadCache，如下图所示。&lt;/div&gt;
&lt;p&gt;　　看到这个方法大家可能比较慌，没有关系，我会在这里为大家一一介绍。&lt;/p&gt;
&lt;p&gt;　　1.首先调用了moveToNextRegion。该方法首先调用closeScanner(其间首先调用了成员变量callable.setClose方法，然后调用了ClientScanner.call方法，这个方法我在后面也会提到，最后将当前成员变量callable中的值置为null，简而言之，将成员变量callable.setClose置为null)。&lt;/p&gt;
&lt;p&gt;　　然后构造了ScannerCallableWithReplicas并赋给成员变量callable。在构造ScannerCallableWithReplicas时需要注意的是其中创建了ReversedScannerCallable。也就是说ScannerCallableWithReplicas的成员变量currentScannerCallable为ReversedScannerCallable。顺便提一下，ScannerCallableWithReplicas的成员变量scan为我们在上面构造的scan。&lt;/p&gt;
&lt;p&gt;　　2.接着调用了ClientScanner.call方法。这里的调用流程比较繁琐。为了更清楚的解释清楚loadCache方法，我们先跳过这里，假设其中已经有了返回值。&lt;/p&gt;
&lt;p&gt;　　3.然后调用了scanResultCache.addAndGet。简单提示一下我们这里的scanResultCache类型为CompleteScanResultCache。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;　　4.然后将结果集中的内容遍历放到成员变量cache中。这里我们可以回过头来看看上面的图。上面图中我框选了cache.poll方法。也就是说cache.poll将在loadCache方法中放入的结果集取出来。&lt;img src=&quot;http://note.youdao.com/src/0F085604DFDD4EEF89BDE26E09D08B63&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224717171-546006533.png&quot; alt=&quot;&quot;/&gt;　　上面我提到过很多次ClientScanner.call方法，但是都没有详细描述，下面我就特意来讲解该方法。其实这个方法很简单，只是调用了方法RpcRetryingCaller.callWithoutRetries。这里的caller是在ReversedClientScanner方法构造时创建的(上面只是提到说构造ReversedClientScanner有需要注意的地方，也就是这里，其截图我在上面也已经贴出来了)。&lt;img src=&quot;http://note.youdao.com/src/F6FF2FC5407B4A208FEDE51BB77813A9&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224757376-1716304435.png&quot; alt=&quot;&quot;/&gt;　　接下来让我们来到RpcRetryingCallerImpl.callWithoutRetries。这里的入参callable我在上面的方法loadCache已经介绍过了。其类型为ScannerCallableWithReplicas。由于ScannerCallableWithReplicas.prepare方法为空实现，我在这里就不贴图了，接下来将重点放在ScannerCallableWithReplicas.call。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224828696-550428629.png&quot; alt=&quot;&quot;/&gt;　　让我们来到ScannerCallableWithReplicas.call，如下图所示。&lt;/div&gt;
&lt;p&gt;　　1.在ClientScanner.closeScanner方法调用时，会走上面的if判断。由于currentScannerCallable.closed的值为true。&lt;/p&gt;
&lt;p&gt;　　2.由于默认的成员变量regionReplication，因此会调用RpcRetryingCallerWithReadReplicas.getRegionLocations。这个方法的调用与我们今天的主要流程并没有什么太多的联系，因此，在这里简单略过。该方法我可能会放在后面的章节中讲到。&lt;/p&gt;
&lt;p&gt;　　3.构造了ResultBoundedCompletionService。这个方法比较重要，在后面的流程中我会反复讲到。&lt;/p&gt;
&lt;p&gt;　　4.调用了addCallsForCurrentReplica，将成员变量currentScannerCallable封装到ScannerCallableWithReplicas.RetryingRPC中，并交由ResultBoundedCompletionService提交。&lt;/p&gt;
&lt;p&gt;　　5.接着调用cs.poll，获取其提交的任务的返回值。&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;　　后面我将详细讲解。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224901015-1309029398.png&quot; alt=&quot;&quot;/&gt;　　首先来到ScannerCallableWithReplicas.addCallsForCurrentReplica方法。容易看到，将成员变量currentScannerCallable封装到RetryingRPC中。然后调用了ResultBoundedCompletionService.submit。这里着重提醒一下大家，这里的currentScannerCallable类型为ReversedScannerCallable。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224928973-1289213065.png&quot; alt=&quot;&quot;/&gt;　　接着让我们来到ResultBoundedCompletionService.submit，如下图所示。&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;　　这里将传入的RetryingRPC封装到QueueingFuture，然后调用了executor.execute。由于QueueingFuture继承自java.util.concurrent.RunnableFuture，也就是在调用executor.execute时，QueueingFuture.run方法会执行。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203224941997-158799681.png&quot; alt=&quot;&quot;/&gt;　　接下来让我们来到QueueingFuture。在下图中，我框选出了其中比较重要的方法。&lt;/div&gt;
&lt;div readability=&quot;20&quot;&gt;　　首先这里调用了RpcRetryingCallerImpl.callWithRetries方法(由于这个方法我在上面已经提到过了，因此在这里就不贴图了)。重要的是其中的入参future类型为ScannerCallableWithReplicas.RetryingRPC。另外后面将当前QueueingFuture添加到ResultBoundedCompletionService成员变量completedTasks中。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225007616-1710167860.png&quot; alt=&quot;&quot;/&gt;　　让我们来到ScannerCallableWithReplicas.RetryingRPC.prepare方法。如下图所示。大家可能对这里的成员变量callable比较模糊了，大家可以往上翻到方法addCallsForCurrentReplica的描述，没错这里的callable就是ScannerCallableWithReplicas的成员变量currentScannerCallable。而ScannerCallableWithReplicas.currentScannerCallable正是在构造ScannerCallableWithReplicas时传入的ReversedScannerCallable。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225022875-2006983984.png&quot; alt=&quot;&quot;/&gt;　　接下来让我们来到ReversedScannerCallable.prepare。由于这是第一次调用prepare方法，因此其成员变量instantiated为false。这里简单提一下，这里的getRow方法获取的是我们调用put时的行键，也就是我们对于目标表的rowKey。由于这里的tableName为TableName.META_TABLE_NAME，其rowKey在后面并没有用到。&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;　　然后调用了ReversedScannerCallable.setStub方法。为成员变量stub的赋值。其值为getConnection().getClient(getLocation().getServerName())调用的返回值。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225051208-1896079319.png&quot; alt=&quot;&quot;/&gt;　　让我们来到ConnectionImplementation.getClient方法。看过我博文《HBase之HRegionServer启动（含与HMaster交互）》的同学看到这里可能就比较熟悉。 没错，这里正是通过ClientProtos.ClientService.newBlockingStub构造了协议ClientProtos.ClientService的客户端stub。关于与服务端交互的流程，我在《HBase之HRegionServer启动（含与HMaster交互）》中已经具体介绍了，大家感兴趣的可以去看一下，我们这里来描述比较重要一个点。&lt;/div&gt;
&lt;div readability=&quot;16&quot;&gt;　　就是computeIfAbsentEx的最后一个入参IOExceptionSupplier。他类似于java中的Supplier(类似的方法调用我在后面讲解方法MetaTableAccessor.getRegionLocations)。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225131640-135451287.png&quot; alt=&quot;&quot;/&gt;　　在第一次调用时，我们的stubs中并没有到该serverName的客户端stub，因此调用了入参supplier的get方法。也就是我们上面看到的lambda表达式方法内容被调用。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225317162-1204654681.png&quot; alt=&quot;&quot;/&gt;　　到这里，ReversedScannerCallable.prepare方法就调用完成了。这个还有一个需要注意的点就是ReversedScannerCallable.prepare方法的最后将其成员变量instantiated置为true。&lt;/div&gt;
&lt;p&gt;　　接下来让我们来到ScannerCallableWithReplicas.RetryingRPC.call方法(这里的callable类型为ReversedScannerCallable)。&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;　　这里再次调用了RpcRetryingCallerImpl.callWithRetries，由于ReversedScannerCallable.prepare方法已经调用，并且其成员变量instantiated被置为true，所以上面描述的内容并不会再次调用(这里框选的内容作为后面的伏笔)。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225334687-1668361278.png&quot; alt=&quot;&quot;/&gt;　　也就是说，接下来应该调用的是ReversedScannerCallable.call。由于其并没有call方法，因此，会一直调用到其父类RegionServerCallable.call。如下图所示。这里的rpcController类型为HBaseRpcControllerImpl。接下来调用了rpcCall方法。由于ReversedScannerCallable中并没有rpcCall方法的实现，而在其父类ScannerCallable有实现rpcCall。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225404092-1046665400.png&quot; alt=&quot;&quot;/&gt;　　接下来，让我们来到ScannerCallable.rpcCall。由于默认的成员变量scannerId为-1，因此，会调用openScanner。由于openScanner方法仅仅是通过Client协议发送到服务端。关于rpc流程我在博客《hbase之RPC调用流程简介》中已经介绍过了，感兴趣的同学可以去看一下，那篇博文讲的比较浅显，我会在春节期间将那篇内容更新，大家可以关注我，到时候有更新大家也就收到通知了。&lt;/div&gt;
&lt;div readability=&quot;18&quot;&gt;　　然后调用了ResponseConverter.getResults，将服务端的返回的ScanResponse转换为Result。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225432643-2131577349.png&quot; alt=&quot;&quot;/&gt;　　让我们来到ResponseConverter.getResults。这个方法的主要作用是将CellScanner中Cell的或ScanResponse中的PB类型的results转换为java类型的Result。至于该方法的详细描述我要放到后面开设的第二章节，也就是HBase中客户端协议各个操作中来讲解，因为这里流程是比较复杂的，要结合上服务端的流程才能讲述清楚。所以这里暂时略过。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225451772-543711710.png&quot; alt=&quot;&quot;/&gt;　　到这里，一个完整的RpcRetryingCallerImpl.callWithRetries方法调用流程可以说是完结了。然后在ResultBoundedCompletionService.QueueingFuture.run方法的后面，将当前QueueingFuture添加到ResultBoundedCompletionService成员变量completedTasks中(虽然我在上面提到过，但这里还是重述一下，以便我们后面的理解)。&lt;/div&gt;
&lt;p&gt;　　而在我们本节描述的整体流程中，ScannerCallableWithReplicas.addCallsForCurrentReplica方法调用完结。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;　　接下来让我们来到ResultBoundedCompletionService.poll，由于其间接调用了ResultBoundedCompletionService.pollForSpecificCompletedTask，如下图所由于在QueueingFuture.run方法的最后，将自身添加到了completedTasks。因此，上面的方法获取的正是刚刚添加的QueueingFuture。接着调用了ResultBoundedCompletionService.QueueingFuture.get方法。如下图所示。也就是说，这里将result返回。这里result的类型我们需要注意一下，以便后面在类型上面的理解。由于这里QueueingFuture成员变量future的实际类型为ScannerCallableWithReplicas.RetryingRPC。大家可以往上翻到ScannerCallableWithReplicas.RetryingRPC.call，就可以发现，这里的result是从ResponseConverter.getResults获得的Result数组与成员变量callable封装后的Pair对象。接着，将r.getFirst()，也就是实际获得的结果返回。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201812/1365945-20181203225529787-1221293209.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　到这里，大家可能以为要结束了，很遗憾，这里只是到了ClientScanner.call方法的返回。&lt;/p&gt;
&lt;p&gt;　　由于接下来的是两个单独的流程了。一个是MetaTableAccessor.getRegionLocations，另外一个是ConnectionImplementation.cacheLocation。至于这两个流程之外的后续流程比较简单，我就不一一叙述了，相信大家跟着源码与我在前面的提示很容易就可以弄清楚了。而前面提到的那两个单独的流程我将放在后面的一节《HBase之Table.put客户端流程(续)》中介绍。到时候欢迎大家阅读。&lt;/p&gt;
&lt;p&gt;　　大家可以关注我的博客，或者发送邮件到我的邮箱15935152719@163.com来沟通交流大数据相关的知识。感谢大家的阅读，如果觉得不错，希望您可以点击下面的推荐。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 15:23:00 +0000</pubDate>
<dc:creator>letsfly</dc:creator>
<og:description>首先，让我们从HTable.put方法开始。由于这一节有很多方法只是简单的参数传递，我就简单略过，但是，关键的方法我还是会截图讲解，所以希望大家尽可能对照源码进行流程分析。另外，在这一节，我单单介绍p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/letsfly/p/10061630.html</dc:identifier>
</item>
<item>
<title>tomcat整体架构 - xuanm</title>
<link>http://www.cnblogs.com/grasp/p/10061742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grasp/p/10061742.html</guid>
<description>&lt;p&gt;        Tomcat作为JavaWeb领域的Web容器，目前在我们淘宝也使用的也非常广泛，现在基本上所有线上业务系统都是部署在Tomcat上。为了对平时开发的Web系统有更深入的理解以及出于好奇心对我们写的Web系统是如何跑在Tomcat上的，于是仔细研究了下Tomcat的源码。大家都知道Servlet规范是Java领域中为服务端编程制定的规范，对于我们开发者只是关注了Servlet规范中提供的编程组件(ServletContextListener,Filer,Servlet) 等 ，但是规范中还有一些我们经常使用的接口（ServletContext,ServletRequest,ServletResponse,FilterChain）等都是由Tomcat去实现的，并且我们开发者实现的编程组件只是被Tomcat去回调而已。所以看Tomcat源码实现也有助于我们更好的理解Servlet规范及系统如何在容器中运行(一些开源的MVC框架如Struts2,Webx,SpringMVC本质无非就是这个)&lt;/p&gt;

&lt;p&gt;        仔细查看下图（网络上描述Tomcat架构比较清晰的一张图），不难发现其中的Connecotr组件以及与Container组件是Tomcat的核心。一个Server可以有多个Service，而一个Service可以包含了多个Connector组件和一个Engine容器组件，一个Engine可以由多个虚拟主机Host组成，每一个Host下面又可以由多个Web应用Context构成，每一个的Context下面可以包含多个Wrapper（Servlet的包装器）组成。&lt;/p&gt;
&lt;p&gt;       Tomcat将Engine，Host，Context，Wrapper统一抽象成Container。一个抽象的Container模块可以包含各种服务。例如，Manager管理器（Session管理），Pipeline管道（ 维护管道阀门Value ）等。Lifecycle接口统一定义了容器的生命周期，通过事件机制实现各个容器间的内部通讯。而容器的核心接口Container的抽象实现中定义了一个Pipeline，一个Manager，一个Realm以及ClassLoader统一了具体容器的实现规范。连接器（Connector）组件的主要任务是为其所接收到的每一个请求（可以是HTTP协议，也可以AJP协议），委托给具体相关协议的解析类ProtocolHandler，构造出Request 对象和Response 对象。然后将这两个对象传送给容器（Container）进行处理。容器（Container）组件收到来自连接器（Connector）的Request 和Response对象后，负责调用Filter，最后调用Servlet的service 方法（进入我们开发的Web系统中）。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201812/738818-20181203230857843-270403203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.Server组件：Server是最顶级的组件，代表Tomcat的运行实例；包含Listener组件用以监听生命周期中的各种事件；包含GlobalNamingResources组件用以集成JNDI；包含Service组件用以提供服务。&lt;/p&gt;
&lt;p&gt;2.Service组件：Service是服务的抽象，代表请求从接受到处理的所有组件的集合；Server组件可以包含多个Service组件；包含Connector组件用以接收客户端的信息；包含Engine组件用以处理请求；包含Executor用以提供线程池执行任务。&lt;/p&gt;
&lt;p&gt;3.Connector组件：接收客户端连接并接收信息报文，信息报文经由它解析后送往容器中处理；包含Mapper组件对请求地址进行路由；包含CoyoteAdaptor组件用以将Connector组件和Engine等容器组件适配起来；包含Protocol组件用以接收客户端连接、接收客户端信息报文、报文解析处理、对客户端响应等整个过程。&lt;/p&gt;
&lt;p&gt;4.Protocol组件：包含JioEndPoint组件，其中的Acceptor组件将启动某个端口的监听，将监听到的请求放入线程池Executor组件，其中的Processor组件对HTTP协议解析并传递到Engine容器继续处理；NIO模式下NioEndPoint多了一个Poller组件轮询多个客户端连接处理事件。&lt;/p&gt;
&lt;p&gt;Engine组件：代表全局Servlet引擎；每个Service组件只能包含一个Engine容器组件；包含Listener组件用以在生命周期中对Engine相关的事件进行监听；包含AccessLog组件以记录访问日志；包含Cluster组件以提供集群功能，将需要共享的数据同步到集群中的其他Tomcat实例中；包含Pipeline组件用以处理请求；包含Realm组件用以提供安全权限功能。&lt;/p&gt;
&lt;p&gt;5.Host组件：代表虚拟主机；一个Engine组件可以包含若干个Host容器组件；包含Listener组件用以在生命周期中对Host相关的事件进行监听；包含AccessLog组件以记录访问日志；包含Cluster组件以提供集群功能，将需要共享的数据同步到集群中的其他Tomcat实例中；包含Pipeline组件用以处理请求；包含Realm组件用以提供安全权限功能。&lt;/p&gt;
&lt;p&gt;6.Context组件：是Web应用的抽象，Web应用部署到Tomcat后运行时就会转化成Context对象；包含了各种静态资源、若干Servlet（Wrapper容器）以及各种其他动态资源；&lt;/p&gt;
&lt;p&gt;　　包含Listener组件用以在生命周期中对Context相关的事件进行监听；&lt;/p&gt;
&lt;p&gt;　　包含AccessLog组件以记录访问日志；&lt;/p&gt;
&lt;p&gt;　　包含Pipeline组件用以处理请求；&lt;/p&gt;
&lt;p&gt;　　包含Realm组件用以提供安全权限功能；&lt;/p&gt;
&lt;p&gt;　　包含Loader组件用以加载Web应用的资源，保证不同Web应用之间的资源隔离；&lt;/p&gt;
&lt;p&gt;　　包含Manager组件用以管理Web容器的会话，包括维护会话的生成、更新和销毁；&lt;/p&gt;
&lt;p&gt;　　包含NamingResource组件将Tomcat配置文件的server.xml和Web应用的context.xml资源和属性映射到内存中；&lt;/p&gt;
&lt;p&gt;7.Mapper组件用以作为路由映射Servlet。&lt;/p&gt;
&lt;p&gt;8.Wrapper组件：对应的是Servlet；包含Web应用开发常用的Servlet组件；包含ServletPool组件用以存放Servlet对象，当Web应用的Servlet实现了SingleThreadModel接口时则会再Wrapper中产生一个Servlet对象池，线程执行时，需先从对象池中获取到一个Servlet对象，ServletPool组件能保证Servlet对象的线程安全；包含Pipeline组件用以处理请求。&lt;/p&gt;
&lt;p&gt;我们从功能的角度将Tomcat源代码分成5个子模块，它们分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Jsper子模块：这个子模块负责jsp页面的解析、jsp属性的验证，同时也负责将jsp页面动态转换为java代码并编译成class文件。在Tomcat源代码中，凡是属于org.apache.jasper包及其子包中的源代码都属于这个子模块；&lt;/li&gt;
&lt;li&gt;Servlet和Jsp规范的实现模块：这个子模块的源代码属于javax.servlet包及其子包，如我们非常熟悉的javax.servlet.Servlet接口、javax.servet.http.HttpServlet类及javax.servlet.jsp.HttpJspPage就位于这个子模块中；&lt;/li&gt;
&lt;li&gt;Catalina子模块：这个子模块包含了所有以org.apache.catalina开头的java源代码。该子模块的任务是规范了Tomcat的总体架构，定义了Server、Service、Host、Connector、Context、Session及Cluster等关键组件及这些组件的实现，这个子模块大量运用了Composite设计模式。同时也规范了Catalina的启动及停止等事件的执行流程。从代码阅读的角度看，这个子模块应该是我们阅读和学习的重点。&lt;/li&gt;
&lt;li&gt;Connectors子模块：如果说上面三个子模块实现了Tomcat应用服务器的话，那么这个子模块就是Web服务器的实现。所谓连接器(Connector)就是一个连接客户和应用服务器的桥梁，它接收用户的请求，并把用户请求包装成标准的Http请求(包含协议名称，请求头Head，请求方法是Get还是Post等等)。同时，这个子模块还按照标准的Http协议，负责给客户端发送响应页面，比如在请求页面未发现时，connector就会给客户端浏览器发送标准的Http 404错误响应页面。&lt;/li&gt;
&lt;li&gt;Resource子模块：这个子模块包含一些资源文件，如Server.xml及Web.xml配置文件。严格说来，这个子模块不包含java源代码，但是它还是Tomcat编译运行所必需的。&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Mon, 03 Dec 2018 15:22:00 +0000</pubDate>
<dc:creator>xuanm</dc:creator>
<og:description>1.背景 Tomcat作为JavaWeb领域的Web容器，目前在我们淘宝也使用的也非常广泛，现在基本上所有线上业务系统都是部署在Tomcat上。为了对平时开发的Web系统有更深入的理解以及出于好奇心对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/grasp/p/10061742.html</dc:identifier>
</item>
<item>
<title>Vue源码解析之数组变异 - 格子熊</title>
<link>http://www.cnblogs.com/karthuslorin/p/10045326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/karthuslorin/p/10045326.html</guid>
<description>&lt;h3 id=&quot;力有不逮的对象&quot;&gt;力有不逮的对象&lt;/h3&gt;
&lt;p&gt;众所周知，在 &lt;code&gt;Vue&lt;/code&gt; 中，直接修改对象属性的值无法触发响应式。当你直接修改了对象属性的值，你会发现，只有数据改了，但是页面内容并没有改变。&lt;/p&gt;
&lt;p&gt;这是什么原因？&lt;/p&gt;
&lt;p&gt;原因在于： &lt;code&gt;Vue&lt;/code&gt; 的响应式系统是基于&lt;code&gt;Object.defineProperty&lt;/code&gt;这个方法的，该方法可以监听对象中某个元素的获取或修改，经过了该方法处理的数据，我们称其为响应式数据。但是，该方法有一个很大的缺点，新增属性或者删除属性不会触发监听，举个栗子：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var vm = new Vue({
    data () {
        return {
            obj: {
                a: 1
            }
        }
    }
})
// `vm.obj.a` 现在是响应式的

vm.obj.b = 2
// `vm.obj.b` 不是响应式的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因在于，在 &lt;code&gt;Vue&lt;/code&gt; 初始化的时候， &lt;code&gt;Vue&lt;/code&gt; 内部会对 &lt;code&gt;data&lt;/code&gt; 方法的返回值进行深度响应式处理，使其变为响应式数据，所以， &lt;code&gt;vm.obj.a&lt;/code&gt; 是响应式的。但是，之后设置的 &lt;code&gt;vm.obj.b&lt;/code&gt; 并没有经过 &lt;code&gt;Vue&lt;/code&gt; 初始化时响应式的洗礼，所以，理所应当的不是响应式。&lt;/p&gt;
&lt;p&gt;那么，&lt;code&gt;vm.obj.b&lt;/code&gt;可以变成响应式吗？当然可以，通过 &lt;code&gt;vm.$set&lt;/code&gt; 方法就可以完美地实现要求，在此不再赘述相关原理了，之后应该会写一篇文章讲述 &lt;code&gt;vm.$set&lt;/code&gt; 背后的原理。&lt;/p&gt;
&lt;h3 id=&quot;更凄惨的数组&quot;&gt;更凄惨的数组&lt;/h3&gt;
&lt;p&gt;上面说了这么多，还没有提到本篇文章的主角——数组，现在该主角出场了。&lt;/p&gt;
&lt;p&gt;比起对象，数组的境遇更加凄惨一些，看看官方文档：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;由于 JavaScript 的限制， &lt;code&gt;Vue&lt;/code&gt; 不能检测以下变动的数组：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当你利用索引直接设置一个项时，例如：&lt;code&gt;vm.items[indexOfItem] = newValue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当你修改数组的长度时，例如：&lt;code&gt;vm.items.length = newLength&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;有可能官方文档不是很清晰，那我们继续举个栗子：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var vm = new Vue({
    data () {
        return {
            items: ['a', 'b', 'c']
        }
    }
})
vm.items[1] = 'x' // 不是响应性的
vm.items.length = 2 // 不是响应性的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，数组连自身元素的修改也无法监听，原因在于， &lt;code&gt;Vue&lt;/code&gt; 对 &lt;code&gt;data&lt;/code&gt; 方法返回的对象中的元素进行响应式处理时，如果元素是数组时，仅仅对数组本身进行响应式化，而不对数组内部元素进行响应式化。&lt;/p&gt;
&lt;p&gt;这也就导致如官方文档所写的后果，无法直接修改数组内部元素来触发响应式。&lt;/p&gt;
&lt;p&gt;那么，有没有破解方法呢？&lt;/p&gt;
&lt;p&gt;当然有，官方规定了 7 个数组方法，通过这 7 个数组方法，可以很开心地触发数组的响应式，这 7 个数组方法分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;push()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shift()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unshift()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;splice()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sort()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reverse()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以发现，这 7 个数组方法貌似就是原生的那些数组方法，为什么这 7 个数组方法可以触发应式，触发视图更新呢？&lt;/p&gt;
&lt;p&gt;你是不是心里想着：数组方法了不起呀，数组方法就可以为所欲为啊？&lt;/p&gt;
&lt;p&gt;骚瑞啊，这 7 个数组方法是真的可以为所欲为的。&lt;/p&gt;
&lt;p&gt;因为，它们是变异后的数组方法。&lt;/p&gt;
&lt;h3 id=&quot;数组变异思路&quot;&gt;数组变异思路&lt;/h3&gt;
&lt;p&gt;什么是变异数组方法？&lt;/p&gt;
&lt;p&gt;变异数组方法即保持数组方法原有功能不变的前提下对其进行功能拓展，在 &lt;code&gt;Vue&lt;/code&gt; 中这个所谓的功能拓展就是添加响应式功能。&lt;/p&gt;
&lt;p&gt;将普通的数组变为变异数组的方法分为两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;功能拓展&lt;/li&gt;
&lt;li&gt;数组劫持&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;功能拓展&quot;&gt;功能拓展&lt;/h4&gt;
&lt;p&gt;先来个思考题：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有这样一个需求，要求在不改变原有函数功能以及调用方式的情况下，使得每次调用该函数都能在控制台中打印出'HelloWorld'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实思路很简单，分为三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用新的变量缓存原函数&lt;/li&gt;
&lt;li&gt;重新定义原函数&lt;/li&gt;
&lt;li&gt;在新定义的函数中调用原函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看看具体的代码实现：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function A () {
    console.log('调用了函数A')
}

const nativeA = A
A = function () {
    console.log('HelloWorld')
    nativeA()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，通过这种方式，我们就保证了在不改变 &lt;code&gt;A&lt;/code&gt; 函数行为的前提下对其进行了功能拓展。&lt;/p&gt;
&lt;p&gt;接下来，我们使用这种方法对数组原本方法进行功能拓展：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 变异方法名称
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

const arrayProto = Array.prototype
// 继承原有数组的方法
const arrayMethods = Object.create(arrayProto)

mutationMethods.forEach(method =&amp;gt; {
    // 缓存原生数组方法
    const original = arrayProto[method]
    arrayMethods[method] = function (...args) {
        const result = original.apply(this, args)
        
        console.log('执行响应式功能')
        
        return result
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中可以看出来，我们调用 &lt;code&gt;arrayMethods&lt;/code&gt; 这个对象中的方法有两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用功能拓展方法：直接调用 &lt;code&gt;arrayMethods&lt;/code&gt; 中的方法&lt;/li&gt;
&lt;li&gt;调用原生方法：这种情况下，通过原型链查找定义在数组原型中的原生方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过上述方法，我们实现了对数组原生方法进行功能的拓展，但是，有一个巨大的问题摆在面前：我们该如何让数组实例调用功能拓展后数组方法呢？&lt;/p&gt;
&lt;p&gt;解决这一问题的方法就是：数组劫持。&lt;/p&gt;
&lt;h4 id=&quot;数组劫持&quot;&gt;数组劫持&lt;/h4&gt;
&lt;p&gt;数组劫持，顾名思义就是将原本数组实例要继承的方法替换成我们功能拓展后的方法。&lt;/p&gt;
&lt;p&gt;想一想，我们在前面实现了一个功能拓展后的数组 &lt;code&gt;arrayMethods&lt;/code&gt; ，这个自定义的数组继承自数组对象，我们只需要将其和普通数组实例连接起来，让普通数组继承于它即可。&lt;/p&gt;
&lt;p&gt;而想实现上述操作，就是通过原型链。&lt;/p&gt;
&lt;p&gt;实现方法如下代码所示：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let arr = []
// 通过隐式原型继承arrayMethods
arr.__proto__ = arrayMethods

// 执行变异后方法
arr.push(1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过功能拓展和数组劫持，我们终于实现了变异数组，接下来让我们看看 &lt;code&gt;Vue&lt;/code&gt; 源码是如何实现变异数组的。&lt;/p&gt;
&lt;h3 id=&quot;源码解析&quot;&gt;源码解析&lt;/h3&gt;
&lt;p&gt;我们来到 &lt;code&gt;src/core/observer/index.js&lt;/code&gt; 中在 &lt;code&gt;Observer&lt;/code&gt; 类中的 &lt;code&gt;constructor&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    // 检测是否是数组
    if (Array.isArray(value)) {
        // 能力检测
        const augment = hasProto
        ? protoAugment
        : copyAugment
        // 通过能力检测的结果选择不同方式进行数组劫持
        augment(value, arrayMethods, arrayKeys)
        // 对数组的响应式处理
        this.observeArray(value)
    } else {
        this.walk(value)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Observer&lt;/code&gt; 这个类是 &lt;code&gt;Vue&lt;/code&gt; 响应式系统的核心组成部分，在初始化阶段最主要的功能是将目标对象进行响应式化。在这里，我们主要关注其对数组的处理。&lt;/p&gt;
&lt;p&gt;其对数组的处理主要是以下代码&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 能力检测
const augment = hasProto
? protoAugment
: copyAugment
// 通过能力检测的结果选择不同方式进行数组劫持
augment(value, arrayMethods, arrayKeys)
// 对数组的响应式处理，很本文关系不大，略过
this.observeArray(value)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先定义了 &lt;code&gt;augment&lt;/code&gt; 常量，这个常量的值由 &lt;code&gt;hasProto&lt;/code&gt; 决定。&lt;/p&gt;
&lt;p&gt;我们来看看 &lt;code&gt;hasProto&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export const hasProto = '__proto__' in {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现， &lt;code&gt;hasProto&lt;/code&gt; 其实就是一个布尔值常量，用来表示浏览器是否支持直接使用 &lt;code&gt;__proto__&lt;/code&gt; （隐式原型） 。&lt;/p&gt;
&lt;p&gt;所以，第一段代码很好理解：根据根据能力检测结果选择不同的数组劫持方法，如果浏览器支持隐式原型，则调用 &lt;code&gt;protoAugment&lt;/code&gt; 函数作为数组劫持的方法，反之则使用 &lt;code&gt;copyAugment&lt;/code&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;不同的数组劫持方法&quot;&gt;不同的数组劫持方法&lt;/h4&gt;
&lt;p&gt;现在我们来看看 &lt;code&gt;protoAugment&lt;/code&gt; 以及 &lt;code&gt;copyAugment&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function protoAugment (target, src: Object, keys: any) {
  /* eslint-disable no-proto */
  target.__proto__ = src
  /* eslint-enable no-proto */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到， &lt;code&gt;protoAugment&lt;/code&gt; 函数极其简洁，和在数组变异思路中所说的方法一致：将数组实例直接通过隐式原型与变异数组连接起来，通过这种方式继承变异数组中的方法。&lt;/p&gt;
&lt;p&gt;接下来我们再看看 &lt;code&gt;copyAugment&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function copyAugment (target: Object, src: Object, keys: Array&amp;lt;string&amp;gt;) {
  for (let i = 0, l = keys.length; i &amp;lt; l; i++) {
    const key = keys[i]
    // Object.defineProperty的封装
    def(target, key, src[key])
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于在这种情况下，浏览器不支持直接使用隐式原型，所以数组劫持方法要麻烦很多。我们知道该函数接收的第一个参数是数组实例，第二个参数是变异数组，那么第三个参数是什么？&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 获取变异数组中所有自身属性的属性名
const arrayKeys = Object.getOwnPropertyNames(arrayMethods)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;arrayKeys&lt;/code&gt; 在该文件的开头就定义了，即变异数组中的所有自身属性的属性名，是一个数组。&lt;/p&gt;
&lt;p&gt;回头再看 &lt;code&gt;copyAugment&lt;/code&gt; 函数就很清晰了，将所有变异数组中的方法，直接定义在数组实例本身，相当于变相的实现了数组的劫持。&lt;/p&gt;
&lt;p&gt;实现了数组劫持后，我们再来看看 &lt;code&gt;Vue&lt;/code&gt; 中是怎样实现数组的功能拓展的。&lt;/p&gt;
&lt;h4 id=&quot;功能拓展-1&quot;&gt;功能拓展&lt;/h4&gt;
&lt;p&gt;数组功能拓展的代码位于 &lt;code&gt;src/core/observer/array.js&lt;/code&gt; ，代码如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import { def } from '../util/index'

// 缓存数组原型
const arrayProto = Array.prototype
// 实现 arrayMethods.__proto__ === Array.prototype
export const arrayMethods = Object.create(arrayProto)

// 需要进行功能拓展的方法
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  // 缓存原生数组方法
  const original = arrayProto[method]
  // 在变异数组中定义功能拓展方法
  def(arrayMethods, method, function mutator (...args) {
    // 执行并缓存原生数组方法的执行结果
    const result = original.apply(this, args)
    // 响应式处理
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    if (inserted) ob.observeArray(inserted)
    // notify change
    ob.dep.notify()
    // 返回原生数组方法的执行结果
    return result
  })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，源码在实现的方式上，和我在数组变异思路中采用的方法一致，只不过在其中添加了响应式的处理。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Vue&lt;/code&gt; 的变异数组从本质上是来说是一种装饰器模式，通过学习它的原理，我们在实际工作中可以轻松处理这类保持原有功能不变的前提下对其进行功能拓展的需求。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 15:05:00 +0000</pubDate>
<dc:creator>格子熊</dc:creator>
<og:description>力有不逮的对象 众所周知，在 中，直接修改对象属性的值无法触发响应式。当你直接修改了对象属性的值，你会发现，只有数据改了，但是页面内容并没有改变。 这是什么原因？ 原因在于： 的响应式系统是基于 这个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/karthuslorin/p/10045326.html</dc:identifier>
</item>
<item>
<title>PEP 492 -- Coroutines with async and await syntax 翻译 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/10024264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/10024264.html</guid>
<description>&lt;p&gt;因为工作中慢慢开始用python的协程，所以想更好的理解一下实现方式，故翻译此文&lt;/p&gt;
&lt;p&gt;原文中把词汇表放到最后，但是我个人觉得放在最开始比较好，这样可以增加当你看原文时的理解程度&lt;/p&gt;
&lt;h2&gt;词汇表&lt;/h2&gt;
&lt;p&gt;原生协程函数 Native coroutine function：&lt;/p&gt;
&lt;p&gt;由async def定义的协程函数，可以使用await和return value语句&lt;/p&gt;

&lt;p&gt;原生协程 Native coroutine：&lt;/p&gt;
&lt;p&gt;原生协程函数返回的对象。见“await表达式”一节。&lt;/p&gt;

&lt;p&gt;基于生成器的协程函数 Generator-based coroutine function：&lt;/p&gt;
&lt;p&gt;基于生成器语法的协程，最常见的是用 @asyncio.coroutine装饰过的函数。&lt;/p&gt;

&lt;p&gt;基于生成器的协程 Generator-based coroutine：&lt;/p&gt;
&lt;p&gt;基于生成器的协程函数返回的对象。&lt;/p&gt;

&lt;p&gt;协程 Coroutine：&lt;/p&gt;
&lt;p&gt;“原生协程”和“基于生成器的协程”都是协程。&lt;/p&gt;

&lt;p&gt;协程对象 Coroutine object：&lt;/p&gt;
&lt;p&gt;“原生协程对象”和“基于生成器的协程对象”都是协程对象。&lt;/p&gt;

&lt;p&gt;Future-like对象 Future-like object：&lt;/p&gt;
&lt;p&gt;一个有__await__方法的对象，或一个有tp_as_async-&amp;gt;am_await函数的C语言对象，它们返回一个迭代器。Future-like对象可以在协程里被一条await语句消费（consume）。协程会被await语句挂起，直到await语句右边的Future-like对象的__await__执行完毕、返回结果。见“await表达式”一节。&lt;/p&gt;

&lt;p&gt;Awaitable&lt;/p&gt;
&lt;p&gt;一个Future-like对象或一个协程对象。见“await表达式”一节。&lt;/p&gt;

&lt;p&gt;异步上下文管理器 Asynchronous context manager：&lt;/p&gt;
&lt;p&gt;有__aenter__和__aexit__方法的对象，可以被async with语句使用。见“异步上下文管理器和‘async with’”一节。&lt;/p&gt;

&lt;p&gt;可异步迭代对象 Asynchronous iterable：&lt;/p&gt;
&lt;p&gt;有__aiter__方法的对象， 该方法返回一个异步迭代器对象。可以被async for语句使用。见“异步迭代器和‘async for’”一节。&lt;/p&gt;

&lt;p&gt;异步迭代器 Asynchronous iterator：&lt;/p&gt;
&lt;p&gt;有__anext__方法的对象。见“异步迭代器和‘async for’”一节。&lt;/p&gt;
&lt;h2&gt;摘要&lt;/h2&gt;
&lt;p&gt;随着互联网和连接程序的增长，引发了对响应性和可扩展代码的需求，该提议的目标是让我们共容易的通过编写显示异步，高并发的python代码并且更加Pythonic&lt;/p&gt;
&lt;p&gt;它提出把写成的概念独立出来，并引入新的支持语法。最终的目标是帮助在python中建立一个通用的，易于接近的异步编程构思模型，并使其尽可能接近于同步编程(&lt;span&gt;说白了就是让你通过类似写同步编程的方式，写出异步代码&lt;/span&gt;)&lt;/p&gt;

&lt;p&gt;这个PEPE建设异步任务是类似于标准模块asyncio.events.AbstractEventLoop的事件循环调度和协调。虽然这个PEP不依赖人去特定的时间循环实现，但它仅仅与使用yield作为调度程序信号的协程类型相关，表示协程将等待知道事件(例如:IO)完成&lt;/p&gt;
&lt;p&gt;我们相信，这里提出的更改将有助于python在快速增长的异步编程领域保持更好的竞争力，因为许多其他语言已经采或将要采用类似的功能&lt;/p&gt;
&lt;h2&gt;API设计和实施修订&lt;/h2&gt;
&lt;p&gt;对Python 3.5的初始beta版本的反馈导致重新设计支持此PEP的对象模型，以更清楚地将原生协程与生成器分离 - 而不是一种新的生成器，现在原生协程有明确的独立类型&lt;/p&gt;
&lt;p&gt;这个改变主要是为了解决原生协程在tornado里使用出现的一些问题&lt;/p&gt;

&lt;p&gt;在CPython3.5.2 中更新了__aiter__ 协议。&lt;/p&gt;
&lt;p&gt;在3.5.2之前，__aiter__ 是被期望返回一个等待解析为异步迭代器，从3.5.2开始，__aiter__ 应该直接返回异步迭代器&lt;/p&gt;
&lt;p&gt;如果在3.5.2中使用旧协议中，Python将引发PendingDeprecationWarning异常&lt;/p&gt;
&lt;p&gt;在CPython 3.6中，旧的__aiter__协议仍将受到引发DeprecationWarning的支持&lt;/p&gt;
&lt;p&gt;在CPython 3.7中，将不再支持旧的__aiter__协议：如果__aiter__返回除异步迭代器之外的任何内容，则将引发RuntimeError。&lt;/p&gt;

&lt;h2&gt;理论和目标&lt;/h2&gt;
&lt;p&gt;当前的Python支持通过生成器（PEP342）实现协程，并通过PEP380中引入的yield from 语法进一步增强，这种方法有很多缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;协程序与生成器具有相同的语法，很容易混淆，对于初级开发者来说尤其如此。&lt;/li&gt;
&lt;li&gt;一个函数是否是一个协程，取决于它里面是否出现了yield或yield from语句。这并不明显，容易在重构函数的时候搞乱，导致出错。&lt;/li&gt;
&lt;li&gt;异步调用被yield语法限制了，我们不能获得、使用更多的语法特性，比如with和for。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个PEP把协程从生成器独立出来，成为Python的一个原生事物。这会消除协程和生成器之间的混淆，方便编写不依赖特定库的协程代码。也为linter和IDE进行代码静态分析提供了机会。&lt;/p&gt;
&lt;p&gt;使用原生协程和相应的新语法，我们可以在异步编程时使用上下文管理器（context manager）和迭代器。如下文所示，新的async with语句可以在进入、离开运行上下文（runtime context）时进行异步调用，而async for语句可以在迭代时进行异步调用。&lt;/p&gt;

&lt;h2&gt;规范&lt;/h2&gt;
&lt;p&gt;该提议引入了新的语法和语义来增强Python对协程支持。&lt;/p&gt;
&lt;p&gt;请理解Python现有的协程（见PEP 342和PEP 380），这次改变的动机来自于asyncio框架（PEP 3156）和Confunctions提案（PEP 3152，此PEP已经被废弃）。&lt;/p&gt;
&lt;p&gt;由此，在本文中，我们使用“原生协程”指用新语法声明的协程。“生成器实现的协程”指用传统方法实现的协程。“协程”则用在两个都可以使用的地方。&lt;/p&gt;
&lt;h3 id=&quot;新的协程声明语法&quot;&gt;新的协程声明语法&lt;/h3&gt;
&lt;p&gt;使用以下语法声明原生协程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_data(db):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;协程语法的关键点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;async def函数必定是协程，即使里面不含有await语句。&lt;/li&gt;
&lt;li&gt;如果在async函数里面使用yield或yield from语句，会引发SyntaxError异常。&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;在CPython内部，引入两个新的代码对象标识（code object flags）：&lt;br/&gt;CO_COROUTINE表示这是原生协程。（由新语法定义）&lt;br/&gt;CO_ITERABLE_COROUTINE表示这是用生成器实现的协程，但是和原生协程兼容。（用装饰器types.coroutine()装饰过的生成器协程）&lt;/li&gt;
&lt;li&gt;调用一个普通生成器，返回一个生成器对象（generator object）；相应的，调用一个协程返回一个协程对象（coroutine object&lt;/li&gt;
&lt;li&gt;协程不再抛出StopIteration异常，因为抛出的StopIteration异常会被包装（wrap）成一个RuntimeError异常。对于普通的生成器想要这样需要进行future import&lt;/li&gt;
&lt;li&gt;如果一个协程从未await等待就被垃圾收集器销毁了，会引发一个RuntimeWarning异常&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;types.coroutine()&lt;/h3&gt;
&lt;p&gt;types模块添加了一个新函数coroutine(fn)，使用它，“生成器实现的协程”和“原生协程”之间可以进行互操作。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@types.coroutine
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_data(db):
    data &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; read_data(db)
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数将CO_ITERABLE_COROUTINE标志应用于生成器函数的代码对象，使其返回一个协程对象。如果fn不是生成器函数，它将被包装。如果它返回一个生成器，它将被包装在一个等待的代理对象中（参见下面的等待对象的定义）。&lt;/p&gt;
&lt;p&gt;types.coroutine()不会设置CO_COROUTINE标识，只有用新语法定义的原生协程才会有这个标识。&lt;/p&gt;
&lt;h3 id=&quot;await表达式&quot;&gt;await表达式&lt;/h3&gt;
&lt;p&gt;新的await表达式用于获得协程执行的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; read_data(db):
    data &lt;/span&gt;= await db.fetch(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SELECT ...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;await 和yield from 是非常类似的，会挂起read_data的执行，直到等待db.fetch完成并返回结果数据。&lt;/p&gt;
&lt;p&gt;await使用yield from的实现，但是加入了一个额外步骤——验证它的参数类型。await只接受awaitable对象，awaitable对象是以下的其中一个：&lt;/p&gt;
&lt;p&gt;在本文中，有__await__方法的对象被称为Future-like对象（协程会被await语句挂起，直到await语句右边的Future-like对象的__await__执行完毕、返回结果。）&lt;/p&gt;
&lt;p&gt;如果__await__返回的不是一个迭代器，则引发TypeError异常。 &lt;/p&gt;
&lt;p&gt;在CPython C API，有tp_as_async.am_await函数的对象，该函数返回一个迭代器（类似__await__方法）&lt;/p&gt;
&lt;p&gt;如果在async def函数之外使用await语句，会引发SyntaxError异常。这和在def函数之外使用yield语句一样。&lt;/p&gt;
&lt;p&gt;如果await右边不是一个awaitable对象，会引发TypeError异常。&lt;/p&gt;

&lt;h3&gt;新的运算符优先级表&lt;/h3&gt;
&lt;p&gt;有效的语法示例&lt;/p&gt;

&lt;table class=&quot;docutils&quot; border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;thead valign=&quot;bottom&quot;&gt;&lt;tr&gt;&lt;th class=&quot;head&quot;&gt;Expression&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;Will be parsed as&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody valign=&quot;top&quot; readability=&quot;12.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;if await fut: pass&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;if (await fut): pass&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;if await fut + 1: pass&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;if (await fut) + 1: pass&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;pair = await fut, 'spam'&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;pair = (await fut), 'spam'&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;with await fut, &lt;span class=&quot;pre&quot;&gt;open(): pass&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;with (await fut), &lt;span class=&quot;pre&quot;&gt;open(): pass&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await &lt;span class=&quot;pre&quot;&gt;foo()['spam'].baz()()&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await ( &lt;span class=&quot;pre&quot;&gt;foo()['spam'].baz()() )&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;return await coro()&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;return ( await coro() )&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;res = await coro() ** 2&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;res = (await &lt;span class=&quot;pre&quot;&gt;coro()) ** 2&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;func(a1=await &lt;span class=&quot;pre&quot;&gt;coro(), a2=0)&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;func(a1=(await &lt;span class=&quot;pre&quot;&gt;coro()), a2=0)&lt;/span&gt;&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await foo() + await bar()&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;(await &lt;span class=&quot;pre&quot;&gt;foo()) + (await &lt;span class=&quot;pre&quot;&gt;bar())&lt;/span&gt;&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;-await foo()&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;&lt;span class=&quot;pre&quot;&gt;-(await &lt;span class=&quot;pre&quot;&gt;foo())&lt;/span&gt;&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;










&lt;p&gt;无效的用法&lt;/p&gt;

&lt;div id=&quot;examples-of-await-expressions&quot; class=&quot;section&quot;&gt;
&lt;table class=&quot;docutils&quot; border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;thead valign=&quot;bottom&quot;&gt;&lt;tr&gt;&lt;th class=&quot;head&quot;&gt;Expression&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;Should be written as&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody valign=&quot;top&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await await coro()&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await (await &lt;span class=&quot;pre&quot;&gt;coro())&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await &lt;span class=&quot;pre&quot;&gt;-coro()&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;td&gt;&lt;tt class=&quot;docutils literal&quot;&gt;await &lt;span class=&quot;pre&quot;&gt;(-coro())&lt;/span&gt;&lt;/tt&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;




&lt;h3&gt;异步上下文管理器和“async with”&lt;/h3&gt;

&lt;p&gt;异步上下文管理器（asynchronous context manager），可以在它的enter和exit方法里挂起、调用异步代码。&lt;/p&gt;
&lt;p&gt;为此，我们设计了一套方案，添加了两个新的魔术方法：__aenter__和__aexit__，它们必须返回一个awaitable。&lt;/p&gt;
&lt;p&gt;异步上下文管理器的一个示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncContextManager:
    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__aenter__&lt;/span&gt;&lt;span&gt;(self):
        await log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;entering context&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__aexit__&lt;/span&gt;&lt;span&gt;(self, exc_type, exc, tb):
        await log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;exiting context&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;新语法&lt;/h3&gt;
&lt;p&gt;采纳了一个异步上下文管理器的新语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;async with EXPR as VAR:
    BLOCK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这在语义上等同于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
mgr =&lt;span&gt; (EXPR)
aexit &lt;/span&gt;= type(mgr).&lt;span&gt;__aexit__&lt;/span&gt;&lt;span&gt;
aenter &lt;/span&gt;= type(mgr).&lt;span&gt;__aenter__&lt;/span&gt;&lt;span&gt;(mgr)

VAR &lt;/span&gt;=&lt;span&gt; await aenter
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    BLOCK
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; await aexit(mgr, *&lt;span&gt;sys.exc_info()):
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    await aexit(mgr, None, None, None)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与常规with语句一样，可以在单个async with语句中指定多个上下文管理器。&lt;/p&gt;
&lt;p&gt;在使用async with时，如果上下文管理器没有__aenter__和__aexit__方法，则会引发错误。在async def函数之外使用async with则会引发SyntaxError异常。&lt;/p&gt;
&lt;h4 id=&quot;示例&quot;&gt;例子&lt;/h4&gt;
&lt;p&gt;使用异步上下文管理器，可以轻松地为协同程序实现适当的数据库事务管理器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; commit(session, data):
    ...

    async with session.transaction():
        ...
        await session.update(data)
        ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;加锁的处理也更加简洁&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;async with lock:
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而不再是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
with (&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; lock):
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;异步迭代器和“async for”&lt;/h3&gt;
&lt;p&gt;异步迭代器可以在它的iter实现里挂起、调用异步代码，也可以在它的__next__方法里挂起、调用异步代码。要支持异步迭代，需要：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象必须实现__aiter__方法（或者，如果使用CPython C API，需要定义tp_as_async.am_aiter）返回一个异步迭代器对象&lt;/li&gt;
&lt;li&gt;一个异步迭代对象必须实现一个__anext__方法（或者，如果使用CPython C API，需要定义tp_as_async.am_anext）返回一个awaitable&lt;/li&gt;
&lt;li&gt;要停止迭代，__anext__必须抛出一个StopAsyncIteration异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个一步迭代的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncIterable:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__aiter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__anext__&lt;/span&gt;&lt;span&gt;(self):
        data &lt;/span&gt;=&lt;span&gt; await self.fetch_data()
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; data:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt; StopAsyncIteration

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fetch_data(self):
        ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;新语法&lt;/h3&gt;
&lt;p&gt;采纳了一个迭代异步迭代器的新语法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;for&lt;/span&gt; TARGET &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ITER:
    BLOCK
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    BLOCK2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在语义上等同于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
iter =&lt;span&gt; (ITER)
iter &lt;/span&gt;= type(iter).&lt;span&gt;__aiter__&lt;/span&gt;&lt;span&gt;(iter)
running &lt;/span&gt;=&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; running:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        TARGET &lt;/span&gt;= await type(iter).&lt;span&gt;__anext__&lt;/span&gt;&lt;span&gt;(iter)
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopAsyncIteration:
        running &lt;/span&gt;=&lt;span&gt; False
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        BLOCK
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    BLOCK2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果async for的迭代器不支持__aiter__方法，则引发TypeError异常。如果在async def函数外使用async for，则引发SyntaxError异常。&lt;/p&gt;
&lt;p&gt;和普通的for语句一样，async for有一个可选的else分句。&lt;/p&gt;
&lt;h3&gt;例子1&lt;/h3&gt;
&lt;p&gt;使用异步迭代协议，可以在迭代期间异步缓冲数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;for&lt;/span&gt; data &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cursor:
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中cursor是一个异步迭代器，它在每N次迭代后从数据库中预取N行数据。&lt;/p&gt;
&lt;p&gt;以下代码说明了新的异步迭代协议：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cursor:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.buffer &lt;/span&gt;=&lt;span&gt; collections.deque()

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; _prefetch(self):
        ...

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__aiter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__anext__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.buffer:
            self.buffer &lt;/span&gt;=&lt;span&gt; await self._prefetch()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.buffer:
                &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt; StopAsyncIteration
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.buffer.popleft()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，可以这样使用Cursor类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Cursor():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(row)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与下述代码相同：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
i = await Cursor().&lt;span&gt;__aiter__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        row &lt;/span&gt;= await i.&lt;span&gt;__anext__&lt;/span&gt;&lt;span&gt;()
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopAsyncIteration:
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(row)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;例子2：&lt;/h3&gt;
&lt;p&gt;以下是将常规迭代转换为异步迭代的实用程序类。虽然这不是一件非常有用的事情，但代码说明了常规迭代器和异步迭代器之间的关系。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; AsyncIteratorWrapper:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, obj):
        self._it &lt;/span&gt;=&lt;span&gt; iter(obj)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__aiter__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self

    async &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__anext__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            value &lt;/span&gt;=&lt;span&gt; next(self._it)
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopIteration:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt; StopAsyncIteration
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value

async &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; letter &lt;span&gt;in&lt;/span&gt; AsyncIteratorWrapper(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(letter)
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;为什么是stopasynciteration&quot;&gt;为什么是StopAsyncIteration？&lt;/h4&gt;
&lt;p&gt;协程在内部仍然是基于生成器实现的，因此，在PEP479之前，下面两者是没有区别的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; g1():
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; fut
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;spam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; g2():
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; fut
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; StopIteration(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于PEP 479已被正式采纳，并作用于协程，以下代码的StopIteration会被包装（wrapp）成一个RuntimeError。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;def&lt;/span&gt;&lt;span&gt; a1():
    await fut
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; StopIteration(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，要想通知外部代码迭代已经结束，抛出一个StopIteration异常的方法不行了。因此，添加了一个新的内置异常StopAsyncIteration，用于表示迭代结束。&lt;/p&gt;
&lt;p&gt;此外，根据PEP 479，协程抛出的所有StopIteration异常都会被包装成RuntimeError异常。&lt;/p&gt;
&lt;h3&gt;协程对象&lt;/h3&gt;
&lt;h4 id=&quot;和生成器的不同之处&quot;&gt;和生成器的不同之处&lt;/h4&gt;
&lt;p&gt;本节仅适用于具有CO_COROUTINE的原生协程，即使用新的async def 定义的函数&lt;/p&gt;
&lt;p&gt;对于asyncio模块里现有的“基于生成器的协程”，仍然保持不变。&lt;/p&gt;
&lt;p&gt;为了把协程和生成器的概念区分开来：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;原生协程对象不实现__iter__和__next__方法，因此，不能对其进行迭代（如for...in循环），也不能传递给iter()，list()，tuple()及其它内置函数。如果尝试对其使用__iter__或__next__方法，会引发TypeError异常。&lt;/li&gt;
&lt;li&gt;未装饰的生成器不能yield from一个原生协程，这样做会引发TypeError异常。&lt;/li&gt;
&lt;li&gt;“基于生成器的协程”在经过 @asyncio.coroutine装饰后，可以yield from原生协程对象。&lt;/li&gt;
&lt;li&gt;对于原生协程对象和原生协程函数，调用inspect.isgenerator()和inspect.isgeneratorfunction()会返回False。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;协程对象的方法&lt;/h3&gt;
&lt;p&gt;协程是基于生成器实现的，因此它们有共同的代码。像生成器对象那样，协程也有throw()，send()和close()方法。&lt;br/&gt;对于协程，StopIteration和GeneratorExit起着同样的作用（虽然PEP 479已经应用于协程）。详见PEP 342、PEP 380，以及Python文档。&lt;/p&gt;
&lt;p&gt;对于协程，send()，throw()方法用于往Future-like对象发送内容、抛出异常。&lt;/p&gt;
&lt;h3&gt;调试特性&lt;/h3&gt;
&lt;p&gt;初级开发者在使用协程时可能忘记使用yield from语句，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@asyncio.coroutine
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; useful():
    asyncio.sleep(&lt;/span&gt;1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; this will do nothing without 'yield from'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;为了调试这种错误，在asyncio中有一个特殊的调试模式，其中@coroutine装饰器用一个特殊对象包装所有函数，并使用析构函数记录警告。每当一个包装的生成器被垃圾回收时，就会生成一条详细的日志消息，其中包含有关定义装饰器函数的确切位置，堆栈跟踪收集位置等的信息.Wrapper对象还提供了一个方便的__repr__函数，其中包含有关生成器的详细信息。&lt;/p&gt;
&lt;h3&gt;新标准库函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;types.coroutine(gen) 详见types.coroutine()一节。&lt;/li&gt;
&lt;li&gt;inspect.iscoroutine(obj) 如果obj是原生协程对象，返回True。&lt;/li&gt;
&lt;li&gt;inspect.iscoroutinefunction(obj) 如果obj是原生协程函数，返回True。&lt;/li&gt;
&lt;li&gt;inspect.isawaitable(obj) 如果obj是awaitable返回True。&lt;/li&gt;
&lt;li&gt;inspect.getcoroutinestate(coro) 返回原生协程对象的当前状态（inspect.getfgeneratorstate(gen)的镜像）。&lt;/li&gt;
&lt;li&gt;inspect.getcoroutinelocals(coro) 返回一个原生协程对象的局部变量的映射【译注：变量名-&amp;gt;值】（inspect.getgeneratorlocals(gen) 的镜像）。&lt;/li&gt;
&lt;li&gt;sys.set_coroutine_wrapper(wrapper) 允许拦截原生协程对象的创建。wrapper必须是一个接受一个参数callable（一个协程对象），或者是None。None会重置（reset）这个wrapper。如果再次调用，新的wrapper会取代旧的。这个函数是线程专有的（thread-specific）。详见“调度特性”一节。&lt;/li&gt;
&lt;li&gt;sys.get_coroutine_wrapper() 返回当前的包装对象(wrapper object)。如果没有则返回None。这个函数是线程专有的（thread-specific）。详见“调度特性”一节。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;新的抽象基类&lt;/h3&gt;
&lt;p&gt;为了更好地与现有框架（如Tornado，见[13]）和编译器（如Cython，见[16]）集成，增加了两个新的抽象基类（ABC）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;collections.abc.Awaitable，Future-like类的抽象基类，实现__await__方法。&lt;/li&gt;
&lt;li&gt;collections.abc.Coroutine，协程对象的抽象基类，实现send(value)，throw(type, exc, tb)，close()和__await__()方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意，“基于生成器的协程”（有CO_ITERABLE_COROUTINE标识）并不实现__await__方法，因此它们不是collections.abc.Coroutine和collections.abc.Awaitable的实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@types.coroutine
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; gencoro():
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;

&lt;span&gt;assert&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; isinstance(gencoro(), collections.abc.Coroutine)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; however:&lt;/span&gt;
&lt;span&gt;assert&lt;/span&gt; inspect.isawaitable(gencoro())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了便于测试对象是否支持异步迭代，还添加了两个ABC：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;collections.abc.AsyncIterable --用于测试__aiter__方法。&lt;/li&gt;
&lt;li&gt;collections.abc.AsyncIterator --用于测试__aiter__和__anext__方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt; &lt;/h3&gt;
</description>
<pubDate>Mon, 03 Dec 2018 14:58:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<og:description>因为工作中慢慢开始用python的协程，所以想更好的理解一下实现方式，故翻译此文 原文中把词汇表放到最后，但是我个人觉得放在最开始比较好，这样可以增加当你看原文时的理解程度 词汇表 原生协程函数 Na</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/10024264.html</dc:identifier>
</item>
<item>
<title>记一次idea性能调优 - 虚空之王</title>
<link>http://www.cnblogs.com/nevermorewang/p/10061377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nevermorewang/p/10061377.html</guid>
<description>&lt;p&gt;　　因自研的自动化测试工具包含压测功能，在自己本地代码开发完毕后进行测试，对目标接口进行1000次访问，发现idea在执行结束后变的异常卡顿，怀疑是idea工具或者程序代码存在问题，遂进行排查。&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;　　本地所用MacBook Pro 2015配置&lt;/p&gt;
&lt;p&gt;　　处理器：i7 2.2GHz&lt;/p&gt;
&lt;p&gt;　　核心数：4&lt;/p&gt;
&lt;p&gt;　　内存：16GB&lt;/p&gt;
&lt;p&gt;　　系统：macOS Mojave&lt;/p&gt;
&lt;p&gt;----------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;　　先从idea排查开始：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、打开jdk自带的jconsole工具，连接idea；同时打开活动监控器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　启动idea，可以看到idea的cpu跟内存消耗并不高：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220522434-1008454759.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220605916-253827753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　启动程序，再次观察cpu跟内存，cpu从2%到了10%，内存增长300M：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220648154-943706500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220709346-1721628236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　本以为jconsole能明显看到jvm的变化情况，结果不然，而且显示的数值很小，只有47兆：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220806193-430467465.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220831585-2081692334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这跟系统的活动监视器的结果明显不符合嘛，后来发现，jconsole实际把idea跟程序的jvm内存使用都分开了，这个显示的只是idea的，其实本例中如果要查看内存大小，应该直接监控程序的。这个是程序的执行模块的内存情况：&lt;/p&gt;
&lt;div readability=&quot;27.027446300716&quot;&gt;
&lt;p&gt;　　&lt;strong&gt;2、执行压测程序，1000访问量，第一次执行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　idea变得非常卡顿，系统的监控器看到明显的内存变化：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203220933492-285008356.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221012354-1072982846.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;　　同时，jconsole看到了明显的内存跟cpu变化情况：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221043187-1625270834.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221104453-983694452.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;　　堆中老年代old：62M，新生代eden：780M左右，幸存区15M,之所以看到新生代跟幸存区一样高，是因为这里显示的百分比，实际新生代占用的非常多。这里多说一句，jvm的各个区的命名也是挺有意思的，新对象刚出生，就叫eden区，eden，，，伊甸园么，亚当跟夏娃开始的那个地方，这名字挺合适的；然后会有垃圾收集，挺不过去就被回收了，对对象来说这辈子也就算完了，挺过去的话，这条命算是保住了，属于幸存者，于是到了幸存区(survivor)。可是生活并没有结束，接下来还是有一次次的gc来考验我们的对象，很多人没能坚持下来，最终经历15次gc而没被回收的，相对来说年龄也不小了，进入的区域叫老年代(old)。挺有意思。&lt;/p&gt;
&lt;p&gt;这次执行结束之后，idea的响应速度还是可以的，不是怎么卡顿。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、压测1000访问量，第二次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　从之前的经历来看，就是这次压测会导致idea非常卡顿，监控器情况:&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221206193-1628540751.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221217025-1792533751.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;　　执行过程中跟上次相比，并无明显区别，cpu跟内存均没有明显增长，但idea抛出了OOM提示框：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221251938-935897366.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;　　如果修改这几个参数，修改后的内容将被保存到/Users/nm/Library/Preferences/IntelliJIdea2018/idea.vmoptions中，idea默认读的配置文件也是这个，而不是安装目录的bin下的。&lt;/p&gt;
&lt;p&gt;　　压测程序执行结束之后，监控器看到的idea占用cpu依然很高，对idea的操作也会有卡顿(有时比较明显，也偶尔有相对流畅的)：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221341013-1527420459.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;　　点击Memory Dump，信息会被存到idea.vmoptions，然后点击continue继续。&lt;/p&gt;
&lt;p&gt;　　jconsole同样看到了内存跟cpu的增长：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221400140-1322447520.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;22.429752066116&quot;&gt;
&lt;p&gt;　　图表中的15:54左右的内存下降应该是jvm的gc导致，后边16:10分左右的cpu跟内存暴增然后降低才是这次压测的表现。（为何堆内存在16:10会骤降，怀疑可能正好有一次gc，jconsole的vm概要有gc次数，忘了截图）&lt;/p&gt;
&lt;p&gt;　　idea OOM框dump出的信息保存在$USER_HOME/heapDump_Leak_Supports.zip中，解压有heapDump.hprof文件，内容如下：&lt;/p&gt;
&lt;p&gt;　　用Memory Analyzer Tool打开这个hprof进行查看：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221448803-1110366988.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;　　说是a、b两部分内容“怀疑有罪”，分别235M跟109M，这两个都是什么东西呢？&lt;/p&gt;
&lt;p&gt;　　两个都是idea自己的一个类的对象com.intellij.openapi.editor.impl.DocumentImpl，看名字是个文档实现类&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221514389-1565831066.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;25.716748768473&quot;&gt;
&lt;p&gt;　　到这里，其实我已经猜出问题出在哪里了，是日志！因为我以前把控制台的输出设置为无限制，而为了本地调试方便，我又把hibernate的日志也打印了出来，在执行单个案例的时候并不明显，而如果执行大量案例执行，这个日志的量就非常大了，多次压测1000访问量后系统产生大量日志，这些日志都被作为文本类的内容被保存了起来，又因为我把控制台日志设为无限，idea不清除这些类对象，最终导致对象越来越大，拖垮了idea。&lt;/p&gt;
&lt;p&gt;　　如果检测的不是idea而是自己的程序，那么还可以继续通过histogram跟dominator_tree进行跟踪。因为强引用、软引用、弱引用跟虚引用只有强引用不会被gc，如果多次gc没有回收掉，肯定有强引用在关联这个对象，通过支配树　　dominator_tree(展示对象层级关系跟内存占用百分比)跟Merge Shortest Paths to GC Roots(展示gc树引用关系图)可以慢慢找到强引用的所在，从而定位内存溢出原因。&lt;/p&gt;


&lt;p&gt;　&lt;strong&gt;　4、参数修正&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　明白了问题所在，那么进行修复并测试，修改idea的相关参数配置为：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
-Xms512m
-Xmn512m
-Xmx2048m
-XX:ReservedCodeCacheSize=240m
-XX:+UseCompressedOops
-Dfile.encoding=UTF-8
-XX:+UseG1GC   //使用G1收集器，好处是并行收集
-XX:+UseNUMA  //优先使用速度较快的内存
-XX:SoftRefLRUPolicyMSPerMB=50
-ea
-Dsun.io.useCanonCaches=false
-Djava.net.preferIPv4Stack=true
-Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot;
-XX:+HeapDumpOnOutOfMemoryError
-XX:-OmitStackTraceInFastThrow
-Xverify:none

-XX:ErrorFile=$USER_HOME/java_error_in_idea_%p.log
-XX:HeapDumpPath=$USER_HOME/java_error_in_idea.hprof
-javaagent:JetbrainsCrack-3.1-release-enc.jar
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;19.325670498084&quot;&gt;
&lt;p&gt;　　主要是将堆内存最小设为512，最大为2G，变为了原来的3倍，然后把gc算法改为了G1，并优化内存读取为NUMA。NUMA我也不熟悉，网上查到的结果如下：&lt;/p&gt;
&lt;p&gt;　　numa 是一个 CPU 的特性。SMP 架构下，CPU 的核是对称，但是他们共享一条系统总线。所以 CPU 多了，总线就会成为瓶颈。在 NUMA 架构下，若干 CPU 组成一个组，组之间有点对点的通讯，相互独立。启动它可以提高性能。&lt;/p&gt;
&lt;div readability=&quot;9.5333333333333&quot;&gt;　　NUMA 需要硬件，操作系统，JVM 同时启用，才能启用。Linux 可以用 &lt;a href=&quot;http://linux.die.net/man/8/numactl&quot;&gt;numactl&lt;/a&gt; 来配置 numa,JVM 通过-XX:+UseNUMA来启用。&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;5、执行，查看结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　按照以上步骤，同样程序启动后执行两次请求数量均为1000的压测，jconsole如图：&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221758153-457008060.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;13.5&quot;&gt;
&lt;p&gt;　　两次明显的内存增长跟cpu消耗，监控器看到的内存情况：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/393620/201812/393620-20181203221820413-1138206153.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;　　相比之前，idea的内存增长到了2.5G，cpu在压测结束后恢复正常。点击idea使用，没有在发生卡顿的情况，可知的确是日志导致idea卡顿的。而当时idea的cpu消耗亦很高，应该是频繁gc所致。&lt;/p&gt;
&lt;p&gt;　　当然，我仅仅这么修改是肯定不行的，如果控制台仍旧是无限，那么总有一天还是会oom的，我目前是手动清空控制台，发现效果也还可以，会有效。如果不手动清空，则一定要设置控制台最大行数，或者内存值，防止因日志而导致的idea卡死现象。&lt;/p&gt;
&lt;p&gt;--------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;　　对jconsole的使用并不熟练，如有错误之处请留言指正，多谢多谢。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 03 Dec 2018 14:20:00 +0000</pubDate>
<dc:creator>虚空之王</dc:creator>
<og:description>因自研的自动化测试工具包含压测功能，在自己本地代码开发完毕后进行测试，对目标接口进行1000次访问，发现idea在执行结束后变的异常卡顿，怀疑是idea工具或者程序代码存在问题，遂进行排查。 本地所用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nevermorewang/p/10061377.html</dc:identifier>
</item>
</channel>
</rss>