<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>自兴人工智能 - 怪比i</title>
<link>http://www.cnblogs.com/guaibi/p/8456763.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guaibi/p/8456763.html</guid>
<description>&lt;p&gt;列表和元组&lt;/p&gt;
&lt;p&gt;数据结构是通过某种方式(如对元素进行编号)组织在一起的数据元素的集合，这些元素可以是数字或字符。在Python中，最基本的数据结构是序列。Python包含6种内建序列，即列表,元组，字符串，Unicode字符串，buffer对象和xrange对象。&lt;/p&gt;
&lt;p&gt;Python中所有序列都可以进行一些特定操作，包括索引，分片，序列相加，乘法，成员资格，长度，最小值和最大值。&lt;/p&gt;
&lt;p&gt;一，序列&lt;/p&gt;
&lt;p&gt;1.索引&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;定义一个列表  frunt = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;] &lt;br/&gt;输出下标为4的元素 &lt;br/&gt;print frunt[4] &lt;br/&gt;结果： e &lt;br/&gt;2.分片 &lt;span&gt;&lt;br/&gt;定义一个列表  &lt;br/&gt;frunt = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]  &lt;br/&gt;获取第一个到第三个的元素  &lt;br/&gt;sfruit = frunt[0:3]  &lt;br/&gt;print sfruit &lt;br/&gt;结果： ['a', 'b', 'c'] &lt;br/&gt;取得整个数组 &lt;br/&gt;sfruit = frunt[:] &lt;br/&gt;print sfruit &lt;br/&gt;结果： ['a', 'b', 'c', 'd', 'e'] &lt;br/&gt;3.序列相加 &lt;br/&gt;frunt = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] &lt;br/&gt;frunt1 = [&quot;d&quot;,&quot;e&quot;] &lt;br/&gt;frunt2 = frunt + frunt1 &lt;br/&gt;print frunt2 &lt;br/&gt;结果：  ['a', 'b', 'c', 'd', 'e'] &lt;br/&gt;4.乘法 &lt;br/&gt;frunt = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] * 5 &lt;br/&gt;print frunt &lt;br/&gt;结果： ['a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c', 'a', 'b', 'c'] &lt;br/&gt;5.成员资格&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;3 in (1, 2, 3)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;    结果： True&lt;/p&gt;

&lt;p&gt;   6.长度&lt;/p&gt;
&lt;p&gt;   frunt = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]&lt;/p&gt;
&lt;p&gt;   length = len(frunt)&lt;/p&gt;
&lt;p&gt;   print length&lt;/p&gt;
&lt;p&gt;   结果： 5&lt;/p&gt;

&lt;p&gt;  7.最大值和最小值&lt;/p&gt;
&lt;p&gt; num = [1,2,3,4,5]&lt;/p&gt;
&lt;p&gt;nums = max(num)&lt;/p&gt;
&lt;p&gt;print nums&lt;/p&gt;
&lt;p&gt;结果： 5&lt;/p&gt;
&lt;p&gt;num = [1,2,3,4,5]&lt;/p&gt;
&lt;p&gt;nums = min(num)&lt;/p&gt;
&lt;p&gt;print nums&lt;/p&gt;
&lt;p&gt;结果： 1&lt;/p&gt;

&lt;p&gt;二，列表&lt;/p&gt;
&lt;p&gt;列表的操作有索引，分片，序列相加，乘法，元素赋值，增加元素，元素删除，分片赋值和列表方法，这些都是更新列表。&lt;/p&gt;
&lt;p&gt;一.更新列表&lt;/p&gt;
&lt;p&gt;1.元素赋值&lt;/p&gt;
&lt;p&gt;num = [1,2,3,4,5]&lt;/p&gt;
&lt;p&gt;num[1] = 6&lt;/p&gt;
&lt;p&gt;print num&lt;/p&gt;
&lt;p&gt;结果：[1, 6, 3, 4, 5]&lt;/p&gt;

&lt;p&gt;2.增加元素&lt;/p&gt;
&lt;p&gt;num = [1,2,3,4,5]&lt;/p&gt;
&lt;p&gt;num.append(6)&lt;/p&gt;
&lt;p&gt;print num&lt;/p&gt;
&lt;p&gt;结果：[1, 6, 3, 4, 5,6]&lt;/p&gt;

&lt;p&gt;3.元素删除&lt;/p&gt;
&lt;p&gt;1. 直接删除所选元素&lt;/p&gt;
&lt;p&gt;num = [1,2,3,4,5]&lt;/p&gt;
&lt;p&gt;num.remove(2)&lt;/p&gt;
&lt;p&gt;print num&lt;/p&gt;
&lt;p&gt;结果： [1,3,4,5]&lt;/p&gt;
&lt;p&gt;2. 根据下标删除元素&lt;/p&gt;
&lt;p&gt;num = [1,2,3,4,5]&lt;/p&gt;
&lt;p&gt;del num[2]&lt;/p&gt;
&lt;p&gt;print num&lt;/p&gt;
&lt;p&gt;结果： [1,2,4,5]&lt;/p&gt;

&lt;p&gt;4.分片赋值&lt;/p&gt;
&lt;p&gt;show = list('自兴人工智能')&lt;/p&gt;
&lt;p&gt;show [5:] =list('学院')&lt;/p&gt;
&lt;p&gt;print show&lt;/p&gt;
&lt;p&gt;结果： ['自','兴','人','工','智','能','学','院']&lt;/p&gt;

&lt;p&gt;二.嵌套列表&lt;/p&gt;
&lt;p&gt;num = [1,2,3,4,5]&lt;/p&gt;
&lt;p&gt;num1 = [1,2,3,4,5,6,7,8]&lt;/p&gt;
&lt;p&gt;mix = [num,num1]&lt;/p&gt;
&lt;p&gt;print mix&lt;/p&gt;
&lt;p&gt;结果： [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8]]&lt;/p&gt;

&lt;p&gt;三.列表方法&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;list.append(obj)&lt;/p&gt;
&lt;p&gt;在列表末尾添加新的对象&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;list.count(obj)&lt;/p&gt;
&lt;p&gt;统计某个元素在列表中出现的次数&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;list.extend(seq)&lt;/p&gt;
&lt;p&gt;在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;list.index(obj)&lt;/p&gt;
&lt;p&gt;从列表中找出某个值第一个匹配项的索引位置&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;list.insert(index, obj)&lt;/p&gt;
&lt;p&gt;将对象插入列表&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;list.pop(obj=list[-1])&lt;/p&gt;
&lt;p&gt;移除列表中的一个元素（默认最后一个元素），并且返回该元素的值&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;list.remove(obj)&lt;/p&gt;
&lt;p&gt;移除列表中某个值的第一个匹配项&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;list.reverse()&lt;/p&gt;
&lt;p&gt;反向列表中元素&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;list.sort([func])&lt;/p&gt;
&lt;p&gt;对原列表进行排序&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;list.clean()&lt;/p&gt;
&lt;p&gt;清空列表&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;list.copy()&lt;/p&gt;
&lt;p&gt;复制列表&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;list.sort(key=len)&lt;/p&gt;
&lt;p&gt;由短到长排序&lt;/p&gt;
&lt;p&gt;list.sort(key=len,reverse=True)&lt;/p&gt;
&lt;p&gt;由长到短排序&lt;/p&gt;
&lt;p&gt;list.sort(reverse=True)&lt;/p&gt;
&lt;p&gt;排序后逆序&lt;/p&gt;

&lt;p&gt;三.元组&lt;/p&gt;
&lt;p&gt;Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。&lt;/p&gt;
&lt;p&gt;1.创建空元组&lt;/p&gt;
&lt;p&gt;tup1 = ();&lt;/p&gt;
&lt;p&gt;2.元组中只包含一个元素时，需要在元素后面添加逗号&lt;/p&gt;
&lt;p&gt;tup1 = (50,);&lt;/p&gt;
&lt;p&gt;元组的基本操作访问元组，修改元组，删除元组，索引和截取等操作。&lt;/p&gt;
&lt;p&gt;1. 访问元组&lt;/p&gt;
&lt;p&gt;num = （1,2,3,4,5）&lt;/p&gt;
&lt;p&gt;print (num[1:5])&lt;/p&gt;
&lt;p&gt;结果：(2, 3, 4, 5)&lt;/p&gt;
&lt;p&gt;2.修改元组&lt;/p&gt;
&lt;p&gt;元组中的元素不能修改，可以进行连接组合&lt;/p&gt;
&lt;p&gt;num = （1,2,3,4,5）&lt;/p&gt;
&lt;p&gt;num1 = （1,2,3,4,5,6,7）&lt;/p&gt;
&lt;p&gt;print (num,num1)&lt;/p&gt;
&lt;p&gt;结果： ((1, 2, 3, 4, 5), (1, 2, 3, 4, 5, 6, 7))&lt;/p&gt;
&lt;p&gt;3.删除元组&lt;/p&gt;
&lt;p&gt;元组中的元素值不能删除，可以使用del语句删除整个元组&lt;/p&gt;
&lt;p&gt;num = (1,2,3,4,5)&lt;/p&gt;
&lt;p&gt;del num&lt;/p&gt;
&lt;p&gt;print num&lt;/p&gt;
&lt;p&gt;结果：Traceback (most recent call last):   File &quot;C:/Users/���ֺ�/PycharmProjects/untitled1/dame1.py&quot;, line 83, in &amp;lt;module&amp;gt;     print num NameError: name 'num' is not defined&lt;/p&gt;
&lt;p&gt; 4.索引和截取&lt;/p&gt;
&lt;p&gt;num = (1,2,3,4,5)&lt;/p&gt;
&lt;p&gt;nums = num [2]&lt;/p&gt;
&lt;p&gt;print nums&lt;/p&gt;
&lt;p&gt;结果：  3&lt;/p&gt;
&lt;p&gt;num = (1,2,3,4,5)&lt;/p&gt;
&lt;p&gt;nums = num [2:]&lt;/p&gt;
&lt;p&gt;print nums&lt;/p&gt;
&lt;p&gt;结果：(3, 4, 5)&lt;/p&gt;
&lt;p&gt;3.元组内置函数&lt;/p&gt;
&lt;p&gt;len(tuple）&lt;/p&gt;
&lt;p&gt;计算元组元素个数。&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;max(tuple)&lt;/p&gt;
&lt;p&gt;返回元组中元素最大值。&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;min(tuple)&lt;/p&gt;
&lt;p&gt;返回元组中元素最小值。&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;tuple(seq)&lt;/p&gt;
&lt;p&gt;将列表转换为元组。&lt;/p&gt;
</description>
<pubDate>Wed, 21 Feb 2018 07:58:00 +0000</pubDate>
<dc:creator>怪比i</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guaibi/p/8456763.html</dc:identifier>
</item>
<item>
<title>Windows Server 2016-图形化迁移FSMO角色 - Wenzhongxiang</title>
<link>http://www.cnblogs.com/wenzhongxiang/p/8456730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenzhongxiang/p/8456730.html</guid>
<description>&lt;p&gt;上章节我们简单介绍了三种不同方式查看FSMO主机角色信息，在开篇之前我们简单回顾一下FSMO五种操作主机角色：林范围操作主机角色有两种，分别是 架构主机角色（Schema Master）和 域命名主机角色（Domain Naming Master）；及域范围操作主机角色三种，分别是 RID 主机角色（RID Master）、PDC 模拟主机角色（PDC Emulator）和基础架构主机角色（Infrastructure Master）；不管是林范围主机角色还是域范围主机角色都必须是唯一。含本章及后续两章分别介绍三种不同方式的FSMO角色迁移的方法，希望可以帮到大家。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看操作主机角色：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.通过netdom query fsmo查看当前操作主机角色信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.迁移架构主机角色（Schema Master）：&lt;/p&gt;
&lt;p&gt;a.在运行栏中输入：regsvr32 schmmgmt.dll并回车：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提示DllregisterServer注册成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b.然后打开MMC控制台添加Active Directory架构；&lt;/p&gt;
&lt;p&gt;c. 在&quot;Active Directory架构&quot;选中右键&quot;更改Active Directory域控制器&quot;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ4.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;d.选择&quot;此域控制器或AD LDS实例&quot;，在列表中选择要切换到的域控spare.azureyun.local，老版本中切换的时候可以输入指定DC名称：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;d.提示Active Directory架构管理单元未连接到架构操作主机。你将不能执行任何更改。只能在架构FSMO上进行架构修改，单击确定继续：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;e.Active Directory架构右键选择&quot;操作主机&quot;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ7.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;f:如图显示，点击&quot;更改&quot;按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;g:提示&quot;你确定要更改操作主机？&quot;，点击&quot;是&quot;继续：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;h.提示成功传送了操作主机：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ10.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;i.此时我们查看架构主机显示信息均为spare.azureyun.local：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ11.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.更改域命名操作主机：&lt;/p&gt;
&lt;p&gt;3.1.在&quot;Active Directory域和信任关系&quot;右键选择&quot;更改Active Directory域控制器&quot;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ12.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.2.选择&quot;此域控制器或AD LDS实例&quot;，在列表中选择要切换到的域控spare.azureyun.local，单击确定继续：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ13.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.3. Active Directory域和信任关系右键选择&quot;操作主机&quot;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ14.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.5. 如图显示，点击&quot;更改&quot;按钮进行域命名操作主机更改：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ15.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.6.提示&quot;确定要将操作主机角色转移到不同的计算机吗&quot;，选择&quot;是&quot;继续：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ16.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.7.提示已成功转移操作主机：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ17.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.8.迁移后当前的域命名操作主机信息均为spare.azureyun.local:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ18.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;更改RID、PDC、基础结构主机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4.1.打开&quot;AD用户和计算机&quot;在&quot;azureyun.local&quot;中右键&quot;更改域控制器&quot;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ19.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.2.选择&quot;Spare.azureyun.local&quot;，单击&quot;确定&quot;继续：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ20.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.3. &quot;AD用户和计算机&quot;在&quot;azureyun.local&quot;中右键选择&quot;操作主机&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ21.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.4.在RID界面选择&quot;更改&quot;，根据提示&quot;你确定要传送操作主机角色&quot;选择&quot;是&quot;进行RID主机角色迁移：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ22.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.5.提示成功传送了操作主机角色:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ23.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ24.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.6.此时查看RID主机均为Spare.azureyun.local:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ25.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.7.切换到PDC界面勾选更改进行当前PDC角色迁移，根据提示选择&quot;是&quot;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ26.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.8. 提示成功传送了操作主机角色:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ27.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.9.此时显示PDC角色均为Spare.azureyun.local：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ28.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.10.切换到基础架构界面，选择&quot;更改&quot;进行角色迁移，根据提示选择&quot;是&quot;进行操作主机角色迁移：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ29.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.11.此时提示成功传送了操作主机角色，单击确定继续：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ30.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.12.查看当前基础结构主机信息均显示&quot;Spare.azureyun.local&quot;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ31.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.所有操作均完成以后，此时我们查询当前FSMO角色信息均为Spare.azureyun.local，迁移成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.azureyun.com/wp-content/uploads/2018/02/022118_0720_WindowsServ32.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本次通过图形化界面进行FSMO角色迁移的操作完成，我们会发现通过图形化界面的操作很繁琐，下两章我们将引入通过命令行迁移FSMO角色内容。感谢大家支持。&lt;/p&gt;

</description>
<pubDate>Wed, 21 Feb 2018 07:30:00 +0000</pubDate>
<dc:creator>Wenzhongxiang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenzhongxiang/p/8456730.html</dc:identifier>
</item>
<item>
<title>Android开发之漫漫长途 XV——RecyclerView - 忘了12138</title>
<link>http://www.cnblogs.com/wangle12138/p/8456508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangle12138/p/8456508.html</guid>
<description>&lt;p&gt;&lt;em&gt;该文章是一个系列文章，是本人在Android开发的漫漫长途上的一点感想和记录，我会尽量按照先易后难的顺序进行编写该系列。该系列引用了《Android开发艺术探索》以及《深入理解Android 卷Ⅰ，Ⅱ，Ⅲ》中的相关知识，另外也借鉴了其他的优质博客，在此向各位大神表示感谢，膜拜！！！&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上文我们很详细的分析了ListView的使用、优化、及ListView的RecycleBin机制，读者如果对ListView不太清楚，那么请参看我的上篇博文。不过呢，Google Material Design提供的RecyclerView已经逐渐的取代ListView。RecyclerView提供了一种插拔式的体验，高度的解耦，异常的灵活，通过设置它提供的不同LayoutManager，ItemDecoration , ItemAnimator实现令人瞠目的效果。&lt;/p&gt;
&lt;p&gt;如果说上面的理由只是大而空泛的话，那我们来看以下场景&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你想控制数据的显示方式，列表显示、网格显示、瀑布流显示等等，之前你需要ListView,GridView和自定义View，而现在你可以通过RecyclerView的布局管理器LayoutManager控制&lt;/li&gt;
&lt;li&gt;你想要控制Item间的间隔（可绘制），想自定义更多样式的分割线，之前你可以设置divider,那么现在你可以使用RecyclerView的ItemDecoration，想怎么画怎么画。&lt;/li&gt;
&lt;li&gt;你想要控制Item增删的动画，ListView呢我们只能自己通过属性动画来操作 Item 的视图。RecyclerView可使用ItemAnimator&lt;/li&gt;
&lt;li&gt;你想要局部刷新某个Item,对于ListView来说，我们知道notifyDataSetChanged 来通知视图更新变化，但是该方法会重绘每个Item，而对于RecyclerView.Adapter 则提供了 notifyItemChanged 用于更新单个 Item View 的刷新，我们可以省去自己写局部更新的工作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;除了上述场景外，RecyclerView强制使用了ViewHolder模式，我们知道ListView使用ViewHolder来进行性能优化，但是这不是必须得，但是在RecyclerView中是必须的，另外RecyclerView还有许多优势，这里就不一一列举了，总体来说现在越来越多的项目使用RecyclerView,许多老旧项目也渐渐使用RecyclerView来替代ListView。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：当我们想要一个列表显示控件的时候，需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展；其他情况下ListView在使用上反而更加方便，快捷。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前言我们就讲到这，那么我们来进入正题。&lt;/p&gt;

&lt;p&gt;作为一个“新”控件，RecyclerView的使用有许多需要注意的地方&lt;/p&gt;
&lt;h2 id=&quot;recyclerview的简单使用&quot;&gt;RecyclerView的简单使用&lt;/h2&gt;
&lt;p&gt;一样的我们新建一个Demo来演示RecyclerView的使用&lt;/p&gt;
&lt;p&gt;[RecyclerViewDemo1Activity.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RecyclerViewDemo1Activity extends AppCompatActivity {
    @BindView(R.id.recycler_view)
    RecyclerView mRecyclerView;

    private List&amp;lt;String&amp;gt; mData;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_recycler_demo1_view);
        ButterKnife.bind(this);

        //LayoutManager必须指定，否则无法显示数据,这里指定为线性布局，
        mRecyclerView.setLayoutManager(new LinearLayoutManager(this));
        //虚拟数据
        mData = createDataList();
        //设置Adapter必须指定，否则数据怎么显示
        mRecyclerView.setAdapter(new RecyclerViewDemo1Adapter(mData));
    }

    protected List&amp;lt;String&amp;gt; createDataList() {
        mData = new ArrayList&amp;lt;&amp;gt;();
        for (int i=0;i&amp;lt;20;i++){
            mData.add(&quot;这是第&quot;+i+&quot;个View&quot;);
        }
        return mData;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其对应的布局文件也很简单activity_recycler_demo1_view.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;
    &amp;gt;

    &amp;lt;android.support.v7.widget.RecyclerView
        android:id=&quot;@+id/recycler_view&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        &amp;gt;
    &amp;lt;/android.support.v7.widget.RecyclerView&amp;gt;


&amp;lt;/LinearLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们再来看RecyclerViewDemo1Adapter&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 与ListView的Adapter不同，RecyclerView的Adapter需要继承RecyclerView.Adapter&amp;lt;VH&amp;gt;(VH是ViewHolder的类名)
 * 记为RecyclerViewDemo1Adapter。
 * 创建ViewHolder：在RecyclerViewDemo1Adapter中创建一个继承RecyclerView.ViewHolder的静态内部类，记为ViewHolder
 * (RecyclerView必须使用ViewHolder模式，这里的ViewHolder实现几乎与ListView优化时所使用的ViewHolder一致)
 * 在RecyclerViewDemo1Adapter中实现：
 *      ViewHolder onCreateViewHolder(ViewGroup parent, int viewType): 映射Item Layout Id，创建VH并返回。
 *      
 *      void onBindViewHolder(ViewHolder holder, int position): 为holder设置指定数据。
 *      
 *      int getItemCount(): 返回Item的个数。
 *      
 * 可以看出，RecyclerView将ListView中getView()的功能拆分成了onCreateViewHolder()和onBindViewHolder()。
 */
public class RecyclerViewDemo1Adapter extends RecyclerView.Adapter&amp;lt;RecyclerViewDemo1Adapter.ViewHolder&amp;gt; {

    private List&amp;lt;String&amp;gt; mData;

    public RecyclerViewDemo1Adapter(List&amp;lt;String&amp;gt; data) {
        this.mData = data;
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        View view = LayoutInflater
                    .from(parent.getContext())
                    .inflate(R.layout.item_menu_main, parent, false);

        return new ViewHolder(view);
    }

    @Override
    public void onBindViewHolder(ViewHolder holder, int position) {
        holder.setData(this.mData.get(position));
        holder.itemView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //item点击事件
            }
        });
    }

    @Override
    public int getItemCount() {
        return this.mData != null ? this.mData.size() : 0;
    }

    static class ViewHolder extends RecyclerView.ViewHolder{
        private TextView mTextView;
        public ViewHolder(View itemView) {
            super(itemView);
            mTextView = (TextView) itemView.findViewById(R.id.tv_title);
        }

        public void setData(String title) {
            this.mTextView.setText(title);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是RecyclerView没有提供如ListView的setOnItemClickListener或者setOnItemLongClickListener之类的Item点击事件，我们必须自己去实现该部分功能，实现的方法有很多种，也比较容易，本例中采用在Adapter中BindViewHolder绑定数据的时候为item设置了点击事件。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;RecyclerView的四大组成分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Adapter：为Item提供数据。必须提供,关于Adapter我们上面的代码注释已经说的很明白了&lt;/li&gt;
&lt;li&gt;Layout Manager：Item的布局。必须提供,我们需要为RecyclerView指定一个布局管理器&lt;/li&gt;
&lt;li&gt;Item Animator：添加、删除Item动画。可选提供，默认是DefaultItemAnimator&lt;/li&gt;
&lt;li&gt;Item Decoration：Item之间的Divider。可选提供，默认是空&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以上面代码的运行结果看起来像是是一个没有分割线的ListView&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/SvrSBvp.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;recyclerview的进阶使用&quot;&gt;RecyclerView的进阶使用&lt;/h2&gt;
&lt;p&gt;上面的基本使用我们是会了，而且点击Item也有反应了，不过巨丑无比啊有木有。起码的分割线都没有，真无语&lt;/p&gt;
&lt;h3 id=&quot;为recyclerview添加分割线&quot;&gt;为RecyclerView添加分割线&lt;/h3&gt;
&lt;p&gt;那么如何创建分割线呢，&lt;br/&gt;创建一个类并继承RecyclerView.ItemDecoration，重写以下两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onDraw()或者onDrawOver: 绘制分割线。&lt;/li&gt;
&lt;li&gt;getItemOffsets(): 设置分割线的宽、高。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后使用RecyclerView通过addItemDecoration()方法添加item之间的分割线。&lt;br/&gt;我们来看一下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RecyclerViewDemo2Activity extends AppCompatActivity {
    @BindView(R.id.recycler_view)
    RecyclerView mRecyclerView;

    private List&amp;lt;String&amp;gt; mData;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_recycler_demo1_view);
        ButterKnife.bind(this);

        //LayoutManager必须指定，否则无法显示数据,这里指定为线性布局，
        mRecyclerView.setLayoutManager(new LinearLayoutManager(this));

        //虚拟数据
        mData = createDataList();

        //设置Adapter必须指定，否则数据怎么显示
        mRecyclerView.setAdapter(new RecyclerViewDemo2Adapter(mData));

        //设置分割线
        mRecyclerView.addItemDecoration(
            new DividerItemDecoration(this,DividerItemDecoration.VERTICAL));
    }

    protected List&amp;lt;String&amp;gt; createDataList() {
        mData = new ArrayList&amp;lt;&amp;gt;();
        for (int i=0;i&amp;lt;20;i++){
            mData.add(&quot;这是第&quot;+i+&quot;个View&quot;);
        }
        return mData;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;布局文件还跟上面的一致，代码也大致相同，不过我们多了一行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//设置分割线
mRecyclerView.addItemDecoration(
    new DividerItemDecoration(this,DividerItemDecoration.VERTICAL));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的DividerItemDecoration是Google给了一个参考的实现类，这里我们通过分析这个例子来看如何自定义Item Decoration。&lt;/p&gt;
&lt;p&gt;[DividerItemDecoration.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DividerItemDecoration extends RecyclerView.ItemDecoration {
    public static final int HORIZONTAL = LinearLayout.HORIZONTAL;
    public static final int VERTICAL = LinearLayout.VERTICAL;

    private static final int[] ATTRS = new int[]{ android.R.attr.listDivider };

    private Drawable mDivider;

  
    private int mOrientation;

    private final Rect mBounds = new Rect();

    /**
     * 创建一个可使用于LinearLayoutManager的分割线
     *
     */
    public DividerItemDecoration(Context context, int orientation) {
        final TypedArray a = context.obtainStyledAttributes(ATTRS);
        mDivider = a.getDrawable(0);
        a.recycle();
        setOrientation(orientation);
    }



    @Override
    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
        if (parent.getLayoutManager() == null) {
            return;
        }
        if (mOrientation == VERTICAL) {
            drawVertical(c, parent);
        } else {
            drawHorizontal(c, parent);
        }
    }

    @SuppressLint(&quot;NewApi&quot;)
    private void drawVertical(Canvas canvas, RecyclerView parent) {
        canvas.save();
        final int left;
        final int right;
        if (parent.getClipToPadding()) {
            left = parent.getPaddingLeft();
            right = parent.getWidth() - parent.getPaddingRight();
            canvas.clipRect(left, parent.getPaddingTop(), right,
                    parent.getHeight() - parent.getPaddingBottom());
        } else {
            left = 0;
            right = parent.getWidth();
        }

        final int childCount = parent.getChildCount();
        for (int i = 0; i &amp;lt; childCount; i++) {
            final View child = parent.getChildAt(i);
            parent.getDecoratedBoundsWithMargins(child, mBounds);
            final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child));
            final int top = bottom - mDivider.getIntrinsicHeight();
            mDivider.setBounds(left, top, right, bottom);
            mDivider.draw(canvas);
        }
        canvas.restore();
    }


    @Override
    public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
            RecyclerView.State state) {
        if (mOrientation == VERTICAL) {
            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
        } else {
            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先看构造函数，构造函数中获得系统属性android:listDivider，该属性是一个Drawable对象。接着设置mOrientation,我们这里传入的是DividerItemDecoration.VERTICAL。&lt;/p&gt;
&lt;p&gt;上面我们就说了如何添加分割线，那么作为实例，我们先看DividerItemDecoration的getItemOffsets方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void getItemOffsets(Rect outRect, View view, RecyclerView parent,
        RecyclerView.State state) {
    if (mOrientation == VERTICAL) {
        outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());
    } else {
        outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;outRect是当前item四周的间距，类似margin属性，现在设置了该item下间距为mDivider.getIntrinsicHeight()。&lt;/p&gt;
&lt;p&gt;那么getItemOffsets()是怎么被调用的呢？&lt;/p&gt;
&lt;p&gt;RecyclerView继承了ViewGroup，并重写了measureChild()，该方法在onMeasure()中被调用，用来计算每个child的大小，计算每个child大小的时候就需要加上getItemOffsets()设置的外间距：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void measureChild(View child, int widthUsed, int heightUsed) {
    final LayoutParams lp = (LayoutParams) child.getLayoutParams();

    final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
    widthUsed += insets.left + insets.right;
    heightUsed += insets.top + insets.bottom;
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;也就是说getItemOffsets()方法是确定分割线的大小的(这个大小指的是高度，宽度)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么接着onDraw()以及onDrawOver()，两者的作用是什么呢以及两者之间有什么关系呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RecyclerView extends ViewGroup {
    @Override
    public void draw(Canvas c) {
        super.draw(c);

        final int count = mItemDecorations.size();
        
        for (int i = 0; i &amp;lt; count; i++) {
            mItemDecorations.get(i).onDrawOver(c, this, mState);
        }
        ......
    }

    @Override
    public void onDraw(Canvas c) {
        super.onDraw(c);

        final int count = mItemDecorations.size();
        for (int i = 0; i &amp;lt; count; i++) {
            mItemDecorations.get(i).onDraw(c, this, mState);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;根据View的绘制流程，首先调用RecyclerView重写的draw()方法，随后super.draw()即调用View的draw()，该方法会先调用onDraw()（这个方法在RecyclerView重写了），再调用dispatchDraw()绘制children。因此：ItemDecoration的onDraw()在绘制Item之前调用，ItemDecoration的onDrawOver()在绘制Item之后调用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在RecyclerView的onDraw()方法中会得到分割线的数目，并循环调用其onDraw()方法，我们再来看分割线实例DividerItemDecoration的onDraw()方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {
    if (parent.getLayoutManager() == null) {
        return;
    }
    if (mOrientation == VERTICAL) {
        drawVertical(c, parent);
    } else {
        drawHorizontal(c, parent);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里调用了drawVertical&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SuppressLint(&quot;NewApi&quot;)
private void drawVertical(Canvas canvas, RecyclerView parent) {
    canvas.save();
    final int left;
    final int right;
    if (parent.getClipToPadding()) {
        left = parent.getPaddingLeft();
        right = parent.getWidth() - parent.getPaddingRight();
        canvas.clipRect(left, parent.getPaddingTop(), right,
                parent.getHeight() - parent.getPaddingBottom());
    } else {
        left = 0;
        right = parent.getWidth();
    }

    final int childCount = parent.getChildCount();
    for (int i = 0; i &amp;lt; childCount; i++) {
        final View child = parent.getChildAt(i);
        parent.getDecoratedBoundsWithMargins(child, mBounds);
        final int bottom = mBounds.bottom + Math.round(ViewCompat.getTranslationY(child));
        final int top = bottom - mDivider.getIntrinsicHeight();
        mDivider.setBounds(left, top, right, bottom);
        mDivider.draw(canvas);
    }
    canvas.restore();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;drawVertical的逻辑比较简单，重要的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //为分割线设置bounds
 mDivider.setBounds(left, top, right, bottom);
 //画出来
 mDivider.draw(canvas);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;小结-1&quot;&gt;小结&lt;/h4&gt;
&lt;p&gt;在RecyclerView中添加分割线需要的操作已经在上文中比较详细的说明了，这里再总结一下。我们在为RecyclerView添加分割线的时候使用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//设置分割线
mRecyclerView.addItemDecoration(
    new DividerItemDecoration(this,DividerItemDecoration.VERTICAL));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中addItemDecoration方法的参数即为分割线的实例，那么如何创建分割线呢，&lt;br/&gt;创建一个类并继承RecyclerView.ItemDecoration，重写以下两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onDraw()或者onDrawOver: 绘制分割线。&lt;/li&gt;
&lt;li&gt;getItemOffsets(): 设置分割线的宽、高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;基本功能设计&quot;&gt;基本功能设计&lt;/h4&gt;
&lt;p&gt;RecyclerView没有提供类似ListView的addHeaderView或者addFooterView方法，所以我们要自己实现。关于实现的方法也有很多种。目前网上能搜到的主流解决办法是在Adapter中重写getItemViewType方法为头部或者底部布局生成特定的item。从而实现头部布局以及底部布局。&lt;/p&gt;
&lt;p&gt;本篇的解决办法与上面的并无本质上的不同，只是我们在Adapter的外面再包上一层，以类似装饰者设计模式的方式对Adapter进行无侵入式的包装。&lt;/p&gt;
&lt;p&gt;我们希望使用的方式比较简单&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//这个是真正的Adapter，在本例中不需要对其改变
mAdapter = new RecyclerViewDemo2Adapter(mData);
//包装的wrapper，对Adapter进行包装。实现添加Header以及Footer等的功能
mHeaderAndFooterWrapper = new HeaderAndFooterWrapper(mAdapter);

TextView t1 = new TextView(this);
t1.setText(&quot;Header 1&quot;);
TextView t2 = new TextView(this);
t2.setText(&quot;Header 2&quot;);
mHeaderAndFooterWrapper.addHeaderView(t1);
mHeaderAndFooterWrapper.addHeaderView(t2);

mRecyclerView.setAdapter(mHeaderAndFooterWrapper);
mHeaderAndFooterWrapper.notifyDataSetChanged();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们下面先对HeaderAndFooterWrapper基本功能&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HeaderAndFooterWrapper&amp;lt;T&amp;gt; extends RecyclerView.Adapter&amp;lt;RecyclerView.ViewHolder&amp;gt;
{
    //以较高的数值作为基数，每一个Header或者Footer对应不同的数值
    private static final int BASE_ITEM_TYPE_HEADER = 100000;
    private static final int BASE_ITEM_TYPE_FOOTER = 200000;
    
    //存储Header和Footer的集合
    private SparseArrayCompat&amp;lt;View&amp;gt; mHeaderViews = new SparseArrayCompat&amp;lt;&amp;gt;();
    private SparseArrayCompat&amp;lt;View&amp;gt; mFootViews = new SparseArrayCompat&amp;lt;&amp;gt;();
    
    //内部的真正的Adapter
    private RecyclerView.Adapter mInnerAdapter;

    public HeaderAndFooterWrapper(RecyclerView.Adapter adapter)
    {
        mInnerAdapter = adapter;
    }

    private boolean isHeaderViewPos(int position)
    {
        return position &amp;lt; getHeadersCount();
    }

    private boolean isFooterViewPos(int position)
    {
        return position &amp;gt;= getHeadersCount() + getRealItemCount();
    }

    
    public void addHeaderView(View view)
    {
        mHeaderViews.put(mHeaderViews.size() + BASE_ITEM_TYPE_HEADER, view);
    }

    public void addFootView(View view)
    {
        mFootViews.put(mFootViews.size() + BASE_ITEM_TYPE_FOOTER, view);
    }

    public int getHeadersCount()
    {
        return mHeaderViews.size();
    }

    public int getFootersCount()
    {
        return mFootViews.size();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这里使用SparseArrayCompat作为存储Header和Footer的集合，SparseArrayCompat有什么特点呢？它类似于Map，只不过在某些情况下比Map的性能要好，并且只能存储key为int的情况。&lt;/p&gt;
&lt;p&gt;我们这里可以看到HeaderAndFooterWrapper是继承于RecyclerView.Adapter&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//真正进行数据处理以及展示的Adapter
mAdapter = new RecyclerViewDemo2Adapter(mData);
//添加Header以及Footer的wrapper
mHeaderAndFooterWrapper = new HeaderAndFooterWrapper(mAdapter);
//设置空View的wrapper
mEmptyWrapperAdapter = new EmptyWrapper(mHeaderAndFooterWrapper);

mRecyclerView.setAdapter(mEmptyWrapperAdapter);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重写相关方法&quot;&gt;重写相关方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    public class HeaderAndFooterWrapper&amp;lt;T&amp;gt; extends 
        RecyclerView.Adapter&amp;lt;RecyclerView.ViewHolder&amp;gt;
{
    private static final int BASE_ITEM_TYPE_HEADER = 100000;
    private static final int BASE_ITEM_TYPE_FOOTER = 200000;
    //SparseArrayCompat类似于Map，其用法与map相似
    private SparseArrayCompat&amp;lt;View&amp;gt; mHeaderViews = new SparseArrayCompat&amp;lt;&amp;gt;();
    private SparseArrayCompat&amp;lt;View&amp;gt; mFootViews = new SparseArrayCompat&amp;lt;&amp;gt;();

    private RecyclerView.Adapter mInnerAdapter;

    public HeaderAndFooterWrapper(RecyclerView.Adapter adapter)
    {
        mInnerAdapter = adapter;
    }

    /**
     * 重写onCreateViewHolder，创建ViewHolder
     * @param parent 父容器，这里指的是RecyclerView
     * @param viewType view的类型，用int表示，也是SparseArrayCompat的key
     * @return
     */
    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)
    {
        if (mHeaderViews.get(viewType) != null)
        {//如果以viewType为key获取的View为null

            //创建ViewHolder并返回
            ViewHolder holder = new ViewHolder(parent.getContext(), mHeaderViews.get(viewType));
            return holder;

        } else if (mFootViews.get(viewType) != null)
        {
            ViewHolder holder =  new ViewHolder(parent.getContext(), mFootViews.get(viewType));
            return holder;
        }
        return mInnerAdapter.onCreateViewHolder(parent, viewType);
    }

    /**
     * 获得对应position的type
     * @param position
     * @return
     */
    @Override
    public int getItemViewType(int position)
    {
        if (isHeaderViewPos(position))
        {
            return mHeaderViews.keyAt(position);
        } else if (isFooterViewPos(position))
        {
            return mFootViews.keyAt(position - getHeadersCount() - getRealItemCount());
        }
        return mInnerAdapter.getItemViewType(position - getHeadersCount());
    }

    private int getRealItemCount()
    {
        return mInnerAdapter.getItemCount();
    }

    /**
     * 绑定数据
     * @param holder
     * @param position
     */
    @Override
    public void onBindViewHolder(RecyclerView.ViewHolder holder, int position)
    {
        if (isHeaderViewPos(position))
        {
            return;
        }
        if (isFooterViewPos(position))
        {
            return;
        }
        mInnerAdapter.onBindViewHolder(holder, position - getHeadersCount());
    }

    /**
     * 得到item数量 (包括头部布局数量和尾部布局数量)
     * @return
     */
    @Override
    public int getItemCount()
    {
        return getHeadersCount() + getFootersCount() + getRealItemCount();
    }


    private boolean isHeaderViewPos(int position)
    {
        return position &amp;lt; getHeadersCount();
    }

    private boolean isFooterViewPos(int position)
    {
        return position &amp;gt;= getHeadersCount() + getRealItemCount();
    }

    /**
    *以mHeaderViews.size() + BASE_ITEM_TYPE_HEADER为key，头部布局View为Value
    *放入mHeaderViews
    */
    public void addHeaderView(View view)
    {
        mHeaderViews.put(mHeaderViews.size() + BASE_ITEM_TYPE_HEADER, view);
    }

    public void addFootView(View view)
    {
        mFootViews.put(mFootViews.size() + BASE_ITEM_TYPE_FOOTER, view);
    }

    public int getHeadersCount()
    {
        return mHeaderViews.size();
    }

    public int getFootersCount()
    {
        return mFootViews.size();
    }

    class ViewHolder extends RecyclerView.ViewHolder {
        private View mConvertView;
        private Context mContext;

        public ViewHolder(Context context, View itemView) {
            super(itemView);
            mContext = context;
            mConvertView = itemView;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上面的代码，HeaderAndFooterWrapper继承于RecyclerView.Adapter&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 重写onCreateViewHolder，创建ViewHolder
 * @param parent 父容器，这里指的是RecyclerView
 * @param viewType view的类型，用int表示，也是SparseArrayCompat的key
 * @return
 */
@Override
public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)
{
    if (mHeaderViews.get(viewType) != null)
    {//如果以viewType为key获取的View为null

        //创建ViewHolder并返回
        ViewHolder holder = new ViewHolder(parent.getContext(), mHeaderViews.get(viewType));
        return holder;

    } else if (mFootViews.get(viewType) != null)
    {
        ViewHolder holder =  new ViewHolder(parent.getContext(), mFootViews.get(viewType));
        return holder;
    }
    return mInnerAdapter.onCreateViewHolder(parent, viewType);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先看onCreateViewHolder方法，该方法返回ViewHolder,我们在其中为头部以及底部布局单独创建ViewHolder，对于普通的item，我们依然调用内部的mInnerAdapter的onCreateViewHolder方法&lt;/p&gt;
&lt;p&gt;创建好ViewHolder后，便进行绑定的工作了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 绑定数据
 * @param holder
 * @param position
 */
@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position)
{
    if (isHeaderViewPos(position))
    {
        return;
    }
    if (isFooterViewPos(position))
    {
        return;
    }
    mInnerAdapter.onBindViewHolder(holder, position - getHeadersCount());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们头部以及底部布局不进行数据的绑定，其他普通的item依然调用内部真正的mInnerAdapter.onBindViewHolder&lt;/p&gt;
&lt;p&gt;运行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/wtFuQho.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;适配gridlayoutmanager&quot;&gt;适配GridLayoutManager&lt;/h4&gt;
&lt;p&gt;上面我们已经初步实现为RecyclerView添加Header以及Footer了，不过上面的我们的布局模式是LinearyLayoutManager，当我们使用GridLayoutManager时，效果就不是我们所想像的那样了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//设置GridLayoutManager
mRecyclerView.setLayoutManager(new GridLayoutManager(this,3));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ZtqmvMZ.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们设置GridLayoutManager时，可以看到头部布局所展示的样子，头部布局还真的被当做一个普通的item布局了。那么我们需要为这个布局做一些特殊处理。我们知道使用GridLayoutManager的SpanSizeLookup设置某个Item所占空间&lt;/p&gt;
&lt;p&gt;在我们的HeaderAndFooterWrapper中重写onAttachedToRecyclerView方法（该方法在Adapter与RecyclerView相关联时回调），如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void onAttachedToRecyclerView(RecyclerView recyclerView)
{
    mInnerAdapter.onAttachedToRecyclerView(recyclerView);

    RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();
    if (layoutManager instanceof GridLayoutManager)
    {
        final GridLayoutManager gridLayoutManager = (GridLayoutManager) layoutManager;
        final GridLayoutManager.SpanSizeLookup spanSizeLookup = gridLayoutManager.getSpanSizeLookup();

        gridLayoutManager.setSpanSizeLookup(new GridLayoutManager.SpanSizeLookup()
        {
            @Override
            public int getSpanSize(int position)
            {
               int viewType = getItemViewType(position);
              if (mHeaderViews.get(viewType) != null)
              {
                  return layoutManager.getSpanCount();
              } else if (mFootViews.get(viewType) != null)
              {
                  return layoutManager.getSpanCount();
              }
              if (spanSizeLookup != null)
                  return spanSizeLookup.getSpanSize(position);
              return 1;
            }
        });
        gridLayoutManager.setSpanCount(gridLayoutManager.getSpanCount());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当发现layoutManager为GridLayoutManager时，通过设置SpanSizeLookup，对其getSpanSize方法，返回值设置为layoutManager.getSpanCount();&lt;/p&gt;
&lt;h4 id=&quot;适配staggeredgridlayoutmanager&quot;&gt;适配StaggeredGridLayoutManager&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;mRecyclerView.setLayoutManager(new StaggeredGridLayoutManager(3, 
    OrientationHelper.VERTICAL));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们设置StaggeredGridLayoutManager时，可以看到如下效果&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/SfE3dZ5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而针对于StaggeredGridLayoutManager，我们需要使用 StaggeredGridLayoutManager.LayoutParams&lt;/p&gt;
&lt;p&gt;在我们的HeaderAndFooterWrapper中重写onViewAttachedToWindow方法（该方法在Adapter与RecyclerView相关联时回调），如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void onViewAttachedToWindow(RecyclerView.ViewHolder holder)
{
    mInnerAdapter.onViewAttachedToWindow(holder);
    int position = holder.getLayoutPosition();
    if (isHeaderViewPos(position) || isFooterViewPos(position))
    {
         ViewGroup.LayoutParams lp = holder.itemView.getLayoutParams();

        if (lp != null
                &amp;amp;&amp;amp; lp instanceof StaggeredGridLayoutManager.LayoutParams)
        {

            StaggeredGridLayoutManager.LayoutParams p = (StaggeredGridLayoutManager.LayoutParams) lp;

            p.setFullSpan(true);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;为recyclerview设置emptyview&quot;&gt;为RecyclerView设置EmptyView&lt;/h3&gt;
&lt;p&gt;上面已经详细给出了为RecyclerView添加Header以及Footer的例子，关于EmptyView的实现方法与上面基本类似，读者可自行实现，当然在本篇末会给出完整的源码地址。&lt;/p&gt;

&lt;p&gt;RecyclerView和ListView的回收机制非常相似，但是ListView是以View作为单位进行回收，RecyclerView是以ViewHolder作为单位进行回收。相比于ListView，RecyclerView的回收机制更为完善&lt;/p&gt;
&lt;p&gt;Recycler是RecyclerView回收机制的实现类，他实现了四级缓存：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mAttachedScrap: 缓存在屏幕上的ViewHolder。&lt;/li&gt;
&lt;li&gt;mCachedViews: 缓存屏幕外的ViewHolder，默认为2个。ListView对于屏幕外的缓存都会调用getView()。&lt;/li&gt;
&lt;li&gt;mViewCacheExtensions: 需要用户定制，默认不实现。&lt;/li&gt;
&lt;li&gt;mRecyclerPool: 缓存池，多个RecyclerView共用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要想理解RecyclerView的回收机制，我们就必须从其数据展示谈起，我们都知道RecyclerView使用LayoutManager管理其数据布局的显示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：以下源码来自support-v7 25.4.0&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;recyclerviewlayoutmanager&quot;&gt;RecyclerView$LayoutManager&lt;/h2&gt;
&lt;p&gt;LayoutManager是RecyclerView下的一个抽象类，Google提供了LinearLayoutManager,GridLayoutManager以及StaggeredGridLayoutManager基本上能满足大部分开发者的需求。这三个类的代码都非常长，这要分析下来可了不得。本篇文章只分析LinearLayoutManager的一部分内容&lt;/p&gt;
&lt;p&gt;与分析ListView时类似，RecyclerView作为一个ViewGroup，肯定也跑不了那几大过程，我们依然还是只分析其layout过程&lt;/p&gt;
&lt;p&gt;[RecyclerView.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    TraceCompat.beginSection(TRACE_ON_LAYOUT_TAG);
    dispatchLayout();
    TraceCompat.endSection();
    mFirstLayoutComplete = true;
}

void dispatchLayout() {
    if (mAdapter == null) {
        Log.e(TAG, &quot;No adapter attached; skipping layout&quot;);
        // leave the state in START
        return;
    }
    if (mLayout == null) {
        Log.e(TAG, &quot;No layout manager attached; skipping layout&quot;);
        // leave the state in START
        return;
    }
    mState.mIsMeasuring = false;
    if (mState.mLayoutStep == State.STEP_START) {
        //1 没有执行过布局流程的情况
        dispatchLayoutStep1();
        mLayout.setExactMeasureSpecsFrom(this);
        dispatchLayoutStep2();
    } else if (mAdapterHelper.hasUpdates() 
        || mLayout.getWidth() != getWidth() ||
            mLayout.getHeight() != getHeight()) {
        //2 执行过布局流程，但是之后size又有变化的情况
        mLayout.setExactMeasureSpecsFrom(this);
        dispatchLayoutStep2();
    } else {
        //3 执行过布局流程，可以直接使用之前数据的情况
        mLayout.setExactMeasureSpecsFrom(this);
    }
    dispatchLayoutStep3();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过，无论什么情况，最终都是完成dispatchLayoutStep1，dispatchLayoutStep2和dispatchLayoutStep3这三步，这样的情况区分只是为了避免重复计算。&lt;/p&gt;
&lt;p&gt;其中第二步的dispatchLayoutStep2是真正的布局!&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void dispatchLayoutStep2() {
    ...... // 设置状态
    mState.mInPreLayout = false; // 更改此状态，确保不是会执行上一布局操作
    // 真正布局就是这一句话，布局的具体策略交给了LayoutManager
    mLayout.onLayoutChildren(mRecycler, mState);
    ......// 设置和恢复状态
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上面的代码可以知道布局的具体操作都交给了具体的LayoutManager,那我们来分析其中的LinearLayoutManager&lt;/p&gt;
&lt;p&gt;[LinearLayoutManager.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
*LinearLayoutManager的onLayoutChildren方法代码也比较多，这里也不进行逐行分析
*只来看关键的几个点
*/
@Override
public void onLayoutChildren(RecyclerView.Recycler recycler, 
                                RecyclerView.State state) {
    
    ......
    //状态判断以及一些准备操作
    onAnchorReady(recycler, state, mAnchorInfo, firstLayoutDirection);
    /**
    *1 感觉这个函数应该跟上一篇我们所分析的ListView的detachAllViewsFromParent();有点像
    */
    detachAndScrapAttachedViews(recycler);
    ......
    //2 感觉这个函数跟上一篇我们所分析的ListView的fillUp有点像
    fill(recycler, mLayoutState, state, false);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面已经给出了真正布局的代码。我们还是按照上一篇的思路来分析，两次layout&lt;/p&gt;
&lt;h3 id=&quot;第1次layout&quot;&gt;第1次layout&lt;/h3&gt;
&lt;h4 id=&quot;第1个重要函数&quot;&gt;第1个重要函数&lt;/h4&gt;
&lt;p&gt;[RecyclerView$LayoutManager]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /**
     *暂时detach和scrap所有当前附加的子视图。视图将被丢弃到给定的回收器中（即参数recycler）。
    *回收器(即Recycler)可能更喜欢重用scrap的视图。
     *
     * @param recycler 指定的回收器Recycler
     */
    public void detachAndScrapAttachedViews(Recycler recycler) {
        final int childCount = getChildCount();
        for (int i = childCount - 1; i &amp;gt;= 0; i--) {
            final View v = getChildAt(i);
            scrapOrRecycleView(recycler, i, v);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第1次layout时，RecyclerView并没有Child,所以跳过该函数，不过我们从上面的代码注释也知道了该函数跟缓存Recycler有关&lt;/p&gt;
&lt;h4 id=&quot;第2个重要函数&quot;&gt;第2个重要函数&lt;/h4&gt;
&lt;p&gt;[LinearLayoutManager.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int fill(RecyclerView.Recycler recycler, LayoutState layoutState,
        RecyclerView.State state, boolean stopOnFocusable) {
    ......
    int remainingSpace = layoutState.mAvailable + layoutState.mExtra;
    LayoutChunkResult layoutChunkResult = mLayoutChunkResult;
    while ((layoutState.mInfinite || remainingSpace &amp;gt; 0) 
            &amp;amp;&amp;amp; layoutState.hasMore(state)) {//这里循环判断是否还有空间放置item
        ......
        //真正放置的代码放到了这里
        layoutChunk(recycler, state, layoutState, layoutChunkResult);
        ......
    }
    if (DEBUG) {
        validateChildOrder();
    }
    return start - layoutState.mAvailable;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进layoutChunk&lt;/p&gt;
&lt;p&gt;[LinearLayoutManager.java]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void layoutChunk(RecyclerView.Recycler recycler, RecyclerView.State state,
        LayoutState layoutState, LayoutChunkResult result) {
    /**
    *获取一个View，这个函数应该是重点了，
    */
    View view = layoutState.next(recycler);
    ......
    //添加View
    addView(view);
    ......
    //计算View的大小
    measureChildWithMargins(view, 0, 0);
    ......
    //布局
    layoutDecoratedWithMargins(view, left, top, right, bottom);
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进next()&lt;/p&gt;
&lt;p&gt;[LinearLayoutManager$LayoutState]&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;View next(RecyclerView.Recycler recycler) {
    if (mScrapList != null) {
        return nextViewFromScrapList();
    }
    final View view = recycler.getViewForPosition(mCurrentPosition);
    mCurrentPosition += mItemDirection;
    return view;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;getViewForPosition方法可以说是RecyclerView中缓存策略最重要的方法，该方法是从RecyclerView的回收机制实现类Recycler中获取合适的View，或者新创建一个View&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;View getViewForPosition(int position, boolean dryRun) {
    /**
    *从这个函数就能看出RecyclerView是以ViewHolder为缓存单位的些许端倪
    */
    return tryGetViewHolderForPositionByDeadline
    (position, dryRun, FOREVER_NS).itemView;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进tryGetViewHolderForPositionByDeadline&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 *试图获得给定位置的ViewHolder，无论是从 
 *mAttachedScrap、mCachedViews、mViewCacheExtensions、mRecyclerPool、还是直接创建。
 *
 * @return ViewHolder for requested position
 */
@Nullable
ViewHolder tryGetViewHolderForPositionByDeadline(int position,
        boolean dryRun, long deadlineNs) {
    ......
    // 1) 尝试从mAttachedScrap获取
    if (holder == null) {
        holder = getScrapOrHiddenOrCachedHolderForPosition(position, dryRun);
        ......
    }

    if (holder == null) {
        ......
        final int type = mAdapter.getItemViewType(offsetPosition);
        // 2) 尝试从mCachedViews获取
        if (mAdapter.hasStableIds()) {
            holder = getScrapOrCachedViewForId(mAdapter.getItemId(offsetPosition),
                    type, dryRun);
            if (holder != null) {
                // update position
                holder.mPosition = offsetPosition;
                fromScrapOrHiddenOrCache = true;
            }
        }
        
        // 3) 尝试从mViewCacheExtensions获取
        if (holder == null &amp;amp;&amp;amp; mViewCacheExtension != null) {
            ......
            final View view = mViewCacheExtension
                    .getViewForPositionAndType(this, position, type);
            if (view != null) {
                holder = getChildViewHolder(view);
                ......
            }
        }

        // 4) 尝试从mRecyclerPool获取
        if (holder == null) { // fallback to pool
           
            holder = getRecycledViewPool().getRecycledView(type);
            if (holder != null) {
                holder.resetInternal();
                if (FORCE_INVALIDATE_DISPLAY_LIST) {
                    invalidateDisplayListInt(holder);
                }
            }
        }
        if (holder == null) {
           // 5) 直接创建
            holder = mAdapter.createViewHolder(RecyclerView.this, type);
           
        }
    }

    ......
    // 6) 判断是否需要bindHolder
    if (!holder.isBound() 
        || holder.needsUpdate() 
        || holder.isInvalid()) {
            
            final int offsetPosition = mAdapterHelper.findPositionOffset(position);
            bound = tryBindViewHolderByDeadline
                (holder, offsetPosition, position, deadlineNs);
        }
    ......

    return holder;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么在第1次layout时，，前4步都不能获得ViewHolder，那么进入第5， 直接创建&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;holder = mAdapter.createViewHolder(RecyclerView.this, type);

public final VH createViewHolder(ViewGroup parent, int viewType) {
    TraceCompat.beginSection(TRACE_CREATE_VIEW_TAG);
    //这里终于看到我们的亲人onCreateViewHolder
    final VH holder = onCreateViewHolder(parent, viewType);
    holder.mItemViewType = viewType;
    TraceCompat.endSection();
    return holder;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个onCreateViewHolder正是在RecyclerViewDemo1Adapter中我们重写的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    Log.d(TAG,&quot;onCreateViewHolder-&amp;gt;viewtype&quot;+viewType);
    View view = LayoutInflater
                .from(parent.getContext())
                .inflate(R.layout.item_menu_main, parent, false);

    return new ViewHolder(view);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初次创建了ViewHolder之后，便进入6，导致我们重写的onBindViewHolder回调，数据与View绑定了&lt;/p&gt;
&lt;h3 id=&quot;第2次layout&quot;&gt;第2次layout&lt;/h3&gt;
&lt;p&gt;从上一篇ListView中我们就知道了再简单的View也至少需要两次Layout,在ListView中通过把屏幕的子View detach并加入mActivieViews，以避免重复添加item并可通过attach提高性能，那么在RecyclerView中，它的做法与ListView十分类似，RecyclerView也是通过detach子View，并把子View对应的ViewHolder加入其1级缓存mAttachedScrap。这部分我们就不详细分析了，读者可参照上一篇的步骤进行分析。&lt;/p&gt;
&lt;h2 id=&quot;recyclerview与listview-缓存机制对比分析&quot;&gt;RecyclerView与ListView 缓存机制对比分析&lt;/h2&gt;
&lt;p&gt;ListView和RecyclerView最大的区别在于数据源改变时的缓存的处理逻辑，ListView是”一锅端”，将所有的mActiveViews都移入了二级缓存mScrapViews，而RecyclerView则是更加灵活地对每个View修改标志位，区分是否重新bindView。&lt;/p&gt;
&lt;h2 id=&quot;小结-2&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;在一些场景下，如界面初始化，滑动等，ListView和RecyclerView都能很好地工作，两者并没有很大的差异，&lt;strong&gt;但是在需要支持动画，或者频繁更新，局部刷新，建议使用RecyclerView，更加强大完善，易扩展&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;本篇呢，我们分析了RecyclerView的使用方法以及RecyclerView部分源码。目的是为了更好的掌握RecyclerView。&lt;/p&gt;
&lt;p&gt;这里呢再上图总结一下RecyclerView的layout流程&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;&lt;img src=&quot;https://i.imgur.com/zOZdPu3.png&quot;/&gt;&lt;/h2&gt;

&lt;p&gt;下篇呢，也是一篇干货，上面两篇文章，我们的数据都是虚拟的，静态的，而实际开发中数据通常都是从服务器动态获得的，这也产生了一系列问题，如&lt;strong&gt;列表的下拉刷新以及上拉加载、ListVIew异步获取图片显示错位等等问题&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/51854533&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/lmj623565791/article/details/51854533&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;此致，敬礼&lt;/p&gt;
</description>
<pubDate>Wed, 21 Feb 2018 05:11:00 +0000</pubDate>
<dc:creator>忘了12138</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangle12138/p/8456508.html</dc:identifier>
</item>
<item>
<title>Python学习-使用opencv-python提取手掌和手心及部分掌纹 - take-fetter</title>
<link>http://www.cnblogs.com/take-fetter/p/8453589.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/take-fetter/p/8453589.html</guid>
<description>&lt;p&gt;上次我们成功训练了手掌识别器http://www.cnblogs.com/take-fetter/p/8438747.html，可以成功得到识别的结果如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1317659/201802/1317659-20180219110044361-1863624034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来需要使用opencv来获取手掌，去除背景部分，这里就需要用到掩膜(mask)、ROI（region of interest）等相关知识,具体的概念还是不讲了,网上很多。&lt;/p&gt;
&lt;p&gt;首先从图中根据上次的程序画框部分提取手掌(当然自己截图再保存也可以-.-)如下&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180220093247591-1495515910.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;接下来讲解一下提取手掌的方法&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;将图片copy，并将图片转换为ycrcb模式，根据ycrcb中的肤色获取和手掌颜色相近的部分，生成黑白图片&lt;/li&gt;
&lt;li&gt;使用黑白图片获得最大的轮廓并生成轮廓图片并得到一个近似的椭圆&lt;/li&gt;
&lt;li&gt;根据椭圆角度进行旋转(原图片和黑白图片及轮廓图片同时旋转)以尽可能的将手掌放为竖直&lt;/li&gt;
&lt;li&gt;根据原图片和黑白图片，利用黑白图片作为掩膜，得到的原图片如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180220102028019-2087654852.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;　　提取手掌中心:&lt;/h2&gt;
&lt;p&gt;　　算法思想：根据黑白图片，基于距离变换得到手掌中心，并根据最大半径画出手掌的内切圆如图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180221100651489-1345219202.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
 distance = cv2.distanceTransform(black_and_white, cv2.DIST_L2, 5&lt;span&gt;, cv2.CV_32F)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Calculates the distance to the closest zero pixel for each pixel of the source image.&lt;/span&gt;
    maxdist =&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; rows,cols = img.shape&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(distance.shape[0]):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(distance.shape[1&lt;span&gt;]):
            dist &lt;/span&gt;=&lt;span&gt; distance[i][j]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; maxdist &amp;lt;&lt;span&gt; dist:
                x &lt;/span&gt;=&lt;span&gt; j
                y &lt;/span&gt;=&lt;span&gt; i
                maxdist &lt;/span&gt;= dist
&lt;/pre&gt;
&lt;pre&gt;
 cv2.circle(original, (x, y), maxdist, (255, 100, 255), 1, 8, 0)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 　　提取掌纹&lt;/h2&gt;
&lt;p&gt;　　　　现在我们已知了圆的半径和圆心坐标，因此可以根据ROI提取出内切正方形(虽然内切正方形会损失很多的信息，但是目前我还没有想到其他的更好的办法)，作出正方形如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180221103009887-1501819522.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作正方形并提取的代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
final_img =&lt;span&gt; original.copy()&lt;br/&gt;#cv2.circle() this line 
half_slide &lt;/span&gt;= maxdist * math.cos(math.pi / 4&lt;span&gt;)
    (left, right, top, bottom) &lt;/span&gt;= ((x - half_slide), (x + half_slide), (y - half_slide), (y +&lt;span&gt; half_slide))
    p1 &lt;/span&gt;=&lt;span&gt; (int(left), int(top))
    p2 &lt;/span&gt;=&lt;span&gt; (int(right), int(bottom))
    cv2.rectangle(original, p1, p2, (&lt;/span&gt;77, 255, 9), 1, 1&lt;span&gt;)
    final_img &lt;/span&gt;= final_img[int(top):int(bottom),int(left):int(right)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180221105014044-173895605.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到出现了灰色部分，按理说是不会存在的，使用cv2.imwrite发现没有出现任何问题，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317659/201802/1317659-20180221105114695-1136785976.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;感觉是cv2.imshow对于输出图片的像素大小有一定限制,进行了自动填充或者是默认有灰色作为背景色且比在这里我们提取出的图片要大&lt;/p&gt;
&lt;p&gt;代码地址：https://github.com/takefetter/Get_PalmPrint/blob/master/process_palm.py&lt;/p&gt;
&lt;h2&gt;感谢：&lt;/h2&gt;
&lt;p&gt;1.https://github.com/dev-td7/Automatic-Hand-Detection-using-Wrist-localisation 这位老哥的repo，基于肤色的提取和形成近似椭圆给我的启发很大（虽然后半部分完全没有用.....）&lt;/p&gt;
&lt;p&gt;2.http://answers.opencv.org/question/180668/how-to-find-the-center-of-one-palm-in-the-picture/ 虽然基于距离变化参考至这里的回答，不过也算是完成了提问者的需求。&lt;/p&gt;
&lt;p&gt;转载请注明出处http://www.cnblogs.com/take-fetter/p/8453589.html&lt;/p&gt;

</description>
<pubDate>Wed, 21 Feb 2018 03:22:00 +0000</pubDate>
<dc:creator>take-fetter</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/take-fetter/p/8453589.html</dc:identifier>
</item>
<item>
<title>深入研究Spark SQL的Catalyst优化器（原创翻译） - shishanyuan</title>
<link>http://www.cnblogs.com/shishanyuan/p/8455786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shishanyuan/p/8455786.html</guid>
<description>&lt;div readability=&quot;10.112280701754&quot;&gt;Spark SQL是Spark最新和技术最为复杂的组件之一。它支持SQL查询和新的DataFrame API。Spark SQL的核心是Catalyst优化器，它以一种新颖的方式利用高级编程语言特性（例如Scala的&lt;a href=&quot;http://docs.scala-lang.org/tour/pattern-matching.html&quot; target=&quot;_blank&quot;&gt;模式匹配&lt;/a&gt;和&lt;a href=&quot;http://docs.scala-lang.org/overviews/quasiquotes/intro.html&quot; target=&quot;_blank&quot;&gt;quasiquotes&lt;/a&gt;）来构建可扩展查询优化器。&lt;/div&gt;
&lt;div readability=&quot;10.804154302671&quot;&gt;我们最近发布了一篇关于Spark SQL的&lt;a href=&quot;http://people.csail.mit.edu/matei/papers/2015/sigmod_spark_sql.pdf&quot; target=&quot;_blank&quot;&gt;论文&lt;/a&gt;，该论文将出现在SIGMOD 2015（由Davies Liu，Joseph K. Bradley，Xiangrui Meng，Tomer Kaftan，Michael J. Franklin和Ali Ghodsi合著）中。在这篇博客文章中，我们重述该论文的部分内容，解释Catalyst优化器的内部功能以实现更广泛的应用。&lt;/div&gt;
&lt;p&gt;为了实现Spark SQL，我们设计了一个新的可扩展优化器Catalyst，它基于Scala中的函数式编程结构。 Catalyst的可扩展设计有两个目的。首先，我们希望能够轻松地为Spark SQL添加新的优化技术和功能，尤其是为了解决我们在使用大数据时遇到的各种问题（例如，半结构化数据和高级分析）。其次，我们希望使外部开发人员能够扩展优化器 - 例如，通过添加数据源特定规则，可以将过滤或聚合的数据推送到外部存储系统，或者支持新的数据类型。 Catalyst支持基于规则和基于成本的优化。&lt;/p&gt;
&lt;p&gt;Catalyst的核心是使用一个通用库生成树并使用规则操作这些树。在该框架的基础上，构建了用于关系查询处理库（例如表达式，逻辑查询计划）和处理执行查询不同阶段的几组规则：分析、逻辑优化、物理计划和代码生成，代码生成将部分查询编译为Java字节码。对于后者，使用了Scala特性quasiquotes，它可以很容易地在运行时由组合表达式生成代码。最后，Catalyst提供了几个公共扩展点，包括外部数据源和用户定义的类型。&lt;/p&gt;

&lt;p&gt;Catalyst中的主要数据类型是由节点对象组成的树。 每个节点都有一个节点类型和零个或多个子节点。 新的节点类型在Scala中定义为TreeNode类的子类。 这些对象是不可变的，并可以使用函数转换来操作，如下一小节所讨论的。&lt;/p&gt;
&lt;p&gt;一个简单的例子，使用非常简单的表达式语言描述三个节点类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Literal（值：Int）：常数值&lt;/li&gt;
&lt;li&gt;Attribute（名称：String）：输入行的属性，例如“x”&lt;/li&gt;
&lt;li&gt;Add（左：TreeNode，右：TreeNode）：两个表达式的总和。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些类可以用来构建树; 例如，表达式x +（1 + 2）的树将在Scala代码中表示如下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Add(Attribute(x), Add(Literal(1), Literal(2)))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;file:///C:/Users/GUOJIN~1/AppData/Local/Temp/enhtmlclip/1.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107289/201802/107289-20180220203734121-1193992126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;规则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;81.107663283893&quot;&gt;
&lt;p&gt;可以使用规则来操作树，这些规则是从一棵树到另一棵树的函数。虽然规则可以在其输入树上运行任意代码（因为该树只是一个Scala对象），但最常见的方法是使用一组模式匹配函数来查找和替换具有特定结构的子树。&lt;/p&gt;
&lt;p&gt;模式匹配是许多函数式语言的一个特性，它允许从代数数据类型的潜在嵌套结构中提取值。在Catalyst中，树提供了一种转换方法，该方法递归地在树的所有节点上应用模式匹配函数，将每个模式匹配转换为结果。例如，我们可以实现一个在常量之间相加？？？Add操作的规则，如下所示：&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;tree.transform {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;case&lt;/span&gt; Add(Literal(c1), Literal(c2)) =&amp;gt; Literal(c1+&lt;span&gt;c2)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将此应用于x +（1 + 2）的树会产生新的树x + 3。这里关键是使用了Scala的标准模式匹配语法，它可用于匹配对象的类型和为提取的值（这里为c1和c2）提供名称。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;传递给变换的模式匹配表达式是一个部分函数，​​这意味着它只需要匹配所有输入树的子集。 Catalyst将测试规则适用树的哪些部分，自动跳过并下降到不匹配的子树。这种能力意味着规则只需对给定适用优化的树进行推理，而对那些不适用的数不进行推理。因此，当新的操作符新增到系统中时，这些规则不需要修改。&lt;/p&gt;
&lt;p&gt;规则（和一般的Scala模式匹配）可以在同一个变换调用中匹配多个模式，这使得一次实现多个转换来得非常简洁。&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;tree.transform {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;case&lt;/span&gt; Add(Literal(c1), Literal(c2)) =&amp;gt; Literal(c1+&lt;span&gt;c2)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;case&lt;/span&gt; Add(left, Literal(0)) =&amp;gt;&lt;span&gt; left
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;case&lt;/span&gt; Add(Literal(0), right) =&amp;gt;&lt;span&gt; right
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际上，规则可能需要多次执行才能完全转换树。Catalyst将规则形成批处理，并执行每个批处理至固定点，该固定点是树应用其规则后不发生改变。虽然规则运行到固定点意味着每个规则是简单且自包含，但这些规则仍会对树上产生较大的全局效果。在上面的例子中，重复的应用规则会持续折叠较大的树，比如（x + 0）+（3 + 3）。另一个例子，第一个批处理可以分析所有属性指定类型的表达式，而第二批处理可使用这些类型来进行常量折叠。在每批处理完毕后，开发人员还可以对新树进行规范性检查（例如，查看所有属性为指定类型），这些检查一般使用递归匹配来编写。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;最后，规则条件及其本身可以包含任意的Scala代码。这使得Catalyst比领域特定语言在优化器上更强大，同时保持简洁特性。&lt;/p&gt;
&lt;p&gt;根据经验，对不可变树的函数转换使得整个优化器非常易于推理和调试。规则也支持在优化器中并行化，尽管该特性还没有利用这个。&lt;/p&gt;

&lt;p&gt;Catalyst的通用树转换框架分为四个阶段，如下所示：（1）分析解决引用的逻辑计划，（2）逻辑计划优化，（3）物理计划，（4）代码生成用于编译部分查询生成Java字节码。 在物理规划阶段，Catalyst可能会生成多个计划并根据成本进行比较。 所有其他阶段完全是基于规则的。 每个阶段使用不同类型的树节点; Catalyst包括用于表达式、数据类型以及逻辑和物理运算符的节点库。 这些阶段如下所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107289/201802/107289-20180220203801358-731069334.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;file:///C:/Users/GUOJIN~1/AppData/Local/Temp/enhtmlclip/2.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;解析&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;sales”中列的类型，甚至列名是否有效，在查询表sale元数据之前这些都是未知的。如果不知道它的类型或没有将它匹配到输入表（或别名）时，那么该属性称为未解析。Spark SQL使用Catalyst规则和记录所有表元数据的Catalog对象来解析这些属性的。构建具有未绑定属性和数据类型的“未解析的逻辑计划”树后，然后执行以下规则：&lt;/p&gt;
&lt;p&gt;1、从Catalog中查找名称关系&lt;/p&gt;
&lt;p&gt;2、将命名属性（如col）映射到操作符的子项&lt;/p&gt;
&lt;p&gt;3、将那些属性引用相同的值给它们一个唯一的ID（随后遇到如col=col时可以进行优化）&lt;/p&gt;
&lt;p&gt;4、通过表达式传递和强制类型：例如，我们无法知道1+col的返回类型，直到解析出col并将其子表达式转换为兼容类型。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;逻辑计划优化&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在逻辑优化阶段，逻辑计划应用了标准的基于规则的优化。（基于成本的优化通过规则生成多个计划，然后计算其成本来执行。）这些优化包括常量折叠、谓词下推、项目裁剪、空值传播、布尔表达式简化以及其他规则。总的来说，为各种情况添加规则非常简单。例如，当我们将固定精度的DECIMAL类型添加到Spark SQL时，我们想要以较低精度的方式优化DECIMAL的聚合（例如求和和平均值）;只需要12行代码编写一个规则便可在SUM和AVG表达式中找到该数，然后将它们转换为未缩放的64位LONG，然后进行聚合，最后将结果转换回来。这个规则的简化版本，只能优化SUM表达式如下所示：&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; object DecimalAggregates &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Rule[LogicalPlan] {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Maximum number of decimal digits in a Long &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;   val MAX_LONG_DIGITS = 18
&lt;span&gt;4&lt;/span&gt;   def apply(plan: LogicalPlan): LogicalPlan =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    plan transformAllExpressions {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;       &lt;span&gt;case&lt;/span&gt;&lt;span&gt; Sum(e @ DecimalType.Expression(prec, scale))
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;           &lt;span&gt;if&lt;/span&gt; prec + 10 &amp;lt;= MAX_LONG_DIGITS =&amp;gt;
&lt;span&gt;8&lt;/span&gt;         MakeDecimal(Sum(UnscaledValue(e)), prec + 10&lt;span&gt;, scale) }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再举一个例子，一个12行代码的规则通过简单的正则表达式将LIKE表达式优化为String.startsWith或String.contains调用。在规则中使用任意Scala代码使得这些优化易于表达，而这些规则超越了子树结构的模式匹配。&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;物理计划&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在物理计划阶段，Spark SQL使用逻辑计划生成一个或多个物理计划，这个过程采用了匹配Spark执行引擎的物理运算符。然后使用成本模型选择计划。目前，基于成本的优化仅用于选择连接算法：对于已知很小的关系，Spark SQL使用Spark中的点对点广播工具进行广播连接。不过，该框架支持更深入地使用基于成本的优化，因为可以使用规则对整棵树进行递归估计。因此，我们打算在未来实施更加丰富的基于成本的优化。&lt;/p&gt;
&lt;p&gt;物理计划还执行基于规则的物理优化，例如将管道项目或过滤器合并到一个Spark映射操作中。另外，它可以将操作从逻辑计划推送到支持谓词或项目下推的数据源。我们将在后面的章节中描述这些数据源的API。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;代码生成&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;查询优化的最后阶段涉及生成Java字节码用于在每台机器上运行。由于Spark SQL经常在内存数据集上运行，其中处理受CPU限制，我们希望Spark SQL支持代码生成以加快执行速度。尽管如此，代码生成引擎的构建通常很复杂，特别是编译器。Catalyst依靠Scala语言的特殊功能quasiquotes来简化代码生成。 Quasiquotes允许在Scala语言中对抽象语法树（AST）进行编程式构建，然后在运行时将其提供给Scala编译器以生成字节码。使用Catalyst将表示SQL表达式的树转换为Scala代码的AST用于描述表达式，然后编译并运行生成的代码。&lt;/p&gt;
&lt;p&gt;作为一个简单的例子，参考第4.2节介绍的Add、Attribute和Literal树节点可以写成（x + y）+1表达式。如果没有使用代码生成，这些表达式必须遍历Add、Attribute和Literal节点树行走才能解释每行数据。这会引入大量的分支和虚函数调用，从而减慢执行速度。如果使用了代码生成，可以编写一个函数将特定的表达式树转换为Scala AST，如下所示：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; def compile(node: Node): AST =&lt;span&gt; node match {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;case&lt;/span&gt; Literal(value) =&amp;gt; q&quot;$value&quot;
&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;case&lt;/span&gt; Attribute(name) =&amp;gt; q&quot;row.get($name)&quot;
&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;case&lt;/span&gt; Add(left, right) =&amp;gt; q&quot;${compile(left)} + ${compile(right)}&quot;
&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以q开头的字符串是quasiquotes，虽然它们看起来像字符串，但它们在编译时由Scala编译器解析，并代表其代码的AST。 Quasiquotes用$符号表示法将变量或其他AST拼接到它们中。例如，文字（1）将成为1的Scala表达式的AST，而属性（“x”）变为row.get（“x”）。最后，类似Add（Literal（1），Attribute（“x”））的树成为像1 + row.get（“x”）这样的Scala表达式的AST。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Quasiquotes在编译时进行类型检查，以确保只替换合适的AST或文字，使得它们比字符串连接更有用，并且直接生成Scala AST，而非在运行时运行Scala语法分析器。此外，它们是高度可组合的，因为每个节点的代码生成规则不需要知道其子节点返回的树是如何构建的。最后，如果Catalyst缺少表达式级别的优化，则由Scala编译器对结果代码进行进一步优化。下图显示quasiquotes生成代码其性能类似于手动优化的程序。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107289/201802/107289-20180220203832654-1442177655.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;file:///C:/Users/GUOJIN~1/AppData/Local/Temp/enhtmlclip/3.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;我们发现quasiquotes非常接近于代码生成，并且发现即使是Spark SQL的新贡献者也可以快速为新类型的表达式添加规则。 Quasiquotes也适用于在本地Java对象上运行的目标：当从这些对象访问字段时，可以直接访问所需字段，而不必将对象复制成Spark SQL 行，并使用行访问器方法。最后，将代码生成的评估与对尚未生成代码的表达式的解释评估结合起来很简单，因为编译的Scala代码可以直接使用到表达式解释器中。&lt;/p&gt;

&lt;div readability=&quot;7.7798165137615&quot;&gt;这篇博客文章介绍了Spark SQL的Catalyst优化器内部原理。 通过这种新颖、简单的设计使Spark社区能够快速建立原型、实现和扩展引擎。 你可以在这里&lt;a href=&quot;http://people.csail.mit.edu/matei/papers/2015/sigmod_spark_sql.pdf&quot; target=&quot;_blank&quot;&gt;阅读&lt;/a&gt;其余的论文。 &lt;/div&gt;
&lt;p&gt;您还可以从以下内容中找到有关Spark SQL的更多信息：&lt;/p&gt;






</description>
<pubDate>Wed, 21 Feb 2018 01:03:00 +0000</pubDate>
<dc:creator>shishanyuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shishanyuan/p/8455786.html</dc:identifier>
</item>
<item>
<title>五、XML与xpath--------------爬取美女图片 - 酱紫酱</title>
<link>http://www.cnblogs.com/jiangzijiang/p/8455553.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangzijiang/p/8455553.html</guid>
<description>
&lt;p&gt;除了正则表达式处理HTML文档，我们还可以用XPath，先将 HTML文件 转换成 XML文档，然后用 XPath 查找 HTML 节点或元素。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt; 先用一个小实例开头吧（爬取贴吧每个帖子的图片）：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Myspider():
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.post_bar &lt;/span&gt;= input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入贴吧名：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.num &lt;/span&gt;= 1

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; postBar(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        获取贴吧帖子的url
        :return:
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        base_url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://tieba.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        url &lt;/span&gt;= base_url + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; self.post_bar
        response &lt;/span&gt;=&lt;span&gt; requests.get(url)
        response.encoding &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解析html 为 HTML 文档，&lt;/span&gt;
        html =&lt;span&gt; etree.HTML(response.text)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 抓取当前页面的所有帖子的url的后半部分，也就是帖子编号&lt;/span&gt;
        tieName = html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class =&quot;threadlist_lz clearfix&quot;]/div/a/@href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; tieUrl &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tieName:
            url &lt;/span&gt;= base_url +&lt;span&gt; tieUrl
            self.imgUrl(url)
    &lt;br/&gt;　　 &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　 def&lt;/span&gt;&lt;span&gt; imgUrl(self,url):&lt;br/&gt;　　　# 获取图片的url
        response &lt;/span&gt;=&lt;span&gt; requests.get(url)
        response.encoding &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        html &lt;/span&gt;=&lt;span&gt; etree.HTML(response.text)
        tieName &lt;/span&gt;= html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//img[@class=&quot;BDE_Image&quot;]/@src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; tieUrl &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tieName:
            self.loadImg(tieUrl)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; loadImg(self,url):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(url)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;正在下载第%s张&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; self.num)
        file &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;images/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(self.num) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 获取图片里的内容&lt;/span&gt;
        images =&lt;span&gt; requests.get(url)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3. 调用文件对象write() 方法，将page_html的内容写入到文件里&lt;/span&gt;
&lt;span&gt;        file.write(images.content)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4. 最后关闭文件&lt;/span&gt;
&lt;span&gt;        file.close()
        self.num &lt;/span&gt;+=1

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; ==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    imgSpdier &lt;/span&gt;=&lt;span&gt; Myspider()
    imgSpdier.postBar()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;请输入贴吧名：美女
https:&lt;/span&gt;//imgsa.baidu.com/forum/w%3D580%3Bcp%3Dtieba%2C10%2C768%3Bap%3D%C3%C0%C5%AE%B0%C9%2C90%2C776/sign=b664839c067b02080cc93fe952e291a3/&lt;span&gt;22292df5e0fe99256453c26938a85edf8db171a8.jpg
正在下载第1张
https:&lt;/span&gt;//imgsa.baidu.com/forum/w%3D580%3Bcp%3Dtieba%2C10%2C768%3Bap%3D%C3%C0%C5%AE%B0%C9%2C90%2C776/sign=17e5260777ec54e741ec1a168903f820/&lt;span&gt;b364034f78f0f7369919e7380655b319ebc41327.jpg
正在下载第2张
https:&lt;/span&gt;//imgsa.baidu.com/forum/w%3D580%3Bcp%3Dtieba%2C10%2C768%3Bap%3D%C3%C0%C5%AE%B0%C9%2C90%2C776/sign=e4394fc1ab86c91708035231f90613bf/&lt;span&gt;b8ec08fa513d2697281da36459fbb2fb4316d839.jpg
正在下载第3张
https:&lt;/span&gt;//imgsa.baidu.com/forum/w%3D580%3Bcp%3Dtieba%2C10%2C768%3Bap%3D%C3%C0%C5%AE%B0%C9%2C90%2C776/sign=852774f1164c510faec4e2125062465d/&lt;span&gt;873df8dcd100baa1cf72ed824b10b912c8fc2ea8.jp&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开存储图片的文件夹：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1317826/201802/1317826-20180220212346268-2081819910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;XML 指可扩展标记语言（e&lt;strong&gt;X&lt;/strong&gt;tensible &lt;strong&gt;M&lt;/strong&gt;arkup &lt;strong&gt;L&lt;/strong&gt;anguage）。&lt;/p&gt;
&lt;p&gt;XML 被设计用来传输和存储数据，而非显示数据。&lt;/p&gt;
&lt;p&gt;　　XML 是一种标记语言，很类似 HTML&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;xml-和-html-的区别&quot;&gt;XML 和 HTML 的区别&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据格式&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;设计目标&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;XML&lt;/td&gt;
&lt;td&gt;Extensible Markup Language &lt;code&gt;（可扩展标记语言）&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;被设计为传输和存储数据，其焦点是数据的内容。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;HTML&lt;/td&gt;
&lt;td&gt;HyperText Markup Language &lt;code&gt;（超文本标记语言）&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示数据以及如何更好显示数据。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;HTML DOM&lt;/td&gt;
&lt;td&gt;Document Object Model for HTML &lt;code&gt;(文档对象模型)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;通过 HTML DOM，可以访问所有的 HTML 元素，连同它们所包含的文本和属性。可以对其中的内容进行修改和删除，同时也可以创建新的元素。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;
&lt;h2 id=&quot;xml文档示例&quot;&gt;XML文档示例&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book &lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;=&quot;cooking&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Everyday Italian&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Giada De Laurentiis&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2005&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30.00&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book &lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;=&quot;children&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Harry Potter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;J K. Rowling&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2005&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book &lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;=&quot;web&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;XQuery Kick Start&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;James McGovern&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Per Bothner&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Kurt Cagle&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;James Linn&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Vaidyanathan Nagarajan&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2003&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;49.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book &lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;=&quot;web&quot;&lt;/span&gt;&lt;span&gt; cover&lt;/span&gt;&lt;span&gt;=&quot;paperback&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Learning XML&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Erik T. Ray&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2003&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;39.95&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;XML的节点关系&lt;/h3&gt;
&lt;p id=&quot;1-父（parent）&quot;&gt;&lt;strong&gt;1. 父（Parent）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个元素以及属性都有一个父。&lt;/p&gt;
&lt;p&gt;下面有的XML例子中，book 元素是 title、author、year 以及 price 元素的父。&lt;/p&gt;
&lt;h4 id=&quot;2-子（children）&quot;&gt;2. 子（Children）&lt;/h4&gt;
&lt;p&gt;元素节点可有零个、一个或多个子。&lt;/p&gt;
&lt;p&gt;在下面的例子中，title、author、year 以及 price 元素都是 book 元素的子。&lt;/p&gt;
&lt;h4 id=&quot;3-同胞（sibling）&quot;&gt;3. 同胞（Sibling）&lt;/h4&gt;
&lt;p&gt;拥有相同的父的节点&lt;/p&gt;
&lt;p&gt;在下面的例子中，title、author、year 以及 price 元素都是同胞。&lt;/p&gt;
&lt;h4 id=&quot;4-先辈（ancestor）&quot;&gt;4. 先辈（Ancestor）&lt;/h4&gt;
&lt;p&gt;某节点的父、父的父，等等。&lt;/p&gt;
&lt;p&gt;在下面的例子中，title 元素的先辈是 book 元素和 bookstore 元素。&lt;/p&gt;
&lt;h4 id=&quot;5-后代（descendant）&quot;&gt;5. 后代（Descendant）&lt;/h4&gt;
&lt;p&gt;某个节点的子，子的子，等等。&lt;/p&gt;
&lt;p&gt;在下面的例子中，bookstore 的后代是 book、title、author、year 以及 price 元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Harry Potter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;J K. Rowling&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2005&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;29.99&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bookstore&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;

&lt;p&gt;XPath (XML Path Language) 是一门在 XML 文档中查找信息的语言，可用来在 XML 文档中对元素和属性进行遍历。&lt;/p&gt;
&lt;p id=&quot;这些就是xpath的语法内容，在运用到python抓取时要先转换为xml。&quot;&gt;&lt;strong&gt;以下是XPath的语法内容，在运用到Python抓取时要先转换为xml。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;XPath 使用路径表达式来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。&lt;/p&gt;
&lt;p&gt;下面列出了最常用的路径表达式：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;表达式&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;描述&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;nodename&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取此节点的所有子节点。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;/&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;从根节点选取。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;//&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;.&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取当前节点。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;..&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取当前节点的父节点。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;@&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选取属性。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;路径表达式&lt;/th&gt;
&lt;th&gt;结果&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/bookstore/book[1]&lt;/td&gt;
&lt;td&gt;选取属于 bookstore 子元素的第一个 book 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;/bookstore/book[last()]&lt;/td&gt;
&lt;td&gt;选取属于 bookstore 子元素的最后一个 book 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;/bookstore/book[last()-1]&lt;/td&gt;
&lt;td&gt;选取属于 bookstore 子元素的倒数第二个 book 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;/bookstore/book[position()&amp;lt;3]&lt;/td&gt;
&lt;td&gt;选取最前面的两个属于 bookstore 元素的子元素的 book 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;//title[@lang]&lt;/td&gt;
&lt;td&gt;选取所有拥有名为 lang 的属性的 title 元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;//title[@lang=’eng’]&lt;/td&gt;
&lt;td&gt;选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;/bookstore/book[price&amp;gt;35.00]&lt;/td&gt;
&lt;td&gt;选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;/bookstore/book[price&amp;gt;35.00]/title&lt;/td&gt;
&lt;td&gt;选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;

&lt;p&gt;lxml 是 一个HTML/XML的解析器，主要的功能是如何解析和提取 HTML/XML 数据。&lt;/p&gt;
&lt;p&gt;lxml和正则一样，也是用 C 实现的，是一款高性能的 Python HTML/XML 解析器，我们可以利用之前学习的XPath语法，来快速的定位特定元素以及节点信息。&lt;/p&gt;
&lt;p&gt;lxml python 官方文档：&lt;a href=&quot;http://lxml.de/index.html&quot; target=&quot;_blank&quot;&gt;http://lxml.de/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;需要安装C语言库，可使用 pip 安装：&lt;code&gt;pip install lxml&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

text &lt;/span&gt;= &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link1.html&quot;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-inactive&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;third item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt; # 注意，此处缺少一个 &amp;lt;/li&amp;gt; 闭合标签
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;利用etree.HTML，将字符串解析为HTML文档&lt;/span&gt;
html =&lt;span&gt; etree.HTML(text)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 按字符串序列化HTML文档&lt;/span&gt;
result = etree.tostring(html).decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span readability=&quot;3&quot;&gt;)&lt;p&gt;#保存成文件，下面会用&lt;br/&gt;with open('hello.html','w') as f:&lt;br/&gt;　　f.write(result)

&lt;/p&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link1.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;first item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link2.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-inactive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link3.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;third item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link4.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;item-0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;link5.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;fifth item&amp;lt;/a&amp;gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;amp;#27880;&amp;amp;#24847;&amp;amp;#65292;&amp;amp;#27492;&amp;amp;#22788;&amp;amp;#32570;&amp;amp;#23569;&amp;amp;#19968;&amp;amp;#20010; &amp;lt;/li&amp;gt; &amp;amp;#38381;&amp;amp;#21512;&amp;amp;#26631;&amp;amp;#31614;&lt;/span&gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;lxml 可以自动修正 html 代码，例子里不仅补全了 li 标签，还添加了 body，html 标签。&lt;/p&gt;
&lt;h3&gt;文件读取：利用 etree.parse() 方法来读取文件。&lt;/h3&gt;
&lt;hr/&gt;
&lt;h4 id=&quot;1-获取所有的-li-标签&quot;&gt;1. 获取所有的 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 标签&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; lxml &lt;span&gt;import&lt;/span&gt;&lt;span&gt; etree

html &lt;/span&gt;= etree.parse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(html))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 显示etree.parse() 返回类型&lt;/span&gt;
&lt;span&gt;
result &lt;/span&gt;= html.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印&amp;lt;li&amp;gt;标签的元素集合&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(len(result))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(result))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(result[0]))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml.etree._ElementTree&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;&lt;span&gt;
[&lt;/span&gt;&amp;lt;Element li at 0xc02e048&amp;gt;, &amp;lt;Element li at 0xc02e088&amp;gt;, &amp;lt;Element li at 0xc02e0c8&amp;gt;, &amp;lt;Element li at 0xc02e108&amp;gt;, &amp;lt;Element li at 0xc02e148&amp;gt;&lt;span&gt;]
&lt;/span&gt;5
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&amp;lt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml.etree._Element&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;2-继续获取li-标签的所有-class属性&quot;&gt;2. 继续获取&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 标签的所有 &lt;code&gt;class&lt;/code&gt;属性:result = html.xpath('//li/@class')            结果：['item-0', 'item-1', 'item-inactive', 'item-1', 'item-0']&lt;/h4&gt;
&lt;h4 id=&quot;3-继续获取li标签下hre-为-link1html-的-a-标签&quot;&gt;3. 继续获取&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;标签下&lt;code&gt;href&lt;/code&gt; 为 &lt;code&gt;link1.html&lt;/code&gt; 的 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 标签：result = html.xpath('//li/a[@href=&quot;link1.html&quot;]')   结果：[&amp;lt;Element a at 0x9bce088&amp;gt;]&lt;/h4&gt;





</description>
<pubDate>Wed, 21 Feb 2018 00:29:00 +0000</pubDate>
<dc:creator>酱紫酱</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiangzijiang/p/8455553.html</dc:identifier>
</item>
<item>
<title>用 k8s 运行一次性任务 - 每天5分钟玩转 Docker 容器技术（132） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8454758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8454758.html</guid>
<description>&lt;p&gt;&lt;span&gt;容器按照持续运行的时间可分为两类：服务类容器和工作类容器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务类容器通常持续提供服务，需要一直运行，比如 http server，daemon 等。工作类容器则是一次性任务，比如批处理程序，完成后容器就退出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kubernetes 的 Deployment、ReplicaSet 和 DaemonSet 都用于管理服务类容器；对于工作类容器，我们用 Job。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看一个简单的 Job 配置文件 myjob.yml：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201802/775365-20180220064045805-321573546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;① &lt;/span&gt;&lt;code&gt;&lt;span&gt;batch/v1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是当前 Job 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;apiVersion&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;② 指明当前资源的类型为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Job&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;③ &lt;/span&gt;&lt;code&gt;&lt;span&gt;restartPolicy&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定什么情况下需要重启容器。对于 Job，只能设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Never&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或者 &lt;/span&gt;&lt;code&gt;&lt;span&gt;OnFailure&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。对于其他 controller（比如 Deployment）可以设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Always&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl apply -f myjob.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 启动 Job。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201802/775365-20180220064105847-1011314811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;kubectl get job&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看 Job 的状态：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201802/775365-20180220064121563-254103002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;DESIRED&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SUCCESSFUL&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 都为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，表示按照预期启动了一个 Pod，并且已经成功执行。&lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl get pod&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看 Pod 的状态：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201802/775365-20180220064133952-1424103149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;因为 Pod 执行完毕后容器已经退出，需要用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;--show-all&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 才能查看 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Completed&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 状态的 Pod。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;kubectl logs&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可以查看 Pod 的标准输出：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201802/775365-20180220064149313-949204956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上是 Pod 成功执行的情况，如果 Pod 失败了会怎么样呢？我们下一节讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 21:50:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8454758.html</dc:identifier>
</item>
<item>
<title>云计算之路-阿里云上：重启 manager 节点引发 docker swarm 集群宕机 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/8455956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/8455956.html</guid>
<description>&lt;p&gt;为了迎接春节假期后的访问高峰，我们今天对 docker swarm 集群进行了变更操作，购买了1台阿里云4核8G的服务器作为 worker 节点，由原来的  3 manager nodes + 2 worker nodes 变为  3 manager nodes + 3 worker nodes 。&lt;/p&gt;
&lt;p&gt;晚上，我们对已经持续运行一段时间的5个节点逐一进行重启操作，重启方式如下：&lt;/p&gt;
&lt;p&gt;1）docker node update --availability drain 让节点下线&lt;br/&gt;2）阿里云控制台重启服务器&lt;br/&gt;3）docker node update --availability active 让节点上线&lt;/p&gt;
&lt;p&gt;以前多次进行过这样的操作，未曾遇到问题，而今天在将其中1台manager节点下线后竟然意外地引发了整个集群宕机 。。。21:39 - 22:02 左右，这个突发的故障给您带来很大的麻烦，请您谅解。受这次故障影响的站点有 &lt;a href=&quot;https://ing.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;闪存&lt;/a&gt;，&lt;a href=&quot;https://q.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;博问&lt;/a&gt;，&lt;a href=&quot;https://edu.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;班级&lt;/a&gt;，&lt;a href=&quot;https://home.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;园子&lt;/a&gt;，&lt;a href=&quot;https://msg.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;短信息&lt;/a&gt;，&lt;a href=&quot;https://job.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;招聘&lt;/a&gt;，&lt;a href=&quot;https://group.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;小组&lt;/a&gt;，&lt;a href=&quot;https://wz.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;网摘&lt;/a&gt;，&lt;a href=&quot;https://news.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;新闻&lt;/a&gt;，openapi 。&lt;/p&gt;
&lt;p&gt;经过分析，我们得到的教训是尽可能避免只有2个manager节点的情况（manager节点采用的是投票机制，少数服从多数，2个节点的投票永远是1:1，这也是一种不稳定情况）。针对这个教训，我们调整了节点的部署，改为了 5 manager nodes + 1 worker nodes ，这样即使2个manger节点下线或出问题，也不会群龙无首。&lt;/p&gt;
&lt;p&gt;docker swarm 集群的不稳定让我们如履薄冰，今年我们会想尽一切办法彻底解决这个问题。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 15:33:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/8455956.html</dc:identifier>
</item>
<item>
<title>【SSH框架】之Hibernate系列一 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8455986.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8455986.html</guid>
<description>
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;微信公众号：compassblog&lt;/p&gt;
&lt;p&gt;欢迎关注、转发，互相学习，共同进步！&lt;/p&gt;
&lt;p&gt;有任何问题，请后台留言联系！&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h3 id=&quot;h1hibernate&quot;&gt;1、Hibernate框架概述&lt;/h3&gt;
&lt;p&gt;（1）、什么是Hibernate&lt;br/&gt;Hibernate是一个开放源代码的 ORM 框架，是主流的Java持久层框架之一，它对 JDBC进行了轻量级的对象封装，使得Java开发人员可以使用面向对象的编程思想来操作数据库。&lt;br/&gt;（2）、Hibernate在三层架构中的位置&lt;br/&gt;上篇文章所讲的Struts2框架取代的是三层框架中的web层，而Hibernate框架取代的则是dao层，具体描述如下图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b33a5e0e10c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（3）、什么是ORM&lt;br/&gt;ORM（Object Relational Mapping），即对象关系映射，就是利用描述对象和数据库表之间映射的元数据，自动把Java应用程序中的对象，持久化到关系型数据库的表中。通过操作Java对象，就可以完成对数据库表的操作。可以把 ORM 理解为关系型数据和对象的一个纽带，开发人员只需要关注纽带一端映射的对象即可。ORM 实现原理如下图：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b359b2c1b9c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（4）、Hibernate框架的优势与功能&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Hlbernate对JDBC访问数据库的代码做了轻量级封装，大大简化了数据访问层繁琐的重复性代码，并且减少了内存消耗，加快了运行效率。&lt;/li&gt;
&lt;li&gt;Hlbernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，它很大程度的简化了DAO (DataAccess Object，数据访问对象）层编码工作。操作数据库的时候，可以以面向对象的方式来完成，不再需要书写SQL语句。&lt;/li&gt;
&lt;li&gt;Hlbernate的性能非常好，映射的灵活性很出色。它支持很多关系型数据库，从一对一到多对多的各种复杂关系。&lt;/li&gt;
&lt;li&gt;可扩展性强，由于源代码的开源以及API的开放，当本身功能不够用时，可以自行编码进行扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h2hibernate&quot;&gt;2、搭建Hibernate框架，完成第一个应用实例&lt;/h3&gt;
&lt;p&gt;（1）、创建一个web项目，导入所需要的jar包，包括数据库驱动包，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b37b63c6d3f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;（2）、创建数据库demo_project和表user，建表语句如下：&lt;/p&gt;

&lt;p&gt;创建数据库demo_project语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create &lt;span class=&quot;hljs-keyword&quot;&gt;database demo_project;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常见表user语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE &lt;span class=&quot;hljs-string&quot;&gt;`user` (
  &lt;span class=&quot;hljs-string&quot;&gt;`id` &lt;span class=&quot;hljs-built_in&quot;&gt;int(&lt;span class=&quot;hljs-number&quot;&gt;10) &lt;span class=&quot;hljs-keyword&quot;&gt;NOT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`name` &lt;span class=&quot;hljs-built_in&quot;&gt;varchar(&lt;span class=&quot;hljs-number&quot;&gt;50) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`age` &lt;span class=&quot;hljs-built_in&quot;&gt;int(&lt;span class=&quot;hljs-number&quot;&gt;3) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`height` &lt;span class=&quot;hljs-built_in&quot;&gt;int(&lt;span class=&quot;hljs-number&quot;&gt;11) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  &lt;span class=&quot;hljs-string&quot;&gt;`weight` &lt;span class=&quot;hljs-keyword&quot;&gt;double(&lt;span class=&quot;hljs-number&quot;&gt;10,&lt;span class=&quot;hljs-number&quot;&gt;0) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-literal&quot;&gt;NULL,
  PRIMARY &lt;span class=&quot;hljs-keyword&quot;&gt;KEY (&lt;span class=&quot;hljs-string&quot;&gt;`id`)
) &lt;span class=&quot;hljs-keyword&quot;&gt;ENGINE=&lt;span class=&quot;hljs-keyword&quot;&gt;InnoDB &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT &lt;span class=&quot;hljs-keyword&quot;&gt;CHARSET=utf8;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）、创建实体User.java，具体代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;User.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.hibernate.demo;

&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;User {
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）、导入约束，在与实体同一个包下新建ORM配置文件User.hbm.xml，书写ORM元数据，具体配置代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;User.hbm.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE hibernate-mapping PUBLIC 
    &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&amp;gt;
   &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）、在src下新建hibernate.cfg.xml主配置文件，具体配置代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hibernate.cfg.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE hibernate-configuration PUBLIC
    &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;hibernate-configuration&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;session-factory&amp;gt;

         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）、新建测试类TestDemo.java，书写测试代码，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TestDemo.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.hibernate.test;

&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.Session;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.SessionFactory;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.Transaction;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.hibernate.cfg.Configuration;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.junit.Test;

&lt;span class=&quot;hljs-keyword&quot;&gt;import com.hibernate.domain.User;

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（7）、使用JUnit测试运行，信息插入成功，具体结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b3c5e45d471?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://user-gold-cdn.xitu.io/2018/2/20/161b3b414a6abb2b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;本项目运行环境：jdk1.7、Tomcat7.0&lt;/p&gt;

&lt;h3 id=&quot;h3hibernate&quot;&gt;3、Hibernate配置文件详解&lt;/h3&gt;
&lt;p&gt;（1）、orm元数据配置详解：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;package&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;property&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;（2）、Hibernate主配置文件详解：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;必选配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;可选配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;引入orm元数据配置&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;/&gt;
&lt;/pre&gt;
&lt;h3&gt;&lt;span&gt;关注微信公众号compassblog，后台回复 “&lt;strong&gt;Hibernate系列一&lt;/strong&gt;&lt;span&gt;” 获取本项目源码&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247483975&amp;amp;idx=1&amp;amp;sn=24f28cdc3399c0d295a5ceb209383e10&amp;amp;chksm=fe322189c945a89f0c2723de0c7c1ef48cbd218e14ed2c8ea0a9c7c4da241737011bc7cf66d7#rd&quot;&gt;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247483975&amp;amp;idx=1&amp;amp;sn=24f28cdc3399c0d295a5ceb209383e10&amp;amp;chksm=fe322189c945a89f0c2723de0c7c1ef48cbd218e14ed2c8ea0a9c7c4da241737011bc7cf66d7#rd&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本系列后期仍会持续更新，欢迎关注！&lt;/p&gt;

&lt;p&gt;如果你认为这篇文章有用，欢迎转发分享给你的好友！&lt;/p&gt;

&lt;p&gt;本号文章可以任意转载，转载请注明出处！&lt;/p&gt;
&lt;h2&gt;扫码关注微信公众号，了解更多&lt;/h2&gt;
&lt;div&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180220230815636&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 20 Feb 2018 15:14:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8455986.html</dc:identifier>
</item>
<item>
<title>使用 RxJS 实现一个简易的仿 Elm 架构应用 - 不如隐茶去</title>
<link>http://www.cnblogs.com/JacZhu/p/8455974.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JacZhu/p/8455974.html</guid>
<description>&lt;p&gt;标签（空格分隔）： 前端&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;什么是-elm-架构&quot;&gt;什么是 Elm 架构&lt;/h2&gt;
&lt;p&gt;Elm 架构是一种使用 Elm 语言编写 Web 前端应用的简单架构，在代码模块化、代码重用以及测试方面都有较好的优势。使用 Elm 架构，可以非常轻松的构建复杂的 Web 应用，无论是面对重构还是添加新功能，它都能使项目保持良好的健康状态。&lt;/p&gt;
&lt;p&gt;Elm 架构的应用通常由三部分组成——&lt;strong&gt;模型&lt;/strong&gt;、&lt;strong&gt;更新&lt;/strong&gt;、&lt;strong&gt;视图&lt;/strong&gt;。这三者之间使用 &lt;strong&gt;Message&lt;/strong&gt; 来相互通信。&lt;/p&gt;
&lt;h3 id=&quot;模型&quot;&gt;模型&lt;/h3&gt;
&lt;p&gt;模型通常是一个简单的 POJO 对象，包含了需要展示的数据或者是界面显示逻辑的状态信息，在 Elm 语言中，通常是自定义的“记录类型”，模型对象及其字段都是不可变的（immutable）。使用 TypeScript 的话，可以简单的用接口来描述模型：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export interface IHabbitPresetsState {
    presets: IHabbitPreset[];
    isLoading: boolean;
    isOperating: boolean;
    isOperationSuccess: boolean;
    isEditing: boolean;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候，我们就需要在心中谨记，&lt;strong&gt;永远不要去修改模型的字段！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;message&quot;&gt;Message&lt;/h3&gt;
&lt;p&gt;Message 用来定义应用程序在运行过程中可能会触发的事件，例如，在一个秒表应用中，我们会定义“开始计时”、“暂停计时”、“重置”这三种事件。在 Elm 中，可以使用 Union Type 来定义 Message，如果使用 TypeScript 的话，可以定义多个消息类，然后再创建一个联合类型定义：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export type HabbitPresetsMsg =
    Get | Receive
    | Add | AddResp
    | Delete | DeleteResp
    | Update | UpdateResp
    | BeginEdit | StopEdit;

export class Get {
}

export class Receive {
    constructor(public payload: IHabbitPreset[]) { }
}

export class Add {
    constructor(public payload: IHabbitPreset) { }
}

export class AddResp {
    constructor(public payload: IHabbitPreset) {
    }
}

export class Delete {
    constructor(public payload: number) {
    }
}

export class DeleteResp {
    constructor(public payload: number) { }
}

export class Update {

    constructor(public payload: IHabbitPreset) {
    }
}

export class UpdateResp {
    constructor(public payload: IHabbitPreset) {
    }
}

export class BeginEdit {
    constructor(public payload: number) { }
}

export class StopEdit {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的应用程序一般从视图层来触发 Message，比如，在页面加载完毕后，就立即触发“加载数据”这个 Message，被触发的 Message 由更新模块来处理。&lt;/p&gt;
&lt;h3 id=&quot;更新&quot;&gt;更新&lt;/h3&gt;
&lt;p&gt;更新，即模型的更新方式，通常是一个函数，用 TypeScript 来描述这个函数就是：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;update(state: IHabbitPresetsState, msg: HabbitPresetsMsg): IHabbitPresetsState&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每当一个新的 Message 被触发的时候，Elm 架构便会将应用程序当前的模型跟接受到 Message 传入 update 函数，再把执行结果作为应用程序新的模型——这就是模型的更新。&lt;br/&gt;在 Elm 程序中，视图的渲染仅依赖模型中的数据，所以，模型的更新往往会导致视图的更新。&lt;/p&gt;
&lt;h3 id=&quot;视图&quot;&gt;视图&lt;/h3&gt;
&lt;p&gt;Elm 语言自带了一个前端的视图库，其特点是视图的更新仅依赖模型的更新，几乎所有的 Message 也都是由视图来触发。但在这篇文章里面，我将使用 Angular5 来演示效果，当然了，也可以使用 React 或者 jQuery 来实现视图，这取决于个人爱好。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;至此，我们大致的了解了一下 Elm 架构的几个要点：模型、更新、视图以及 Message。一个 Elm 架构的程序，通常是视图因为用户的动作触发特定 Message，然后由这个触发的 Message 跟当前应用的模型计算得出新的模型，新的模型的产生使得视图产生变化。&lt;/p&gt;
&lt;h2 id=&quot;开始实现&quot;&gt;开始实现&lt;/h2&gt;
&lt;p&gt;首先让我们写出一个空的框架：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export class ElmArch&amp;lt;TState, TMsgType&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TState 表示应用程序的模型类型，TMsgType 表示应用程序的消息联合类型。&lt;/p&gt;
&lt;p&gt;由上一节可以知道，Message 是应用程序能够运行的关键，Message 在运行时要能够手动产生，并且，Message 的触发还要能被监听，所以，可以使用 RxJS/Subject 来构建一个 Message 流。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;export class ElmArch&amp;lt;TState, TMsgType&amp;gt; {
    private readonly $msg = new Subject&amp;lt;TMsgType&amp;gt;();
    send(msg: TMsgType) {
        this.$msg.next(msg);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里之所以定义一个 send 函数是为了更好的将代码封装起来，消息流对外只暴露一个触发消息的接口。&lt;/p&gt;
&lt;p&gt;接下来，我们可以考虑一下模型流的实现。他跟消息流很类似，首先要能被监听，其次，还接收到消息后还要能手动产生，所以也可以使用 Subject 来实现。但是这里我用的是 BehaviorSubject ，因为 Behavior Subject 能够保留最后产生的对象，这样我们就可以随时访问模型里面的数据，而不需要使用 Subscribe。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$res = new BehaviorSubject&amp;lt;TState&amp;gt;(initState);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，1/3 的工作已经完成了，现在来按照我们的要求，使用 rxjs 让消息流能正确的触发模型流的更新。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;this.$msg.scan(this.update, initState)
            .subscribe((s: TState) =&amp;gt; {
                    $res.next(s);
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;scan 是 rxjs 的一个操作符，类似于 JS 中的 reduce，LINQ 中的 Aggregate。因为设置了一个初始模型（initState），所以在消息流每次产生新的消息的时候，update 函数就可以接收到上一次计算出来的模型，以及最新接收到的消息，然后返回新的模型。也就是说，scan 将消息流转化为了新的模型流。接着订阅这个模型流，并用之前定义的 BehaviorSubject 来广播新的模型。&lt;/p&gt;
&lt;p&gt;这里就接近完成 1/2 的工作了，模型跟消息这两个的东西已经实现好了，接下来就继续实现更新。&lt;/p&gt;
&lt;p&gt;Elm 是一门函数式语言，模式匹配的能力比 js 不知道高到哪里去了，既然要模仿 Elm 架构，那么这个地方也要仿出来。&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;type Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt; =
    [new (...args: any[]) =&amp;gt; TMsg, (acc: TState, msg: TMsg, $msg: Subject&amp;lt;TMsgType&amp;gt;) =&amp;gt; TState];

    /**
     * Pattern matching syntax
     * @template TMsg
     * @param {new (...args: any[]) =&amp;gt; TMsg} type constructor of Msg
     * @param {(acc: TState, msg: TMsg, $msg: Subject&amp;lt;TMsgType&amp;gt;) =&amp;gt; TState} reducer method to compute new state
     * @returns {Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt;}
     * @memberof ElmArch
     */
    caseOf&amp;lt;TMsg&amp;gt;(
        type: new (...args: any[]) =&amp;gt; TMsg,
        reducer: (acc: TState, msg: TMsg, $msg: Subject&amp;lt;TMsgType&amp;gt;) =&amp;gt; TState)
        : Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt; {
        return [type, reducer];
    }

    matchWith&amp;lt;TMsg&amp;gt;($msg: Subject&amp;lt;TMsgType&amp;gt;, patterns: Pattern&amp;lt;TMsg, TState, TMsgType&amp;gt;[]) {
        return (acc: TState, msg: TMsg) =&amp;gt; {
            const state = acc;
            for (const it of patterns) {
                if (msg instanceof it[0]) {
                    return it[1](state, msg, $msg);
                }
            }
            throw new Error('Invalid Message Type');
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们定义了一个元组类型 &lt;code&gt;Pattern&lt;/code&gt; 用来表示模式匹配的语法，在这里面，主要需要实现的是基于类型的匹配，所以元组的第一个元素是消息类，第二个参数是当匹配成功时要执行的回调函数，用来计算新的模型，使用 &lt;code&gt;caseOf&lt;/code&gt; 函数可以创建这种元组。&lt;code&gt;matchWith&lt;/code&gt; 函数的返回值是一个函数，与 &lt;code&gt;scan&lt;/code&gt; 的第一个参数的签名相符合，第一个参数是最后被创建出来的模型，第二个参数是接收到的消息。在这个函数中，我们找到与接收到的消息相匹配的 pattern 元组，然后用这个元组的第二个元素计算出新的模型。&lt;/p&gt;
&lt;p&gt;用上面的东西就可以比较好的模拟模式匹配的功能了，写出来的样子像这样：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;const newStateAcc = matchWith(msg, [
            caseOf(GetMonth, (s, m, $m) =&amp;gt; {
                // blablabla
            }),
            caseOf(GetMonthRecv, (s, m) =&amp;gt; {
                // blablabla
            }),
            caseOf(ChangeDate, (s, m) =&amp;gt; {
                // blablabla
            }),
            caseOf(SaveRecord, (s, m, $m) =&amp;gt; {
                // blablabla
            }),
            caseOf(SaveRecordRecv, (s, m) =&amp;gt; {
                // blablabla
            })
        ])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，之前用来构建模型流的地方就需要做一些改动：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;this.$msg.scan(this.matchWith(this.$msg, patterns), initState)
            .subscribe((s: TState) =&amp;gt; {
                    $res.next(s);
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在构建模型流需要依赖一个初始状态跟一个模式数组，那么就可以用一个函数封装起来，将这两个依赖项作为参数传入：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;begin(initState: TState, patterns: Pattern&amp;lt;any, TState, TMsgType&amp;gt;[]) {
        const $res = new BehaviorSubject&amp;lt;TState&amp;gt;(initState);
        this.$msg.scan(this.matchWith(this.$msg, patterns), initState)
            .subscribe((s: TState) =&amp;gt; {
                    $res.next(s);
            });
        return $res;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到目前为止，2/3 的工作就已经完成了，我们设计出了消息流、模型流以及处理消息的更新方法，做一个简单的计数器是完全没有问题的。&lt;a href=&quot;https://stackblitz.com/edit/angular-6uk7be?embed=1&amp;amp;file=app/hello.component.ts&quot;&gt;点击查看样例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是实际上，我们需要面对的问题远不止一个计数器这么简单，更多的情况是处理请求，有时候还需要处理消息的时候触发新的消息。对于异步的请求，需要在请求的响应中触发新的消息，可以直接调用 &lt;code&gt;$msg.next()&lt;/code&gt; ，对于需要在更新的操作中触发新的消息，也可以主动调用 &lt;code&gt;$msg.next()&lt;/code&gt; 这个函数就好了。&lt;/p&gt;
&lt;p&gt;不过，事情往往没有这么简单，因为模型流并不是从消息流直接通过 rxjs 的操作符转换出来的，而更新函数中模式匹配部分执行时间长短不一，这可能导致消息与模型更新顺序不一致的问题。我想出的解决方法是：对于同步的操作需要触发新的消息，就必须要保证当前消息处理完成后，模型的更新被广播出去后才能触发新的消息。基于这一准则，我就又添加了一些代码：&lt;/p&gt;
&lt;pre class=&quot;ts&quot;&gt;
&lt;code&gt;type UpdateResult&amp;lt;TState, TMsgType&amp;gt; = TState | [TState, TMsgType[]];

/**
* Generate a result of a new state with a sets of msgs, these msgs will be published after new state is published
* @param {TState} newState
* @param {...TMsgType[]} msgs
* @returns {UpdateResult&amp;lt;TState, TMsgType&amp;gt;}
* @memberof ElmArch
*/
nextWithCmds(newState: TState, ...msgs: TMsgType[]): UpdateResult&amp;lt;TState, TMsgType&amp;gt; {
    if (arguments.length === 1) {
        return newState;
    } else {
        return [newState, msgs];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我添加了新的类型—— &lt;code&gt;UpdateResult&amp;lt;TState, TMsgType&amp;gt;&lt;/code&gt;，这个类型表示模型类型或模型类型与消息数组类型的元组类型。这么说起来确实有些绕口，这个类型存在的意义就是：Update 函数除了返回新的模型之外，还可以选择性的返回接下来要触发的消息。这样，单纯的模型流就变成了模型消息流，接着在 &lt;code&gt;subscribe&lt;/code&gt; 的地方，在原先的模型流产生新的模型的地方后面再去触发新的消息流，如果返回结果中有需要触发的消息的话。&lt;/p&gt;
&lt;p&gt;完整代码在此：&lt;a href=&quot;https://gist.github.com/ZeekoZhu/c10b30815b711db909926c172789dfd2&quot; class=&quot;uri&quot;&gt;https://gist.github.com/ZeekoZhu/c10b30815b711db909926c172789dfd2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用样例&quot;&gt;使用样例&lt;/h2&gt;
&lt;p&gt;在上面的 gits 中提到了一个样例，但是不是很完整，之后会放出完整例子。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;看到这里，你可能已经发现了，本文实现的这个小工具看起来跟 redux 挺像的，确实，redux 也是 js 程序员对 Elm 架构的致敬。通过把 Web 应用的逻辑拆解成一个个状态间改变的逻辑，可以帮助我们更好的理解所编写的东西，同时，也让 MV* 的思想得到进一步的展现，因为在编写 update 相关的代码的时候，可以在实现业务逻辑的同时而毫不碰触 UI 层面的东西，所以，正如本文开头提到的，视图可以是任何东西：React、Angular、jQuery，这都没关系，只要能够对模型的 Observable 流的改变做出响应， DOM API 也是可以的，可能，这就是所谓的响应式编程吧。&lt;/p&gt;
&lt;h3 id=&quot;对于普通的-angular-应用来说意味这什么&quot;&gt;对于普通的 Angular 应用来说意味这什么？&lt;/h3&gt;
&lt;p&gt;在我自己将这个小工具结合 Angular 的使用体验来看，最大的改变就是&lt;strong&gt;代码变得更加有规律&lt;/strong&gt;了，特别是处理异步并改变 UI 的场景，变得更容易套路化，更容易套路化就意味着更方便生成代码了。再一个，在 Angualr 中，如果组件依赖的所有输入都是 Observable 对象，那么可以将默认的变更检查策略改为：OnPush。这样，&lt;strong&gt;Angular 就不用对这个组件进行“脏检查”了&lt;/strong&gt;，只有在 Observable 发生更新的时候，才会去重新改变组件，这个好处，不言而喻。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 15:06:00 +0000</pubDate>
<dc:creator>不如隐茶去</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JacZhu/p/8455974.html</dc:identifier>
</item>
</channel>
</rss>