<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>把时间当作朋友 - Avenstar</title>
<link>http://www.cnblogs.com/zjf-1992/p/10018391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjf-1992/p/10018391.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201811/819169-20181125135952644-1368268767.jpg&quot; alt=&quot;&quot; width=&quot;1173&quot; height=&quot;461&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;90后意味着已经步入奔三的路途中了......仿佛这一切真的感觉就在瞬息之间，从一个稚嫩的18岁的男孩变成一个男人，意味着得去承担生活所给予你的一切。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里楼主有必要重复一篇很有意思的一篇帖子，便于启发你对&lt;strong&gt;时间&lt;/strong&gt;方面的&lt;strong&gt;思考和优化&lt;/strong&gt;， 亦可称为——可&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://pan.baidu.com/s/1uKiseCSyMNoVh8VIlleVbg&quot;&gt;&lt;span&gt;量化的A4纸时间格子&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://pan.baidu.com/s/1uKiseCSyMNoVh8VIlleVbg&quot;&gt;&lt;span&gt;&lt;strong&gt;.......&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设每个人的&lt;strong&gt;平均寿命是75岁&lt;/strong&gt;，&lt;strong&gt;在A4纸上格子大概是这样&lt;/strong&gt;（&lt;strong&gt;75*12 = 900 格子，一个格子代表一个月&lt;/strong&gt;）&lt;strong&gt;.......&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201811/819169-20181125133750030-1320581612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 假设你与某个女生或男生谈了6个月恋爱，在A4纸上是这样&lt;strong&gt;.......&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201811/819169-20181125134256433-408799277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  假设你与父母一年见一次面，在A4纸时间格子上是这样.......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201811/819169-20181125135156647-738664912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你今年26岁，在A4纸上格子大概是这样（26*12 = 312 个格子）.......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201811/819169-20181125134713462-424410599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你今年30岁，在A4纸格子上是这样（30*12 = 360 格子 ）.......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201811/819169-20181125134834515-354903086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 当&lt;strong&gt;每天、每周累计至每个月&lt;/strong&gt;白白浪费掉的或没有成长的&lt;strong&gt;损耗的时间&lt;/strong&gt;，等同于&lt;strong&gt;你的A4时间格子纸&lt;/strong&gt;被小偷偷去，在你毫不知情的情况下涂上一格，什么感觉.....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就像李宗盛《给自己的歌》歌词写到的那样，&lt;span&gt;&lt;em&gt;等你发现时间是贼了，它早已偷光你的选择.......&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;事实尽管如此，通过以上&lt;strong&gt;人&lt;/strong&gt;相对于&lt;strong&gt;时间&lt;/strong&gt;而言大概可以得出2结论；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1、不利的是每个人的时间、精力极度有限，每个人每天都拥有24小时（86400秒）.......&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2、&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;有利的是&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;每个人可以通过系统性的阅读、学习建立自己的思维体系或模型、概念的认知，优化自己的方法论、原则，进而通过&lt;strong&gt;调整自己&lt;/strong&gt;和时间成为更好的朋友（找到适合自己的节奏，持续去做）。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;通常情况下一个&lt;strong&gt;陌生的关键词或概念（宏观的来说知识）&lt;/strong&gt;对于一个人来说不管你用不用它都在那里，就像一部智能终端手机人人都用，但若如果你问某个使用手机的人———你打电话你的手机底层逻辑究竟发生了什么，他一定会表现的一眼茫然......&lt;/p&gt;
&lt;p&gt;类比学习生活中的知识（生活本身就是很复杂的知识错综复杂、相互交织）&lt;strong&gt;......真正意义上人是很难讲清楚的。即便讲得清楚，分享者分享的也是自己最擅长的那部分及衍生出来的部分.....&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了便于&lt;strong&gt;人的理解&lt;/strong&gt;便有了人为的方式处理 如 &lt;strong&gt;关键字、标签、概念、目录大纲、章节之类的术语一说。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如&lt;strong&gt;&quot;时间&quot; 这个关键字，人人都用却不见得人人都有自己的方法论和原则。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生活中有些人明明30岁了看上去像20多岁的小伙子，为什么？换一种角度来看，保持&lt;strong&gt;年轻&lt;/strong&gt;确实是有&lt;strong&gt;方法和原则可遵循的。引用时间管理范畴的知识来解释便是：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;、运动
&lt;/span&gt;2&lt;span&gt;、阅读
&lt;/span&gt;3、建立良好的、合理的饮食习惯等&lt;br/&gt;4、.......
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;然而，&quot;时间&quot;这一关键词&lt;/strong&gt;&lt;strong&gt;在新手的世界坐标系中基本全是盲区或者说没有概念。&lt;/strong&gt;（类似如下图所示）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201811/819169-20181122000454362-356844215.jpg&quot; alt=&quot;&quot; width=&quot;910&quot; height=&quot;455&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而对于&lt;strong&gt;概念（个人理解包括&lt;/strong&gt;关键字、标签、概念、目录大纲、章节等）的理解在程序的世界里像&lt;strong&gt;黑白盒子，&lt;/strong&gt;&lt;strong&gt;白盒子&lt;/strong&gt;人人&lt;strong&gt;都知道的部分，对外公开透明的信息或知识&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;如冬天冷了，人自然而然的会穿棉袄；感冒了要吃药，累了要休息，便于恢复&lt;strong&gt;精力&lt;/strong&gt;等&lt;strong&gt;.......&lt;/strong&gt;还有家喻户晓的名著《西游记》《红楼梦》等......&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;黑盒子私有的部分&lt;/strong&gt;，可简单理解为&lt;strong&gt;不对外公开的私有化的信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如你点了一份外卖，对你而言你希望可以吃一顿美味可口的中午餐，至于这份餐是如何做出来的&lt;strong&gt;中间省去的步骤, &lt;/strong&gt;对你来说就是&lt;strong&gt;黑盒子。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种交易本质上就是一种&lt;strong&gt;付费购买服务的过程&lt;/strong&gt;，通过付费把方便留给自己，&lt;strong&gt;服务的提供者&lt;/strong&gt;帮你节约了&lt;strong&gt;更多的时间或满足购买者的需求.....&lt;/strong&gt;当然类似这样的现实例子数不胜数......&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;诸如插线板、插座、手机运行原理、社群运营、社群的通信技术IM、存进银行的钱现金流的去向、人的大脑、个人的隐私、电脑CPU、主板、私密文件、逻辑思维运营体系等.......&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201811/819169-20181121233851171-474790048.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 新手接着通过&lt;strong&gt;系统性的大量与&quot;时间&quot;相&lt;/strong&gt;关联性主题阅读、系统性学习实践，于是便有了与时间关联性概念的基本认知 【对时间这一词的认识越来越清晰】（如下图所示）&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201811/819169-20181125111643551-1424412735.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;概念之间融汇贯通，链接形成动态的、适合自己的、可调整性的系统便是与&quot;时间&quot;主题关联性的知识体系(或说&lt;/strong&gt;思维框架) （如下图所示）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201811/819169-20181125112044611-2104323874.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设你针对某一&lt;strong&gt;主题（如时间）&lt;/strong&gt;，阅读了30本高质量的书籍（假设作者写这本书大概用了30年时间），并且你做到&lt;strong&gt;概念之间融汇贯通，就可以解释生活中的很多问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么这道数学算法就是  &lt;strong&gt;30*30 = 900 （年）&lt;/strong&gt; 从某种程度来说&lt;strong&gt;就是突破了时间上的限制~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 至此鉴于篇幅所限，即便说1、2篇文章也不见得能说清楚，但至少提供了一种与学习&lt;strong&gt;&quot;时间&quot;相关的思维方法&lt;/strong&gt;才是最重要的。&lt;/p&gt;
&lt;p&gt;好比&lt;strong&gt;别人几年、甚至几十年的日积月累。你想在几分钟、几小时、几天内做到消化那是不可能的。&lt;/strong&gt;这也不难解释肥胖的人不可能马上就变瘦。&lt;strong&gt;存量&lt;/strong&gt;（如肥胖）&lt;strong&gt;是长时间累加形成的结果。谁也无法在短时间内改变存量那样。   &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;楼主梳理以上与 &lt;strong&gt;“时间”&lt;/strong&gt; 体系主题相关联的书籍，现分享给大家哈 ~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;【美】戴维  ● 艾伦 《搞定 | 无压力的工作的艺术 》 
 德内拉*梅多斯 《系统之美 ● 决策者的系统思考》
【美】阿图  ● 葛文德  《清单革命》
【日】奥野宣之  《如何有效地阅读一本书》
【美】Andy Hunt 著  《程序员思维修炼》
【中】纪元《哪有没时间这回事儿》 
【中】李笑来 ● 《把时间当做朋友》
【美】 洛尔 ●  《精力管理》
【日】 小山龙介   《整理的艺术》
【美】 斯蒂芬·盖斯  ●  《微习惯》
【英】雷戈 麦吉沃恩  ●  《精要主义》
【英】里奥 ● 巴伯塔    《少的力量》
【美】 汤姆 ● 拉思  《你充电了吗？》 激活人生精力的关键&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来分享一些生活中的&lt;strong&gt;好习惯清单~&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;、养成早起的习惯，多出半个小时，好进入学习或工作的状态。
&lt;/span&gt;2&lt;span&gt;、早餐  1个苹果（补充维生素）2个包子（一个肉馅、一个素菜）。
&lt;/span&gt;3&lt;span&gt;、午餐时一心一意吃饭，不看手机，把午餐当做是自己认真工作换来的奖赏。（楼主发现午餐时很多人一边吃饭一边看手机，估计饭是什么味道都没尝到~）
&lt;/span&gt;4&lt;span&gt;、一周至少有2次跑步的时间。【今年稍微胖了，年会前夕计划减掉5斤】
&lt;/span&gt;5&lt;span&gt;、珍惜时间，学会好好学习，重质不重量。
&lt;/span&gt;6&lt;span&gt;、不断记录，写日记，每一天、每一周、每一月、每一年（30天就是一个A4格子），反思、总结。
&lt;/span&gt;7&lt;span&gt;、生活案例素材化，整理归类。
&lt;/span&gt;8&lt;span&gt;、每个月至少读一本书。
&lt;/span&gt;9&lt;span&gt;、找寻适合自己的高效时段。
&lt;/span&gt;10&lt;span&gt;、合理使用自己的碎片时间。&lt;/span&gt;
11&lt;span&gt;、不盲目跟风，多思考、学习事物底层规律、原则与方法。&lt;/span&gt;
12&lt;span&gt;、减少大脑切屏的时间。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后梳理下本文的大体思路~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819169/201811/819169-20181125231640826-1514002505.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;如果您觉得我的文章对您有用，请随意打赏。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/819169/201809/819169-20180908180823712-39370341.png&quot; alt=&quot;&quot; width=&quot;150&quot;/&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt;微信打赏&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 25 Nov 2018 23:11:00 +0000</pubDate>
<dc:creator>Avenstar</dc:creator>
<og:description>90后意味着已经步入奔三的路途中了......仿佛这一切真的感觉就在瞬息之间，从一个稚嫩的18岁的男孩变成一个男人，意味着得去承担生活所给予你的一切。 这里楼主有必要重复一篇很有意思的一篇帖子，便于启</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjf-1992/p/10018391.html</dc:identifier>
</item>
<item>
<title>[UWP]在应用开发中安全使用文件资源 - HHChaos</title>
<link>http://www.cnblogs.com/hhchaos/p/10018301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhchaos/p/10018301.html</guid>
<description>&lt;p&gt;在WPF或者UWP应用开发中，有时候会不可避免的需要操作文件系统（创建文件/目录），这时候有几个坑是需要大家注意下的。&lt;/p&gt;
&lt;h2 id=&quot;创建文件或目录时的非法字符检测&quot;&gt;创建文件或目录时的非法字符检测&lt;/h2&gt;
&lt;p&gt;在Windows系统中，我们创建文件时会注意到，某些特殊字符是不可以用作文件名输入的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1239018/201811/1239018-20181126004755380-1604465054.jpg&quot; alt=&quot;非法文件名&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，同样的，如果你的应用可以提供给用户创建文件/目录的功能，要特别注意的是：你必须对用户键入的文件或者目录名检测，避免用户键入非法字符。&lt;/p&gt;
&lt;p&gt;否则，应用可能会遇到下面这个bug：&lt;code&gt;System.IO.FileNotFoundException:“文件名、目录名或卷标语法不正确。”&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1239018/201811/1239018-20181126004838017-1814196897.jpg&quot; alt=&quot;非法字符异常&quot;/&gt;&lt;/p&gt;
&lt;p&gt;避免手段其实也很简单，System.IO.Path类中可以获取到所有的非法字符，我们只需要检测文件或目录名，避免出现非法字符就可以了。&lt;/p&gt;
&lt;p&gt;不可以在文件名中出现的字符 Path.GetInvalidFileNameChars(）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char[41] { '&quot;', '&amp;lt;', '&amp;gt;', '|', '\0', '\u0001', '\u0002', '\u0003', '\u0004', '\u0005', '\u0006', '\a', '\b', '\t', '\n', '\v', '\f', '\r', '\u000e', '\u000f', '\u0010', '\u0011', '\u0012', '\u0013', '\u0014', '\u0015', '\u0016', '\u0017', '\u0018', '\u0019', '\u001a', '\u001b', '\u001c', '\u001d', '\u001e', '\u001f', ':', '*', '?', '\\', '/' }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不可以在路径字符串中出现的字符 Path.GetInvalidPathChars()：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char[36] { '&quot;', '&amp;lt;', '&amp;gt;', '|', '\0', '\u0001', '\u0002', '\u0003', '\u0004', '\u0005', '\u0006', '\a', '\b', '\t', '\n', '\v', '\f', '\r', '\u000e', '\u000f', '\u0010', '\u0011', '\u0012', '\u0013', '\u0014', '\u0015', '\u0016', '\u0017', '\u0018', '\u0019', '\u001a', '\u001b', '\u001c', '\u001d', '\u001e', '\u001f' }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里给大家提供一个小窍门，使用C#交互窗口（VS2015及更高版本都可以使用），可以快速查看代码片段执行结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1239018/201811/1239018-20181126004911786-393153354.jpg&quot; alt=&quot;C#交互窗口&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在xaml中引用外部资源时的非法字符检测&quot;&gt;在XAML中引用外部资源时的非法字符检测&lt;/h2&gt;
&lt;p&gt;此外，在开发WPF或者UWP应用时，如果我们需要在XAML中引入外部资源URI，那么情况会比较特殊一点。&lt;/p&gt;
&lt;p&gt;有时候尽管你的文件名或者路径URI均没有包含Windows文件系统中的非法字符，应用仍有可能崩溃。这是因为，在XAML中定义了一些不允许出现的字符，这些字符与Windows文件系统中的非法字符不尽相同。&lt;/p&gt;
&lt;p&gt;这些字符是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{ ';' , '/' , '?' , ':' , '@' , '&amp;amp;' , '=' , '+' , '$' , ',','&amp;lt;' , '&amp;gt;' , '#' , '%' , '&quot;' }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如‘#’，它在文件系统中是合法字符，但是却不能出现在XAML中引入的外部资源URI字符串里。&lt;/p&gt;
&lt;p&gt;这个问题在邵猛大佬的《&lt;a href=&quot;https://www.cnblogs.com/shaomeng/p/5171178.html&quot;&gt;WPF 图片显示中的保留字符问题&lt;/a&gt;》中也是有讲到的，但是文章中没有给到解决方法。&lt;/p&gt;
&lt;p&gt;在某些情况下，如开发应用时，我们允许用户上传图片到应用文件夹下作为资源使用，我们可以在拷贝资源时通过排除/替换文件名里非法字符的方法来避免这个BUG。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static class XamlUriHelper
{
    private static readonly char[] Excluded = { ';' , '/' , '?' , ':' , '@' , '&amp;amp;' , '=' , '+' , '$' , ',','&amp;lt;' , '&amp;gt;' , '#' , '%' , '&quot;' };

    public static string GetValidName(string fileName)
    {
        foreach (var item in Excluded)
        {
            fileName = fileName.Replace(item, '_');
        }
        return fileName;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结尾&quot;&gt;结尾&lt;/h2&gt;
&lt;p&gt;上面说到的两种情况，第一种是比较好处理的，而第二种需要一些折中的处理手段。另外吐槽一点，XAML应用这么久了，第二种情况按理说是不应该出现的，不知道微软方面有没有注意到（或者说是否有官方解决方法，类似转义符什么的？）。如果有了解这个问题的大佬，欢迎在评论区指出！&lt;/p&gt;
&lt;p&gt;这篇博文到此结束，谢谢大家！&lt;/p&gt;
</description>
<pubDate>Sun, 25 Nov 2018 16:56:00 +0000</pubDate>
<dc:creator>HHChaos</dc:creator>
<og:description>在WPF或者UWP应用开发中，有时候会不可避免的需要操作文件系统（创建文件/目录），这时候有几个坑是需要大家注意下的。 创建文件或目录时的非法字符检测 在Windows系统中，我们创建文件时会注意到，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hhchaos/p/10018301.html</dc:identifier>
</item>
<item>
<title>记一次返工之后记 - Grey Zeng</title>
<link>http://www.cnblogs.com/greyzeng/p/10018247.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/greyzeng/p/10018247.html</guid>
<description>&lt;p&gt;作者：&lt;a href=&quot;http://www.cnblogs.com/greyzeng/&quot;&gt;Grey&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;时间：2018-11-25&lt;/p&gt;
&lt;p&gt;原文地址： &lt;a href=&quot;https://www.cnblogs.com/greyzeng/p/10018247.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/greyzeng/p/10018247.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/greyzeng/p/9029530.html&quot;&gt;之前做的功能&lt;/a&gt;, 又有新的需求了，原先的需求是支持某个类型的待办审批，现在是要支持系统所有类型待办的审批，虽然之前的代码写的很匆忙，比较“丑陋”，但是好在未出什么bug，新需求来了以后，我本想乘此机会重构一下自己之前写的比较丑陋的代码，但是因为陆陆续续有插入进来的优先级更高的任务，所以这个新需求一直被hold住，最后有一周的时间来做这个需求，由于要测试的流程比较多，而且创建流程的过程比较费时，为了给测试预留多一些时间，我放弃了重构的念头，先快速实现需求，在保证原有功能和新增需求没有问题的情况下，再一点点重构自己的代码。&lt;/p&gt;
&lt;h2 id=&quot;原需求&quot;&gt;原需求&lt;/h2&gt;
&lt;p&gt;有一个Web系统X，用户可以通过这个系统查看自己的待办信息，并且可以用于待办的审批，还有一个我们做的手机应用Y，Y系统需要支持查看X系统的待办信息并完成审批操作。&lt;/p&gt;
&lt;h2 id=&quot;新需求&quot;&gt;新需求&lt;/h2&gt;
&lt;p&gt;原需求里面说的待办信息只是某两个类型的待办，实际上这个X系统有很多待办类型，而且每个类型的处理逻辑，显示元素都是不一样的，我们现在要实现再Y上支持X系统的所有待办类型的审批。&lt;/p&gt;
&lt;h2 id=&quot;资源&quot;&gt;资源&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;X系统的源码。&lt;/li&gt;
&lt;li&gt;X系统虽然不是我们公司做的，但是我司运维人员对于X系统的业务相对熟悉。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;开发前的准备&quot;&gt;开发前的准备&lt;/h2&gt;
&lt;p&gt;为了避免上一次返工的问题之一：需求没有梳理清楚。在写代码之前，开发和测试都需要非常了解业务逻辑，所以，在开发之前，我特意申请了一次培训，让运维人员给我们（我作为开发，还有一位测试人应）讲解一下整个系统的流程，也不需要特别正式的会议室，就几个人在电脑旁边，运维人员从头到尾给我们整个走一遍流程，有任何疑问都当下提出，当下解决， 解决不了的记录下来，运维人员后去请教实际用户这些问题。补充一点：最了解X系统业务的人当然是使用这个系统的用户，可是这个系统比较特殊的一点是，大部分用户都是领导，我们几乎不太可能让领导来花时间来给我们讲整个业务逻辑，只能是当我们遇到一些实际的业务问题，再去和他们请教。而运维人员，算是除了用户以外，相对比较了解X系统的人了，什么？你说X系统的开发人员？这个系统的开发商已经“跑路”了:)&lt;/p&gt;
&lt;p&gt;在培训完业务流程后，我还没有急着做开发，而是先让测试人员在X系统上走一遍流程，并把走流程中的一些关键信息（如待办详情，操作按钮，下一步操作选择）截图，一来测试需要了解整个业务流程才知道如何设计测试用例，二来截图也可以给我开发做一些参考，比如需要显示待办详情里面的哪些信息，操作按钮要如何显示，下一步操作要如何处理等。&lt;/p&gt;
&lt;p&gt;测试人员在X系统上走完流程以后，我自己也参考测试人员写的操作步骤和截图，走了一遍流程，算是心里有个底了。&lt;/p&gt;
&lt;h2 id=&quot;遇到的问题&quot;&gt;遇到的问题&lt;/h2&gt;
&lt;p&gt;X系统有个测试环境，我们都是在X系统的测试环境中开发和测试的，但是这个环境很不稳定，因为运维人员经常为了排查X系统的问题，会经常把X系统正式环境的数据导入到测试环境，这样我们在X系统做的数据就会被重置，这就尴尬了，我们的开发周期是一周，想在这一周保证测试数据稳定是不可能的了，所以，我又做了一件事，找了一个新的服务器，在这个服务器上重新搭建一个X系统的测试环境（包括应用服务器，数据库），总算是解决了这个问题。&lt;/p&gt;
&lt;p&gt;遇到的另外一个问题是，每次X系统中的待办建走到特定节点比较费时，而每个特定节点需要定制开发，比如我们的手机应用Y要支持X系统某个待办的第五个环节，那我需要在X系统上建一个待办，然后一步一步走到第五个环节，然后找这个环节需要显示的信息，需要做的操作，非常麻烦，而且一旦我在手机上操作了这个环节（比如审批了），这个环节就跳到了第六个环节了，如果我第五个环节的东西还没有完全开发完，我又要建一个流程并走到第五个环节，比较麻烦。所以我想了一个办法，就是在走到某个环节的时候，先备份一下数据库，走完这个环节如果想再回去看下的话，直接恢复备份数据库就可以了。&lt;/p&gt;
&lt;h2 id=&quot;开发和测试&quot;&gt;开发和测试&lt;/h2&gt;
&lt;p&gt;放弃重构想法以后，我开发相对比较谨慎，基本没有改动之前的代码，新的需求都是重新写的代码，并为考虑复用太多之前的代码，虽然几次很想重构，但是还是忍住了，求稳。&lt;/p&gt;
&lt;p&gt;业务逻辑理清了，接下来就是要看懂X系统的源码了，X源码注释也比较少，充斥着类似以下这样的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(StringUtils.equalsIgnoreCase(subTypeId, &quot;501&quot;)){
    // do something
    ...
}else if(StringUtils.equalsIgnoreCase(subTypeId, &quot;502&quot;)){
    // do something
    ...
}else if(StringUtils.equalsIgnoreCase(subTypeId, &quot;601&quot;)){
    // do something
    ...
}else if(StringUtils.equalsIgnoreCase(subTypeId, &quot;602&quot;)){
    // do something
    ...
} else if(StringUtils.equalsIgnoreCase(subTypeId, &quot;604&quot;)){
    // do something
    ...
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我必须一个一个节点走才知道这里的诸如：&quot;501&quot;，&quot;604&quot;是什么意思，然后把这里面对应的SQL拿出来分析，看下需要哪些参数，这些参数是如何获取的，而且有些SQL的查询还很复杂，参数很多，我本想直接用正则匹配页面中的这些参数值，后来想想，还是不能依赖X系统的页面信息，我都是直接查数据库获取需要的参数，分析SQL和获取查询参数，耗费了巨大的时间，不过事实证明，这样做是对的，我这相当于重做了一遍X系统了。&lt;/p&gt;
&lt;p&gt;接下来是设计X系统集成到我们手机APP系统Y中以后的展示和操作，由于数据都拿到了，我就需要把这些数据转换成我们手机APP中展示的元素，比如：Table，KeyValue，List，这些东西实际上没有一个统一的标准，我们就把详情中比较关键的一些信息显示出来，至于是显示成Table还是KeyValue，这个没有严格的标准，用户似乎不太关注内容的排版，只要是显示了必要信息，简单明了，就足够了，所以这部分”设计“，就按照我自己的想法来做了。&lt;/p&gt;
&lt;p&gt;接下来是审批操作，审批操作比较麻烦的一点是，你必须完全了解，点击这个待办的操作按钮背后的所有逻辑，因为我们是要集成待办的操作，所以我们实现的逻辑要和X系统一模一样，最简单粗暴的方案当然是模拟X系统的操作，比如用一些爬虫工具模拟点击操作的按钮，这样我们就完全不需要了解X系统的操作流程了，但是这并不保险，还是因为上一次返工给我带来的教训：万一操作的元素变动了一下，我们的操作就完全失效了。所以这次我还是选择直接理解操作背后的逻辑，说白了就是把操作对应的Ajax请求一个一个看懂并找到对应的参数值，然后发一个一模一样的Ajax操作，当然X系统点击操作还不是简单的拿一些现有的参数发请求，有一些是页面中的js拼装的一些数据，这部分也要完全理解并完全移植过来，一旦有一些操作没有移植过来，如果待办审批出了问题，是非常严重的，因为这些待办涉及比较重要的招投标流程，流程涉及的金额也是很大的。&lt;/p&gt;
&lt;p&gt;我回忆了一下，真正写代码的时间实际上不多，花时间最多的是看X系统的源码，和熟悉X系统的业务流程。&lt;/p&gt;
&lt;p&gt;最后是测试，因为要在手机APP上测试流程，但是我们自己的工号下面都没有对应的待办信息，需要登录相应的领导的账户才可以拿到待办信息，虽然是测试环境，但是我们手机APP是不会用用户的信息去登录测试的，因为登录后，用户的所有信息我们都可以看到了，解决办法就是，在获取用户待办的时候，我们只拿用户的X系统的待办，其他信息不获取，所以获取X系统的待办逻辑的代码，加了这么一小段逻辑，大概意思就是如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;this.工号 = 获取登录人的工号(); // 登录人是自己人
Map&amp;lt;String,String&amp;gt; changedInfo = newHashMap();
changedInfo.put(&quot;自己人的工号1&quot;,&quot;有待办的人的工号1&quot;);
changedInfo.put(&quot;自己人的工号2&quot;,&quot;有待办的人的工号2&quot;);
changedInfo.put(&quot;自己人的工号3&quot;,&quot;有待办的人的工号3&quot;);
this.工号 = changedInfo.get(this.工号);

List todoList = 通过工号获取某人X系统的待办信息(this.工号);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;感悟&quot;&gt;感悟&lt;/h2&gt;
&lt;p&gt;这个需求开发并上线已经两周了，我监控了一段时间运行日志，暂时未发现问题，本次整个开发过程，吸取了上一次返工的教训，为我以后的开发工作也积累了一些新的经验，谨以这两篇博客（本篇博客, &lt;a href=&quot;https://www.cnblogs.com/greyzeng/p/9029530.html&quot;&gt;上一篇博客&lt;/a&gt;）作为一个记录，也希望可以分享给有需要的人。&lt;/p&gt;
</description>
<pubDate>Sun, 25 Nov 2018 16:17:00 +0000</pubDate>
<dc:creator>Grey Zeng</dc:creator>
<og:description>记一次返工之后记 作者：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/greyzeng/p/10018247.html</dc:identifier>
</item>
<item>
<title>Shell编程-10-Shell中的数组 - Surpassme</title>
<link>http://www.cnblogs.com/surpassme/p/10018237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surpassme/p/10018237.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;    如果大家有其他语言的基础或经验，就很快能明白数组了。简单来说，数组就某一种相同类型的元素组合，而后通过下标对其进行访问各元素。&lt;/p&gt;
&lt;h3 id=&quot;数组基础&quot;&gt;数组基础&lt;/h3&gt;
&lt;h4 id=&quot;基础语法&quot;&gt;基础语法&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;第一种形式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; array=(value1 value2 value3 ...)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第二种形式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;array=([0]=value1 [1]=value2 [2]=value3 ...)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在以上形式中中括号代表的数组的下标索引，等号后面为其对应的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;第三种形式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;array[0]=value1;array[1]=value2;array[2]=value3&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第四种形式：动态数组&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;array=($(命令))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array=(`命令`)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在日常使用中推荐大家使用第一种形式和第四种形式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;数组示例&quot;&gt;数组示例&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;第一种形式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# array=(1 3 5)
[root@localhost Test]# echo ${array[*]}
1 3 5&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第二种形式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# array=([0]=1 [1]=3 [2]=5)
[root@localhost Test]# echo ${array[*]}
1 3 5&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第三种形式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# array[0]=1;array[1]=3;array[2]=5
[root@localhost Test]# echo ${array[*]}
1 3 5&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第四种形式：动态数组&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# array=($(ls))
[root@localhost Test]# echo ${array[*]}
break.sh caseif.sh case.sh compareNum.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# array=(`ls`)
[root@localhost Test]# echo ${array[*]}
break.sh caseif.sh case.sh compareNum.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数组输出&quot;&gt;数组输出&lt;/h4&gt;
&lt;p&gt;  数组输出通过采用下标索引的形式进行输出，输出数组的格式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;${ 数组名称 [下标索引] }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;**如未指定数组下标，则默认下标索引从0开始;如果使用*或@则代表输出整个数组元素**。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# array=(1 3 5)
[root@localhost Test]# echo ${array[2]} # 输出第3个元素
5
[root@localhost Test]# echo ${array}    # 未指定下标输出第1个元素
1
[root@localhost Test]# echo ${array[*]} #  使用 * 输出整个数组元素
1 3 5
[root@localhost Test]# echo ${array[@]} #  使用 @ 输出整个数组元素
1 3 5&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数组长度&quot;&gt;数组长度&lt;/h4&gt;
&lt;p&gt;  输出数长度常用格式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;${ #数组名称 [*] }
或
${ #数组名称 [@] }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# array=(1 3 5)
[root@localhost Test]# echo ${#array[*]}
3
[root@localhost Test]# echo ${#array[@]}
3&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数组赋值&quot;&gt;数组赋值&lt;/h4&gt;
&lt;p&gt;  可通过&lt;strong&gt;数组名[下标索引]&lt;/strong&gt;对数组进行赋值，其格式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;数组名[下标索引]=value&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如果下标不存在，则自动向数组添加一个新的元素值&lt;/li&gt;
&lt;li&gt;如果下标存在，则会覆盖先前的元素值&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;示例如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# array=(1 3 5)
[root@localhost Test]# array[2]=100  # 下标存在，覆盖之前的元素
[root@localhost Test]# array[5]=888  # 下标不存在，则自动添加一个新的元素值
[root@localhost Test]# echo ${array[*]}
1 3 100 888
[root@localhost Test]# echo ${#array[@]}
4&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数组删除&quot;&gt;数组删除&lt;/h4&gt;
&lt;p&gt;  数组本质上还是一种变量，因此通过使用&lt;strong&gt;unset&lt;/strong&gt;进行清除数组元素。其语法格式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unset 数组名称[下标索引]&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果不带下标索引，则表示清除整个数组，需要注意与输出数组元素不带下标索引的区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# array=(1 3 5 7 9)
[root@localhost Test]# echo ${array[@]}
1 3 5 7 9
[root@localhost Test]# unset array[1] # 清除数组中第2个元素
[root@localhost Test]# echo ${array[@]}
1 5 7 9
[root@localhost Test]# unset array    # 清除整个数组
[root@localhost Test]# echo ${array[@]}
                                      # 清除数组后，输出为空&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数组删除扩展方法&quot;&gt;数组删除扩展方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# b=(a b c d e f g h i)
[root@localhost Test]# echo ${b[*]}
a b c d e f g h i
[root@localhost Test]# echo ${b[*]#a*}  # 从左边开始匹配最短的数组元素并删除
b c d e f g h i
[root@localhost Test]# echo ${b[*]##b*} # 从左边开始匹配最长的数组元素并删除
a c d e f g h i
[root@localhost Test]# echo ${b[*]%i*}  # 从右边开始匹配最短的数组元素并删除
a b c d e f g h
[root@localhost Test]# echo ${b[*]%%g*} # 从右边开始匹配最长的数组元素并删除
a b c d e f h i
[root@localhost Test]# echo ${b[*]}     # 该删除并不影响原数组的内容
a b c d e f g h i&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;数组从某种意义上来说，就是一种特殊的字符变量，因此也适合前面讲的子符串处理的功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;数组截取与替换&quot;&gt;数组截取与替换&lt;/h4&gt;
&lt;p&gt;  数组的截取示例如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# a=($(echo {0..9}))
[root@localhost Test]# echo ${a[*]}
0 1 2 3 4 5 6 7 8 9
[root@localhost Test]# echo ${a[*]:1:3} # 截取下标索引1~3的元素
1 2 3
[root@localhost Test]# echo ${a[*]:0:2}# 截取下标索引0~2的元素
0 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  数组的替换格式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;${ 数组名[*/@]/查找字符/替换字符 }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;该替换操作并不会改变原先的数组内容&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  数组的替换示例如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# echo ${a[*]}
0 1 2 3 4 5 6 7 8 9
[root@localhost Test]# echo ${a[*]/4/456} # 将4替换为456
0 1 2 3 456 5 6 7 8 9
[root@localhost Test]# echo ${a[*]}
0 1 2 3 4 5 6 7 8 9&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组示例-1&quot;&gt;数组示例&lt;/h3&gt;
&lt;p&gt;1、使用循环打印数组元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat array.sh
#!/bin/bash
array=($(echo {0..5}))
echo &quot;first method&quot;
for((i=0;i&amp;lt;${#array[*]};i++)) # 类C风格的for循环
  do
    echo ${i}
  done

echo &quot;second method&quot;
for ele in ${array[*]}  # for in 循环
 do
   echo ${ele}
 done

[root@localhost Test]# bash array.sh
first method
0
1
2
3
4
5
second method
0
1
2
3
4
5&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数组总结&quot;&gt;数组总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1、数组定义&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;array=(1 2 3) # 静态数组
array=($(ls)) # 动态数组&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2、数组赋值&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;array[3]=5&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3、数组删除&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;unset array[3]&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4、数组输出&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; ${array[*]}或${array[@]} # 输出数组全部内容
 ${array[1]}              # 输出数组单个元素&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;5、数组长度&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; ${#array[*]}或${#array[@]} # 输出数组长度&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;6、循环输出数组元素&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;for((i=0;i&amp;lt;${#array[*]};i++))
  do
    echo ${i}
  done
或
for ele in ${array[*]}
 do
   echo ${ele}
 done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;本文同步在微信订阅号上发布，如各位小伙伴们喜欢我的文章，也可以关注我的微信订阅号：woaitest，或扫描下面的二维码添加关注：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3349421-2a0edd703123621d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyQRCode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 25 Nov 2018 16:11:00 +0000</pubDate>
<dc:creator>Surpassme</dc:creator>
<og:description>[TOC]     如果大家有其他语言的基础或经验，就很快能明白数组了。简单来说，数组就某一种相同类型的元素组合，而后通过下标对其进行访问各元素。 数组基础 基础语法 第一种形式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surpassme/p/10018237.html</dc:identifier>
</item>
<item>
<title>IntelliJ IDEA 2018.3 重大升级，哪些功能打动了你？ - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/10017577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/10017577.html</guid>
<description>&lt;p&gt;2018.11.28 IntelliJ IDEA 2018.3 正式版发布。对于一个忠实爱好者，迫不及待的我下载了最新版本来体验下。而且 IDEA 今年的第三次重大更新提供了不容错过的显著功能！你可以访问详细概述的新内容 &lt;a href=&quot;https://www.jetbrains.com/idea/whatsnew/#v2018-3-java&quot;&gt;What's New&lt;/a&gt;，或直接访问网站并立即&lt;a href=&quot;https://www.jetbrains.com/idea/download&quot;&gt;下载 IntelliJ IDEA的全新版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;具体的安装步骤就不在赘述了，可以参考之前的 &lt;a href=&quot;https://www.cnblogs.com/jajian/p/7989032.html&quot;&gt;系列教程 | IntelliJ IDEA（一） ：安装与破解&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;安装完成之后，启动IntelliJ IDEA 2018.3，期待的等待加载过程，首先可以看到，加载界面已经发生变化了，IntelliJ IDEA 2018.2的时候是大红色的，现在改成了如下的背景：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125204005703-224938426.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加载完成之后，还是一如既往的先让你设置操作习惯，当然你也可以默认设置然后直接跳过，之后进入功能界面，发现操作界面好像没有什么大的变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125205723181-1975563304.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于如下的弹框我还是保持让它每次启动自动弹出，因为它可以提示我一些快捷键的使用，毕竟快捷键那么多，每次能了解多一点能更高效率的开发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125205401099-1234828519.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然操作界面上看不出什么大的改变，那说明新的功能升级并非是在工具的界面上而是一些功能使用上，我们将根据官方博客以及自己的理解来为大家解读一下这次更新有哪些全新的功能。&lt;/p&gt;

&lt;p&gt;虽然Java 12尚未发布，而且我们市场上现在普遍的还是在使用JDK 8，但是我们可以先提前了解一点。&lt;/p&gt;
&lt;h2 id=&quot;java-12&quot;&gt;Java 12&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA 2018.3最新支持 Java 12，您可以在IDE中预览Raw String Literals（&lt;a href=&quot;http://openjdk.java.net/jeps/326&quot;&gt;JEP 326&lt;/a&gt;），并利用大量有用的检查和快速修复。例如，将多行字符串文字转换为原始字符串文字，反之亦然，检测冗余的前导或尾部反引号（`）等。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;何为 Raw String Literals&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;原始字符串文字可以跨越多行源代码，不会解释\n表单的转义序列，例如Unicode转义符\uXXXX。简单来说就是，它不会对反斜杠''进行特殊的转义处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;转换为原始字符串文字&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125211308956-1178586037.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少反引号的数量&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125212125132-2088479440.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分割原始字符串文字&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125212139857-1055222023.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;检测更多重复项&quot;&gt;检测更多重复项&lt;/h2&gt;
&lt;p&gt;即使在更复杂的情况下，IntelliJ IDEA现在也可以快速发现重复，例如变量名称不同。IDEA 将在差异查看器中显示重复项，因此您可以将它们彼此并排比较。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125214604565-1581632350.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-stream-api的改进&quot;&gt;Java Stream API的改进&lt;/h2&gt;
&lt;p&gt;IDEA 检测在后续最小 Call 之前进行不必要的已排序 Call 的情况。还提供了用于删除冗余排序 Call 的快速修复程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125215129588-426945853.gif&quot; alt=&quot;JavaRedundantMin&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据流增强功能&quot;&gt;数据流增强功能&lt;/h2&gt;
&lt;p&gt;我们已经创建了一个新的基于数据流的检查，称为 &lt;strong&gt;Condition is covered by further condition&lt;/strong&gt;。当第一个条件被第二个条件覆盖时，它会检测到第一个条件是不必要的情况。IDE提供了一个快速修复程序来消除这些冗余条件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125215624455-1728932940.gif&quot; alt=&quot;JavaSimplifingCondition&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;禁止检查的冗余使用&quot;&gt;禁止检查的冗余使用&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA现在可以检测到@SuppressWarning注释、// noinspection行注释或/** noinspection */ JavaDoc注释的冗余用法。当被抑制的检查不再处理相关方法体、类或语句中的任何警告时，IDEA 不仅会给您一个警告，而且还会提供一个快速修复程序来删除这些不必要的注释和注释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125220016822-388201723.gif&quot; alt=&quot;JavaRedundantSuppression&quot;/&gt;&lt;/p&gt;

&lt;p&gt;编辑器也是我们开发中常用的一些功能，新版本中 IDEA 又为我们推出了一些实用又便捷的操作。&lt;/p&gt;
&lt;h2 id=&quot;多行todo评论&quot;&gt;多行TODO评论&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA 2018.3现在支持多行 TODO 注释，现在第一个和所有后续的 TODO 注释行在编辑器中突出显示并列在TODO工具窗口中。只需从多行 TODO 注释的第二行开始添加缩进，IDEA 就会将其与普通注释区分开来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125220324899-811852996.gif&quot; alt=&quot;EditorMultipleTODOComments&quot;/&gt;&lt;/p&gt;
&lt;p&gt;老版本中，是不支持多行 TODO 注释的显示的，而在新版本中，如果 todo 注释有多行，你只需要在下面几行前面再添加一个空格即可。&lt;/p&gt;
&lt;h2 id=&quot;禁用对特殊文件和文件夹的代码格式化&quot;&gt;禁用对特殊文件和文件夹的代码格式化&lt;/h2&gt;
&lt;p&gt;我们已经可以从格式化、导入优化和代码重排中锁定某些文件——实际上是从任何涉及格式化的操作中锁定，无论是显式的还是隐式的。只需创建一个范围，并将任何不能格式化的文件添加到其中!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125220744577-1959990426.png&quot; alt=&quot;EditorDisableFormating&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新的缩进状态栏&quot;&gt;新的缩进状态栏&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA在一个新的缩进状态栏中显示当前文件中的缩进大小。如果文件的缩进与项目的当前设置不匹配，将在缩进视图中添加星号。现在可以选择控制状态栏中当前缩进的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125220931178-931078991.png&quot; alt=&quot;EditorIndent&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;editorconfig支持的改进&quot;&gt;EditorConfig支持的改进&lt;/h2&gt;
&lt;p&gt;IDE现在为EditorConfig文件提供语法突出显示和代码完成。您还可以使用新的缩进状态栏弹出窗口轻松导航到正在使用的EditorConfig文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125221029913-1075542272.gif&quot; alt=&quot;EditorConfig&quot;/&gt;&lt;/p&gt;

&lt;p&gt;IDEA 中的版本控制一直是我比较热爱的一个功能，对于代码分支管理，代码拉取提交都比较友好，特别是 Merge 冲突的时候，本地代码和远程分支代码的冲突 Diff Code 分界面展示，清晰一目了然，减少了合并代码的痛苦。在新版本中 IDEA 又对版本控制做了哪些优化呢？&lt;/p&gt;
&lt;h2 id=&quot;github拉请求&quot;&gt;GitHub拉请求&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA最新支持GitHub Pull请求。从全新的GitHub pull requests工具窗口预览GitHub储存库中的所有拉请求。使用diff预览更改，或者通过上下文菜单从Pull请求创建一个本地分支，然后将其合并为常规分支。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125221306910-1782498533.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;history-up-to-here-可以展示完整的历史&quot;&gt;“History up to Here” 可以展示完整的历史&lt;/h2&gt;
&lt;p&gt;以前，&lt;strong&gt;History up to Here&lt;/strong&gt; 只显示所选提交之前文件的历史记录，但是现在它可以通过切换到工具栏上显示所有分支来显示文件之后发生的事情。如果文件后来被删除了，这可能特别有用，因为要查明这种情况并非易事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125221456547-147386609.gif&quot; alt=&quot;VCSHistoryUpToHere&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;vcs日志中的高级导航&quot;&gt;VCS日志中的高级导航&lt;/h2&gt;
&lt;p&gt;您现在可以在VCS日志中从提交散列导航到VCS日志选项卡中的提交之后，或者在使用Go to hash/branch/tag操作之后，使用前进和后退导航操作。使用左右箭头键导航到子或父提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125221731380-2131145485.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;忽略空格&quot;&gt;忽略空格&lt;/h2&gt;
&lt;p&gt;用 IDEA合并代码时，发现有时候只是两个开发者提交的代码是因为格式化，导致一些空格的差异，我们可能也需要一个个检查下。&lt;/p&gt;
&lt;p&gt;现在，在新版本中，IDEA 可以在合并时忽略空白更改。在“ 合并修订版本”对话框中，有一个新的“ 忽略” 下拉菜单，其中包含用于在合并时隐藏或修剪空白更改的选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125222022452-1598161432.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;将文件从一个git分支复制到另一个分支&quot;&gt;将文件从一个Git分支复制到另一个分支&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA 2018.3允许您通过方便的新的Get from Branch操作轻松地将文件从一个Git分支复制到另一个Git分支，该操作可从Compare branches对话框的Files选项卡中获得。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125222107835-1082938879.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;提交对话框中的分支名称&quot;&gt;提交对话框中的分支名称&lt;/h2&gt;
&lt;p&gt;IDE将在“ 提交”对话框中显示您要提交文件的分支名称。目前 IDEA 已经为Git，Mercurial 和 SVN 实现了这个功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125222226619-491174583.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;预览文件历史记录选项卡中的差异&quot;&gt;预览文件历史记录选项卡中的差异&lt;/h2&gt;
&lt;p&gt;Diff Preview现在可在Version Control工具窗口的File History选项卡中找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125222306804-1039111361.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;新搜索无处不在&quot;&gt;新搜索无处不在&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA 2018.3引入了一种更好的方法来浏览项目和IDEA。请热烈欢迎重新设计Search Everywhere！实际上，它不仅仅是Search Everywhere，因为它包含了所有其他导航对话框：Search Everywhere， Find Action，Go to class，Go to file和Go to symbol。请注意，所有这些导航对话框仍可通过自己的键盘快捷方式访问，如前所述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125222706981-1978749770.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IDEA 中的搜索可以分为以下几类:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;类搜索&lt;/strong&gt;，比如 Java，Groovy，Scala 等类文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文件搜索&lt;/strong&gt;，类文件之外的所有文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;符号搜索&lt;/strong&gt;，包括接口名，类名，函数名，成员变量等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Action 搜索&lt;/strong&gt;，找到你的操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字符串搜索及替换&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 IDEA 的世界里，搜索无处不在，你几乎可以瞬间找到你想要找到的任何一行代码甚至任何一个字。新版中，IDEA 更是将类、文件、符号、Action 搜索与双 Shift 键调出来的 SearchEverywhere 无缝地结合在一起。&lt;/p&gt;
&lt;h2 id=&quot;在find-in-path中搜索多行片段&quot;&gt;在“Find in Path”中搜索多行片段&lt;/h2&gt;
&lt;p&gt;现在，可以在路径中的查找/路径替换对话框中执行多行片段的搜索/替换 。您不再需要使用正则表达式来执行多行搜索。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125222917099-968760287.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;新结构搜索和替换对话框&quot;&gt;新结构搜索和替换对话框&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA 2018.3提供了一个更新的、流线型的&lt;strong&gt;结构化搜索和替换对话框&lt;/strong&gt;。自动完成功能可在搜索字段的预定义模板中使用。您可以在搜索图标下方的下拉菜单中查看搜索历史记录。范围配置现在也更容易，更灵活。复杂的“ 编辑变量”表单已替换为过滤器面板，您可以在更新的对话框中找到该面板。&lt;/p&gt;
&lt;p&gt;举个栗子：如果我们想搜索所有的 try catch 语句块，在调出结构化搜索框之后，可以输入以下文本：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try {
  $TryStatement$;
} catch($ExceptionType$ $Exception$){
  $CatchStatement$;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，IDEA 就会把所有的 try catch 语句块搜索出来，而新版更是强化了这个功能，下面我用两张动图演示一下这次更新的两个功能&lt;/p&gt;
&lt;p&gt;结构化搜索由于输入的文本比较长，所以一般我们会自己预置一些模板，然后给模板命名，然后结构化搜索的时候呢，我们就可以直接基于这个模板名来搜索，新版更新的第一个功能就是，在文本输入框里，按下智能补全键，可以迅速调出模板，按照最近的搜索历史排序，然后再按下回车，文本就自动给你填充上了，你还可以点击左上角的搜索 icon，也会展示你最近的搜索记录，这些记录是以文本的方式展示的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125224234414-2045864533.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的文本就是系统内置的结构化模板 try's，点击完 Find 按钮之后，所有的 try catch 都会展示出来，我们还可以进一步过滤，比如，我们想要找出 catch 到的 exception 的名字为 flash，给对应的模板变量加上一个 Text 类型的 filter 即可迅速定位。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125224243720-496963960.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2018.3版本中更新了“首选项（设置）” 中的“ 插件”页面，以便更轻松地管理，安装，卸载和更新插件。现在，您不仅可以按名称搜索插件，还可以按标签搜索插件。它变得更好，因为您现在还可以通过下载，名称，评级，功能或更新对结果进行排序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125225455925-629064586.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调出插件配置之后，页面分为三大部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Marketplace&lt;/strong&gt;： 插件市场，你可以搜索到你想要的插件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Installed&lt;/strong&gt;： 当前安装的所有的插件，你还可以点击左上角搜索小 icon，按类别查看当前已安装的插件，其中的 custom 选项便是自己下载安装的插件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Updates&lt;/strong&gt;：当前安装过的插件如果有更新，都会在这里显示出来&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后一个是配置项，你可以自定义你的插件仓库，你可以给配置插件下载的 http 代理（尤其是国外网络访问差的时候），你还可以从本地硬盘中安装插件&lt;/p&gt;

&lt;p&gt;IntelliJ IDEA 2018.3带有一种新的集中式方法，可通过新的Run Anything操作（双击 &lt;code&gt;Ctrl&lt;/code&gt; 调出窗口）在IDEA 中运行命令。使用新操作启动运行配置，可以运行包括 Maven 、Gradle 等其他终端命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125225233496-1771879732.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在菜单栏中如下的图标按钮即可打开，亦可通过快捷键双击 &lt;code&gt;Ctrl&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125224444846-1877019984.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，只需按Shift键即可将Run Anything对话框切换到Debug Anything模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125225343674-997262809.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;IDEA 这次又推出了一款新主题 &lt;strong&gt;High constrast&lt;/strong&gt;，但是我感觉不是特别好看 我还是喜欢原来的 &lt;strong&gt;Darcula&lt;/strong&gt;，根据每个人的口味吧，自己选择。主题预览如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125230919740-1317287622.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;IntelliJ IDEA 2018.3完全支持最近发布的Spring Boot 2.1。现在，当您使用Spring Initializr创建项目时，IDE将建议安装或启用适当的插件，以确保支持所有选定的技术。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125231056836-1051068615.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;attach-到-java进程&quot;&gt;attach 到 java进程&lt;/h2&gt;
&lt;p&gt;IDEA 的 debug 功能无论是对于调试找错还是阅读源码，都发挥了非常重要的作用，新版 IDEA 对 debug 功能进一步加强，现在不仅仅能 debug 当前的应用，而且能够 attach 到任意的 Java 进程，attach 之后，你就可以看到该进程的线程状态，并且使用强大的 Memory View 功能可以看到当前内存的状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125231222961-174811255.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;自动重启侦听远程连接&quot;&gt;自动重启侦听远程连接&lt;/h2&gt;
&lt;p&gt;现在，在调试远程进程时，IDE可以自动重新启动配置。只需 为远程调试配置启用新的自动重启选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125231345623-1352731750.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;远程jvm中的异步堆栈跟踪&quot;&gt;远程JVM中的异步堆栈跟踪&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA 2018.3现在支持远程JVM中的异步堆栈跟踪。要远程开始使用代理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将/lib/rt/debugger-agent.jar复制到远程计算机。&lt;/li&gt;
&lt;li&gt;将-javaagent：debugger-agent.jar添加到远程JVM选项。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在，您可以在“ 异步注释配置”对话框中定义自己的异步注释。&lt;/p&gt;
&lt;h2 id=&quot;删除所有断点的操作&quot;&gt;删除所有断点的操作&lt;/h2&gt;
&lt;p&gt;IntelliJ IDEA 2018.3提供了一些方便的新操作，可以删除项目中的所有断点或文件中的所有断点。您可以在“首选项（设置）”中为这些快捷方式分配自己的快捷方式 键图| 调试器操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125231452053-1700206828.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在网上看到一篇文章说 IDEA 2018.3 支持 CPU 的火焰图了，但是我看官网上没有介绍，所以也不确定，但是如果真有这功能我感觉满酷炫的。这里引用一下他的内容做个介绍。&lt;/p&gt;
&lt;p&gt;IDEA 分析 Java 程序的性能分析了，主要包括如下几个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;火焰图分析 CPU 性能消耗，你可以分析 Java 进程的所有线程的 CPU 消耗火焰图，也可以只选择一个线程来分析&lt;/li&gt;
&lt;li&gt;方法调用图，可以找到在某个线程中，消耗 cpu 最多的方法&lt;/li&gt;
&lt;li&gt;方法列表，可以看到每个方法的调用次数，点进去还可以看到详细的调用栈&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面用一章动图来展示一下，具体的细节读者可自行探索&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1162587/201811/1162587-20181125231812136-466767338.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了这个神器之后，你不需要额外的 profiler 工具，就可以直接在 IDEA 里面完成应用程序的性能分析。预计不久的将来，Eclipse MAT 相关的功能可能也会移植到 IDEA 中，届时，Java 应用程序性能分析，堆分析，gc 分析将统统可以在 IDEA 里面运行，真正的 All In One 时代即将到来！&lt;/p&gt;

&lt;p&gt;当然本次的更新不止这些，篇幅有限，而且很多我目前也用不上，例如：关于Kubernetes的支持Helm资源文件，在Helm资源文件中导航，关于数据库的SQL代码完成的改进等等。&lt;/p&gt;
&lt;p&gt;如果你感兴趣的话可以前往 IDEA 的官网阅读下他们更新的日志，或下载他们最新的版本体验下。IDEA 现在发展的越来越好，用户肯定也会越来越多，还没有加入体验的现在可以试着使用下。&lt;/p&gt;
&lt;p&gt;参考：1. &lt;a href=&quot;https://blog.jetbrains.com/idea/2018/11/intellij-idea-2018-3-github-pull-requests-java-12-multiline-todo-comments-git-submodule-support-and-more/&quot;&gt;IDEA 的新功能&lt;/a&gt; 2. [微信公众号] 闪电侠的博客&lt;/p&gt;
</description>
<pubDate>Sun, 25 Nov 2018 16:02:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>前言 2018.11.28 IntelliJ IDEA 2018.3 正式版发布。对于一个忠实爱好者，迫不及待的我下载了最新版本来体验下。而且 IDEA 今年的第三次重大更新提供了不容错过的显著功能！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/10017577.html</dc:identifier>
</item>
<item>
<title>redis学习笔记 - 陈芳志</title>
<link>http://www.cnblogs.com/chenfangzhi/p/10018213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenfangzhi/p/10018213.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;最近在学习redis，觉得redis确实是分布式系统中的一个利器，于是看了很多官方文档，带着一些问题，结合平时项目中使用情况作了一些总结，本文不适合redis初学者，初学者可以查看&lt;a href=&quot;http://doc.redisfans.com/&quot;&gt;Redis 命令参考&lt;/a&gt;先学习下redis。&lt;/p&gt;
&lt;h2 id=&quot;一redis和memcached的区别&quot;&gt;一、redis和memcached的区别&lt;/h2&gt;
&lt;p&gt;以下来自Stack Overflow的一个问答&lt;a href=&quot;https://stackoverflow.com/questions/10558465/memcached-vs-redis?rq=1&quot;&gt;memcached-vs-redis&lt;/a&gt;，已经说的十分清楚了：&lt;/p&gt;
&lt;p&gt;redis比memcached更强大、更流行、更受支持。Memcached只能做Redis能做的一小部分事情。即使在它们重叠的一些地方，redis也能做的更好。&lt;/p&gt;
&lt;p&gt;以下是详细对比：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;速度：两者都非常快。基准测试因工作负载、版本和许多其他因素而异，但通常显示redis与memcached一样快或几乎一样快。我推荐使用redis，但并不是因为memcached慢&lt;/li&gt;
&lt;li&gt;内存使用：
&lt;ol&gt;&lt;li&gt;memcached：你可以指定缓存大小，当插入项目时，守护进程会快速增长到略大于此大小。除了重新启动memcached之外，从来没有真正的方法可以回收这些空间。您所有的键都可以过期，您可以刷新数据库，它仍然会使用您配置它时使用的全部RAM。&lt;/li&gt;
&lt;li&gt;redis：设置最大大小取决于您。Redis使用的内存永远不会超过它必须使用的内存，它会将不再使用的内存还给您。&lt;/li&gt;
&lt;li&gt;我将100000个大约2KB字符串(大约200MB)的随机句子存储到这两个字符串中。Memcached内存的使用增长到大约225MB。Redis内存的使用增长到大约228MB。刷新后，redis下降到大约29MB, memcached保持在~225MB。它们在存储数据方面也同样高效，但redis能够回收数据。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;持久化：这对redis来说是一个明显的胜利，因为它在默认情况下是这样做的，并且持久化有很多可配置项。Memcached没有在没有第三方工具的情况下转储到磁盘的机制。&lt;/li&gt;
&lt;li&gt;扩展： 在您需要一个以上的实例作为缓存之前，这两种方法都为您提供了大量的空间。Redis提供了一些工具来帮助您做这些事，而memcached不提供这些工具。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二批量导入数据&quot;&gt;二、批量导入数据&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有时候我们需要批量导入一些数据，这时候可以通过将命令写入文本中，然后通过管道导入redis，文本中的命令不需要显示的分隔符结尾，内容如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;set key1 value1
set key2 value2
set key3 value3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导入命令如下：&lt;code&gt;cat command.txt|redis-cli -h 10.10.23.15&lt;/code&gt;也可以加上&lt;code&gt;--pipe&lt;/code&gt;批量执行命令&lt;/p&gt;
&lt;h2 id=&quot;三关于redis-sentinel和cluster&quot;&gt;三、关于redis Sentinel和Cluster&lt;/h2&gt;
&lt;p&gt;redis的哨兵是官方作为redis高可用的解决方案，针对的是redis的主从故障转移，没有分片的功能。如果你的数据一个redis实例能够完全存放时，那么redis Sentinel是一种不错的方案，能够监视redis集群，并提供故障转移的功能。但是如果一台redis不能完全放下你的数据时，你必须选择扩展redis，有很多解决方案，早期很多采用了客户端分片或者代理的形式，在redis3.0官方支持集群，这种方案是服务端分片，一开始不理解哨兵和集群的关系，以为哨兵是用来做高可用，集群只是分片，但是其实集群本身就是自治的，并且已经有了高可用的功能，在配置集群的时候，可以配置主节点和相应的从节点，集群会相互探测节点的存活，在主节点下线时进行故障转移，等于说，搭建集群事并不需要也不应该才让哨兵介入。&lt;/p&gt;
&lt;h2 id=&quot;四提高redis性能&quot;&gt;四、提高redis性能&lt;/h2&gt;
&lt;p&gt;这里我看到了一篇十分不错的文章：&lt;a href=&quot;https://www.cnblogs.com/mushroom/p/4738170.html&quot;&gt;Redis性能问题排查解决手册&lt;/a&gt;，内容十分不错，在排查redis性能问题的时候可以当一个手册来看，我主要关注的点如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;slowlog： 这个命令用来查redis的慢查询日志，之前在优化mysql时，慢查询日志非常有用，让我对这个比较敏感，另外redis的慢查询日志是保存在内存中的，在重启的时候，日志会丢失。像对于redis来说，一般的命令执行非常快，瓶颈主要会在网络io，所以设置10ms是比较保守的，一个命令如果要&lt;/li&gt;
&lt;li&gt;命令复杂度：redis在处理客户端请求时是单线程的，所以redis对cpu非常敏感，如果一个命令非常耗时就会导致其他的命令被阻塞，因此我们得十分注意redis命令的复杂度，例如集合的运算和list的随机存取时，在用到复杂度高的命令时需要十分注意value的大小，像list的lset命令是O(n)级别的，如果能始终控制list在几百以下，那么经常使用也是完全没问题的，但是如果上万的场景，如果这样的需求，是不是应该考虑做列表的切片，或者采用zset来代替。&lt;/li&gt;
&lt;li&gt;批量执行命令：redis的很多命令都提供了批量执行的版本，可以用这些命令很容易优化，上面也说了redis的主要瓶颈在io，所以如果可以用批量执行命令的话，尽量批量执行。对于不同类型的命令，redis还提供了流水线，流水线是一种客户端行为，你打开流水线之后发送的命令会被客户端缓存着，当你告知客户端发送命令时，命令会被批量传送到redis，执行完后批量返回，只有一次往返，提高了吞吐量。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里想说下zset的两个命令： &lt;code&gt;ZRANGE key start stop [WITHSCORES]&lt;/code&gt;和&lt;code&gt;ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]&lt;/code&gt;,zrange的复杂度O(log(N)+M)，N为有序集的基数，M为被结果集的基数没有太多疑问。但是ZRANGEBYSCORE这个命令的服务度，如果没有后面的[LIMIT offset count]那么他和zange的复杂度是一样的，但是如果加上后面的分页参数他的复杂度实际是O(log(N)+M+offset)，试想这样的场景：zset有200000个元素，且分数一样（这样的场景是存在的，见：redis实战），查找排名199990到200000的元素，两者的复杂度天差地别，实现的分页功能确实一样的。所以，一共要小心这种隐藏的坑。&lt;/p&gt;
&lt;h2 id=&quot;五redis的锁&quot;&gt;五、redis的锁&lt;/h2&gt;
&lt;p&gt;在实现一个需要加锁的操作时，redis提供了三种方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;事务： 乐观锁，适合冲突很少的场景&lt;/li&gt;
&lt;li&gt;分布式锁： 悲观锁，适合冲突频繁的场景，如果冲突频繁事务的重试次数为激增，大量消耗cpu&lt;/li&gt;
&lt;li&gt;lua： 适合性能瓶颈的优化，是一种锁的优化手段&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;六lua脚本和事务&quot;&gt;六、lua脚本和事务&lt;/h2&gt;
&lt;p&gt;redis中lua脚本十分简单，可以把它理解为redis中的存储过程。在数据库中，尤其是mysql，很多公司都禁止使用存储过程，因为不好维护，有很多人喜欢把逻辑写在存储过程(其实我觉得如果存储过程中只写简单的sql，并且有统一的公司规范也是比较容易维护的，主要是有些人写在代码中，有些人写存储过程，而且逻辑写经常写在存储过程，所以直接禁止比较好)。&lt;br/&gt;对于redis的lua来说，我觉得在有些情况下是很有必要的，因为redis单线程处理客户端命令的这一个特点，lua脚本的执行也是原子性的，在很多的需要事务的场景都可以采用lua来代替，比如：获取key a的值，如果a&amp;gt;10，那么设置b为0。采用lua可以减少网络的往返次数，在对性能有极致要求的情况下，采用lua提高几倍的吞吐量是非常有用的手段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是我认为在大多数情况下都不应该使用lua，尽量采用redis本身支持的事务和流水线等功能来提高吞吐量&lt;/strong&gt;，理由如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;lua对集群支持不友好：一般场景下事务的性能已经足够了，如果采用lua之后又在达到瓶颈，那么势必要考虑集群来横向扩展了，lua如果涉及到多个键分布在不同的实例上，集群会直接返回失败，上面说过集群不支持多键命令，同样不支持key在不同实例的lua脚本。如果要支持这个lua脚本，那么你要保证键都在一个实例。详情参见：&lt;a href=&quot;https://redis.io/topics/cluster-spec#keys-hash-tags&quot;&gt;Keys hash tags&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;lua可维护性：lua虽然很简单，但是不是团队中每个人都会，如果里面写了很多的逻辑，可维护性比较差&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我的建议还是尽量不使用lua，如果有必要使用lua可以作为后期性能瓶颈的优化方案。&lt;/p&gt;
&lt;p&gt;另外在说说事务和lua，事务在某些场景还是lua不能代替的，如：在事务watch之后，我需要检查下内存中的变量a，如果a大于0，那么执行事务。lua的上下文是在redis中，它能看到的只是整个redis，所以lua并不能完全代替事务。&lt;/p&gt;
&lt;h2 id=&quot;七关于redis的事务概念&quot;&gt;七、关于redis的事务概念&lt;/h2&gt;
&lt;p&gt;很多人都知道redis的事务概念，也知道数据库中的事务，但是这两个事务是没有什么关联的。redis的事务保证了操作的原子性，在操作执行的过程中，操作不会被打断，例如操作 1,2,3 即使1失败了，2和3照样会执行。redis事务的原子性和数据库事务的原子性也没有太大关系，如果说非要对应那么更加对应的是数据库事务的隔离性，数据库事务的原子性和隔离性定义如下（摘自360百科）：&lt;/p&gt;
&lt;p&gt;原子性： 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;redis没有回滚，如果失败也继续执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;隔离性：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同一时间仅有一个请求用于同一数据。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;redis单线程保证了执行过程中不会被另一个事务打扰&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;八redis的zset&quot;&gt;八、redis的zset&lt;/h2&gt;
&lt;p&gt;在使用的过程中觉得zset的功能实在是强大，因为他有序性的特点，能提供很多功能。有必要好好学习底层的实现（hashmap+skiplist），非常有用的数据结构。&lt;/p&gt;
&lt;h2 id=&quot;九redis的key驱逐策略&quot;&gt;九、redis的key驱逐策略&lt;/h2&gt;
&lt;p&gt;memcache默认是基于lru驱逐，而redis的默认是关闭的，如果内存满了，redis会拒绝执行写命令。在编写程序的时候需要知道redis有没有配置lru，如果配置了那么你的key都是不可靠的，有可能会丢失，这就是缓存的典型场景。对于缓存来说，最好给你的每个key都设置上过期时间。&lt;/p&gt;
&lt;h2 id=&quot;十redis部署方案&quot;&gt;十、redis部署方案&lt;/h2&gt;
&lt;p&gt;关于redis的部署方案有很多，需要针对具体的应用场景，主要考虑的是成本，一个备份节点没用到，成本很高，另外如果作为数据库必须持久化&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果只是缓存，无高可用： 单机版，（如果做了持久化，要考虑数据的过期问题，主要是程序的考虑）&lt;/li&gt;
&lt;li&gt;缓存+高可用：一主一从+哨兵（只在从节点持久化）&lt;/li&gt;
&lt;li&gt;缓存+高可用+高性能：一主多从+哨兵 客户端做读写分离（所有的读写分离都需要考虑一致性的问题）&lt;/li&gt;
&lt;li&gt;数据库，一个实例能放下所有数据：可以采用主从（双机持久化）+哨兵，&lt;/li&gt;
&lt;li&gt;数据库+一个实例不能放下所有数据：集群+主从+双机持久化&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;方案无非是 持久化、主从高可用、读写分离、集群等组合，需要根据实际的业务来部署，建议在微服务架构下不要采用一套方案，而是多个方案部署，比如缓存部署一套，内存数据库方案部署一套，针对高并发场景单一致性要求不高的部署读写分离。每个服务之间用到的数据库在最好隔开，如果使用同一个缓存就选择不同的db，有利于后期迁移数据。关于部署方案可以参考&lt;a href=&quot;https://help.aliyun.com/document_detail/52685.html?spm=a2c4g.11186623.6.548.5fa46fd3y5qosd&quot;&gt;阿里云redis文档&lt;/a&gt;，非常值得学习。&lt;/p&gt;
&lt;p&gt;这里有一点疑问，我在网上看到很多都说主从采用链式复制，包括阿里云的读写分离也采用了这样一个方案，好处显而易见，但是不知道自己搭建的话怎么实现，我看官网文档的sentinel都是星式复制，找不到相关的部署方法，如果有知道的，望大神告知！&lt;/p&gt;
</description>
<pubDate>Sun, 25 Nov 2018 15:58:00 +0000</pubDate>
<dc:creator>陈芳志</dc:creator>
<og:description>[TOC] 最近在学习redis，觉得redis确实是分布式系统中的一个利器，于是看了很多官方文档，带着一些问题，结合平时项目中使用情况作了一些总结，本文不适合redis初学者，初学者可以查看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenfangzhi/p/10018213.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 轻松学-从安装环境开始 - Ron.liang</title>
<link>http://www.cnblogs.com/viter/p/10018158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/10018158.html</guid>
<description>&lt;h3 id=&quot;asp.net-core-介绍&quot;&gt;Asp.Net Core 介绍&lt;/h3&gt;
&lt;p&gt;    Asp.Net Core是微软新一代的跨平台开发框架，基友 C# 语言进行开发，该框架的推出，意味着微软从系统层面正式进击 Linux 服务器平台；从更新速度开来看，微软在 Asp.Net Core 的开发上可谓不遗余力。&lt;/p&gt;
&lt;p&gt;    从开发者社区看，Asp.Net Core 有多火热，那么在过去 10 年间，C# 的开发者就有多压抑，过去 10 年以来，以 C# 开发语言为主业的开发者，几乎只能游历于所谓的企业级开发，其实就是做 OA、ERP、CRM 等传统软件开发，或者服务于部分互联网公司的内部管理系统；从业务层面来说，他们从来都没有进入互联网公司的核心业务；即使部分业务以 Mono 为容器寄存于 Linux 平台的出现，也没能为他们争得一席之地。&lt;/p&gt;
&lt;p&gt;     不客气的说，C# 过去一直被认为是做小项目开发所使用的，这种类似于 Java 语法的开发语言，却没有取得类似 Java 的地位，其根本原因在于微软的策略定位的失误；过去 10 年的闭源，带来的是生态的凋零、市场的没落。&lt;/p&gt;
&lt;p&gt;    C# 语言的开发者，在这个行业可以说是苦不堪言，冷暖自知，从薪资水平到行业地位，我们苦苦支撑，今天，我们终于等来了可能存在的春天。&lt;/p&gt;
&lt;p&gt;    .Net的历史渊源流长，笔者从 2006 年进入微软的开发阵营，从 .Net 1.1 和 VS2003 开始，一直看着 .Net 成长，版本号越来越高，SDK 包越来越大，部署变得日益艰难；Asp.Net Core 的出现彻底改变了这一切，跨平台部署，高可维护性，易迁移，现在我们也能用上稍微便宜的 Linux 服务器，更重要的是，Asp.Net Core 的生态圈正在快速建立并日臻完善中。&lt;/p&gt;
&lt;h3 id=&quot;如何安装-.netcore-sdk-开发者工具包&quot;&gt;如何安装 .NetCore SDK 开发者工具包&lt;/h3&gt;
&lt;p&gt;     .NetCore SDK 支持 Linux 全平台和 Windows 平台，目前 SDK和Runtime 最新版本是 2.2&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开网址&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;https://www.microsoft.com/net/download/dotnet-core/2.2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201811/26882-20181125233337464-760011345.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开终端，Windows 点击开始菜单，输入 cmd 打开控制台，输入命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;dotnet —version&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;黑漆漆的终端窗口上将显示以下内容&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201811/26882-20181125233417610-1557020891.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共享你，已经开始踏上了 Asp.Net Core 的旅程&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;hello-world&quot;&gt;Hello World!&lt;/h3&gt;
&lt;p&gt;    世界上所有的程序都以 Hello World! 开始，我们也不能免俗&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开终端控制台，输入命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;dotnet new Console -o MyApp&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;终端控制台将显示如下内容&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201811/26882-20181125233449316-1415521739.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以上窗口提示我们创建了一个 “Console” 类型的项目，并输出项目文件到 /Users/liangguixiao/MyApp 文件夹中，该项目命名为 MyApp，并且 .NETCore 在创建完成后自动连接 Nuget 将项目依赖包进行了还原&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Processing post-creation actions...
Running 'dotnet restore' on MyApp/MyApp.csproj...
  Restoring packages for /Users/liangguixiao/MyApp/MyApp.csproj...
  Generating MSBuild file /Users/liangguixiao/MyApp/obj/MyApp.csproj.nuget.g.props.
  Generating MSBuild file /Users/liangguixiao/MyApp/obj/MyApp.csproj.nuget.g.targets.
  Restore completed in 157.9 ms for /Users/liangguixiao/MyApp/MyApp.csproj.

Restore succeeded.&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;现在，在终端控制台输入命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cd /Users/liangguixiao/MyApp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; * 定位到项目所在文件夹，然后在资源管理器中打开文件夹，可以看到项目下有很多文件，我们先忽略，继续往下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201811/26882-20181125233531399-1710191060.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接下来在终端控制台输入命令对项目文件进行编译&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;dotnet build &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201811/26882-20181125233608877-1286251014.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提示 Build succeeded. 编译成功，没有任何错误&lt;/li&gt;
&lt;li&gt;再接再励，继续在终端控制台输入命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;dotnet run &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201811/26882-20181125233636029-765888116.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;*完美，终端控制台输出了 Hello World!，恭喜你，你人生的第一个 .NETCore 项目创建并运行成功&lt;/p&gt;
&lt;h3 id=&quot;推荐&quot;&gt;推荐&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;努力为开源社区作贡献，推荐一个自己开发的基于 .netcore+pgsql 的快速开发脚手架，内置 ORM框架，github地址：&lt;a href=&quot;https://github.com/lianggx/mystaging&quot; class=&quot;uri&quot;&gt;https://github.com/lianggx/mystaging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;文中如有疏漏之处，欢迎指正。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;    今天我们简要介绍了 Asp.Net Core 的前世今生，并了解了如何下载并安装开发者工具包（SDK），最后，还通过终端控制台创建并运行了第一个 Asp.Net Core 控制台项目，并通过输入各种命令最终让程序输出了 Hello World! 字符，在接下来的第二章里面，我们将通过 Hello World! 来介绍各种常用命令、项目文件目录等信息，进一步了解 Asp.Net Core。&lt;/p&gt;
</description>
<pubDate>Sun, 25 Nov 2018 15:43:00 +0000</pubDate>
<dc:creator>Ron.liang</dc:creator>
<og:description>Asp.Net Core 介绍     Asp.Net Core是微软新一代的跨平台开发框架，基友 C 语言进行开发，该框架的推出，意味着微软从系统层面正式进击</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viter/p/10018158.html</dc:identifier>
</item>
<item>
<title>爬虫基础（二）——网页 - 南宫恨</title>
<link>http://www.cnblogs.com/ydkh/p/10012790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ydkh/p/10012790.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　爬虫要爬取的信息主要来自于网页加载的内容，有必要了解一些网页的知识。&lt;/p&gt;
&lt;p&gt;  当我们在浏览器网址栏输入一个网址——URL，经过TCP/IP协议簇的处理，这个网址请求的信息就被发送到URL对应的服务器，接着服务器处理这个请求，并将请求的内容返回给浏览器，浏览器便显示或者下载URL请求相应的资源。这是前一篇博客所述。&lt;/p&gt;
&lt;p&gt;  在这一篇博客，笔者尝试说明浏览器是如何显示出这个页面的。如下&lt;/p&gt;
&lt;h2&gt;HTML&lt;/h2&gt;
&lt;h3&gt;HTML的含义&lt;/h3&gt;
&lt;p&gt;  与超文本相对的是线性文本。线性，即直线关系，成比例。一本书，从第一页到最后一页，呈现直线关系；一本书的书签，从第一章转跳至第十章，呈现的是非线性关系。对于线性的计算机文件，不能直接从从一个位置的文件非线性地转至另一个位置的文件，这中间是要经过一定的顺序；相反，超文本之间的关系是非线性的，从一个HTML文件可以直接连接至另一个HTML文件。促成这种连接的正是是超文本链接，超文本链接就是超链接，上一篇的URL就是超链接的一种，电子书中的书签也是超链接的一种。&lt;/p&gt;
&lt;p&gt;  HTML是一门语言，常用于编写网页，HTML文件是超文本的一种形式。以下是一些名称的解释，以辅助理解，不必太在意于严格的定义。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HTML(HyperText Mark-up Language)：超文本标记语言&lt;/li&gt;
&lt;li&gt;超文本：HyperText，用超链接的方法，将不同空间的文字信息组织在一起的网状文本&lt;/li&gt;
&lt;li&gt;链接：link，从一个文档指向其它文档或从文本锚点(anchor)指向某已命名位置的链接&lt;/li&gt;
&lt;li&gt;锚点：anchor，是网页制作中超级链接的一种，又叫命名锚记。命名锚记像一个迅速定位器一样是一种页面内的超级链接&lt;/li&gt;
&lt;li&gt;超链接：hyperlink，它是一种允许我们同其他网页或站点之间进行连接的页面元素&lt;/li&gt;
&lt;li&gt;超文本链接：Hypertext link，就是超链接。是指用文字链接的形式来指向一个页面&lt;/li&gt;
&lt;li&gt;线性：linear，指量与量之间按比例、成直线的关系，在数学上可以理解为一阶导数为常数的函数&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;树&lt;/h3&gt;
&lt;h4&gt;树的概念&lt;/h4&gt;
&lt;p&gt;  树的结构是很简单的，平时留心观察即可知道树为何是“直”的。从第一个分叉开始这树就是由无数的“开叉”结构组成，直至最微小的枝芽。怎么简单怎么来，数学上的描述不管。下面的性质和定义来自《用Python解决数据结构和算法》&lt;/p&gt;
&lt;h4&gt;树的性质&lt;/h4&gt;
&lt;p&gt;  相关术语在“定义1”里面有解释，以分类树为例 此处有图片&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;树是分层的，分层的意思是树的顶层部分更加宽泛一般而底层部分更加精细具体。在图1中，最上层是“界”，它下面的一层（上层的子层）是“门”，然后是“纲”等等。&lt;/li&gt;
&lt;li&gt;一个节点的子节点（node）和另一个节点的子节点（children）是完全独立的。如图1，“猫属”有两个子节点“家生”和“野生”，“蝇属”中也有一个“家生”， 但它和“猫属”中的“家生”是完全不同而且相互独立的。&lt;/li&gt;
&lt;li&gt;树的每个叶节点（leaf）都是不同的。如图1，对每一种动物，我们都可以从根节点（root）开始沿着一条特定的路径找到它对应的叶节点，并把它和其他动物区分开， 例如对于家猫&lt;/li&gt;
&lt;li&gt;树下层的所有部分（子树Subtree）移动到树的另一位置而不影响更下层的情况。如图2，我们可以将所有标注/etc的子树从根节点下移动到usr/下面但是对httpd的内容及其子节点的内容不会有影响。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124185808789-1684937044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图1 一些动物的分类树&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124185946044-1061338903.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;图2 一小部分Unix文件系统的分层情况&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;定义1&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;  &lt;strong&gt;树是节点和连接节点的边的集合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  这个定义简单粗暴，但蕴含的东西不少。以下是一些相关的东西，都是些抽象的概念，将其类比成枝节叶可以吧&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;节点（Node）：树的基本组成&lt;/li&gt;
&lt;li&gt;边（Edge）：树的基本组成，连接两个节点。。每个节点（除了根节点）都有且只有一条与其他节点相连的入边（指向该节点的边），每个节点可能有许多条出边（从该节点指向其他节点的边）。&lt;/li&gt;
&lt;li&gt;根节点（Root）：树中唯一没有入边的节点&lt;/li&gt;
&lt;li&gt;路径（Path）：路径是由边连接起来的节点的有序排列&lt;/li&gt;
&lt;li&gt;子节点集（Childern）：当一个节点的入边来自于另外一个节点时，称前者为后者的子节点。同一个节点的所有子节点构成子节点集&lt;/li&gt;
&lt;li&gt;父节点（Parent）：一个节点是它的所有出边连接的节点的父节点。&lt;/li&gt;
&lt;li&gt;兄弟节点（Sibling）同一节点的所有子节点胡伟兄弟节点&lt;/li&gt;
&lt;li&gt;子树（Subtree）：子树是一个父节点的某个子节点的所有边和后代节点所构成的集合&lt;/li&gt;
&lt;li&gt;叶节点（LeafNode）：没有子节点的节点称为叶节点&lt;/li&gt;
&lt;li&gt;层数（Level）：一个节点的层数是指从跟节点到该节点的路径的边的数目，定义根节点层数为0&lt;/li&gt;
&lt;li&gt;高度（Height）：树的高度等于所有节点层数的最大值&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;定义2&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;  &lt;strong&gt;每棵树为空，或者包含一个根节点和0个或多个子树，其中每个子树也符合这样的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  这个定义巧妙，用到递归只能“巧妙”了。&lt;/p&gt;
&lt;h3&gt;HTML的构成&lt;/h3&gt;
&lt;p&gt;  HTML是由一系列的元素组成，元素由首尾标签和其中的内容组成，学习HTML就要学习那一堆元素。标签表示元素的起始和结束。下面是一个简单的HTML网页。例如代下面代码中&lt;/p&gt;
&lt;p&gt;&amp;lt;li&amp;gt;List item one&amp;lt;/li&amp;gt;是元素，&amp;lt;li&amp;gt;是首标签，&amp;lt;/li&amp;gt;是尾标签，'List item one'是内容。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt; xml:lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt; lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;simple&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A simple web page&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;List item one&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;List item two&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;http://www.cs.luther.edu&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Luther CS &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;代码1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  这个网页也相当于一棵树，树的每一层都对应超文本标记符的一层嵌套。如图3&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124190353932-1354695843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图3 与网页的构成元素相对应的树&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;DOM&lt;/h3&gt;
&lt;p&gt;  DOM（Document Object Model），文档对象模型。当浏览器要显示HTML文档网页的时候，浏览器会创建这个网页全部元素的内部表示体系——DOM，类似于地图表示实际的地点一样，DOM也可以看做是这个HTML网页的“地图”，我们可以通过JavaScript（例如父子对象的形式）去读取DOM这张“地图”。在DOM里面，网页的所有元素以父子对象等形式形成树形结构，这棵树最顶层的是浏览器window对象（如图4），window对象的一个子对象是document对象，一个HTML文档被加载到浏览器的时候，都会创建一个document对象，这个对象包含了HTML文档的全部元素，同样HTML的内容也会表示成树形结构（如图3）&lt;/p&gt;
&lt;p&gt;  当DOM把网页表示成“树”的形式（如图3）时，每个元素都相当于树的节点（元素节点），每个属性也相当一个节点（属性节点），文本也是（文本节点），属性节点和文本节点包含在元素节点中。边表示了元素间的关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124190622808-1820019762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图4 window对象及其一些子对象&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;CSS&lt;/h2&gt;
&lt;p&gt;  通过DOM模型，浏览器就知道如何去显示一个HTML网页的title，h1，body，ul······，但这并不是唯一的方式，我们同样可以通过CSS(Cascading Style Sheets)层级样式表去告诉浏览器该如何去显示一个网页文档，实际上浏览器也会根据外部样式表去构建一棵“树”——CSSOM（CSS Object Model，CSS 对象模型）。&lt;/p&gt;
&lt;p&gt;  CSS是一种样式表语言，用于为HTML文档定义布局。例如，设置字体、颜色、边距、高度、宽度、背景图像等等。爬虫中经常用到CSS选择器。&lt;/p&gt;
&lt;h3&gt;添加CSS的方法&lt;/h3&gt;
&lt;h4&gt;行内样式表&lt;/h4&gt;
&lt;p&gt;  为HTML应用CSS的一种方法是使用HTML属性style。例如下面代码，通过行内样式表将页面背景设为红色，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;例子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;background-color: #FF0000;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这个页面是红色的&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;内部样式表&lt;/h4&gt;
&lt;p&gt;  为HTML应用CSS的另一种方法是采用HTML元素style。代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;例子&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
     body &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;background-color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #FF0000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;        
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这个页面是红色的&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;外部样式表&lt;/h4&gt;
&lt;p&gt;  外部样式表就是一个扩展名为css的文本文件。如何在一个HTML文档里引用一个外部样式表文件（style.css）呢？可以在HTML文档里创建一个指向外部样式表文件的链接（link）即可，就像下面代码那样，其中href=&quot;style/style.css是CSS文件的路径，要注意的就是外部样式表的路径问题，详略。 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;style/style.css&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;CSS构造样式规则&lt;/h3&gt;
&lt;p&gt;  样式表中包含了定义网页外观的规则，样式表中的每条规则都有两个主要部分：选择器（selector）和声明块（declaration block）。选择器的作用在于定位以及决定哪些元素受到影响；声明块由一个或多个属性- 值对（每个属性-值对构成一条声明，declaration）组成，它们指定应该做什么（参见图5 ～图6）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124191553565-911238200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　构造样式规则的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入selector ，这里的selector 表示希望进行格式化的元素。&lt;/li&gt;
&lt;li&gt;输入{（前花括号）开始声明块。&lt;/li&gt;
&lt;li&gt;输入property:value; ,其中property是CSS 属性的名称，描述要应用哪种格式；value 是该属性允许的选项之一。&lt;/li&gt;
&lt;li&gt;根据需要，重复第(3) 步。通常一行输入一个property: value（一条声明），如图6所示的那样，但这并非强制要求。&lt;/li&gt;
&lt;li&gt;输入}，结束声明块和样式规则。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;CSS选择器&lt;/h3&gt;
&lt;p&gt;  由于选择器具有定位作用，例如所以利用选择器就可以定位到我们想提取的数据，因此，CSS选择器经常在爬虫中出现。常见的CSS选择器语法规则如图7，&lt;a title=&quot;见W3C链接&quot; href=&quot;http://www.w3school.com.cn/cssref/css_selectors.asp&quot;&gt;见W3C链接&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181124191626461-473935059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图7 一些CSS选择器的语法规则&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;CSS选择器的应用&lt;/h3&gt;
&lt;h4&gt;在Beautiful Soup中的应用&lt;/h4&gt;
&lt;p&gt;  例如如果爬取到下面这段HTML代码，就可以通过CSS选择器去提取，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
html_doc = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;The Dormouse's story&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p class=&quot;title&quot;&amp;gt;&amp;lt;b&amp;gt;The Dormouse's story&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p class=&quot;story&quot;&amp;gt;Once upon a time there were three little sisters; and their names were
&amp;lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&amp;gt;Elsie&amp;lt;/a&amp;gt;,
&amp;lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&amp;gt;Lacie&amp;lt;/a&amp;gt; and
&amp;lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&amp;gt;Tillie&amp;lt;/a&amp;gt;;
and they lived at the bottom of a well.&amp;lt;/p&amp;gt;

&amp;lt;p class=&quot;story&quot;&amp;gt;...&amp;lt;/p&amp;gt;
&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; bs4 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; BeautifulSoup
soup &lt;/span&gt;= BeautifulSoup(html_doc, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lxml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择所有title标签,结果是一个列表，可迭代&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择body标签下的所有a标签，并获取文本&lt;/span&gt;
results = soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;body a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; result &lt;span&gt;in&lt;/span&gt;&lt;span&gt; results:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result.get_text())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过id查找 选择a标签，其id属性为link1的标签&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a#link1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择所有p标签中的第三个标签&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p:nth-of-type(3)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相当于soup.select(p)[2]&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 选择a标签，其href属性以lacie结尾&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a[href$=&quot;lacie&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择a标签，其href属性包含.com&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a[href*=&quot;.com&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过【属性】查找,选择a标签，其属性中存在myname的所有标签&lt;/span&gt;
a = soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a[myname]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择a标签，其属性href=http://example.com/lacie的所有标签&lt;/span&gt;
b = soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a[href='http://example.com/lacie']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择a标签，其href属性以http开头&lt;/span&gt;
c = soup.select(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a[href^=&quot;http&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(c)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('292bf443-d7cd-4ad3-bf48-667b2ac48155')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_292bf443-d7cd-4ad3-bf48-667b2ac48155&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_292bf443-d7cd-4ad3-bf48-667b2ac48155&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('292bf443-d7cd-4ad3-bf48-667b2ac48155',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_292bf443-d7cd-4ad3-bf48-667b2ac48155&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择body标签下的直接a子标签&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;body &amp;gt; a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择id=link1后的所有兄弟节点标签&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#link1~.mysis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择id=link1后的下一个兄弟节点标签&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#link1 + .mysis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择a标签，其类属性为mysis的标签&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(soup.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a.mysis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从html中排除某标签，此时soup中不再有script标签&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;([s.extract()&lt;span&gt;for&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt; soup(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)])
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果想排除多个呢&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;([s.extract()&lt;span&gt;for&lt;/span&gt; s &lt;span&gt;in&lt;/span&gt; soup([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fram&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])])
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;在pyquery中的应用&lt;/h4&gt;
&lt;p&gt;  例如如果爬取到下面这段HTML代码，就可以通过CSS选择器去提取，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
html = &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div class=&quot;wrap&quot;&amp;gt;
    &amp;lt;div id=&quot;container&quot;&amp;gt;
        &amp;lt;ul class=&quot;list&quot;&amp;gt;
             &amp;lt;li class=&quot;item-0&quot;&amp;gt;first item&amp;lt;/li&amp;gt;
             &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
             &amp;lt;li class=&quot;item-0 active&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;&amp;lt;span class=&quot;bold&quot;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
             &amp;lt;li class=&quot;item-1 active&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
             &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;/ul&amp;gt;
     &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq
doc &lt;/span&gt;=&lt;span&gt; pq(html)
a &lt;/span&gt;= doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.item-0.active a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先获取class为item-0 且class为active的li标签内的a标签节点，再提取属性&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a, type(a))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a.attr(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取到的结果为链接路径： link3.html&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a.attr.href)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a.text())                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取文本，获得a节点的wb&lt;/span&gt;
li = doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.item-0.active&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(li.html())               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; html()返回该节点的所有文本，包括标签a的开始和结束&lt;/span&gt;
lt = doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(lt.html())               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只返回第一个li的文本，欲获取全部需要遍历&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(lt.text())               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回所有li的文本，用空格隔开，结果是字符串类型&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(lt.text()))
b &lt;/span&gt;= doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b, type(b))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(b.attr.href)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; attr（）方法只会得到第一个节点的属性，这时，需要遍历&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; b.items():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(item.attr.href)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3b29f225-3bb7-4a91-ab0f-0ec25da3e2c2')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3b29f225-3bb7-4a91-ab0f-0ec25da3e2c2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3b29f225-3bb7-4a91-ab0f-0ec25da3e2c2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3b29f225-3bb7-4a91-ab0f-0ec25da3e2c2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3b29f225-3bb7-4a91-ab0f-0ec25da3e2c2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
html = &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
&amp;lt;div id=&quot;container&quot;&amp;gt;
    &amp;lt;ul class=&quot;list&quot;&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;first item&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1&quot;&amp;gt;&amp;lt;a href=&quot;link2.html&quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-0 active&quot;&amp;gt;&amp;lt;a href=&quot;link3.html&quot;&amp;gt;&amp;lt;span class=&quot;bold&quot;&amp;gt;third item&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-1 active&quot;&amp;gt;&amp;lt;a href=&quot;link4.html&quot;&amp;gt;fourth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&quot;item-0&quot;&amp;gt;&amp;lt;a href=&quot;link5.html&quot;&amp;gt;fifth item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; pyquery &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyQuery as pq
doc &lt;/span&gt;=&lt;span&gt; pq(html)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#container .list li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#container .list li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)))
items &lt;/span&gt;= doc(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(items.text())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(items.text()))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(items)
lis &lt;/span&gt;= items.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(lis)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(items))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(lis))
ls &lt;/span&gt;= items.children()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回子节点&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(ls)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(type(ls))
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;JavaScript&lt;/h2&gt;
&lt;p&gt;  这里只说两点，ajax和渲染，因为爬虫经常碰到&lt;/p&gt;
&lt;h3&gt;渲染——浏览器如何显示页面&lt;/h3&gt;
&lt;p&gt;　　到目前为止，已经了解到浏览器在加载HTML的时候，先解析HTML文档，然后生成HTML树——DOM，同时浏览器生成了另外一棵树——CSSOM，这两个模型共同创建“渲染树”，之后浏览器就有了足够的信息去进行布局，并在屏幕上绘制页面。如果这里没有外部样式表也没有行内或者内部样式表（前面所述），也无需操心，因为浏览器本身也自带了一个默认的CSS样式表，只不过我们自定义的CSS样式表会将它覆盖而已。这里的“绘制的页面”就是要显示的页面，暂且理解成编程中的“print”吧，这里的一些奇怪的问题（比如：“浏览器显示HTML文档首尾标签去哪里啦？）”都可以类比print函数中的一些问题（“引号去哪里了？”）来看待，因为浏览器的显示和print函数是的目的都是将内容显示到电脑屏幕！只不过这里的绘制不是普通打印而是&lt;strong&gt;“彩打”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;渲染的过程如下（图片来自&lt;a title=&quot;这里&quot; href=&quot;https://baijiahao.baidu.com/s?id=1593097105869520145&amp;amp;wfr=spider&amp;amp;for=pc&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1418526/201811/1418526-20181125224310378-1064573937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　为什么渲染还和JavaScript有关呢？是的，单单是HTML和CSS就可以显示出网页，但JavaScript却有更强大的功能，其实JavaScript就是网页源代码中的一个脚本，他在浏览器显示页面的时候可以改变这个页面的布局和内容，也就是改变DOM和CSSOM的能力，从而改变了网页的显示。 &lt;/p&gt;
&lt;h3&gt;ajax&lt;/h3&gt;
&lt;p&gt;　　Ajax是一种无需刷新页面即可从服务器（或客户端）上加载数据的手段，这里的刷新是指重新请求，重新下载页面。而Ajax却可以在不刷新的情况下加载数据，从而给人一种“流畅”的感觉。但ajax只是其中的一种手段，例如上面提到的JavaScript渲染也是这样的一种手段。那么ajax是如何实现这种效果的呢？既然加载了数据那么肯定是向服务器发送了请求，那么如何做到不显示新的页面呢？答案是XMLHttpRequest（XHR）对象，它可以实现这种方式。既然是对象当然就有类似于“send()”等方法向服务器发送请求，然后接受到服务器响应的内容，接下来avaScript就会解释并处理这些内容，然后渲染网页，继而浏览器将数据显示出来。因此在爬虫的时候要想爬取这种动态加载的数据，就需要在开发者工具中去找寻这些新的URL请求，然后再在程序中模拟这种请求，再提取数据。就这样先吧。代码来自&lt;a title=&quot;W3C&quot; href=&quot;http://www.w3school.com.cn/tiy/t.asp?f=ajax_post&quot; target=&quot;_blank&quot;&gt;W3C&lt;/a&gt;如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; loadXMLDoc()
{
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; xmlhttp;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (window.XMLHttpRequest)
  {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; code for IE7+, Firefox, Chrome, Opera, Safari&lt;/span&gt;
&lt;span&gt;  xmlhttp&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
  }
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
  {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; code for IE6, IE5&lt;/span&gt;
&lt;span&gt;  xmlhttp&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ActiveXObject(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.XMLHTTP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  }
xmlhttp.onreadystatechange&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;()
  {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (xmlhttp.readyState&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt; xmlhttp.status&lt;/span&gt;&lt;span&gt;==&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;)
    {
    document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myDiv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).innerHTML&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;xmlhttp.responseText;
    }
  }
xmlhttp.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/ajax/demo_post.asp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
xmlhttp.send();
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;AJAX&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; onclick&lt;/span&gt;&lt;span&gt;=&quot;loadXMLDoc()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;请求数据&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;myDiv&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　周末结束了！以上。&lt;/p&gt;
</description>
<pubDate>Sun, 25 Nov 2018 15:42:00 +0000</pubDate>
<dc:creator>南宫恨</dc:creator>
<og:description>前言 爬虫要爬取的信息主要来自于网页加载的内容，有必要了解一些网页的知识。 当我们在浏览器网址栏输入一个网址——URL，经过TCP/IP协议簇的处理，这个网址请求的信息就被发送到URL对应的服务器，接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ydkh/p/10012790.html</dc:identifier>
</item>
<item>
<title>Dubbo 源码解析四 —— 负载均衡LoadBalance - 王守昌</title>
<link>http://www.cnblogs.com/wangshouchang/p/10018141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangshouchang/p/10018141.html</guid>
<description>&lt;p&gt;欢迎来我的 &lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo&quot;&gt;Star&lt;/a&gt; &lt;a href=&quot;https://github.com/wsccoder&quot;&gt;Followers&lt;/a&gt; 后期后继续更新Dubbo别的文章&lt;/p&gt;
&lt;h5 id=&quot;dubbo-源码分析系列之一环境搭建&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/wangshouchang/p/9694197.html&quot;&gt;Dubbo 源码分析系列之一环境搭建&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&quot;dubbo-入门之二---项目结构解析&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/wangshouchang/p/9800659.html&quot;&gt;Dubbo 入门之二 ——- 项目结构解析&lt;/a&gt;&lt;/h5&gt;
&lt;h5 id=&quot;dubbo-源码分析系列之三-架构原理&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/wangshouchang/p/9812757.html&quot;&gt;Dubbo 源码分析系列之三 —— 架构原理&lt;/a&gt;&lt;/h5&gt;
&lt;h2 id=&quot;技术点&quot;&gt;技术点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;面试中Dubbo负载均衡常问的几点&lt;/li&gt;
&lt;li&gt;常见负载均衡算法简介&lt;/li&gt;
&lt;li&gt;Dubbo 官方文档介绍&lt;/li&gt;
&lt;li&gt;Dubbo 负载均衡的策略&lt;/li&gt;
&lt;li&gt;Dubbo 负载均衡源码解析&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;面试中dubbo负载均衡常问的几点&quot;&gt;面试中Dubbo负载均衡常问的几点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;谈谈dubbo中的&lt;code&gt;负载均衡算法&lt;/code&gt;及特点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;最小活跃数&lt;/code&gt;算法中是如何统计这个活跃数的&lt;/li&gt;
&lt;li&gt;简单谈谈你对&lt;code&gt;一致性哈希算法&lt;/code&gt;的认识&lt;/li&gt;
&lt;li&gt;Dubbo默认的负载均衡策略是什么， 为什么使用 RandomLoadBalance 随机负载均衡算法&lt;/li&gt;
&lt;li&gt;谈谈几种负载均衡的优缺点&lt;/li&gt;
&lt;li&gt;如果让你设计负载均衡你将如何设计&lt;/li&gt;
&lt;li&gt;源码负载均衡你学到了什么&lt;/li&gt;
&lt;li&gt;有没有将Dubbo的负载均衡的原理使用在实际的项目中&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;常见负载均衡算法简介&quot;&gt;常见负载均衡算法简介&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;首先引出一点 负载均衡的目的是什么？&lt;/em&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;当一台服务器的承受能力达到上限时，那么就需要多台服务器来组成集群，提升应用整体的吞吐量，那么这个时候就涉及到如何合理分配客户端请求到集群中不同的机器，这个过程就叫做负载均衡&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;下面简单介绍几种负载均衡算法，有利于理解源码中为什么这样设计&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;权重随机算法&quot;&gt;权重随机算法&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;策略就是根据权重占比随机。算法很简单，就是一根数轴。然后利用伪随机数产生点，**看点落在了哪个区域从而选择对应的&lt;em&gt;服务器&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/6/3/163c5bfda5fe150f?imageslim&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;权重轮询算法&quot;&gt;权重轮询算法&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;轮询算法是指依次访问可用服务器列表，其和随机本质是一样的处理，在无权重因素下，轮询只是在选数轴上的点时采取自增对长度取余方式。有权重因素下依然自增取余，再看选取的点落在了哪个区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一致性hash负载均衡算法&quot;&gt;一致性Hash负载均衡算法&lt;/h3&gt;
&lt;p&gt;利用Hash算法定位相同的服务器&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;普通的Hash&lt;/strong&gt;：当客户端请求到达是则使用 hash(client) % N,其中N是服务器数量，利用这个表达式计算出该客户端对应的Server处理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致性Hash&lt;/strong&gt;：一致性Hash是把服务器分布变成一个环形，每一个hash(clinet)的结果会在该环上顺时针寻找第一个与其邻的&lt;code&gt;Server&lt;/code&gt;节点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://link.juejin.im/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34969168&quot;&gt;一致性Hash算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;—————————— 下面这部分是来源于dubbo 官方文档 ------------------------------------&lt;/p&gt;
&lt;h2 id=&quot;dubbo-官方文档介绍&quot;&gt;Dubbo 官方文档介绍&lt;/h2&gt;
&lt;h3 id=&quot;负载均衡&quot;&gt;负载均衡&lt;/h3&gt;
&lt;p&gt;在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 Random LoadBalance 随机调用&lt;/p&gt;
&lt;h3 id=&quot;负载均衡策略&quot;&gt;负载均衡策略&lt;/h3&gt;
&lt;h3 id=&quot;random-loadbalance&quot;&gt;Random LoadBalance&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;随机&lt;/strong&gt;，按权重设置随机概率。&lt;/li&gt;
&lt;li&gt;在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;roundrobin-loadbalance&quot;&gt;RoundRobin LoadBalance&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;轮询&lt;/strong&gt;，按公约后的权重设置轮询比率。&lt;/li&gt;
&lt;li&gt;存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;leastactive-loadbalance&quot;&gt;LeastActive LoadBalance&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;最少活跃调用数&lt;/strong&gt;，相同活跃数的随机，活跃数指调用前后计数差。&lt;/li&gt;
&lt;li&gt;使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;consistenthash-loadbalance&quot;&gt;ConsistentHash LoadBalance&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一致性 Hash&lt;/strong&gt;，相同参数的请求总是发到同一提供者。&lt;/li&gt;
&lt;li&gt;当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。&lt;/li&gt;
&lt;li&gt;算法参见：&lt;a href=&quot;http://en.wikipedia.org/wiki/Consistent_hashing&quot; class=&quot;uri&quot;&gt;http://en.wikipedia.org/wiki/Consistent_hashing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;缺省只对第一个参数 Hash，如果要修改，请配置 &lt;code&gt;&amp;lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;缺省用 160 份虚拟节点，如果要修改，请配置 &lt;code&gt;&amp;lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;h3 id=&quot;服务端服务级别&quot;&gt;服务端服务级别&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dubbo:service interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;客户端服务级别&quot;&gt;客户端服务级别&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dubbo:reference interface=&quot;...&quot; loadbalance=&quot;roundrobin&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;服务端方法级别&quot;&gt;服务端方法级别&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dubbo:service interface=&quot;...&quot;&amp;gt;
    &amp;lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&amp;gt;
&amp;lt;/dubbo:service&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;客户端方法级别&quot;&gt;客户端方法级别&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dubbo:reference interface=&quot;...&quot;&amp;gt;
    &amp;lt;dubbo:method name=&quot;...&quot; loadbalance=&quot;roundrobin&quot;/&amp;gt;
&amp;lt;/dubbo:reference&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;———————————————— Dubbo 官方文档已结束 ------------------------------------------&lt;/p&gt;
&lt;h2 id=&quot;dubbo-负载均衡的策略&quot;&gt;Dubbo 负载均衡的策略&lt;/h2&gt;
&lt;blockquote readability=&quot;3.2291666666667&quot;&gt;
&lt;p&gt;上面官网文档已经说明 Dubbo 的负载均衡算法总共有4种&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;我们先看下接口的继承图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1041678-2a60b5d43333fa71.png?imageMogr2/auto-orient/&quot; alt=&quot;类继承结构&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;loadbalance&quot;&gt;LoadBalance&lt;/h3&gt;
&lt;p&gt;首先查看 LoadBalance 接口&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Invoker select(List&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-config/dubbo-config-api/src/test/java/org/apache/dubbo/config/mock/MockLoadBalance.java&quot;&gt;LoadBalance&lt;/a&gt; 定义了一个方法就是从 invokers 列表中选取一个&lt;/p&gt;
&lt;h3 id=&quot;abstractloadbalance&quot;&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java&quot;&gt;AbstractLoadBalance&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/AbstractLoadBalance.java&quot;&gt;AbstractLoadBalance&lt;/a&gt; 抽象类是所有负载均衡策略实现类的父类，实现了LoadBalance接口 的方法，同时提供抽象方法交由子类实现，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; select(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) {
        if (invokers == null || invokers.size() == 0)
            return null;
        if (invokers.size() == 1)
            return invokers.get(0);
        return doSelect(invokers, url, invocation);
    }

    protected abstract &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doSelect(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;下面对四种均衡策略依次解析&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;randomloadbalance随机&quot;&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RandomLoadBalance.java&quot;&gt;RandomLoadBalance&lt;/a&gt;(随机)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;随机&lt;/strong&gt;，按权重设置随机概率。&lt;/li&gt;
&lt;li&gt;在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/RandomLoadBalance.java&quot;&gt;RandomLoadBalance#doSelect()&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doSelect(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) {
    //先获得invoker 集合大小
    int length = invokers.size(); // Number of invokers
    //总权重
    int totalWeight = 0; // The sum of weights
    //每个invoker是否有相同的权重
    boolean sameWeight = true; // Every invoker has the same weight?
    // 计算总权重
    for (int i = 0; i &amp;lt; length; i++) {
        //获得单个invoker 的权重
        int weight = getWeight(invokers.get(i), invocation);
        //累加
        totalWeight += weight; // Sum
        if (sameWeight &amp;amp;&amp;amp; i &amp;gt; 0 &amp;amp;&amp;amp; weight != getWeight(invokers.get(i - 1), invocation)) {
            sameWeight = false;
        }
    }
    // 权重不相等，随机后，判断在哪个 Invoker 的权重区间中
    if (totalWeight &amp;gt; 0 &amp;amp;&amp;amp; !sameWeight) {
        // 随机
        // If (not every invoker has the same weight &amp;amp; at least one invoker's weight&amp;gt;0), select randomly based on totalWeight.
        int offset = ThreadLocalRandom.current().nextInt(totalWeight);
        // 区间判断
        // Return a invoker based on the random value.
        for (int i = 0; i &amp;lt; length; i++) {
            offset -= getWeight(invokers.get(i), invocation);
            if (offset &amp;lt; 0) {
                return invokers.get(i);
            }
        }
    }
    // 权重相等，平均随机
    // If all invokers have the same weight value or totalWeight=0, return evenly.
    return invokers.get(ThreadLocalRandom.current().nextInt(length));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;算法分析&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;假定有3台dubbo provider:&lt;br/&gt;10.0.0.1:20884, weight=2&lt;br/&gt;10.0.0.1:20886, weight=3&lt;br/&gt;10.0.0.1:20888, weight=4&lt;br/&gt;随机算法的实现：&lt;br/&gt;totalWeight=9;&lt;br/&gt;假设offset=1（即random.nextInt(9)=1）&lt;br/&gt;1-2=-1&amp;lt;0？是，所以选中 10.0.0.1:20884, weight=2&lt;/p&gt;
&lt;p&gt;假设offset=4（即random.nextInt(9)=4）&lt;br/&gt;4-2=2&amp;lt;0？否，这时候offset=2， 2-3&amp;lt;0？是，所以选中 10.0.0.1:20886, weight=3&lt;/p&gt;
&lt;p&gt;假设offset=7（即random.nextInt(9)=7）&lt;br/&gt;7-2=5&amp;lt;0？否，这时候offset=5， 5-3=2&amp;lt;0？否，这时候offset=2， 2-4&amp;lt;0？是，所以选中 10.0.0.1:20888, weight=4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;流程图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1041678-d69d4e6bb1acf146.png?imageMogr2/auto-orient/&quot; alt=&quot;流程图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/test/java/org/apache/dubbo/rpc/cluster/loadbalance/RoundRobinLoadBalanceTest.java&quot;&gt;RoundRobinLoadBalance#doSelect()(轮询)&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;轮询&lt;/strong&gt;，按公约后的权重设置轮询比率。&lt;/li&gt;
&lt;li&gt;存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doSelect(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) {
    String key = invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();
    int length = invokers.size(); // Number of invokers
    int maxWeight = 0; // The maximum weight
    int minWeight = Integer.MAX_VALUE; // The minimum weight
    final LinkedHashMap&amp;lt;Invoker&amp;lt;T&amp;gt;, IntegerWrapper&amp;gt; invokerToWeightMap = new LinkedHashMap&amp;lt;Invoker&amp;lt;T&amp;gt;, IntegerWrapper&amp;gt;();
    int weightSum = 0;
    // 计算最小、最大权重，总的权重和。
    for (int i = 0; i &amp;lt; length; i++) {
        int weight = getWeight(invokers.get(i), invocation);
        maxWeight = Math.max(maxWeight, weight); // Choose the maximum weight
        minWeight = Math.min(minWeight, weight); // Choose the minimum weight
        if (weight &amp;gt; 0) {
            invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));
            weightSum += weight;
        }
    }
    // 计算最小、最大权重，总的权重和。
    AtomicPositiveInteger sequence = sequences.get(key);
    if (sequence == null) {
        sequences.putIfAbsent(key, new AtomicPositiveInteger());
        sequence = sequences.get(key);
    }
    // 获得当前顺序号，并递增 + 1
    int currentSequence = sequence.getAndIncrement();
    // 权重不相等，顺序根据权重分配
    if (maxWeight &amp;gt; 0 &amp;amp;&amp;amp; minWeight &amp;lt; maxWeight) {
        int mod = currentSequence % weightSum;// 剩余权重
        for (int i = 0; i &amp;lt; maxWeight; i++) {// 循环最大权重
            for (Map.Entry&amp;lt;Invoker&amp;lt;T&amp;gt;, IntegerWrapper&amp;gt; each : invokerToWeightMap.entrySet()) {
                final Invoker&amp;lt;T&amp;gt; k = each.getKey();
                final IntegerWrapper v = each.getValue();
                // 剩余权重归 0 ，当前 Invoker 还有剩余权重，返回该 Invoker 对象
                if (mod == 0 &amp;amp;&amp;amp; v.getValue() &amp;gt; 0) {
                    return k;
                }
                // 若 Invoker 还有权重值，扣除它( value )和剩余权重( mod )。
                if (v.getValue() &amp;gt; 0) {
                    v.decrement();
                    mod--;
                }
            }
        }
    }
    // 权重相等，平均顺序获得
    // Round robin
    return invokers.get(currentSequence % length);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;算法说明&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;假定有3台权重都一样的dubbo provider:&lt;br/&gt;10.0.0.1:20884, weight=100&lt;br/&gt;10.0.0.1:20886, weight=100&lt;br/&gt;10.0.0.1:20888, weight=100&lt;br/&gt;轮询算法的实现：&lt;br/&gt;其调用方法某个方法(key)的sequence从0开始：&lt;br/&gt;sequence=0时，选择invokers.get(0%3)=10.0.0.1:20884&lt;br/&gt;sequence=1时，选择invokers.get(1%3)=10.0.0.1:20886&lt;br/&gt;sequence=2时，选择invokers.get(2%3)=10.0.0.1:20888&lt;br/&gt;sequence=3时，选择invokers.get(3%3)=10.0.0.1:20884&lt;br/&gt;sequence=4时，选择invokers.get(4%3)=10.0.0.1:20886&lt;br/&gt;sequence=5时，选择invokers.get(5%3)=10.0.0.1:20888&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;leastactiveloadbalance最少活跃数&quot;&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java&quot;&gt;LeastActiveLoadBalance&lt;/a&gt;(最少活跃数)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;最少活跃调用数&lt;/strong&gt;，相同活跃数的随机，活跃数指调用前后计数差。&lt;/li&gt;
&lt;li&gt;使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doSelect(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) {
    // 总个数
    int length = invokers.size(); // Number of invokers
    // 最少的活跃数
    int leastActive = -1; // The least active value of all invokers
    // 相同最小活跃数的个数
    int leastCount = 0; // The number of invokers having the same least active value (leastActive)
    // 相同最小活跃数的下标
    int[] leastIndexs = new int[length]; // The index of invokers having the same least active value (leastActive)
    //总权重
    int totalWeight = 0; // The sum of weights
    // 第一个权重，用于于计算是否相同
    int firstWeight = 0; // Initial value, used for comparision
    // 是否所有权重相同
    boolean sameWeight = true; // Every invoker has the same weight value?
    // 计算获得相同最小活跃数的数组和个数
    for (int i = 0; i &amp;lt; length; i++) {
        Invoker&amp;lt;T&amp;gt; invoker = invokers.get(i);
        // 活跃数
        int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); // Active number
        // 权重
        int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); // Weight
        // 发现更小的活跃数，重新开始
        if (leastActive == -1 || active &amp;lt; leastActive) { // Restart, when find a invoker having smaller least active value.
            // 记录最小活跃数
            leastActive = active; // Record the current least active value
            // 重新统计相同最小活跃数的个数
            leastCount = 1; // Reset leastCount, count again based on current leastCount
            // 重新记录最小活跃数下标
            leastIndexs[0] = i; // Reset
            // 重新统计总权重
            totalWeight = weight; // Reset
            // 记录第一个权重
            firstWeight = weight; // Record the weight the first invoker
            // 还原权重标识
            sameWeight = true; // Reset, every invoker has the same weight value?
        // 累计相同最小的活跃数
        } else if (active == leastActive) { // If current invoker's active value equals with leaseActive, then accumulating.
            // 累计相同最小活跃数下标
            leastIndexs[leastCount++] = i; // Record index number of this invoker
            // 累计总权重
            totalWeight += weight; // Add this invoker's weight to totalWeight.
            // 判断所有权重是否一样
            // If every invoker has the same weight?
            if (sameWeight &amp;amp;&amp;amp; i &amp;gt; 0
                    &amp;amp;&amp;amp; weight != firstWeight) {
                sameWeight = false;
            }
        }
    }
    // assert(leastCount &amp;gt; 0)
    if (leastCount == 1) {
        // 如果只有一个最小则直接返回
        // If we got exactly one invoker having the least active value, return this invoker directly.
        return invokers.get(leastIndexs[0]);
    }
    if (!sameWeight &amp;amp;&amp;amp; totalWeight &amp;gt; 0) {
        // 如果权重不相同且权重大于0则按总权重数随机
        // If (not every invoker has the same weight &amp;amp; at least one invoker's weight&amp;gt;0), select randomly based on totalWeight.
        int offsetWeight = ThreadLocalRandom.current().nextInt(totalWeight);
        // 并确定随机值落在哪个片断上
        // Return a invoker based on the random value.
        for (int i = 0; i &amp;lt; leastCount; i++) {
            int leastIndex = leastIndexs[i];
            offsetWeight -= getWeight(invokers.get(leastIndex), invocation);
            if (offsetWeight &amp;lt;= 0)
                return invokers.get(leastIndex);
        }
    }
    // 如果权重相同或权重为0则均等随机
    // If all invokers have the same weight value or totalWeight=0, return evenly.
    return invokers.get(leastIndexs[ThreadLocalRandom.current().nextInt(leastCount)]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单思路介绍&lt;/p&gt;
&lt;p&gt;概括起来就两部分,一部分是&lt;code&gt;活跃数&lt;/code&gt;和&lt;code&gt;权重&lt;/code&gt;的统计,另一部分是选择&lt;code&gt;invoker&lt;/code&gt;.也就是他把最小活跃数的&lt;code&gt;invoker&lt;/code&gt;统计到&lt;code&gt;leastIndexs&lt;/code&gt;数组中,如果权重一致(这个一致的规则参考上面的随机算法)或者总权重为0,则均等随机调用,如果不同,则从&lt;code&gt;leastIndexs&lt;/code&gt;数组中按照权重比例调用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法说明&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;最小活跃数算法实现：&lt;br/&gt;假定有3台dubbo provider:&lt;br/&gt;10.0.0.1:20884, weight=2，active=2&lt;br/&gt;10.0.0.1:20886, weight=3，active=4&lt;br/&gt;10.0.0.1:20888, weight=4，active=3&lt;br/&gt;active=2最小，且只有一个2，所以选择10.0.0.1:20884&lt;/p&gt;
&lt;p&gt;假定有3台dubbo provider:&lt;br/&gt;10.0.0.1:20884, weight=2，active=2&lt;br/&gt;10.0.0.1:20886, weight=3，active=2&lt;br/&gt;10.0.0.1:20888, weight=4，active=3&lt;br/&gt;active=2最小，且有2个，所以从[10.0.0.1:20884,10.0.0.1:20886 ]中选择；&lt;br/&gt;接下来的算法与随机算法类似：&lt;br/&gt;假设offset=1（即random.nextInt(5)=1）&lt;br/&gt;1-2=-1&amp;lt;0？是，所以选中 10.0.0.1:20884, weight=2&lt;br/&gt;假设offset=4（即random.nextInt(5)=4）&lt;br/&gt;4-2=2&amp;lt;0？否，这时候offset=2， 2-3&amp;lt;0？是，所以选中 10.0.0.1:20886, weight=3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;流程图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1041678-974214615c58dce8.png?imageMogr2/auto-orient/&quot; alt=&quot;流程图&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;consistenthashloadbalance一致性哈希&quot;&gt;&lt;a href=&quot;https://github.com/wsccoder/incubator-dubbo/blob/master/dubbo-cluster/src/main/java/org/apache/dubbo/rpc/cluster/loadbalance/LeastActiveLoadBalance.java&quot;&gt;ConsistentHashLoadBalance&lt;/a&gt;(一致性哈希)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一致性 Hash&lt;/strong&gt;，相同参数的请求总是发到同一提供者。&lt;/li&gt;
&lt;li&gt;当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;源码其实分为四个步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义全局一致性hash选择器的&lt;code&gt;ConcurrentMap&amp;lt;String, ConsistentHashSelector&amp;lt;?&amp;gt;&amp;gt; selectors&lt;/code&gt;，key为方法名称，例如com.alibaba.dubbo.demo.TestService.getRandomNumber&lt;/li&gt;
&lt;li&gt;如果一致性hash选择器不存在或者与以前保存的一致性hash选择器不一样（即dubbo服务provider有变化，通过System.identityHashCode(invokers)计算一个identityHashCode值） 则需要重新构造一个一致性hash选择器&lt;/li&gt;
&lt;li&gt;构造一个一致性hash选择器ConsistentHashSelector的源码如下，通过参数i和h打散Invoker在TreeMap上的位置，replicaNumber默认值为160，所以最终virtualInvokers这个TreeMap的size为&lt;code&gt;invokers.size()*replicaNumber&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选择Invoker的步骤
&lt;ol&gt;&lt;li&gt;根据Invocation中的参数invocation.getArguments()转成key&lt;/li&gt;
&lt;li&gt;算出这个key的md5值&lt;/li&gt;
&lt;li&gt;根据md5值的hash值从TreeMap中选择一个Invoker&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;下面源码解析+注释&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ConsistentHashLoadBalance extends AbstractLoadBalance {
    public static final String NAME = &quot;consistenthash&quot;;

    /**
     * 服务方法与一致性哈希选择器的映射
     *
     * KEY：serviceKey + &quot;.&quot; + methodName
     */
    private final ConcurrentMap&amp;lt;String, ConsistentHashSelector&amp;lt;?&amp;gt;&amp;gt; selectors = new ConcurrentHashMap&amp;lt;String, ConsistentHashSelector&amp;lt;?&amp;gt;&amp;gt;();

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    protected &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; doSelect(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, URL url, Invocation invocation) {
        String methodName = RpcUtils.getMethodName(invocation);
        // 基于 invokers 集合，根据对象内存地址来计算定义哈希值
        String key = invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + methodName;
        int identityHashCode = System.identityHashCode(invokers);
        // 获得 ConsistentHashSelector 对象。若为空，或者定义哈希值变更（说明 invokers 集合发生变化），
        // 进行创建新的 ConsistentHashSelector 对象
        ConsistentHashSelector&amp;lt;T&amp;gt; selector = (ConsistentHashSelector&amp;lt;T&amp;gt;) selectors.get(key);
        if (selector == null || selector.identityHashCode != identityHashCode) {
            selectors.put(key, new ConsistentHashSelector&amp;lt;T&amp;gt;(invokers, methodName, identityHashCode));
            selector = (ConsistentHashSelector&amp;lt;T&amp;gt;) selectors.get(key);
        }
        return selector.select(invocation);
    }

    private static final class ConsistentHashSelector&amp;lt;T&amp;gt; {

        /**
         * 虚拟节点与 Invoker 的映射关系
         */
        private final TreeMap&amp;lt;Long, Invoker&amp;lt;T&amp;gt;&amp;gt; virtualInvokers;

        /**
         * 每个Invoker 对应的虚拟节点数
         */
        private final int replicaNumber;

        /**
         * 定义哈希值
         */
        private final int identityHashCode;

        /**
         * 取值参数位置数组
         */
        private final int[] argumentIndex;

        ConsistentHashSelector(List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers, String methodName, int identityHashCode) {
            this.virtualInvokers = new TreeMap&amp;lt;Long, Invoker&amp;lt;T&amp;gt;&amp;gt;();
            // 设置 identityHashCode
            this.identityHashCode = identityHashCode;
            URL url = invokers.get(0).getUrl();
            // 初始化 replicaNumber
            this.replicaNumber = url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);
            // 初始化 argumentIndex
            String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));
            argumentIndex = new int[index.length];
            for (int i = 0; i &amp;lt; index.length; i++) {
                argumentIndex[i] = Integer.parseInt(index[i]);
            }
            // 初始化 virtualInvokers
            for (Invoker&amp;lt;T&amp;gt; invoker : invokers) {
                String address = invoker.getUrl().getAddress();
                // 每四个虚拟结点为一组，为什么这样？下面会说到
                for (int i = 0; i &amp;lt; replicaNumber / 4; i++) {
                    // 这组虚拟结点得到惟一名称
                    byte[] digest = md5(address + i);
                    // Md5是一个16字节长度的数组，将16字节的数组每四个字节一组，
                    // 分别对应一个虚拟结点，这就是为什么上面把虚拟结点四个划分一组的原因
                    for (int h = 0; h &amp;lt; 4; h++) {
                        // 对于每四个字节，组成一个long值数值，做为这个虚拟节点的在环中的惟一key
                        long m = hash(digest, h);
                        virtualInvokers.put(m, invoker);
                    }
                }
            }
        }

        public Invoker&amp;lt;T&amp;gt; select(Invocation invocation) {
            // 基于方法参数，获得 KEY
            String key = toKey(invocation.getArguments());
            // 计算 MD5 值
            byte[] digest = md5(key);
            // 计算 KEY 值
            return selectForKey(hash(digest, 0));
        }

        /**
         * 基于方法参数，获得 KEY
         * @param args
         * @return
         */
        private String toKey(Object[] args) {
            StringBuilder buf = new StringBuilder();
            for (int i : argumentIndex) {
                if (i &amp;gt;= 0 &amp;amp;&amp;amp; i &amp;lt; args.length) {
                    buf.append(args[i]);
                }
            }
            return buf.toString();
        }

        /**
         * 选一个 Invoker 对象
         * @param hash
         * @return
         */
        private Invoker&amp;lt;T&amp;gt; selectForKey(long hash) {
            // 得到大于当前 key 的那个子 Map ，然后从中取出第一个 key ，就是大于且离它最近的那个 key
            Map.Entry&amp;lt;Long, Invoker&amp;lt;T&amp;gt;&amp;gt; entry = virtualInvokers.ceilingEntry(hash);
            // 不存在，则取 virtualInvokers 第一个
            if (entry == null) {
                entry = virtualInvokers.firstEntry();
            }
            // 存在，则返回
            return entry.getValue();
        }

        /**
         * 对于每四个字节，组成一个 Long 值数值，做为这个虚拟节点的在环中的惟一 KEY
         * @param digest
         * @param number
         * @return
         */
        private long hash(byte[] digest, int number) {
            return (((long) (digest[3 + number * 4] &amp;amp; 0xFF) &amp;lt;&amp;lt; 24)
                    | ((long) (digest[2 + number * 4] &amp;amp; 0xFF) &amp;lt;&amp;lt; 16)
                    | ((long) (digest[1 + number * 4] &amp;amp; 0xFF) &amp;lt;&amp;lt; 8)
                    | (digest[number * 4] &amp;amp; 0xFF))
                    &amp;amp; 0xFFFFFFFFL;
        }

        /**
         * MD5 是一个 16 字节长度的数组，将 16 字节的数组每四个字节一组，
         * 分别对应一个虚拟结点，这就是为什么上面把虚拟结点四个划分一组的原因
         * @param value
         * @return
         */
        private byte[] md5(String value) {
            MessageDigest md5;
            try {
                md5 = MessageDigest.getInstance(&quot;MD5&quot;);
            } catch (NoSuchAlgorithmException e) {
                throw new IllegalStateException(e.getMessage(), e);
            }
            md5.reset();
            byte[] bytes;
            try {
                bytes = value.getBytes(&quot;UTF-8&quot;);
            } catch (UnsupportedEncodingException e) {
                throw new IllegalStateException(e.getMessage(), e);
            }
            md5.update(bytes);
            return md5.digest();
        }

    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一致性哈希算法的三个关键点 &lt;strong&gt;原理&lt;/strong&gt;， &lt;strong&gt;down机影响面&lt;/strong&gt;， &lt;strong&gt;虚拟节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lihao21/article/details/54193868&quot;&gt;一致性Hash(Consistent Hashing)原理剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;down 机影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在某个节点挂机的时候，会根据虚拟节点选择下一个节点。只影响到一个节点，其他的节点不受到影响&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虚拟节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据一致性Hash算法将生成很多的虚拟节点，这些节点落在圆环中。当某个节点down掉，则压力会给到指定的虚拟节点&lt;/p&gt;
&lt;blockquote readability=&quot;1.0384615384615&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/entry/5b13e712e51d4506da5a039b&quot;&gt;常见负载均衡算法分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dubbo.incubator.apache.org/zh-cn/docs/user/demos/loadbalance.html&quot;&gt;Dubbo 官方文档 负载均衡&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/10c30d7b8b6a&quot;&gt;阿飞的博客 14.dubbo源码-负载均衡&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/53feb7f5f5d9&quot;&gt;dubbo源码解析-LoadBalance&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/javanoob/p/dubbo_loadbalance.html&quot;&gt;Dubbo 负载均衡策略与实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://svip.iocoder.cn/Dubbo/cluster-4-impl-loadbalance/&quot;&gt;精尽 Dubbo 源码解析 —— 集群容错（四）之 LoadBalance 实现&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 25 Nov 2018 15:33:00 +0000</pubDate>
<dc:creator>王守昌</dc:creator>
<og:description>欢迎来我的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangshouchang/p/10018141.html</dc:identifier>
</item>
<item>
<title>初步接触 Java Net 网络编程 - czwbig</title>
<link>http://www.cnblogs.com/czwbig/p/10018118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/czwbig/p/10018118.html</guid>
<description>&lt;p&gt;本文目的是大概了解 Java 网络编程体系，需要一点点 Java IO 基础，推荐教程 &lt;a href=&quot;https://www.cnblogs.com/czwbig/p/10007201.html&quot;&gt;系统学习 Java IO&lt;/a&gt;。主要参考 JavaDoc 和 Jakob Jenkov 的英文教程《Java Networking》 &lt;a href=&quot;http://tutorials.jenkov.com/java-networking/index.html&quot; class=&quot;uri&quot;&gt;http://tutorials.jenkov.com/java-networking/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-网络编程概览&quot;&gt;Java 网络编程概览&lt;/h2&gt;
&lt;p&gt;Java 有一个相当容易使用的内置网络 API，可以很容易地通过互联网上的 TCP / IP 套接字或 UDP 套接字进行通信。 TCP 通常比 UDP 使用得更频繁。&lt;/p&gt;
&lt;p&gt;即使 Java Networking API 允许通过套接字打开和关闭网络连接，但所有通信都通过 Java IO 类 InputStream 和 OutputStream 实现的。&lt;br/&gt;或者，我们可以使用 Java NIO API 中的网络类。 用法类似于 Java Networking API 中的类，但 Java NIO API 可以在非阻塞模式下工作。 在某些情况下，非阻塞模式可提升性能。&lt;/p&gt;
&lt;h5 id=&quot;java-tcp-网络基础&quot;&gt;Java TCP 网络基础&lt;/h5&gt;
&lt;p&gt;通常，客户端会打开与服务器的 TCP / IP 连接，然后开始与服务器通信，当通信结束后客户端关闭连接。如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181125113944385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N6d2JpZw==,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端可以通过一个已打开的连接发送多个请求，实际上，客户端可以向服务器发送尽可能多的数据。 当然，如果需要，服务器也可以关闭连接。&lt;/p&gt;
&lt;h5 id=&quot;java-中-socket-类和-serversocket-类&quot;&gt;Java 中 Socket 类和 ServerSocket 类&lt;/h5&gt;
&lt;p&gt;当客户端想要打开到服务器的 TCP / IP 连接时，它使用 Java Socket 类来实现。 套接字被告知连接到哪个 IP 地址和 TCP 端口，其余部分由 Java 完成。&lt;/p&gt;
&lt;p&gt;如果要启动服务器以侦听来自某个 TCP 端口上的客户端的传入连接，则必须使用 Java ServerSocket 类。 当客户端通过客户端套接字连接到服务器的 ServerSocket 时，服务器上会为该连接分配一个 Socket 。 客户端和服务器的通信就是 Socket 到 Socket 的通信了。&lt;/p&gt;
&lt;p&gt;Socket和ServerSocket在后面的文本中有更详细的介绍。&lt;/p&gt;
&lt;h5 id=&quot;java-udp-网络基础&quot;&gt;Java UDP 网络基础&lt;/h5&gt;
&lt;p&gt;UDP 的工作方式与 TCP 略有不同。 使用 UDP ，客户端和服务器之间没有连接。 客户端可以向服务器发送数据，并且服务器可以（或可以不）接收该数据。 客户端永远不会知道数据是否在另一端收到。 从服务器到客户端发送的数据也是如此。&lt;br/&gt;由于无法保证数据传输，因此 UDP 协议的协议开销较小。&lt;/p&gt;
&lt;p&gt;在一些情况下，无连接 UDP 模型优于 TCP ，比如传输视频等多媒体文件，缺少一些数据是不影响观看的。&lt;/p&gt;
&lt;h2 id=&quot;tcp-socket套接字&quot;&gt;TCP Socket（套接字）&lt;/h2&gt;
&lt;p&gt;为了通过 Internet 连接到服务器（通过TCP / IP），需要创建一个 Socket 并将其连接到服务器。 或者，如果您更喜欢使用 Java NIO ，则可以使用 Java NIO SocketChannel 。&lt;/p&gt;
&lt;h5 id=&quot;创建一个socket&quot;&gt;创建一个Socket&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Socket socket = new Socket(&quot;baidu.com&quot;, 80);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个参数是地址，可以是 ip 或者域名字符串，第二个参数是端口，端口80是Web服务器端口。&lt;/p&gt;
&lt;h5 id=&quot;写入-socket&quot;&gt;写入 Socket&lt;/h5&gt;
&lt;p&gt;要写入 Socket，必须获取其 OutputStream ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Socket socket = new Socket(&quot;baidu.com&quot;, 80);
OutputStream outputStream = socket.getOutputStream();

outputStream.write(&quot;some data&quot;.getBytes());
outputStream.flush();
outputStream.close();

socket.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当真的希望通过互联网向服务器发送数据时，不要忘记调用 flush() 。操作系统中的底层 TCP / IP 实现会先缓冲数据，缓冲块的大小是与 TCP ​​/ IP 数据包的大小相适应的，这就是说，调用 flush() 只是通知系统发送，但系统并不是立即就帮忙发出去。&lt;/p&gt;
&lt;h5 id=&quot;从-socket-读取&quot;&gt;从 Socket 读取&lt;/h5&gt;
&lt;p&gt;要从 Socket 读取，需要获取其 InputStream ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Socket socket = new Socket(&quot;baidu.com&quot;, 80);
InputStream in = socket.getInputStream();

int data = in.read();
//... read more data...

in.close();
socket.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;记住，在读取时我们不能使用读取 InputStream 返回 -1 来判断数据读取结束 ，因为只有在服务器关闭连接时才返回 -1 。 但是服务器可能并不总是关闭连接，比如通过同一连接发送多个请求。 在这种情况下，关闭连接将是非常愚蠢的。&lt;/p&gt;
&lt;p&gt;相反，必须知道从 Socket 的 InputStream 中读取多少字节。 服务器会告知 Socket 它发送的字节数，或者通过查找特殊的数据结束字符来完成。&lt;/p&gt;
&lt;p&gt;使用 Socket 后，必须关闭它以关闭与服务器的连接，这可以通过调用 Socket 对象的 close() 方法完成。&lt;/p&gt;
&lt;h2 id=&quot;serversocket&quot;&gt;ServerSocket&lt;/h2&gt;
&lt;p&gt;可以使用 ServerSocket 来实现 Java 服务器，这样就可以通过 TCP / IP 侦听来自客户端的传入连接。如果更喜欢使用 Java NIO 而不是 Java Networking（标准API），那么也可以使用 ServerSocketChannel 。&lt;/p&gt;
&lt;h5 id=&quot;创建一个-serversocket&quot;&gt;创建一个 ServerSocket&lt;/h5&gt;
&lt;p&gt;这是一个简单的代码示例，它创建一个侦听端口 9000 的 ServerSocket：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ServerSocket serverSocket = new ServerSocket(9000);&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;监听传入的连接&quot;&gt;监听传入的连接&lt;/h5&gt;
&lt;p&gt;要接受传入连接，必须调用 ServerSocket.accept() 方法。 accept() 方法返回一个 Socket ，其行为类似于普通的 Socket ，示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ServerSocket serverSocket = new ServerSocket(9000);
boolean isStopped = false;
while(!isStopped){
    Socket clientSocket = serverSocket.accept();
    //do something with clientSocket
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次调用 accept() 方法时只打开一个传入连接。&lt;br/&gt;此外，只有在运行服务器的线程调用 accept() 时才能接受传入连接。 线程在此方法之外执行的所有时间都没有客户端可以连接。 因此，“accept”线程通常将传入连接（Socket）传递给工作线程池，然后工作线程与客户端进行通信。 有关多线程服务器设计的更多信息，请参阅教程跟踪 Java 多线程服务器。&lt;/p&gt;
&lt;h5 id=&quot;关闭客户端-sockets&quot;&gt;关闭客户端 Sockets&lt;/h5&gt;
&lt;p&gt;一旦客户端请求完成，并且不会从该客户端收到进一步的请求，必须关闭该Socket，就像关闭普通客户端Socket一样。调用：&lt;code&gt;socket.close();&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;关闭服务端-sockets&quot;&gt;关闭服务端 Sockets&lt;/h5&gt;
&lt;p&gt;一旦服务器关闭，就需要关闭 ServerSocket 。 调用：&lt;code&gt;serverSocket.close();&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;udp-datagramsocketudp数据报套接字&quot;&gt;UDP DatagramSocket（UDP数据报套接字）&lt;/h2&gt;
&lt;p&gt;DatagramSocket 是 Java 通过 UDP 而不是 TCP 进行网络通信的机制。 UDP 也是 IP 协议的上层。 可以使用 DatagramSocket 来发送和接收 UPD 数据报。&lt;/p&gt;
&lt;h5 id=&quot;udp-对比-tcp&quot;&gt;UDP 对比 TCP&lt;/h5&gt;
&lt;p&gt;通过 TCP 发送数据时，首先要创建连接。 建立 TCP 连接后，TCP 保证数据到达另一端，或者它会告诉你发生了错误。&lt;/p&gt;
&lt;p&gt;使用 UDP，只需将数据包（数据报）发送到网络上的某个 IP 地址。 无法保证数据会到达，也无法保证 UDP 数据包到达的顺序。 这意味着 UDP 比 TCP 具有更少的协议开销（没有流完整性检查）。&lt;/p&gt;
&lt;p&gt;UDP 适用于数据传输，如果数据包在转换过程中丢失则无关紧要。 例如，想象一下通过互联网传输直播电视信号，如果一两帧丢失，这是无关紧要的。我们更不希望直播延迟只是为了确保所有帧都显示出来。 宁愿跳过错过的帧，并直接查看最新的帧。&lt;/p&gt;
&lt;p&gt;还有实时监控视频，宁愿丢失一两帧，也不想延迟于现实 30 秒。与摄像机录像的存储有点不同，将图像从相机录制到磁盘时, 为了保证完整性，可能不希望丢失单帧，而是更愿意稍微延迟。&lt;/p&gt;
&lt;h5 id=&quot;datagrampacket-类&quot;&gt;DatagramPacket 类&lt;/h5&gt;
&lt;p&gt;此类表示数据报包。数据报包用来实现无连接包投递服务。&lt;/p&gt;
&lt;blockquote readability=&quot;7.4515050167224&quot;&gt;
&lt;p&gt;Java 使用 DatagramSocket 代表 UDP 协议的 Socket ，DatagramSocket 本身只是码头，不维护状态，不能产生IO流，它的唯一作用就是接收和发送数据报，使用 DatagramPacket 来代表数据报，DatagramSocket 接收和发送的数据都是通过 DatagramPacket 对象完成的。&lt;br/&gt;每条报文仅根据该包中包含的信息从一台机器路由到另一台机器。从一台机器发送到另一台机器的多个包可能选择不同的路由，也可能按不同的顺序到达。不对包投递做出保证。&lt;br/&gt;引用自 &lt;a href=&quot;http://book.51cto.com/art/201203/322540.htm&quot;&gt;李刚《疯狂Java讲义（第2版）》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其所有构造器如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;DatagramPacket(byte[] buf, int length)&lt;/td&gt;
&lt;td&gt;构造 DatagramPacket，用来接收长度为 length 的数据包。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;DatagramPacket(byte[] buf, int length, InetAddress address, int port)&lt;/td&gt;
&lt;td&gt;构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;DatagramPacket(byte[] buf, int length, SocketAddress address)&lt;/td&gt;
&lt;td&gt;构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;以上3个在 byte[] buf 参数后面追加 int offset&lt;/td&gt;
&lt;td&gt;为长度为 length 的包设置偏移量为 offset&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;InetAddress 类表示互联网协议 (IP) 地址，可以通过静态方法 getByName(String host) 获得其对象。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;SocketAddress 类里面什么都没有。其子类 InetSocketAddress是(IP地址+端口号)类型，也就是端口地址类型，同样可以使用静态方法 createUnresolved(String host, int port) 获取对象，另外也能由构造函数 InetSocketAddress(InetAddress addr, int port) 创建，其中 InetAddress 对象可省略，也可用字符串代替。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;通过-datagramsocket-发送数据datagrampacket&quot;&gt;通过 DatagramSocket 发送数据（DatagramPacket ）&lt;/h5&gt;
&lt;p&gt;要通过 DatagramSocket 发送数据，必须首先创建一个 DatagramPacket ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;byte[] buffer = new byte[65508];
InetAddress address = InetAddress.getByName(&quot;baidu.com&quot;);

DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 9000);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字节缓冲区（字节数组）是要在 UDP 数据报中发送的数据。 上述缓冲区的长度（65508字节）是可以在单个 UDP 数据包中发送的最大数据量。&lt;/p&gt;
&lt;p&gt;DatagramPacket 构造函数中的 buffer.length 是要发送的缓冲区中数据的长度，忽略该数据量之后缓冲区中的所有数据。&lt;/p&gt;
&lt;p&gt;InetAddress 实例包含发送 UDP 数据包的节点（例如服务器）的地址。 InetAddress 类表示 IP 地址（Internet地址）。 getByName() 方法返回一个 InetAddress 实例，其 IP 地址与给定的主机名匹配。&lt;/p&gt;
&lt;p&gt;port 参数是服务器接收数据正在侦听的 UDP 端口，UDP 和 TCP 端口是不一样的。同一台计算机可以有不同的线程同时监听 UDP 的 80 端口和 TCP 中的 80 端口。不同协议下，端口号互不干扰，端口只是应用程序的标识。&lt;/p&gt;
&lt;p&gt;创建一个 DatagramSocket ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;DatagramSocket datagramSocket = new DatagramSocket();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要发送数据，请调用 send() 方法，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;datagramSocket.send(packet);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个完整的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public class DatagramExample {
    public static void main(String[] args) throws Exception {
        DatagramSocket datagramSocket = new DatagramSocket();

        byte[] buffer = &quot;123456789&quot;.getBytes();
        InetAddress receiverAddress = InetAddress.getLocalHost();

        DatagramPacket packet = new DatagramPacket(buffer, buffer.length, receiverAddress, 80);
        datagramSocket.send(packet);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;通过-datagramsocket-接收数据-datagrampacket&quot;&gt;通过 DatagramSocket 接收数据 （DatagramPacket ）&lt;/h5&gt;
&lt;p&gt;通过 DatagramSocket 接收数据是通过首先创建 DatagramPacket 然后通过 DatagramSocket 的 receive() 方法接收数据来完成的。 这是一个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;DatagramSocket socket = new DatagramSocket(80);
byte[] buffer = new byte[10];
DatagramPacket packet = new DatagramPacket(buffer, buffer.length);

socket.receive(packet);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用传递给构造函数的参数值 80 来实例化 DatagramSocket , 此参数是 DatagramSocket 接收 UDP 数据包的 UDP 端口。 如前所述，TCP 和 UDP 端口不相同，因此不重叠。 可以在 TCP 和 UDP 80 端口上侦听两个不同的进程，而不会发生任何冲突。&lt;/p&gt;
&lt;p&gt;其次，创建字节缓冲区和 DatagramPacket 。 注意 DatagramPacket 没有关于要发送数据的节点的信息，就像创建 DatagramPacket 用于发送数据时一样。 这是因为我们将使用 DatagramPacket 接收数据而不是发送数据，因此，不需要目标地址。&lt;/p&gt;
&lt;p&gt;最后调用 DatagramSocket 的 receive() 方法。 此方法将一直阻塞，直到收到 DatagramPacket 。&lt;/p&gt;
&lt;p&gt;收到的数据位于 DatagramPacket 的字节缓冲区中。 这个缓冲区可以通过调用如下代码获取：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;byte[] buffer = packet.getData();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缓冲区会接收多少数据应该由你找到答案。 正在使用的协议应指定每个 UDP 数据包发送的数据量，或指定可以查找到的数据结束标记。真正的服务器程序可能会在循环中调用 receive() 方法，并将所有收到的 DatagramPacket 传递给工作线程池，就像 TCP 服务器对传入连接一样。&lt;/p&gt;
&lt;h2 id=&quot;url-urlconnection&quot;&gt;URL + URLConnection&lt;/h2&gt;
&lt;p&gt;java.net 包中两个有趣的类：URL 类和 URLConnection 类，这些类可用于创建与 Web 服务器（HTTP 服务器）的客户端连接。 这是一个简单的代码示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class URLExample {
    public static void main(String[] args) throws IOException {
        URL url = new URL(&quot;http://baidu.com&quot;);

        URLConnection urlConnection = url.openConnection();
        InputStream inputStream = urlConnection.getInputStream();

        int data = inputStream.read();
        while (data != -1) {
            System.out.print((char) data);
            data = inputStream.read();
        }
        inputStream.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将会输出&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
&amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;http-get-和-post&quot;&gt;HTTP GET 和 POST&lt;/h5&gt;
&lt;p&gt;URLConnection 类的作用是构造一个到指定 URL 的 URL 连接。它只有一个构造函数：&lt;code&gt;URLConnection(URL url)&lt;/code&gt; 。&lt;br/&gt;默认情况下，URLConnection 向 Web 服务器发送 HTTP GET 请求，即查询数据。如果要发送 HTTP POST 请求提交数据，请调用URLConnection.setDoOutput(true) 方法，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;URL url = new URL(&quot;http://baidu.com&quot;);
URLConnection urlConnection = url.openConnection();
urlConnection.setDoOutput(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦设置了 setDoOutput(true) ，因为要提交数据，所以需要输出流。可以打开 URLConnection 的 OutputStream ，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;OutputStream output = urlConnection.getOutputStream();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用此 OutputStream ，可以在 HTTP 请求的正文中编写所需的任何数据。 请记住对其进行 URL 编码（参考 &lt;a href=&quot;https://github.com/chokcoco/cnblogsArticle/issues/6&quot;&gt;【基础进阶】URL详解与URL编码&lt;/a&gt; ，并记得在完成向其写入数据后关闭 OutputStream 。&lt;/p&gt;
&lt;h5 id=&quot;本地文件的url&quot;&gt;本地文件的URL&lt;/h5&gt;
&lt;p&gt;URL 类还可用于访问本地文件系统中的文件。 因此，如果需要代码处理来源不明的文件，比如是来自网络还是本地文件系统，则 URL 类是打开文件的便捷方式。&lt;br/&gt;以下是使用 URL 类在本地文件系统中打开文件的示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;URL url = new URL(&quot;file:/D:/test/test.txt&quot;);

URLConnection urlConnection = url.openConnection();
InputStream input = urlConnection.getInputStream();

int data = input.read();
while(data != -1){
    System.out.print((char) data);
    data = input.read();
}
input.close();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，这和通过 HTTP 访问 Web 服务器上的文件的唯一区别是 URL ：&lt;code&gt;&quot;file:/D:/test/test.txt&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;http://baidu.com&quot;&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;jarurlconnection&quot;&gt;JarURLConnection&lt;/h4&gt;
&lt;p&gt;JarURLConnection 类用于连接 Java Jar 文件。 连接后可以获取有关 Jar 文件内容的信息。 这是一个简单的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String urlString = &quot;http://butterfly.jenkov.com/&quot;
                 + &quot;container/download/&quot;
                 + &quot;jenkov-butterfly-container-2.9.9-beta.jar&quot;;

URL jarUrl = new URL(urlString);
JarURLConnection connection = new JarURLConnection(jarUrl);

Manifest manifest = connection.getManifest();
JarFile jarFile = connection.getJarFile();
//do something with Jar file...&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 25 Nov 2018 15:27:00 +0000</pubDate>
<dc:creator>czwbig</dc:creator>
<og:description>本文目的是大概了解 Java 网络编程体系，不深入。主要参考 JavaDoc 和 Jakob Jenkov 的英文教程《Java Networking》</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/czwbig/p/10018118.html</dc:identifier>
</item>
</channel>
</rss>