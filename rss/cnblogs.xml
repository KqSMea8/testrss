<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何解释vue的生命周期才能令面试官满意？ - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/8828015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/8828015.html</guid>
<description>&lt;p&gt;当然，甩张Image给面试官这句话肯定是开玩笑的（适度幽默，缓解紧张气氛）。不过这张流程图还是有用的，因为它是我从Vue官网上拷贝下来的，只要你能理解了这张图，也就对Vue的生命周期有了一个大致的了解。那么接下来，闰土大叔将手摸手教你如何深入浅出地说出令面试官满意的、有亮点的回答。&lt;/p&gt;
&lt;p&gt;在谈到Vue的生命周期的时候，我们首先需要创建一个实例，也就是在 new Vue ( ) 的对象过程当中，首先执行了init（init是vue组件里面默认去执行的），在init的过程当中首先调用了beforeCreate，然后在injections（注射）和reactivity（反应性）的时候，它会再去调用created。所以在init的时候，事件已经调用了，我们在beforeCreate的时候千万不要去修改data里面赋值的数据，最早也要放在created里面去做（添加一些行为）。&lt;/p&gt;
&lt;p&gt;当created完成之后，它会去判断instance（实例）里面是否含有“el”option（选项），如果没有的话，它会调用vm.$mount(el)这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有“template”这个选项，如果有的话，它会把template解析成一个render function ，这是一个template编译的过程，结果是解析成了render函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;render (h) {
  &lt;span class=&quot;hljs-built_in&quot;&gt;return h(&lt;span class=&quot;hljs-string&quot;&gt;'div', {}, this.text)
}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释一下，render函数里面的传参h就是Vue里面的createElement方法，return返回一个createElement方法，其中要传3个参数，第一个参数就是创建的div标签；第二个参数传了一个对象，对象里面可以是我们组件上面的props，或者是事件之类的东西；第三个参数就是div标签里面的内容，这里我们指向了data里面的text。&lt;/p&gt;
&lt;p&gt;使用render函数的结果和我们之前使用template解析出来的结果是一样的。render函数是发生在beforeMount和mounted之间的，这也从侧面说明了，在beforeMount的时候，$el还只是我们在HTML里面写的节点，然后到mounted的时候，它就把渲染出来的内容挂载到了DOM节点上。这中间的过程其实是执行了render function的内容。&lt;/p&gt;
&lt;p&gt;在使用.vue文件开发的过程当中，我们在里面写了template模板，在经过了vue-loader的处理之后，就变成了render function，最终放到了vue-loader解析过的文件里面。这样做有什么好处呢？原因是由于在解析template变成render function的过程，是一个非常耗时的过程，vue-loader帮我们处理了这些内容之后，当我们在页面上执行vue代码的时候，效率会变得更高。&lt;/p&gt;
&lt;p&gt;beforeMount在有了render function的时候才会执行，当执行完render function之后，就会调用mounted这个钩子，在mounted挂载完毕之后，这个实例就算是走完流程了。&lt;/p&gt;
&lt;p&gt;后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用beforeUpdate，然后经过Virtual DOM，最后updated更新完毕。当组件被销毁的时候，它会调用beforeDestory，以及destoryed。&lt;/p&gt;
&lt;p&gt;这就是vue实例从新建到销毁的一个完整流程，以及在这个过程中它会触发哪些生命周期的钩子函数。那说到这儿，可能很多童鞋会问，钩子函数是什么意思？&lt;/p&gt;
&lt;p&gt;钩子函数，其实和回调是一个概念，当系统执行到某处时，检查是否有hook，有则回调。说的更直白一点，每个组件都有属性，方法和事件。所有的生命周期都归于事件，在某个时刻自动执行。&lt;/p&gt;
&lt;p&gt;其实，当你跟面试官阐述到这儿的时候，面试官基本上已经满意你的回答了，隐约看到了你的技术功底。当然，如果你还想更进一步，让面试官对你刮目相看，达到加分的效果，你还可以这样说：&lt;/p&gt;
&lt;p&gt;在这个过程当中，Vue为我们提供了renderError方法，这个方法只有在开发的时候它才会被调用，在正式打包上线的过程当中，它是不会被调用的。它主要是帮助我们调试render里面的一些错误。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;renderError (h, err) {
  &lt;span class=&quot;hljs-built_in&quot;&gt;return h(&lt;span class=&quot;hljs-string&quot;&gt;'div', {}, err.stack)
}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有且只有当render方法里面报错了，才会执行renderError方法。&lt;/p&gt;
&lt;p&gt;所以我们主动让render函数报个错：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot; lang=&quot;bash&quot;&gt;render (h) {
  throw new TypeError(&lt;span class=&quot;hljs-string&quot;&gt;'render error')
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 13 Apr 2018 20:15:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/8828015.html</dc:identifier>
</item>
<item>
<title>Hadoop 3.x 新特性剖析系列1 - 哥不是小萝莉</title>
<link>http://www.cnblogs.com/smartloli/p/8827623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartloli/p/8827623.html</guid>
<description>&lt;p&gt;　　目前从Hadoop官网的Wiki来看，稳定版本已经发行到Hadoop2.9.0，最新版本为Hadoop3.1.0，查阅JIRA，社区已经着手迭代Hadoop3.2.0。那么，今天笔者就带着大家来剖析一下Hadoop3，看看它给我们带来了哪些新特性。&lt;/p&gt;

&lt;p&gt;　　从功能上来说，Hadoop3比Hadoop2有些功能得到了增强，具体增加了哪些，后面再讲。首先，我们来看看Hadoop3主要带来了哪些变化：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDK：在Hadoop2时，可以使用JDK7，但是在Hadoop3中，最低版本要求是JDK8，所以低于JDK8的版本需要对JDK进行升级，方可安装使用Hadoop3&lt;/li&gt;
&lt;li&gt;EC技术：Erasure Encoding 简称EC，是Hadoop3给HDFS拓展的一种新特性，用来解决存储空间文件。EC技术既可以防止数据丢失，又能解决HDFS存储空间翻倍的问题&lt;/li&gt;
&lt;li&gt;YARN：提供YARN的时间轴服务V.2，以便用户和开发人员可以对其进行测试，并提供反馈意见，使其成为YARN Timeline Service v.1的替代品。&lt;/li&gt;
&lt;li&gt;优化Hadoop Shell脚本&lt;/li&gt;
&lt;li&gt;重构Hadoop Client Jar包&lt;/li&gt;
&lt;li&gt;支持随机Container&lt;/li&gt;
&lt;li&gt;MapReduce任务级本地优化&lt;/li&gt;
&lt;li&gt;支持多个NameNode&lt;/li&gt;
&lt;li&gt;部分默认服务端口被改变&lt;/li&gt;
&lt;li&gt;支持文件系统连接器&lt;/li&gt;
&lt;li&gt;DataNode内部添加了负载均衡&lt;/li&gt;
&lt;li&gt;重构后台程序和任务对管理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面，笔者就为大家来一一剖析这些新特性的具体内容，其内容包含JDK版本、EC技术、YARN的时间轴服务这三类特性，其他特性笔者在后面的博客再为大家慢慢剖析。&lt;/p&gt;
&lt;h2&gt;2.1 JDK&lt;/h2&gt;
&lt;p&gt;　　在Hadoop 3中，所有的Hadoop JAR包编译的环境都是基于Java8来完成的，所有如果仍然使用的是Java 7或者更低的版本，你可能需要升级到Java 8才能正常的运行Hadoop3。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201804/666745-20180414021359874-2066787726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.2 EC技术&lt;/h2&gt;
&lt;p&gt;　　首先，我们先来了解一下什么是Erasure Encoding。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201804/666745-20180414023030056-1352281308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一般来说，在存储系统中，EC技术主要用于廉价磁盘冗余阵列，即RAID。如上图，RAID通过Stripping实现EC技术，其中逻辑顺序数据（比如：文件）被划分成更小的单元（比如：位、字节或者是块），并将连续单元存储在不同的磁盘上。&lt;/p&gt;
&lt;p&gt;　　然后，对原始数据单元的每个Stripe，计算并存储一定数量的奇偶校验单位。这个过程称之为编码，通过基于有效数据单元和奇偶校验单元的解码计算，可以恢复任意Stripe单元的错误。当我们想到了擦除编码的时候，我们可以先来了解一下在Hadoop2中复制的早期场景。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201804/666745-20180414024146050-1731430899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　HDFS默认情况下，它的备份系数是3，一个原始数据块和其他2个副本。其中2个副本所需要的存储开销各站100%，这样使得200%的存储开销，会消耗其他资源，比如网络带宽。然而，在正常操作中很少访问具有低IO活动的冷数据集的副本，但是仍然消耗与原始数据集相同的资源量。&lt;/p&gt;
&lt;p&gt;　　对于EC技术，即擦除编码存储数据和提供容错空间较小的开销相比，HDFS复制，EC技术可以代替复制，这将提供相同的容错机制，同时还减少了存储开销。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201804/666745-20180414025409340-384343278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　EC和HDFS的整合可以保持与提供存储效率相同的容错。例如，一个副本系数为3，要复制文件的6个块，需要消耗6*3=18个块的磁盘空间。但是，使用EC技术（6个数据块，3个奇偶校验块）来部署，它只需要消耗磁盘空间的9个块（6个数据块+3个奇偶校验块）。这些与原先的存储空间相比较，节省了50%的存储开销。&lt;/p&gt;
&lt;p&gt;　　由于擦除编码需要在执行远程读取时，对数据重建带来额外的开销，因此他通常用于存储不太频繁访问的数据。在部署EC之前，用户应该考虑EC的所有开销，比如存储、网络、CPU等。&lt;/p&gt;
&lt;h2&gt;2.3 YARN的时间线V.2服务&lt;/h2&gt;
&lt;p&gt; 　　Hadoop引入YARN Timeline Service v.2是为了解决两个主要问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提高时间线服务的可伸缩性和可靠性；&lt;/li&gt;
&lt;li&gt;通过引入流和聚合来增强可用性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　下面首先，我们来剖析一下它伸缩性。&lt;/p&gt;
&lt;h3&gt;2.3.1  伸缩性&lt;/h3&gt;
&lt;p&gt;　　YARN V1仅限于读写单个实例，不能很好的扩展到小集群之外。YARN V2使用了更具有伸缩性的分布式体系架构和可扩展的后端存储，它将数据的写入与数据的读取进行了分离。并使用分布式收集器，本质上是每个YARN应用的收集器。读则是独立的实例，专门通过REST API服务来查询&lt;/p&gt;
&lt;h3&gt;2.3.2  可用性&lt;/h3&gt;
&lt;p&gt;　　对于可用性的改进，在很多情况下，用户对流或者YARN应用的逻辑组的信息比较感兴趣。启动一组或者一系列的YARN应用程序来完成逻辑应用是很常见的。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201804/666745-20180414032646933-1853167323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.3.3 架构体系&lt;/h3&gt;
&lt;p&gt; 　　YARN时间线服务V2采用了一组收集器写数据到后端进行存储。收集器被分配并与它们专用的应用程序主机进行协作，如下图所示，属于该应用程序的所有数据都被发送到应用程序时间轴的收集器中，但是资源管理器时间轴收集器除外。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/666745/201804/666745-20180414035415378-1954334798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　对于给定的应用程序，应用程序可以将数据写入同一时间轴收集器中。此外，为应用程序运行容器的其他节点的节点管理器，还会向运行应用程序主节点的时间轴收集器写入数据。资源管理器还维护自己的时间手机线收集器，它只发布YARN的通用生命周期事件，以保持其写入量合理。时间的读取器是单独的守护进程从收集器中分离出来的，它旨在服务于REST API查询操作。&lt;/p&gt;

&lt;p&gt;　　本篇博客先给大家剖析前面几个特性，其内容由JDK的版本升级、EC技术的作用及优势、YARN的时间轴V2版本的主要作用。Hadoop3后面的几个特性，在下一篇博客为大家再剖析。&lt;/p&gt;

&lt;p&gt;　　这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！&lt;/p&gt;
</description>
<pubDate>Fri, 13 Apr 2018 19:53:00 +0000</pubDate>
<dc:creator>哥不是小萝莉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smartloli/p/8827623.html</dc:identifier>
</item>
<item>
<title>Spring之事务管理 - 非洲铜</title>
<link>http://www.cnblogs.com/africancu/p/8825446.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/africancu/p/8825446.html</guid>
<description>&lt;p&gt;    &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;事务管理对于企业应用至关重要。它保证了用户的每一次操作都是可靠的，即便出现了异常的访问情况，也不至于破坏后台数据的完整性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    就像银行的自助取款机，通常都能正常为客户服务，但是也难免遇到操作过程中机器突然出故障的情况，此时，事务就必须确保出故障前对账户的操作不生效，就像用户刚才完全没有使用过取款机一样，以保证用户和银行的利益都不受损失。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、事务的介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    事务是若干个操作组合在一起，形成一个原子性的工作单元。这一组操作要么全部成功，要么全部失败。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;事务的特性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    事务有四个特性，分别是ACID，也就是原子性、一致性、隔离性和持久性。&lt;/p&gt;
&lt;p&gt;    原子性（Atomicity）：事务是一个原子操作，由一系列的动作组成，要么全部成功，要么全部失败。&lt;/p&gt;
&lt;p&gt;    一致性（Consistency）：事务一旦完成，系统必须确保数据的完整性，而不会部分成功，部分失败。&lt;/p&gt;
&lt;p&gt;   &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;隔离性（Isolation）：可能存在多个事务处理相同的数据，这时，事务之间应该隔离开来，防止数据被损坏。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    持久性（Durability）：事务一旦完成，数据就被持久化到硬盘了。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;隔离存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    脏读（dirty read）：A事务读到了B事务未提交了数据，而B事务又回滚了，所以A事务读到的是无效数据。&lt;/p&gt;
&lt;p&gt;    不可重复读（norepeatable read）：A事务两次（或者多次）查询到的数据不相同，因为B事务在A的两次查询期间对数据进行了更新。&lt;/p&gt;
&lt;p&gt;    幻读（phantom read）：&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;A事务两次（或者多次）查询到的数据不相同，&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;因为B事务在A的两次查询期间&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;插入&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;了新的数据&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    因为存在隔离问题，所以有隔离级别来解决这些问题。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;  &lt;strong&gt;  隔离级别：&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    read uncommitted：读未提交。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    read committed：读已提交。该级别解决了脏读。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    repeatable read：可重复读。该级别解决了脏读和不可重复读。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    serializable：串行化。解决全部问题，但是效率最低。因为它在操作的时候，完全锁定了相关的表，其他事务只能处于等待状态。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;    Java模拟事务操作：&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Connection conn = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
    conn &lt;/span&gt;=&lt;span&gt; getConnection();
    conn.setAutoCommit(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭事务的自动提交&lt;/span&gt;
&lt;span&gt;    A
    B
    C
    D
    conn.commit();
}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(){
    conn.rollback();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    ABCD是同一个事务内的动作。ABCD有任何一个动作抛了异常，都将进入catch块中进行事务回滚。&lt;/p&gt;

&lt;p&gt;     Java模拟带保存点的事务操作：   &lt;/p&gt;
&lt;div readability=&quot;24.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Connection conn = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
Savepoint savepoint &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
    conn &lt;/span&gt;=&lt;span&gt; getConnection();
    conn.setAutoCommit(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭事务的自动提交&lt;/span&gt;
&lt;span&gt;    A
    B
    savepoint &lt;/span&gt;=&lt;span&gt; conn.setSavepoint();
    C
    D
    conn.commit();
}&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(savepoint != &lt;span&gt;null&lt;/span&gt;){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;savepoint不为空，说明已经执行到了C或者D&lt;/span&gt;
        conn.rollback(savepoint);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回滚到保存点&lt;/span&gt;
    }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        conn.rollback();     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;savepoing为空，说明在执行A或者B的时候就抛了异常&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;二、Spring事务的API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;在 Spring 中，事务是通过 TransactionDefinition 接口来定义的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    Spring为了管理事务，设计了三个顶级接口，Spring的事务管理就是围绕这三个顶级接口而展开的。 &lt;/p&gt;
&lt;div readability=&quot;52&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133643/201804/1133643-20180414004517438-2080852075.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;    我们重点解析事务详情，事务详情也叫事务定义，或者事务属性。&lt;/p&gt;
&lt;p&gt;    事务详情中定义两组常量，分别用来描述&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;隔离级别&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/strong&gt;和 &lt;strong&gt;传播行为&lt;/strong&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;   &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;隔离级别：&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        isolation_default = -1，默认值，使用数据库的隔离级别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        isolation_read_uncommitted = 1， 读未提交&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        isolation_read_committed = 2， 读已提交&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        isolation_repeatable_read = 4， 可重复读&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        isolation_serializable = 8， 串行化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        1、2、4、8这四个常量值是定义在java.sql.Connection接口中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    &lt;strong&gt;传播行为：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;       &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;所谓事务的传播行为是指，如果在当前事务开始之前，一个事务上下文已经存在，此时有若干选项可以指定当前事务性方法的执行行为。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        假设现在有A、B两个操作。     &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;76.5&quot;&gt;
&lt;p&gt;        propagation_required = 0，默认值，如果A有事务，B就使用A的事务。如果A没事务，B创建一个新事务。&lt;/p&gt;
&lt;p&gt;        propagation_supports = 1，如果A有事务，B就使用A的事务。如果A没事务，B以非事务执行。&lt;/p&gt;
&lt;p&gt;        propagation_mandatory = 2，如果A有事务，B就事务A的事务。如果A没事务，B会抛出异常。&lt;/p&gt;
&lt;p&gt;        propagation_requires_new = 3，如果A有事务，将A的事务挂起，B创建一个新事务执行，如果A没事务，B也创建一个新事务执行。&lt;/p&gt;
&lt;p&gt;        propagation_not_supported = 4，如果A有事务，将A的事务挂起，B以非事务执行。如果A没事务，B也以非事务执行。&lt;/p&gt;
&lt;p&gt;       &lt;span class=&quot;Apple-converted-space&quot;&gt; propagation_never = 5，&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;如果A有事务，B将抛异常。如果A没事务，B以非事务执行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        propagation_nested = 6，如果A有事务，B的事务将嵌套在A的事务里面执行。B的事务执行完之后，再出来继续执行A的事务，所以A事务中得有个保存点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;事务超时：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    &lt;strong&gt;事务的只读属性：&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;事务的只读属性是指，对事务性资源进行只读操作或者是读写操作。所谓事务性资源就是指那些被事务管理的资源，比如数据源、 JMS 资源，以及自定义的事务性资源等等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        如果确定只对事务性资源进行只读操作，那么我们可以将事务标志为只读的，以提高事务处理的性能。在 TransactionDefinition 中以 boolean 类型来表示该事务是否只读。&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    &lt;strong&gt;事务的回滚规则：&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;       &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt; &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;通常情况下，如果在事务中抛出了未检查异常（继承自 RuntimeException 的异常），则默认将回滚事务。如果没有抛出任何异常，或者抛出了已检查异常，则仍然提交事务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        这通常也是大多数开发者希望的处理方式。但是，我们可以根据需要人为控制事务在抛出某些未检查异常时依然提交事务，或者在抛出某些已检查异常时回滚事务。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;三、手动编程管理事务（基于底层API）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;根据PlatformTransactionManager、TransactionDefinition 和 TransactionStatus 三个核心接口，我们完全可以通过编程的方式来进行事务管理。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        下面给出一个小demo：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;       &lt;span class=&quot;Apple-converted-space&quot;&gt; 数据库： &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;72.5&quot;&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133643/201804/1133643-20180414004709647-505187208.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;strong&gt;        1. dao层&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.african.dao;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BankDao {
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; transfer(Long fromId, Long toId, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; amount);
}


&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.african.dao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.support.JdbcDaoSupport;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BankDaoImpl &lt;span&gt;extends&lt;/span&gt; JdbcDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BankDao {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; transfer(Long fromId, Long toId, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; amount) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; f = &lt;span&gt;this&lt;/span&gt;.getJdbcTemplate().update(&quot;update account set money = money - ? where id = ?&quot;&lt;span&gt;, amount, fromId);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; i = 1 / 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t = &lt;span&gt;this&lt;/span&gt;.getJdbcTemplate().update(&quot;update account set money = money + ? where id = ?&quot;&lt;span&gt;, amount, toId);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(f &amp;gt; 0 &amp;amp;&amp;amp; t &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;        2. service层&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.african.service;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BankService {    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; transfer(Long fromId, Long toId, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; amount);
}


&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.african.service;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.PlatformTransactionManager;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.TransactionDefinition;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.TransactionStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.african.dao.BankDao;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BankServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BankService {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BankDao bankDao;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事务详情&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; TransactionDefinition txDefinition;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事务管理器&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; PlatformTransactionManager txManager;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; transfer(Long fromId, Long toId, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; amount) {
        TransactionStatus txStatus &lt;/span&gt;=&lt;span&gt; txManager.getTransaction(txDefinition);
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            result &lt;/span&gt;=&lt;span&gt; bankDao.transfer(fromId, toId, amount);
            txManager.commit(txStatus);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            result &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            txManager.rollback(txStatus);
            System.out.println(&lt;/span&gt;&quot;转账失败&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBankDao(BankDao bankDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bankDao =&lt;span&gt; bankDao;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTxDefinition(TransactionDefinition txDefinition) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.txDefinition =&lt;span&gt; txDefinition;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTxManager(PlatformTransactionManager txManager) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.txManager =&lt;span&gt; txManager;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;    3. applicationContext.xml&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driverClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;jdbcUrl&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;jdbc:mysql://localhost:3306/txdemo&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.dao.BankDaoImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.service.BankServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义事务详情 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;txDefinition&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.transaction.support.DefaultTransactionDefinition&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;propagationBehaviorName&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;PROPAGATION_REQUIRED&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;        4. 测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.african.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.african.service.BankService;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestApp {
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; demo01() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
        BankService bankService &lt;/span&gt;= context.getBean(&quot;bankService&quot;, BankService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        bankService.transfer(&lt;/span&gt;1L, 2L&lt;span&gt;, 1000D);
        context.getClass().getMethod(&lt;/span&gt;&quot;close&quot;&lt;span&gt;).invoke(context);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        测试之后可以看到，数据库的数据并没有发生改变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、手动编程管理事务（基于TransactionTemplate）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt; &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;通过前面的示例可以发现，这种事务管理方式很容易理解，但令人头疼的是，事务管理的代码散落在业务逻辑代码中，破坏了原有代码的条理性，并且每一个业务方法都包含了类似的启动事务、提交/回滚事务的样板代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        幸好，Spring 也意识到了这些，并提供了简化的方法，这就是 Spring 在数据访问层非常常见的模板回调模式。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        我们再实现一个基于TransactionTemplate的demo：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        1. dao层（如上）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;        2. service层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.african.service;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BankService {    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; transfer(Long fromId, Long toId, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; amount);
}


&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.african.service;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.TransactionStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionCallback;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.african.dao.BankDao;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BankServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BankService {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BankDao bankDao;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TransactionTemplate transactionTemplate;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; transfer(Long fromId, Long toId, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; amount) {
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; transactionTemplate.execute(&lt;span&gt;new&lt;/span&gt; TransactionCallback&amp;lt;Boolean&amp;gt;&lt;span&gt;() {
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean doInTransaction(TransactionStatus status) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    bankDao.transfer(fromId, toId, amount);
                    result &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置回滚&lt;/span&gt;
&lt;span&gt;                    status.setRollbackOnly();
                    System.out.println(&lt;/span&gt;&quot;转账失败&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            }
        });
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBankDao(BankDao bankDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bankDao =&lt;span&gt; bankDao;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTransactionTemplate(TransactionTemplate transactionTemplate) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.transactionTemplate =&lt;span&gt; transactionTemplate;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;    3. applicationContext.xml&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driverClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;jdbcUrl&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;jdbc:mysql://localhost:3306/txdemo&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.dao.BankDaoImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.service.BankServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;transactionTemplate&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;txTemplate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txTemplate&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    4. 测试类（如上）&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;五、声明式事务管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;Spring 的声明式事务管理在底层是建立在 AOP 的基础之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    声明式事务管理有四种方式：&lt;/p&gt;
&lt;p&gt;    1.&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 基于&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;TransactionInterceptor 类来进行声明式事务管理&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    2.&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;基于&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;TransactionProxyFactoryBean&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;来进行声明式事务管理&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    3. 基于 &amp;lt;tx&amp;gt; 命名空间进行声明式事务管理&lt;/p&gt;
&lt;p&gt;    4. 基于 @Transactional 注解来进行声明式事务管理&lt;/p&gt;


&lt;p&gt;   &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;5.1  &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;基于&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;TransactionInterceptor 类来进行声明式事务管理&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    首先我们看一下这种方式的配置文件：&lt;/p&gt;
&lt;div readability=&quot;24&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driverClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;jdbcUrl&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;jdbc:mysql://localhost:3306/ee19_spring_day03&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.dao.BankDaoImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;这个事务拦截器就是切面&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txInterceptor&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.transaction.interceptor.TransactionInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;transactionAttributes&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;transfer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;PROPAGATION_REQUIRED&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankServiceTarget&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.service.BankServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;目标类&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;target&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;bankServiceTarget&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置切面&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;interceptorNames&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;idref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;txInterceptor&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;首先，我们配置了一个 TransactionInterceptor 来定义相关的事务规则，他有两个主要的属性：一个是 transactionManager，用来指定一个事务管理器，并将具体事务相关的操作委托给它；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;    另一个是 Properties 类型的 transactionAttributes 属性，它主要用来定义事务规则，该属性的每一个键值对中，键指定的是方法名，方法名可以使用通配符，而值就表示相应方法的所应用的事务属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;指定事务属性的具体的书写规则如下：&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;25&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
传播行为 [，隔离级别] [，只读属性] [，超时属性] [不影响提交的异常] [，导致回滚的异常] 
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;    其中传播行为是必须的，其他都是可选的。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    超时属性的取值必须以“TIMEOUT_”开头，后面跟一个int类型的值，表示超时时间，单位是秒。&lt;/p&gt;
&lt;p&gt;    不影响提交的异常是指，即使事务中抛出了这些类型的异常，事务任然正常提交。必须在每一个异常的名字前面加上“+”。异常的名字可以是类名的一部分。比如“+RuntimeException”、“+tion”等等。&lt;/p&gt;
&lt;p&gt;    导致回滚的异常是指，当事务中抛出这些类型的异常时，事务将回滚。必须在每一个异常的名字前面加上“-”。异常的名字可以是类名的全部或者部分，比如“-RuntimeException”、“-tion”等等。&lt;/p&gt;
&lt;p&gt;    给一个书写例子：    &lt;/p&gt;
&lt;div readability=&quot;24&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;transfer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;PROPAGATION_REQUIRED，ISOLATION_READ_COMMITTED，TIMEOUT_20，+AException，+BException，-CException&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    使用 PROPAGATION_REQUIRED 事务传播行为，事务的隔离级别是 ISOLATION_READ_COMMITTED，超时时间为20秒，当事务抛出 AException 或者 BException 类型的异常，则仍然提交，当抛出 CException 类型的异常时必须回滚事务。&lt;/p&gt;
&lt;p&gt;    这里没有指定&quot;readOnly&quot;，表示事务不是只读的。&lt;/p&gt;
&lt;p&gt;    由于Spring是通过感知异常来决定是否回滚，所以此时在Service中，我们不能再去捕获异常，这个异常必须要让Spring知道。所以Service实现类改成了：&lt;/p&gt;
&lt;div readability=&quot;35.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.african.service;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.african.dao.BankDao;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BankServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BankService {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BankDao bankDao;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; transfer(Long fromId, Long toId, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; amount) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这种方式，在这里不能自己去捕获异常，这个异常必须由spring感知&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bankDao.transfer(fromId, toId, amount);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setBankDao(BankDao bankDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bankDao =&lt;span&gt; bankDao;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;    5.2  &lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;基于&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;TransactionProxyFactoryBean&lt;span data-wiz-span=&quot;data-wiz-span&quot;&gt;来进行声明式事务管理&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    前面的声明式事务虽然好，但是却存在一个非常恼人的问题：配置文件太多。我们必须针对每一个目标对象配置一个 ProxyFactoryBean；&lt;/p&gt;
&lt;p&gt;    为了缓解这个问题，Spring 为我们提供了 TransactionProxyFactoryBean，用于将TransactionInterceptor 和 ProxyFactoryBean 的配置合二为一。   &lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driverClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;jdbcUrl&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;jdbc:mysql://localhost:3306/ee19_spring_day03&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.dao.BankDaoImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankServiceTarget&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.service.BankServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;target&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;bankServiceTarget&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;transactionAttributes&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;transfer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;PROPAGATION_REQUIRED&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
  
&lt;p&gt;&lt;strong&gt;    5.3   基于 &amp;lt;tx&amp;gt; 命名空间进行声明式事务管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    前面两种声明式事务配置方式奠定了 Spring 声明式事务管理的基石。在此基础上，Spring 2.x 引入了 &amp;lt;tx&amp;gt; 命名空间，结合使用 &amp;lt;aop&amp;gt; 命名空间，配置变得更加简单和灵活。&lt;/p&gt;
&lt;p&gt;　另外，得益于 &amp;lt;aop&amp;gt; 命名空间的切点表达式支持，声明式事务也变得更加强大。&lt;/p&gt;
&lt;div readability=&quot;43&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driverClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;jdbcUrl&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;jdbc:mysql://localhost:3306/ee19_spring_day03&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.dao.BankDaoImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.service.BankServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:advice &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txAdvice&quot;&lt;/span&gt;&lt;span&gt; transaction-manager&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:attributes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;transfer&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;REQUIRED&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:attributes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:advice&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;如果事务的默认配置就能满足需求，上面元素的配置可以简化为以下方式&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot; /&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:pointcut &lt;/span&gt;&lt;span&gt;expression&lt;/span&gt;&lt;span&gt;=&quot;execution(* cn.african.service..*.*(..))&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;txPointcut&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:advisor &lt;/span&gt;&lt;span&gt;advice-ref&lt;/span&gt;&lt;span&gt;=&quot;txAdvice&quot;&lt;/span&gt;&lt;span&gt; pointcut-ref&lt;/span&gt;&lt;span&gt;=&quot;txPointcut&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    由于使用了切点表达式，我们就不需要针对每一个业务类创建一个代理对象了。&lt;/p&gt;
&lt;p&gt;    另外，如果配置的事务管理器 Bean 的名字取值为“transactionManager”，则我们可以省略 &amp;lt;tx:advice&amp;gt; 的 transaction-manager 属性，因为该属性的默认值即为“transactionManager”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    5.4. 基于 @Transactional 注解来进行声明式事务管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    除了基于命名空间的事务配置方式，Spring 2.x 还引入了基于 Annotation 的方式，具体主要涉及@Transactional 标注。@Transactional 可以作用于接口、接口方法、类以及类方法上。&lt;/p&gt;
&lt;p&gt;    当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。&lt;/p&gt;
&lt;p&gt;   删除通知配置和aop编程的配置，添加注解驱动：&lt;/p&gt;
&lt;div readability=&quot;42.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driverClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;jdbcUrl&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;jdbc:mysql://localhost:3306/ee19_spring_day03&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;123456&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.dao.BankDaoImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;bankService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.african.service.BankServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;bankDao&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用事务注解时，必须要开启注解驱动 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:annotation-driven &lt;/span&gt;&lt;span&gt;transaction-manager&lt;/span&gt;&lt;span&gt;=&quot;txManager&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        transaction-manager 属性的默认值是 transactionManager，如果事务管理器 Bean 的名字即为该值，则可以省略该属性。&lt;/p&gt;
&lt;p&gt;        虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 小组建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。&lt;/p&gt;
&lt;p&gt;        另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;结束语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        1.  基于 TransactionDefinition、PlatformTransactionManager、TransactionStatus 编程式事务管理是 Spring 提供的最原始的方式，通常我们不会这么写，但是了解这种方式对理解 Spring 事务管理的本质有很大作用。 &lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        2.  基于 TransactionTemplate 的编程式事务管理是对上一种方式的封装，使得编码更简单、清晰。&lt;/p&gt;
&lt;p&gt;        3.  基于 TransactionInterceptor 的声明式事务是 Spring 声明式事务的基础，通常也不建议使用这种方式，但是与前面一样，了解这种方式对理解 Spring 声明式事务有很大作用。&lt;/p&gt;
&lt;p&gt;        4.  基于 TransactionProxyFactoryBean 的声明式事务是上中方式的改进版本，简化的配置文件的书写，这是 Spring 早期推荐的声明式事务管理方式，但是在 Spring 2.0 中已经不推荐了。&lt;/p&gt;
&lt;p&gt;        5.  基于 &amp;lt;tx&amp;gt; 和 &amp;lt;aop&amp;gt; 命名空间的声明式事务管理是目前推荐的方式，其最大特点是与 Spring AOP 结合紧密，可以充分利用切点表达式的强大支持，使得管理事务更加灵活。&lt;/p&gt;
&lt;p&gt;        6.  基于 @Transactional 的方式将声明式事务管理简化到了极致。开发人员只需在配置文件中加上一行启用相关后处理 Bean 的配置，然后在需要实施事务管理的方法或者类上使用 @Transactional 指定事务规则即可实现事务管理，而且功能也不必其他方式逊色。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 13 Apr 2018 16:56:00 +0000</pubDate>
<dc:creator>非洲铜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/africancu/p/8825446.html</dc:identifier>
</item>
<item>
<title>Java基础之程序流程控制 - maybe程序员</title>
<link>http://www.cnblogs.com/maybecoding/p/8825112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maybecoding/p/8825112.html</guid>
<description>&lt;h2&gt;Java中的程序流程控制&lt;/h2&gt;
&lt;h3&gt;Java中的程序流程分为三种结构：①顺序结构；②分支结构；③循环结构&lt;/h3&gt;
&lt;h3&gt;一.顺序结构&lt;/h3&gt;
&lt;p&gt;　　Java中定义成员变量的时候，采用的是前向引用，也就是后面的变量可以引用之前定义好的变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FlowControl {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正确引用&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; num1 = 10&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num2 = 5+&lt;span&gt; num1;
        
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误引用&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         int num4 =num3 + num2;
         int num3 =9;
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;二.分支结构&lt;/h3&gt;
&lt;p&gt;　　分支语句1：if-else&lt;/p&gt;
&lt;p&gt;　　 if语句的三种格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IfTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 10&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种方式&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(i==10&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;i小于10&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(i&amp;gt;10&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;i大于10&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(i);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三种&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(i&amp;lt;10&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;i小于10&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (i&amp;gt;10&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;i大于10&quot;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;i等于10&quot;&lt;span&gt;);
        }       
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意&lt;/span&gt; ：请思考一下，一下代码的执行结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IfTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = 4&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; y = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x&amp;gt;2&lt;span&gt;) {
            
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(y&amp;gt;1&lt;span&gt;)
                    System.out.println(y);
                System.out.println(x&lt;/span&gt;+&lt;span&gt;y);
        
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;x is&quot;+&lt;span&gt;x);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;  二.switch分支结构&lt;/h3&gt;
&lt;p&gt;　　switch结构表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; *switch语法
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; *switch(表达式) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *    case 常量1:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *        语句;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; *        break;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; *    case 常量2:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; *        语句;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; *        break;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; *        ......
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; *    case 常量n;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; *        语句;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; *        break;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; *    default:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; *        语句;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; *        berak：
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; *}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SwitchTest {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; i =2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(i) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     System.out.println(&quot;一年级&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; 2&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     System.out.println(&quot;二年级&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;case&lt;/span&gt; 3&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     System.out.println(&quot;三年级&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     System.out.println(&quot;校长&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;switch语句中应该注意的东西：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;switch表达式中支持的返回值类型：byte，short，int，枚举，char，string；&lt;/p&gt;
&lt;p&gt;case子句必须是&lt;span&gt;常量&lt;/span&gt;；且所有case子句的执行逻辑应该是不相同的。&lt;/p&gt;
&lt;p&gt;default子句是可以选择的，没有匹配的case子句时会默认匹配default子句中的值。&lt;/p&gt;
&lt;p&gt;在switch语句中，应该每一个case中都应该由跳出逻辑,应当由break语句；如果没有break语句，程序会顺序执行到switch结尾。&lt;/p&gt;
&lt;h3&gt;三.循环结构&lt;/h3&gt;
&lt;p&gt;一. 首先我们来了解一下循环语句的四个组成部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化部分　　&lt;/li&gt;
&lt;li&gt;循环条件部分&lt;/li&gt;
&lt;li&gt;循环体部分&lt;/li&gt;
&lt;li&gt;迭代部分&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 二. 循环语句分类：for循环，while循环，do/while循环&lt;/p&gt;
&lt;p&gt;　　首先,我们来看for循环。&lt;/p&gt;
&lt;p&gt;　　for循环的语法格式：for（初始化值①；布尔值测试②；更改表达式④）{&lt;/p&gt;
&lt;p&gt;　　语句或者语句块③；&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;图例（图是从别的地方抠来的.....）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1372036/201804/1372036-20180413235611026-1234983550.png&quot; alt=&quot;&quot; width=&quot;396&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　while循环语法格式&lt;/p&gt;
&lt;p&gt;　　初始化语句；&lt;/p&gt;
&lt;p&gt;　　whlie（条件）{&lt;/p&gt;
&lt;p&gt;　　语句；&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WhileTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; result =0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(i&amp;lt;=10&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             result=result+&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             System.out.println(&quot;result:&quot;+&lt;span&gt;result);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;do-while循环语句&lt;/p&gt;
&lt;p&gt;　　语法格式：&lt;/p&gt;
&lt;p&gt;　　　　初始化语句&lt;/p&gt;
&lt;p&gt;　　　　do{&lt;/p&gt;
&lt;p&gt;　　　　语句或者语句块&lt;/p&gt;
&lt;p&gt;　　}while（布尔测试值）&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DoWhileTest2 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; result =0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             result=result+&lt;span&gt;i;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             System.out.println(&quot;result:&quot;+&lt;span&gt;result);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         }&lt;span&gt;while&lt;/span&gt;(i&amp;lt;10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了这三种流程语句，我们还有一些特殊的流程控制语句，比如break语句，continue语句；return语句；都可以控制程序流程，这些语句将会在之后做一些总结。&lt;/p&gt;

</description>
<pubDate>Fri, 13 Apr 2018 16:19:00 +0000</pubDate>
<dc:creator>maybe程序员</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maybecoding/p/8825112.html</dc:identifier>
</item>
<item>
<title>基于 MySQL 的数据库实践（自然连接） - wander4096</title>
<link>http://www.cnblogs.com/wander4096/p/8825099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wander4096/p/8825099.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/wander4096/p/8825016.html&quot;&gt;基本查询&lt;/a&gt;一节的示例中，我们有从 instructor 和 teaches 表组合信息，匹配条件是 instructor.ID 等于 teaches.ID 的查询，ID 属性是两个表中具有相同名称的所有属性，按照两个表中所有相同名称属性组合实际上是一种通用情况，即 &lt;code&gt;from&lt;/code&gt; 子句中的匹配条件在最自然的情况下需要在所有匹配名称的属性上相等。因此，SQL 提供了完成这种操作的运算，称之为自然连接（natural join）。实际上，SQL 还支持更丰富的连接（join）运算，后面会提到。&lt;/p&gt;
&lt;p&gt;自然连接运算作用于两个关系，并产生一个关系作为结果，不同于两个关系上的笛卡尔积，笛卡尔积将第一个关系的每个元组与第二个关系的所有元组都进行连接；自然连接只考虑那些在两个关系模式中都出现的属性上取值相同的元组对。&lt;br/&gt;因此，回到 instructor 和 teaches 关系的例子上，它们的自然连接只考虑在唯一共有属性 ID 上取值相同的元组对。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; name, course_id
    -&amp;gt; &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; instructor &lt;span class=&quot;kw&quot;&gt;natural&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; teaches;
+&lt;span class=&quot;co&quot;&gt;------------+-----------+&lt;/span&gt;
| name       | course_id |
+&lt;span class=&quot;co&quot;&gt;------------+-----------+&lt;/span&gt;
| Srinivasan | CS&lt;span class=&quot;dv&quot;&gt;-101&lt;/span&gt;    |
| Srinivasan | CS&lt;span class=&quot;dv&quot;&gt;-315&lt;/span&gt;    |
| Srinivasan | CS&lt;span class=&quot;dv&quot;&gt;-347&lt;/span&gt;    |
| Wu         | FIN&lt;span class=&quot;dv&quot;&gt;-201&lt;/span&gt;   |
| Mozart     | MU&lt;span class=&quot;dv&quot;&gt;-199&lt;/span&gt;    |
| Einstein   | PHY&lt;span class=&quot;dv&quot;&gt;-101&lt;/span&gt;   |
| El Said    | HIS&lt;span class=&quot;dv&quot;&gt;-351&lt;/span&gt;   |
| Katz       | CS&lt;span class=&quot;dv&quot;&gt;-101&lt;/span&gt;    |
| Katz       | CS&lt;span class=&quot;dv&quot;&gt;-319&lt;/span&gt;    |
| Crick      | BIO&lt;span class=&quot;dv&quot;&gt;-101&lt;/span&gt;   |
| Crick      | BIO&lt;span class=&quot;dv&quot;&gt;-301&lt;/span&gt;   |
| Brandt     | CS&lt;span class=&quot;dv&quot;&gt;-190&lt;/span&gt;    |
| Brandt     | CS&lt;span class=&quot;dv&quot;&gt;-190&lt;/span&gt;    |
| Brandt     | CS&lt;span class=&quot;dv&quot;&gt;-319&lt;/span&gt;    |
| Kim        | EE&lt;span class=&quot;dv&quot;&gt;-181&lt;/span&gt;    |
+&lt;span class=&quot;co&quot;&gt;------------+-----------+&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; (&lt;span class=&quot;fl&quot;&gt;0.01&lt;/span&gt; sec)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们知道 &lt;code&gt;from&lt;/code&gt; 子句可以涉及多个关系，现在我们可以说，这些关系也可以是自然连接的结果，这是很直观的，因为自然连接的结果也是一个关系。&lt;br/&gt;考虑查询，列出教师的名字以及他们讲授课程的名称。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; name, title
    -&amp;gt; &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; instructor &lt;span class=&quot;kw&quot;&gt;natural&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; teaches, course
    -&amp;gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; teaches.course_id = course.course_id;
+&lt;span class=&quot;co&quot;&gt;------------+----------------------------+&lt;/span&gt;
| name       | title                      |
+&lt;span class=&quot;co&quot;&gt;------------+----------------------------+&lt;/span&gt;
| Crick      | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Biology          |
| Crick      | Genetics                   |
| Srinivasan | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Computer Science |
| Katz       | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Computer Science |
| Brandt     | Game Design                |
| Brandt     | Game Design                |
| Srinivasan | Robotics                   |
| Katz       | Image Processing           |
| Brandt     | Image Processing           |
| Srinivasan | &lt;span class=&quot;kw&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;System&lt;/span&gt; Concepts   |
| Kim        | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Digital Systems  |
| Wu         | Investment Banking         |
| El Said    | World History              |
| Mozart     | Music Video Production     |
| Einstein   | Physical Principles        |
+&lt;span class=&quot;co&quot;&gt;------------+----------------------------+&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; (&lt;span class=&quot;fl&quot;&gt;0.01&lt;/span&gt; sec)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个查询首先计算 instructor 和 teaches 的自然连接，如前所见，再计算这个救过和 course 的笛卡尔积，然后按照 &lt;code&gt;where&lt;/code&gt; 子句筛选出结果，注意 &lt;code&gt;where&lt;/code&gt; 子句中的 teaches.course_id 表示自然连接结果中的 course_id 域，这是因为该域最终来自 teaches 关系。&lt;br/&gt;下面的查询给出的结果虽然在当前模式下相同，但其实是有问题的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; name, title
    -&amp;gt; &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; instructor &lt;span class=&quot;kw&quot;&gt;natural&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; teaches &lt;span class=&quot;kw&quot;&gt;natural&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; course;
+&lt;span class=&quot;co&quot;&gt;------------+----------------------------+&lt;/span&gt;
| name       | title                      |
+&lt;span class=&quot;co&quot;&gt;------------+----------------------------+&lt;/span&gt;
| Crick      | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Biology          |
| Crick      | Genetics                   |
| Srinivasan | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Computer Science |
| Katz       | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Computer Science |
| Brandt     | Game Design                |
| Brandt     | Game Design                |
| Srinivasan | Robotics                   |
| Katz       | Image Processing           |
| Brandt     | Image Processing           |
| Srinivasan | &lt;span class=&quot;kw&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;System&lt;/span&gt; Concepts   |
| Kim        | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Digital Systems  |
| Wu         | Investment Banking         |
| El Said    | World History              |
| Mozart     | Music Video Production     |
| Einstein   | Physical Principles        |
+&lt;span class=&quot;co&quot;&gt;------------+----------------------------+&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; (&lt;span class=&quot;fl&quot;&gt;0.00&lt;/span&gt; sec)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的问题在于 course 关系和 instructor 关系中都包含了 dept_name 属性，因此它们自然连接的结果要在这个属性上相同，这样的查询会遗漏以下模式的元组对，教师所讲授的课程不是他所在系的课程，前一个查询能够正确输出这样的元组对。&lt;br/&gt;为了应付这个问题，即在保留自然连接的简洁性的同时规避过多的属性匹配，SQL 提供了一种自然连接的构造形式，允许用户来指定需要哪些列相等。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; name, title
    -&amp;gt; &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; (instructor &lt;span class=&quot;kw&quot;&gt;natural&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; teaches) &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; course &lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; (course_id);
+&lt;span class=&quot;co&quot;&gt;------------+----------------------------+&lt;/span&gt;
| name       | title                      |
+&lt;span class=&quot;co&quot;&gt;------------+----------------------------+&lt;/span&gt;
| Crick      | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Biology          |
| Crick      | Genetics                   |
| Srinivasan | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Computer Science |
| Katz       | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Computer Science |
| Brandt     | Game Design                |
| Brandt     | Game Design                |
| Srinivasan | Robotics                   |
| Katz       | Image Processing           |
| Brandt     | Image Processing           |
| Srinivasan | &lt;span class=&quot;kw&quot;&gt;Database&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;System&lt;/span&gt; Concepts   |
| Kim        | Intro. &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; Digital Systems  |
| Wu         | Investment Banking         |
| El Said    | World History              |
| Mozart     | Music Video Production     |
| Einstein   | Physical Principles        |
+&lt;span class=&quot;co&quot;&gt;------------+----------------------------+&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; (&lt;span class=&quot;fl&quot;&gt;0.00&lt;/span&gt; sec)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;join ... using&lt;/code&gt; 运算中需要给定一个属性名列表，其两个输入中都必须具有指定名称的属性，考虑运算 &lt;code&gt;r1 join r2 using (A1, A2)&lt;/code&gt;，它与 r1 和 r2 的自然连接类似，只不过在 &lt;code&gt;t1.A1 = t2.A1&lt;/code&gt; 且 &lt;code&gt;t1.A2 = t2.A2&lt;/code&gt; 的情况下就能匹配 r1 的元组 t1 和 r2 的元组 t2，即使它们都有属性 A3，也不考虑这个属性的事。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Apr 2018 16:14:00 +0000</pubDate>
<dc:creator>wander4096</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wander4096/p/8825099.html</dc:identifier>
</item>
<item>
<title>SSM（Spring）中，在工具类中调用服务层的方法 - 天生吾材</title>
<link>http://www.cnblogs.com/dz-boss/p/8825087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dz-boss/p/8825087.html</guid>
<description>&lt;p&gt;因为平时在调用service层时都是在controller中，有配置扫描注入，spring会根据配置自动注入所依赖的服务层。&lt;/p&gt;
&lt;p&gt;但因我们写的工具类不属于controller层，所以当所写接口需要调用服务层是，常常会为NULL。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关于工具类调用服务层的方法&lt;/span&gt;
    @Autowired  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入service层&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; VTcTbdwdmService vTcTbdwdmService;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在spring初始化之前，初始化一个静态类&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; MulConditionUtils mulConditionUtils;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义服务层的方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setVTcTbdwdmService(VTcTbdwdmService vTcTbdwdmService) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vTcTbdwdmService=&lt;span&gt;vTcTbdwdmService;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过@PostConstruct方法实现Bean初始化之前和销毁之前的自定义操作&lt;/span&gt;
&lt;span&gt;    @PostConstruct
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
        mulConditionUtils&lt;/span&gt;=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        mulConditionUtils.vTcTbdwdmService&lt;/span&gt;=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.vTcTbdwdmService; // 初使化时将已静态化的vTcTbdwdmService实例化
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;p&gt;关键点1:：private static MulConditionUtils mulConditionUtils;静态初使化 一个工具类  这样是为了在spring初使化之前&lt;/p&gt;
&lt;p&gt;关键点2：@PostConstruct；通过@PostConstruct 和 @PreDestroy 方法 实现初始化和销毁bean之前进行的操作&lt;/p&gt;
&lt;p&gt;具体调用服务层时：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
String allTbdwdm = mulConditionUtils.vTcTbdwdmService.getSonTbdwdm(newTbdw);
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 13 Apr 2018 16:08:00 +0000</pubDate>
<dc:creator>天生吾材</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dz-boss/p/8825087.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——38.  使用接口模拟可扩展的枚举 - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/8824754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/8824754.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。&lt;br/&gt;在这里第一时间翻译成中文版。供大家学习分享之用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4366140-ca5216df5c1029f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在几乎所有方面，枚举类型都优于本书第一版中描述的类型安全模式[Bloch01]。 从表面上看，一个例外涉及可扩展性，这在原始模式下是可能的，但不受语言结构支持。 换句话说，使用该模式，有可能使一个枚举类型扩展为另一个; 使用语言功能特性，它不能这样做。 这不是偶然的。 大多数情况下，枚举的可扩展性是一个糟糕的主意。 令人困惑的是，扩展类型的元素是基类型的实例，反之亦然。 枚举基本类型及其扩展的所有元素没有好的方法。 最后，可扩展性会使设计和实现的很多方面复杂化。&lt;/p&gt;
&lt;p&gt;也就是说，对于可扩展枚举类型至少有一个有说服力的用例，这就是操作码（ operation codes），也称为opcodes。 操作码是枚举类型，其元素表示某些机器上的操作，例如条目 34中的&lt;code&gt;Operation&lt;/code&gt;类型，它表示简单计算器上的功能。 有时需要让API的用户提供他们自己的操作，从而有效地扩展API提供的操作集。&lt;/p&gt;
&lt;p&gt;幸运的是，使用枚举类型有一个很好的方法来实现这种效果。基本思想是利用枚举类型可以通过为opcode类型定义一个接口，并实现任意接口。例如，这里是来自条目 34的&lt;code&gt;Operation&lt;/code&gt;类型的可扩展版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Emulated extensible enum using an interface
public interface Operation {
    double apply(double x, double y);
}


public enum BasicOperation implements Operation {
    PLUS(&quot;+&quot;) {
        public double apply(double x, double y) { return x + y; }
    },
    MINUS(&quot;-&quot;) {
        public double apply(double x, double y) { return x - y; }
    },
    TIMES(&quot;*&quot;) {
        public double apply(double x, double y) { return x * y; }
    },
    DIVIDE(&quot;/&quot;) {
        public double apply(double x, double y) { return x / y; }
    };
    private final String symbol;


    BasicOperation(String symbol) {
        this.symbol = symbol;
    }


    @Override public String toString() {
        return symbol;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然枚举类型（&lt;code&gt;BasicOperation&lt;/code&gt;）不可扩展，但接口类型（&lt;code&gt;Operation&lt;/code&gt;）是可以扩展的，并且它是用于表示API中的操作的接口类型。 你可以定义另一个实现此接口的枚举类型，并使用此新类型的实例来代替基本类型。 例如，假设想要定义前面所示的操作类型的扩展，包括指数运算和余数运算。 你所要做的就是编写一个实现&lt;code&gt;Operation&lt;/code&gt;接口的枚举类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Emulated extension enum
public enum ExtendedOperation implements Operation {
    EXP(&quot;^&quot;) {
        public double apply(double x, double y) {
            return Math.pow(x, y);
        }
    },
    REMAINDER(&quot;%&quot;) {
        public double apply(double x, double y) {
            return x % y;
        }
    };

    private final String symbol;

    ExtendedOperation(String symbol) {
        this.symbol = symbol;
    }

    @Override public String toString() {
        return symbol;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只要API编写为接口类型（&lt;code&gt;Operation&lt;/code&gt;），而不是实现（&lt;code&gt;BasicOperation&lt;/code&gt;），现在就可以在任何可以使用基本操作的地方使用新操作。请注意，不必在枚举中声明&lt;code&gt;apply&lt;/code&gt;抽象方法，就像您在具有实例特定方法实现的非扩展枚举中所做的那样（第162页）。 这是因为抽象方法（&lt;code&gt;apply&lt;/code&gt;）是接口（&lt;code&gt;Operation&lt;/code&gt;）的成员。&lt;/p&gt;
&lt;p&gt;不仅可以在任何需要“基本枚举”的地方传递“扩展枚举”的单个实例，而且还可以传入整个扩展枚举类型，并使用其元素。 例如，这里是第163页上的一个测试程序版本，它执行之前定义的所有扩展操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    double x = Double.parseDouble(args[0]);
    double y = Double.parseDouble(args[1]);
    test(ExtendedOperation.class, x, y);
}


private static &amp;lt;T extends Enum&amp;lt;T&amp;gt; &amp;amp; Operation&amp;gt; void test(
        Class&amp;lt;T&amp;gt; opEnumType, double x, double y) {
    for (Operation op : opEnumType.getEnumConstants())
        System.out.printf(&quot;%f %s %f = %f%n&quot;,
                          x, op, y, op.apply(x, y));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，扩展的操作类型的类字面文字（&lt;code&gt;ExtendedOperation.class&lt;/code&gt;）从&lt;code&gt;main&lt;/code&gt;方法里传递给了&lt;code&gt;test&lt;/code&gt;方法，用来描述扩展操作的集合。这个类的字面文字用作限定的类型令牌（条目 33）。&lt;code&gt;opEnumType&lt;/code&gt;参数中复杂的声明（&lt;code&gt;&amp;lt;T extends Enum&amp;lt;T&amp;gt; &amp;amp; Operation&amp;gt; Class&amp;lt;T&amp;gt;&lt;/code&gt;）确保了Class对象既是枚举又是&lt;code&gt;Operation&lt;/code&gt;的子类，这正是遍历元素和执行每个元素相关联的操作时所需要的。&lt;/p&gt;
&lt;p&gt;第二种方式是传递一个&lt;code&gt;Collection&amp;lt;? extends Operation&amp;gt;&lt;/code&gt;，这是一个限定通配符类型（条目 31），而不是传递了一个class对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) {
    double x = Double.parseDouble(args[0]);
    double y = Double.parseDouble(args[1]);
    test(Arrays.asList(ExtendedOperation.values()), x, y);
}

private static void test(Collection&amp;lt;? extends Operation&amp;gt; opSet,
        double x, double y) {
    for (Operation op : opSet)
        System.out.printf(&quot;%f %s %f = %f%n&quot;,
                          x, op, y, op.apply(x, y));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的代码稍微不那么复杂，&lt;code&gt;tes&lt;/code&gt;t方法灵活一点：它允许调用者将多个实现类型的操作组合在一起。另一方面，也放弃了在指定操作上使用&lt;code&gt;EnumSe&lt;/code&gt;t(条目 36)和&lt;code&gt;EnumMap&lt;/code&gt;(条目 37)的能力。&lt;/p&gt;
&lt;p&gt;上面的两个程序在运行命令行输入参数4和2时生成以下输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;4.000000 ^ 2.000000 = 16.000000
4.000000 % 2.000000 = 0.000000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用接口来模拟可扩展枚举的一个小缺点是，实现不能从一个枚举类型继承到另一个枚举类型。如果实现代码不依赖于任何状态，则可以使用默认实现(条目 20)将其放置在接口中。在我们的&lt;code&gt;Operation&lt;/code&gt;示例中，存储和检索与操作关联的符号的逻辑必须在&lt;code&gt;BasicOperation&lt;/code&gt;和&lt;code&gt;ExtendedOperation&lt;/code&gt;中重复。在这种情况下，这并不重要，因为很少的代码是冗余的。如果有更多的共享功能，可以将其封装在辅助类或静态辅助方法中，以消除代码冗余。&lt;/p&gt;
&lt;p&gt;该条目中描述的模式在Java类库中有所使用。例如，&lt;code&gt;java.nio.file.LinkOption&lt;/code&gt;枚举类型实现了&lt;code&gt;CopyOption&lt;/code&gt;和&lt;code&gt;OpenOption&lt;/code&gt;接口。&lt;/p&gt;
&lt;p&gt;总之，&lt;strong&gt;虽然不能编写可扩展的枚举类型，但是你可以编写一个接口来配合实现接口的基本的枚举类型，来对它进行模拟&lt;/strong&gt;。这允许客户端编写自己的枚举（或其它类型）来实现接口。如果API是根据接口编写的，那么在任何使用基本枚举类型实例的地方，都可以使用这些枚举类型实例。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Apr 2018 15:30:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/8824754.html</dc:identifier>
</item>
<item>
<title>深入理解.net - 1.继承的本质 - Nuss</title>
<link>http://www.cnblogs.com/Nuss/p/8748666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Nuss/p/8748666.html</guid>
<description>&lt;p&gt;最近偶然看到这个博客&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/anytao/archive/2007/04/06/must_net_00.html&quot;&gt;你必须知道的.net&lt;/a&gt;&lt;/strong&gt;，作者6的飞起啊，干货十足，还是07年写的。。。写的也很赞，评论更精彩，在此强烈推荐一波，看的感觉就像沙漠里发现了绿洲一样，很兴奋，意犹未尽，迫不及待的看完一篇再看下一篇，但是知识还是需要整理，沉淀的，那就写博客吧，于是有了接下来的文章。本文将通过看此书和相关博客以及结合自己目前的理解所写，如有不对之处，欢迎指正。&lt;/p&gt;
&lt;h2 id=&quot;对象的创建过程&quot;&gt;对象的创建过程&lt;/h2&gt;
&lt;p&gt;要了解继承的本质首先我们要清楚一个对象的创建过程，这里有个 Chicken 类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Chicken 
{
    private  string type = &quot;Chicken&quot;;
    
    public Chicken()
    {
    }
    
    public void ShowType()
    {            
        Console.WriteLine($&quot;Type is {type}&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们需要使用这个类的时候，我们通常是这样写的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Chicken chicken = new Chicken(); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它是如何工作的呢？先上图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1142573/201804/1142573-20180410235844089-990915058.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先执行的是 &quot;Chicken chicken&quot; 语句，即线程栈Stack上声明了一个Chicken类型的引用chicken，此时值为null，Stack上内存分配由高到低地址开始创建， 而Heap上则相反；&lt;/li&gt;
&lt;li&gt;执行 &quot;new Chicken()&quot; ，new 操作符会在托管堆（具体在GCH：Garbage Collection Heap）上申请创建实例的内存空间，初始化类的字段（Feild）信息，并调用构造函数。结合上图，实例在GCHeap创建的详细过程如下：
&lt;ul&gt;&lt;li&gt;对象实例地址的开始4个字节为SyncBlockIndex，指向SyncEntryTable,存储的是多线程同步的一些信息，详细内容可查看文章末尾参考连接；&lt;/li&gt;
&lt;li&gt;紧接着是TypeHandle,指向的是Loader Heap（加载器堆） 中的MethodTable，而MethodTable中存储该类型的静态字段，方法表以及实现的接口等信息，从这里我们也就清楚了，一个类不管实例成员有多少，static成员和方法信息只存储一份在内存中，并先于实例创建，使用的时候则通过TypeHandle到MethodTable查找，并编译成cpu指令，存储在内存中，以后再使用时则直接执行该指令即可。&lt;/li&gt;
&lt;li&gt;初始完SyncBlockIndex和TypeHandle，则加载Chicken类型的字段信息，本文初始的也就是type字段（&lt;em&gt;字符串信息的存储比较特殊实际存储模型&lt;a href=&quot;http://www.cnblogs.com/artech/archive/2010/10/18/1855122.html&quot;&gt;详见此链接&lt;/a&gt;&lt;/em&gt;），另外强调的是属性不在此处初始，属性本质上还是 **_Get/**_Set方法；&lt;/li&gt;
&lt;li&gt;初始完字段后，则调用构造函数Chicken(),并返回this。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;3.最后将this赋值给Stack上的chicken引用类型，即chicken维护一个指向heap上Chicken实例的指针，实际stact上的chicken存储的是GCHeap上实例存储的地址；&lt;/p&gt;
&lt;h2 id=&quot;继承的本质&quot;&gt;继承的本质&lt;/h2&gt;
&lt;p&gt;如果你看到这里，那说明你已经对一个对象的创建过程有了清晰的认识。回归主题那继承的本质是什么？先别急，下面我们写一个 Animal 类，让上文中的Chicken类继承它，并重写父类中的ShowType方法，&lt;em&gt;本示例代码参考书中示例略微有所调整&lt;/em&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Animal 
{
    private string type =&quot;Animal&quot;;

    public Animal()
    {

    }

    public virtual void ShowType()
    {
        Console.WriteLine($&quot;Type is {type}&quot;);
    }
}
public class Chicken : Animal
{
    public string type = &quot;Chicken&quot;;

    public Chicken()
    {
    }
    
    public override void ShowType()
    {            
        Console.WriteLine($&quot;Type is {type}&quot;);
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这个时候我们去执行 Chicken chicken = new Chicken(); 发生了什么呢？&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1142573/201804/1142573-20180413223703596-252994622.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据上图我们可以很直观的看出（此处暂时不考虑Object）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先会先初始化chicken.type 字段，然后调用Chicken 构造函数；&lt;/li&gt;
&lt;li&gt;此时编译器发现还有父类则去为父类Animal 申请内存，即初始Animal.type 字段，然后调用Animal的构造函数；因为所有类型都是继承自System.Object 所以实际上会一直遍历到Object类型；此外从这个过程中我们也可以发现子类是可以继承父类私有成员信息，即chicken可以继承Animal的type字段，字段存储顺序是父类在前子类在后，跟踪截图如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1142573/201804/1142573-20180413230547440-1689873228.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Animal()方法体执行完后，然后在执行Chicken()的方法体。&lt;/li&gt;
&lt;li&gt;此处额外说下关于方法的加载，在继承过程子类会将父类中的方法copy一份，并将重写的方法覆盖掉父类中的方法，这也就为多态提供了基础。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;写这篇博客参考了不少其它牛人的博客，发现关于这块往深里东西还有很多，如AppDomain应用程序域，ManagerHeap可以分多种不同的类型，GC对不同的Heap处理规则也是不同的，近期也会持续分享相关内容。写博文期间内容也不断反复调整了几轮，希望在此我都表达清楚了，限于篇幅主要内容还是关于对象和继承的本质过程，内容基本上也都是根据自己的理解写出来的，难免有疏漏的地方，如有不对的对方还请指出，那将是我不断进步的源泉:-)。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
</description>
<pubDate>Fri, 13 Apr 2018 15:25:00 +0000</pubDate>
<dc:creator>Nuss</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Nuss/p/8748666.html</dc:identifier>
</item>
<item>
<title>换个视角来看git命令与代码库发生网络交互报错事件 - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/8824660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/8824660.html</guid>
<description>&lt;p&gt;　　git的一系列命令中像 clone、pull、push等与代码库发生网络交互时，可能报下面的错误信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;fatal: remote error: CAPTCHA required
Your Stash account has been marked as requiring a CAPTCHA to be solved before
you may login again. This is typically caused by too many attempts to login
&lt;/span&gt;&lt;span&gt;with&lt;/span&gt;&lt;span&gt; an incorrect password. The required CAPTCHA prevents your SCM client from
accessing Stash until it is solved, even &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; you enter your password correctly.

If you are currently logged &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; to Stash via a browser you may need to logout
and then log back &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; order to clear the CAPTCHA.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从报错信息来看，大概的意思是：“你的容器账号在登陆之前需要进行验证，这是因为登陆时太多的密码错误造成的。虽然你当前输入的密码正确，但是这个验证码拒绝客户端访问容器直到这个问题解决。”&lt;/p&gt;
&lt;p&gt;　　这个问题如何解决呢？&lt;/p&gt;
&lt;p&gt;　　这里面提到了一个单词“ CAPTCHA”意思是验证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/826860/201804/826860-20180413225837019-1577356254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面提到的“验证”是否就是图中的验证码概念呢？&lt;/p&gt;
&lt;p&gt;　　我们来逻辑推测一把。&lt;/p&gt;
&lt;p&gt;　　以clone为例子，git执行clone命令，首先需要有可以到代码库中访问代码的权利。我们平时在网页登陆时一般都是通过填写用户名＋密码。不过当网页在登陆时密码连续多次输入错误，下面就会出现“验证码”图片让我们点击。我写到这里是不是恍然明白了什么？没错，这个“ CAPTCHA”就是在git访问代码库时出现的“验证码图片”。惊喜不惊喜，意外不惊喜。原来我们平时使用的命令走的路子也是和我们手动页面操作一样。&lt;/p&gt;
&lt;p&gt;　　知道这个原因后，我们修改报错就迎刃而解了。这里我们采用最直观，看起来与这个报错不相关的方式。“1.打开登陆网页，输入正确的用户名＋密码登陆进去。2.退出登陆。重新再输入正确的用户名＋密码登陆进去。”如此这两次操作，就可以保证再次在页面登陆时，不会弹出“验证码图片”。此时再执行git clone命令。报错消失。顺利拿到了想要的代码。&lt;/p&gt;

</description>
<pubDate>Fri, 13 Apr 2018 15:19:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/8824660.html</dc:identifier>
</item>
<item>
<title>使用生成器把Kafka写入速度提高1000倍 - 青南</title>
<link>http://www.cnblogs.com/xieqiankun/p/use_yield_correctly.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieqiankun/p/use_yield_correctly.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;title: 使用生成器把Kafka写入速度提高1000倍&lt;br/&gt;toc: true&lt;br/&gt;comment: true&lt;br/&gt;date: 2018-04-13 21:35:09&lt;br/&gt;tags: ['Python', '经验']&lt;br/&gt;category: ['Python']&lt;br/&gt;---&lt;/p&gt;
&lt;p&gt;通过本文你会知道Python里面什么时候用yield最合适。本文不会给你讲生成器是什么，所以你需要先了解Python的yield，再来看本文。&lt;/p&gt;
&lt;h2 id=&quot;疑惑&quot;&gt;疑惑&lt;/h2&gt;
&lt;p&gt;多年以前，当我刚刚开始学习Python协程的时候，我看到绝大多数的文章都举了一个生产者-消费者的例子，用来表示在生产者内部可以随时调用消费者，达到和多线程相同的效果。这里凭记忆简单还原一下当年我看到的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; time


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; consumer():
    product &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;:
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; product &lt;span class=&quot;op&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;:
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'consumer: {}'&lt;/span&gt;.&lt;span class=&quot;bu&quot;&gt;format&lt;/span&gt;(product))
        product &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; producer():
    c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; consumer()
    &lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(c)
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;):
        c.send(i)

start &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
producer()
end &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f&lt;span class=&quot;st&quot;&gt;'直到把所有数据塞入Kafka，一共耗时：{end - start}秒'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2018-04-13-23-05-55.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些文章的说法，就像统一好了口径一样，说这样写可以减少线程切换开销，从而大大提高程序的运行效率。但是当年我始终想不明白，这种写法与直接调用函数有什么区别，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2018-04-13-21-51-37.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直到后来我需要操作Kafka的时候，我明白了使用yield的好处。&lt;/p&gt;
&lt;h2 id=&quot;探索&quot;&gt;探索&lt;/h2&gt;
&lt;p&gt;为了便于理解，我会把实际场景做一些简化，以方便说明事件的产生发展和解决过程。事件的起因是我需要把一些信息写入到Kafka中，我的代码一开始是这样的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; time
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; pykafka &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; KafkaClient

client &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; KafkaClient(hosts&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1:9092&quot;&lt;/span&gt;)
topic &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; client.topics[b&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;]


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; consumer(product):
    &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; topic.get_producer(delivery_reports&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; producer:
        producer.produce(&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(product).encode())


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; feed():
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;):
        consumer(i)


start &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
feed()
end &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f&lt;span class=&quot;st&quot;&gt;'直到把所有数据塞入Kafka，一共耗时：{end - start}秒'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码的运行效果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/witoutyield1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写入10条数据需要100秒，这样的龟速显然是有问题的。问题就出在这一句代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; topic.get_producer(delivery_reports&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; producer&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获得Kafka生产者对象是一个非常耗费时间的过程，每获取一次都需要10秒钟才能完成。所以写入10个数据就获取十次生产者对象。这消耗的100秒主要就是在获取生产者对象，而真正写入数据的时间短到可以忽略不计。&lt;/p&gt;
&lt;p&gt;由于生产者对象是可以复用的，于是我对代码作了一些修改：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; time
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; pykafka &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; KafkaClient

client &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; KafkaClient(hosts&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1:9092&quot;&lt;/span&gt;)
topic &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; client.topics[b&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;]
products &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; consumer(product_list):
    &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; topic.get_producer(delivery_reports&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; producer:
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; product &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; product_list:
            producer.produce(&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(product).encode())


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; feed():
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;):
        products.append(i)
    consumer(products)


start &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
feed()
end &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f&lt;span class=&quot;st&quot;&gt;'直到把所有数据塞入Kafka，一共耗时：{end - start}秒'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先把所有数据存放在一个列表中，最后再一次性给consumer函数。在一个Kafka生产者对象中展开列表，再把数据一条一条塞入Kafka。这样由于只需要获取一次生产者对象，所以需要耗费的时间大大缩短，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/witoutyield2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种写法在数据量小的时候是没有问题的，但数据量一旦大起来，如果全部先放在一个列表里面的话，服务器内存就爆了。&lt;/p&gt;
&lt;p&gt;于是我又修改了代码。每100条数据保存一次，并清空暂存的列表：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; time
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; pykafka &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; KafkaClient

client &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; KafkaClient(hosts&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1:9092&quot;&lt;/span&gt;)
topic &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; client.topics[b&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;]


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; consumer(product_list):
    &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; topic.get_producer(delivery_reports&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; producer:
        &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; product &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; product_list:
            producer.produce(&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(product).encode())


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; feed():
    products &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1003&lt;/span&gt;):
        products.append(i)
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(products) &lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;:
            consumer(products)
            products &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; []

    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; products:
        consumer(products)


start &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
feed()
end &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f&lt;span class=&quot;st&quot;&gt;'直到把所有数据塞入Kafka，一共耗时：{end - start}秒'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于最后一轮循环可能无法凑够100条数据，所以&lt;code&gt;feed&lt;/code&gt;函数里面，循环结束以后还需要判断&lt;code&gt;products&lt;/code&gt;列表是否为空，如果不为空，还要再消费一次。这样的写法，在上面这段代码中，一共1003条数据，每100条数据获取一次生产者对象，那么需要获取11次生产者对象，耗时至少为110秒。&lt;/p&gt;
&lt;p&gt;显然，要解决这个问题，最直接的办法就是减少获取Kafka生产者对象的次数并最大限度复用生产者对象。如果读者举一反三的能力比较强，那么根据开关文件的两种写法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 写法一&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test.txt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'w'&lt;/span&gt;, encoding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'utf-8'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; f:
    f.write(&lt;span class=&quot;st&quot;&gt;'xxx'&lt;/span&gt;)
    
&lt;span class=&quot;co&quot;&gt;# 写法二&lt;/span&gt;
f &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'test.txt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'w'&lt;/span&gt;, encoding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'utf-8'&lt;/span&gt;)
f.write(&lt;span class=&quot;st&quot;&gt;'xxx'&lt;/span&gt;)
f.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以推测出获取Kafka生产者对象的另一种写法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 写法二&lt;/span&gt;
producer &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; topic.get_producer(delivery_reports&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)
producer.produce(b&lt;span class=&quot;st&quot;&gt;'xxxx'&lt;/span&gt;)
producer.close()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一来，只要获取一次生产者对象并把它作为全局变量就可以一直使用了。&lt;/p&gt;
&lt;p&gt;然而，pykafka的官方文档中使用的是第一种写法，通过上下文管理器&lt;code&gt;with&lt;/code&gt;来获得生产者对象。暂且不论第二种方式是否会报错，只从写法上来说，第二种方式必需要手动关闭对象。开发者经常会出现开了忘记关的情况，从而导致很多问题。而且如果中间出现了异常，使用上下文管理器的第一种方式会自动关闭生产者对象，但第二种方式仍然需要开发者手动关闭。&lt;/p&gt;
&lt;h2 id=&quot;函数vs生成器&quot;&gt;函数VS生成器&lt;/h2&gt;
&lt;p&gt;但是如果使用第一种方式，怎么能在一个上下文里面接收生产者传进来的数据呢？这个时候才是yield派上用场的时候。&lt;/p&gt;
&lt;p&gt;首先需要明白，使用yield以后，函数就变成了一个生成器。生成器与普通函数的不同之处可以通过下面两段代码来进行说明：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; funciton(i):
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'进入'&lt;/span&gt;)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(i)
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'结束'&lt;/span&gt;)

&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;):
    funciton(i)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2018-04-13-22-29-40.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;函数在被调用的时候，函数会从里面的第一行代码一直运行到某个&lt;code&gt;return&lt;/code&gt;或者函数的最后一行才会退出。&lt;/p&gt;
&lt;p&gt;而生成器可以从中间开始运行，从中间跳出。例如下面的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; generator():
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'进入'&lt;/span&gt;)
    i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;:
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;:
            &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(i)
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'跳出'&lt;/span&gt;)
        i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;

g &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; generator()
&lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(g)
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;):
    g.send(i)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果如下图所示。&lt;br/&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/2018-04-13-23-09-43.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，&lt;code&gt;进入&lt;/code&gt;只打印了一次。代码运行到&lt;code&gt;i = yield None&lt;/code&gt;后就跳到外面，外面的数据可以通过&lt;code&gt;g.send(i)&lt;/code&gt;的形式传进生成器，生成器内部拿到外面传进来的数据以后继续执行下一轮&lt;code&gt;while&lt;/code&gt;循环，打印出被传进来的内容，然后到&lt;code&gt;i = yield None&lt;/code&gt;的时候又跳出。如此反复。&lt;/p&gt;
&lt;p&gt;所以回到最开始的Kafka问题。如果把&lt;code&gt;with topic.get_producer(delivery_reports=True) as producer&lt;/code&gt;写在上面这一段代码的&lt;code&gt;print('进入')&lt;/code&gt;这个位置上，那岂不是只需要获取一次Kafka生产者对象，然后就可以一直使用了？&lt;/p&gt;
&lt;p&gt;根据这个逻辑，设计如下代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; time
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; pykafka &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; KafkaClient

client &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; KafkaClient(hosts&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1:9092&quot;&lt;/span&gt;)
topic &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; client.topics[b&lt;span class=&quot;st&quot;&gt;'test'&lt;/span&gt;]


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; consumer():
    &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; topic.get_producer(delivery_reports&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; producer:
        &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'init finished..'&lt;/span&gt;)
        next_data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;:
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; next_data:
                producer.produce(&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;(next_data).encode())
            next_data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;


&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; feed():
    c &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; consumer()
    &lt;span class=&quot;bu&quot;&gt;next&lt;/span&gt;(c)
    &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;):
        c.send(i)

start &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
feed()
end &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; time.time()
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(f&lt;span class=&quot;st&quot;&gt;'直到把所有数据塞入Kafka，一共耗时：{end - start}秒'&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一次直接插入1000条数据，总共只需要10秒钟，相比于每插入一次都获取一次Kafka生产者对象的方法，效率提高了1000倍。运行效果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7sbpmp.com1.z0.glb.clouddn.com/withyield.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;读者如果仔细对比第一段代码和最后一段代码，就会发现他们本质上是一回事。但是第一段代码，也就是网上很多人讲yield的时候举的生产者-消费者的例子之所以会让人觉得毫无用处，就在于他们的消费者几乎就是秒运行，这样看不出和函数调用的差别。而我最后这一段代码，它的消费者分成两个部分，第一部分是获取Kafka生产者对象，这个过程非常耗时；第二部分是把数据通过Kafka生产者对象插入Kafka，这一部分运行速度极快。在这种情况下，使用生成器把这个消费者代码分开，让耗时长的部分只运行一次，让耗时短的反复运行，这样就能体现出生成器的优势。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Apr 2018 15:17:00 +0000</pubDate>
<dc:creator>青南</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieqiankun/p/use_yield_correctly.html</dc:identifier>
</item>
</channel>
</rss>