<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>野生前端的数据结构基础练习（8）——图 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10030035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10030035.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201811/26/3683ba6e7d8a56107602dbbc5cd93532.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.5593220338983&quot;&gt;
&lt;p&gt;网上的相关教程非常多，基础知识自行搜索即可。&lt;/p&gt;
&lt;p&gt;习题主要选自Orelly出版的《数据结构与算法javascript描述》一书。&lt;/p&gt;
&lt;p&gt;参考代码可见:&lt;a href=&quot;https://github.com/dashnowords/blogs/tree/master/Structure/graph&quot; class=&quot;uri&quot;&gt;https://github.com/dashnowords/blogs/tree/master/Structure/graph&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一.图的基本知识&quot;&gt;一.图的基本知识&lt;/h3&gt;
&lt;h4 id=&quot;基本概念&quot;&gt;基本概念&lt;/h4&gt;
&lt;p&gt;图是由边的集合和点的集合组成的。如果图的边有方向（或者说图中的顶点对是有序的）则成为&lt;strong&gt;有向图&lt;/strong&gt;，如果边没有方向则称为&lt;strong&gt;无向图&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;基本建模&quot;&gt;基本建模&lt;/h4&gt;
&lt;p&gt;图可以用来对现实中许多事物进行建模。比如交通流量，计算机网络等。&lt;/p&gt;
&lt;h3 id=&quot;二.基本练习&quot;&gt;二.基本练习&lt;/h3&gt;
&lt;ol readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;构建一个图的类&lt;code&gt;Graph&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;图的深度优先搜索（DFS）&lt;/p&gt;
&lt;p&gt;深度优先搜索从起始顶点开始，直到到达最后一个顶点，然后回溯，直到遍历完随后顶点或查找到指定顶点。深度优先是应用非常广泛的基本搜索思想，往往借助&lt;code&gt;栈&lt;/code&gt;结构来实现。demo中的&lt;code&gt;dfs.js&lt;/code&gt;直接使用函数的调用栈来追踪搜索，如果数据量很大，则可以通过手动用一个数组来管理&lt;code&gt;栈&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;图的广度优先搜索（BFS）&lt;/p&gt;
&lt;p&gt;广度优先搜索从第一个顶点开始，尝试访问尽可能靠近它的顶点，搜索范围基本是逐层移动的。它的实现依靠数据结构中的&lt;code&gt;队列&lt;/code&gt;来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;BFS查找最短路径&lt;/p&gt;
&lt;p&gt;图最常见的操作之一就是寻找从一个顶点到另一个顶点的最短路径。书中示例中通过&lt;code&gt;this.edgeTo&lt;/code&gt;这个数组来存储顶点的访问路径，例如w节点是通过访问v节点的临近节点时访问的，那么就执行如下赋值&lt;code&gt;this.edgeTo[w] = v&lt;/code&gt;，并将节点标记为已访问，由于广度优先搜索逐层扩展的特性，最终通过&lt;code&gt;this.edgeTo&lt;/code&gt;迭代显示出的路径必然是搜索中最先实现标记的路径，也就是最短的路径，所以并不需要将每次访问都记录下来最终再比较步长。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;拓扑排序&lt;/p&gt;
&lt;p&gt;拓扑排序用于输出一个有向无环图所有顶点的线性序列，使之满足：&lt;/p&gt;
&lt;p&gt;a 每个顶点只出现一次&lt;/p&gt;
&lt;p&gt;b 若存在一条从顶点A到B的路径，那么序列中A一定出现在B前面。&lt;/p&gt;
&lt;p&gt;书中给出的示例在输出时描述有误，导致输出结果与真实的排序是相反的，在拓扑排序时采用了&lt;code&gt;栈&lt;/code&gt;结构，入栈顺序是反的，正确的输出顺序是按照出栈顺序来输出。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;三.小结&quot;&gt;三.小结&lt;/h3&gt;
&lt;p&gt;图论是非常复杂的领域，对数学基础要求较高，感兴趣的读者可以自行继续研究。至此，基本数据结构的课就补完了，希望你也认真做了练习，完成了这个基本的扫盲过程。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 23:08:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>网上的相关教程非常多，基础知识自行搜索即可。 习题主要选自Orelly出版的《数据结构与算法javascript描述》一书。 参考代码可见:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10030035.html</dc:identifier>
</item>
<item>
<title>Linux定时任务调度 - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/10029926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/10029926.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;crond 任务调度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;crontab 进行 定时任务的设置，。&lt;/p&gt;
&lt;p&gt;概述&lt;/p&gt;
&lt;p&gt;    任务调度：是指系统在某个时间执行的特定的命令或程序。&lt;/p&gt;
&lt;p&gt;    任务调度分类：1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等&lt;/p&gt;
&lt;p&gt;    2.个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份。&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
&lt;p&gt;    crontab [选项]&lt;/p&gt;
&lt;p&gt;常用选项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181128001932946-1957731272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181128001938020-219685987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181128002004302-1951175272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181128002015267-693938868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181128002024589-1221346158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181128002038717-398925268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181128002053278-1542352466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@MrChengs tmp]# crontab -&lt;span&gt;r
[root@MrChengs tmp]# 
[root@MrChengs tmp]#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181128002109839-1908363543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201811/1488757-20181128002115141-1194071392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 27 Nov 2018 16:22:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>crond 任务调度 crontab 进行 定时任务的设置，。 概述 任务调度：是指系统在某个时间执行的特定的命令或程序。 任务调度分类：1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/10029926.html</dc:identifier>
</item>
<item>
<title>分布式程序如何进行线上灰度自动化验收? - 大卡尔</title>
<link>http://www.cnblogs.com/jinsdu/p/10029837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinsdu/p/10029837.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前面在&lt;a href=&quot;https://www.cnblogs.com/jinsdu/p/7507887.html&quot;&gt;如何负责一个项目的质量保证工作&lt;/a&gt;一文中，笔者将质量保障划分为三个阶段，研发质量，上线质量和线上质量。其中针对上线流程，特别提到灰度阶段，QA应该提供相应的验收机制。今天来具体说说&lt;br/&gt;，针对分布式程序如何打造一个方便好用的灰度验收工具。&lt;/p&gt;
&lt;p&gt;我们知道，绝大多数分布式程序天然的支持灰度迭代，通过有序的, 分批次的迭代上线，能够有效的控制故障规模，起到发布中验收的效果。但即使这样，如果基础设施不够完善，还是没办法做到无损灰度的。出了问题，实际仍然是有用户感知，只不过范围较小而已。&lt;/p&gt;
&lt;p&gt;线上发布，多数是SRE运维同学操作，他们很有可能不清楚业务细节，比较欠缺验收手段。多数情况下，发布部署的同学主要依靠查看日志和监控告警手段来验收发布。但其实这样非常的被动, 如果是监控告警触发报障，情况可能还好，运维同学会很快感知，快速止损。但如果是客户报障，一来一去时间上就会很长，如果稍微影响的客户多些，就是一例事故。&lt;/p&gt;
&lt;p&gt;举个极端例子，比如一个面向用户的接口，因为bug导致用户正常请求在特定场合会返回4xx。如果带着这种bug去灰度，很有可能监控告警层面不会感知，因为4xx在HTTP协议中属于客户端问题，运维同学一般会排除此类code的告警。而客户遇到此类问题，也有可能会首先怀疑自己的行为是否正确，所以到爆发时，影响面可能就比较大。&lt;/p&gt;
&lt;p&gt;然而针对这种用户场景的测试，QA是有验收手段的。&lt;br/&gt;在实际业务迭代中，QA一般都会产出自动化测试，所以就可以通过这些自动化用例，单独对灰度的实例进行验收，确保发布符合预期。&lt;/p&gt;
&lt;p&gt;然而理想很丰满，现实却骨感。实际上多数自动化测试用例并不是那么方便的，去交付别人去使用。它有其复杂性，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务端的产品，测试框架多数是基于配置文件来适配不同的测试环境，不同的测试账号。日记月累下，测试配置有可能会比较复杂。而让不懂这块的人去改这些配置，心智成本较高。&lt;/li&gt;
&lt;li&gt;测试框架为满足多样性的需求，会越做越复杂，比如golang领域的ginkgo，功能很丰富，支持并发的跑用例，focus or skip的组合，递归遍历等，对不熟悉的使用者来讲会造成困扰。&lt;/li&gt;
&lt;li&gt;QA的测试用例可能包含多种层次类型，比如集成，e2e，或者破坏性的。而破坏性的用例，必须确保不能在线上执行，这点很重要。&lt;/li&gt;
&lt;li&gt;测试数据如何方便的快捷准备，也是需要考量的.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了测试用例本身的复杂性之外，还需要考虑用例的更新机制，以及分发机制。&lt;/p&gt;
&lt;p&gt;所以若想将测试用例交付部署人员来使用，必须解决其易用性,安全性问题,降低使用者的心智负担。&lt;/p&gt;
&lt;h2 id=&quot;interface-for-tests-execution&quot;&gt;Interface for Tests Execution&lt;/h2&gt;
&lt;p&gt;一个可行的方案就是构建一个interface程序，专门用于运行测试用例，将所有的复杂性问题都封装起来，做到对使用者友好：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;比如可以内置所有配置到二进制程序中，并能让使用者方便的选择使用范围&lt;/li&gt;
&lt;li&gt;还要能提供简单方式，其使用者指定灰度服务的IP地址，做到针对性测试&lt;/li&gt;
&lt;li&gt;一键准备测试数据，最好让使用者无感知&lt;/li&gt;
&lt;li&gt;固定使用姿势，不给使用者犯错的机会&lt;/li&gt;
&lt;li&gt;工具要有清晰的help文档，随用随学&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至于分发问题，就可以将程序托管在公有云存储上，通过shell脚本，一键下载。这种方案会极大的降低使用者的心智负担，对测试服务的推广非常有益。&lt;/p&gt;
&lt;p&gt;kubernetes test infra中的Kubetest也是这种思想的的典型代表。&lt;/p&gt;
&lt;h2 id=&quot;test-as-a-service&quot;&gt;Test as a Service&lt;/h2&gt;
&lt;p&gt;业界，大家一直在探寻QA的转型之路，不管是左移还是右移，或者是工程效率层面，测试服务的输出都是其中非常有价值的topic。笔者认为，QA不光要拥有业务质量的全局视角，还要能发现业务痛点，然后围绕质量方向，打造高价值产品或平台，以此来输出质量保障服务。测试不在于人，而在于服务。测试服务不是测试同学的玩物，应该是围绕解决如何保证业务质量的难题。同时，单个人，或者单个组织来做质量保证必有其局限性，质量全员建设才是王道。&lt;/p&gt;
&lt;p&gt;提供这种灰度验收的工具，其实也是对QA的测试用例提出了更高要求，只有持续保障其稳定，高效，才能不断产生价值。&lt;/p&gt;

&lt;p&gt;Email: jinsdu@outlook.com&lt;/p&gt;
&lt;p&gt;Blog: &lt;a href=&quot;http://www.cnblogs.com/jinsdu/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/jinsdu/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/CarlJi&quot; class=&quot;uri&quot;&gt;https://github.com/CarlJi&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 15:53:00 +0000</pubDate>
<dc:creator>大卡尔</dc:creator>
<og:description>前言 前面在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinsdu/p/10029837.html</dc:identifier>
</item>
<item>
<title>vue 与原生app的对接交互（混合开发） - 华猿</title>
<link>http://www.cnblogs.com/nogodie/p/10029858.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nogodie/p/10029858.html</guid>
<description>&lt;p&gt;小伙伴们在用vue开发h5项目特别是移动端的项目，很多都是打包后挂载在原生APP上的，那就少不了与原生交互了，我最近就是在坐这个，踩了一些坑，拿出来给大家分享下。&lt;/p&gt;
&lt;h3&gt;0.通过url传输数据：（一般是在入口页面传下app的用户信息进来供vue h5使用）&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;methods: {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收url后的数据&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            urltext() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 let loc =&lt;span&gt; location.href;  &lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 let n1 = loc.length;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地址的总长度&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 let n2 = loc.indexOf(&quot;=&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得=号的位置&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;                 let outToken = loc.substr(n2 + 1, n1 - n2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从=号后面的内容&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                console.log(loc,n1,n2,outToken)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;.outTokenPost(outToken)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传到处理函数&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            },
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.原生APP提供一个接口对象的引用（例如一个扫码的接口，可能还有回调函数以获得扫码结果）&lt;/h3&gt;
&lt;p&gt;思路就是万物通过window 进行交互&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
// 将vue组件的要回调的函数暴露出去&lt;br/&gt;mounted:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将subscanQRCallBack方法绑定到window下面，提供给外部调用&lt;/span&gt;
                window['scanQRCallBack'] = (result) =&amp;gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.subscanQRCallBack(result)
                }
     
        },&lt;br/&gt;methods:{
            scan(){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; alert('开始扫码了')&lt;/span&gt;
                window.client.startScanQR('OS与js交互'&lt;span&gt;,scanQRCallBack)　　// 通过window调用app提供的client对象
            },

            subscanQRCallBack(result){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; alert('扫码结果6466：'+result);&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.scanPost(result)
            },&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 27 Nov 2018 15:49:00 +0000</pubDate>
<dc:creator>华猿</dc:creator>
<og:description>小伙伴们在用vue开发h5项目特别是移动端的项目，很多都是打包后挂载在原生APP上的，那就少不了与原生交互了，我最近就是在坐这个，踩了一些坑，拿出来给大家分享下。 0.通过url传输数据：（一般是在入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nogodie/p/10029858.html</dc:identifier>
</item>
<item>
<title>经典案例那个什么多线程--卖票..........................就是好像有点不对~~！先写下来.有大哥哥，大姐姐帮看下吗 - 北九北</title>
<link>http://www.cnblogs.com/peng1314/p/10029807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng1314/p/10029807.html</guid>
<description>&lt;p&gt;package javawork;&lt;/p&gt;
&lt;p&gt;public class RunnableDemo2 {&lt;/p&gt;
&lt;p&gt;public static void main(String[] args) {&lt;br/&gt;Runnable02 ru = new Runnable02();&lt;br/&gt;Thread ru1 = new Thread(ru);&lt;br/&gt;Thread ru2 = new Thread(ru);// 两个窗口&lt;br/&gt;ru1.start();// 两个窗口启动&lt;br/&gt;ru2.start();&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;class Runnable02 implements Runnable {&lt;br/&gt;private int num = 16;&lt;br/&gt;Object obj = new Object();&lt;br/&gt;String s = new String();&lt;br/&gt;boolean flag = false;&lt;/p&gt;
&lt;p&gt;@Override&lt;br/&gt;public void run() {&lt;br/&gt;while (true) {&lt;br/&gt;// 同步代码块&lt;br/&gt;// flag为 false时 执行同步代码块&lt;br/&gt;if (!flag) {&lt;br/&gt;synchronized (this) {// 同步代码快的函数可以是任意函数&lt;br/&gt;if (num &amp;gt; 0) {&lt;br/&gt;System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (num--) + &quot;号票&quot; + &quot;同步代码块++++&quot;);&lt;br/&gt;try {&lt;br/&gt;Thread.sleep(100);&lt;br/&gt;} catch (InterruptedException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} // 睡眠0.2S&lt;br/&gt;}&lt;br/&gt;flag = true;&lt;br/&gt;}&lt;br/&gt;// 同步函数&lt;br/&gt;} else {&lt;br/&gt;funtion();&lt;br/&gt;flag = false;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;// 同步函数的锁是This&lt;br/&gt;public synchronized void funtion() {&lt;br/&gt;if (num &amp;gt; 0) {&lt;br/&gt;System.out.println(Thread.currentThread().getName() + &quot;:&quot; + (num--) + &quot;号票&quot; + &quot;同步函数----&quot;);&lt;br/&gt;try {&lt;br/&gt;Thread.sleep(100);&lt;br/&gt;} catch (InterruptedException e) {&lt;br/&gt;// TODO Auto-generated catch block&lt;br/&gt;e.printStackTrace();&lt;br/&gt;} // 睡眠0.2S&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 15:33:00 +0000</pubDate>
<dc:creator>北九北</dc:creator>
<og:description>package javawork; public class RunnableDemo2 { public static void main(String[] args) { Runnable02 r</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng1314/p/10029807.html</dc:identifier>
</item>
<item>
<title>[译]聊聊C＃中的泛型的使用（新手勿入） - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10029782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10029782.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;今天忙里偷闲在浏览外文的时候看到一篇讲C#中泛型的使用的文章，因此加上本人的理解以及四级没过的英语水平斗胆给大伙进行了翻译，当然在翻译的过程中发现了一些问题，因此也进行了纠正，当然，原文的地址我放在最下面，如果你的英文水平比较好的话，可以直接直接阅读全文。同时最近建了一个.NET Core实战项目交流群637326624，有兴趣的朋友可以来相互交流。目前.NET Core实战项目之CMS的教程也已经更新了6篇了，目前两到三天更新一篇。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10029782.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10029782.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;C＃和.NET中的泛型程序具有强类型集合的许多优点，并为代码提供更高质量和性能提升。泛型是C#语言和公共语言运行库（CLR）中的一个新功能，它将类型参数的概念引入.NET Framework。类型参数使得设计某些类和方法成为可能，例如，通过使用泛型类型参数T，可以大大简化类型之间的强制转换或装箱操作的过程（装箱、拆箱问题）。说白了，泛型就是通过参数化类型来实现在同一份代码上操作多种数据类型，利用“参数化类型”将类型抽象化，从而实现灵活的复用。每个集合的详细规范可以在System.Collection.Generic名称空间下找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127232611460-274150037.jpg&quot; alt=&quot;通用类C＃&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;装箱和拆箱&quot;&gt;装箱和拆箱&lt;/h2&gt;
&lt;p&gt;.Net定义了两种主要的数据类型来表示变量，也就是传说中的值类型和引用类型。这是需要装箱和拆箱的地方。装箱是一种通过将变量存储到System.Object中来显式地将值类型转换为引用类型的机制。当您装入值时，CLR会将新对象分配到堆中，并将值类型的值复制到该实例中。例如，您创建了一个int类型的变量：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;int a = 20;  
object b = a; //装箱&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相反的操作是拆箱，它是将引用类型转换回值类型的过程。此过程验证接收数据类型是否与装箱类型一致;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;int c = (int)b; // 拆箱&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C＃编译器可以看到从int到object的赋值，反之亦然。当编译该程序并通过IL解析器检查IL生成的代码时，您会注意到当b被赋值为a时，程序通过在IL中自动插入一个box指令来响应，当c被赋值为b时如下;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127232610935-1372402568.jpg&quot; alt=&quot;IL-opcode.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码加载常量20并将其存储在本地插槽中；它将值20加载到堆栈中并将其装箱。最后，它将被装箱的20返回到堆栈上，并将其拆箱为int类型&lt;/p&gt;
&lt;p&gt;这个过程.NET CLR执行了一系列操作，例如，首先在托管堆中分配一个对象，然后在装箱中将值转换为内存位置，并在拆箱期间将值存储在堆上并且必须转回到堆栈。因此，从性能的角度来看，装箱和拆箱过程在泛型中具有非常重要的意义，因为这个过程如果不使用泛型的话会耗费更多地资源。&lt;/p&gt;
&lt;h2 id=&quot;泛型类&quot;&gt;泛型类&lt;/h2&gt;
&lt;p&gt;可以通过在类名后面加上符号来定义泛型类。这里没有强制必须将“T”字放在泛型的定义中。您可以在TestClass &amp;lt;&amp;gt;类声明中使用任何单词。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class TestClass&amp;lt;T&amp;gt; { }  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;System.Collection.Generic命名空间下还定义了许多实现了这些关键字接口的类型。下表列出了此命名空间的核心类类型。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Collection&lt;/td&gt;
&lt;td&gt;泛型集合的基类，可以比较两个泛型对象是否相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/td&gt;
&lt;td&gt;键值对的泛型集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;List&lt;/td&gt;
&lt;td&gt;可动态调整列表项的大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Queue&lt;/td&gt;
&lt;td&gt;先进先出（FIFO）列表的泛型实现&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Stack&lt;/td&gt;
&lt;td&gt;后进先出（LIFO）列表的泛型实现&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;简单的泛型类示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下示例显示了一个简单的泛型类型的操作。TestClass 定义一个长度为5的泛型类型数组。Add()方法负责将任何类型的对象添加到集合中，而Indexer属性是循环语句迭代的实现。最后在主类中，我们使用整形类型来实例化TestClass 类，并使用Add()方法将一些整数类型数据添加到集合中。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections.Generic;  
  
namespace GenericApp  
{  
    public class TestClass&amp;lt;T&amp;gt;  
    {  
        // 定义一个长度为5的泛型类型的数组
        T[] obj = new T[5];  
        int count = 0;  
  
        // 向反省类型添加数据 
        public void  Add(T item)  
        {  
            //checking length  
            if (count + 1 &amp;lt; 6)  
            {  
                obj[count] = item;  
  
            }  
            count++;  
        }  
        //foreach语句迭代索引
        public T this[int index]  
        {  
            get { return obj[index]; }  
            set { obj[index] = value; }  
        }   
    }  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            //用整形来实例化泛型类
            TestClass&amp;lt;int&amp;gt; intObj = new TestClass&amp;lt;int&amp;gt;();  
  
            //向集合中添加int数据
            intObj.Add(1);  
            intObj.Add(2);  
            intObj.Add(3);     //没有装箱 
            intObj.Add(4);   
            intObj.Add(5);  
  
            //遍历显示数据
            for (int i = 0; i &amp;lt; 5; i++)  
            {  
                Console.WriteLine(intObj[i]);   //没有拆箱
            }  
            Console.ReadKey();    
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在构建并运行该程序之后，程序的输出如下所示;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127232610372-1311406304.jpg&quot; alt=&quot;简单仿制Example.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;泛型的主要特性&quot;&gt;泛型的主要特性&lt;/h2&gt;
&lt;p&gt;泛型类型的一些重要特征使它们相比传统的非泛型类型具有如下的显著特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类型安全&lt;/li&gt;
&lt;li&gt;性能&lt;/li&gt;
&lt;li&gt;二进制代码复用&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类型安全&quot;&gt;类型安全&lt;/h3&gt;
&lt;p&gt;泛型最重要的特征之一是类型安全性。对于非泛型ArrayList类，如果使用对象类型，则可以向集合中添加任何类型，这些类型有时会导致严重的问题。下面的示例显示向ArrayList类型的集合添加一个整数、字符串和对象；&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;ArrayList obj = new ArrayList();  
obj.Add(50);  
obj.Add(&quot;Dog&quot;);  
obj.Add(new TestClass());  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，如果使用整数对象来使用foreach语句进行遍历的话，当编译器接受到代码，但是因为集合中的所有元素都不是整数，所以会导致运行时异常；&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;foreach(int i in obj)  
{  
    Console.WriteLine(i);    
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编程的经验法则是应该尽早检测到错误。对于泛型类Test，泛型类型T定义允许哪些类型。通过使用Test的定义，只能向集合添加整型类型的数据。这时候当Add()方法具有以下无效参数的时候编译器将不编译代码；&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Test&amp;lt;int&amp;gt; obj = new Test&amp;lt;int&amp;gt;();  
obj.Add(50);  
obj.Add(&quot;Dog&quot;);            //编译错误 
obj.Add(new TestClass());  //编译错误&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;性能&quot;&gt;性能&lt;/h3&gt;
&lt;p&gt;在下面的示例中，ArrayList类存储对象，并且定义了Add()方法来存储一些整型参数。因此，整数类型被装箱。当使用foreach语句读取ArrayList中的值时，将发生拆箱。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;ArrayList  obj = new ArrayList();   
obj.Add(50);    //装箱- 值类型转换成引用类型 
int x= (int)obj[0]; //拆箱
foreach(int i in obj)  
{  
   Console.WriteLine(i);   // 拆箱
} &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：泛型比其他集合（如ArrayList）更快。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代替使用对象类型，TestClass类的泛型类型被定义为int，因此在从编译器动态生成的类中将使用int类型。所以将不会发生装箱和拆箱，如下所示；&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;TestClass&amp;lt;int&amp;gt; obj = new TestClass&amp;lt;int&amp;gt;();  
obj.Add(50);    //没有装箱 
int x= obj[0]; // 没有拆箱
foreach(int i in obj)  
{  
   Console.WriteLine(i);   //没有拆箱 
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二进制代码复用&quot;&gt;二进制代码复用&lt;/h3&gt;
&lt;p&gt;泛型类型提供了一种源代码保护机制。泛型类可以定义一次，并且可以使用许多不同类型来进行实例化。泛型可以在一种CLR支持的语言中定义，并可以被另一种.NET语言使用。以下TestClass 使用int和string类型进行实例化：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;TestClass&amp;lt;int&amp;gt; obj = new TestClass&amp;lt;int&amp;gt;();  
obj.Add(50);  
  
TestClass&amp;lt;string&amp;gt; obj1 = new TestClass&amp;lt;string&amp;gt;();  
Obj1.Add(&quot;hello&quot;);  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通用方法&quot;&gt;通用方法&lt;/h2&gt;
&lt;p&gt;虽然大多数开发人员通常会使用基类库中的现有泛型类型，但也有可能会构建自己的泛型成员和自定义的泛型类型。&lt;/p&gt;
&lt;p&gt;本示例的目的是构建一个交换方法，该方法可以使用单个类型参数对任何可能的数据类型（基于值或基于引用）进行操作。由于交换算法的性质，传入的参数将作为使用ref关键字修饰的引用类型来进行发送。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections.Generic;  
  
namespace GenericApp  
{  
    class Program  
    {  
        //泛型方法
        static void Swap&amp;lt;T&amp;gt;(ref T a, ref T b)  
        {  
            T temp;  
            temp = a;  
            a = b;  
            b = temp;  
        }  
        static void Main(string[] args)  
        {  
            //交换两个整形数据
            int a = 40, b = 60;  
            Console.WriteLine(&quot;Before swap: {0}, {1}&quot;, a, b);  
  
            Swap&amp;lt;int&amp;gt;(ref a, ref b);  
  
            Console.WriteLine(&quot;After swap: {0}, {1}&quot;, a, b);  
  
            Console.ReadLine();  
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译此泛型方法实现的程序后，输出如下所示;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201811/1377250-20181127232610049-650956191.jpg&quot; alt=&quot;通用-Methods.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;字典&quot;&gt;字典&lt;/h2&gt;
&lt;p&gt;字典也被称为映射或散列表。它表示允许您基于关键字来访问元素的数据结构。字典的一个重要特征是更快的查找; 您可以添加或删除选项而不会产生性能开销。&lt;/p&gt;
&lt;p&gt;.Net提供了几个字典类，例如Dictionary &amp;lt;TKey，TValue&amp;gt;。类型参数TKey和TValue分别表示关键字的类型和它可以存储的值。&lt;/p&gt;
&lt;h3 id=&quot;简单的字典示例&quot;&gt;简单的字典示例&lt;/h3&gt;
&lt;p&gt;以下示例演示使用泛型的简单字典集合。在此程序中，将创建一个Dictionary类型对象，该对象接受int作为键，字符串作为值。然后我们将一些字符串值添加到字典集合中，最后显示字典集合元素。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections.Generic;  
  
namespace GenericApp  
{  
    public class Program    
    {  
        static void Main(string[] args)  
        {  
            //定义一个字典集合
            Dictionary&amp;lt;int,string&amp;gt; dObj = new Dictionary&amp;lt;int,string&amp;gt;(5);  
  
            //向字典中添加类型
  
            dObj.Add(1,1,&quot;Tom&quot;);    
            dObj.Add(2,&quot;John&quot;);  
            dObj.Add(3, &quot;Maria&quot;);  
            dObj.Add(4, &quot;Max&quot;);  
            dObj.Add(5, &quot;Ram&quot;);  
  
            //输出数据
            for (int i = 1; i &amp;lt;= dObj.Count;i++)  
            {  
                Console.WriteLine(dObj[i]);  
            }  
            Console.ReadKey();  
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下示例通过定义附加类emp来描述一些更复杂的问题，其中我们覆盖ToString()方法以显示特定员工的名称和薪水。稍后在Main()方法中，创建一个新的Dictionary &amp;lt;TKey，TValue）的实例，其中键的类型为string，值为emp类型。构造函数分配2个元素的容量。emp对象和作为键的字符串值被添加到字典集合中。最后，使用foreach语句迭代集合元素并显示在屏幕上。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Text;  
using System.Collections.Generic;  
  
namespace GenericApp  
{  
    public class emp   
    {  
        private string name;  
        private int salary;  
   
        public emp(string name,int salary)  
        {  
            this.name = name;  
            this.salary = salary;   
        }  
        public override string ToString()  
        {  
            StringBuilder sb = new StringBuilder(200);  
            sb.AppendFormat(&quot;{0},{1}&quot;,name,salary);  
  
            return sb.ToString();  
        }  
  
    }  
    public class Program    
    {  
        static void Main(string[] args)  
        {  
            //定义一个字典集合 
            Dictionary&amp;lt;string, emp&amp;gt; dObj = new Dictionary&amp;lt;string, emp&amp;gt;(2);  
  
            //向字典中添加元素
            emp tom = new emp(&quot;tom&quot;, 2000);  
            dObj.Add(&quot;tom&quot;,tom);   // 键，值 
            emp john = new emp(&quot;john&quot;, 4000);  
            dObj.Add(&quot;john&quot;,john);  
  
            //print data  
            foreach(Object str in dObj.Values)  
            {  
               Console.WriteLine(str);  
            }  
   
            Console.ReadKey();  
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;队列&quot;&gt;队列&lt;/h2&gt;
&lt;p&gt;队列是一种特殊类型的容器，可确保以FIFO（先进先出）方式访问元素。队列集合最适合实现消息传递的组件。我们可以使用以下语法定义Queue集合对象：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Queue qObj = new Queue();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Queue集合的属性，方法和其他规则定义都位于Sysyem.Collection命名空间下。下表定义了关键成员;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Enqueue()&lt;/td&gt;
&lt;td&gt;将对象添加到队列的末尾。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Dequeue()&lt;/td&gt;
&lt;td&gt;从队列的开头删除对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Peek()&lt;/td&gt;
&lt;td&gt;返回队列开头的对象而不删除它。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面演示了一个基本的队列类型的集合，将一些字符串类型值添加到集合中，最后使用while语句来显示整个集合中的数据 。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections;  
  
namespace GenericApp  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            //定义一个队列
            Queue qObj = new Queue();  
  
            //向队列中添加字符串数据
            qObj.Enqueue(&quot;Tom&quot;);  
            qObj.Enqueue(&quot;Harry&quot;);  
            qObj.Enqueue(&quot;Maria&quot;);       
            qObj.Enqueue(&quot;john&quot;);  
  
            //显示队列中的数据 
            while(qObj.Count !=0 )  
            {  
                Console.WriteLine(qObj.Dequeue());  
            }  
  
            Console.ReadKey();    
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;堆栈&quot;&gt;堆栈&lt;/h2&gt;
&lt;p&gt;Stack集合是LIFO的抽象（后进先出）。我们可以使用以下语法定义Stack集合对象：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Stack qObj = new Stack();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下表说明了堆栈的关键成员;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Contains()&lt;/td&gt;
&lt;td&gt;如果在集合中找到特定元素，则返回true。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Clear()&lt;/td&gt;
&lt;td&gt;删除集合的所有元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Peek()&lt;/td&gt;
&lt;td&gt;预览堆栈中的最新元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Push()&lt;/td&gt;
&lt;td&gt;它将元素推入堆栈。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Pop()&lt;/td&gt;
&lt;td&gt;返回并删除堆栈的顶部元素。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;以下演示了堆栈集合。首先，将数组类型对象引用到堆栈集合中。然后使用Pop（）方法从堆栈中删除集合中元素的值并显示在屏幕上。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections;  
  
namespace GenericApp  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
            int[] iArray = new int[] {1,2,3,4,5,6,7,8,9,10 };  
  
            //定义一个堆栈
            Stack sObj = new Stack(iArray);  
  
            Console.WriteLine(&quot;Total items=&quot;+sObj.Count);  
  
            //显示集合数据
            for (int i = 0; i &amp;lt; sObj.Count;++i )  
            {  
                Console.WriteLine(sObj.Pop());  
            }  
  
            Console.ReadKey();    
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用泛型实现的另一个示例中，使用Push()方法将5个项添加到堆栈中。然后使用循环迭代输出堆栈中的数据。堆栈的枚举器不会删除数据; 它只是以LIFO方式返回每个项目，如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;  
using System.Collections;  
  
namespace GenericApp  
{  
    class Program  
    {  
        static void Main(string[] args)  
        {  
  
             //定义一个堆栈
            Stack sObj = new Stack();

            //向集合添加数据
            for (int i = 0; i &amp;lt; 5; ++i)
            {
                sObj.Push(i+1);
            }
            Console.WriteLine(&quot;Total items=&quot; + sObj.Count);
            //打印数据 
            foreach (int i in sObj)
            {
                Console.WriteLine(i);
            }
            Console.ReadKey();
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天忙里偷闲，在浏览外文的时候看到一篇讲泛型的文章，因此就加上自己的理解进行了相关翻译，也加深了自己对泛型的理解！如果英文比较好的话可以直接访问https://www.c-sharpcorner.com/UploadFile/84c85b/using-generics-with-C-Sharp/ 自行查看！当然，我在翻译的过程中也发现了文中的一些错误，所以进行了更正！同时最近建了一个.NET Core实战项目交流群637326624，有兴趣的朋友可以来相互交流。目前.NET Core实战项目之CMS的教程也已经更新了6篇了，目前两到三天更新一篇。最后感谢大家的阅读。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 15:28:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>写在前面 今天忙里偷闲在浏览外文的时候看到一篇讲C 中泛型的使用的文章，因此加上本人的理解以及四级没过的英语水平斗胆给大伙进行了翻译，当然在翻译的过程中发现了一些问题，因此也进行了纠正，当然，原文的地</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10029782.html</dc:identifier>
</item>
<item>
<title>Shell编程-11-子Shell和Shell嵌套 - Surpassme</title>
<link>http://www.cnblogs.com/surpassme/p/10029758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surpassme/p/10029758.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h3 id=&quot;什么是子shell&quot;&gt;什么是子Shell&lt;/h3&gt;
&lt;p&gt;    子Shell的概念其实是贯穿整个Shell的，如果想要更好的理解和写Shell脚本则必须要了解子Shell的相关知识。其概念如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;子Shell本质就是从当前的Shell环境中打开一个新的Shell环境，而新开的Shell称之为子Shell（SubShell），相应的开启子Shell的环境称之为父Shell。子Shell和父Shell是子进程和父进程的关系，而这个进程则全部是bash进程。子Shell可以从父Shell中继承变量、命令全路径、文件描述符、当前工作目录等。在子Shell中常用的两个变量如下所示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;$BASH_SUBSHELL:查看从当前进程开始的子Shell层数&lt;/li&gt;
&lt;li&gt;$BASHPID:查看当前所处BASH的PID&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;在Linux系统中，系统运行的程序基本都是从CentOS 6.x(init)或CentOS7.x(systemd)PID为1的进程）继承而来的，所有的程序都可以看作为init的子进程。
# CentOS 6.x
[root@localhost data]# pstree -hp
init(1)─┬─NetworkManager(3643)
        ├─Xvnc(22811)
        ├─abrtd(4760)
        ├─acpid(3755)
        ├─atd(4801)
        ├─auditd(3392)───{auditd}(3393)
        ├─automount(3849)─┬─{automount}(3850)
        │                 ├─{automount}(3851)
        │                 ├─{automount}(3854)
        │                 └─{automount}(3857)
# CentOS 7.x
[root@localhost ~]# pstree -hp
systemd(1)─┬─ModemManager(1051)─┬─{ModemManager}(1068)
           │                    └─{ModemManager}(1076)
           ├─Xvnc(5563)─┬─{Xvnc}(5566)
           │            ├─{Xvnc}(5567)
           │            ├─{Xvnc}(5568)

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;子shell产生的途径&quot;&gt;子Shell产生的途径&lt;/h3&gt;
&lt;h4 id=&quot;通过后台作业&quot;&gt;通过后台作业：&amp;amp;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat jobs.sh
#!/bin/bash
parentShell=&quot;ParentShell&quot;
echo &quot;Parent Shell start and Level:&quot;$BASH_SUBSHELL
# define subshell
{
 echo &quot;SubShell start and Level:&quot;$BASH_SUBSHELL
 subShell=&quot;SubShell&quot;
 echo &quot;SubShell value: ${subShell}&quot;
 echo &quot;parentShell value: ${parentShell}&quot;
# sleep 5
 echo &quot;SubShell end and Level: $BASH_SUBSHELL &quot;
} &amp;amp; # running in backgroud
echo &quot;Parent end and Level:$BASH_SUBSHELL&quot;

if [ -z &quot;${subShell}&quot; ]
  then
    echo &quot;subShell is not defined in ParentShell&quot;
else
  echo &quot;subShell is defined in ParentShel&quot;
fi
[root@localhost Test]# bash jobs.sh
Parent Shell start and Level:0
Parent end and Level:0
subShell is not defined in ParentShell
SubShell start and Level:1
SubShell value: SubShell
parentShell value: ParentShell
SubShell end and Level: 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据运行结果，结论如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Shell中可以使用&lt;strong&gt;&amp;amp;&lt;/strong&gt;产生子Shell&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;&amp;amp;&lt;/strong&gt;产生的子Shell可以直接引用父Shell的变量，而子Shell产生的变量不能被父Shell引用&lt;/li&gt;
&lt;li&gt;在Shell中使用&lt;strong&gt;&amp;amp;&lt;/strong&gt;可以实现多线程并发&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;通过管道&quot;&gt;通过管道：|&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat jobs.sh
#!/bin/bash
parentShell=&quot;ParentShell&quot;
echo &quot;Parent Shell start and Level:&quot;$BASH_SUBSHELL
# define subshell
echo &quot;&quot; |  # 管道
{
 echo &quot;SubShell start and Level:&quot;$BASH_SUBSHELL
 subShell=&quot;SubShell&quot;
 echo &quot;SubShell value: ${subShell}&quot;
 echo &quot;parentShell value: ${parentShell}&quot;
# sleep 5
 echo &quot;SubShell end and Level: $BASH_SUBSHELL &quot;
}
echo &quot;Parent end and Level:$BASH_SUBSHELL&quot;

if [ -z &quot;${subShell}&quot; ]
  then
    echo &quot;subShell is not defined in ParentShell&quot;
else
  echo &quot;subShell is defined in ParentShel&quot;
fi
[root@localhost Test]# bash jobs.sh
Parent Shell start and Level:0
SubShell start and Level:1
SubShell value: SubShell
parentShell value: ParentShell
SubShell end and Level: 1
Parent end and Level:0
subShell is not defined in ParentShell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据运行结果，结论如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Shell中可以使用&lt;strong&gt;管道&lt;/strong&gt;产生子Shell&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;管道&lt;/strong&gt;产生的子Shell可以直接引用父Shell的变量，而子Shell产生的变量不能被父Shell引用&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;管道&lt;/strong&gt;产生的Shell是顺序执行的，仅能在子Shell执行完成后才能返回父Shell中继续执行，这一点也是与&lt;strong&gt;&amp;amp;&lt;/strong&gt;最大的区别。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;通过&quot;&gt;通过()&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat jobs.sh
#!/bin/bash
parentShell=&quot;ParentShell&quot;
echo &quot;Parent Shell start and Level:&quot;$BASH_SUBSHELL
# define subshell
(
 echo &quot;SubShell start and Level:&quot;$BASH_SUBSHELL
 subShell=&quot;SubShell&quot;
 echo &quot;SubShell value: ${subShell}&quot;
 echo &quot;parentShell value: ${parentShell}&quot;
# sleep 5
 echo &quot;SubShell end and Level: $BASH_SUBSHELL &quot;
)
echo &quot;Parent end and Level:$BASH_SUBSHELL&quot;

if [ -z &quot;${subShell}&quot; ]
  then
    echo &quot;subShell is not defined in ParentShell&quot;
else
  echo &quot;subShell is defined in ParentShel&quot;
fi
[root@localhost Test]# bash jobs.sh
Parent Shell start and Level:0
SubShell start and Level:1
SubShell value: SubShell
parentShell value: ParentShell
SubShell end and Level: 1
Parent end and Level:0
subShell is not defined in ParentShell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据运行结果，结论如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Shell中可以使用&lt;strong&gt;()&lt;/strong&gt;产生子Shell&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;()&lt;/strong&gt;产生的子Shell可以直接引用父Shell的变量，而子Shell产生的变量不能被父Shell引用&lt;/li&gt;
&lt;li&gt;由&lt;strong&gt;()&lt;/strong&gt;产生的Shell是顺序执行的，仅能在子Shell执行完成后才能返回父Shell中继续执行，&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;看到这个结果，大家会不会觉得使用()跟使用管道一样的？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;通过调用外部shell&quot;&gt;通过调用外部Shell&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat subShell.sh parentShell.sh  -n
       # SubShell
     1  #!/bin/bash
     2   echo &quot;SubShell start and Level:&quot;$BASH_SUBSHELL
     3   subShell=&quot;SubShell&quot;
     4   echo &quot;SubShell value: ${subShell}&quot;
     5   echo &quot;parentShell value: ${parentShell}&quot;
     6   echo &quot;parentExportShell value: ${parentExportShell}&quot;
     7   if [ -z &quot;${parentShell}&quot;  ];then
     8      echo &quot;parentShell value is : null&quot;
     9   else
    10      echo &quot;parentShell value is : &quot;${parentShell}
    11   fi
    12
    13  # ParentShell
    14  #!/bin/bash
    15  parentShell=&quot;Parent&quot;
    16  export parentExportShell=&quot;parentExportShell&quot;
    17  echo &quot;Parent Shell start and Level:&quot;$BASH_SUBSHELL
    18  bash ./subShell.sh # invoke subshell
    19  sleep 3
    20  echo &quot;Parent Shell end and Level:&quot;$BASH_SUBSHELL
    21  if [ -z &quot;${subShell}&quot; ]
    22    then
    23     echo &quot;subShell is not defined in ParentShell&quot;
    24  else
    25     echo &quot;subShell is defined in ParentShell&quot;
    26  fi
[root@localhost Test]# bash parentShell.sh
Parent Shell start and Level:0
SubShell start and Level:0
SubShell value: SubShell
parentShell value:
parentExportShell value: parentExportShell
parentShell value is : null
Parent Shell end and Level:0
subShell is not defined in ParentShell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据运行结果，结论如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Shell中可以通过外部Shell脚本产生子Shell&lt;/li&gt;
&lt;li&gt;在调用外部Shell时，父Shell定义的变量不能被子Shell继承，如果要继承父Shell的变量，必须使用export使其成为全局环境变量。&lt;/li&gt;
&lt;li&gt;调用外部Shell产生的Shell是顺序执行的，仅能在子Shell执行完成后才能返回父Shell中继续执行，&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;shell脚本调用模式&quot;&gt;Shell脚本调用模式&lt;/h3&gt;
&lt;p&gt;    通常在大型的项目中，都会将较大模块进行拆分为多个小模块进行代码编写调试等。因此在一个Shell脚本中也不可能包含所有模块，一般都采用在一个脚本中去调用当前用到的脚本，这种被称之为&lt;strong&gt;Shell嵌套&lt;/strong&gt;。在一个脚本中嵌套脚本的方式主要有&lt;strong&gt;fork&lt;/strong&gt;、&lt;strong&gt;exec&lt;/strong&gt;和&lt;strong&gt;source&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;fork模式调用脚本&quot;&gt;fork模式调用脚本&lt;/h4&gt;
&lt;p&gt;    fork模式是最普通的脚本调用方式。在使用该方式调用脚本时，系统会创建一个子Shell去调用脚本。其调用方式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/bin/bash /path/shellscript.sh # 未给脚本添加执行权限时
或
/path/shellscript.sh # 脚本拥有执行权限时&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;fork本质是复制进程&lt;/strong&gt;。使用该方式时，fork会复制当前进程做为一个副本，而后将这些资源交给子进程。因此子进程会继承父进程的一些资源，如环境变量、变量等。而父进程却是完全独立的，子进程和父进程相当于面向对象中一个对象的两个实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;exec模式调用脚本&quot;&gt;exec模式调用脚本&lt;/h4&gt;
&lt;p&gt;    exec调用脚本时，不会开启一个新的子Shell来进行调用脚本，被调用的脚本和调用脚本在同一个Shell内执行。&lt;strong&gt;但需要注意的是使用exec调用新脚本后，在执行完新脚本的内容后，不再返回到调用脚本中执行后续未执行的内容&lt;/strong&gt;，这也是与fork调用脚本的主要区别。其主要调用方式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;exec /path/shellscript.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;exec的本质是加载另外一个程序来代替当前运行的进程&lt;/strong&gt;。即在不创建新进程的情况下去加载一个新程序，而在进程执行完成后就直接退出exec所在的Shell环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;source模式调用脚本&quot;&gt;source模式调用脚本&lt;/h4&gt;
&lt;p&gt;    source调用脚本时，也不会开启一个新的子Shell来执行被调用的脚本，同样也是在同一个Shell中执行，因此被调用脚本是可以继承调用脚本的变量、环境变量等。&lt;strong&gt;与exec调用方式的区别是，source在执行完被调用脚本的内容后，依然会返回调用脚本中，去执行调用脚本中未执行的内容&lt;/strong&gt;。其主要调用方式如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;source /path/shellscript.sh
或
. /path/shellscript.sh  # .和source是等价的&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三种调用模式示例&quot;&gt;三种调用模式示例&lt;/h4&gt;
&lt;p&gt;    示例代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat -n subShell.sh parentShell.sh
     1  #!/bin/bash
     2   echo &quot;SubShell start and Level:&quot;$BASH_SUBSHELL
     3   echo &quot;SubShell PID is:&quot; $$
     4   subShell=&quot;SubShell&quot;
     5   echo &quot;SubShell value: ${subShell}&quot;
     6   echo &quot;parentShell value: ${parentShell}&quot;
     7   echo &quot;parentExportShell value: ${parentExportShell}&quot;
     8   if [ -z &quot;${parentShell}&quot;  ];then
     9      echo &quot;parentShell value is : null&quot;
    10   else
    11      echo &quot;parentShell value is : &quot;${parentShell}
    12   fi
    13  #!/bin/bash
    14  # print usage
    15  function Usage() {
    16    echo &quot;Usage:$0 {fork|exec|source}&quot;
    17    exit 1
    18  }
    19  # print return variable
    20  function PrintPara() {
    21   if [ -z &quot;${subShell}&quot; ]
    22    then
    23     echo &quot;subShell is not defined in ParentShell&quot;
    24   else
    25     echo &quot;subShell is defined in ParentShell &quot;${subShell}
    26   fi
    27  }
    28  # invoke pattern
    29  function ParentFunction() {
    30    parentShell=&quot;Parent&quot;
    31    export parentExportShell=&quot;parentExportShell&quot;
    32    echo &quot;Parent Shell start and Level:&quot;$BASH_SUBSHELL
    33    echo &quot;Parent PID is:&quot;$$
    34    case &quot;$1&quot; in
    35      fork)
    36         echo &quot;Using fork pattern&quot;
    37         /bin/bash ./subShell.sh
    38         PrintPara ;;
    39      exec)
    40         echo &quot;Using exec pattern&quot;
    41         exec ./subShell.sh
    42         PrintPara ;;
    43      source)
    44         echo &quot;Using source pattern&quot;
    45         source ./subShell.sh
    46         PrintPara ;;
    47      *)
    48        echo &quot;Input error ,usage is:&quot; Usage
    49     esac
    50  }
    51  # check parameter number
    52  function CheckInputPara() {
    53    if [ $# -ne 1 ]
    54      then
    55        Usage
    56    fi
    57    ParentFunction $*
    58  }
    59  CheckInputPara $*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1、fork调用结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# bash parentShell.sh fork
Parent Shell start and Level:0
Parent PID is:26413
Using fork pattern
SubShell start and Level:0
SubShell PID is: 26414
SubShell value: SubShell
parentShell value:
parentExportShell value: parentExportShell
parentShell value is : null
subShell is not defined in ParentShell&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、父Shell和子Shell的PID不一样，则可以说明产生了新的子进程&lt;br/&gt;2、调用脚本中定义的全局变量可以传入到被调用脚本，而被调用的脚本中定义的变量是无法返回到调用脚本中的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、exec调用结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# chmod +x subShell.sh
[root@localhost Test]# bash parentShell.sh exec
Parent Shell start and Level:0
Parent PID is:25543
Using exec pattern
SubShell start and Level:0
SubShell PID is: 25543
SubShell value: SubShell
parentShell value:
parentExportShell value: parentExportShell
parentShell value is : null&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、父Shell和子Shell的PID一样，则可以说明未产生新的子进程&lt;br/&gt;2、调用脚本中定义的全局变量可以传入到被调用脚本&lt;br/&gt;3、最重要的一点就是在执行完被调用脚本后直接退出Shell了，而调用脚本未执行的内容并没有被执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、source调用结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# bash parentShell.sh source
Parent Shell start and Level:0
Parent PID is:19955
Using source pattern
SubShell start and Level:0
SubShell PID is: 19955
SubShell value: SubShell
parentShell value: Parent
parentExportShell value: parentExportShell
parentShell value is : Parent
subShell is defined in ParentShell: SubShell&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、父Shell和子Shell的PID一样，则可以说明未产生新的子进程&lt;br/&gt;2、调用脚本中定义的普通变量和全局变量可以传入到被调用脚本，反之亦然&lt;br/&gt;3、最重要的一点就是在执行完被调用脚本后返回调用脚本中继续执行剩下的内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;三种调用模式使用场景&quot;&gt;三种调用模式使用场景&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、fork模式使用场景&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;fork模式常用于常规嵌套脚本执行的场景中，仅仅是执行嵌套脚本中命令，调用脚本也不需要使用被调用脚本中的变量和函数等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;2、exec模式使用场景&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;exec模式常用于调用脚本中末尾中。而这种模式在执行完被调用脚本中就直接退出，因此使用较少，可使用source代替exec&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;3、source模式使用场景&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;source模式算是在Shell常用的一种脚本嵌套调用模式，常用于执行嵌套脚本启动一些服务程序等，其最大的优点就是嵌套脚本中定义的变量和函数等资源可以被调用脚本获取和使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文同步在微信订阅号上发布，如各位小伙伴们喜欢我的文章，也可以关注我的微信订阅号：woaitest，或扫描下面的二维码添加关注：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3349421-2a0edd703123621d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyQRCode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 15:18:00 +0000</pubDate>
<dc:creator>Surpassme</dc:creator>
<og:description>[TOC] 什么是子Shell     子Shell的概念其实是贯穿整个Shell的，如果想要更好的理解和写Shell脚本则必须要了解子Shell的相关知识。其概念如下所示： 子S</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surpassme/p/10029758.html</dc:identifier>
</item>
<item>
<title>应届生秋招可能会遇到的三个问题 - DarrenHu_吴邪</title>
<link>http://www.cnblogs.com/DarrenHu/p/xiaozhao.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DarrenHu/p/xiaozhao.html</guid>
<description>&lt;h2 id=&quot;第一题&quot;&gt;第一题：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;喜欢但是工资低的工作跟不喜欢但是工资高的工作，如何抉择？&lt;/li&gt;
&lt;li&gt;自我介绍的时候应该突出什么方面比较讨喜？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好的，我们现在说一下这个同学的问题，喜欢但是工资低的工作和不喜欢但是工资高的工作，该如何选择，那在大原则上我们肯定都是建议大家去选择，喜欢的工作。就是工资低，这个是一个现状，工资可以通过后期的努力，可以去慢慢的提升，但是喜欢这件事情来说，是比较难改变的。所以，如果你挑了一个不喜欢的工作，一定是越做越难受。所以说这个工资高。你也不一定说能持续多久，或者说一直这样。可能对于升值来说也没那么容易，那这个就需要大家去思考，第二个问题，就是你是不是经济压力那么大。但是如果说你的家庭并没有给到一个很大的经济压力，我建议更多同学去追逐自己喜欢的工作。但如果说你说家里特别困难的，当然只能向现实去低头，这个是没有办法的事。&lt;/p&gt;
&lt;p&gt;说一下这个同学第二个问题就是关于自我介绍的时候应该突出什么方面比较讨喜，那讨喜的话，我会把它理解为是加分项，那我们先说一下自我介绍的重点。到介绍的时候重点突出的更多的事，首先是你的语言的清晰。然后逻辑清晰，这里面逻辑清晰的话就是主次分明，你主要应该去讲的东西就是你的简历的。亮点和这份工作的匹配度。就是你突出的地方。和这份工作，他的匹配关系，这个是你的终点，那讨喜这一块，我们通常会觉得因为自我介绍其实信息量很少。但是你不能讲太多东西，然后变得很长，所以说。讨喜的话一般比较好的就是我们会去讲到我为什么去这家公司，可能是因为我是这家公司的重度用户。可能是因为我很认可这家公司的某个理念或者认可某产品，就是突出是你提前做好的准备。&lt;/p&gt;
&lt;h2 id=&quot;第二题&quot;&gt;第二题：&lt;/h2&gt;
&lt;p&gt;秋招拿到了一个互联网的offer，但不满足于公司的平台。现在找到了一份平台很大，有比较对口的实习，但目前没有hc，不保证能实习转正，从12月要做到明年三月。我听大企业的hr说现在校招也喜欢用之前在企业实习的孩子，这是真的吗？如果去的话，这样会影响到之后的春招吗？十二月找什么实习比较好呢？&lt;/p&gt;
&lt;p&gt;正是因为企业其实很喜去留用实习生这一点，所以我们在没有课程的时候都会强烈建议大家去，然后说去参加这边实习会不会去影响到春招，当然是。会，而且是积极的影响。会让你春招应该是更有把握的。那同时也刚才回答过了你现在要准备春招当然是要找一份。相对来说时间有一定程度的，然后平台更大的去提升你本身简历的含金量。因为对于你要参加春招来说能拿到一份大平台的实习，而且是三个月，只有一个月我还是要慎重考虑一下，三个月是非常值得的，再怎么说也可以提升你简历含金量。&lt;/p&gt;
&lt;h2 id=&quot;第三题&quot;&gt;第三题：&lt;/h2&gt;
&lt;p&gt;对于人生的决策来说，其实分为很多个，你很怕一个不小心选择了，就会产生蝴蝶效应。那么这篇就是为你准备的。&lt;br/&gt;看看这篇&lt;a href=&quot;https://www.zhihu.com/question/303357472/answer/537376328&quot;&gt;如何大幅度地提高决策能力&lt;/a&gt;首赞就是最好的回答。&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 14:31:00 +0000</pubDate>
<dc:creator>DarrenHu_吴邪</dc:creator>
<og:description>应届生秋招可能会遇到的三个问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DarrenHu/p/xiaozhao.html</dc:identifier>
</item>
<item>
<title>拖拽TreeViewItem到OCX控件 - Johar</title>
<link>http://www.cnblogs.com/Johar/p/10029328.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Johar/p/10029328.html</guid>
<description>&lt;p&gt;由于C#在性能方面，和C++还是有不少的差距，所以在项目中有一块是用C++的OCX控件实现，然后包括在WPF项目中。由于C++，C#属于不同的体系架构，造成了许多问题，特使是拖拽TreeViewItem到OCX控件上面，两者的渲染方式不同，OCX控件一直显示在最前面，所以拖拽的时候，看不见拖拽的AdornerLayer，并且鼠标还显示禁止状态。下面的内容主要是解决这两个问题的经历：&lt;/p&gt;
&lt;p&gt;1.解决拖拽TreeViewItem到OCX控件上面，鼠标是禁止状态。没有显示AdornerLayer，用户考虑到我们使用技术的原因，也还理解，只是这个禁止状态，用户接受不了，所以解决这个问题成为重中之重。&lt;/p&gt;
&lt;p&gt;（1）刚刚看到禁止图标，一眼就以为是AllowDrop没有设置为True，然后就把这个控件有这个属性的地方都设置了一遍，结果鼠标拖拽的时候移上去还是禁止状态。&lt;/p&gt;
&lt;p&gt;（2）依旧对AllowDrop属性不死心，让同事看OCX控件中有没有对应的属性，最终找到一个AcceptFile，虽然和AllowDrop不太一样，但是活马当死马医，只能要求同事生成ocx控件，给我试一把。最终结果还是不能解决问题。&lt;/p&gt;
&lt;p&gt;（3）在没有什么好的想法的时候，依旧对OCX的属性设置还抱有一点希望，到处问同事，搜google，bing，msdn，最终一上午都没有看到有用的信息，只能无奈放弃。&lt;/p&gt;
&lt;p&gt;（4）后面也没有什么好的方法，就在博客园，msdn上面提问，具体可以见&lt;a href=&quot;https://q.cnblogs.com/q/111134/&quot; target=&quot;_blank&quot;&gt;https://q.cnblogs.com/q/111134/&lt;/a&gt;，&lt;a href=&quot;https://social.msdn.microsoft.com/Forums/zh-CN/02959b72-a46c-4a27-bef5-cf8e246e8977/22312wpf200132530225341treeviewitem21040ocx2551120214200136529240736?forum=wpfzhchs#c8c87cb0-6ed5-492f-9f3e-1c40857db1f1&quot; target=&quot;_blank&quot;&gt;https://social.msdn.microsoft.com/Forums/zh-CN/02959b72-a46c-4a27-bef5-cf8e246e8977/22312wpf200132530225341treeviewitem21040ocx2551120214200136529240736?forum=wpfzhchs#c8c87cb0-6ed5-492f-9f3e-1c40857db1f1&lt;/a&gt;，然后根据msdn上面技术支持给的建议，参考&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/walkthrough-enabling-drag-and-drop-on-a-user-control&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/framework/wpf/advanced/walkthrough-enabling-drag-and-drop-on-a-user-control&lt;/a&gt;中的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436823/201811/436823-20181127213233425-1217584525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在项目中的TreeView中，我也重写了该方法，强制将鼠标设置为箭头，结果启动程序试了一下，拖拽TreeViewItem到OCX控件上面，鼠标还是箭头，不是禁止状态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnGiveFeedback(GiveFeedbackEventArgs e)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnGiveFeedback(e);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            Mouse.SetCursor(Cursors.Arrow);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             e.Handled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;           
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.解决拖拽项所在的AdornerLayer，被OCX控件遮挡的问题&lt;/p&gt;
&lt;p&gt;由于OCX是通过WindowsFormsHost的方式加到WPF程序中，两者的渲染机制不同，导致OCX控件显示在最前面，WPF中ZIndex也就英雄无用武之地。&lt;/p&gt;
&lt;p&gt;（1）考虑到窗口可以显示在OCX的前面，想过在鼠标进入OCX的时候，在鼠标下面添加一个窗口，跟随鼠标移动，这种想法是可行的，但是在OCX控件的Enter和Leave事件中都没有响应到拖拽过程中，鼠标的进入控件，离开控件的事件，导致这个没有向下执行下去。&lt;/p&gt;
&lt;p&gt;（2）后面还考虑直接将鼠标式样改成拖拽项的图标，也因此放弃了。&lt;/p&gt;
&lt;p&gt;（3）最后在拖拽的过程中，我发现拖拽到OCX控件的e.Effects == DragDropEffects.None，其他的WPF部分，可以直接在窗口上面将AllowDrop属性设置为True就行，因此可以根据这个区分拖拽是在WPF上面还是OCX上面，当在OCX上面的时候修改鼠标的式样。因为TreeViewItem是一张图片和其名称够成，平时设置鼠标式样的时候，是直接将图片设置为鼠标式样，看了一下Cursor里面的属性，没有发现可以设置文字的地方，只能先将字符串转化为图片，再将两张图片合并在一起。其中关键的代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Drawing;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.InteropServices;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Input;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Interop;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; ViewModels
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CursorHelper
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cursor CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; filePath)
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;             Bitmap bmp = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;                 bmp = Bitmap.FromFile(filePath) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Bitmap;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (bmp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; BitmapCursor.CreateBmpCursor(bmp);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cursors.Arrow;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cursors.Arrow;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; 
&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Cursor CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt; filePath, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             Bitmap bmp = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                 bmp = Bitmap.FromFile(filePath) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Bitmap;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (bmp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; nameBmp =&lt;span&gt; StringToImg(name);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; mergeBmp =&lt;span&gt; CombinImage(bmp, nameBmp);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (mergeBmp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; BitmapCursor.CreateBmpCursor(mergeBmp);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cursors.Arrow;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cursors.Arrow;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Bitmap StringToImg(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             Graphics g = Graphics.FromImage(&lt;span&gt;new&lt;/span&gt; Bitmap(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             Font font = &lt;span&gt;new&lt;/span&gt; Font(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;宋体&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             SizeF sizeF = g.MeasureString(name, font); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测量出字体的高度和宽度&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;             Brush brush =&lt;span&gt; Brushes.White;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             PointF pf = &lt;span&gt;new&lt;/span&gt; PointF(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             Bitmap img = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bitmap(Convert.ToInt32(sizeF.Width), Convert.ToInt32(sizeF.Height));
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             g =&lt;span&gt; Graphics.FromImage(img);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            g.DrawString(name, font, brush, pf);
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; img;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Bitmap CombinImage(Image icoImg, Image stringImg)
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; Math.Max(icoImg.Height, stringImg.Height);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             Bitmap bmp = &lt;span&gt;new&lt;/span&gt; Bitmap(icoImg.Width + stringImg.Width + &lt;span&gt;6&lt;/span&gt;&lt;span&gt;, height);
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;             Graphics g =&lt;span&gt; Graphics.FromImage(bmp);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;             g.Clear(Color.FromArgb(&lt;span&gt;150&lt;/span&gt;, &lt;span&gt;201&lt;/span&gt;, &lt;span&gt;252&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             g.DrawImage(icoImg, &lt;span&gt;0&lt;/span&gt;, (height - icoImg.Height) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, icoImg.Width, icoImg.Height);
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;             g.DrawImage(stringImg, icoImg.Width + &lt;span&gt;6&lt;/span&gt;, (height - stringImg.Height) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, stringImg.Width, stringImg.Height);            
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bmp;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Cursor GetCursor(FASTreeViewItemViewModel data)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (data.NodeType ==&lt;span&gt; NodeType.Camera)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data.DeviceType ==&lt;span&gt; DeviceType.Normal)
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.OnLine)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_IPC_on.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.OffLine)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_IPC_off.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.DeviceType ==&lt;span&gt; DeviceType.PTZ)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.OnLine)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_ptzIPC_on.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.OffLine)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_ptzIPC_off.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.NodeType ==&lt;span&gt; NodeType.PollingGroup)
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.Normal)
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_patrol.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.State ==&lt;span&gt; TreeItemState.Running)
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; CreateBitmapCursor(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;{0}Device_patrol_play.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, AppViewModel.Instance.BaseDirectory), data.DisplayName);
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Cursors.Arrow;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt;     &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BitmapCursor : SafeHandle
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsInvalid
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; handle == (IntPtr)(-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; 
&lt;span&gt;134&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Cursor CreateBmpCursor(Bitmap cursorBitmap)
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;             BitmapCursor c = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BitmapCursor(cursorBitmap);
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; CursorInteropHelper.Create(c);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; 
&lt;span&gt;140&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; BitmapCursor(Bitmap cursorBitmap)
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             : &lt;span&gt;base&lt;/span&gt;((IntPtr)(-&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;             handle =&lt;span&gt; cursorBitmap.GetHicon();
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; 
&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ReleaseHandle()
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;             &lt;span&gt;bool&lt;/span&gt; result =&lt;span&gt; DestroyIcon(handle);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt;             handle = (IntPtr)(-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; 
&lt;span&gt;155&lt;/span&gt;         [DllImport(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; DestroyIcon(IntPtr hIcon);
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnGiveFeedback(GiveFeedbackEventArgs e)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnGiveFeedback(e);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (e.Effects.HasFlag(DragDropEffects.Move))
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                Mouse.SetCursor(Cursors.Arrow);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; dataItem = &lt;span&gt;this&lt;/span&gt;.SelectedItem &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TreeViewItemViewModelBase;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (dataItem != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    Mouse.SetCursor(dataItem.GetCurrentCursor());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             e.Handled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过这两种方式，就解决上述的两个问题，可以满足项目的要求。&lt;/p&gt;

</description>
<pubDate>Tue, 27 Nov 2018 13:58:00 +0000</pubDate>
<dc:creator>Johar</dc:creator>
<og:description>由于C#在性能方面，和C++还是有不少的差距，所以在项目中有一块是用C++的OCX控件实现，然后包括在WPF项目中。由于C++，C#属于不同的体系架构，造成了许多问题，特使是拖拽TreeViewIte</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Johar/p/10029328.html</dc:identifier>
</item>
<item>
<title>Android ION内存分配 - willhua</title>
<link>http://www.cnblogs.com/willhua/p/10029280.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willhua/p/10029280.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://lwn.net/Articles/480055/&quot;&gt;英文原文&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;ion-heaps&quot;&gt;ION heaps&lt;/h3&gt;
&lt;h4 id=&quot;ion设计的目标&quot;&gt;ION设计的目标&lt;/h4&gt;
&lt;p&gt;为了避免内存碎片化，或者为一些有着特殊内存需求的硬件，比如GPUs、display controller以及camera等，在系统启动的时候，会为他们预留一些memory pools，这些memory pools就由&lt;strong&gt;ION&lt;/strong&gt;来管理。通过&lt;strong&gt;ION&lt;/strong&gt;就可以在硬件以及user space之间实现&lt;strong&gt;zero-copy&lt;/strong&gt;的内存share。&lt;/p&gt;
&lt;h4 id=&quot;ion的实现&quot;&gt;ION的实现&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ION&lt;/strong&gt;通过&lt;strong&gt;ION heaps&lt;/strong&gt;来展示presents它对应的memory pools。不同的Android硬件可能会要求不同的&lt;strong&gt;ION heaps&lt;/strong&gt;实现，默认的&lt;strong&gt;ION&lt;/strong&gt;驱动会提供如下三种不同的&lt;strong&gt;ION heaps&lt;/strong&gt;实现：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ION_HEAP_TYPE_SYSTEM: memory allocated via vmalloc_user()&lt;/li&gt;
&lt;li&gt;ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kzalloc&lt;br/&gt;. ION_HEAP_TYPE_CARVEOUT: carveout memory is physically contiguous and set aside at boot.&lt;br/&gt;开发者可以自己实现更多的&lt;strong&gt;ION heaps&lt;/strong&gt;。比如&lt;strong&gt;NVIDIA&lt;/strong&gt;就提交了一种&lt;strong&gt;ION_HEAP_TYPE_IOMMU&lt;/strong&gt;的heap，这种heap带有&lt;strong&gt;IOMMU&lt;/strong&gt;功能。&lt;br/&gt;不管哪一种&lt;strong&gt;ION heaps&lt;/strong&gt;实现，他们都必须实现如下接口：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;   struct ion_heap_ops {
    int (*allocate) (struct ion_heap *heap,
             struct ion_buffer *buffer, unsigned long len,
             unsigned long align, unsigned long flags);
    void (*free) (struct ion_buffer *buffer);
    int (*phys) (struct ion_heap *heap, struct ion_buffer *buffer,
             ion_phys_addr_t *addr, size_t *len);
    struct scatterlist *(*map_dma) (struct ion_heap *heap,
             struct ion_buffer *buffer);
    void (*unmap_dma) (struct ion_heap *heap, 
             struct ion_buffer *buffer);
    void * (*map_kernel) (struct ion_heap *heap, 
             struct ion_buffer *buffer);
    void (*unmap_kernel) (struct ion_heap *heap, 
             struct ion_buffer *buffer);
    int (*map_user) (struct ion_heap *heap, struct ion_buffer *buffer,
             struct vm_area_struct *vma);
   };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来说，接口的各个函数功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;allocate()&lt;/code&gt;和&lt;code&gt;free()&lt;/code&gt;分别用来从heap中&lt;strong&gt;分配&lt;/strong&gt;或者&lt;strong&gt;释放&lt;/strong&gt;一个&lt;code&gt;ion_buffer&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;对于物理连续的内存，&lt;code&gt;phys()&lt;/code&gt;用来得到&lt;code&gt;ion_buffer&lt;/code&gt;对象的&lt;strong&gt;物理内存地址&lt;/strong&gt;及其&lt;strong&gt;大小&lt;/strong&gt;。如果heap没有提供物理连续的内存，那么它也可以不用提供这个接口。其中，&lt;code&gt;ion_phys_addr_t&lt;/code&gt;将来会被定义在&lt;em&gt;/include/linux/types.h&lt;/em&gt;中的&lt;code&gt;phys_addr_t&lt;/code&gt;替代。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map_dma()&lt;/code&gt;和&lt;code&gt;unmap_dma()&lt;/code&gt;分别来用使&lt;code&gt;ion_buffer&lt;/code&gt;对象为&lt;a href=&quot;https://blog.csdn.net/kris_fei/article/details/72628692&quot;&gt;DMA（Direct Memory Access，直接内存存取。顾名思义，不占用cpu资源，从一个硬件存储区域把一部分连续的数据复制到另一个硬件存储区域）&lt;/a&gt;做好准备或者取消做好准备&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map_kernel()&lt;/code&gt;和&lt;code&gt;unmap_kernel()&lt;/code&gt;分别用来把physical memory映射(map)到内核虚拟地址空间(kernel virtual address space)或者取消映射&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map_user()&lt;/code&gt;用来把physical memory映射(map)到用户内存空间(user space)。为什么没有对应的&lt;code&gt;unmap_user()&lt;/code&gt;呢？因为，这个映射用一个file descriptor来表示，当这个file descriptor关闭的时候，这个映射关系就自动取消了。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;在user-space使用ion&quot;&gt;在user space使用ION&lt;/h3&gt;
&lt;h4 id=&quot;使用场景&quot;&gt;使用场景&lt;/h4&gt;
&lt;p&gt;典型的，在用户空间使用的设备访问库(user space device access libraries)一般使用&lt;strong&gt;ION&lt;/strong&gt;来分配大块连续的media buffers。比如，still camera library分配一个capture buffer来供camera device使用。当这个buffer填满video data的时候，这个library就能把这块buffer传递给kernel，然后让JPEG硬编码模块来处理。&lt;/p&gt;
&lt;h4 id=&quot;具体使用细节&quot;&gt;具体使用细节&lt;/h4&gt;
&lt;p&gt;在user space 的C/C++程序能够能够分配&lt;strong&gt;ION&lt;/strong&gt;内存之前，它必须获得访问&lt;code&gt;/dev/ion&lt;/code&gt;的权限。通过调用&lt;code&gt;open(&quot;/dev/ion&quot;, O_RDONLY)&lt;/code&gt;就可获得一个以handle形式返回的file descriptor，这个file descriptor用来代表一个&lt;strong&gt;ION client&lt;/strong&gt;。注意，虽然传给&lt;code&gt;open&lt;/code&gt;一个&lt;code&gt;O_RDONLY&lt;/code&gt;参数，但是你仍然可对这块memory进行写操作。在一个user process中最多有一个client。当有了一个client之后，就可以开始分配&lt;strong&gt;ION&lt;/strong&gt;内存。为了分配内存，client必须填满下面的&lt;code&gt;ion_allocation_data&lt;/code&gt;结构，&lt;code&gt;handle&lt;/code&gt;除外，因为它是output参数。其他三个参数分别指明内存的大小、对齐方式以及flags。flags是一个bit mask，用来说明可以从哪些heaps中分配想要的内存。其决定顺序由系统启动时，通过&lt;code&gt;ion_device_add_heap()&lt;/code&gt;添加的heap顺来决定。比如，ION_HEAP_TYPE_CARVEOUT是在ION_HEAP_TYPE_CONTIG之前被add的，那么如果&lt;code&gt;flags = ION_HEAP_TYPE_CONTIG | ION_HEAP_TYPE_CARVEOUT&lt;/code&gt;，那么就是先尝试分配ION_HEAP_TYPE_CARVEOUT类型的heap，如果不行，再尝试分配ION_HEAP_TYPE_CONTIG类型的heap。（）&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;   struct ion_allocation_data {
        size_t len;
        size_t align;
        unsigned int flags;
        struct ion_handle *handle;
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;user space通过&lt;code&gt;ioctl()&lt;/code&gt;系统接口来与&lt;strong&gt;ION&lt;/strong&gt;交互。在client填充&lt;code&gt;ion_allocatoin_data&lt;/code&gt;结构之后，就可以通过调用&lt;code&gt;int ioctl(int client_fd, ION_IOC_ALLOC, struct ion_allocation_data *allocation_data)&lt;/code&gt;来allocate a buffer。这个调用介绍之后，分配的buffer会通过&lt;code&gt;ion_allocatoin_data&lt;/code&gt;的&lt;code&gt;handle&lt;/code&gt;来返回，但是CPU不可以访问这个buffer。这个&lt;code&gt;handle&lt;/code&gt;只可以通过调用&lt;code&gt;int ioctl(int client_fd, ION_IOC_SHARE, struct ion_fd_data *fd_data);&lt;/code&gt;来获得一个用来share的file descriptor。这里，&lt;code&gt;client_fd&lt;/code&gt;参数是前面通过&lt;code&gt;open&lt;/code&gt;获得的一个对应&lt;code&gt;/dev/ion&lt;/code&gt; file descriptor，&lt;code&gt;fd_data&lt;/code&gt;是如下的数据结构，其&lt;code&gt;handle&lt;/code&gt;对应&lt;code&gt;ion_allocation_data::handle&lt;/code&gt;，是input参数；&lt;code&gt;fd&lt;/code&gt;则是output参数，可以用来share。&lt;br/&gt;当一个user process中的client分享(share)了这个&lt;code&gt;fd&lt;/code&gt;之后，在其他user process中(当然，也可share给创建这个&lt;code&gt;fd&lt;/code&gt;的client自己)，为了获得这个shared buffer，先必须通过调用&lt;code&gt;open(&quot;/dev/ion&quot;, O_RDONLY)&lt;/code&gt;获得一个client。(注：&lt;strong&gt;ION&lt;/strong&gt;通过线程的PID来track各个client， 尤其是process中的&quot;group leader&quot;线程的PID。在相同的process中重复调用&lt;code&gt;open(&quot;/dev/ion&quot;, O_RDONLY)&lt;/code&gt;只会获得指向kernel同一个client的another file descriptor)。获得client之后，然后再通过&lt;code&gt;mmap()&lt;/code&gt;函数来把这个&lt;code&gt;fd&lt;/code&gt;映射到address space of process(&lt;a href=&quot;http://man7.org/linux/man-pages/man2/mmap.2.html&quot;&gt;mmap函数参考1&lt;/a&gt;，&lt;a href=&quot;http://www.cnblogs.com/xmphoenix/archive/2011/08/20/2146938.html&quot;&gt;参考2&lt;/a&gt;)。如果要释放这个&lt;code&gt;fd&lt;/code&gt;对应的buffer，在调用&lt;code&gt;mmap()&lt;/code&gt;的process中，先要通过&lt;code&gt;munmap()&lt;/code&gt;来取消&lt;code&gt;mmap()&lt;/code&gt;的效果。然后在之前share这个&lt;code&gt;fd&lt;/code&gt;的client中，需要通过&lt;code&gt;int ioctl(int client_fd, ION_IOC_FREE, struct ion_handle_data *handle_data);&lt;/code&gt;来关闭这个&lt;code&gt;fd&lt;/code&gt;对应的file descriptor。其中，&lt;code&gt;ion_handle_data&lt;/code&gt;表示前面通过&lt;code&gt;ION_IOC_ALLOC&lt;/code&gt;命令获得的&lt;code&gt;handle&lt;/code&gt;，其定义如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;     struct ion_handle_data {
         struct ion_handle *handle;
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;ION_IOC_FREE&lt;/code&gt;命令会导致对应的&lt;code&gt;handle&lt;/code&gt;的计数减1。当&lt;code&gt;handle&lt;/code&gt;计数为0的时候，其指向的&lt;code&gt;ion_handle&lt;/code&gt;对象就会被销毁，并且相关的&lt;strong&gt;ION bookkeeping&lt;/strong&gt;数据结构也会更新。&lt;/p&gt;
&lt;h5 id=&quot;demo&quot;&gt;Demo&lt;/h5&gt;
&lt;p&gt;在这个Demo中，&lt;code&gt;fd&lt;/code&gt;在同一个client中被share使用：&lt;a href=&quot;http://devarea.com/android-ion/#.W_lnfOgzaH8&quot;&gt;来源&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;sys/ioctl.h&amp;gt;
#include &amp;lt;sys/mman.h&amp;gt;

#include &quot;/home/developer/kernel3.4/goldfish/include/linux/ion.h&quot;

void main()
{
    struct ion_fd_data fd_data;
    struct ion_allocation_data ionAllocData;
    ionAllocData.len=0x1000;
    ionAllocData.align = 0;
    ionAllocData.flags = ION_HEAP_TYPE_SYSTEM;

    int fd=open(&quot;/dev/ion&quot;,O_RDWR);
    ioctl(fd,ION_IOC_ALLOC, &amp;amp;ionAllocData);
    fd_data.handle = ionAllocData.handle;
    ioctl(fd,ION_IOC_SHARE,&amp;amp;fd_data); 
    int *p = mmap(0,0x1000,PROT_READ|PROT_WRITE,MAP_SHARED,fd_data.fd,0);
    p[0]=99;
    perror(&quot;test&quot;);
    printf(&quot;hello all %d\n&quot;,p[0]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;在kernel中share-ion-buffer&quot;&gt;在kernel中share ION buffer&lt;/h3&gt;
&lt;p&gt;在kernel中支持multiple clients，每一个使用&lt;strong&gt;ION&lt;/strong&gt;功能的driver都可以在kernel中对应一个client。一个kernel driver通过调用&lt;code&gt;struct ion_client *ion_client_create(struct ion_device *dev, unsigned int heap_mask, const char *debug_name)&lt;/code&gt;来获得一个&lt;strong&gt;ION&lt;/strong&gt; client handle（注意，前面在user space中通过&lt;code&gt;open(&quot;/dev/ion&quot;, O_RDONLY)&lt;/code&gt;返回的client是&lt;code&gt;int&lt;/code&gt;类型）。&lt;code&gt;dev&lt;/code&gt;参数是一个和&lt;code&gt;/dev/ion&lt;/code&gt;相关的&lt;strong&gt;global ION device&lt;/strong&gt;，&lt;code&gt;heap_mask&lt;/code&gt;参数和之前提到的&lt;code&gt;ion_allocation_data&lt;/code&gt;的&lt;code&gt;flags&lt;/code&gt;成员一样的含义。&lt;br/&gt;当在user space中通过&lt;code&gt;ION_IOC_SHARE&lt;/code&gt;命令得到一个buffer的file descriptor并把它传递给kernel之后，kernel driver通过调用&lt;code&gt;struct ion_handle *ion_import_fd(struct ion_client *client, int fd_from_user);&lt;/code&gt;来把这个fd变成一个&lt;code&gt;ion_handle&lt;/code&gt;对象，这个对象就是这个driver中对相应的buffer一个client-local reference。&lt;code&gt;ion_import_fd&lt;/code&gt;方法会根据这个buffer的物理地址来查找：在本client中是否已经obtained一个对应此buffer的&lt;code&gt;ion_handle&lt;/code&gt;，如果是的话，那么就可以简单的增加这个&lt;code&gt;ion_handle&lt;/code&gt;的引用计数即可。&lt;br/&gt;有些硬件只能通过physical addresses来操作physically-contiguous buffers，那么，这些对应的drivers就需要通过调用&lt;code&gt;int ion_phys(struct ion_client *client, struct ion_handle *handle, ion_phys_addr_t *addr, size_t *len)&lt;/code&gt;来把&lt;code&gt;ion_handle&lt;/code&gt;转变成一个physical buffer。当然，如果这个buffer不是physically contiguous，那么这个调用就会失败。&lt;br/&gt;当处理一个来自client的调用时，&lt;strong&gt;ION&lt;/strong&gt;会validates 输入的 file descriptor, client and handle arguments。比如&lt;strong&gt;ION&lt;/strong&gt;会确保 file descriptor是由&lt;code&gt;ION_IOC_SHARE&lt;/code&gt;命令创建的；比如当&lt;code&gt;ion_phys()&lt;/code&gt;调用时，&lt;strong&gt;ION&lt;/strong&gt;会检测这个buffer是否在这个client对应有访问权限list中，如果不是，那么就会返回错误。这样的验证机制能够减少可能的unwanted accesses以及疏忽的内存泄露。&lt;br/&gt;&lt;strong&gt;ION&lt;/strong&gt;通过debugfs提供可视化的debug，它通过在/sys/kernel/debug/ion下面，使用stored files来记录相应的heaps和clients，并使用symbolic names或者PIDs来标志。&lt;/p&gt;
&lt;h3 id=&quot;比较ion和dmabuf&quot;&gt;比较ION和DMABUF&lt;/h3&gt;
&lt;p&gt;本节部分翻译。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ION&lt;/strong&gt;和&lt;strong&gt;DMABUF&lt;/strong&gt;都是通过传递一个匿名file descriptor对象，给其他client一个基于引用计数的访问权限，从而达到分享内存的目的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ION&lt;/strong&gt;通过一个可分享和追踪的方式从预留的memory pool中分配内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DMABUF&lt;/strong&gt;更多的专注于buffer导入、导出以及同步的方式来实现在&lt;strong&gt;NON-ARM&lt;/strong&gt;架构上的buffer的分享。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ION&lt;/strong&gt;目前&lt;strong&gt;只支持Android kernel&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ION&lt;/strong&gt;所有的user-space program都可以通过&lt;em&gt;/dev/ion&lt;/em&gt;接口来分配&lt;strong&gt;ION&lt;/strong&gt;内存。但是在Android会通过验证user和group IDs的方式来阻止对&lt;strong&gt;ION&lt;/strong&gt;的非授权访问。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://lwn.net/Articles/480055/&quot;&gt;The Android ION memory allocator&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://web.cse.ohio-state.edu/~xuan.3/courses/694/Memory-Management.pdf&quot;&gt;Good PDF&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://lwn.net/Articles/565469/&quot;&gt;Integrating the ION memory allocator&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://android.googlesource.com/platform/system/core/+/master/libion/ion.c&quot;&gt;ION.C&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://android.googlesource.com/platform/system/core/+/master/libion/original-kernel-headers/linux/ion.h&quot;&gt;ION.H&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://devarea.com/android-ion/#.W_qMsegzaH9&quot;&gt;DEMO&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/jacky_perf/article/details/51992664&quot;&gt;CSDN&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 27 Nov 2018 13:50:00 +0000</pubDate>
<dc:creator>willhua</dc:creator>
<og:description>The Android ION memory allocator</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willhua/p/10029280.html</dc:identifier>
</item>
</channel>
</rss>