<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java源码安全审查 - 大道方圆</title>
<link>http://www.cnblogs.com/xdecode/p/9252113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xdecode/p/9252113.html</guid>
<description>&lt;p&gt;最近业务需要出一份Java Web应用源码安全审查报告, 对比了市面上数种工具及其分析结果, 基于结果总结了一份规则库. 本文目录结构如下: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180709065207738-1918048937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;检测工具&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;FindSecurityBugs&lt;/h4&gt;
&lt;p&gt;基于class文件分析, 他是大名鼎鼎的findbugs的插件,  安装比较简单. 在&lt;a href=&quot;http://findbugs.sourceforge.net/downloads.html&quot; target=&quot;_blank&quot;&gt;findbugs官网&lt;/a&gt;下载安装包,  &lt;a href=&quot;http://find-sec-bugs.github.io/download.htm&quot; target=&quot;_blank&quot;&gt;插件jar&lt;/a&gt;, 把jar放到findbugs-3.0.1\plugin目录.&lt;/p&gt;
&lt;p&gt;打开bin路径下的findbugs.bat启动软件. 在菜单栏 - 编辑 - 选项可以查看插件是否启用成功.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180703100830226-1476370001.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建项目, 输入名称, 选择需要分析的class路径, 引用的第三方包地址, 源码路径, 点击Analyze即可. &lt;/p&gt;
&lt;p&gt;最终生成的结果可以转为html报告, 也可以导出xml文件, 在findbugs分析查看. 本文主要关注Security一栏.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180703101650940-1527143347.png&quot; alt=&quot;&quot; width=&quot;699&quot; height=&quot;463&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;代码卫士&lt;/h4&gt;
&lt;p&gt;360出品, 名声似乎不太好, 误报比较多, 不过结果也有一定的参考价值. 如果代码在&lt;a href=&quot;https://gitee.com/&quot; target=&quot;_blank&quot;&gt;码云&lt;/a&gt;的话, 点服务一栏, 可以在线扫描码云库里的源码, 本地代码要去&lt;a href=&quot;http://www.codesafe.cn/&quot; target=&quot;_blank&quot;&gt;官网&lt;/a&gt;申请试用.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180702065903742-1662114067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扫描结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180703102016467-1994147687.png&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;382&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;Fortify&lt;/h4&gt;
&lt;p&gt;HP出品的老牌扫描工具, 网上有&lt;a href=&quot;http://www.9553.com/soft/46695.htm&quot; target=&quot;_blank&quot;&gt;破解的&lt;/a&gt;. 安装过程一路next即可. 最后启动AuditWorkBench, 选择scan java project, 耐心等待.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180702070439268-2097041680.png&quot; alt=&quot;&quot; width=&quot;539&quot; height=&quot;404&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果跟findbugs类似.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180704063148385-1143389515.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;326&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;CodePecker&lt;/h3&gt;
&lt;p&gt;啄木鸟源码分析, 国内的一款也是基于字节码分析的工具, 提供了一个收费的&lt;a href=&quot;http://www.cloudcp.cn/login.action&quot; target=&quot;_blank&quot;&gt;在线审计平台&lt;/a&gt;. 知乎有不少软文, 没找到免费试用的地方, 放弃了.&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;结果分析&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;代码注入&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;命令注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;命令注入是指应用程序执行命令的字符串或字符串的一部分来源于不可信赖的数据源，程序没有对这些不可信赖的数据进行验证、过滤，导致程序执行恶意命令的一种攻击方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        String dir = request.getParameter(&quot;dir&quot;&lt;span&gt;);
        Process proc &lt;/span&gt;= Runtime.getRuntime().exec(&quot;cmd.exe /c dir&quot; + dir);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果攻击者传递了一个dir形式为&quot;dummy &amp;amp;&amp;amp; del c:\\dbms\\*.*&quot;的字符串，那么该段代码将会在执行其他指定命令的同时执行这条删除命令。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    （1）程序对非受信的用户输入数据进行净化，删除不安全的字符。&lt;br/&gt;    （2）限定输入类型, 创建一份安全字符串列表，限制用户只能输入该列表中的数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方式1&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!Pattern.matches(&quot;[0-9A-Za-z@.]+&quot;&lt;span&gt;, dir)) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Handle error&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方式2&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; number = Integer.parseInt(request.getParameter(&quot;dir&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (number) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 btype = &quot;tables&quot;
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Option 1&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt; 2&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 btype = &quot;users&quot;
&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Option 2&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             ......
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HTTP响应截断&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;程序从一个不可信赖的数据源获取数据，未进行验证就置于HTTP头文件中发给用户，可能会导致HTTP响应截断攻击。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    String author =&lt;span&gt; request.getParameter(AUTHOR_PARAM);
    ... 
    Cookie cookie &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Cookie(&quot;author&quot;&lt;span&gt;, author);
    cookie.setMaxAge(cookieExpiration);
    response.addCookie(cookie);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么如果攻击者提交的是一个恶意字符串，比如“Wiley Hacker\r\nHTTP/1.1 200 OK\r\n...”，那么HTTP响应就会被分割成以下形式的两个响应：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;    HTTP/1.1 200 OK    &lt;/p&gt;
&lt;p&gt;　...    &lt;/p&gt;
&lt;p&gt;    Set-Cookie: author=Wiley Hacker    &lt;/p&gt;
&lt;p&gt;    HTTP/1.1 200 OK    &lt;/p&gt;
&lt;p&gt;    ...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样第二个响应已完全由攻击者控制，攻击者可以用所需的头文件和正文内容构建该响应实施攻击。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;防止HTTP响应截断攻击的最安全的方法是创建一份安全字符白名单，只接受完全由这些受认可的字符组成的输入出现在HTTP响应头文件中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        String author =&lt;span&gt; request.getParameter(AUTHOR_PARAM);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Pattern.matches(&quot;[0-9A-Za-z]+&quot;&lt;span&gt;, author)) {
            ...
            Cookie cookie &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Cookie(&quot;author&quot;&lt;span&gt;, author);
            cookie.setMaxAge(cookieExpiration);
            response.addCookie(cookie);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SQL注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SQL注入是一种数据库攻击手段。攻击者通过向应用程序提交恶意代码来改变原SQL语句的含义，进而执行任意SQL命令，达到入侵数据库乃至操作系统的目的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　　　　　　String sqlString = &quot;SELECT * FROM db_user WHERE username = '&quot; + username + &quot;' AND password = '&quot; + pwd + &quot;'&quot;&lt;span&gt;; 
            Statement stmt &lt;/span&gt;=&lt;span&gt; connection.createStatement(); 
            ResultSet rs &lt;/span&gt;= stmt.executeQuery(sqlString); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;攻击者能够替代username和password中的任意字符串，它们可以使用下面的关于password的字符串进行SQL注入。&lt;/p&gt;
&lt;p&gt;SELECT * FROM db_user WHERE username='' AND password='' OR '1'='1' &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;造成SQL注入攻击的根本原因在于攻击者可以改变SQL查询的上下文，使程序员原本要作为数据解析的数值，被篡改为命令了。防止SQL注入的方法如下：&lt;br/&gt;    （1）正确使用参数化API进行SQL查询。&lt;br/&gt;    （2）如果构造SQL指令时需要动态加入约束条件，可以通过创建一份合法字符串列表，使其对应于可能要加入到SQL指令中的不同元素，来避免SQL注入攻击。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        String sqlString = &quot;select * from db_user where username=? and password=?&quot;&lt;span&gt;;
        PreparedStatement stmt &lt;/span&gt;=&lt;span&gt; connection.prepareStatement(sqlString);
        stmt.setString(&lt;/span&gt;1&lt;span&gt;, username);
        stmt.setString(&lt;/span&gt;2&lt;span&gt;, pwd);
        ResultSet rs &lt;/span&gt;= stmt.executeQuery();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;正则表达式注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据被传递至应用程序并作为正则表达式使用。可能导致线程过度使用 CPU 资源，从而导致拒绝服务攻击。 &lt;/p&gt;
&lt;p&gt;下述代码java中字符串的split, replaceAll均支持正则的方式, 导致CPU挂起.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; String input = &quot;0000000000000000000000000000000000000000000000&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(input.split(&quot;(0*)*A&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(&quot;耗时:&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;该正则的意思是说匹配器在输入的末尾并没有检测到”A”。现在外侧的限定符后退一次，内存的则前进一次，如此重复，无法得到结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;因此，匹配器逐步回退，并尝试所有的组合以找出匹配符号。它最终将返回(没有匹配的结果)，但是该过程的复杂性是指数型的(输入中添加一个字符加倍了运行时间)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用线程池 + Future, 限定执行时间, 并捕获异常.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         ExecutorService service = Executors.newFixedThreadPool(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Future result = service.submit(&lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Object&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object call() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;final&lt;/span&gt; String input = &quot;0000000000000000000000000000000000000000000000&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; input.split(&quot;(0*)*A&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        service.shutdown();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(result.get(5, TimeUnit.SECONDS));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;LDAP注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;LDAP注入是指客户端发送查询请求时，输入的字符串中含有一些特殊字符，导致修改了LDAP本来的查询结构，从而使得可以访问更多的未授权数据的一种攻击方式。&lt;/p&gt;
&lt;p&gt;以下代码动态构造一个 LDAP 查询，并对其加以执行，该查询可以检索所有报告给指定经理的雇员记录。该经理的名字是从 HTTP 请求中读取的，因此不可信任。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     DirContext ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InitialDirContext(env);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     String managerName = request.getParameter(&quot;managerName&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;retrieve all of the employees who report to a manager&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     String filter = &quot;(manager=&quot; + managerName + &quot;)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     NamingEnumeration employees = ctx.search(&quot;ou=People,dc=example,dc=com&quot;,filter);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果攻击者为 managerName 输入字符串 Hacker, Wiley)(|(objectclass=*)，则该查询会变成：&lt;br/&gt;  (manager=Hacker, Wiley)(|(objectclass=*))&lt;/p&gt;
&lt;p&gt;根据执行查询的权限，增加 |(objectclass=*) 条件会导致筛选器与目录中的所有输入都匹配，而且会使攻击者检索到有关用户输入池的信息。&lt;/p&gt;
&lt;p&gt;如果攻击者能够控制查询的命令结构，那么这样的攻击至少会影响执行 LDAP 查询的用户可以访问的所有记录。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用白名单的方法，确保LDAP查询中由用户控制的数值完全来自于预定的字符集合，应不包含任何LDAP元字符。&lt;/p&gt;
&lt;p&gt;比如使用Spring框架中EqualsFilter类来构造一个编码得当的筛选器字符串.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    DirContext ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InitialDirContext(env);
    String managerName &lt;/span&gt;= request.getParameter(&quot;managerName&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;retrieve all of the employees who report to a manager&lt;/span&gt;
    EqualsFilter filter = &lt;span&gt;new&lt;/span&gt; EqualsFilter(&quot;manager&quot;&lt;span&gt;, managerName);
    NamingEnumeration employees &lt;/span&gt;= ctx.search(&quot;ou=People,dc=example,dc=com&quot;,filter.toString());
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;输入验证&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;拒绝服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;拒绝服务是攻击者通过极度消耗应用资源，以致程序崩溃或其他合法用户无法进行使用的一种攻击方式。&lt;/p&gt;
&lt;p&gt;例如解压文件前，未检查文件大小，攻击者可以通过提供一个超大文件，实施DOS攻击。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 　　 FileOutputStream fos = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(entry.getName());
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     dest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedOutputStream(fos, BUFFER);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; ((count = zis.read(data, 0, BUFFER)) != -1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         dest.write(data, 0&lt;span&gt;, count);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对涉及到系统资源的外部数据应该进行严格校验，防止无限制的输入。对于用户上传的文件, 要在后台进行大小校验. &lt;/p&gt;
&lt;p&gt;比如对解压文件进行验证，超过100M，将抛出异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (entry.getSize() &amp;gt;&lt;span&gt; TOOBIG) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;File to be unzipped is huge.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;重定向参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;应用程序允许未验证的用户输入控制重定向中的URL,可能会导致攻击者发动钓鱼攻击。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
         String url = request.getParameter(&quot;url&quot;&lt;span&gt;);
          response.sendRedirect(url);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;创建一份合法URL列表，用户只能从中进行选择，进行重定向操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;XML实体注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简称XXE攻击, XML解析器中默认会解析xml中的ENTITY来支持全局变量以及外部文件读取.&lt;/p&gt;
&lt;p&gt;如果从web请求中获取xml内容, 并在服务器端解析, 则可能导致xxe攻击.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         DocumentBuilderFactory dbf =&lt;span&gt; DocumentBuilderFactory.newInstance();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         DocumentBuilder db =&lt;span&gt; dbf.newDocumentBuilder();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Document doc =&lt;span&gt; db.parse(xmlFile);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         NodeList list = doc.getElementsByTagName(&quot;active&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    （1）关闭XML实体解析&lt;/p&gt;
&lt;p&gt;    （2）使用JSON来替代XML做数据传输&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; DocumentBuilderFactory dbf =&lt;span&gt;DocumentBuilderFactory.newInstance();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; dbf.setExpandEntityReferences(&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;资源注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用用户输入控制资源标识符，借此攻击者可以访问或修改其他受保护的系统资源。当满足以下两个条件时，就会发生资源注入：&lt;br/&gt;    （1）攻击者可以指定已使用的标识符来访问系统资源。例如，攻击者可能可以指定用来连接到网络资源的端口号。 &lt;br/&gt;    （2）攻击者可以通过指定特定资源来获取某种权限，而这种权限在一般情况下是不可能获得的。例如，程序可能会允许攻击者把敏感信息传输到第三方服务器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         URL url = &lt;span&gt;new&lt;/span&gt; URL(request.getParameter(&quot;remoteURL&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         URLConnection connection =&lt;span&gt; url.openConnection();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;         ...
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         String remotePort = request.getParameter(&quot;remotePort&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         ServerSocket srvr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServerSocket(remotePort);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         Socket skt = srvr.accept();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用白名单策略, 限制资源文件读取和访问.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日志伪造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;允许日志记录未经验证的用户输入，会导致日志伪造攻击。攻击者可能通过破坏文件格式或注入意外的字符，从而使文件无法使用。&lt;/p&gt;
&lt;p&gt;更阴险的攻击可能会导致日志文件中的统计信息发生偏差, 掩护攻击者的跟踪轨迹.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (loginSuccessful) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        logger.severe(&quot;User login succeeded for: &quot; +&lt;span&gt; username);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         logger.severe(&quot;User login failed for: &quot; +&lt;span&gt; username);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;攻击者可以将username替换为一个多行字符串，如下所示：&lt;br/&gt;    jack&lt;br/&gt;    2013-7-30 java.util.logging.LogManager log&lt;br/&gt;    Server: User login succeeded for: Tom&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对不可信赖的数据进行校验。&lt;/p&gt;
&lt;p&gt;另外日志中不应该出现敏感数据, 例如密码, 手机号, 邮箱这些信息.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!Pattern.matches(&quot;[A-Za-z0-9_]+&quot;&lt;span&gt;, username)) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Unsanitized username&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;        logger.severe(&quot;User login failed for unauthorized user&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (loginSuccessful) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         logger.severe(&quot;User login succeeded for: &quot; +&lt;span&gt; username);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     } 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;文件校验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于用户上传的文件, 需要在前后台双重校验, 校验后缀, 文件大小, 二进制头等等.&lt;/p&gt;
&lt;p&gt;其他可输入项, 也要做前后台双重校验, 防止中间人修改数据.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对文件二进制头进行校验&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         MAGIC_NUMBER.put(&quot;jpg&quot;, &lt;span&gt;new&lt;/span&gt; String[]{&quot;FFD8&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         MAGIC_NUMBER.put(&quot;gif&quot;, &lt;span&gt;new&lt;/span&gt; String[]{&quot;47494638&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         MAGIC_NUMBER.put(&quot;png&quot;, &lt;span&gt;new&lt;/span&gt; String[]{&quot;89504E470D0A1A0A&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         MAGIC_NUMBER.put(&quot;pdf&quot;, &lt;span&gt;new&lt;/span&gt; String[]{&quot;25504446&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         MAGIC_NUMBER.put(&quot;doc&quot;, &lt;span&gt;new&lt;/span&gt; String[]{&quot;D0CF11E0A1B11AE1&quot;, &quot;7B5C72746631&quot;&lt;span&gt;}); 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         MAGIC_NUMBER.put(&quot;xls&quot;, &lt;span&gt;new&lt;/span&gt; String[]{&quot;D0CF11E0A1B11AE1&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         MAGIC_NUMBER.put(&quot;ppt&quot;, &lt;span&gt;new&lt;/span&gt; String[]{&quot;D0CF11E0A1B11AE1&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         MAGIC_NUMBER.put(&quot;docx&quot;, &lt;span&gt;new&lt;/span&gt; String[]{&quot;504B0304&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         MAGIC_NUMBER.put(&quot;xlsx&quot;, &lt;span&gt;new&lt;/span&gt; String[]{&quot;504B0304&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         MAGIC_NUMBER.put(&quot;pptx&quot;, &lt;span&gt;new&lt;/span&gt; String[]{&quot;504B0304&quot;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * 在检验范围内（MAGIC_NUMBER.keySet(): jpg, gif, png, pdf, xls, ppt, doc, xlsx, pptx, docx）
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;     * 且文件后缀和文件二进制头不一致。返回false
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; checkFileType(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] content, String suffix) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;MAGIC_NUMBER.keySet().contains(suffix)) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] bytes = Arrays.copyOfRange(content, 0&lt;span&gt;, Math.min(content.length, MAGIC_HEADER_LENGTH));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         String fileCode =&lt;span&gt; getFileHeader(bytes);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String magicNumber : MAGIC_NUMBER.get(suffix)) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (fileCode.toUpperCase().startsWith(magicNumber)) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;span&gt;&lt;strong&gt;密码管理&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;硬编码密码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序中采用硬编码方式处理密码，一方面会降低系统安全性，另一方面不易于程序维护。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; String rootManagerPassword =&lt;span&gt; DEFAULTADMINPASSWORD;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (password == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             password = &quot;123456&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;程序中所需密码应从配置文件中获取经过加密的密码值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;弱加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在安全性要求较高的系统中，使用不安全的加密算法（如DES、RC4、RC5等），将无法保证敏感数据的保密性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;             Cipher des = Cipher.getInstance(&quot;DES&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             SecretKey key = KeyGenerator.getInstance(&quot;DES&quot;).generateKey();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用安全的加密算法（如AES、3DES、RSA)对敏感数据进行加密。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;             Cipher aes = Cipher.getInstance(&quot;AES&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             KeyGenerator kg = KeyGenerator.getInstance(&quot;AES&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             kg.init(128&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             SecretKey key = kg.generateKey();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;不安全的Hash&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在安全性要求较高的系统中，不应使用被业界公认的不安全的哈希算法（如MD2、MD4、MD5、SHA、SHA1等)来保证数据的完整性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;             MessageDigest messageDigest = MessageDigest.getInstance(&quot;MD5&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             messageDigest.update(stringID.getBytes());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;采用散列值&amp;gt;=224比特的SHA系列算法（如SHA-224、SHA-256、SHA-384和SHA-512）来保证敏感数据的完整性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         md = MessageDigest.getInstance(&quot;SHA-256&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        md.update(bt);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         strDes = bytes2Hex(md.digest()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; to HexString&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;不安全的随机数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java API中提供了java.util.Random类实现PRNG()，该PRNG是可移植和可重复的，如果两个java.util.Random类的实例使用相同的种子，会在所有Java实现中生成相同的数值序列。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Random对象r和s设置了相同的种子，因此 i == j 以及数组b[]和c[]的相应值是相等的。&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         Random r = &lt;span&gt;new&lt;/span&gt; Random(12345&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; r.nextInt();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] b = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        r.nextBytes(b);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         Random s = &lt;span&gt;new&lt;/span&gt; Random(12345&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; j =&lt;span&gt; s.nextInt();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;byte&lt;/span&gt;[] c = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         s.nextBytes(c);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用更安全的随机数生成器，如java.security.SecureRandom类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         SecureRandom number = SecureRandom.getInstance(&quot;SHA1PRNG&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         System.out.println(number.nextInt()  + &quot;  &quot; + number.nextInt());
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;跨站脚本&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;XSS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序从数据库或其它后端数据存储获取不可信赖的数据，在未检验数据是否存在恶意代码的情况下，便将其传送给了Web用户，应用程序将易于受到存储型XSS攻击。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         PrintWriter writer =&lt;span&gt; WebUtils.createPrintWriter(res);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        writer.print(str);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        writer.flush();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         writer.close();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对输出的字符串内容进行html转义编码.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String replaceScript4Xss(String message) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isEmpty(message)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StringUtils.EMPTY;
    }
    StringBuffer builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; StringBuffer(message.length() * 2&lt;span&gt;);
    CharacterIterator it &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringCharacterIterator(message);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;char&lt;/span&gt; ch = it.first(); ch != CharacterIterator.DONE; ch =&lt;span&gt; it.next()) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((((ch &amp;gt; '`') &amp;amp;&amp;amp; (ch &amp;lt; '{')) || ((ch &amp;gt; '@') &amp;amp;&amp;amp; (ch &amp;lt; '['&lt;span&gt;)))
                &lt;/span&gt;|| (((ch == ' ') || ((ch &amp;gt; '/') &amp;amp;&amp;amp; (ch &amp;lt; ':'))) || (((ch == '.') || (ch == ',')) || ((ch == '-') || (ch == '_'&lt;span&gt;))))) {
            builder.append(ch);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            builder.append(&lt;/span&gt;&quot;&amp;amp;#&quot; + (&lt;span&gt;int&lt;/span&gt;) ch + &quot;;&quot;&lt;span&gt;);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder.toString();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;CSRF跨站&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;跨站请求伪造(CSRF)是伪造客户端请求的一种攻击。应用程序允许用户提交不包含任何保密信息的请求，将可能导致CSRF攻击。&lt;/p&gt;
&lt;p&gt;如以下代码片段用于银行转账功能，若对于该重要敏感的操作没有进行相应防护，将易于导致跨站请求伪造攻击。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &amp;lt;form method=&quot;GET&quot; action=&quot;/transferFunds &quot; &amp;gt; 
&lt;span&gt;2&lt;/span&gt;        cash: &amp;lt;input type=&quot;text&quot; name=&quot;cash&quot;&amp;gt; 
&lt;span&gt;3&lt;/span&gt;        to: &amp;lt;input type=&quot; text &quot; name=“to&quot;&amp;gt; 
&lt;span&gt;4&lt;/span&gt;        &amp;lt;input type=&quot;submit&quot; name=&quot;action&quot; value=&quot;TransferFunds&quot;&amp;gt; 
&lt;span&gt;5&lt;/span&gt;     &amp;lt;/form&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    （1）二次验证，进行重要敏感操作时，要求用户进行二次验证。&lt;br/&gt;    （2）验证码，进行重要敏感操作时，加入验证码。&lt;br/&gt;    （3）在重要敏感操作的表单中加入隐藏的Token, 服务器端程序响应用户请求前先验证Token，判断请求的合法性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cookie属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookie未设置httponly以及secure属性.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Cookie cookie = &lt;span&gt;new&lt;/span&gt; Cookie(&quot;userName&quot;&lt;span&gt;,userName);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; response.addCookie(cookie);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Cookie cookie = &lt;span&gt;new&lt;/span&gt; Cookie(&quot;userName&quot;&lt;span&gt;,userName);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; cookie.setSecure(&lt;span&gt;true&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Secure flag&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; cookie.setHttpOnly(&lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Cookie生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookie生命周期不应该超过一年.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Cookie cookie = &lt;span&gt;new&lt;/span&gt; Cookie(&quot;email&quot;&lt;span&gt;, email);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; cookie.setMaxAge(60*60*24*365);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;jsessionid&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;登录前后改变jsessionid标识, 修改配置容器, 增强jsessionid算法逻辑.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; HttpSession oldSession = req.getSession(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldSession != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;废弃旧的session, 否则每次退出后再登录, jsessionid不会变化.&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    oldSession.invalidate();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; HttpSession session = req.getSession(&lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;SecurityHeaders&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置更安全的HTTP Header&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;             res.addHeader(&quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             res.addHeader(&quot;X-XSS-Protection&quot;, &quot;1; mode=block&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             res.addHeader(&quot;X-Frame-Options&quot;, &quot;SAMEORIGIN&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             res.addHeader(&quot;Content-Security-Policy&quot;, &quot;object-src 'self'&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;             res.addHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             res.addHeader(&quot;Pragma&quot;, &quot;no-cache&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;             res.addDateHeader(&quot;Expires&quot;, 0);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;资源管理&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;日期格式化 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SimpleDateFormat 非线程安全的，parse()和format()方法包含一个可导致用户看到其他用户数据的race condition。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleDateFormat dateFormat;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用ThreadLocal放置SimpleDateFormat或者同步锁的方式.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;访问权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;程序未进行恰当的访问权限控制，执行了一个包含用户控制主键的SQL语句，可能会导致攻击者访问未经授权的记录。&lt;br/&gt;如下面代码片段中的SQL语句用于查询与指定标识符相匹配的清单。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     id = Integer.decode(request.getParameter(&quot;invoiceID&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     String query = &quot;SELECT * FROM invoices WHERE id = ?&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     PreparedStatement stmt =&lt;span&gt; conn.prepareStatement(query);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     stmt.setInt(1&lt;span&gt;, id);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     ResultSet results = stmt.execute();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先判断当前用户权限是否可以增删数据, 可以通过把当前被授权的用户名作为查询语句的一部分来实现。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     userName =&lt;span&gt; ctx.getAuthenticatedUserName();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     id = Integer.decode(request.getParameter(&quot;invoiceID&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     String query = 
&lt;span&gt;4&lt;/span&gt;         &quot;SELECT * FROM invoices WHERE id = ? AND user = ?&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     PreparedStatement stmt =&lt;span&gt; conn.prepareStatement(query);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     stmt.setString(1&lt;span&gt;, id);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     stmt.setString(2&lt;span&gt;, userName);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     ResultSet results = stmt.execute();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;API限流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于开放的API进行限流操作, 防止资源耗尽. 例如获取IP城市 或者 天气等等, 限制每个IP每小时最多调用1000次之类的.&lt;/p&gt;
&lt;p&gt;简单实现可以用计数器限流, 另外Guava提供了RateLimiter可以实现令牌桶算法限流.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; RateLimiter limiter =&lt;span&gt; caches.get(ip);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (limiter.tryAcquire()) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     System.out.println(i + &quot; success &quot; + &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;HH:mm:ss.sss&quot;).format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     System.out.println(i + &quot; failed &quot; + &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;HH:mm:ss.sss&quot;).format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;资源释放&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一些资源文件, 使用完毕后要在finally语句中进行释放, 例如connection, 文件句柄, socket等等.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             DatabaseMetaData e =&lt;span&gt; connection.getMetaData();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             ResultSet rs1 =&lt;span&gt; e.getTableTypes();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            ......
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SQLException e) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; StringUtils.EMPTY;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;            DBUtils.close(connection);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;路径遍历&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用程序对用户可控制的输入未经合理校验，就传送给一个文件API。攻击者可能会使用一些特殊的字符（如“..”和“/”）摆脱受保护的限制，访问一些受保护的文件或目录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1     String path =&lt;span&gt; getInputPath();
2     if (path.startsWith(&quot;/safe_dir/&quot;&lt;span&gt;)){
3         File f = new&lt;span&gt; File(path);
4 &lt;span&gt;        f.delete()
5     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;攻击者可能提供类似下面的输入：/safe_dir/../important.dat&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用白名单策略, 限制资源文件读取和访问.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路径输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;禁止输出服务器绝对路径到前端.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         PrintWriter writer =&lt;span&gt; WebUtils.createPrintWriter(res);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         writer.write(file.getAbsolutePath());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用相对路径&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据跨越信任边界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据从一个不可信赖域存储到一个可信赖域导致程序错误信赖未验证的数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
1        String name = req.getParameter(&quot;userName&quot;&lt;span&gt;);
2        HttpSession sess =&lt;span&gt; req.getSession();
3        sess.setAttribute(&quot;user&quot;, name);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数据跨越信任边界时需要进行合理的验证，保证信赖域中数据是安全的。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;配置管理&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;Session失效配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将Session的失效时间设置为30分钟或更少，既能使用户在一段时间内与应用程序互动，又提供了一个限制窗口攻击的合理范围。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;session-config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;session-timeout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;30&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;session-timeout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;session-config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;错误页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Web应用程序的默认错误页面不应显示程序的敏感信息。Web应用程序应该为4xx（如404）错误、5xx（如503）错误、java.lang.Throwable异常定义一个错误页面，防止攻击者挖掘应用程序容器内置错误响应信息。报错页面中不应该包含类名, 方法名, 执行堆栈等信息.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;应用程序应该在web.xml中配置默认的错误页面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;error-page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;error-code&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;403&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;error-code&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/common/403.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;error-page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;error-page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;error-code&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;404&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;error-code&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/common/404.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;error-page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;error-page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;error-code&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;500&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;error-code&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/common/500.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;error-page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;error-page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exception-type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;java.lang.Throwable&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exception-type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/common/error.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;error-page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;不安全的SSLContext&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  　　　　SSLContext.getInstance(&quot;SSL&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;配置web容器使用更安全的TLSv1.2协议.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; 　　　　 SSLContext.getInstance(&quot;TLS&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;未加密的Socket&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         ServerSocket soc = &lt;span&gt;new&lt;/span&gt; ServerSocket(1234&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Socket soc = &lt;span&gt;new&lt;/span&gt; Socket(&quot;www.google.com&quot;,80&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         ......
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;修复方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         ServerSocket soc = SSLServerSocketFactory.getDefault().createServerSocket(1234&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        ......
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Socket soc = SSLSocketFactory.getDefault().createSocket(&quot;www.google.com&quot;, 443&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         ......
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;不安全的FTP协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码中使用SFTP替代FTP&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;          Channel channel = session.openChannel(&quot;sftp&quot;&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;          channel.connect();  
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 08 Jul 2018 22:53:00 +0000</pubDate>
<dc:creator>大道方圆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xdecode/p/9252113.html</dc:identifier>
</item>
<item>
<title>乌镇区块链大会随记 - amongv587</title>
<link>http://www.cnblogs.com/amongv587/p/9281908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/amongv587/p/9281908.html</guid>
<description>&lt;h2&gt;火币孵化器孵化的项目：&lt;/h2&gt;
&lt;p&gt;MobileCoin: 隐私保护&lt;/p&gt;
&lt;p&gt;OASIS LABS: &lt;/p&gt;
&lt;p&gt;Certik&lt;/p&gt;
&lt;p&gt;Republic: 美国证券交易委员会， 推动区块链合规化&lt;/p&gt;
&lt;p&gt;支点：&lt;/p&gt;
&lt;p&gt;Libra Credit：&lt;/p&gt;


&lt;h2&gt;朱波孵化的项目：&lt;/h2&gt;
&lt;p&gt;链报：做区块链的搜索引擎辅助投资者投资。&lt;/p&gt;
&lt;p&gt;分析是否有人有坐庄等行为。&lt;/p&gt;


&lt;h2&gt;TASChain—吴轶群---虾米音乐创始人&lt;/h2&gt;
&lt;h3&gt;商用智能合约COM&lt;/h3&gt;
&lt;p&gt;安全计算、有用的DAPP，类库支持&lt;/p&gt;

&lt;h3&gt;P2P网络强化：&lt;/h3&gt;
&lt;p&gt;防火墙穿透率：90%-96%&lt;/p&gt;

&lt;p&gt;虾米音乐：区块链加数字版权&lt;/p&gt;
&lt;p&gt;两项穿透技术专利&lt;/p&gt;
&lt;p&gt;一项去中心化的技术专利&lt;/p&gt;



&lt;h3&gt;设备指纹&lt;/h3&gt;
&lt;p&gt;多维向量数据采集&lt;/p&gt;
&lt;p&gt;数据安全性&lt;/p&gt;
&lt;p&gt;弱特征组合&lt;/p&gt;
&lt;p&gt;深度贝叶斯网络DBN&lt;/p&gt;
&lt;p&gt;准确率：99%&lt;/p&gt;

&lt;p&gt;在线即挖矿&lt;/p&gt;
&lt;p&gt;设备即押金&lt;/p&gt;
&lt;p&gt;VRF（组间）+POW(组内)&lt;/p&gt;

&lt;h2&gt;身份链---中钞区块链研究所-张义峰&lt;/h2&gt;
&lt;p&gt;不同网站都需要维护一个账号&lt;/p&gt;

&lt;h2&gt;IOMob---共享的城市交通&lt;/h2&gt;
&lt;p&gt;实现电动摩托车共享、公共和私人自行车共享服务等。&lt;/p&gt;


&lt;h2&gt;本体Ont-----温萌萌&lt;/h2&gt;

&lt;h2&gt;AChain&lt;/h2&gt;
&lt;p&gt;可以构造自己的区块链网络---悟空网络&lt;/p&gt;

&lt;h2&gt;ZOS-----高潮&lt;/h2&gt;

&lt;h2&gt;Top 链&lt;/h2&gt;
&lt;p&gt;全球第一个基于区块链的分布式通信云：&lt;/p&gt;
&lt;p&gt;解决问题&lt;/p&gt;
&lt;p&gt;（1）      互联互通。 Whatsapp 微信  facebook等等&lt;/p&gt;
&lt;p&gt;（2）      隐私安全问题&lt;/p&gt;
&lt;p&gt;（3）      经济成本问题&lt;/p&gt;
&lt;p&gt;应用APP：VPN服务，voip服务，视频通话，网盘与UGC，SMS服务，Messaging，直播与CDN服务。&lt;/p&gt;

&lt;p&gt;颠覆现有的通信系统。&lt;/p&gt;
&lt;p&gt;原有应用迁移：Dingtone(10亿分钟/每年)，CoverMe(400万用户)，SkyVPN(每天 120T)&lt;/p&gt;
&lt;p&gt;易建立繁荣生态系统&lt;/p&gt;
&lt;p&gt;Steven说 Telegram是拷贝他们的应用，然后开源的。&lt;/p&gt;
&lt;p&gt;对标Status  orbid protocol  telegram ton。&lt;/p&gt;
&lt;p&gt;IPFS可能第三代去中心化的存储服务，TOP要做去中心化的通信服务，通信社交应用的基础设施：TeleOS Protocol&lt;/p&gt;

&lt;h2&gt;Yeecall&lt;/h2&gt;
&lt;p&gt;区块链时代的基础设施。&lt;/p&gt;
&lt;p&gt;他们用区块链解决了跨境通信的漫游问题：&lt;/p&gt;
&lt;p&gt;原来系统在全世界有5个数据中心，400多个传输节点，整网处理能力大概是5K-1万，改造分布式节点为全节点，数据全同步。通信处理能力提高到了1万-1万5。&lt;/p&gt;
&lt;p&gt;公链的发展最后要解决的主要是：计算、存储、带宽问题。&lt;/p&gt;

&lt;h2&gt;Vanbex:&lt;/h2&gt;

&lt;h2&gt;TrustNote chain&lt;/h2&gt;
&lt;p&gt;Trust Token Things&lt;/p&gt;
&lt;p&gt;极轻，极趣， 极速&lt;/p&gt;

&lt;h2&gt;Bumo blockchain&lt;/h2&gt;
&lt;p&gt;从2014年开始的：&lt;/p&gt;
&lt;p&gt;开源，共建子链。&lt;/p&gt;
&lt;p&gt;跨链，让主网可以兼容其他形态的主网&lt;/p&gt;
&lt;p&gt;TPS:2000+ 公链&lt;/p&gt;
&lt;p&gt;已经有的项目：&lt;/p&gt;



&lt;h2&gt;矩阵元—juice/jugo基于以太坊改的：&lt;/h2&gt;
&lt;p&gt;异构计算。软硬件协同进化。&lt;/p&gt;
&lt;p&gt;（1）重写了编译器，&lt;/p&gt;
&lt;p&gt;（2）软件进化已经到了一个瓶颈，FPGA用来解决问题。&lt;/p&gt;

&lt;p&gt;支付、清算、结算合二为一&lt;/p&gt;
&lt;p&gt;清算交收一体化&lt;/p&gt;
&lt;p&gt;原来的交易是单向性的，大致是从下往上的。&lt;/p&gt;
&lt;p&gt;连接节点会越来越多，树状结构的架构会有问题。&lt;/p&gt;

&lt;p&gt;未来数据时代：&lt;/p&gt;
&lt;p&gt;（1）      原生数据的采集和生产&lt;/p&gt;
&lt;p&gt;（2）      数据的存储和计算&lt;/p&gt;
&lt;p&gt;（3）      数据的分发和交换&lt;/p&gt;
&lt;p&gt;（4）      数据的分析和处理&lt;/p&gt;

&lt;p&gt;分别对应着&lt;/p&gt;
&lt;p&gt;IOT+IIOT&lt;/p&gt;
&lt;p&gt;云计算&lt;/p&gt;
&lt;p&gt;区块链&lt;/p&gt;
&lt;p&gt;AI+大数据&lt;/p&gt;

&lt;p&gt;全数字世界的根本挑战：盲人摸象。获取所有数据的成本太高。&lt;/p&gt;
&lt;p&gt;数据的收集方和使用方，数据没有办法定价，只有流动性的数据才能定价。&lt;/p&gt;
&lt;p&gt;区块链=下一代计算架构？&lt;/p&gt;
&lt;p&gt;计算+存储+通信&lt;/p&gt;
&lt;p&gt;原生的区块链没有任何的隐私属性。有充沛的隐私保护属性，数据才有可能流动。&lt;/p&gt;
&lt;p&gt;使用有效算力共识：DPOS+零知识证明。&lt;/p&gt;
&lt;p&gt;基于计算的智能合约：合约计算化、计算合约化&lt;/p&gt;
&lt;p&gt;PBFT: 20个节点就很难运转了。7-10个节点复杂合约，TPS:200-300. 简单合约和单一网络可以达到1000-2000. 实际生产环境200-300其实是足够的。不追求TPS.&lt;/p&gt;

&lt;p&gt;雄安租房：政府部门之间数据可以访问，但是数据不需要拷贝。&lt;/p&gt;
&lt;p&gt;上海清算所&lt;/p&gt;
&lt;p&gt;数据协同操作&lt;/p&gt;
&lt;p&gt;航空：&lt;/p&gt;

&lt;h2&gt;三三复杂美：&lt;/h2&gt;
&lt;p&gt;从2013年开始就开始申请了50项关于区块链的专利。&lt;/p&gt;
&lt;p&gt;票据系统已经落地了很多应用了。&lt;/p&gt;

&lt;h2&gt;IDHub—曲明&lt;/h2&gt;
&lt;p&gt;从15年开始探索。&lt;/p&gt;
&lt;p&gt;传统的数字身份：&lt;/p&gt;
&lt;p&gt;（1）      侧重于身份验证&lt;/p&gt;
&lt;p&gt;（2）      中心化账户模型&lt;/p&gt;
&lt;p&gt;（3）      打通多维多方数据，建立身份体系&lt;/p&gt;
&lt;p&gt;区块链数字身份：&lt;/p&gt;
&lt;p&gt;（1）      自主性和隐私保护&lt;/p&gt;
&lt;p&gt;（2）      以关系属性定义数字身份&lt;/p&gt;
&lt;p&gt;（3）      通过经济激励模型，构建多方的身份验证体系。&lt;/p&gt;

&lt;p&gt;难点：&lt;/p&gt;
&lt;p&gt;（1）      自主性的“度”:数据和隐私保护的平衡&lt;/p&gt;
&lt;p&gt;（2）      个人数据的确权和有效存储的控制&lt;/p&gt;
&lt;p&gt;（3）      自主身份的经济激励&lt;/p&gt;
&lt;p&gt;（4）      自主身份对现实世界的赋能与链接。&lt;/p&gt;

&lt;p&gt;电子政务：16年和佛山政府签约. 59个应用零跑腿。自然人和法人的数字身份&lt;/p&gt;
&lt;p&gt;电子互联网：HiveVelocity.&lt;/p&gt;


&lt;h2&gt;GoWithMini---李东&lt;/h2&gt;
&lt;p&gt;去中心化的地图来支持共享经济。（共享经济的市场5200亿， 54%增长）&lt;/p&gt;
&lt;p&gt;差异化：数据：建立一个众包地图，数据贡献者可以获得利益。&lt;/p&gt;
&lt;p&gt;空间节点自制，空间可以划分owner。&lt;/p&gt;
&lt;p&gt;冷启动：发展中国家；用户来创建地图数据。&lt;/p&gt;

&lt;p&gt;在手机OS层面，解决数据隐私问题。&lt;/p&gt;
&lt;p&gt;瞄准市场：东南亚、非洲、南美。&lt;/p&gt;
&lt;p&gt;已经上线3个月：100万用户。&lt;/p&gt;

&lt;p&gt;采用：DPOS。&lt;/p&gt;
&lt;p&gt;核心技术：地图数据实时编译。&lt;/p&gt;
&lt;p&gt;UGC数据共识机制：采用谢林点的堆成协调博弈机制，随机选取多个轻节点POSW方式交叉验证，兼顾低成本和准确率。&lt;/p&gt;
&lt;p&gt;核心技术：手机加密定位。自身位置不会泄露，同时可以帮你赚钱。&lt;/p&gt;

&lt;h2&gt;CarLiveChain—齐宪威&lt;/h2&gt;
&lt;p&gt;带千万级用户all in 车联网区块链&lt;/p&gt;
&lt;p&gt;中国：1500亿美金的市场。&lt;/p&gt;
&lt;p&gt;生态对于数据的需要：跟车相关的社交、消费、安全等需求。&lt;/p&gt;
&lt;p&gt;车联网区块链价值演进：阿里巴巴中心化运营管理经验—&amp;gt;御途优选场景化电商—&amp;gt;小车哎呦移动互联网社交—&amp;gt;车联网公链&lt;/p&gt;
&lt;p&gt;回归用户的价值，维护用户的中长期的价值。&lt;/p&gt;


&lt;h2&gt;HelloPay/LanguagePay&lt;/h2&gt;
&lt;p&gt;分发电子货币给用户，鼓励用户使用电子货币来进行社交旅游等服务。&lt;/p&gt;


&lt;h2&gt;链安科技&lt;/h2&gt;
&lt;p&gt;形式化验证做区块链安全。&lt;/p&gt;

&lt;h2&gt;方图---蔡良滨&lt;/h2&gt;
&lt;p&gt;场外衍生品市场&lt;/p&gt;



&lt;h2&gt;RRchain  ---刘爽&lt;/h2&gt;
&lt;p&gt;区块链再分布式计算市场的应用&lt;/p&gt;
&lt;p&gt;算力供应者：贡献算力的个体可以获得激励。&lt;/p&gt;

&lt;p&gt;对比GOLEM&lt;/p&gt;


&lt;h2&gt;溢唐数据—曾熙&lt;/h2&gt;
&lt;p&gt;双十一：25.6万/秒。&lt;/p&gt;
&lt;p&gt;上海交易所：8万/秒&lt;/p&gt;

&lt;h2&gt;DropChain ---陈显达&lt;/h2&gt;
&lt;p&gt;食物供应链行业的应用 。&lt;/p&gt;

&lt;p&gt;40billion dollars&lt;/p&gt;

&lt;h2&gt;量子链---帅初&lt;/h2&gt;
&lt;p&gt;开发X86的虚拟机，方便大家开发部署合约。&lt;/p&gt;


&lt;h2&gt;CarBlock&lt;/h2&gt;
&lt;p&gt;（1）      通过区块链把数据所有权拿回来给用户。&lt;/p&gt;
&lt;p&gt;（2）      用户授权车厂收集数据，用户付收据收集费&lt;/p&gt;
&lt;p&gt;（3）      用户数据可以交易，获得收益&lt;/p&gt;

&lt;p&gt;数据不会被篡改，没有人可以窥探数据。&lt;/p&gt;
&lt;p&gt;在欧美已经有41万车在CarBlock上跑着。&lt;/p&gt;
&lt;p&gt;已经签了美国最大的后装车辆网提供商，最大的前装车联网提供商，最大的上门服务提供商，最大的维修站等。&lt;/p&gt;

&lt;h2&gt;云象科技&lt;/h2&gt;
&lt;p&gt;联盟链和公有链&lt;/p&gt;
&lt;h2&gt;菩提预测市场—林吓洪&lt;/h2&gt;

&lt;h2&gt;芯链---HBP&lt;/h2&gt;
&lt;p&gt;VISA:4万4每秒&lt;/p&gt;

&lt;p&gt;软硬件协同，硬件加速的公链。&lt;/p&gt;

&lt;h2&gt;六域链&lt;/h2&gt;
&lt;p&gt;基于物联网的国际标准开发的。&lt;/p&gt;
&lt;p&gt;共识：SDFT---RAFT变种&lt;/p&gt;

&lt;h2&gt;CyberVein:&lt;/h2&gt;
&lt;p&gt;去中心化的数据存储、安全和应用。DAG架构、POC----分布式数据库。&lt;/p&gt;



&lt;h2&gt;比原链&lt;/h2&gt;
&lt;h2&gt;链报&lt;/h2&gt;
&lt;p&gt;做区块链的搜索引擎，分析区块链数据，看是否有人坐庄等。&lt;/p&gt;



&lt;h2&gt;区块链的产业趋势： 火币研究所：袁煜明&lt;/h2&gt;
&lt;p&gt;整体趋势:&lt;/p&gt;
&lt;p&gt;(1)    渗透----从传统金融到加密金融渗透。&lt;/p&gt;
&lt;p&gt;(2)    应用----应用场景加上区块链&lt;/p&gt;
&lt;p&gt;(3)    并购-----市值已经大的项目，并购其他互联网项目。&lt;/p&gt;
&lt;p&gt;(4)    用户-----当前用户数不多。全球2000万不到，中国可能才百万用户。&lt;/p&gt;
&lt;p&gt;(5)    代际------以年轻人为主&lt;/p&gt;
&lt;p&gt;(6)    性别------主要是以男生为主。类似于淘宝，刚开始男生玩，后面女生也开始加入。&lt;/p&gt;
&lt;p&gt;五大板块：&lt;/p&gt;
&lt;p&gt;1、 硬件和基础设施----利用科学计算来做POW。&lt;/p&gt;

&lt;p&gt;2、 公链平台：&lt;/p&gt;
&lt;p&gt;3、 中间层：中间层的出现和成熟会加速Dapp的开发和落地，垂直行业dapps的发展会引发新的需求。&lt;/p&gt;
&lt;p&gt;4、 服务层：去中心化和中心化的加密资产交易所将共存；市场行情信息提供商；电子钱包是分布式应用程序的切入点&lt;/p&gt;
&lt;p&gt;5、 应用层：沟通效率低下，信用成本高；对数据验证和共识有很大需求；对数据共享和高计算能力有很大需求。&lt;/p&gt;

&lt;p&gt;区块链技术发展：&lt;/p&gt;
&lt;p&gt;建立公共和去中心化的经济。 （P2P网络，分布式账本， 分布式经济）&lt;/p&gt;
&lt;p&gt;技术上的问题：可扩展性（交易验证速度慢，交易处理能力弱---解决方案：改变共识机制，改变交易验证过程），隐私性（区块链特性：透明，可追溯，可验证；解决方案：Coinjoin, 环签名，零知识证明，匿名网络）、互操作性（资产不可转让，没有交流和互动，解决方案：公链、中继、侧链、分布式秘钥、哈希锁定）。&lt;/p&gt;

&lt;p&gt;火币：去中心化、社区自治、安全、可监管、可扩展&lt;/p&gt;

&lt;h2&gt;资产数字化&lt;/h2&gt;
&lt;p&gt;大资管时代的来临&lt;/p&gt;
&lt;p&gt;新时代寻找的是共识&lt;/p&gt;
&lt;p&gt;（1）      货币数字化&lt;/p&gt;
&lt;p&gt;（2）      股权数字化&lt;/p&gt;



&lt;h2&gt;跨链&lt;/h2&gt;
&lt;p&gt;多链并行，协同&lt;/p&gt;
&lt;h2&gt;未来的金融---ZOS-高潮：&lt;/h2&gt;
&lt;p&gt;全球成为分布式金融，融资世界化、金融无中介（《没有银行的世界》）、投资全球化，信贷智能化、资产数字化&lt;/p&gt;


&lt;h2&gt;区块链1.0  2.0  3.0 的划分&lt;/h2&gt;
&lt;p&gt;OK资本的解读：电子货币，智能合约，消费者领域。&lt;/p&gt;

&lt;h2&gt;Token/通证经济学&lt;/h2&gt;
&lt;p&gt;Token是价值承载和流通的必需。&lt;/p&gt;



&lt;h2&gt;什么是真正的区块链精神---陈伟星&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;区块链的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;见证账本----去中心化的账本记录见证来替代记账中介&lt;/p&gt;
&lt;p&gt;见证合约----去中心化的合约执行见证来代替合约中介&lt;/p&gt;
&lt;p&gt;保护隐私数据价值----将数据价值回归给每一个用户&lt;/p&gt;

&lt;p&gt;将金融中介的利润降下来，只有劳动才能创造财富。&lt;/p&gt;


&lt;h2&gt;不可能三角&lt;/h2&gt;
&lt;p&gt;分散性、安全和并发处理不可能都达到&lt;/p&gt;


&lt;h2&gt;本体Ont—温萌萌&lt;/h2&gt;
&lt;p&gt;构建下一代信任互联网的基础和下一代信任协作平台&lt;/p&gt;

&lt;h2&gt;公链生态建设&lt;/h2&gt;
&lt;p&gt;（1）      钱包支持&lt;/p&gt;
&lt;p&gt;（2）      电子货币交易&lt;/p&gt;
&lt;p&gt;（3）      智能合约&lt;/p&gt;
&lt;p&gt;（4）      数字资产&lt;/p&gt;
&lt;h2&gt;公链如何成功&lt;/h2&gt;
&lt;p&gt;区块链生态：创新的技术+活跃的社区+丰富的应用&lt;/p&gt;

&lt;h2&gt;如何落地—工信部工业经济研究所所长-于佳宁&lt;/h2&gt;
&lt;p&gt; 实体经济的基本逻辑：&lt;/p&gt;
&lt;p&gt;（1）      产业协作环境的信息化&lt;/p&gt;
&lt;p&gt;（2）      电子信息可信化&lt;/p&gt;
&lt;p&gt;（3）      数据资源资产化&lt;/p&gt;
&lt;p&gt;（4）      “信任传递”的数据资源共享机制&lt;/p&gt;
&lt;p&gt;（5）      平台机构自证清白&lt;/p&gt;
&lt;p&gt;（6）      政府实现穿透式监管&lt;/p&gt;
&lt;p&gt;（7）      多主体平等协作联盟组织&lt;/p&gt;
&lt;p&gt;落地场景：&lt;/p&gt;
&lt;p&gt;（1）      微版权&lt;/p&gt;
&lt;p&gt;（2）      商品溯源&lt;/p&gt;
&lt;p&gt;（3）      供应链金融—中小微企业；金融脱虚向实的助推器&lt;/p&gt;
&lt;p&gt;（4）      大数据—六合数字；征信等；数据无法自证。&lt;/p&gt;
&lt;p&gt;等&lt;/p&gt;
&lt;h2&gt;数据流动起来才是资产&lt;/h2&gt;
&lt;p&gt;数据作为资产的交换，才生产货币度量衡的需求。&lt;/p&gt;


&lt;h2&gt;区块链不是为了解决原子交易的性能问题&lt;/h2&gt;
&lt;p&gt;双十一场景下，没有提交事务，原子化交易是没有提交的。&lt;/p&gt;
&lt;p&gt;区块链是为了解决支付清算交收一体化。&lt;/p&gt;

&lt;h2&gt;需要做数据对平的场景可以运用区块链&lt;/h2&gt;
&lt;h2&gt;数字身份领域会有一家独角兽&lt;/h2&gt;
&lt;h2&gt;法定数字货币发出来之后的承载体是什么&lt;/h2&gt;
&lt;p&gt;数字身份&lt;/p&gt;

&lt;h2&gt;行业上链，通证先行&lt;/h2&gt;
&lt;p&gt;协作：行业上下游的强协作激励机制&lt;/p&gt;
&lt;p&gt;品牌：通证全球流通，建立全球品牌&lt;/p&gt;
&lt;p&gt;组织：新的行业协会，社区自治组织&lt;/p&gt;
&lt;p&gt;自金融：从自媒体到自金融。&lt;/p&gt;
&lt;p&gt;超越公司：利益关联方VS股东。&lt;/p&gt;


&lt;h2&gt;区块链的代币是高效的融资方式&lt;/h2&gt;
&lt;h2&gt;行业的沉淀期，应该是要积累技术的&lt;/h2&gt;
&lt;h2&gt;公链的发展一定是需要的是应用&lt;/h2&gt;
&lt;p&gt;公链里面的币值太高，不利于应用的落地。&lt;/p&gt;
&lt;p&gt;最后能够落地的一定是要重视用户的应用&lt;/p&gt;

&lt;h2&gt;构建价值协议&lt;/h2&gt;



&lt;h2&gt;区块链挑战—本体Ont—温萌萌&lt;/h2&gt;
&lt;p&gt;（1）      扩展性&lt;/p&gt;
&lt;p&gt;（2）      隐私性---GPDR:数据可以删除，数据可以迁移。 分布式的身份识别。&lt;/p&gt;
&lt;p&gt;（3）      基础设施和工具缺乏。方便开发者快速开发应用程序&lt;/p&gt;
&lt;p&gt;（4）      共识机制：可扩展性、公平性、快速达成共识。&lt;/p&gt;
&lt;p&gt;（5）      政策支持：与主流商业体系的对接。 公链是需要时间验证的。&lt;/p&gt;
&lt;p&gt;（6）      技术、业务、社区、市场、资金、人才、法律。&lt;/p&gt;


&lt;h2&gt;区块链的价值投资---朱波&lt;/h2&gt;
&lt;p&gt;互联网泡沫-à&lt;/p&gt;
&lt;p&gt;一定要回归创业者的心态，你到底要为行业做什么呢。区块链创业者比股权创业者要求更高。&lt;/p&gt;

&lt;p&gt;区块链的搜索引擎：链报&lt;/p&gt;


&lt;h2&gt;OK资本投资逻辑---周子涵&lt;/h2&gt;
&lt;p&gt;资产、交易成本、协作关系&lt;/p&gt;
&lt;p&gt;现实资产如何上链，如何不损耗真实性有效性。&lt;/p&gt;

&lt;p&gt;深入理解各垂直行业区块链改造力。&lt;/p&gt;
&lt;p&gt;（1）      解决行业的哪些问题。&lt;/p&gt;
&lt;p&gt;（2）      问题是不是制约性的&lt;/p&gt;
&lt;p&gt;（3）      这个行业的原来的利益相关者，有没有去改造的推动力。&lt;/p&gt;



&lt;h2&gt;区块链与社会扩容—李国权—新加坡&lt;/h2&gt;
&lt;p&gt;为社会治理管理提供新的技术手段&lt;/p&gt;
&lt;p&gt;用非中心化和开原型的组织形式来实现不垄断，普惠，安全，所有权共享的社会。&lt;/p&gt;
&lt;p&gt;区块链通过非中心化社区网络来实现共享，利用区块链代币和智能合约来鼓励社区参与者，引导大家尊重社区的利益，在社区决策和治理层面上智能合约的约定，仍然是中心化的，兼顾效率和普惠。&lt;/p&gt;
&lt;p&gt;例如：基于区块链的IoMob, 打通客运企业应用APP，组成本地客运企业生态圈、进而形成城市群生态圈。&lt;/p&gt;

&lt;h2&gt;浙江—杭州&lt;/h2&gt;
&lt;p&gt;区块链特色小镇、区块链产业园等&lt;/p&gt;
&lt;p&gt;打造区块链研究和应用高地。&lt;/p&gt;
&lt;p&gt;杭州有40多家区块链企业&lt;/p&gt;

&lt;p&gt;课题：如何用区块链技术来解决垃圾回收问题&lt;/p&gt;

&lt;h2&gt;中国通证经济领袖计划—元道&lt;/h2&gt;
&lt;p&gt;中关村区块链联盟理事长 元道&lt;/p&gt;

</description>
<pubDate>Sun, 08 Jul 2018 16:32:00 +0000</pubDate>
<dc:creator>amongv587</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/amongv587/p/9281908.html</dc:identifier>
</item>
<item>
<title>MySQL中间件之ProxySQL(5)：线程、线程池、连接池 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9281909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9281909.html</guid>
<description>&lt;p&gt;ProxySQL由多个模块组成，是一个多线程的daemon类程序。每个模块都有一个或多个线程去执行任务。&lt;/p&gt;
&lt;p&gt;例如，以下是刚启动ProxySQL时的进程情况，一个main进程，一个主线程，21个线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@s1 ~]# pstree | grep proxy    
        |-proxysql---proxysql---21*[{proxysql}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是正常运行时使用的线程列表：&lt;/p&gt;

&lt;h2 id=&quot;main-thread&quot;&gt;1.1 Main thread&lt;/h2&gt;
&lt;p&gt;这其实是一个进程，该进程只负责引导、启动核心模块以及启动其它核心线程。&lt;/p&gt;

&lt;h2 id=&quot;admin-thread&quot;&gt;1.2 Admin thread&lt;/h2&gt;
&lt;p&gt;该线程负责以下几件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化并引导启动Admin接口。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;从磁盘数据库或配置文件中加载配置，为ProxySQL的运行提供环境。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;启动一个监听者，让其负责监听并接受到Admin接口的新连接，并为每个这样的连接创建一个新线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，每连接一次admin接口，就会新生成一个线程。每次退出admin接口时，减去一个线程。&lt;/p&gt;

&lt;h2 id=&quot;mysql-workers&quot;&gt;1.3 MySQL workers&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mysql-threads&lt;/code&gt;线程负责处理MySQL流量，包括所有来自客户端的连接以及所有到后端服务器节点的连接。也就是：用少量线程处理任意多数量的连接。&lt;/p&gt;
&lt;p&gt;MySQL workers线程在相同的端口上进行监听。当新客户端发起连接请求，其中一个MySQL worker线程将成功接受该连接，并创建一个MySQL会话(session)：客户端和会话绑定在该worker线程上，直到连接断开。换句话说，在断开连接之前，某客户端的所有连接总是被同一个worker线程处理。&lt;/p&gt;
&lt;p&gt;默认情况下，MySQL worker的线程数量为4。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;mysql&amp;gt; select @@mysql-threads;
+-----------------+
| @@mysql-threads |
+-----------------+
| 4               |
+-----------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mysql-threads&lt;/code&gt;变量修改后，必须重启ProxySQL才能生效，这是少有的需要重启的变量之一(另一个是&lt;code&gt;mysql-stacksize&lt;/code&gt;)。例如，修改为8个mysql worker线程。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;set mysql-threads=8;
save mysql variables to disk;

select * from runtime_global_variables 
 where variable_name='mysql-threads';
+---------------+----------------+
| variable_name | variable_value |
+---------------+----------------+
| mysql-threads | 4              |
+---------------+----------------+

service proxysql stop
service proxysql start

select * from runtime_global_variables 
 where variable_name='mysql-threads';
+---------------+----------------+
| variable_name | variable_value |
+---------------+----------------+
| mysql-threads | 8              |
+---------------+----------------+&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;mysql-auxiliary-threads&quot;&gt;1.4 MySQL auxiliary threads&lt;/h2&gt;
&lt;p&gt;这些线程其实就是&lt;strong&gt;空闲线程(idle threads)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果proxysql使用&lt;code&gt;--idle-threads&lt;/code&gt;选项启动，每个worker线程都会&lt;strong&gt;伴随启动一个&lt;/strong&gt;auxiliary线程。每个worker线程以及它的auxiliary线程一起工作：第一个线程处理活动的连接，并将所有的空闲连接派遣到第二个线程上，但第二个线程只要等待到了发生在空闲连接上的一个事件(或超时)，就会将连接还给第一个线程。&lt;/p&gt;
&lt;p&gt;当活动的客户端连接数量远少于空闲客户端连接数量时，强烈建议使用&quot;idle threads&quot;。这使得ProxySQL可以处理几十万个连接(测试时是100W个连接)。&lt;/p&gt;

&lt;h2 id=&quot;monitor模块相关的线程&quot;&gt;1.5 Monitor模块相关的线程&lt;/h2&gt;
&lt;p&gt;monitor模块有自己的线程管理系统，还有自己的线程池。正常情况下，monitor模块有以下几个线程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个master线程，负责生成、协调其它monitor相关的线程。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;一个负责监控&lt;code&gt;connect&lt;/code&gt;的线程。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;一个负责监控&lt;code&gt;ping&lt;/code&gt;的线程。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;一个负责监控&lt;code&gt;read_only&lt;/code&gt;的线程。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;一个负责监控&lt;code&gt;replication lag&lt;/code&gt;的线程。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;一个线程池提供monitor worker线程，上面每个监控线程都是任务的生产者，worker线程从任务队列消费一个任务并执行该任务。该线程池初始时默认为mysql thread的两倍。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;线程池负责执行所有的检查任务，并通过以上各调度线程来监控调度情况。线程池会基于监控队列中待检查的数量多少而自动增长、收缩。基于检查的结果，会使用相同的线程对结果进行处理，例如避开一个节点、重新配置一个主机组。&lt;/p&gt;

&lt;h2 id=&quot;query-cache-purge-thread&quot;&gt;1.6 Query Cache purge thread&lt;/h2&gt;
&lt;p&gt;该线程是需要时才生成的，它扮演的是垃圾收集器，回收查询缓存。通过垃圾收集器，可保证在客户端等待响应的过程中绝不会回收缓存。&lt;/p&gt;

&lt;h2 id=&quot;其它线程&quot;&gt;1.7 其它线程&lt;/h2&gt;
&lt;p&gt;在ProxySQL运行过程中，偶尔会派生临时线程，这些临时线程是为了向后端发送KILL语句，以便杀掉后端服务器上对查询长时间无响应的查询线程。&lt;/p&gt;
&lt;p&gt;此外，ilbmariadbclient库还会使用一些后台线程，这些线程是为了和后端MySQL server进行一些特定的异步交互任务。&lt;/p&gt;
&lt;p&gt;还有一些模块，例如内置的Http server，正处于实验阶段的cluster、ClickHouse Server、SQLite3 Server，如果启用了这些功能，则会按需创建它们对应的线程。&lt;/p&gt;


&lt;p&gt;在ProxySQL中，有两个地方使用了线程池：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;快速建立和后端MySQL的连接：ProxySQL为了尽快和后端MySQL建立新的TCP连接，使用了一个线程池来等待accept()返回新连接。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Monitor模块：为了尽快执行各监控线程生产的监控任务，monitor模块提供了一个monitor worker线程池，可以快速从任务队列中消费任务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是，正常情况下，MySQL worker线程是最繁忙、最消耗CPU资源的部分，但在一个极其繁忙的环境下，monitor模块需要监控的连接数过多，消耗的CPU也是不可忽视的。&lt;/p&gt;


&lt;p&gt;ProxySQL同样有两个连接池，和线程池部分是对应的。&lt;/p&gt;

&lt;h2 id=&quot;快速连接到后端mysql节点&quot;&gt;3.1 快速连接到后端MySQL节点&lt;/h2&gt;
&lt;p&gt;线程池是为了快速和后端建立新的TCP连接，而这里的连接池是为了快速和后端建立连接。&lt;/p&gt;
&lt;p&gt;ProxySQL使用一个连接池来存放一定数量的&quot;之前已经和某后端建立连接，但当前是空闲连接&quot;的连接。当需要向这些连接对应的后端发送新的数据包时，可以快速地取回连接，因为这些连接早已经被打开。&lt;/p&gt;
&lt;p&gt;当应用程序发送了一个MySQL请求给ProxySQL时，ProxySQL首先解析要路由到哪个后端，如果连接池中已经有和该后端的连接，将重用该连接，否则将创建一个新的和后端的连接。&lt;/p&gt;
&lt;p&gt;当处理完客户端的请求后，连接会还回主机组管理器(HostGroup Manager)。如果主机组管理器判断了该连接是可以被安全共享的，且连接池未满，则该连接会放进连接池。&lt;/p&gt;
&lt;p&gt;放进连接池的连接都是空闲连接，正在使用的连接是不可能进入连接池的。ProxySQL会定期发送ping消息来维持空闲连接。如果某连接从上一次ping之后，如果还没有被使用，则该连接被定义为空闲连接。对于空闲连接ping的时间间隔由变量mysql-ping_interval_server_msec控制。&lt;/p&gt;
&lt;p&gt;但是，不是所有的未使用的连接都会放进连接池。该变量用来控制某后端的空闲连接和最大总连接数的百分比。对于每个hostgroup/backend，主机组管理器只会保持连接池中的最大连接数为&lt;code&gt;mysql-free_connections_pct * mysql_servers.max_connections / 100&lt;/code&gt;。池中的每个空闲连接都通过间断性的ping来维持它的打开状态。&lt;/p&gt;
&lt;p&gt;当一个连接放回连接池时，会计算这个连接之后还能处理多少个语句，当处理的语句数量达到该阈值后，将关闭该连接(v1.4.3之前)或者重置该连接(从v1.4.4开始)。&lt;/p&gt;

&lt;h3 id=&quot;相关变量&quot;&gt;3.1.1 相关变量&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;mysql-ping_interval_server_msec&lt;/code&gt;&lt;br/&gt;ProxySQL为了维持和后端的空闲连接，每隔一段时间发送一次ping，该变量指定发起ping的时间间隔。默认值为10000毫秒(即10秒)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mysql-ping_timeout_server&lt;/code&gt;&lt;br/&gt;ProxySQL为了维持和后端的空闲连接，每隔一段时间发送一次ping。该变量指定ping得到回复的超时时间。默认值为200毫秒。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mysql-connection_max_age_ms&lt;/code&gt;&lt;br/&gt;当该变量设置的值大于0时(单位毫秒)，如果某个空闲连接(当前没有任何会话使用)的空闲时长超过了这里设置的值，则这个连接会关闭。默认值为0，表示不会因为存活时间而关闭空闲连接。&lt;/p&gt;

&lt;h2 id=&quot;monitor模块的连接池&quot;&gt;3.2 Monitor模块的连接池&lt;/h2&gt;
&lt;p&gt;Monitor有它自己的连接池。当连接池中空闲连接的空闲时长达到了&lt;code&gt;3 * mysql-monitor_ping_interval&lt;/code&gt;(毫秒)后，该空闲连接将自动被purge。&lt;/p&gt;
&lt;p&gt;变量&lt;code&gt;mysql-monitor_ping_interval&lt;/code&gt;的默认值为1分钟(60000毫秒)，所以，monitor连接池中的空闲连接默认最长维持3分钟。&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 16:32:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9281909.html</dc:identifier>
</item>
<item>
<title>golang基础---Slice切片 - failymao</title>
<link>http://www.cnblogs.com/failymao/p/9281873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/failymao/p/9281873.html</guid>
<description>&lt;p&gt;&lt;strong&gt;切片Slice在go语言中是单独的类型（指向底层的数组），不同于python(对可迭代对象操作的工具)，注意区分数组和slice的区别&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li&gt;定义一个空slice,格式&lt;code&gt;var s []int&lt;/code&gt;,这种既没有长度也没有元素赋值的类型（相比叫array）&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;数组的基本操作如下 ，类似与python中列表切片的操作，详见实例&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;fmt&quot;

func main() {
    var s1 []int                                //这样就是一个slice类型，既没有长度也没有元素赋值
    a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} //这是一个数组
    s2 := a[5:10]                               //切片，索引5到10的元素，不包含索引为10
    s3 := a[:3]                                 //切片，索引1-3的元素，不包含索引3
    s4 := a[6:]                                 //切片，第6个索引到最后一个索引的元素
    s5 := a[:]                                  //切片，复制一个数组
    fmt.Println(s1)
    fmt.Println(a)
    fmt.Println(s2) //数组的切片，类似python
    fmt.Println(s3)
    fmt.Println(s4)
    fmt.Println(s5)
}

/*输出
s1---&amp;gt;  []
a---&amp;gt;   [0 0 0 0 0 0 0 0 0 0]
s2---&amp;gt;  [6 7 8 9 10]
s3---&amp;gt;  [1 2 3]
s4---&amp;gt;  [7 8 9 10]
s5---&amp;gt;  [1 2 3 4 5 6 7 8 9 10]
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;使用make初始化一个slice类型，包含三个参数&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;①切片类型 []int&lt;/li&gt;
&lt;li&gt;②初始长度 len&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;③容量 cap&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;fmt&quot;

func main() {
    s1 := make([]int, 3, 10)      //使用make初始化一个slice,包含三个参数：①切片类型②初始长度③容量
    fmt.Println(len(s1), cap(s1)) //输出长度，容量
    fmt.Println(s1)
}

/*输出：
len(s1)---&amp;gt;3
cap(s1)---&amp;gt;10
s1---&amp;gt;  [0 0 0]  //可变数组
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Reslice ,在原slice基础上再次切片，slice一个数组时，不仅取出了len,同时容量也会得到相应的切片。&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;//Reslice,在slice基础上再次slice.
package main
import &quot;fmt&quot;

func main() {
    a := []byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'k', 'm'} //定义一个数组，元素为byte类型
    sa := a[3:5]                                             // slice切片，取索引三到五，不包含索引5
    sb := sa[1:3]
    fmt.Println(string(sa))
    fmt.Println(len(sa), cap(sa))
    fmt.Println(string(sb))
    fmt.Println(len(sb), cap(sb))
}

/*输出
sting(sa)---&amp;gt;   de
len(sa)---&amp;gt;     2
cap(sa)---&amp;gt;     6
string(sb)---&amp;gt;  ef
len(sb)---&amp;gt;     2
cap(sb)---&amp;gt;     5
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Append,类似python中list类型，使用append,从数组尾部追加元素&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;14.5&quot;&gt;&lt;li&gt;可以将一个slice追加在另一个slice尾部&lt;/li&gt;
&lt;li&gt;如果最终长度未超过追加到slice的容量，则返回原始slice&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;如果超过追加的slice的容量则将重新分配数组并拷贝原始数据&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;fmt&quot;

func main() {
    s1 := make([]int, 3, 8) //初始化slice,长度位3，容量为8
    fmt.Printf(&quot;%p\n&quot;, s1)  //输出s1的内存地址
    fmt.Println(s1)
    s1 = append(s1, 1, 2, 3) //末尾追加三个元素,cap依然为8
    fmt.Printf(&quot;%p\n&quot;, s1)   //原来的slice
    fmt.Println(s1)
    s1 = append(s1, 1, 2, 3, 4) //继续追加元素，超过原s1容量，会重新分配新的内存地址
    fmt.Printf(&quot;%p\n&quot;, s1)      //cap容量超过8，为9
    fmt.Println(s1)
}

/*
p*s1---&amp;gt;    0xc042070040
s1---&amp;gt;      [0 0 0]
p*s1s1--&amp;gt;   0xc042070040
s1---&amp;gt;      [0 0 0 1 2 3]
p*s1---&amp;gt;    0xc04205e080   //新的内存地址
s1---&amp;gt;      [0 0 0 1 2 3 1 2 3 4]
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;当两个slice同时指向某一个数组时，改变某一个slice索引时，另一个slice索引值及原数组的索引也会改变&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;fmt&quot;

func main() {
    a := []int{1, 2, 3, 4, 5, 6}
    s1 := a[2:5]
    s2 := a[1:3]
    fmt.Println(s1, s2)
    s1[0] = 9
    fmt.Println(s1, s2)
    fmt.Println(a)
}

/*
s1---&amp;gt;  [3 4 5]
s2---&amp;gt;  [2 3]
//更改s1的slice索引后，s2的索引也会改
s1---&amp;gt;  [9 4 5]
s2---&amp;gt;  [2 9]
a---&amp;gt;   [1 2 9 4 5 6]
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;copy，格式 &lt;code&gt;copy(s1,s2)&lt;/code&gt;, 将s2拷贝到s1数组中，当len(s1) &amp;gt; len(s2)时，最终将s2中的索引&lt;br/&gt;替换掉s1的索引，当len(s1)&amp;lt;len(s2)时，s1的索引值全部被对应s2的索引替换&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;package main
import &quot;fmt&quot;

func main() {
    s1 := []int{1, 2, 3, 4, 5}
    s2 := []int{6, 7, 8}
    copy(s1, s2) //将s2的元素拷贝到s1,s2
    fmt.Println(s1)

    copy(s2, s1)
    fmt.Println(s2)

    copy(s1, s2[2:3]) //只拷贝某一切片的索引
    fmt.Println(s1)
}

/*输出
s1---&amp;gt;  [6 7 8 4 5]
s2---&amp;gt;  [1 2 3]
s1---&amp;gt;  [8 2 3 4 5]
*/&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 08 Jul 2018 16:10:00 +0000</pubDate>
<dc:creator>failymao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/failymao/p/9281873.html</dc:identifier>
</item>
<item>
<title>JeeSite 数据权限应用 - tosser</title>
<link>http://www.cnblogs.com/tosser/p/9281853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tosser/p/9281853.html</guid>
<description>&lt;p&gt;　　中午吃饭时看了一下陆毅版的《三国》，刚好看的是蜀军缺粮，诸葛亮让王平去劫司马懿的粮。司马懿看蜀军用木牛流马运量很方便，就抢了蜀军的木牛流马仿制了一批，结果司马懿用它运粮时，被王平冒充司马懿的人在验粮时，对木牛流马动了手脚，结果木牛流马不能动弹了，被蜀军把几十万担的粮食抢走了。看到这里的时候，我想到了我们的项目。网上有个开源项目，在不熟悉的情况下把源码下载下来部署了就敢用？胆子是不是有点大？真遇到类似“木牛流马”的问题，那真的就亏大了啊。难道要联系作者？　　&lt;/p&gt;
&lt;p&gt;　　呵呵～！！言归正传……&lt;/p&gt;
&lt;p&gt;　　在各种系统中，经常会涉及到数据权限的管理。在 JeeSite 开源系统中已经基本给出了一套解决数据权限管理的解决方案。下面来简单的进行说明一下我项目中涉及到的应用。&lt;/p&gt;

&lt;p&gt;问题出发&lt;/p&gt;
&lt;p&gt;　　在系统中每个信息录入人员之间的数据要求在显示时是分离的，即人员 A 录入的信息人员 B 是看不到的，同理人员 B 录入的信息人员 A 同样也是看不到的，人员 A 和人员 B 属于同一个部门。但是，人员 A 和人员 B 的部门负责人可以同时看到人员 A 和人员 B 录入的信息。在这种情况下，就需要使用到数据权限。&lt;/p&gt;

&lt;p&gt;JeeSite 对数据权限的支持&lt;/p&gt;
&lt;p&gt;　　要完成数据权限的功能，需要分为两部分，一部分是设置角色中对“数据范围”的控制，另一部分是在需要进行数据权限控制的地方增加相应的代码。&lt;/p&gt;
&lt;p&gt;　　在角色中设置“数据范围”比较简单，直接操作就可以了，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/892439/201807/892439-20180708234430814-516636203.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　另外一部分则是要增加控制数据权限的代码，增加的方法在 JeeSite 的手册《内置组件的应用》中给出了关于数据权限的说明，说明如下：&lt;/p&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;数据权限&lt;br/&gt;应用场景：某用户访问数据范围：公司及子公司，本公司，部门及子部门，本部门，当前用户，明细设置。&lt;br/&gt;// 生成数据权限过滤条件（dsf为dataScopeFilter的简写，在xml中使用 ${sqlMap.dsf}调用权限SQL）&lt;br/&gt;user.getSqlMap().put(&quot;dsf&quot;, dataScopeFilter(user.getCurrentUser(), &quot;o&quot;, &quot;u&quot;));&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- 分页查询用户信息 --&amp;gt;&lt;br/&gt;&amp;lt;select id=&quot;findList&quot; parameterType=&quot;User&quot; resultMap=&quot;userResult&quot;&amp;gt;&lt;br/&gt;SELECT&lt;br/&gt;        &amp;lt;include refid=&quot;userColumns&quot;/&amp;gt;&lt;br/&gt;FROM sys_user a&lt;br/&gt;        &amp;lt;include refid=&quot;userJoins&quot;/&amp;gt;&lt;br/&gt;WHERE a.del_flag = '0'&lt;br/&gt;        &amp;lt;!-- 数据范围过滤 --&amp;gt;&lt;br/&gt;        ${sqlMap.dsf}&lt;br/&gt;&amp;lt;/select&amp;gt;&lt;/p&gt;
&lt;p&gt;/**&lt;br/&gt; * 数据范围过滤&lt;br/&gt; * @param user 当前用户对象，通过“entity.getCurrentUser()”获取&lt;br/&gt; * @param officeAlias 机构表别名，多个用“,”逗号隔开。&lt;br/&gt; * @param userAlias 用户表别名，多个用“,”逗号隔开，传递空，忽略此参数&lt;br/&gt; * @return 标准连接条件对象&lt;br/&gt; */&lt;br/&gt;String dataScopeFilter (User user, String officeAlias, String userAlias)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　上面就是 JeeSite 手册中介绍的方法，首先要增加“生成数据权限过滤条件”，其次就是要“在 xml 中使用 ${sqlMap.dsf} 调用权限 SQL ”，就是这样的两部分。至于 dataScopeFilter() 是 JeeSite 提供的方法。&lt;/p&gt;
&lt;p&gt;　　JeeSite 支持根据数据库表生成代码的功能，生成的代码包含 4 个 Java 文件、1 个 XML 文件和 2 个 JSP 文件。&lt;/p&gt;
&lt;p&gt;　　比如数据库中的表名是 xxx_yyy ，那么生成的 4 个 Java 文件分别是 XxxYyy.java、XxxYyyController.java、XxxYyyService.java 和 XxxYyyDao.java，生成 XML 文件名是 XxxYyyDao.xml，生成的两个 JSP 文件分别是 XxxYyyForm.jsp 和 XxxYyyList.jsp。&lt;/p&gt;
&lt;p&gt;　　对于改造权限的重点，在于 XxxYyyService.java 文件和 XxxYyyDao.xml 文件中。&lt;/p&gt;

&lt;p&gt;实例演示&lt;/p&gt;
&lt;p&gt;　　按照文档在 XxxYyyService.java 中添加“生成数据权限过滤条件”的代码，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PagefindPage(Pagepage, XxxYyy xxxYyy) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成数据权限过滤条件（dsf为dataScopeFilter的简写，在xml中使用 ${sqlMap.dsf}调用权限SQL）&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     xxxYyy.getSqlMap().put(&quot;dsf&quot;, dataScopeFilter(UserUtils.getUser(), &quot;o&quot;, &quot;u&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.findPage(page, xxxYyy);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先使用 XxxYyy 的对象 xxxYyy 来调用 getSqlMap 方法，在手册中使用的是 user 作为示范的，这里需要替换成自己实际的对象。&lt;br/&gt;　　在 dataScopeFilter() 方法中， o 和 u 是数据表的别名，因为要按照用户或部门进行过滤，因此实际的表要进行左连接，左连接时一般会给表起一个别名，左连接的部分代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; LEFT JOIN sys_user        u ON u.id =&lt;span&gt; a.create_by
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; LEFT JOIN sys_office      o ON u.office_id = o.id
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也就是传入的 o 和 u 分别是 sys_office 表和 sys_user 表的别名，而 u.id=a.create_by 是表示 sys_user 的 id 和主表的 create_by 进行关联，而 u.office_id 和 o.id 进行关联。&lt;/p&gt;
&lt;p&gt;　　基本到了这里第一步的“生成数据权限过滤条件”就完了，第二步需要在 XxxYyy.xml 中引用“ ${sqlMap.dsf} ”。&lt;/p&gt;
&lt;p&gt;　　这里的 XML 文件是 MyBatis，只要在查询的 where 的结尾处引入即可，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;/where&amp;gt;
&lt;span&gt;2&lt;/span&gt;     &amp;lt;!-- 数据范围过滤 --&amp;gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    ${sqlMap.dsf}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &amp;lt;choose&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样就基本可以解决数据权限的问题，并且我用 A 用户录入一条信息，B 用户录入一条信息，A 和 B 用户只能查看自己录入的数据，但是作为 A 和 B 的部门负责人 C 可以同时查看他们录入的数据。&lt;/p&gt;

&lt;p&gt;补充&lt;/p&gt;
&lt;p&gt;　　使用 dataScopeFilter() 的实现在 BaseService.java 中，该方法存在两个，他们的定义也稍微有所差别，两个定义分别如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 数据范围过滤
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; user 当前用户对象，通过“entity.getCurrentUser()”获取
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; officeAlias 机构表别名，多个用“,”逗号隔开。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; userAlias 用户表别名，多个用“,”逗号隔开，传递空，忽略此参数
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 标准连接条件对象
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String dataScopeFilter(User user, String officeAlias, String userAlias);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * 数据范围过滤（符合业务表字段不同的时候使用，采用exists方法）
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; entity 当前过滤的实体类
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; sqlMapKey sqlMap的键值，例如设置“dsf”时，调用方法：${sqlMap.sdf}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; officeWheres office表条件，组成：部门表字段=业务表的部门字段
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; userWheres user表条件，组成：用户表字段=业务表的用户字段
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * @example
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; * dataScopeFilter(user, &quot;dsf&quot;, &quot;id=a.office_id&quot;, &quot;id=a.create_by&quot;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; * dataScopeFilter(entity, &quot;dsf&quot;, &quot;code=a.jgdm&quot;, &quot;no=a.cjr&quot;); // 适应于业务表关联不同字段时使用，如果关联的不是机构id是code。
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dataScopeFilter(BaseEntity entity, String sqlMapKey, String officeWheres, String userWheres);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　前面介绍的是调用了它的第一种形式。第一种形式的实现中对应角色设置中“数据范围”的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Role.DATA_SCOPE_ALL.equals(r.getDataScope())){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Role.DATA_SCOPE_COMPANY_AND_CHILD.equals(r.getDataScope())){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Role.DATA_SCOPE_COMPANY.equals(r.getDataScope())){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Role.DATA_SCOPE_OFFICE_AND_CHILD.equals(r.getDataScope())){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Role.DATA_SCOPE_OFFICE.equals(r.getDataScope())){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Role.DATA_SCOPE_CUSTOM.equals(r.getDataScope())){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;else if (Role.DATA_SCOPE_SELF.equals(r.getDataScope())){&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; dataScope.add(r.getDataScope());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中有一些如 DATA_SCOPE_ALL 等定义，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据范围（1：所有数据；2：所在公司及以下数据；3：所在公司数据；4：所在部门及以下数据；5：所在部门数据；8：仅本人数据；9：按明细设置）&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DATA_SCOPE_ALL = &quot;1&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DATA_SCOPE_COMPANY_AND_CHILD = &quot;2&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DATA_SCOPE_COMPANY = &quot;3&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DATA_SCOPE_OFFICE_AND_CHILD = &quot;4&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DATA_SCOPE_OFFICE = &quot;5&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DATA_SCOPE_SELF = &quot;8&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DATA_SCOPE_CUSTOM = &quot;9&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用以上数据对比角色中“数据范围”的部分，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/892439/201807/892439-20180708235137206-1198914240.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从图中可以看出，在实现的部分通过 if / elseif 来实现了不同选项的 SQL 语句的拼接，拼接后的内容被引入到 MyBatis 中，从而实现了数据权限的管理。&lt;/p&gt;
&lt;p&gt;　　到此，关于 JeeSite 中数据权限的基本介绍就到这里了。我本身不熟悉 Java 语言，对于 JeeSite 的二次开发也是我第一次接触 Java 语言，写在这里方便下次使用。有不正确的，请指正！&lt;/p&gt;

</description>
<pubDate>Sun, 08 Jul 2018 15:58:00 +0000</pubDate>
<dc:creator>tosser</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tosser/p/9281853.html</dc:identifier>
</item>
<item>
<title>Redis Cluster(集群) - pursuer.chen</title>
<link>http://www.cnblogs.com/chenmh/p/9221468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmh/p/9221468.html</guid>
<description>&lt;h2&gt;一、概述&lt;/h2&gt;
&lt;p&gt;在前面的文章中介绍过了redis的主从和哨兵两种集群方案，redis从3.0版本开始引入了redis-cluster(集群)。可以说从主从-哨兵-集群可以看到redis的不断完善；主从复制是最简单的节点同步方案无法主从自动故障转移。哨兵可以同时管理多个主从同步方案同时也可以处理主从自动故障转移，通过配置多个哨兵节点可以解决单点网络故障问题，但是单个节点的性能压力问题无法解决。集群解决了前面两个方案的所有问题。&lt;/p&gt;

&lt;p&gt;Redis-Cluster架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/135426/201806/135426-20180624185758226-2069219423.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.Redis-Cluster采用无中心结构，每个节点都和其它节点通过互ping保持连接，每个节点保存整个集群的状态信息，可以通过连接任意节点读取或者写入数据(甚至是没有数据的空节点)。&lt;/p&gt;
&lt;p&gt;2.只有当集群中的大多数节点同时fail整个集群才fail。&lt;/p&gt;
&lt;p&gt;3.整个集群有16384个slot，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。读取一个key时也是相同的算法。&lt;/p&gt;
&lt;p&gt;4.当主节点fail时从节点会升级为主节点，fail的主节点online之后自动变成了从节点。&lt;/p&gt;

&lt;h2&gt;二、集群安装&lt;/h2&gt;
&lt;h3&gt;1.插件安装&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum -y install ruby rubygems
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下周ruby依赖的redis.gem&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
wget https://rubygems.&lt;span&gt;global&lt;/span&gt;.ssl.fastly.net/gems/redis-3.2.2.gem
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装redis.gem&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
gem install redis-3.2.2.gem 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：不要使用gem install redis来默认安装，默认安装可能会安装redis-4.0.0版本。之前因为安装默认的版本过高导致reshard的时候一直失败&lt;/span&gt;。可以参考：&lt;a href=&quot;http://www.cnblogs.com/chenmh/p/9221672.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/chenmh/p/9221672.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装redis-stat&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gem install redis-stat
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果操作系统是7.0以上版本，可能会因为yum方式安装的ruby的版本太低，报“&lt;strong&gt;redis requires Ruby version &amp;gt;= 2.2.2&lt;/strong&gt;”错误，这时可以这样处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
gpg --keyserver hkp:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
\curl -sSL https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get.rvm.io | bash -s stable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
source  /etc/profile.d/rvm.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看可以安装的版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rvm list known
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装其中的一个版本，大于2.2.2的版本即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rvm install &lt;span&gt;2.4&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看已安装的gem,ruby版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ruby -&lt;span&gt;v 
gem &lt;/span&gt;-v
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行gem安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
gem install redis
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.安装redis&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
tar -xvf redis-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;.tar.gz
cd redis&lt;/span&gt;-&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;7&lt;/span&gt;&lt;span&gt;
make MALLOC&lt;/span&gt;=&lt;span&gt;libc
cp src&lt;/span&gt;/redis-server redis-cli redis-trib.rb redis-benchmark redis-check-aof redis-check-rdb redis-sentinel /usr/local/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建redis目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mkdir -p /redis/redis-cluster/&lt;span&gt;
cd &lt;/span&gt;/redis/redis-cluster/&lt;span&gt;
mkdir &lt;/span&gt;-p &lt;span&gt;7001&lt;/span&gt;/data &lt;span&gt;7001&lt;/span&gt;/log &lt;span&gt;7001&lt;/span&gt;/&lt;span&gt;tmp
cp &lt;/span&gt;-rp &lt;span&gt;7002&lt;/span&gt;&lt;span&gt;
cp &lt;/span&gt;-rp 7003&lt;span&gt; 
cp &lt;/span&gt;-rp &lt;span&gt;8001&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
cd &lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
vim redis.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
port &lt;span&gt;7001&lt;/span&gt;&lt;span&gt;
daemonize yes
timeout &lt;/span&gt;&lt;span&gt;300&lt;/span&gt;&lt;span&gt;
databases &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;
save &lt;/span&gt;&lt;span&gt;900&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
save &lt;/span&gt;&lt;span&gt;300&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
save &lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
stop&lt;/span&gt;-writes-on-bgsave-&lt;span&gt;error yes
rdbcompression yes
rdbchecksum yes 
lua&lt;/span&gt;-time-limit &lt;span&gt;5000&lt;/span&gt;&lt;span&gt;
bind 192.168.191.11&lt;br/&gt;######################################limit#######################
maxclients &lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
maxmemory 512mb
maxmemory&lt;/span&gt;-policy &lt;span&gt;volatile&lt;/span&gt;-&lt;span&gt;ttl
maxmemory&lt;/span&gt;-samples &lt;span&gt;5&lt;/span&gt;&lt;span&gt;

#######################################file#######################
pidfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/redis/redis-cluster/7001/tmp/redis_7001.pid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
loglevel notice
logfile &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/redis/redis-cluster/7001/log/redis_7001.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dbfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dump.rdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
dir &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/redis/redis-cluster/7001/data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 

appendonly yes
appendfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appendonly.aof&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
appendfsync everysec
no&lt;/span&gt;-appendfsync-on-&lt;span&gt;rewrite no
auto&lt;/span&gt;-aof-rewrite-percentage &lt;span&gt;100&lt;/span&gt;&lt;span&gt;
auto&lt;/span&gt;-aof-rewrite-min-&lt;span&gt;size 64mb
######################################replication###########################
slave&lt;/span&gt;-serve-stale-&lt;span&gt;data yes
slave&lt;/span&gt;-read-&lt;span&gt;only yes
repl&lt;/span&gt;-diskless-&lt;span&gt;sync no
repl&lt;/span&gt;-diskless-sync-delay &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
repl&lt;/span&gt;-disable-tcp-&lt;span&gt;nodelay no
slave&lt;/span&gt;-priority &lt;span&gt;100&lt;/span&gt;&lt;span&gt;
requirepass &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
masterauth &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

######################################slowlog################################
slowlog&lt;/span&gt;-log-slower-than &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
slowlog&lt;/span&gt;-max-len &lt;span&gt;128&lt;/span&gt;&lt;span&gt;
latency&lt;/span&gt;-monitor-threshold &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
 
####################################cluster####################################
cluster&lt;/span&gt;-&lt;span&gt;enabled yes
cluster&lt;/span&gt;-config-file &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/redis/redis-cluster/7001/nodes.conf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
cluster&lt;/span&gt;-node-timeout &lt;span&gt;5000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将redis.conf配置文件拷贝到其它的几个节点并修改对应的端口、路径等相关信息。&lt;/p&gt;
&lt;h3&gt;3.启动redis集群 &lt;/h3&gt;
&lt;p&gt;启动所有的redis集群&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./redis-server redis.conf 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以写在bash脚本文件中启动&lt;/p&gt;
&lt;h2&gt;三、集群管理&lt;/h2&gt;
&lt;h3&gt;1.创建集群&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-trib.rb create 192.168.191.11:7001 192.168.191.11:7002 192.168.191.11:7003
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果加上参数--replicas 1表示为每一个主节点创建一个从节点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：其实也不建议使用-replicas 1来自动创建主从关系，因为这种创建方法没办法指定哪个从节点对应哪个主节点，无法控制交叉主从。可以先创建好主节点，然后再通过创建从节点指定主节点。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.集群配置密码处理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;默认如果redis cluster节点配置了密码验证，redis-trib.rb操作会失败，则需要在需要执行redis-trib.rb操作的节点修改client.rb文件，操作如下：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
find / -name &lt;span&gt;'&lt;/span&gt;&lt;span&gt;client.rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /usr/lib/ruby/gems/1.8/gems/redis-3.2.1/lib/redis/client.rb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意：由于每个人安装的版本不一样所以路径也可能有所差别，在passwd参数后面设置验证的密码，注意所有节点的密码必须是相同的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/135426/201807/135426-20180708223044940-799333529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.检查集群&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-trib.rb check 192.168.191.11:7001
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/135426/201807/135426-20180708223159412-250187845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 4.增加节点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.增加主节点&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-trib.rb add-node 192.168.191.11:7004 192.168.191.11:7001
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：最后后面的ip和端口是目前集群中已经存在的节点，前面的ip和端口是要增加的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.增加从节点&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
----&lt;span&gt;增加从节点
redis&lt;/span&gt;-trib.rb add-node --slave 192.168.191.11:8001 192.168.191.11:7001 
----&lt;span&gt;增加从节点并指定主节点
redis&lt;/span&gt;-trib.rb add-node --slave --master-id 64ee652b75a78fc08253fddab5a920988a870f68 192.168.191.11:8001 192.168.191.11:7001 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：最后面的ip和端口是现集群中已经存在的节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/135426/201807/135426-20180708224744811-431946222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.移动slot&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-trib.rb reshard 192.168.191.11:7001
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;iphe端口随便指定集群中的某一个，然后输入要移动的slot个数和源节点目标节点id,最后输入done即可。&lt;/p&gt;
&lt;h3&gt;6.移动节点&lt;/h3&gt;
&lt;p&gt;可以指定当前节点的master,或者改变当前节点所属的master,登入到当前节点执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cluster replicate 5d8ef5a7fbd72ac586bef04fa6de8a88c0671052  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;##新master的nodeid&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;7.删除节点&lt;/h3&gt;
&lt;p&gt;注意： 删除主节点之前需要先将主节点上的所有slot移动到别的主节点，并且保证没有从节点，否则需要先将从节点移走或者删除&lt;/p&gt;
&lt;p&gt;删除节点时需要指定节点的id&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-trib.rb &lt;span&gt;del&lt;/span&gt;-node 192.168.191.11:7001 af0f17b501b9f9f5e71ff6be1cf8114c9e11a80b 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后面的id即为需要删除的节点id,删除节点和增加节点语法节点的循序正好相反&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;四、集群相关命令&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CLUSTER INFO 打印集群的信息
CLUSTER NODES 列出集群当前已知的所有节点（node），以及这些节点的相关信息。 &lt;/span&gt;
CLUSTER MEET &amp;lt;ip&amp;gt; &amp;lt;port&amp;gt;&lt;span&gt; 将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。
CLUSTER FORGET &lt;/span&gt;&amp;lt;node_id&amp;gt;&lt;span&gt; 从集群中移除 node_id 指定的节点。
CLUSTER REPLICATE &lt;/span&gt;&amp;lt;node_id&amp;gt;&lt;span&gt; 将当前节点设置为 node_id 指定的节点的从节点。
CLUSTER SAVECONFIG 将节点的配置文件保存到硬盘里面。
CLUSTER ADDSLOTS &lt;/span&gt;&amp;lt;slot&amp;gt;&lt;span&gt; [slot ...] 将一个或多个槽（slot）指派（assign）给当前节点。
CLUSTER DELSLOTS &lt;/span&gt;&amp;lt;slot&amp;gt;&lt;span&gt; [slot ...] 移除一个或多个槽对当前节点的指派。
CLUSTER FLUSHSLOTS 移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。
CLUSTER SETSLOT &lt;/span&gt;&amp;lt;slot&amp;gt; NODE &amp;lt;node_id&amp;gt;&lt;span&gt; 将槽 slot 指派给 node_id 指定的节点。
CLUSTER SETSLOT &lt;/span&gt;&amp;lt;slot&amp;gt; MIGRATING &amp;lt;node_id&amp;gt;&lt;span&gt; 将本节点的槽 slot 迁移到 node_id 指定的节点中。
CLUSTER SETSLOT &lt;/span&gt;&amp;lt;slot&amp;gt; IMPORTING &amp;lt;node_id&amp;gt;&lt;span&gt; 从 node_id 指定的节点中导入槽 slot 到本节点。
CLUSTER SETSLOT &lt;/span&gt;&amp;lt;slot&amp;gt;&lt;span&gt; STABLE 取消对槽 slot 的导入（import）或者迁移（migrate）。 &lt;/span&gt;
CLUSTER KEYSLOT &amp;lt;key&amp;gt;&lt;span&gt; 计算键 key 应该被放置在哪个槽上。
CLUSTER COUNTKEYSINSLOT &lt;/span&gt;&amp;lt;slot&amp;gt;&lt;span&gt; 返回槽 slot 目前包含的键值对数量。
CLUSTER GETKEYSINSLOT &lt;/span&gt;&amp;lt;slot&amp;gt; &amp;lt;count&amp;gt;&lt;span&gt; 返回 count 个 slot 槽中的键。 &lt;/span&gt;
CLUSTER SLAVES node-id 返回一个master节点的slaves 列表
&lt;/pre&gt;&lt;/div&gt;






&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.7112676056338&quot;&gt;&lt;tr readability=&quot;6.4172535211268&quot;&gt;&lt;td readability=&quot;8.556338028169&quot;&gt;
&lt;p&gt;&lt;span&gt;备注：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    作者：&lt;/span&gt;&lt;span&gt;&lt;a title=&quot;点击跳转到原文&quot; href=&quot;http://www.cnblogs.com/chenmh/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;pursuer.chen&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    博客：&lt;span&gt;&lt;a id=&quot;lnkMyHome&quot; title=&quot;点击跳转到原文&quot; href=&quot;http://www.cnblogs.com/chenmh/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/chenmh&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本站点所有随笔都是原创，欢迎大家转载；但转载时必须注明文章来源，且在文章开头明显处给明链接，否则保留追究责任的权利。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《欢迎交流讨论》&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</description>
<pubDate>Sun, 08 Jul 2018 15:25:00 +0000</pubDate>
<dc:creator>pursuer.chen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmh/p/9221468.html</dc:identifier>
</item>
<item>
<title>初识Spring - lukely</title>
<link>http://www.cnblogs.com/lukely/p/9281647.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lukely/p/9281647.html</guid>
<description>
&lt;p&gt;不使用框架，我们写按照mvc结构来写代码是这样的：&lt;/p&gt;
&lt;p&gt;业务层：service&lt;/p&gt;
&lt;p&gt;定义一个业务层接口UserService ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserService {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后根据这个几口写一个业务层实现类UserServiceImpl ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; UserDao userDao = &lt;span&gt;new&lt;/span&gt; UserDaoImpl();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口的实例化问题，自己来new 代码的耦合性很高。&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser() {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;userDao.addUser();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;持久层UserDao ：&lt;/p&gt;
&lt;p&gt;定义一个接口持久层接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserDao {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后根据这个接口写一个持久层实现类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt; @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; System.out.println(&quot;添加用户！&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;  
&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们来模拟，层持久层获取数据返回。数据就是“添加用户”这几个字&lt;/p&gt;

&lt;p&gt;然后写一个测试类来测试取回的数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserDaoTest {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; UserService userService = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserServiceImpl();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private UserService userService;&lt;/span&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;userService = (UserService) context.getBean(&quot;userService&quot;);&lt;/span&gt;
&lt;span&gt; userService.addUser();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;整个流程下来，我们可以发现，传统的方式我们需要在业务层new 持久层的对象。在测试类中，需要new 业务层的对象。也就是说，传统的方式我们获取被依赖对象的方式是使用new关键字，自己在需要的地方自己new。&lt;/p&gt;

&lt;p&gt;这种方式使用javaSE里面说的“组合”，通过组合来复用了被依赖对象里面的方法。但是这种方法是很笨重的，笨重表现如下：&lt;/p&gt;
&lt;p&gt;1、需要用到1个依赖对象，我们就需要在这个类中主动new1个依赖类的对象，需要用到N个不同的依赖对象，我们就需要主动new N个对象。这样的话，就会使代码变得臃肿，如果业务逻辑很复杂，那这种方式也会增加代码的复杂程度，无论是开发过程中还是给别人看，都不能很容易就梳理出这里的业务。&lt;/p&gt;
&lt;p&gt;2、耦合性很强。这一点我以前也一直不明白为什么说耦合性很强，不灵活。现在我终于明白了一点。耦合性强，就意味着可扩展性差。我们可以试想一种情况：&lt;/p&gt;
&lt;p&gt;就是项目完成后。发布上线一年了。突然业务的木偶一个小部分需要发生了变化C对象，之前是调用A对象的，现在要改成B对象才合适。这种情况之下：&lt;/p&gt;
&lt;p&gt;如果使用传统的new的方法，如何做出修改呢？这时候就需要将C类里面new A对像的地方改为new B对象。然后重新打包，替换原来的包。这项工作就比较负责。也根本谈不上扩展性。&lt;/p&gt;

&lt;p&gt;这个时候，如果我们使用另外一种方式---工厂模式，会怎么样呢？肯定会简单很多。&lt;/p&gt;
&lt;p&gt;比如：先创建一个工厂类，专门用于创建对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyFactoryUtils {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T getInstance(Class&amp;lt;T&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; String interfaceName =&lt;span&gt; c.getSimpleName();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; String interfaceImplName = ResourceBundle.getBundle(&quot;myinterface&quot;&lt;span&gt;).getString(interfaceName);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T) Class.forName(interfaceImplName).newInstance();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;e.printStackTrace();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;加载接口实例失败..&quot; +&lt;span&gt; e);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后业务层的代码就可以变成这样了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; UserDao userDao = MyFactoryUtils.getInstance(UserDao .&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser() {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;userDao.addUser();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们通过工厂类，来获取持久层的对象，如：第2行&lt;/p&gt;
&lt;p&gt;这个对象是怎么获取的呢？是通过配置文件获取的：&lt;/p&gt;
&lt;p&gt;myinterface.properties.&lt;/p&gt;
&lt;p&gt;在这个配置文件中，以key--value的方式配置好&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UserDao=com.mytest.dao.imple.UserDaoImpl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 通过这种方式，我们就大大增强了之前代码的灵活性。如果我们在要更换成别的对象了。我们只要将配置文件中的value换掉就好了。&lt;/p&gt;
&lt;p&gt;可是这种方式只能解决耦合性强的问题啊，代码臃肿的问题还是不能解决的。这个时候，spring框架的价值就体现出来了。spring框架不仅较大程度低解决了耦合性强的问题，也解决了代码臃肿的问题。那spring是如何解决耦合性强的问题的呢？&lt;/p&gt;
&lt;p&gt;也是通过配置文件。此时spring就相当于一个bean工厂（bean可以简单地理解为那些一类对象）。跟上面的工厂模式一样，只要在配置文件中设置好相应的配置，就可以像上面一样灵活了。&lt;/p&gt;
&lt;p&gt;此时使用spring框架的代码是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserDaoTest {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService userService;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; ClassPathXmlApplicationContext context = &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; userService = (UserService) context.getBean(&quot;userService&quot;&lt;span&gt;);&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;userService.addUser();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
 &lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们通过spring提供的工厂对象 context 并根据这个工厂的getBean方法获取需要的对象。配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt;2&lt;/span&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
&lt;span&gt;3&lt;/span&gt; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt;4&lt;/span&gt; xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &amp;lt;bean id=&quot;userService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.myTest.service.impl.UserServiceImpl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;span&gt;7&lt;/span&gt; &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样也就可以实现像工厂模式那样降低了代码的耦合性。可是我们这里明明看到的是，代码要比工厂的那个写得更多啊？其实不是，在这个类里面：ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);&lt;/p&gt;
&lt;p&gt;这个语句，只要写一次就够了，就可以根据：&lt;/p&gt;
&lt;p&gt;userService = (UserService) context.getBean(&quot;userService&quot;);这种方式获取不同的对象了。要获取不同的对象只要将getBean（id）。里的id换掉就可以了。这样相对工厂方式来说，代码量减少了，灵活性得到了保持。但是这种方式，还是会需要需要很多getBean方法来获取不同的对象，业务一复杂了，也会需要很多个相似的代码来获得不同的对象，灵活性上和代码冗余量可不可以更好一点呢？&lt;span&gt;这个时候就是DI---依赖注入闪亮登场了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDao userDao;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUserDao(UserDao userDao) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.userDao =&lt;span&gt; userDao;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUser() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;userDao.addUser();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，我们现在的代码及编程了现在这个样子，代码量明显比之前要少了很多了。配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
&lt;span&gt; 3&lt;/span&gt; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
&lt;span&gt; 4&lt;/span&gt; xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &amp;lt;bean id=&quot;userDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.itcast.dao.impl.UserDaoImpl&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;span&gt; 7&lt;/span&gt;  &amp;lt;bean id=&quot;userService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;cn.itcast.service.impl.UserServiceImpl&quot;&amp;gt;
&lt;span&gt; 8&lt;/span&gt;  &amp;lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&amp;gt;&amp;lt;/property&amp;gt;
&lt;span&gt; 9&lt;/span&gt;  &amp;lt;/bean&amp;gt;
&lt;span&gt;10&lt;/span&gt; &amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到在业务层实现类的配置里面，配置了一个属性&amp;lt;&lt;span&gt;property &amp;gt;,这个正是我们的持久层的对象。这样只要这个业务层一旦初始化，就会同时初始化持久层对象了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样，就代码来说，因为使用了工厂，使用了配置文件，相比什么都不使用，直接new的传统写法来说，这样的代码就更加精简，更加具有灵活性了。业务层代码，因为主要代码都集中在了业务上，所以业务也及更好理解了。也因为使用配置文件的方式，想换什么实现方式，在配置文件中将配置文件改了，也就好了，更加地灵活。&lt;/p&gt;

&lt;p&gt;到这里，我们可以发现，spring核心的&lt;span&gt;IOC控制反转，其实就是将创建对象的过程由原来的自己使用new关键字，转变成由spring的工厂去创建。将获得依赖对象的方式由原来的创建式，变成了配置式（在spring的配置文件中配置。）。但是，我个人无法理解的是为什么说是“反转”。我理解的反转是，本来是我为你做的事情，现在变成了你为我做，这叫反转。可是在spring这里，明显就是，本来我为自己做的事情，现在由别人为我做了。所以翻译成了”反转“，会不会对理解上有些误解呢？见仁见智了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DI，依赖注入。关于这一点，我也是不太能理解（不能理解依赖注入成了spring的特性这一点）。这个依赖注入按照我的理解，就是同样的功能随着IOC而采用了不同的实现方式而已。因为注入，本质是将A对象注入到B对象里面，好让B对象可以使用A对象的方法，而达到复用代码的目的。这个目的使用组合的方式本身就可以实现。或者说为了达到“注入”这种更形象的样子（不考虑spring本身，单论注入），使用组合，完全可以实现。所以为什么依赖注入成了Spring专有的了呢？所以我认为，所谓依赖注入：实际上也就是代码复用的另一种形式，或者干脆说是组合的另外一种形式罢了。（这个问题我的确是有些钻牛角尖了，欢迎多多批评。）&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 14:45:00 +0000</pubDate>
<dc:creator>lukely</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lukely/p/9281647.html</dc:identifier>
</item>
<item>
<title>[netcore]CentOS安装使用.netcore极简教程（免费提供学习服务器） - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/netcore_centos.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/netcore_centos.html</guid>
<description>&lt;p&gt;本文目标是指引从未使用过Linux的.Neter，如何在CentOS7上安装.Net Core环境，以及部署.Net Core应用。&lt;/p&gt;

&lt;p&gt;仅针对CentOS，其它Linux系统类似，命令环节稍加调整；&lt;/p&gt;
&lt;p&gt;需要提前准备好服务器地址、用户名、密码；&lt;/p&gt;
&lt;p&gt;如果手上没有Linux系统，可使用新生命团队免费提供的公网服务器 &lt;span&gt;&lt;strong&gt;centos.newlifex.com&lt;/strong&gt;&lt;/span&gt;  &lt;/p&gt;



&lt;p&gt;在Windows开发机上安装 xshell 和 xftp ，前者用于SSH连接Linux服务器，后者用于FTP上传下载文件。&lt;/p&gt;
&lt;p&gt;打开xshell，新建连接，名称和主机都填 &lt;span&gt;&lt;strong&gt;centos.newlifex.com&lt;/strong&gt;&lt;/span&gt; ，（实际应用中就是你的Linux服务器地址或域名），其它默认，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708114452335-1250298170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击连接，弹出一个SSH安全警告，需要接受并保存SSH密钥。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708114558980-1970286277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 接受后要求输入用户名，我们这里输入&lt;strong&gt;&lt;span&gt;root&lt;/span&gt;&lt;/strong&gt;，选择记住用户名&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708114725291-711940989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 确定后，要求输入密码，新生命团队开放服务器本周的密码是 &lt;strong&gt;&lt;span&gt;nx@1250407685&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708114945342-1398310216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了省事，我们同样选择记住密码。&lt;/p&gt;
&lt;p&gt;确定后，我们可以看到登录成功！同时在左边会话管理器看到了刚才创建的这个连接，以后需要同时管理很多Linux服务器的时候，这样子就方便多了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708115201982-2001968391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我来试试几个可能用得到的命令：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;w 查看现在谁在连接这台服务器&lt;/strong&gt;&lt;/span&gt;。下图看到只有我自己连着。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;free -h 查看服务器内存使用情况&lt;/span&gt;&lt;/strong&gt;。下图看到已用内存119M，Linux这点非常漂亮。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708115543394-173715349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;top 命令查看系统进程占用资源情况&lt;/span&gt;&lt;/strong&gt;。类似于Windows任务管理器，定时刷新，按键Q退出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708115812533-2037633259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;共63个进程，只有1个在运行，挺干净。不过底下看到有个java进程，不太爽，后面想办法干掉它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ps aux 查看进程详细信息&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708121255563-1354465336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这下子知道，那个java进程来自 cloudmonitor，应该是云监控。&lt;/p&gt;


&lt;p&gt;我们是奔着.Net Core而来的，重点是安装运行时环境。&lt;/p&gt;
&lt;p&gt;为了方便和一劳永逸，我们抄捷径，先看我的配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708121537377-1322348860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开xshell的快速命令工具栏，然后添加几组快捷命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708121810719-977019569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708121821975-1360231203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;按钮“&lt;strong&gt;&lt;span&gt;.Net Core&lt;/span&gt;&lt;/strong&gt;”&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;sudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm&lt;br/&gt;sudo yum update -y&lt;br/&gt;sudo yum install -y dotnet-runtime-2.1&lt;br/&gt;dotnet --info&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt; （注意：&lt;span&gt;&lt;strong&gt;最后一行命令后面必须有一个换行，否则最后命令无法得到执行，下同&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt; 按钮“&lt;strong&gt;&lt;span&gt;.Net Core SDK&lt;/span&gt;&lt;/strong&gt;”&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;sudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm&lt;br/&gt;sudo yum update -y&lt;br/&gt;sudo yum install -y dotnet-sdk-2.1&lt;br/&gt;dotnet --version&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt;按钮“&lt;strong&gt;&lt;span&gt;Asp.Net Core&lt;/span&gt;&lt;/strong&gt;”&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;sudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm&lt;br/&gt;sudo yum update -y&lt;br/&gt;sudo yum install -y aspnetcore-runtime-2.1&lt;br/&gt;dotnet --info&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt;按钮“&lt;strong&gt;&lt;span&gt;卸载.Net Core&lt;/span&gt;&lt;/strong&gt;”&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;sudo yum remove -y aspnetcore-*&lt;br/&gt;sudo yum remove -y dotnet-*&lt;/p&gt;

&lt;/blockquote&gt;
&lt;p&gt;具体功能就不介绍了，来源于：https://www.microsoft.com/net/download/linux-package-manager/centos/sdk-current&lt;/p&gt;
&lt;p&gt;我们试试第一个按钮，安装.net core运行时，没有asp.net core，也没有.net core sdk&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708122352258-657160089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图看到，安装了netcore运行时2.1.1&lt;/p&gt;
&lt;p&gt;可以用卸载按钮，然后再装另外两个，看看有什么不同。&lt;/p&gt;


&lt;p&gt; 用vs2017新建一个netcore控制台项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708122613205-2070970134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Nuget引用 NewLife.Core ，建立一个稍微高级一点的例程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708122720463-1550216535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main(String[] args)
{
    XTrace.UseConsole();

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; svr = &lt;span&gt;new&lt;/span&gt; ApiServer(&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;)
    {
        Log &lt;/span&gt;=&lt;span&gt; XTrace.Log,
        EncoderLog &lt;/span&gt;=&lt;span&gt; XTrace.Log,
        StatPeriod &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ns = svr.EnsureCreate() &lt;span&gt;as&lt;/span&gt;&lt;span&gt; NetServer;
    ns.SocketLog &lt;/span&gt;=&lt;span&gt; XTrace.Log;
    ns.SessionLog &lt;/span&gt;=&lt;span&gt; XTrace.Log;
    ns.LogSend &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    ns.LogReceive &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    svr.Start();

    Console.ReadKey();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上，我们用ApiServer建立一个RPC服务，并打开全部调试日志，它内置有两个服务接口很方便测试RPC通信。&lt;/p&gt;
&lt;p&gt;编译并发布为可移植应用：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708220406911-465511875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们可以得到这样一个目录，运行必要的文件是dll和那个runtimeconfig.json&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708220511329-168608216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用xshell连上服务，我们这里可以是 &lt;span&gt;&lt;strong&gt;centos.newlifex.com&lt;/strong&gt;&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;xshell工具栏上有一个绿色图标，打开xftp，左窗口地址栏进入刚才的发布目录，右窗口新建/root/ApiServer目录，并&lt;span&gt;&lt;strong&gt;把左边必要的文件拖到右边&lt;/strong&gt;&lt;/span&gt;，即可实现上传！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708220733085-1524020471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 回到xshell中，&lt;strong&gt;&lt;span&gt;cd ApiServer&lt;/span&gt;&lt;/strong&gt;进入目录，&lt;strong&gt;&lt;span&gt;dotnet ConsoleApp5.dll&lt;/span&gt;&lt;/strong&gt; 即可执行应用，（前提是已安装netcore运行时）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708220948906-638233925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 客户端用码神工具XCoder（https://github.com/NewLifeX/XCoder）连接地址 &lt;span&gt;&lt;strong&gt;tcp://centos.newlifex.com:1234&lt;/strong&gt;&lt;/span&gt;，选择 &lt;strong&gt;&lt;span&gt;Api/All&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;Api/Info&lt;/span&gt;&lt;/strong&gt; 两个服务接口均测试通过，表明我们的&lt;strong&gt;&lt;span&gt;.Net Core&lt;/span&gt;&lt;/strong&gt;应用成功在&lt;strong&gt;&lt;span&gt;CentOS&lt;/span&gt;&lt;/strong&gt;上跑起来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708221322608-1567368892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 光有运行还不够，有时候我们还要查看应用工作日志。还是用xftp，刚才右边的窗口刷新一下，可以看到多出来Log目录，就是我们的应用日志，右键传输即可下载到本地，当然也可以简单直接的往左边拖过去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708221128440-996081899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; vscode打开日志文件，可以看到很详细的信息，特别是日志头，便于分析查找问题&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/19592/201807/19592-20180708221714097-1891187654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这一篇面向Linux零基础的Windows工程师的极简教程，终于写完了，基本上足以应付八成以上的日常工作。&lt;/p&gt;
&lt;p&gt;其它更多细节，可以在网上找到，比如&lt;strong&gt;怎么样把应用安装成为服务、怎么样做到开机启动&lt;/strong&gt;，等等。&lt;/p&gt;

&lt;p&gt; &lt;span&gt;&lt;strong&gt;综合过去20年写代码的经验，netcore具有极强的优势，尽管有一些小问题，但我要说，只要微软不放弃，我坚决不放弃！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我是大石头，打1999年起，19年老码农。目前在快递行业从事数据分析架构工作，分析跑在路上的上亿包裹。欢迎大家一起C#大数据！&lt;/p&gt;

&lt;p&gt;End.&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 14:37:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/netcore_centos.html</dc:identifier>
</item>
<item>
<title>基于HTTP协议的几种实时数据获取技术 - 五月的仓颉</title>
<link>http://www.cnblogs.com/xrq730/p/9280404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xrq730/p/9280404.html</guid>
<description>

&lt;p&gt;&lt;span&gt;HTTP协议大家都很熟悉了，开始本文之前，首先简单回顾一下HTTP协议。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HTTP协议是建立在TCP协议上的应用层协议，协议的本质是&lt;strong&gt;&lt;span&gt;请求----应答&lt;/span&gt;&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708160705118-1294702638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即对于HTTP协议来说，服务端给一次响应后整个请求就结束了，这是HTTP请求最大的特点，也是由于这个特点，HTTP请求无法做到的是服务端向客户端主动推送数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但由于HTTP协议的广泛应用，很多时候确实又想使用HTTP协议去实现实时的数据获取，这种时候应当怎么办呢？下面首先介绍几种基于HTTP协议的实时数据获取方法。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;轮询是最普遍的基于HTTP协议获取实时数据的方式，轮询又分为短轮询和长轮询。短轮询非常简单，用一张图表示一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708160838824-343690762.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端向服务端请求数据，服务端立即将数据返回给客户端，客户端没有拿到想要的数据（比如返回结果告诉客户端，数据处理中），客户端继续发请求，服务端继续立即响应，周而复始。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种实时数据获取的方式比较粗暴，优点在于编程简单，客户端发请求，服务端实时回响应即可。缺点主要有两个：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;无效请求多，每一次无效请求都在浪费带宽和服务器的计算资源&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对服务器压力大，定时发请求，并发一高，可能服务端瞬间会收到成千上万个请求，很容易拖垮服务器甚至导致宕机&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;那么短轮询适合哪种使用场景呢，按照我的理解如果&lt;span&gt;&lt;strong&gt;数据变化比较频繁&lt;/strong&gt;&lt;/span&gt;或者&lt;span&gt;&lt;strong&gt;能预期到数据在短时间内会发生一次变化&lt;/strong&gt;&lt;/span&gt;的场景可以使用短轮询，比如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708171452543-1194967339.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户在PC端买了一个东西唤起网页端，由于PC端和网页端是不通的，我们预期到用户应该很快会完成付款，这种时候为了开发简单短轮询是一种可以使用的方式，直接服务端提供一个接口告诉客户端订单状态，客户端每5秒请求一次即可，拿到结果就可以不用请求了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用短轮询注意要做好请求次数上限的控制，比如请求100次还没检测到用户付款，可以弹窗&quot;请完成付款后去我的订单页面查询&quot;就可以不用请求了。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;长轮询是另一种实时获取数据的方式，看一下流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708161146922-2090036041.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本质上没有改变，依然是客户端在没有收到自己想要数据的情况下不断发送请求给服务端，差别在于服务端收到请求不再直接给响应，而是将请求挂起，自己去定时判断数据的变化，有变化就立马返回给客户端，没有就等到超时为止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以很明显的看到，长轮询的优点就是客户端的请求少了很多避免了无谓的客户端请求，缺点则是服务端会挂起大量请求增加资源消耗且服务器对HTTP请求并发数量是有限制的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微信网页版的登陆是一个典型的长轮询的例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708161328381-1835976845.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从图上看，客户端不断发送请求到服务器，服务器第一时间并没有给出回应，于是客户端等待，在超时的情况下继续发送请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总的来说我理解一般使用长轮询会更多一点，短轮询更加看重的是编程简单，适合小型应用。像微信网页端登录这种，成千上万个用户同时登陆，隔一段时间服务端收成千上个请求去处理哪里受得了，堆机器分摊每台服务器上处理请求的数量终究不是解决问题的办法。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;上面介绍了两种轮询方式，但是两种综合起来都有比较明显的缺点，总结起来有以下几个：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;伪实时，即上述两种方式都不是真正的实时，无论短轮询的客户端轮询时间多短，还是长轮询的服务端轮询时间多短，都存在一定程度的延时&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有的轮询只要没有需要的数据返回，都是对计算资源的一种浪费&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;HTTP协议本身是一个重的协议，每一次都必须带有HTTP首部+HTTP头部，实际上对我们来说需要的只是HTTP Body而已，多余的数据都是对带宽的一种浪费&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因此，最好我们可以做到的事情是：客户端和服务端之间有一条通路，当服务端数据有变化的时候，服务端可以主动推送到客户端。WebSocket就是HTML5之后为了做到这一点而诞生的一种协议，虽然这是一种新的协议，但也是基于HTTP协议的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看一下WebSocket的原理，很简单：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708161546262-572559871.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WebSocket客户端首先通过HTTP协议发送几个特别的header到服务端，告诉服务端现在我发起的是HTTP请求，但我要升级到WebSocket了：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Upgrade:websocket&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Connection：Upgrade&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Sec-WebSocket-Key: XXX&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Sec-WebSocket-Protocol: chat, superchat&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Sec-WebSocket-Version: XX&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;只要服务器支持WebSocket协议（Tomcat7、Jetty7之后都是支持WebSocket的），那么服务端收到请求且建立连接成功后会返回Sec-WebSocket-Accept、Sec-WebSocket-Protocol这两个header给客户端，且Http Status为101表示协议切换成功，这样客户端和服务端只要任意一方没有断开连接，就可以基于这一条通路进行通讯了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再谈一下之前提的WebSocket相比长短轮询对于带宽资源的节省。有一个测试，假设HTTP Header是871字节，WebSocket由于数据传输是基于帧的，帧传输更加高效，对比长短轮询，2个字节即可代替871个字节的Header，测试结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708164206777-1353691310.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相同的每秒客户端轮询的次数，当次数高达10W/s的高频率次数的时候，轮询需要消耗665Mbps，而WebSocket仅仅只花费了1.526Mbps，将近435倍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WebSocket做到了真正的实时且大量节省带宽资源，但是我理解也有自己的问题，就是开发成本比较高，这里的开发成本倒不是说自己去实现WebSocket，这个在Java语言层面上直接使用Netty-Socketio即可，API很简单，提供了对WebSocket完整的实现，真正的开发成本在于分布式环境下的数据同步问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举个例子，有一个在线聊天系统10W人同时在线，此时有一个用户发了一条1K的语音消息，单机保持10W的连接倒是可以（这里不是HTTP请求，因此不受连接池数影响），问题在于带宽。单机同时向10W用户推送1K语音消息，需要的带宽至少10M，这还只是纯粹推送数据出去，没有考虑到数据进来的场景，实际运行过程中需要的带宽会更多，对于企业来说这是一笔非常大的成本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，大量连接的场景下都会做集群（实际就算没有大量连接，为了高可用性，也会做集群），10W并发分出5台机器，平均每台机器有2W连接，考虑集群下会出现的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201807/801753-20180708161921082-348442478.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;客户端1把数据发送到服务器1，服务器1连接的所有客户端都可以推送该条语音，但是问题在于：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;服务器2~服务器5连的所有客户端如何拿到数据？简单的一种方式是使用消息队列，将数据通过消息队列发送到所有订阅的服务器上&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;那如果传输的是一张1M的图片，数据太大不适合使用消息队列怎么办，可以先将数据存储下来，消息队列只发送id，收到消息的服务器再根据id去取真正的数据并推送&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果依赖消息队列，那么不仅仅需要对应用进行代码开发，还需要对消息服务器做分布式集群、做压力测试，保证高可用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2W连接正常预计发送1K的消息是没问题的，但是万一用户发送了1M图片导致远超预估带宽怎么办，是业务上取舍不能发送超过XXX的数据还是技术上处理&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其他太多需要考虑的问题没有列出来，总而言之，用WebSocket在大量请求、高并发的场景下，代码开发成本是非常高的。但是由于WebSocket可以做到真正的实时服务端对客户端的数据推送且对带宽资源有大量的节省，因此很多IM、音视频、弹幕等应用都会使用WebSocket。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 14:09:00 +0000</pubDate>
<dc:creator>五月的仓颉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xrq730/p/9280404.html</dc:identifier>
</item>
<item>
<title>读特朗普，这是个什么样的对手 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/9281409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/9281409.html</guid>
<description>&lt;p&gt;若不是贸易战我想我是不会读特朗普的书的，因为他给我的第一印象就是满嘴大话，狂妄自傲。简直是来搞笑的，比如宣布要在美墨边境修墙，费用还要墨西哥承担。但到了今年3月份，特朗普扬言要对华500亿产品加收25%关税，虽然期间双方团队经过反复协商，但本月6号还是落下实锤。这让我非常好奇这到底是个什么样的人，于是最近我读了《特朗普自传》和《从20万到30亿》，下面就来聊聊我所理解的特朗普。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-0e51986b9f188e29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;h3&gt;成长历程&lt;/h3&gt;
&lt;p&gt;特朗普祖父年幼时从苏格兰移民到美国，特朗普的父亲弗瑞德·特朗普，开始是一名木匠，靠自己的打拼成为了一名房地产商，但主要出租廉租房。家中五个孩子，父母从小教育他们钱来之不易，他们也不以自诩为富家子弟。特朗普出生在1946年，自小就会跟着父亲去工地，少年时代放假回家都会跟着他父亲学做生意，学着跟承包商周旋，参观楼盘，讨价还价，等等。 &lt;/p&gt;
&lt;p&gt;除此之外，年少的特朗普还有很高的社交天赋，在面对比他强势的对手时他明白：如果你跟他对着干，一旦他发现你的弱点，就能轻而易举击败你。但是，&lt;strong&gt;如果你也很强势，但是你尊重他，他就会真诚对你。不卑不亢才能赢得尊重，卑躬屈膝只有招来更甚的压迫&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-4896c1a88bc179ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;    年轻特朗普&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 1964年，特朗普从纽约军校毕业后，去了宾夕法尼亚大学沃顿商学院读书。沃顿让他明白，“学习成绩不代表一切，我的同学根本没有那么独一无二或令人敬畏，我一点也不比他们差。”而特朗普的内心觉得自己不会做父亲的房产生意，而想做更大、刺激、有吸引力的生意，因为他觉得父亲的方式赚钱太慢了。特朗普大学毕业之后，自己已经有了20万的资产，一边继续帮父亲打理生意，一边自己在曼哈顿发展。&lt;/p&gt;
&lt;h3&gt;地产大亨养成记&lt;/h3&gt;
&lt;p&gt;不得不说特朗普在房地产项目上很有造诣，必须得提一下特朗普大厦。&lt;/p&gt;
&lt;p&gt;1971年，年轻的特朗普常走街串巷考察地段，看中了纽约57号大街和第五大道交会处的一座11层的建筑，这个地块位置极佳，面积又大，特朗普坚信在这个地方建一座大厦，前景一定不错。当时这块地属于格涅斯科公司，由富兰克林管理。特朗普第一次去找富兰克林，对方礼貌的回绝了他，说：“你居然认为我们会把这块风水宝地卖出去，真是天方夜谭”。&lt;/p&gt;
&lt;p&gt;回去后特朗普还是不想放弃，于是开始给富兰克林写信，第一封信是表达感谢对方愿意见他，一个月之后，特朗普再次写信请他重新考虑之前的申请，不过这封信没有得到回音。于是又写了一封信询问是否可以再次去拜访，三个月后，特朗普再去造访富兰克林，但是对方还是没有改变初衷。不过这为后面的事情埋下了伏笔。真是福兮祸所依。&lt;/p&gt;
&lt;p&gt;格涅斯科公司这三年来经历了财务危机，公司换了一位行政总裁约翰·哈尼根，他不停地卖出公司资产，以便甩掉累累负债，偿还银行贷款。而特朗普的这些信打动了这位后来者。他主动联系了特朗普，表示有意向出售。而特朗普心里明白：&lt;strong&gt;像哈尼根这样的人职业经理人，每新到一家公司是不会对公司员工和产品有什么感情的，冷酷无情是他的一贯作风，比起过程更注重结果&lt;/strong&gt;。不过，格涅斯科公司只拥有这块地的租用权，租期还剩29年，特朗普同意以2500万美元买下这块土地的租用权。考虑到没签合同之前，最主要的就是保密，如果将生意公开化，一定会遭到所有人的哄抢，价格自然也会一路飙升。于是特朗普告诉哈尼根：“咱们先拟一份合同草约，写上你同意我出2500万美元买你的地方，前提是我们要制定出双方满意的合同。这样的话，我们都得对这笔生意负责到底。”哈尼根没有任何异议。哈尼根虽然精明，可毕竟不是纽约本地人。他不知道这个地方是个烫手的山芋，即使经济不景气，也有很多人垂青于此。这样，特朗普&lt;strong&gt;不仅口头上谈成了生意，还得到了书面的保障&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;后来特朗普又为银行贷款和上空使用权奔波，一切快准备就续的时候，到了1979年1月，消息泄露了，很多买家找上了格涅斯科公司，包括石油发家的阿拉伯商人。这个时候，之前跟约翰·哈尼根签订的那份合同草约成了保证特朗普生意顺利进行的幸运星。虽然他不敢保证那份草约具有法律约束力，但至少他可以凭此向法院上诉，使邦维泰勒几年之内无法卖出。特朗普要让格涅斯科公司知道，&lt;strong&gt;他们敢毁约，我就敢上诉。而且格涅斯科公司的债权人现在催得很紧，他们没有太多时间为这笔生意周旋&lt;/strong&gt;。不久《纽约时报》记者前来采访特朗普，特朗普干脆放出消息说自己已经跟格涅斯科公司达成了协议，我会在邦维泰勒所在的地方新建一座大厦，所以邦维百货几个月之内就要关闭了。正是这条消息给对方造成了很大的舆论压力，邦维百货的高管纷纷离职，生意做不下去了，消息见报5天后，格涅斯科公司顺利地跟特朗普签订了合同。到1980年3月份，大厦开始动工，落成后成为了北美地区第二高楼。大厦的设计、建造、营销都很成功。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-f85f766619ed9c4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;特朗普大厦&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;要了解一个人不能只听他说什么，还要观察他的行为，特朗普的耐心和谈判技巧毋庸置疑。 此后特朗普集团在酒店赌场、高尔夫球场、溜冰场的建设方面都很出色。一手缔造了他的商业帝国。无疑他是一位非常成功的地产商人，而且是在出手时机，谈判，设计，建造，营销各方面都很出色的商人。&lt;/p&gt;
&lt;h3&gt;爱名狂人&lt;/h3&gt;
&lt;p&gt;这个特点也要从特朗普大厦说起，在建造的过程中，因为他不愿意为几件艺术装饰雕塑花钱，便拆除了他们，没想到却引起了轩然大波，《纽约时报》指责他“高楼大厦的背后没有高尚的人格，大宗生意必然牺牲艺术作品。”，进而后续的许多宣传报道都是负面的，但起到的作用却并不全是消极的，而且新闻报道为特朗普大厦吸引了很多注意力，公寓的销售量也猛增。作为一名商人，特朗普从中悟出一个道理：&lt;strong&gt;好名声比坏名声强，不过，坏名声比没名声强。说白了，争议也能促进销售&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-dda3ed3473628667.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;所以我们现在看到的特朗普充满争议性，没准就是他自己想要的结果。比如曾经有一名记者写了一本《特朗普国度》骂他，特朗普就控告该作者以及出版社，有一条他不能忍的是，作者有意把他的财产减少了几十亿美元，说自己最多只有几亿美元。2007年9月，《福布斯》杂志确认特朗普的资产总额上升到了30亿美元。但特朗普认为他们的估计还是太保守了，比其实际资产低很多。&lt;/p&gt;
&lt;p&gt;此外，特朗普非常喜欢用自己的名字命名他的杰作，比如特朗普大厦、特朗普国家高尔夫球场、特朗普苏荷区酒店式公寓、特朗普国际饭店、迪拜的特朗普国际棕榈酒店以及特朗普海滨大道等等。在出书这件事情，他照样也很成功。往往一个爱名的人，比较惜名，因为名誉带来的附加值让维护是值得的。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;有人说我言语粗鲁，也有人说我桀骜不驯，还有人说我满嘴废话。这些评价都没错，&lt;strong&gt;我倒是把它们当成了褒奖&lt;/strong&gt;，因为这样的我还实现了这么多成就。我并非做事没有耐心，但是当我意识到应该把注意力集中到别的事情上去的时候，我认为最明智的就是转移精力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实在当选总统之前，特朗普通过《飞黄腾达》真人秀节目，已经成为了一名网红。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果你有自己值得自豪的优点，而且又有足够的理由来支撑自己的这份自信，那么你就大胆秀出你的自信。对于自己取得的成就根本无须遮遮掩掩。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特朗普确实善于作秀。比如他非常期待因为朝鲜核问题而获得诺贝尔和平奖，在郭台铭决定在美国建厂之后，他宣传那是&quot;世界八大奇迹&quot;。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-77c8b410fdc57123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;特朗普参加富士康开工&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;Q&amp;amp;A&lt;/h3&gt;
&lt;p&gt;每年特朗普会收到很多信，他回复了其中的一些问题，我选了几个比较有意思的。&lt;/p&gt;
&lt;p&gt;1.如果你的下属一而再再而三地因为同样的问题出错，你会怎么处理？&lt;/p&gt;
&lt;p&gt;答：我没有这样的下属。这样的人现在应该在为别人效力。&lt;/p&gt;
&lt;p&gt;2.你崇拜哪些历史人物，为什么？&lt;/p&gt;
&lt;p&gt;答：亚伯拉罕·林肯是一个，因为他在我们国家最困难的时候担任总统。他也是自学成才，在成为总统之前还吃了很多年苦。另一位就是温斯顿·丘吉尔，他在人类历史关键的第二次世界大战中挺身而出。他是一位出色的演说家，他那激动人心的演说鼓舞了成千上万人的斗志，他还因为自己写作的历史小说获得了诺贝尔文学奖。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/133630-a18524e02b25470c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;特朗普与里根总统&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;3.对于想自己创业的人，你有什么建议吗？&lt;/p&gt;
&lt;p&gt;答：准备好迎接各种各样的问题，它们每天都会发生。不论发生什么问题，你都要打起精神来，要有兵来将挡、水来土掩的气概。永不放弃！&lt;/p&gt;
&lt;p&gt;4.即便我们已经努力奋斗了，但结果还是不如人意该怎么办呢？&lt;/p&gt;
&lt;p&gt;答：首先你要知道有这种疑虑的不仅仅是你一个人。我曾经为了等待某些事的发生花了整整30年，有些人等待了比我更长的时间。你要想到自己做的事有可能并不正确，因此不管你多么努力都看不到成效。但是，你要确信自己手里干的事是适合自己的，你要喜欢自己所干的事业，并坚持到底。&lt;/p&gt;
&lt;p&gt;5.你小时候的梦想是什么？&lt;/p&gt;
&lt;p&gt;答：我的梦想是要么当棒球运动员，要么当建筑商。我喜欢用自己的积木来搭建摩天大楼。我的棒球打得也很好，还因此得到了奖学金。我曾经想过去美国南加州大学进修电影拍摄，但因为对房地产业的了解和热爱让我最终选择了沃顿商学院。&lt;/p&gt;
&lt;h3&gt;这样的对手&lt;/h3&gt;
&lt;p&gt;特朗普高调、聪明，在谈判中发现了对方的弱点会毫不吝啬的杀价，为做好一件事他有十足的耐心和充分的准备。他爱名，但也很乐意成为争论的焦点。回顾贸易战前夕，特朗普与2017年11月份来华访问，三天拿下了两千多亿美元的订单，回去没多久就开始变脸，但变脸的时候还不忘说一句和我们的习大大是好朋友。真是得了便宜还卖乖，而且谈判期间揪住中兴死死不放，直到开出天价罚单，现在中兴也是刚从ICU出来，头上的氧气管子还被美国捏在手里。这一切基本上美方是按照剧本在本色出演。&lt;/p&gt;
&lt;p&gt;我不清楚管理企业和管理国家有多大的区别，企业竞争可以吃掉对手，但国家之间多是寻求互利共赢。很显然，特朗普正在像治理企业一样治理国家，为了企业有更好的发展，于是先退出巴黎气候协定，降低国内企业税收。然后为了让本国企业在国外有多的销路和竞争力，于是发动贸易战，贸易战的初衷之一就是各国有同样互惠的关税。但美国优先和以邻为壑的态度还是激起了全世界的反击，不见得是一条正确的路。面对特朗普这样的人，就如他自己所说的一样，在强势的对手面前，你也要保持强势，并且尊重对方，才有可能获得公平相待。以其人之道还治其人之身。另外就是要有十足的准备，不要对其抱有侥幸心理。按照既定目标，不断前进，不受其阻扰。&lt;/p&gt;
&lt;p&gt;最后说明一下，其实《永不放弃》和《从20万到30亿》中大量素材是重复的，基本上都是特朗普引以为傲的地产项目，前者更像是一位成功学导师的姿态灌输鸡汤，后者更贴近原型。如果你时间有限，我建议你读《从20万到30亿：特朗普自传》，这里有很多谈判协商的细节。想要资源可以留言&lt;/p&gt;
</description>
<pubDate>Sun, 08 Jul 2018 13:45:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/9281409.html</dc:identifier>
</item>
</channel>
</rss>