<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C#语法——泛型的多种应用 - kiba518</title>
<link>http://www.cnblogs.com/kiba/p/9321530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kiba/p/9321530.html</guid>
<description>&lt;p&gt;本篇文章主要介绍泛型的应用。&lt;/p&gt;
&lt;p&gt;泛型是.NET Framework 2.0 版类库就已经提供的语法，主要用于提高代码的可重用性、类型安全性和效率。&lt;/p&gt;
&lt;p&gt;泛型的定义&lt;/p&gt;
&lt;p&gt;下面定义了一个普通类和一个泛型类，我们可以明确看到泛型类和普通类最大的区别就是多了一个&amp;lt;T&amp;gt;。&lt;/p&gt;
&lt;p&gt;所以，这个&amp;lt;T&amp;gt;就标记了，这个类是泛型类。其中这个T，也可以写成A,B,C,D或其他字符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public class Generic
{
    public String Name;
}
&lt;/pre&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public class Generic&amp;lt;T&amp;gt;
{
    public T Name;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;泛型，顾名思义，就是泛指的类型。好比男人，女人，白人，黑人，可以泛称为【人】。&lt;/p&gt;
&lt;p&gt;但类型只能是一个类型。 那么泛型和类型之间是什么关系呢？&lt;/p&gt;
&lt;p&gt;其实很简单，泛型在定义的时候，是泛指类型；在使用的时候，就需要被指定，到底使用哪个类型。&lt;/p&gt;
&lt;p&gt;即，使用时，就不在是泛指类型，而是特定类型。&lt;/p&gt;
&lt;p&gt;好比，定义时，定义了一个人。但在使用时，必须明确指定，到底是黑人还是白人。&lt;/p&gt;
&lt;p&gt;泛型的使用&lt;/p&gt;
&lt;p&gt;泛型类跟普通类的使用方式一样，都需要实例化对象，再由对象来调用内部的属性或方法。&lt;/p&gt;
&lt;p&gt;下面代码实例化了泛型Generic，实例化时，还指定了该泛型Generic的指定类型为String。&lt;/p&gt;
&lt;p&gt;所以要给泛型Generic的属性Name赋值，就需要赋值字符串类型的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public static void Excute()
{
    Generic&amp;lt;String&amp;gt; gs = new Generic&amp;lt;String&amp;gt;();
    gs.Name = &quot;Kiba518&quot;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面代码定义了一个Int类型的泛型Generic。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public static void Excute()
{
    Generic&amp;lt;int&amp;gt; gs = new Generic&amp;lt;int&amp;gt;();
    gs.Name = 518;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;泛型的默认值&lt;/p&gt;
&lt;p&gt;泛型的默认值，如下面代码所示。需要使用default(T)来赋值。&lt;/p&gt;
&lt;p&gt;不管泛型到底是String,int,bool或者是一个Class类型，都可以被自动赋值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public static void Excute()
{
    Generic&amp;lt;int&amp;gt; gs = new Generic&amp;lt;int&amp;gt;();
    gs.Name = 518;
    Generic&amp;lt;Task&amp;gt; gsTask = new Generic&amp;lt;Task&amp;gt;();
    gsTask.Name = new Task(()=&amp;gt; {
        Console.WriteLine(&quot;Kiba518&quot;);
    });
}

public class Generic&amp;lt;T&amp;gt;
{
    public T Name = default(T); 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;泛型的约束&lt;/p&gt;
&lt;p&gt;在泛型类中，有个特别的约束可供我们使用。&lt;/p&gt;
&lt;p&gt;当我们不显示的声明时，这个约束不存在。但当我们显示的声明的时候，这个约束就会执行。&lt;/p&gt;
&lt;p&gt;下面，我们来看看这个特别的约束。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public static void Excute()
{ 
    Generic&amp;lt;FanXing&amp;gt; gFanXing = new Generic&amp;lt;FanXing&amp;gt;();
    Generic&amp;lt;Base&amp;gt; gFanXingBase = new Generic&amp;lt;Base&amp;gt;();
    //Generic&amp;lt;string&amp;gt; gs = new Generic&amp;lt;string&amp;gt;(); 这样定义会报错
} 
public class Generic&amp;lt;T&amp;gt; where T : Base
{
    public T Name = default(T); 
} 
public class Base  
{
    public string Name { get; set; }
}
public class FanXing : Base
{
    public new string Name { get; set; }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面代码所示，【where T : Base】就是这个特别的约束。&lt;/p&gt;
&lt;p&gt;当显示声明这个约束的时候，定义会限制泛型的类型。&lt;/p&gt;
&lt;p&gt;什么是限制泛型的类型呢？&lt;/p&gt;
&lt;p&gt;很简单，泛型T，是泛指某一个类型。我们在定义泛型类时，还需显示的指定类型，此时我们显示指定的类型，要受这个限制。&lt;/p&gt;
&lt;p&gt;这个限制就是指【where T : Base】。&lt;/p&gt;
&lt;p&gt;它是限制是，要求我们指定的类型T必须是Base，或者该类型继承自Base，如FanXing类。&lt;/p&gt;
&lt;p&gt;泛型的函数&lt;/p&gt;
&lt;p&gt;在C#中，泛型不仅可以用于类，还可以直接用于函数。&lt;/p&gt;
&lt;p&gt;具体使用方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public static void Excute()
 {
     GenericFunc gf = new GenericFunc();
     gf.FanXingFunc&amp;lt;FanXing&amp;gt;(new FanXing() { Name=&quot;Kiba518&quot;});
 }
 public class GenericFunc
 {
     public void FanXingFunc&amp;lt;T&amp;gt;(T obj)
     {
         Console.WriteLine(obj.GetType());
     }
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单，调用泛型函数的时候，指定泛型函数的[指定类型]即可。&lt;/p&gt;
&lt;p&gt;但是，这里我们发现一个问题，那就是，在泛型函数里，使用泛型对象的时候，我们发现对象都是object类型的。&lt;/p&gt;
&lt;p&gt;那我们如果想使用泛型对象里的属性和方法时，要怎么办呢？&lt;/p&gt;
&lt;p&gt;很简单，反射就可以了。&lt;/p&gt;
&lt;p&gt;下面我们添加一个反射函数GetPropertyValue，专门用来获取属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public class GenericFunc
{
    public void FanXingFunc&amp;lt;T&amp;gt;(T obj)
    { 
        var name = GetPropertyValue(obj, &quot;Name&quot;);
        Console.WriteLine(name); 
    }
    public object GetPropertyValue(object obj, string name)
    {
        object drv1 = obj.GetType().GetProperty(name).GetValue(obj, null);
        return drv1;
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/243596/201807/243596-20180717175934604-1844179227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们就得到了我们想要的结果，如果想使用泛型类里的函数，道理也一样，只需要用反射来调用即可。&lt;/p&gt;
&lt;p&gt;结语&lt;/p&gt;
&lt;p&gt;看到这里，有些同学可能会觉得泛型很复杂，连使用其对象下的属性，都得反射，太繁琐了，还不如不用呢。&lt;/p&gt;
&lt;p&gt;有这样想法的同学，心里想想就好了，如果对老司机这么说，他肯定会内心默默的微笑，然后对你说，你想的没错。&lt;/p&gt;
&lt;p&gt;然后，你就没有然后了。&lt;/p&gt;
&lt;p&gt;泛型的应用，开篇已经说了，主要用在提高代码的可重用性、类型安全性和效率上。&lt;/p&gt;
&lt;p&gt;如果只是定义一个类，调用一个属性，那泛型的存在就是鸡肋。&lt;/p&gt;
&lt;p&gt;但事实上，我们的系统永远只有更复杂，更复杂，更复杂。因此泛型才有了用武之地。&lt;/p&gt;

&lt;p&gt;----------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;注：此文章为原创，欢迎转载，请在文章页面明显位置给出此文链接！&lt;br/&gt;若您觉得这篇文章还不错请点击下右下角的&lt;span&gt;【&lt;strong&gt;推荐】&lt;/strong&gt;&lt;/span&gt;，非常感谢！&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 23:06:00 +0000</pubDate>
<dc:creator>kiba518</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kiba/p/9321530.html</dc:identifier>
</item>
<item>
<title>图解Java常用数据结构(一) - 大道方圆</title>
<link>http://www.cnblogs.com/xdecode/p/9321848.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xdecode/p/9321848.html</guid>
<description>&lt;p&gt;最近在整理数据结构方面的知识, 系统化看了下Java中常用数据结构, 突发奇想用动画来绘制数据流转过程.&lt;/p&gt;
&lt;p&gt;主要基于jdk8, 可能会有些特性与jdk7之前不相同, 例如LinkedList LinkedHashMap中的双向列表不再是回环的.&lt;/p&gt;
&lt;p&gt;HashMap中的单链表是尾插, 而不是头插入等等, 后文不再赘叙这些差异, 本文目录结构如下:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717140301329-1795204354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;LinkedList&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;经典的双链表结构, 适用于乱序插入, 删除. 指定序列操作则性能不如ArrayList, 这也是其数据结构决定的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;add(E) / addLast(E)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717133746276-313211308.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;add(index, E)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这边有个小的优化, 他会先判断index是靠近队头还是队尾, 来确定从哪个方向遍历链入.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; 1&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             Node&amp;lt;E&amp;gt; x =&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; index; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 x =&lt;span&gt; x.next;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             Node&amp;lt;E&amp;gt; x =&lt;span&gt; last;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - 1; i &amp;gt; index; i--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 x =&lt;span&gt; x.prev;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134043714-1008528320.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;靠队尾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134100309-1487165805.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;get(index)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;也是会先判断index, 不过性能依然不好, 这也是为什么不推荐用for(int i = 0; i &amp;lt; lengh; i++)的方式遍历linkedlist, 而是使用iterator的方式遍历.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134201828-1536755274.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134212062-1192617618.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;remove(E)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134240000-783801823.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;ArrayList&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;底层就是一个数组, 因此按序查找快, 乱序插入, 删除因为涉及到后面元素移位所以性能慢.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;add(index, E)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134402495-1450834113.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般默认容量是10, 这边偷懒一下, 假设容量只有5, 扩容后, 会length*1.5, &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134419069-835274795.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;remove(E)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;循环遍历数组, 判断E是否equals当前元素, 删除性能不如LinkedList.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134440963-1609104909.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Stack&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;经典的数据结构, 底层也是数组, 继承自Vector, 先进后出FILO, 默认new Stack()容量为10, 超出自动扩容.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;push(E)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134532106-566548837.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pop()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134546142-1425174736.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;后缀表达式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Stack的一个典型应用就是计算表达式如 9 + (3 - 1) * 3 + 10 / 2, 计算机将中缀表达式转为后缀表达式, 再对后缀表达式进行计算.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中缀转后缀&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数字直接输出&lt;/li&gt;
&lt;li&gt;栈为空时，遇到运算符，直接入栈&lt;/li&gt;
&lt;li&gt;遇到左括号, 将其入栈&lt;/li&gt;
&lt;li&gt;遇到右括号, 执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出。&lt;/li&gt;
&lt;li&gt;遇到运算符(加减乘除)：弹出所有优先级大于或者等于该运算符的栈顶元素，然后将该运算符入栈&lt;/li&gt;
&lt;li&gt;最终将栈中的元素依次出栈，输出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134649235-361366195.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算后缀表达&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;遇到数字时，将数字压入堆栈&lt;/li&gt;
&lt;li&gt;遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算, 并将结果入栈&lt;/li&gt;
&lt;li&gt;重复上述过程直到表达式最右端&lt;/li&gt;
&lt;li&gt;运算得出的值即为表达式的结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134706912-413651296.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;队列&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;与Stack的区别在于, Stack的删除与添加都在队尾进行, 而Queue删除在队头, 添加在队尾.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生产消费者中常用的阻塞有界队列, FIFO.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;put(E)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134917471-223068187.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;put(E) 队列满了&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lock;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        lock.lockInterruptibly();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (count ==&lt;span&gt; items.length)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;strong&gt;&lt;span&gt;                notFull.await();
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;            enqueue(e);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;            lock.unlock();
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134930548-1581371083.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;take()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当元素被取出后, 并没有对数组后面的元素位移, 而是更新takeIndex来指向下一个元素.&lt;/p&gt;
&lt;p&gt;takeIndex是一个环形的增长, 当移动到队列尾部时, 会指向0, 再次循环.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; E dequeue() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert lock.getHoldCount() == 1;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert items[takeIndex] != null;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Object[] items = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.items;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         E x =&lt;span&gt; (E) items[takeIndex];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         items[takeIndex] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (++takeIndex ==&lt;span&gt; items.length)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             takeIndex = 0&lt;span&gt;;
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;10&lt;/span&gt;         count--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (itrs != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            itrs.elementDequeued();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        notFull.signal();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717134947090-1857674903.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;HashMap&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;最常用的哈希表, 面试的童鞋必备知识了, 内部通过数组 + 单链表的方式实现. jdk8中引入了红黑树对长度 &amp;gt; 8的链表进行优化, 我们另外篇幅再讲.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;put(K, V&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135210703-312944088.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;put(K, V) 相同hash值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135235292-826682325.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;resize 动态扩容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当map中元素超出设定的阈值后, 会进行resize (length * 2)操作, 扩容过程中对元素一通操作, 并放置到新的位置.&lt;/p&gt;
&lt;p&gt;具体操作如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在jdk7中对所有元素直接rehash, 并放到新的位置.&lt;/li&gt;
&lt;li&gt;在jdk8中判断元素原hash值新增的bit位是0还是1, 0则索引不变, 1则索引变成&quot;原索引 + oldTable.length&quot;.&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两条链
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原来的hash值新增的bit为0的链，头部和尾部&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     Node&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原来的hash值新增的bit为1的链，头部和尾部&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     Node&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Node&amp;lt;K,V&amp;gt;&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环遍历出链条链&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         next =&lt;span&gt; e.next;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (loTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 loHead =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 loTail.next =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             loTail =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (hiTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 hiHead =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 hiTail.next =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             hiTail =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     } &lt;span&gt;while&lt;/span&gt; ((e = next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;扩容前后位置不变的链&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (loTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         loTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         newTab[j] =&lt;span&gt; loHead;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;扩容后位置加上原数组长度的链&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (hiTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         hiTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         newTab[j + oldCap] =&lt;span&gt; hiHead;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135330300-1394283875.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;LinkedHashMap&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;继承自HashMap, 底层额外维护了一个双向链表来维持数据有序. 可以通过设置accessOrder来实现FIFO(插入有序)或者LRU(访问有序)缓存.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;put(K, V)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135428093-1692938646.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;get(K)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;accessOrder为false的时候, 直接返回元素就行了, 不需要调整位置. &lt;/p&gt;
&lt;p&gt;accessOrder为true的时候, 需要将最近访问的元素, 放置到队尾.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135449262-926868516.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;removeEldestEntry 删除最老的元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285727/201807/1285727-20180717135601748-1338089287.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 22:30:00 +0000</pubDate>
<dc:creator>大道方圆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xdecode/p/9321848.html</dc:identifier>
</item>
<item>
<title>Golang vs PHP 之文件服务器 - 李嘉的博客</title>
<link>http://www.cnblogs.com/lijiajia/p/9326940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiajia/p/9326940.html</guid>
<description>&lt;h5 id=&quot;前面的话&quot;&gt;前面的话&lt;/h5&gt;
&lt;p&gt;&lt;em&gt;作者为golang脑残粉，本篇内容可能会引起phper不适，请慎读！&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;前两天有同事遇到一个问题，需要一个能支持上传、下载功能的HTTP服务器做一个数据中心。我刚好弄过，于是答应帮他搭一个。&lt;/p&gt;
&lt;p&gt;HTTP服务器，首先想到的就是PHP + nginx。于是开撸，先写一个PHP的上传&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
    if ($_FILES[&quot;file&quot;][&quot;error&quot;] &amp;gt; 0)
    {
        echo &quot;错误：: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&amp;lt;br&amp;gt;&quot;;
    }
    else
    {
        if (file_exists(&quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))
        {
            echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot; 文件已经存在。 &quot;;
        }
        else
        {
            move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]);
            echo &quot;文件存储在: &quot; . &quot;upload/&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];
        }
    }
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，写好了！需求完成了！测试一下把！&lt;/p&gt;
&lt;h5 id=&quot;于是开始第一次测试结果失败&quot;&gt;于是开始第一次测试，结果：失败！&lt;/h5&gt;
&lt;p&gt;原因是PHP的upload_max_filesize只有2M，上传的文件大小超过限制了。&lt;br/&gt;修改了一下php.ini配置，再次测试可以上传了&lt;/p&gt;
&lt;p&gt;那么部署到服务器上去把。服务器上有一个openresty（nginx的系列的web服务器），把upload.php文件丢里面，然后重启服务。好了，又可以测试一下了！&lt;/p&gt;
&lt;h5 id=&quot;于是第二次测试结果失败&quot;&gt;于是第二次测试，结果：失败！&lt;/h5&gt;
&lt;p&gt;原因是，openresty默认没开php解析，要改下配置。把nginx.conf里的php解析打开一下。重启nginx，然后再测试一下吧~&lt;/p&gt;
&lt;h5 id=&quot;于是第三次测试还是失败&quot;&gt;于是，第三次测试，还是失败！&lt;/h5&gt;
&lt;p&gt;原来。。这台机器上，虽然有nginx，但是没有安装PHP！！！ 想到还要去外网下载PHP，然后还要选版本，然后回来安装还要配置环境变量以及openresty关联php的配置后。。&lt;/p&gt;
&lt;p&gt;算了，再见吧 PHP！&lt;/p&gt;
&lt;h4 id=&quot;轮到go语言上场的时候了&quot;&gt;轮到Go语言上场的时候了！！&lt;/h4&gt;
&lt;p&gt;在golang的世界里1行代码就能搞定一个文件服务器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;log&quot;
    &quot;net/http&quot;
)

func main() {
    log.Fatal(http.ListenAndServe(&quot;:8038&quot;, http.FileServer(http.Dir(&quot;./&quot;))))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就这样，你就可以在本机访问8038端口去下载指定路径的文件了！不需要依赖nginx或者其他任何web服务器&lt;/p&gt;
&lt;p&gt;包含上传、下载功能的FileServer.go全部代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;os&quot;
)

const (
    uploadPath = &quot;./Files/&quot;
)

func main() {
    http.HandleFunc(&quot;/upload&quot;, uploadHandle)
    fs := http.FileServer(http.Dir(uploadPath))
    http.Handle(&quot;/Files/&quot;, http.StripPrefix(&quot;/Files&quot;, fs))
    log.Fatal(http.ListenAndServe(&quot;:8037&quot;, nil))
}

func uploadHandle(w http.ResponseWriter, r *http.Request) {
    file, head, err := r.FormFile(&quot;file&quot;)
    if err != nil {
        fmt.Println(err)
        return
    }
    defer file.Close()
    filePath := uploadPath + head.Filename
    fW, err := os.Create(filePath)
    if err != nil {
        fmt.Println(&quot;文件创建失败&quot;)
        return
    }
    defer fW.Close()
    _, err = io.Copy(fW, file)
    if err != nil {
        fmt.Println(&quot;文件保存失败&quot;)
        return
    }
    io.WriteString(w, &quot;save to &quot;+filePath)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;如何部署&quot;&gt;如何部署&lt;/h4&gt;
&lt;p&gt;go是静态编译型语言，直接编译出可执行文件，在windows上也就是exe。放到任何一台机器上，不需要安装额外环境，就能直接运行！&lt;/p&gt;
&lt;p&gt;所以编译出FileServer.exe文件，丢到服务器机子上执行。&lt;/p&gt;
&lt;h3 id=&quot;继续测试结果-成功稳&quot;&gt;继续测试！结果： 成功，稳！&lt;/h3&gt;
</description>
<pubDate>Tue, 17 Jul 2018 16:50:00 +0000</pubDate>
<dc:creator>李嘉的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijiajia/p/9326940.html</dc:identifier>
</item>
<item>
<title>探秘SpringAop(一)_介绍以及使用详解 - 阳光温暖</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9326917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9326917.html</guid>
<description>&lt;h3 id=&quot;常用的编程范式&quot;&gt;常用的编程范式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;aop-是什么&quot;&gt;AOP 是什么&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;是一种编程方式，不是编程语言&lt;/li&gt;
&lt;li&gt;解决特定问题，不能解决所有的问题&lt;/li&gt;
&lt;li&gt;OOP的补充，不是代替&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;aop-初衷&quot;&gt;AOP 初衷&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;DRY: Don't repeat yourself(代码重复)&lt;/li&gt;
&lt;li&gt;SoC：Separation of Concerns（关注点分离）
&lt;ul&gt;&lt;li&gt;水平分离：展示层-&amp;gt; 服务层 -&amp;gt; 持久层&lt;/li&gt;
&lt;li&gt;垂直分离：模块划分（订单、库存等）&lt;/li&gt;
&lt;li&gt;切面分离：分离功能性需求与非功能性需求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;aop的优点&quot;&gt;AOP的优点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;集中处理某一关注点/横切逻辑&lt;/li&gt;
&lt;li&gt;可以很方便地添加/删除关注点&lt;/li&gt;
&lt;li&gt;侵入性少，增强代码可读性及可维护性&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;aop的应用场景&quot;&gt;AOP的应用场景&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;权限控制&lt;/li&gt;
&lt;li&gt;缓存控制&lt;/li&gt;
&lt;li&gt;性能监控&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;支持aop的语言&quot;&gt;支持AOP的语言&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Java、Python、PHP...&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;springaop使用详解&quot;&gt;SpringAOP使用详解&lt;/h3&gt;
&lt;p&gt;首先，我整理了一张图，让大家更好的梳理SpringAOP的使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/aop%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;poincut-详解&quot;&gt;@Poincut 详解&lt;/h4&gt;
&lt;h5 id=&quot;匹配包类型_-within&quot;&gt;匹配包/类型_ within()&lt;/h5&gt;
&lt;h5 id=&quot;匹配对象&quot;&gt;匹配对象&lt;/h5&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;匹配AOP对象的目标对象为指定类型的方法,即LogService的aop代理对象的方法&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;@Pointcut(&quot;this(com.zhb.log.Loggable)&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;匹配实现Loggable接口的目标对象(而不是aop代理后的对象)的方法&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;@Pointcut(&quot;target(com.zhb.log.Loggable)&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;this 可以拦截 DeclareParents(Introduction)&lt;/li&gt;
&lt;li&gt;target 不拦截 DeclareParents(Introduction)&lt;/li&gt;
&lt;li&gt;匹配所有以Service结尾的bean里头的方法&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;@Pointcut(&quot;bean(*Service)&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;匹配参数-args&quot;&gt;匹配参数 args()&lt;/h5&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;匹配任何以find开头而且只有一个Long参数的方法&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;@Pointcut(&quot;execution(* &lt;em&gt;..find&lt;/em&gt;(Long))&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;匹配任何以find开头的而且第一个参数为Long型的方法&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;@Pointcut(&quot;execution(* &lt;em&gt;..find&lt;/em&gt;(Long,..))&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;匹配任何只有一个Long参数的方法&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;@Pointcut(&quot;within(com.zhb..*) &amp;amp;&amp;amp; args(Long)&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;匹配第一个参数为Long型的方法&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;@Pointcut(&quot;within(com.zhb..*) &amp;amp;&amp;amp; args(Long,..)&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;匹配注解&quot;&gt;匹配注解&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;匹配方法标注有AdminOnly的注解的方法&lt;/li&gt;
&lt;li&gt;@Pointcut(&quot;@annotation(com.zhb.anno.AdminOnly) &amp;amp;&amp;amp; within(com.zhb..*)&quot;)&lt;/li&gt;
&lt;li&gt;匹配标注有NeedSecured的类底下的方法 //class级别&lt;/li&gt;
&lt;li&gt;@Pointcut(&quot;@within(com.zhb.anno.NeedSecured) &amp;amp;&amp;amp; within(com.zhb..*)&quot;)&lt;/li&gt;
&lt;li&gt;匹配标注有NeedSecured的类及其子类的方法 //runtime级别&lt;/li&gt;
&lt;li&gt;在spring context的环境下,二者没有区别&lt;/li&gt;
&lt;li&gt;@Pointcut(&quot;@target(com.zhb.anno.NeedSecured) &amp;amp;&amp;amp; within(com.zhb..*)&quot;)&lt;/li&gt;
&lt;li&gt;匹配传入的参数类标注有Repository注解的方法&lt;/li&gt;
&lt;li&gt;@Pointcut(&quot;@args(com.zhb.anno.NeedSecured) &amp;amp;&amp;amp; within(com.zhb..*)&quot;)&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;匹配方法&quot;&gt;匹配方法&lt;/h5&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;匹配任何公共方法&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;@Pointcut(&quot;execution(public * com.zhb.service.&lt;em&gt;.&lt;/em&gt;(..))&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;匹配com.zhb包及子包下Service类中无参方法&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;@Pointcut(&quot;execution(* com.zhb..&lt;em&gt;Service.&lt;/em&gt;())&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;匹配com.zhb包及子包下Service类中的任何只有一个参数的方法&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;@Pointcut(&quot;execution(* com.zhb..&lt;em&gt;Service.&lt;/em&gt;(*))&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;匹配com.zhb包及子包下任何类的任何方法&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;@Pointcut(&quot;execution(* com.zhb..&lt;em&gt;.&lt;/em&gt;(..))&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;匹配com.zhb包及子包下返回值为String的任何方法&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;@Pointcut(&quot;execution(String com.zhb..&lt;em&gt;.&lt;/em&gt;(..))&quot;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;匹配异常&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;execution(public * com.zhb.service.&lt;em&gt;.&lt;/em&gt;(..) throws java.lang.IllegalAccessException)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其实，这么多实际工作中用到的比较少，我平时就用过execution 这一个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;advice-详解&quot;&gt;Advice 详解&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;@Before(value = &quot;matchLongArg() &amp;amp;&amp;amp; args(productId)&quot;)&lt;/li&gt;
&lt;li&gt;public void beforeWithArgs(Long productId)&lt;/li&gt;
&lt;li&gt;@AfterReturning(value = &quot;matchReturn()&quot;,returning = &quot;returnValue&quot;)&lt;/li&gt;
&lt;li&gt;public void getReulst(Object returnValue)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;给出一段常用代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
    @Pointcut(&quot;within(com.zhb.controller.GirlController)&quot;)
    public void mathType(){}

    @Before(value = &quot;mathType() &amp;amp;&amp;amp; args(obj)&quot;)
    public void before(Object obj){

        System.out.println(&quot;这里是目标方法执行前先执行&quot;);
        //获取参数
        System.out.println(&quot;这里是目标方法的参数&quot;+obj.toString());
    }
    @AfterReturning(returning = &quot;entity&quot;,value = &quot;mathType()&quot;)
    public void after(JoinPoint joinPoint,Object entity){
        System.out.println(&quot;这里是目标方法执行完并成功返回结果 正常结束后才执行&quot;);
        System.out.println(&quot;方法的返回结果为&quot;+entity);
        System.out.println(&quot;目标方法内的参数为&quot;+ Arrays.asList(joinPoint.getArgs()));
    }
    @AfterThrowing(throwing = &quot;e&quot;,value = &quot;mathType()&quot;)
    public void mathThrow(Throwable  e){
        System.out.println(&quot;这里是目标方法抛出异常后才执行&quot;);
        System.out.println(&quot;异常信息为&quot;+e);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;大家再用到的时候可以自行搜索&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 17 Jul 2018 16:38:00 +0000</pubDate>
<dc:creator>阳光温暖</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9326917.html</dc:identifier>
</item>
<item>
<title>使用OkHttp模拟登陆LeetCode - zxzhang</title>
<link>http://www.cnblogs.com/ZhaoxiCheung/p/9302510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhaoxiCheung/p/9302510.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;网上有很多模拟登陆 LeetCode 的教程，但是基本都是使用 Python 来实现的。作为一个 Java 语言爱好者，因此想用 Java 来实现下。在实现的过程中，也遇到了一些坑点，故在此作为记录。&lt;/p&gt;
&lt;h2 id=&quot;过程&quot;&gt;过程&lt;/h2&gt;
&lt;p&gt;根据浏览器F12分析登陆页面&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180717235053350-533448489.png&quot;/&gt;&lt;br/&gt;从上图可以看出，LeetCode 生成一个 token ，然后在登陆的时候带上这个信息，因此我们模拟登陆的大致思路：首先获取得到 cookie（包含有token），然后在登陆的时候带上这个 cookie 信息，完成 LeetCode 的验证机制，进行模拟登陆。&lt;br/&gt;但是直接进行模拟带上 login（用户名）、password（密码）、csrfmiddlewaretoken（验证信息）是失败的，提示 Forbidden。思考无果，另开思路。&lt;br/&gt;用 fiddler 进行抓包，未登陆状态，数据如下图（也可用浏览器F12来进行分析）：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180712232736078-365644654.png&quot;/&gt;&lt;br/&gt;登陆状态，数据如下图，从图中，我们可以发现，其 Content-Type 字段与我们之前常见的值不一样，其是 multipart/form-data 格式，因此我们在模拟登陆，要将其考虑进来。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180712232921124-260362886.png&quot;/&gt;&lt;br/&gt;创建一个 multipart/form-data 的媒体格式，然后生成我们要的请求体，至于我们要的是哪种请求体，其格式可以从 fiddler 抓包的结果获悉。&lt;br/&gt;在SyntaxView中具体的详情如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180712233632559-2022692863.png&quot;/&gt;&lt;br/&gt;值得注意的是 Content-Type 中的boundary只有四个“-”，而在请求体中有六个“-”，之前因为忽略了这个，一直被拒绝访问（挺坑爹的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static final String boundary = &quot;----WebKitFormBoundaryhG2vKxp7y2GAwhPX&quot;;
public static final MediaType MULTIPART = MediaType.parse(&quot;multipart/form-data; boundary=&quot; + boundary);
String form_data = &quot;--&quot; + boundary + &quot;\r\n&quot;
                + &quot;Content-Disposition: form-data; name=\&quot;login\&quot;&quot; + &quot;\r\n\r\n&quot;
                + usrname + &quot;\r\n&quot;
                + &quot;--&quot; + boundary + &quot;\r\n&quot;
                + &quot;Content-Disposition: form-data; name=\&quot;password\&quot;&quot; + &quot;\r\n\r\n&quot;
                + passwd
                + &quot;--&quot; + boundary + &quot;\r\n&quot;
                + &quot;Content-Disposition: form-data; name=\&quot;csrfmiddlewaretoken\&quot;&quot; + &quot;\r\n\r\n&quot;
                + csrftoken + &quot;\r\n&quot;
                + &quot;--&quot; + boundary + &quot;--&quot;;
        RequestBody requestBody = RequestBody.create(MULTIPART,form_data);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结果&quot;&gt;结果&lt;/h2&gt;
&lt;p&gt;将其返回的报文打印出来，得到如下信息则表示模拟登陆成功&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180718001109137-81787662.png&quot;/&gt;&lt;br/&gt;从 fiddler 的抓包结果中也可以证实这点&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180718002750037-2135053785.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;package LeetCodeLogin;

import okhttp3.*;
import org.jsoup.Connection;
import org.jsoup.Jsoup;


import java.io.IOException;
import java.util.*;


import static java.lang.System.out;

public class Login {
    public static final String boundary = &quot;----WebKitFormBoundaryhG2vKxp7y2GAwhPX&quot;;
    public static final MediaType MULTIPART = MediaType.parse(&quot;multipart/form-data; boundary=&quot; + boundary);
    public static void main(String... args) throws IOException {
        Scanner scanner = new Scanner(System.in);


        String url = &quot;https://leetcode.com/accounts/login/&quot;;
        String usrname = &quot;xxx&quot;;
        String passwd = &quot;xxx&quot;;

        Connection.Response response1 = Jsoup.connect(url)
                .method(Connection.Method.GET)
                .execute();

        String csrftoken = response1.cookie(&quot;csrftoken&quot;);
        String __cfduid = response1.cookie(&quot;__cfduid&quot;);
        out.println(&quot;csrftoken = &quot; + csrftoken);
        out.println(&quot;__cfduid = &quot; + __cfduid );

        OkHttpClient client = new OkHttpClient().newBuilder()
                .followRedirects(false)
                .followSslRedirects(false)
                .build();


        String form_data = &quot;--&quot; + boundary + &quot;\r\n&quot;
                + &quot;Content-Disposition: form-data; name=\&quot;login\&quot;&quot; + &quot;\r\n\r\n&quot;
                + usrname + &quot;\r\n&quot;
                + &quot;--&quot; + boundary + &quot;\r\n&quot;
                + &quot;Content-Disposition: form-data; name=\&quot;password\&quot;&quot; + &quot;\r\n\r\n&quot;
                + passwd
                + &quot;--&quot; + boundary + &quot;\r\n&quot;
                + &quot;Content-Disposition: form-data; name=\&quot;csrfmiddlewaretoken\&quot;&quot; + &quot;\r\n\r\n&quot;
                + csrftoken + &quot;\r\n&quot;
                + &quot;--&quot; + boundary + &quot;--&quot;;
        RequestBody requestBody = RequestBody.create(MULTIPART,form_data);



        Request request = new Request.Builder()
                .addHeader(&quot;Content-Type&quot;, &quot;multipart/form-data; boundary=&quot; + boundary)
                .addHeader(&quot;Connection&quot;,&quot;keep-alive&quot;)
                .addHeader(&quot;Accept&quot;,&quot;*/*&quot;)
                .addHeader(&quot;Origin&quot;,&quot;https://leetcode.com&quot;)
                .addHeader(&quot;Referer&quot;,url)
                .addHeader(&quot;Cookie&quot;,&quot;__cfduid=&quot; + __cfduid + &quot;;&quot; + &quot;csrftoken=&quot; + csrftoken)
                .post(requestBody)
                .url(url)
                .build();

        Response response = client.newCall(request).execute();
        out.println(response.message());
        out.println(response.headers());
        out.println(response.body().string());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，在上述代码中，我们通过下述代码禁止了重定向，来自己处理重定向请求，可参考&lt;a href=&quot;https://jianshu.com/p/d04bfd6b6146&quot;&gt;使用OkHttp进行重定向拦截处理&lt;/a&gt;，若是没有进行重定向拦截，也会使得模拟登陆失败。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    .followRedirects(false)
    .followSslRedirects(false)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;本次模拟登陆，虽然代码很简单，但是确实也经历了一些波折，比对过 Python 和 Js 写的模拟登陆的代码，用 Java 来进行模拟似乎多了一些琐碎的细节，对于具体的为何 Python 和 Js 能如此简介的处理的原理还在琢磨中。此次，也得到了朋友 &lt;a href=&quot;https://home.cnblogs.com/u/faberry&quot;&gt;faberry&lt;/a&gt; 的帮助，在一些地方给了意见。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 16:32:00 +0000</pubDate>
<dc:creator>zxzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZhaoxiCheung/p/9302510.html</dc:identifier>
</item>
<item>
<title>函数式编程之-组合函数 - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9326823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9326823.html</guid>
<description>&lt;h2 id=&quot;组合&quot;&gt;组合&lt;/h2&gt;
&lt;p&gt;函数式编程的核心在于&lt;code&gt;组合&lt;/code&gt;，其中之一就是如何组合函数。我们在Currying一文就提到过组合，我们当时是这样描述的：只有一个输入和一个输出的函数才能完成组合，当然并不是所有的函数都只有一个输入，Currying可以帮助我们把多个输入参数的函数变成只有一个输入的函数。&lt;br/&gt;那么到底什么是组合，怎么组合？&lt;br/&gt;给定下面的两个函数：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1232840/o_Jietu20180717-235558@2x.png&quot;/&gt;&lt;br/&gt;组合上面的两个函数：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1232840/o_Jietu20180717-235616@2x.png&quot;/&gt;&lt;br/&gt;变成下面的函数：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1232840/o_Jietu20180717-235629@2x.png&quot;/&gt;&lt;br/&gt;看个例子：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let add1 x = x + 1 
let multiply2 x = x * 2
let compose g f x = f(g(x))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的函数类型为：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;add1 : x:int -&amp;gt; int
multiply2 : x:int -&amp;gt; int
compose : g:('a -&amp;gt; 'b) -&amp;gt; f:('b -&amp;gt; 'c) -&amp;gt; x:'a -&amp;gt; 'c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过compose函数来把add1和multiptly2组合起来：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let add1ThenMultiply2 x = compose add1 multiply2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1232840/o_Jietu20180717-235639@2x.png&quot;/&gt;&lt;br/&gt;从而得到新的函数：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1232840/o_Jietu20180717-235650@2x.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let result = add1ThenMultiply2 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1232840/o_Jietu20180717-235702@2x.png&quot;/&gt;&lt;br/&gt;既然compose这个函数在F#这么常用，不如定义一个操作符&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;来表示：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let (&amp;gt;&amp;gt;) f g x = g ( f(x) )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此上面的代码也可以通过&amp;gt;&amp;gt;来组合：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let add1ThenMultiply2 x = (&amp;gt;&amp;gt;) add1 multiply2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于操作符支持中缀表达式，也即操作符可以写在两个参数的中间，例如+号：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;(+) 1 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上可以写为：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;1 + 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么上面的代码就可以写成：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let add1ThenMultiply2 x = add1 &amp;gt;&amp;gt; multiply2&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;组合和管道符的区别&quot;&gt;组合和管道符的区别&lt;/h2&gt;
&lt;p&gt;上面的例子我们还可以用管道符来实现：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let result1 = 10 |&amp;gt; add1 |&amp;gt; multiply2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;管道符和组合的定义看起来非常相似：&lt;/p&gt;
&lt;pre class=&quot;fsharp&quot;&gt;
&lt;code&gt;let (|&amp;gt;) x f = f x
let (&amp;gt;&amp;gt;) f g x = g ( f(x) )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;管道符(|&amp;gt;)接受两个参数，在往下一个管道符传递的时候已经完成了求值，而函数组合实际上生成了新的函数，最后一步传入实际的参数才会完成求值。&lt;br/&gt;下面的图示描述了管道符的求值过程：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xiandnc/1232840/o_Jietu20180717-235710@2x.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 16:15:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9326823.html</dc:identifier>
</item>
<item>
<title>负的CPU保护环 - 李秋豪</title>
<link>http://www.cnblogs.com/liqiuhao/p/9326738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiuhao/p/9326738.html</guid>
<description>&lt;h2 id=&quot;什么是cpu保护环&quot;&gt;&lt;span&gt;什么是CPU保护环？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6&quot;&gt;计算机科学&lt;/a&gt;中, &lt;strong&gt;分级保护域&lt;/strong&gt;（英语：hierarchical protection domains），经常被叫作&lt;strong&gt;保护环&lt;/strong&gt;（Protection Rings），又称&lt;strong&gt;环型保护&lt;/strong&gt;（Rings Protection）、&lt;strong&gt;CPU环&lt;/strong&gt;（CPU Rings），简称Rings。这是一种用来在发生故障时保护数据和功能，提升容错度，避免恶意操作 ，提升&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8&quot;&gt;计算机安全&lt;/a&gt;的设计方式。工作在不同Ring中的对象对资源有不同的访问级别。Rings是从最高特权级（通常对应最小的数字）到最低特权级（最大的数字）排列的。在大多数操作系统中，Ring 0拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存），同时内层Ring可以随便使用外层Ring的资源。&lt;br/&gt;(&lt;em&gt;来自维基百科&lt;/em&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072319/201807/1072319-20180717234134808-109500174.png&quot; alt=&quot;Priv_rings&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rings的概念最早出现于x86保护模式的设计中。现在，这些Rings通常存储于段选择子和段描述符的特权级位置上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ring0-2为“管理员”层级，可以做大部分事情，但是Ring1-2不能使用特权指令——例如加载描述符表的&lt;code&gt;LGDT&lt;/code&gt;、&lt;code&gt;LLDT&lt;/code&gt;和加载任务寄存器的指令&lt;code&gt;ltr&lt;/code&gt;以及停机指令&lt;code&gt;hlt&lt;/code&gt;等等（Intel的初衷是让驱动存在于此Ring1-2，但现代操作系统通常将驱动也放在Ring0上）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ring3代表“用户模式”。如果你的当前特权级（CFL）或者请求特权级（RFL）在这个环上，那么你需要通过系统调用请求内核帮你完成一些资源利用操作，例如I/O读写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综上，Rings的设计将用户程序和服务程序对资源的利用进行隔离。正确使用Rings可以提升资源使用的安全性。例如，某个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%97%B4%E8%B0%8D%E8%BD%AF%E4%BB%B6&quot;&gt;间谍软件&lt;/a&gt;作为一个在Ring 3运行的用户程序，它在不通知用户的时候打开&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%91%84%E5%83%8F%E5%A4%B4&quot;&gt;摄像头&lt;/a&gt;应该会被阻止，因为访问硬件需要使用被&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F&quot;&gt;驱动程序&lt;/a&gt;保留的Ring 1的方法。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;为什么会有负的保护环&quot;&gt;&lt;span&gt;为什么会有负的保护环？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在现在的处理器中，大多有对虚拟化的硬件支持，例如Intel VT-x 和 AMD-V。在进行虚拟化之前，需要一些“高级管理员程序”初始化虚拟控制结构（这被称为VMCS），随后定义虚拟机并调用 &lt;code&gt;vmenter&lt;/code&gt; 和处理 &lt;code&gt;vmexit&lt;/code&gt; 进行虚拟化。而这些代码就工作在“Ring-1”层级。事实上，CPU并没有定义这种层级，但是考虑到每一个被虚拟化的内核都认为它们对系统有完全的控制权（Ring0），而它们又是被虚拟层所控制（对它们不可见），所以称其为“Ring-1”也是有道理的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统管理模式（&lt;a href=&quot;https://en.wikipedia.org/wiki/System_Management_Mode&quot;&gt;SMM&lt;/a&gt;）是另一种执行特殊指令的操作模式。电脑主板上会有一些固件（例如BIOS）建立起SMM来处理系统管理中断，例如为了实现高级电源管理。当这些事件/中断发生后，操作系统（甚至是上面提到的虚拟层）都会被挂起，随后CPU进入一个特殊的地址空间处理中断。由于SMM对于操作系统和虚拟层都不可见，所以通常称其工作在“Ring-2”下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有人可能记得去年有一个新闻：&lt;a href=&quot;http://news.mydrivers.com/1/554/554587.htm&quot;&gt;MINIX悄然成最流行系统：暗藏核弹级漏洞&lt;/a&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Intel现代处理器都支持ME管理引擎，用来管理协调内部的诸多模块，尤其是传统芯片组整合进入之后，处理器已经差不多成了SoC（System on Chip）单芯片系统，更需要一个“协同总管CPU”，而MINIX就是这个微型CPU的操作系统。 AMD也有自己的协同处理器，称为PSP。这个CPU可以对芯片组做任何事情，&lt;strong&gt;即使是在系统通电但还没有启动的时候（甚至系统的启动也是它的管理范畴）&lt;/strong&gt;。所以我们也称其工作在“Ring-3”下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从安全的角度考虑，程序工作的Ring值越低，其行为的可见性也就越低。例如用户程序不会意识到自己是工作在一个“虚拟地址”中，而OS不会意识到自己只是多个被虚拟化出来的一个，而虚拟层不会意识到自己在工作过程中SMM已经完成了对一些中断的处理，而协同处理器对以上所有对象都是不可见的。可以想象，如果能够在Ring值更低的层级植入恶意程序，其被查杀的难度也会越高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，以上说明基于x86架构，其他的架构CPU也有类似设计方式，例如ARM的user (3), supervisor (0), VMM (-1) 和TrustZone (-2)。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Protection_ring&quot;&gt;Protection ring From Wikipedia&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://software.intel.com/en-us/forums/watercooler-catchall/topic/306240&quot;&gt;Ring Architecture Question From Intel&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://manybutfinite.com/post/cpu-rings-privilege-and-protection/&quot;&gt;CPU Rings, Privilege, and Protection&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://security.stackexchange.com/questions/129098/what-is-protection-ring-1&quot;&gt;What is protection ring -1?&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;a href=&quot;https://book.douban.com/subject/20492528/&quot;&gt;《x86汇编语言:从实模式到保护模式》&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 17 Jul 2018 15:43:00 +0000</pubDate>
<dc:creator>李秋豪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqiuhao/p/9326738.html</dc:identifier>
</item>
<item>
<title>3YAdmin-专注通用权限控制与表单的后台管理系统模板 - 若若若邪</title>
<link>http://www.cnblogs.com/jaycewu/p/9326716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaycewu/p/9326716.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/wjkang/3YAdmin&quot;&gt;3YAdmin&lt;/a&gt;基于React+Antd构建。GitHub搜索React+Antd+Admin出来的结果没有上百也有几十个，为什么还要写这个东西呢？&lt;/p&gt;
&lt;p&gt;一个后台管理系统的核心我认为应该是权限控制，表单以及错误信息收集这三大块，前两个最为重要。而GitHub上的大多数项目关注点都不在这里，各种第三方组件堆砌在一起，看起来很炫酷，但是实用性没多大，改起来也麻烦(如果是vue,可以看我的另一个项目&lt;a href=&quot;https://github.com/wjkang/vue-quasar-admin&quot;&gt;vue-quasar-admin&lt;/a&gt;)。&lt;/p&gt;
&lt;p&gt;有人可能会有疑问：权限控制，不同系统实现不一样，根本没法做到通用。权限控制的模型就那几种，而且大部分都是RBAC，可能做不到完全通用，但是至少改动不会太大。&lt;/p&gt;
&lt;h2 id=&quot;yadmin&quot;&gt;3YAdmin&lt;/h2&gt;
&lt;p&gt;  &lt;a href=&quot;https://github.com/wjkang/3YAdmin&quot;&gt;3YAdmin&lt;/a&gt;是一个专注通用权限控制与表单的后台管理系统模板。&lt;/p&gt;
&lt;p&gt;  3YAdmin支持两种布局模式，Tab模式和正常模式。两种模式是webpack打包编译时确定的，打包某个模式时不会引入另外一种模式下的多余代码(React 实现Tab模式比较蛋疼)。&lt;/p&gt;
&lt;p&gt;  3YAdmin实现了RBAC权限控制模型的核心功能页面和操作。&lt;/p&gt;
&lt;p&gt;  3YAdmin通过解析定义好的JSON数据，可以生成查询表单，静态表单，动态表单。&lt;/p&gt;
&lt;p&gt;  搭配&lt;a href=&quot;https://github.com/wjkang/lazy-mock&quot;&gt;lazy-mock&lt;/a&gt; 可以快速生成前后端带mock数据的增删改查功能(简单的代码生成器)。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/jaycewu/p/9326716.html&quot;&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be46aa44f07&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/facebook/react/&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/react-16.3.2-brightgreen.svg&quot; alt=&quot;react&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/ant-design/ant-design&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/antd-3.5.3-brightgreen.svg&quot; alt=&quot;antd&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/axios-0.18.0-brightgreen.svg&quot; alt=&quot;axios&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/reduxjs/redux&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/redux-4.0.0-brightgreen.svg&quot; alt=&quot;redux&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/axios/axios&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/react--router--dom-4.2.2-brightgreen.svg&quot; alt=&quot;react-router-dom&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/jaycewu/p/9326716.html&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/license-MIT-brightgreen.svg&quot; alt=&quot;MIT&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;online demo:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jaycewu.coding.me/3YAdmin-preview&quot;&gt;Tab Mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jaycewu.coding.me/3YAdmin-preview-common&quot;&gt;Common Mode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;登录账号:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;admin 123

test 123456

website_admin 123456&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;功能与特点&quot;&gt;功能与特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;真实后端数据支持&lt;/li&gt;
&lt;li&gt;登录/登出&lt;/li&gt;
&lt;li&gt;收缩左侧菜单栏&lt;/li&gt;
&lt;li&gt;响应式布局&lt;/li&gt;
&lt;li&gt;按需加载&lt;/li&gt;
&lt;li&gt;Tag标签导航&lt;/li&gt;
&lt;li&gt;面包屑&lt;/li&gt;
&lt;li&gt;全屏/退出全屏&lt;/li&gt;
&lt;li&gt;动态菜单与静态菜单&lt;/li&gt;
&lt;li&gt;菜单按模块划分&lt;/li&gt;
&lt;li&gt;通用权限控制
&lt;ul&gt;&lt;li&gt;菜单级权限控制&lt;/li&gt;
&lt;li&gt;接口级权限控制&lt;/li&gt;
&lt;li&gt;元素级权限控制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;全局可配置loading效果&lt;/li&gt;
&lt;li&gt;网络异常处理&lt;/li&gt;
&lt;li&gt;模块
&lt;ul&gt;&lt;li&gt;系统模块
&lt;ul&gt;&lt;li&gt;系统设置
&lt;ul&gt;&lt;li&gt;菜单管理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;权限管理
&lt;ul&gt;&lt;li&gt;功能管理&lt;/li&gt;
&lt;li&gt;角色管理&lt;/li&gt;
&lt;li&gt;角色权限管理&lt;/li&gt;
&lt;li&gt;角色用户管理&lt;/li&gt;
&lt;li&gt;用户角色管理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;组织架构
&lt;ul&gt;&lt;li&gt;部门管理&lt;/li&gt;
&lt;li&gt;职位管理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用户管理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;审计日志&lt;/li&gt;
&lt;li&gt;数据初始化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;例子
&lt;ul&gt;&lt;li&gt;权限测试页&lt;/li&gt;
&lt;li&gt;错误页&lt;/li&gt;
&lt;li&gt;JSON表单(通过解析JSON数据,动态生成表单)
&lt;ul&gt;&lt;li&gt;Search Form(查询表单)&lt;/li&gt;
&lt;li&gt;Common Form(静态表单,解析第一次后,JSON数据改变后表单不会跟着变)&lt;/li&gt;
&lt;li&gt;Dynamic Form(动态表单,JSON数据改变后表单重新生成)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;安装使用&quot;&gt;安装使用&lt;/h2&gt;
&lt;h2 id=&quot;install&quot;&gt;Install&lt;/h2&gt;
&lt;pre class=&quot;bush&quot;&gt;
&lt;code&gt;git clone https://github.com/wjkang/3YAdmin.git

npm install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装后台mock服务&lt;/p&gt;
&lt;pre class=&quot;bush&quot;&gt;
&lt;code&gt;git clone -b 3YAdmin https://github.com/wjkang/quasar-admin-server.git

npm install

npm start&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;run&quot;&gt;Run&lt;/h2&gt;
&lt;h3 id=&quot;development&quot;&gt;Development&lt;/h3&gt;
&lt;pre class=&quot;bush&quot;&gt;
&lt;code&gt;npm start&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;productionbuild&quot;&gt;Production(Build)&lt;/h3&gt;
&lt;pre class=&quot;bush&quot;&gt;
&lt;code&gt;npm run build&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;p&gt;直接将react-react-app生成的配置复制出来进行修改，都在react-scripts文件夹下，当前配置了antd按需引入，分chunk打包以及使用了AutoDllPlugin。可以按照自己的需要进行修改。&lt;/p&gt;
&lt;p&gt;打包模式的配置需修改buils.js与start.js文件中的process.env.REACT_APP_LAYOUT_MODE&lt;/p&gt;
&lt;h2 id=&quot;使用教程&quot;&gt;使用教程&lt;/h2&gt;
&lt;p&gt;后面会出详细使用教程以及前后端分离的后台管理系统前端架构设计思路(包含vue和react)，喜欢的话可以给个star。&lt;/p&gt;
&lt;h2 id=&quot;效果展示&quot;&gt;效果展示&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be3fa3f4080?w=1913&amp;amp;h=872&amp;amp;f=jpeg&amp;amp;s=17544&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be3fa489ed8?w=1911&amp;amp;h=868&amp;amp;f=jpeg&amp;amp;s=28493&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be3fa746b37?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=39638&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be3fcf1f787?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=51561&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be3fc440fb4?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=102208&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be4670a06e5?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=84317&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be4b809cdb8?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=77884&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be4c776b40f?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=73593&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be4c7abdd9e?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=74306&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be4ff033b19?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=49744&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be50ddb4bb3?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=97566&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/17/164a8be554015a57?w=1920&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=74087&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 15:34:00 +0000</pubDate>
<dc:creator>若若若邪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jaycewu/p/9326716.html</dc:identifier>
</item>
<item>
<title>Java并发编程笔记之基础总结(二) - 狂小白</title>
<link>http://www.cnblogs.com/huangjuncong/p/9324072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/9324072.html</guid>
<description>&lt;h3&gt;一.线程中断&lt;/h3&gt;
&lt;p&gt;Java 中线程中断是一种线程间协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是需要被中断的线程根据中断状态自行处理。&lt;/p&gt;
&lt;p&gt;　　1.void interrupt() 方法：中断线程，例如当线程 A 运行时，线程 B 可以调用线程 A 的 interrupt() 方法来设置线程 A 的中断标志为 true 并立即返回。设置标志仅仅是设置标志，线程 A 并没有实际被中断，会继续往下执行的。如果线程 A 因为调用了 wait 系列函数或者 join 方法或者 sleep 函数而被阻塞挂起，这时候线程 B 调用了线程 A 的 interrupt() 方法，线程 A 会在调用这些方法的地方抛出 InterruptedException 异常而返回。&lt;/p&gt;

&lt;p&gt;　　2.boolean isInterrupted()：检测当前线程是否被中断，如果是返回 true，否者返回 false，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean isInterrupted() {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递false，说明不清除中断标志&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt; isInterrupted(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3.boolean interrupted():检测当前线程是否被中断，如果是返回 true，否者返回 false，与 isInterrupted 不同的是该方法如果发现当前线程被中断后会清除中断标志，并且该函数是 static 方法，可以通过 Thread 类直接调用。另外从下面代码可以知道 interrupted() 内部是获取当前调用线程的中断标志而不是调用 interrupted() 方法的实例对象的中断标志。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; boolean interrupted() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除中断标志&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; currentThread().isInterrupted(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看一个线程使用 Interrupted 优雅退出的经典使用例子，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){    
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{    
         ....    
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程退出条件&lt;/span&gt;
         &lt;span&gt;while&lt;/span&gt;(!Thread.currentThread().isInterrupted()&amp;amp;&amp;amp; more work to &lt;span&gt;do&lt;/span&gt;&lt;span&gt;){    
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do more work;    &lt;/span&gt;
&lt;span&gt;         }    
    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e){    
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; thread was interrupted during sleep or wait    &lt;/span&gt;
&lt;span&gt;    }    
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;{    
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cleanup, if required    &lt;/span&gt;
&lt;span&gt;    }    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面看一个根据中断标志判断线程是否终止的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterruptTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果当前线程被中断则退出循环&lt;/span&gt;
                &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;Thread.currentThread().isInterrupted())
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动子线程&lt;/span&gt;
&lt;span&gt;        thread.start();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主线程休眠1s，以便中断前让子线程输出点东西&lt;/span&gt;
        Thread.sleep(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断子线程&lt;/span&gt;
        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main thread interrupt thread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        thread.interrupt();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待子线程执行完毕&lt;/span&gt;
&lt;span&gt;        thread.join();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main is over&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717155718360-1098815264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码子线程 thread 通过检查当前线程中断标志来控制是否退出循环，主线程在休眠 1s 后调用 thread 的 interrupt() 方法设置了中断标志，所以线程 thread 退出了循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：中断一个线程仅仅是设置了该线程的中断标志，也就是设置了线程里面的一个变量的值，本身是不能终止当前线程运行的，一般程序里面是检查这个标志的状态来判断是否需要终止当前线程。&lt;/p&gt;

&lt;h3&gt;二.理解线程上下文切换&lt;/h3&gt;
&lt;p&gt;在多线程编程中，线程个数一般都大于 CPU 个数，而每个 CPU 同一时刻只能被一个线程使用，为了让用户感觉多个线程是在同时执行，CPU 资源的分配采用了时间片轮转的策略，也就是给每个线程分配一个时间片，在时间片内占用 CPU 执行任务。当前线程的时间片使用完毕后当前就会处于就绪状态并让出 CPU 让其它线程占用，这就是上下文切换，从当前线程的上下文切换到了其它线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么就有一个问题让出 CPU 的线程等下次轮到自己占有 CPU 时候如何知道之前运行到哪里了？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以在切换线程上下文时候需要保存当前线程的执行现场，当再次执行时候根据保存的执行现场信息恢复执行现场&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程上下文切换时机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1.当前线程的 CPU 时间片使用完毕处于就绪状态时候；&lt;/p&gt;
&lt;p&gt;　　2.当前线程被其它线程中断时候&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：由于线程切换是有开销的，所以并不是开的线程越多越好，比如如果机器是4核心的，你开启了100个线程，那么同时执行的只有4个线程，这100个线程会来回切换线程上下文来共享这四个 CPU。&lt;/p&gt;

&lt;h3&gt;三.线程死锁&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;什么是线程死锁呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717161132774-1067772434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，线程 A 已经持有了资源1的同时还想要资源2，线程 B 在持有资源2的时候还想要资源1，所以线程1和线程2就相互等待对方已经持有的资源，就进入了死锁状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么产生死锁的原因都有哪些，学过操作系统的应该都知道死锁的产生必须具备以下四个必要条件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.互斥条件&lt;/strong&gt;：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其它进行请求获取该资源，则请求者只能等待，直至占有资源的线程用毕释放。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.请求并持有条件&lt;/strong&gt;：指一个线程已经持有了至少一个资源，但又提出了新的资源请求，而新资源已被其其它线程占有，所以当前线程会被阻塞，但阻塞的同时并不释放自己已经获取的资源。&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　3.不可剥夺条件&lt;/strong&gt;：指线程获取到的资源在自己使用完之前不能被其它线程抢占，只有在自己使用完毕后由自己释放。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4.环路等待条件&lt;/strong&gt;：指在发生死锁时，必然存在一个线程——资源的环形链，即线程集合{T0，T1，T2，···，Tn}中的 T0 正在等待一个 T1 占用的资源；T1 正在等待 T2 占用的资源，……Tn正在等待已被 T0 占用的资源。&lt;/p&gt;

&lt;p&gt;下面通过一个例子来说明线程死锁，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DeadLockTest1 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建资源&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object resourceA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object resourceB = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程A&lt;/span&gt;
        Thread threadA = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                synchronized (resourceA) {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; get ResourceA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waiting get ResourceB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    synchronized (resourceB) {
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get ResourceB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程B&lt;/span&gt;
        Thread threadB = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                synchronized (resourceB) {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; get ResourceB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waiting get ResourceA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    synchronized (resourceA) {
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get ResourceA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                };
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动线程&lt;/span&gt;
&lt;span&gt;        threadA.start();
        threadB.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717161510784-600410248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面分析下代码和结果，其中 Thread-0 是线程 A，Thread-1 是线程 B，代码首先创建了两个资源，并创建了两个线程。&lt;/p&gt;
&lt;p&gt;从输出结果可以知道线程调度器先调度了线程 A，也就是把 CPU 资源让给了线程 A，线程 A 调用了 getResourceA() 方法，方法里面使用 synchronized(resourceA) 方法获取到了 resourceA 的监视器锁，然后调用 sleep 函数休眠 1s，休眠 1s 是为了保证线程 A 在执行 getResourceB 方法前让线程 B 抢占到 CPU 执行 getResourceB 方法。&lt;/p&gt;
&lt;p&gt;线程 A 调用了 sleep 期间，线程 B 会执行 getResourceB 方法里面的 synchronized(resourceB)，代表线程 B 获取到了 objectB 对象的监视器锁资源，然后调用 sleep 函数休眠 1S。&lt;/p&gt;
&lt;p&gt;好了，到了这里线程 A 获取到了 objectA 的资源，线程 B 获取到了 objectB 的资源。线程 A 休眠结束后会调用 getResouceB 方法企图获取到 ojbectB 的资源，而 ObjectB 资源被线程 B 所持有，所以线程 A 会被阻塞而等待。而同时线程 B 休眠结束后会调用 getResourceA 方法企图获取到 objectA 上的资源，而资源 objectA 已经被线程 A 持有，所以线程 A 和 B 就陷入了相互等待的状态也就产生了死锁。&lt;/p&gt;

&lt;p&gt;下面从产生死锁的四个条件来谈谈本案例如何满足了四个条件。&lt;/p&gt;
&lt;p&gt;首先资源 resourceA 和 resourceB 都是互斥资源，当线程 A 调用 synchronized(resourceA) 获取到 resourceA 上的监视器锁后释放前，线程 B 在调用 synchronized(resourceA) 尝试获取该资源会被阻塞，只有线程 A 主动释放该锁，线程 B 才能获得，这满足了资源互斥条件。&lt;/p&gt;
&lt;p&gt;线程 A 首先通过 synchronized(resourceA) 获取到 resourceA 上的监视器锁资源，然后通过 synchronized(resourceB) 等待获取到 resourceB 上的监视器锁资源，这就构造了持有并等待。&lt;/p&gt;
&lt;p&gt;线程 A 在获取 resourceA 上的监视器锁资源后，不会被线程 B 掠夺走，只有线程 A 自己主动释放 resourceA 的资源时候，才会放弃对该资源的持有权，这构造了资源的不可剥夺条件。&lt;/p&gt;
&lt;p&gt;线程 A 持有 objectA 资源并等待获取 objectB 资源，而线程 B 持有 objectB 资源并等待 objectA 资源，这构成了循环等待条件。&lt;/p&gt;
&lt;p&gt;所以线程 A 和 B 就形成了死锁状态。&lt;/p&gt;
&lt;h4&gt;那么如何避免线程死锁呢？&lt;/h4&gt;
&lt;p&gt;要想避免死锁，需要破坏构造死锁必要条件的至少一个即可，但是学过操作系统童鞋应该都知道目前只有持有并等待和循环等待是可以被破坏的。&lt;/p&gt;
&lt;p&gt;造成死锁的原因其实和申请资源的顺序有很大关系，使用资源申请的有序性原则就可以避免死锁，那么什么是资源的有序性呢，先看一下对上面代码的修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建线程B&lt;/span&gt;
        Thread threadB = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                synchronized (resourceA) {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; get ResourceB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }

                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;waiting get ResourceA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    synchronized (resourceB) {
                        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get ResourceA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                };
            }
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717161716732-795083047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码可知修改了线程 B 中获取资源的顺序和线程 A 中获取资源顺序一致，其实资源分配有序性就是指假如线程 A 和 B 都需要资源1，2，3……n 时候，对资源进行排序，线程 A 和 B 只有在获取到资源 n-1 时候才能去获取资源 n。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：编写并发程序，多个线程进行共享多个资源时候要注意采用资源有序分配法避免死锁的产生。&lt;/p&gt;

&lt;h3&gt;四守护线程与用户线程&lt;/h3&gt;
&lt;p&gt;Java 中线程分为两类，分别为 Daemon 线程（守护线程）和 User 线程（用户线程），在 JVM 启动时候会调用 main 函数，main 函数所在的线程是一个用户线程，这个是我们可以看到的线程，其实 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程（严格说属于 JVM 线程）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么守护线程和用户线程有什么区别呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;区别之一是当最后一个非守护线程结束时候，JVM 会正常退出，而不管当前是否有守护线程；也就是说守护线程是否结束并不影响 JVM 的退出。言外之意是只要有一个用户线程还没结束正常情况下 JVM 就不会退出。&lt;/p&gt;
&lt;p&gt;那么 Java 中如何创建一个守护线程呢？代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        Thread daemonThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为守护线程&lt;/span&gt;
        daemonThread.setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        daemonThread.start();

} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可知只需要设置线程的 daemon 参数为 true 即可。&lt;/p&gt;
&lt;p&gt;下面通过例子来加深用户线程与守护线程的区别的理解，首先看下面代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserThreadTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(;;){}
            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动子线&lt;/span&gt;
&lt;span&gt;        thread.start();

        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main thread is over&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717162105967-744109618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上代码在 main 线程中创建了一个 thread 线程，thread 线程里面是无限循环，运行代码从结果看 main 线程已经运行结束了，那么 JVM 进程已经退出了？从 IDE 的输出结侧上的红色方块说明 JVM 进程并没有退出，另外 Mac 上执行 &lt;code&gt;ps -eaf | grep java&lt;/code&gt; 会输出结果，也可以证明这个结论。&lt;/p&gt;
&lt;p&gt;这个结果说明了当父线程结束后，子线程还是可以继续存在的，也就是子线程的生命周期并不受父线程的影响。也说明了当用户线程还存在的情况下 JVM 进程并不会终止。&lt;/p&gt;
&lt;p&gt;那么我们把上面的 thread 线程设置为守护线程后在运行看看会有什么效果，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/17.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DaemonThreadTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(;;){}
            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为守护线程&lt;/span&gt;
        thread.setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动子线&lt;/span&gt;
&lt;span&gt;        thread.start();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main thread is over&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180717162357032-1173066310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上在启动线程前设置线程为守护线程，从输出结果可知 JVM 进程已经终止了，执行 &lt;code&gt;ps -eaf |grep java&lt;/code&gt; 也看不到 JVM 进程了。这个例子里面 main 函数是唯一的用户线程，thread 线程是守护线程，当 main 线程运行结束后，JVM 发现当前已经没有用户线程了，就会终止 JVM 进程。&lt;/p&gt;
&lt;p&gt;Java 中在 main 线程运行结束后，JVM 会自动启动一个叫做 DestroyJavaVM 线程，该线程会等待所有用户线程结束后终止 JVM 进程。&lt;/p&gt;
&lt;p&gt;下面通过简单的 JVM 代码来证明这个结论，翻开 JVM 的代码，最终会调用到 JavaMain 这个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; JNICALL
JavaMain(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt; _args)
{   
    ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行Java中的main函数 &lt;/span&gt;
    (*env)-&amp;gt;&lt;span&gt;CallStaticVoidMethod(env, mainClass, mainID, mainArgs);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;main函数返回值&lt;/span&gt;
    ret = (*env)-&amp;gt;ExceptionOccurred(env) == NULL ? &lt;span&gt;0&lt;/span&gt; : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待所有非守护线程结束，然后销毁JVM进程&lt;/span&gt;
&lt;span&gt;    LEAVE();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LEAVE 是 C 语言里面的一个宏定义，定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; LEAVE() 
    &lt;span&gt;do&lt;/span&gt;&lt;span&gt; { 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((*vm)-&amp;gt;DetachCurrentThread(vm) !=&lt;span&gt; JNI_OK) { 
            JLI_ReportErrorMessage(JVM_ERROR2); 
            ret &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; 
        } 
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (JNI_TRUE) { 
            (&lt;/span&gt;*vm)-&amp;gt;&lt;span&gt;DestroyJavaVM(vm); 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret; 
        } 
    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (JNI_FALSE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面宏的作用实际是创建了一个名字叫做 DestroyJavaVM 的线程来等待所有用户线程结束。&lt;/p&gt;
&lt;p&gt;在 Tomcat 的 NIO 实现 NioEndpoint 中会开启一组接受线程用来接受用户的链接请求和一组处理线程负责具体处理用户请求，那么这些线程是用户线程还是守护线程呢？下面我们看下 NioEndpoint 的 startInternal 方法，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startInternal() throws Exception {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;running) {
            running &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            paused &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            ...

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建处理线程&lt;/span&gt;
            pollers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Poller[getPollerThreadCount()];
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;pollers.length; i++&lt;span&gt;) {
                pollers[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Poller();
                Thread pollerThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(pollers[i], getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-ClientPoller-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;i);
                pollerThread.setPriority(threadPriority);
                pollerThread.setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明为守护线程&lt;/span&gt;
&lt;span&gt;                pollerThread.start();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动接受线程&lt;/span&gt;
&lt;span&gt;            startAcceptorThreads();
    }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startAcceptorThreads() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; getAcceptorThreadCount();
        acceptors &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Acceptor[count];

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;) {
            acceptors[i] &lt;/span&gt;=&lt;span&gt; createAcceptor();
            String threadName &lt;/span&gt;= getName() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-Acceptor-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i;
            acceptors[i].setThreadName(threadName);
            Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(acceptors[i], threadName);
            t.setPriority(getAcceptorThreadPriority());
            t.setDaemon(getDaemon());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置是否为守护线程，默认为守护线程&lt;/span&gt;
&lt;span&gt;            t.start();
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; boolean daemon = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setDaemon(boolean b) { daemon =&lt;span&gt; b; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; boolean getDaemon() { &lt;span&gt;return&lt;/span&gt; daemon; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码也就是说默认情况下接受线程和处理线程都是守护线程，这意味着当 Tomact 收到 shutdown 命令后 Tomact 进程会马上消亡，而不会等处理线程处理完当前的请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：如果你想在主线程结束后 JVM 进程马上结束，那么创建线程的时候可以设置线程为守护线程，否则如果希望主线程结束后子线程继续工作，等子线程结束后在让 JVM 进程结束那么就设置子线程为用户线程。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 15:25:00 +0000</pubDate>
<dc:creator>狂小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/9324072.html</dc:identifier>
</item>
<item>
<title>吴恩达《深度学习》第四门课（3）目标检测（Object detection） - ysyouaremyall</title>
<link>http://www.cnblogs.com/ys99/p/9326637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ys99/p/9326637.html</guid>
<description>&lt;h2&gt;3.1目标定位&lt;/h2&gt;
&lt;p&gt;（1）案例1：在构建自动驾驶时，需要定位出照片中的行人、汽车、摩托车和背景，即四个类别。可以设置这样的输出，首先第一个元素p&lt;sub&gt;c&lt;/sub&gt;=1表示有要定位的物体，那么用另外四个输出元素表示定位框的中心坐标和宽高，再用3个输出元素one-hot表示是三个类别中的哪一类。当第一个元素p&lt;sub&gt;c&lt;/sub&gt;=0时表示是背景，然后就不需要考虑其他输出了，如下图所示（&lt;strong&gt;需要注意的是是根据图片的标签y来决定使用几个元素的&lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717201605500-1345646596.png&quot; alt=&quot;&quot; width=&quot;539&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）损失函数：上图中左下角是使用了平方误差损失函数这是为了方便解释方便而使用的。实际使用中p&lt;sub&gt;c&lt;/sub&gt;使用逻辑回归，c&lt;sub&gt;1&lt;/sub&gt;,c&lt;sub&gt;2&lt;/sub&gt;,c&lt;sub&gt;3&lt;/sub&gt;是用softmax激活然后然后用对数损失函数，位置信息是使用平方误差损失函数，然后将这些损失函数相加起来得到最终的代价函数。当标签y=0时，只考虑p&lt;sub&gt;c&lt;/sub&gt;即可。&lt;/p&gt;
&lt;h2&gt;3.2特征点检测&lt;/h2&gt;
&lt;p&gt;（1）特征点检测就是第一个单元输出1，表示有这个对象（如人脸），然后如果在人脸上定义了64个特征点（如下图所示），每个特征点用（x,y）表示，那么网络将会有1+2*68=129个单元输出。需要注意的一点是在标注样本时，所有标签在所有图片中务必保持一致，比如说，第5个特征点表示左眼的外眼角，那么所有图片的第五个特征点都应该是这个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717203358791-888805087.png&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.3目标检测&lt;/h2&gt;
&lt;p&gt;（1）案例是检测图片中的汽车，首先是有裁剪合适的照片（裁剪合适是指照片中如果有汽车那么汽车将占满整张图），进行训练一个可以分类汽车的网络，即输出是否有汽车。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717204358475-456221849.png&quot; alt=&quot;&quot; width=&quot;501&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）滑动窗口目标检测是用一个滑动窗口从图片的最左上角从做到右（设定一定步长）从上到下去滑动，分别将窗口内的图片裁剪下来送入到之间训练好的网络中，判断有无汽车，然后改变窗口大小，以及步长等，重复上面步骤，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717204756738-430346787.png&quot; alt=&quot;&quot; width=&quot;593&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717204809273-1527405459.png&quot; alt=&quot;&quot; width=&quot;591&quot; height=&quot;117&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）滑动窗口的问题就是计算量非常的大，因为要保证精确度化不能用太大的步长，这样滑动窗口很多，而且很多地方是属于重复计算了。&lt;/p&gt;
&lt;h2&gt;3.4卷积的滑动窗口实现&lt;/h2&gt;
&lt;p&gt;（1）将全连接层转换为卷积层，如下图所示5*5*16与400个单元进行全连接可以转换为用400个5*5*16的卷积核来卷积5*5*16，这样每一个卷积核其实就相当与都是全连接的结果，唯一的区别就是之前全连接输出是400个单元，现在输出是1*1*400，维度不同，下一层全连接转卷积同样操作，最后一层原来是输出4个单元，现在变成了1*1*4，维度不同，仅此而已。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717211235664-1533712577.png&quot; alt=&quot;&quot; width=&quot;506&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）上一节中一个一个滑动框输入网络中，有许多计算是重叠的，即多次计算，所以可以将原图直接输入到网络中，这样避免了重复计算。之所以将前面的全连接层变成卷积层，是因为只有都是卷积层的时候才可以输入任意尺寸的图片，更具体的说是参数不随图片尺寸变化，而全连接层参数w时固定的意味着图片输入尺寸要固定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717211755244-1659188765.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;216&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）该方法还存在的一个问题就是边界框位置不够准确。&lt;/p&gt;
&lt;h2&gt;3.5Bounding Box预测（YOLO算法）&lt;/h2&gt;
&lt;p&gt;（1）将一张图3*3共9个单元（在论文中是分成19*19，论文默认前提是一个单元里只有一个对象），每个单元都有上面提到的1+4+3=8个输出（还是用上面无人驾驶的例子，3个类别加一个背景）所以整个网络输出为3*3*8。换言之就是输入一张图片，然后网络最终输出的维度为3*3*8，3*3是指有图片分成这么多格子，然后每个格子需要用到8个参数。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717214347020-1339547375.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;376&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）YOLO中将对象（即识别的物体）的中心点落在哪一个网格中就，它就属于哪个网格，一个对象只能属于一个网络，即使这个目标可能横跨了好多个网格。&lt;/p&gt;
&lt;p&gt;（3）b&lt;sub&gt;x&lt;/sub&gt;,b&lt;sub&gt;y&lt;/sub&gt;,b&lt;sub&gt;w&lt;/sub&gt;,b&lt;sub&gt;h&lt;/sub&gt;一种表示方法：将网格（注意不是整张图）的左上角记做（0,0），网格右下角为（1,1），所以bx,by的值都在0到1之间，反证法如果超过1说明它不应该划分到这个网格中。bw,bh也是相对于网格的比例，所以其值可能大于1.如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717215009320-402557521.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.6交并比&lt;/h2&gt;
&lt;p&gt;（1）IoU=（A∩B）/（A∪B），一般将交并比的值大于0.5看成是检测正确的，当然这个值可以根据实际情况来定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717215815060-417923554.png&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;203&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.7非极大值抑制&lt;/h2&gt;
&lt;p&gt;（1）需要理解的一点是，我们做的样本标签中一个对象只会属于一个网格（中心点落在该网格上），但是当我们开始对网络进行预测时，很多网格都会觉得这个对象是属于自己的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717221659125-117097115.png&quot; alt=&quot;&quot; width=&quot;299&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）用只有一个类别（如汽车）来说明非极大值抑制的过程。首先将预测到有汽车的网格中概率小于阈值的都去掉（比如说0.6），然后将剩下预测到有汽车的都进行排序，去其中可能性最大的，它将成为一个预测结果，然后与它的交并比大于某个阈值的都去掉，然后再在剩下中取最大可能性的，重复以上步骤，直到处理完全部。&lt;/p&gt;
&lt;p&gt;如下图所示（下图中的pc其实是之前的pc乘上类别概率c1、c2或c3）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717222501302-1103494451.png&quot; alt=&quot;&quot; width=&quot;565&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）当有多个类别时，按类别分开进行非极大值抑制。&lt;/p&gt;
&lt;h2&gt;3.8Anchor Box&lt;/h2&gt;
&lt;p&gt;（1）上面都是假设一个网格里面只有一个对象，如果有两个对象，如下图所示，人和汽车的中心点几乎重合，这时可以提出一种新概念，即在一个网格框中设置多个不同形状的anchor box,比如说两个，一个瘦高的，一个挨胖的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717224814407-861633352.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）其实实质就是每个网格的第三维度增加输出，把之前的3*3*8变成3*3*16（如下图所示），有时候会变成四个维度如3*3*2*8。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717224435891-993557660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）有一点需要注意的是，在给样本打标签时要做到统一，比如说瘦高型的，那么将对应到前八个输出，如果是矮胖型的对应到后面的八个输出。&lt;/p&gt;
&lt;p&gt;（4）当超过两个对象在同一个网格（其实概率特别小），暂时没有什么好的办法；如果两个对象都是与同一种类型（比如说瘦高型的），也没什么特别好的办法。&lt;/p&gt;
&lt;h2&gt;3.9YOLO算法&lt;/h2&gt;
&lt;p&gt;（1）将上面提到的各个模块组合在一起其实就是YOLO算法了，每个网格多个anchor box，最后再做非极大值抑制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717225956821-219785882.png&quot; alt=&quot;&quot; width=&quot;438&quot; height=&quot;261&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.10候选区域（Region proposals）&lt;/h2&gt;
&lt;p&gt;（1）RCNN：首先使用传统图像分割的方法，对图像进行分割，然后提取出2000个可能有对象的候选框，&lt;strong&gt;这样相对于最开始提到的滑动框的方式减少了非常多的框&lt;/strong&gt;，&lt;strong&gt;其他二者其实是一回事，&lt;/strong&gt;然后送入网络，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717230857216-1636266985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）Fast RCNN：即先将整个图像进行卷积，然后再将候选框映射到卷积之后的输出做分类，其实就是上面提到的卷积整幅图减少重复计算。&lt;/p&gt;
&lt;p&gt;（3）Faster RCNN:由于使用传统的图像分割选出候选框需要非常多的时间，所以使用卷积神经网络来选出候选框。三个算法特点如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201807/1326691-20180717231439439-457032727.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Jul 2018 15:15:00 +0000</pubDate>
<dc:creator>ysyouaremyall</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ys99/p/9326637.html</dc:identifier>
</item>
</channel>
</rss>