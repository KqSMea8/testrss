<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>你在面试时是否无意中暴露了缺点？资深面试官如何从细节中看候选人的软实力 - hsm_computer</title>
<link>http://www.cnblogs.com/JavaArchitect/p/8326003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaArchitect/p/8326003.html</guid>
<description>&lt;p&gt;    面试时，面试官不仅会考察专业技能，更得考察候选人的软实力，比如候选人的沟通能力，以及团队协作能力，更重要的是，得确保候选人不是刺头，能和现有团队和睦相处。如果发现候选人虽然能力很强，但进团队后由于沟通能力差等因素，无法和团队里有效合作，那么这个人同样是无法应聘成功的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226172/201801/1226172-20180121204004646-1430947815.png&quot; alt=&quot;&quot; width=&quot;242&quot; height=&quot;149&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    这方面，有经验的面试人不会直接问，比如不会直接问，你和上个团队相处怎么样？因为候选人总会说好的，至少我面试的候选人都不会自曝其丑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226172/201801/1226172-20180121204842615-1268871568.png&quot; alt=&quot;&quot; width=&quot;240&quot; height=&quot;181&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    但大多数面试官能从候选人的谈吐举动中对候选人的软实力进行打分，这里我就结合最近的一些面试实例来告诉大家衡量的依据，大家也可以据此避免一些可能犯错的地方。&lt;/p&gt;
&lt;p&gt;    或许之前大家在面试时也出现过如下案例中所说的情况，唯一的差别是，别的面试官淘汰你了，但不会和你说原因，你可能也就一直重复这些问题，而我不仅会指出问题，更能给出正确的做法。&lt;/p&gt;
&lt;p&gt;    这里给出的案例完全是对事不对人，并没有任何想要映射到某个具体的人的企图。&lt;/p&gt;

&lt;p&gt;    案例一，在闲聊中无意中露出了自己不稳重。&lt;/p&gt;
&lt;p&gt;    小A来了，我下楼去接他，从见面开始，到进面试方面，小A一直是没话找话，而且说话有些轻浮，不稳重。作为面试官，我只能敷衍他。&lt;/p&gt;
&lt;p&gt;    这类人，如果技术可以，那么什么都好说，但如果出现可上可下的情况，被淘汰的可能性很大，因为大多数公司想找个稳重的职业素养好的候选人。&lt;/p&gt;
&lt;p&gt;    正确的做法是，在面试的过程中，包括从面试官接触开始到被面试官送出门，你可以面露微笑，也可以不是特别严肃，但别嬉皮笑脸，更别没话找话。&lt;/p&gt;

&lt;p&gt;    案例二，没准备好之前公司的离职原因，自曝家丑，兼说如何说离职原因。&lt;/p&gt;
&lt;p&gt;    这个是我听说的一个案例，候选人小B，被问到为什么要离职，从他的回答中，被面试官听出是因为他上份工作没做好，给公司造成损失，所以在上家公司里呆不下去了。&lt;/p&gt;
&lt;p&gt;    我不知道最后的面试结果，但这样一来，我估计除非这个候选人能力特别强，否则很悬。&lt;/p&gt;
&lt;p&gt;    如果大家被问到为什么离职，大家可以从客观情况上找原因，比如要换城市发展，或公司业务方向调整（或干脆关门），总之不是因为大家主观上不稳定，而是客观情况导致不得不换。&lt;/p&gt;
&lt;p&gt;    如果被面试官感觉是你主观上为了追求高工资低压力的工作，虽然这本身不错，但就会重点考察你的稳定性，而且一旦你最近换工作比较频繁，而且没有足够的解释，那么一定会被面试官认为你可能不稳定。&lt;/p&gt;

&lt;p&gt;    案例三，回答问题时，话很多，但没法说到点子上。&lt;/p&gt;
&lt;p&gt;    比如我问，你在数据库层面有过哪些实际的优化经验，同时再强调下，是实际经验，而不是理论经验。&lt;/p&gt;
&lt;p&gt;    这时如果候选人开门见山地说，没项目经验，但看过一些技术文档，随后再说下看到的一些要点，这样最多就是让面试官感觉这部分能力有些欠缺。&lt;/p&gt;
&lt;p&gt;    我们也知道，候选人不可能十全十美，在某个方面没有实际经验，这很正常，更况且有时候我们问的是加分项，比如我们要招个初级程序员，数据库层面的实际优化经验是个加分项，哪怕他说不出什么，也没问题。&lt;/p&gt;
&lt;p&gt;    但这里给大家要强调的是，别为了掩盖自己的某个缺陷，让候选人感觉你表达上有问题，或者谈吐上没逻辑性。&lt;/p&gt;
&lt;p&gt;    还是拿刚才的数据库实际优化经验举例，我见过一些候选人，的确也能说上些要点，但最后都被归结成“理论经验”，而不是“实践经验”。这样，候选人给我的感觉就是没按要求回答，这就涉及到软实力方面的问题了。&lt;/p&gt;
&lt;p&gt;    这里给大家的建议是，遇到没接触过或者不大熟悉的问题，尽量别蒙混过关，毕竟面试官经验比较丰富，能蒙过去的可能性很小。这时或者可以干脆承认没这方面经验，或者可以谈些类似的经验。&lt;/p&gt;

&lt;p&gt;    案例四，回答问题一定得有条理，争取先用最短的话说清楚，然后再展开。&lt;/p&gt;
&lt;p&gt;    比如我给出了一个场景，然后问这样做是否会出问题。这时我希望听到的回答是，候选人先说出结论，然后说出理由。哪怕候选人结论说错，但理由有一定的道理，那么也算过。&lt;/p&gt;
&lt;p&gt;    但有些候选人会啰嗦地说一大堆，在五句话后，我还是无法清晰地听出候选人的结论。这时候选人就不是仅仅暴露出能力方面的问题了，我就会给候选人打上“沟通上有问题”或“表达能力不佳”这类的不好标签。&lt;/p&gt;
&lt;p&gt;    还是这句话，如果候选人在某方面能力不强，这本身问题不大，只要候选人能在其它方面弥补即可，但千万别因此心存侥幸，企图用模棱两可的回答来蒙面试官。&lt;/p&gt;

&lt;p&gt;    案例五，随着我不断深入提问，候选人会逐渐不耐烦。&lt;/p&gt;
&lt;p&gt;    我们知道，跳高比赛中，选手大多会以“无法成功挑战某个高度”而告终，在面试里，面试官也会通过一些超越候选人能力的问题来看候选人对某个知识的掌握深度。&lt;/p&gt;
&lt;p&gt;    比如第一层问题，在Oracle方面，候选人能有哪些调优的经验，这时大多数候选人都能回答出，假设候选人提到了索引。&lt;/p&gt;
&lt;p&gt;    那么在第二层，我就会问索引的应用场景，哪些地方可以用，哪些不能用，大多数候选人也能说上。&lt;/p&gt;
&lt;p&gt;    后面是第三层，问下索引的物理结构，以及Oracle对索引的一些内部优化，这时能说上来的候选人一般都很强。&lt;/p&gt;
&lt;p&gt;    后面还有第四层，如何根据执行计划，查看索引需要被改进，以及如何改进。&lt;/p&gt;
&lt;p&gt;    从上述四层问题里，我们能看到是逐步推进的，对一般的高级开发来说，能说到第三层就不错了，掌握第二层知识点也行。但我就见过一些候选人，因为回答不上，所以东拉西扯，或者顾左右而言他，或者干脆情绪不稳定。&lt;/p&gt;
&lt;p&gt;    这时，我就要怀疑候选人与别人的沟通能力，我可能会担心，万一把他招进来，他在和其它人沟通时，会不会也出现这类沟通不善的情况。一旦让面试官有类似的想法，这对候选人就很不利了。&lt;/p&gt;

&lt;p&gt;   案例六，候选人不擅于表达出自己的想法，或者让人有误解，或者用简单的话来回答问题&lt;/p&gt;
&lt;p&gt;    比如我问ArrayList和LinkedList有什么差别，各自都适用于哪些场景？&lt;/p&gt;
&lt;p&gt;    一些不善沟通的候选人就会只说，一个基于数组，一个基于链表，然后需要我不断提示，再不断深入回答。一个两个问题这样就算了，如果大多数问题都这样，那么候选人就可能会被打上“表达能力欠缺” 的标签了。&lt;/p&gt;
&lt;p&gt;    这里给大家的建议是，首先用适当的语句（当然也不能太多）清晰地回答出问题，然后在面试官许可的情况下，说下这个问题的衍生情况，比如在上述问题里，说出LinkedList是基于双向链表的，同时说出双向链表本身有什么优势。&lt;/p&gt;

&lt;p&gt;   案例七，在面试中，总是想套出面试官对这个问题的答案。&lt;/p&gt;
&lt;p&gt;    比如我问java里final关键字作用在类上是什么含义，这是个比较基础的问题，一般候选人都能回答上。但哪怕回答不上，你也别反复套面试官的话，比如说个回答，问面试官对不对，或者根据面试官的脸部表情反复修正自己的结论。&lt;/p&gt;
&lt;p&gt;    这样会让面试官感觉候选人有些投机取巧，或者至少没主见。还是这句话，会就是会，哪怕不会，也别暴露出自己性格或沟通方面的问题。&lt;/p&gt;

&lt;p&gt;    根据上述的案例，我们来总结下候选人在面试时应当注意的要点。在&lt;span&gt;&lt;a href=&quot;http://www.broadview.com.cn/book/4843&quot;&gt;java web轻量级开发面试教程&lt;/a&gt;里&lt;/span&gt;，我已经有所总结，这里仅仅是展示软实力方面的要点。&lt;/p&gt;
&lt;p&gt;    要点一，一旦你见到面试官，其实面试就已经开始了，你的一举一动都被面试官看在眼里，在这个过程中，你应当展示出自己很稳重，这样就会给人以踏实感。话说回来，面试最长也就一个小时，哪怕装，这应该也不难吧。&lt;/p&gt;
&lt;p&gt;    要点二，你可以回答不出一些问题，但别让面试官感觉你在沟通表达等方面有问题，更别让面试官感觉你无法和团队成员一起协作（比如得控制自己的情绪）。&lt;/p&gt;
&lt;p&gt;    要点三，稳重，沟通表达能力强，协作能力强，这些甚至比专业技能更重要，哪怕你通过了技术面试，如果你在这些方面给面试官留下了好印象，那么有些面试官甚至会帮你多争取工资。&lt;/p&gt;

&lt;p&gt;    最后，我也想不断收集面试的素材，从而提升自己在技术面试官方面的能力，如果大家在这方面有好的经验，或者有类似的素材，也请通过评论等方式来告诉我，谢谢大家。&lt;/p&gt;

</description>
<pubDate>Sun, 21 Jan 2018 15:04:00 +0000</pubDate>
<dc:creator>hsm_computer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JavaArchitect/p/8326003.html</dc:identifier>
</item>
<item>
<title>dubbo源码—Service Invoke - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/8325992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/8325992.html</guid>
<description>&lt;p&gt;dubbo的远程调用过程是怎么样的？&lt;/p&gt;
&lt;p&gt;dubbo远程过程调用经过了那些处理？&lt;/p&gt;
&lt;p&gt;发起远程调用的时候究竟传了什么数据给provider？&lt;/p&gt;
&lt;p&gt;要解决这些问题，欢迎一起探讨走进dubbo源码栏目。&lt;/p&gt;
&lt;p&gt;在service reference中说了consumer端发起调用的时候使用的是远程服务的本地代理，发起调用的堆栈是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/846961/201801/846961-20180121225953021-1100419110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面说过consumer在引用服务的时候最终会生成一个proxy，该proxy是实现了对应的服务接口(比如：com.test.service.TestDubboService)，而且包含一个InvokerInvocationHandler属性，在proxy的服务接口方法中调用InvokerInvocationHandler.invoke&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(Object proxy, Method method, Object[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Throwable {
  String methodName = method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;();
  Class&amp;lt;?&amp;gt;[] parameterTypes = method.&lt;span class=&quot;fu&quot;&gt;getParameterTypes&lt;/span&gt;();
  &lt;span class=&quot;co&quot;&gt;// 判断是否是Object的方法，如果是则直接执行本地调用，不发起远程调用&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (method.&lt;span class=&quot;fu&quot;&gt;getDeclaringClass&lt;/span&gt;() == Object.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; method.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(invoker, args);
  }
  &lt;span class=&quot;co&quot;&gt;// toString、hashCode、equals执行本地调用&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;&quot;toString&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(methodName) &amp;amp;&amp;amp; parameterTypes.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; invoker.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
  }
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;&quot;hashCode&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(methodName) &amp;amp;&amp;amp; parameterTypes.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; invoker.&lt;span class=&quot;fu&quot;&gt;hashCode&lt;/span&gt;();
  }
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;&quot;equals&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(methodName) &amp;amp;&amp;amp; parameterTypes.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; invoker.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(args[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
  }

  &lt;span class=&quot;co&quot;&gt;// RpcInvocation是一个很重要的类，是真正在consumer和provider之间通过网络传输的实体，里面包含了服务调用需要的必要信息&lt;/span&gt;
  RpcInvocation invocation = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RpcInvocation&lt;/span&gt;(method, args);
  Result r = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
  &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
    r = invoker.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(invocation);
    Object o = r.&lt;span class=&quot;fu&quot;&gt;recreate&lt;/span&gt;();
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; o;
  } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable e) {
    &lt;span class=&quot;co&quot;&gt;// ... 省略中间代码&lt;/span&gt;
  }
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; RpcInvocation &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Invocation, Serializable {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; serialVersionUID = -4355285085441097045L;
    &lt;span class=&quot;co&quot;&gt;// 调用的方法全限定名&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String               methodName;
    &lt;span class=&quot;co&quot;&gt;// 方法的参数类型&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Class&amp;lt;?&amp;gt;[]           parameterTypes;
    &lt;span class=&quot;co&quot;&gt;// 入参&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Object[]             arguments;
    &lt;span class=&quot;co&quot;&gt;// 附件，可以传递一些其他信息&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt;  attachments;
    &lt;span class=&quot;co&quot;&gt;// invoker&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; Invoker&amp;lt;?&amp;gt; invoker;
    &lt;span class=&quot;co&quot;&gt;// ... 省略中间代码&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面通过invoke调用发起invoker的调动链，依次调用invoker.invoke方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MockClusterInvoker#invoke&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;invoke方法里面会判断是否配置了mock参数&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果没有配置则直接继续调用invoke&lt;/li&gt;
&lt;li&gt;如果配置的值以force开头，表明直接mock调用&lt;/li&gt;
&lt;li&gt;如果mock配置了但是不以force开头，要先试试正常调用，如果正常调用失败了才会使用mock&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;AbstractClusterInvoker#invoke&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里继续正常情况下的非mock调用。其实上面接下来调用的是FailbackClusterInvoker#invoke，但是FailbackClusterInvoker继承了AbstractClusterInvoker，而且FailbackClusterInvoker没有实现invoke方法，所以直接调用了超类的invoke方法&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;判断当前Invoker是否被销毁，如果销毁直接抛出异常&lt;/li&gt;
&lt;li&gt;然后调用directory.list找出所有的invoker&lt;/li&gt;
&lt;li&gt;通过SPI加载负载均衡的扩展&lt;/li&gt;
&lt;li&gt;调用实现类的doInvoke&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;FailbackClusterInvoker#doInvoke&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个类是负责dubbo调用失败重试的类&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先检查是否有可以调用的invoker&lt;/li&gt;
&lt;li&gt;调用AbstractClusterInvoker.select，通过路由到一个指定invoker&lt;/li&gt;
&lt;li&gt;通过路由到的invoker发起调用&lt;/li&gt;
&lt;li&gt;如果调用抛出异常了，将请求加入失败列表然后定时重试&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面invoker链调动完之后，会调用dubbo的filter链&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// dubbo有一个调用上下文RpcContext，这个filter就是负责往context写信息&lt;/span&gt;
com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;filter&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ConsumerContextFilter&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// dubbo支持事件通知（oninvoke,onreturn,onthrow），通过该filter实现，&lt;/span&gt;
com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;rpc&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;protocol&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;filter&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FutureFilter&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 负责调用过程的监控，调用耗时、并发数等&lt;/span&gt;
com.&lt;span class=&quot;fu&quot;&gt;alibaba&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;dubbo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;monitor&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;support&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;MonitorFilter&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前面部分都是前置处理，开始通过网络向远程发起调用是DubboInvoker.doInvoke方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;29&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; Result &lt;span class=&quot;fu&quot;&gt;doInvoke&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Invocation invocation) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Throwable {
  RpcInvocation inv = (RpcInvocation) invocation;
  &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; String methodName = RpcUtils.&lt;span class=&quot;fu&quot;&gt;getMethodName&lt;/span&gt;(invocation);
  &lt;span class=&quot;co&quot;&gt;// 往invocation的attachments中写入path和version参数&lt;/span&gt;
  inv.&lt;span class=&quot;fu&quot;&gt;setAttachment&lt;/span&gt;(Constants.&lt;span class=&quot;fu&quot;&gt;PATH_KEY&lt;/span&gt;, &lt;span class=&quot;fu&quot;&gt;getUrl&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getPath&lt;/span&gt;());
  inv.&lt;span class=&quot;fu&quot;&gt;setAttachment&lt;/span&gt;(Constants.&lt;span class=&quot;fu&quot;&gt;VERSION_KEY&lt;/span&gt;, version);

  ExchangeClient currentClient;
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (clients.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) {
    currentClient = clients[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;];
  } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
    &lt;span class=&quot;co&quot;&gt;// 因为dubbo支持多个client连接同一个provider，也就是是同一个provider多个连接connections，所以可能是有多个client&lt;/span&gt;
    currentClient = clients[index.&lt;span class=&quot;fu&quot;&gt;getAndIncrement&lt;/span&gt;() % clients.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;];
  }
  &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;co&quot;&gt;// 是否是异步调用，异步调用通过RpcContext.getContext().getFuture().get()来获取结果&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; isAsync = RpcUtils.&lt;span class=&quot;fu&quot;&gt;isAsync&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getUrl&lt;/span&gt;(), invocation);
    &lt;span class=&quot;co&quot;&gt;// Oneway：单向调用，调用方只管发起调用，不需要知道返回值，直接返回&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Twoway：双向调用，调用方发起调用后需要知道返回值，需要返回值的情况又分为同步等待或者是异步通知&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; isOneway = RpcUtils.&lt;span class=&quot;fu&quot;&gt;isOneway&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;getUrl&lt;/span&gt;(), invocation);
    &lt;span class=&quot;co&quot;&gt;// 方法调用的超时时间&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; timeout = &lt;span class=&quot;fu&quot;&gt;getUrl&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getMethodParameter&lt;/span&gt;(methodName, Constants.&lt;span class=&quot;fu&quot;&gt;TIMEOUT_KEY&lt;/span&gt;,Constants.&lt;span class=&quot;fu&quot;&gt;DEFAULT_TIMEOUT&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isOneway) {
      &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; isSent = &lt;span class=&quot;fu&quot;&gt;getUrl&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getMethodParameter&lt;/span&gt;(methodName, Constants.&lt;span class=&quot;fu&quot;&gt;SENT_KEY&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
      currentClient.&lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(inv, isSent);
      RpcContext.&lt;span class=&quot;fu&quot;&gt;getContext&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;setFuture&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
      &lt;span class=&quot;co&quot;&gt;// oneWay只管发送，不关心结果，直接返回&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RpcResult&lt;/span&gt;();
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (isAsync) {
      ResponseFuture future = currentClient.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;(inv, timeout) ;
      &lt;span class=&quot;co&quot;&gt;// 异步调用，直接返回，由future来接收结果，需要结果的时候从future中get&lt;/span&gt;
      RpcContext.&lt;span class=&quot;fu&quot;&gt;getContext&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;setFuture&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; FutureAdapter&amp;lt;Object&amp;gt;(future));
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RpcResult&lt;/span&gt;();
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
      &lt;span class=&quot;co&quot;&gt;// 同步调用&lt;/span&gt;
      RpcContext.&lt;span class=&quot;fu&quot;&gt;getContext&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;setFuture&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
      &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (Result) currentClient.&lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;(inv, timeout).&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;();
    }
  } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (TimeoutException e) {
    &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RpcException&lt;/span&gt;(RpcException.&lt;span class=&quot;fu&quot;&gt;TIMEOUT_EXCEPTION&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Invoke remote method timeout. method: &quot;&lt;/span&gt; + invocation.&lt;span class=&quot;fu&quot;&gt;getMethodName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;, provider: &quot;&lt;/span&gt; + &lt;span class=&quot;fu&quot;&gt;getUrl&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;, cause: &quot;&lt;/span&gt; + e.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;(), e);
  } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (RemotingException e) {
    &lt;span class=&quot;co&quot;&gt;// 这儿的异常是dubbo调用过程中dubbo本身的异常，并不是应用抛出的异常&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RpcException&lt;/span&gt;(RpcException.&lt;span class=&quot;fu&quot;&gt;NETWORK_EXCEPTION&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Failed to invoke remote method: &quot;&lt;/span&gt; + invocation.&lt;span class=&quot;fu&quot;&gt;getMethodName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;, provider: &quot;&lt;/span&gt; + &lt;span class=&quot;fu&quot;&gt;getUrl&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;, cause: &quot;&lt;/span&gt; + e.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;(), e);
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那究竟最后consumer通过网络向provider传输过去的是什东西呢？下面这个方法属于HeaderExchangeChannel类&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ResponseFuture &lt;span class=&quot;fu&quot;&gt;request&lt;/span&gt;(Object request, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; timeout) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; RemotingException {
  &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (closed) {
    &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;RemotingException&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getLocalAddress&lt;/span&gt;(), &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;Failed to send request &quot;&lt;/span&gt; + request + &lt;span class=&quot;st&quot;&gt;&quot;, cause: The channel &quot;&lt;/span&gt; + &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt; + &lt;span class=&quot;st&quot;&gt;&quot; is closed!&quot;&lt;/span&gt;);
  }
  &lt;span class=&quot;co&quot;&gt;// create request.&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 这儿的Request就是consumer发送出去的内容，Request.data就是RpcInvocation，也就是说provider通过netty接收到的对象就是Request&lt;/span&gt;
  Request req = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Request();
  req.&lt;span class=&quot;fu&quot;&gt;setVersion&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2.0.0&quot;&lt;/span&gt;);
  req.&lt;span class=&quot;fu&quot;&gt;setTwoWay&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
  req.&lt;span class=&quot;fu&quot;&gt;setData&lt;/span&gt;(request);
  DefaultFuture future = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DefaultFuture&lt;/span&gt;(channel, req, timeout);
  &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt;{
    &lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
    channel.&lt;span class=&quot;fu&quot;&gt;send&lt;/span&gt;(req);
  }&lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (RemotingException e) {
    future.&lt;span class=&quot;fu&quot;&gt;cancel&lt;/span&gt;();
    &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; e;
  }
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; future;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至于dubbo中的网络层netty这里就不深入介绍了，netty又是一个很强大的框架，以后专门介绍吧。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;至此，前面说的三个问题都解决了。consumer已经向provider发出了请求，接下来就是provider响应请求了。&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jan 2018 15:01:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/8325992.html</dc:identifier>
</item>
<item>
<title>linux下，文件的权限和数字对应关系详解 - 名白</title>
<link>http://www.cnblogs.com/mingbai/p/linuxPermission2Num.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mingbai/p/linuxPermission2Num.html</guid>
<description>&lt;h2 id=&quot;命令&quot;&gt;命令&lt;/h2&gt;
&lt;p&gt;chmod ABC file&lt;/p&gt;
&lt;p&gt;其中A、B、C各为一个数字，分别表示User、Group、及Other的权限。&lt;/p&gt;
&lt;p&gt;A、B、C这三个数字如果各自转换成由“0”、“1”组成的二进制数，则二进制数的每一位分别代表一个角色的读、写、运行的权限。比如User组的权限A：&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;1&lt;/h2&gt;
&lt;p&gt;如果可读、可写、可运行，就表示为二进制的111，转换成十进制就是7。&lt;br/&gt;如果可读、可写、不可运行，就表示为二进制的110，转换成十进制就是6。&lt;br/&gt;如果可读、不可写、可运行，就表示为二进制的101，转换成十进制就是5。&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;2&lt;/h2&gt;
&lt;p&gt;一些人说的“4=r,2=w,1=x”的意思是：&lt;br/&gt;r 代表读，w 代表写，x 代表执行，&lt;br/&gt;如果可读，权限是二进制的100，十进制是4；&lt;br/&gt;如果可写，权限是二进制的010，十进制是2；&lt;br/&gt;如果可运行，权限是二进制的001，十进制是1；&lt;/p&gt;
&lt;h2 id=&quot;section-2&quot;&gt;3&lt;/h2&gt;
&lt;p&gt;具备多个权限，就把相应的 4、2、1 相加就可以了：&lt;br/&gt;若要 rwx 则 4+2+1=7&lt;br/&gt;若要 rw- 则 4+2=6&lt;br/&gt;若要 r-x 则 4+1=5&lt;br/&gt;若要 r-- 则 =4&lt;br/&gt;若要 -wx 则 2+1=3&lt;br/&gt;若要 -w- 则 =2&lt;br/&gt;若要 --x 则 =1&lt;br/&gt;若要 --- 则 =0&lt;/p&gt;
&lt;h2 id=&quot;section-3&quot;&gt;4&lt;/h2&gt;
&lt;p&gt;为不同的角色分配不同的权限，放在一起，就出现 777、677这样的数字了。&lt;/p&gt;
&lt;p&gt;你也可以用 chmod u+x file 的方式为User组添加运行权限。&lt;br/&gt;详细信息，看看 chmod 的帮助吧。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://blog.csdn.net/u013063153/article/details/53113979&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/u013063153/article/details/53113979&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jan 2018 15:01:00 +0000</pubDate>
<dc:creator>名白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mingbai/p/linuxPermission2Num.html</dc:identifier>
</item>
<item>
<title>从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 - 撒网要见鱼</title>
<link>http://www.cnblogs.com/dailc/p/8325991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dailc/p/8325991.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;见解有限，如有描述不当之处，请帮忙及时指出，如有错误，会及时修正。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;----------超长文+多图预警，需要花费不少时间。----------&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果看完本文后，还对进程线程傻傻分不清，不清楚浏览器多进程、浏览器内核多线程、JS单线程、JS运行机制的区别。那么请回复我，一定是我写的还不够清晰，我来改。。。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;----------正文开始----------&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近发现有不少介绍JS单线程运行机制的文章，但是发现很多都仅仅是介绍某一部分的知识，而且各个地方的说法还不统一，容易造成困惑。&lt;br/&gt;因此准备梳理这块知识点，结合已有的认知，基于网上的大量参考资料，&lt;br/&gt;从浏览器多进程到JS单线程，将JS引擎的运行机制系统的梳理一遍。&lt;/p&gt;
&lt;p&gt;展现形式：由于是属于系统梳理型，就没有由浅入深了，而是从头到尾的梳理知识体系，&lt;br/&gt;重点是将关键节点的知识点串联起来，而不是仅仅剖析某一部分知识。&lt;/p&gt;
&lt;p&gt;内容是：从浏览器进程，再到浏览器内核运行，再到JS引擎单线程，再到JS事件循环机制，从头到尾系统的梳理一遍，摆脱碎片化，形成一个知识体系&lt;/p&gt;
&lt;p&gt;目标是：看完这篇文章后，对浏览器多进程，JS单线程，JS事件循环机制这些都能有一定理解，&lt;br/&gt;有一个知识体系骨架，而不是似懂非懂的感觉。&lt;/p&gt;
&lt;p&gt;另外，本文适合有一定经验的前端人员，&lt;strong&gt;新手请规避&lt;/strong&gt;，避免受到过多的概念冲击。可以先存起来，有了一定理解后再看，也可以分成多批次观看，避免过度疲劳。&lt;/p&gt;
&lt;h2 id=&quot;大纲&quot;&gt;大纲&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;区分进程和线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器是多进程的&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;浏览器都包含哪些进程？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;浏览器多进程的优势&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;重点是浏览器内核（渲染进程）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Browser进程和浏览器内核（Renderer进程）的通信过程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;梳理浏览器内核中线程之间的关系&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;简单梳理下浏览器渲染流程&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;load事件与DOMContentLoaded事件的先后&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;css加载是否会阻塞dom树渲染？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;普通图层和复合图层&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从Event Loop谈JS的运行机制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;事件循环进阶：macrotask与microtask&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写在最后的话&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;区分进程和线程&quot;&gt;区分进程和线程&lt;/h2&gt;
&lt;p&gt;线程和进程区分不清，是很多新手都会犯的错误，没有关系。这很正常。先看看下面这个形象的比喻：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 进程是一个工厂，工厂有它的独立资源

&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 工厂之间相互独立

&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 线程是工厂中的工人，多个工人协作完成任务

&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 工厂内有一个或多个工人

&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 工人之间共享空间&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再完善完善概念：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 工厂的资源 &lt;span class=&quot;op&quot;&gt;-&amp;gt;&lt;/span&gt; 系统分配的内存（独立的一块内存）

&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 工厂之间的相互独立 &lt;span class=&quot;op&quot;&gt;-&amp;gt;&lt;/span&gt; 进程之间相互独立

&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 多个工人协作完成任务 &lt;span class=&quot;op&quot;&gt;-&amp;gt;&lt;/span&gt; 多个线程在进程中协作完成任务

&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 工厂内有一个或多个工人 &lt;span class=&quot;op&quot;&gt;-&amp;gt;&lt;/span&gt; 一个进程由一个或多个线程组成

&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 工人之间共享空间 &lt;span class=&quot;op&quot;&gt;-&amp;gt;&lt;/span&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再巩固下：&lt;/p&gt;
&lt;p&gt;如果是windows电脑中，可以打开任务管理器，可以看到有一个后台进程列表。对，那里就是查看进程的地方，而且可以看到每个进程的内存资源信息以及cpu占有率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/process_list.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，应该更容易理解了：&lt;strong&gt;进程是cpu资源分配的最小单位（系统会给它分配内存）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，再用较为官方的术语描述一遍：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;tips&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不同进程之间也可以通信，不过代价较大&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;现在，一般通用的叫法：&lt;strong&gt;单线程与多线程&lt;/strong&gt;，都是指&lt;strong&gt;在一个进程内&lt;/strong&gt;的单和多。（所以核心还是得属于一个进程才行）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;浏览器是多进程的&quot;&gt;浏览器是多进程的&lt;/h2&gt;
&lt;p&gt;理解了进程与线程了区别后，接下来对浏览器进行一定程度上的认识：（先看下简化理解）&lt;/p&gt;
&lt;p&gt;关于以上几点的验证，&lt;strong&gt;请再第一张图&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/process_list2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中打开了&lt;code&gt;Chrome&lt;/code&gt;浏览器的多个标签页，然后可以在&lt;code&gt;Chrome的任务管理器&lt;/code&gt;中看到有多个进程（分别是每一个Tab页面有一个独立的进程，以及一个主进程）。&lt;br/&gt;感兴趣的可以自行尝试下，如果再多打开一个Tab页，进程正常会+1以上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在这里浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了&lt;br/&gt;（所以每一个Tab标签对应一个进程并不一定是绝对的）&lt;/p&gt;
&lt;h3 id=&quot;浏览器都包含哪些进程&quot;&gt;浏览器都包含哪些进程？&lt;/h3&gt;
&lt;p&gt;知道了浏览器是多进程后，再来看看它到底包含哪些进程：（为了简化理解，仅列举主要进程）&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Browser进程：浏览器的主进程（负责协调、主控），只有一个。作用有&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;负责浏览器界面显示，与用户交互。如前进，后退等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;负责各个页面的管理，创建和销毁其他进程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将Renderer进程得到的内存中的Bitmap，绘制到用户界面上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;网络资源的管理，下载等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;GPU进程：最多一个，用于3D绘制等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;浏览器渲染进程（浏览器内核）（Renderer进程，内部是多线程的）：默认每个Tab页面一个进程，互不影响。主要作用为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;页面渲染，脚本执行，事件处理等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;强化记忆：&lt;strong&gt;在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/process_list3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，可以通过Chrome的&lt;code&gt;更多工具 -&amp;gt; 任务管理器&lt;/code&gt;自行验证&lt;/p&gt;
&lt;h3 id=&quot;浏览器多进程的优势&quot;&gt;浏览器多进程的优势&lt;/h3&gt;
&lt;p&gt;相比于单进程浏览器，多进程有如下优点：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;避免单个page crash影响整个浏览器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;避免第三方插件crash影响整个浏览器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;多进程充分利用多核优势&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方便使用沙盒模型隔离插件等进程，提高浏览器稳定性&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单点理解：&lt;strong&gt;如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，内存等资源消耗也会更大，有点空间换时间的意思。&lt;/p&gt;
&lt;h3 id=&quot;重点是浏览器内核渲染进程&quot;&gt;重点是浏览器内核（渲染进程）&lt;/h3&gt;
&lt;p&gt;重点来了，我们可以看到，上面提到了这么多的进程，那么，对于普通的前端操作来说，最终要的是什么呢？答案是&lt;strong&gt;渲染进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以这样理解，页面的渲染，JS的执行，事件的循环，都在这个进程内进行。接下来重点分析这个进程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请牢记，浏览器的渲染进程是多线程的&lt;/strong&gt;（这点如果不理解，&lt;strong&gt;请回头看进程和线程的区分&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;终于到了线程这个概念了😭，好亲切。那么接下来看看它都包含了哪些线程（列举一些主要常驻线程）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;GUI渲染线程&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;注意，&lt;strong&gt;GUI渲染线程与JS引擎线程是互斥的&lt;/strong&gt;，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中&lt;strong&gt;等到JS引擎空闲时&lt;/strong&gt;立即被执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JS引擎线程&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JS引擎线程负责解析Javascript脚本，运行代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;同样注意，&lt;strong&gt;GUI渲染线程与JS引擎线程是互斥的&lt;/strong&gt;，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件触发线程&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定时触发器线程&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;传说中的&lt;code&gt;setInternal&lt;/code&gt;与&lt;code&gt;setTimeout&lt;/code&gt;所在线程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步http请求线程&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在XMLHttpRequest在连接后是通过浏览器新开一个线程请求&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将检测到状态变更时，如果设置有回调函数，异步线程就&lt;strong&gt;产生状态变更事件&lt;/strong&gt;，将这个回调再放入事件队列中。再由JavaScript引擎执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看到这里，如果觉得累了，可以先休息下，这些概念需要被消化，毕竟后续将提到的事件循环机制就是基于&lt;code&gt;事件触发线程&lt;/code&gt;的，所以如果仅仅是看某个碎片化知识，&lt;br/&gt;可能会有一种似懂非懂的感觉。要完成的梳理一遍才能快速沉淀，不易遗忘。放张图巩固下吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/browser_inner_thread.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再说一点，为什么JS引擎是单线程的？额，这个问题其实应该没有标准答案，譬如，可能仅仅是因为由于多线程的复杂性，譬如多线程操作一般要加锁，因此最初设计时选择了单线程。。。&lt;/p&gt;
&lt;h3 id=&quot;browser进程和浏览器内核renderer进程的通信过程&quot;&gt;Browser进程和浏览器内核（Renderer进程）的通信过程&lt;/h3&gt;
&lt;p&gt;看到这里，首先，应该对浏览器内的进程和线程都有一定理解了，那么接下来，再谈谈浏览器的Browser进程（控制进程）是如何和内核通信的，&lt;br/&gt;这点也理解后，就可以将这部分的知识串联起来，从头到尾有一个完整的概念。&lt;/p&gt;
&lt;p&gt;如果自己打开任务管理器，然后打开一个浏览器，就可以看到：&lt;strong&gt;任务管理器中出现了两个进程（一个是主控进程，一个则是打开Tab页的渲染进程）&lt;/strong&gt;，&lt;br/&gt;然后在这前提下，看下整个的过程：(简化了很多)&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Browser进程收到用户请求，首先需要获取页面内容（譬如通过网络下载资源），随后将该任务通过RendererHost接口传递给Render进程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;渲染线程接收请求，加载网页并渲染网页，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当然可能会有JS线程操作DOM（这样可能会造成回流并重绘）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后Render进程将结果传递给Browser进程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Browser进程接收到结果并将结果绘制出来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里绘一张简单的图：（很简化）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/browser_rending_interact.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看完这一整套流程，应该对浏览器的运作有了一定理解了，这样有了知识架构的基础后，后续就方便往上填充内容。&lt;/p&gt;
&lt;p&gt;这块再往深处讲的话就涉及到浏览器内核源码解析了，不属于本文范围。&lt;/p&gt;
&lt;p&gt;如果这一块要深挖，建议去读一些浏览器内核源码解析文章，或者可以先看看参考下来源中的第一篇文章，写的不错&lt;/p&gt;
&lt;h2 id=&quot;梳理浏览器内核中线程之间的关系&quot;&gt;梳理浏览器内核中线程之间的关系&lt;/h2&gt;
&lt;p&gt;到了这里，已经对浏览器的运行有了一个整体的概念，接下来，先简单梳理一些概念&lt;/p&gt;
&lt;h3 id=&quot;gui渲染线程与js引擎线程互斥&quot;&gt;GUI渲染线程与JS引擎线程互斥&lt;/h3&gt;
&lt;p&gt;由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。&lt;/p&gt;
&lt;p&gt;因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，&lt;br/&gt;GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。&lt;/p&gt;
&lt;h3 id=&quot;js阻塞页面加载&quot;&gt;JS阻塞页面加载&lt;/h3&gt;
&lt;p&gt;从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。&lt;/p&gt;
&lt;p&gt;譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。&lt;br/&gt;然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。&lt;/p&gt;
&lt;p&gt;所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。&lt;/p&gt;
&lt;h3 id=&quot;webworkerjs的多线程&quot;&gt;WebWorker，JS的多线程？&lt;/h3&gt;
&lt;p&gt;前文中有提到JS引擎是单线程的，而且JS执行时间过长会阻塞页面，那么JS就真的对cpu密集型计算无能为力么？&lt;/p&gt;
&lt;p&gt;所以，后来HTML5中支持了&lt;code&gt;Web Worker&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;MDN的官方解释是：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面

一个worker是使用一个构造函数创建的一个对象(&lt;span class=&quot;va&quot;&gt;e&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;g&lt;/span&gt;. &lt;span class=&quot;at&quot;&gt;Worker&lt;/span&gt;()) 运行一个命名的JavaScript文件 

这个文件包含将在工作线程中运行的代码&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; workers 运行在另一个全局上下文中&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;不同于当前的window

因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样理解下：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，如果有非常耗时的工作，请单独开一个Worker线程，这样里面不管如何翻天覆地都不会影响JS引擎主线程，&lt;br/&gt;只待计算出结果后，将结果通信给主线程即可，perfect!&lt;/p&gt;
&lt;p&gt;而且注意下，&lt;strong&gt;JS引擎是单线程的&lt;/strong&gt;，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。&lt;/p&gt;
&lt;p&gt;其它，关于Worker的详解就不是本文的范畴了，因此不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;webworker与sharedworker&quot;&gt;WebWorker与SharedWorker&lt;/h3&gt;
&lt;p&gt;既然都到了这里，就再提一下&lt;code&gt;SharedWorker&lt;/code&gt;（避免后续将这两个概念搞混）&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程&lt;/p&gt;
&lt;h2 id=&quot;简单梳理下浏览器渲染流程&quot;&gt;简单梳理下浏览器渲染流程&lt;/h2&gt;
&lt;p&gt;本来是直接计划开始谈JS运行机制的，但想了想，既然上述都一直在谈浏览器，直接跳到JS可能再突兀，因此，中间再补充下浏览器的渲染流程（简单版本）&lt;/p&gt;
&lt;p&gt;为了简化理解，前期工作直接省略成：（要展开的或完全可以写另一篇超长文）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 浏览器输入url，浏览器主进程接管，开一个下载线程，
然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，
随后将内容通过RendererHost接口转交给Renderer进程

&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; 浏览器渲染流程开始&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;
&lt;p&gt;解析html建立dom树&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解析css构建render树（将CSS代码解析成树形的数据结构，然后结合DOM合并成render树）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;布局render树（Layout/reflow），负责各元素尺寸、位置的计算&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;绘制render树（paint），绘制页面像素信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所有详细步骤都已经略去，渲染完毕后就是&lt;code&gt;load&lt;/code&gt;事件了，之后就是自己的JS逻辑处理了&lt;/p&gt;
&lt;p&gt;既然略去了一些详细的步骤，那么就提一些可能需要注意的细节把。&lt;/p&gt;
&lt;h3 id=&quot;load事件与domcontentloaded事件的先后&quot;&gt;load事件与DOMContentLoaded事件的先后&lt;/h3&gt;
&lt;p&gt;上面提到，渲染完毕后会触发&lt;code&gt;load&lt;/code&gt;事件，那么你能分清楚&lt;code&gt;load&lt;/code&gt;事件与&lt;code&gt;DOMContentLoaded&lt;/code&gt;事件的先后么？&lt;/p&gt;
&lt;p&gt;很简单，知道它们的定义就可以了：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。&lt;br/&gt;(譬如如果有async加载的脚本就不一定完成)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。&lt;br/&gt;（渲染完毕了）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，顺序是：&lt;code&gt;DOMContentLoaded -&amp;gt; load&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;css加载是否会阻塞dom树渲染&quot;&gt;css加载是否会阻塞dom树渲染？&lt;/h3&gt;
&lt;p&gt;这里说的是头部引入css的情况&lt;/p&gt;
&lt;p&gt;首先，我们都知道：&lt;strong&gt;css是由单独的下载线程异步下载的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后再说下几个现象：&lt;/p&gt;
&lt;p&gt;这可能也是浏览器的一种优化机制。&lt;/p&gt;
&lt;p&gt;因为你加载css的时候，可能会修改下面DOM节点的样式，&lt;br/&gt;如果css加载不阻塞render树渲染的话，那么当css加载完之后，&lt;br/&gt;render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。&lt;br/&gt;所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，&lt;br/&gt;在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。&lt;/p&gt;
&lt;h3 id=&quot;普通图层和复合图层&quot;&gt;普通图层和复合图层&lt;/h3&gt;
&lt;p&gt;渲染步骤中就提到了&lt;code&gt;composite&lt;/code&gt;概念。&lt;/p&gt;
&lt;p&gt;可以简单的这样理解，浏览器渲染的图层一般包含两大类：&lt;code&gt;普通图层&lt;/code&gt;以及&lt;code&gt;复合图层&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先，普通文档流内可以理解为一个复合图层（这里称为&lt;code&gt;默认复合层&lt;/code&gt;，里面不管添加多少元素，其实都是在同一个复合图层中）&lt;/p&gt;
&lt;p&gt;其次，absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于&lt;code&gt;默认复合层&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后，可以通过&lt;code&gt;硬件加速&lt;/code&gt;的方式，声明一个&lt;code&gt;新的复合图层&lt;/code&gt;，它会单独分配资源&lt;br/&gt;（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响&lt;code&gt;默认复合层&lt;/code&gt;里的回流重绘）&lt;/p&gt;
&lt;p&gt;可以简单理解下：&lt;strong&gt;GPU中，各个复合图层是单独绘制的，所以互不影响&lt;/strong&gt;，这也是为什么某些场景硬件加速效果一级棒&lt;/p&gt;
&lt;p&gt;可以&lt;code&gt;Chrome源码调试 -&amp;gt; More Tools -&amp;gt; Rendering -&amp;gt; Layer borders&lt;/code&gt;中看到，黄色的就是复合图层信息&lt;/p&gt;
&lt;p&gt;如下图。可以验证上述的说法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/css_speedup_layer.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何变成复合图层（硬件加速）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将该元素变成一个复合图层，就是传说中的硬件加速技术&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最常用的方式：&lt;code&gt;translate3d&lt;/code&gt;、&lt;code&gt;translateZ&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;opacity&lt;/code&gt;属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;will-chang&lt;/code&gt;属性（这个比较偏僻），一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），&lt;br/&gt;作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;video&amp;gt;&amp;lt;iframe&amp;gt;&amp;lt;canvas&amp;gt;&amp;lt;webgl&amp;gt;&lt;/code&gt;等元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其它，譬如以前的flash插件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;absolute和硬件加速的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以看到，absolute虽然可以脱离普通文档流，但是无法脱离默认复合层。&lt;br/&gt;所以，就算absolute中信息改变时不会改变普通文档流中render树，&lt;br/&gt;但是，浏览器最终绘制时，是整个复合层绘制的，所以absolute中信息的改变，仍然会影响整个复合层的绘制。&lt;br/&gt;（浏览器会重绘它，如果复合层中内容多，absolute带来的绘制信息变化过大，资源消耗是非常严重的）&lt;/p&gt;
&lt;p&gt;而硬件加速直接就是在另一个复合层了（另起炉灶），所以它的信息改变不会影响默认复合层&lt;br/&gt;（当然了，内部肯定会影响属于自己的复合层），仅仅是引发最后的合成（输出视图）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复合图层的作用？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能&lt;/p&gt;
&lt;p&gt;但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;硬件加速时请使用index&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染&lt;/p&gt;
&lt;p&gt;具体的原理时这样的：&lt;br/&gt;&lt;strong&gt;webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，&lt;br/&gt;那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），&lt;br/&gt;会默认变为复合层渲染，如果处理不当会极大的影响性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单点理解，其实可以认为是一个隐式合成的概念：&lt;strong&gt;如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层&lt;/strong&gt;，这点需要特别注意&lt;/p&gt;
&lt;p&gt;另外，这个问题可以在这个地址看到重现（原作者分析的挺到位的，直接上链接）：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://web.jobbole.com/83575/&quot; class=&quot;uri&quot;&gt;http://web.jobbole.com/83575/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;从event-loop谈js的运行机制&quot;&gt;从Event Loop谈JS的运行机制&lt;/h2&gt;
&lt;p&gt;到此时，已经是属于浏览器页面初次渲染完毕后的事情，JS引擎的一些运行机制分析。&lt;/p&gt;
&lt;p&gt;注意，这里不谈&lt;code&gt;可执行上下文&lt;/code&gt;，&lt;code&gt;VO&lt;/code&gt;，&lt;code&gt;scop chain&lt;/code&gt;等概念（这些完全可以整理成另一篇文章了），这里主要是结合&lt;code&gt;Event Loop&lt;/code&gt;来谈JS代码是如何执行的。&lt;/p&gt;
&lt;p&gt;读这部分的前提是已经知道了JS引擎是单线程，而且这里会用到上文中的几个概念：（如果不是很理解，可以回头温习）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;JS引擎线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事件触发线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定时触发器线程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后再理解一个概念：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JS分为同步任务和异步任务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;同步任务都在主线程上执行，形成一个&lt;code&gt;执行栈&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;主线程之外，&lt;strong&gt;事件触发线程&lt;/strong&gt;管理着一个&lt;code&gt;任务队列&lt;/code&gt;，只要异步任务有了运行结果，就在&lt;code&gt;任务队列&lt;/code&gt;之中放置一个事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一旦&lt;code&gt;执行栈&lt;/code&gt;中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取&lt;code&gt;任务队列&lt;/code&gt;，将可运行的异步任务添加到可执行栈中，开始执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/js_event_loop.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里，应该就可以理解了：为什么有时候setTimeout推入的事件不能准时执行？因为可能在它推入到事件列表时，主线程还不空闲，正在执行其它代码，&lt;br/&gt;所以自然有误差。&lt;/p&gt;
&lt;h3 id=&quot;事件循环机制进一步补充&quot;&gt;事件循环机制进一步补充&lt;/h3&gt;
&lt;p&gt;这里就直接引用一张图片来协助理解：（参考自Philip Roberts的演讲《&lt;a href=&quot;http://vimeo.com/96425312&quot;&gt;Help, I'm stuck in an event-loop&lt;/a&gt;》）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/js_event_loop2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图大致描述就是：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;主线程运行时会产生执行栈，&lt;br/&gt;栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如此循环&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;单独说说定时器&quot;&gt;单独说说定时器&lt;/h3&gt;
&lt;p&gt;上述事件循环机制的核心是：JS引擎线程和事件触发线程&lt;/p&gt;
&lt;p&gt;但事件上，里面还有一些隐藏细节，譬如调用&lt;code&gt;setTimeout&lt;/code&gt;后，是如何等待特定时间后才添加到事件队列中的？&lt;/p&gt;
&lt;p&gt;是JS引擎检测的么？当然不是了。它是由&lt;strong&gt;定时器线程&lt;/strong&gt;控制（因为JS引擎自己都忙不过来，根本无暇分身）&lt;/p&gt;
&lt;p&gt;为什么要单独的定时器线程？因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时。&lt;/p&gt;
&lt;p&gt;什么时候会用到定时器线程？&lt;strong&gt;当使用&lt;code&gt;setTimeout&lt;/code&gt;或&lt;code&gt;setInterval&lt;/code&gt;时&lt;/strong&gt;，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。&lt;/p&gt;
&lt;p&gt;譬如:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'hello!'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码的作用是当&lt;code&gt;1000&lt;/code&gt;毫秒计时完毕后（由定时器线程计时），将回调函数推入事件队列中，等待主线程执行&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'hello!'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'begin'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码的效果是最快的时间内将回调函数推入事件队列中，等待主线程执行&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行结果是：先&lt;code&gt;begin&lt;/code&gt;后&lt;code&gt;hello!&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;虽然代码的本意是0毫秒后就推入事件队列，但是W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。&lt;br/&gt;(不过也有一说是不同浏览器有不同的最小时间设定)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;就算不等待4秒，就算假设0毫秒就推入事件队列，也会先执行&lt;code&gt;begin&lt;/code&gt;（因为只有可执行栈内空了后才会主动读取事件队列）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;settimeout而不是setinterval&quot;&gt;setTimeout而不是setInterval&lt;/h3&gt;
&lt;p&gt;用setTimeout模拟定期计时和直接用setInterval是有区别的。&lt;/p&gt;
&lt;p&gt;因为每次setTimeout计时到后就会去执行，然后执行一段时间后才会继续setTimeout，中间就多了误差&lt;br/&gt;（误差多少与代码执行时间有关）&lt;/p&gt;
&lt;p&gt;而setInterval则是每次都精确的隔一段时间推入一个事件&lt;br/&gt;（但是，事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了）&lt;/p&gt;
&lt;p&gt;而且setInterval有一些比较致命的问题就是：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;累计效应（上面提到的），如果setInterval代码在（setInterval）再次添加到队列之前还没有完成执行，&lt;br/&gt;就会导致定时器代码连续运行好几次，而之间没有间隔。&lt;br/&gt;就算正常间隔执行，多个setInterval的代码执行时间可能会比预期小（因为代码执行需要一定时间）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;譬如像iOS的webview,或者Safari等浏览器中都有一个特点，&lt;strong&gt;在滚动的时候是不执行JS的&lt;/strong&gt;，&lt;br/&gt;如果使用了setInterval，会发现在滚动结束后会执行多次由于滚动不执行JS积攒回调，&lt;br/&gt;如果回调执行时间过长,就会非常容器造成卡顿问题和一些不可知的错误&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;而且把浏览器最小化显示等操作时，setInterval并不是不执行程序，&lt;br/&gt;它会把setInterval的回调函数放在队列中，等浏览器窗口再次打开时，一瞬间全部执行时&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，鉴于这么多但问题，目前一般认为的最佳方案是：&lt;strong&gt;用setTimeout模拟setInterval，或者特殊场合直接用requestAnimationFrame&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;事件循环进阶macrotask与microtask&quot;&gt;事件循环进阶：macrotask与microtask&lt;/h2&gt;
&lt;p&gt;这段参考了参考来源中的第2篇文章（英文版的），（加了下自己的理解重新描述了下），&lt;br/&gt;强烈推荐有英文基础的同学直接观看原文，作者描述的很清晰，示例也很不错，如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&quot; class=&quot;uri&quot;&gt;https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上文中将JS事件循环机制梳理了一遍，在ES5的情况是够用了，但是在ES6盛行的现在，仍然会遇到一些问题，譬如下面这题：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'script start'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'setTimeout'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;resolve&lt;/span&gt;().&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'promise1'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'promise2'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'script end'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嗯哼，它的正确执行顺序是这样子的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;script start
script end
promise1
promise2
setTimeout&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么呢？因为Promise里有了一个一个新的概念：&lt;code&gt;microtask&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;或者，进一步，JS中分为两种任务类型：&lt;strong&gt;&lt;code&gt;macrotask&lt;/code&gt;和&lt;code&gt;microtask&lt;/code&gt;&lt;/strong&gt;，在ECMAScript中，microtask称为&lt;code&gt;jobs&lt;/code&gt;，macrotask可称为&lt;code&gt;task&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它们的定义？区别？简单点可以按如下理解：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每一个task会从头到尾将这个任务执行完毕，不会执行其它&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染&lt;br/&gt;（&lt;code&gt;task-&amp;gt;渲染-&amp;gt;task-&amp;gt;...&lt;/code&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;也就是说，在当前task任务后，下一个task之前，在渲染之前&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分别很么样的场景会形成macrotask和microtask呢？&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;microtask：Promise，process.nextTick等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再根据线程来理解下：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;macrotask中的事件都是放在一个事件队列中的，而这个队列由&lt;strong&gt;事件触发线程&lt;/strong&gt;维护&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由&lt;strong&gt;JS引擎线程维护&lt;/strong&gt;&lt;br/&gt;（这点由自己理解+推测得出，因为它是在主线程下无缝执行的）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，总结下运行机制：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行一个宏任务（栈中没有就从事件队列中获取）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;执行过程中如果遇到微任务，就将它添加到微任务的任务队列中&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dailc.github.io/staticResource/blog/basicKnowledge/singlethreadeventloop/js_macrotask_microtask.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，请注意下&lt;code&gt;Promise&lt;/code&gt;的&lt;code&gt;polyfill&lt;/code&gt;与官方版本的区别：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;官方版本中，是标准的microtask形式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式（目前没见过有能直接模拟microtask，如果确实有，后续会修改这部分）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;请特别注意这两点区别&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了），&lt;br/&gt;但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准）&lt;/p&gt;
&lt;h2 id=&quot;写在最后的话&quot;&gt;写在最后的话&lt;/h2&gt;
&lt;p&gt;看到这里，不知道对JS的运行机制是不是更加理解了，从头到尾梳理，而不是就某一个碎片化知识应该是会更清晰的吧？&lt;/p&gt;
&lt;p&gt;同时，也应该注意到了JS根本就没有想象的那么简单，前端的知识也是无穷无尽，层出不穷的概念、N多易忘的知识点、各式各样的框架、&lt;br/&gt;底层原理方面也是可以无限的往下深挖，然后你就会发现，你知道的太少了。。。&lt;/p&gt;
&lt;p&gt;另外，本文也打算先告一段落，其它的，如JS词法解析，可执行上下文以及VO等概念就不继续在本文中写了，后续可以考虑另开新的文章。&lt;/p&gt;
&lt;p&gt;最后，喜欢的话，就请给个赞吧！&lt;/p&gt;
&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;h3 id=&quot;博客&quot;&gt;博客&lt;/h3&gt;
&lt;p&gt;初次发布&lt;code&gt;2018.01.21&lt;/code&gt;于我个人博客上面&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html&quot; class=&quot;uri&quot;&gt;http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
</description>
<pubDate>Sun, 21 Jan 2018 15:00:00 +0000</pubDate>
<dc:creator>撒网要见鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dailc/p/8325991.html</dc:identifier>
</item>
<item>
<title>KinectFusion解析 - ZonghaoChen</title>
<link>http://www.cnblogs.com/zonghaochen/p/8325905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zonghaochen/p/8325905.html</guid>
<description>&lt;p&gt;  三维重建是指获取真实物体的三维外观形貌，并建立可复用模型的一种技术。它是当下计算机视觉的一个研究热点，主要有三方面的用途：1）相比于二维图像，可以获取更全面的几何信息；2）在VR/AR中，建立真实和虚拟之间的纽带；3）辅助机器人更好的感知世界。传统的三维重建方法主要是SfM（Structure from Motion），通过一系列不同位置采集的图像，离线计算出三维模型。帝国理工和微软研究院在2011年提出的KinectFusion开启了用RGBD相机实时三维重建的序幕。本文主要参考KinectFusion的论文[1-2]，解析它的算法流程。&lt;br/&gt;  KinectFusion由四部分组成（图1）：首先，处理采集到的原始深度图，获取点云voxel的坐标以及法向量坐标；接着，根据当前帧的点云和上一帧预测出的点云计算当前相机的位置姿态；然后，根据相机位置姿态更新TSDF值，融合点云；最后根据TSDF值估计出表面。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; readability=&quot;7&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1107868/201801/1107868-20180121222920584-1587043074.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;/&gt;&lt;br/&gt;图1： KinectFusion整体算法流程。&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;  KinectFusion用一群voxel来描述三维空间。它把固定大小的一个空间（比如&lt;span class=&quot;math inline&quot;&gt;\(3m\times3m\times3m\)&lt;/span&gt;）均匀分割成一个个小方块（比如&lt;span class=&quot;math inline&quot;&gt;\(512\times512\times512\)&lt;/span&gt;），每个小方块就是一个voxel，存储TSDF值以及权重。具体算法如下文所示。

&lt;p&gt;  流程和公式如图2所示。先对原始深度图&lt;span class=&quot;math inline&quot;&gt;\(R_k\)&lt;/span&gt;进行滤波降噪，这里选择双边滤波，目的是保持清晰的边界。一般的滤波是在空间域做加权平均，像素越靠近中心点，权重越高。双边滤波是在空间域加权平均的基础上再对值域加权平均，即像素灰度值越靠近中心像素的灰度值，权重越高。在边界附近，灰度值差异很大，所以虽然边界两边的像素在空间域靠在一起，但是由于灰度值差别非常大，对于互相的权重很低，所以可以保持清晰的边界，如图3所示。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; readability=&quot;7&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1107868/201801/1107868-20180121222943396-1329037724.png&quot; width=&quot;60%&quot; height=&quot;60%&quot;/&gt;&lt;br/&gt;图2：原始数据处理流程。&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;div align=&quot;center&quot; readability=&quot;7&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1107868/201801/1107868-20180121222957193-187410483.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;/&gt;&lt;br/&gt;图3：双边滤波器。&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;  拿到降噪后的深度图&lt;span class=&quot;math inline&quot;&gt;\(D_k\)&lt;/span&gt;之后，再根据相机内参&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;，可以反投影出每个像素点的三维坐标，这就是Vertex map &lt;span class=&quot;math inline&quot;&gt;\(V_k\)&lt;/span&gt;。公式中&lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;是像素坐标，&lt;span class=&quot;math inline&quot;&gt;\(\dot{u}\)&lt;/span&gt;是对应的齐次坐标。每个vertex的法向量可以很方便的通过相邻vertex用叉乘得到。然后对深度图降采样，行数、列数各减一半。降采样使用的是均值降采样，即深度图上四个相邻像素的深度值被平均成一个值。构建三层金字塔的目的是为了从粗到细地计算相机位置姿态，有加速计算的效果。

&lt;p&gt;  相机的位置姿态是用ICP (Iterative Closest Point) 求解的。ICP是处理点云的常规手段，通过最小化两块点云的差别，迭代求解出拍摄两块点云的相机之间的相对位置。有不同的方式来描述点云的差别，最常用的是point-to-point和point-to-plane两种。KinectFusion选择的是point-to-plane的方式，要把点到点的距离向法向量投影，如图4所示。2001年的一篇论文[3]详细比较了point-to-point和point-to-plane的效果，结论是point-to-plane要比point-to-point收敛速度快很多，而且更鲁棒。图5列出了[3]中的Figure15和16，比较了在两种点云形貌的情况下不同ICP的收敛速度和残差。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; readability=&quot;7&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1107868/201801/1107868-20180121223016771-1650719820.png&quot; width=&quot;40%&quot; height=&quot;40%&quot;/&gt;&lt;br/&gt;图4：Point-to-plane ICP.&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;&lt;div align=&quot;center&quot; readability=&quot;7&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1107868/201801/1107868-20180121223031646-1668853674.png&quot; width=&quot;40%&quot; height=&quot;40%&quot;/&gt;&lt;br/&gt;图5：论文[3]中不同ICP的对比。&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;  损失函数的公式中，&lt;span class=&quot;math inline&quot;&gt;\(T_{g,k}\)&lt;/span&gt;是第&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;帧图片时相机在世界坐标系下的位置姿态，这是优化求解的对象。&lt;span class=&quot;math inline&quot;&gt;\(\dot{V}_k(u)\)&lt;/span&gt;是第&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;帧深度图上像素&lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;反投影出的vertex坐标，&lt;span class=&quot;math inline&quot;&gt;\(\hat{u}\)&lt;/span&gt;是这个vertex在第&lt;span class=&quot;math inline&quot;&gt;\(k-1\)&lt;/span&gt;帧图片的投影。为什么这里&lt;span class=&quot;math inline&quot;&gt;\(\hat{V}_{k-1}^{g}\)&lt;/span&gt;有hat上标呢？因为这里的vertex并不是直接在第&lt;span class=&quot;math inline&quot;&gt;\(k-1\)&lt;/span&gt;帧深度图上，而是第&lt;span class=&quot;math inline&quot;&gt;\(k-1\)&lt;/span&gt;帧融合TSDF后的预测值。如果直接用第&lt;span class=&quot;math inline&quot;&gt;\(k-1\)&lt;/span&gt;帧的数据，那这就是frame-to-frame的方式，会带来累计误差。而实际采用的是frame-to-model的方式，误差小很多。为了加速计算，这里利用了三层金字塔，从粗到细计算，最大迭代次数分别是&lt;span class=&quot;math inline&quot;&gt;\([4,5,10]\)&lt;/span&gt;。

&lt;p&gt;  先介绍一个概念SDF(Signed Distance Function)，SDF描述的是点到面的距离，在面上为0，在面的一边为正，另一边为负。TSDF(Truncated SDF)是只考虑面的邻域内的SDF值，邻域的最大值是max truncation的话，则实际距离会除以max truncation这个值，达到归一化的目的，所以TSDF的值在-1到+1之间，如图6所示。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1107868/201801/1107868-20180121223052459-1534928814.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;/&gt;&lt;br/&gt;图6：TSDF的更新。&lt;br/&gt;&lt;/div&gt;
&lt;p&gt;  TSDF的具体算法也在图6中，利用GPU并行处理各个voxel。首先把每个voxel根据计算出的相机位置姿态投影到相机上，如果在相机的视椎内，则会有一个像素点和它对应，&lt;span class=&quot;math inline&quot;&gt;\(D_i(p)\)&lt;/span&gt;是这个像素点距离表面的实际测量值，&lt;span class=&quot;math inline&quot;&gt;\(t_i-v^g\)&lt;/span&gt;则是voxel到相机的距离，两者的差就是SDF值。然后用max truncation归一化得到当前TSDF值。接着，用加权平均的方式更新TSDF值。voxel越正对着相机（如图7所示），越靠近相机，权重越大，用公式表示就是：&lt;span class=&quot;math inline&quot;&gt;\(W(p)\propto cos(\theta)/R_k(u)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt;的像。但论文[1]中也提到把权重全部设为1，对TSDF做简单的平均，也可以取得很好的效果；而如图6算法第12行，设置max weight后，可以去除场景中动态物体的影响（这一点没有特别想明白）。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot; readability=&quot;7&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1107868/201801/1107868-20180121223109912-1397738353.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;/&gt;&lt;br/&gt;图7：TSDF的权重和相机观察方向的关系。&lt;br/&gt;&lt;/div&gt;

&lt;p&gt;  更新完TSDF值之后，就可以用TSDF来估计表面。这样估计出来的表面比直接用RGBD相机得到的深度图有更少的噪音，更少的孔洞（RGBD相机会有一些无效的数据，点云上表现出来的就是黑色的孔洞）。具体的表面估计方法叫Raycasting。这种方法模拟观测位置有一个相机，从每个像素按内参&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;投射出一条射线，射线穿过一个个voxel，在射线击中表面时，必然穿过TSDF值为一正一负的两个紧邻的voxel（因为射线和表面的交点的TSDF值为0），表面就夹在这两个voxel里面。然后可以利用线性插值，根据两个voxel的位置和TSDF值求出精确的交点位置。这些交点的集合就呈现出三维模型的表面。&lt;/p&gt;
&lt;p&gt;参考文献：&lt;br/&gt;[1] Newcombe R A, Izadi S, Hilliges O, et al. KinectFusion: Real-time dense surface mapping and tracking[C]//Mixed and augmented reality (ISMAR), 2011 10th IEEE international symposium on. IEEE, 2011: 127-136.&lt;br/&gt;[2] Izadi S, Kim D, Hilliges O, et al. KinectFusion: real-time 3D reconstruction and interaction using a moving depth camera[C]//Proceedings of the 24th annual ACM symposium on User interface software and technology. ACM, 2011: 559-568.&lt;br/&gt;[3] Rusinkiewicz S, Levoy M. Efficient variants of the ICP algorithm[C]//3-D Digital Imaging and Modeling, 2001. Proceedings. Third International Conference on. IEEE, 2001: 145-152.&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jan 2018 14:32:00 +0000</pubDate>
<dc:creator>ZonghaoChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zonghaochen/p/8325905.html</dc:identifier>
</item>
<item>
<title>Dora.Interception,为.NET Core度身打造的AOP框架：全新的版本 - Artech</title>
<link>http://www.cnblogs.com/artech/p/dora2-01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/dora2-01.html</guid>
<description>&lt;p&gt;Dora.Interception 1.0（Github地址：可以访问GitHub地址：&lt;a href=&quot;https://github.com/jiangjinnan/Dora&quot;&gt;https://github.com/jiangjinnan/Dora&lt;/a&gt;）推出有一段时间了，最近花了点时间将它升级到2.0，主要有如下的改进：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供了原生的动态代理生成底层框架&lt;span&gt;Dora.DynamicProxy&lt;/span&gt;：之前依赖第三方框架Castle实现最底层的代理生成，但是它不支持基于Task的并行编程（也就是说通过它编写的Interceptor无法实现异步执行），所以我采用IL Emit的方式自行实现了这部分的功能，这些底层的功能实现在Dora.DynamicProxy中。&lt;/li&gt;
&lt;li&gt;提供了如下两种形式的拦截方案：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;基于实例封装：如果消费的类型是一个&lt;span&gt;接口&lt;/span&gt;，那么提供的类型为动态生成的代理类，该代理类封装了目标对象。对于每一个动态生成的接口实现成员来说，它会负责执行应用的Interceptor。如果需要调用目标方法，被封装的目标对象的对应方法会被调用。这种拦截方案要求目标类型实现一个接口，接口中定义的&lt;span&gt;所有方法和属性&lt;/span&gt;都是可以被拦截的。&lt;/li&gt;
&lt;li&gt;基于类型继承：如果目标类型是一个&lt;span&gt;非Sealed&lt;/span&gt;类型，一个继承与它的代理类型会被动态生成。如果Interceptor被应用到目标类型的某个虚方法或者属性上，该成员会在生成的代理类中被重写，进而使Interceptor得以执行。这种拦截机制适合非Sealed类型，只有&lt;span&gt;虚方法/属性&lt;/span&gt;能够被拦截。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;提供了针对属性的拦截支持：之前的版本支持针对方法的拦截，最新版本中提供了针对属性的拦截支持。我们可以选择将Interceptor应用到某个类型的属性上，也可以单独应用到该属性的Get或者Set方法上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于Dora.Interception将Dora.DynamicProxy作为默认的动态代理类型生成框架，所以不在依赖任何第三发框架，因此在编程会变得更加简单，现在我们来做一个简单的演示。在安装了最新版本的NuGet包&lt;span&gt;Dora.Interception&lt;/span&gt;之后，我们可以按照 “约定” 的方式来定义如下这么一个简单的Interceptor类型。为了验证针对Task并行编程的支持，我们特意在拦截方法InvokeAsync中Delay了一秒钟。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarInterceptor
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; InterceptDelegate _next;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FoobarInterceptor(InterceptDelegate next)
    {
        _next &lt;/span&gt;=&lt;span&gt; next;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync(InvocationContext context)
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Interception task starts.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Interception task completes.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(context);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我将Interceptor和Interceptor的注册特意区分开来，Interceptor的注册默认采用特性标注的形式来实现，为此我们为上面定义的FoobarInterceptor创建一个对应的特性类型FoobarAttribute。如下面的代码片段所示，FoobarAttribute派生于&lt;span&gt;InterceptorAttribute&lt;/span&gt;，FoobarInterceptor在重写的Use方法中被构建，在构建过程中可以指定该Interceptor在整个Interceptor Chain的位置（Order）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method |&lt;span&gt; AttributeTargets.Property)] 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarAttribute : InterceptorAttribute
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Use(IInterceptorChainBuilder builder)
    {
        builder.Use&lt;/span&gt;&amp;lt;FoobarInterceptor&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Order);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们定义了简单的类型Demo来使用FoobarInterceptor，Demo实现了接口IDemo，FoobarAttribute标注在需要被拦截的方法InvokeAsync上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IDemo
{
    Task InvokeAsync();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo : IDemo
{
    [Foobar]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync()
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Target method is invoked.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于Dora.Interception实现了与.NET Core的Dependency Injection的无缝集成，所以我们只需要采用我们熟悉的方式来提供服务实例就可以了。如下面的代码片段所示，我们将IDemo和Demo之间的映射关系注册到创建的ServiceCollection上之后，并没有调用BuildeServiceProvider方法，而是调用&lt;span&gt;BuildInterceptableServiceProvider&lt;/span&gt;来创建提供服务的ServiceProvider。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; demo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
                .AddSingleton&lt;/span&gt;&amp;lt;IDemo, Demo&amp;gt;&lt;span&gt;() 
                .BuildeInterceptableServiceProvider()
                .GetRequiredService&lt;/span&gt;&amp;lt;IDemo&amp;gt;&lt;span&gt;();  
        demo.InvokeAsync();
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Continue...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Console.Read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下所示的是这段代码的执行结果，我们可以看到应用的FoobarInterceptor被正常执行，而且它完全是以异步的方式执行的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201801/19327-20180121221911943-1345833219.png&quot;&gt;&lt;img width=&quot;329&quot; height=&quot;141&quot; title=&quot;clip_image001&quot; alt=&quot;clip_image001&quot; src=&quot;https://images2017.cnblogs.com/blog/19327/201801/19327-20180121221912209-1150084454.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果Demo没有实现任何的接口，并且它不是一个Sealed类型，它的虚方法和属性也是可以被拦截的。比如我们将Demo做了如下的改动。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo
{
    [Foobar]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Task InvokeAsync()
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Target method is invoked.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有Demo没有了接口实现，所以我们需要对服务注册代码做相应的修改。执行修后的代码，我们依然会得到相同的输出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; demo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
                .AddSingleton&lt;/span&gt;&amp;lt;Demo, Demo&amp;gt;&lt;span&gt;() 
                .BuildeInterceptableServiceProvider()
                .GetRequiredService&lt;/span&gt;&amp;lt;Demo&amp;gt;&lt;span&gt;();  
        demo.InvokeAsync();
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Continue...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Console.Read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于上一版本来说，被拦截的成员仅限于普通的方法，最新的版本增加对属性的支持。如果一个Interceptor被直接应用到某个属性上，它实际上会被同时应用到该属性的Get和Set方法上。比如我们在Demo类型上添加一个Value属性，并在上面标准FoobarAttribute。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo
{
    [Foobar]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Value { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们按照如下的方式获取一个Demo对象，并调用其Value属性的Set和Get方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; demo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceCollection()
                .AddSingleton&lt;/span&gt;&amp;lt;Demo, Demo&amp;gt;&lt;span&gt;()
                .BuildInterceptableServiceProvider()
                .GetRequiredService&lt;/span&gt;&amp;lt;Demo&amp;gt;&lt;span&gt;();
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Set...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        demo.Value &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; demo.Value;
        Console.Read();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从如下的输出结果可以看出，我们注册到Value属性上的FoobarInterceptor在Get和Set方法被调用的时候都执行了一遍。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201801/19327-20180121222832646-1144806125.png&quot;&gt;&lt;img width=&quot;357&quot; height=&quot;174&quot; title=&quot;clip_image002&quot; alt=&quot;clip_image002&quot; src=&quot;https://images2017.cnblogs.com/blog/19327/201801/19327-20180121222832959-76773247.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果我们只需要在某个属性的Get或者Set方法上应用某个Interceptor，我们也可以作针对性的标注。在如下的代码片段中，我们将FoobarAttrbute标准到Get方法上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Value { [Foobar] &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次执行程序，我们会发现FoobarInterceptor仅仅在调用Value属性的Get方法时被执行了一次。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/19327/201801/19327-20180121222833396-1464864267.png&quot;&gt;&lt;img width=&quot;347&quot; height=&quot;169&quot; title=&quot;clip_image003&quot; alt=&quot;clip_image003&quot; src=&quot;https://images2017.cnblogs.com/blog/19327/201801/19327-20180121222833756-153648184.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jan 2018 14:19:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/artech/p/dora2-01.html</dc:identifier>
</item>
<item>
<title>PostgreSQL=&gt;递归查询 - funnyZpC</title>
<link>http://www.cnblogs.com/funnyzpc/p/8232073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/funnyzpc/p/8232073.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PostgreSQL=&amp;gt;递归查询&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;转载请注明源地址：&lt;/strong&gt;&lt;/span&gt;&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 数据库聚合函数与递归函数&quot; href=&quot;http://www.cnblogs.com/funnyzpc/p/8232073.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/funnyzpc/p/8232073.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　距上次博客更新刚好两周，这两周发生了很多，比如：SFTP服务拉取数据，第三方公共平台接口逻辑迁移新框架，新框架(Spring Cloud)上手，公司月报和审计数据获取等等。。。，差不多都有无尽的坑，尤其是最后者，实是折腾人啊&lt;img src=&quot;https://images2017.cnblogs.com/blog/1161789/201801/1161789-20180121214046490-934109345.png&quot; alt=&quot;&quot; width=&quot;39&quot; height=&quot;36&quot;/&gt;&lt;span&gt;~；牢骚归牢骚，但是事情还是要认真做的，。。。，就目前来看，这些对于我最大的好处就是有助于快速理解公司业务逻辑&lt;img src=&quot;https://images2017.cnblogs.com/blog/1161789/201801/1161789-20180121214147021-1900988592.png&quot; alt=&quot;&quot; width=&quot;37&quot; height=&quot;36&quot;/&gt;&lt;span&gt;&lt;span&gt;；啊哈~，扯完，从这些日子开始抽周末时间学习数据库-&amp;gt;&lt;span&gt;PosgreSQL&lt;/span&gt;(个人惯称：大象&lt;img src=&quot;https://images2017.cnblogs.com/blog/1161789/201801/1161789-20180121214216240-1622313421.png&quot; alt=&quot;&quot; width=&quot;39&quot; height=&quot;32&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;),遂从本节起说PostgreSQL有关的动西。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　记得在上一家公司的时候做过一个冷门的附加功能，就是把根据传入的部门ID(一个List)查找部门下所有的人员，当时是Oracle数据库配合着Mybatis来做的，中间填过两个坑，一个是Mybatis的forach的参数个数超过1K会报错，导致递归不能查询，另一个坑是Oracle的递归造型稍难，这个。。。我翻了几篇博客写了好几行注释加以理解，希望后来人能明白前人的良苦用心。&lt;/span&gt;&lt;span&gt;由于新买MBP 未装Oracle环境，oracle的递归讲解就此略过哈(◡‿◡✿)o~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先给出一个测试表(&lt;span&gt;&lt;strong&gt;elevel&lt;/strong&gt;&lt;/span&gt;) 关于&lt;span&gt;职称级别&lt;/span&gt;的表，&lt;span&gt;一位数的ID是最大分类(英语、计算机、会计)，然后子级别的parent_id字段引用父级ID&lt;/span&gt;，有些级别比较笼统这里不讨论哈~：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;testDB=&amp;gt; select * from elevel order by&lt;span class=&quot;Apple-converted-space&quot;&gt;  rpad(id::varchar,5,'0');&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  id&lt;span class=&quot;Apple-converted-space&quot;&gt;  | &lt;span class=&quot;Apple-converted-space&quot;&gt;        name &lt;span class=&quot;Apple-converted-space&quot;&gt;        | parent_id&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;------+----------------------+-----------&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;    1 | 英语 &lt;span class=&quot;Apple-converted-space&quot;&gt;                | &lt;span class=&quot;Apple-converted-space&quot;&gt;         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   11 | 英语专业四八级 &lt;span class=&quot;Apple-converted-space&quot;&gt;      | &lt;span class=&quot;Apple-converted-space&quot;&gt;        1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  111 | 英语专业四级 &lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;        11&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  112 | 英语专业八级 &lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;        11&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   12 | 大学英语三、四、六级 | &lt;span class=&quot;Apple-converted-space&quot;&gt;        1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  121 | 大学英语三级 &lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;        12&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  122 | 大学英语四级 &lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;        12&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  123 | 大学英语六级 &lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;        12&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;    2 | 计算机 &lt;span class=&quot;Apple-converted-space&quot;&gt;              | &lt;span class=&quot;Apple-converted-space&quot;&gt;         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   21 | NCR计算机等级&lt;span class=&quot;Apple-converted-space&quot;&gt;        | &lt;span class=&quot;Apple-converted-space&quot;&gt;        2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  211 | NCR计算机一级&lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;        21&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  212 | NCR计算机二级&lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;        21&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  213 | NCR计算机三级&lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;        21&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  214 | NCR计算机四级&lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;        21&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   22 | IT认证类考试 &lt;span class=&quot;Apple-converted-space&quot;&gt;        | &lt;span class=&quot;Apple-converted-space&quot;&gt;        2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  221 | CISCO认证&lt;span class=&quot;Apple-converted-space&quot;&gt;            |&lt;span class=&quot;Apple-converted-space&quot;&gt;        22&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  222 | ORACLE认证 &lt;span class=&quot;Apple-converted-space&quot;&gt;          |&lt;span class=&quot;Apple-converted-space&quot;&gt;        22&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;    3 | 会计 &lt;span class=&quot;Apple-converted-space&quot;&gt;                | &lt;span class=&quot;Apple-converted-space&quot;&gt;         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   31 | 会计从业证 &lt;span class=&quot;Apple-converted-space&quot;&gt;          | &lt;span class=&quot;Apple-converted-space&quot;&gt;        3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   32 | 会计职称 &lt;span class=&quot;Apple-converted-space&quot;&gt;            | &lt;span class=&quot;Apple-converted-space&quot;&gt;        3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  321 | 初级职称(助理会计师) |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  322 | 中级职称(会计师) &lt;span class=&quot;Apple-converted-space&quot;&gt;    |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  323 | 高级职称(高级职称) &lt;span class=&quot;Apple-converted-space&quot;&gt;  |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 3231 | 正高级会计师 &lt;span class=&quot;Apple-converted-space&quot;&gt;        | &lt;span class=&quot;Apple-converted-space&quot;&gt;      323&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 3232 | 副高级会计师 &lt;span class=&quot;Apple-converted-space&quot;&gt;        | &lt;span class=&quot;Apple-converted-space&quot;&gt;      323&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;(25 rows)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　数据造型已经给出了，这里我放出&lt;span&gt;建表语句及测试数据&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;137&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; create table &lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; elevel
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;(
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;    id          &lt;span&gt;integer&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;    &quot;name&quot;      &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;VARYING&lt;/span&gt; (&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    parent_id   &lt;span&gt;integer&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; insert data&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;英语&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;计算机&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;会计&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;英语专业四八级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;111&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;英语专业四级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;112&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;英语专业八级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;11&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;121&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;大学英语三级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;122&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;大学英语四级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;大学英语三、四、六级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;123&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;大学英语六级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;21&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NCR计算机等级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;22&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;IT认证类考试&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;211&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NCR计算机一级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;212&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NCR计算机二级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;213&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NCR计算机三级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;214&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;NCR计算机四级&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;221&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;CISCO认证&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;222&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ORACLE认证&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;31&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;会计从业证&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;32&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;会计职称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;321&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;初级职称(助理会计师)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;322&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;中级职称(会计师)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;323&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;高级职称(高级职称)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;3231&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;正高级会计师&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;323&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;      &lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; elevel (id, &quot;name&quot;, parent_id) &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;3232&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;副高级会计师&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;323&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;      &lt;span&gt;COMMIT&lt;/span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　现在我定一个需求：&lt;span&gt;查询“会计”(id=3)类别下的所有的子记录（包含id=3的记录）&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;WITH&lt;/span&gt; &lt;strong&gt;&lt;span&gt;RECURSIVE&lt;/span&gt;&lt;/strong&gt; le (id,name,parent_id) &lt;span&gt;as&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;(
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;select&lt;/span&gt; id,name,parent_id &lt;span&gt;from&lt;/span&gt; elevel &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;union&lt;/span&gt; &lt;span&gt;all&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;  &lt;span&gt;select&lt;/span&gt; e2.id,e2.name,e2.parent_id &lt;span&gt;from&lt;/span&gt; elevel e2,le e3 &lt;span&gt;where&lt;/span&gt; e3.id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;e2.parent_id 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; le &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; rpad(id::&lt;span&gt;varchar&lt;/span&gt;,&lt;span&gt;&lt;span&gt;5&lt;/span&gt;,'0'&lt;/span&gt;) &lt;span&gt;asc&lt;/span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查询结果：　&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  id&lt;span class=&quot;Apple-converted-space&quot;&gt;  | &lt;span class=&quot;Apple-converted-space&quot;&gt;        name &lt;span class=&quot;Apple-converted-space&quot;&gt;        | parent_id&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;------+----------------------+-----------&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;    3 | 会计 &lt;span class=&quot;Apple-converted-space&quot;&gt;                | &lt;span class=&quot;Apple-converted-space&quot;&gt;         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   31 | 会计从业证 &lt;span class=&quot;Apple-converted-space&quot;&gt;          | &lt;span class=&quot;Apple-converted-space&quot;&gt;        3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   32 | 会计职称 &lt;span class=&quot;Apple-converted-space&quot;&gt;            | &lt;span class=&quot;Apple-converted-space&quot;&gt;        3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  321 | 初级职称(助理会计师) |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  322 | 中级职称(会计师) &lt;span class=&quot;Apple-converted-space&quot;&gt;    |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  323 | 高级职称(高级职称) &lt;span class=&quot;Apple-converted-space&quot;&gt;  |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 3231 | 正高级会计师 &lt;span class=&quot;Apple-converted-space&quot;&gt;        | &lt;span class=&quot;Apple-converted-space&quot;&gt;      323&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 3232 | 副高级会计师 &lt;span class=&quot;Apple-converted-space&quot;&gt;        | &lt;span class=&quot;Apple-converted-space&quot;&gt;      323&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;(8 rows)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据以上查询结果，这里敲黑板，划重点&lt;img src=&quot;https://images2017.cnblogs.com/blog/1161789/201801/1161789-20180121214606662-2084851189.png&quot; alt=&quot;&quot; width=&quot;36&quot; height=&quot;35&quot;/&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;=&amp;gt;“&lt;strong&gt;RECURSIVE&lt;/strong&gt;” 是PostgreSQL的&lt;strong&gt;关键字&lt;/strong&gt;不是具体存在的表&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　=&amp;gt;第一行中的：&quot;(id,name,parent_id)&quot;定义的是虚拟el表的参数，字段的名称可随意，但字段的个数一定要与3~5行中的查询结果的个数一致！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　=&amp;gt;&quot;el&quot;是声明的虚拟表，每次递归一层后都会将本层数据写入el中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　=&amp;gt;第三行中的id=3是需要查询开始层的ID，关键是第五行=&amp;gt;需要将虚拟表“el&quot;表与“elevel”实体表连表查询&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　=&amp;gt;特别需要注意的是第三行中的中的where条件(e3.id=e2.parent_id) ,取虚拟表的ID和实体表parent_id连&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　这个条件决定了当前递归查询的查询方式(向上查询还是向下查询)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　=&amp;gt;第三行的递归开始查询不可缺少，不然查询报错，个人理解这是PostgreSQL根据首行的记录来递归子记录&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，需要总结的大概就是这些，至于第七行中的&lt;span&gt;rpad函数&lt;/span&gt;是向右补齐的函数，用于排序的需要，读者可以略去order by之后的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好了，一个简单的递归查询就成了，嗯。。。，如需求同学说：&lt;span&gt;我需要将每条记录的递归结构(path)和层级(depath)的顺序都显示出来。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　遗憾的是PG递归查询本身并没有提供相应的函数和关键字来方便我们的需求，怎么办=&amp;gt;加字段：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; RECURSIVE le (id,name,parent_id,&lt;strong&gt;&lt;span&gt;path&lt;/span&gt;&lt;/strong&gt;,&lt;strong&gt;&lt;span&gt;depath&lt;/span&gt;&lt;/strong&gt;) &lt;span&gt;as&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;(
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;select&lt;/span&gt; id,name,parent_id,&lt;span&gt;Array&lt;/span&gt;&lt;span&gt;[id] &lt;/span&gt;&lt;span&gt;as&lt;/span&gt; path,&lt;span&gt;1&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; depath &lt;span&gt;from&lt;/span&gt; elevel &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;  &lt;span&gt;union&lt;/span&gt; &lt;span&gt;all&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;  &lt;span&gt;select&lt;/span&gt; e2.id,e2.name,e2.parent_id,e3.path&lt;span&gt;||&lt;/span&gt;e3.id,e3.depath&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;      &lt;span&gt;from&lt;/span&gt; elevel e2,le e3 &lt;span&gt;where&lt;/span&gt; e3.id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;e2.parent_id 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; le &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; rpad(id::&lt;span&gt;varchar&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;asc&lt;/span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查询结果：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
  id&lt;span class=&quot;Apple-converted-space&quot;&gt;  | &lt;span class=&quot;Apple-converted-space&quot;&gt;        name &lt;span class=&quot;Apple-converted-space&quot;&gt;        | parent_id | &lt;span class=&quot;Apple-converted-space&quot;&gt;    path &lt;span class=&quot;Apple-converted-space&quot;&gt;    | depath&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;------+----------------------+-----------+--------------+--------&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;    3 | 会计 &lt;span class=&quot;Apple-converted-space&quot;&gt;                | &lt;span class=&quot;Apple-converted-space&quot;&gt;          | {3}&lt;span class=&quot;Apple-converted-space&quot;&gt;          |&lt;span class=&quot;Apple-converted-space&quot;&gt;      1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   31 | 会计从业证 &lt;span class=&quot;Apple-converted-space&quot;&gt;          | &lt;span class=&quot;Apple-converted-space&quot;&gt;        3 | {3,3}&lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;      2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   32 | 会计职称 &lt;span class=&quot;Apple-converted-space&quot;&gt;            | &lt;span class=&quot;Apple-converted-space&quot;&gt;        3 | {3,3}&lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;      2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  321 | 初级职称(助理会计师) |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32 | {3,3,32} &lt;span class=&quot;Apple-converted-space&quot;&gt;    |&lt;span class=&quot;Apple-converted-space&quot;&gt;      3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  322 | 中级职称(会计师) &lt;span class=&quot;Apple-converted-space&quot;&gt;    |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32 | {3,3,32} &lt;span class=&quot;Apple-converted-space&quot;&gt;    |&lt;span class=&quot;Apple-converted-space&quot;&gt;      3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  323 | 高级职称(高级职称) &lt;span class=&quot;Apple-converted-space&quot;&gt;  |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32 | {3,3,32} &lt;span class=&quot;Apple-converted-space&quot;&gt;    |&lt;span class=&quot;Apple-converted-space&quot;&gt;      3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 3231 | 正高级会计师 &lt;span class=&quot;Apple-converted-space&quot;&gt;        | &lt;span class=&quot;Apple-converted-space&quot;&gt;      323 | {3,3,32,323} |&lt;span class=&quot;Apple-converted-space&quot;&gt;      4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 3232 | 副高级会计师 &lt;span class=&quot;Apple-converted-space&quot;&gt;        | &lt;span class=&quot;Apple-converted-space&quot;&gt;      323 | {3,3,32,323} |&lt;span class=&quot;Apple-converted-space&quot;&gt;      4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;(8 rows)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　嗯~，可以看到查询SQL与之上的查询&lt;span&gt;不同的是第三行中定义了一个&quot;Array[id]&quot; 的递归结构字段，最为和一个“1” 的深度字段&lt;/span&gt;，Array函数是PostgreSQL特有的数组函数，读者可以自行查阅资料了解哈( ^)o(^ )~。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然以上查询语句满足既已有的需求，想下-&amp;gt;如果这里变我最成最初我做过的那个需求(&lt;span&gt;查询部门下的所有人，不含部门记录&lt;/span&gt;)，该怎么办呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　额~，递归本身提供给我们的结果已经趋于完美了，由于官方api并没有提供进一步的方法，这里只有从查询结果着手解决这个问题囖&lt;img src=&quot;https://images2017.cnblogs.com/blog/1161789/201801/1161789-20180121213539099-2049945656.png&quot; alt=&quot;&quot; width=&quot;37&quot; height=&quot;36&quot;/&gt;&lt;span&gt;~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;with&lt;/span&gt; RECURSIVE le (id,name,parent_id,path,depath) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; 
(
 &lt;/span&gt;&lt;span&gt;select&lt;/span&gt; id,name,parent_id,Array&lt;span&gt;[&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; path,&lt;span&gt;1&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; depath &lt;span&gt;from&lt;/span&gt; elevel &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
 &lt;span&gt;union&lt;/span&gt; &lt;span&gt;all&lt;/span&gt;
 &lt;span&gt;select&lt;/span&gt; e2.id,e2.name,e2.parent_id,e3.path&lt;span&gt;||&lt;/span&gt;e3.id,e3.depath&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; 
     &lt;span&gt;from&lt;/span&gt; elevel e2,le e3 &lt;span&gt;where&lt;/span&gt; e3.id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;e2.parent_id 
)
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; le l &lt;span&gt;where&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;(&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; le &lt;span&gt;where&lt;/span&gt; parent_id&lt;span&gt;=&lt;/span&gt;l.id) &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; rpad(id::&lt;span&gt;varchar&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;asc&lt;/span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查询结果：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  id&lt;span class=&quot;Apple-converted-space&quot;&gt;  | &lt;span class=&quot;Apple-converted-space&quot;&gt;        name &lt;span class=&quot;Apple-converted-space&quot;&gt;        | parent_id | &lt;span class=&quot;Apple-converted-space&quot;&gt;    path &lt;span class=&quot;Apple-converted-space&quot;&gt;    | depath&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;------+----------------------+-----------+--------------+--------&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   31 | 会计从业证 &lt;span class=&quot;Apple-converted-space&quot;&gt;          | &lt;span class=&quot;Apple-converted-space&quot;&gt;        3 | {3,3}&lt;span class=&quot;Apple-converted-space&quot;&gt;        |&lt;span class=&quot;Apple-converted-space&quot;&gt;      2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  321 | 初级职称(助理会计师) |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32 | {3,3,32} &lt;span class=&quot;Apple-converted-space&quot;&gt;    |&lt;span class=&quot;Apple-converted-space&quot;&gt;      3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  322 | 中级职称(会计师) &lt;span class=&quot;Apple-converted-space&quot;&gt;    |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32 | {3,3,32} &lt;span class=&quot;Apple-converted-space&quot;&gt;    |&lt;span class=&quot;Apple-converted-space&quot;&gt;      3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 3231 | 正高级会计师 &lt;span class=&quot;Apple-converted-space&quot;&gt;        | &lt;span class=&quot;Apple-converted-space&quot;&gt;      323 | {3,3,32,323} |&lt;span class=&quot;Apple-converted-space&quot;&gt;      4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 3232 | 副高级会计师 &lt;span class=&quot;Apple-converted-space&quot;&gt;        | &lt;span class=&quot;Apple-converted-space&quot;&gt;      323 | {3,3,32,323} |&lt;span class=&quot;Apple-converted-space&quot;&gt;      4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;(5 rows)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　根据以上查询SQL来看，答案其实很简单，在递归完成后将存在子记录的用where条件过滤掉即可(见查询语句最后一行)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;嗯，以上几个例子全部是向下递归查询，下面我展示下向上查询的语句，很简单=&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;with&lt;/span&gt; RECURSIVE le (id,name,parent_id) &lt;span&gt;as&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt; &lt;span&gt; (
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;select&lt;/span&gt; id,name,parent_id &lt;span&gt;from&lt;/span&gt; elevel &lt;span&gt;where&lt;/span&gt; id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;323&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;union&lt;/span&gt; &lt;span&gt;all&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;   &lt;span&gt;select&lt;/span&gt; e2.id,e2.name,e2.parent_id &lt;span&gt;from&lt;/span&gt; elevel e2,le e3 &lt;span&gt;where&lt;/span&gt; e3.parent_id&lt;span&gt;=&lt;/span&gt;&lt;span&gt;e2.id
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt; )
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;  &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; le &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; rpad(id::&lt;span&gt;varchar&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;asc&lt;/span&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查询结果：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; id&lt;span class=&quot;Apple-converted-space&quot;&gt;  |&lt;span class=&quot;Apple-converted-space&quot;&gt;        name&lt;span class=&quot;Apple-converted-space&quot;&gt;        | parent_id&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;-----+--------------------+-----------&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;   3 | 会计 &lt;span class=&quot;Apple-converted-space&quot;&gt;              | &lt;span class=&quot;Apple-converted-space&quot;&gt;         &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  32 | 会计职称 &lt;span class=&quot;Apple-converted-space&quot;&gt;           | &lt;span class=&quot;Apple-converted-space&quot;&gt;  　    3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 323 | 高级职称(高级职称)   |&lt;span class=&quot;Apple-converted-space&quot;&gt;        32&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到与向上查询的查询语句相差不几，关键，关键是=&amp;gt;&lt;span&gt;第5行的where条件&lt;/span&gt;，很意外吧，如此小的改动就有查询方向上的变化，个人对此的理解是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　=&amp;gt;递归向下查询是用虚拟表的&lt;strong&gt;id&lt;/strong&gt;去联结递归表的&lt;strong&gt;parent_id&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　=&amp;gt;递归向上查询是用虚拟表的&lt;strong&gt;parent_id&lt;/strong&gt;去联结递归表的&lt;strong&gt;id&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本人愚钝，目前对于两者的区别发现仅限于此，欢迎读者点拨哈&lt;img src=&quot;https://images2017.cnblogs.com/blog/1161789/201801/1161789-20180121213738553-1194513540.png&quot; alt=&quot;&quot;/&gt;。。。&lt;img src=&quot;https://images2017.cnblogs.com/blog/1161789/201801/1161789-20180121213808974-113988084.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;span&gt;~&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，需要说明的是，&lt;span&gt;在公司业务满足的情况下尽可能用单层查询语句查询，尤其对于层级较少较固定的结构下较为合适&lt;/span&gt;，此建议主要针对的是递归的两大问题而言：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　1&amp;gt;递归的查询效率较低，尤其是记录较多层级庞大的记录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2&amp;gt;若现有记录的层级如有交叉，极容易导致递归死循环，这点尤其要注意&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK, 本节完成，下节开始讲：“&lt;span&gt;&lt;strong&gt;窗口函数&lt;/strong&gt;&lt;/span&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在是：2018-01-21 21:20:50，愿各位晚安，明天要上班哦~&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jan 2018 13:49:00 +0000</pubDate>
<dc:creator>funnyZpC</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/funnyzpc/p/8232073.html</dc:identifier>
</item>
<item>
<title>游戏服务器设计之任务系统 - 知然</title>
<link>http://www.cnblogs.com/zhiranok/p/8325498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhiranok/p/8325498.html</guid>
<description>&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;任务系统是游戏中最重要的系统之一，本文旨在设计一个轻量清晰的任务系统。通用易扩展是本系统关注的重点。任务系统中当角色的条件满足时，自动触发每一类型的任务，每个任务有其所需的完成条件，当角色完成了指定的操作后，则会触发任务自动完成，任务完成后一般玩家会领取对应的奖励，结束任务，此任务的生命周期结束，如果这个任务有后续任务，那么会自动触发下一个任务，从玩家角度讲，任务是一条故事线，所以经常会说主线、支线任务就是这个原因。&lt;/p&gt;
&lt;h2 id=&quot;设计&quot;&gt;设计&lt;/h2&gt;
&lt;p&gt;当设计任务时有如下几个重点：&lt;/p&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;任务需要以线的方式组织，一般都是在每个任务配置中指定下一个任务的id，每个任务线的第一个和最后一个比较特殊，第一个任务必须在角色属性满足条件下自动获得，而最后一个任务因为是故事线的结尾所以不能触发下一个任务，需要保持任务已结束的状态，如果故事线增加了后续任务，那么任务可以继续往下顺延。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;任务需要满足条件才能接取，所谓的条件一般都是角色属性，比如角色等级。比如等级10级以上的可接取，为了抽象这个需求，任务可接条件设置两个字段角色属性类型和属性值，这个等级的例子就是等级:10。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;任务接取后角色在游戏中做相关的操作，如果跟接取的任务相关，那么任务的进度会自动更新，那么二者是组合产生关联的呢？我们使用事件机制，玩家的游戏行为拆分出一系列的事件类型，用三个字段表示，事件类型，事件对象，事件值，比如打怪，事件类型为击杀怪物，事件对象为树妖，事件值为1。对应的任务完成条件也是这三个配置，不过任务配置中的值为目标值，另外有一种特殊情况比较常见就是状态完成条件，比如某任务需要角色达到100级完成，这个时候就用一个特殊的事件类型，属性表示状态类的完成条件，本例中配置就应该为属性:等级:100。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;任务完成后需要触发下一个任务，但是如果下一个任务条件不满足，那么也不允许获得该任务，待角色属性成长后满足了条件再自动获得。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;任务配置除了支持以上说的参数外，需要流出一些可扩展参数，比如任务奖励，任务绑定的npc，任务接、交过程中的对白、过场动画等。任务系统使用csv做配置，增加配置只需要增加字段就可以了，每个任务有map类型的参数字段保留了所有扩展配置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;任务操作的时序图&quot;&gt;任务操作的时序图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/282357/201801/282357-20180121212328428-1258696213.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;任务操作的状态图&quot;&gt;任务操作的状态图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/282357/201801/282357-20180121212352959-493188686.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;系统中大量使用了事件机制，增加了易用性和可扩展性。角色上线载入数据，使用事件机制，避免了与数据库模块产生耦合，同时也很好的支持了异步和同步模式。&lt;/li&gt;
&lt;li&gt;任务系统与客户端的协议细节没有做实现，这个使用者在确定的事件下hook到然后通知客户端即可，完全不需要修改任务系统。&lt;/li&gt;
&lt;li&gt;任务系统的接口都已适配到脚本层，利用h2engine 的通用脚本层，无论是Python，lua，js，php都可以使用相同的接口调用任务系统。&lt;/li&gt;
&lt;li&gt;GitHub地址: &lt;a href=&quot;https://github.com/fanchy/h2engine&quot; class=&quot;uri&quot;&gt;https://github.com/fanchy/h2engine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;关于任务系统使用的属性管理器：&lt;a href=&quot;http://www.cnblogs.com/zhiranok/p/h2engine_propmgr.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/zhiranok/p/h2engine_propmgr.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;关于游戏服务器引擎h2engine：&lt;a href=&quot;http://www.cnblogs.com/zhiranok/p/ffengine.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/zhiranok/p/ffengine.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sun, 21 Jan 2018 13:35:00 +0000</pubDate>
<dc:creator>知然</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhiranok/p/8325498.html</dc:identifier>
</item>
<item>
<title>【Html5】-- 塔台管制 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/8325317.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/8325317.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/417688/201801/417688-20180121202457584-1388303579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 想做这个游戏已久，今天终于初步完成，先解释下，这是一个模拟机场塔台管制指挥的游戏，飞机从不同的方向飞入管制空域，有不同的目的地，飞机名称最后一个字母表示飞机要到达的目的地，分ABCD和R。A-D表示四个方向，R表示到本场的跑道降落。飞机有H,M,S三种速度，离场必须不能是最快的速度(H)，降落必须是S的速度这样才能得分。默认设置是20架飞机，最多容量默认是10架飞机。当然实际的指挥比这个要复杂。&lt;/p&gt;
&lt;h2&gt;基本原理&lt;/h2&gt;
&lt;p&gt;整个游戏是基于canvas的，纯JavaScript，四种朝向的飞机是用四张图片实现的，所有要不断渲染的对象都在airspace这个数组里面。有Plane，Runway和Exit三个对象。正确指挥一架飞机到目的地有5分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Plane(id,sx,sy,heading,url){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x=&lt;span&gt;sx;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y=&lt;span&gt;sy;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.flightId=&lt;span&gt;id;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.h=heading||&quot;down&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;up down left right&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.img=url||&quot;down.png&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.draw=&lt;span&gt;drawPlane
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.move=&lt;span&gt;movePlane
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.speed=airspeed[getRandom(3&lt;span&gt;)];
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.D=destination[getRandom(5&lt;span&gt;)];
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state=&quot;cruise&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width=&lt;span&gt;size;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height=&lt;span&gt;size;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getCenter=&lt;span&gt;getCenter;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Runway(name,x,y,w,h){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt;name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x=&lt;span&gt;y;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y=&lt;span&gt;y;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width=&lt;span&gt;w;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height=&lt;span&gt;h;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.draw=&lt;span&gt;drawRunway;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getCenter=&lt;span&gt;getCenter;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;点击捕获&lt;/h3&gt;
&lt;p&gt;到canvas上选中一架飞机之后会用红色边框，表示当前正在指挥的飞机。canvas本身没有提供对象的click事件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/417688/201801/417688-20180121205021224-1238995245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 所以要根据鼠标的位置来判断是否选中了目标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; eventDispature(canvas){
  canvas.onclick&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
     console.log(e.offsetX,e.offsetY,e.type)
     detectEvent(e.offsetX,e.offsetY,e.type)
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; detectEvent(x,y,type){
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否击中&lt;/span&gt;
  airspace.forEach(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(p){
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;范围 x,x+size y,y+size&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt; maX=p.x+&lt;span&gt;p.width;
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; maY=p.y+&lt;span&gt;p.height;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x&amp;gt;=p.x&amp;amp;&amp;amp;x&amp;lt;=maX&amp;amp;&amp;amp;y&amp;gt;=p.y&amp;amp;&amp;amp;y&amp;lt;=&lt;span&gt;maY){
          p.selected&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
          taget&lt;/span&gt;=&lt;span&gt;p;
          console.log(&lt;/span&gt;&quot;选中&quot;&lt;span&gt;,p.flightId,p.x,p.y)
          airspace.filter(n&lt;/span&gt;=&amp;gt;n.flightId!=p.flightId).forEach(n=&amp;gt;n.selected=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
      }
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据e.offsetX和e.offsetY获得事件的位置，判断是否在某个飞机的坐标范围里，然后标记选中，并去除其他被标记selected的飞机。当然这个地方还可以完善成一个事件系统，并支持其他的事件。&lt;/p&gt;
&lt;h3&gt;碰撞检测&lt;/h3&gt;
&lt;p&gt;碰撞有四种情况，首先是飞机与飞机相撞，飞机飞出边界（是否正确飞向入口），飞机飞入跑道(是否对准入口进入)。错误操作的飞机将会被移除airspace数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; isIntersect(p1,p2){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; center=&lt;span&gt;p1.getCenter();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c1=&lt;span&gt;p2.getCenter();
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dx=Math.abs(center.x-&lt;span&gt;c1.x);
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dy=Math.abs(center.y-&lt;span&gt;c1.y);
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; dx&amp;lt;(p1.width/2+p2.width/2)&amp;amp;&amp;amp;dy&amp;lt;(p1.height/2+p2.height/2&lt;span&gt;)
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三种情况的判断主要依靠上面这个方法，然后再有区分，飞机飞入跑道，首先是坐标矩形会与跑道矩形相交，然后y1，y2在跑道的y轴范围之内即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/417688/201801/417688-20180121210451396-1935712279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(isIntersect(plane,runway)&amp;amp;&amp;amp;plane.state==&lt;span&gt;states.cruise){
    console.warn(plane.flightId&lt;/span&gt;+&quot;进入跑道&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入跑道的条件是 左边的两个点 和右边的两个点&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; y1=&lt;span&gt;plane.y;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; y2=plane.y+&lt;span&gt;plane.height;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;速度最慢，方向是跑道才能得分&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(y1&amp;gt;runway.y&amp;amp;&amp;amp;y1&amp;lt;runway.y+runway.height&amp;amp;&amp;amp;y2&amp;gt;runway.y&amp;amp;&amp;amp;y2&amp;lt;runway.y+&lt;span&gt;runway.height
      &lt;/span&gt;&amp;amp;&amp;amp;plane.D==destination[4]&amp;amp;&amp;amp;plane.speed==airspeed[2&lt;span&gt;])
        {
        plane.state&lt;/span&gt;=&lt;span&gt;states.landing;
        score&lt;/span&gt;+=5&lt;span&gt;;
        info(plane.flightId&lt;/span&gt;+&quot;正确降落跑道&quot;&lt;span&gt;);
        showPlaneNum();
        plane.state&lt;/span&gt;=&lt;span&gt;states.stop;
        removePlane(plane.flightId);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        plane.state&lt;/span&gt;=&lt;span&gt;states.crash;
        info(plane.flightId&lt;/span&gt;+&quot;坠毁，航向&quot;+plane.h+&quot;,速度&quot;+&lt;span&gt;plane.speed);
        removePlane(plane.flightId);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;判断进入入口的道理一样。右下角几个按钮分别表示四个方向和三种速度。&lt;/p&gt;
&lt;h3&gt;不足：&lt;/h3&gt;
&lt;p&gt;1.飞机用了四张图片还是有点笨，因为当初旋转移动没有搞定，后续继续研究。&lt;/p&gt;
&lt;p&gt;2.飞机碰撞的算法还不够准确，离场的判断只判断了一个点。这里是考虑到离场判断和入场飞机有冲突，这里需要再优化下。&lt;/p&gt;
&lt;p&gt;3.还可以增加一些效果。&lt;/p&gt;
&lt;p&gt;PS：这其实是当时入学时一个测试程序，当时就记住了，今天用前端实现一回。来玩一玩吧，喜欢就给个赞，欢迎拍砖。&lt;/p&gt;
&lt;p&gt;git：&lt;a href=&quot;https://github.com/stoneniqiu/ATC&quot; target=&quot;_blank&quot;&gt;https://github.com/stoneniqiu/ATC&lt;/a&gt; &lt;/p&gt;
</description>
<pubDate>Sun, 21 Jan 2018 13:22:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/8325317.html</dc:identifier>
</item>
<item>
<title>Generator函数语法解析 - unclekeith</title>
<link>http://www.cnblogs.com/unclekeith/p/8325465.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/unclekeith/p/8325465.html</guid>
<description>&lt;p&gt;转载请注明出处: &lt;a href=&quot;http://www.cnblogs.com/unclekeith/p/8325465.html&quot;&gt;Generator函数语法解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Generator函数是ES6提供的一种异步编程解决方案，语法与传统函数完全不同。以下会介绍一下Generator函数。&lt;/p&gt;
&lt;p&gt;写下这篇文章的目的其实很简单，是想梳理一下自己对于Generator的理解，同时呢，为学习async函数做一下知识储备。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;generator函数&quot;&gt;Generator函数&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;基本概念&lt;/li&gt;
&lt;li&gt;yield表达式&lt;/li&gt;
&lt;li&gt;next方法&lt;/li&gt;
&lt;li&gt;next方法的参数&lt;/li&gt;
&lt;li&gt;yield*表达式&lt;/li&gt;
&lt;li&gt;与Iterator接口的关系&lt;/li&gt;
&lt;li&gt;for...of循环&lt;/li&gt;
&lt;li&gt;作为对象属性的Generator函数&lt;/li&gt;
&lt;li&gt;Generator函数中的this&lt;/li&gt;
&lt;li&gt;应用&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;
&lt;p&gt;对于Generator函数(也可以叫做生成器函数)的理解，可以从四个方面：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;形式上：&lt;/strong&gt;Generator函数是一个普通的函数，不过相对于普通函数多出了两个特征。一是在function关键字和函数明之间多了'*'号；二是函数内部使用了yield表达式，用于定义Generator函数中的每个状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法上：&lt;/strong&gt;Generator函数封装了多个内部状态(通过yield表达式定义内部状态)。执行Generator函数时会返回一个遍历器对象(Iterator对象)。也就是说，Generator是遍历器对象生成函数，函数内部封装了多个状态。通过返回的Iterator对象，可以依次遍历(调用next方法)Generator函数的每个内部状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用上：&lt;/strong&gt;普通函数在调用之后会立即执行，而Generator函数调用之后不会立即执行，而是会返回遍历器对象(Iterator对象)。通过Iterator对象的next方法来遍历内部yield表达式定义的每一个状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写法上：&lt;/strong&gt;*号放在哪里好像都可以也。看个人习惯吧，我喜欢第一种写法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *gen () {}   √
function* gen () {}
function * gen () {}
function*gen () {}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;yield表达式&quot;&gt;yield表达式&lt;/h3&gt;
&lt;p&gt;yield，英文意思即产生、退让的意思，因此yield表达式也有两种作用：&lt;strong&gt;定义内部状态&lt;/strong&gt;和&lt;strong&gt;暂停执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;举一个栗子吧: )&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *gen () {
  yield 1
  yield 2
  return 3
}

const g = gen()   // Iterator对象
g.next() // {value: 1, done: false}
g.next() // {value: 2, done: false}
g.next() // {value: 3, done: true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码中可以看出，gen函数使用yield表达式定义了两个内部状态。同时呢，也可以看出来，return语句只能有一个，而yield表达式却可以有多个。&lt;/p&gt;
&lt;p&gt;执行gen函数之后，会返回一个遍历器对象，而不是立即执行gen函数。如果需要获取yield表达式定义的每个状态，需要调用next方法。&lt;/p&gt;
&lt;p&gt;每调用一次next方法都会返回一个包含value和done属性的对象，此时会停留在某个yield表达式结尾处。value属性值即是yield表达式的值；done属性是布尔值，表示是否遍历完毕。&lt;/p&gt;
&lt;p&gt;另外呢，yield表达式没有返回值，或者说返回值是undefined。待会会说明一下如何给yield表达式传递返回值。&lt;/p&gt;
&lt;p&gt;需要注意的是，yield表达式的值，只有调用next方法时才能获取到。因此等于为JavaScript提供了手动的'惰性求值'(Lazy Evaluation)的功能。&lt;/p&gt;
&lt;p&gt;一般情况下，Generator函数会结合yield表达式使用，通过yield表达式定义多个内部状态。但是，如果不使用yield表达式的Generator函数就成为了一个单纯的暂缓执行函数，个人感觉没什么意义...&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *gen () {
  console.log('凯斯')
}

window.setTimeout(() =&amp;gt; {
  gen().next()
}, 2000)

// 不使用yield表达式来暂停函数的执行，还不如使用普通函数呢..
// 所以Generator函数配合yield表达式使用效果更佳&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，yield表达式如果用在另一个表达式中，需要为其加上圆括号。作为函数参数和语句是可以不使用圆括号。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *gen () {
  console.log('hello' + yield) ×
  console.log('hello' + (yield)) √
  console.log('hello' + yield '凯斯') ×
  console.log('hello' + (yield '凯斯')) √
  foo(yield 1)  √
  const param = yield 2  √
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;next方法&quot;&gt;next方法&lt;/h3&gt;
&lt;p&gt;yield表达式具有暂停执行的功能，而恢复执行的是next方法。每一次调用next方法，就会从函数头部或者上一次停下来的地方开始执行，直到遇到下一个yield表达式(return 语句)为止。同时，调用next方法时，会返回包含value和done属性的对象，value属性值可以为yield表达式、return语句后面的值或者undefined值，done属性表示遍历是否结束。&lt;/p&gt;
&lt;p&gt;遍历器对象的next方法(从Generator函数继承而来)的运行逻辑如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield表达式后面的那个表达式的值，作为返回的对象的value属性值。&lt;/li&gt;
&lt;li&gt;下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。&lt;/li&gt;
&lt;li&gt;如果没有再遇到新的yield表达式，就一直运行到函数结束，直到遇到return语句为止，并将return语句后面表达式的值，作为返回的对象的value属性值。&lt;/li&gt;
&lt;li&gt;如果该函数没有return语句，则返回的对象的value属性值为undefined。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上面的运行逻辑可以看出，返回的对象的value属性值有三种结果：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;yield表达式后面的值&lt;/li&gt;
&lt;li&gt;return语句后面的值&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;也就是说，如果有yield表达式，则value属性值就是yield表达式后面的指；如果没有yield表达式，value属性值就等于return语句后面的值；如果yield表达式和return语句都不存在的话，则value属性值就等于undefined。举个例子: )&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *gen () {
  yield 1
  yield 2
  return 3
}

const g = gen()
g.next() // {value: 1, done: false}
g.next() // {value: 2, done: false}
g.next() // {value: 3, done: true}
g.next() // {value: undefined, done: true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据next运行逻辑再针对这个例子，就很容易理解了。调用gen函数，返回遍历器对象。&lt;/p&gt;
&lt;p&gt;第一次调用next方法时，在遇到第一个yield表达式时停止执行，value属性值为1，即yield表达式后面的值，done为false表示遍历没有结束；&lt;/p&gt;
&lt;p&gt;第二次调用next方法时，从暂停的yield表达式后开始执行，直到遇到下一个yield表达式后暂停执行，value属性值为2，done为false；&lt;/p&gt;
&lt;p&gt;第三次调用next方法时，从上一次暂停的yield表达式后开始执行，由于后面没有yield表达式了，所以遇到return语句时函数执行结束，value属性值为return语句后面的值，done属性值为true表示已经遍历完毕了。&lt;/p&gt;
&lt;p&gt;第四次调用next方法时，value属性值就是undefined了，此时done属性为true表示遍历完毕。以后再调用next方法都会是这两个值。&lt;/p&gt;
&lt;h3 id=&quot;next方法的参数&quot;&gt;next方法的参数&lt;/h3&gt;
&lt;p&gt;yield表达式本身没有返回值，或者说总是返回undefined。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *gen () {
  var x = yield 'hello world'
  var y = x / 2
  return [x, y]
}
const g = gen()
g.next()    // {value: 'hello world', done: false}
g.next()    // {value: [undefined, NaN], done: true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码可以看出，第一次调用next方法时，value属性值是'hello world'，第二次调用时，由于变量y的值依赖于变量x，而yield表达式没有返回值，所以返回了undefined给变量x，此时undefined / 2为NaN。&lt;/p&gt;
&lt;p&gt;要解决上面的问题，可以给next方法传递参数。&lt;strong&gt;next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *gen () {
  var x = yield 'hello world'
  var y = x / 2
  return [x, y]
}
const g = gen()
g.next()    // {value: 'hello world', done: false}
g.next(10)    // {value: [10, 5], done: true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当给第二个next方法传递参数10时，yield表达式的返回值为10，即&lt;code&gt;var x = 10&lt;/code&gt;，所以此时变量y为5。&lt;/p&gt;
&lt;p&gt;注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8引擎直接忽略第一次使用next方法的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上说，第一个next方法用来启动遍历器对象，所以不用带上参数。所以呢，每次使用next方法会比yield表达式要多一次。&lt;/p&gt;
&lt;p&gt;如果想要第一次调用next方法时就可以传递参数，可以使用闭包的方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 实际上就是在闭包内部执行了一次next方法
function wrapper (gen) {
  return function (...args) {
    const genObj = gen(...args)
    genObj.next()
    return genObj
  }
}
const generator = wrapper(function *generator () {
  console.log(`hello ${yield}`)
  return 'done'
})
const a = generator().next('keith')
console.log(a)   // hello keith, done&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;yield表达式-如果在generator函数中调用另一个generator函数默认情况下是无效的&quot;&gt;yield*表达式&lt;br/&gt;如果在Generator函数中调用另一个Generator函数，默认情况下是无效的。&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;function *foo () {
  yield 1
}
function *gen () {
  foo()
  yield 2
}
const g = gen()
g.next()  // {value: 2, done: false}
g.next()  // {value: undefined, done: true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码中可以看出，并没有在&lt;code&gt;yield 1&lt;/code&gt;处停止执行。此时就需要使用yield* 表达式。从语法角度上说，如果yield表达式后面跟着遍历器对象，需要在yield表达式后面加上星号，表明它返回的是一个遍历器对象。实际上，yield*表达式是for...of循环的简写，完全可以使用for...of循环来代替yield*表达式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *foo () {
  yield 1
}
function *gen () {
  yield* foo()
  yield 2
}
const g = gen()
g.next()   // {value: 1, done: false}
g.next()   // {value: 2, done: false}
g.next()   // {value: undefined, done: true}

// 相当于
function *gen () {
  yield 1
  yield 2
}

// 相当于
function *gen () {
  for (let item of foo()) {
    yield item
  }
  yield 2
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果直接使用了&lt;code&gt;yield foo()&lt;/code&gt;，返回的对象的value属性值为一个遍历器对象。而不是Generator函数的内部状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *foo () {
  yield 1
}
function *gen () {
  yield foo()
  yield 2
}
const g = gen()
g.next()   // {value: Generator, done: false}
g.next()   // {value: 2, done: false}
g.next()   // {value: undefined, done: true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，任何数据类型(Array, String)只要有Iterator接口，就能够被&lt;code&gt;yield*&lt;/code&gt;遍历&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const arr = ['a', 'b']
const str = 'keith'
function *gen () {
  yield arr
  yield* arr
  yield str
  yield* str
}
const g = gen()
g.next() // {value: ['a', 'b'], done: false}
g.next() // {value: 'a', done: false}
g.next() // {value: 'b', done: false}
g.next() // {value: 'keith', done: false}
g.next() // {value: 'k', done: false}
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在Generator函数中存在return语句，则需要使用&lt;code&gt;let value = yield* iterator&lt;/code&gt;方式获取返回值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *foo () {
  yield 1
  return 2
}
function *gen () {
  var x = yield* foo()
  return x
}
const g = gen()
g.next()  // {value: 1, done: false}
g.next()  // {value: 2, done: true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用yield*表达式可以很方便的取出嵌套数组的成员。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 普通方法
const arr = [1, [[2, 3], 4]]
const str = arr.toString().replace(/,/g, '')
for (let item of str) {
  console.log(+item)      // 1, 2, 3, 4
}

// 使用yield*表达式
function *gen (arr) {
  if (Array.isArray(arr)) {
    for (let i = 0; i &amp;lt; arr.length; i++) {
      yield * gen(arr[i])
    }
  } else {
    yield arr
  }
}
const g = gen([1, [[2, 3], 4]])
for (let item of g) {
  console.log(item)       // 1, 2, 3, 4
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;与iterator接口的关系&quot;&gt;与Iterator接口的关系&lt;/h3&gt;
&lt;p&gt;任何一个对象的&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/symbol#%E5%86%85%E7%BD%AE%E7%9A%84-Symbol-%E5%80%BC&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt;属性，指向默认的遍历器对象生成函数。而Generator函数也是遍历器对象生成函数，所以可以将Generator函数赋值给&lt;code&gt;Symbol.iterator&lt;/code&gt;属性，这样就使对象具有了Iterator接口。默认情况下，对象是没有Iterator接口的。&lt;br/&gt;具有Iterator接口的对象，就可以被&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/array#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6&quot;&gt;扩展运算符(...)&lt;/a&gt;，&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/destructuring&quot;&gt;解构赋值&lt;/a&gt;，&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/array#Array-from&quot;&gt;Array.from&lt;/a&gt;和&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/iterator&quot;&gt;for...of&lt;/a&gt;循环遍历了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const person = {
  name: 'keith',
  height: 180
}
function *gen () {
  const arr = Object.keys(this)
  for (let item of arr) {
    yield [item, this[item]]
  }
}
person[Symbol.iterator] = gen
for (let [key, value] of person) {
  console.log(key, value)   // name keith , height 180
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Generator函数函数执行之后，会返回遍历器对象。该对象本身也就有&lt;code&gt;Symbol.iterator&lt;/code&gt;属性，执行后返回自身&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *gen () {}
const g = gen()
g[Symbol.iterator]() === g    // true&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;for...of循环&quot;&gt;for...of循环&lt;/h3&gt;
&lt;p&gt;for...of循环可以自动遍历Generator函数生成的Iterator对象，不用调用next方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *gen () {
  yield 1
  yield 2
  yield 3
  return 4
}
for (let item of gen()) {
  console.log(item)  // 1 2 3
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码使用for...of循环，依次显示 3 个yield表达式的值。这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。&lt;/p&gt;
&lt;h3 id=&quot;作为对象属性的generator函数&quot;&gt;作为对象属性的Generator函数&lt;/h3&gt;
&lt;p&gt;如果一个对象有Generator函数，那么可以使用简写方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let obj = {
  * gen () {}
}
// 也可以完整的写法
let obj = {
  gen: function *gen () {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然了，如果是在构造函数中，简写形式也是一样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class F {
  * gen () {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;generator函数中的this&quot;&gt;Generator函数中的this&lt;/h3&gt;
&lt;p&gt;Generator函数中的this对象跟构造函数中的this对象有异曲同工之处。先来看看构造函数中的new关键字的工作原理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function F () {
  this.a = 1
}
const f = new F()&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;调用构造函数F，返回实例对象f&lt;/li&gt;
&lt;li&gt;将构造函数内部中的this指向这个实例对象&lt;/li&gt;
&lt;li&gt;将构造函数中的原型对象赋值给实例对象的原型&lt;/li&gt;
&lt;li&gt;执行构造函数中的代码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;调用Generator函数会返回遍历器对象，而不是实例对象，因此无法获取到this指向的实例对象上的私有属性和方法。但是这个遍历器对象可以继承Generator函数的prototype原型对象上的属性和方法(公有属性和方法)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *Gen () {
  yield this.a = 1
}
Gen.prototype.say = function () {
  console.log('keith')
}
const g = new Gen()
g.a      // undefined
g.say()  // 'keith'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果希望修复this指向性问题，可以使用call方法将函数执行时所在的作用域绑定到Generator.prototype原型对象上。这样做，会使私有属性和方法变成公有的了，因为都在原型对象上了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function *Gen () {
  this.a = 1
  yield this.b = 2
  yield this.c = 3
}
const g = Gen.call(Gen.prototype)
g.next()   // {value: 2, done: false}
g.next()   // {value: 3, done: false}
g.next()   // {value: undefined, done: true}
g.a        // 1，继承自Gen.prototype
g.b        // 2，同上
g.c        // 3，同上&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;应用&quot;&gt;应用&lt;/h3&gt;
&lt;p&gt;Generator函数的应用主要在异步编程上，会在下一篇文章中分享。请期待噢: )&lt;/p&gt;
</description>
<pubDate>Sun, 21 Jan 2018 13:17:00 +0000</pubDate>
<dc:creator>unclekeith</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/unclekeith/p/8325465.html</dc:identifier>
</item>
</channel>
</rss>