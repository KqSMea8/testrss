<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET Core开发日志——RequestDelegate - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9404671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9404671.html</guid>
<description>&lt;p&gt;本文主要是对&lt;a href=&quot;https://www.cnblogs.com/kenwoo/p/9275922.html&quot;&gt;.NET Core开发日志——Middleware&lt;/a&gt;的补遗，但是会从看起来平平无奇的RequestDelegate开始叙述，所以以其作为标题，也是合情合理。&lt;/p&gt;
&lt;p&gt;RequestDelegate是一种委托类型，其全貌为&lt;code&gt;public delegate Task RequestDelegate(HttpContext context)&lt;/code&gt;，MSDN上对它的解释，&quot;A function that can process an HTTP request.&quot;——处理HTTP请求的函数。唯一参数，是最熟悉不过的HttpContext，返回值则是表示请求处理完成的异步操作类型。&lt;/p&gt;
&lt;p&gt;可以将其理解为ASP.NET Core中对一切HTTP请求处理的抽象(委托类型本身可视为函数模板，其实现具有统一的参数列表及返回值类型)，没有它整个框架就失去了对HTTP请求的处理能力。&lt;/p&gt;
&lt;p&gt;并且它也是构成Middleware的基石。或者更准确地说参数与返回值都是其的&lt;code&gt;Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&lt;/code&gt;委托类型正是维持Middleware运转的核心齿轮。&lt;/p&gt;
&lt;p&gt;组装齿轮的地方位于ApplicationBuilder类之内，其中包含着所有齿轮的集合。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private readonly IList&amp;lt;Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&amp;gt; _components = new List&amp;lt;Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及添加齿轮的方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IApplicationBuilder Use(Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt; middleware)
{
    _components.Add(middleware);
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Startup类的Configure方法里调用以上ApplicationBuilder的Use方法，就可以完成一个最简单的Middleware。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app)
{
    app.Use(_ =&amp;gt;
    {
        return context =&amp;gt;
        {
            return context.Response.WriteAsync(&quot;Hello, World!&quot;);
        };
        
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;齿轮要想变成Middleware，在完成添加后，还需要经过组装。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public RequestDelegate Build()
{
    RequestDelegate app = context =&amp;gt;
    {
        context.Response.StatusCode = 404;
        return Task.CompletedTask;
    };

    foreach (var component in _components.Reverse())
    {
        app = component(app);
    }

    return app;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Build方法里先定义了最底层的零件——app，&lt;code&gt;context =&amp;gt; { context.Response.StatusCode = 404; return Task.CompletedTask; }&lt;/code&gt;，这段代码意味着，如果没有添加任何Middleware的话，ASP.NET Core站点启动后，会直接出现404的错误。&lt;/p&gt;
&lt;p&gt;接下的一段，遍历倒序排列的齿轮，开始正式组装。&lt;/p&gt;
&lt;p&gt;在上述例子里，只使用了一个齿轮：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;_ =&amp;gt;
{
    return context =&amp;gt;
    {
        return context.Response.WriteAsync(&quot;Hello, World!&quot;);
    };
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么第一次也是最后一次循环后，执行&lt;code&gt;component(app)&lt;/code&gt;操作，app被重新赋值为：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;context =&amp;gt; context.Response.WriteAsync(&quot;Hello, World!&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组装的结果便是app的值。&lt;/p&gt;
&lt;p&gt;这个组装过程在WebHost进行BuildApplication时开始操作。从此方法的返回值类型可以看出，虽然明义上是创建Application，其实生成的是RequestDelegate。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private RequestDelegate BuildApplication()
{
    try
    {
        ...

        var builderFactory = _applicationServices.GetRequiredService&amp;lt;IApplicationBuilderFactory&amp;gt;();
        var builder = builderFactory.CreateBuilder(Server.Features);
        ...
        Action&amp;lt;IApplicationBuilder&amp;gt; configure = _startup.Configure;
        ...

        configure(builder);

        return builder.Build();
    }
    ...
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而这个RequestDelegate最终会在HostingApplication类的ProcessRequestAsync方法里被调用。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public virtual async Task StartAsync(CancellationToken cancellationToken = default)
{
    ...

    var application = BuildApplication();

    ...
    var hostingApp = new HostingApplication(application, _logger, diagnosticSource, httpContextFactory);
    ...
}    

public HostingApplication(
    RequestDelegate application,
    ILogger logger,
    DiagnosticListener diagnosticSource,
    IHttpContextFactory httpContextFactory)
{
    _application = application;
    _diagnostics = new HostingApplicationDiagnostics(logger, diagnosticSource);
    _httpContextFactory = httpContextFactory;
}

public Task ProcessRequestAsync(Context context)
{
    return _application(context.HttpContext);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中的执行结果即是显示Hello, World!字符。&lt;/p&gt;
&lt;p&gt;404的错误不再出现，意味着这种Middleware只会完成自己对HTTP请求的处理，并不会将请求传至下一层的Middleware。&lt;/p&gt;
&lt;p&gt;要想达成不断传递请求的目的，需要使用另一种Use扩展方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IApplicationBuilder Use(this IApplicationBuilder app, Func&amp;lt;HttpContext, Func&amp;lt;Task&amp;gt;, Task&amp;gt; middleware)
{
    return app.Use(next =&amp;gt;
    {
        return context =&amp;gt;
        {
            Func&amp;lt;Task&amp;gt; simpleNext = () =&amp;gt; next(context);
            return middleware(context, simpleNext);
        };
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实际代码中可以这么写：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app)
{
    app.Use(async (context, next) =&amp;gt;
    {
        await context.Response.WriteAsync(&quot;I am a Middleware!\n&quot;);
        await next.Invoke();
    });

    app.Use(_ =&amp;gt;
    {
        return context =&amp;gt;
        {
            return context.Response.WriteAsync(&quot;Hello, World!&quot;);
        };
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在多了个Middleware，继续上面的组装过程。app的值最终被赋值为：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;async context =&amp;gt;
{
    Func&amp;lt;Task&amp;gt; simpleNext = () =&amp;gt; context.Response.WriteAsync(&quot;Hello, World!&quot;); 

    await context.Response.WriteAsync(&quot;I am a Middleware!\n&quot;);
    await simpleNext.Invoke();
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示结果为：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;I am a Middleware!
Hello, World!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的流程图中可以清楚地说明这个过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180802220938603-1241984758.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果把&lt;code&gt;await next.Invoke()&lt;/code&gt;注释掉的话，&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app)
{
    app.Use(async (context, next) =&amp;gt;
    {
        await context.Response.WriteAsync(&quot;I am a Middleware!\n&quot;);
        //await next.Invoke();
    });

    app.Use(_ =&amp;gt;
    {
        return context =&amp;gt;
        {
            return context.Response.WriteAsync(&quot;Hello, World!&quot;);
        };

    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中第一个Middleware处理完后，不会继续交给第二个Middleware处理。注意以下simpleNext的方法只被定义而没有被调用。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;async context =&amp;gt;
{
    Func&amp;lt;Task&amp;gt; simpleNext = () =&amp;gt; context.Response.WriteAsync(&quot;Hello, World!&quot;); 

    await context.Response.WriteAsync(&quot;I am a Middleware!\n&quot;);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况被称为短路(short-circuiting)。&lt;/p&gt;
&lt;p&gt;做短路处理的Middleware一般会放在所有Middleware的最后，以作为整个pipeline的终点。&lt;/p&gt;
&lt;p&gt;并且更常见的方式是用Run扩展方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static void Run(this IApplicationBuilder app, RequestDelegate handler)
{
    ...

    app.Use(_ =&amp;gt; handler);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以可以把上面例子的代码改成下面的形式：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app)
{
    app.Use(async (context, next) =&amp;gt;
    {
        await context.Response.WriteAsync(&quot;I am a Middleware!\n&quot;);
        await next.Invoke();
    });

    app.Run(async context =&amp;gt;
    {
        await context.Response.WriteAsync(&quot;Hello, World!&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了短路之外，Middleware处理时还可以有分支的情况。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app)
{
    app.Map(&quot;/branch1&quot;, ab =&amp;gt; {
        ab.Run(async context =&amp;gt;
        {
            await context.Response.WriteAsync(&quot;Map branch 1&quot;);
        });
    });

    app.Map(&quot;/branch2&quot;, ab =&amp;gt; {
        ab.Run(async context =&amp;gt;
        {
            await context.Response.WriteAsync(&quot;Map branch 2&quot;);
        });
    });

    app.Use(async (context, next) =&amp;gt;
    {
        await context.Response.WriteAsync(&quot;I am a Middleware!\n&quot;);
        await next.Invoke();
    });

    app.Run(async context =&amp;gt;
    {
        await context.Response.WriteAsync(&quot;Hello, World!&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;URL地址后面跟着branch1时：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180802223038092-435518923.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;URL地址后面跟着branch2时：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180802223018275-816736623.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其它情况下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/991496/201808/991496-20180802222950392-1628326817.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Map扩展方法的代码实现：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IApplicationBuilder Map(this IApplicationBuilder app, PathString pathMatch, Action&amp;lt;IApplicationBuilder&amp;gt; configuration)
{
    ...

    // create branch
    var branchBuilder = app.New();
    configuration(branchBuilder);
    var branch = branchBuilder.Build();

    var options = new MapOptions
    {
        Branch = branch,
        PathMatch = pathMatch,
    };
    return app.Use(next =&amp;gt; new MapMiddleware(next, options).Invoke);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建分支的办法就是重新实例化一个ApplicationBuilder。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IApplicationBuilder New()
{
    return new ApplicationBuilder(this);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对分支的处理则是封装在MapMiddleware类之中。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task Invoke(HttpContext context)
{
    ...

    PathString matchedPath;
    PathString remainingPath;

    if (context.Request.Path.StartsWithSegments(_options.PathMatch, out matchedPath, out remainingPath))
    {
        // Update the path
        var path = context.Request.Path;
        var pathBase = context.Request.PathBase;
        context.Request.PathBase = pathBase.Add(matchedPath);
        context.Request.Path = remainingPath;

        try
        {
            await _options.Branch(context);
        }
        finally
        {
            context.Request.PathBase = pathBase;
            context.Request.Path = path;
        }
    }
    else
    {
        await _next(context);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说到MapMiddleware，不得不提及各种以Use开头的扩展方法，比如UseStaticFiles，UseMvc，UsePathBase等等。&lt;/p&gt;
&lt;p&gt;这些方法内部都会调用UseMiddleware方法以使用各类定制的Middleware类。如下面UsePathBase的代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IApplicationBuilder UsePathBase(this IApplicationBuilder app, PathString pathBase)
{
    ...

    // Strip trailing slashes
    pathBase = pathBase.Value?.TrimEnd('/');
    if (!pathBase.HasValue)
    {
        return app;
    }

    return app.UseMiddleware&amp;lt;UsePathBaseMiddleware&amp;gt;(pathBase);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而从UseMiddleware方法中可以获知，Middleware类需满足两者条件之一才能被有效使用。其一是实现IMiddleware，其二，必须有Invoke或者InvokeAsync方法，且方法至少要有一个HttpContext类型参数(它还只能是放第一个)，同时返回值需要是Task类型。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;internal const string InvokeMethodName = &quot;Invoke&quot;;
internal const string InvokeAsyncMethodName = &quot;InvokeAsync&quot;;

public static IApplicationBuilder UseMiddleware(this IApplicationBuilder app, Type middleware, params object[] args)
{
    if (typeof(IMiddleware).GetTypeInfo().IsAssignableFrom(middleware.GetTypeInfo()))
    {
        ...

        return UseMiddlewareInterface(app, middleware);
    }

    var applicationServices = app.ApplicationServices;
    return app.Use(next =&amp;gt;
    {
        var methods = middleware.GetMethods(BindingFlags.Instance | BindingFlags.Public);
        var invokeMethods = methods.Where(m =&amp;gt;
            string.Equals(m.Name, InvokeMethodName, StringComparison.Ordinal)
            || string.Equals(m.Name, InvokeAsyncMethodName, StringComparison.Ordinal)
            ).ToArray();

        ...

        var ctorArgs = new object[args.Length + 1];
        ctorArgs[0] = next;
        Array.Copy(args, 0, ctorArgs, 1, args.Length);
        var instance = ActivatorUtilities.CreateInstance(app.ApplicationServices, middleware, ctorArgs);
        if (parameters.Length == 1)
        {
            return (RequestDelegate)methodinfo.CreateDelegate(typeof(RequestDelegate), instance);
        }

        var factory = Compile&amp;lt;object&amp;gt;(methodinfo, parameters);

        return context =&amp;gt;
        {
            var serviceProvider = context.RequestServices ?? applicationServices;
            ...
            return factory(instance, context, serviceProvider);
        };
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对ASP.NET Core中Middleware的介绍到此终于可以告一段落，希望这两篇文章能够为读者提供些许助力。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Aug 2018 15:21:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9404671.html</dc:identifier>
</item>
<item>
<title>【Java入门提高篇】Day27 Java容器类详解（九）——LinkedList详解 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/9388355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/9388355.html</guid>
<description>&lt;p&gt;　　这次介绍一下List接口的另一个践行者——LinkedList，这是一位集诸多技能于一身的List接口践行者，可谓十八般武艺，样样精通，栈、队列、双端队列、链表、双向链表都可以用它来模拟，话不多说，赶紧一起来看看吧。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802231741024-569135464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　本篇将从以下几个方面对LinkedList进行解析：&lt;/p&gt;
&lt;p&gt;　　1.LinkedList整体结构。&lt;/p&gt;
&lt;p&gt;　　2.LinkedList基本操作使用栗子。&lt;/p&gt;
&lt;p&gt;　　3.LinkedList与ArrayList的对比分析。&lt;/p&gt;
&lt;p&gt;　　4.LinkedList整体源码分析。&lt;/p&gt;
&lt;h2&gt;LinkedList整体结构&lt;/h2&gt;
&lt;p&gt;　　先来看看LinkedList中的结构，LinkedList跟ArrayList不一样，ArrayList中是动态维护了一个数组，所有的操作都是 在该数据上进行操作，而LinkedList中其实是一个个的Node节点，每个Node节点首尾相连。如果你还记得前几篇的内容的话，就应该会想起HashMap中其实也是有Node节点的，但两者还是有比较多不一样的地方，先来看看LinkedList中的Node吧。　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802231755857-2091494589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; {
        E item;
        Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; next;
        Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; prev;

        Node(Node&lt;/span&gt;&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; element;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prev =&lt;span&gt; prev;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　嗯，其实很简单，里面只有三个成员变量，item用来存储具体的元素信息，next指向下一个Node节点，prev指向上一个Node节点，node节点之间通过next和prev相连接，组成了一个双向链表的形式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180730095938174-1615793774.png&quot; alt=&quot;&quot; width=&quot;264&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180730100001924-167779787.png&quot; alt=&quot;&quot; width=&quot;752&quot; height=&quot;221&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802231821839-2087034714.png&quot; alt=&quot;&quot;/&gt;嗯，看图说话应该就很好懂了，LinkedList正是由Node这样首尾相连组成了铁索连环的格局&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802231838106-599633645.png&quot; alt=&quot;&quot;/&gt;。而HashMap中的Node节点其实是一个单链表的节点，只有指向后一个节点的引用（next），并没有指向前一个节点的引用，回顾一下HashMap的Node节点代码便能发现这一点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
        V value;
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;

        Node(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hash =&lt;span&gt; hash;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
        }

       ......省略部分代码&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;LinkedList基本操作使用栗子&lt;/h2&gt;
&lt;p&gt;　　接下来看看LinkedList中的一些基础操作，以下是一个小栗子： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
ublic &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkedListTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义要插入集合的字符串对象&lt;/span&gt;
        String a = &quot;A&quot;, b = &quot;B&quot;, c = &quot;C&quot;, d = &quot;D&quot;, e = &quot;E&quot;, f = &quot;F&quot;, g = &quot;G&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建List集合&lt;/span&gt;
        LinkedList&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add操作 添加元素&lt;/span&gt;
&lt;span&gt;        list.add(a);
        list.add(b);
        list.add(c);
        list.add(f);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 迭代器遍历&lt;/span&gt;
        System.out.println(&quot;修改前：&quot;&lt;span&gt;);
        traverseListByIterator(list);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set操作
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将索引位置为1的对象修改为对象g&lt;/span&gt;
        list.set(1&lt;span&gt;, g);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将索引位置为2的对象修改为对象d&lt;/span&gt;
        list.set(2&lt;span&gt;, e);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建迭代器进行遍历（注意：迭代器是一次性使用的，遍历到列表尾部之后，无法重置，再次遍历时需要新建迭代器）&lt;/span&gt;
&lt;span&gt;        System.out.println();
        System.out.println(&lt;/span&gt;&quot;set修改后的集合中的元素是：&quot;&lt;span&gt;);
        traverseListByIterator(list);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建ArrayList&lt;/span&gt;
        List&amp;lt;String&amp;gt; strings = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        strings.add(d);
        strings.add(a);
        strings.add(f);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; addAll添加所有元素&lt;/span&gt;
&lt;span&gt;        list.addAll(strings);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;foreach方式遍历&lt;/span&gt;
        System.out.println(&quot;addAll修改后的集合中的元素是：&quot;&lt;span&gt;);
        traverseListByForEach(list);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove移除元素&lt;/span&gt;
        String removeElement =&lt;span&gt; list.remove();
        System.out.println(&lt;/span&gt;&quot;移除的元素是：&quot; +&lt;span&gt; removeElement);
        System.out.println(&lt;/span&gt;&quot;remove修改后的集合中的元素是：&quot;&lt;span&gt;);
        traverseListByForEach(list);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add插入元素（在第四个位置插入元素&quot;gg&quot;）&lt;/span&gt;
        list.add(3, &quot;gg&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;add插入元素后的集合中的元素是：&quot;&lt;span&gt;);
        traverseListByForEach(list);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * foreach方式遍历列表
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; list 待遍历的列表
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;void&lt;/span&gt; traverseListByForEach(List&amp;lt;T&amp;gt;&lt;span&gt; list){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (T t : list){
            System.out.print(t &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        }
        System.out.println();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 迭代器方式遍历列表
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; list 待遍历的列表
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;void&lt;/span&gt; traverseListByIterator(List&amp;lt;T&amp;gt;&lt;span&gt; list){
        Iterator&lt;/span&gt;&amp;lt;T&amp;gt; iterator =&lt;span&gt; list.iterator();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环获取列表中的元素&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (iterator.hasNext()) {
            System.out.print(iterator.next() &lt;/span&gt;+ &quot; &quot;&lt;span&gt;);
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里仅仅演示了LinkedList的链表操作，主要有add、addAll、remove、set等，几乎每个常用方法都有重载方法，比如只有一个参数的add方法，会直接将该元素插入到列表的尾部，而有两个参数的add方法，会将元素插入指定位置。&lt;/p&gt;
&lt;h2&gt;LinkedList与ArrayList的对比分析&lt;/h2&gt;
&lt;p&gt;　　也许你会问，ArrayList不是也挺好用的吗，那些操作ArrayList也能做啊，为什么还要用LinkedList呢？&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802231900873-2031120641.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这是一个好问题，ArrayList的最大特点就是能随机访问，因为元素在物理上是连续存储的，所以访问的时候，可以通过简单的算法直接定位到指定位置，所以不管队列的元素数量有多少，总能在O(1)的时间里定位到指定位置，但是连续存储也是它的缺点，导致要在中间插入一个元素的时候，所有之后的元素都要往后挪动。而LinkedList的插入只需要调整前后元素的引用即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802095824010-179280176.png&quot; alt=&quot;&quot; width=&quot;829&quot; height=&quot;634&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802095932730-884704119.png&quot; alt=&quot;&quot; width=&quot;840&quot; height=&quot;695&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802100015432-1098381794.png&quot; alt=&quot;&quot; width=&quot;853&quot; height=&quot;576&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802231916802-643083582.png&quot; alt=&quot;&quot;/&gt;看图说话，ArrayList插入显然需要进行更多的赋值操作，特别是数组元素个数比较多的时候，会更加明显，如果刚好需要扩容的话，那就会更慢了。而LinkedList只需要将插入位置的前后元素的next或prev引用进行调整即可，而且也没有扩容问题，因为它本身就没有容量的概念，理论上可以无限添加元素。&lt;/p&gt;
&lt;p&gt;　　然后来实际对比一下效率差距：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TimeCounter {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    TimeCounter(String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; count(){&lt;/span&gt;&lt;span&gt;long&lt;/span&gt; time =&lt;span&gt; System.currentTimeMillis();
        doSomething();
        System.out.println(name &lt;/span&gt;+ &quot; 耗时：&quot; + (System.currentTimeMillis() -&lt;span&gt; time));
    }

    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　先将这个计时抽象成一个模板，每个需要统计耗时的操作只需要继承该类，然后重写doSomeThing方法即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        TimeCounter arrayListAddCounter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TimeCounter(&quot;ArrayList add插入到末尾：&quot;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();

            @Override
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000; i++&lt;span&gt;) {
                    list.add( i);
                }
            }
        };

        TimeCounter linkedListAddCounter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TimeCounter(&quot;LinkedList add插入到末尾：&quot;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();

            @Override
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000; i++&lt;span&gt;) {
                    list.add( i);
                }
            }
        };

        arrayListAddCounter.count();
        linkedListAddCounter.count();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ArrayList add插入到末尾： 耗时：&lt;/span&gt;11&lt;span&gt;
LinkedList add插入到末尾： 耗时：&lt;/span&gt;9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802231929440-210752145.png&quot; alt=&quot;&quot;/&gt;好像勉强符合预期，LinkedList比ArrayList略微快一点，其实如果在ArrayList容量足够的情况下，ArrayList的插入元素到末尾操作是要比LinkedList插入要快的，因为它只需要进行一次赋值即可，而LinkedList还需要先new一个新节点然后再接到链表的最后，这个new的过程看起来微不足道，但是一旦循环次数到达一定量级，开销是不可忽略的。例如把上面的循环次数从100000改成1000000，结果就会变成这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ArrayList add插入到末尾： 耗时：40&lt;span&gt;
LinkedList add插入到末尾： 耗时：&lt;/span&gt;768
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802231947800-1068773577.png&quot; alt=&quot;&quot;/&gt;这时候，创建节点的开销成了主要时间开销，效率甚至不如ArrayList。我们再换一个插入方式，上面是把元素插入到末尾，这次来把元素插入到首端看看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        TimeCounter arrayListAddCounter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TimeCounter(&quot;ArrayList add插入到首端：&quot;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();

            @Override
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000; i++&lt;span&gt;) {
                    list.add(&lt;/span&gt;0&lt;span&gt;, i);
                }
            }
        };

        TimeCounter linkedListAddCounter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TimeCounter(&quot;LinkedList add插入到首端：&quot;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();

            @Override
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000; i++&lt;span&gt;) {
                    list.add(&lt;/span&gt;0&lt;span&gt;, i);
                }
            }
        };

        arrayListAddCounter.count();
        linkedListAddCounter.count();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ArrayList add插入到首端： 耗时：607&lt;span&gt;
LinkedList add插入到首端： 耗时：&lt;/span&gt;11
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当每次都插入在首端时，ArrayList每次都需要进行元素移动，而且列表中元素越多，需要进行移动的次数也越多，在这种情况下，LinkedList是明显优于ArrayList的。&lt;/p&gt;
&lt;p&gt;　　所以说，其实这两者是各有所长各有所短的，一般情况下，选ArrayList就好，除非是需要进行循环操作的次数到达了万的量级的时候，才需要对两者进行选择。也许你会说，既然一般情况下，两者的效率差别不大，那直接用ArrayList就好了，说这么多干嘛呢。哈哈，如果是这样想，那就大错特错了。首先我们不仅需要知其然，还需要知其所以然，如果仅仅知道LinkedList比ArrayList插入效率高，但是却不知道为什么高，高多少，是远远不够的。其次，我们不能仅仅考虑正常情况，对于极端情况也需要有预防措施，对极端情况的思考，正是高手与新手的最大区别。&lt;/p&gt;
&lt;p&gt;　　下面再看看查找元素的比较：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        TimeCounter arrayListAddCounter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TimeCounter(&quot;ArrayList get遍历元素：&quot;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();

            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000; i++&lt;span&gt;) {
                    list.add(i);
                }
            }

            @Override
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000; i++&lt;span&gt;) {
                    list.get(i);
                }
            }
        };

        TimeCounter linkedListAddCounter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TimeCounter(&quot;LinkedList get遍历元素：&quot;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();

            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000; i++&lt;span&gt;) {
                    list.add(i);
                }
            }

            @Override
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doSomething() {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 100000; i++&lt;span&gt;) {
                    list.get(i);
                }
            }
        };

        arrayListAddCounter.count();
        linkedListAddCounter.count();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ArrayList get遍历元素： 耗时：3&lt;span&gt;
LinkedList get遍历元素： 耗时：&lt;/span&gt;4484
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ArrayList完胜，可以看出LinkedList中查找元素是一个十分耗时的操作，甚至比插入元素耗时还要长，因为每次get的时候都是从链表两端进行逐个查找，直到找到指定的位置。想要知道具体细节的话，那就耐心的看看下面的源码解析吧。&lt;/p&gt;
&lt;h2&gt;LinkedList整体源码分析&lt;/h2&gt;
&lt;p&gt;　　先来看看LinkedList的整体结构：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802205933118-1149505200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802205943540-1161231515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到LinkedList有四个内部类，分别是Node、ListItr、DescendingIterator、LLSpliterator。Node类主要用于存放元素，先来看看Node：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放元素&lt;/span&gt;
&lt;span&gt;        E item;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向下一个Node节点&lt;/span&gt;
        Node&amp;lt;E&amp;gt;&lt;span&gt; next;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向上一个Node节点&lt;/span&gt;
        Node&amp;lt;E&amp;gt;&lt;span&gt; prev;

        Node(Node&lt;/span&gt;&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; element;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prev =&lt;span&gt; prev;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是可以说是最简单的类了，也构成了LinkedList的基础，LinkedList正是由一个个Node节点连接组成。再来看看ListItr类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;列表迭代器类&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ListItr &lt;span&gt;implements&lt;/span&gt; ListIterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; lastReturned;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; next;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nextIndex;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expectedModCount =&lt;span&gt; modCount;

        ListItr(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert isPositionIndex(index);&lt;/span&gt;
            next = (index == size) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : node(index);
            nextIndex &lt;/span&gt;=&lt;span&gt; index;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextIndex &amp;lt;&lt;span&gt; size;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            checkForComodification();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hasNext())
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();

            lastReturned &lt;/span&gt;=&lt;span&gt; next;
            next &lt;/span&gt;=&lt;span&gt; next.next;
            nextIndex&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lastReturned.item;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasPrevious() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextIndex &amp;gt; 0&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E previous() {
            checkForComodification();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hasPrevious())
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();

            lastReturned &lt;/span&gt;= next = (next == &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; last : next.prev;
            nextIndex&lt;/span&gt;--&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lastReturned.item;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nextIndex() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextIndex;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; previousIndex() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextIndex - 1&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            checkForComodification();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastReturned == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();

            Node&lt;/span&gt;&amp;lt;E&amp;gt; lastNext =&lt;span&gt; lastReturned.next;
            unlink(lastReturned);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next ==&lt;span&gt; lastReturned)
                next &lt;/span&gt;=&lt;span&gt; lastNext;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                nextIndex&lt;/span&gt;--&lt;span&gt;;
            lastReturned &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            expectedModCount&lt;/span&gt;++&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; set(E e) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastReturned == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
            checkForComodification();
            lastReturned.item &lt;/span&gt;=&lt;span&gt; e;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(E e) {
            checkForComodification();
            lastReturned &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                linkLast(e);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                linkBefore(e, next);
            nextIndex&lt;/span&gt;++&lt;span&gt;;
            expectedModCount&lt;/span&gt;++&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEachRemaining(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; action) {
            Objects.requireNonNull(action);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (modCount == expectedModCount &amp;amp;&amp;amp; nextIndex &amp;lt;&lt;span&gt; size) {
                action.accept(next.item);
                lastReturned &lt;/span&gt;=&lt;span&gt; next;
                next &lt;/span&gt;=&lt;span&gt; next.next;
                nextIndex&lt;/span&gt;++&lt;span&gt;;
            }
            checkForComodification();
        }

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个类是LinkedList的迭代器类，主要用于顺序遍历LinkedList，在前面的栗子中有使用迭代器的hasNext方法和next方法，其实它们的实现都很简单，hasNext只是简单的比较下一个要访问的元素序号是否大于列表中的元素个数，next方法则是将next的引用赋值给lastReturned变量，然后将next指向其下一个节点并且将index加1。但跟普通迭代器不一样的地方在于这个迭代器不仅可以正序遍历，还可以使用previous方法进行倒序遍历，DescendingIterator便是使用了迭代器的previous方法进行便利的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 降序迭代器
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DescendingIterator &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ListItr itr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListItr(size());
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; itr.hasPrevious();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; itr.previous();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            itr.remove();
        }
    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个迭代器就比较简单了，只是包裹了一个ListItr实例，然后重载了Iterator的几个方法。LLSpliterator是用于并行流的可分割式迭代器，这里就不做过多介绍了。&lt;/p&gt;
&lt;p&gt;　　再来看看常用的几个方法的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加指定元素到列表尾部
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        linkLast(e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 把元素e链接成尾节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkLast(E e) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l =&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(l, e, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        last &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            l.next &lt;/span&gt;=&lt;span&gt; newNode;
        size&lt;/span&gt;++&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当插入一个元素时，会new一个Node对象，并将该值放入Node节点中，然后挂到链表的尾部。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在列表指定位置插入指定元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
        checkPositionIndex(index);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index ==&lt;span&gt; size)
            linkLast(element);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            linkBefore(element, node(index));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入一个元素到指定非空节点之前
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; linkBefore(E e, Node&amp;lt;E&amp;gt;&lt;span&gt; succ) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert succ != null;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; pred =&lt;span&gt; succ.prev;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;&lt;span&gt;(pred, e, succ);
        succ.prev &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            pred.next &lt;/span&gt;=&lt;span&gt; newNode;
        size&lt;/span&gt;++&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　add的重载版本，可以指定序号进行插入，将元素插入到链表中间，进行的操作过程可以联系前面的图进行理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回指定位置的元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkElementIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node(index).item;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回指定元素序号的非空节点。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Node&lt;/span&gt;&amp;lt;E&amp;gt; node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert isElementIndex(index);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;做了一个小优化，如果取的序号小于元素个数的一半，则从链表首端开始遍历，否则从链表尾部开始遍历&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; 1&lt;span&gt;)) {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; x =&lt;span&gt; first;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; index; i++&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.next;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; x =&lt;span&gt; last;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - 1; i &amp;gt; index; i--&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.prev;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到get方法其实是从头部或者尾部进行遍历定位的，每次将x的引用向后/向前移动一位，当链表数据量比较大时，这个过程其实是很耗时间的，前面的对比中应该也能发现这一点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取回并删除此列表的头部（第一个元素）。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E remove() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; removeFirst();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除列表指定位置的元素，如果其后子序列存在，则将其元素左移，将它们的序号减一。
     * 返回列表中移除的元素。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkElementIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unlink(node(index));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除并返回首节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E removeFirst() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unlinkFirst(f);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除首节点并返回该节点元素值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; E unlinkFirst(Node&amp;lt;E&amp;gt;&lt;span&gt; f) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert f == first &amp;amp;&amp;amp; f != null;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; E element =&lt;span&gt; f.item;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; next =&lt;span&gt; f.next;
        f.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        f.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
        first =&lt;span&gt; next;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            last &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            next.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size&lt;/span&gt;--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除非空节点x
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E unlink(Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; x) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert x != null;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; E element =&lt;span&gt; x.item;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; next =&lt;span&gt; x.next;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; prev =&lt;span&gt; x.prev;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            first &lt;/span&gt;=&lt;span&gt; next;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            prev.next &lt;/span&gt;=&lt;span&gt; next;
            x.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            last &lt;/span&gt;=&lt;span&gt; prev;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            next.prev &lt;/span&gt;=&lt;span&gt; prev;
            x.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        x.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size&lt;/span&gt;--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　remove方法也有两个重载版本，不带参数的remove方法仅仅移除并返回最后一个节点，而指定序号参数的remove方法则会移除并返回链表中指定位置的节点。&lt;/p&gt;
&lt;p&gt;　　此外链表还有可以用于队列的诸多方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在尾部添加元素：(add, offer)，add()会在长度不够时抛出异常：IllegalStateException;  offer()则不会,只返回false。&lt;/li&gt;
&lt;li&gt;查看头部元素 (element, peek)，返回头部元素，但不改变队列。element()会在没元素时抛出异常：NoSuchElementException;  peek()返回null;&lt;/li&gt;
&lt;li&gt;删除头部元素 (remove, poll)，返回头部元素，并且从队列中删除，remove()会在没元素时抛出异常：NoSuchElementException;  poll()返回null; &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　即可以通过以上方法来实现单向队列的操作，也可以使用addFirst,addLast,removeFirst,removeLast方法来实现双向队列的操作。以下是一个简单队列的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyQueue&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LinkedList&amp;lt;T&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;T&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空队列&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        list.clear();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断队列是否为空&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list.isEmpty();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;进队&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; enqueue(T o) {
        list.addLast(o);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T dequeue(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;list.isEmpty())
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list.removeFirst();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取队列长度&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list.size();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看队首元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T peek() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list.getFirst();
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试队列&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        MyQueue&lt;/span&gt;&amp;lt;String&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; MyQueue&amp;lt;String&amp;gt;&lt;span&gt;();
        System.out.println(queue.isEmpty());
        queue.enqueue(&lt;/span&gt;&quot;a&quot;&lt;span&gt;);
        queue.enqueue(&lt;/span&gt;&quot;b&quot;&lt;span&gt;);
        queue.enqueue(&lt;/span&gt;&quot;c&quot;&lt;span&gt;);
        queue.enqueue(&lt;/span&gt;&quot;d&quot;&lt;span&gt;);
        queue.enqueue(&lt;/span&gt;&quot;e&quot;&lt;span&gt;);
        queue.enqueue(&lt;/span&gt;&quot;f&quot;&lt;span&gt;);
        System.out.println(queue.length());
        System.out.println(queue.dequeue());
        System.out.println(queue.dequeue());
        System.out.println(queue.peek());
        System.out.println(queue.dequeue());
        queue.clear();
        queue.enqueue(&lt;/span&gt;&quot;s&quot;&lt;span&gt;);
        queue.enqueue(&lt;/span&gt;&quot;t&quot;&lt;span&gt;);
        queue.enqueue(&lt;/span&gt;&quot;r&quot;&lt;span&gt;);
        System.out.println(queue.dequeue());
        System.out.println(queue.length());
        System.out.println(queue.peek());
        System.out.println(queue.dequeue());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　嗯，其实就是借鸡生蛋的事情嘛，哈哈。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802232013500-807011822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再来看看用LinkedList的简单栈实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyStack&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LinkedList&amp;lt;T&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;T&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入栈&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; push(T v) {
        stack.addFirst(v);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出栈，但不删除&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T peek() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stack.getFirst();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出栈&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T pop() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stack.removeFirst();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 栈是否为空&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; empty() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stack.isEmpty();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印栈元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stack.toString();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　你看，其实很简单吧，LinkedList提供的大量的方法，可以很方便的进行链表、双向链表、队列、双端队列、栈等数据结构的实现，可以说非常好用了。&lt;/p&gt;
&lt;p&gt;　　下面是LinkedList的全部源码，行有余力的话可以选择你想要了解的部分进行阅读，如果有不懂的地方可以在本文后面留言，当然，也可以直接跳过，以后想要深入了解的时候再进行阅读也不迟。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 双向链表实现了List接口和Deque接口，实现了多有可选List操作，并且允许放入所有的元素，包括null。
 *
 * 所有的操作都表现得像双向链表，索引到列表中的操作将从开头或者结尾遍历列表，以较接近指定索引为准。
 *
 * 注意，这个实现类不是线程安全的，如果多个线程同时访问一个链表，并且至少一个线程修改了链表的结构，
 * 则必须在外部实现同步。结构性修改指的是那些增加删除一个或多个元素的操作，仅设置元素的值不是结构修改。
 * 这通常通过在封装列表的某个对象上进行同步来实现。
 *
 * 如果没有这样的对象存在，则列表应该使用Collections#synchronizedList方法包装，最好在创建列表的时候进行，
 * 以防止意外的非同步引用对列表进行了修改。
 *   List list = Collections.synchronizedList(new LinkedList(...));
 *
 * 该类的iterator方法和listIterator方法返回的迭代器是“fail-fast”的，如果列表在迭代器创建之后的任何时刻被进行
 * 结构性的修改了，则调用迭代器自身的remove或者add方法时将会抛出ConcurrentModificationException异常，因此
 * 当遇到并发修改时，迭代器会快速的失败，而不是在未来某个不确定的时刻进行武断冒险或不确定性的行为
 *
 * 注意，通常来说，不能保证迭代器的fail-fast机制，在遇到非同步的并发修改时，不可能做出任何严格的保证。
 * fail-fast 迭代器只能尽最大努力抛出ConcurrentModificationException异常，因此，如果程序依赖这个异常来
 * 进行正确性判断是错误的，fail-fast机制仅应该用于检测异常。
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedList&amp;lt;E&amp;gt;
        &lt;span&gt;extends&lt;/span&gt; AbstractSequentialList&amp;lt;E&amp;gt;
        &lt;span&gt;implements&lt;/span&gt; List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;&lt;span&gt;, Cloneable, java.io.Serializable {
    &lt;/span&gt;&lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指向第一个节点
     * 恒等式: (first == null &amp;amp;&amp;amp; last == null) ||
     *            (first.prev == null &amp;amp;&amp;amp; first.item != null)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; first;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指向最后一个节点
     * 恒等式: (first == null &amp;amp;&amp;amp; last == null) ||
     *            (last.next == null &amp;amp;&amp;amp; last.item != null)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; last;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造一个空的列表
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkedList() {
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造一个包含指定集合内所有元素的列表，存储的顺序为集合的迭代器访问顺序。
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException 空指针异常
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedList(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
        addAll(c);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 把元素e链接成首节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkFirst(E e) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, e, f);
        first &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            last &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            f.prev &lt;/span&gt;=&lt;span&gt; newNode;
        size&lt;/span&gt;++&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 把元素e链接成尾节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkLast(E e) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l =&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(l, e, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        last &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            l.next &lt;/span&gt;=&lt;span&gt; newNode;
        size&lt;/span&gt;++&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入一个元素到指定非空节点之前
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; linkBefore(E e, Node&amp;lt;E&amp;gt;&lt;span&gt; succ) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert succ != null;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; pred =&lt;span&gt; succ.prev;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;&lt;span&gt;(pred, e, succ);
        succ.prev &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;=&lt;span&gt; newNode;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            pred.next &lt;/span&gt;=&lt;span&gt; newNode;
        size&lt;/span&gt;++&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除首节点并返回该节点元素值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; E unlinkFirst(Node&amp;lt;E&amp;gt;&lt;span&gt; f) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert f == first &amp;amp;&amp;amp; f != null;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; E element =&lt;span&gt; f.item;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; next =&lt;span&gt; f.next;
        f.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        f.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
        first =&lt;span&gt; next;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            last &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            next.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size&lt;/span&gt;--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除尾节点并返回该节点元素值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; E unlinkLast(Node&amp;lt;E&amp;gt;&lt;span&gt; l) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert l == last &amp;amp;&amp;amp; l != null;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; E element =&lt;span&gt; l.item;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; prev =&lt;span&gt; l.prev;
        l.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        l.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
        last =&lt;span&gt; prev;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            prev.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size&lt;/span&gt;--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除非空节点x
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E unlink(Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; x) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert x != null;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; E element =&lt;span&gt; x.item;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; next =&lt;span&gt; x.next;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; prev =&lt;span&gt; x.prev;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            first &lt;/span&gt;=&lt;span&gt; next;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            prev.next &lt;/span&gt;=&lt;span&gt; next;
            x.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            last &lt;/span&gt;=&lt;span&gt; prev;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            next.prev &lt;/span&gt;=&lt;span&gt; prev;
            x.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        x.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size&lt;/span&gt;--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回列表的首节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E getFirst() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; f.item;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回列表的最后一个节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E getLast() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l =&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; l.item;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除并返回首节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E removeFirst() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unlinkFirst(f);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除并返回尾节点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E removeLast() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l =&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unlinkLast(l);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入指定元素到列表首端
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addFirst(E e) {
        linkFirst(e);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 扩展指定元素到列表尾端
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addLast(E e) {
        linkLast(e);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回列表中是否包含指定元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(Object o) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; indexOf(o) != -1&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回列表中元素个数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加指定元素到列表尾部
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        linkLast(e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 如果该元素存在，则移除列表中首次出现的该指定元素，如果不存在，则原链表不会改变。
     * 如果该列表中包含该指定元素则返回true，否则返回false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object o) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item)) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加指定集合中的所有元素到列表的尾部，顺序为指定集合的迭代器遍历顺序。如果该操作正在进行时，指定集合
     * 被修改了，那么该操作的行为是不可预测的。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addAll(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; addAll(size, c);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将指定集合中的所有元素插入到该列表的指定位置之后。将当前在该位置的元素及其之后的元素右移。新元素在列表
     * 中的顺序为其原集合迭代器遍历顺序。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addAll(&lt;span&gt;int&lt;/span&gt; index, Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
        checkPositionIndex(index);

        Object[] a &lt;/span&gt;=&lt;span&gt; c.toArray();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; numNew =&lt;span&gt; a.length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (numNew == 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; pred, succ;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index ==&lt;span&gt; size) {
            succ &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            pred &lt;/span&gt;=&lt;span&gt; last;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            succ &lt;/span&gt;=&lt;span&gt; node(index);
            pred &lt;/span&gt;=&lt;span&gt; succ.prev;
        }

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object o : a) {
            @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;) E e =&lt;span&gt; (E) o;
            Node&lt;/span&gt;&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(pred, e, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                first &lt;/span&gt;=&lt;span&gt; newNode;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                pred.next &lt;/span&gt;=&lt;span&gt; newNode;
            pred &lt;/span&gt;=&lt;span&gt; newNode;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (succ == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            last &lt;/span&gt;=&lt;span&gt; pred;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            pred.next &lt;/span&gt;=&lt;span&gt; succ;
            succ.prev &lt;/span&gt;=&lt;span&gt; pred;
        }

        size &lt;/span&gt;+=&lt;span&gt; numNew;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除列表中所有元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清除节点之间所有元素的链接不是必要的，但是:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - 如果被清除的节点处于不同代之间，可以帮助分代GC。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; - 一定要释放内存，即便有一个迭代器引用&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; ) {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; next =&lt;span&gt; x.next;
            x.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            x.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            x.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            x &lt;/span&gt;=&lt;span&gt; next;
        }
        first &lt;/span&gt;= last = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size &lt;/span&gt;= 0&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 位置访问操作&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回指定位置的元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkElementIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node(index).item;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用指定元素替换指定位置的元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E set(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
        checkElementIndex(index);
        Node&lt;/span&gt;&amp;lt;E&amp;gt; x =&lt;span&gt; node(index);
        E oldVal &lt;/span&gt;=&lt;span&gt; x.item;
        x.item &lt;/span&gt;=&lt;span&gt; element;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldVal;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在列表指定位置插入指定元素，如果该位置有任何元素，则将其后的子序列元素都往右移（将它们的序号都增加1）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
        checkPositionIndex(index);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index ==&lt;span&gt; size)
            linkLast(element);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            linkBefore(element, node(index));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 移除列表指定位置的元素，如果其后子序列存在，则将其元素左移，将它们的序号减一。
     * 返回列表中移除的元素。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkElementIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unlink(node(index));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断该序号是否在列表中对应位置存在元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isElementIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt;&lt;span&gt; size;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断给参数是否是迭代器或者add操作的合法位置
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isPositionIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt;=&lt;span&gt; size;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造一个IndexOutOfBoundsException 异常的详情消息，在错误处理代码的许多可能的重构中，
     * 这个大纲在服务端和客户端虚拟机中都表现的最好。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String outOfBoundsMsg(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Index: &quot;+index+&quot;, Size: &quot;+&lt;span&gt;size;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; checkElementIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isElementIndex(index))
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; checkPositionIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isPositionIndex(index))
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回指定元素序号的非空节点。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Node&lt;/span&gt;&amp;lt;E&amp;gt; node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert isElementIndex(index);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;做了一个小优化，如果取的序号小于元素个数的一半，则从链表首端开始遍历，否则从链表尾部开始遍历&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; 1&lt;span&gt;)) {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; x =&lt;span&gt; first;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; index; i++&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.next;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; x =&lt;span&gt; last;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - 1; i &amp;gt; index; i--&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.prev;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 搜索操作&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回指定元素在列表中第一次出现的位置，否则返回-1
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(Object o) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
                index&lt;/span&gt;++&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
                index&lt;/span&gt;++&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回指定元素在链表中最后一次出现的位置，如果链表中不包含该元素，则返回-1
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lastIndexOf(Object o) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; size;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = last; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.prev) {
                index&lt;/span&gt;--&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = last; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.prev) {
                index&lt;/span&gt;--&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队列操作&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取回但不删除此列表的头部（第一个元素）。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peek() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : f.item;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取回但不删除此列表的头部（第一个元素）。
     * 如果不存在，则会抛出NoSuchElementException异常
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E element() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getFirst();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取回并删除此列表的头部（第一个元素）。
     * 如果该链表为空，则返回null
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E poll() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : unlinkFirst(f);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取回并删除此列表的头部（第一个元素）。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E remove() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; removeFirst();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 添加指定元素到链表尾部
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; offer(E e) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; add(e);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双向队列操作&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入指定元素到队列首部
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; offerFirst(E e) {
        addFirst(e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入指定元素到队列尾部
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; offerLast(E e) {
        addLast(e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     *
     * 取回但是不删除队列的首元素。如果队列为空则返回null。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peekFirst() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : f.item;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取回但是不删除链表的最后一个元素，如果队列为空，则返回null
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peekLast() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l =&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : l.item;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取回并删除队列的首元素，如果队列为空，则返回null
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E pollFirst() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : unlinkFirst(f);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取回并删除队列的尾元素，如果队列为空，则返回null
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E pollLast() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l =&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : unlinkLast(l);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 在队列前端插入元素
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; push(E e) {
        addFirst(e);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除并返回队列的第一个元素，如果列表为空则抛出NoSuchElementException 异常
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E pop() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; removeFirst();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除此队列中第一个出现的指定元素（从头到尾的方式遍历时），如果队列中不包含该元素，则队列不会改变。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; removeFirstOccurrence(Object o) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; remove(o);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除此队列中最后一次出现的指定元素（从头到尾的方式遍历时），如果队列中不包含该元素，则队列不会改变。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; removeLastOccurrence(Object o) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = last; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.prev) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = last; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.prev) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item)) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回从指定位置开始，以正确的序列迭代该列表的迭代器.
     * 列表迭代器是“fail-fast”的，如果列表在迭代器创建之后的任何时刻被进行
     * 结构性的修改了，则调用迭代器自身的remove或者add方法时将会抛出ConcurrentModificationException异常，因此
     * 当遇到并发修改时，迭代器会快速的失败，而不是在未来某个不确定的时刻进行武断冒险或不确定性的行为
     *
     * 注意，通常来说，不能保证迭代器的fail-fast机制，在遇到非同步的并发修改时，不可能做出任何严格的保证。
     * fail-fast 迭代器只能尽最大努力抛出ConcurrentModificationException异常，因此，如果程序依赖这个异常来
     * 进行正确性判断是错误的，fail-fast机制仅应该用于检测异常。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; ListIterator&amp;lt;E&amp;gt; listIterator(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkPositionIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListItr(index);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;列表迭代器类&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ListItr &lt;span&gt;implements&lt;/span&gt; ListIterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录上一个返回的节点&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; lastReturned;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向下一个节点&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; next;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一个节点的序号&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nextIndex;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于检测遍历过程中List是否被修改&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expectedModCount =&lt;span&gt; modCount;

        ListItr(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert isPositionIndex(index);&lt;/span&gt;
            next = (index == size) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : node(index);
            nextIndex &lt;/span&gt;=&lt;span&gt; index;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextIndex &amp;lt;&lt;span&gt; size;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测是否修改&lt;/span&gt;
&lt;span&gt;            checkForComodification();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hasNext())
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();

            lastReturned &lt;/span&gt;=&lt;span&gt; next;
            next &lt;/span&gt;=&lt;span&gt; next.next;
            nextIndex&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lastReturned.item;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasPrevious() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextIndex &amp;gt; 0&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E previous() {
            checkForComodification();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hasPrevious())
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();

            lastReturned &lt;/span&gt;= next = (next == &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; last : next.prev;
            nextIndex&lt;/span&gt;--&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lastReturned.item;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nextIndex() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextIndex;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; previousIndex() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextIndex - 1&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            checkForComodification();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastReturned == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();

            Node&lt;/span&gt;&amp;lt;E&amp;gt; lastNext =&lt;span&gt; lastReturned.next;
            unlink(lastReturned);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next ==&lt;span&gt; lastReturned)
                next &lt;/span&gt;=&lt;span&gt; lastNext;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                nextIndex&lt;/span&gt;--&lt;span&gt;;
            lastReturned &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            expectedModCount&lt;/span&gt;++&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; set(E e) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastReturned == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
            checkForComodification();
            lastReturned.item &lt;/span&gt;=&lt;span&gt; e;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(E e) {
            checkForComodification();
            lastReturned &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                linkLast(e);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                linkBefore(e, next);
            nextIndex&lt;/span&gt;++&lt;span&gt;;
            expectedModCount&lt;/span&gt;++&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEachRemaining(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; action) {
            Objects.requireNonNull(action);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (modCount == expectedModCount &amp;amp;&amp;amp; nextIndex &amp;lt;&lt;span&gt; size) {
                action.accept(next.item);
                lastReturned &lt;/span&gt;=&lt;span&gt; next;
                next &lt;/span&gt;=&lt;span&gt; next.next;
                nextIndex&lt;/span&gt;++&lt;span&gt;;
            }
            checkForComodification();
        }

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放元素&lt;/span&gt;
&lt;span&gt;        E item;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向下一个Node节点&lt;/span&gt;
        Node&amp;lt;E&amp;gt;&lt;span&gt; next;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向上一个Node节点&lt;/span&gt;
        Node&amp;lt;E&amp;gt;&lt;span&gt; prev;

        Node(Node&lt;/span&gt;&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; element;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prev =&lt;span&gt; prev;
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回一个倒序遍历的迭代器
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; descendingIterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DescendingIterator();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 降序迭代器
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DescendingIterator &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ListItr itr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListItr(size());
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; itr.hasPrevious();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; itr.previous();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            itr.remove();
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LinkedList&amp;lt;E&amp;gt;&lt;span&gt; superClone() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (LinkedList&amp;lt;E&amp;gt;) &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CloneNotSupportedException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(e);
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 浅克隆
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object clone() {
        LinkedList&lt;/span&gt;&amp;lt;E&amp;gt; clone =&lt;span&gt; superClone();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Put clone into &quot;virgin&quot; state&lt;/span&gt;
        clone.first = clone.last = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        clone.size &lt;/span&gt;= 0&lt;span&gt;;
        clone.modCount &lt;/span&gt;= 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize clone with our elements&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next)
            clone.add(x.item);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clone;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回一个包含列表所有元素的数组，元素的顺序为从第一个到最后一个。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object[] toArray() {
        Object[] result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[size];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next)
            result[i&lt;/span&gt;++] =&lt;span&gt; x.item;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回一个包含列表所有元素的数组，元素的顺序为从第一个到最后一个。返回元素数组的类型
     * 与指定数组的类型一致。如果列表大小适合指定的数组，则返回该数组。 否则，将为新数组分配指定
     * 数组的运行时类型和此列表的大小。
     *
     * 如果列表的空间适合指定的数组（数组比列表有更多的元素），紧跟在列表末尾之后的数组中的元素设置
     * 为null（仅当调用者知道列表不包含任何null元素时，这在确定列表长度时很有用。）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T[] toArray(T[] a) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a.length &amp;lt;&lt;span&gt; size)
            a &lt;/span&gt;=&lt;span&gt; (T[])java.lang.reflect.Array.newInstance(
                    a.getClass().getComponentType(), size);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        Object[] result &lt;/span&gt;=&lt;span&gt; a;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next)
            result[i&lt;/span&gt;++] =&lt;span&gt; x.item;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a.length &amp;gt;&lt;span&gt; size)
            a[size] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 876323262645176354L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 序列化
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeObject(java.io.ObjectOutputStream s)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.io.IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out any hidden serialization magic&lt;/span&gt;
&lt;span&gt;        s.defaultWriteObject();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out size&lt;/span&gt;
&lt;span&gt;        s.writeInt(size);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out all elements in the proper order.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next)
            s.writeObject(x.item);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 反序列化
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readObject(java.io.ObjectInputStream s)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.io.IOException, ClassNotFoundException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in any hidden serialization magic&lt;/span&gt;
&lt;span&gt;        s.defaultReadObject();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in size&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; s.readInt();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in all elements in the proper order.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i++&lt;span&gt;)
            linkLast((E)s.readObject());
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建一个可分割的迭代器
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Spliterator&amp;lt;E&amp;gt;&lt;span&gt; spliterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LLSpliterator&amp;lt;E&amp;gt;(&lt;span&gt;this&lt;/span&gt;, -1, 0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; Spliterators.IteratorSpliterator 的定制版本 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LLSpliterator&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; Spliterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BATCH_UNIT = 1 &amp;lt;&amp;lt; 10;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; batch array size increment&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_BATCH = 1 &amp;lt;&amp;lt; 25;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; max batch array size;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; LinkedList&amp;lt;E&amp;gt; list; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; null OK unless traversed&lt;/span&gt;
        Node&amp;lt;E&amp;gt; current;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; current node; null until initialized&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; est;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; size estimate; -1 until first needed&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; expectedModCount; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initialized when est set&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; batch;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; batch size for splits&lt;/span&gt;
&lt;span&gt;
        LLSpliterator(LinkedList&lt;/span&gt;&amp;lt;E&amp;gt; list, &lt;span&gt;int&lt;/span&gt; est, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedModCount) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; list;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.est =&lt;span&gt; est;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.expectedModCount =&lt;span&gt; expectedModCount;
        }

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getEst() {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; force initialization&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; LinkedList&amp;lt;E&amp;gt;&lt;span&gt; lst;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((s = est) &amp;lt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((lst = list) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    s &lt;/span&gt;= est = 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    expectedModCount &lt;/span&gt;=&lt;span&gt; lst.modCount;
                    current &lt;/span&gt;=&lt;span&gt; lst.first;
                    s &lt;/span&gt;= est =&lt;span&gt; lst.size;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; estimateSize() { &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;) getEst(); }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Spliterator&amp;lt;E&amp;gt;&lt;span&gt; trySplit() {
            Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; getEst();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt; 1 &amp;amp;&amp;amp; (p = current) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = batch +&lt;span&gt; BATCH_UNIT;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;gt;&lt;span&gt; s)
                    n &lt;/span&gt;=&lt;span&gt; s;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;gt;&lt;span&gt; MAX_BATCH)
                    n &lt;/span&gt;=&lt;span&gt; MAX_BATCH;
                Object[] a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[n];
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt; { a[j++] = p.item; } &lt;span&gt;while&lt;/span&gt; ((p = p.next) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; j &amp;lt;&lt;span&gt; n);
                current &lt;/span&gt;=&lt;span&gt; p;
                batch &lt;/span&gt;=&lt;span&gt; j;
                est &lt;/span&gt;= s -&lt;span&gt; j;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterators.spliterator(a, 0&lt;span&gt;, j, Spliterator.ORDERED);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEachRemaining(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; action) {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((n = getEst()) &amp;gt; 0 &amp;amp;&amp;amp; (p = current) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                current &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                est &lt;/span&gt;= 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    E e &lt;/span&gt;=&lt;span&gt; p.item;
                    p &lt;/span&gt;=&lt;span&gt; p.next;
                    action.accept(e);
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; --n &amp;gt; 0&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (list.modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAdvance(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; action) {
            Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getEst() &amp;gt; 0 &amp;amp;&amp;amp; (p = current) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;--&lt;span&gt;est;
                E e &lt;/span&gt;=&lt;span&gt; p.item;
                current &lt;/span&gt;=&lt;span&gt; p.next;
                action.accept(e);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (list.modCount !=&lt;span&gt; expectedModCount)
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; characteristics() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterator.ORDERED | Spliterator.SIZED |&lt;span&gt; Spliterator.SUBSIZED;
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后，再对LinkedList做一个简单的小结：&lt;/p&gt;
&lt;p&gt;　　LinkedList是由Node节点首尾相连而成的结构，相比ArrayList而言，在进行插入和删除时不需要进行大量的元素移动，省去了元素复制的开销，也不存在扩容开销，但是每次添加节点都需要创建一个新的Node对象，所以当节点数量很多时，这部分对象将占用很大开销，包括时间成本和空间成本，因此需要根据实际情况进行合理选择。LinkedList因为提供了大量方便的获取元素、插入元素和移除元素的方法，所以可以很方便的进行队列、栈等数据结构的实现。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802232039773-1825347881.png&quot; alt=&quot;&quot;/&gt;到此，LinkedList就算讲解完毕了，一不小心又写了这么长，罪过罪过。。。下次还是多分几篇写吧，这么长的文章，确实不便于阅读，面壁中。。。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201808/1043143-20180802232055289-1573515805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 02 Aug 2018 15:21:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/9388355.html</dc:identifier>
</item>
<item>
<title>C、C++字符操作归总 - 彼方的境界</title>
<link>http://www.cnblogs.com/lmg1/p/9410854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lmg1/p/9410854.html</guid>
<description>&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;strong&gt;1）字符串操作 &lt;/strong&gt;&lt;br/&gt;strcpy(p, p1) 复制字符串 &lt;br/&gt;strncpy(p, p1, n) 复制指定长度字符串 &lt;br/&gt;strcat(p, p1) 附加字符串 &lt;br/&gt;strncat(p, p1, n) 附加指定长度字符串 &lt;br/&gt;strlen(p) 取字符串长度 &lt;br/&gt;strcmp(p, p1) 比较字符串 &lt;br/&gt;strcasecmp忽略大小写比较字符串&lt;br/&gt;strncmp(p, p1, n) 比较指定长度字符串 &lt;br/&gt;strchr(p, c) 在字符串中查找指定字符 &lt;br/&gt;strrchr(p, c) 在字符串中反向查找 &lt;br/&gt;strstr(p, p1) 查找字符串 &lt;br/&gt;strpbrk(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找该集合的任一元素 &lt;br/&gt;strspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找不属于该集合的任一元素的偏移 &lt;br/&gt;strcspn(p, p1) 以目标字符串的所有字符作为集合，在当前字符串查找属于该集合的任一元素的偏移  &lt;br/&gt;* 具有指定长度的字符串处理函数在已处理的字符串之后填补零结尾符 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;2）字符串到数值类型的转换 &lt;/strong&gt;&lt;br/&gt;strtod(p, ppend) 从字符串 p 中转换 double 类型数值，并将后续的字符串指针存储到 ppend 指向的 char* 类型存储。&lt;br/&gt;strtol(p, ppend, base) 从字符串 p 中转换 long 类型整型数值，base 显式设置转换的整型进制，设置为 0 以根据特定格式判断所用进制，0x, 0X 前缀以解释为十六进制格式整型，0    前缀以解释为八进制格式整型&lt;br/&gt;atoi(p) 字符串转换到 int 整型 &lt;br/&gt;atof(p) 字符串转换到 double 符点数 &lt;br/&gt;atol(p) 字符串转换到 long 整型 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;313&quot;&gt;
&lt;p&gt;&lt;strong&gt;3）字符检查 &lt;/strong&gt;&lt;br/&gt;isalpha() 检查是否为字母字符 &lt;br/&gt;isupper() 检查是否为大写字母字符 &lt;br/&gt;islower() 检查是否为小写字母字符 &lt;br/&gt;isdigit() 检查是否为数字 &lt;br/&gt;isxdigit() 检查是否为十六进制数字表示的有效字符 &lt;br/&gt;isspace() 检查是否为空格类型字符 &lt;br/&gt;iscntrl() 检查是否为控制字符 &lt;br/&gt;ispunct() 检查是否为标点符号 &lt;br/&gt;isalnum() 检查是否为字母和数字 &lt;br/&gt;isprint() 检查是否是可打印字符 &lt;br/&gt;isgraph() 检查是否是图形字符，等效于 isalnum() | ispunct() &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）函数原型&lt;br/&gt;原型：strcpy(char destination[], const char source[]); &lt;/strong&gt;&lt;br/&gt;功能：将字符串source拷贝到字符串destination中 &lt;br/&gt;例程：  &lt;br/&gt; #include &amp;lt;iostream.h&amp;gt; &lt;br/&gt;#include &amp;lt;string.h&amp;gt; &lt;br/&gt;void main(void) &lt;br/&gt;{ &lt;br/&gt;　 char str1[10] = { &quot;TsinghuaOK&quot;}; &lt;br/&gt;　 char str2[10] = { &quot;Computer&quot;}; &lt;br/&gt;　 cout &amp;lt;&amp;lt;strcpy(str1,str2)&amp;lt;&amp;lt;endl; &lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;运行结果是:Computer &lt;br/&gt;第二个字符串将覆盖掉第一个字符串的所有内容！ &lt;br/&gt;注意：在定义数组时，字符数组1的字符串长度必须大于或等于字符串2的字符串长度。不能用赋值语句将一个字符串常量或字符数组直接赋给一个字符数组。所有字符串处理函数都包含在头文件string.h中。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;strncpy(char destination[], const char source[], int numchars);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;strncpy：将字符串source中前numchars个字符拷贝到字符串destination中。 &lt;br/&gt;strncpy函数应用举例 &lt;br/&gt;原型：strncpy(char destination[], const char source[], int numchars); &lt;br/&gt;功能：将字符串source中前numchars个字符拷贝到字符串destination中 &lt;br/&gt;例程： &lt;/p&gt;
&lt;p&gt;#include &amp;lt;iostream.h&amp;gt; &lt;br/&gt;#include &amp;lt;string.h&amp;gt; &lt;br/&gt;void main(void) &lt;br/&gt;{ &lt;br/&gt;　 char str1[10] = { &quot;Tsinghua &quot;}; &lt;br/&gt;　 char str2[10] = { &quot;Computer&quot;}; &lt;br/&gt;　 cout &amp;lt;&amp;lt;strncpy(str1,str2,3)&amp;lt;&amp;lt;endl; &lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;运行结果：Comnghua &lt;br/&gt;注意：字符串source中前numchars个字符将覆盖掉字符串destination中前numchars个字符！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型：strcat(char target[], const char source[]); &lt;/strong&gt;&lt;br/&gt;功能：将字符串source接到字符串target的后面 &lt;br/&gt;例程： &lt;br/&gt;#include &amp;lt;iostream.h&amp;gt; &lt;br/&gt;#include &amp;lt;string.h&amp;gt; &lt;br/&gt;void main(void) &lt;br/&gt;{ &lt;br/&gt;　 char str1[] = { &quot;Tsinghua &quot;}; &lt;br/&gt;　 char str2[] = { &quot;Computer&quot;}; &lt;br/&gt;　 cout &amp;lt;&amp;lt;strcpy(str1,str2)&amp;lt;&amp;lt;endl; &lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;运行结果：Tsinghua Computer&lt;/p&gt;
&lt;p&gt;注意：在定义字符数组1的长度时应该考虑字符数组2的长度，因为连接后新字符串的长度为两个字符串长度之和。进行字符串连接后，字符串1的结尾符将自动被去掉，在结尾串末尾保留新字符串后面一个结尾符。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原型：strncat(char target[], const char source[], int numchars); &lt;/strong&gt;&lt;br/&gt;功能：将字符串source的前numchars个字符接到字符串target的后面 &lt;br/&gt;例程：&lt;/p&gt;
&lt;p&gt;#include &amp;lt;iostream.h&amp;gt; &lt;br/&gt;#include &amp;lt;string.h&amp;gt; &lt;br/&gt;void main(void) &lt;br/&gt;{ &lt;br/&gt;　 char str1[] = { &quot;Tsinghua &quot;}; &lt;br/&gt;　 char str2[] = { &quot;Computer&quot;}; &lt;br/&gt;　 cout &amp;lt;&amp;lt;strncat(str1,str2,3)&amp;lt;&amp;lt;endl; &lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;运行结果：Tsinghua Com&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;原型：int strcmp(const char firststring[], const char secondstring[]); &lt;/strong&gt;&lt;br/&gt;功能：比较两个字符串firststring和secondstring &lt;br/&gt;例程： &lt;/p&gt;
&lt;p&gt;#include &amp;lt;iostream.h&amp;gt; &lt;br/&gt;#include &amp;lt;string.h&amp;gt; &lt;br/&gt;void main(void) &lt;br/&gt;{ &lt;br/&gt;　 char buf1[] = &quot;aaa&quot;; &lt;br/&gt;　 char buf2[] = &quot;bbb&quot;; &lt;br/&gt;　 char buf3[] = &quot;ccc&quot;; &lt;br/&gt;　 int ptr;  &lt;br/&gt;　 ptr = strcmp(buf2,buf1);  &lt;br/&gt;　 if(ptr &amp;gt; 0) &lt;br/&gt;　　 cout &amp;lt;&amp;lt;&quot;Buffer 2 is greater than buffer 1&quot;&amp;lt;&amp;lt;endl; &lt;br/&gt;　 else  &lt;br/&gt;　　 cout &amp;lt;&amp;lt;&quot;Buffer 2 is less than buffer 1&quot;&amp;lt;&amp;lt;endl; &lt;br/&gt;　 ptr = strcmp(buf2,buf3);  &lt;br/&gt;　 if(ptr &amp;gt; 0) &lt;br/&gt;　　 cout &amp;lt;&amp;lt;&quot;Buffer 2 is greater than buffer 3&quot;&amp;lt;&amp;lt;endl; &lt;br/&gt;　 else  &lt;br/&gt;　　 cout &amp;lt;&amp;lt;&quot;Buffer 2 is less than buffer 3&quot;&amp;lt;&amp;lt;endl; &lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;运行结果是:Buffer 2 is less than buffer 1  &lt;br/&gt;                  Buffer 2 is greater than buffer 3&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;原型：strlen( const char string[] ); &lt;/strong&gt;&lt;br/&gt;功能：统计字符串string中字符的个数 &lt;br/&gt;例程： &lt;/p&gt;
&lt;p&gt;#include &amp;lt;iostream.h&amp;gt; &lt;br/&gt;#include &amp;lt;string.h&amp;gt; &lt;br/&gt;void main(void) &lt;br/&gt;{ &lt;br/&gt;  char str[100];  &lt;br/&gt;  cout &amp;lt;&amp;lt;&quot;请输入一个字符串:&quot;; &lt;br/&gt;  cin &amp;gt;&amp;gt;str; &lt;br/&gt;  cout &amp;lt;&amp;lt;&quot;The length of the string is :&quot;&amp;lt;&amp;lt;strlen(str)&amp;lt;&amp;lt;&quot;个&quot;&amp;lt;&amp;lt;endl; &lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;运行结果The length of the string is x (x为你输入的字符总数字)&lt;/p&gt;
&lt;p&gt;注意：strlen函数的功能是计算字符串的实际长度，不包括'\0'在内。另外，strlen函数也可以直接测试字符串常量的长度，如：strlen(&quot;Welcome&quot;)。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;void *memset(void *dest, int c, size_t count);  &lt;/strong&gt;&lt;br/&gt;将dest前面count个字符置为字符c.  返回dest的值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;void *memmove(void *dest, const void *src, size_t count);  &lt;/strong&gt;&lt;br/&gt;从src复制count字节的字符到dest. 如果src和dest出现重叠, 函数会自动处理.  返回dest的值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;void *memcpy(void *dest, const void *src, size_t count);  &lt;/strong&gt;&lt;br/&gt;从src复制count字节的字符到dest. 与memmove功能一样, 只是不能处理src和dest出现重叠.  返回dest的值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;void *memchr(const void *buf, int c, size_t count);  &lt;/strong&gt;&lt;br/&gt;在buf前面count字节中查找首次出现字符c的位置. 找到了字符c或者已经搜寻了count个字节, 查找即停止. 操作成功则返回buf中首次出现c的位置指针, 否则返回NULL. &lt;/p&gt;
&lt;p&gt;void *_memccpy(void *dest, const void *src, int c, size_t count);  &lt;br/&gt;从src复制0个或多个字节的字符到dest. 当字符c被复制或者count个字符被复制时, 复制停止. &lt;/p&gt;
&lt;p&gt;如果字符c被复制, 函数返回这个字符后面紧挨一个字符位置的指针. 否则返回NULL. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int memcmp(const void *buf1, const void *buf2, size_t count);  &lt;/strong&gt;&lt;br/&gt;比较buf1和buf2前面count个字节大小.  &lt;br/&gt;返回值&amp;lt; 0, 表示buf1小于buf2;  &lt;br/&gt;返回值为0, 表示buf1等于buf2;  &lt;br/&gt;返回值&amp;gt; 0, 表示buf1大于buf2. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int memicmp(const void *buf1, const void *buf2, size_t count); &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比较buf1和buf2前面count个字节. 与memcmp不同的是, 它不区分大小写. &lt;/p&gt;
&lt;p&gt;返回值同上. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strrev(char *string);  &lt;/strong&gt;&lt;br/&gt;将字符串string中的字符顺序颠倒过来. NULL结束符位置不变.  返回调整后的字符串的指针. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *_strupr(char *string);  &lt;/strong&gt;&lt;br/&gt;将string中所有小写字母替换成相应的大写字母, 其它字符保持不变.  返回调整后的字符串的指针. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *_strlwr(char *string);  &lt;/strong&gt;&lt;br/&gt;将string中所有大写字母替换成相应的小写字母, 其它字符保持不变.  返回调整后的字符串的指针. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strchr(const char *string, int c);  &lt;/strong&gt;&lt;br/&gt;查找字  串string中首次出现的位置, NULL结束符也包含在查找中.  返回一个指针, 指向字符c在字符串string中首次出现的位置, 如果没有找到, 则返回NULL. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strrchr(const char *string, int c);  &lt;/strong&gt;&lt;br/&gt;查找字符c在字符串string中最后一次出现的位置, 也就是对string进行反序搜索, 包含NULL结束符.  &lt;br/&gt;返回一个指针, 指向字符c在字符串string中最后一次出现的位置, 如果没有找到, 则返回NULL. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strstr(const char *string, const char *strSearch);  &lt;/strong&gt;&lt;br/&gt;在字符串string中查找strSearch子串.  返回子串strSearch在string中首次出现位置的指针. 如果没有找到子串strSearch, 则返回NULL. 如果子串strSearch为空串, 函数返回string值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strdup(const char *strSource);  &lt;/strong&gt;&lt;br/&gt;函数运行中会自己调用malloc函数为复制strSource字符串分配存储空间, 然后再将strSource复制到分配到的空间中. 注意要及时释放这个分配的空间. &lt;br/&gt;返回一个指针, 指向为复制字符串分配的空间; 如果分配空间失败, 则返回NULL值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strcat(char *strDestination, const char *strSource);  &lt;/strong&gt;&lt;br/&gt;将源串strSource添加到目标串strDestination后面, 并在得到的新串后面加上NULL结束符. 源串strSource的字符会覆盖目标串strDestination后面的结束符NULL. 在字符串的复制或添加过程中没有溢出检查, 所以要保证目标串空间足够大. 不能处理源串与目标串重叠的情况.  函数返回strDestination值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strncat(char *strDestination, const char *strSource, size_t count); &lt;/strong&gt;&lt;br/&gt;将源串strSource开始的count个字符添加到目标串strDest后. 源串strSource的字符会覆盖目标串strDestination后面的结束符NULL. 如果count大于源串长度, 则会用源串的长度值替换count值. 得到的新串后面会自动加上NULL结束符. 与strcat函数一样, 本函数不能处理源串与目标串重叠的情况. 函数返回strDestination值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strcpy(char *strDestination, const char *strSource);  &lt;/strong&gt;&lt;br/&gt;复制源串strSource到目标串strDestination所指定的位置, 包含NULL结束符. 不能处理源串与目标串重叠的情况.函数返回strDestination值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strncpy(char *strDestination, const char *strSource, size_t count);&lt;/strong&gt;&lt;br/&gt;将源串strSource开始的count个字符复制到目标串strDestination所指定的位置. 如果count值小于或等于strSource串的长度, 不会自动添加NULL结束符目标串中, 而count大于strSource串的长度时, 则将strSource用NULL结束符填充补齐count个字符, 复制到目标串中. 不能处理源串与目标串重叠的情况.函数返回strDestination值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strset(char *string, int c);  &lt;/strong&gt;&lt;br/&gt;将string串的所有字符设置为字符c, 遇到NULL结束符停止. 函数返回内容调整后的string指针. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strnset(char *string, int c, size_t count);  &lt;/strong&gt;&lt;br/&gt;将string串开始count个字符设置为字符c, 如果count值大于string串的长度, 将用string的长度替换count值. 函数返回内容调整后的string指针. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size_t strspn(const char *string, const char *strCharSet);  &lt;/strong&gt;&lt;br/&gt;查找任何一个不包含在strCharSet串中的字符 (字符串结束符NULL除外) 在string串中首次出现的位置序号.  返回一个整数值, 指定在string中全部由characters中的字符组成的子串的长度. 如果string以一个不包含在strCharSet中的字符开头, 函数将返回0值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;size_t strcspn(const char *string, const char *strCharSet);  &lt;/strong&gt;&lt;br/&gt;查找strCharSet串中任何一个字符在string串中首次出现的位置序号, 包含字符串结束符NULL.  &lt;br/&gt;返回一个整数值, 指定在string中全部由非characters中的字符组成的子串的长度. 如果string以一个包含在strCharSet中的字符开头, 函数将返回0值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strspnp(const char *string, const char *strCharSet);  &lt;/strong&gt;&lt;br/&gt;查找任何一个不包含在strCharSet串中的字符 (字符串结束符NULL除外) 在string串中首次出现的位置指针. 返回一个指针, 指向非strCharSet中的字符在string中首次出现的位置. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strpbrk(const char *string, const char *strCharSet);&lt;/strong&gt;&lt;br/&gt;查找strCharSet串中任何一个字符在string串中首次出现的位置, 不包含字符串结束符NULL.  &lt;br/&gt;返回一个指针, 指向strCharSet中任一字符在string中首次出现的位置. 如果两个字符串参数不含相同字符, 则返回NULL值. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int strcmp(const char *string1, const char *string2);  &lt;/strong&gt;&lt;br/&gt;比较字符串string1和string2大小.  &lt;br/&gt;返回值&amp;lt; 0, 表示string1小于string2;  &lt;br/&gt;返回值为0, 表示string1等于string2;  &lt;br/&gt;返回值&amp;gt; 0, 表示string1大于string2. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int stricmp(const char *string1, const char *string2);  &lt;/strong&gt;&lt;br/&gt;比较字符串string1和string2大小，和strcmp不同, 比较的是它们的小写字母版本.返回值与strcmp相同. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int strcmpi(const char *string1, const char *string2);  &lt;/strong&gt;&lt;br/&gt;等价于stricmp函数, 只是提供一个向后兼容的版本. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int strncmp(const char *string1, const char *string2, size_t count);  &lt;/strong&gt;&lt;br/&gt;比较字符串string1和string2大小，只比较前面count个字符. 比较过程中, 任何一个字符串的长度小于count, 则count将被较短的字符串的长度取代. 此时如果两串前面的字符都相等, 则较短的串要小. &lt;br/&gt;返回值&amp;lt; 0, 表示string1的子串小于string2的子串;  &lt;br/&gt;返回值为0, 表示string1的子串等于string2的子串;  &lt;br/&gt;返回值&amp;gt; 0, 表示string1的子串大于string2的子串. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int strnicmp(const char *string1, const char *string2, size_t count); &lt;/strong&gt;&lt;br/&gt;比较字符串string1和string2大小，只比较前面count个字符. 与strncmp不同的是, 比较的是它们的小写字母版本.  返回值与strncmp相同. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;char *strtok(char *strToken, const char *strDelimit);  &lt;/strong&gt;&lt;br/&gt;在strToken 串中查找下一个标记, strDelimit字符集则指定了在当前查找调用中可能遇到的分界符. 返回一个指针, 指向在strToken中找到的下一个标记. 如果找不到标记, 就返回NULL值. 每次调用都会修改strToken内容, 用NULL字符替换遇到的每个分界符.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;252&quot;&gt;
&lt;p&gt;&lt;strong&gt;c++概念字符串操作 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、char_traits 字符特征类 &lt;/strong&gt;&lt;br/&gt;1）意义：包装特定串元素的通用行为界面，以便容器实现时依据特征信息而执行特定行为 &lt;br/&gt;2）定义了通用类型名 &lt;/p&gt;
&lt;p&gt;typedef _Elem char_type; &lt;br/&gt;typedef int int_type; &lt;br/&gt;typedef streampos pos_type; &lt;br/&gt;typedef streamoff off_type; &lt;br/&gt;typedef mbstate_t state_type; &lt;/p&gt;
&lt;p&gt;其中 int_type 表示字符元素转换到特定编码时的整型表示，pos_type, off_type 分别作为字符串索引和字符串元素偏移的类型，类似容器迭中的指针，迭代类型和指针，迭代器的偏移类型。最后的 state_type 用于存储流状态，如出错，格式控制等等。 &lt;/p&gt;
&lt;p&gt;3）定义了字符 / 字符串操作的包装界面，以便通用算法的调用 &lt;/p&gt;
&lt;p&gt;assign(a, b) 定义将 b 字符赋值给 a 字符的过程，实现 a.operator = 的行为 &lt;br/&gt;eq(a, b) 定义 a 字符和 b 字符的相等关系，实现 a.operator == 的行为 &lt;br/&gt;lt(a, b) 定义 a 小于 b 的关系，实现 a.operator &amp;lt; 的行为 &lt;br/&gt;compare(a_ptr, b_ptr, cnt) 定义两组字符串的比较，返回 int 类型，实现类似 memcmp 的行为 &lt;br/&gt;length(ptr) 定义取字符串长度，实现类似 strlen 的行为 &lt;br/&gt;copy(a_ptr, b_ptr, cnt) 定义两组字符串的复制，实现类似 memcpy 的行为 &lt;br/&gt;move(a_ptr, b_ptr, cnt) 定义两组字符串的不重叠复制，实现类似 memmove 的行为 &lt;br/&gt;assign(ptr, cnt, ch) 定义了填充字符串的过程，实现类似 memset 的行为 &lt;br/&gt;to_int_type(ch) 定义了 char_type 到 int_type 整型的转换过程 &lt;br/&gt;to_char_type(n) 定义了 int_type 到 char_type 字符型的转换过程 &lt;br/&gt;eq_int_type(a, b) 定义两个和当前 char_type 类型对应的 int_type 的相等关系 &lt;br/&gt;eof() 定义字符串结尾符，使用整型表示 &lt;br/&gt;not_eof(n) 定义非字符串结尾符，若输入结尾符，则返回 1，其他输入返回原值，即总是不返回 eof() &lt;/p&gt;
&lt;p&gt;4）int_type 类型应是当前字符类型的整型编码 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、std::string 并不是序列容器&lt;/strong&gt;，没有 front() 和 back() 界面用于取出前端和尾端的元素，使用 std::string::operator [] 并传递 streampos 类型取得特定元素，如 std::string::size() - 1 作为索引取得最后一个字符 &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;三、basic_string 支持的初始化 &lt;/strong&gt;&lt;br/&gt;1）默认初始化 &lt;br/&gt;2）分配器 &lt;br/&gt;3）复制构造 &lt;br/&gt;4）局部复制 [_Roff, _Roff + _Count) &lt;br/&gt;5）局部复制 + 分配器 &lt;br/&gt;6）C 字符串 [_Ptr, &amp;lt;null&amp;gt;) &lt;br/&gt;7）C 字符串 + _Count [_Ptr, _Ptr + _Count) &lt;br/&gt;8）C 字符串 + 分配器 &lt;br/&gt;9）C 字符串 + _Count + 分配器 [_Ptr, _Ptr + _Count)&lt;/p&gt;
&lt;p&gt;10）_Count * _Ch &lt;br/&gt;11）_Count * _Ch + 分配器 &lt;br/&gt;12）迭代器 [_ItF, _ItL) &lt;br/&gt;13）迭代器 + 分配器 &lt;/p&gt;
&lt;p&gt;字符到串不能初始化，但支持 operator = 赋值和 operator += 累加赋值运算。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、字符串的区间有效性 &lt;/strong&gt;&lt;br/&gt;对串的索引访问在超过字符串的有效区间时，因为串的在实现上对内置的字符缓冲区执行下标访问，所以不会导致异常，但是将得到不可预知的结果，通常是不可用的。&lt;br/&gt;将其他字符串作为右值输入时，对该串取出计数大于串大小时按串大小计算。 &lt;br/&gt;std::basic_string::size_type 的实际类型为 size_t，在 Visual C++ 7.1 中实现为 unsigned，std::basic_string::npos 被静态设定为 &lt;/p&gt;
&lt;p&gt;(basic_string&amp;lt;_Elem, _Traits, _Alloc&amp;gt;::size_type)(-1); &lt;/p&gt;
&lt;p&gt;在查找子字符串等操作时，函数返回 npos 的值表示非法索引。 &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;五、比较字符串 &lt;/strong&gt;&lt;br/&gt;允许的比较对象 &lt;br/&gt;1）compare(s2) 其他同类型字符串 &lt;br/&gt;2）compare(p) C 风格字符串 &lt;br/&gt;3）compare(off, cnt, s2) [off, off + cnt) 同 s2 执行比较 &lt;br/&gt;4）compare(off, cnt, s2, off2, cnt2) [off, off + cnt) 同 s2 [off2, cnt2) 执行比较 &lt;br/&gt;5）compare(off, cnt, p) [off, off + cnt) 同 [p , &amp;lt;null&amp;gt;) 执行比较 &lt;br/&gt;6）compare(off, cnt, p, cnt2) [off, off + cnt) 同 [p, p + cnt2) 执行比较 &lt;/p&gt;
&lt;p&gt;返回 -1, 0, 1 作为小于、等于和大于的比较结果。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 六、附加数据 &lt;/strong&gt;&lt;br/&gt;1）使用 operator += 接受其他字符串，C 风格字符串和字符 &lt;br/&gt;2）使用 push_back() 在尾部附加字符，并使得通过字符串构造的 back_iterator 可以访问 &lt;br/&gt;3）append() 附加 &lt;br/&gt;        1、append(s) 追加字符串 &lt;br/&gt;        2、append(s, off, cnt) 追加字符串 s [off, off + cnt) &lt;br/&gt;        3、append(p) 追加字符串 [p, &amp;lt;null&amp;gt;) &lt;br/&gt;        4、append(p, cnt) 追加字符串 [p, p + cnt) &lt;br/&gt;        5、append(n, c) 填充 n * c &lt;br/&gt;        6、append(InF, InL) 追加输入流 [InF, InL) &lt;/p&gt;
&lt;p&gt;4）insert() 插入 &lt;br/&gt;        1、insert(off, s2) 插入字符串 &lt;br/&gt;        2、insert(off, s2, off2, cnt2) 插入字符串 s [off2, off2 + cnt2) &lt;br/&gt;        3、insert(off, p) 插入字符串 [p, &amp;lt;null&amp;gt;) &lt;br/&gt;        4、insert(off, p, cnt) 插入字符串 [p, p + cnt)&lt;/p&gt;
&lt;p&gt;        5、insert(off, n, c) 插入 n * c &lt;br/&gt;        6、insert(iter) 元素默认值填充 &lt;br/&gt;        7、insert(iter, c) 插入特定元素 &lt;br/&gt;        8、insert(iter, n, c) 插入 n*c &lt;br/&gt;        9、insert(iter, InF, InL) 插入 [InF, InL) &lt;/p&gt;
&lt;p&gt;5）operator +(a, b) &lt;br/&gt;字符串关联运算符重载中支持 operator + 的形式 &lt;br/&gt;        1、s + s &lt;br/&gt;        2、s + p &lt;br/&gt;        3、s + c &lt;br/&gt;        4、p + s &lt;br/&gt;        5、c + s &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;七、查找、替换和清除 &lt;/strong&gt;&lt;br/&gt;1）find() 查找 &lt;br/&gt;        1、find(c, off) 在 s [off, npos) 中查找 c &lt;br/&gt;        2、find(p, off, n) 在 s [off, npos) 中查找 [p, p + n) &lt;br/&gt;        3、find(p, off) 在 s [off, npos) 中查找 [p, &amp;lt;null&amp;gt;) &lt;br/&gt;        4、find(s2, off) 在 s [off, npos) 中查找 s2 &lt;/p&gt;
&lt;p&gt;2）find() 的变种 &lt;br/&gt;        1、rfind() 具有 find() 的输入形式，反序查找 &lt;br/&gt;        2、find_first_of() 具有 find() 的输入形式，返回第一个匹配的索引 &lt;br/&gt;        3、find_last_of() 具有 find() 的输入形式，返回倒数第一个匹配的索引 &lt;br/&gt;        4、find_first_not_of() 具有 find() 的输入形式，返回第一个不匹配的索引 &lt;br/&gt;        5、find_last_not_of() 具有 find() 的输入形式，返回倒数第一个不匹配的索引 &lt;/p&gt;
&lt;p&gt;3）replace() 替换 &lt;br/&gt;        1、replace(off, cnt, s2) 将 s [off, off + cnt) 替换成 s2 &lt;br/&gt;        2、replace(off, cnt, s2, off2, cnt2) 将 s [off, off + cnt) 替换成 s2 [off2, off2 + cnt2)&lt;br/&gt;        3、replace(off, cnt, p) 将 s [off, off + cnt) 替换成 [p, &amp;lt;null&amp;gt;) &lt;br/&gt;        4、replace(off, cnt, p, cnt2) 将 s [off, off + cnt) 替换成 [p, p + cnt2)&lt;/p&gt;
&lt;p&gt;        5、replace(off, cnt, n, c) 将 s [off, off + cnt) 替换成 c * n &lt;/p&gt;
&lt;p&gt;使用迭代器的情况： &lt;br/&gt;        6、replace(InF, InL, s2) 将 [InF, InL) 替换成 s2 &lt;br/&gt;        7、replace(InF, InL, p) 将 [InF, InL) 替换成 [p, &amp;lt;null&amp;gt;) &lt;br/&gt;        8、replace(InF, InL, p, cnt) 将 [InF, InL) 替换成 [p, p + cnt) &lt;br/&gt;        9、replace(InF, InL, n, c) 将 [InF, InL) 替换成 n * c &lt;br/&gt;        10、replace(InF, InL, InF2, InL2) 将 [InF, InL) 替换成 [InF2, InL2) &lt;/p&gt;
&lt;p&gt;4）erase() 删除 &lt;br/&gt;        1、erase(off, cnt) 从字符串 s 中删除 s [off, off + cnt) &lt;br/&gt;        2、erase(iter) 从字符串 s 中删除 *iter &lt;br/&gt;        3、erase(ItF, ItL) 从字符串 s 中删除 [ItF, ItL) &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;八、取出字符串 &lt;/strong&gt;&lt;br/&gt;1）取得 C 风格字符串 &lt;br/&gt;c_str() 返回常量类型的 C 风格字符串指针，copy(ptr, cnt, off = 0) 则将指定大小的字符串复制到特定指针。data() 在 Visual C++ 7.1 中仅仅调用了 c_str() 实现。 &lt;br/&gt;2）取得子字符串 &lt;br/&gt;substr(off, cnt) 取得 s [off, off + cnt) 的副本。  &lt;br/&gt;3）复制子字符串 &lt;br/&gt;copy(p, off, cnt) 将 s [off, off + cnt) 复制到 p。 &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;九、字符串的缓冲区管理 &lt;/strong&gt;&lt;br/&gt;字符串具有类似 std::vector 的缓冲区管理界面。  &lt;br/&gt;size() 取得有效元素长度 &lt;br/&gt;max_size() 取得当前内存分配器能分配的有效空间 &lt;br/&gt;reserve() 为缓冲区预留空间 &lt;br/&gt;capacity() 取得缓冲区的容量 &lt;br/&gt;resize() 重设串的长度，可以为其指定初始化值 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  十、定义输入迭代器的尾端 &lt;/strong&gt;&lt;br/&gt;向 istream_iterator 传递输入流对象以创建输入迭代器，输入迭代器持有输入流对象的指针，默认创建和读取流失败的情况下该指针被设置为 0。并且在实现输入迭代器间的 operator == 相等运算时，进行持有的流对象指针的相等比较，这样，默认创建的输入迭代器将被用于匹配输入流的结束。 &lt;/p&gt;
&lt;p&gt;* 当输入流读取失败，用户执行 if, while 条件判断时，实际上先将判断值转换成 void* 类型，或者根据 operator ! 运算符的返回结果，对输入流重载 operator void* 和 operator ! 运算符，可以定义输入流在布尔表达式中的行为，使得当流读取失败的情况下，输入迭代器可以通过布尔表达式来确认，而不是显式访问 fail() 成员函数. &lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 02 Aug 2018 15:20:00 +0000</pubDate>
<dc:creator>彼方的境界</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lmg1/p/9410854.html</dc:identifier>
</item>
<item>
<title>Ubuntu的显示问题不全解决 - 肥沃源头活水</title>
<link>http://www.cnblogs.com/linxin1314/p/9410847.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linxin1314/p/9410847.html</guid>
<description>&lt;p&gt;首先我们安装的是Ubuntu 16.04版本。最开始一直不能解分辨率问题，导致信息显示不全&lt;/p&gt;
&lt;p&gt;利用&lt;span&gt;xrandr -s 1369x768(中间x是乘号不是英文字母)&lt;/span&gt; 命令来设置分辨率，&lt;/p&gt;
&lt;p&gt;需注意的是：&lt;/p&gt;
&lt;p&gt;1、他只是临时的，当重启虚拟机的时候，他会恢复到原始分辨率&lt;/p&gt;
&lt;p&gt;2、如果不知道客户机支持的分辨率可以使用 xrandr 会弹出他所有适应的分辨率值，可以拷贝&lt;/p&gt;
</description>
<pubDate>Thu, 02 Aug 2018 15:19:00 +0000</pubDate>
<dc:creator>肥沃源头活水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linxin1314/p/9410847.html</dc:identifier>
</item>
<item>
<title>Deepin深度Linux系统安装记录 - 兄弟要花吗</title>
<link>http://www.cnblogs.com/editwe/p/9410835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/editwe/p/9410835.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;测试设备：小米游戏本，最新版15.6进入安装后发现黑屏，所以使用15.5安装&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;下载后得到文件夹&lt;code&gt;15.5 Release&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将里面的ISO镜像文件，使用2345之类的虚拟光驱挂载&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftvqelcqioj30v90gwwew.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.前往&lt;code&gt;计算机&lt;/code&gt;打开刚刚文件加载的光驱&lt;br/&gt;- 打开DEEPIN_S.EXE安装程序，按自己需求设定密码、语言、硬盘和容量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftvqgggynmj30v90gw763.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.点击安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1ftvqipxwokj308y0dzt8j.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.完成后显示需要关闭快速启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftvqjo32c6j308y0dzt8n.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.前往控制面板关闭快速启动并保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1ftvqke7i8ij30v90hmdg3.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.重启，并在BIOS加载时按F12键进入BootManger&lt;br/&gt;- 选择Deepin入口回车&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftvqldb045j31411hc0ye.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8.进入后有个5s倒计时，进入安装的意思，在显示安装成功前不需要任何操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1ftvqmv6k96j31411hc0u4.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftvqo12q5wj31hc141425.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装需要十分钟&lt;/li&gt;
&lt;li&gt;完成显示安装成功&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftvqoqdwzej31hc141wj4.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击&lt;code&gt;立即体验&lt;/code&gt;按钮是重启，在加载BIOS时F12选择Deepin启动&lt;br/&gt;9.安装完成后的启动会出现列表&lt;/li&gt;
&lt;li&gt;选择第一个进入&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1ftvqqn379aj31hd1hcae1.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入密码即可登录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1ftvqr0qsdcj31hc1410we.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;10.其他&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;鼠标移动速度太快，但是设置里修改速度依然不理想&lt;/li&gt;
&lt;li&gt;使用还有待研究&lt;/li&gt;
&lt;li&gt;关机在这里&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1ftvqta4lv6j31am0q6npd.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1ftvqthujfgj31hc0u0189.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;11.卸载Deepin系统&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Win10中找到Deepin系统安装盘符，进入deepin文件夹，运行&lt;code&gt;uninstall.exe&lt;/code&gt;选择卸载，再将deepin文件夹删除&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 02 Aug 2018 15:16:00 +0000</pubDate>
<dc:creator>兄弟要花吗</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/editwe/p/9410835.html</dc:identifier>
</item>
<item>
<title>HTTP 各种特性应用（二） - 本心依然</title>
<link>http://www.cnblogs.com/zhangtaotqy/p/9410828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangtaotqy/p/9410828.html</guid>
<description>&lt;h2&gt;一、Cookie&lt;/h2&gt;
&lt;p&gt;通过 Set-Cookie 设置、 下次浏览器请求就会带上、 键值对，可以设置多个。&lt;/p&gt;
&lt;p&gt;Cookie 属性&lt;/p&gt;
&lt;p&gt;max-age 和 expires 设置过期时间&lt;/p&gt;
&lt;p&gt;Secure 只在 https 的时候发送&lt;/p&gt;
&lt;p&gt;HttpOnly 无法通过  document.cookie 访问&lt;/p&gt;
&lt;p&gt;server.js 代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; http = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; fs = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

http.createServer(function (request, response) {
  console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;request come&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, request.url)

  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request.url === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; html = fs.readFileSync(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    response.writeHead(&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;, {
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Set-Cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id=123; max-age=2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc=456;domain=test.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    })
    response.end(html)
  }

}).listen(&lt;/span&gt;&lt;span&gt;8888&lt;/span&gt;&lt;span&gt;)

console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;server listening on 8888&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;test.html 代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Content&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  console.log(document.cookie)
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请求结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201808/1071925-20180802224920830-1053340040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201808/1071925-20180802225002608-697656449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201808/1071925-20180802225011618-394687058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、 HTTP 长连接&lt;/h2&gt;
&lt;p&gt;server.js &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; http = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; fs = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

http.createServer(function (request, response) {
  console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;request come&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, request.url)

  &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; html = fs.readFileSync(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; img = fs.readFileSync(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request.url === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
    response.writeHead(&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;, {
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    })
    response.end(html)
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    response.writeHead(&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;, {
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;image/jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Connection&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;keep-alive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; or close&lt;/span&gt;
&lt;span&gt;    })
    response.end(img)
  }

}).listen(&lt;/span&gt;&lt;span&gt;8888&lt;/span&gt;&lt;span&gt;)

console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;server listening on 8888&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;test.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;ie=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Document&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test1.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test2.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test3.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test4.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test5.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test6.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test7.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test11.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test12.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test13.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test14.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test15.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test16.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test17.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test111.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test112.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test113.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test114.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test115.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test116.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;/test117.jpg&quot;&lt;/span&gt;&lt;span&gt; alt&lt;/span&gt;&lt;span&gt;=&quot;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;test.jpg&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201808/1071925-20180802231057320-1869387986.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 请求运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1071925/201808/1071925-20180802231319801-1121651388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 02 Aug 2018 15:15:00 +0000</pubDate>
<dc:creator>本心依然</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangtaotqy/p/9410828.html</dc:identifier>
</item>
<item>
<title>【java爬虫】---爬虫+基于接口的网络爬虫 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9386207.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9386207.html</guid>
<description>&lt;p&gt;         上一篇讲了&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/qdhxhz/p/9338834.html&quot;&gt;【java爬虫】---爬虫+jsoup轻松爬博客&lt;/a&gt;，该方式有个很大的局限性，就是你通过jsoup爬虫只适合爬静态网页，所以只能爬当前页面的所有新闻。如果需要爬一个网&lt;/p&gt;
&lt;p&gt;站所有信息，就得通过接口，通过改变参数反复调该网站的接口，爬到该网站的所有数据信息。&lt;/p&gt;
&lt;p&gt;         本博客以爬金色财经新闻信息为对象，去爬取该网站从建站以来发表的所有新闻信息。下面会一步一步讲解。这里重点重点讲思路，最后我会提供完整源码。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;第一步：找接口&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;     你要获得该网站所有新闻数据，第一步当然是获得接口，通过接口来获取所有信息。&lt;/p&gt;
&lt;p&gt;     F12--&amp;gt;Network--&amp;gt;all，找到接口：https://api.jinse.com/v4/information/list?catelogue_key=news&amp;amp;&lt;span&gt;limit=23&lt;/span&gt;&amp;amp;&lt;span&gt;information_id=56630&lt;/span&gt;&amp;amp;&lt;span&gt;flag=down&lt;/span&gt;&amp;amp;version=9.9.9&lt;/p&gt;
&lt;p&gt;    对这三个参数做个说明：&lt;span&gt;limit=23&lt;/span&gt;   代表每次调用该接口返回23条数据。&lt;/p&gt;
&lt;p&gt;                                          &lt;span&gt;information_id=56630&lt;/span&gt;  代表下面返回的23条数据是通过大于56630或者小于56630这个ID指来返回数据。&lt;/p&gt;
&lt;p&gt;                                          &lt;span&gt;flag=down&lt;/span&gt;   代表向下翻页 这里也就是指ID小于56630的23条数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 通过postMan测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  输入：https://api.jinse.com/v4/information/list?catelogue_key=news&amp;amp;&lt;span&gt;limit=2&lt;/span&gt;&amp;amp;&lt;span&gt;information_id=0&lt;/span&gt;&amp;amp;flag=down&amp;amp;version=9.9.9（这里返回两条，id=0这里代表最新的两条数据）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回json数据格式：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bb6dcef2-8b3a-4511-ba06-38d85a30f542')&quot; readability=&quot;60&quot;&gt;&lt;img id=&quot;code_img_closed_bb6dcef2-8b3a-4511-ba06-38d85a30f542&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bb6dcef2-8b3a-4511-ba06-38d85a30f542&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bb6dcef2-8b3a-4511-ba06-38d85a30f542',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bb6dcef2-8b3a-4511-ba06-38d85a30f542&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;115&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;news&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 2&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 2&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: null,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 58300&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bottom_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 58325&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 58300&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;跨越牛熊的摆渡人：看金融IT服务如何助力加密货币交易&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;short_title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当传统金融IT服务商进入加密货币时代&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 1&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 0,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: false,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;extra&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9.9.9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;存量资金与投资者日渐枯竭，如何获取新用户和新资金入场，成为大小交易所都在考虑的问题。而交易深度有限、流动性和行情稳定性不佳，也成为横亘在牛熊之间的一道障碍。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;published_at&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 1532855806&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;临渊&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author_avatar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://img.jinse.com/753430_image20.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 127939&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author_level&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 1&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read_number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 27064&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read_number_yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.7万&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thumbnail_pic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://img.jinse.com/996033_image1.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thumbnails_pics&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://img.jinse.com/996033&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                ],
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thumbnail_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 1&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;金色财经&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;topic_url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://m.jinse.com/news/blockchain/219916.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;attribute_exclusive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;attribute_depth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;深度&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;attribute_spread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
            }
        },
        {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 58325&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;各路大佬怎样看待区块链：技术新武器应寻找新战场&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;short_title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;各路大佬怎样看待区块链：技术新武器应寻找新战场&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 1&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 0,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is_top&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: false,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;extra&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9.9.9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;summary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;今年年初由区块链社区引发的讨论热潮,成为全民一时热议的话题,罕有一项技术,能像区块链这样——在其应用还未大范围铺开、被大众直观感知时,就搅起舆论风暴,扰动民众情绪。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;published_at&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 1532853425&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新浪财经&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author_avatar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://img.jinse.com/581794_image20.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author_id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 94556&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;author_level&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 5&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read_number&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 33453&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;read_number_yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.3万&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thumbnail_pic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://img.jinse.com/995994_image1.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thumbnails_pics&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://img.jinse.com/995994&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                ],
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thumbnail_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 1&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;新浪财经&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;topic_url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://m.jinse.com/blockchain/219934.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;attribute_exclusive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;attribute_depth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;attribute_spread&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
            }
        }
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;接口返回信息&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;第二步：通过定时任务开启爬虫工作&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Slf4j
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SchedulePressTrigger {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CrawlerJinSeLivePressService crawlerJinSeLivePressService;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
    * 定时抓取金色财经的新闻
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Scheduled(initialDelay &lt;/span&gt;= 1000, fixedRate = 600 * 1000&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doCrawlJinSeLivePress() {

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  log.info(&quot;开始抓取金色财经新闻, time:&quot; + new Date());&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            crawlerJinSeLivePressService.start();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  log.error(&quot;本次抓取金色财经新闻异常&quot;, e);&lt;/span&gt;
&lt;span&gt;        }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  log.info(&quot;结束抓取金色财经新闻, time:&quot; + new Date());&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;第三步：主要实现类&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 抓取金色财经快讯
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; xub
 * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 2018/6/29
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Slf4j
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CrawlerJinSeLivePressServiceImpl &lt;span&gt;extends&lt;/span&gt; AbstractCrawlLivePressService &lt;span&gt;implements&lt;/span&gt;&lt;span&gt;
        CrawlerJinSeLivePressService {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个参数代表每一次请求获得多少个数据&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PAGE_SIZE = 15&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个是真正翻页参数，每一次找id比它小的15个数据（有写接口是通过page=1，2来进行翻页所以比较好理解一点，其实它们性质一样）&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; bottomId;


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个这里没有用到，但是如果有数据层，就需要用到，这里我只是把它答应到控制台&lt;/span&gt;
&lt;span&gt;    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; LivePressService livePressService;
    
    
    
    &lt;/span&gt;&lt;span&gt;//定时任务运行这个方法，doTask没有被重写，所有运行父类的方法&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            doTask(CoinPressConsts.CHAIN_FOR_LIVE_PRESS_DATA_URL_FORMAT);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  log.error(&quot;抓取金色财经新闻异常&quot;, e);&lt;/span&gt;
&lt;span&gt;        }
    }


    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; List&amp;lt;PageListPress&amp;gt; crawlPage(&lt;span&gt;int&lt;/span&gt; pageNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最多抓取100页，多抓取也没有特别大的意思。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (pageNum &amp;gt;= 100&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyList();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 格式化翻页参数（第一次bottomId为0，第二次就是这次爬到的最小bottomId值）&lt;/span&gt;
        String requestUrl =&lt;span&gt; String.format(CoinPressConsts.CHAIN_FOR_LIVE_PRESS_DATA_URL_FORMAT, PAGE_SIZE, bottomId);&lt;br/&gt;Response response &lt;/span&gt;=&lt;span&gt; OkHttp.singleton().newCall(
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Request.Builder().url(requestUrl).addHeader(&quot;referer&quot;&lt;span&gt;, CoinPressConsts.CHAIN_FOR_LIVE_URL).get().build())
                .execute();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (response.isRedirect()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果请求发生了跳转，说明请求不是原来的地址了，返回空数据。&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyList();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先获得json数据格式&lt;/span&gt;
        String responseText =&lt;span&gt; response.body().string();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在通过工具类进行数据赋值&lt;/span&gt;
       &lt;strong&gt;&lt;span&gt; JinSePressResult jinSepressResult = JsonUtils.objectFromJson(responseText, JinSePressResult.class);
        &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; jinSepressResult) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反序列化失败&lt;/span&gt;
            System.out.println(&quot;抓取金色财经新闻列表反序列化异常&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Collections.emptyList();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取金色财经最小的记录id，来进行翻页&lt;/span&gt;
        bottomId =&lt;span&gt; jinSepressResult.getBottomId();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个是谷歌提供了guava包里的工具类，Lists这个集合工具，对list集合操作做了些优化提升。&lt;/span&gt;
        List&amp;lt;PageListPress&amp;gt; pageListPresss =&lt;span&gt; Lists.newArrayListWithExpectedSize(PAGE_SIZE);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (JinSePressResult.DayData dayData : jinSepressResult.getList()) {
            JinSePressData data &lt;/span&gt;=&lt;span&gt; dayData.getExtra();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新闻发布时间（时间戳格式）这里可以来判断只爬多久时间以内的新闻&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt;   createTime = data.getPublishedAt() * 1000&lt;span&gt;;
            Long timemill&lt;/span&gt;=&lt;span&gt;System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;           if (System.currentTimeMillis() - createTime &amp;gt; CoinPressConsts.MAX_CRAWLER_TIME) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 快讯过老了，放弃
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;               continue;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;           }&lt;/span&gt;
            SimpleDateFormat sdf=&lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;span&gt;);
            String sd &lt;/span&gt;= sdf.format(&lt;span&gt;new&lt;/span&gt; Date(createTime));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 时间戳转换成时间&lt;/span&gt;
            Date newsCreateTime=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得新闻发布时间&lt;/span&gt;
                newsCreateTime =&lt;span&gt; sdf.parse(sd);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParseException e) {
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;strong&gt;&lt;span&gt;//具体文章页面路径（这里可以通过这个路径+jsoup就可以爬新闻正文所有信息了）&lt;/span&gt;&lt;/strong&gt;
            String href =&lt;span&gt; data.getTopicUrl();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新闻摘要&lt;/span&gt;
            String summary =&lt;span&gt; data.getSummary();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新闻阅读数量&lt;/span&gt;
            String pressreadcount =&lt;span&gt; data.getReadNumber();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新闻标题&lt;/span&gt;
            String title =&lt;span&gt; dayData.getTitle();

                pageListPresss.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PageListPress(href,title, Integer.parseInt(pressreadcount),
                        newsCreateTime ,  summary));
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pageListPresss;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;AbstractCrawlLivePressService 类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbstractCrawlLivePressService {
    String url;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doTask(String url) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.url =&lt;span&gt; url;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pageNum = 1&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过 while (true)会一直循环调取接口，直到数据为空或者时间过老跳出循环&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            List&lt;/span&gt;&amp;lt;PageListPress&amp;gt; newsList = crawlPage(pageNum++&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抓取不到新的内容本次抓取结束&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(newsList)) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }    
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里并没有把数据放到数据库，而是直接从控制台输出&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = newsList.size() - 1; i &amp;gt;= 0; i--&lt;span&gt;) {
                PageListPress pageListNews &lt;/span&gt;=&lt;span&gt; newsList.get(i);
                System.out.println(pageListNews.toString());
          
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个由具体实现类实现&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; List&amp;lt;PageListPress&amp;gt; crawlPage(&lt;span&gt;int&lt;/span&gt; pageNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException;

&lt;span&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PageListPress {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新闻详情页面url&lt;/span&gt;
         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String href;
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新闻标题&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String title;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新闻阅读数量&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; readCounts;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新闻发布时间&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date createTime;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新闻摘要&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String summary;
    
        }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;JinSePressResult &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *在创建对象的时候一定要分析好json格式的类型
 *金色新闻的返回格式就是第一层有普通属性和一个list集合
 *在list集合中又有普通属性和一个extra的对象。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@JsonIgnoreProperties(ignoreUnknown &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; JinSePressResult {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; news;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
    @JsonProperty(&lt;/span&gt;&quot;top_id&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; topId;
    @JsonProperty(&lt;/span&gt;&quot;bottom_id&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; bottomId;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;list的名字也要和json数据的list名字一致，否则无用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;DayData&amp;gt;&lt;span&gt; list;

    @Data
    @JsonIgnoreProperties(ignoreUnknown &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DayData {

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String title;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里对象的属性名extra也要和json的extra名字一致&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; JinSePressData extra;
        @JsonProperty(&lt;/span&gt;&quot;topic_url&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String topicUrl;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这里需要注意两点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;  （1）在创建对象时一定要先搞清楚json格式类型是对象里含有集合，或者集合中还有对象等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;（2） 你可以只定义你需要的属性字段，当你不能和json的属性名一致但类型不一致。比如上面你改成 List extra 这个时候序列化就会失败，因为json的extra明显是一个对象，而这边接受的确实一个集合。关键是属&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;性名一致&lt;/span&gt;&lt;span&gt; 所以在赋值的时候就会报错，序列化失败。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;第四步：看运行结果&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;   这里只是截取控制台输出的部分信息，通过这种方式可以获得该网站的所有新闻信息。同时我们已经获得具体新闻的URL，那么我们就可以通过JSOup来获取该新闻的所有具体信息。（完美）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201807/1090617-20180729213803221-743970421.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;第五步：数据库去重思路&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;   因为你不可能每一次爬取玩数据都直接放到数据库中，肯定要比较该条新闻数据库中是否已经存在，不存在才放到数据库中。思路如下：&lt;/p&gt;
&lt;p&gt;   （1）数据库表中添加一个能辨别该新闻唯一的属性字段，比如jinse+bottomId组成唯一属性，或者该新闻具体页面路径URI组成唯一属性。&lt;/p&gt;
&lt;p&gt;   （2）创建map&amp;lt;URL，Boolean&amp;gt;集合，通过URI看数据库是否存在，有就&amp;lt;URL，true&amp;gt;,没有&amp;lt;URL，flase&amp;gt;。&lt;/p&gt;
&lt;p&gt;   （3）在存储之前通过map.get（URI）如果为false则存储数据库中。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Git源码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 首先说明下，源码本人是通过Idea测试运行通过，这里用了lombok，你需要现在idea或者eclipse配置Lombok。&lt;/p&gt;
&lt;p&gt; 源码地址：&lt;a href=&quot;https://github.com/yudiandemingzi/panjiekou&quot; target=&quot;_blank&quot;&gt;https://github.com/yudiandemingzi/panjiekou&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;想太多，做太少，中间的落差就是烦恼。想没有烦恼，要么别想，要么多做。中校【9】&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Aug 2018 15:13:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9386207.html</dc:identifier>
</item>
<item>
<title>Docker 简单部署 ElasticSearch - 简玄冰</title>
<link>http://www.cnblogs.com/jianxuanbing/p/9410800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jianxuanbing/p/9410800.html</guid>
<description>&lt;p&gt;Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。&lt;br/&gt;不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式的实时文件存储，每个字段都被索引并可被搜索&lt;/li&gt;
&lt;li&gt;分布式的实时分析搜索引擎&lt;/li&gt;
&lt;li&gt;可以扩展到上百台服务器，处理PB级结构化或非结构化数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;拉取镜像&quot;&gt;2.1 拉取镜像&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;docker pull docker.elastic.co/elasticsearch/elasticsearch:6.3.2&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运行容器&quot;&gt;2.2 运行容器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ElasticSearch&lt;/code&gt;的默认端口是9200，我们把宿主环境9200端口映射到&lt;code&gt;Docker&lt;/code&gt;容器中的9200端口，就可以访问到&lt;code&gt;Docker&lt;/code&gt;容器中的&lt;code&gt;ElasticSearch&lt;/code&gt;服务了，同时我们把这个容器命名为&lt;code&gt;es&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:6.3.2&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置跨域&quot;&gt;2.3 配置跨域&lt;/h2&gt;
&lt;h3 id=&quot;进入容器&quot;&gt;2.3.1 进入容器&lt;/h3&gt;
&lt;p&gt;由于要进行配置，因此需要进入容器当中修改相应的配置信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker exec -it es /bin/bash&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;进行配置&quot;&gt;2.3.2 进行配置&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# 显示文件
ls
结果如下：
LICENSE.txt  README.textile  config  lib   modules
NOTICE.txt   bin             data    logs  plugins

# 进入配置文件夹
cd config

# 显示文件
ls
结果如下：
elasticsearch.keystore  ingest-geoip  log4j2.properties  roles.yml  users_roles
elasticsearch.yml       jvm.options   role_mapping.yml   users

# 修改配置文件
vi elasticsearch.yml

# 加入跨域配置
http.cors.enabled: true
http.cors.allow-origin: &quot;*&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;重启容器&quot;&gt;2.3 重启容器&lt;/h2&gt;
&lt;p&gt;由于修改了配置，因此需要重启&lt;code&gt;ElasticSearch&lt;/code&gt;容器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker restart es&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;展示如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/534030/201808/534030-20180802225429612-1324370884.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为什么要安装&lt;code&gt;ElasticSearch-Head&lt;/code&gt;呢，原因是需要有一个管理界面进行查看&lt;code&gt;ElasticSearch&lt;/code&gt;相关信息&lt;/p&gt;
&lt;h2 id=&quot;拉取镜像-1&quot;&gt;3.1 拉取镜像&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;docker pull mobz/elasticsearch-head:5&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运行容器-1&quot;&gt;3.2 运行容器&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d --name es_admin -p 9100:9100 mobz/elasticsearch-head:5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;展示如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/534030/201808/534030-20180802225531963-1621975.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/534030/201808/534030-20180802225452815-1012955236.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/534030/201808/534030-20180802225515507-1387981373.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/534030/201808/534030-20180802225507521-535389532.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，我们就完成了用Docker提供Elasticsearch服务，而不污染宿主机环境了，这样还有一个好处，如果想同时启动多个不同版本的Elastcsearch或者其他服务，Docker也是一个理想的解决方案。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Aug 2018 15:07:00 +0000</pubDate>
<dc:creator>简玄冰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jianxuanbing/p/9410800.html</dc:identifier>
</item>
<item>
<title>javascript基础修炼(2)——What's this(上) - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9410495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9410495.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;开发者的javascript造诣取决于对【动态】和【异步】这两个词的理解水平。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201807/30/cd1ce376258ab732cceb2a360bfb1552.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;一.this是什么&quot;&gt;一.this是什么&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;是javascript关键字之一，是javascript能够实现&lt;strong&gt;面向对象编程&lt;/strong&gt;的核心概念。用得好能让代码优雅高端，风骚飘逸，用不好也绝对是坑人坑己利器。我们常常会在一些资料中看到对&lt;code&gt;this&lt;/code&gt;的描述是:&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;是一个特殊的与&lt;strong&gt;Execution Contexts&lt;/strong&gt;相关的对象,用于指明当前代码执行时的&lt;strong&gt;Execution Contexts&lt;/strong&gt;，&lt;code&gt;this&lt;/code&gt;在语句执行进入一个&lt;strong&gt;Execution Contexts&lt;/strong&gt;时被赋值，且在代码执行过程中不可再改变。&lt;br/&gt;注：&lt;strong&gt;Execution Contexts&lt;/strong&gt;也就是我们常听到的&lt;strong&gt;&quot;上下文&quot;&lt;/strong&gt;或&lt;strong&gt;&quot;执行环境&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看不懂？看不懂就对了，我也看不懂。&lt;br/&gt;对于&lt;code&gt;this&lt;/code&gt;的指向，我们常会听到这样一个原则——&lt;strong&gt;this是一个指针，指向当前调用它的对象&lt;/strong&gt;。但实际使用中，我们却发现有时候很难知道&lt;strong&gt;当前调用它&lt;/strong&gt;的是哪个对象，从而引发了一系列的误用和奇怪现象。&lt;/p&gt;
&lt;p&gt;今天，我们就换一种思路，试试如何从语言的角度一步一步地去理解&lt;code&gt;this&lt;/code&gt;,你会发现：&lt;br/&gt;&lt;strong&gt;只要你能听懂中国话，就意味着你能理解this&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;二.近距离看this&quot;&gt;二.近距离看this&lt;/h3&gt;
&lt;h4 id=&quot;this的语法意义&quot;&gt;2.1 this的语法意义&lt;/h4&gt;
&lt;p&gt;javascript是一门&lt;strong&gt;程序设计语言&lt;/strong&gt;,也就是说，它是一种&lt;strong&gt;语言&lt;/strong&gt;，是语言，就有语法特性。如果抛开&lt;code&gt;this&lt;/code&gt;的原理和编程中的用法，仅从语文的层面去理解，它的本质就是&lt;code&gt;代词&lt;/code&gt;。什么是代词？汉语中的&lt;code&gt;你&lt;/code&gt;,&lt;code&gt;我&lt;/code&gt;,&lt;code&gt;他&lt;/code&gt;,&lt;code&gt;你们&lt;/code&gt;,&lt;code&gt;我们&lt;/code&gt;,&lt;code&gt;他们&lt;/code&gt;这一类的词语就是代词。代词并不具体指某一个具体的事物，但结合上下文，就可以知道这类词语代替的是谁。&lt;br/&gt;比如下面这几句描述的语境:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;他&lt;/strong&gt;大爷是赵本山
&lt;ul&gt;&lt;li&gt;&lt;em&gt;请问：谁大爷是赵本山？&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;没法回答，因为没有上下文约束，此处的&lt;strong&gt;他&lt;/strong&gt;可能指任何人。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;李雷来头可不小，&lt;strong&gt;他&lt;/strong&gt;大爷是赵本山
&lt;ul&gt;&lt;li&gt;&lt;em&gt;请问：谁大爷是赵本山？&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;很容易回答，因为前一句话使得我们能够得知当前上下文中，&lt;strong&gt;&quot;他&quot;&lt;/strong&gt;指的就是&lt;strong&gt;&quot;李雷&quot;&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;___来头可不小，&lt;strong&gt;他&lt;/strong&gt;大爷是赵本山
&lt;ul&gt;&lt;li&gt;&lt;em&gt;请问：谁大爷是赵本山？&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;此处空格填谁，谁大爷就是赵本山。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;小结一下：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;代词，用于指代某个具体事物，当结合上下文时，就可以知道其具体的指向。换句话说，有了上下文时，代词就有了具体的意义。&lt;code&gt;this&lt;/code&gt;在javascript语言中的意义，就如同&lt;code&gt;代词&lt;/code&gt;在汉语中的意义是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;不同作用域中的this&quot;&gt;2.2 不同作用域中的this&lt;/h4&gt;
&lt;p&gt;在ES6出现前，javascript中的作用域只分为全局作用域和函数作用域两种。(以下部分暂不讨论严格模式)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;全局作用域中使用this&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;全局作用域中的&lt;code&gt;this&lt;/code&gt;是指向&lt;code&gt;window对象&lt;/code&gt;的,但&lt;code&gt;window对象&lt;/code&gt;上却并没有&lt;code&gt;this&lt;/code&gt;这个属性：&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201807/30/2e9e5dc7546e2d508c44f839ba698e1e.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;函数作用域使用this&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;函数作用域中的&lt;code&gt;this&lt;/code&gt;也是有指向的(本例中指向&lt;code&gt;window对象&lt;/code&gt;),我们知道函数的原型链是会指向&lt;code&gt;Object&lt;/code&gt;的,所以函数本身可以被当做一个对象来看待，但遗憾的是&lt;code&gt;函数&lt;/code&gt;的原型链上也没有&lt;code&gt;this&lt;/code&gt;这个属性：&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201807/30/a2cd614be63987c591f38459e19036db.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;综上所述，&lt;code&gt;this&lt;/code&gt;可以直观地理解为:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;this与函数相关，是函数在运行时解释器自动为其赋值的一个局部常量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;javascript代码编写方式&quot;&gt;2.3 javascript代码编写方式&lt;/h4&gt;
&lt;h5 id=&quot;a.不使用this&quot;&gt;&lt;strong&gt;a.不使用&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;这是有可能发生的。很多初学者会发现，自己在编写javascript代码时并没有用到&lt;strong&gt;this&lt;/strong&gt;,但是也并不影响自己编写代码。前面提到过上下文信息的意义在于让代词明确其指向，那么如果一段话的上下文中并没有使用代词，在语文中我们就不需要联系上下文就能理解这段话;同理，如果函数的函数体中并没有使用&lt;code&gt;this&lt;/code&gt;关键字来指代任何对象，或者不需要关注其调用对象，那实际上就算不确定&lt;code&gt;this&lt;/code&gt;的指向，函数的执行过程也不会有歧义。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 *数据加工转换类的函数，对开发者来说更关注结果，而并不在乎是谁在调用。
*/
function addNumber(a,b) {
    return a + b;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论是&lt;strong&gt;计算机对象&lt;/strong&gt;调用&lt;em&gt;addNumber&lt;/em&gt;方法，或是&lt;strong&gt;算盘对象&lt;/strong&gt;调用&lt;em&gt;addNumber&lt;/em&gt;方法，甚至是&lt;strong&gt;人类对象&lt;/strong&gt;通过心算调用&lt;em&gt;addNumber&lt;/em&gt;方法，都无所谓，因为我们关注的是结果，而不是它怎么来的。&lt;/p&gt;
&lt;h5 id=&quot;b.不使用函数自带的this&quot;&gt;&lt;strong&gt;b.不使用函数自带的&lt;code&gt;this&lt;/code&gt;&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;有时候我们编写的代码是需要用到一些关于&lt;code&gt;调用对象&lt;/code&gt;的信息的，但由于不熟悉&lt;code&gt;this&lt;/code&gt;的用法，许多开发者使用了另一种变通的方式，也就是&lt;strong&gt;显式传参&lt;/strong&gt;。比如我们在一个方法中，需要打出上下文对象的名字，下面两种编写方式都是可以实现的。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//方式一.使用this
invoker.whoInvokeMe = function(){
    console.log(this.name);
}

//方式二.不使用this
function whoInvokeMe2(invoker){
    console.log(invoker.name);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式二&lt;/strong&gt;的方式并不是语法错误，可以让开发者避开了因为对&lt;code&gt;this&lt;/code&gt;关键字的误用而引发的混乱,同样也避开了&lt;code&gt;this&lt;/code&gt;所带来的对代码的抽象能力和简洁性,同时会造成一些性能上的损失，毕竟这样做会使得每次调用函数时需要处理更多的参数，而这些参数本可以通过内置的&lt;code&gt;this&lt;/code&gt;获取到。&lt;/p&gt;
&lt;h5 id=&quot;c.面向对象的编程&quot;&gt;&lt;strong&gt;c.面向对象的编程&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;提到this，必然会提到另一个词语——&lt;strong&gt;面向对象&lt;/strong&gt;。&quot;面向对象&quot;是一种编程思想,请暂时抛开&lt;strong&gt;封装&lt;/strong&gt;,&lt;strong&gt;继承&lt;/strong&gt;,&lt;strong&gt;多态&lt;/strong&gt;等高大上的修饰词带来的负担，纯粹地感受一下这种思想本身。有的人说&quot;面向对象&quot;赋予了编程一种哲学的意义，它是使用程序语言的方式对现实世界进行的一种简化抽象，现实世界的一个用户，一种策略，一个消息，某个算法，在面向对象的世界里均将其视为一个对象，也就是哲学意义上的&lt;code&gt;无分别&lt;/code&gt;,每一个对象都有其生命周期，它怎么来，要做什么，如何消亡，以及它与万物之间的联系。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;面向对象&lt;/code&gt;的思想，是用程序语言勾勒现实世界框架的方式之一，它的出现不是用来为难开发者的，而是为了让开发者能以更贴近日常生活的认知方式来提升对程序语言的理解能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;如果没有this&quot;&gt;2.4 如果没有this&lt;/h4&gt;
&lt;p&gt;我们来看一下如果javascript中不使用&lt;code&gt;this&lt;/code&gt;关键字，对程序编写会造成什么影响呢？&lt;br/&gt;我们先来编写一段简单的定义代码：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    //假设我们定义一个人的类
    function Person(name){

    }
     
    // 方法-介绍你自己(使用this编写)
    Person.prototype.introduceYourselfWithThis = function () {
        if (Object.hasOwnProperty.call(this, 'name')) {
           return `My name is ${this.name}`;
        } 
        return `I have no name`;
    }

    // 方法-介绍你自己(不使用this编写)
    Person.prototype.introduceYourself = function (invoker) {
        if (Object.hasOwnProperty.call(invoker, 'name')) {
            return `My name is ${invoker.name}`;
        }
        return `I have no name`;
    }

    //生成两个实例，并为各自的name属性赋值
    var liLei = new Person();
    liLei.name = 'liLei';
    var hanMeiMei = new Person();
    hanMeiMei.name = 'hanMeiMei';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的简单示例中，我们定义了一个不包含任何实例属性的&lt;code&gt;人&lt;/code&gt;类，并使用不同的方式为其定义&lt;strong&gt;介绍你自己&lt;/strong&gt;这个方法，第一种定义使用常规的面向对象写法，使用&lt;code&gt;this&lt;/code&gt;获取上下文对象，获取实例的&lt;code&gt;name&lt;/code&gt;属性;第二种定义不使用&lt;code&gt;this&lt;/code&gt;,而是将&lt;strong&gt;调用者名称&lt;/strong&gt;作为参数传递进方法。&lt;br/&gt;我们在控制台进行一些简单的使用：&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201807/30/d67a116faf96f8db62fea37e6fc83644.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;br/&gt;那么这两种不同的写法区别到底是什么呢？&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;&lt;strong&gt;函数实际功能的变化&lt;/strong&gt;&lt;br/&gt;从上面的示例中不难看出，当开发中不使用this时，需要开发者自行传入上下文对象，并将其以参数的形式在函数执行时传入，如果传入的&lt;em&gt;invoker&lt;/em&gt; 对象和 &lt;em&gt;this&lt;/em&gt;的指向一致，那么结果就一致，如果不一致，则会造成混乱。
&lt;ul&gt;&lt;li&gt;从编码角度来看&lt;br/&gt;&lt;code&gt;introduceYourselfWithThis()&lt;/code&gt;方法只是&lt;code&gt;introduceYourself(invoker)&lt;/code&gt;方法的特例(当this === invoker时)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;从方法的含义来看&lt;br/&gt;定义者希望实现&lt;strong&gt;自我介绍&lt;/strong&gt;功能而编写了&lt;code&gt;introduceYourself()&lt;/code&gt;方法，可是使用者在阅读到&lt;code&gt;introduceYourself()&lt;/code&gt;的源码时看到的代码表达的意义是：**我告诉你一个名字，你把它填在'My name is __'这句话中再返回给我。&lt;strong&gt;而不是一个与调用对象有着紧密联系的&lt;/strong&gt;自我介绍**动作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;画蛇添足的参数传递&lt;/strong&gt;&lt;br/&gt;在正确的使用过程中，&lt;em&gt;this&lt;/em&gt; 和 &lt;em&gt;invoker&lt;/em&gt; 的指向是一致的，形参&lt;em&gt;invoker&lt;/em&gt;的定义不仅增加了函数使用的复杂度，也增加了函数运行的负担，却没有为函数的执行带来任何新的附加信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;重复的雷同代码&lt;/strong&gt;&lt;br/&gt;如果编码中不使用&lt;code&gt;this&lt;/code&gt;,也就相当于汉语中不使用代词，那么我们就需要在每一个独立的句子中使用完整的信息。为了使&lt;code&gt;introduceYourself()&lt;/code&gt;方法能够正确的执行，我们需要在每一个实例生成后，为其绑定确切的实例方法，即：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    var liLei = new Person();
    liLei.name = 'liLei';
    //定义实例方法
    liLei.introduceYourself = function (){
        return `My name is liLei`;
    };
   
    var hanMeiMei = new Person();
    hanMeiMei.name = 'hanMeiMei';
    //定义实例方法
    hanMeiMei.introduceYourself = function (){
        return `My name is hanMeiMei`;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;即时不使用&lt;code&gt;this&lt;/code&gt;,你也不会直接陷入无法编写javascript代码的境地，只是需要将所有的定义和使用场景全部具体化, 需要手动对所有的具体功能编写具体实现，也就是&quot;面向过程&quot;的编程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;================================&lt;strong&gt;我是华丽的分割线&lt;/strong&gt;======================================&lt;/p&gt;
&lt;h4 id=&quot;轻松一刻&quot;&gt;&lt;strong&gt;【轻松一刻】&lt;/strong&gt;&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;话说赤壁之战后,一日闲来无事，孔明与刘关张三兄弟一起喝酒。孔明说，我出三道题考考各位学识修养，如何啊？三兄弟举手赞同。&lt;br/&gt;孔明：第一题，主公，赤壁之战发生在哪里？&lt;br/&gt;刘备：赤壁啊&lt;br/&gt;孔明：答对了，主公果然厉害。第二题，关将军，双方有多少人参战？&lt;br/&gt;关羽：联军5万，曹军20余万。&lt;br/&gt;孔明：答对了，关将军也是智勇双全啊。最后一题，他们分别是谁？&lt;br/&gt;张飞：我......我靠&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;愿你能够掌握&lt;code&gt;this&lt;/code&gt;，不要在自己的代码里搞出&lt;strong&gt;他们分别是谁&lt;/strong&gt;的尴尬，小心被队友活埋。&lt;/p&gt;
&lt;p&gt;================================&lt;strong&gt;我是华丽的分割线&lt;/strong&gt;======================================&lt;/p&gt;
&lt;h3 id=&quot;三.-this的一般指向规则&quot;&gt;三. this的一般指向规则&lt;/h3&gt;
&lt;p&gt;javascript中有四条关于&lt;code&gt;this&lt;/code&gt;指向的基本规则。今天，我们将一起通过&lt;strong&gt;【码农视角】&lt;/strong&gt;和&lt;strong&gt;【语文老师视角】&lt;/strong&gt;来分别解读这些规则，你会发现他们理解起来其实很自然。&lt;/p&gt;
&lt;h4 id=&quot;规则1作为函数调用时this指向全局对象&quot;&gt;规则1——作为函数调用时，this指向全局对象&lt;/h4&gt;
&lt;p&gt;浏览器中的全局对象，指的是&lt;code&gt;window&lt;/code&gt;对象。这一规则指的就是我们在全局作用域或者函数作用域中使用&lt;code&gt;function&lt;/code&gt;关键字直接声明或使用函数表达式赋值给标识符的方式创建的函数。为了在调用时在内存中找到所声明的方法，我们需要一个&lt;strong&gt;标识符&lt;/strong&gt;来指向它的位置，具名函数可以通过它的名字找到，匿名函数则需要通过标识符来找到。&lt;strong&gt;作为函数调用的实质，就是通过方法名直或标识符找到函数并执行它。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般什么样的函数我们会这样定义呢？&lt;br/&gt;就是那些不关注调用者的函数，比如上面举例的&lt;em&gt;addNumber()&lt;/em&gt;方法，&lt;strong&gt;这类函数往往是将一步或几步业务逻辑组合在一起，起一个新的名字便于管理和重用，而并不关注使用者到底是谁。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;语文老师解读版&lt;/strong&gt;：&lt;br/&gt;很好理解，当你想描述一个动作却不知道或者不关注具体是谁做的，代词就指向&lt;code&gt;有的人&lt;/code&gt;。&lt;br/&gt;比如臧克家同学在作文里写的这样：&lt;br/&gt;有的人活着，但是他已经死了;&lt;br/&gt;有的人死了，但是他还活着;&lt;br/&gt;上文中的&lt;strong&gt;他&lt;/strong&gt;指谁？指&lt;strong&gt;有的人&lt;/strong&gt;；那&lt;strong&gt;有的人&lt;/strong&gt;是谁？随便，爱谁谁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;规则2作为方法调用时this指向上下文对象&quot;&gt;规则2——作为方法调用时，this指向上下文对象&lt;/h4&gt;
&lt;p&gt;上文中我们看到函数的作用域链上是包含&lt;code&gt;Object&lt;/code&gt;对象的，所以函数可以被当做对象来理解。当函数作为对象被赋值在另一个对象的属性上时，这个对象的属性值里会保存函数的地址，因为用函数作为赋值运算的右值时是一个引用类型赋值。如果这个函数正好又是一个匿名函数，那么执行时只能通过&lt;strong&gt;对象属性&lt;/strong&gt;中记录的地址信息来找到这个函数在内存中的位置，从而执行它。所以当函数作为方法调用时，&lt;code&gt;this&lt;/code&gt;中包含的信息的本质是&lt;strong&gt;这个函数执行时是怎么被找查找到的。答案就是：通过this所指向的这个对象的属性找到的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般什么样的函数我们会这样定义呢？&lt;br/&gt;&lt;strong&gt;作为方法定义的函数，往往是另一个抽象合集的具体实现。&lt;/strong&gt;比如前例的&lt;code&gt;addNumber()&lt;/code&gt;这个方法，只是将两个数字相加这样一个抽象动作，至于是谁通过什么方式来执行这个计算过程，无所谓，它可以概括所有对象&lt;em&gt;将两个数字相加并给出结果&lt;/em&gt;这一动作。可如果它作为一个对象方法来调用时，就有了更明确的现实指向意义:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Computer.addNumber()&lt;/code&gt;表达了计算机通过软硬件联合作用而给出结果的过程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Calculator.addNumber()&lt;/code&gt;表达了计算器通过简易硬件计算给出结果的过程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Abacus.addNumber()&lt;/code&gt;表达了算盘通过加减珠子的方式给出结果的过程&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;语文老师解读版&lt;/strong&gt;：&lt;br/&gt;当你想知道一个代词具体指的是谁时，当然需要联系上下文语境进行理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;规则3作为构造函数使用时this指向生成的实例&quot;&gt;规则3——作为构造函数使用时,this指向生成的实例&lt;/h4&gt;
&lt;p&gt;作为构造函数使用，就是&lt;strong&gt;new + 构造函数名&lt;/strong&gt;的方式调用的情况。&lt;br/&gt;js引擎在调用new操作符的逻辑可以用伪代码表示为:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;new Person('liLei') = {
    //生成一个新的空对象
    var obj = {}; 
    //空对象的原型链指向构造函数的原型对象
    obj.__proto__ = Person.prototype; 
    //使用call方法执行构造函数并显式指定上下文对象为新生成的obj对象
    var result = Person.call(obj,&quot;liLei&quot;); 
    // 如果构造函数调用后返回一个对象，就return这个对象，否则return新生成的obj对象
    return typeof result === 'object'? result : obj;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;暂不考虑构造函数有返回值的情况，那么很容易就可以明白&lt;code&gt;this&lt;/code&gt;为什么指向实例了，因为类定义函数在执行的时候显式地绑定了this为&lt;code&gt;新生成的对象&lt;/code&gt;，也就是调用new操作符后得到的实例对象。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;语文老师解读版&lt;/strong&gt;：&lt;br/&gt;有些同学喜欢抄袭，抄袭这个动作可以描述为：&quot;把一份作业Copy一遍，在最后写上&lt;strong&gt;自己&lt;/strong&gt;的名字。&quot;。如果李雷是&lt;strong&gt;喜欢抄袭&lt;/strong&gt;的人之一，那么他就掌握了&quot;抄袭&quot;这个方法，那你觉得他每次抄完作业后在署名的地方应该写自己的名字&quot;李雷&quot;还是写这一类人的总称&quot;喜欢抄袭的人&quot;呢？&lt;br/&gt;&lt;strong&gt;抬杠的那个同学，我记住你了！放学别走！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;规则4使用callapplybind方法显式指定this&quot;&gt;规则4——使用call/apply/bind方法显式指定this&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;call&lt;/code&gt;/&lt;code&gt;bind&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt;这三个方法是javascript动态性的重要组成部分，后续的篇章会有详细的讲解。这里只看一下API用法，了解一下其对于this指向的影响：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;func.call(&lt;strong&gt;this&lt;/strong&gt;, arg1, arg2...)&lt;/li&gt;
&lt;li&gt;func.apply(&lt;strong&gt;this&lt;/strong&gt;, [arg1, arg2...])&lt;/li&gt;
&lt;li&gt;func.bind(&lt;strong&gt;this&lt;/strong&gt; [, arg1[, arg2[, ...]]])&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个规则很好理解，就是说函数执行时遇到函数体里有&lt;code&gt;this&lt;/code&gt;的语句都用显式指定的对象来替换。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;语文老师解读版&lt;/strong&gt;：&lt;br/&gt;就是直接告诉你下文中的代词指什么，比如：×××宪法(以下简称&quot;本法&quot;)，那读者当然就知道后面所说的&quot;本法&quot;指谁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;四.-基本规则示例&quot;&gt;四. 基本规则示例&lt;/h3&gt;
&lt;p&gt;为了更清晰地看到上面两条原则的区别，我们来看一个示例：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;        var heroIdentity = '[Function Version]Iron Man';
        
        function checkIdentity(){
            return this.heroIdentity;
        } 

        var obj = {
            name:'Tony Stark',
            heroIdentity:'[Method Version]Iron Man',
            checkIdentityFromObj:checkIdentity
        }

        function TheAvenger(name){
            this.heroIdentity = name;
            this.checkIdentityFromNew = checkIdentity;
        }

        var tony = new TheAvenger('[New Verison]Iron Man');

        
        console.log('1.直接调用方法时结果为:',checkIdentity());
        console.log('2.通过obj.checkIdentityFromObj调用同一个方法结果为：',obj.checkIdentityFromObj());
        console.log('3.new操作符生成的对象:',tony.checkIdentityFromNew());
        console.log('4.call方法显示修改this指向:',checkIdentity.call({heroIdentity:'[Call Version]Iron Man'}));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出的结果是这样的：&lt;br/&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201807/30/e8172f6720deffa8d0573c3af30c93ff.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;br/&gt;&lt;strong&gt;同一个方法，同一个&lt;/strong&gt;this&lt;strong&gt;,调用的方式不同，得到的结果也不同。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;五.-后记&quot;&gt;五. 后记&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;在基础面前，一切技巧都是浮云。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果认为明白了this的基本规则就可以为所欲为,那你就真的&lt;strong&gt;too young too simple&lt;/strong&gt;了。&lt;br/&gt;了解了&lt;strong&gt;基本指向规则&lt;/strong&gt;，只能让你在开发中自己尽可能少挖坑或者不挖坑。但是想要填别人的坑或者读懂大师级代码中简洁优雅的用法，还需要更多的修炼和反思。实际应用中许多复杂的使用场景是很难一下子搞明白&lt;code&gt;this&lt;/code&gt;的指向以及为什么要指定this的指向的。&lt;br/&gt;笔者将在&lt;strong&gt;《javascript基础修炼(3)——What's this（下）》&lt;/strong&gt;中详细讲述开发中千奇百怪的&lt;code&gt;this&lt;/code&gt;。欲知后事如何，先点个赞先吧！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文章：&lt;/strong&gt;&lt;br/&gt;[1].&lt;a href=&quot;https://www.cnblogs.com/faith3/p/6209741.html&quot;&gt;js中的new()到底做了什么&lt;/a&gt;&lt;br/&gt;[2].&lt;a href=&quot;https://www.cnblogs.com/lwhkdash/archive/2012/02/09/2344349.html&quot;&gt;ECMA-262-3 in detail. Chapter 1. Execution Contexts&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Aug 2018 14:04:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9410495.html</dc:identifier>
</item>
<item>
<title>我的AI之路 —— 从裸机搭建GPU版本的深度学习环境 - xingoo</title>
<link>http://www.cnblogs.com/xing901022/p/9410302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing901022/p/9410302.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;之前一直在CPU上跑深度学习，由于做的是NLP方向所以也能勉强忍受。最近在做图像的时候，实在是扛不住了...还好领导们的支持买个虚拟机先体验下。由于刚买的机器，环境都得自己摸索，瞎搞过很多次，也走过很多弯路，所以我就记录下从裸机安装深度学习环境的正确过程。（全程root用户哦！）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;服务器是阿里云的CentOS7.4，默认的时候选择的CUDA驱动选错了，1.5以上的tensorflow都应该选择CUDA9.0，注意不要太高，也不要太低！TF很挑剔！&lt;/p&gt;
&lt;p&gt;先来聊聊裸机里面包含什么有用的东西：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;git：好像是1.18.x的版本，记不清了&lt;/li&gt;
&lt;li&gt;python：2.7&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面就开始安装吧！&lt;/p&gt;

&lt;p&gt;我这边选择的版本是3.6.6，原则就是当前最新最稳定的大版本，以及最高的小版本。如果本机下载，可以直接去这个地址：&lt;br/&gt;https://www.python.org/ftp/python/3.6.6/&lt;br/&gt;如果是服务器下载可以使用命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://www.python.org/ftp/python/3.6.6/Python-3.6.6.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后解压缩压缩包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar zxvf Python-3.6.6.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入目录后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd Python-3.6.6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先创建python3安装目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /usr/local/python3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开始编译安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./configure --prefix=/usr/local/python3
make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改老版本的python执行文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mv /usr/bin/python /usr/bin/python_old2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建python3的软连接&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ln -s /usr/local/python3/bin/python3 /usr/bin/python&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用命令验证下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@izwz9fnfgk9709s3h9ex47z ~]# python -V
Python 3.6.6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后不要忘记增加pip3的可执行文件:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以通过pip3安装python3的模块了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@izwz9fnfgk9709s3h9ex47z ~]# pip3 -V
pip 18.0 from /usr/local/python3/lib/python3.6/site-packages/pip (python 3.6)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时python就升级完了。&lt;/p&gt;
&lt;p&gt;由于这时修改了python脚本的版本，可能对老系统的脚本有影响，所以需要修改两个脚本——&lt;code&gt;/usr/bin/yum&lt;/code&gt;、&lt;code&gt;/usr/libexec/urlgrabber-ext-down&lt;/code&gt;把对应的文件头从&lt;code&gt;#!/usr/bin/python&lt;/code&gt;修改为&lt;code&gt;#!/usr/bin/python2.7&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外，我这里用的是阿里云，python下载很多东西都很快，如果是其他的服务或者物理机，有时候需要临时指定yum源，可以使用下面的命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip3 install xxx -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考资料：https://www.cnblogs.com/idotest/p/5442173.html&lt;/p&gt;

&lt;p&gt;默认CentOS装的git是1.8版本有点陈旧，可以对它进行重装。&lt;/p&gt;
&lt;p&gt;安装之前需要先升级gcc一类的东西，按照下面的脚本过程执行即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 安装gcc相关的东西
yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel 
yum install  gcc perl-ExtUtils-MakeMaker
# 这里可以挑一个最新版本下载
wget http://ftp.gnu.org/pub/gnu/libiconv/libiconv-1.15.tar.gz
tar zxvf libiconv-1.15.tar.gz 
cd libiconv-1.15
./configure --prefix=/usr/local/libiconv
make &amp;amp;&amp;amp; make install

# 卸载之前的git
yum remove git

# 重新下载git
wget https://github.com/git/git/archive/v2.18.0.tar.gz
tar zxvf v2.18.0.tar.gz
cd git-2.18.0
make configure
./configure --prefix=/usr/local/git --with-iconv=/usr/local/libiconv
make all doc
make install install-doc install-html
echo &quot;export PATH=$PATH:/usr/local/git/bin&quot; &amp;gt;&amp;gt; /etc/bashrc
source /etc/bashrc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后重新验证一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@izwz9fnfgk9709s3h9ex47z soft]# git --version
git version 2.18.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我的开发流程是这样，我们自己有git的代码库，我本地写完代码提交到gitlab。然后从阿里云的服务器clone代码，运行。由于里面涉及到大量的图片资源，因此clone的时候有个技巧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone xxxx --depth 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定一下clone的深度，不然git会下载每一次的提交历史。如果训练的图片或者模型很多都删除或者替换掉了，就没必要下载了。&lt;/p&gt;
&lt;p&gt;参考资料：https://blog.csdn.net/z_dianjun/article/details/50819908&lt;/p&gt;

&lt;p&gt;我记得在学校的时候写过一篇手把手教你在windows安装cuda6，当时看的人还挺多。这回在linux上安装，感觉更简单了。&lt;/p&gt;
&lt;p&gt;首先去官网下载cuda的版本，如果不知道你该安装哪一个版本的CUDA，就先确定你想使用哪一个版本的tensorflow，然后去tensorflow的github里面查看configure.py这个文件：&lt;br/&gt;https://github.com/tensorflow/tensorflow/blob/3379bae787d73d6db67d66a284bd1a076b2cbdba/configure.py&lt;br/&gt;这里面有说明对应的CUDA版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_DEFAULT_CUDA_VERSION = '9.0'
_DEFAULT_CUDNN_VERSION = '7'
_DEFAULT_NCCL_VERSION = '2.2'
_DEFAULT_CUDA_COMPUTE_CAPABILITIES = '3.5,7.0'
_DEFAULT_CUDA_PATH = '/usr/local/cuda'
_DEFAULT_CUDA_PATH_LINUX = '/opt/cuda'
_DEFAULT_CUDA_PATH_WIN = ('C:/Program Files/NVIDIA GPU Computing '
                          'Toolkit/CUDA/v%s' % _DEFAULT_CUDA_VERSION)
_DEFAULT_TENSORRT_PATH_LINUX = '/usr/lib/%s-linux-gnu' % platform.machine()
_TF_OPENCL_VERSION = '1.2'
_DEFAULT_COMPUTECPP_TOOLKIT_PATH = '/usr/local/computecpp'
_DEFAULT_TRISYCL_INCLUDE_DIR = '/usr/local/triSYCL/include'
_SUPPORTED_ANDROID_NDK_VERSIONS = [10, 11, 12, 13, 14, 15]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这里需要的是9.0，注意9.0就是9.0，别以为9.2更牛逼就安装9.2，到时候一样用不了的（本篇文章当前最新的是9.2版本）。&lt;/p&gt;
&lt;p&gt;安装文件的地址在这里：&lt;br/&gt;https://developer.nvidia.com/cuda-90-download-archive&lt;/p&gt;
&lt;p&gt;按照我的系统CentOS7，我是这么选的：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_Jietu20180802-210255@2x.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以直接在服务器上执行下面的命令进行下载：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://developer.nvidia.com/compute/cuda/9.0/Prod/local_installers/cuda-repo-rhel7-9-0-local-9.0.176-1.x86_64-rpm&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载后按照官网的安装指令安装就行了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo rpm -i cuda-repo-rhel7-9-0-local-9.0.176-1.x86_64-rpm 
yum clean all
yum install cuda&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_cuda_anzhuang1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：如果之前你的及其里面装了其他版本的cuda，或者你已经安装了cuda9.2，yum里面已经缓存了9.2的安装文件，那么可以这么做，创建下面的脚本，执行&lt;code&gt;sh rpm_e.sh cuda&lt;/code&gt;移除全部的cuda安装资源，重新输入上面的三条命令安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@izwz9fnfgk9709s3h9ex47z soft]# cat rpm_e.sh 
#/bin/bash

set -x
temp_rpm=$(rpm -qa | grep $1)
for item in $temp_rpm
do
 rpm -e $item --nodeps
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成后，添加环境变量&lt;code&gt;vi /etc/profile&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export CUDA_HOME=/usr/local/cuda-9.0
export PATH=/usr/local/cuda-9.0/bin${PATH:+:${PATH}}
export LD_LIBRARY_PATH=/usr/local/cuda-9.0/lib64${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行&lt;code&gt;source /etc/profile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;再执行以下nvcc命令验证下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@izwz9fnfgk9709s3h9ex47z bin]# nvcc -V
nvcc: NVIDIA (R) Cuda compiler driver
Copyright (c) 2005-2017 NVIDIA Corporation
Built on Fri_Sep__1_21:08:03_CDT_2017
Cuda compilation tools, release 9.0, V9.0.176&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时基本的CUDA就安装完了，如果想要体验下CUDA的程序，也可以编译执行以下samples里面的代码。&lt;/p&gt;

&lt;p&gt;由于我们是搞深度学习，因此需要安装这个cuDNN，它是专门针对深度学习的库。&lt;/p&gt;
&lt;p&gt;首先登陆这个网址：https://developer.nvidia.com/rdp/cudnn-archive&lt;/p&gt;
&lt;p&gt;先要进行注册，邮箱确认，同意配合测试，填一下基本信息，然后就可以下载了。&lt;/p&gt;
&lt;p&gt;只要CUDA版本是9.0就行，我这边选择的是cuDNN v7.1。&lt;/p&gt;
&lt;p&gt;下载后传到服务器上，执行解压缩：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf cudnn-9.0-linux-x64-v7.1.tgz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后拷贝对应的文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo cp cuDNN/cuda/include/cudnn.h /usr/local/cuda/include
sudo cp cuDNN/cuda/lib64/* /usr/local/cuda/lib64&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改libcudnn.so&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#下面的操作在/usr/local/cuda/lib64/目录下进行
cd /usr/local/cuda/lib64

sudo rm -rf libcudnn.so libcudnn.so.7#删除两个符号链接；
sudo ln -s libcudnn.so.7.0.64 libcudnn.so.7
sudo ln -s libcudnn.so.7 libcudnn.so&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样cuDNN就安装完了。&lt;/p&gt;
&lt;h3 id=&quot;安装完cudnn不要忘记重启机器不然tensorflow可能会识别不到&quot;&gt;安装完cuDNN不要忘记重启机器，不然tensorflow可能会识别不到！&lt;/h3&gt;
&lt;p&gt;参考资料：https://blog.csdn.net/guoyunfei20/article/details/78191599&lt;/p&gt;

&lt;p&gt;最后照着官网的安装步骤来就行了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo pip3 install -U --pre pip setuptools wheel
sudo pip3 install -U --pre numpy scipy matplotlib scikit-learn scikit-image
sudo pip3 install -U --pre tensorflow-gpu
# sudo pip3 install -U --pre tensorflow ## CPU版本
sudo pip3 install -U --pre keras
# 如果搞图像，还需要安装cv2
sudo pip3 install -U --pre opencv-python&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他的按照自己需要的来就行了。&lt;/p&gt;
&lt;p&gt;然后打开python命令行，import一下，看看有没有错&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@izwz9fnfgk9709s3h9ex47z soft]# python
Python 3.6.6 (default, Aug  2 2018, 14:32:43) 
[GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import tensorflow as tf
&amp;gt;&amp;gt;&amp;gt; import keras
Using TensorFlow backend.
&amp;gt;&amp;gt;&amp;gt; tf.__version__
'1.10.0-rc0'
&amp;gt;&amp;gt;&amp;gt; keras.__version__
'2.2.1'
&amp;gt;&amp;gt;&amp;gt; &lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/xing901022/1187174/o_cudaanzhuang2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到里面已经有GPU参与的信息了，而且速度上明显感觉有质一般飞跃！爽！&lt;/p&gt;

&lt;p&gt;如果有不方便下载的，我这里也有所有组件的安装资源，可以去yunpan下载。&lt;/p&gt;
&lt;p&gt;https://pan.baidu.com/s/1IkgVpnn2VWUNXAFkKVlM6g&lt;/p&gt;
</description>
<pubDate>Thu, 02 Aug 2018 13:33:00 +0000</pubDate>
<dc:creator>xingoo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xing901022/p/9410302.html</dc:identifier>
</item>
</channel>
</rss>