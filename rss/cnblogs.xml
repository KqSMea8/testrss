<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>小笔记 - Kusion_Lee</title>
<link>http://www.cnblogs.com/smileL/p/9521203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smileL/p/9521203.html</guid>
<description>&lt;p&gt;动态包含与静态包含的区别：&lt;br/&gt;*include指令：&amp;lt;%@include file=&quot;&quot; %&amp;gt;，静态包含当前页面和被包含的页面，合并后产生一个servlet源码；&lt;br/&gt;*include标签: &amp;lt;jsp:include page=&quot;&quot;&amp;gt;&amp;lt;/jsp:include&amp;gt;，动态包含当前页面和被包含的页面，分别生产servlet源码和字节码，运行由tomcat进行合并输出；&lt;br/&gt;为页面响应设置中文格式：response.setContentType(&quot;text/html;charset=utf-8&quot;);&lt;/p&gt;
</description>
<pubDate>Wed, 22 Aug 2018 15:52:00 +0000</pubDate>
<dc:creator>Kusion_Lee</dc:creator>
<og:description>动态包含与静态包含的区别：*include指令：&lt;%@include file=&quot;&quot; %&gt;，静态包含当前页面和被包含的页面，合并后产生一个servlet源码；*incl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smileL/p/9521203.html</dc:identifier>
</item>
<item>
<title>python--Email提醒 - guguobao</title>
<link>http://www.cnblogs.com/guguobao/p/9521201.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guguobao/p/9521201.html</guid>
<description>&lt;h2 id=&quot;发送邮箱的协议是stmppython内置对smtp支持可以发送纯文本邮件html邮件和带附件邮件python对smtp支持有smtplib和email两个模块email负责构造邮件smtplib负责发送邮件&quot;&gt;发送邮箱的协议是STMP，python内置对SMTP支持，可以发送纯文本邮件，HTML邮件和带附件邮件。python对SMTP支持有smtplib和email两个模块，email负责构造邮件，smtplib负责发送邮件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在使用前，先申请一个163邮箱，开启SMTP功能，采用网易的电子邮件服务器smtp.163.com&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;先构造纯文本邮件&quot;&gt;先构造纯文本邮件&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from email.mime.text import MIMEText
msg = MIMEText('python爬虫运行异常','plain','utf-8')&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;构造MIMEText对象需要3个参数
&lt;ul&gt;&lt;li&gt;邮件正文&lt;/li&gt;
&lt;li&gt;MIME的subtype，传入'plain'表示纯文本，最终的MIME就是“text/plain”&lt;/li&gt;
&lt;li&gt;设置编码格式，UTF-8编码保证多语言兼容性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;下面是完整的代码&quot;&gt;下面是完整的代码&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#coding:utf-8
from email.header import Header
from email.mime.text import MIMEText
from email.utils import parseaddr, formataddr

import smtplib

def _format_addr(s):
    name, addr = parseaddr(s)
    return formataddr((Header(name, 'utf-8').encode(), addr))
#发件人地址
from_addr = 'xxxxxxxx@163.com'
#邮箱密码
password = 'pass'
#收件人地址
to_addr = 'xxxxxxxx@qq.com'
#163网易邮箱服务器地址
smtp_server = 'smtp.163.com'
#设置邮件信息
msg = MIMEText('Python爬虫运行异常，异常信息为遇到HTTP 403', 'plain', 'utf-8')
msg['From'] = _format_addr('一号爬虫 &amp;lt;%s&amp;gt;' % from_addr)
msg['To'] = _format_addr('管理员 &amp;lt;%s&amp;gt;' % to_addr)
msg['Subject'] = Header('一号爬虫运行状态', 'utf-8').encode()
#发送邮件
server = smtplib.SMTP(smtp_server, 25)
server.login(from_addr, password)
server.sendmail(from_addr, [to_addr], msg.as_string())
server.quit()&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 22 Aug 2018 15:51:00 +0000</pubDate>
<dc:creator>guguobao</dc:creator>
<og:description>发送邮箱的协议是STMP，python内置对SMTP支持，可以发送纯文本邮件，HTML邮件和带附件邮件。python对SMTP支持有smtplib和email两个模块，email负责构造邮件，smtp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guguobao/p/9521201.html</dc:identifier>
</item>
<item>
<title>Linux MySQL 8.0 忘记密码 - itabel</title>
<link>http://www.cnblogs.com/it-abel/p/9521186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/it-abel/p/9521186.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不小忘了MySQL的密码，按照书上和网上的内容都没能修改成功，终于在借鉴了多篇文章成功之后找到原因，修改密码成功，特此分享&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;修改-mysql-密码&quot;&gt;修改 MySQL 密码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;第一步：关闭 MySQL 进程&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;systemctl stop mysqld
service mysqld stop
/etc/init.d/mysql stop
kill PID
#以选一个方法即可&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第二步：配置 /etc/my.cnf 跳过权限表认证直接登录&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# 在【mysqld】模块添加：skip-grant-tables   保存退出
[mysqld]
skip-grant-table&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第三步：重启 MySQL 服务，登录进入&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;systemctl start mysqld
service mysqld start
/etc/init.d/mysql start
#以上选一个方法即可&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第四步：刷新权限表，使得权限认证重新生效&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;flush privileges&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;注意网上很多文章都没有该步骤这样是不正确的会报错的如下图&quot;&gt;注意：网上很多文章都没有该步骤，这样是不正确的，会报错的，如下图：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itlyb.com/uploads/markdown/20180822-233637-711.png&quot;/&gt;&lt;br/&gt;正确应该如下图（新版 MySQL 密码需要设置复杂一些至少8位）：&lt;br/&gt;&lt;img src=&quot;http://www.itlyb.com/uploads/markdown/20180822-233409-346.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最后：不要忘了把 /etc/my.cnf 修改回来，重启&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 22 Aug 2018 15:43:00 +0000</pubDate>
<dc:creator>itabel</dc:creator>
<og:description>不小忘了MySQL的密码，按照书上和网上的内容都没能修改成功，终于在借鉴了多篇文章成功之后找到原因，修改密码成功，特此分享</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/it-abel/p/9521186.html</dc:identifier>
</item>
<item>
<title>MySQL之数据库基本操作 - xiezh</title>
<link>http://www.cnblogs.com/xiezh-it/p/9521134.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiezh-it/p/9521134.html</guid>
<description>&lt;h2&gt;&lt;span&gt;一、创建数据库&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;MySQL中创建数据库的SQL语法格式为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;CREATE DATABASE 数据库名;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中，数据库名不能与已经存在的数据库同名。下图创建数据库test_db：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1462578/201808/1462578-20180822232548673-303306669.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以通过使用以下语句查看数据库的定义：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;SHOW CREATE DATABASE 数据库名(\G);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中，“\G”表示格式化输出，可加可不加。如下图所示： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1462578/201808/1462578-20180822232630223-1942312151.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以使用以下如何查看当前所有存在的数据库：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;SHOW DATABASES;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1462578/201808/1462578-20180822232712754-92178596.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、删除数据库&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;MySQL中删除数据库的SQL语法格式为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;DROP DATABASE 数据库名;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如下图所示，将test_db数据库删除： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1462578/201808/1462578-20180822232756342-1844079819.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将数据库删除之后，再查看该数据库的定义，则会报错：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1462578/201808/1462578-20180822232811861-1104983916.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;备注：&lt;/strong&gt;&lt;/span&gt;注意在使用删除数据库命令时要谨慎，因为在执行该命令时MySQL不会给出任何提醒确认信息，删除数据库之后，数据库中存储的所有数据表和数据都将一同被删除，并且无法恢复。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Aug 2018 15:30:00 +0000</pubDate>
<dc:creator>xiezh</dc:creator>
<og:description>一、创建数据库 MySQL中创建数据库的SQL语法格式为： 其中，数据库名不能与已经存在的数据库同名。下图创建数据库test_db： 可以通过使用以下语句查看数据库的定义： 其中，“\G”表示格式化输</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiezh-it/p/9521134.html</dc:identifier>
</item>
<item>
<title>知识碎片 - 木言成反</title>
<link>http://www.cnblogs.com/muyanchengfan/p/9521097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/muyanchengfan/p/9521097.html</guid>
<description>&lt;p&gt;这部分内容没有固定主题，不定期更新，都是些零碎的，我觉得有必要记一笔的知识。希望能对其他人也有所帮助。&lt;/p&gt;

&lt;h2 id=&quot;sklearn.feature_selection-里的-f_regression&quot;&gt;sklearn.feature_selection 里的 F_regression&lt;/h2&gt;
&lt;p&gt;特征选择方法众多，sklearn 的特征选择模块里给出了几种非常简易高效的方法。针对回归问题，sklearn 给出了两种方法，其中一种是 F_regression 引起了我的注意。F_regression 在 sklearn 里只有寥寥几句的介绍，好在源码简短易读。之前搜了搜网上其它对这个函数的解读，要么解释不全，要么干脆是错的，所以我就在这里详细讲讲。&lt;/p&gt;

&lt;p&gt;先放源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1431650/201808/1431650-20180822225704674-1559724031.png&quot; width=&quot;500&quot; height=&quot;500&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;/&gt;&lt;/p&gt;

&lt;p&gt;F_regression 在干什么？一句话就能讲清楚：每个特征 X 单独拎出来和 Y 计算相关系数，并排序。特征选择就是基于 X 和 Y 的相关程度。&lt;/p&gt;
&lt;p&gt;当然实际操作还是分了三步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;计算相关系数；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转化为 F score；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算 p 值；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后排名是根据 F score，可以选择输出 p 值。&lt;/p&gt;
&lt;p&gt;一步一步讲。相关系数最不用谈，就是 Y 与 X 线性关系的度量。计算完相关系数还不够，这里的相关系数严格来说是样本相关系数，如何从样本推论到总体呢？这就需要做假设检验，对未知参数提出某种假设，利用样本提供的信息对提出的假设进行检验，根据检验结果对提出的假设做出拒绝或接受的判断。参照线性回归的假设检验形式，在此我们提出的假设（零假设）为 X 与 Y 不存在线性关系，即 &lt;span class=&quot;math inline&quot;&gt;\(\beta = 0\)&lt;/span&gt;。提出零假设后，我们需要去计算 p 值，p 值即零假设成立的情况下所得到的样本观察结果或更极端结果出现的概率。如果 p 值足够小，我们就能拒绝零假设，从而认为 X 与 Y 存在线性关系。&lt;/p&gt;
&lt;p&gt;注意到相关系数和 R 平方的关系，两者在简单线性回归，即只有一个变量的情形下是等价的。&lt;/p&gt;
&lt;p&gt;这种方法的缺陷一目了然，就是完全忽略了其它特征的影响，实际用的时候还需谨慎。我一般会参照 p 值，设定一个显著性水平，低于显著性水平的特征全部舍弃。或者舍弃排名最靠后的，而不是取排名靠前的。&lt;/p&gt;
</description>
<pubDate>Wed, 22 Aug 2018 15:21:00 +0000</pubDate>
<dc:creator>木言成反</dc:creator>
<og:description>这部分内容没有固定主题，不定期更新，都是些零碎的，我觉得有必要记一笔的知识。希望能对其他人也有所帮助。   sklearn.feature_selection 里的 F_regression</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/muyanchengfan/p/9521097.html</dc:identifier>
</item>
<item>
<title>Spring之Bean的注入 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/9508805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/9508805.html</guid>
<description>&lt;p&gt;Bean的配置中介绍的是Bean声明问题，在哪声明怎么声明的问题。Bean的注入是怎么实例化，怎么注入的问题。Bean注入的方式有两种，一种是在XML中配置，另一种则是使用注解的方式注入。&lt;/p&gt;
&lt;p&gt;一、XML方式注入&lt;/p&gt;
&lt;p&gt;XML方式注入一般有三种方式：属性注入、构造函数注入和工厂方法注入。&lt;/p&gt;
&lt;p&gt;一、属性注入&lt;br/&gt;在传统的对象实例化时可以通过new class()，然后通过setXXX()方法设置对象的属性值或依赖对象，属性注入也是采用这种方式，只是Spring框架会在内部完成这些操作，它会先调用Bean的默认构造函数实例化Bean对象，然后通过反射的方式调用Setter方法注入属性值。它会使用默认的构造函数(无参数构造函数)，只需为注入的属性设置set方法，可选择性和灵活性比较高，所以也是比较常用的一种注入方式。这里示例还是在IOC章节使用人和空气的基础上稍作修改来演示。IAir接口和CleanAir、DirtyAir类不变，这里就不贴了。&lt;/p&gt;
&lt;p&gt;1.新建XMLInstance类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_bba4654b-a5a1-4ddb-80fe-e3c654dd5339&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bba4654b-a5a1-4ddb-80fe-e3c654dd5339&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bba4654b-a5a1-4ddb-80fe-e3c654dd5339&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; XMLInstance {
    
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IAir air;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAir(IAir air) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.air =&lt;span&gt; air;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Breath()
    {
        System.out.println(&lt;/span&gt;&quot;Name:&quot;+&lt;span&gt;this&lt;/span&gt;.name+&quot;;Air:&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.air.toString());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; XMLInstance(String name, IAir air) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.air =&lt;span&gt; air;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; XMLInstance() {
        
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DestoryMethod()
    {
        System.out.println(&lt;/span&gt;&quot;DestoryMethod&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitMethod()
    {
        System.out.println(&lt;/span&gt;&quot;InitMethod&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;在XMLInstance类中并未声明构造函数，对于air属性只设置了set方法，get方法也没设置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;CleanAir&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.CleanAir&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;qualifier &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;cleanair&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; 
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;xmlinstance&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.XMLInstance&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;air&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;CleanAir&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;abc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Xml中使用property类配置属性，name是属性名，value用来设置基本数据类型的属性值。Spring配置文件中bean之间可以相互引用，引用时可以用&amp;lt;ref&amp;gt;标签配置bean的id属性使用。&amp;lt;ref&amp;gt;可以用在&amp;lt;property&amp;gt;属性中，也可以用在&amp;lt;construct-arg&amp;gt;构造函数的参数值，还可以用在其他地方,通过引用能减少bean的声明。&lt;/p&gt;
&lt;p&gt;二、构造函数注入&lt;br/&gt;在属性注入时先使用默认的构造函数(无参数构造函数)实例化，然后通过set方法注入属性，在传统实例化对象时可以自定义构造函数进行实例化，构造函数注入就是通过自定义构造函数来进行对象的实例化。这里在XMLInstance类的基础上增加了一个构造函数，第一个参数是String类型的name,第二个参数是IAir类型的air。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; XMLInstance(String name, IAir air) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.air =&lt;span&gt; air;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Xml中使用使用&amp;lt;construect-arg&amp;gt;来设置构造函数的参数，index属性设置参数的顺序，参数顺序应该与构造函数的一致，ref设置引用bean的id，value设置构造函数参数的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;xmlcontructinstance&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.XMLInstance&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;CleanAir&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constructor-arg &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;abc&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constructor-arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、工厂方法注入&lt;br/&gt;工厂方法注入参考的是工厂设计模式，通过在工厂类中实现对象的实例化。工厂类负责创建一个或多个目标类实例，工厂类方法一般以接口或抽象类变量的形式返回目标类实例，工厂类对外屏蔽了目标类的实例化步骤，调用者甚至不用知道具体的目标类是什么。工厂方法也分静态工厂方法和非静态工厂方法，静态工厂方式不用实例化工厂类，直接通过类名调用，非静态工厂方法需要先实例化工厂类，然后通过工厂类对象调用获取对象。这里创建了一个工厂类XMLFactory，在类中定义了一个静态方法，和一个实例方法用来实例化bean对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; XMLFactory {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; XMLInstance CreateInstance()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; XMLInstance(&quot;instance&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CleanAir());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; XMLInstance CreateStaticInstance()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; XMLInstance(&quot;static instance&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CleanAir());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.静态工厂方法&lt;br/&gt;只需设置工厂方法对应的类，以及对应的工厂方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&quot;xmlfactorystaticinstance&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.demo.model.XMLFactory&quot; factory-method=&quot;CreateStaticInstance&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.实例工厂方法&lt;br/&gt;需要先实例化工厂类，再通过工厂类对象调用实例方法获取bean对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;bean id=&quot;xmlfactoryinstance&quot; factory-bean=&quot;xmlfactory&quot; factory-method=&quot;CreateInstance&quot; destroy-method=&quot;DestoryMethod&quot; init-method=&quot;InitMethod&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、常见数据类型注入&lt;/p&gt;
&lt;p&gt;(1)List属性注入&lt;br/&gt;使用&amp;lt;list&amp;gt;配置java.util.List类型的属性。List属性中元素可以是任何数据类型的值，如果是Java对象可以使用ref指定，或使用&amp;lt;bean&amp;gt;定义新实例。如果是基础数据类型可直接用字符串。&amp;lt;list&amp;gt;中的元素会按配置的先后顺序排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
      &amp;lt;property name=&quot;lists&quot;&amp;gt;
         &amp;lt;list&amp;gt;
            &amp;lt;value&amp;gt;1&amp;lt;/value&amp;gt;
            &amp;lt;ref bean=&quot;CleanAir&quot; /&amp;gt;
             &amp;lt;bean &lt;span&gt;class&lt;/span&gt;=&quot;com.demo.model.CleanAir&quot;/&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)Set属性注入&lt;br/&gt;使用&amp;lt;set&amp;gt;配置java.util.Set类型的属性。Set属性中元素可以是任何数据类型的值，如果是Java对象可以使用ref指定，或使用&amp;lt;bean&amp;gt;定义新实例。如果是基础数据类型可直接用字符串。&amp;lt;set&amp;gt;中的元素没有先后顺序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sets&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;CleanAir&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.CleanAir&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3)Map属性注入&lt;br/&gt;使用&amp;lt;map&amp;gt;配置java.util.Map类型的属性。&amp;lt;entry&amp;gt;配置Map里的元素，Key指定索引，value指定值。如果是Java对象可以使用ref指定，或使用&amp;lt;bean&amp;gt;定义新实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;maps&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key1&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key2&quot;&lt;/span&gt;&lt;span&gt; value-ref&lt;/span&gt;&lt;span&gt;=&quot;CleanAir&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key3&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.CleanAir&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(4)Properties属性注入&lt;br/&gt;使用&amp;lt;props&amp;gt;配置java.util.Properties类型的属性。&amp;lt;props&amp;gt;配置一个Properties对象，&amp;lt;prop&amp;gt;配置一条属性，属性Key配置索引。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;pros&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;prokey1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;prokeyA&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;prokey2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;prokeyB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(5)自定义属性编辑器&lt;/p&gt;
&lt;p&gt;对于有一些属性是没法注入的，此时就需要自定义，比如日期类型。可以通过继承PropertyEditorSupport的类，重写setAsText方法来实现注入。这里定义了CustomerProperty继承PropertyEditorSupport，重写了setAsText方法，并将该bean配置到xml中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.beans.PropertyEditorSupport;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.ParseException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerProperty &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; PropertyEditorSupport {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String format=&quot;yyyy-MM-dd&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getFormat() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; format;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setFormat(String format) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.format =&lt;span&gt; format;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAsText(String text) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException {
        
        SimpleDateFormat sdf&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormat(format);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;super.setAsText(text);&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换对象，能过setValue方法重新赋值&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setValue(sdf.parse(text));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ParseException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;customEditorConfigurer&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;customEditors&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;java.util.Date&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.CustomerProperty&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置之后就可以注入Date类型的属性了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;date&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;2018-8-20&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里新建了XmlCollectionsDemo类，配置了上面的几个类型的属性来演示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_89d4522e-b967-435e-8929-98e6ab0dad91&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_89d4522e-b967-435e-8929-98e6ab0dad91&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_89d4522e-b967-435e-8929-98e6ab0dad91&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Properties;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.BeanFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; XmlCollectionsDemo {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Object&amp;gt;&lt;span&gt; list;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Properties pros;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;Object&amp;gt;&lt;span&gt; sets;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,Object&amp;gt;&lt;span&gt; maps;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date date;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Date getDate() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; date;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDate(Date date) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.date =&lt;span&gt; date;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Object&amp;gt;&lt;span&gt; list() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setLists(List&amp;lt;Object&amp;gt;&lt;span&gt; list) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; list;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Properties getPros() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pros;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPros(Properties pros) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pros =&lt;span&gt; pros;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Set&amp;lt;Object&amp;gt;&lt;span&gt; getSets() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sets;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setSets(Set&amp;lt;Object&amp;gt;&lt;span&gt; sets) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sets =&lt;span&gt; sets;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Object&amp;gt;&lt;span&gt; getMaps() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; maps;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setMaps(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; maps) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maps =&lt;span&gt; maps;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main( String[] args ) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {

        ApplicationContext context&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[]{&quot;ApplicationContext.xml&quot;&lt;span&gt;});
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;context;
        XmlCollectionsDemo annontationInstance&lt;/span&gt;=(XmlCollectionsDemo)factory.getBean(&quot;xmlCollectionsDemo&quot;&lt;span&gt;);
        System.out.println(annontationInstance.list);
        System.out.println(annontationInstance.pros);
        System.out.println(annontationInstance.sets);
        System.out.println(annontationInstance.maps);
        System.out.println(annontationInstance.date);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_8f01af79-6968-48b3-a0ca-096cdebbcb17&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8f01af79-6968-48b3-a0ca-096cdebbcb17&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8f01af79-6968-48b3-a0ca-096cdebbcb17&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;xmlCollectionsDemo&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.XmlCollectionsDemo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;lists&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;CleanAir&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.CleanAir&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sets&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ref &lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;=&quot;CleanAir&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.CleanAir&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;maps&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key1&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key2&quot;&lt;/span&gt;&lt;span&gt; value-ref&lt;/span&gt;&lt;span&gt;=&quot;CleanAir&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;key3&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model.CleanAir&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;pros&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;prokey1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;prokeyA&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;prokey2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;prokeyB&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;date&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;2018-8-20&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 通过运行main方法，打印出属性值。&lt;br/&gt;[1, CleanAir, CleanAir]&lt;br/&gt;{prokey2=prokeyB, prokey1=prokeyA}&lt;br/&gt;[1, CleanAir, CleanAir]&lt;br/&gt;{key1=1, key2=CleanAir, key3=CleanAir}&lt;br/&gt;Mon Aug 20 00:00:00 CST 2018&lt;/p&gt;
&lt;p&gt;五、初始化函数、销毁函数&lt;br/&gt;通过上面3种注入方式的学习也对通过xml对bean实例化有的了解，有的对象在实例化之后还需要执行某些初始化代码，但这些初始化代码还不能写在构造函数中，此时可以将初始化代码写到某个方法中，将init-method属性值设置为该方法，Spring会强制执行该方法进行初始化。而又的对象在使用完毕之后需要释放，可以使用destroy-method来进行销毁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DestoryMethod()
    {
        System.out.println(&lt;/span&gt;&quot;DestoryMethod&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitMethod()
    {
        System.out.println(&lt;/span&gt;&quot;InitMethod&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里先在XMLInstance类中增加了上面两个方法来模拟销毁和初始化方法。然后在xml配置bean时就可以设置destroy-method、init-method属性的值对应两个方法的方法名。注解中@PostConstruct对应init-method，@PreDestory对应destroy-method。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;xmlfactoryinstance&quot;&lt;/span&gt;&lt;span&gt; factory-bean&lt;/span&gt;&lt;span&gt;=&quot;xmlfactory&quot;&lt;/span&gt;&lt;span&gt; factory-method&lt;/span&gt;&lt;span&gt;=&quot;CreateInstance&quot;&lt;/span&gt;&lt;span&gt; destroy-method&lt;/span&gt;&lt;span&gt;=&quot;DestoryMethod&quot;&lt;/span&gt;&lt;span&gt; init-method&lt;/span&gt;&lt;span&gt;=&quot;InitMethod&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、注解注入方式&lt;/p&gt;
&lt;p&gt;一、常用注解介绍&lt;br/&gt;学习完XML注入之后再学习注解方式注入就容易的多，注解方式注入主要涉及到@Autowired,@Resource,@Required,@Qualifier,@Value这几个注解。在第2章节的2.2.4IOC实例中定义Person时就使用过@Autowired、@Qualifier。下面来了解下它们具体用法。&lt;br/&gt;@Autowired：默认是按类型匹配注入bean，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。在使用@Autowired时，首先在容器中查询对应类型的bean，如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据，如果查询的结果不止一个，那么@Autowired会根据名称来查找。如果查询的结果为空，那么会抛出异常。解决方法时，使用required=false。&lt;br/&gt;@Required：适用于bean属性setter方法，并表示受影响的bean属性必须在XML配置文件在配置时进行填充。否则，容器会抛出一个BeanInitializationException异常。&lt;br/&gt;@Qualifier：@Autowired默认是单实例的，但是在面向接口编程中，如果把一个属性设置为接口类型，一个接口可能有多个实现，那到底是注入哪一个呢?为了解决这个问题，就有了@Qualifier。&lt;br/&gt;@Value：在xml配置属性时可以通过property的value设置默认值，@Value也可以为属性设置默认值。&lt;br/&gt;@Resource：默认按名称匹配注入bean。要求提供一个bean名称的属性，如果属性为空，则自动采用标注处的变量名或方法名作为bean的名称。如果我们没有在使用@Resource时指定bean的名字，同时Spring容器中又没有该名字的bean,这时候@Resource就会退化为@Autowired即按照类型注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.model;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Required;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnnontationInstance {
    
    @Value(&lt;/span&gt;&quot;abc&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Resource与@Autowired两者选其一
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Autowired
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    @Qualifier(value=&quot;cleanair&quot;)&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; IAir air;
    @Resource(name&lt;/span&gt;=&quot;CleanAir&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAir(IAir air) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.air =&lt;span&gt; air;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Breath()
    {
        System.out.println(&lt;/span&gt;&quot;Name:&quot;+&lt;span&gt;this&lt;/span&gt;.name+&quot;;Air:&quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.air.toString());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码使用@Value注解为name设置了默认值，使用@Resources设置bean的名称为IAir属性注入bean,也可以使用@Autowired+@Qualifier为IAir注入bean。&lt;/p&gt;
&lt;p&gt;二、开启注解&lt;br/&gt;上面配置完注解之后，还要告诉Spring开启注解，这样@Autowired、@Resources这些注解才起作用。开启有两种比较简单的方式。&lt;br/&gt;1.在xml配置文件中使用context:annotation-config&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:annotation-config &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.在xml配置文件中使用context:component-scan &lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;com.demo.model&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 22 Aug 2018 15:20:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>Bean的配置中介绍的是Bean声明问题，在哪声明怎么声明的问题。Bean的注入是怎么实例化，怎么注入的问题。Bean注入的方式有两种，一种是在XML中配置，另一种则是使用注解的方式注入。 一、XML</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/9508805.html</dc:identifier>
</item>
<item>
<title>Spring Boot单元测试 - 日进一步</title>
<link>http://www.cnblogs.com/zjiuwei/p/9521072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjiuwei/p/9521072.html</guid>
<description>&lt;p&gt;一个测试类包含下面两个注解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类中可直接注入接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Resource
MyServerMgr myServerMgr;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在方法上加@Test表示它是个测试方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; query() {
 String result &lt;/span&gt;=&lt;span&gt; myServerMgr.query();
 log.info(&lt;/span&gt;&quot;test query result is {}.&quot;&lt;span&gt;, result);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用断言判断结果&lt;/span&gt;
 assertEquals(result, &quot;query result&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以通过@Before和@After注解修饰的方法，来表示测试方法执行前和执行后的行为。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Before
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUp() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
 log.info(&lt;/span&gt;&quot;Before setUp.&quot;&lt;span&gt;);
}
 
@After
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; tearDown() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
 log.info(&lt;/span&gt;&quot;After tearDown.&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此一个简单的单元测试就完成了。&lt;/p&gt;

&lt;p&gt;Spring Mock MVC：模拟Servlet容器里的测试控制器。&lt;/p&gt;
&lt;p&gt;下面部分介绍如何测试Spring Controller API。&lt;/p&gt;
&lt;p&gt;Controller测试类需要额外增加@WebAppConfiguration注解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest
@WebAppConfiguration&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要在测试类中注入WebApplicationContext：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Resource
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; WebApplicationContext webApplicationContext;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要使用MockMvc模拟发送rest请求，所以需要定义MockMvc变量并在测试方法执行前初始化它：&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt;&lt;span&gt; MockMvc mockMvc;
 
 @Before
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUp() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
 log.info(&lt;/span&gt;&quot;set mockmvc&quot;&lt;span&gt;);
 mockMvc &lt;/span&gt;=&lt;span&gt; MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mockMvc = MockMvcBuilders.standaloneSetup(webApplicationContext).build();&lt;/span&gt;
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要说明的是，Mock MVC有两种构建方式：&lt;/p&gt;
&lt;p&gt;standaloneSetup：手工创建并配置的控制器。&lt;/p&gt;
&lt;p&gt;webAppContextSetup：根据Spring应用程序上下文来构建Mock MVC。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们采用webAppContextSetup方式。&lt;/p&gt;

&lt;p&gt;使用@Test注解声明测试方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; query() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
 mockMvc.perform(get(&lt;/span&gt;&quot;/myapp&quot;&lt;span&gt;))
 .andExpect(status().isOk())
 .andExpect(content().string(&lt;/span&gt;&quot;query result&quot;&lt;span&gt;));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结一下：&lt;/p&gt;
&lt;p&gt;1、需要熟悉并掌握@RunWith(SpringRunner.class)、@SpringBootTest、@Before、@After、@Test几个注解的用法。&lt;/p&gt;
&lt;p&gt;2、测试服务端接口和测试Controller的不同是Controller需要额外的加载上下文并初始化MockMvc，并通过MockMvc模拟发送rest请求，通过断言判定结果是否正确。&lt;/p&gt;
</description>
<pubDate>Wed, 22 Aug 2018 15:17:00 +0000</pubDate>
<dc:creator>日进一步</dc:creator>
<og:description>一个测试类包含下面两个注解： 测试类中可直接注入接口： 在方法上加@Test表示它是个测试方法： 可以通过@Before和@After注解修饰的方法，来表示测试方法执行前和执行后的行为。 至此一个简单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjiuwei/p/9521072.html</dc:identifier>
</item>
<item>
<title>HDFS你一定要知道，要考的 - 叁金</title>
<link>http://www.cnblogs.com/jixin/p/9521053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jixin/p/9521053.html</guid>
<description>&lt;p&gt;你肯定听过Hadoop，对就是那头奔跑的小象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/585224/201808/585224-20180822230922971-1285710721.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hadoop作为大数据时代代表性的解决方案被大家所熟知，它主要包含两部分内容：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;HDFS分布式文件存储&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;MapReduce分a布式计算框架&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面我们分析存储方案的发展的时候有提到分布式文件存储的出现是为了解决存储的三大问题：可扩展性，高吞吐量，高可靠性&lt;/p&gt;
&lt;p&gt;那么Hadoop的核心HDFS是如何解决上面三个问题的呢？&lt;/p&gt;
&lt;p&gt;其实设计一个系统我们要考虑到它的应用场景，然后对它的功能和特性进行设计，做出取舍。我们可能会关注这几个问题：&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;原始存储格式 or 特殊存储格式，通过什么格式存储才能方便的管理数据，保证数据的迁移和安全。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;大文件 or 小文件，文件系统适合大文件还是小文件存储，如何提供I/O效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;数据高可用 or 空间利用率，通过复制副本技术提高数据可用性必然会降低空间利用率，应该如何取舍。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;是否有元数据服务，元数据服务是保存存储数据元数据信息的服务，读写数据都需要连接元数据服务器保证一致性。存在元数据服务势必会存在单点问题和性能瓶颈问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上面这个4个问题划重点，要考的！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HDFS它的设计目标就是把超大的数据集存储到多台普通计算机上，并且可以提供高可靠性和高吞吐量的服务，支持通过添加节点的方式对集群进行扩容。所以HDFS有着它自己的设计前提：&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对存储大文件支持很好，不适用于存储大量小文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过流式访问数据，保证高吞吐量而不是低延时的用户响应&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;简单一致性，使用场景应为一次写入多次读取，不支持多用户写入，不支持任意修改文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;冗余备份机制，空间换可靠性（Hadoop3中引入纠删码机制，纠删码需通过计算恢复数据，实为通过时间换空间，有兴趣的可以查看RAID的实现）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;移动计算优于移动数据，为支持大数据处理主张移动计算优于移动数据，提供相关接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;遵循以上的设计前提和目标最终的成品就是我们日常应用中的HDFS了。HDFS主要由NameNode和DataNode构成，以Master/Slave模式运行。我们来详细了解一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/585224/201808/585224-20180822230934611-1718747504.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据块&quot;&gt;数据块&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/585224/201808/585224-20180822230945071-639654862.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个就对应前面我们提出的疑问“原始存储格式 or 特殊存储格式”，在HDFS上抽象出了一个数据块的概念。可以认为是HDFS的特殊存储格式，当你存储文件的时候不是以文件为单位进行数据存储的，而是以数据块为单位进行存储。这样有什么好处呢？首先，它屏蔽了文件的概念，如果你存一个超大的文件，文件的大小大于你任何一个单个磁盘的大小，在HDFS中会把你的文件切割成多个数据块，存储到不同机器的不同磁盘中。这样就简化了存储系统的设计，而且也适用于数据的备份、迁移功能，提高了数据的容错性和可用性。&lt;/p&gt;
&lt;h2 id=&quot;namenode&quot;&gt;NameNode&lt;/h2&gt;
&lt;p&gt;这个对应前面的疑问“是否有元数据服务”，在HDFS中NameNode就起着元数据管理服务的作用，它管理着整个文件系统的命名空间，维护着文件系统树详情并对其持久化。&lt;/p&gt;
&lt;p&gt;当我们写入或者读取数据时都需要先连接NameNode，获取可操作的DataNode节点才能继续操作。所以NameNode是存在单点问题和性能问题的。Hadoop2中可以配置HA的模式，一个集群拥有两个NameNode一个处于Active状态一个处于Standby状态，其中一个失效后另一个可以自动切换成Active，进而解决了一部分单点问题。（在Hadoop3中支持配置多个NameNode，进一步解决NameNode的单点问题）。NameNode将元数据信息保存在内存中，内存就是NameNode的性能瓶颈，如果集群中小文件过多会产生大量元数据信息占用NameNode的内存。所以HDFS对大文件的支持更好。NameNode会占用较多的内存和I/O资源，所以运行NameNode的节点不会启动DataNode或者执行MapReduce任务。&lt;/p&gt;
&lt;h2 id=&quot;datanode&quot;&gt;DataNode&lt;/h2&gt;
&lt;p&gt;DataNode就是HDFS的工作节点了，它负责存储数据，为客户端提供数据块的读写服务。在启动时会将它存储的数据块的列表发送给NameNode，根据NameNode的要求对数据块进行创建、删除和备份，还会通过心跳定期向NameNode更新存储数据块信息。&lt;/p&gt;
&lt;p&gt;HDFS通过备份副本的方式实现可靠性，Hadoop2缺省的数据块大小为128M，复制因子为，默认的备份副本的分布位置与机架和节点有关。当DataNode丢失连接后，NameNode会把失败节点的数据（从其他备份副本节点）复制到另外一个健康的DataNode节点，保证集群里面的数据库始终维持指定的副本数量。&lt;/p&gt;
&lt;h2 id=&quot;写流程&quot;&gt;写流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/585224/201808/585224-20180822230956984-1720784969.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先，HDFS Client和NameNode建立连接，告诉NameNode要存储一个文件。NameNode维护着DataNode的列表，知道哪些DataNode上面还有空间可以进行存储。&lt;/li&gt;
&lt;li&gt;NameNode通过查看存储的元数据信息，发现DataNode1,2,3上可以进行存储。于是他将此信息返回给HDFS Client。&lt;/li&gt;
&lt;li&gt;HDFS Client接受到NameNode的返回的DataNode列表后，Client会与距离最近DataNode1建立连接，让其准备好接收数据。然后将文件进行分块，将数据块1和NameNode返回的DataNode列表信息一起发送给DataNode1.&lt;/li&gt;
&lt;li&gt;DataNode1通过列表信息得知要发送给DataNode2.所以DataNode1将数据与列表信息发送给DataNode2.DataNode2又发送给DataNode3，此时数据块1已经存储完成并备份了三份。&lt;/li&gt;
&lt;li&gt;当DataNode1,2,3都接收并存储数据块1后，会向NameNode发送信息，告知已经接收到了数据块1.并把数据块1相关信息发送给NameNode，NameNode更新元数据信息并 与Client通信告知数据块1已经存储完毕。然后Client开始进行数据块2的存储。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里需要注意的是一个大型的HDFS文件系统一般都是需要跨很多机架的，不同机架之间的数据传输需要经过网关，并且，同一个机架中机器之间的带宽要大于不同机架机器之间的带宽。如果把所有的副本都放在不同的机架中，这样既可以防止机架失败导致数据块不可用，又可以在读数据时利用到多个机架的带宽，并且也可以很容易的实现负载均衡。如果副本数量是3的情况下，HDFS默认把第一个副本放到机架的一个节点上，另一个副本放到同一个机架的另一个节点上，把最后一个节点放到不同的机架上。这种策略减少了跨机架副本的个数提高了写的性能，也能够允许一个机架失败的情况，算是一个很好的权衡。&lt;/p&gt;
&lt;h2 id=&quot;读流程&quot;&gt;读流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/585224/201808/585224-20180822231008548-1337930080.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HDFS Client与NameNode建立链接，告诉NameNode要读取文件xxx。&lt;/li&gt;
&lt;li&gt;NameNode通过查询自己的元数据信息，得到文件xxx的数据块映射信息及存储数据块的DataNode列表。然后将这些信息发送给Client。&lt;/li&gt;
&lt;li&gt;Client得到这些信息之后，寻找最近可用的DataNode1.取回数据块1.从DataNode2取回数据块2. 自此成功读取文件xxx&lt;/li&gt;
&lt;li&gt;如果DataNode2出现问题挂掉了，则从DataNode3进行数据块读取。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;文件读取时，NameNode会选择最近的DataNode提供给客户端。&lt;/p&gt;
&lt;p&gt;划重点划重点，要考的！！！&lt;/p&gt;
&lt;p&gt;欢迎关注我：叁金大数据（不稳定持续更新~~~）&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/585224/201808/585224-20180822231022540-1520025250.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Aug 2018 15:11:00 +0000</pubDate>
<dc:creator>叁金</dc:creator>
<og:description>你肯定听过Hadoop，对就是那头奔跑的小象。 Hadoop作为大数据时代代表性的解决方案被大家所熟知，它主要包含两部分内容： HDFS分布式文件存储 MapReduce分a布式计算框架 前面我们分析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jixin/p/9521053.html</dc:identifier>
</item>
<item>
<title>mybatis源码探究（-）MapperProxyFactory&amp;MapperProxy - 贝克田庄</title>
<link>http://www.cnblogs.com/clovejava/p/9520961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clovejava/p/9520961.html</guid>
<description>&lt;p&gt;&lt;strong&gt;在MyBatis中MapperProxyFactory,MapperProxy,MapperMethod是三个很重要的类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;弄懂了这3个类你就大概清楚Mapper接口与SQL的映射，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;为什么是接口，没有实例类也可以完成注入或者调用&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;其中MapperMethod可以参考：&lt;a href=&quot;https://my.oschina.net/u/2474629/blog/1503250&quot;&gt;MapperMethod源码分析传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在调用MyBatis的addMapper的时候如果你跟踪源码就会最终跟到MapperRegistry的addMapper中有如下的语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
knownMappers.put(type, &lt;span&gt;new&lt;/span&gt; MapperProxyFactory&amp;lt;T&amp;gt;(type));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;type就是Mapper接口。下面我们来看一下MapperProxyFactory的源码。&lt;/p&gt;
&lt;h2 id=&quot;h2_2&quot;&gt;MapperProxyFactory&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MapperProxyFactory&amp;lt;T&amp;gt;&lt;span&gt; {

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt;&lt;span&gt; mapperInterface;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt; methodCache = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;Method, MapperMethod&amp;gt;&lt;span&gt;();

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MapperProxyFactory(Class&amp;lt;T&amp;gt;&lt;span&gt; mapperInterface) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapperInterface =&lt;span&gt; mapperInterface;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Class&amp;lt;T&amp;gt;&lt;span&gt; getMapperInterface() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperInterface;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt;&lt;span&gt; getMethodCache() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodCache;
  }

  @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; T newInstance(MapperProxy&amp;lt;T&amp;gt;&lt;span&gt; mapperProxy) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Class[] { mapperInterface }, mapperProxy);
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T newInstance(SqlSession sqlSession) {
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; MapperProxy&amp;lt;T&amp;gt; mapperProxy = &lt;span&gt;new&lt;/span&gt; MapperProxy&amp;lt;T&amp;gt;&lt;span&gt;(sqlSession, mapperInterface, methodCache);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newInstance(mapperProxy);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;MapperProxyFactory一看名字我们就知道肯定是一个工厂类，就是为了生成MapperProxy。其实MapperProxyFactory也非常简单。首先看2个成员mapperInterface就是Mapper接口，methodCache就是对Mapper接口中的方法和方法的封装类（MapperMethod）的映射。MapperMethod处理的事情主要就是：处理Mapper接口中方法的注解，参数，和返回值。如果想了解更多的细节可以参考&lt;a href=&quot;https://my.oschina.net/u/2474629/blog/1503250&quot;&gt;MapperMethod源码分析传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后就是2个newInstance，看名字就知道是工厂方法，一个是protected，一个是public，所以首先看public方法。发现有一个参数SqlSession，SqlSession处理的其实就是执行一次SQL的过程。其实public的newInstance就是new了一个MapperProxy,关于MapperProxy可以先看一下后面的MapperProxy。然后调用了protected的newInstance。&lt;/p&gt;
&lt;p&gt;接着我们看protected的newInstance。protected简单明了，就是使用Java Proxy的工厂方法生成一个了Mapper接口的代理类。我想都关系MyBatis源码了应该对Java的Proxy动态代理方式应该非常熟悉了。如果不熟悉可以参考一下我之前写的一篇关于Java动态代理的&lt;a href=&quot;https://my.oschina.net/u/2474629/blog/798564&quot;&gt;Java动态代理细探&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们指定MapperProxy实现了InvocationHandler，所以调用Mapper接口中的方法走的是MapperProxy的invoke。而MapperProxy的invoke是把Method包装成了MapperMethod，MapperMethod处理了Mapper接口方法与xml映射的关系。是不是串联起来了。&lt;/p&gt;
&lt;h2 id=&quot;h2_3&quot;&gt;MapperProxy&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MapperProxy&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler, Serializable {

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = -6424540398559729838L&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SqlSession sqlSession;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt;&lt;span&gt; mapperInterface;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;Method, MapperMethod&amp;gt;&lt;span&gt; methodCache;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MapperProxy(SqlSession sqlSession, Class&amp;lt;T&amp;gt; mapperInterface, Map&amp;lt;Method, MapperMethod&amp;gt;&lt;span&gt; methodCache) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sqlSession =&lt;span&gt; sqlSession;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mapperInterface =&lt;span&gt; mapperInterface;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.methodCache =&lt;span&gt; methodCache;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.equals(method.getDeclaringClass())) {
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args);
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ExceptionUtil.unwrapThrowable(t);
      }
    }
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; MapperMethod mapperMethod =&lt;span&gt; cachedMapperMethod(method);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperMethod.execute(sqlSession, args);
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MapperMethod cachedMapperMethod(Method method) {
    MapperMethod mapperMethod &lt;/span&gt;=&lt;span&gt; methodCache.get(method);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mapperMethod == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      mapperMethod &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MapperMethod(mapperInterface, method, sqlSession.getConfiguration());
      methodCache.put(method, mapperMethod);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mapperMethod;
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看MapperProxy实现了InvocationHandler接口，不用仔细想，基本上是因为Java动态代理。&lt;/p&gt;
&lt;p&gt;既然实现了InvocationHandler接口那么当然要先看一下invoke方法了。首先检查了如果是Object中方法就直接调用方法本身。&lt;/p&gt;
&lt;p&gt;如果不是就把方法Method包装成MapperMethod，我们前面已经提到了MapperMethod主要就是处理方法的注解，参数，返回值，参数与SQL语句中的参数的对应关系。再次打一波广告，如果像了解更多MapperMethod的细节可以参考&lt;a href=&quot;https://my.oschina.net/u/2474629/blog/1503250&quot;&gt;MapperMethod源码分析传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为把Method处理为MapperMethod还是一个比较重的操作，所以这里做了缓存处理。&lt;/p&gt;
&lt;h2 id=&quot;h2_4&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;总结一下，我们公共MyBatis添加的Mapper的操作实际上添加的是MapperProxyFactory，这个是MapperProxy的工厂类，但是MapperProxyFactory生产的也不是MapperProxy，而是Mapper的Proxy代理。使用的InvocationHandler是MapperProxy，MapperProxy的invoke方法实际上是把Mapper接口方法包装为了MapperMethod，并执行的MapperMethod的execute方法。MapperMethod处理的逻辑是Mapper方法与xml中的SQL的一些映射关系。例如@MapKey等注解的处理，一些如RowBounds特殊参数的处理以及一些其他关于Mapper方法与SQL映射的处理。执行SQL的逻辑其实是委托给了SqlSession相关的逻辑。&lt;/p&gt;
</description>
<pubDate>Wed, 22 Aug 2018 14:53:00 +0000</pubDate>
<dc:creator>贝克田庄</dc:creator>
<og:description>在MyBatis中MapperProxyFactory,MapperProxy,MapperMethod是三个很重要的类。 弄懂了这3个类你就大概清楚Mapper接口与SQL的映射， 为什么是接口，没</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/clovejava/p/9520961.html</dc:identifier>
</item>
<item>
<title>9.0 toast定位+WebDriverWait显示等待 - 佬贰</title>
<link>http://www.cnblogs.com/pythontest/p/9520941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythontest/p/9520941.html</guid>
<description>&lt;p&gt;Toast  &lt;span&gt;判断&lt;/span&gt;&lt;span&gt;-----&lt;/span&gt;&lt;span&gt;基本操作问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先基本操作，进入安卓市场的账号密码页面&lt;/span&gt;---&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180822223912551-628043825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; appium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.ui &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WebDriverWait
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; appium.webdriver.common.touch_action &lt;span&gt;import&lt;/span&gt; TouchAction &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入Touch Action类&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time,re,os
Start&lt;/span&gt;=&lt;span&gt;{}
Start[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设备型号  android或者ios&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformVersion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;安卓设备版本号&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;deviceName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.176.101:5555&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;安卓设备名称&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\xuexi\apk\anzhuoshichang_16793302.apk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设备路径  pc电脑存放apk包的路径&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;上面的路径不推荐这种写法，但是目前先这么写！后续告诉大家正确的写法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;appPackage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;包名&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;appActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.baidu.appsearch.LauncherActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;容器&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;noReset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否重新安装app  True不重新安装&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;unicodeKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否禁用手机键盘  True禁用手机输入法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;resetKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否启动appium自带键盘 True开始手机输入法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;automationName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uiautomator2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;可选模式  本教程默认 Uiautomator2&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;newCommandTimeout&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;超时时间（s）&lt;/span&gt;
driver = webdriver.Remote(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://127.0.0.1:4723/wd/hub&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,Start)
driver.implicitly_wait(&lt;/span&gt;10)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐式等待十秒&lt;/span&gt;
time.sleep(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;模拟器或者手机上已经有了安卓市场，那么启动之后，直接点击左上角的头像图标&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
head&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/person_center_btn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
driver.find_element_by_id(head).click()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;点击头像图标进入个人中心&lt;/span&gt;
time.sleep(5&lt;span&gt;)
login&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/please_login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
driver.find_element_by_id(login).click() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;点击立即登录&lt;/span&gt;
time.sleep(5)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;为什么要进入到这个页面呢&lt;/span&gt;---&lt;span&gt;因为这个页面输入有个&lt;/span&gt;&lt;span&gt;toast&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;............&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如图所示：这个&lt;/span&gt;toast&lt;span&gt;提示是在&lt;/span&gt;&lt;span&gt;uiautomator&lt;/span&gt;&lt;span&gt;上面定位不到的，所以需要稍微处理一下！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180822224121938-1743440833.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;然后随便输入一个手机号码和一个密码登记登录：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Elements=driver.find_elements_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/edt_text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Elements[0].set_text(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;17700000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;因为账号输入和密码输入id相同，所以需要用到elements，之前有介绍过&lt;/span&gt;
Elements[1].set_text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/btn_login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).click()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;这时手机出现下图所示的&lt;/span&gt;toast&lt;span&gt;提示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180822224244818-1055270639.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;之前章节有说过权限弹窗定位的那个方法&lt;/span&gt;--&lt;span&gt;用在这里就&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;了！记得导入这个库&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;from selenium.webdriver.support import expected_conditions as EC  #实际上是调用的这个类expected_conditions  ------as EC重命名&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;使用方法： &lt;span&gt;WebDriverWait(driver,30, 0.5&lt;span&gt;).until(EC.&lt;span&gt;&lt;strong&gt;presence_of_element_located&lt;/strong&gt;&lt;/span&gt;(Element))&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;strong&gt;expected_conditions类提供的预期条件判断方法：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;45&quot;&gt;
&lt;p&gt;title_is： 判断当前页面的title是否完全等于（==）预期字符串，返回布尔值&lt;/p&gt;
&lt;p&gt;title_contains : 判断当前页面的title是否包含预期字符串，返回布尔值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;presence_of_element_located&lt;/span&gt; : 判断某个元素是否被加到了dom树里，并不代表该素一定可见&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;visibility_of_element_located : 判断某个元素是否可见. 可见代表元素非隐藏，并且元素的宽和高都不等于0&lt;/p&gt;
&lt;p&gt;visibility_of : 跟上面的方法做一样的事情，只是上面的方法要传入locator，这个方法直接传定位到的element就好了&lt;/p&gt;
&lt;p&gt;presence_of_all_elements_located : 判断是否至少有1个元素存在于dom树中。&lt;/p&gt;
&lt;p&gt;text_to_be_present_in_element : 判断某个元素中的text是否 包含 了预期的字符串&lt;/p&gt;
&lt;p&gt;text_to_be_present_in_element_value : 判断某个元素中的value属性是否 包含 了预期的字符串&lt;/p&gt;
&lt;p&gt;frame_to_be_available_and_switch_to_it : 判断该frame是否可以switch进去，如果可以的话，返回True并且switch进去，否则返回False&lt;/p&gt;
&lt;p&gt;invisibility_of_element_located : 判断某个元素中是否不存在于dom树或不可见&lt;/p&gt;
&lt;p&gt;element_to_be_clickable : 判断某个元素中是否可见并且是enable的，这样的话才叫clickable&lt;/p&gt;
&lt;p&gt;staleness_of : 等某个元素从dom树中移除，注意，这个方法也是返回True或False&lt;/p&gt;
&lt;p&gt;element_to_be_selected : 判断某个元素是否被选中了,一般用在下拉列表&lt;/p&gt;
&lt;p&gt;element_selection_state_to_be : 判断某个元素的选中状态是否符合预期&lt;/p&gt;
&lt;p&gt;element_located_selection_state_to_be : 跟上面的方法作用一样，只是上面的方法传入定位到的element，而这个方法传入locator&lt;/p&gt;
&lt;p&gt;alert_is_present : 判断页面上是否存在alert&lt;/p&gt;

&lt;/div&gt;
&lt;p class=&quot;pre&quot;&gt; 注：如果toast用presence_of_element_locatedpan判断不到，可以考虑用alert_is_present&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180822224348452-1622532901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;pre&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    Element &lt;/span&gt;= (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@text='网络连接异常，请重试']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    WebDriverWait(driver,&lt;/span&gt;30, 0.5&lt;span&gt;).until(EC.presence_of_element_located(Element))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;获取到toast提示：网络连接异常，请重试&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;凉了,兄碟&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;稍微换一下写法呢：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180822224437565-1808523134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果：很舒服---也是可以的--&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    Element &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@text='网络连接异常，请重试']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    WebDriverWait(driver,&lt;/span&gt;60, 0.5).until(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; driver:driver.find_element_by_xpath(Element))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;获取到toast提示：网络连接异常，请重试&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;凉了,兄碟&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;备注：&lt;/span&gt;toast&lt;span&gt;定位基本上是稳定的，但是偶尔会判断不鸟，属于正常现象，建议把扫描时间&lt;/span&gt;&lt;span&gt;0.5s&lt;/span&gt;&lt;span&gt;换成&lt;/span&gt;&lt;span&gt;0.1s&lt;/span&gt;&lt;span&gt;会稳定很多！&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;WebDriverWait(driver,60, 0.5).until(lambda driver:driver.find_element_by_xpath(Element))&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个是显示等待，&lt;/span&gt; &lt;span&gt;意思就是&lt;/span&gt; &lt;span&gt;等待&lt;/span&gt;60s   在这六十秒中，每隔0.5秒扫描一次，是否出现元素 Element&lt;/p&gt;



&lt;p&gt;&lt;span&gt;现在把上面的强制等待&lt;/span&gt;time.sleep（）全部换成显示等待！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226638/201808/1226638-20180822224823671-247547633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; appium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support.ui &lt;span&gt;import&lt;/span&gt;&lt;span&gt; WebDriverWait
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.support &lt;span&gt;import&lt;/span&gt;&lt;span&gt; expected_conditions as EC
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; appium.webdriver.common.touch_action &lt;span&gt;import&lt;/span&gt; TouchAction &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入Touch Action类&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time,re,os
Start&lt;/span&gt;=&lt;span&gt;{}
Start[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设备型号  android或者ios&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformVersion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;安卓设备版本号&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;deviceName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.176.101:5555&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;安卓设备名称&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C:\Users\Administrator\Desktop\xuexi\apk\anzhuoshichang_16793302.apk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设备路径  pc电脑存放apk包的路径&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;上面的路径不推荐这种写法，但是目前先这么写！后续告诉大家正确的写法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;appPackage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;包名&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;appActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.baidu.appsearch.LauncherActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;容器&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;noReset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否重新安装app  True不重新安装&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;unicodeKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否禁用手机键盘  True禁用手机输入法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;resetKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;是否启动appium自带键盘 True开始手机输入法&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;automationName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;uiautomator2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;可选模式  本教程默认 Uiautomator2&lt;/span&gt;
Start[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;newCommandTimeout&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;超时时间（s）&lt;/span&gt;
driver = webdriver.Remote(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://127.0.0.1:4723/wd/hub&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,Start)
driver.implicitly_wait(&lt;/span&gt;10)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;隐式等待十秒&lt;/span&gt;
time.sleep(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;模拟器或者手机上已经有了安卓市场，那么启动之后，直接点击左上角的头像图标&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
head&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/person_center_btn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
driver.find_element_by_id(head).click()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;点击头像图标进入个人中心&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; time.sleep(5)&lt;/span&gt;
login=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/please_login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断十秒内是否获取到登录元素&lt;/span&gt;
WebDriverWait(driver,10,0.5).until(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; driver:driver.find_element_by_id(login))
driver.find_element_by_id(login).click() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;点击立即登录&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; time.sleep(5)&lt;/span&gt;
Elements=driver.find_elements_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/edt_text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;点击立即登录之后，获取下一页页面的元素&lt;/span&gt;
WebDriverWait(driver,10,0.5).until(&lt;span&gt;lambda&lt;/span&gt; driver:driver.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@text=&quot;手机/邮箱/通行证&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
Elements[0].set_text(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;17700000000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;因为账号输入和密码输入id相同，所以需要用到elements，之前有介绍过&lt;/span&gt;
Elements[1].set_text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
driver.find_element_by_id(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;com.hiapk.marketpho:id/btn_login&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;因为这个toast提示时间出来的有点晚，所以等待时间稍微加那么一丢丢&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; try:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     Element = (&quot;xpath&quot;, &quot;//*[@text='网络连接异常，请重试']&quot;)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     WebDriverWait(driver,60, 0.5).until(EC.presence_of_element_located(Element))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     print('获取到toast提示：网络连接异常，请重试')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; except:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     print('凉了,兄碟')&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    Element &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//*[@text='网络连接异常，请重试']&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    WebDriverWait(driver,&lt;/span&gt;60, 0.5).until(&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; driver:driver.find_element_by_xpath(Element))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;获取到toast提示：网络连接异常，请重试&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;凉了,兄碟&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;基本上原理都是大同小异....理解了之后，可以写的花里胡哨的！！！！！&lt;/p&gt;

</description>
<pubDate>Wed, 22 Aug 2018 14:50:00 +0000</pubDate>
<dc:creator>佬贰</dc:creator>
<og:description>Toast 判断 基本操作问题 首先基本操作，进入安卓市场的账号密码页面 为什么要进入到这个页面呢 因为这个页面输入有个toast提示............ 如图所示：这个toast提示是在uiau</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pythontest/p/9520941.html</dc:identifier>
</item>
</channel>
</rss>