<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>自定义事件 - Shapeying</title>
<link>http://www.cnblogs.com/shapeY/p/7923353.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shapeY/p/7923353.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　除了浏览器提供的原生事件外，有时我们还需要自定义事件以满足特定的需求，比如小模块之间的通信，传递信息等。JavaScript提供了几种自定义事件的方式：&lt;/p&gt;
&lt;p&gt;　　　　1. &lt;strong&gt;&lt;code&gt;Event()&lt;/code&gt;&lt;/strong&gt; 构造函数, 创建一个新的事件对象 &lt;code&gt;Event&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　　　2. &lt;strong&gt;&lt;code&gt;CustomEvent()&lt;/code&gt;  &lt;/strong&gt;创建一个自定义事件&lt;/p&gt;
&lt;p&gt;　　　　3. &lt;strong&gt;&lt;code&gt;document.createEvent() &lt;/code&gt;&lt;/strong&gt;&lt;code&gt;创建一个新的事件（Event），随之必须调用自身的 init 方法进行初始化。&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Event()&lt;/h2&gt;
&lt;p&gt;　　语法 ： event = new Event(typeArg, eventInit) &lt;/p&gt;
&lt;p&gt;　　typeArg是一个表示事件类型的字符串。&lt;/p&gt;
&lt;p&gt;　　eventInit是事件的配置项：&lt;/p&gt;
&lt;p&gt;　　　　&lt;code&gt;&quot;bubbles&quot;&lt;/code&gt;，可选，&lt;code&gt;Boolean&lt;/code&gt;类型，默认值为 &lt;code&gt;false&lt;/code&gt;，表示该事件是否冒泡。&lt;/p&gt;
&lt;p&gt;　　　　&lt;code&gt;&quot;cancelable&quot;&lt;/code&gt;，可选，&lt;code&gt;Boolean&lt;/code&gt;类型，默认值为 &lt;code&gt;false&lt;/code&gt;， 表示该事件能否被取消。&lt;/p&gt;
&lt;p&gt;　　　　&lt;code&gt;&quot;composed&quot;&lt;/code&gt;，可选，&lt;code&gt;Boolean&lt;/code&gt;类型，默认值为 &lt;code&gt;false&lt;/code&gt;，指示事件是否会在阴影根之外&lt;/p&gt;
&lt;p&gt;　　自定义事件的监听和原生事件一样；触发的时候通过 targetDom.&lt;strong&gt;&lt;code class=&quot; language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;dispatchEvent(event)&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;code class=&quot; language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;触发，看下面的栗子&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//用来触发自定义事件
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;点我&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre readability=&quot;13&quot;&gt;
var button = document.querySelector('button');&lt;p&gt;&lt;span&gt;var&lt;/span&gt; selfEvent = &lt;span&gt;new&lt;/span&gt; Event(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bubbles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cancelable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;composed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    });


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听&lt;/span&gt;
    document.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(e){
      alert(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;事件顺利触发啦！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;触发&lt;/span&gt;
    button.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(){
      document.dispatchEvent(selfEvent) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;触发自定义事件&lt;/span&gt;
    })
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　需要注意的是，&lt;strong&gt;IE不支持该方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;如果自定义事件的时候，需要传递一些额外的字段，这个时候就可以用&lt;strong&gt;&lt;code&gt;CustomEvent()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;token function&quot;&gt;&lt;strong&gt;&lt;code&gt;CustomEvent()&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;token function&quot;&gt;&lt;strong&gt;　　&lt;/strong&gt;和Event()方法类似，不过在创建的时候，&lt;/span&gt;CustomEventInit中多了一个detail字段，可以用来传递额外的对象，而且少了composed字段。&lt;/p&gt;
&lt;p&gt;        触发和监听都和Event()类似，&lt;strong&gt;而且同样不支持IE&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IE不支持  可携带数据&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; custom = &lt;span&gt;new&lt;/span&gt; CustomEvent(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;custom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,{
      &lt;/span&gt;&lt;strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;detail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可携带额外的数据&lt;/span&gt;
        age : &lt;span&gt;18&lt;/span&gt;&lt;span&gt;
      },
      &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bubbles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cancelable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听&lt;/span&gt;
    document.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;custom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(e){
      console.log(e);
    })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;触发&lt;/span&gt;
    button.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;click&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,function(){
      document.dispatchEvent(custom)
    })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么如果想要兼容IE的话，要怎么办呢？&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;code&gt;document.createEvent()&lt;/code&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;token function&quot;&gt;　　这种方式已经被官方声明不推荐使用了。但是浏览器都是支持的，&lt;strong&gt;IE也都支持&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token function&quot;&gt;　　document.createEvent('Event') 创建一个自定义事件之后，在&lt;strong&gt;触发事件之前一定需要进行初始化&lt;/strong&gt;。而且要注意只&lt;strong&gt;能是document创建，不过使用的时候，所有元素都可以&lt;/strong&gt;，和之前两种方式一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token function&quot;&gt;　　初始化事件的时候&lt;strong&gt;指定事件名及能否冒泡，能否被阻止&lt;/strong&gt;等。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只能是document创建  事件被触发前，必须通过initEvent()初始化   兼容性好IE支持 但是已废弃&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; create = document.createEvent('Event'&lt;span&gt;);
    create.initEvent(&lt;/span&gt;'create', &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听&lt;/span&gt;
    document.addEventListener('create',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
      console.log(e);
    })

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;触发&lt;/span&gt;
    button.addEventListener('click',&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
      document.dispatchEvent(create)
    })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 29 Nov 2017 15:34:00 +0000</pubDate>
<dc:creator>Shapeying</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shapeY/p/7923353.html</dc:identifier>
</item>
<item>
<title>2016年下半年软件设计师下午试卷真题解析 - 的川</title>
<link>http://www.cnblogs.com/dichuan/p/7811756.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dichuan/p/7811756.html</guid>
<description>&lt;p&gt;&lt;span&gt; 阅读下列说明，回答问题1至问题4，将解答填入答题纸的对应栏内。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【说明】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;某证券交易所为了方便提供证券交易服务，欲开发一证券交易平台，该平台的主要功能如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（1）开户。根据客户服务助理提交的开户信息，进行开户，并将客户信息存入客户记录中，账户信息（余额等）存入账户记录中；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（2）存款。客户可以向其账户中存款，根据存款金额修改账户余额；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（3）取款。客户可以从其账户中取款，根据取款金额修改账户余额；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（4）证券交易。客户和经纪人均可以进行证券交易（客户通过在线方式，经纪人通过电话），将交易信息存入交易记录中；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;（5）检查交易。平台从交易记录中读取交易信息，将交易明细返回给客户。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;现采用结构化方法对该证券交易平台进行分析与设计，获得如图1-1所示的上下文数据流图和图1-2所示的0层数据流图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1262589/201711/1262589-20171109230408231-2103898032.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1262589/201711/1262589-20171109230432091-1487064339.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; 问题：1.1 （3分）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用说明中的词语，给出图1-1中的实体E1-E3的名称。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题：1.2 （3分）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;使用说明中的词语，给出图1-2中的数据存储D1-D3的名称。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题：1.3 （4分）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;根据说明和图中的术语，补充图1-2中缺失的数据流及其起点和终点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题：1.4 （5分）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;实际的证券交易通常是在证券交易中心完成的，因此，该平台的“证券交易”功能需将交易信息传递给证券交易中心。针对这个功能需求，需要对图1-1和图1-2进行哪些修改，请用200字以内的文字加以说明。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 答案&lt;/h2&gt;
&lt;h3&gt;问题：1.1&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;E1：客户服务助理，E2：客户，E3：经纪人。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本题要求识别E1-E3具体为哪个外部实体，通读试题说明，可以了解到适合充当外部实体的包括：客户、客户服务助理、经记人。具体的对应关系，可以通过将顶层图与题目说明进行匹配得知。如：从图中可看出E1会向交易平台发出数据流开户信息;；而从试题说明根据客户服务助理提交的开户信息，进行开户，并将客户信息存入客户记录中，账户信息存入账户记录中可以看出，E1对应是客户服务助理。E2、E3同理可得。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;问题：1.2&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;D1：客户记录，D2：账户记录，D3：交易记录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本题要求识别存储，解决这类问题，以图的分析为主，配合说明给存储命名，因为存储相关的数据流一般展现了这个存储中到底存了些什么信息，如从图中可以看到D1中有客户信息，而D2中有账户信息，题目说明中又有根据客户服务助理提交的开户信息，进行开户，并将客户信息存入客户记录中，账户信息存入账户记录中。自然D1应为客户记录，D2应为账户记录。同理，D3为交易记录。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;问题：1.3&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数据流名称：修改账户余额，起点：存款，终点：D2。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;数据流名称：修改账户余额，起点：取款，终点：D2。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;数据流名称：交易信息存入交易记录，起点：证券交易，终点：D3。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺失数据流1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;名称：修改账户余额，起点：存款，终点：D2。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;理由：从试题说明客户可以向其账户中存款，根据存款金额修改账户余额可以看出，这个功能有操作根据存款金额修改账户余额。据此可以了解到从该功能应有数据流存款至D2，而0层图没有。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;缺失数据流2:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;名称：修改账户余额，起点：取款，终点：D2。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;理由：从试题说明客户可以从其账户中取款，根据取款金额修改账户余额可以看出，这个功能有操作根据取款金额修改账户余额。据此可以了解到从该功能应有数据流取款至D2，而0层图没有。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;缺失数据流3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;名称：交易信息存入交易记录，起点：证券交易，终点：D3。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;理由：从试题说明客户和经纪人均可以进行证券交易，将交易信息存入交易记录中可以看出，这个功能有操作将交易信息存入交易记录中。据此可以了解到从该功能应有数据流证券交易至D3，而0层图没有。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;问题：1.4&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;增加外部实体证券交易中心，原来证券交易中的交易信息的数据流终点改为证券交易中心，数据流检测交易中的起点改为证券交易中心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本题强调实际的证券交易通常是在证券交易中心完成，这个证券交易中心属于典型的外部实体，所以需要增加外部实体证券交易中心。由于该平台的证券交易功能需将交易信息传递给证券交易中心，因此将原来证券交易中的交易信息的数据流终点改为证券交易中心，数据流检测交易中的起点改为证券交易中心。&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;span&gt;阅读下列说明和C代码，回答问题1至问题3，将解答写在答题纸的对应栏内。
【说明】
模式匹配是指给定主串t和子串s，在主串t中寻找子串s的过程，其中s称为模式。如果匹配成功，返回s在t中的位置，否则返回-1 。
KMP算法用next数组对匹配过程进行了优化。KMP算法的伪代码描述如下：
1．在串t和串s中，分别设比较的起始下标i=j=0。
2．如果串t和串s都还有字符，则循环执行下列操作：
（1）如果j=-l或者t[i]=s[j]，则将i和j分别加1，继续比较t和s的下一个字符；
（2）否则，将j向右滑动到next[j]的位置，即j =next[j]。
3．如果s中所有字符均已比较完毕，则返回匹配的起始位置（从1开始）；否则返回-1．
其中，next数组根据子串s求解。求解next数组的代码已由get_next函数给出。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;【C代码】
（1）常量和变量说明
t，s：长度为lt,ls的字符串
next:next数组，长度为ls
（2）C程序&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;求next[]的值&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; get_next( &lt;span&gt;int&lt;/span&gt; *next, &lt;span&gt;char&lt;/span&gt; *s, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ls)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;，j=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    next[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]=-&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;初始化next[0]&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(i &amp;lt; ls) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;还有字符&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(j==-&lt;span&gt;1 ll&lt;/span&gt; s[i]==s[j]) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;匹配&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        {
            j&lt;/span&gt;++&lt;span&gt;;
            i&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( s[i]==&lt;span&gt;s[j])
                next[i] &lt;/span&gt;=&lt;span&gt; next[j];
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                next[i] &lt;/span&gt;=&lt;span&gt; j;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            j &lt;/span&gt;=&lt;span&gt; next[j];
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; kmp( &lt;span&gt;int&lt;/span&gt; *next, &lt;span&gt;char&lt;/span&gt; *t,&lt;span&gt;char&lt;/span&gt; *s, &lt;span&gt;int&lt;/span&gt; lt, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ls )
{
    Int i&lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;,j =&lt;span&gt;0&lt;/span&gt;&lt;span&gt; ;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt; lt &amp;amp;&amp;amp; （&lt;span&gt;1&lt;/span&gt;&lt;span&gt;） )
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( j==-&lt;span&gt;1&lt;/span&gt; || （&lt;span&gt;2&lt;/span&gt;&lt;span&gt;） )
        {
            i &lt;/span&gt;++&lt;span&gt; ;
            j &lt;/span&gt;++&lt;span&gt; ;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            （&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;） ;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (j &amp;gt;=&lt;span&gt; ls)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; （&lt;span&gt;4&lt;/span&gt;&lt;span&gt;） ;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;问题：4.1   （8分）
根据题干说明，填充C代码中的空（1）～（4）.
 
问题：4.2   （2分）
根据题干说明和C代码，分析出kmp算法的时间复杂度为（5）（主串和子串的长度分别为lt和ls，用O符号表示）。
 
问题：4.3   （5分）
根据C代码，字符串“BBABBCAC”的next数组元素值为（6）（直接写素值，之间用逗号隔开）。若主串为“AABBCBBABBCACCD”，&lt;br/&gt;子串为“BBABBCAC”，则函数Kmp的返回值是（7）。&lt;/span&gt;
&lt;/pre&gt;
&lt;h2&gt;答案&lt;/h2&gt;
&lt;pre&gt;
&lt;span&gt;（1）：j&amp;lt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;ls
（2）：t[i]==&lt;/span&gt;&lt;span&gt;&lt;span&gt;s[j];
（3&lt;/span&gt;&lt;span&gt;&lt;span&gt;）：get_next(next, s, ls)，
            j=&lt;/span&gt;&lt;span&gt;&lt;span&gt;next[j]
（4）：i+1-&lt;/span&gt;&lt;span&gt;&lt;span&gt;ls 
（5）：O(ls+&lt;/span&gt;&lt;span&gt;&lt;span&gt;lt) 
（6）：[-1,-1,1,-1,-1,2,0,0&lt;/span&gt;&lt;span&gt;&lt;span&gt;]
（7）：6&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;阅读下列说明和java代码，将应填入 （n） 处的字句写在答题纸的对应栏内。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;【说明】&lt;/span&gt;&lt;br/&gt;&lt;span&gt;某发票（lnvoice）由抬头（Head）部分、正文部分和脚注（Foot）部分构成。现采用装饰（Decorator）模式实现打印发票的功能，得到如图6-1所示的类图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1262589/201711/1262589-20171109224103169-1203495389.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题：6.1   【java代码】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; invoice
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printInvoice()
    {
        System.out.println ( &lt;/span&gt;&quot;This is the content of the invoice!&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Decorator &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Invoice
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Invoice ticket;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Decorator(lnvoice t)
    {
        ticket &lt;/span&gt;=&lt;span&gt; t;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printInvoice()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ticket != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            （&lt;/span&gt;1&lt;span&gt;） ;
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; HeadDecorator &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Decorator
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HeadDecorator(lnvoice t)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(t);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printInvoice ()
    {
        System.out.println( &lt;/span&gt;&quot;This is the header of the invoice! &quot;&lt;span&gt;);
        （&lt;/span&gt;2&lt;span&gt;） ;
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; FootDecorator &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Decorator
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FootDecorator(Invoice t)
    {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(t);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printlnvoice()
    {
        （ &lt;/span&gt;3&lt;span&gt;） ;
        System.out.println( &lt;/span&gt;&quot;This is the footnote of the invoice! &quot;&lt;span&gt;);
    }
}
Class test
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        Invoice t &lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Invioce();
        Invoice ticket;
        ticket&lt;/span&gt;= （4&lt;span&gt;） ;
        ticket.printInvoice();
        System.out.println(“&lt;/span&gt;------------------&lt;span&gt;“);
        ticket&lt;/span&gt;= （5&lt;span&gt;） ;
        ticket.printInvoice();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;程序的输出结果为：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;This is the header of the invoice!&lt;/span&gt;&lt;br/&gt;&lt;span&gt;This is the content of the invoice!&lt;/span&gt;&lt;br/&gt;&lt;span&gt;This is the footnote of the invoice!&lt;/span&gt;&lt;br/&gt;&lt;span&gt;----------------------------&lt;/span&gt;&lt;br/&gt;&lt;span&gt;This is the header of the invoice!&lt;/span&gt;&lt;br/&gt;&lt;span&gt;This is the footnote of the invoice!&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;答案&lt;/h2&gt;
&lt;pre&gt;
&lt;span&gt;（1&lt;/span&gt;&lt;span&gt;&lt;span&gt;）ticket.printInvoice()
（2）super&lt;/span&gt;&lt;span&gt;&lt;span&gt;.printInvoice()
（3）super&lt;/span&gt;&lt;span&gt;&lt;span&gt;.printInvoice()
（4）new HeadDecorator(new&lt;/span&gt;&lt;span&gt;&lt;span&gt; FootDecorator(t)) 
（5）new HeadDecorator(new FootDecorator(null))&lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;

</description>
<pubDate>Wed, 29 Nov 2017 15:15:00 +0000</pubDate>
<dc:creator>的川</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dichuan/p/7811756.html</dc:identifier>
</item>
<item>
<title>eclipse环境下基于已构建struts2项目整合spring+hibernate - Mr至简</title>
<link>http://www.cnblogs.com/wujingtaocoding/p/7923260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wujingtaocoding/p/7923260.html</guid>
<description>&lt;p&gt;本文是基于已构建的struts2项目基础上整合&lt;/p&gt;
&lt;p&gt;spring+hibernate，若读者还不熟悉struts2项目，请先阅读&lt;/p&gt;

&lt;p&gt;实现步骤：&lt;/p&gt;
&lt;p&gt;第一步：引入spring所需jar包，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1273572/201711/1273572-20171129220342104-1090852117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步：导入hibernate所需jar包，如下图中被选中jar文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1273572/201711/1273572-20171129220732558-585009412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步：导入struts-spring整合包，暂且就这么称呼吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1273572/201711/1273572-20171129221041604-1247098007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四步：导入MySQL驱动包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1273572/201711/1273572-20171129221300823-1022383636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第五步：所有准备工作就绪后，接下来创建spring与hibernate配置文件，命名为applicationContext.xml，配置如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:task=&quot;http://www.springframework.org/schema/task&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xsi:schemaLocation=&quot;
http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd 
http://www.springframework.org/schema/context 
http://www.springframework.org/schema/context/spring-context-3.0.xsd
http://www.springframework.org/schema/task  
http://www.springframework.org/schema/task/spring-task-3.1.xsd
http://www.springframework.org/schema/tx 
http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
http://www.springframework.org/schema/aop 
http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
&quot;&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 这是spring配置文件命名空间的引入，命名空间具体含义请参考前辈资料 &lt;/p&gt;

&lt;p&gt;第六步：在web.xml文件中配置对spring的监听，配置如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.0&quot;&amp;gt;
  &amp;lt;display-name&amp;gt;SSHDemo&amp;lt;/display-name&amp;gt;
  
      &amp;lt;!-- spring的监听器配置开始 --&amp;gt;
    &amp;lt;!-- spring监听器的作用：提供实例(IOC) --&amp;gt;
      &amp;lt;context-param&amp;gt;
        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
        &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;
    
    &amp;lt;listener&amp;gt;
        &amp;lt;listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/listener&amp;gt;
  
  &amp;lt;!-- 将请求路径交由struts过滤 --&amp;gt;
  &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是在struts2项目基础配置上增加对spring的监听。&lt;/p&gt;
&lt;p&gt;第七步：项目下构建业务层接口(TestServiceI)、实现类(TestServiceImpl)以及数据库操作层接口(TestDaoI)、实现类(TestDaoImpl)&lt;/p&gt;
&lt;p&gt;整个项目结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1273572/201711/1273572-20171129223230714-2074843352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中dao层实现类中我们需要注入一个session工厂（工厂注入请留意本文后续），接着打开session工厂用于操作数据库，代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; wjt.com.test.dao.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.HibernateException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.Session;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.SessionFactory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; wjt.com.test.dao.TestDaoI;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; TestDaoI{
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SessionFactory sessionFactory;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSessionFactory(SessionFactory sessionFactory) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sessionFactory =&lt;span&gt; sessionFactory;
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Session getCurrentSession() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sessionFactory.getCurrentSession();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (HibernateException e) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sessionFactory.openSession();
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDaoMethod() {
        System.out.println(&lt;/span&gt;&quot;dao层测试方法...&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(getCurrentSession()!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            System.out.println(&lt;/span&gt;&quot;session工厂注入成功！&quot;&lt;span&gt;);
        }
        
    }
    
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中service层实现类中我们暂时写一个空方法进行测试dao层接口对象的注入成功与否并调用dao层方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; wjt.com.test.service.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; wjt.com.test.dao.TestDaoI;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; wjt.com.test.service.TestServiceI;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; TestServiceI{
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TestDaoI testDao;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTestDao(TestDaoI testDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.testDao =&lt;span&gt; testDao;
    }



    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testServiceMethod() {
        System.out.println(&lt;/span&gt;&quot;service层测试方法...&quot;&lt;span&gt;);
        testDao.testDaoMethod();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中Action层我们在原来struts2项目的基础上注入service层接口并调用其方法，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; wjt.com.test.action;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; wjt.com.test.service.TestServiceI;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TestAction &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActionSupport{
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TestServiceI testService;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTestService(TestServiceI testService) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.testService =&lt;span&gt; testService;
    }



    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String execute() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot;struts==========================&quot;&lt;span&gt;);
        testService.testServiceMethod();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整个s2sh项目中的结构布局如上述第七步所示，用于视图映射的类我们封装在action包下，用于实现业务逻辑的我们封装在service包下，用于访问数据库对数据进行操作的我们封装在dao包下。&lt;/p&gt;
&lt;p&gt;第八步：配置spring+hibernate的配置文件&lt;/p&gt;
&lt;p&gt;截止到现在整个s2sh项目的准备工作已经准备完毕，接下来我们我们配置hibernate的数据源、session工厂，配置spring的核心之一控制反转IOC或称为依赖注入DI。&lt;/p&gt;
&lt;p&gt;配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:task&lt;/span&gt;=&quot;http://www.springframework.org/schema/task&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;
&lt;/span&gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans-3.0.xsd &lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context &lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context-3.0.xsd&lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/task  &lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/task/spring-task-3.1.xsd&lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx-3.0.xsd&lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop &lt;/span&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop-3.0.xsd&lt;/span&gt;
&quot;&amp;gt;

    &amp;lt;!-- 数据源配置 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot;
        &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&amp;gt;
        &amp;lt;property name=&quot;url&quot;&lt;span&gt; value&lt;/span&gt;=&quot;jdbc:mysql://localhost:3306/wjt_test?useUnicode=true&amp;amp;amp;characterEncoding=UTF-8&amp;amp;amp;zeroDateTimeBehavior=convertToNull&amp;amp;amp;autoReconnect=true&quot; /&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;root&quot; /&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;wujingtao&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 配置hibernate session工厂 --&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot;
        &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
        &amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQL5InnoDBDialect&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.show_sql&quot;&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.format_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;

    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 注入对象  采用属性注入方式--&amp;gt;
    
    &amp;lt;bean id=&quot;testDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;wjt.com.test.dao.impl.TestDaoImpl&quot; scope=&quot;prototype&quot;&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;&amp;lt;!-- 引用上方的hibernate工厂 --&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;bean id=&quot;testService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;wjt.com.test.service.impl.TestServiceImpl&quot; scope=&quot;prototype&quot;&amp;gt;
        &amp;lt;property name=&quot;testDao&quot; ref=&quot;testDao&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;bean id=&quot;testAction&quot; &lt;span&gt;class&lt;/span&gt;=&quot;wjt.com.test.action.TestAction&quot; scope=&quot;prototype&quot;&amp;gt;
        &amp;lt;property name=&quot;testService&quot; ref=&quot;testService&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;


&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中IOC配置采用属性注入的方式，大家可以根据个人喜好选择spring注入的几种方式，我个人偏爱基于注解的属性注入方式，注解方式注入会在后续的文章中给出。&lt;/p&gt;
&lt;p&gt;第九步：将struts2运行时的对象交由spring创建，即所谓的应用IOC&lt;/p&gt;
&lt;p&gt;在struts.xml配置文件中添加如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!&lt;span&gt;DOCTYPE struts PUBLIC
            &lt;/span&gt;&quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
            &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&amp;gt;&amp;lt;!-- 这里要和struts2版本号统一 --&amp;gt;

&amp;lt;struts&amp;gt;

    &amp;lt;!-- 告知Struts2运行时使用Spring来创建对象 这行代码是新加的--&amp;gt;
    &amp;lt;constant name=&quot;struts.objectFactory&quot; value=&quot;spring&quot; /&amp;gt;

    &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;default&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot;&amp;gt;
        &amp;lt;action name=&quot;login&quot; &lt;span&gt;class&lt;/span&gt;=&quot;wjt.com.test.action.TestAction&quot;&amp;gt;
            &amp;lt;result name=&quot;success&quot;&amp;gt;index.jsp&amp;lt;/result&amp;gt;
        &amp;lt;/action&amp;gt;
    &amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;

&amp;lt;/struts&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试项目：&lt;/p&gt;
&lt;p&gt;在tomcat下部署并启动项目&lt;/p&gt;
&lt;p&gt;浏览器地址栏输入：http://localhost:8080/SSHDemo/login&lt;/p&gt;
&lt;p&gt;浏览器显示如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1273572/201711/1273572-20171129225918511-2038282261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;eclipse输出显示如下：（因为我们在各层有打印信息）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1273572/201711/1273572-20171129230105183-988463965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里完整的s2sh项目构建完毕并通过测试。&lt;/p&gt;
&lt;p&gt;本人是刚毕业的小白，写文章的目的是全当给自己做笔记了，博文有不合理的地方还请读者指出！&lt;/p&gt;

</description>
<pubDate>Wed, 29 Nov 2017 15:10:00 +0000</pubDate>
<dc:creator>Mr至简</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wujingtaocoding/p/7923260.html</dc:identifier>
</item>
<item>
<title>python之列表（list）的使用方法介绍 - 蜗牛前进的方向</title>
<link>http://www.cnblogs.com/ddpeng/p/7923255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ddpeng/p/7923255.html</guid>
<description>&lt;p&gt; python之列表（list）介绍&lt;/p&gt;
&lt;p&gt;在python的使用过程中，我们经常会用到列表，然而经常会遇到疑惑，下面我将详细介绍下列表使用方法。&lt;/p&gt;
&lt;p&gt;一、列表&lt;/p&gt;
&lt;p&gt;列表经常用到的功能使增、删、改和查功能。&lt;/p&gt;
&lt;p&gt;1.　增&lt;/p&gt;
&lt;p&gt;　　增的常用的方法有两种list.append和list.insert.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　append方法 ：在列表的末尾追加。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　例子：列表a = [1,2,3,4,5,6,7,8,9,10]，追加一个100，那么操作方法是 a.append(100)，即如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129212731995-1783766465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　insert方法 ：在指定位置追加。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　例子：列表a = [1,2,3,4,5,6,7,8,9,10]，第一个位置追加0，那么操作方法是a.insert(0,0),即如下所示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129213026933-1782825558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.　删&lt;/p&gt;
&lt;p&gt; 　　删就是用del方法，其中del list[x]为列表中某一个元素；而del list为删除整个列表。&lt;/p&gt;
&lt;p&gt;　　例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　列表a = [1,2,3,4,5,6,7,8,9,10]，删除列表中第一个元素，那么操作方法是del a[0]，即如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129213707698-1342338895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　列表a = [1,2,3,4,5,6,7,8,9,10]，删除列表中最后一个元素，可使用倒叙法：del[-1]，即如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129213853948-786296818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　列表a = [1,2,3,4,5,6,7,8,9,10]，还可以用list.pop(x)，其中x为index索引值，即如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129223310698-405641365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　注：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　删除整个列表a = [1,2,3,4,5,6,7,8,9,10]，直接执行del a即可，如果再使用列表a需要重新定义，即如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129214254464-525277124.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.　改&lt;/p&gt;
&lt;p&gt;　　将预先定义好的列表中的值进行替换。&lt;/p&gt;
&lt;p&gt;　　例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　列表a = [1,2,3,4,5,6,7,8,9,10]，将第一个元素更改为0，即a[0]=0，即如下所示：　　&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129215510729-127359935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　列表a = [1,2,3,4,5,6,7,8,9,10]，将最后一个元素更改为0，可使用倒叙法：a[-1]=0，即如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129215748167-1931249163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.   查&lt;/p&gt;
&lt;p&gt;　　即根据列表下标索引查询。&lt;/p&gt;
&lt;p&gt;　　例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　查询列表a = [1,2,3,4,5,6,7,8,9,10]中第一个元素的值，即如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129220131339-604978190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　查询列表a = [1,2,3,4,5,6,7,8,9,10]中最后一个元素的值，即如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129220246854-91755689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　列表查询之索引越界（因为列表下标是从0开始的，目前的例子中共计10个元素，第10个元素下标是9，当执行a[10]时是第11个元素就越界了。）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129221718058-1743556713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.　拓展&lt;/p&gt;
&lt;p&gt;　　5.1　遍历计算列表a = [1,1,2,3,4,1,1,10]中1的个数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　for循环实现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129220718354-518309917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　高阶函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129220951276-967709188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　直接用内建函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129221050792-615831588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5.2　将1-100的数用列表显示出来&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　用range函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129221358683-1588422070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　使用for循环&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129221531917-1701956093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　5.3　将列表中元素用生成以*分割的字符串&lt;/p&gt;
&lt;p&gt;　　此算法用到了join函数即 &quot;*&quot;.join(list)&lt;/p&gt;
&lt;p&gt;　　例如：将列表a = ['1','2','3'] 变成 1*2*3&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129224003448-1942441288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：列表a中的元素必须为字符串类型。&lt;/p&gt;
&lt;p&gt;　　另：字符串也可以用join方法用指定符号分割。&lt;/p&gt;
&lt;p&gt;　　5.4    根据列表中的值算出下标索引值&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129224412104-1500421174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注：如果列表中有相同的值时，返回的下标索引是最靠前的那一个。&lt;/p&gt;
&lt;p&gt;　　5.5  列表的切片操作&lt;/p&gt;
&lt;p&gt;　　列表的切片是指根据下标索引的值进行切片，主要有list[x:]，lixt[x:-y],list[x:y:n]，其中x为起始元素，y为倒叙数的元素值，n为步长，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129225053183-533285468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5.6 列表的升序排列&lt;/p&gt;
&lt;p&gt;　　用到的是sort方法，及list.sort()&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1277144/201711/1277144-20171129225641933-1814815492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.　列表操作包含的函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cmp(list1, list2)：比较两个列表的元素 &lt;/li&gt;
&lt;li&gt;len(list)：列表元素个数 &lt;/li&gt;
&lt;li&gt;max(list)：返回列表元素最大值 &lt;/li&gt;
&lt;li&gt;min(list)：返回列表元素最小值 &lt;/li&gt;
&lt;li&gt;list(seq)：将元组转换为列表 &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;到目前为止介绍了列表的增删改查和列表拓展，希望能够帮到正在学习列表的同志们，欢迎留言！&lt;/p&gt;
</description>
<pubDate>Wed, 29 Nov 2017 15:07:00 +0000</pubDate>
<dc:creator>蜗牛前进的方向</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ddpeng/p/7923255.html</dc:identifier>
</item>
<item>
<title>【OCR技术系列之一】字符识别技术总览 - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/7923015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/7923015.html</guid>
<description>&lt;p&gt;最近入坑研究OCR，看了比较多关于OCR的资料，对OCR的前世今生也有了一个比较清晰的了解。所以想写一篇关于OCR技术的综述，对OCR相关的知识点都好好总结一遍，以加深个人理解。&lt;/p&gt;

&lt;p&gt;OCR英文全称是Optical Character Recognition，中文叫做光学字符识别。它是利用光学技术和计算机技术把印在或写在纸上的文字读取出来，并转换成一种计算机能够接受、人又可以理解的格式。文字识别是计算机视觉研究领域的分支之一，而且这个课题已经是比较成熟了，并且在商业中已经有很多落地项目了。比如汉王OCR，百度OCR，阿里OCR等等，很多企业都有能力都是拿OCR技术开始挣钱了。其实我们自己也能感受到，OCR技术确实也在改变着我们的生活：比如一个手机APP就能帮忙扫描名片、身份证，并识别出里面的信息；汽车进入停车场、收费站都不需要人工登记了，都是用车牌识别技术；我们看书时看到不懂的题，拿个手机一扫，APP就能在网上帮你找到这题的答案。太多太多的应用了，OCR的应用在当今时代确实是百花齐放啊。&lt;/p&gt;

&lt;p&gt;如果要给OCR进行分类，我觉得可以分为两类：手写体识别和印刷体识别。这两个可以认为是OCR领域两个大主题了，当然印刷体识别较手写体识别要简单得多，我们也能从直观上理解，印刷体大多都是规则的字体，因为这些字体都是计算机自己生成再通过打印技术印刷到纸上。在印刷体的识别上有其独特的干扰：在印刷过程中字体很可能变得断裂或者墨水粘连，使得OCR识别异常困难。当然这些都可以通过一些图像处理的技术帮他尽可能的还原，进而提高识别率。总的来说，单纯的印刷体识别在业界已经能做到很不错了，但说100%识别是肯定不可能的，但是说识别得不错那是没毛病。&lt;/p&gt;
&lt;p&gt;印刷体已经识别得不错了，那么手写体呢？手写体识别一直是OCR界一直想攻克的难关，但是时至今天，感觉这个难关还没攻破，还有很多学者和公司在研究。为什么手写体识别这么难识别？因为人类手写的字往往带有个人特色，每个人写字的风格基本不一样，虽然人类可以读懂你写的文字，但是机器缺很难。那为什么机器能读懂印刷体？因为印刷体是机器造出来的啊，那机器当然能读懂自己造的字体啦哈哈~其实上面也提到了，印刷体一般都比较规则，字体都基本就那几十种，机器学习这几十种字体并不是一件难事，但是手写体，每个人都有一种字体的话，那机器该学习多少字体啊？这就是难度所在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201711/1093303-20171129221043620-1914679795.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果按识别的内容来分类，也就是按照识别的语言的分类的话，那么要识别的内容将是人类的所有语言（汉语、英语、德语、法语等）。如果仅按照我们国人的需求，那识别的内容就包括：汉字、英文字母、阿拉伯数字、常用标点符号。根据要识别的内容不同，识别的难度也各不相同。简单而言，识别数字是最简单了，毕竟要识别的字符只有0~9，而英文字母识别要识别的字符有26个（如果算上大小写的话那就52个），而中文识别，要识别的字符高达数千个（二级汉字一共6763个）！因为汉字的字形各不相同，结构非常复杂（比如带偏旁的汉字）如果要将这些字符都比较准确地识别出来，是一件相当具有挑战性的事情。但是，并不是所有应用都需要识别如此庞大的汉字集，比如车牌识别，我们的识别目标仅仅是数十个中国各省和直辖市的简称，难度就大大减少了。当然，在一些文档自动识别的应用是需要识别整个汉字集的，所以要保证识别的整体的识别还是很困难的。&lt;/p&gt;

&lt;p&gt;现在就来整理一下常见的OCR流程，为了方便描述，那就举文档中的字符识别为例子来展开说明吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201711/1093303-20171129221103276-330618637.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如输入系统的图像是一页文本，那么识别时的第一件事情是判断页面上的文本朝向，因为我们得到的这页文档往往都不是很完美的，很可能带有倾斜或者污渍，那么我们要做的第一件事就是进行图像预处理，做角度矫正和去噪。然后我们要对文档版面进行分析，进每一行进行行分割，把每一行的文字切割下来，最后再对每一行文本进行列分割，切割出每个字符，将该字符送入训练好的OCR识别模型进行字符识别，得到结果。但是模型识别结果往往是不太准确的，我们需要对其进行识别结果的矫正和优化，比如我们可以设计一个语法检测器，去检测字符的组合逻辑是否合理。比如，考虑单词Because，我们设计的识别模型把它识别为8ecause，那么我们就可以用语法检测器去纠正这种拼写错误，并用B代替8并完成识别矫正。这样子，整个OCR流程就走完了。从大的模块总结而言，一套OCR流程可以分为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    版面分析 -&amp;gt; 预处理-&amp;gt; 行列切割 -&amp;gt; 字符识别 -&amp;gt; 后处理识别矫正 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的流程图可以看出，要做字符识别并不是单纯一个OCR模块就能实现的（如果单纯的OCR模块，识别率相当低），都要各个模块的组合来保证较高的识别率。上面的流程分的比较粗，每个模块下还是有很多更细节的操作，每个操作都关系着最终识别结果的准确性。做过OCR的童鞋都知道，送入OCR模块的图像越清晰（即预处理做的越好），识别效果往往就越好。那现在对这流程中最为重要的字符识别技术做一个总结。&lt;/p&gt;

&lt;p&gt;现在我们只想单纯地想对字符进行识别，那方法会有哪些呢？我列了一下可以采取的策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用谷歌开源OCR引擎Tesseract&lt;/li&gt;
&lt;li&gt;使用大公司的OCR开放平台（比如百度），使用他们的字符识别API&lt;/li&gt;
&lt;li&gt;传统方法做字符的特征提取，输入分类器，得出OCR模型&lt;/li&gt;
&lt;li&gt;暴力的字符模板匹配法&lt;/li&gt;
&lt;li&gt;大杀器：基于深度学习下的CNN字符识别&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面提到的OCR方法都有其有点和缺点，也正如此，他们也有各自特别适合的应用场景。&lt;/p&gt;
&lt;p&gt;首先说开源OCR引擎Tesseract。搞字符识别的童鞋应该都听说过Tesseract这个东西，这是谷歌维护的一个OCR引擎，它已经有一段相当悠久的历史了。Tesseract现在的版本已经支持识别很多种语言了，当然也包括汉字的识别。毕竟Tesseract是外国人搞得一个东西，所以在汉字识别的精度上还是不能摆上台面，不过还是自己去改善。但是Tesseract在阿拉伯数字和英文字母上的识别还是可以的，如果你要做的应用是要识别英文或者数字，不妨考虑一下使用Tesseract，毕竟拿来就能得到不错的结果。当然啦，要做到你想要的识别率，后期微调或者优化肯定要多下功夫的。&lt;/p&gt;
&lt;p&gt;接下来说一下借用OCR开放平台做文字识别。现在很多大公司都开放了OCR的API供开发者调用，当然啦，小量调用是不收费的，但是大量调用就要收费了。最近我也在百度开放平台上调用OCR的API做一些识别的工作，说实话，在汉字的识别上，我们中国公司的技术还是顶尖的，在汉字识别的准确率上已经让人很满意了。比如我要识别一些文本，自己写个python脚本，调用开放平台的服务，返回的就是识别结果了。这种模式有啥不好的地方吗？首先是需要钱（当然每天小批量识别一下是不用钱的），第二是自己的控制程度不足，我们想要提升识别精度，我们不可以从OCR识别上做改进（毕竟别人的东西，我们改不了），能做只是预处理和后期矫正，能做的还是比较有限的。但是，如果自己不想花大量时间做OCR模型并且手上有钱的话，这种识别方法还是OK的。&lt;/p&gt;
&lt;p&gt;上面提到的都是用的是别人的东西，那我们想从头自己做，咋办？&lt;/p&gt;
&lt;p&gt;那就自己做吧！先谈一谈字符模板那匹配法。暴力的字符模板匹配法看起来很蠢，但是在一些应用上可能却很凑效。比如在对电表数字进行识别时，考虑到电表上的字体较少（可能就只有阿拉伯数字），而且字体很统一，清晰度也很高，所以识别难度不高。针对这种简单的识别场景，我们首先考虑的识别策略当然是最为简单和暴力的模板匹配法。我们首先定义出数字模板（0~9），然后用该模板滑动匹配电表上的字符，这种策略虽然简单但是相当有效。我们不需要左思右想去建模，训练模型，只需要识别前做好模板库就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201711/1093303-20171129221119026-958711147.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板匹配法只限于一些很简单的场景，但对于稍微复杂的场景，那就不太实用了。那此时我们可以采取OCR的一般方法，即特征设计、特征提取、分类得出结果的计算机视觉通用的技巧。在深度学习大放异彩之前，OCR的方法基本都是这种方法，其效果嘛，并不算特别好。在这里简单说一下这里常见的方法。第一步是特征设计和提取，特征设计是一件很烦人的事情，做过模式识别相关项目的童鞋也深有体会，我们现在识别的目标是字符，所以我们要为字符设计它独有的的特征，来为后面的特征分类做好准备。字符有啥特征呢？有结构特征，即字符的端点、交叉点、圈的个数、横线竖线条数等等，都是可以利用的字符特征。比如“品”字，它的特征就是它有3个圈，6条横线，6条竖线。除了结构特征，还有大量人工专门设计的字符特征，据说都能得到不错的效果。最后再将这些特征送入分类器（SVM）做分类，得出识别结果。这种方式最大的缺点就是，人们需要花费大量时间做特征的设计，这是一件相当费工夫的事情。通过人工设计的特征（例如HOG）来训练字符识别模型，此类单一的特征在字体变化，模糊或背景干扰时泛化能力迅速下降。而且过度依赖字符切分的结果，在字符扭曲、粘连、噪声干扰的情况下，切分的错误传播尤其突出。针对传统OCR解决方案的不足，学界业界纷纷拥抱基于深度学习的OCR。&lt;/p&gt;
&lt;p&gt;这些年深度学习的出现，让OCR技术焕发第二春。现在OCR基本都用卷积神经网络来做了，而且识别率也是惊人的好，人们也不再需要花大量时间去设计字符特征了。在OCR系统中，人工神经网络主要充当特征提取器和分类器的功能，输入是字符图像，输出是识别结果，一气呵成。这里就不再展开说明卷积神经网络了，想要知道的细节的可以看我以前写过的一篇博客&lt;a href=&quot;http://www.cnblogs.com/skyfsm/p/6790245.html&quot;&gt;《卷积神经网络CNN总结》&lt;/a&gt;。当然用深度学习做OCR并不是在每个方面都很优秀，因为神经网络的训练需要大量的训练数据，那么如果我们没有办法得到大量训练数据时，这种方法很可能就不奏效了。其次，神经网络的训练需要花费大量的时间，并且需要用到的硬件资源一般都比较多，这几个都是需要考虑的问题。&lt;/p&gt;
&lt;p&gt;在接下来的博客中，我将在工程上一一实现以上说到的几种OCR的识别方法~~&lt;/p&gt;

&lt;p&gt;在一些简单环境下OCR的准确度已经比较高了（比如电子文档），但是在一些复杂环境下的字符识别，在当今还没有人敢说自己能做的很好。现在大家都很少会把目光还放在如何对电子文档的文字识别该怎么进一步提高准确率了，因为他们把目光放在更有挑战性的领域。OCR传统方法在应对复杂图文场景的文字识别显得力不从心，越来越多人把精力都放在研究如何把文字在复杂场景读出来，并且读得准确作为研究课题，用学界术语来说，就是场景文本识别（文字检测+文字识别）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1093303/201711/1093303-20171129221133323-1213320398.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，自然场景下的文字识别比简单场景的文字识别实在困难太多了，现在虽然出了很多成果，但是离理想结果还是差很远。&lt;/p&gt;
&lt;p&gt;当然啦，除上面的场景文字识别外，历史悠久的手写体的识别到现在还是一件具有挑战的课题，在深度学习的浪潮下，手写体的识别已经前进了一大步，但是尚且没达到印刷体识别那种可以商用的地步，所以啊，OCR的研究还得不断地进行下去。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Nov 2017 14:12:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/7923015.html</dc:identifier>
</item>
<item>
<title>微信小程序支付及退款流程详解 - 未曾见海</title>
<link>http://www.cnblogs.com/afei-qwerty/p/7922982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/afei-qwerty/p/7922982.html</guid>
<description>[unable to retrieve full-text content]微信小程序的支付和退款流程 近期在做微信小程序时，涉及到了小程序的支付和退款流程，所以也大概的将这方面的东西看了一个遍，就在这篇博客里总结一下。 首先说明一下，微信小程序支付的主要逻辑集中在后端，前端只需携带支付所需的数据请求后端接口然后根据返回结果做相应成功失败处理即可。我在后端使用的是php，当</description>
<pubDate>Wed, 29 Nov 2017 14:04:00 +0000</pubDate>
<dc:creator>未曾见海</dc:creator>
<dc:identifier>http://www.cnblogs.com/afei-qwerty/p/7922982.html</dc:identifier>
</item>
<item>
<title>Hangfire在ASP.NET CORE中的简单实现 - akaxb</title>
<link>http://www.cnblogs.com/akaxb/p/7921783.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/akaxb/p/7921783.html</guid>
<description>&lt;p&gt;hangfire是执行后台任务的利器，具体请看官网介绍：https://www.hangfire.io/&lt;/p&gt;
&lt;p&gt;新建一个asp.net core mvc 项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129173257065-367473524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129173316362-625361565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;引入nuget包 Hangfire.AspNetCore&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129173352315-812484573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hangfire的任务需要数据库持久化，我们在Startup类中修改ConfigureServices&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129173720644-1721844246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在Configure方法中启用hangfire中间件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129173821612-382944579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们运行一下项目，可以看到，数据库里自动生成了很多表，这些表就是用来持久化任务的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129203619120-1780179940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们打开如下地址，可以看到hangfire的作业控制面板，现在开没有任何作业&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129203820933-303197450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 在Configure方法中添加一个周期性作业，每分钟执行一次输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129204119808-792486993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次启动应用程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129204221917-1396581538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129204255948-236625088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129204320511-535248323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出作业已经有了。&lt;/p&gt;
&lt;p&gt;再次修改代码，假设现在有2个任务，发送跟接收消息，那么写一个接口IMessage，Message实现该接口&lt;img id=&quot;uploading_image_97695&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129204546229-659954198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129204733808-346575489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在starup中注册，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129205019886-574828800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在Configure方法中使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129205113120-1531559982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次启动程序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/566908/201711/566908-20171129205240448-82898676.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新增的2个作业都有了。&lt;/p&gt;
&lt;p&gt;以上只是hangfire在asp.net core中的简单使用。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Nov 2017 12:57:00 +0000</pubDate>
<dc:creator>akaxb</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/akaxb/p/7921783.html</dc:identifier>
</item>
<item>
<title>Activity切换动画---点击哪里从哪放大 - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/7922683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/7922683.html</guid>
<description>&lt;p&gt;emmmm，这次来梳理一下 Activity 切换动画的研究。首先，老规矩，看一下效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1924341-48ee346a06f201d3.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;效果图.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次要实现的动画效果就是类似于上图那样，&lt;strong&gt;点击某个 view，就从那个 view 展开下个 Activity，Activity 退出时原路返回，即缩放到点击的那个 view&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;emmm，如果要你来做这样一个效果，你会怎么做呢？&lt;/p&gt;
&lt;p&gt;我们就一步步的来思考。&lt;/p&gt;
&lt;p&gt;首先来说说，要给 Activity 的切换写动画的话，可以通过什么来实现？也许这种场景比较少，但相信大家多多少少知道一些，嗯，如果你还是不大清楚的话，可以先看看这篇&lt;a href=&quot;http://blog.csdn.net/qq_23547831/article/details/51821159&quot;&gt;实现Activity跳转动画的五种方式&lt;/a&gt;，这个大神总结了几种方式，大概过一下有哪些方案即可，我也没深入阅读，感兴趣的话再慢慢看就可以了。&lt;/p&gt;
&lt;p&gt;这里就大概总结一下几种方式：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1.使用 style 的方式定义 Activity 的切换动画&lt;br/&gt;2.使用 overridePendingTransition 方法实现 Activity 跳转动画&lt;br/&gt;3.使用 ActivityOptions 切换动画实现 Activity 跳转动画(部分动画可支持到 api &amp;gt;= 16)&lt;br/&gt;4.使用 ActivityOptions 动画共享组件的方式实现跳转 Activity 动画(api &amp;gt;= 21)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前我了解的也大概就是以上几种方式，前两种使用方式很简单，只需要在 xml 中写相应的动画（滑进滑出动画、渐变动画、放大动画等），然后应用到相应的 activity 即可。而且还不需要考虑兼容低版本问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--style方式--&amp;gt;
&amp;lt;item name=&quot;android:activityOpenEnterAnimation&quot;&amp;gt;@anim/anim_activity_enter&amp;lt;/item&amp;gt;
&amp;lt;item name=&quot;android:activityCloseExitAnimation&quot;&amp;gt;@anim/anim_activity_exit&amp;lt;/item&amp;gt;

//代码方式
startActivity(intent)
overridePendingTransition(R.anim.anim_activity_enter, R.anim.anim_activity_exit);

//anim_activity_enter.xml 和 anim_activity_exit.xml 就是在 xml 中写动画&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述两种方式使用很简单，效果也很好。&lt;strong&gt;缺点就是，不够灵活，只能实现 xml 写出的动画，即平移、渐变、缩放等基本动画的组合，无法实现炫酷的动画。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，显然，我们开头效果图展示的动画，用这两种 xml 实现的动画方式并没有办法做到，因为&lt;strong&gt;放大动画的中心点位置是需要动态计算的&lt;/strong&gt;。xml 中写缩放动画时，中心点只能是写死的。&lt;/p&gt;
&lt;p&gt;这样的话， &lt;strong&gt;style 的动画方案和 overridePendingTransition 的方案就只能先抛弃了&lt;/strong&gt;，那么再继续看看其他的方案。&lt;/p&gt;
&lt;p&gt;ActivityOptions 动画实现方案应该是 Google 在 Android 5.0 之后推出 Material Design 系列里的一个转场动画方案。当然，Google 在后续也推出了一些内置动画，方便开发者直接使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1924341-2f158d671ad7f419.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MaterialDesign动画示例.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图就是 Google 推出的 Material Design 规范的动画实现里一个示例。关于 Android 5.0 后的动画，网上一大堆相关文章，我也没在这方面里去深入研究过，所以这里就不打算介绍动画要怎么用（不然误导大家就不好了），感兴趣的可以自己去网上找找哈，这里就说下如果要实现开头介绍的动画，用这种方式可行不可行，可行的话又该怎么做。&lt;/p&gt;
&lt;h2 id=&quot;android-5.0-activity-转场动画&quot;&gt;Android 5.0+ Activity 转场动画&lt;/h2&gt;
&lt;p&gt;开个小标题，因为觉得下面会讲比较多的东西。&lt;/p&gt;
&lt;p&gt;开头效果图的动画：新的 Activity 在点击的 View 的中心点放大。&lt;/p&gt;
&lt;p&gt;看上图 MaterialDesign 动画示例中，好像动画效果也是某个 View 展开下个 Activity？那这么说的话，这种方式应该就是可行的了？&lt;/p&gt;
&lt;p&gt;对 5.0+ 动画有所了解的话，示例中的动画应该有个名称叫：&lt;strong&gt;共享元素切换动画&lt;/strong&gt;。意思就是字面上说的，两个 Activity 切换，可以设置它们的共享元素，也就是可以让上个界面的某个 View 在下个界面上做动画的一种效果。&lt;/p&gt;
&lt;p&gt;既然这样，我们就先来看看 5.0+ 动画，用代码怎么写。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1924341-0b5886ad9c85137b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;5.0后切场动画调用.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那些动画要怎么实现的我们就不看了，直接看怎么使用。上图的代码是个例子，如果要使用 5.0+ 的 Activity 转场动画，那就不能再继续使用 startActivity(Intent intent) 了，而是要使用 startActivity(Intent intent, Bundle options) 这个方法了。而 options 参数要传入的就通过 ActivityOptions 类指定的一些转场动画了，Google 为我们封装了一些动画接口，我们就来看看它支持哪些转场。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1924341-a88ab7ebf2dcefc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ActivityOptions动画接口列表.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，下面就来讲讲 &lt;strong&gt;makeScaleUpAnimation()&lt;/strong&gt; 放大动画和 &lt;strong&gt;makeSceneTransitionAnimation()&lt;/strong&gt; 共享元素动画。因为好像只有这两个可以实现开头效果图展示的动画效果。&lt;/p&gt;
&lt;p&gt;对了，上上图中的 ActivityOptionsCompat 类作用的 ActivityOptions 一样，只是前者是 Google 为我们提供的一个兼容实现，因为这是 5.0+ 动画，那么在 5.0 以下的版本就不能使用了，所以 Google 提供了兼容处理，让有些动画可以支持更低版本，动画效果都一致，至于内部具体是怎么实现，有兴趣可以去看看。但也不是所有的动画都做到兼容处理的，像 ActivityOptions 提供的几种动画，基本都可以兼容，但共享元素动画就不行了。至于哪些动画可以兼容，哪些不行，打开 ActivityOptionsCompat 类就清楚了，这个类在 support v4包里，下面就贴张图看看：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1924341-d7d7fd5e7df1a22d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ActivityOptionsCompat.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;makescaleupanimation&quot;&gt;makeScaleUpAnimation()&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1924341-11505ea33d501f89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;makeScaleUpAnimation.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口参数的作用都在上图里注释了，理解了之后有没有发现，这个接口实现的动画效果就是我们想要的！！从哪放大，宽高从多少开始放大都可以自己设定，完美是不是！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不是&lt;/strong&gt;，还是别高兴太早了，这个接口确实可以实现点击哪个 View，就从哪个 View 放大的效果。但是返回呢，Activity 退出时要按原路缩小至点击的 View，这个要怎么做？是吧，找遍了所有接口都没有。&lt;/p&gt;
&lt;p&gt;不止这点，还有我们常见的 &lt;strong&gt;setDuration()&lt;/strong&gt; 有找到么，&lt;strong&gt;setInterpolator()&lt;/strong&gt; 有找到么？没有，都没有，也就是说如果要用这个接口做动画的话，动画的执行时间，还有插值器我们都没办法设置，那这肯定没法满足产品的需求啊，哪里有不修改执行时间和插值器的动画！&lt;strong&gt;所以，这个方案也抛弃&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;makescenetransitionanimation&quot;&gt;makeSceneTransitionAnimation()&lt;/h3&gt;
&lt;p&gt;共享元素动画就复杂多了，不管是我们要使用它的方式还是它内部做的事。总之，我对这个接触也不多，这里就大概概括一下使用的一些步骤：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;需要对共享的元素设置 transitionName，在 xml 中设置 android:transitionName 或代码里调用 View.setTransitionName()。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;startActivity(Intent) 换成 startActivity(Intent intent, Bundle options)，options 需要通过 ActivityOptions.makeSceneTransitionAnimation() 设置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;优点和缺点一会再说，先看看效果：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1924341-2fb8d1a9aba1c0bb.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;共享元素动画.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果貌似就是我们想要的，那我们就来说说这种方式的优缺点，然后再做决定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进入和退出时的动画都是由内部实现了，我们只需要设置参数就行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;共享的元素需要设置相同的 transitionName，我们点击的 View 和打开的 Activity 是动态的，不确定性的。所以，如果对这些 View 都设置相同的 transitionName 不知道会不会有新的问题产生。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;新 Activity 的起始宽高和位置无法设置，默认位置是共享的 View，也可以理解成点击的 View，这点没问题。但起始宽高默认是点击 View 的大小，上面 gif 图演示可能效果不太好。也就是说，放大动画开始时，新 Activity 是从点击 View 的宽高作为起始放大至全屏，返回时从全屏缩小至点击 View 的宽高。上图中点击的 view 都很小，所以看不出什么，但在 Tv 应用的页面中，经常有那种特别大的 view，如果是这种情况，那动画就很难看了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第2点缺点也许可以自己写继续 Transition 写动画来解决，但没研究过共享动画的原理，还不懂怎么修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最大的缺点是只支持 api &amp;gt;= 21 的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基于目前能力不够，不足以解决以上缺点所列问题，所以&lt;strong&gt;暂时抛弃该方案&lt;/strong&gt;，但后期会利用时间来学习下 5.0+ 转场动画原理。&lt;/p&gt;
&lt;p&gt;emmm，这样一来，岂不是就没办法实现效果图所需要的动画了？别急，方案还是有的，继续往下看。&lt;/p&gt;
&lt;h2 id=&quot;github-开源库方案&quot;&gt;Github 开源库方案&lt;/h2&gt;
&lt;p&gt;其实，Github 上有很多这种动画效果的开源库，我找了几个把项目下载下来看了下代码，发现有的人思路是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;Activity 跳转时，先把当前界面截图，然后将这张图传给下个 Activity，然后下个 Activity 打开时将背景设置成上个界面截图传过来的图片，然后再对根布局做放大动画，动画结束后将背景取消掉。&lt;/p&gt;
&lt;p&gt;Activity 退出时有两种方案：&lt;/p&gt;
&lt;p&gt;方案一：将当前 Activity 背景设置成上个界面的截图（这需要对这张图片进行缓存处理，不然图片很大可能已经被回收了），然后对根布局做缩小动画，动画结束之后再执行真正的 finish() 操作。&lt;/p&gt;
&lt;p&gt;方案二：将当前 Activity 界面截图，然后传给新展示到界面的 Activity，然后做缩小动画。（这需要 Activity 有一个置于顶层的 View 来设置截图为背景，然后对这个 View 做动画。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;用-view-动画来实现-activity-转场动画效果&quot;&gt;用 View 动画来实现 Activity 转场动画效果&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（该集中注意力啦，亲爱的读者们，上面其实都是废话啦，就是我自己在做这个动画效果过程中的一些摸索阶段啦，跟本篇要讲的动画实现方案其实关系不大了，不想看废话的可以略过，但下面就是本篇要讲的 Activity 切换动画的实现方案了）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;受到了 Github 上大神开源库的启发，我在想，Activity 界面其实也就是个 View，那既然这样我要打开的 Activity 设置成透明的，然后对根布局做放大动画，这样不就行了？&lt;/p&gt;
&lt;p&gt;想到就做，先是在 style.xml 中设置透明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;item name=&quot;android:windowBackground&quot;&amp;gt;@android:color/transparent&amp;lt;/item&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后实例化一个放大动画：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ScaleAnimation scaleAnimation = new ScaleAnimation(0.0f, 1.0f, 0.0f, 1.0f, x, y);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;宽高从 0 开始放大至全屏，x,y 是放大的中心点，这个可以根据点击的 View 来计算，先看看效果行不行，x,y 就先随便传个值。&lt;/p&gt;
&lt;p&gt;动画也有了，那需要找到 Activity 的根布局。想了下，这动画的代码要么是写在基类里，要么是写个专门的辅助类，不管怎样，代码都需要有共用性，那怎么用相同的代码找到所有不同 Activity 的根布局呢？&lt;/p&gt;
&lt;p&gt;规定一个相同的 id，然后设置到每个 Activity 布局文件的第一个 ViewGroup 里？---是可行，但太麻烦了，要改动的地方也太多了。&lt;/p&gt;
&lt;p&gt;别忘了，&lt;strong&gt;每个 Activity 最底层就是一个 DecorView，虽然这个 DecorView 没有 id，但我们可以通过 getWindow().getDecorView() 来获取到它的引用啊&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;再不然，&lt;strong&gt;我们 setContentLayout() 都是将自己写的布局文件设置到一个 FrameLayout 里，记得吧，这个 FrameLayout 是有 id 的，是 Window 的一个静态常量 ID_ANDROID_CONTENT&lt;/strong&gt;, 所以我们可以通过下面方式来获取到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;View view = activity.findViewById(activity.getWindow().ID_ANDROID_CONTENT);
//View view = activity.getWindow().getDecorView();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;透明属性，动画，View 都有了，那接下去就是执行了，在哪里执行好呢，onCreate() 里或 onStart() 里应该都可以。那就先在 onCreate() 里执行试试看好了。&lt;/p&gt;
&lt;p&gt;噢，对了，很重要一点，&lt;strong&gt;别忘了，Activity 转场是有默认动画的，不同系统可能实现的不同，所以得把这个默认动画关掉&lt;/strong&gt;，所以可以在 BaseActivity 里重写下 startActivity()，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void startActivity(Intent intent) {
    super.startActivity(intent);
    overridePendingTransition(0, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;overridePendingTransition(0, 0) 传入 0 表示不执行切换动画，呈现出来的效果就是下个 Activity 瞬间就显示在屏幕上了，而我们又对下个 Activity 设置了宽高从 0 开始放大的效果，那么理想中实现的效果应该是：当前 Activity 呈现在界面上，然后下个 Activity 逐渐放大到覆盖住全屏。&lt;/p&gt;
&lt;p&gt;好，运行，看下效果：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1924341-62a4b5795ee7cec5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Activity放大动画问题.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咦~，为什么周围会是黑色的呢，都设置了 windowBackground 是透明的了啊，emmm，上网查了下，发现还需要一个半透明属性 windowIsTranslucent，所以去 style.xml 中再加上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;item name=&quot;android:windowBackground&quot;&amp;gt;@android:color/transparent&amp;lt;/item&amp;gt;
&amp;lt;item name=&quot;android:windowIsTranslucent&quot;&amp;gt;true&amp;lt;/item&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再运行试一下，看下效果：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1924341-404a5dc4fb83aae3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Activity放大动画.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，效果出来了。那就下去就是退出时的动画了。退出动画跟打开动画其实就是反过程，动画变成缩小动画：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ScaleAnimation scaleAnimation = new ScaleAnimation(1.0f, 0.0f, 1.0f, 0.0f, x, y);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之前从 0 开始放大，现在换成从全屏开始缩小，x,y 就保存在 intent 携带的数据里。那么也就只剩最后一个问题，缩小动画该什么时候执行呢？&lt;/p&gt;
&lt;p&gt;我们退出一个页面时一般都是用 finish() 的吧，既然这样，在基类里重写一下这个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void finish() {
    ActivityAnimationHelper.animScaleDown(this, new AbsAnimationListener() {
        @Override
        public void onAnimationEnd() {
            BaseActivity.super.finish();
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;x,y 的计算，动画的实现、执行我都是写在一个辅助类里，然后在 BaseActivity 里调用。这个不重要，思想比较重要。我们重写了 finish()，然后去执行缩小动画，同样动画是应用在 Activity 的根布局，然后写一个动画进度的回调，但动画结束时再去调用 super.finish()。也就是说，但调用了 finish() 时，实际上 Activity 并没有 finish() 掉，而是先去执行缩小动画，动画执行完毕再真正的去执行 finish() 操作。&lt;/p&gt;
&lt;p&gt;至此，开头所展示的效果图的动画效果已经实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但你以为事情做完了么？不，填坑之路才刚开始！（哭丧脸）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;优化之路又名填坑之路&quot;&gt;优化之路，又名填坑之路&lt;/h3&gt;
&lt;p&gt;我前面说过，这种方案只能算是一种暂时性的替代方案，知道我什么这么说么？因为这种方案实现是会碰到太多坑了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.动画的流畅性问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先是动画的流畅性问题，本篇里演示的 gif 图之所以看起来还很流畅，是因为切换的两个 Activity 界面都太简单了，但界面布局复杂一点时，打开一个 Activity 界面的测量、布局、绘制以及我们在 onCreate() 里写的一些加载数据、网络请求操作跟放大动画都挤到一起去了，甚至网络请求回来后更新界面时动画都还有可能在执行中，这样动画的流畅性就更惨了。&lt;/p&gt;
&lt;p&gt;在优化时，找到一个大神的一篇文章：&lt;a href=&quot;http://codethink.me/2015/06/21/a-new-implementation-of-activity-transition-animations/&quot;&gt;一种新的Activity转换动画实现方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章里讲的实现原理正是本篇介绍的方案，而且讲得更详细，可以继续去这篇看一下，相信你对本篇介绍的方案会更理解。&lt;/p&gt;
&lt;p&gt;有一点不同的是，大神的放大动画的执行时机是在 onPreDraw() 时机开启的，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
    @Override
    public boolean onPreDraw() {
    view.getViewTreeObserver().removeOnPreDrawListener(this);
        if (view.getAnimation() == animation &amp;amp;&amp;amp; !animation.hasEnded()) {
          return false;
        }
         view.startAnimation(animation);
         return true;
     }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;emmm，说实话，这个回调第一次见，我也不大清楚它的回调时机是什么，作用是什么，网上的解释也摸棱两可，没看明白，待后续有时间自己看看源码好了。&lt;/p&gt;
&lt;p&gt;但我可以跟你们肯定的是，我看了一部分 5.0+ 动画源码，它内部也是在一个 Activity 的 onStart() 方法里注册了 onPreDraw() 回调监听，然后在回调时执行 5.0+ 的动画。但它内部做的事，远不止这些，实在是太多了，估计是进行的一些优化操作，我目前是还没有能力去搞懂。&lt;br/&gt;但我们动画执行的时机是需要换一下了，想一下也知道，在 onCreate() 里做动画，听着就感觉有点奇怪。既然大神，还有 Google 官方都是在 onPreDraw() 里执行，那我们当然可以模仿学习。&lt;/p&gt;
&lt;p&gt;看 5.0+ 源码过程中，发现它在动画开始和结束前会调用一个 ViewGroup 的 suppressLayout() 方法，这个方法隐藏的：&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1924341-a7a7aed7e16f2663.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;suppressLayout.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个隐藏的方法，我们要调用的话，就需要通过反射的方式。这个方法的注释大概是说禁止 ViewGroup 进行 layout() 操作。这样的话，我们有一个可以优化的地方，我们可以在动画开始时调用这个方法禁止 layout() 操作，动画结束时恢复。&lt;/p&gt;
&lt;p&gt;这样做的好处是，动画执行过程中，如果网络或本地数据已经回调，通知 adapter 去刷新 view 时，这样会导致动画很卡顿。所以，当我们用 suppressLayout() 做了优化之后，就只有等动画结束的时候界面才会去重新 layout 刷新布局，优化动画流畅性。&lt;/p&gt;
&lt;p&gt;但这样做也有一个问题是，如果你在 onCreate() 或 onResume() 之类的方法发起一个 requestFocus() 操作的话，很有可能这个操作会被丢弃掉，导致界面理应获得焦点的 view 发生错乱问题。&lt;/p&gt;
&lt;p&gt;至于原因，因为对 suppressLayout() 也还不是很理解，打算等对 onPreDraw() 理解了之后一起研究一下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.windowIsTranslucent 半透明引发的问题&lt;/strong&gt;&lt;br/&gt;哇，这个属性，真的是。。。&lt;br/&gt;你们好奇的话，就网上搜一下这个半透明属性，一堆各种问题。但其实，网上碰到的那些问题，我基本都没遇到过，但我遇到的是更奇葩，网上没找到解决方案的问题，哭瞎。&lt;/p&gt;
&lt;p&gt;emmm，我是做 Tv 应用开发的，windowIsTranslucent 这个在不同的盒子上表现的效果不一样，简直了。&lt;/p&gt;
&lt;p&gt;在设置了 android:windowIsTranslucent=true 时，有的盒子界面就会是透明的，即使你设置了一张不透明的背景图，但透明度不会很明显。&lt;br/&gt;有的盒子则是在新的 Activity 打开时，如果 view 没有完全加载出来，则会显示上个 Activity 的界面，造成的现象就是打开新 Activity 时，会一瞬间闪过上个界面的画面。&lt;/p&gt;
&lt;p&gt;还有，Tv 应用一般都会跟视频播放有关，那就涉及到播放器。而播放器需要一个 surfaceview，而 surfaceview 遇到半透明属性时，问题更多。&lt;/p&gt;
&lt;p&gt;原因，都不清楚（哎，可悲）。但只要不使用半透明这个属性，就一切正常了，但如果不用这个属性，本篇介绍的动画方案又没法实现。这真的是鱼和熊掌不可兼得啊。&lt;/p&gt;
&lt;p&gt;所以，我就在想，&lt;strong&gt;既然 windowIsTranslucent 为 false 时，一切正常；为 true 时，动画正常。那是否有办法在动画过程中设置为 true，动画结束之后设置为 false 呢？&lt;/strong&gt;如果可以的话，按理来说应该正好解决问题。&lt;/p&gt;
&lt;p&gt;但找了半天，没有找到相关的接口来动态设置这个属性的值，这个半透明属性值是设置在 style.xml 里的。网上有一些介绍说：在代码动态修改 style 的，但打开那些文章你会发现，说的是动态修改，但基本都要求要么在 super.onCreate() 之前调用，要么在 setContentLayout() 之前，要么重写 setTheme()，这么多限制，那哪里有用。&lt;/p&gt;
&lt;p&gt;后来，在找播放器黑屏的问题时，找到一篇大神写的博客：&lt;a href=&quot;http://www.jianshu.com/p/b6d682e301c2&quot;&gt;Android版与微信Activity侧滑后退效果完全相同的SwipeBackLayout&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;题目虽然看起来跟本篇一点关系都没有，但作者遇到的问题跟我的问题本质上是一个的，也是 windowIsTranslucent 属性导致的问题。很开心的是，作者介绍了&lt;strong&gt;利用反射去调用 Activity 里的 convertFromTranslucent() 和 convertToTranslucent() 方法来动态修改这个半透明属性值，这两个方法是对外隐藏的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;后来，我很好奇 5.0+ 的动画到底是怎么实现的这种动画效果，因为它明明不需要设置 windowIsTranslucent 为 true，但它的动画，Activity 在跳转时，上个 Activity 是可见的，这是怎么做到的。&lt;/p&gt;
&lt;p&gt;我跟踪了一部分源码，也很开心的发现，原来它内部也是用的 Activity 里的这两个方法，在动画开始前将 Activity 设置成半透明的，动画结束后设置回去。当然，内部它有权限调用 Activity 的方法，而我们没有权限，所以只能通过反射来调用。&lt;/p&gt;
&lt;p&gt;开心，问题解决了。我们只要通过反射，在动画开始之前调用 Activity 的 convertToTranslucent() 将 Activity 设置成半透明的，动画结束再调用 convertFromTranslucent() 设置回去，这样动画的效果达到了，又不会因为设置了 windowIsTranslucent 为 true 而引入各种问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是，测试时发现，在 api 21 以下的盒子上，这个方法没启作用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我去查看，比较了下 21 以上和以下 Activity 的代码，发现 convertToTranslucent() 这个方法它的内部实现是不一样的，21及以上是一套代码，21以下至19是一套代码，19以下则是没有这两个方法。&lt;/p&gt;
&lt;p&gt;后来又仔细看了上面大神那篇文章，发现说，原来 19-21 的版本，这两个方法要能够生效的话，需要默认在 style.xml 先将 Activity 设置成半透明的，而 21 及以上的，则不需要。至于19以下的，就完全不能用这个方法了。&lt;/p&gt;
&lt;p&gt;解决方法也很简单，那就在 style.xml 默认设置 Activity 是半透明的，这样动画结束之后再设回去就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是，这样播放器就会有问题---黑屏&lt;/strong&gt;。原因是因为调用了 convertFromTranslucent() 设置不透明，一旦调用这个方法，如果该界面有播放器，那么就会黑屏。至于具体原因，还是不清楚，上面那个大神的文章里也提到了这个现象，但他也不知道如何解决，我也不知道。&lt;/p&gt;
&lt;p&gt;最后，为了解决黑屏的问题，只能是如果界面有播放器的话，那个这个界面的动画就换另外一种方法来实现，至于是什么方案也可以实现开头介绍的动画效果，我就不说了，Github 上很多，但都有同一个特点，那就是贼麻烦。&lt;/p&gt;
&lt;p&gt;稍微总结一下，本篇提的动画方案适用于以下几种场景：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;如果你的应用设置了 windowIsTranslucent 为 true 时，没有发现什么问题的话，那恭喜你，该动画方案可以兼容各种版本。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;如果你的应用设置了 windowIsTranslucent 为 true 时会有一些问题，但你的应用里没有播放器的话，那恭喜你，该动画方案可以兼容 19 及以上版本。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;如果你的应用设置了 windowIsTranslucent 为 true 时会有一些问题，而且应用里也有播放器的话，那如果你实在走投无路想使用该动画方案的话，那你再来找我吧，在研究出其他方案之前，咱们一起来慢慢填坑。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;注：本篇侧重点是介绍一种 Activity 动画方案的实现思路，注意，是思路！因为本篇所介绍的动画方案并不成熟，仍有很多坑，所以，学习、探讨就可以，慎用！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上传了一个 demo，如果对这种动画方案感兴趣的话，可以去看看代码。跟动画有关的代码都在 ui/anim 文件夹里。&lt;br/&gt;&lt;a href=&quot;https://github.com/woshidasusu/ActivityAnimationDemo&quot;&gt;一种 Activity 转场动画----点击哪里从哪放大&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1924341-ab7dc4915dc5ec24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;项目.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;老样子，最后再留几个问题给大家思考一下（其实我也不懂，还望有大神能解答一下）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q1：overridePendingTransition() 实现的转场动画一点都不卡，但用 View 动画方案来实现 Activity 转场动画有时会有些卡顿，感觉是 Activity 启动做的那一大堆事跟动画挤一起了，那 overridePendingTransition() 原理到底是怎么实现？跟着源码跳进去看感觉有点懵，有时间得再研究一下这部分的源码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2：Activity 切换时，一般下个 Activity 直接覆盖在本 Activity 上了，按我的理解，如果对要打开的 Activity 的 window 设置成透明属性，那应该就可以看到下层的 Activity 才对，为什么不行呢？为什么一定要设置 android:windowIsTranslucent = true 才可以呢？android 5.0 的共享元素动画很明显可以看到下个 Activity 在缩放时，上个 Activity 是可见的，那么它又是怎么实现的呢？原理是什么呢？这部分源码看了一部分了，等理解透了点，在梳理出来。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Nov 2017 12:57:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/7922683.html</dc:identifier>
</item>
<item>
<title>Nuxt框架实践 - 不止前端</title>
<link>http://www.cnblogs.com/buzhiqianduan/p/7922525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buzhiqianduan/p/7922525.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3765249-3ba28d2c1b468621.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;nuxt&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天抽空过了遍nuxt文档，写了个实践demo，关于nuxt我已经断断续续看了好几遍了，自我感觉也算是入门了吧，从开发到上线心里都有底。后期打算在项目用起来的是nuxt框架，一些函数工具库，比如ramda，lodash等等，后台服务估计会使用### &lt;a href=&quot;https://github.com/fastify/fastify&quot;&gt;fastify&lt;/a&gt; 这个库，目测非常方便，尝试尝试。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;基础只是还是以官方文档为主，尝试过程中如果有什么问题可以留言，看到会回复，文章如有错误，欢迎指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;预处理器的使用&quot;&gt;预处理器的使用&lt;/h2&gt;
&lt;p&gt;安装需要的loader后指定lang就可以直接使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm i less less-loader --save--dev

／／全局css
  css: [
    {
      src: 'static/less/base.sass',
      lang: 'less'
    }
  ],
  ／／页面中使用

    &amp;lt;style lang=&quot;less&quot; scoped&amp;gt;&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;页面loading&quot;&gt;页面loading&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//禁用
module.exports = {
  loading: false
}

／／颜色条
module.exports = {
loading: { color: '#3B8070' }
}

／／使用组件
添加一个loading组件 (官方示例如下，详情可看官方文档)
引用该组件
module.exports = {
  loading: '~components/loading.vue'
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
///  components/loading.vue

 &amp;lt;template lang=&quot;html&quot;&amp;gt;
  &amp;lt;div class=&quot;loading-page&quot; v-if=&quot;loading&quot;&amp;gt;
    &amp;lt;p&amp;gt;Loading...&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  data: () =&amp;gt; ({
    loading: false
  }),
  methods: {
    start () {
      this.loading = true
    },
    finish () {
      this.loading = false
    }
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;
.loading-page {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.8);
  text-align: center;
  padding-top: 200px;
  font-size: 30px;
  font-family: sans-serif;
}
&amp;lt;/style&amp;gt;
 
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;按照官方引用组件的方法，我测试报了个错，把~/ 改成 ./ 解决。估计是nuxt解析vue文件的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用插件第三方模块&quot;&gt;使用插件、第三方模块&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;//通过script标签

 head: {  
     script: [
      { src: 'https://res.wx.qq.com/open/js/jweixin-1.2.0.js' }
    ]
  },
  
  //plugins配置 ， ssr：false 设置只在客户端使用
  
   plugins: [
    { src: '~plugins/flexible.js', ssr: false }
  ],

／／在页面中使用axios，配置vendor使其只打包一次

／／页面
&amp;lt;template&amp;gt;
  &amp;lt;h1&amp;gt;{{ title }}&amp;lt;/h1&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import axios from 'axios'

export default {
  async asyncData ({ params }) {
    let { data } = await axios.get(`https://my-api/posts/${params.id}`)
    return { title: data.title }
  }
}
&amp;lt;/script&amp;gt;

／／配置文件

module.exports = {
  build: {
    vendor: ['axios']
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用第三方组件库&quot;&gt;使用第三方组件库&lt;/h2&gt;
&lt;p&gt;在nuxt里使用第三方UI组件库也非常简单。以iview为例（我个人非常中意的组件库）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;///在plugins下新建 iview.js

import Vue from 'vue'
import iView from 'iview';

Vue.use(iView);

////配置文件引入css和plugin

module.exports = {
  css: [
    { src: 'iview/dist/styles/iview.css'}
  ],
  plugins: [
    { src: '~plugins/iview.js', ssr: false }
  ],
 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;路由&quot;&gt;路由&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;
//基础路由示例， 详情请看官方文档

pages/
--| user/
-----| index.vue
-----| one.vue
--| index.vue


router: {
  routes: [
    {
      name: 'index',
      path: '/',
      component: 'pages/index.vue'
    },
    {
      name: 'user',
      path: '/user',
      component: 'pages/user/index.vue'
    },
    {
      name: 'user-one',
      path: '/user/one',
      component: 'pages/user/one.vue'
    }
  ]
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nuxt为我们省去了定义路由的过程，页面结构自动生成路由，不得不说，这对开发效率是有比较大的提升。官方还提供了路由切换动画，中间件等配置，我们可以在切换路由时良好的控制页面。&lt;/p&gt;
&lt;h2 id=&quot;中间件&quot;&gt;中间件&lt;/h2&gt;
&lt;p&gt;开发后台管理页面的时候，我们经常有autu认证需求，如果没有登录，或者权限问题，都有一个脚本去控制跳转，中间件就派上用场了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
  //  middleware/auth.js
  
export default function ({ store, redirect }) {
  if (!store.state.user) {
    return redirect('/login')
  }
}

//页面单独使用

export default {
  middleware: 'auth'
  }

///全局使用

module.exports = {
  router: {
    middleware: 'auth'
  }  
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们定义了一个auth中间件，如果用户未登录，则跳转登录页。&lt;/p&gt;
&lt;h2 id=&quot;视图和错误页&quot;&gt;视图和错误页&lt;/h2&gt;
&lt;p&gt;一般开发SPA页面，我们一般是组件＋页面混合开发，，nuxt则是固定布局layouts，路由必须采用一个layouts，默认default，页面内部我们可以像个vue开发那样引入多个components。&lt;/p&gt;
&lt;p&gt;nuxt可以定义个错误页，在layouts下定义个error.vue文件。具体代码可以看官方文档&lt;/p&gt;
&lt;h2 id=&quot;asyncdata&quot;&gt;asyncData&lt;/h2&gt;
&lt;p&gt;nuxt扩展的异步数据方法，对于页面数据，我们一般有页面data定义的形式和vuex统一管理的形式，可以根据自己的需求选择。&lt;/p&gt;
&lt;p&gt;data定义这里就不赘述了，这里说一下vuex统一管理数据的做法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
///page页面
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;container&quot;&amp;gt;
    &amp;lt;p class=&quot;title&quot;&amp;gt;数据展示!&amp;lt;/p&amp;gt;
    &amp;lt;Table :columns=&quot;columns1&quot; :data=&quot;data1&quot;&amp;gt;&amp;lt;/Table&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  import { mapState } from 'vuex'
  import axios from 'axios'
  
  export default {
    middleware: 'auth',  //定义页面中间件
    head () {
      return {
        title: '其他页面'
      }
    },
    data () {
      return {}
    },
    async fetch ({ store, params }) {
      let { data } = await axios.get('http://106.14.205.222/article/list?page=1&amp;amp;limit=10&amp;amp;isActive=1')
      console.log( data )
      store.commit('SET_LIST', data.list)
    },
    computed: {
      ...mapState([
        // 映射 this.xxx 为 store.state.xxx
        'columns1',
        'data1'
      ])
    },
  }
&amp;lt;/script&amp;gt;


  
  
//store  index.js

import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

const store = () =&amp;gt; new Vuex.Store({
  
  state: {
    columns1: [
      {
        title: '标题',
        key: 'title'
      },
      {
        title: '介绍',
        key: 'intro'
      },
      {
        title: '日期',
        key: 'time'
      }
    ],
    data1: [],
    user: 'xu' //如果为空，则会中间件控制跳转404
  },
  mutations: {
    SET_LIST: (state, data) =&amp;gt; {
      state.data1 = data
    },
  }
})

export default store


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里通过fetch刷新了vuex的数据，页面映射了store的数据，这种写法我们可以通过this.xxx 处理vuex的数据。demo为了快捷只用了index演示，常规项目我们应该采用模块写法。&lt;/p&gt;
&lt;h2 id=&quot;权限配置高级路由鉴权&quot;&gt;权限配置（高级－路由鉴权）&lt;/h2&gt;
&lt;p&gt;还是关于session 和 登录相关的一些权限问题，官方高级文档有非常详细的例子。这里就不在demo里再现了。&lt;a href=&quot;https://zh.nuxtjs.org/examples/auth-routes&quot;&gt;路由鉴权&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对vuex管理数据有兴趣的同学， 可以多看看vuex状态树 和权限相关的文章或者应用，当然官方文档是要烂熟于心的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后台开发以及项目部署&quot;&gt;后台开发以及项目部署&lt;/h2&gt;
&lt;p&gt;后台开发一般就是在项目下在建立一个server文件夹，做到同时输出API和页面，我们可以选择自己喜欢的服务框架 ，比如express活着koa，将nuxt 介入到服务框架来，就可以完成所谓的同构开发。可以看看一个koa例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import Koa from 'koa'
import Nuxt from 'nuxt'
import nuxtConf from '../nuxt.config'


const app = new Koa()

const start = async () =&amp;gt; {
  let config = require('../nuxt.config.js')
  config.dev = !(app.env === 'production')
  const nuxt = await new Nuxt(config)

  if (conf.env !== 'production') {
    try {
      await nuxt.build()
    } catch (e) {
      console.error(e)
      process.exit(1)
    }
  }

  app.use(async (ctx, next) =&amp;gt; {
    ctx.status = 200
    await nuxt.render(ctx.req, ctx.res)
  })

  app.listen(conf.port, conf.host)
  console.log('Server listening on ' + conf.host + ':' + conf.port) // eslint-disable-line no-console
}

start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nuxt自身提供了一个部署命令，可以通过 npm run start 来运行，nuxt还能生成静态页，你可以在在别的地方托管你的网站，比如Githubpage和cdn。喜欢同一管理上线的项目的同学，推荐用pm2 来进行部署。&lt;/p&gt;
&lt;p&gt;一台机器，好几个项目，就可以用nginx来进行反向代理端口。nginx也算是上线必不可少的一步，有空我也会写一篇实践文章。&lt;/p&gt;
&lt;blockquote readability=&quot;3.9166666666667&quot;&gt;
&lt;p&gt;官方也有提供服务框架版本，比如express &lt;a href=&quot;https://github.com/nuxt-community/express-template&quot; class=&quot;uri&quot;&gt;https://github.com/nuxt-community/express-template&lt;/a&gt; ，还有其他的可以自行Github🔍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;nuxt的学习曲线非常小，就像vue框架一样，已经是一个开箱即用的状态，我们可以直接跨过配置直接开发。对配置有兴趣的可以在vue官方文档找到ssr渲染文档。&lt;/p&gt;
&lt;p&gt;本来是想写nuxt ＋ koa ＋ mongodb 的全栈式应用文章的，但是最近比较忙，这个计划只能搁置了。有些方法和好用的东西我我也是最近才学习，觉得不错在文章里做一个分享和记录。来源的话是慕课网Scott老师的《开发微信全家桶项目 Vue/Node/MongoDB高级技术栈全覆盖》视频教程，课程级别为高级，有些地方我自己也是云里雾里，比如API分层，控制器。。不过最让人头疼的还是微信那一堆认证。。。。&lt;/p&gt;
&lt;p&gt;整个nuxt的简单demo我都放在了Github ，对上面的scott老师的视频教程有兴趣的同学，也可以在Github找到源码。demo多实践，工作少踩坑，小公司现在最让我开心的估计是自主开发了，公司项目我可以自己选择使用什么技术。想怎么写怎么写，可以申请整个开发项目，自己开发页面，服务器，数据库，心大的可以用rn开发app。。。相应的这锅也要背好，有压力有动力嘛，写代码这么愉快的事对吧～&lt;/p&gt;
&lt;p&gt;传送门： &lt;a href=&quot;https://github.com/xu455255849/nuxt-demo&quot;&gt;Nuxt示例代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果觉得本文对你有所帮助，就star一下吧～大传送之术！ &lt;a href=&quot;https://github.com/xu455255849/myBlog&quot;&gt;我的博客Github&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Nov 2017 12:24:00 +0000</pubDate>
<dc:creator>不止前端</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/buzhiqianduan/p/7922525.html</dc:identifier>
</item>
<item>
<title>程序员的自我救赎---1.3：事务的使用 - Near_wen</title>
<link>http://www.cnblogs.com/demon28/p/7919665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/demon28/p/7919665.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7886504.html&quot; target=&quot;_blank&quot;&gt;《前言》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;《目录》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（一） Winner2.0 框架基础分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（二） 短信中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（三）SSO单点登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（四）PLSQL报表系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（五）钱包系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（六）GPU支付中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（七）权限系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（八）监控系统&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（九）会员中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十）消息中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十一）Winner前端框架与RPC接口规范讲解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt;（十二）上层应用案例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7887136.html&quot; target=&quot;_blank&quot;&gt; （十三）番外篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;《事务的使用》&lt;/p&gt;

&lt;p&gt;关于事务，我今天要把自己放在一个初学者的心态来写这篇文章。之前几篇文章大多讲的是对于Winner的应用，今天要从根本上来讲&lt;/p&gt;
&lt;p&gt;一下“事务”，以及事务在Winner中的应用。&lt;/p&gt;

&lt;p&gt;首先从基础讲起，什么是“事务”？事务能帮我们解决哪些问题？ 摘录百度上的一段话教科书式的文字：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实很好理解，比如说我们的商品购物流程中支付成功之后要做的几步操作： &lt;/p&gt;
&lt;p&gt;1，修改订单表该状态；&lt;/p&gt;
&lt;p&gt;2，修改库存表库存数量；&lt;/p&gt;
&lt;p&gt;3，添加物流表发货信息；&lt;/p&gt;
&lt;p&gt;三个操作必须一气呵成，这时候就需要串联事务，当一个操作失败之后，事务就回滚整个业务失败。当操作成功之后，所有操作才最终持久化执行。&lt;/p&gt;

&lt;p&gt;假设我们没有事务的话，会怎么样？&lt;/p&gt;
&lt;p&gt;还是上面三个流程，没有联事务就有可能出现以下情况：&lt;/p&gt;
&lt;p&gt;步骤一： 修改订单表该状态 （完成）&lt;/p&gt;
&lt;p&gt;步骤二：修改库存表库存数量 (完成)&lt;/p&gt;
&lt;p&gt;步骤三：添加物流发货信息（失败）&lt;/p&gt;

&lt;p&gt;当步骤三失败，由于没有事务回滚，程序中就必须得通过程序判断步骤三得到失败后，再操作“步骤二”中库存订单数量回到未修改前的值。&lt;/p&gt;
&lt;p&gt;同事还要还原“步骤一”中订单表的订单状态。&lt;/p&gt;
&lt;p&gt;而且，如果数据库健壮性不够，有可能导致二次修改步骤一，步骤二失败，造出数据库一片混乱。&lt;/p&gt;

&lt;p&gt;这就是为什么我们要使用事务，事务有四大特性（百度摘录）：&lt;/p&gt;

&lt;h3 class=&quot;title-text&quot;&gt;&lt;span&gt;原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。&lt;/span&gt;&lt;/h3&gt;
&lt;h3 class=&quot;title-text&quot;&gt;&lt;span&gt;一致性：事务在完成时，必须使所有的数据都保持一致状态。&lt;/span&gt;&lt;/h3&gt;
&lt;h3 class=&quot;title-text&quot;&gt;&lt;span&gt;隔离性：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。&lt;/span&gt;&lt;/h3&gt;
&lt;h3 class=&quot;title-text&quot;&gt;&lt;span&gt;持久性：事务完成之后，它对于系统的影响是永久性的。&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;这些其实我也早忘了，毕竟工作多年以后也不会有这样的考试，读书那会还是记得挺清楚的，只是那会不能感受到&lt;/p&gt;
&lt;p&gt;事务的重要性，那时候的老师也不管那么多就照本宣科的讲，那些是以后工作生涯的重点，有时候老师自己都不知道&lt;/p&gt;
&lt;p&gt;造成了我们可能花很多时间去理解“游标”，“函数” 这些压根用不着几次的东西。&lt;/p&gt;

&lt;p&gt;开始事物：begin transaction&lt;/p&gt;
&lt;p&gt;提交事物：commit  transaction&lt;/p&gt;
&lt;p&gt;回滚事物：rollback transaction&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;begin&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt;  
 
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@errorSum&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;      &lt;span&gt;--&lt;/span&gt;&lt;span&gt;定义局部变量  &lt;/span&gt;
 
&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  &lt;span&gt;--&lt;/span&gt;&lt;span&gt;初始化临时变量  &lt;/span&gt;
 
&lt;span&gt;update&lt;/span&gt; bank &lt;span&gt;set&lt;/span&gt; currentMoneycurrentMoney&lt;span&gt;=&lt;/span&gt; currentMoney&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; customerName&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
 
&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;@@error&lt;/span&gt;    &lt;span&gt;--&lt;/span&gt;&lt;span&gt;累计是否有错误  &lt;/span&gt;
 
&lt;span&gt;update&lt;/span&gt; bank &lt;span&gt;set&lt;/span&gt; currentMoneycurrentMoney&lt;span&gt;=&lt;/span&gt; currentMoney&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; customerName&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 
 
&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;@@error&lt;/span&gt;    &lt;span&gt;--&lt;/span&gt;&lt;span&gt;累计是否有错误  &lt;/span&gt;
 
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;@errorSum&lt;/span&gt;&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;     &lt;span&gt;--&lt;/span&gt;&lt;span&gt;如果有错误  &lt;/span&gt;
 
&lt;span&gt;begin&lt;/span&gt;  
 
&lt;span&gt;rollback&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt;  
 
&lt;span&gt;end&lt;/span&gt;  
 
&lt;span&gt;else&lt;/span&gt;  
 
&lt;span&gt;begin&lt;/span&gt;  
 
&lt;span&gt;commit&lt;/span&gt;  &lt;span&gt;transaction&lt;/span&gt;  
 
&lt;span&gt;end&lt;/span&gt;  
 
&lt;span&gt;go&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我就偷个懒，不自己去写个事务的案例，直接从网络上摘录，出处与：http://database.51cto.com/art/201108/283348.htm。&lt;/p&gt;
&lt;p&gt;每个数据库语法略又有不同，大整体差不到哪去我这里就不详细解释每个关键字上面意思了，自行百度吧！ 再说这还是比较基础的知识，我就一笔带过。&lt;/p&gt;

&lt;p&gt;最后在事务基础知识再补充一点，使用事务时一定要谨慎，事务必须 “一开一关”，开启了一个事务必须要关闭这个事务，无论是提交（commit ） 还是 回滚（roolback）。&lt;/p&gt;
&lt;p&gt;必须要有关闭操作，如果没有关闭事务，则会造成事务挂起。数据库就会被锁，一旦数据数据被锁，轻则导致该表不能操作，重则导致整个数据库不能操作，致使整个&lt;/p&gt;
&lt;p&gt;程序奔溃不能运行。 这里一定要谨慎，在我工作了8年后我任然很多次看到我们系统会出现锁表的情况，都是有个别程序员对事务应用不当，导致事务挂起，数据库死锁。&lt;/p&gt;

&lt;p&gt;Winner一直使用的是Oracle数据库，这里贴一个我们常用的Sql工具：&quot;锁表侦探&quot;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; ROOT, L.SID_BLOCKED, L.TYPE, L.LMODE, SINFO.&lt;span&gt;*&lt;/span&gt;
  &lt;span&gt;FROM&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; ROWNUM ORDERNO, CONNECT_BY_ROOT SID_WAITING ROOT, T.&lt;span&gt;*&lt;/span&gt;
          &lt;span&gt;FROM&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; B.SID SID_BLOCKED, W.SID SID_WAITING, W.TYPE, W.LMODE
                  &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; V$LOCK B, V$LOCK W
                 &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; B.ID1 &lt;span&gt;=&lt;/span&gt;&lt;span&gt; W.ID1
                   &lt;/span&gt;&lt;span&gt;AND&lt;/span&gt; B.ID2 &lt;span&gt;=&lt;/span&gt;&lt;span&gt; W.ID2
                   &lt;/span&gt;&lt;span&gt;AND&lt;/span&gt; B.BLOCK &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
                   &lt;span&gt;AND&lt;/span&gt; W.REQUEST &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;
                &lt;span&gt;UNION&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;
                &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;, SID, TYPE, LMODE
                  &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; V$LOCK B
                 &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; B.BLOCK &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
                   &lt;span&gt;AND&lt;/span&gt; SID &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;DISTINCT&lt;/span&gt;&lt;span&gt; W.SID SID_WAITING
                                     &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; V$LOCK B, V$LOCK W
                                    &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; B.ID1 &lt;span&gt;=&lt;/span&gt;&lt;span&gt; W.ID1
                                      &lt;/span&gt;&lt;span&gt;AND&lt;/span&gt; B.ID2 &lt;span&gt;=&lt;/span&gt;&lt;span&gt; W.ID2
                                      &lt;/span&gt;&lt;span&gt;AND&lt;/span&gt; B.BLOCK &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
                                      &lt;span&gt;AND&lt;/span&gt; W.REQUEST &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)) T
         START &lt;/span&gt;&lt;span&gt;WITH&lt;/span&gt; SID_BLOCKED &lt;span&gt;IS&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;
        CONNECT &lt;/span&gt;&lt;span&gt;BY&lt;/span&gt; SID_BLOCKED &lt;span&gt;=&lt;/span&gt;&lt;span&gt; PRIOR SID_WAITING) L
  &lt;/span&gt;&lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; S.SID,
                    SERIAL#,
                    O.OBJECT_NAMES,
                    T.START_TIME,
                    S.STATUS,
                    ST.SQL_TEXT,
                    S.MACHINE,
                    
                    S.PROGRAM,
                    S.USERNAME,
                    S.LOGON_TIME
               &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; V$SESSION S
               &lt;/span&gt;&lt;span&gt;JOIN&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; SESSION_ID,
                           SUBSTR(SYS_CONNECT_BY_PATH(&lt;/span&gt;&lt;span&gt;OBJECT_NAME&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;), &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) OBJECT_NAMES
                      &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; ROW_NUMBER() &lt;span&gt;OVER&lt;/span&gt;(PARTITION &lt;span&gt;BY&lt;/span&gt; SESSION_ID &lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;OBJECT_NAME&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; RN,
                                   LO.&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;,
                                   O.&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;
                              &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; V$LOCKED_OBJECT LO
                              &lt;/span&gt;&lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; DBA_OBJECTS O
                                &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; LO.&lt;span&gt;OBJECT_ID&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; O.&lt;span&gt;OBJECT_ID&lt;/span&gt;&lt;span&gt;) T
                     &lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; CONNECT_BY_ISLEAF &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
                     START &lt;/span&gt;&lt;span&gt;WITH&lt;/span&gt; RN &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
                    CONNECT &lt;/span&gt;&lt;span&gt;BY&lt;/span&gt; SESSION_ID &lt;span&gt;=&lt;/span&gt;&lt;span&gt; PRIOR SESSION_ID
                           &lt;/span&gt;&lt;span&gt;AND&lt;/span&gt; RN &lt;span&gt;=&lt;/span&gt;&lt;span&gt;
                              
                               PRIOR RN &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) O
                 &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; S.SID &lt;span&gt;=&lt;/span&gt;&lt;span&gt; O.SESSION_ID
               &lt;/span&gt;&lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; V$&lt;span&gt;TRANSACTION&lt;/span&gt;&lt;span&gt; T
                 &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; S.TADDR &lt;span&gt;=&lt;/span&gt;&lt;span&gt; T.ADDR
               &lt;/span&gt;&lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt;&lt;span&gt; V$SQLAREA ST
                 &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; ST.ADDRESS &lt;span&gt;=&lt;/span&gt;&lt;span&gt; S.SQL_ADDRESS) SINFO
    &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; SINFO.SID &lt;span&gt;=&lt;/span&gt;&lt;span&gt; L.SID_WAITING
 &lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; ORDERNO;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在后面的篇章中会讲到“报表系统”，我习惯把锁表侦探添加到报表系统中，每次遇到锁表情况的时候就上报表系统查看是哪个项目锁表。&lt;/p&gt;
&lt;p&gt;这里有人就会问了，锁表侦探能查出具体哪张表所了，那怎么监控数据库有没有锁表的迹象？ 这里要推荐第二个工具：“Spotligth”&lt;/p&gt;
&lt;p&gt;翻译过来叫“聚光灯”， Spotligth有很多版本，有监控 服务器的，有监控数据库的（主流都支持）&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.spotlightessentials.com&quot; target=&quot;_blank&quot;&gt;spotlight on Oracle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.spotlightessentials.com&quot; target=&quot;_blank&quot;&gt;spotlight on Mysql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.spotlightessentials.com&quot; target=&quot;_blank&quot;&gt;spotlight on Windows&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我上班的时候 是两台电脑，一台办公，另外一台则挂着Spotligth 实时监控着我们的数据库，一飘红里面上报表系统查“锁表侦探”&lt;/p&gt;
&lt;p&gt;然后通知到相应的技术员，当然有时候还免不了要对犯错误的技术员 “指点”几句。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171129114639050-920037730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; =======================华丽的分割线=======================&lt;/p&gt;

&lt;p&gt;基础知识就到这里了，下面就是Winner的干货了。 在整个Winner中，我觉得最牛逼的当属“事务”这一块，能想出这种方式并开发出来了的真的很厉害。&lt;/p&gt;
&lt;p&gt;最初我在上家公司任职时，我的老大（William ）他跟我讲事务的时候我就觉得太屌了，而这个事务就是由他开发的。&lt;/p&gt;

&lt;p&gt;其他的不多说，贴一张图就知道Winner中的事务有多好用：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/161176/201711/161176-20171129120314237-146759762.png&quot; alt=&quot;&quot; width=&quot;1601&quot; height=&quot;1001&quot;/&gt;&lt;/p&gt;

&lt;p&gt;真的超级好用，一来不用写一句Sql，二来业务流程清晰，尤其是当程序需要调试的时候，这种方式能让程序员清晰的看到业务逻辑的每一个流程。&lt;/p&gt;
&lt;p&gt;这里运用到一个“职责分离”的思想，我们设定数据库的职责就是：&lt;strong&gt;“持久化存储数据”&lt;/strong&gt;  复杂的业务逻辑由程序去处理。&lt;/p&gt;

&lt;p&gt;我刚参加工作那会任职过的几家公司，就没有这种思想（可能也是因为去的都是单一的项目型公司）。 最常见的就是 一旦涉及业务流程处理的他们&lt;/p&gt;
&lt;p&gt;就习惯性的以“存储过程”去处理，这样就使得开发变得繁琐，一会要写C#代码，一会有要去写sql代码，最重要的是数据库的不同又造成程序员要熟悉&lt;/p&gt;
&lt;p&gt;各种数据库的sql语法来写存储过程、事务、函数等等。&lt;/p&gt;

&lt;p&gt;“职责分离”的思想跟设计模式六大原则中的“单一职责”有点类似，但是“单一职责”更多的是指在程序中一个类只负责一项职责。“职责分离” 相当于“单一职责”&lt;/p&gt;
&lt;p&gt;的抽象版，程序做程序的负责业务逻辑，数据库做数据库的数据存储。   &lt;/p&gt;

&lt;p&gt;我曾经也见过，有的公司一开始用的sqlserver数据库，然后开发方式还是当时特牛气的 &lt;strong&gt;Html + Ajax + C# + 存储过程&lt;/strong&gt;，后来因为业务关系更换到MySql，大量的存储&lt;/p&gt;
&lt;p&gt;过程写在了数据库里面，特别是有些关键字Mysql是没有或不支持的，致使他们痛苦不堪。&lt;/p&gt;

&lt;p&gt;==============================华丽的分割线========================&lt;/p&gt;

&lt;p&gt;我们来看看Winner是如何实现的，首先Winner的业务类对象都基础了 FacadeBase 这个基类。 （关于Winner解决方案不清楚的可以&lt;a href=&quot;http://www.cnblogs.com/demon28/p/7905369.html&quot; target=&quot;_blank&quot;&gt;《解决方案命名规范》&lt;/a&gt;）&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using System;
using Winner.Framework.Core.DataAccess;
using Winner.Framework.Core.Interface;
using Winner.Framework.Utils;

namespace Winner.Framework.Core.Facade
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; class FacadeBase : IDisposable, IPromptInfo
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IChangePage ChangePage;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FacadeBase();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PromptInfo PromptInfo { get; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Transaction&lt;/span&gt; &lt;span&gt;Transaction&lt;/span&gt;&lt;span&gt; { get; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; virtual void Dispose();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; void ReferenceTransactionFrom(&lt;span&gt;Transaction&lt;/span&gt; &lt;span&gt;transaction&lt;/span&gt;&lt;span&gt;);
        protected void Alert(ResultType restulType);
        protected void Alert(PromptInfo result);
        protected void Alert(string msg);
        protected void Alert(ResultType restulType, PromptInfo result);
        protected void Alert(ResultType restulType, string msg);
        protected void Alert(string msg, PromptInfo result);
        protected void Alert(ResultType restulType, string msg, PromptInfo result);
        protected void BeginTransaction();
        protected void &lt;/span&gt;&lt;span&gt;Commit&lt;/span&gt;&lt;span&gt;();
        protected void RealRollback();
        protected void &lt;/span&gt;&lt;span&gt;Rollback&lt;/span&gt;&lt;span&gt;();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  FacadeBase在&lt;a title=&quot;Winner.Framework.Core&quot; href=&quot;http://winner.t01.pw:81/html/7644f824-ba30-361e-f5f3-d419355b06f6.htm&quot; data-tochassubtree=&quot;true&quot;&gt;Winner.Framework.Core&lt;/a&gt; 程序集中，关于 FacadeBase其他的方法后面的篇章中再详细讲，今天重点讲事务这一块。&lt;/p&gt;

&lt;pre&gt;
public Transaction Transaction&lt;span&gt; { get; } 定义事务对象； 对象由&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;public void ReferenceTransactionFrom(Transaction transaction&lt;span&gt;); 串联事务；&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;protected void BeginTransaction(); 开启事务；&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;protected void Rollback&lt;span&gt;();  回滚事务；&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;protected void Commit&lt;span&gt;(); 提交事务；&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;protected void RealRollback(); 强制回滚事务；&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.Core.DataAccess;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.Core.Interface;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.Utils;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Winner.Framework.Core.Facade
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通用三层架构的业务处理层(BLL)基类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FacadeBase : IDisposable, IPromptInfo
    {
      &lt;/span&gt;
        &lt;span&gt;#region&lt;/span&gt; 事务
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事物对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Transaction Transaction { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 开启事务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BeginTransaction()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.Transaction == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Transaction = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Winner.Framework.Core.DataAccess.Transaction();
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Transaction.BeginTransaction();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 提交事务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Commit()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Transaction.Commit();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 强制回滚事物
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RealRollback()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Transaction.RealRollback();
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事物串联
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;transaction&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;事物对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReferenceTransactionFrom(Transaction transaction)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Transaction =&lt;span&gt; transaction;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 回滚事物
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Rollback()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Transaction.Rollback();
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

    &lt;span&gt;

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;为了更清楚的单一讲清楚事务，FacadeBase我精剪掉了其他方法，只剩下事务有关的方法，会看到FacadeBase作为调用实现几个基本的操作&lt;/p&gt;
&lt;p&gt;整个Winner事务的核心在Winner.Framework.Core.DataAccess.Transaction  这个对象中。&lt;/p&gt;

&lt;p&gt;下面贴一些阿杰开发的Winner2.0 的事务对象，写的非常漂亮。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data.Common;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.Core.CustomException;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.Core.Delegate;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Winner.Framework.Utils;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Winner.Framework.Core.DataAccess
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 数据库事务机制
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;![CDATA[
&lt;/span&gt;    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 四大特性：原子性、一致性、隔离性、持久性
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; ]]&amp;gt;
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt;
    [DebuggerDisplay(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;事务状态={Status},计数器={Counter}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Transaction
    {
        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; Event

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 开启事务时触发
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; BeginTransaction BeginTransactionEvent;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 提交事务时触发
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; CommitTransaction CommitEvent;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 强制回滚时触发
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; RealRollbackTransaction RealRollbackEvent;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 回滚事务时触发
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; RollbackTransaction RollbackEvent;

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; Property

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否已开启事务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsBegin { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否提交
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsCommit { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否强制回滚
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsRealRollback { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是否回滚
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsRollback { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事务计数器
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Counter { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }


        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事务状态
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; TransactionStatus Status { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取或设置连接数据库对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;internal&lt;/span&gt; IDbConnection DbConnection { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取或设置事务机制对象
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;internal&lt;/span&gt; IDbTransaction DBTransaction { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; Member

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 开启事务(此处不真正开事务，会导致性能问题，所以在使用ADO.NET对象时才开启事务)
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BeginTransaction()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.Counter == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Status =&lt;span&gt; TransactionStatus.已启动事务;
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.IsBegin = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.IsCommit = &lt;span&gt;this&lt;/span&gt;.IsRollback = &lt;span&gt;this&lt;/span&gt;.IsRealRollback = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.BeginTransactionEvent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.BeginTransactionEvent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                    }
                }
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Counter++&lt;span&gt;;
                OutupRunLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BeginTransaction() Counter: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Counter);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Debuger.IsDebug)
                {
                    Log.Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开启事务时出现异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
                }
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TransactionException(e);
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 提交事务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Commit()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.IsRealRollback)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Counter)
                {
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TransactionException(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Status.ToString());

                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DBTransaction.IsNull())
                        {
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DBTransaction.Commit();
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DbConnection.IsNull())
                        {
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DbConnection.Close();
                        }
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Status =&lt;span&gt; TransactionStatus.事务已提交;
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.IsCommit = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.IsBegin = &lt;span&gt;this&lt;/span&gt;.IsRollback = &lt;span&gt;this&lt;/span&gt;.IsRealRollback = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.CommitEvent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CommitEvent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                        }
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                OutupRunLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Commit() Counter: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Counter);
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Counter--&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Debuger.IsDebug)
                {
                    Log.Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交事务时出现异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
                }
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 强制回滚事务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RealRollback()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.IsRollback)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DBTransaction.IsNull())
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DBTransaction.Rollback();
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DbConnection.IsNull())
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DbConnection.Close();
                }

                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Status =&lt;span&gt; TransactionStatus.事务已强制回滚;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.IsRollback = &lt;span&gt;this&lt;/span&gt;.IsRealRollback = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.IsBegin = &lt;span&gt;this&lt;/span&gt;.IsCommit = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.RealRollbackEvent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.RealRollbackEvent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                }
                OutupRunLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RealRollback()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Debuger.IsDebug)
                {
                    Log.Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;强制回滚事务出现异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ex);
                }
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TransactionException(ex);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.IsRealRollback = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 回滚事务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Rollback()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.IsRealRollback)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Counter)
                {
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;:
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TransactionException(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Status.ToString());

                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DBTransaction.IsNull())
                        {
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DBTransaction.Rollback();
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DbConnection.IsNull())
                        {
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DbConnection.Close();
                        }
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Status =&lt;span&gt; TransactionStatus.事务已回滚;
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.IsRollback = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.IsBegin = &lt;span&gt;this&lt;/span&gt;.IsCommit = &lt;span&gt;this&lt;/span&gt;.IsRealRollback = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.RollbackEvent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.RollbackEvent(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                        }
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }

                OutupRunLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Rollback() Counter: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Counter);
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Counter--&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Debuger.IsDebug)
                {
                    Log.Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;回滚事务时出现异常&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
                }
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
            }
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 输出运行日志
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;msg&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OutupRunLog(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; msg)
        {
            Debug.WriteLine(msg);
            Console.WriteLine(msg);
        }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事务状态
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; TransactionStatus
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 未开启事务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        未启动事务 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 已开启事务，但未操作数据库
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        已启动事务 = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 已开启事务，并有数据库事务被挂起
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        事务已挂起 = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        事务已提交 = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事务已回滚
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        事务已回滚 = &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事务已强制回滚
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        事务已强制回滚 = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;  原理不复杂，都是调用System.Data 的 IDbTransaction 去完成的，经典的地方在于这个 Counter 事务计数器累加事务。&lt;/p&gt;
&lt;p&gt;而且阿杰的代码有个很有限的地方，并不是调用 BeginTransaction()，就去开启事务，这里是一个非常巧妙巧妙的设计，有效的&lt;/p&gt;
&lt;p&gt;避免了个别马虎的技术员开启了事务却有在代币流程中忘记提交or回滚造成的数据库死锁。&lt;/p&gt;

&lt;p&gt;下午阿杰过来和我聊了会，我说我在写关于事务的博客，阿杰说了很多。包括他当初为什么这样设计，以及他综合了动软基础框架的&lt;/p&gt;
&lt;p&gt;事务，还有微软的分布式事务。只是我还没办法转换成自己的语言写成博客，同时也要我经历像阿杰这样的创作过程，才能&lt;/p&gt;
&lt;p&gt;像他那样富含底蕴的讲述他的思考逻辑。&lt;/p&gt;

&lt;p&gt;今天我就写到这里，本来想跟深入的剖析一下Transaction对象，但是仔细看了一下，有些地方我也不是特别明白。哈哈，有点尴尬！&lt;/p&gt;
&lt;p&gt;关于对事务这一块的理解，如果有机会我希望阿杰也能写一篇博客，比我更详细的阐述Winner事务，尤其是他在对比多个框架的事务后，&lt;/p&gt;
&lt;p&gt;他对Winner创作过程的思考。他一定写的比我出彩，毕竟我只是一个使用者，而他是创这者。&lt;/p&gt;

&lt;p&gt;关于Winner，我新建了一个QQ群，有兴趣的可以加我们QQ群，阿杰，jason都在群中。我们可以一起探讨Winner，群号:261083244 &lt;/p&gt;
&lt;p&gt;也可以扫描博客左侧二维码加群。&lt;/p&gt;








</description>
<pubDate>Wed, 29 Nov 2017 12:23:00 +0000</pubDate>
<dc:creator>Near_wen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/demon28/p/7919665.html</dc:identifier>
</item>
</channel>
</rss>