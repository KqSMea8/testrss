<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Django REST framework+Vue 打造生鲜超市（六） - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/8813641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/8813641.html</guid>
<description>&lt;h2&gt;七、用户登录与手机注册&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;7.1.drf的token&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）INSTALL_APP中添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
INSTALLED_APPS =&lt;span&gt; (
    ...
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rest_framework.authtoken&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; token会生成一张表authtoken_token，所以要运行migrations和migrate&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180413205548712-1932947058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）url配置  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework.authtoken &lt;span&gt;import&lt;/span&gt;&lt;span&gt; views


urlpatterns &lt;/span&gt;=&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; token&lt;/span&gt;
    path(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;api-token-auth/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, views.obtain_auth_token)
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）postman发送数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180413214035936-1946337023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;token值会保存到数据中，跟这个用户相关联&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180413214145821-1356317899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （4）客户端身份验证&lt;/p&gt;
&lt;p&gt;对于客户端进行身份验证，令牌密钥应包含在 &lt;code&gt;Authorization&lt;/code&gt; HTTP header 中。关键字应以字符串文字 “Token” 为前缀，用空格分隔两个字符串。例如：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-python&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Authorization: Token 9944b09199c62bcf9418ad846dd0e4bbdfc6ee4b
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意： 如果您想在 header 中使用不同的关键字（例如 &lt;code&gt;Bearer&lt;/code&gt;），只需子类化 &lt;code&gt;TokenAuthentication&lt;/code&gt; 并设置 &lt;code&gt;keyword&lt;/code&gt; 类变量。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果成功通过身份验证，&lt;code&gt;TokenAuthentication&lt;/code&gt; 将提供以下凭据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;request.user&lt;/code&gt; 是一个 Django &lt;code&gt;User&lt;/code&gt; 实例.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request.auth&lt;/code&gt; 是一个 &lt;code&gt;rest_framework.authtoken.models.Token&lt;/code&gt; 实例.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;未经身份验证的响应被拒绝将导致 &lt;code&gt;HTTP 401 Unauthorized&lt;/code&gt; 的响应和相应的 WWW-Authenticate header。例如：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-python&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
WWW-Authenticate: Token
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt; 要想获取request.user和request.auth还要在settings中添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
REST_FRAMEWORK =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DEFAULT_AUTHENTICATION_CLASSES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: (
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rest_framework.authentication.BasicAuthentication&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rest_framework.authentication.SessionAuthentication&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rest_framework.authentication.TokenAuthentication&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    )
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; drf的token缺点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保存在数据库中，如果是一个分布式的系统，就非常麻烦&lt;/li&gt;
&lt;li&gt;token永久有效，没有过期时间。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;7.2.json web token方式完成用户认证&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;使用方法：http://getblimp.github.io/django-rest-framework-jwt/&lt;/p&gt;
&lt;p&gt;（1）安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip install djangorestframework-jwt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
REST_FRAMEWORK =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DEFAULT_AUTHENTICATION_CLASSES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: (
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rest_framework.authentication.BasicAuthentication&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rest_framework.authentication.SessionAuthentication&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rest_framework_jwt.authentication.JSONWebTokenAuthentication&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    )
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）url&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; jwt的token认证接口&lt;/span&gt;
    path(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jwt-auth/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, obtain_jwt_token )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）postman&lt;/p&gt;
&lt;p&gt;post形式：http://127.0.0.1:8000/jwt-auth/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180413233203383-485145717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Now in order to access protected api urls you must include the &lt;code&gt;Authorization: JWT &amp;lt;your_token&amp;gt;&lt;/code&gt; header.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ curl -H &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization: JWT &amp;lt;your_token&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; http://localhost:8000/protected-url/
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;7.3.vue和jwt接口调试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;vue中登录接口是login&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
//&lt;span&gt;登录
export const login &lt;/span&gt;= params =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; axios.post(`${local_host}/login/&lt;span&gt;`, params)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后台的接口跟前端要一致&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
urlpatterns =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; jwt的认证接口&lt;/span&gt;
    path(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, obtain_jwt_token )
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在就可以登录了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180413235051769-937150989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; jwt接口它默认采用的是用户名和密码登录验证，如果用手机登录的话，就会验证失败，所以我们需要自定义一个用户验证&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 自定义用户认证&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; （1）settings中配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
AUTHENTICATION_BACKENDS =&lt;span&gt; (
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;users.views.CustomBackend&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,

)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）users/views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; users.views.py&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.contrib.auth.backends &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ModelBackend
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.auth &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get_user_model
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.db.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Q

User &lt;/span&gt;=&lt;span&gt; get_user_model()

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomBackend(ModelBackend):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    自定义用户验证
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; authenticate(self, username=None, password=None, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;用户名和手机都能登录&lt;/span&gt;
            user =&lt;span&gt; User.objects.get(
                Q(username&lt;/span&gt;=username) | Q(mobile=&lt;span&gt;username))
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; user.check_password(password):
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; user
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; None
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）JWT有效时间设置&lt;/p&gt;
&lt;p&gt;settings中配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;有效期限&lt;/span&gt;
JWT_AUTH =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;JWT_EXPIRATION_DELTA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: datetime.timedelta(days=7),    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;也可以设置seconds=20&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;JWT_AUTH_HEADER_PREFIX&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;JWT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,                       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;JWT跟前端保持一致，比如“token”这里设置成JWT&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;7.4.云片网发送短信验证码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）注册&lt;/p&gt;
&lt;p&gt; “开发认证”--&amp;gt;&amp;gt;“签名管理”--&amp;gt;&amp;gt;“模板管理”&lt;/p&gt;
&lt;p&gt; 还要添加iP白名单，测试就用本地ip，部署的时候一定要换成服务器的ip&lt;/p&gt;
&lt;p&gt;（2）发送验证码&lt;/p&gt;
&lt;p&gt;apps下新建utils文件夹。再新建yunpian.py，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; apps/utils/yunpian.py&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; YunPian(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, api_key):
        self.api_key &lt;/span&gt;=&lt;span&gt; api_key
        self.single_send_url &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://sms.yunpian.com/v2/sms/single_send.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; send_sms(self, code, mobile):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;需要传递的参数&lt;/span&gt;
        parmas =&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apikey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: self.api_key,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mobile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: mobile,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【慕雪生鲜超市】您的验证码是{code}。如非本人操作，请忽略本短信&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(code=&lt;span&gt;code)
        }

        response &lt;/span&gt;= requests.post(self.single_send_url, data=&lt;span&gt;parmas)
        re_dict &lt;/span&gt;=&lt;span&gt; json.loads(response.text)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; re_dict

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;例如：9b11127a9701975c734b8aee81ee3526&lt;/span&gt;
    yun_pian = YunPian(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2e87d17327d4be01608f7c6da23ecea2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    yun_pian.send_sms(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;手机号码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;7.5.drf实现发送短信验证码接口&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;手机号验证：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;是否合法&lt;/li&gt;
&lt;li&gt;是否已经注册&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1）settings.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 手机号码正则表达式&lt;/span&gt;
REGEX_MOBILE = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;^1[358]\d{9}$|^147\d{8}$|^176\d{8}$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）users下新建serializers.py,代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; users/serializers.py&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime, timedelta
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; MxShop.settings &lt;span&gt;import&lt;/span&gt;&lt;span&gt; REGEX_MOBILE
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; users.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; VerifyCode
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework &lt;span&gt;import&lt;/span&gt;&lt;span&gt; serializers
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.auth &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get_user_model
User &lt;/span&gt;=&lt;span&gt; get_user_model()


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SmsSerializer(serializers.Serializer):
    mobile &lt;/span&gt;= serializers.CharField(max_length=11&lt;span&gt;)
    
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;函数名必须：validate + 验证字段名&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; validate_mobile(self, mobile):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        手机号码验证
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否已经注册&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; User.objects.filter(mobile=&lt;span&gt;mobile).count():
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; serializers.ValidationError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户已经存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否合法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; re.match(REGEX_MOBILE, mobile):
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; serializers.ValidationError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;手机号码非法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 验证码发送频率&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;60s内只能发送一次&lt;/span&gt;
        one_mintes_ago = datetime.now() - timedelta(hours=0, minutes=1, seconds=&lt;span&gt;0)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; VerifyCode.objects.filter(add_time__gt=one_mintes_ago, mobile=&lt;span&gt;mobile).count():
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; serializers.ValidationError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;距离上一次发送未超过60s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; mobile
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）APIKEY加到settings里面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;云片网APIKEY&lt;/span&gt;
APIKEY = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxxx327d4be01608xxxxxxxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）views后台逻辑&lt;/p&gt;
&lt;p&gt;我们要重写CreateModelMixin的create方法，下面是源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; CreateModelMixin(object):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    Create a model instance.
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; create(self, request, *args, **&lt;span&gt;kwargs):
        serializer &lt;/span&gt;= self.get_serializer(data=&lt;span&gt;request.data)
        serializer.is_valid(raise_exception&lt;/span&gt;=&lt;span&gt;True)
        self.perform_create(serializer)
        headers &lt;/span&gt;=&lt;span&gt; self.get_success_headers(serializer.data)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(serializer.data, status=status.HTTP_201_CREATED, headers=&lt;span&gt;headers)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_create(self, serializer):
        serializer.save()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_success_headers(self, data):
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Location&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: str(data[api_settings.URL_FIELD_NAME])}
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; (TypeError, KeyError):
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要加上自己的逻辑&lt;/p&gt;
&lt;p&gt;users/views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; rest_framework.mixins &lt;span&gt;import&lt;/span&gt;&lt;span&gt; CreateModelMixin
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework &lt;span&gt;import&lt;/span&gt;&lt;span&gt; viewsets
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .serializers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SmsSerializer
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.response &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Response
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework &lt;span&gt;import&lt;/span&gt;&lt;span&gt; status
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; utils.yunpian &lt;span&gt;import&lt;/span&gt;&lt;span&gt; YunPian
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; MxShop.settings &lt;span&gt;import&lt;/span&gt;&lt;span&gt; APIKEY
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; random &lt;span&gt;import&lt;/span&gt;&lt;span&gt; choice
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; .models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; VerifyCode


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SmsCodeViewset(CreateModelMixin,viewsets.GenericViewSet):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    手机验证码
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    serializer_class &lt;/span&gt;=&lt;span&gt; SmsSerializer

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; generate_code(self):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        生成四位数字的验证码
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        seeds &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234567890&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        random_str &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(4&lt;span&gt;):
            random_str.append(choice(seeds))

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;.join(random_str)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; create(self, request, *args, **&lt;span&gt;kwargs):
        serializer &lt;/span&gt;= self.get_serializer(data=&lt;span&gt;request.data)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;验证合法&lt;/span&gt;
        serializer.is_valid(raise_exception=&lt;span&gt;True)

        mobile &lt;/span&gt;= serializer.validated_data[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mobile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

        yun_pian &lt;/span&gt;=&lt;span&gt; YunPian(APIKEY)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成验证码&lt;/span&gt;
        code =&lt;span&gt; self.generate_code()

        sms_status &lt;/span&gt;= yun_pian.send_sms(code=code, mobile=&lt;span&gt;mobile)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; sms_status[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] !=&lt;span&gt; 0:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response({
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mobile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: sms_status[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
            }, status&lt;/span&gt;=&lt;span&gt;status.HTTP_400_BAD_REQUEST)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            code_record &lt;/span&gt;= VerifyCode(code=code, mobile=&lt;span&gt;mobile)
            code_record.save()
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Response({
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mobile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: mobile
            }, status&lt;/span&gt;=status.HTTP_201_CREATED)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;云片网单条短信发送的使用说明：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180414111709649-1524688192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180414111746226-1628927162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （5）配置url&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; users.views &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SmsCodeViewset

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置codes的url&lt;/span&gt;
router.register(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, SmsCodeViewset, base_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt; &lt;span&gt;开始验证&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 输入不合法的手机号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180414154028312-675194737.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;输入合法的手机号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 会返回输入的手机号码，并受到短信验证码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180414112252030-1251568187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7.6.user serializer 和validator验证&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;完成注册的接口&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180414115412543-160274290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户注册需要填写手机号，验证码和密码，相当于create model操作，所以继承CreateModelMixin&lt;/p&gt;
&lt;p&gt;（1）修改UserProfile中mobile字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mobile = models.CharField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;电话&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,max_length=11,null=True, blank=True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置允许为空，因为前段只有一个值，是username，所以mobile可以为空，为了验证合法&lt;/p&gt;
&lt;p&gt;（2）users/serializers.py&lt;/p&gt;
&lt;p&gt;代码里面我都写好了注释，就不再重复解释了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserRegSerializer(serializers.ModelSerializer):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    用户注册
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;UserProfile中没有code字段，这里需要自定义一个code序列化字段&lt;/span&gt;
    code = serializers.CharField(required=True, write_only=True, max_length=4, min_length=4&lt;span&gt;,
                                 error_messages&lt;/span&gt;=&lt;span&gt;{
                                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;blank&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入验证码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;required&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入验证码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;max_length&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;验证码格式错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;min_length&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;验证码格式错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                                 },
                                help_text&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;验证码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;验证用户名是否存在&lt;/span&gt;
    username = serializers.CharField(label=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, help_text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, required=True, allow_blank=&lt;span&gt;False,
                                     validators&lt;/span&gt;=[UniqueValidator(queryset=User.objects.all(), message=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户已经存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)])

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;验证code&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; validate_code(self, code):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户注册，已post方式提交注册信息，post的数据都保存在initial_data里面&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;username就是用户注册的手机号，验证码按添加时间倒序排序，为了后面验证过期，错误等&lt;/span&gt;
        verify_records = VerifyCode.objects.filter(mobile=self.initial_data[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]).order_by(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-add_time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; verify_records:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最近的一个验证码&lt;/span&gt;
            last_record =&lt;span&gt; verify_records[0]
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 有效期为五分钟。&lt;/span&gt;
            five_mintes_ago = datetime.now() - timedelta(hours=0, minutes=5, seconds=&lt;span&gt;0)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; five_mintes_ago &amp;gt;&lt;span&gt; last_record.add_time:
                &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; serializers.ValidationError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;验证码过期&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; last_record.code !=&lt;span&gt; code:
                &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; serializers.ValidationError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;验证码错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; serializers.ValidationError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;验证码错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 所有字段。attrs是字段验证合法之后返回的总的dict&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; validate(self, attrs):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;前端没有传mobile值到后端，这里添加进来&lt;/span&gt;
        attrs[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mobile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = attrs[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;code是自己添加得，数据库中并没有这个字段，验证完就删除掉&lt;/span&gt;
        &lt;span&gt;del&lt;/span&gt; attrs[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; attrs

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        model &lt;/span&gt;=&lt;span&gt; User
        fields &lt;/span&gt;= (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mobile&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（3）users/views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserViewset(CreateModelMixin,viewsets.GenericViewSet):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    用户
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    serializer_class &lt;/span&gt;= UserRegSerializer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （4）配置url&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
router.register(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;users&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, UserViewset, base_name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;users&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;测试代码：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入已经存在的用户名&lt;/li&gt;
&lt;li&gt;不输入验证码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180414125505606-1006879582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7.7.django信号量实现用户密码修改&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）完善用户注册&lt;/p&gt;
&lt;p&gt;添加一条用户短信验证码数据之后进行验证。&lt;/p&gt;
&lt;p&gt;user/views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserViewset(CreateModelMixin,viewsets.GenericViewSet):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    用户
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    serializer_class &lt;/span&gt;=&lt;span&gt; UserRegSerializer
    queryset &lt;/span&gt;= User.objects.all()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;user/serializer.py添加&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 fields = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mobile&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）password不能明文显示和加密保存&lt;/p&gt;
&lt;p&gt;需要重载Create方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入密码的时候不显示明文&lt;/span&gt;
    password =&lt;span&gt; serializers.CharField(
        style&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;input_type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;},label=True,write_only=&lt;span&gt;True
    )

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;密码加密保存&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; create(self, validated_data):
        user &lt;/span&gt;= super(UserRegSerializer, self).create(validated_data=&lt;span&gt;validated_data)
        user.set_password(validated_data[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
        user.save()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; user
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是重载Create方法，下面介绍如何用信号量来实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;信号量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）users下面创建signals.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; users/signals.py&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.db.models.signals &lt;span&gt;import&lt;/span&gt;&lt;span&gt; post_save
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.dispatch &lt;span&gt;import&lt;/span&gt;&lt;span&gt; receiver
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; rest_framework.authtoken.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Token

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.auth &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get_user_model
User &lt;/span&gt;=&lt;span&gt; get_user_model()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; post_save:接收信号的方式&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;sender: 接收信号的model&lt;/span&gt;
@receiver(post_save, sender=&lt;span&gt;User)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; create_user(sender, instance=None, created=False, **&lt;span&gt;kwargs):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否新建，因为update的时候也会进行post_save&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; created:
        password &lt;/span&gt;=&lt;span&gt; instance.password
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;instance相当于user&lt;/span&gt;
&lt;span&gt;        instance.set_password(password)
        instance.save()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）还需要重载配置&lt;/p&gt;
&lt;p&gt;users/apps.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; users/apps.py&lt;/span&gt;

&lt;span&gt;from&lt;/span&gt; django.apps &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AppConfig

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UsersConfig(AppConfig):
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;users&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    verbose_name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户管理&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; ready(self):
        &lt;/span&gt;&lt;span&gt;import&lt;/span&gt; users.signals
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AppConfig自定义的函数，会在django启动时被运行&lt;/p&gt;
&lt;p&gt;现在添加用户的时候，密码就会自动加密存储了&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;7.8.vue和注册功能联调&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;生成token的两个重要步骤，一是payload，二是encode&lt;/p&gt;
&lt;p&gt;users/views.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserViewset(CreateModelMixin,viewsets.GenericViewSet):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    用户
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    serializer_class &lt;/span&gt;=&lt;span&gt; UserRegSerializer
    queryset &lt;/span&gt;=&lt;span&gt; User.objects.all()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; create(self, request, *args, **&lt;span&gt;kwargs):
        serializer &lt;/span&gt;= self.get_serializer(data=&lt;span&gt;request.data)
        serializer.is_valid(raise_exception&lt;/span&gt;=&lt;span&gt;True)
        user &lt;/span&gt;=&lt;span&gt; self.perform_create(serializer)
        re_dict &lt;/span&gt;=&lt;span&gt; serializer.data
        payload &lt;/span&gt;=&lt;span&gt; jwt_payload_handler(user)
        re_dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; jwt_encode_handler(payload)
        re_dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = user.name &lt;span&gt;if&lt;/span&gt; user.name &lt;span&gt;else&lt;/span&gt;&lt;span&gt; user.username

        headers &lt;/span&gt;=&lt;span&gt; self.get_success_headers(serializer.data)

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Response(re_dict, status=status.HTTP_201_CREATED, headers=&lt;span&gt;headers)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; perform_create(self, serializer):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; serializer.save()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口写好后，接下来测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201804/1299879-20180414154222095-1048195450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入合法的手机号，会发送验证码到手机上，然后输入验证码和密码，登录成功&lt;/p&gt;

</description>
<pubDate>Sat, 14 Apr 2018 07:43:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/8813641.html</dc:identifier>
</item>
<item>
<title>异步导入导出架构设计 - 井传红</title>
<link>http://www.cnblogs.com/jingch/p/8832161.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingch/p/8832161.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;为什么要用异步？&lt;/h2&gt;
&lt;p&gt;在我们平时的业务系统中，文件导入，文件导出是一个很常见的业务需求。正常情况下，同步导出就可以满足我们80%的需求。但是对于数据量大，业务拼接复杂的系统来说，导出超时，导入超时是不可避免的，而且是无法忍受的。异步能让业务线程在后台运行，没有等待时间，处理完成通知出来就行了。这种场景在现实生活中也很常见，比如医院里面拍CT，做体检时的体检报告，都是延后去拿结果的。&lt;/p&gt;
&lt;h2&gt;异步导出的使用场景&lt;/h2&gt;
&lt;p&gt;那什么时候会需要用到异步呢？统计、导入、导出、发送模板消息、订单状态变更后的复杂业务处理。。。 &lt;/p&gt;
&lt;p&gt;它们都有共同的特点：&lt;/p&gt;
&lt;p&gt;1.处理耗时长&lt;/p&gt;
&lt;p&gt;2.业务优先级低&lt;/p&gt;
&lt;p&gt;3.容易超时&lt;/p&gt;
&lt;p&gt;4.数据量大&lt;/p&gt;

&lt;h2&gt;异步导出的优缺点&lt;/h2&gt;
&lt;p&gt;异步的优点：&lt;/p&gt;
&lt;p&gt;      它能解决导出超时问题，能大大的提高接口请求处理速度，提高吞吐量，提升系统性能&lt;/p&gt;
&lt;p&gt;任何事情都有两面性，也许不具有绝对性，但是在这里是成立的。既然它有那么多优点，当然也会有缺点。&lt;/p&gt;
&lt;p&gt;异步的缺点：&lt;/p&gt;
&lt;p&gt;     它比同步导出要复杂得多，接口多了几倍，所需服务器也要多，学习成本高，开发成本高&lt;/p&gt;
&lt;h2&gt;架构图设计&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/669229/201804/669229-20180414141620298-1483155241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;架构解析&lt;/h2&gt;
&lt;p&gt;按流程来：&lt;/p&gt;
&lt;p&gt;1.前端发出导出请求&lt;/p&gt;
&lt;p&gt;2.接口服务器接到请求并校验参数&lt;/p&gt;
&lt;p&gt;3.如果参数不符，直接弹出校验结果，流程结束！&lt;/p&gt;
&lt;p&gt;4.生成一个任务实体，状态设为处理中并将实体写入redis。开启异步线程，在异步方法中调用导出接口。返回给前端在处理中状态&lt;/p&gt;
&lt;p&gt;5.前端接受到已经在处理中返回值，开启ajax轮询，每隔10秒请求一次任务查询状态接口&lt;/p&gt;
&lt;p&gt;6.导出接口将数据拼接完成&lt;/p&gt;
&lt;p&gt;7.将数据传到文件服务器生成文件并返回url&lt;/p&gt;
&lt;p&gt;8.从redis中取出任务实体将url写入，并且将状态设为已完成并更新redis(后端处理流程就结束了)&lt;/p&gt;
&lt;p&gt;9.前端ajax请求发现返回值状态变成已完成后，取出url并停止轮询。&lt;/p&gt;
&lt;p&gt;10.前端请求清除任务实体接口，通过后端接口将redis中的对象移除。&lt;/p&gt;
&lt;p&gt;11.前端展示导出结果，自动下载或者手动点击可以根据业务来。&lt;/p&gt;


&lt;p&gt;这里还有一个页面初始化的按钮变化流程。&lt;/p&gt;
&lt;p&gt;1.打开页面后导出按钮置灰不可点击&lt;/p&gt;
&lt;p&gt;2.ajax请求查询任务状态接口，如果显示没有任务在进行中，那就让导出按钮可以点击。如果状态是导出已完成，则显示下载按钮相关页面&lt;/p&gt;
&lt;h2&gt;数据来源&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/669229/201804/669229-20180414152309261-1905569550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;接口设计&lt;/h2&gt;
&lt;h3&gt; 接口列表&lt;/h3&gt;
&lt;p&gt; 1.&lt;strong&gt;获取任务状态&lt;/strong&gt; getTaskStatus     &lt;/p&gt;
&lt;p&gt;              返回实体TaskResultOut：&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;l类型&lt;/td&gt;
&lt;td&gt;是否可为空&lt;/td&gt;
&lt;td&gt;注释&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;pre&gt;
status
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt; int&lt;/td&gt;
&lt;td&gt; 不，默认0&lt;/td&gt;
&lt;td&gt; 任务状态（0=未开始，1=进行中 2=已完成）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;   message&lt;/td&gt;
&lt;td&gt; string&lt;/td&gt;
&lt;td&gt; 是&lt;/td&gt;
&lt;td&gt; 提示信息（正确或错误）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;   url&lt;/td&gt;
&lt;td&gt; string&lt;/td&gt;
&lt;td&gt; 是&lt;/td&gt;
&lt;td&gt; 文件地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;   state&lt;/td&gt;
&lt;td&gt; bool&lt;/td&gt;
&lt;td&gt; 不,默认fasle&lt;/td&gt;
&lt;td&gt; 任务成功还是失败（y）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;



&lt;p&gt;2.&lt;strong&gt;注册导出任务（导出） &lt;/strong&gt;registerExportTask&lt;/p&gt;
&lt;p&gt;          返回true/false,表明是否注册成功&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;清除任务状态 &lt;/strong&gt;clearTaskInfo&lt;/p&gt;
&lt;p&gt;          返回true/fasle,表明清除是否成功&lt;/p&gt;
&lt;h2&gt;前端设计&lt;/h2&gt;
&lt;p&gt;前端js由前端编写,具体的由于嵌套太深，就不贴出来了,在架构解析中已经说的很详细了。&lt;/p&gt;
&lt;p&gt;&quot;export&quot;: function(e) {&lt;br/&gt;return t.post(r.api.form[&quot;export&quot;], e, {})&lt;br/&gt;},&lt;br/&gt;getTaskStatus: function(e) {&lt;br/&gt;return t.post(r.api.form.getTaskStatus, e, {})&lt;br/&gt;},&lt;br/&gt;registerExportTask: function(e) {&lt;br/&gt;return t.post(r.api.form.registerExportTask, e, {})&lt;br/&gt;},&lt;br/&gt;clearTaskInfo: function(e) {&lt;br/&gt;return t.post(r.api.form.clearTaskInfo, e, {})&lt;br/&gt;}&lt;/p&gt;

&lt;h2&gt;项目实际应用&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/669229/201804/669229-20180414151106472-724346329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/669229/201804/669229-20180414151137946-1667546163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 点击取消后&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/669229/201804/669229-20180414151301143-1125443727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/669229/201804/669229-20180414151438137-1622211936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;异步导出的整个流程和设计就全在这里了。&lt;/p&gt;

&lt;p&gt;由于篇幅有限，且导入的流程大同小异。直接奉上一副设计图吧。&lt;/p&gt;
&lt;h2&gt;多级异步导入方案&lt;/h2&gt;
&lt;h2&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/669229/201804/669229-20180414152846471-598141656.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;

&lt;h2&gt;最后&lt;/h2&gt;
&lt;p&gt;代码是没有滴，东西是要自己创造滴！&lt;/p&gt;
</description>
<pubDate>Sat, 14 Apr 2018 07:32:00 +0000</pubDate>
<dc:creator>井传红</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingch/p/8832161.html</dc:identifier>
</item>
<item>
<title>.NET面试资料整理 - lingfeng95</title>
<link>http://www.cnblogs.com/zhao123/p/8832148.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhao123/p/8832148.html</guid>
<description>&lt;p&gt;1.WCF和Web Api的区别&lt;br/&gt;答：1WCF是.NET平台开发的一站式框架，Web Api的设计和构建只考虑一件事情，那就是Http，而WCF的设计主要考虑是SOAP和WS-*；Web Api非常轻量，在功能和灵活性上都不能和WCF相比。如果你的服务是基于TCP的，或者支持更多的传输机制，那么WCF是更好地选择。然而并不是所有的平台都支持SOAP和WS-*，当客户端不支持这些协议的时候，Web Api将是更好地选择；WCF是基于SOAP协议的，数据格式是XML，而Web Api是基于RESTful标准的，数据格式多样化，可以是XML，JSON等。WCF配置繁琐，而Web Api它是简单的，代码可读性强，上手快，接口更标准，更清晰，没有混乱的方法名称，有的只是集中比较标准的请求，如get，post，put，delete等，并且Web api是一个URL连接，可以在不同的平台运转，同时支持MVC的特征，像路由、控制器、action、filter、模型绑定、控制反转（IOC）或依赖注入（DI），单元测试。&lt;br/&gt;SOAP（SOAP：Simple Object Access Protocol） 简单对象访问协议，一般是基于XML的。&lt;br/&gt;google，facebook，baidu，新浪还是腾讯。他们对外开放的接口都是基于Http的Web API&lt;/p&gt;
&lt;p&gt;2.MVC和Web Api的区别&lt;br/&gt;答：MVC主要用于建站，WEB Api主要用于构建http服务。两种架构都是在ASP.NET的基础上进行改造的，主要是对httpModule和httpHandler做了扩展，MVC引申出了强大的路由机制，实现了诸如MvcHandler和ControllerFactory这种消息处理和后台控制器方法选择机制，而Web api在MVC基础上另外写了一套独立于ASP.NET的消息处理管道。&lt;br/&gt;MVC只能运行在IIS上，Web api可以运行在WebHost，ConsoleHost甚至windows Services上。&lt;/p&gt;
&lt;p&gt;3.MVC的路由配置&lt;br/&gt;答：基本的路由规则是从特殊到一般的排列，小范围写在前，大范围写在后，路由规则可以注册多条，路由的名称（name）不能重复，路由规则可以设置约束，即正则表达式。&lt;br/&gt;URl构造：&lt;br/&gt;routes.MapRoute(name:&quot;Default&quot;,url:&quot;{controller}/{action}/{id}&quot;,defaults:new {controller=&quot;home&quot;,action=&quot;Index&quot;,id=UrlParamter.Optional})&lt;br/&gt;在RouterConfig.cs中配置这些的&lt;/p&gt;
&lt;p&gt;4.MVC 的生命周期（运行机制）&lt;br/&gt;答：http是一种无状态的请求，他的生命周期就是从客户端浏览器发出请求开始，到得到响应结束。&lt;br/&gt;Request → UrlRoutingModule(IHttpModule init) → Route Table → RouteHandler（MvcRouteHandler） → MvcHandler（IHttpHandler）→ ProcessRequest → Controller（IController Factory）→ Controller.Execute&lt;br/&gt;→ ActionInvoker → ActionMethod → ActionResult → ActionResult.ExecuteResult → reponse&lt;/p&gt;
&lt;p&gt;5.Web Api2 http请求生命周期&lt;br/&gt;答：IIS Hosting → Http Request → HttpServer → HttpRequestMessage → HttpRouteDispatcher → HttpControllerDispatcher → Authorization Filters → Action Filters → View&lt;/p&gt;
&lt;p&gt;6.Web Api2应用架构详解&lt;br/&gt;答：常见的应用包括以下四类，PC客户端程序，APP程序，网站程序，H5程序。&lt;br/&gt;如何确认一个app能够访问webapi?&lt;br/&gt;使用AppID验证app访问webapi的合法性，AppID为服务端给出的一个ID标志。&lt;br/&gt;我们可以为web/app/winform分别分配一个ID，从而可以确定访问的合法性，和访问的渠道。&lt;/p&gt;
&lt;p&gt;如何保证app参数的正确性，没有被篡改？&lt;br/&gt;客户端使用AppID对应的AppSecert，对参数进行签名(MD5/SHA等)&lt;br/&gt;服务端使用同样的方式签名，和客户端签名校验。&lt;/p&gt;
&lt;p&gt;如何防止webapi url被截获，重新访问？&lt;br/&gt;客户端访问webapi时带上时间戳参数，服务端对时间戳进行校验，如10分钟内的访问才是有效的。&lt;/p&gt;
&lt;p&gt;涉及具体用户的操作时，如何验证用户？&lt;br/&gt;可以使用username,psw参数的方式访问webapi。但是这种方式很不安全。&lt;br/&gt;使用授权token是很好的解决办法。在用户登录成功时，服务端生成一个授权码，对应用户信息。&lt;br/&gt;访问时带上token参数，服务端查询token有效性，和token对应的用户信息。&lt;/p&gt;
&lt;p&gt;7.MVC、MVP、MVVM架构模式的区别和联系&lt;br/&gt;MVC是比较直观的架构模式，用户操作-&amp;gt;View（负责接收用户的输入操作）-&amp;gt;Controller（业务逻辑处理）-&amp;gt;Model（数据持久化）-&amp;gt;View（将结果反馈给View）。MVP是把MVC中的Controller换成了Presenter（呈现），目的就是为了完全切断View跟Model之间的联系，由Presenter充当桥梁，做到View-Model之间通信的完全隔离。如果说MVP是对MVC的进一步改进，那么MVVM则是思想的完全变革。它是将“数据模型数据双向绑定”的思想作为核心，因此在View和Model之间没有联系，通过ViewModel进行交互，而且Model和ViewModel之间的交互是双向的，因此视图的数据的变化会同时修改数据源，而数据源数据的变化也会立即反应到View上。这方面典型的应用有.NET的WPF，js框架Knockout、AngularJS等。&lt;/p&gt;
&lt;p&gt;8.反射的简单介绍&lt;br/&gt;C#中反射的概念：在运行的时候发现对象的相关信息。根据这些信息可以动态的执行对象的方法以及获取对象的属性所储存的值。&lt;br/&gt;那么EF实体框架，就是反射的应用之一。&lt;/p&gt;
&lt;p&gt;9.EF介绍&lt;br/&gt;EntityFramework是ADO.NET中的一套支持开发面向数据的软件应用程序的技术,是微软的一个ORM框架。&lt;br/&gt;有Dapper.NET、NHeberneit、EF、IBatis.Net和SubSonic等&lt;br/&gt;优点：&lt;br/&gt;1.简洁的Linq to Sql语句大大提高了开发人员的效率，不要再写复杂的sql语句；&lt;br/&gt;2.不再需要再管应用程序如何去连接数据库；&lt;br/&gt;3.传统的表驱动方式创建EDM，然后通过EDM生成模型和数据层代&lt;br/&gt;DataBase First、Model First、CodeFirst&lt;/p&gt;
&lt;p&gt;10.MVC2，MVC3，MVC4和MVC5的不同&lt;br/&gt;答：MVC3需要.net framework4.0,可以指定视图引擎，WebForm，Razor等。&lt;br/&gt;MVC4 多了Web api,asp.net4.5，MVC5 多了Web Api2.0 asp.net4.5.1&lt;/p&gt;
&lt;p&gt;11.javascript中闭包&lt;br/&gt;如果一个函数访问了它的外部变量，那么它就是一个闭包。通过访问外部变量，一个闭包可以维持（keep alive）这些变量&lt;br/&gt;var add = (function () {&lt;br/&gt;var counter = 0;&lt;br/&gt;return function () {return counter += 1;}&lt;br/&gt;})();&lt;br/&gt;或者&lt;br/&gt;var add = function () {&lt;br/&gt;var counter = 0;&lt;br/&gt;return function () {return counter += 1;}&lt;br/&gt;};&lt;br/&gt;var add1=add()&lt;/p&gt;
&lt;p&gt;12.SQL的执行顺序&lt;br/&gt;答：from → on → join → where → group by → with → having → select → distinct → order by → top&lt;/p&gt;
&lt;p&gt;13.SQL性能优化&lt;br/&gt;答：1)尽量避免模糊查询（like），解决办法，把检索条件修改为下拉框，根据下拉框直接查询数据；根据条件查询出一个临时表数据，再和临时表数据进行复杂关联。2）索引问题，避免对索引字段进行运算，像&amp;lt;&amp;gt;,!=,not,is null,is not null,避免索引字段使用函数，索引字段不要用空值表示。3）update，select复杂语句，多级嵌套的时候，尽量修改为拆成几步，生成一些临时数据，再进行操作。4）update同一张表的时候多次执行，修改为一次执行（update ATable set name = (select name from BTable where id =ATable .id)）。5）用union all代替union，union会将各查询的记录作对比。6）在where语句中，尽量避免对索引字段济宁计算。7）where中应该避免使用having，in，not in，or。可以使用exist代替(select * from ATable where exists(select * from BTable where BTable.id=ATable.id))。8)索引的时候，数字类型就是数字类型，时间类型就是时间类型，不要用字符串表示数字类型或者时间类型，否则索引回无效。9）不用动不动就select * ，很傻的好不好。10）排序的时候，避免使用耗费资源的操作，如：distinct、union、minus、itersect，order by的SQL语句或启动SQL引擎，耗费资源的排序（SORT）功能，distinct需要执行一次排序，其他的都需要执行两次排序。11）慎重用临时表可以极大地提高效率。(drop table #temp;create table #temp(id int,name nvarchar(50)))&lt;/p&gt;
&lt;p&gt;14.事务的特性&lt;br/&gt;1）原子性（要么全成功，要么全失败）；2）一致性（加加减减保持一致）；3）隔离性（多个事务之间的并发操作，事务之间相互隔离，互不影响）；4）持久性（事务一旦提交将是永久性的）&lt;/p&gt;
&lt;p&gt;15.事务的隔离级别&lt;br/&gt;1）read uncommitted(未提交读，脏读)，相当于nolock；2）read committed（已提交读，默认级别）；3）repeatable read（可以重复读），相当于（hold lock）；4）seriable（可序列化）；5）snapshot（快照）；6）read comminted snapshot（已提交读隔离）&lt;br/&gt;read uncommitted → read committed → repeatable read → seriable 隔离级别越来越高，读操作的请求锁定就越严格，锁的市价越长久，所以隔离级别越高，一致性就越高，同时性能也影响很大。&lt;/p&gt;
&lt;p&gt;16.sql server中存储过程和函数&lt;br/&gt;1）CREATE FUNCTION Sales.ufn_SalesByStore (@storeid int)&lt;br/&gt;RETURNS TABLE&lt;br/&gt;AS&lt;br/&gt;RETURN&lt;br/&gt;(&lt;br/&gt;SELECT P.ProductID, P.Name, SUM(SD.LineTotal) AS 'Total'&lt;br/&gt;FROM Production.Product AS P&lt;br/&gt;JOIN Sales.SalesOrderDetail AS SD ON SD.ProductID = P.ProductID&lt;br/&gt;JOIN Sales.SalesOrderHeader AS SH ON SH.SalesOrderID = SD.SalesOrderID&lt;br/&gt;JOIN Sales.Customer AS C ON SH.CustomerID = C.CustomerID&lt;br/&gt;WHERE C.StoreID = @storeid&lt;br/&gt;GROUP BY P.ProductID, P.Name&lt;br/&gt;);&lt;br/&gt;GO&lt;/p&gt;
&lt;p&gt;SELECT * FROM Sales.ufn_SalesByStore (602);&lt;br/&gt;2）存储过程&lt;br/&gt;CREATE PROCEDURE HumanResources.uspGetEmployees&lt;br/&gt;@LastName nvarchar(50),&lt;br/&gt;@FirstName nvarchar(50)&lt;br/&gt;AS&lt;br/&gt;SET NOCOUNT ON;&lt;br/&gt;SELECT FirstName, LastName, JobTitle, Department&lt;br/&gt;FROM HumanResources.vEmployeeDepartment&lt;br/&gt;WHERE FirstName = @FirstName AND LastName = @LastName;&lt;br/&gt;GO&lt;/p&gt;
&lt;p&gt;EXEC HumanResources.uspGetEmployees @LastName = N'Ackerman', @FirstName = N'Pilar';&lt;/p&gt;
&lt;p&gt;17.Sqlserver中常用函数&lt;br/&gt;1）concat连接函数；2）length返回字符串的长度；3)lower转换成小写；4）upper；5）ltrim删除左边的自负互传&lt;br/&gt;6）substr截取字符串；7）replace替换字符串；8）&lt;br/&gt;聚合函数、配置函数、转换函数、加密函数、游标函数、日期和时间函数、数学函数、元数据函数、排名函数、行集函数、安全函数、字符串函数、系统函数、文本和图像函数等。9)sum、coun、max、min、avg&lt;/p&gt;
&lt;p&gt;18.常用的SQL&lt;br/&gt;1）常用的单词，create（创建）、drop（删除），适用于（database、table、view、index）&lt;br/&gt;2)修改列，alter table tablename add column col type&lt;br/&gt;3）基本sql语句&lt;br/&gt;3.1）选择：select * from talename where 范围&lt;br/&gt;3.2）插入：insert into tablename(col1,col2) values(&quot;col1&quot;,&quot;col2&quot;)&lt;br/&gt;3.3) 删除：delete from tablename where 范围&lt;br/&gt;3.4）更新：update tablename set col1=&quot;col1&quot;,col2=&quot;col2&quot;&lt;/p&gt;
&lt;p&gt;19.Web常见的安全漏洞&lt;br/&gt;1)安全攻击&lt;br/&gt;1.1)SQL,HTML,JS,OS命令注入&lt;br/&gt;1.2)XSS(CSS)跨站脚本攻击，利用站内信任用户，在WEB页面插入恶意script代码&lt;br/&gt;1.3)CSRF跨站请求伪造&lt;br/&gt;1.4)目录便利漏洞&lt;br/&gt;1.5)参数篡改&lt;br/&gt;1.6)会话劫持&lt;br/&gt;2）防止攻击的措施总结&lt;br/&gt;2.1)对用户输入的数据进行全面安全检查或过滤，尤其注意检查是否包含SQL或XSS特殊符号。（服务器和客户端都需要验证）&lt;br/&gt;2.2)不要使用管理员权限的数据库连接，不要动态拼接sql&lt;br/&gt;2.3)机密信息加密，不能使用明文&lt;br/&gt;2.4）每个页面加载时，对用户进行合法性验证&lt;br/&gt;2.5）登陆后session中的敏感信息进行加密，避免在永久cookie中存储敏感信息，重要的cookie信息标记为http only&lt;br/&gt;2.6）发送敏感信息时使用SSL，POST方式。尽量使用新型web http安全协议&lt;br/&gt;2.7）不要直接抛出异常的详细信息给用户，异常返回友好的页面，防止用户看到敏感信息&lt;br/&gt;2.8）在服务器与网络的接口处设置防火墙，用于阻断外界用户对服务器的扫描和探测&lt;br/&gt;2.9）限制网站后台访问权限，如：禁止公网IP访问后台，禁止服务员使用弱口令&lt;br/&gt;2.10）限制敏感页面或目录的访问权限&lt;br/&gt;2.11）项目发布前使用漏洞扫描软件，如IBM appScan，UnisWebScanner&lt;/p&gt;
&lt;p&gt;20.Cookie和session&lt;br/&gt;由于HTTP是无状态的协议，所以服务器端用记住用户登录的状态，就需要某种机制来识别具体的用户，这个机制就是session&lt;br/&gt;服务器如何识别特定的用户，这个时候cookie就产生了，每次http请求的时候，客户端都会发送相应的cookie信息到服务器，&lt;br/&gt;第一次创建session的时候，服务器会在http协议中告诉客户，需要在cookie里面记录一个sessionid，以后每次请求把这个&lt;br/&gt;会话id发送服务器，服务器就知道是谁了。&lt;br/&gt;session是服务器端保存的一个数据结果，用来跟踪用户状态，这个数据可以保存在集群、数据库、文件中&lt;br/&gt;cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现session的一种方式&lt;/p&gt;
&lt;p&gt;21.http常用协议状态&lt;br/&gt;200：请求被正常处理 204：请求被受理但没有资源可以返回&lt;br/&gt;206：请求一部分 301：永久性重定向&lt;br/&gt;400：请求报文语法有误，服务器无法识别 401：请求需要认证&lt;br/&gt;403：请求的对应资源禁止被访问 404：服务器无法找到对应资源&lt;br/&gt;500：服务内内部错误 503：服务器正忙&lt;/p&gt;
&lt;p&gt;22.web跨域解决办法&lt;br/&gt;在JavaScript中，有一种很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）， 即JavaScript只能访问与包含他的文档在统一域名下的内容。&lt;br/&gt;跨域处理方法：&lt;br/&gt;1）JSONP&lt;br/&gt;原理：js脚本，css样式文件，图片，这三种是与页面本身不同源的，JSONP就是利用script中src属性没有限制达到跨域&lt;br/&gt;请求的：动态添加一个&amp;lt;script&amp;gt;标签来实现。当然这些都是get请求&lt;br/&gt;2）CORS策略&lt;br/&gt;需要服务器对CORS的支持，设置Access-Control-Allow-Origin来进行。&lt;br/&gt;3）document.domain+iframe的设置&lt;br/&gt;主域名相同的条件下才鞥进行&lt;br/&gt;4）HTML5的postMessage&lt;br/&gt;在IE中使用&lt;br/&gt;5）使用window.name来进行跨域&lt;/p&gt;

</description>
<pubDate>Sat, 14 Apr 2018 07:29:00 +0000</pubDate>
<dc:creator>lingfeng95</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhao123/p/8832148.html</dc:identifier>
</item>
<item>
<title>CLR-基元类型以及溢出检查 - franhome</title>
<link>http://www.cnblogs.com/franhome/p/8831944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/franhome/p/8831944.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;=========（CLR via C#阅读笔记）========&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基元类型（primitive type）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基元类型也不做过多的解释，举个例子即可清晰的辨别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在java里曾使用过Sting s=&quot;java&quot;; 定义字符串，然后就会觉得很诧异，为啥是大写开头，我写C#,一直都是 string ,int ,double,float等等小写开头，这时候，来了解基元类型方可解惑。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; a=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  System.Int32 a=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; a=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;  System.Int32 a=&lt;span&gt;new&lt;/span&gt; System.Int32();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上定义int类型的语法，都是能正确编译与运行的，其中第一种最方便简洁，&lt;em&gt;&lt;span&gt;那么这种方便简洁的int,string,byte..decimal,object等等都称作C#的基元类型，对应FCL类型则为System.Int32(其它依次类推，注意是大写开头)&lt;/span&gt;。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上，基元类型和FCL类型效果完全一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;基元类型转换可能造成精度或数量级的丢失：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后下面谈到，基元类型中的一些转换问题：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;5&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.Int32&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; j=i; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.Int64&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上述代码能够正确的完成隐式转换，也支持一些字面值的转换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是将代码调换一下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; longi=&lt;span&gt;5&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.Int64&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; j=i; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.Int32&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个时候是不安全的转换，因为long 可以容纳更长的数字，如果long对象的值超过了int,那么会发生丢失精度或数量级，这个时候必须使用显示转换。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是即使做了显示转换，也无法避免误差的产生：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对数据转换造成误差做了一个小小的测试:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/653549/201804/653549-20180414145758834-2147478004.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;得出结论，在超过int（-2,147,483,648 到 2,147,483,647）范围后，int会从头在依次计算，比如比范围多1，就会从最大值回到开头，多2，就会往后再数一个&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;而浮点型，不论是float还是double都是直接截取整数位不会进行四舍五入（有些语言不是截取）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;checkd和uncheckd基元类操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作用：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;一些元算可能会有溢出发生，例如&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt; b=&lt;span&gt;100&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;无符号八位值，范围0-255&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; b=(&lt;span&gt;byte&lt;/span&gt;)(b+&lt;span&gt;200&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;溢出得到值 (100+200)-255-1=44&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果，你觉得这种溢出是非法的不可接受的，那么可以加上checked：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;几种常见用法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;checked语句对指定的代码块进行检查：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 //unchecked写法亦然，但是表示不对溢出进行检查
2 checked
3 {
4 byte b=100;  //无符号八位值，范围0-255
5 b=(byte)(b+200); //溢出得到值 (100+200)-255-1=44
6 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;需要注意的是，checked操作符仅仅对块里面进行的运算表达式生效，如果你放一个方法进去，是不会有任何效果的&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;使用checked操作符：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; b=&lt;span&gt;checked&lt;/span&gt;((&lt;span&gt;byte&lt;/span&gt;)(b+&lt;span&gt;200&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; b=(&lt;span&gt;byte&lt;/span&gt;)&lt;span&gt;checked&lt;/span&gt;(b+&lt;span&gt;200&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;两种写法都可以&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;这时候，再发生溢出的时候会抛出&lt;/span&gt;&lt;span&gt;System.OverflowException&lt;/span&gt;&lt;span&gt;: 算术运算导致溢出。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt;当然在极少数时候，异常是允许的，甚至是希望的，比如：&lt;/span&gt;&lt;span&gt;计算哈希值或者校验和&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;checked和unchecked到底是啥？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;引申：CLR提供了一些特殊的IL指令，允许编译器选择它认为最恰当的行为。CLR有一个add指令，作用是将两个值相加，但不执行溢出的检查。还有一个add.ovf指令，作用也是将两个值相加，但会发生溢出时抛出System.OverflowException,当然减乘除也有对应方法，分别是sub/sub.ovf,mul/mul.ovf和conv/conv.ovf。而上面说到的checked和unchecked则是C#层面上提供的编译器开关，自然用来指定编译器下对应的指令（上面提到的IL指令）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;需要注意的是，使用了/checked+（/check-）编译器开关，会使代码执行变得稍慢，因为CLR会进行对应的语句检查。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何有效的避免对基元类型的不良操作和编码：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;尽量使用有符合数值类型，这允许编译器检测更多的上溢/下溢错误（有符号意味着区分正负，无符号是没有负数的），也会减少可能的强制类型转换，另外无符号数值不符合CLS（Common  Language Standard）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果代码可能发生你不希望的溢出（比如错误的输入造成的），就把这些代码放到checked块中，并捕捉异常。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;将允许溢出的代码块放到unchecked块中&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;没有上述检查操作符的，意味着溢出是bug&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;MsoNormal&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;开发环境最好，打开编译器的/checked+开关（&lt;/span&gt;&lt;strong&gt;&lt;span&gt;生成-高级&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;），尽可能暴露问题，发布时应使用/checked-开关，确保代码更快的运行（当然如果能够对检查要求严格，又能接受带来的性能损失也可以打开开发来编译，可以防止应用程序在包含已损坏的数据的前提下运行）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;特别的地方：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; &lt;strong&gt;System.Decimal虽然在C#中是基元类型，但是在CLR中并不是,意味着没有对应的IL指令，它使用int,float,double,uint等数组来表示范围内的大小，如图：&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/653549/201804/653549-20180414150018774-1492793635.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; &lt;strong&gt;可以分析出：&lt;/strong&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;操作符“+”，“-”...对于decimal其实是无效的，但是我们不仅可以对他进行操作符的基本运算，也可以用提供的Add...等方法进行运算，因为它内部其实是对操作符进行了重载，且在运算不安全时是会自动抛出&lt;span&gt;OverFlowException&lt;/span&gt;的异常的。&lt;/strong&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;checked  和 unchecked无效，它无需cheked操作符来检查抛出异常，也无法unchecked阻止异常抛出。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; &lt;strong&gt;System.Numerics.BigInteger类型类似Decimal，也使用数组来表示任意大的数，但是它如何计算都不会溢出，只有在内存不足以改变数组大小时才会抛出异常&lt;span&gt;OutMemoryException&lt;/span&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;上述有更为详细的demo，效果如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/653549/201804/653549-20180414145530538-421707329.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Github地址：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/JOJOJOFran/CLR-Via-C--TEST/tree/master/Design_Type/Primitive%20Type&quot;&gt;&lt;span&gt;https://github.com/JOJOJOFran/CLR-Via-C--TEST/tree/master/Design_Type/Primitive%20Type&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有啥问题欢迎指正！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 14 Apr 2018 07:04:00 +0000</pubDate>
<dc:creator>franhome</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/franhome/p/8831944.html</dc:identifier>
</item>
<item>
<title>Java中的阻塞队列 - MindMrWang</title>
<link>http://www.cnblogs.com/MindMrWang/p/8831788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MindMrWang/p/8831788.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一丶什么是阻塞队列&lt;/strong&gt;&lt;br/&gt;阻塞队列（BlockingQueue）是一个支持两个可以进行&lt;strong&gt;阻塞插入&lt;/strong&gt;和&lt;strong&gt;阻塞移除&lt;/strong&gt;的附加方法的队列。&lt;br/&gt;1）阻塞插入：当队列满后，队列会阻塞（拒绝）插入元素，直到队列不满。&lt;br/&gt;2）阻塞移除：当队列为空时，队列会阻塞（拒绝）移除元素，直到队列里有元素。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;二丶JDK提供的7个阻塞队列&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ArrayBlockingQueue：由数组结构组成的&lt;strong&gt;有界&lt;/strong&gt;阻塞队列&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue：由链表结构组成的&lt;strong&gt;有界&lt;/strong&gt;阻塞队列&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue：&lt;strong&gt;支持优先级排序&lt;/strong&gt;的&lt;strong&gt;无界&lt;/strong&gt;阻塞队列&lt;/li&gt;
&lt;li&gt;DelayQueue：使用&lt;strong&gt;优先级&lt;/strong&gt;队列实现的&lt;strong&gt;无界&lt;/strong&gt;阻塞队列&lt;/li&gt;
&lt;li&gt;SynchronousQueue：&lt;strong&gt;不存储元素&lt;/strong&gt;的阻塞队列&lt;/li&gt;
&lt;li&gt;LinkedTransferQueue：由链表结构组成的&lt;strong&gt;无界&lt;/strong&gt;阻塞队列&lt;/li&gt;
&lt;li&gt;LinkedBlockingDeque：由链表结构组成的&lt;strong&gt;双向&lt;/strong&gt;阻塞队列&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;三丶阻塞队列的实现原理&lt;/strong&gt;&lt;br/&gt;介绍过阻塞队列后博主想到的第一个应用就是生产者和消费者场景，阻塞队列是如何实现的，那我们可以想象一下用一般的多线程是如何实现生产者和消费者场景的：&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_39266910/article/details/78145340&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/qq_39266910/article/details/78145340&lt;/a&gt;&lt;br/&gt;上面是博主以前看多线程编程核心一书敲得代码，里面写就是用的wait和notify来实现生产者和消费者场景的，同样，在学习ReentrantLock的视乎也用来实现过生产者和消费者场景，但是不同的是，后者可以实现多生产者和多消费者的场景，因为一个Lock可以有多个Condition对象不是吗？&lt;br/&gt;如果理解了这些，那么阻塞队列就更加不难理解了，我们的阻塞队列就是利用Condition来实现的，我们就拿ArrayBlockingQueue的add方法源码的看看吧：&lt;br/&gt;首先这个是ArrayBlockingQueue的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ArrayBlockingQueue&amp;lt;E&amp;gt; extends AbstractQueue&amp;lt;E&amp;gt;
        implements BlockingQueue&amp;lt;E&amp;gt;, java.io.Serializable {
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  public boolean add(E e) {
        return super.add(e);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个直接继承了父类AbstractQueue的add方法，那我们直接打开其父类的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public boolean add(E e) {
        if (offer(e))
            return true;
        else
            throw new IllegalStateException(&quot;Queue full&quot;);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;额...可能我们还要打开offer方法：&lt;br/&gt;小提示：在eclipse中直接按ctrl+鼠标左键打开的是接口Queue的offer方法，我们需要按Ctrl+T，然后可以发现ArrayBlockingQueue对这个offer方法进行实现了，所以直接找到ArrayBlockingQueue里的offer方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public boolean offer(E e) {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            if (count == items.length)
                return false;
            else {
                enqueue(e);
                return true;
            }
        } finally {
            lock.unlock();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上的代码使用enqueue方法进行入队操作，虽然这个时候我们还没看见Condition，但是我们已经看见了ReentrantLock了不是吗？&lt;br/&gt;继续追源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private void enqueue(E x) {
        // assert lock.getHoldCount() == 1;
        // assert items[putIndex] == null;
        final Object[] items = this.items;
        items[putIndex] = x;
        if (++putIndex == items.length)
            putIndex = 0;
        count++;
        notEmpty.signal();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈哈，看到了这&lt;code&gt;notEmpty.signal();&lt;/code&gt;行代码，我笑了，哼，我们直接打开notEmpty，然后发现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private final Condition notEmpty;
    private final Condition notFull;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到了吧，就是Condition对象来实现的。&lt;/p&gt;
&lt;p&gt;我之所以不上来就把ArrayBlockingQueue的字段列上来，然后分析，是因为博主认为，一样东西不要上来就看它的架构（对大多数人而言），首先我们要会用，然后再摸清楚它的构造，就像汽车以上，我们不都是会开车后，然后车慢慢出问题了，然后找方法去修理吗？&lt;br/&gt;者可能是博主个人的学习方式，大神可能就不适合我说的这种方式了。&lt;/p&gt;
&lt;p&gt;关于阻塞队列底层实现真的不难（博主那么菜也能看的七分懂），所以就不继续往下面看了，至于其他几种阻塞队列的实现，有空再拜读，感兴趣的小伙伴也可以自己去看看，应该能收获一些有用的知识！&lt;br/&gt;（写这篇文章的目的之一也是自己在看线程池，原来只想简单罗列一下几个阻塞队列，没想到写的多了一点，当然也没有多太多，嘿嘿）&lt;/p&gt;
&lt;p&gt;2018 4.14 14：31&lt;/p&gt;
</description>
<pubDate>Sat, 14 Apr 2018 06:32:00 +0000</pubDate>
<dc:creator>MindMrWang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MindMrWang/p/8831788.html</dc:identifier>
</item>
<item>
<title>公共平台服务治理与鉴权 - 少年天团</title>
<link>http://www.cnblogs.com/1024Community/p/8831539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1024Community/p/8831539.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;聊一聊最近了解的公司服务治理平台，主要是思想，理念，而不是一种技术或框架。整个平台设计，融入了OAUTH2认证，融入了微服务思想，帮助公司各系统在复杂的IT架构下，实现一种便捷统一的调用方案，同时完成调用的管理（监控、注册、鉴权等）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;0&quot;&gt;&lt;span&gt;问题&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;一种思想或理念的出现，是否有价值，我认为主要在于它实际解决了哪些问题。基于这个价值观，我们先看看，当一个公司有成百上千个系统时，会有哪些问题？&lt;br/&gt;pi如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;接口访问有没有鉴权？如何鉴权？这个话题很大，归根揭底就是，要让提供方知道调用方是谁（身份），并且同意调用（授权）。&lt;/li&gt;
&lt;li&gt;想看看系统间调用关系，得查代码或文档&lt;/li&gt;
&lt;li&gt;某个系统异常，怎么评估影响范围？谁调了它，它调了谁？&lt;/li&gt;
&lt;li&gt;某系统调用量如何？负载均衡之前需不需要流量控制？&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;1&quot;&gt;&lt;span&gt;解决问题&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;服务治理平台，目标就是把所有系统的所有接口，管理起来，对调用方进行鉴权，对提供方开放接口注册，运营来统一管理授权。最终，解决权限问题，监控系统间调用关系，实现公司级的服务治理。&lt;br/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2&quot;&gt;&lt;span&gt;鉴权&lt;/span&gt;&lt;/h4&gt;
&lt;br/&gt;开放平台，很重要的一个点，就是对访问进行权限控制。比较老的Basic Auth认证方式，在请求中加入用户名和密码，由服务端来进行鉴权。目前较通用的OAuth认证，通过Access Token完成授权与认证，具体不在详述，目前我们使用OAUTH2。&lt;br/&gt;其实，抽象来看，鉴权主要围绕两个问题，1，你是谁，2，同意不同意你调。&lt;br/&gt;围绕这两个问题，我们来捋一捋怎么设计，来完成这两个事：
&lt;ol&gt;&lt;li&gt;首先，得有个系统，让&lt;code&gt;调用方注册用户，申请访问接口等&lt;/code&gt;，暂且命名为portal&lt;/li&gt;
&lt;li&gt;其次，提供方可以在平台注册自己的接口&lt;/li&gt;
&lt;li&gt;平台管理人员，一般是运营同事，得有个系统可以&lt;code&gt;查看注册接口、访问申请、注册用户、发布到公共平台等等&lt;/code&gt;，并完成对各种访问的授权，暂且命名为admin&lt;/li&gt;
&lt;li&gt;另，既然使用了oauth2，就得有个取token的系统，暂且命名为oauth&lt;/li&gt;
&lt;li&gt;最后，得有个对外的统一入口吧（即公共平台），暂且名为open&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;整个调用鉴权流程，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344248/201804/1344248-20180414135421175-1155357141.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
1. 调用方注册用户
2. protal返回用户id和secret
3. 管理员，审核用户（你是谁？）
4. 用户id通过审核
5. 通过审核的用户id申请相关访问资源
6. 管理员，授权资源访问（同不同意你调？）
7. 资源申请通过
8. 根据用户id和secret到oauth取token
9. 到公共平台（open）访问你申请的资源，需要带上token
10. open对token进行鉴权
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3&quot;&gt;&lt;span&gt;注册&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;提供方系统注册接口到公共平台，有很多种方式，目前，我们主要使用两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;系统内置平台注册SDK，在代码中实现接口注册&lt;/li&gt;
&lt;li&gt;系统调用平台开放注册接口，通过HTTP请求完成注册。这种方式，提供方本身又成了公共平台的调用方，需要走一遍上面的鉴权过程=。=&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;整个注册流程比较简单，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1344248/201804/1344248-20180414135432341-567661999.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4&quot;&gt;&lt;span&gt;管理&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;基于以上分析，有个提供方并在平台注册了接口，有了调用方并在平台获得了授权，那么整个管理平台的基本职能就可以推断出来：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务注册、维护&lt;/li&gt;
&lt;li&gt;消费维护、授权&lt;/li&gt;
&lt;li&gt;应用申请授权、接口发布&lt;/li&gt;
&lt;li&gt;系统运行态数据监控&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;5&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;以上，仅仅是一个梗概，认识一个东西，我喜欢先看轮廓，在扣细节。&lt;br/&gt;扣个细节，比如，授权单位如果是个接口的话，我们公司将近2w个openAPI接口，授权起来比较琐碎，此时可以用分组来进行管理。如某个小系统的所有接口放到一个组里面，调用方通过申请组资源的访问，来完成对组内接口的访问。&lt;br/&gt;在比如，授权时可以设置用户token的时效，过期token失效，需要重新取token。时效设置多久合适，大家可以另行分析。我们系统是金融领域=。=&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以上来自天团运营总监：&lt;a href=&quot;http://www.cnblogs.com/lknny/&quot;&gt;坤少&lt;/a&gt;&lt;br/&gt;感谢观看，点个赞，我觉得不过分。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Apr 2018 05:55:00 +0000</pubDate>
<dc:creator>少年天团</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1024Community/p/8831539.html</dc:identifier>
</item>
<item>
<title>通俗易懂的讲解区块链 - GodChao</title>
<link>http://www.cnblogs.com/majianchao/p/8831283.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/majianchao/p/8831283.html</guid>
<description>&lt;p&gt;    最近，区块链很火，刚刚在人大会上又火了一把。之所以如此，是因为区块链既是全新的技术方案、交易模式和商业逻辑，同时也是一种全新的制度机制。区块链的“网红效应”才刚刚开始。&lt;/p&gt;
&lt;p&gt;    本文的主要思想来自于&amp;lt;区块链：即使技术方案，也是制度机制&amp;gt;。我也是一个区块链的小白，对一直对区块链很感兴趣和好奇。本文讲解的很到位，故而分享给大家。&lt;/p&gt;
&lt;p&gt;一 去中心化-----区块链的第一机理&lt;/p&gt;
&lt;p&gt;       当今时代，社会制度的核心机制是“中心化”，国家、政府、各类首脑机关、银行、交易所、公司等都是中心。这些中心根据各自承担的职能，对权力、军事、交通、信息、货币、商业交易等几乎社会运行所涉及的一切资源进行集中或分散，社会成员通过与各类中心的互动而获取财富、履行职责，并且与其他成员之间建立联络。当然，并不是说所有的人类行为都需要借助中心来完成，但“中心化”无疑是社会运行最主要的模式。&lt;/p&gt;
&lt;p&gt;　　“中心化”作为一种机制的优势有很多，可以提高效率、集合资源、迅速建立起秩序等，但中心化的缺陷也是显而易见的，因为中心化意味着对个体权利和选择机会进行了限制，并且必然会对资源财富、社会成员的活动等形成控制，造成不平等、不公平、不透明。所以，去除“中心”的存在，实现社会成员与成员之间的直接互联，由成员共同而且自发地对公共事务实施管理，这一直是人类的理想之一。&lt;/p&gt;
&lt;p&gt;　　区块链最初只是“比特币”的基础技术，在创立之初未必会有太过复杂的意旨，但随着比特币风靡于世，其所暗含的内在机理也正在不断地释放出光芒。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjKVZLyhmwiaiaXYiaXzNhc4FLA6mImiaBs2kFh0ibHiaOQympHvkSE1rOFKibWq3E3wNqyxG7vSlMgatiaLiam5Tjorxiaw/0?wx_fmt=jpeg&quot; alt=&quot;&quot; data-w=&quot;1114&quot; data-s=&quot;300,640&quot; data-copyright=&quot;0&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5403949730700179&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“点”与“点”的直联，也即人与人的直联，没有中心，也不需要中心，按照区块链的这种逻辑，基于商业交易的直联可以消灭企业，基于货币的直联可以消灭银行，基于管理公共事务的直联，那是无政府主义。&lt;/p&gt;
&lt;p&gt;二 共识机制&lt;/p&gt;
&lt;p&gt;    ​   主流社会制度的“痛点”显然不止“中心化”这么一项，“信任”就是另外一个“痛点”，尤其是陌生人之间的信任。“信任”是个大问题，司法、货币、银行、公证、征信，甚至政府的存在等，几乎都是为了实现社会成员的守信和相互信任，“中心化”某种程度上也是因为“中心”更可信。但是，现行机制的效果并不令人满意，且成本巨大。&lt;/p&gt;
&lt;p&gt;　　区块链解决了信任问题！&lt;/p&gt;
&lt;p&gt;　　区块链要求每个联结点在共同的账本上对每一笔交易进行分布式记账，每当交易发生之后，信息会通知到所有的“点”，各个“点”（即人）按照预设的规则独立地对交易进行确认，整个过程中，信息透明统一，参与者资格权限完全对等。多数“点”确认的结果就是最终的结论，系统会自动将你的数据修正为大家认可的结果。你想作弊或者坚持不同的观点，除非你能让超过51%的“点”都同时认可你的结论，当参与的“点”多到一定程度时，这事实上是不可能的。一次交易得到确认之后，交易的记录和各种数据打包成块，加上时间戳，编入链中，然后启动下一轮交易（块），新旧区块前后为继形成“链”。各个区块所存储的交易记录可以无限追溯，随时备查且无法更改，想要作假、撒谎、隐瞒真相，根本无机可乘，人与人之间的信任由此得以确立！&lt;/p&gt;
&lt;p&gt;    ​    ​这种信任不依赖于某个权威，而是建立在“共识”之上，一种由所有参与者在完全平等和信息充分透明的基础之上达成的“共识”，并且由所有人共同维护和传承已经形成的“共识”，是真正“多数人对少数人的暴政”。&lt;/p&gt;
&lt;p&gt;　　第二代区块链还引入了“智能合约”机制，在程序中加入了能够自动履行的合约，一旦约定的条件得到满足，系统将自动实施强制交付，所有的联结点也都会见证和确认这一过程，容不得背信弃义行为的发生。&lt;/p&gt;
&lt;p&gt;三 激励机制&lt;/p&gt;
&lt;p&gt;    ​    ​任何一种制度机制，首要的功能显然应当是“激励”，其次才是约束，有效的激励是社会进步真正的动力。现行社会治理体系中的产权制度和分配方式等，宗旨皆在于激励人们去发展生产力、创造财富；公司薪酬制度、职工持股、职级晋升等同样是为了激励员工努力创造价值。区块链如果应用于商业场景，自身不需要附带激励功能，因为参与者的商业诉求自然会激励他们主动地去管理和维护区块链。但如果应用于公共事务，就必须加入激励机制，否则链条将无法延续下去。&lt;/p&gt;
&lt;p&gt;　　比特币、以太币以及其他各种虚拟代币（token），正是区块链具备激励功能的体现。中本聪所设计的区块链是试验之作，本身并无商业价值，为了引起关注、发展联结点，同时激励参与者不断通过“挖矿”式计算来创建新的区块，共同维护链条的延展存续，他必须要给予为此而做出努力的人以“报酬”。所以，在每一次“挖矿”成功并得到确认之后，新的区块形成，而公认胜出的“挖矿”者则获得token，并被记入公共账本。中本聪将这种本质上属于一段计算机程序的奖励命名为“比特币（Bitcoin）”，这种命名暗合了现实社会中人们关于货币的各种意念，从而使区块链被误认为是一种造钱的计算机程序，比特币因此而风靡于世，并且还催生出一波虚拟货币热潮。&lt;/p&gt;
&lt;p&gt;　　无论是从制度设计，还是实际效果，最早的“比特币区块链”所蕴含的激励机制无疑都是十分成功的。&lt;/p&gt;
&lt;p&gt;    ​    ​虚拟货币热潮主要体现在“ICO（初次代币发行）”这个概念之上，如在2014年通过ICO众筹得以发展的以太坊（Ethereum）。但实践中多数ICO公司的目的并不在于开发区块链，或者尚且处在毫无头绪的状态，只是以技术创新为装帧，以发行“token”之名行募集资金之实，他们此时发行的勿宁说是一种虚拟的证券，与区块链技术无关，完全是规避资本市场管制的非法行为，理所当然被禁止。&lt;/p&gt;
&lt;p&gt;　　至于各种以网络“虚拟货币”取代法定货币的讨论，显然是伪命题。基于区块链技术的“虚拟货币”只存在于特定的区块链场景之中，并且无中心、无组织；而法定货币是通货，是一个国家主权的体现，承载着几乎全部社会财富，因而绝无可能被某种网络上自行创制的“虚拟货币”所取代。但“虚拟货币”是数字化的，方便快捷，并且交易完全透明，可以无限追溯，基于此类货币的洗钱、行贿、受贿等犯罪行为无所遁形。所以，随着技术的进步和货币数字化交易方式的普及，由政府主导，基于区块链技术发行“法定数字货币”作为通货使用，减少或取消“纸币”的发行，将会是必然的趋势。即便如此，国家主导发行的区块链货币也不可能是完全“去中心化”的。&lt;/p&gt;
&lt;p&gt;四 前进展望&lt;/p&gt;
&lt;p&gt;    ​    ​理论上言，可以将现实生活中互联网可及的所有事物都装在一个巨大的区块链中，从而彻底解决平等、公平、失信、犯罪等一切问题，区块链技术似乎也蕴含了这样远大的理想。但这种理想无异于“乌托邦”，不仅科技水平不支持，世俗国家林立的世界也不允许存在这样的“链”。&lt;/p&gt;
&lt;p&gt;　　目前，比特币每秒能够执行的交易只有廖廖几笔，而中心化机制的支付宝每秒频次可达几十万笔。分布式记账，等待所有的“点”形成共识，以及对各个参与者巨大的数据储存和分析能力的要求等，都决定了区块链的效率极其低下，根本无法满足现实交易的需求。所以，区块链目前的实用价值尚且不高。但在多方当事人参与，且呈流程化延展的交易场景里，比如供应链交易、票据流通，乃至诉讼程序等场合，区块链无疑具有明显的应用优势，实践中成功的案例也在不断涌现。&lt;/p&gt;
&lt;p&gt;　　技术从不因人而停滞，人却因技术而解放。未来，随着互联技术的不断进步，信息传输速度和软硬件性能的不断提高，相信区块链终将克服所有障碍，而成为最有效、最流行的技术方案，其所蕴含的全新的制度机制也必将绽放出人类文明之花。&lt;/p&gt;

</description>
<pubDate>Sat, 14 Apr 2018 05:08:00 +0000</pubDate>
<dc:creator>GodChao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/majianchao/p/8831283.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构（栈01） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8799326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8799326.html</guid>
<description>&lt;p&gt;　　其实说到底，在js中栈更像是一种变种的数组，只是没有数组那么多的方法，也没有数组那么灵活。但是栈和队列这两种数据结构比数组更加的高效和可控。而在js中要想模拟栈，依据的主要形式也是数组。&lt;/p&gt;
&lt;p&gt;　　从这篇文章开始，可能会接触到一些原型，原型链，类，构造函数等相关的js概念，但是这里并不会过多的介绍这些概念，必要的时候会进行一些简要的说明，推荐大家去看看&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html#top&quot; target=&quot;_blank&quot;&gt;汤姆大叔的深入理解Javascript系列&lt;/a&gt;，王福朋大神的&lt;a href=&quot;http://www.cnblogs.com/wangfupeng1988/p/3977987.html&quot; target=&quot;_blank&quot;&gt;深入理解Javascript原型和闭包系列&lt;/a&gt;。都是极为不错的深度好文，推荐大家可以深入学习。&lt;/p&gt;
&lt;p&gt;　　要想实现一个数据结构，首先你要明白它的基本原理，那么栈是什么？又是如何工作的呢？&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://baike.baidu.com/item/%E6%A0%88/12808149?fr=aladdin&quot; target=&quot;_blank&quot;&gt;栈（stack）&lt;/a&gt;是一种遵循&lt;strong&gt;后进先出&lt;/strong&gt;（Last In First Out）原则的有序集合。&lt;strong&gt;新添加的元素和待删除的元素都保存在栈的同一端，称为栈顶，另一端就叫做栈底。在栈里，新元素都接近栈顶，旧元素都靠近栈底。&lt;/strong&gt;其实可以把栈简单理解成往一个木桶里堆叠的放入物品，最后放进去的在桶的顶端，也是可以最先拿出来的，而最先放进去的却在桶的底部，只有把所有上面的物品拿出来之后才可以拿走底部的物品。&lt;/p&gt;
&lt;p&gt;　　对于数组来说，可以添加元素，删除元素，获取数组的长度以及返回对应下标得到值，那么在开始构造一个栈之前，我们需要了解一下栈都有哪些基本操作。&lt;/p&gt;
&lt;p&gt;　　1、压栈，也称之为入栈，也就是把元素加入栈中。就像是数组中的push一样。&lt;/p&gt;
&lt;p&gt;　　2、出栈，移除栈顶的元素。就像是数组中的pop一样。&lt;/p&gt;
&lt;p&gt;　　3、获取栈顶的元素，不对栈做任何其他操作。就像是在数组中通过下标获取对应的值一样。&lt;/p&gt;
&lt;p&gt;　　4、判断栈是否为空。就像是判断数组的长度是否为0一样。&lt;/p&gt;
&lt;p&gt;　　5、清空栈，也就是移除栈里的所有元素。就像是把数组的长度设置为0一样。&lt;/p&gt;
&lt;p&gt;　　6、获取栈里的元素个数。就像是数组的length属性一样。&lt;/p&gt;
&lt;p&gt;　　那么，我相信我大家已经对栈有了一个基本的了解，那么我们接下来就看看如何通过构造函数来实现一个自己的js栈。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Stack () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; items =&lt;span&gt; [];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先，我们来实现一个入栈的方法，这个方法负责往栈里加入元素，要注意的是，该方法只能添加元素到栈顶，也就是栈的尾部。&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.push = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ele) {
        items.push(ele)
    }

}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stack = &lt;span&gt;new&lt;/span&gt; Stack();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们声明一个构造函数，并且在构造函数中生命一个私有变量items，作为我们Stack类储存栈元素的基本支持。然后，加入一个push方法，通过this来使其指向调用该方法的实例。下面我们还会通过这样的方式依次添加其他的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Stack () {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; items =&lt;span&gt; [];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先，我们来实现一个入栈的方法，这个方法负责往栈里加入元素，要注意的是，该方法只能添加元素到栈顶，也就是栈的尾部。&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.push = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ele) {
        items.push(ele);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;然后我们再添加一个出栈的方法，同样的，我们只能移除栈顶的元素。&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.pop = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ele) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; items.pop();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看栈顶，也就是栈的尾部元素是什么&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.peek = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; items[items.length - 1&lt;span&gt;];
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查栈是否为空&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.isEmpty = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; items.length == 0&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查栈的长度&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.size = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; items.length;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空栈&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.clear = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        items &lt;/span&gt;=&lt;span&gt; [];
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印栈内元素&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.print = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        console.log(items.toString())
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样我们就通过构造函数完整的创建了一个栈。我们可以通过new命令实例化一个Stack对象来测试一下我们的栈好不好用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; stack = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stack();
console.log(stack.isEmpty());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
stack.push(1&lt;span&gt;);
stack.print();
stack.push(&lt;/span&gt;3&lt;span&gt;);
stack.print();
console.log(stack.isEmpty());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
console.log(stack.size());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
stack.push(10&lt;span&gt;);
stack.print();
stack.pop();
stack.print();
stack.clear();
console.log(stack.isEmpty());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们发现我们的Stack类执行的还算不错。那么还有没有其他的方式可以实现Stack类呢？在ES6之前我可能会遗憾懵懂的对你Say No。但是现在我们可以一起来看看ES6带我们的一些新鲜玩意。&lt;/p&gt;
&lt;p&gt; 　　在开始改造我们的Stack类之前，需要先说一下ES6的几个概念。&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/class#constructor-%E6%96%B9%E6%B3%95&quot; target=&quot;_blank&quot;&gt;Class语法&lt;/a&gt;，&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/symbol&quot; target=&quot;_blank&quot;&gt;Symbol基本类型&lt;/a&gt;和&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/set-map#WeakMap&quot; target=&quot;_blank&quot;&gt;WeakMap&lt;/a&gt;。简单解释一下，以对后面的改造不会一脸懵逼，而大家想要更深入的了解ES6新增的各种语法，可以去自行查阅。&lt;/p&gt;
&lt;p&gt;　　Class语法简单来说就是一个语法糖，它的功能ES5也是完全可以实现的，只是这样看写起来更加清晰可读，更像是面向对象的语法。&lt;/p&gt;
&lt;p&gt;　　Symbol是ES6新增的一个基本类型，前面几篇文章说过，ES5只有6中数据类型，但是在ES6中又新增一种数据类型Symbol，它表示独一无二的值。&lt;/p&gt;
&lt;p&gt;　　WeakMap，简单来说就是用于生成键值对的集合，就像是对象（{}）一样，WeakMap的一个重要用处就是部署私有属性。&lt;/p&gt;
&lt;p&gt;　　当然，上面的简单介绍可不仅仅是这样的，真正的内容要比这些多得多。&lt;/p&gt;
&lt;p&gt;　　那么在大家知道了它们的一些基本意义。咱们开始改造一下Stack类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Stack {
  constructor() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.items =&lt;span&gt; [];
  }

  push(element) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.items.push(element);
  }

  pop() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.items.pop();
  }

  peek() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.items[&lt;span&gt;this&lt;/span&gt;.items.length - 1&lt;span&gt;];
  }

  isEmpty() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.items.length === 0&lt;span&gt;;
  }

  size() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.items.length;
  }

  clear() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.items =&lt;span&gt; [];
  }

  toString() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.items.toString();
  }

  print() {
      console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.items.toString())
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是用class来实现的Stack类，其实我们可以看一下，除了使用了constructor构造方法以外，其实并没有什么本质上的区别。&lt;/p&gt;
&lt;p&gt;　　那么我们还可以使用Symbol数据类型来实现，简单改造一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const _items = Symbol('stackItems'&lt;span&gt;);

class Stack {
  constructor() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[_items] =&lt;span&gt; [];
  }

  push(element) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;[_items].push(element);
  }

  pop() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;[_items].pop();
  }

  peek() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;[_items][&lt;span&gt;this&lt;/span&gt;[_items].length - 1&lt;span&gt;];
  }

  isEmpty() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;[_items].length === 0&lt;span&gt;;
  }

  size() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;[_items].length;
  }

  clear() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[_items] =&lt;span&gt; [];
  }

  print() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.toString());
  }

  toString() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;[_items].toString();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用Symbol也没有大的变化，只是声明了一个独一无二的_items来代替构造方法中的数组。&lt;/p&gt;
&lt;p&gt;　　但是这样的实现方式有一个弊端，那就是ES6新增的Object.getOwnPropertySymbols方法可以读取到类里面声明的所有Symbols属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const stack = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stack();
const objectSymbols &lt;/span&gt;=&lt;span&gt; Object.getOwnPropertySymbols(stack);
stack.push(&lt;/span&gt;1&lt;span&gt;);
stack.push(&lt;/span&gt;3&lt;span&gt;);
console.log(objectSymbols.length); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
console.log(objectSymbols); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [Symbol()]&lt;/span&gt;
console.log(objectSymbols[0]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Symbol()&lt;/span&gt;
stack[objectSymbols[0]].push(1&lt;span&gt;);
stack.print(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1, 3, 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　不知道大家注意没有，我们定义的Symbol是在构造函数之外的，因此谁都可以改动它。所以这样的方式还不是很完善的。那么我们还可以使用ES6的WeakMap，然后用闭包实现私有属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过闭包把声明的变量变成私有属性&lt;/span&gt;
let Stack = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明栈的基本依赖&lt;/span&gt;
const _items = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WeakMap();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明计数器&lt;/span&gt;
const _count = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WeakMap();

class Stack {
  constructor() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化stack和计数器的值，这里的set是WeakMap的自身方法，通过set和get来设置值和取值，这里用this作为设置值的键名，那this又指向啥呢？自行console！&lt;/span&gt;
    _count.set(&lt;span&gt;this&lt;/span&gt;, 0&lt;span&gt;);
    _items.set(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, {});
  }

  push(element) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在入栈之前先获取长度和栈本身&lt;/span&gt;
    const items = _items.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    const count &lt;/span&gt;= _count.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里要注意_count可是从0开始的噢&lt;/span&gt;
    items[count] =&lt;span&gt; element;
    _count.set(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, count + 1&lt;span&gt;);
  }

  pop() {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果为空，那么则无法出栈&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEmpty()) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; undefined;
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取items和count，使长度减少1&lt;/span&gt;
    const items = _items.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    let count &lt;/span&gt;= _count.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    count&lt;/span&gt;--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新为_count赋值&lt;/span&gt;
    _count.set(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, count);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除出栈的元素，并返回该元素&lt;/span&gt;
    const result =&lt;span&gt; items[count];
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; items[count];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  }

  peek() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEmpty()) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; undefined;
    }
    const items &lt;/span&gt;= _items.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    const count &lt;/span&gt;= _count.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回栈顶元素&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; items[count - 1&lt;span&gt;];
  }

  isEmpty() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _count.get(&lt;span&gt;this&lt;/span&gt;) === 0&lt;span&gt;;
  }

  size() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _count.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  }

  clear() {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; while (!this.isEmpty()) {
        this.pop();
      } &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    _count.set(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, 0&lt;span&gt;);
    _items.set(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, {});
  }

  toString() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isEmpty()) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ''&lt;span&gt;;
    }
    const items &lt;/span&gt;= _items.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    const count &lt;/span&gt;= _count.get(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    let objString &lt;/span&gt;= `${items[0&lt;span&gt;]}`;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 1; i &amp;lt; count; i++&lt;span&gt;) {
      objString &lt;/span&gt;=&lt;span&gt; `${objString},${items[i]}`;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; objString;
  }

  print() {
      console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.toString());
  }
}

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Stack;
})()

const stack &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stack();
stack.push(&lt;/span&gt;1&lt;span&gt;);
stack.push(&lt;/span&gt;3&lt;span&gt;);
stack.print(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1, 3, 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是最终比较完善的版本了。那么不知道大家注没注意到一个小细节，前面我们只是声明一个变量，先不管他是不是私有的，就是数组，整个Stack构造函数都是基于items数组来进行各种方法的。&lt;/p&gt;
&lt;p&gt;但是这里通过WeakMap作为基本，我们却多用了一个_count，前面说了_count是计数器，那么为啥要用计数器？因为WeakMap是键值对的“对象类型”，本身是没有像数组这样的长度之说的，所以需要一个计数器来代替数组的下标，以实现基于Stack的各种方法。&lt;/p&gt;
&lt;p&gt; 　　到这里基本上就完成了我们的栈，下一篇文章会看看如何用我们写好的栈去做一些有趣事情。&lt;/p&gt;

&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 14 Apr 2018 04:38:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8799326.html</dc:identifier>
</item>
<item>
<title>【机器学习】Iris Data Set（鸢尾属植物数据集） - 昕-2008</title>
<link>http://www.cnblogs.com/Belter/p/8831216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Belter/p/8831216.html</guid>
<description>&lt;p&gt;&lt;span&gt;注&lt;/span&gt;：数据是机器学习模型的原材料，当下机器学习的热潮离不开大数据的支撑。在机器学习领域，有大量的公开数据集可以使用，从几百个样本到几十万个样本的数据集都有。有些数据集被用来教学，有些被当做机器学习模型性能测试的标准（例如ImageNet图片数据集以及相关的图像分类比赛）。这些高质量的公开数据集为我们学习和研究机器学习算法提供了极大的便利，类似于模式生物对于生物学实验的价值。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Iris数据集概况&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;Iris Data Set（鸢尾属植物数据集）是我现在接触到的历史最悠久的数据集，它首次出现在著名的英国统计学家和生物学家&lt;a href=&quot;https://en.wikipedia.org/wiki/Ronald_Fisher&quot; target=&quot;_blank&quot;&gt;Ronald Fisher&lt;/a&gt; 1936年的论文《The use of multiple measurements in taxonomic problems》中，被用来介绍线性判别式分析。在这个数据集中，包括了三类不同的鸢尾属植物：Iris Setosa，Iris Versicolour，Iris Virginica。每类收集了50个样本，因此这个数据集一共包含了150个样本。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;特征&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;该数据集测量了所有150个样本的4个特征，分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;sepal length（花萼长度）&lt;/li&gt;
&lt;li&gt;sepal width（花萼宽度）&lt;/li&gt;
&lt;li&gt;petal length（花瓣长度）&lt;/li&gt;
&lt;li&gt;petal width（花瓣宽度）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上四个特征的单位都是厘米（cm）。&lt;/p&gt;
&lt;p&gt;通常使用$m$表示样本量的大小，$n$表示每个样本所具有的特征数。因此在该数据集中，$m = 150, n = 4$&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;数据集的获取&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;该数据集被广泛用于分类算法的示例中，很多机器学习相关的数据都对这个数据集进行了介绍，因此可以获得的途径应该也会很多。&lt;/p&gt;
&lt;p&gt;下面是该数据集存放的原始位置，该位置好像已经无法下载了，但是收集了使用该数据集的论文列表可供参考：&lt;/p&gt;
&lt;p&gt;https://archive.ics.uci.edu/ml/datasets/Iris/&lt;/p&gt;
&lt;p&gt;另一个比较方便的获取方式是，直接利用Python中的机器学习包scikit-learn直接导入该数据集，可参考&lt;a href=&quot;http://scikit-learn.org/stable/datasets/index.html#iris-plants-database&quot; target=&quot;_blank&quot;&gt;Iris Plants Database&lt;/a&gt;，下面是具体的操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; load_iris
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; data =&lt;span&gt; load_iris()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(dir(data))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看data所具有的属性或方法&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(data.DESCR)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看数据集的简介&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;直接读到pandas的数据框中&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt; pd.DataFrame(data=data.data, columns=data.feature_names)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是第3行和第4行的输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
['DESCR', 'data', 'feature_names', 'target', 'target_names']

Iris Plants Database
====================

Notes
-----
Data Set Characteristics:
    :Number of Instances: 150 (50 in each of three classes)
    :Number of Attributes: 4 numeric, predictive attributes and the class
    :Attribute Information:
        - sepal length in cm
        - sepal width in cm
        - petal length in cm
        - petal width in cm
        - class:
                - Iris-Setosa
                - Iris-Versicolour
                - Iris-Virginica
    :Summary Statistics:

    ============== ==== ==== ======= ===== ====================
                    Min  Max   Mean    SD   Class Correlation
    ============== ==== ==== ======= ===== ====================
    sepal length:   4.3  7.9   5.84   0.83    0.7826
    sepal width:    2.0  4.4   3.05   0.43   -0.4194
    petal length:   1.0  6.9   3.76   1.76    0.9490  (high!)
    petal width:    0.1  2.5   1.20  0.76     0.9565  (high!)
    ============== ==== ==== ======= ===== ====================

    :Missing Attribute Values: None
    :Class Distribution: 33.3% for each of 3 classes.
    :Creator: R.A. Fisher
    :Donor: Michael Marshall (MARSHALL%PLU@io.arc.nasa.gov)
    :Date: July, 1988

This is a copy of UCI ML iris datasets.
http://archive.ics.uci.edu/ml/datasets/Iris

The famous Iris database, first used by Sir R.A Fisher

This is perhaps the best known database to be found in the
pattern recognition literature.  Fisher's paper is a classic in the field and
is referenced frequently to this day.  (See Duda &amp;amp; Hart, for example.)  The
data set contains 3 classes of 50 instances each, where each class refers to a
type of iris plant.  One class is linearly separable from the other 2; the
latter are NOT linearly separable from each other.

References
----------
...
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;数据的可视化展示&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;将数据用图像的形式展示出来，可以对该数据集有一个直观的整体印象。下面利用该数据集4个特征中的后两个，即花瓣的长度和宽度，来展示所有的样本点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; plt.style.use(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ggplot&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; X = data.data  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只包括样本的特征，150x4&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; y = data.target  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 样本的类型，[0, 1, 2]&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; features = data.feature_names  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4个特征的名称&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; targets = data.target_names  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3类鸢尾花的名称，跟y中的3个数字对应&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; plt.figure(figsize=(10, 4&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; plt.plot(X[:, 2][y==0], X[:, 3][y==0], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, label=&lt;span&gt;targets[0])
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; plt.plot(X[:, 2][y==1], X[:, 3][y==1], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;kx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, label=targets[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; plt.plot(X[:, 2][y==2], X[:, 3][y==2], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ro&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, label=targets[2&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; plt.xlabel(features[2&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; plt.ylabel(features[3&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iris Data Set&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;plt.legend()
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; plt.savefig(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iris Data Set.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, dpi=200&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;利用上面的代码画出来的图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1035701/201804/1035701-20180414121209289-1556178089.png&quot; alt=&quot;&quot; width=&quot;1066&quot; height=&quot;426&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;https://en.wikipedia.org/wiki/Iris_flower_data_set&lt;/p&gt;
&lt;p&gt;https://archive.ics.uci.edu/ml/datasets/Iris/&lt;/p&gt;
&lt;p&gt;https://matplotlib.org/users/style_sheets.html&lt;/p&gt;
&lt;p&gt;http://scikit-learn.org/stable/datasets/index.html#iris-plants-database&lt;/p&gt;

</description>
<pubDate>Sat, 14 Apr 2018 04:28:00 +0000</pubDate>
<dc:creator>昕-2008</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Belter/p/8831216.html</dc:identifier>
</item>
<item>
<title>【Web安全】DoS及其家族 - 木可大大</title>
<link>http://www.cnblogs.com/neal-ke/p/8831194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neal-ke/p/8831194.html</guid>
<description>&lt;blockquote readability=&quot;6.6022727272727&quot;&gt;
&lt;p&gt;不久前我分享过的&lt;a href=&quot;https://www.jianshu.com/p/b45df741f711&quot; target=&quot;_blank&quot;&gt;Web安全概述&lt;/a&gt;获得了大家的广泛关注，说明大家对Web安全这一块还是很关心的，因此木可大大将陆续推出目前常见的Web攻击手段和对应的防范策略。本期向大家介绍的是DoS和它的家族。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;DoS&lt;/h2&gt;
&lt;p&gt;DoS(Denial of Service，拒绝服务攻击)，它的原理很简单，就是用我们手里的机器去给服务器发请求，如果我们手头的服务器各方面性能都比服务器的主机的性能好，那么当我们发送大量请求给服务器，占用服务器的资源，导致服务器没有能力去处理其他用户请求。&lt;/p&gt;
&lt;p&gt;为了加深大家的理解，我就详细介绍DoS攻击中最有名的实现方式：&lt;code&gt;Syn-Flood攻击&lt;/code&gt;。在具体介绍&lt;code&gt;Syn-Flood攻击&lt;/code&gt;之前，我先和大家温故一下什么是三次握手。所谓的三次握手，就是在建立TCP连接的时候，客户端和服务器需要做几次通讯，确认相互之间的信息。它是保证TCP协议可靠性的重要手段之一。下面我们就来看一下它的具体流程：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-0e1781ee604c8dd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/10175366-0e1781ee604c8dd3.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;br/&gt;&lt;/div&gt;

&lt;p&gt;1、客户端（Client）首先向服务器（Server）发送连接请求，请求内容是：&lt;code&gt;SYN=1 Seq=X&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;2、服务器收到这个包以后，将这个数据放入到一个队列中，这个队列叫&lt;code&gt;syn_table&lt;/code&gt;。并且发送一个返回包，作为响应，这个返回包有自己的序列号（Seq=Y），以及一个Ack，Ack的值就是客户端发来的Seq值加一；&lt;/p&gt;
&lt;p&gt;3、客户端收到返回信息以后，将服务器的Seq加一作为Ack又发给服务器；&lt;/p&gt;
&lt;p&gt;4、服务器收到这第三个包，验证没问题以后，就将这个连接放入到&lt;code&gt;request_sock_queue&lt;/code&gt;&lt;br/&gt;，三次握手完成。&lt;/p&gt;
&lt;p&gt;以上就是三次握手的具体流程。看到这里大家可能会有个疑问，平时我们在和服务器建立连接的时候仅仅调用&lt;code&gt;connect&lt;/code&gt;，我们并没有进行三次握手，实际上&lt;code&gt;connect&lt;/code&gt;这个高层概念是对三次握手的抽象，它的具体实现完成了三次握手流程。&lt;/p&gt;
&lt;p&gt;面对TCP的三次握手协议，攻击者应该如何发起攻击呢？攻击者首先故意发起一个握手数据包，服务器收到以后将它放入等待队列，并返回确认。其次，攻击者不再发送第3个确认包，这样一来，服务器就会进行多次重传发送（Linux系统通过tcp_synack_retries配置重传次数），消耗了大量额外开销，以及等待队列被占用，甚至于等待队列被占满，最终导致服务器不能接收客户端的请求。这就是&lt;code&gt;Syn-Flood&lt;/code&gt;攻击。&lt;/p&gt;
&lt;p&gt;目前，我们是采取何种方法来解决&lt;code&gt;Syn-Flood&lt;/code&gt;攻击的呢？第一种方法，缩短等待时间，尽早删除在等待队列中等待非法请求数据包；第二种方法是在第一次握手报文不放入等待队列，我们将一个32位的无符号整数作为第二次握手的Seq返回给客户端，该整数通过将用户请求的参数（包括请求的地址、端口等），加上服务器的一个序列号等做了一次运算得到。如果是正常用户，它在收到这个整数之后加1作为ACK返回给服务器，服务器在拿到数据后，对这个ACK减1再进行逆运算得到各个参数，最后发出去的数据进行比对，如果完全一致，说明是一个有效的响应，存放到相应的数据结构，反之则不是。通过该方法，非法请求就不能占用系统资源了。&lt;/p&gt;
&lt;h2&gt;DDoS&lt;/h2&gt;
&lt;p&gt;DDoS(Distributed Denial of Service，分布式拒绝服务)，它是DoS家族里很难防范的一种攻击方式，攻击者首先控制大量肉鸡，然后向目标服务器发送海量请求，导致目标服务器不可用。这里我们不禁要问攻击者是如何获取大量肉鸡的呢？攻击者会对某些APP或网站植入一些恶意代码，譬如说&lt;code&gt;curl www.mukedada.com&lt;/code&gt;，用户在使用这款APP或网站时，会自动请求&lt;code&gt;www.mukedada.com&lt;/code&gt;这个网站，如果这款APP或网站的活跃用户数很多，那么&lt;code&gt;www.mukedada.com&lt;/code&gt;这个网站就会受到很多莫名的请求。这就要求我们在平时上网过程中不要浏览一些不知名的网站和下载来源不明的APP。&lt;/p&gt;
&lt;p&gt;针对这种攻击方式，我们该如何防御呢？首先，作为用户我们尽量从正规渠道下载APP以及文明上网，尽量不让自己做肉鸡；其次，作为服务厂家，当服务器受到DDoS攻击时，我们尽量提升服务器的处理能力，当我们服务器的处理能力大于攻击者的能力时，这些攻击对服务器就不算啥事；最后，一般情况下，我们的服务器的处理能力一般低于攻击者的能力，针对这种情况，目前有以下几种方法：1.暴力方式，譬如：设置访问频率阈值，当某个IP单位时间内访问次数超过这个阈值就拒绝；对于某个服务，如果瞬时请求过大，选择直接拒绝保证其他服务的正常工作；这种方式可能导致正常用户也无法使用。2. 验证码，为了防止暴露方式带来的误伤正常用户，目前服务商在收到大量请求时，会向&quot;用户&quot;发送验证码，如果是真实用户则会输入验证码，而是肉鸡的话，则不会，通过该方法则分辨出真实用户和肉鸡。&lt;/p&gt;
&lt;h2&gt;DRDoS&lt;/h2&gt;
&lt;p&gt;通过上文介绍，DDos攻击需要获取大量的肉鸡，但是获取肉鸡也越来越困难了，那目前还有没有不用控制肉鸡还能大量攻击的呢？DRDoS((Distributed Reflection Denial of Service，分布式反射拒绝服务)，攻击者将不是将请求直接发送给被攻击者，而是发送给一个第三方，通过第三方中转到被攻击者，这就是&quot;Reflection&quot;的体现。它的流程具体如下：攻击者将请求包的源IP篡改成要被攻击者的IP，目标IP是第三方IP，那么第三方的恢复报文的目标IP就变成被攻击者的IP，这样一来，被攻击者就会收到大量请求导致服务不可用。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-129a21ef8e402cf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/10175366-129a21ef8e402cf2.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;br/&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是：1. 攻击者往往选择的是基于UDP协议的系统，因为UDP协议是不可靠的，能够伪造源IP； 2. 攻击者往往会选择那些响应包大于请求包的服务。基于此，一般被被攻击的服务包括DNS服务、Memcached服务等。&lt;br/&gt;为了加深大家理解，我就以Memecached服务为例。首先，Memcahced运行在11211端口，支持TCP和UDP一些，也就是说攻击者能够伪造源IP，同时，Memcached支持最大键值但数据对1M存储，意味着攻击者用较小的请求包让攻击者收到变大了几十倍的数据包。&lt;/p&gt;
&lt;p&gt;对于这种攻击，有没有方法来防范呢？首先，扩大服务器的宽带；其次，尽可能选择TCP协议；最后，对于一些被放大的返回包直接进行丢弃。&lt;/p&gt;
&lt;div class=&quot;image-block&quot;&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1576089/i991j1wedf.jpeg?imageView2/0/w/1620&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;欢迎关注微信公众号：木可大大，所有文章都将同步在公众号上。&lt;/p&gt;
</description>
<pubDate>Sat, 14 Apr 2018 04:16:00 +0000</pubDate>
<dc:creator>木可大大</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/neal-ke/p/8831194.html</dc:identifier>
</item>
</channel>
</rss>