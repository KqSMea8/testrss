<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>依赖注入[2]: 基于IoC的设计模式 - Artech</title>
<link>http://www.cnblogs.com/artech/p/net-core-di-02.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/net-core-di-02.html</guid>
<description>&lt;p&gt;正如我们在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-01.html&quot;&gt;控制反转&lt;/a&gt;》提到过的，很多人将IoC理解为一种“面向对象的设计模式”，实际上IoC自身不仅与面向对象没有必然的联系，它也算不上是一种设计模式。一般来讲，设计模式提供了一种解决某种具体问题的方案，但是IoC既没有一个针对性的问题领域，其自身没有提供一种可实施的解决方案，所以我更加倾向于将IoC视为一种设计原则。实际上很多我们熟悉的设计模式背后采用了IoC原则，接下来我们就来介绍几种典型的“设计模式”。&lt;/p&gt;

&lt;p&gt;提到IoC，很多人首先想到的是DI，但是在我看来与IoC思想最为接近的倒是另一种被称为“模板方法（Template  Method）”的设计模式。模板方法模式与IoC的意图可以说不谋而合，该模式主张将一个可复用的工作流程或者由多个步骤组成的算法定义成模板方法，组成这个流程或者算法的步骤实现在相应的虚方法之中，模板方法根据按照预先编排的流程去调用这些虚方法。所有这些方法均定义在同一个类中，我们可以通过派生该类并重写相应的虚方法达到对流程定制的目的。&lt;/p&gt;
&lt;p&gt;对于《&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-01.html&quot;&gt;控制反转&lt;/a&gt;》演示的这个MVC的例子，我们可以将整个请求处理流程实现在如下一个&lt;strong&gt;MvcEngine&lt;/strong&gt;类中，请求的监听与接收、目标Controller的激活与执行以及View的呈现分别定义在5个受保护的虚方法中，模板方法StartAsync根据预定义的请求处理流程先后调用这5个方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcEngine
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task StartAsync(Uri address)
    {
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; ListenAsync(address);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; request = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ReceiveAsync();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controller = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; CreateControllerAsync(request);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; view = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ExecuteControllerAsync(controller);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; RenderViewAsync(view);
        }
    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Task ListenAsync(Uri address);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Task&amp;lt;Request&amp;gt;&lt;span&gt; ReceiveAsync();
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Task&amp;lt;Controller&amp;gt;&lt;span&gt; CreateControllerAsync(Request request);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Task&amp;lt;View&amp;gt;&lt;span&gt; ExecuteControllerAsync(Controller controller);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Task RenderViewAsync(View view);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于具体的应用来说，如果定义在MvcEngine针对请求的处理方式完全符合它的要求，它只需要创建这个一个MvcEngine对象，然后指定一个对应的基地址调用模板方法StartAsync开启这个MVC引擎即可。如果该MVC引擎处理请求的某个环节不能满足它的要求，它可以创建MvcEngine的派生类，并重写实现该环节的相应虚方法即可。&lt;/p&gt;
&lt;p&gt;比如说定义在某个应用程序中的Controller都是无状态的，它希望采用单例（Singleton）的方式重用已经激活的Controller以提高性能，那么它就可以按照如下的方式创建一个自定义的&lt;strong&gt;FoobarMvcEngine&lt;/strong&gt;并按照自己的方式重写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMvcEngine : MvcEngine
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Task&amp;lt;View&amp;gt;&lt;span&gt; CreateControllerAsync (Request request)
    {
        &lt;/span&gt;&amp;lt;&amp;lt;省略实现&amp;gt;&amp;gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于一个复杂的流程来说，我们倾向于将组成该流程的各个环节实现在相对独立的组件之中，那么针对流程的定制就可以通过提供定制组件的方式来实现。我们知道23种设计模式之中有一种重要的类型，那就是“创建型模式”，比如常用的“工厂方法”和“抽象工厂”，IoC所体现的针对流程的共享与定制可以通过它们来完成。&lt;/p&gt;
&lt;p&gt;所谓的工厂方法，说白了就是在某个类中定义用于提供依赖对象的方法，这个方法可以是一个单纯的虚方法，也可以是具有默认实现的虚方法，至于方法声明的返回类型，可以是一个接口或者抽象类，也可以是未被封闭（Sealed）的具体类型。作为它的派生类型，它可以实现或者重写工厂方法以提供所需的具体对象。&lt;/p&gt;
&lt;p&gt;同样以我们的MVC框架为例，我们让独立的组件来完成组成整个请求处理流程的几个核心环节。具体来说，我们针对这些核心组件定义了如下这几个对应的接口。&lt;strong&gt;IWebLister&lt;/strong&gt;接口用来监听、接收和响应请求（针对请求的响应由ReceiveAsync方法返回的HttpContext对象来完成，后者表示针对当前请求的上下文），&lt;strong&gt;IControllerActivator&lt;/strong&gt;接口用于根据当前请求激活目标Controller对象，已经在后者执行完成后做一些释放回收工作。至于&lt;strong&gt;IControllerExecutor&lt;/strong&gt;和&lt;strong&gt;IViewRender&lt;/strong&gt;接口则分别用来完成针对Controller的执行和针对View的呈现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWebLister
{
    Task ListenAsync(Uri address);
    Task&lt;/span&gt;&amp;lt;HttpContext&amp;gt;&lt;span&gt; ReceiveAsync();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IControllerActivator
{
    Task&lt;/span&gt;&amp;lt;Controller&amp;gt;&lt;span&gt; CreateControllerAsync(HttpContext httpContext);
    Task ReleaseAsync(Controller controller);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IControllerExecutor
{
    Task&lt;/span&gt;&amp;lt;View&amp;gt;&lt;span&gt; ExecuteAsync(Controller controller, HttpContext httpContext);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IViewRender
{
    Task RendAsync(View view, HttpContext httpContext);
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;我们在作为MVC引擎的MvcEngine类中定义了四个工厂方法（GetWebListener、GetControllerActivator、GetControllerExecutor和GetViewRenderer）来提供上述这4种组件。这四个工厂方法均为具有默认实现的虚方法，我们可以利用它们提供默认的组件。在用于启动引擎的StartAsync方法中，我们利用这些工厂方法提供的对象来具体完成请求处理流程的各个核心环节。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;code&gt; &lt;/code&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcEngine
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task StartAsync(Uri address)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; listener =&lt;span&gt; GetWebLister();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; activator =&lt;span&gt; GetControllerActivator();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; executor =&lt;span&gt; GetControllerExecutor();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; render =&lt;span&gt; GetViewRender();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ListenAsync(address);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContext = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ReceiveAsync();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controller = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.CreateControllerAsync(httpContext);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; view = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; executor.ExecuteAsync(controller, httpContext);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; render.RendAsync(view, httpContext);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;

            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.ReleaseAsync(controller);
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IWebLister GetWebLister(); 
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IControllerActivator GetControllerActivator();
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IControllerExecutor GetControllerExecutor();
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IViewRender GetViewRender();
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;对于具体的应用程序来说，如果需要对请求处理的某个环节进行定制，它需要将定制的操作实现在对应接口的实现类中。在MvcEngine的派生类中，我们需要重写对应的工厂方法来提供被定制的对象。 比如上面提及的以单例模式提供目标Controller对象的实现就定义在SingletonControllerActivator类中，我们在派生于MvcEngine的&lt;strong&gt;FoobarMvcEngine&lt;/strong&gt;类中重写了工厂方法GetControllerActivator使其返回一个&lt;strong&gt;SingletonControllerActivator&lt;/strong&gt;对象。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingletonControllerActivator : IControllerActivator
{         
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;Controller&amp;gt;&lt;span&gt; CreateControllerAsync(HttpContext httpContext)
    {
        &lt;/span&gt;&amp;lt;&amp;lt;省略实现&amp;gt;&amp;gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task ReleaseAsync(Controller controller) =&amp;gt;&lt;span&gt; Task.CompletedTask;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarMvcEngine : MvcEngine
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; ControllerActivator GetControllerActivator() =&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingletonControllerActivator();
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;虽然工厂方法和抽象工厂均提供了一个“生产”对象实例的工厂，但是两者在设计上却有本质的不同。工厂方法利用定义在某个类型的抽象方法或者虚方法实现了针对单一对象提供方式的抽象，而抽象工厂则利用一个独立的接口或者抽象类来提供&lt;strong&gt;一组&lt;/strong&gt;相关的对象。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;具体来说，我们需要定义一个独立的工厂接口或者抽象工厂类，并在其中定义多个的工厂方法来提供“同一系列”的多个相关对象。如果希望抽象工厂具有一组默认的“产出”，我们也可以将一个未被封闭的具体类作为抽象工厂，以虚方法形式定义的工厂方法将默认的对象作为返回值。我们根据实际的需要通过实现工厂接口或者继承抽象工厂类（不一定是抽象类）定义具体工厂类来提供一组定制的系列对象。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;现在我们采用抽象工厂模式来改造我们的MVC框架。如下面的代码片段所示，我们定义了一个名为IMvcEngineFactory的接口作为抽象工厂，定义在其中定义了四个方法来提供请求监听和处理过程使用到的4种核心对象。如果MVC提供了针对这四种核心组件的默认实现，我们可以按照如下的方式为这个抽象工厂提供一个默认实现（MvcEngineFactory）。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IMvcEngineFactory
{
    IWebLister GetWebLister();
    IControllerActivator GetControllerActivator();
    IControllerExecutor GetControllerExecutor();
    IViewRender GetViewRender();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcEngineFactory： IMvcEngineFactory
{
    IWebLister GetWebLister();
    IControllerActivator GetControllerActivator();
    IControllerExecutor GetControllerExecutor();
    IViewRender GetViewRender();
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;现在我们采用抽象工厂模式来改造我们的MVC框架。我们在创建MvcEngine对象可以提供一个具体的IMvcEngineFactory对象，如果没有显式指定，MvcEngine会使用默认的EngineFactory对象。在用于启动引擎的StartAsync方法中，MvcEngine利用IMvcEngineFactory来获取相应的对象协作完整对请求的处理流程。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;code&gt; &lt;/code&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MvcEngine
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IMvcEngineFactory EngineFactory { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MvcEngine(IMvcEngineFactory engineFactory = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
    &lt;/span&gt;=&amp;gt; EngineFactory = engineFactory??&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MvcEngineFactory();
        
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task StartAsync(Uri address)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; listener =&lt;span&gt; EngineFactory.GetWebLister();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; activator =&lt;span&gt; EngineFactory.GetControllerActivator();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; executor =&lt;span&gt; EngineFactory.GetControllerExecutor();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; render =&lt;span&gt; EngineFactory.GetViewRender();
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ListenAsync(address);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContext = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; listener.ReceiveAsync();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controller = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.CreateControllerAsync(httpContext);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; view = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; executor.ExecuteAsync(controller, httpContext);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; render.RendAsync(view, httpContext);
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; activator.ReleaseAsync(controller);
            }
        }
    }
        
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;如果具体的应用程序需要采用上面定义的SingletonControllerActivator以单例的模式来激活目标Controller，我们可以按照如下的方式定义一个具体的工厂类FoobarEngineFactory。最终的应用程序将这么一个FoobarEngineFactory对象作为MvcEngine的EngineFactory。&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarEngineFactory : EngineFactory
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; ControllerActivator GetControllerActivator()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingletonControllerActivator();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        Uri address &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://0.0.0.0:8080/mvcapp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        MvcEngine engine     &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MvcEngine(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FoobarEngineFactory());
        engine.Start(address);
    }
}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;除了上面介绍这三种典型的设计，还有很多其他的设计模式，比如策略模式、观察者模式等等，它们无一不是采用IoC的设计原则。Martin Fowler在《Inversion of Control 》一文中正是通过观察者模式来介绍IoC的。我们将在&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-03.html&quot;&gt;下一篇&lt;/a&gt;中对依赖注入模式进行深入讲解。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-01.html&quot;&gt;依赖注入[1]: 控制反转&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-02.html&quot;&gt;依赖注入[2]: 基于IoC的设计模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-03.html&quot;&gt;依赖注入[3]: 依赖注入模式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-04.html&quot;&gt;依赖注入[4]: 创建一个简易版的DI框架[上篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-05.html&quot;&gt;依赖注入[5]: 创建一个简易版的DI框架[下篇]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-06.html&quot;&gt;依赖注入[6]: .NET Core DI框架[编程体验]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-07.html&quot;&gt;依赖注入[7]: .NET Core DI框架[服务注册]&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/net-core-di-08html&quot;&gt;依赖注入[8]: .NET Core DI框架[服务消费]&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Jul 2018 22:26:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/artech/p/net-core-di-02.html</dc:identifier>
</item>
<item>
<title>JS中的作用域（一）-详谈 - 方红亮</title>
<link>http://www.cnblogs.com/fanghl/p/9369414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanghl/p/9369414.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;本篇文章在于详细解读JavaScript的作用域，从底层原理来解释一些常见的问题，例如变量提升、隐式创建变量等问题，在和大家一起交流进步的同时，也算对自己知识掌握的记录，方便以后复习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先，直接捡干的来，JS作用域大致分为三部分：词法作用域、函数作用域/块作用域、闭包。&lt;/p&gt;
&lt;p&gt;　　在传统的编译语言中，程序的源代码编译由三个步骤组成：词法分析、语法分析、代码生成。而JS属于动态语言，它的编译过程不发生在构建之前，而是在代码执行前（一般只有几微妙，甚至更短），简单说，任何JS代码执行前都要编译，编译完通常马上就要执行。&lt;/p&gt;
&lt;p&gt;　　例如： var a = 2; 将其分解为以下步骤：&lt;/p&gt;
&lt;p&gt;　　1.遇到   var a  编译器会询问作用域是否已经存在同名变量于同一个作用域的集合中，若存在，则忽略该声明。若不存在，编译器在当前作用域声明一个新变量a。&lt;/p&gt;
&lt;p&gt;　　2.接下来编译器会为引擎生成运行时的代码，这些代码用于处理  a = 2的赋值操作。引擎运行时会询问作用域，当前作用域是否存在变量a，若存在，引擎直接使用该变量。否则引擎继续向上查找，直到顶层全局作用域还未找到，则会抛出ReferenceError，如果找到，就会将2赋值给它。   &lt;/p&gt;
&lt;p&gt;　　在上面的例子中，引擎有两种查询方式：LHS、RHS。&lt;/p&gt;
&lt;p&gt;　　其中L、R代表“左”、“右”，是相对于赋值操作的左右，当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询，也可以这么理解，RHS查询是找到某个变量的值，而LHS是找到变量的容器本身！！！即作用域中开辟的变量存放空间。举个例子：如下代码   console.log(a); 引擎对a的查询就是RHS，这里没有赋值操作，需要查找a的值，并把它传给console.log(..);函数。在逐级向上查找中，直到全局也没找到，则抛出ReferenceError。但LHS若没找到是不会抛出错误的。具体原因继续看。&lt;/p&gt;
&lt;p&gt;　　举个例子：  a= 2； 这里对a的引用则是LHS引用，我们并不关心但前值是多少，只是想要为 =2 这个赋值操作找到合法目标，可能有童鞋疑问，=2不就是赋给a的嘛？对啊，但是a到底存不存在呢？在当前作用域中，我们是不知道是否创建了a的存储空间的，如果作用域中存在 var a ,那么该a的存储空间存在，LHS能成功，但是没有a的存储空间呢？也就是a并未创建呢？此时，LHS也不会抛出错误，而是隐式的在当前作用域（全局作用域、即最高层作用域，一层一层找上去的）为我们创建变量a的存储空间，然后把 =2 赋值给a。这也就是为啥 var a =2; 创建的是局部变量，而没有 var 申明的变量是全局变量的原因。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;作用域的嵌套&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394956/201807/1394956-20180726005001364-879384746.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　作用域就是一套如何存储和查找变量的规则。在嵌套作用域中，如上图，在foo（）中无法找到变量 b，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或者到达最顶层（全局作用域）。上图想要执行console.log()函数，就要对b进行RHS查找，得到其值。才foo中无法完成b的RHS，但在外层中却可以完成。即：引擎从当前的执行作用域中开始查找变量，找不到，则逐级向上查找，直到最顶层作用域。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;区分LHS和RHS&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;区分两种查询方式很重要，因为上文简单提到RHS找不到会抛出ReferenceError，而LHS则不会，它会隐式创建所需的变量。如下             &lt;img src=&quot;https://images2018.cnblogs.com/blog/1394956/201807/1394956-20180726010441901-2043469190.png&quot; alt=&quot;&quot;/&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394956/201807/1394956-20180726010916853-1469441499.png&quot; alt=&quot;&quot;/&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　对b的RHS查找失败，因为没有声明（创建）变量b，未声明的变量，在任何作用域中都无法找到！那么，在上图中，只要把 b= 2放在console.log()之前，函数就成功执行了，因为第一步执行 b= 2；赋值操作进行LHS，找不到，则在全局中隐式创建变量b，此时使用 window.b 是可以得到2的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;词法作用域&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　词法作用域就是定义此法阶段的作用域，即你写代码时将变量和作用域写在哪里而决定其作用范围。作用域在查找到第一个标识符时即停止查找，多层嵌套的作用域中同名的标识符，内部遮蔽外部（遮蔽效应），全局遮蔽可用window.得到其值，而局部遮蔽的则无论如何都无法被访问到。无论函数在哪里被调用，以何种方式调用，其词法作用域都只由被声明时所处的位置决定，即你写下哪他就在哪发挥作用。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394956/201807/1394956-20180726013252965-883087814.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;上图中，全局作用域中只有一个标识符，即foo，函数foo作用域中有三个标识符，即b，bar ，a 。函数bar里面只有一个标识符 c 。其每个标识符处于不同的作用域中，而代码运行时会以他们不同的位置而访问权限不同。这些位置在书写时已经被我们写死了，他们的作用被我们写好了，这就是词法作用域！代码的位置真的被我们“写死了嘛”？接着看&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;词法欺骗&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;词法作用域由写代码时声明的位置决定，也可以由两种机制来动态改变词法作用域。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　1.  eval（）函数。可接受一个字符串为参数，将其中内容视为好像在书写时就在这个地方的代码。可以理解为我在梦中就是高富帅，真实的就连后面的剧情（梦中剧情，哈哈）都是以高富帅为基础开展的，不知道这个比喻贴切不?即就是eval（）可以让里面的参数代码段达到书写时就在这个地方的效果。如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394956/201807/1394956-20180726015828929-708431728.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　输出结果为a:5，b:8，而不是a= 2，根据词法作用域中。foo中找不到a，则到上一层作用域中寻找，上一层中找到了 a = 2 ；。可是eval（）函数却欺骗了词法作用域，直接将a放在了foo内部，而导致引擎不需要到外层作用域去查找，直接使用 a = 5 ，从而达到此法欺骗。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.  with语句。with 语句通常用作重复引用一个对象的多个属性的快捷方式。代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1394956/201807/1394956-20180726022239127-454555842.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　with语句也可以达到欺骗词法的作用，但是副作用也很明显，造成了变量泄露。原因是调用obj2的时候，其没有变量a，进行LHS查询，最后隐式创建全局变量属性a ，导致变量泄露。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　以上两种词法欺骗方式，第一严重影响性能，第二在严格模式下有诸多限制，所以不建议使用。函数作用域和闭包近期在整理，过几天推出&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　今天只介绍了作用域和词法作用域，希望对小伙伴理解有所帮助，分享转载的朋友请注明出处，码字不易，谢谢理解！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Jul 2018 18:33:00 +0000</pubDate>
<dc:creator>方红亮</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanghl/p/9369414.html</dc:identifier>
</item>
<item>
<title>Netty源码—四、事件处理 - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/9369282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/9369282.html</guid>
<description>&lt;p&gt;前面经过channel初始化、注册，所需要的数据结构(epoll_event)基本上准备好了，serverSocket也处于监听状态，可以接收来自客户端的请求了。NioServerSocketChannel注册在了NioEventLoop#selector，在注册过程中启动了NioEventLoop，run方法会循环执行，每次循环都会执行select和执行所有的task。如果select有事件，则会处理收到的事件。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void processSelectedKeys() {
    if (selectedKeys != null) {
        // 是否使用优化过的selectionKey
        processSelectedKeysOptimized();
    } else {
        processSelectedKeysPlain(selector.selectedKeys());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面在NioEventLoop初始化的时候说过关于selectionKey优化的问题，这里不再赘述。两种方式主要是遍历selectionKey的方式不同，具体处理事件的调用是一样的。这里以processSelectedKeysOptimized为例。&lt;/p&gt;
&lt;h2 id=&quot;accept&quot;&gt;accept&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    // channel是NioServerSocketChannel
    // unsafe是NioMessageUnsafe
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
    // 省略中间代码...
    if ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
        // 调用NioMessageUnsafe.read
        unsafe.read();
    }
} catch (CancelledKeyException ignored) {
    unsafe.close(unsafe.voidPromise());
}

public void read() {
    // 省略中间代码...
                // 由于是ServerSocket，只负责accept，如果有IO事件说明就是有新的客户端连接，所以这里就是创建NioSocketChannel
                int localRead = doReadMessages(readBuf);
                if (localRead == 0) {
                    break;
                }
                if (localRead &amp;lt; 0) {
                    closed = true;
                    break;
                }

                allocHandle.incMessagesRead(localRead);
            } while (allocHandle.continueReading());
        } catch (Throwable t) {
            exception = t;
        }

        int size = readBuf.size();
        for (int i = 0; i &amp;lt; size; i ++) {
            readPending = false;
            // 注册刚刚创建的NioSocketChannel
            pipeline.fireChannelRead(readBuf.get(i));
        }
        readBuf.clear();
        allocHandle.readComplete();
        pipeline.fireChannelReadComplete();
        // 省略中间代码...
    }
}

protected int doReadMessages(List&amp;lt;Object&amp;gt; buf) throws Exception {
    // 调用java.nio.channels.ServerSocketChannel#accept来创建SocketChannel
    SocketChannel ch = SocketUtils.accept(javaChannel());

    try {
        if (ch != null) {
            // 创建NioSocketChannel
            buf.add(new NioSocketChannel(this, ch));
            return 1;
        }
    } catch (Throwable t) {
        // 省略中间代码...
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面创建了NioSocketChannel之后，接下来注册所有客户端连接的NioSocketChannel，调用的是DefaultChannelPipeline#fireChannelRead方法，接下来是执行pipeline中的handler，在初始化的时候添加了LoggingHandler （如果启动的时候配置了的话），那么目前pipeline中的handler有&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;io.netty.channel.DefaultChannelPipeline$HeadContext：pipeline创建的时候默认的第一个handler&lt;/li&gt;
&lt;li&gt;io.netty.handler.logging.LoggingHandler：启动的时候用户配置的handler&lt;/li&gt;
&lt;li&gt;io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor&lt;/li&gt;
&lt;li&gt;io.netty.channel.DefaultChannelPipeline$TailContext：pipeline创建的时候默认的最后一个handler&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面看下ServerBootstrap$ServerBootstrapAcceptor是什么时候添加到handler的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// io.netty.bootstrap.ServerBootstrap#init
// 这个方法是NioServerSocketChannel初始化的时候调用的
void init(Channel channel) throws Exception {
    // 省略中间代码...
    p.addLast(new ChannelInitializer&amp;lt;Channel&amp;gt;() {
        @Override
        public void initChannel(final Channel ch) throws Exception {
            final ChannelPipeline pipeline = ch.pipeline();
            ChannelHandler handler = config.handler();
            if (handler != null) {
                pipeline.addLast(handler);
            }

            ch.eventLoop().execute(new Runnable() {
                @Override
                public void run() {
                    // 在pipeline中添加ServerBootstrapAcceptor
                    pipeline.addLast(new ServerBootstrapAcceptor(
                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                }
            });
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以说ServerBootstrapAcceptor，是因为NioSocketChannel的register过程是这个handler的channelRead方法开始的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void channelRead(ChannelHandlerContext ctx, Object msg) {
    final Channel child = (Channel) msg;

    child.pipeline().addLast(childHandler);

    setChannelOptions(child, childOptions, logger);

    // 配置NioSocketChannel
    for (Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, Object&amp;gt; e: childAttrs) {
        child.attr((AttributeKey&amp;lt;Object&amp;gt;) e.getKey()).set(e.getValue());
    }

    try {
        // 这里childGroup就是一开始我们配置的workerGroup
        // 所以调用的是io.netty.channel.MultithreadEventLoopGroup#register(io.netty.channel.Channel)
        childGroup.register(child).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    forceClose(child, future.cause());
                }
            }
        });
    } catch (Throwable t) {
        forceClose(child, t);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来的注册过程和NioServerSocketChannel的注册过程是类似的，创建socket，创建SelectionKeyImpl等。只不过NioSocketChannel不监听accept事件。&lt;/p&gt;
&lt;h2 id=&quot;read&quot;&gt;read&lt;/h2&gt;
&lt;p&gt;上面在接收到来自客户端的连接请求后，将NioSocketChannel注册到selector上，这个selector也是在NioEventLoop里面的，后面和这个客户端的通信都会通过这个channel进行，如果客户端发送来数据，也是selector收到读事件通知，然后调用processSelectedKey来处理read事件。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    // channel是NioSocketChannel
    // unsafe是NioSocketChannelUnsafe
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
    // 省略中间代码...
    if ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
        // 调用NioByteUnsafe.read
        unsafe.read();
    }
} catch (CancelledKeyException ignored) {
    unsafe.close(unsafe.voidPromise());
}

public final void read() {
    final ChannelConfig config = config();
    if (shouldBreakReadReady(config)) {
        clearReadPending();
        return;
    }
    final ChannelPipeline pipeline = pipeline();
    // PooledByteBufAllocator，默认的内存申请管理器
    final ByteBufAllocator allocator = config.getAllocator();
    // AdaptiveRecvByteBufAllocator$HandleImpl
    final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();
    allocHandle.reset(config);

    ByteBuf byteBuf = null;
    boolean close = false;
    try {
        do {
            // 申请内存
            byteBuf = allocHandle.allocate(allocator);
            // 读取数据
            allocHandle.lastBytesRead(doReadBytes(byteBuf));
            if (allocHandle.lastBytesRead() &amp;lt;= 0) {
                // nothing was read. release the buffer.
                byteBuf.release();
                byteBuf = null;
                close = allocHandle.lastBytesRead() &amp;lt; 0;
                if (close) {
                    // There is nothing left to read as we received an EOF.
                    readPending = false;
                }
                break;
            }

            allocHandle.incMessagesRead(1);
            readPending = false;
            // 执行pipeline中的handler
            pipeline.fireChannelRead(byteBuf);
            byteBuf = null;
        } while (allocHandle.continueReading());
        // 省略中间代码
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说NioSocketChannel中的handler包括&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;io.netty.channel.DefaultChannelPipeline$HeadContext&lt;/li&gt;
&lt;li&gt;org.lep.test.netty.protocol.custom.codec.NettyMessageDecoder：自定义的解码器&lt;/li&gt;
&lt;li&gt;org.lep.test.netty.protocol.custom.codec.NettyMessageEncoder：自定义的编码器&lt;/li&gt;
&lt;li&gt;org.lep.test.netty.protocol.custom.server.LoginAuthRespHandler：自定义的handler&lt;/li&gt;
&lt;li&gt;org.lep.test.netty.protocol.custom.server.HeartBeatRespHandler：自定义的handler&lt;/li&gt;
&lt;li&gt;io.netty.channel.DefaultChannelPipeline$TailContext&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;netty提供了一些基本的编解码功能，自己可以根据实际需要扩展使用，然后自定义自己的逻辑处理handler。&lt;/p&gt;
&lt;p&gt;上面还涉及到内存的分配部分留在下一节介绍。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;read事件处理过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;接收到read事件&lt;/li&gt;
&lt;li&gt;分配内存，初始化buffer&lt;/li&gt;
&lt;li&gt;调用channel.read将数据读取到buffer中&lt;/li&gt;
&lt;li&gt;执行pipeline中的handler，包括了编解码的handler，自定义的handler来处理数据&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 25 Jul 2018 17:17:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/9369282.html</dc:identifier>
</item>
<item>
<title>linux一步一脚印---rm命令 - PurpleKing</title>
<link>http://www.cnblogs.com/king-of-purple/p/9369140.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/king-of-purple/p/9369140.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1 命令功能（简要说明）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    该命令用来删除Linux系统中的文件或目录。通常情况下rm不会删除目录，你必须通过指定参数-r或-R来删除目录。另外rm通常可以将该文件或目录恢复（注意，rm删除文件其实只是将指向数据块的索引点（information nodes）释放，只要不被覆盖，数据其实还在硬盘上。如果想要保证文件的内容无法复原，可以使用命令shred 。 另外一般还是要慎用rm -rf  /*这样的命令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 命令语法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    rm【选项】... 文件...     #注：【】中的内容为非必选项&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3 命令选项（只做常用命令参数讲述）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　 使用帮助命令：man rm 或 rm -help&lt;/p&gt;
&lt;p&gt;-f, --force 强制删除。忽略不存在的文件，不提示确认&lt;br/&gt;-i  在删除前需要确认&lt;br/&gt;-I(大写i)  在删除超过三个文件或者递归删除前要求确认。此选项比-i 提示内容更少，但同样可以阻止大多数错误发生&lt;br/&gt;--interactive[=WHEN] 根据指定的WHEN 进行确认提示：never，once (-I)，或者always (-i)。如果此参数不加WHEN 则总是提示&lt;br/&gt;--one-file-system 递归删除一个层级时，跳过所有不符合命令行参数的文件系统上的文件&lt;br/&gt;--no-preserve-roo 不特殊对待&quot;/&quot;&lt;br/&gt;--preserve-root 不允许删除&quot;/&quot;(默认)&lt;br/&gt;-r, -R, --recursive 递归删除目录及其内容&lt;br/&gt;-v, --verbose 详细显示进行的步骤&lt;br/&gt;--help 显示此帮助信息并退出&lt;br/&gt;--version 显示版本信息并退出&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4 使用范例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;（1）rm 目录(文件名) ------------这里注意下默认rm命令是有别名（alias rm='rm -i'），并且无法强制覆盖，即使使用-f 参数也无法强制覆盖文件，可以使用\rm 执行rm命令时不走alias。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除指定文件&lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls&lt;/span&gt;
&lt;span&gt;canglaoshi.txt
[root&lt;/span&gt;@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; rm canglaoshi.txt &lt;/span&gt;
rm：是否删除普通空文件 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;canglaoshi.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;？y
[root&lt;/span&gt;@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls&lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; touch xiaocang.txt&lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls&lt;/span&gt;
&lt;span&gt;xiaocang.txt
[root&lt;/span&gt;@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; \rm xiaocang.txt &lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls&lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　（2）rm -rf  目录(文件名)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个多级目录，不管目录是够为空，都能强制删除目录，以后目录下的子目录。&lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; mkdir -p dir1/{dir2,dir3/{dir4,dir5}} &lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls&lt;/span&gt;
&lt;span&gt;dir1
[root&lt;/span&gt;@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cd dir1&lt;/span&gt;
[root@localhost dir1]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls&lt;/span&gt;
&lt;span&gt;dir2  dir3
[root&lt;/span&gt;@localhost dir1]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cd ..&lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; rm dir1&lt;/span&gt;
rm: 无法删除&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dir1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: 是一个目录
[root&lt;/span&gt;@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; rm -rf dir1&lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls&lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　（3）rm -v 某类文件，并详细显示命令执行过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;新建立两类文件，并只删除txt结尾的这一类文件&lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; touch canglaoshi.txt xiaocang.txt av.log&lt;/span&gt;
[root@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls&lt;/span&gt;
&lt;span&gt;av.log  canglaoshi.txt  xiaocang.txt
[root&lt;/span&gt;@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; rm -v *.txt&lt;/span&gt;
rm：是否删除普通空文件 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;canglaoshi.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;？y
已删除&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;canglaoshi.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
rm：是否删除普通空文件 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaocang.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;？y
已删除&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xiaocang.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
[root&lt;/span&gt;@localhost command_test]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls&lt;/span&gt;
&lt;span&gt;av.log
[root&lt;/span&gt;@localhost command_test]&lt;span&gt;#&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 25 Jul 2018 16:16:00 +0000</pubDate>
<dc:creator>PurpleKing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/king-of-purple/p/9369140.html</dc:identifier>
</item>
<item>
<title>centos7通过yum安装nginx - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/9369134.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/9369134.html</guid>
<description>&lt;h3&gt;centos7通过yum安装nginx&lt;/h3&gt;
&lt;p&gt;nginx不支持centos7通过yum直接安装~~~&lt;/p&gt;
&lt;p&gt;1、查看操作系统位数&lt;br/&gt;[root@-jenkins ~]# rpm -aq|grep centos-release&lt;br/&gt;centos-release-7-4.1708.el7.centos.&lt;span&gt;x86_64&lt;/span&gt;/&lt;/p&gt;
&lt;p&gt;2、创建nginx的yum源&lt;br/&gt;[root@-jenkins ~]# cat  /etc/yum.repos.d/nginx.repo&lt;br/&gt;[nginx]&lt;br/&gt;name=nginx repo&lt;br/&gt;baseurl=http://nginx.org/packages/centos/7/&lt;span&gt;x86_64&lt;/span&gt;/&lt;br/&gt;gpgcheck=0&lt;br/&gt;enabled=1&lt;/p&gt;&lt;p&gt;注意：上面的&lt;span&gt;x86_64&lt;/span&gt;改为你自己的操作系统位数。&lt;br/&gt;3、yum命令安装&lt;br/&gt;[root@-jenkins ~]# yum install -y nginx&lt;br/&gt;4、启动服务&lt;br/&gt;[root@-jenkins ~]# service nginx start&lt;br/&gt;或者&lt;br/&gt;[root@-jenkins ~]# systemctl start nginx&lt;br/&gt;Redirecting to /bin/systemctl start nginx.service&lt;br/&gt;You have new mail in /var/spool/mail/root&lt;br/&gt;5、查看端口默认为80&lt;br/&gt;[root@-jenkins ~]# ss -lntp|grep 80&lt;br/&gt;LISTEN     0      128          *:80                       *:*                   users:((&quot;nginx&quot;,pid=23806,fd=6),(&quot;nginx&quot;,pid=23805,fd=6))&lt;/p&gt;
&lt;p&gt;6、发布路径&lt;/p&gt;
&lt;p&gt;[root@-jenkins ~]#/usr/share/nginx/html/&lt;/p&gt;
&lt;p&gt;访问: http://IP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1271786/201807/1271786-20180726000856739-1292012491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 25 Jul 2018 16:12:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dev0ps/p/9369134.html</dc:identifier>
</item>
<item>
<title>this引用逃逸 - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/9369096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/9369096.html</guid>
<description>
&lt;h2&gt;1、什么是This逃逸？&lt;/h2&gt;
&lt;p&gt;　　在构造器构造还未彻底完成前（即实例初始化阶段还未完成），将自身this引用向外抛出并被其他线程复制（访问）了该引用，可能会问到该还未被初始化的变量，甚至可能会造成更大严重的问题。&lt;/p&gt;
&lt;p&gt;　　废话不多说，看一下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 模拟this逃逸
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Lijian
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThisEscape {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;final常量会保证在构造器内完成初始化（但是仅限于未发生this逃逸的情况下，具体可以看多线程对final保证可见性的实现）&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;尽管实例变量有初始值，但是还实例化完成&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; j = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ThisEscape obj;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ThisEscape() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         i=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         j=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将this逃逸抛出给线程B&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThisEscape();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程A：模拟构造器中this逃逸,将未构造完全对象引用抛出&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;Thread threadA = new Thread(new Runnable() {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            public void run() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                //obj = new ThisEscape();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        });&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程B：读取对象引用，访问i/j变量&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         Thread threadB = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可能会发生初始化失败的情况解释：实例变量i的初始化被重排序到构造器外，此时1还未被初始化&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                 ThisEscape objB =&lt;span&gt; obj;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                    System.out.println(objB.j);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NullPointerException e) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     System.out.println(&quot;发生空指针错误：普通变量j未被初始化&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                    System.out.println(objB.i);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NullPointerException e) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     System.out.println(&quot;发生空指针错误：final变量i未被初始化&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;threadA.start();&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            threadB.start();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：这说明ThisEscape还未完成实例化，构造还未彻底结束。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;发生空指针错误：普通变量j未被初始化
发生空指针错误：final变量i未被初始化&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种情况是利用线程A模拟this逃逸，但不一定会发生，线程A模拟构造器正在构造...而线程B尝试访问变量，这是因为&lt;/p&gt;
&lt;p&gt;（1）由于JVM的指令重排序存在，实例变量i的初始化被安排到构造器外（final可见性保证是final变量规定在构造器中完成的）；&lt;/p&gt;
&lt;p&gt;（2）类似于this逃逸，线程A中构造器构造还未完全完成。&lt;/p&gt;
&lt;p&gt;所以尝试多次输出（相信我一定会发生的，只是概率相对低），也会发生类似this引用逃逸的情况。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 模拟this逃逸
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Lijian
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThisEscape {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;final常量会保证在构造器内完成初始化（但是仅限于未发送this逃逸的情况下）&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;尽管实例变量有初始值，但是还实例化完成&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; j = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ThisEscape obj;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ThisEscape() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         i=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         j=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;obj = new ThisEscape();&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程A：模拟构造器中this逃逸,将未构造完全对象引用抛出&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Thread threadA = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造初始化中...线程B可能获取到还未被初始化完成的变量
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;类似于this逃逸，但并不定发生&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThisEscape();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程B：读取对象引用，访问i/j变量&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         Thread threadB = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可能会发生初始化失败的情况解释：实例变量i的初始化被重排序到构造器外，此时1还未被初始化&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                 ThisEscape objB =&lt;span&gt; obj;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                    System.out.println(objB.j);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NullPointerException e) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     System.out.println(&quot;发生空指针错误：普通变量j未被初始化&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                    System.out.println(objB.i);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NullPointerException e) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     System.out.println(&quot;发生空指针错误：final变量i未被初始化&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            threadA.start();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            threadB.start();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、什么情况下会This逃逸？&lt;/h2&gt;
&lt;p&gt;（1）&lt;strong&gt;在构造器中很明显地抛出this引用提供其他线程使用（如上述的明显将this抛出）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（2）&lt;strong&gt;在构造器中内部类使用外部类情况：内部类访问外部类是没有任何条件的，也不要任何代价，也就造成了当外部类还未初始化完成的时候，内部类就尝试获取为初始化完成的变量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在构造器中启动线程：启动的线程任务是内部类，在内部类中xxx.this访问了外部类实例，就会发生访问到还未初始化完成的变量&lt;/li&gt;
&lt;li&gt;在构造器中注册事件，这是因为在构造器中监听事件是有回调函数（可能访问了操作了实例变量），而事件监听一般都是异步的。在还未初始化完成之前就可能发生回调访问了未初始化的变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在构造器中启动线程代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 模拟this逃逸2：构造器中启动线程
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Lijian
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThisEscape2 {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ThisEscape2() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         i = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         j = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RunablTest()).start();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部类实现Runnable：引用外部类&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RunablTest &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 System.out.println(ThisEscape2.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.j);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NullPointerException e) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 System.out.println(&quot;发生空指针错误：普通变量j未被初始化&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 System.out.println(ThisEscape2.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.i);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NullPointerException e) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 System.out.println(&quot;发生空指针错误：final变量i未被初始化&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThisEscape2();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;构造器中注册事件，引用网上的一段伪代码将以解释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThisEscape3 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; var;
 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ThisEscape3(EventSource source) {&lt;br/&gt;　　　　 &lt;span&gt;//注册事件，会一直监听，当发生事件e时，会执行回调函数doSomething&lt;/span&gt;
        source.registerListener(&lt;br/&gt;　　　　　　　&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//匿名内部类实现&lt;/span&gt;&lt;/span&gt;
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventListener() {
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onEvent(Event e) {&lt;br/&gt;　　　　　　　　　　　 &lt;span&gt;&lt;span&gt;//此时ThisEscape3可能还未初始化完成，var可能还未被赋值，自然就发生严重错误&lt;/span&gt;&lt;/span&gt;
                    doSomething(e);
                }
            }
        );&lt;/span&gt;&lt;span&gt;
        var &lt;/span&gt;= 10&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;// 在回调函数中访问变量&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; doSomething(Event e) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; var;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3、怎样避免This逃逸？&lt;/h2&gt;
&lt;p&gt;　　（1）单独编写一个启动线程的方法，不要在构造器中启动线程，尝试在外部启动。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Thread t;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ThisEscape2() {
    t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; EscapeRunnable());
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initStart() {
    t.start();
}
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）将事件监听放置于构造器外，比如new Object()的时候就启动事件监听，但是在构造器内不能使用事件监听，那可以在static{}中加事件监听，这样就跟构造器解耦了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
    source.registerListener(
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventListener() {
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onEvent(Event e) {
                    doSomething(e);
                }
            }
        );
        var &lt;/span&gt;= 10&lt;span&gt;;
    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4、总结&lt;/h2&gt;
&lt;p&gt;　　this引用逃逸问题实则是Java多线程编程中需要注意的问题，引起逃逸的原因无非就是在多线程的编程中“滥用”引用（往往涉及构造器中显式或隐式地滥用this引用），在使用到this引用的时候需要特别注意！&lt;/p&gt;
</description>
<pubDate>Wed, 25 Jul 2018 16:01:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/9369096.html</dc:identifier>
</item>
<item>
<title>Java并发编程原理与实战九：synchronized的原理与使用 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/9369071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/9369071.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、理论层面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内置锁与互斥锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修饰普通方法、修饰静态方法、修饰代码块&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.roocon.thread.t3;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sequence {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; synchronized放在普通方法上，内置锁就是当前方法的实例&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getNext(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; synchronized修饰静态方法，内置锁就是当前的Class字节码对象Sequence.class&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPrevious(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; value--&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; xx(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; synchronized修饰静态代码块，则锁的是任意一个对象&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        synchronized (this){ }
        synchronized (Integer.valueOf(value)) { }
        synchronized (Sequence.class) { }
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;synchronized&lt;/span&gt; (Sequence.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Sequence sequence &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sequence();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
               &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
                   System.out.println(Thread.currentThread().getName()&lt;/span&gt;+&quot; &quot;+&lt;span&gt;sequence.getNext());
                   &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                       Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
                   } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                       e.printStackTrace();
                   }
               }
            }
        }).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
                    System.out.println(Thread.currentThread().getName()&lt;/span&gt;+&quot; &quot;+&lt;span&gt;sequence.getNext());
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
                    System.out.println(Thread.currentThread().getName()&lt;/span&gt;+&quot; &quot;+&lt;span&gt;sequence.getNext());
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、JVM层面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201807/401339-20180725234650872-874092032.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看xx方法同步代码块字节码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201807/401339-20180725234714281-44943035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看同步方法字节码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/401339/201807/401339-20180725234736519-1689891005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;任何对象都可以作为锁，那么锁信息又存在对象的什么地方呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存在对象头中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象头中的信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Mark Word&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Class Metadata Address 类的类型地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Array Length&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.偏向锁：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每次获得锁和释放锁会浪费资源（消耗时间），很多情况下，竞争锁不是由多个线程，而是由一个线程在使用。线程在获取锁时，会依据对象头Mark word信息进行判断执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象头Mark word中会保存如下信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　线程id&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Epoch&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对象的分代年龄信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　是否是偏向锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　锁标志位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;偏向锁在获取锁之后，如果没有竞争，也就是一直是这个线程在获取锁，那么当这个线程第二次再来进入该方法时，不需要再去获取锁了，也不需要释放锁，这样，就节省了大量的获取锁释放锁的资源。那么，什么时候会释放锁呢？只有当存在竞争时，才会去释放锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;偏向锁适用于什么场景？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只有一个线程在访问同步代码块的场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.轻量级锁：可以同时让多个线程进入同步代码块。自旋锁就是轻量级锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;轻量级锁是如何加锁的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在线程执行同步代码块之前，jvm会先在当前线程的栈帧中创建用于存储锁记录的存储空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（栈帧是什么？虚拟机栈中存储的是一个一个的栈帧，栈帧中存储了方法的执行信息，每个方法都会伴随着栈帧的进栈和出栈）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后呢，并将对象头中的mark word复制到锁记录中。然后呢，开始竞争锁就可以了。竞争成功之后，markword就改变了，会将锁标志位改成轻量级锁。接着，开始执行同步体。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外一个线程也想获得该锁。同样，它也将对象头中的mark word复制到锁记录中，它发现已经被其他线程获得了锁，所以它修改不成功。于是，它就不停的去修改，不停的失败，直到第一个线程把这个锁释放了，它就可以修改成功了。刚才这一个过程，就是所谓的自旋锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.重量级锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是重量级锁？就是，这个线程获得锁进入之后，其他线程必须在外面等待。synchronized就是重量级锁。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面只是对synchronized 如何实现同步功能的一个视频学习总结，更加细节的深入原理可以参考下面两篇文章：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zaizhoumo/p/7700161.html&quot;&gt;synchronized的实现原理&lt;/a&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/javazejian/article/details/72828483&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;深入理解Java并发之synchronized实现原理&lt;/strong&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;《java并发编程与实战》龙果学院&lt;/p&gt;
</description>
<pubDate>Wed, 25 Jul 2018 15:53:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/9369071.html</dc:identifier>
</item>
<item>
<title>『度量学习』知识梳理 - xinet</title>
<link>http://www.cnblogs.com/q735613050/p/9369023.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/q735613050/p/9369023.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1114626-09bf1ca3e3a0a2c7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1080/q/50&quot; alt=&quot;图片发自简书App&quot;/&gt;&lt;/p&gt;
&lt;p&gt;graph RL subgraph 0 a1[度量学习] --&amp;gt; |也称为马氏度量学习问题|b1[线性变换] a1[度量学习] --&amp;gt; b2[非线性变换] end subgraph 1 b1 --&amp;gt; c1[监督学习] c1 --&amp;gt; |该类型的算法充分利用数据的标签信息|d1[全局] c1 --&amp;gt; |该类型的算法同时考虑数据的标签信息和数据点之间的几何关系|d2[局部] end subgraph 2 b1 --&amp;gt; c2[非监督学习] end subgraph 3 d1 --&amp;gt; f1[ITML] d1 --&amp;gt; f2[MMC] d1 --&amp;gt; f3[MCML] end subgraph 4 d2 --&amp;gt; g1[NCA] d2 --&amp;gt; g2[LMNN] d2 --&amp;gt; g3[RCA] d2 --&amp;gt; g4[Local LDA] end subgraph 5 c2 --&amp;gt; e1[PCA] c2 --&amp;gt; e2[MDS] c2 --&amp;gt; e3[NMF] c2 --&amp;gt; e4[ICA] c2 --&amp;gt; e5[NPE] c2 --&amp;gt; e6[LPP] end subgraph 6 b2 --&amp;gt; b3[非线性降维] b2 --&amp;gt; b4[核方法] end subgraph 7 b3 --&amp;gt; h1[ISOMAP] b3 --&amp;gt; h2[LLE] b3 --&amp;gt; h3[LE] end subgraph 8 b4 --&amp;gt; t1[Non-Mahalanobis Local Distance Functions] b4 --&amp;gt; t2[Mahalanobis Local Distance Functions] b4 --&amp;gt; t3[Metric Learning with Neural Networks] end&lt;/p&gt;
&lt;h2 id=&quot;几篇经典论文&quot;&gt;几篇经典论文&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Distance metric learning with application to clustering with side-information&lt;/li&gt;
&lt;li&gt;Information-theoretic metric learning(关于ITML)&lt;/li&gt;
&lt;li&gt;Distance metric learning for large margin nearest neighbor classification(关于LMNN)&lt;/li&gt;
&lt;li&gt;Learning the parts of objects by non-negative matrix factorization（Nature关于RCA的文章）&lt;/li&gt;
&lt;li&gt;Neighbourhood components analysis(关于NCA)&lt;/li&gt;
&lt;li&gt;Metric Learning by Collapsing Classes(关于MCML)&lt;/li&gt;
&lt;li&gt;Distance metric learning a comprehensive survey(一篇经典的综述)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Python 封装了一些度量方法&lt;/strong&gt;：&lt;a href=&quot;https://pypi.python.org/pypi/metric-learn/&quot;&gt;metric-learn&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Jul 2018 15:38:00 +0000</pubDate>
<dc:creator>xinet</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/q735613050/p/9369023.html</dc:identifier>
</item>
<item>
<title>JXl常用解析详解 - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9368700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9368700.html</guid>
<description>&lt;h2&gt;目的：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;java解析 excel 无非就是apache poi 或者 jxl 两者在使用上其实都差不多，关键还是看你自己熟悉那个，用那个！我也是初次接触jxl 看很多博客说 jxl只适用于处理小数据量 excel，或者说是功能比较单一的，实际上我看了jxl的包，发现其实用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，功能还是很强大的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要了解：支持 Reads data from Excel 95, 97, 2000, &lt;span&gt;XP, and 2003&lt;/span&gt; workbooks&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;title-article&quot;&gt;&lt;span&gt;jxl.read.biff.BiffException: Unable to recognize OLE stream  出现这个错误就是excel 2007格式不符合引起的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;官网：http://jexcelapi.sourceforge.net/&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;java doc： http://jxl.sourceforge.net/javadoc/index.html&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span&gt;依赖管理：&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;net.sourceforge.jexcelapi&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jxl&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.6.12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;UML大纲：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725212957777-1356266150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;创建简单的excel：&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testCreateExcel() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建xls文件&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            file.createNewFile();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2:创建工作簿&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             WritableWorkbook workbook =&lt;span&gt; Workbook.createWorkbook(file);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3:创建sheet,设置第二三四..个sheet，依次类推即可&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             WritableSheet sheet = workbook.createSheet(&quot;测试&quot;, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4：设置titles&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             String[] titles = { &quot;编号&quot;, &quot;账号&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5:给第一行设置列名&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; titles.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 sheet.addCell(&lt;span&gt;new&lt;/span&gt; Label(i, 0&lt;span&gt;, titles[i]));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             sheet.setHeader(&quot;aa&quot;, &quot;cc&quot;, &quot;cc&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6：模拟数据库导入数据 注意起始行为1&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 1; i &amp;lt; 100; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加编号&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 sheet.addCell(&lt;span&gt;new&lt;/span&gt; Label(0, i, &lt;span&gt;new&lt;/span&gt; String(&quot;编号&quot;+&lt;span&gt;i)));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加密码&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 sheet.addCell(&lt;span&gt;new&lt;/span&gt; Label(1, i, &lt;span&gt;new&lt;/span&gt; String(&quot;编号&quot;+&lt;span&gt;i)));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            workbook.write();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            workbook.close();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RowsExceededException e) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (WriteException e) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 效果：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725214909558-409499633.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h2&gt;简单读取Excel：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testCreateExcel() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1:创建workbook&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             Workbook workbook =&lt;span&gt; Workbook.getWorkbook(file);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2:获取第一个工作表sheet&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             Sheet sheet = workbook.getSheet(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3:读取数据&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            System.out.println(sheet.getColumns());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            System.out.println(sheet.getRows());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.自己注意行列关系&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; sheet.getRows(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; sheet.getColumns(); j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     Cell cell =&lt;span&gt; sheet.getCell(j, i);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    System.out.println(cell.getContents());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt; (BiffException |&lt;span&gt; IOException e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1160484/201807/1160484-20180725220429111-1280536109.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 25 Jul 2018 14:22:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9368700.html</dc:identifier>
</item>
<item>
<title>基于webpack4搭建一个react脚手架 - Dante丶</title>
<link>http://www.cnblogs.com/DDante/p/9368694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DDante/p/9368694.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;React 16.0 boilerplate with react-router-dom, redux &amp;amp; webpack 4. (for javascript)&lt;br/&gt;&lt;a href=&quot;https://github.com/Dante-dan/react-sample-javascript&quot;&gt;github项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;项目初始化&quot;&gt;项目初始化&lt;/h2&gt;
&lt;h3 id=&quot;统一规范代码格式&quot;&gt;统一规范代码格式&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;配置 &lt;code&gt;.editorconfig&lt;/code&gt; 使得IDE的方式统一 (见代码)&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置 &lt;code&gt;.eslintrc.js&lt;/code&gt; 使得代码规范统一 (见代码)&lt;/p&gt;
&lt;h3 id=&quot;预期功能&quot;&gt;预期功能&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;管理资源： 能加载css、sccc、less、以及静态文件&lt;/li&gt;
&lt;li&gt;管理输出：将打包后的静态文件输出至static目录下，以各自的文件类型管理&lt;/li&gt;
&lt;li&gt;dev：使用source map，方便调试时代码定位&lt;/li&gt;
&lt;li&gt;dev：配置devServer，并配置热替换，热加载，自动刷新，自动打开浏览器，并预留proxyTable&lt;/li&gt;
&lt;li&gt;dev：设置默认打开8080，被占用则寻找下一个空接口&lt;/li&gt;
&lt;li&gt;production：代码分离，打包css文件，css代码压缩，js代码压缩，输出到模板html，配置gzip&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;analysis:：使用BundleAnalyzerPlugin 分析打包后的性能&lt;/p&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;目录结构&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;首先使用npm init 初始化一个包含package.json的根目录&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;:.
│  .babelrc             #babel的规则以及插件
│  .editorconfig        #IDE/编辑器相关的配置
│  .eslintignore        #Eslint忽视的目录
│  .eslintrc.js         #Eslint的规则和插件
│  .gitignore           #Git忽视的目录
│  .postcssrc.js        #postcss的插件
│  package-lock.json
│  package.json         #项目相关的包
│  README.md
│  yarn.lock
│
├─build                 #webpack相关的配置
│      utils.js         #webpack配置中的通用方法
│      webpack.base.conf.js #webpack的基础配置
│      webpack.dev.conf.js  #webpack的开发环境配置
│      webpack.prod.conf.js #webpack的生产环境配置
│
└─src                   #主目录，业务代码
    │  app.css
    │  App.js
    │  favicon.ico
    │  index.ejs
    │  index.js
    │
    └─assets            #静态目录，存放静态资源
        │  config.json
        │
        └─img
                logo.svg&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装依赖&quot;&gt;安装依赖&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;eslint-loader&lt;/li&gt;
&lt;li&gt;eslint&lt;/li&gt;
&lt;li&gt;eslint-config-airbnb&lt;/li&gt;
&lt;li&gt;eslint-plugin-import&lt;/li&gt;
&lt;li&gt;eslint-friendly-formatter&lt;/li&gt;
&lt;li&gt;eslint-plugin-flowtype&lt;/li&gt;
&lt;li&gt;eslint-plugin-jsx-a11y&lt;/li&gt;
&lt;li&gt;eslint-plugin-react&lt;/li&gt;
&lt;li&gt;babel-polyfill&lt;/li&gt;
&lt;li&gt;webpack&lt;/li&gt;
&lt;li&gt;jest&lt;/li&gt;
&lt;li&gt;friendly-errors-webpack-plugin &lt;code&gt;编译提示的webpack插件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;html-webpack-plugin &lt;code&gt;新建html入口文件的webpack插件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;copy-webpack-plugin &lt;code&gt;webpack配置合并模块&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;webpack-merge &lt;code&gt;webpack配置合并模块&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;webpack-dev-server&lt;/li&gt;
&lt;li&gt;webpack-bundle-analyzer&lt;/li&gt;
&lt;li&gt;webpack-cli&lt;/li&gt;
&lt;li&gt;portfinder 寻找接口的插件&lt;/li&gt;
&lt;li&gt;extract-text-webpack-plugin&lt;/li&gt;
&lt;li&gt;node-notifier&lt;/li&gt;
&lt;li&gt;optimize-css-assets-webpack-plugin&lt;/li&gt;
&lt;li&gt;autoprefixer&lt;/li&gt;
&lt;li&gt;mini-css-extract-plugin&lt;/li&gt;
&lt;li&gt;autoprefixer&lt;/li&gt;
&lt;li&gt;css-loader&lt;/li&gt;
&lt;li&gt;less-loader&lt;/li&gt;
&lt;li&gt;postcss-loader&lt;/li&gt;
&lt;li&gt;postcss-import&lt;/li&gt;
&lt;li&gt;postcss-loader&lt;/li&gt;
&lt;li&gt;style-loader&lt;/li&gt;
&lt;li&gt;babel-core&lt;/li&gt;
&lt;li&gt;babel-eslint&lt;/li&gt;
&lt;li&gt;babel-loader&lt;/li&gt;
&lt;li&gt;babel-plugin-transform-runtime&lt;/li&gt;
&lt;li&gt;babel-plugin-import&lt;/li&gt;
&lt;li&gt;babel-preset-env&lt;/li&gt;
&lt;li&gt;babel-preset-react&lt;/li&gt;
&lt;li&gt;babel-polyfill&lt;/li&gt;
&lt;li&gt;url-loader&lt;/li&gt;
&lt;li&gt;cross-env&lt;/li&gt;
&lt;li&gt;file-loader&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;yarn add eslint eslint-loader eslint-config-airbnb eslint-plugin-import eslint-friendly-formatter eslint-plugin-flowtype eslint-plugin-jsx-a11y eslint-plugin-react babel-polyfill webpack jest webpack-merge copy-webpack-plugin html-webpack-plugin friendly-errors-webpack-plugin webpack-dev-server webpack-bundle-analyzer webpack-cli portfinder extract-text-webpack-plugin node-notifier optimize-css-assets-webpack-plugin autoprefixer mini-css-extract-plugin autoprefixer css-loader less-loader postcss-loader postcss-import postcss-loader style-loader babel-core babel-eslint babel-loader babel-plugin-transform-runtime babel-plugin-import babel-preset-env babel-preset-react babel-polyfill url-loader cross-env file-loader -D
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;项目配置&quot;&gt;项目配置&lt;/h2&gt;
&lt;h3 id=&quot;webpack-基础配置&quot;&gt;webpack 基础配置&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;为了控制开发环境和生产环境，我们可以新建build文件夹。分别书写开发环境和生产环境的webpack配置文件，这样也更可以方便我们分别控制生产环境和开发环境。&lt;/li&gt;
&lt;li&gt;为了提高代码的复用率，也为了区别 &lt;code&gt;基础配置&lt;/code&gt; 和 &lt;code&gt;个性配置&lt;/code&gt; ，可以分别新建&lt;code&gt;webpack.base&lt;/code&gt;、&lt;code&gt;webpack.dev&lt;/code&gt; 和 &lt;code&gt;webpack.prod&lt;/code&gt;三个配置文件。首先配置最基础的entry(入口)和output(出口)。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;module.exports = {
  context: path.resolve(__dirname, '../'),  //绝对路径。__dirname为当前目录。
    //基础目录用于从配置中解析入口起点。因为webpack配置在build下，所以传入 '../'
  entry: {
    app: ('./src/index.js') //项目的入口
  },
  output: {
    path: path.resolve(__dirname, '../dist'),
    filename: '[name].[hash:8].js',
    publicPath: '/',
    libraryTarget: 'umd',
  },
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;entry&quot;&gt;entry&lt;/h4&gt;
&lt;p&gt;entry可以分别为字符串、数组和对象。&lt;/p&gt;
&lt;p&gt;倘若应用只有一个单一的入口，entry的值可以使用任意类型，不会影响输出结果。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// entry为字符串
{
    entry: './src/index.js',
    output: {
        path: '/dist',
        filename: 'bundle.js'
    }
}
// 结果会生成 '/dist/bundle.js'&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// entry为数组，可以添加多个彼此不互相依赖的文件。结合output.library选项，如果传入数组，则只导出最后一项。
{
    //如果你在html文件里引入了'bable-polyfill',可以通过数组将它加到bundle.js的最后。
    entry: ['./src/index.js', 'babel-polyfill'] ,
    output:{
        path: '/dist',
        filename: 'bundle.js'
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// entry为对象，可以将页面配置为多页面的而不是SPA，有多个html文件。通过对象告诉webpack为每个入口，成一个bundle文件。
// 多页面的配置，可能还要借助于HtmlWebpackPlugin，来指定每个html需要引入的js
{
    entry: {
        index: './src/index.js'
        main: './src/index.js'
        login: './src/login.js'
    }
    output:{
        path: '/dist/pages'
        filename: '[name]-[hash:5].js' //文件名取自'entry'对象的键名，为了防止推送代码后浏览器读缓存，故再生成的文件之后加上hash码。
    }
}
// 会分别生成index.js,main.js,login.js三个文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于 &lt;a href=&quot;https://segmentfault.com/a/1190000004511992&quot;&gt;webpack构建多页面&lt;/a&gt; 可以参考这篇文章。不过现在webpack4.x也是一次断崖式升级，感兴趣的同学可以自行搜索。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// entry也可以传入混合类型
{
    entry:{
        vendor: ['jquery','amap','babel-polyfill'] //也可以借助CommonsChunkPlugin提取vendor的chunk。
        index: './src/index.js'
    }
    output: {
        path: '/dist'
        filename: '[name]-[hash:5].js'
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.7913669064748&quot;&gt;
&lt;p&gt;CommonsChunkPlugin在webpack4.0之后移除了，可以使用splitChunksPlugin代替。&lt;/p&gt;
&lt;p&gt;可以参阅如下链接：&lt;a href=&quot;https://www.webpackjs.com/plugins/split-chunks-plugin/&quot;&gt;optimization.splitChunks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h4 id=&quot;output&quot;&gt;output&lt;/h4&gt;
&lt;p&gt;output最基础的两个配置为 &lt;code&gt;path&lt;/code&gt; 和 &lt;code&gt;filename&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;path&lt;/code&gt; 告诉 webpack的输出目录在那里，一般我们会设置在根目录的 &lt;code&gt;dist&lt;/code&gt; 文件夹；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filename&lt;/code&gt; 用于指定输出文件的文件名，如果配置了创建了多个单独的 &lt;code&gt;chunk&lt;/code&gt; 则可以使用&lt;code&gt;[name].[hash]&lt;/code&gt; 这种占位符来确保每个文件有唯一的名称；&lt;/li&gt;
&lt;li&gt;另一个常见配置 &lt;code&gt;publicPath&lt;/code&gt; 则是用于更加复杂的场景。举例：在本地时，你可能会使用 &lt;code&gt;../assets/test.png&lt;/code&gt; 这种url来载入图片。而在生产环境下，你可能会使用CDN或者图床的地址。那么就需要配置 &lt;code&gt;publicPath = &quot;http://cdn.example.com/assets/&quot;&lt;/code&gt; 来实现生产模式下编译输出文件时自动更新url。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; output: {
    path: path.resolve(__dirname, '../dist'),
    filename: '[name].[hash:8].js',
    publicPath: '/',
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;resolve&quot;&gt;resolve&lt;/h4&gt;
&lt;p&gt;resolve常用的两个配置为 &lt;code&gt;alias&lt;/code&gt; 和 &lt;code&gt;extensions&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;alias&lt;/code&gt; 创建import或者require的别名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extensins&lt;/code&gt; 自动解析文件拓展名，补全文件后缀&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;resolve: {
    // 自动解析文件扩展名(补全文件后缀)(从左-&amp;gt;右)
    // import hello from './hello'  （!hello.js? -&amp;gt; !hello.jsx? -&amp;gt; !hello.json）
    extensions: ['.js', '.jsx', '.json'],
    alias: {
      '@': resolve('src')
    }
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;module&quot;&gt;module&lt;/h4&gt;
&lt;p&gt;module的选项决定了如何处理项目中的不同类型的模块。其中常用的有 &lt;code&gt;rules&lt;/code&gt; 和 &lt;code&gt;noParese&lt;/code&gt; 两个配置项。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;noParese&lt;/code&gt; 是为了防止weback解析与所有与rule相匹配的文件。目的是，忽略大型的library可以提高构建性能。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;noParse: function(content) {
  return /jquery|lodash/.test(content);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;rules&lt;/code&gt; 用于在创建模块是，匹配规则数组，以确定哪些规则能够对module应用loader，或者是修改parser。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;module: {
    rules: [
    {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        enforce: 'pre',
        use: [{
          loader: 'babel-loader',
        }, {
          loader: 'eslint-loader', // 指定启用eslint-loader
          options: {
            formatter: require('eslint-friendly-formatter'),
            emitWarning: false
          }
        }]
      },
    {
        test: /\.css$/,
        include: /node_modules/,
        use: [
          MiniCssExtractPlugin.loader,
          'css-loader',
          {
            loader: 'postcss-loader',
            options: {
              plugins: () =&amp;gt; [autoprefixer({ browsers: 'last 5 versions' })],
              sourceMap: false,
            },
          },
        ],
      },
      {
        test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: ('assets/img/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: ('assets/media/[name].[hash:7].[ext]')
        }
      },
      {
        test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
        loader: 'url-loader',
        options: {
          limit: 10000,
          name: ('assets/fonts/[name].[hash:7].[ext]')
        }
      }
    ]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如上述代码，就使用&lt;code&gt;eslint-lodaer&lt;/code&gt; 和 &lt;code&gt;babel-loader&lt;/code&gt; 处理了除了&lt;code&gt;node_modules&lt;/code&gt; 以外的 &lt;code&gt;js||jsx&lt;/code&gt;。同时配置了，解析图片、视频、字体文件等的解析，当rules匹配到的文件时，小于10000 byte 时，采用url-loader解析文件。&lt;strong&gt;（因为base64会让图片的体积变大，所以当文件较大时，使用base64并不明智）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;webpack开发配置&quot;&gt;Webpack开发配置&lt;/h3&gt;
&lt;p&gt;因为在webpack 4.X 中使用了流行的 ”约定大于配置“ 的做法，所以在新加入配置项 &lt;code&gt;mode&lt;/code&gt; ，可以告知webpack使用相应模式的内置优化。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;development&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;会将&lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 的值设为 &lt;code&gt;development&lt;/code&gt; 。启用&lt;code&gt;NamedChunksPlugin&lt;/code&gt; 和 &lt;code&gt;NamedMoudulesPlugin&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;production&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;会将&lt;code&gt;process.env.NODE_ENV&lt;/code&gt; 的值设为 &lt;code&gt;production&lt;/code&gt; 。启用&lt;code&gt;FlagDependencyUsagePlugin&lt;/code&gt;，&lt;code&gt;FlagIncludedChunksPlugin&lt;/code&gt;，&lt;code&gt;ModuleConcatenationPlugin&lt;/code&gt;，&lt;code&gt;NoEmitOnErrorsPlugin&lt;/code&gt;，&lt;code&gt;OccurrenceOrderPlugin&lt;/code&gt;，&lt;code&gt;SideEffectsFlagPlugin&lt;/code&gt; 和&lt;code&gt;UglifyJsPlugin&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果我们只设置NODE_ENV，则不会自动设置 &lt;code&gt;mode&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在开发时，我们往往希望能看到当前开发的页面，并且能热加载。这时，我们可以借助webpack-dev-server 这个插件，来在项目中起一个应用服务器。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;// package.json
&quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack-dev-server --mode development --config build/webpack.dev.conf.js&quot;,
}
// 设置当前的mode为development，同样这个配置也可以写在webpack.dev.conf.js中。然后使用build目录下的webpack.dev.conf.js 来配置相关的webpack。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;devServer: {
    clientLogLevel: 'warning',
    historyApiFallback: true, //在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html
    contentBase: path.resolve(__dirname, '../src'),
    compress: true,
    hot: true, // 热加载
    inline: true, //自动刷新
    open: true, //自动打开浏览器
    host: HOST||'localhost',
    port: PORT,
    overlay: { warnings: false, errors: true }, // 在浏览器上全屏显示编译的errors或warnings。
    publicPath: '/',
    proxy: {},
    quiet: true, // necessary for FriendlyErrorsPlugin // 终端输出的只有初始启动信息。 webpack 的警告和错误是不输出到终端的
    watchOptions: {
      poll: false
    }
  },
  plugins: [
    new webpack.DefinePlugin({
      ...process.env
    }),
    //开启HMR(热替换功能,替换更新部分,不重载页面！)
    new webpack.HotModuleReplacementPlugin(),// HMR shows correct file names in console on update.
    //显示模块相对路径
    new webpack.NamedModulesPlugin(),
    //不显示错误信息
    new webpack.NoEmitOnErrorsPlugin(),
    // https://github.com/ampedandwired/html-webpack-plugin
    ]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实在开发时，我们可以设置 &lt;code&gt;contentBase: '/src'&lt;/code&gt; ，&lt;code&gt;contentBase&lt;/code&gt; 指定了devServer能访问的资源地址。因为我们开发时，资源大部分都放在&lt;code&gt;src&lt;/code&gt;目录下，所以可以直接指定资源路径为&lt;code&gt;src&lt;/code&gt;目录。因为我们在webpack基础配置时，配置了 &lt;code&gt;output&lt;/code&gt; 输出为 &lt;code&gt;dist&lt;/code&gt; 目录，所以我们也可以在devServer里，设置 &lt;code&gt;contentBase&lt;/code&gt; 为 &lt;code&gt;dist&lt;/code&gt; 目录。不过此时需要使用copyWebpackPlugin将一些静态资源复制到 &lt;code&gt;dist&lt;/code&gt; 目录下，手动新建dist目录，并复制也可以。&lt;/p&gt;
&lt;p&gt;另外，当使用 history 路由时，要配置 &lt;code&gt;historyApiFallback = true&lt;/code&gt; ，以此让服务器放弃路由权限，交由前端路由。而是用 hash 路由则不需要此配置。&lt;/p&gt;
&lt;h2 id=&quot;项目进阶&quot;&gt;项目进阶&lt;/h2&gt;
&lt;h3 id=&quot;生产环境配置&quot;&gt;生产环境配置&lt;/h3&gt;
&lt;p&gt;在使用webpack 4.x 的 mode 配置之后，需要我们手动配置的项已经减少了很多，像js代码压缩这种工具 &lt;code&gt;UglifyJsPlugin&lt;/code&gt; 就已经不用手动去配置。但是像很多前面提到的 &lt;code&gt;代码分离&lt;/code&gt; 、&lt;code&gt;css代码提取和压缩&lt;/code&gt; 、&lt;code&gt;html的生成&lt;/code&gt; 以及 &lt;code&gt;复制静态资源&lt;/code&gt; 还需要我们手动配置。&lt;/p&gt;
&lt;h4 id=&quot;代码分离&quot;&gt;代码分离&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 设置代码分离的输出目录
output: {
    path: path.resolve(__dirname, '../dist'),
    filename: ('js/[name].[hash:8].js'),
    chunkFilename: ('js/[name]-[id].[hash:8].js')
  },
 // 代码分离
 optimization: {
    runtimeChunk: {
      name: &quot;manifest&quot;
    },
    splitChunks: {
      chunks: 'all'
    }
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;2.6470588235294&quot;&gt;
&lt;p&gt;可以参阅如下链接：&lt;a href=&quot;https://www.webpackjs.com/plugins/split-chunks-plugin/&quot;&gt;optimization.splitChunks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h4 id=&quot;css代码压缩&quot;&gt;css代码压缩&lt;/h4&gt;
&lt;p&gt;借助 &lt;code&gt;MiniCssExtractPlugin&lt;/code&gt; 来实现压缩css和提取css。因为 &lt;code&gt;MiniCssExtractPlugin&lt;/code&gt; 无法与style-loader 共存，所以我们需要判断当前环境是生成环境还是开发环境。&lt;/p&gt;
&lt;p&gt;我们可以新建一个util.js的文件，在webpack当中一些共用的方法。考虑使用个别配置字段 &lt;code&gt;extract&lt;/code&gt; 来配置使用何种方式来配置css-loader。参见 &lt;code&gt;util.js&lt;/code&gt; 代码。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;new MiniCssExtractPlugin({
      filename: 'css/[name].[hash:8].css',
      chunkFilename: 'css/[name]-[id].[hash:8].css',
    }),&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;生成html&quot;&gt;生成HTML&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;htmlWebpackPlugin&lt;/code&gt;，配合ejs。可以使控制html 的生成。通过配置的方式，生成html。因为 &lt;code&gt;HtmlWebpackPlugin&lt;/code&gt; 本身可以解析ejs，所以不需要单独引入ejs的loader。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;new HtmlWebpackPlugin({
      filename: 'index.html',
      template: './src/index.ejs', // 设置目录
      title: 'React Demo',
      inject: true, // true-&amp;gt;'head' || false-&amp;gt;'body'
      minify: {
        //删除Html注释
        removeComments: true,
        //去除空格
        collapseWhitespace: true,
        //去除属性引号
        removeAttributeQuotes: true
        // more options:
        // https://github.com/kangax/html-minifier#options-quick-reference
      },
      // necessary to consistently work with multiple chunks via CommonsChunkPlugin
      chunksSortMode: 'dependency'
    }),&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;ejs&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
  &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
  &amp;lt;meta name=&quot;robots&quot; content=&quot;noindex, nofollow&quot;&amp;gt;

  &amp;lt;title&amp;gt;&amp;lt;%= htmlWebpackPlugin.options.title %&amp;gt;&amp;lt;/title&amp;gt;
  &amp;lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot;&amp;gt;
  &amp;lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot;&amp;gt;

  &amp;lt;% for (var chunk in htmlWebpackPlugin.files.css) { %&amp;gt;
  &amp;lt;link rel=&quot;preload&quot; href=&quot;&amp;lt;%= htmlWebpackPlugin.files.css[chunk] %&amp;gt;&quot;  as=&quot;style&quot;&amp;gt;
  &amp;lt;% } %&amp;gt;
  &amp;lt;% for (var chunk in htmlWebpackPlugin.files.chunks) { %&amp;gt;
  &amp;lt;link rel=&quot;preload&quot; href=&quot;&amp;lt;%= htmlWebpackPlugin.files.chunks[chunk].entry %&amp;gt;&quot; as=&quot;script&quot;&amp;gt;
  &amp;lt;% } %&amp;gt;

  &amp;lt;base href=&quot;/&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;root&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;style type=&quot;text/css&quot;&amp;gt;
  body {
    font-family: 'Source Sans Pro','Helvetica Neue',Helvetica,Arial,sans-serif;
  }
&amp;lt;/style&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;复制静态目录&quot;&gt;复制静态目录&lt;/h4&gt;
&lt;p&gt;将所以可能被请求的静态文件，分别放在assets目录下。那么在打包后，为了保证目录能正常访问（不使用CDN等加载静态资源时），我们可以配置 &lt;code&gt;publicPath = '/'&lt;/code&gt; 。然后借助于 &lt;code&gt;CopyWebpackPlugin&lt;/code&gt; 实现资源复制。&lt;/p&gt;
&lt;pre class=&quot;javas&quot;&gt;
&lt;code&gt;new CopyWebpackPlugin([{
      from: './src/assets/',
      to: 'assets'
    }]),&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 &lt;code&gt;src/assets&lt;/code&gt; 复制到 &lt;code&gt;dist/assets&lt;/code&gt; 目录下。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;开启打包分析&quot;&gt;开启打包分析&lt;/h4&gt;
&lt;p&gt;借助插件 &lt;code&gt;BundleAnalyzerPlugin&lt;/code&gt; 直接在plugins中创建该插件：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// webpack.prod.conf.js
const BundleAnalyzerPlugin = process.env.NODE_ENV=== 'analysis' ? require('webpack-bundle-analyzer').BundleAnalyzerPlugin:null
process.env.NODE_ENV=== 'analysis' ? new BundleAnalyzerPlugin() : ()=&amp;gt;{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在package.json 中可做如下配置：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;&quot;scripts&quot;: {
    &quot;analysis&quot;: &quot;cross-env NODE_ENV=analysis webpack -p --mode production --progress --config ./build/webpack.prod.conf.js &quot;,
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过注入环境变量，来控制是否运行打包分析。&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;ssh部署&quot;&gt;ssh部署&lt;/h4&gt;
&lt;p&gt;打包后的dist文件夹，可以直接借助 node 的 ssh-node ，直接部署到服务器指定的目录下。 ssh-node既支持ssh，也支持密码登录。建议可以为在每个项目下，新建一个.ssh文件，存放项目的私钥。代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// usage: https://www.npmjs.com/package/node-ssh
var path, node_ssh, ssh, fs, opn, host

fs = require('fs')
path = require('path')
node_ssh = require('node-ssh')
opn = new require('opn')
ssh = new node_ssh()
host = 'localhost'
var localDir = './dist'
var remoteDir = '/opt/frontend/new'
var removeCommand = 'rm -rf ./*'
var pwdCommand = 'pwd'

ssh.connect({
  host: host,
  username: 'root',
  port: 22,
  // password,
  privateKey: &quot;./.ssh/id_rsa&quot;,
})
  .then(function() {
    ssh.execCommand(removeCommand, { cwd:remoteDir }).then(function(result) {
      console.log('STDOUT: ' + result.stdout)
      console.log('STDERR: ' + result.stderr)
      ssh.putDirectory(localDir, remoteDir).then(function() {
        console.log(&quot;The File thing is done&quot;)
        ssh.dispose()
        opn('http://'+host, {app:['chrome']})
      }, function(error) {
        console.log(&quot;Something's wrong&quot;)
        console.log(error)
        ssh.dispose()
      })
    })
  })
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，在命令行直接 &lt;code&gt;node deploy.js&lt;/code&gt; 就可以运行以上脚本，我们也可以添加一个build + deploy的script脚本，便于启动。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;&quot;scripts&quot;: {
    &quot;depoly&quot;: &quot;npm run build &amp;amp;&amp;amp; node ./deploy.js&quot;,
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;本次从零到一，新建了一个react脚手架。过程中有很多问题，也参考了不少大牛的解释。代码里也有诸多问题。还望各位看官，不吝指教。&lt;br/&gt;记得留下你的足迹哦。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;参考了vue-cli v2.96的webpack配置。&lt;br/&gt;&lt;a href=&quot;https://github.com/chemdemo/chemdemo.github.io/issues/13&quot;&gt;【翻译】Webpack——令人困惑的地方&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.webpackjs.com/configuration/&quot;&gt;webpack中文文档&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Jul 2018 14:20:00 +0000</pubDate>
<dc:creator>Dante丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DDante/p/9368694.html</dc:identifier>
</item>
</channel>
</rss>