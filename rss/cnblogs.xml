<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>TensorFlow-谷歌深度学习库 手把手教你如何使用谷歌深度学习云平台 - 火山岩上的小红花</title>
<link>http://www.cnblogs.com/duwenlu/p/8704258.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duwenlu/p/8704258.html</guid>
<description>&lt;p&gt;自己的电脑跑cnn, rnn太慢？ 还在为自己电脑没有好的gpu而苦恼？ 程序一跑一俩天连睡觉也要开着电脑训练？&lt;/p&gt;
&lt;p&gt;如果你有这些烦恼何不考虑考虑使用谷歌的云平台呢？注册之后即送300美元噢～下面我就来介绍一下谷歌云平台的使用。&lt;/p&gt;
&lt;p&gt;1 配置谷歌云平台项目（GCP Project)&lt;/p&gt;
&lt;p&gt;https://console.cloud.google.com/cloud-resource-manager&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180402231810274-1676309421.png&quot; alt=&quot;&quot; width=&quot;225&quot; height=&quot;90&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照谷歌的向导你可以一步一步创建一个新的项目。这个项目就是你本地的项目并想放在云上跑的东西。&lt;/p&gt;
&lt;p&gt;点击创建项目，输入新建的项目名称，等一下下你的新项目就创建好啦。新的项目的dashboard如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180402232622428-1729587200.png&quot; alt=&quot;&quot; width=&quot;502&quot; height=&quot;283&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2 将这个项目绑定一个付款账号，当然谷歌给了你300刀，如果你只是做一些小项目仅供个人学习的话300刀应该是足够的。&lt;/p&gt;
&lt;p&gt;https://cloud.google.com/billing/docs/how-to/modify-project&lt;/p&gt;
&lt;p&gt;如果你还没有一个付款账号，会提示你先创建一个账号， 总之你要关联你的账号到你新建的项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180402233317749-880288799.png&quot; alt=&quot;&quot; width=&quot;127&quot; height=&quot;187&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置完毕后你会看到谷歌给你的赠金信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180402233538146-508235364.png&quot; alt=&quot;&quot; width=&quot;245&quot; height=&quot;73&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.启用API，在 Google Cloud Platform 中注册您的应用以使用 Google Cloud Machine Learning EngineGoogle Compute Engine API&lt;/p&gt;
&lt;p&gt; https://console.cloud.google.com/flows/enableapi?apiid=ml.googleapis.com,compute_component&lt;/p&gt;
&lt;p&gt;选择要注册API的项目。显示正在启用API。你讲看到下面这个界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180402234525239-758884259.png&quot; alt=&quot;&quot; width=&quot;340&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4 设置凭据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180402234813268-1825377751.png&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建一个服务账号，角色为项目的所有者。点击创建后一个包含了你的私钥的json文件将下载到你的本地所指定的路径。&lt;/p&gt;
&lt;p&gt;设置环境变量GOOGLE_APPLICATION_CREDENTIALS为你保存以上json文件的路径。比如mac os用户在terminal中输入如下（引号中为你本地的json文件路径）：&lt;/p&gt;
&lt;pre class=&quot;devsite-code-button-clone&quot;&gt;
&lt;span class=&quot;pln&quot;&gt;export GOOGLE_APPLICATION_CREDENTIALS&lt;span class=&quot;pun&quot;&gt;=&lt;span class=&quot;str&quot;&gt;&quot;/home/user/Downloads/service-account-file.json&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;5 当以上都设置完毕后，接下来要下载和初始化cloud sdk啦&lt;/p&gt;
&lt;p&gt;https://cloud.google.com/sdk/docs/  &lt;/p&gt;
&lt;p&gt;下载完成后，初始化cloud sdk～&lt;/p&gt;
&lt;p&gt;在terminal中进入你存放sdk的路径，输入一下&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&amp;gt; sh ./google-cloud-sdk/install.sh&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180403001359722-44235047.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;109&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;选择是否帮助完善cloud sdk&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180403001657685-1811950717.png&quot; alt=&quot;&quot; width=&quot;368&quot; height=&quot;156&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择是否需要更新$PATH， 如果更新你可以在命令行中任何路径下使用google cloud命令。然后会提示你输入你个路径，或直接为空使用默认。&lt;/p&gt;
&lt;p&gt;这里我选择的是为空。如果是mac用户不知道会不会遇到和我相同的问题，就是路径没有设置成功。我的解决办法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180403002240325-1112360167.png&quot; alt=&quot;&quot; width=&quot;329&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在命令行中source completion.bash.inc 和 path.bash.inc两个文件。&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;USER-MBP:Google_Cloud_Compute_Engine$ source /Users/.../.../.../google-cloud-sdk/path.bash.inc&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;USER-MBP:Google_Cloud_Compute_Engine$ source /Users/.../.../.../google-cloud-sdk/completion.bash.inc&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;运行gcloud init初始化sdk&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint lang-sh&quot;&gt;
&lt;span class=&quot;pun&quot;&gt;./&lt;span class=&quot;pln&quot;&gt;google&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;cloud&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;sdk&lt;span class=&quot;pun&quot;&gt;/&lt;span class=&quot;pln&quot;&gt;bin&lt;span class=&quot;pun&quot;&gt;/&lt;span class=&quot;pln&quot;&gt;gcloud init&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;以上我们完成了想要使用谷歌深度学习平台的配置，总结一下就是创建一个项目，设置结算信息关联项目，创建服务账号密钥并设置环境变量， 下载初始化sdk。&lt;/p&gt;

&lt;p&gt;接下来的重头戏当然就是把我们本地的代码放到谷歌云上训练啦～～～&lt;/p&gt;
&lt;p&gt;1.打包你的训练模型&lt;/p&gt;
&lt;p&gt;https://cloud.google.com/ml-engine/docs/packaging-trainer&lt;/p&gt;
&lt;p&gt;第一步 使用推荐的项目结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180403003237971-1714922087.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建一个空的setup.py文件， 在trainer文件夹中创建一个空的__init__.py&lt;/p&gt;
&lt;p&gt;2. 确认你云端上保存你的所用中间或最终输出结果（比如checkpoint文件）的路径， 这一步很重要！！！！否则你不知道在哪找你训练的参数呀！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180403003856204-1957342517.png&quot; alt=&quot;&quot; width=&quot;185&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Google Cloud Platfrom左侧的导航栏中选择存储，创建存储分区&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180403004241719-1142669577.png&quot; alt=&quot;&quot; width=&quot;255&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，创建一个分区，选择regional，位置为us-east1可以使用gpu！！！而且比较便宜呀～～～&lt;/p&gt;
&lt;p&gt;这样你在云端上就有了一个路径，比如我的情况就是&lt;span class=&quot;s1&quot;&gt;gs://yzm_bucket&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;创建完成后，在你本地的代码中把你所有的输出路径都要替换成你的云端路径。这样在云端训练时才能把结果也保存在云端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;比如这样：path_to_latest_checkpoint_file = saver.save(sess, 'gs://yzm_bucket/log/latest.ckpt')&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;3. 确认本地代码中所需要的依赖&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;需要查看cloud ml runtime的版本信息 -&amp;gt; https://cloud.google.com/ml-engine/docs/runtime-version-list&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;目前的化&lt;/span&gt;Cloud ML runtime最新版本为1.6， 支持python 3.5。 查看你想使用的版本有没有所有你所依赖的包。 如果你的程序用pip安装了一些python模块（如pillow）但是使用的runtime版本中并不包含这些包，你需要手动设置你的包依赖。 请在setup.py中（如果你用标准的项目结构，就是你traniner的根目录即它的上一层）添加如下信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; setuptools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; find_packages
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; setuptools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; setup

REQUIRED_PACKAGES &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;some_PyPI_package&amp;gt;=1.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

setup(
    name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;trainer&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    version&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    install_requires&lt;/span&gt;=&lt;span&gt;REQUIRED_PACKAGES,
    packages&lt;/span&gt;=&lt;span&gt;find_packages(),
    include_package_data&lt;/span&gt;=&lt;span&gt;True,
    description&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;My trainer application package.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4. 使用&lt;strong&gt;gcloud ml-engine jobs submit training&lt;/strong&gt;提交你要运行的训练任务&lt;/p&gt;
&lt;p&gt;https://cloud.google.com/sdk/gcloud/reference/ml-engine/jobs/submit/training&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
gcloud ml-engine jobs submit training JOB &lt;br/&gt;--module-name=MODULE_NAME [--config=CONFIG] [--job-dir=JOB_DIR] [--labels=[KEY=VALUE,…]] &lt;br/&gt;[--package-path=PACKAGE_PATH] [--packages=[PACKAGE,…]] [--python-version=PYTHON_VERSION] &lt;br/&gt;[--region=REGION] [--runtime-version=RUNTIME_VERSION] [--scale-tier=SCALE_TIER] &lt;br/&gt;[--staging-bucket=STAGING_BUCKET] [--async     | --stream-logs] [GCLOUD_WIDE_FLAG …] [-- USER_ARGS …]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如像这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  $ gcloud ml-&lt;span&gt;engine jobs submit training my_job \
          &lt;/span&gt;--module-&lt;span&gt;name trainer.task \
          &lt;/span&gt;--staging-bucket gs://my-&lt;span&gt;bucket \
          &lt;/span&gt;--package-path /my/code/path/&lt;span&gt;trainer \
          &lt;/span&gt;--packages additional-dep1.tar.gz,dep2.whl
&lt;/pre&gt;&lt;/div&gt;

&lt;pre readability=&quot;4&quot;&gt;
gcloud ml-&lt;span readability=&quot;2&quot;&gt;engine jobs submit training 后面是任务的名称（唯一标识任务的名称，不可以和之前提交的任务名重复），&lt;br/&gt;module-name 为trainer.task, task就是你程序的入口python文件，在标准项目结构中叫做task.py的那个文件， trainer为标准项目结构中trainer文件夹。&lt;br/&gt;staging-bucket 为google cloud上的路径，指定你把你的代码文件上传到哪在运行程序的时候可以在那个路径上找到你的源码。这里存在了叫做my-bucket的云路径上。&lt;br/&gt;package-path 为你本地到trainer文件夹的路径，也就是你把trainer文件夹存在了本地的什么位置&lt;p&gt;除了以上参数你可能还需要以下参数&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
[--job-dir=JOB_DIR] &lt;br/&gt;job-dir 指明了在云端你想要把输出存在什么位置， 如果你已经在代码中指明，此步可以省略。
&lt;/pre&gt;
&lt;pre&gt;
[--python-version=PYTHON_VERSION] &lt;br/&gt;python-version：如果你是用python 3，请明确在这里声明否则默认为python 2&lt;/pre&gt;
&lt;pre&gt;
[--runtime-version=RUNTIME_VERSION] &lt;br/&gt;runtime-version：最新版本为1.6，支持python 3&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;如果你考虑使用GPU,也请设置参数如下。&lt;br/&gt;https://cloud.google.com/ml-engine/docs/using-gpus&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;To use GPUs in the cloud, configure your training job to access GPU-enabled machines:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Set the scale tier to &lt;code&gt;CUSTOM&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Configure each task (master, worker, or parameter server) to use one of the GPU-enabled machine types below, based on the number of GPUs and the type of accelerator required for your task:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;code&gt;standard_gpu&lt;/code&gt;: A single NVIDIA Tesla K80 GPU&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;complex_model_m_gpu&lt;/code&gt;: Four NVIDIA Tesla K80 GPUs&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;complex_model_l_gpu&lt;/code&gt;: Eight NVIDIA Tesla K80 GPUs&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;standard_p100&lt;/code&gt;: A single NVIDIA Tesla P100 GPU (&lt;em&gt;Beta&lt;/em&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;code&gt;complex_model_m_p100&lt;/code&gt;: Four NVIDIA Tesla P100 GPUs (&lt;em&gt;Beta&lt;/em&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt; 在本地保存config.yaml文件，并在里写入你想要指定的gpu配置信息。&lt;/p&gt;
&lt;pre class=&quot;prettyprint notranslate&quot; readability=&quot;5&quot;&gt;
&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;trainingInput&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;pln&quot;&gt;&lt;br/&gt;scaleTier&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;pln&quot;&gt; CUSTOM&lt;br/&gt;masterType&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;pln&quot;&gt; complex_model_m_gpu&lt;br/&gt;workerType&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;pln&quot;&gt; complex_model_m_gpu&lt;br/&gt;parameterServerType&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;pln&quot;&gt; large_model&lt;br/&gt;workerCount&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;9&lt;span class=&quot;pln&quot;&gt;&lt;br/&gt;parameterServerCount&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;pln&quot;&gt; &lt;span class=&quot;lit&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;p&gt;如果是新手&lt;code&gt;scaleTier&lt;/code&gt;推荐使用BASIC_GPU而不是CUSTOM&lt;br/&gt;然后在命令中多加一个参数
&lt;/p&gt;&lt;/pre&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;--config &lt;/span&gt;/my/code/path/to&lt;span class=&quot;s1&quot;&gt;/config.yaml&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;prettyprint notranslate&quot;&gt;
&lt;br/&gt;比如我的情况，代码如下：
&lt;/pre&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;gcloud ml-engine jobs submit training beta330&lt;span class=&quot;Apple-converted-space&quot;&gt;  --module-name trainer.task --staging-bucket gs://yzm_bucket --package-path /Users/wenlu/PycharmProjects/Google_Cloud_Compute_Engine/yzm_recognition/trainer --python-version=3.5 --runtime-version=1.6 --config /Users/wenlu/PycharmProjects/Google_Cloud_Compute_Engine/yzm_recognition/trainer/config.yaml&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;这就是在谷歌云端跑tensorflow的全部啦～～～～&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;成功的化，terminal会出现以下&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Job [beta330] submitted successfully.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;Your job is still active. You may view the status of your job with the command&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  $ gcloud ml-engine jobs describe beta330&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;or continue streaming the logs with the command&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s1&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;  $ gcloud ml-engine jobs stream-logs beta330&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;jobId: beta330&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;state: QUEUED&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;在谷歌云端机器学习引擎中的job中出现如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180403033737793-1370316830.png&quot; alt=&quot;&quot; width=&quot;625&quot; height=&quot;174&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;p&gt;你可以即时的查看日志信息，什么地方出错了输出的loss是多少了准确率已经到多少了之类之类的～～如果失败了你也可以看到traceback来研究哪个地方导致程序出错了。&lt;/p&gt;
&lt;p&gt;而在我的云端存储中，输出是这个样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336707/201804/1336707-20180403034047407-2078616262.png&quot; alt=&quot;&quot; width=&quot;594&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好啦～大概就是这样吧。如果你有任何疑问欢迎留言提问哈。&lt;/p&gt;

</description>
<pubDate>Mon, 02 Apr 2018 19:49:00 +0000</pubDate>
<dc:creator>火山岩上的小红花</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/duwenlu/p/8704258.html</dc:identifier>
</item>
<item>
<title>【作业】HansBug的前三次OO作业分析与小结 - HansBug</title>
<link>http://www.cnblogs.com/HansBug/p/8694939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HansBug/p/8694939.html</guid>
<description>&lt;p&gt;OO课程目前已经进行了三次的作业，容我在本文中做一点微小的工作。&lt;/p&gt;

&lt;p&gt;第一次作业由于难度不大，所以笔者程序实际上写的也比较随意一些。（&lt;del&gt;&lt;a href=&quot;https://files.cnblogs.com/files/HansBug/OO%E7%AC%AC01%E6%AC%A1%E4%BD%9C%E4%B8%9A%E6%8C%87%E5%AF%BC%E4%B9%A6.pdf&quot;&gt;点击就送指导书~&lt;/a&gt;&lt;/del&gt;）&lt;/p&gt;
&lt;h2 id=&quot;类图&quot;&gt;类图&lt;/h2&gt;
&lt;p&gt;程序的大致结构如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402232134162-1586517174.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码分析&quot;&gt;代码分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402194817719-2119327278.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402195500279-1997047654.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402195505959-148006220.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，整体的功能还是相对零散的，耦合状况也基本还可以。然而类似&lt;code&gt;Main.main&lt;/code&gt;、&lt;code&gt;Polynomial.Polynomial&lt;/code&gt;两个函数的复杂度仍有点高。笔者后来查阅了&lt;a href=&quot;https://files.cnblogs.com/files/han-1034683568/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8Cv1.2.0.pdf&quot;&gt;阿里Java开发规范手册&lt;/a&gt;，发现两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;单个方法的长度不宜过长&lt;/strong&gt;，入口点方法（&lt;code&gt;Main.main&lt;/code&gt;）也是一样&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不宜在构造函数中携带过多的计算逻辑&lt;/strong&gt;。手册第七页，第11条中也有明确的规定：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;11. 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;笔者的程序这一点就有待修改，同时，类似&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Polynomial&lt;/span&gt;(String str) {
        &lt;span class=&quot;co&quot;&gt;// something inside&lt;/span&gt;
    };&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的构造函数，更适合写在类似&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Polynomial &lt;span class=&quot;fu&quot;&gt;parsePolynomial&lt;/span&gt;(String str) {
        &lt;span class=&quot;co&quot;&gt;// something inside&lt;/span&gt;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;的静态方法中。&lt;/p&gt;
&lt;h2 id=&quot;公测&quot;&gt;公测&lt;/h2&gt;
&lt;h3 id=&quot;我方&quot;&gt;我方&lt;/h3&gt;
&lt;p&gt;公测不出意外，笔者的程序在公测阶段没有出现任何错误。&lt;/p&gt;
&lt;h3 id=&quot;对方&quot;&gt;对方&lt;/h3&gt;
&lt;p&gt;对方的程序在公测被测出了一个bug，是栈溢出，溢出的位置是正则表达式。&lt;/p&gt;
&lt;p&gt;对方试图用一个规模庞大的正则表达式来先行判断整个表达式是否合法，于是在遇到规模较大的数据时出现了栈溢出的情况。&lt;/p&gt;
&lt;h2 id=&quot;互测&quot;&gt;互测&lt;/h2&gt;
&lt;h3 id=&quot;我方-1&quot;&gt;我方&lt;/h3&gt;
&lt;p&gt;不出意外，笔者的程序未被测出bug。&lt;/p&gt;
&lt;h3 id=&quot;对方-1&quot;&gt;对方&lt;/h3&gt;
&lt;p&gt;对方的程序被测出了一个bug，对方&lt;strong&gt;仍在对象内使用传统的&lt;code&gt;int&lt;/code&gt;数组&lt;/strong&gt;，而且&lt;strong&gt;空间开的非常小&lt;/strong&gt;，最终导致数组越界，程序出错（然而事实上对方在顶层进行了Exception的catch，故没有出现crash）。&lt;/p&gt;
&lt;h2 id=&quot;反思&quot;&gt;反思&lt;/h2&gt;
&lt;p&gt;第一次由于任务算法&lt;strong&gt;难度很低&lt;/strong&gt;，且&lt;strong&gt;工程量也不很大&lt;/strong&gt;（小几百行的量，甚至据说部分大佬压缩到了100行内），所以笔者的很多写法较为随意，大约整个工程用时一小时不到。所以在&lt;strong&gt;工程性方面没做过多的考量&lt;/strong&gt;，&lt;strong&gt;架构也没有进行很充分的优化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;第一次据笔者观察，很多同学还&lt;strong&gt;对java这门语言完全处于不熟悉的状态&lt;/strong&gt;，对于正则表达式等概念及其具体原理也完全不了解，更不用说面向对象的设计思想了。据笔者所知，像这样试图用一个庞大的正则表达式判断格式的同学并不在少数。然而了解正则表达式相关原理的同学都应该清楚，正则表达式不是让你这么用的。正则表达式更多的用于&lt;strong&gt;相对简单&lt;/strong&gt;且没有复杂的重复和嵌套的一些的&lt;strong&gt;模式匹配&lt;/strong&gt;，以及其内部&lt;strong&gt;关键位置信息的提取&lt;/strong&gt;。（更多信息和算法原理可以翻阅&lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;Wikipedia - Regular Expression&lt;/a&gt;，大致原理为有限状态自动机，本文不再赘述。）&lt;/p&gt;
&lt;p&gt;此外，在C#、Java这类的语言中，&lt;strong&gt;直接使用传统数组&lt;/strong&gt;在大部分情况下并&lt;strong&gt;不是明智的选择&lt;/strong&gt;，Java中没有像C++那样提供很完善的面向用户的指针机制，为的是一定程度上的系统安全性。而传统数组存在&lt;strong&gt;灵活性极差&lt;/strong&gt;的问题。简单来说，数组开小了，会crash；数组开大了，空间的浪费很严重（甚至有部分大佬还在适用oi/acm味满满的长度高达100050超大数组[滑稽]）。所以，更推荐各位优先使用Java封装好的数据结构，例如序列类的&lt;code&gt;Vector&lt;/code&gt;、&lt;code&gt;ArrayList&lt;/code&gt;（实际上后者效率更高，推荐&lt;code&gt;ArrayList&lt;/code&gt;），例如Key-Value类的&lt;code&gt;HashMap&lt;/code&gt;（笔者在后来还自行继承封装了一款支持默认值的&lt;code&gt;HashDefaultMap&lt;/code&gt;），而不是去自己实现一个所谓的数据结构。或者也可以这样说，&lt;strong&gt;你能想到能做到的算法封装，人家Java作者早就想到了&lt;/strong&gt;。&lt;strong&gt;IT界从来不缺勤奋的轮子工，需要的是聪明的懒人&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;第二次作业，是实现一个傻瓜电梯。问题一如既往的简单，但是真正一去写，诶？细节这么多？恩，真正的工程终于来了。（&lt;del&gt;&lt;a href=&quot;https://files.cnblogs.com/files/HansBug/OO%E7%AC%AC02%E6%AC%A1%E4%BD%9C%E4%B8%9A%E6%8C%87%E5%AF%BC%E4%B9%A6V1.2.pdf&quot;&gt;点击就送指导书~&lt;/a&gt;&lt;/del&gt;）&lt;/p&gt;
&lt;h2 id=&quot;类图-1&quot;&gt;类图&lt;/h2&gt;
&lt;p&gt;第二次作业，笔者的程序结构大致如下（图片规模略大）：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402203114037-1925871389.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;笔者将所有的输入请求抽象为了&lt;code&gt;Request&lt;/code&gt;类，再将操作和RUN指令分别继承为了&lt;code&gt;OperationRequest&lt;/code&gt;和&lt;code&gt;RunRequest&lt;/code&gt;，&lt;code&gt;OperationRequest&lt;/code&gt;类再继承为内部请求类（&lt;code&gt;InnerRequest&lt;/code&gt;）和外部请求类（&lt;code&gt;OuterRequest&lt;/code&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;代码分析-1&quot;&gt;代码分析&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402203413205-2073282646.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402203611745-506270731.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402203617252-1216837117.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这一次的耦合状况较上一次有好转（没有出现红色字）。然而依然存在&lt;strong&gt;部分方法复杂度略高&lt;/strong&gt;的情况（比如入口点函数，依然是红字状态）。看来，功能还需要进一步拆散。&lt;/p&gt;
&lt;h2 id=&quot;公测-1&quot;&gt;公测&lt;/h2&gt;
&lt;h3 id=&quot;我方-2&quot;&gt;我方&lt;/h3&gt;
&lt;p&gt;第二次作业中，笔者的程序公测出现了一个bug。后来经检查，是因为&lt;strong&gt;没有仔细研读guide book&lt;/strong&gt;上的一个功能需求而导致的功能缺失造成的（没有支持数字前的&lt;code&gt;+&lt;/code&gt;）。&lt;/p&gt;
&lt;h3 id=&quot;对方-2&quot;&gt;对方&lt;/h3&gt;
&lt;p&gt;对方在公测中没有出现任何bug。&lt;/p&gt;
&lt;h2 id=&quot;互测-1&quot;&gt;互测&lt;/h2&gt;
&lt;h3 id=&quot;我方-3&quot;&gt;我方&lt;/h3&gt;
&lt;p&gt;我方一开始有一处被对方认定为imcomplete，这段代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package configs;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 全局设置类&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ApplicationConfig {
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 层数限制&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; default_max_floor = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; default_min_floor = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; default_present_floor = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 时间戳限制&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; default_max_timestamp = 0xffffffffL;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; default_min_timestamp = 0L;
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 默认电梯数量&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; default_lift_count = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 最大可接受的合法请求数&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; max_valid_requests = &lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对方给出的理由是，&lt;em&gt;guide book上面规定不准使用public&lt;/em&gt;。然而，根据笔者之前长时间大量的工程经验来看，&lt;strong&gt;这样的写法还是很常见的&lt;/strong&gt;（&lt;code&gt;public static&lt;/code&gt;来设置常数的形式）。&lt;/p&gt;
&lt;p&gt;况且，笔者在guide book中找到的原文如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;必须要实现电梯、楼层、请求队列、调度器、请求这五个类，且类中不允许出现 Public 属性。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说的是&lt;strong&gt;public属性&lt;/strong&gt;是不被允许的，那么&lt;code&gt;public static&lt;/code&gt;究竟算不算在内呢？笔者先后问了多个助教，助教们之间意见也不是很统一（总体还是认为可以使用&lt;code&gt;public static&lt;/code&gt;的更多）。&lt;/p&gt;
&lt;p&gt;后来笔者基于这个问题与吴际老师进行了交流，老师的意见可以归结为如下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这种写法不是不可以，但是&lt;code&gt;public static&lt;/code&gt;的值&lt;strong&gt;仍有被非法篡改的可能&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;比如，使用&lt;code&gt;public final&lt;/code&gt;来将设置类的值限定为常量可以有效地防止修改。&lt;/li&gt;
&lt;li&gt;比如，使用getter方法来进行静态的访问也可以从根本上杜绝非法篡改。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;笔者后来再次翻阅了代码规范手册，发现一般常量类的东西需要使用&lt;code&gt;static final&lt;/code&gt;关键字，同时命名方式一般为&lt;strong&gt;全部大写并按照单词来下划线分隔&lt;/strong&gt;（例如：&lt;code&gt;YES&lt;/code&gt;、&lt;code&gt;UNKNOWN_REASON&lt;/code&gt;等）（详见手册第3页，常量定义）。&lt;/p&gt;
&lt;p&gt;以及，最终看了下助教&lt;strong&gt;仲裁&lt;/strong&gt;的结果，&lt;strong&gt;结果是不算bug&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;对方-3&quot;&gt;对方&lt;/h3&gt;
&lt;p&gt;很不巧，这次没有发现对方的bug。不过可以看的出来，是一个&lt;strong&gt;逻辑思维清晰&lt;/strong&gt;，但是&lt;strong&gt;代码规范和工程思维比较欠缺&lt;/strong&gt;的同学。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;第二次作业某种意义上算得上是个&lt;strong&gt;真真正正的工程&lt;/strong&gt;了，笔者这次虽然还是有点小遗憾，但总算是找到了久违的OOP工程的手感。&lt;/p&gt;
&lt;p&gt;笔者的程序部分地方还是&lt;strong&gt;存在代码质量问题&lt;/strong&gt;，还是有进一步改进的空间的。&lt;/p&gt;
&lt;p&gt;此外，因为guide book读漏了而导致的公测bug这个&lt;strong&gt;实在是不应该的&lt;/strong&gt;，以后必须要注意仔细研究需求。&lt;/p&gt;

&lt;p&gt;第三次作业是第二次作业的升级版，采用了相对智能的电梯调度措施，然后需求细节一样较为繁琐。（&lt;del&gt;&lt;a href=&quot;https://files.cnblogs.com/files/HansBug/OO%E7%AC%AC03%E6%AC%A1%E4%BD%9C%E4%B8%9A%E6%8C%87%E5%AF%BC%E4%B9%A62018v1.3.pdf&quot;&gt;点击就送指导书~&lt;/a&gt;&lt;/del&gt;）&lt;/p&gt;
&lt;h2 id=&quot;类图-2&quot;&gt;类图&lt;/h2&gt;
&lt;p&gt;笔者的程序结构如下（图片规模还是较大）：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402213135908-1353395602.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;笔者在第二次&lt;code&gt;LiftController&lt;/code&gt;类外部套了一个&lt;code&gt;Scheduler&lt;/code&gt;进行更加智能的调度。&lt;/p&gt;
&lt;p&gt;此外，笔者为了方便在调试时看清楚整个程序内部的计算逻辑细节，设置了&lt;strong&gt;Debug信息输出接口&lt;/strong&gt;。（详情见&lt;a href=&quot;http://www.cnblogs.com/HansBug/p/8701447.html&quot;&gt;【技巧】Java工程中的Debug信息分级输出接口&lt;/a&gt;）&lt;/p&gt;
&lt;h2 id=&quot;代码质量&quot;&gt;代码质量&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402215043419-1875797229.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402215212101-457611032.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/703546/201804/703546-20180402215218686-725650439.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，还是老毛病，有些&lt;strong&gt;核心方法的规模过大&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;公测-2&quot;&gt;公测&lt;/h2&gt;
&lt;h3 id=&quot;我方-4&quot;&gt;我方&lt;/h3&gt;
&lt;p&gt;笔者的程序在公测环节没有出现任何错误。&lt;/p&gt;
&lt;h3 id=&quot;对方-4&quot;&gt;对方&lt;/h3&gt;
&lt;p&gt;对方的程序在公测环节出现了一处错误，出错位置在&lt;code&gt;边界情况测试&lt;/code&gt;--&amp;gt;&lt;code&gt;副请求时间==主请求开门时间，不捎带&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;互测-2&quot;&gt;互测&lt;/h2&gt;
&lt;h3 id=&quot;我方-5&quot;&gt;我方&lt;/h3&gt;
&lt;p&gt;笔者在公测环节找出了对方程序的两个bug：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对方的程序在一个地方存在&lt;strong&gt;queue对象非法访问&lt;/strong&gt;的问题（准确的说，是越界访问）&lt;/li&gt;
&lt;li&gt;对方的程序在处理一次性处理多个请求的时候，并未严格按照输入顺序进行输出（笔者判断的没错的话，对方应该是&lt;strong&gt;将主请求进行了单独处理&lt;/strong&gt;，从而导致了这样的错误）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;对方-5&quot;&gt;对方&lt;/h3&gt;
&lt;p&gt;不出意料，对方未发现笔者程序的bug。&lt;/p&gt;
&lt;h2 id=&quot;总结-1&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;第三次作业没有再犯第二次作业的低级错误，也没有被挑出bug。&lt;/p&gt;
&lt;p&gt;然而实际上，第三次作业仍然有着&lt;strong&gt;一些的缺陷&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;和第二次作业一样&lt;strong&gt;功能不够分散&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由于需求分析花了非常多的时间，导致这次作业起步时间很晚，&lt;strong&gt;很多架构实际上并不是很好的设计&lt;/strong&gt;（笔者写程序的时候自己就已经在这么觉得，然而时间紧迫还是选择了优先完成任务）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;等到下次作业，笔者&lt;strong&gt;会对一部分的架构进行大改&lt;/strong&gt;，争取用更优的架构来面对接下来的project。&lt;/p&gt;
&lt;p&gt;此外，还是必须吐槽一句，&lt;strong&gt;guide book中很多该明确的需求并没有明确到位&lt;/strong&gt;。也许现实中的开发真的没那么特别明确细致的需求，然而我们的&lt;strong&gt;公测环节却有着无比明确的细节需求&lt;/strong&gt;（而实际项目中的此类细节需求&lt;strong&gt;很大一部分是开发者自己定义&lt;/strong&gt;的，其余的是&lt;strong&gt;甲乙双方协商确定的&lt;/strong&gt;），这两者之间，显然存在着不可调和的矛盾。希望OO课程组就这一问题进行制度上的改善。&lt;/p&gt;

&lt;p&gt;以上三次作业，让笔者感到自己还有一些不足：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;部分方法依然复杂度偏高&lt;/strong&gt;（有的已经接近100行），应该根据其功能模块进一步拆分&lt;/li&gt;
&lt;li&gt;对于需求很多时候还是没有弄得特别清楚，导致第二次公测挂掉了一个点（实际开发中，需求还是非常重要的）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;经过了研读阿里Java代码规范手册后，笔者意识到自己在OOP方面仍然有不少需要进一步规范和改进的地方。笔者之后会尽力做到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;充分明确需求&lt;/li&gt;
&lt;li&gt;动手写代码之前仔细研究架构的合理性和扩展性&lt;/li&gt;
&lt;li&gt;严格遵循代码规范&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;笔者在发布此文章之前，听过不少来自身边同学的各类吐槽，也看了一些其他同学已经发布的文章，感觉不少同学对有些事情的认识还是&lt;strong&gt;存在着一些误区&lt;/strong&gt;，笔者准备在此结合自己在工程开发方面的经验和踩过的坑，和大家聊一聊。&lt;/p&gt;
&lt;h2 id=&quot;代码越短就越好&quot;&gt;代码越短就越好？&lt;/h2&gt;
&lt;p&gt;之前看到一些同学的作业，不少作业里面都在说自己的程序写的还不够好，下次争取精简的更短。&lt;/p&gt;
&lt;p&gt;其实，这是个很错误的认识。&lt;strong&gt;代码短等于代码质量高吗？当然不是！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个很经典的例子，让我们来看几段程序：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* 程序一 */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(i++ + ++i);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* 程序二 */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = i++;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k = ++i;
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(j + k);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/* 程序三 */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = i;
    i += &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    i += &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k = i;
    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(j + k);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，现在请告诉我，这三个程序的运行结果都是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没错，输出的结果都是&lt;code&gt;6&lt;/code&gt;，这三个程序是等价的&lt;/strong&gt;。那么请告诉我，哪个程序你最先看懂，&lt;strong&gt;哪个程序你最先计算出了结果&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;我想大部分人的顺序都是：&lt;code&gt;程序三&lt;/code&gt;-&amp;gt;&lt;code&gt;程序二&lt;/code&gt;-&amp;gt;&lt;code&gt;程序一&lt;/code&gt;。然而程序从短到长的顺序是什么呢？&lt;strong&gt;完全和这个相反&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;让我们回到这个问题的定义上来——&lt;strong&gt;究竟什么样的代码叫做高质量代码&lt;/strong&gt;？我们来思考几件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码是谁写的？人写的。&lt;/li&gt;
&lt;li&gt;代码是干什么的？实现功能的。&lt;/li&gt;
&lt;li&gt;实现功能是干什么的？创造价值的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么我们再来思考一个问题：&lt;strong&gt;从结构化程序设计，到面向对象编程，甚至到后来的函数式编程，这些东西存在的意义是什么&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;毫无疑问，&lt;strong&gt;最终目的肯定是创造更多的价值&lt;/strong&gt;。而决定能否创造价值、创造多少价值&lt;strong&gt;最核心最根本的因素&lt;/strong&gt;，是&lt;strong&gt;写代码的人&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这下很明显了，&lt;strong&gt;这一切的发展，围绕的都是开发程序的人&lt;/strong&gt;。说的更直接一些，&lt;strong&gt;能有助于提高开发者的开发速度，提高开发者对程序的维护和扩展能力，提高团队合作效率的代码，就是高质量代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这么看来，像刚才那样第一个程序，的确很短，也不得不说能驾驭的了这种程序，开发者也肯定挺厉害。但是这种东西真的能让自己以外的人（甚至自己过了一段时间后）快速的理解么？显然不能。&lt;strong&gt;所以类似这样的，短小精悍但是实际上不利于整体开发效率和质量的代码，也是很糟糕的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，说了这些，并不是说短小的代码有错。而是，不应该为了短小而短小，而&lt;strong&gt;应该是为了让程序更加清晰可读而将程序进行适度的精简&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;system.out调试很低级&quot;&gt;System.out调试很低级？&lt;/h2&gt;
&lt;p&gt;看到过一些同学（作业里的和身边的都有）之前在抱怨，自己只会输出调试如何如何如何。。。。&lt;/p&gt;
&lt;p&gt;然而我还是和上一节一样，一句话：&lt;strong&gt;这一切，围绕的都是开发程序的人&lt;/strong&gt;。说的更直接一些，&lt;strong&gt;能帮你更快定位和找出bug（包括程序bug和逻辑bug）的办法，就是好办法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;笔者在第三次作业中，从ubuntu系统&lt;code&gt;ssh&lt;/code&gt;的DEBUG模式获得了一些灵感，自己开发了一个可用于快速debug的分级debug信息输出控制模块。（更多信息详见&lt;a href=&quot;http://www.cnblogs.com/HansBug/p/8701447.html&quot;&gt;【技巧】Java工程中的Debug信息分级输出接口&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;实践表明，笔者使用此输出调试时，&lt;strong&gt;一样可以很快的定位错误&lt;/strong&gt;，甚至还具备了一般的debugger较为欠缺的逻辑bug发现能力（实际上debugger使用者一般容易更多的倾向于局部的程序bug，而具有连贯前后文的输出调试则可以很&lt;strong&gt;立体的将逻辑bug展现&lt;/strong&gt;在你面前）。&lt;/p&gt;
&lt;p&gt;以及，再次声明，说这些，不是在反对使用debugger。而是想告诉各位，&lt;strong&gt;适合自己的，就是最好的&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;代码规范不重要&quot;&gt;代码规范不重要？&lt;/h2&gt;
&lt;p&gt;之前，在QQ群上讨论了一下代码风格的问题，然后马上就有一位ACM大佬，出来对这件事情嗤之以鼻。&lt;/p&gt;
&lt;p&gt;这位大佬的逻辑大概是——代码风格好就没bug了？代码乱七八糟就有bug了？&lt;/p&gt;
&lt;p&gt;好，不说别的。首先，问问各位，出自你们自己之手的电梯程序，如果全篇没有一个注释，代码写的乱七八糟，到处都是奇奇怪怪的英文缩写甚至中英文混搭，大小写也在乱用。&lt;/p&gt;
&lt;p&gt;请问，一个月后你们自己拿来再看看，你还能记得多少，随便找个方法你能讲得出来参数都什么意义返回的是啥不？&lt;strong&gt;事实证明，基本没人能做到，甚至可以说大部分代码都不记得了&lt;/strong&gt;（是的，不要对人类的那点记性太过乐观）。&lt;/p&gt;
&lt;p&gt;然而实际上，独立的开发是很少见的，哪里有项目开发，哪里就有teamwork。你拿着一个自己都看不明白甚至都不愿意看的程序，来和别人合作完成项目，指望别人比你自己还了解你的程序？然后别人根本用不了，你得改来改去。后来，别人终于调用上去了，然后由于各种奇奇怪怪的问题导致不兼容（不可能？自己去看看阿里Java手册，这种事情多得是）。这开发效率可能有多高呢？&lt;strong&gt;在这个时间就是金钱就是机遇的时代，把大量时间浪费在这种本可以避免的地方，无异于自掘坟墓&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然后好不容易终于跑起来了，下次再维护，发现之前的代码又带来了各种坑，又得继续从自己挖的坑里头爬出来继续挖坑再跳进去。。。。&lt;strong&gt;毫无疑问，这分明是一个恶性循环&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;试想，如果你是个人开发者，你的代码严格遵循一定的规范，并按照规范写了注释。那么&lt;strong&gt;无论过了多久，你都能很快的看明白自己的程序并进行有效的维护&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果你是开发团队，严格遵循了代码规范，那么在不同人代码对接的时候，大家遵循的都是同一个标准，&lt;strong&gt;可以减少很多不必要的沟通麻烦和兼容性问题，极大的提高开发效率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而对于纯算法竞赛选手，他们写程序的模式永远就是 &lt;code&gt;写代码&lt;/code&gt;-&amp;gt;&lt;code&gt;调试&lt;/code&gt;-&amp;gt;&lt;code&gt;AC&lt;/code&gt;-&amp;gt;&lt;code&gt;AC不掉继续调试&lt;/code&gt;-&amp;gt;&lt;code&gt;AC&lt;/code&gt;-&amp;gt;&lt;code&gt;写题解&lt;/code&gt;-&amp;gt;&lt;code&gt;扔掉&lt;/code&gt; 这么几个步骤。而比赛场上（ACM为例）一共就五个小时（而且一般还都是各写各的，所谓的teamwork也仅仅是交流思路），平时刷题一个题撑死了也没几天（甚至很多题就是几小时几十分钟的事），&lt;strong&gt;完全没有任何长期维护和团队开发的需求&lt;/strong&gt;在内，他们当然会选择怎么用的爽怎么来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;忽略代码规范重要性的，只能说他们根本没体验过被自己挖的坑坑无数遍的痛苦，更不懂效率对于一个项目（尤其是初创项目）的重要性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;此外，对于有些常数优化控，且不说在现代的编译环境下你们那一套还能不能奏效，就算都奏效，请自己上腾讯云看看&lt;strong&gt;云服务器一个月多少钱&lt;/strong&gt;，再看看一个科班出身的&lt;strong&gt;程序猿一个月工资多少钱&lt;/strong&gt;，谁轻谁重自己掂量掂量吧。。。&lt;/p&gt;
</description>
<pubDate>Mon, 02 Apr 2018 19:04:00 +0000</pubDate>
<dc:creator>HansBug</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HansBug/p/8694939.html</dc:identifier>
</item>
<item>
<title>UWP 页面间传递参数（常见类型string、int以及自定义类型） - 星期八再娶你</title>
<link>http://www.cnblogs.com/hupo376787/p/8697703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hupo376787/p/8697703.html</guid>
<description>&lt;p&gt;这是一篇很基础的，大佬就不要看了，也不要喷，谢谢🌺🐔😂😂😂。&lt;/p&gt;

&lt;p&gt;在看实例之前，我们先看一下页面导航Navigate的定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Navigate(Type sourcePageType);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Navigate(Type sourcePageType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; parameter);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Navigate(Type sourcePageType, &lt;span&gt;object&lt;/span&gt; parameter, NavigationTransitionInfo infoOverride);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有三种方法，其中两种是可以传递参数的&lt;/p&gt;

&lt;p&gt;传递分两种，一种带参数的，一种利用全局变量。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 1.带parameter类型的传递&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 看一个小李子：&lt;/p&gt;
&lt;p&gt;xaml代码定义很简单，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            &amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;Name: &quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBox &lt;/span&gt;&lt;span&gt;Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; x:Name&lt;/span&gt;&lt;span&gt;=&quot;txtName&quot;&lt;/span&gt;&lt;span&gt; PlaceholderText&lt;/span&gt;&lt;span&gt;=&quot;Enter name here&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Age: &quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBox &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; x:Name&lt;/span&gt;&lt;span&gt;=&quot;txtAge&quot;&lt;/span&gt;&lt;span&gt; PlaceholderText&lt;/span&gt;&lt;span&gt;=&quot;Enter age here&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;Weight: &quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBox &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; x:Name&lt;/span&gt;&lt;span&gt;=&quot;txtWeight&quot;&lt;/span&gt;&lt;span&gt; PlaceholderText&lt;/span&gt;&lt;span&gt;=&quot;Enter weight here&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;Pass Name&quot;&lt;/span&gt;&lt;span&gt; Click&lt;/span&gt;&lt;span&gt;=&quot;PassName&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Content&lt;/span&gt;&lt;span&gt;=&quot;Pass Object&quot;&lt;/span&gt;&lt;span&gt; Click&lt;/span&gt;&lt;span&gt;=&quot;PassObject&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/298986/201804/298986-20180402205450203-2098315598.png&quot; alt=&quot;&quot; width=&quot;580&quot; height=&quot;321&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要看一下后台的实现，以及参数是如何传递的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PassName(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txtName.Text.Trim() == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;Frame.Navigate(typeof(ResultPage), txtName.Text.Trim());&lt;/span&gt;&lt;span&gt;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PassObject(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txtName.Text.Trim() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || txtAge.Text.Trim() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || txtWeight.Text.Trim() == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User
            {
                Name &lt;/span&gt;=&lt;span&gt; txtName.Text.Trim(),
                Age &lt;/span&gt;=&lt;span&gt; Convert.ToInt32(txtAge.Text.Trim()),
                Weight &lt;/span&gt;=&lt;span&gt; Convert.ToDouble(txtWeight.Text.Trim())
            };
            &lt;/span&gt;&lt;span&gt;Frame.Navigate(typeof(ResultPage), user);&lt;/span&gt;&lt;span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后新增一个User.cs文件类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class User
    {
        public string Name { get; set; }
        public int Age { get; set; }
        public double Weight { get; set; }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在结果页面ResultPage：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBox &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;txtResult&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button &lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;=&quot;Back to MainPage&quot;&lt;/span&gt;&lt;span&gt; Click&lt;/span&gt;&lt;span&gt;=&quot;Back&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;后台需要&lt;span&gt;&lt;strong&gt;&lt;span&gt;重写OnNavigatedTo&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;，因为我们需要一进入结果页面，就对传递进来的参数进行处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnNavigatedTo(NavigationEventArgs e)
        {
&lt;/span&gt;&lt;span&gt;            if&lt;/span&gt; (e.Parameter.GetType().Equals(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(User)))
            {
                User user &lt;/span&gt;= &lt;span&gt;(User)e.Parameter;&lt;/span&gt;
                txtResult.Text = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name: {user.Name}  Age: {user.Age}  Weight: {user.Weight}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e.Parameter.GetType().Equals(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)))
            {
                txtResult.Text &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name: {e.Parameter.ToString()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;点击主页面的传递按钮，在结果页面就可以看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/298986/201804/298986-20180402211450569-358051699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;User对象被传递了过来&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 利用全局变量传递&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此方法不要parameter了，只需要在App.xaml.cs里面定义全局变量即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; g_string;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; User g_user = &lt;span&gt;new&lt;/span&gt; User();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用的时候么，前面加上(Application.Current as App).即可。&lt;/p&gt;

&lt;p&gt;还是前面的例子，传递User&lt;/p&gt;
&lt;p&gt;MainPage后台只需要写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PassObject(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (txtName.Text.Trim() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || txtAge.Text.Trim() == &lt;span&gt;&quot;&quot;&lt;/span&gt; || txtWeight.Text.Trim() == &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User
            {
                Name &lt;/span&gt;=&lt;span&gt; txtName.Text.Trim(),
                Age &lt;/span&gt;=&lt;span&gt; Convert.ToInt32(txtAge.Text.Trim()),
                Weight &lt;/span&gt;=&lt;span&gt; Convert.ToDouble(txtWeight.Text.Trim())
            };

            (Application.Current &lt;/span&gt;&lt;span&gt;as&lt;/span&gt; App).g_user =&lt;span&gt; user;//划重点
            Frame.Navigate(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(ResultPage));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意Navigate 不加参数了哦&lt;/p&gt;
&lt;p&gt;在ResultPage里面写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnNavigatedTo(NavigationEventArgs e)
        {
            User user &lt;/span&gt;= (Application.Current &lt;span&gt;as&lt;/span&gt; App).g_user;
            txtResult.Text = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name: {user.Name}  Age: {user.Age}  Weight: {user.Weight}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即可。&lt;/p&gt;

</description>
<pubDate>Mon, 02 Apr 2018 17:01:00 +0000</pubDate>
<dc:creator>星期八再娶你</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hupo376787/p/8697703.html</dc:identifier>
</item>
<item>
<title>Spring框架入门 - 佳先森</title>
<link>http://www.cnblogs.com/cailijia52o/p/8699845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cailijia52o/p/8699845.html</guid>
<description>&lt;p&gt;&lt;span&gt;　◆功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　&lt;/span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;span&gt;　　----------------百度百科&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;控制反转（Inversion of Control，英文缩写为IoC）把创建对象的权利交给框架,是框架的重要特征，并非面向对象编程的专用术语。它包括依赖注入和依赖查找。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;传统的业务层，当需要资源时就在该业务层&lt;/span&gt;new&lt;span&gt;资源，这样耦合性（程序之间相互依赖关联）较高。现在将&lt;/span&gt;new&lt;span&gt;的部分交给&lt;/span&gt;spring&lt;span&gt;&lt;span&gt;&lt;span&gt;，做到高内聚低耦合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;简而言之：原先是每当调用&lt;/span&gt;dao&lt;span&gt;层或&lt;/span&gt;service&lt;span&gt;层方法时，由&lt;/span&gt;app&lt;span&gt;来&lt;/span&gt;new&lt;span&gt;，现在是将&lt;/span&gt;new&lt;span&gt;的权利交给&lt;/span&gt;spring&lt;span&gt;，要什么资源从&lt;/span&gt;spring&lt;span&gt;中获取！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;519.31892946058&quot;&gt;　　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180402194136411-1762223274.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;　　 其实基本核心jar有beans;context;core;expression包，其他是依赖log4j日志。当然spring的jar不止这些，后期慢慢加上。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;3.配置log4j配置文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 日志文件定义在src目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;### direct log messages to stdout ###
log4j.appender.stdout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target&lt;/span&gt;=&lt;span&gt;System.err
log4j.appender.stdout.layout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern&lt;/span&gt;=%d{ABSOLUTE} %5p %c{&lt;span&gt;1&lt;/span&gt;}:%L - %m%&lt;span&gt;n

### direct messages to file mylog.log ###
log4j.appender.file&lt;/span&gt;=&lt;span&gt;org.apache.log4j.FileAppender
log4j.appender.file.File&lt;/span&gt;=&lt;span&gt;c\:mylog.log
log4j.appender.file.layout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern&lt;/span&gt;=%d{ABSOLUTE} %5p %c{&lt;span&gt;1&lt;/span&gt;}:%L - %m%&lt;span&gt;n

### &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; log levels - &lt;span&gt;for&lt;/span&gt; more verbose logging change &lt;span&gt;'&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; to &lt;span&gt;'&lt;/span&gt;&lt;span&gt;debug&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ###

log4j.rootLogger&lt;/span&gt;=info, stdout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　4.测试日志文件是否部署成功&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.clj.demo1;

import org.apache.log4j.Logger;
import org.junit.Test;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 演示日志用法
 * @author Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建日志类&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Logger log=Logger.getLogger(Demo1.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以将log4j.rootLogger属性中的info改为off则不会再控制台显示&lt;/span&gt;
        log.info(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行了&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;&lt;span&gt;　5.定义一个接口和实现类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo2;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserService {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo2;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
        System.out.println(&lt;/span&gt;&quot;初始化。。&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello() {
        System.out.println(&lt;/span&gt;&quot;Hello Spring&quot;+&quot;\t&quot;+&lt;span&gt;name);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destory(){
        System.out.println(&lt;/span&gt;&quot;销毁。。&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　6.定义spring专属的配置文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　  &lt;span&gt;定义名为applicationContext.xml,位置为src下，与日志文件同目录，导入相对应的约束，并将实现类注入到配置文件中&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:p&lt;/span&gt;=&quot;http://www.springframework.org/schema/p&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;
&lt;/span&gt;        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;&lt;/span&gt;
     &amp;lt;!--&lt;span&gt; 使用bean标签  
         &lt;/span&gt;1&lt;span&gt;.id值唯一（必写）
        &lt;/span&gt;2&lt;span&gt;.注意：class为实现类路径，不是接口（必写）
        &lt;/span&gt;3.init-&lt;span&gt;method核心方法执行之前初始化工作（选写）
        &lt;/span&gt;4.destroy-method核心方法执行之后初始化工作（选写）--&amp;gt;
     &amp;lt;bean id=&quot;userService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo2.UserServiceImpl&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&amp;gt;
         &amp;lt;property name=&quot;name&quot; value=&quot;佳先森&quot;&amp;gt;&amp;lt;/property&amp;gt;
     &amp;lt;/bean&amp;gt;&lt;br/&gt;&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 &lt;strong&gt;&lt;span&gt;7.测试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1 {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 原始方式
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建实现类&lt;/span&gt;
        UserServiceImpl s=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserServiceImpl();
        s.setName(&lt;/span&gt;&quot;佳先森&quot;&lt;span&gt;);
        s.sayHello();
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 老的工厂版本BeanFactory
     * 旧的工厂不会创建配置文件对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run2(){
        BeanFactory factory&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; XmlBeanFactory(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;applicationContext.xml&quot;&lt;span&gt;));
        UserService us&lt;/span&gt;=(UserService)factory.getBean(&quot;userService&quot;&lt;span&gt;);
        us.sayHello();
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用spring框架IOC方式
     * 新版本factory创建启动服务器会创建配置文件对象，再次调用时无需加载工厂
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run3(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建工厂，加载核心配置文件(ClassPathXmlApplicationContext从src下找)&lt;/span&gt;
        ApplicationContext ac=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从工厂中获取到对象(配置文件中的id值,这里用了多态)&lt;/span&gt;
        UserService usi=(UserService) ac.getBean(&quot;userService&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用对象的方法执行&lt;/span&gt;
&lt;span&gt;        usi.sayHello();
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 演示destroy-method方法
     * bean摧毁方法不会自动执行
     * 除非scope= singleton或者web容器中会自动调用，但是main函数或测试用例需要手动调用（需要使用ClassPathXmlApplicationContext的close()方法）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run4(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建工厂，加载核心配置文件(ClassPathXmlApplicationContext从src下找)&lt;/span&gt;
        ClassPathXmlApplicationContext ac=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从工厂中获取到对象(配置文件中的id值,这里用了多态)&lt;/span&gt;
        UserService usi=(UserService) ac.getBean(&quot;userService&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用对象的方法执行&lt;/span&gt;
&lt;span&gt;        usi.sayHello();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ApplicationContext实现类提供close方法，将工厂关闭就可执行destory-method方法&lt;/span&gt;
&lt;span&gt;        ac.close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　 &lt;span&gt;其中旧工厂与新工厂的区别 &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * BeanFactory和ApplicationContext的区别&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * BeanFactory               -- BeanFactory采取延迟加载，第一次getBean时才会初始化Bean&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * ApplicationContext      -- 在加载applicationContext.xml时候就会创建具体的Bean对象的实例，还提供了一些其他的功能&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;            * 事件传递&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;            * Bean自动装配&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;            * 各种不同应用层的Context实现&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　总结：这是个最基本的demo，是将实现类配置到了spring配置文件中，每次启动服务器时，就会加载配置文件，从而实例化了实现类&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;16&quot;&gt;&lt;strong&gt;&lt;span&gt;四、spring之依赖注入&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　&lt;strong&gt;1、什么是依赖注入？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;Spring 能有效地组织J2EE应用各层的对象。不管是控制层的Action对象，还是业务层的Service对象，还是持久层的DAO对象，都可在Spring的 管理下有机地协调、运行。Spring将各层的对象以松耦合的方式组织在一起，Action对象无须关心Service对象的具体实现，Service对 象无须关心持久层对象的具体实现，各层对象的调用完全面向接口。当系统需要重构时，代码的改写量将大大减少。&lt;/span&gt;&lt;span&gt;依赖注入让bean与bean之间以配置文件组织在一起，而不是以硬编码的方式耦合在一起。理解依赖注入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    依赖注入(Dependency Injection)和控制反转(Inversion of Control)是同一个概念。具体含义是:当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者 实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管是依赖注入，还是控制反转，都说明Spring采用动态、灵活的方式来管理各种对象。对象与对象之间的具体实现互相透明。&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;2. IOC和DI的概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　* IOC -- Inverse of Control，控制反转，将对象的创建权反转给Spring！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　* DI -- Dependency Injection，依赖注入，在Spring框架负责创建Bean对象时，动态的将依赖对象注入到Bean组件中！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;3.演示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;对于类成员变量，常用的注入方式有两种&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;       属性set方法注入和构造方法注入&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;      先演示第一种：属性set方法注入&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 1）持久层&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo3;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomerDaoImpl {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(){
        System.out.println(&lt;/span&gt;&quot;我是持久层的Dao&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 2）业务层&lt;/p&gt;
&lt;p&gt;　　 注意：此时是想将持久层注入到业务层，将创建持久层实例权利交给框架，条件是业务层必须提供持久层的成员属性和set方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo3;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 依赖注入之将dao 层注入到service层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomerServiceImpl{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供成员属相，提供set方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerDaoImpl customerDao;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerDao(CustomerDaoImpl customerDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerDao =&lt;span&gt; customerDao;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(){
        System.out.println(&lt;/span&gt;&quot;我是业务层的service...&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.原始方式
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new CustomerDaoImpl().save();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.spring 之IOC方式&lt;/span&gt;
&lt;span&gt;        customerDao.save();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 3）配置文件配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- 演示依赖注入 --&amp;gt;
     &amp;lt;bean id=&quot;customerDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo3.CustomerDaoImpl&quot;/&amp;gt;
     &amp;lt;bean id=&quot;customerService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo3.CustomerServiceImpl&quot;&amp;gt;
             &amp;lt;!-- 将Dao注入到service层 --&amp;gt;
            &amp;lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;&amp;gt;&amp;lt;/property&amp;gt;
     &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 4）测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * spring 依赖注入方式
     * 将dao层注入到service层
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run2(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建工厂，加载配置文件，customerService被创建，从而也创建了customerDao&lt;/span&gt;
        ApplicationContext context=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
        CustomerServiceImpl csi&lt;/span&gt;=(CustomerServiceImpl) context.getBean(&quot;customerService&quot;&lt;span&gt;);
        csi.save();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 第二种：构造方法注入&lt;/p&gt;
&lt;p&gt;　　1）pojo类并提供构造方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo4;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 演示的构造方法的注入方式
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Car1 {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cname;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Double price;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car1(String cname, Double price) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cname =&lt;span&gt; cname;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.price =&lt;span&gt; price;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Car1 [cname=&quot; + cname + &quot;, price=&quot; + price + &quot;]&quot;&lt;span&gt;;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 2）配置文件配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
         &amp;lt;!-- 演示构造方法注入方式 --&amp;gt;
     &amp;lt;bean id=&quot;car1&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo4.Car1&quot;&amp;gt;
         &amp;lt;!-- 写法一&amp;lt;constructor-arg name=&quot;cname&quot; value=&quot;宝马&quot;/&amp;gt;
         &amp;lt;constructor-arg name=&quot;price&quot; value=&quot;400000&quot;/&amp;gt; --&amp;gt;
         &amp;lt;!--写法二 --&amp;gt;
         &amp;lt;constructor-arg index=&quot;0&quot; value=&quot;宝马&quot;/&amp;gt;
         &amp;lt;constructor-arg index=&quot;1&quot; value=&quot;400000&quot;/&amp;gt;
       &amp;lt;/bean&amp;gt;      
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run1(){
        ApplicationContext ac&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
        Car1 car&lt;/span&gt;=(Car1) ac.getBean(&quot;car1&quot;&lt;span&gt;);
        System.out.println(car);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　  拓展：构造方法之将一个对象注入到另一个对象中&lt;/p&gt;
&lt;p&gt;　　 1）pojo类：目的：将上列中的车注入到人类，使之成为其中一个属性，则必须在此类中提供车的成员属性，并提供有参构造方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo4;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Car1 car1;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String name, Car1 car1) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.car1 =&lt;span&gt; car1;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person [name=&quot; + name + &quot;, car1=&quot; + car1 + &quot;]&quot;&lt;span&gt;;
    }
    
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 2）配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
         &amp;lt;!-- 构造方法之将一个对象注入到另一个对象--&amp;gt;
     &amp;lt;bean id=&quot;person&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo4.Person&quot;&amp;gt;
         &amp;lt;constructor-arg name=&quot;name&quot; value=&quot;佳先森&quot;/&amp;gt;
         &amp;lt;constructor-arg name=&quot;car1&quot; ref=&quot;car1&quot;/&amp;gt;
     &amp;lt;/bean&amp;gt;         
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;&lt;span&gt;　4.如何注入集合数组&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 1）定义pojo类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo4;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Arrays;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Properties;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 演示集合注入的方式
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] arrs;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; list;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; sets;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String,String&amp;gt;&lt;span&gt; map;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Properties pro;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPro(Properties pro) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pro =&lt;span&gt; pro;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setSets(Set&amp;lt;String&amp;gt;&lt;span&gt; sets) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sets =&lt;span&gt; sets;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setMap(Map&amp;lt;String, String&amp;gt;&lt;span&gt; map) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.map =&lt;span&gt; map;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setList(List&amp;lt;String&amp;gt;&lt;span&gt; list) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; list;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setArrs(String[] arrs) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.arrs =&lt;span&gt; arrs;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;User [arrs=&quot; + Arrays.toString(arrs) + &quot;, list=&quot; +&lt;span&gt; list
                &lt;/span&gt;+ &quot;, sets=&quot; + sets + &quot;, map=&quot; + map + &quot;, pro=&quot; + pro + &quot;]&quot;&lt;span&gt;;
    }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
     &amp;lt;!-- 注入集合 --&amp;gt;
     &amp;lt;bean id=&quot;user&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo4.User&quot;&amp;gt;
         &amp;lt;!-- 数组 --&amp;gt;
         &amp;lt;property name=&quot;arrs&quot;&amp;gt;
             &amp;lt;list&amp;gt;
                 &amp;lt;value&amp;gt;数字1&amp;lt;/value&amp;gt;
                 &amp;lt;value&amp;gt;数字2&amp;lt;/value&amp;gt;
                 &amp;lt;value&amp;gt;数字3&amp;lt;/value&amp;gt;
             &amp;lt;/list&amp;gt;
         &amp;lt;/property&amp;gt;
         &amp;lt;!-- list集合 --&amp;gt;
         &amp;lt;property name=&quot;list&quot;&amp;gt;
             &amp;lt;list&amp;gt;
                 &amp;lt;value&amp;gt;金在中&amp;lt;/value&amp;gt;
                 &amp;lt;value&amp;gt;王杰&amp;lt;/value&amp;gt;
             &amp;lt;/list&amp;gt;
         &amp;lt;/property&amp;gt;
         &amp;lt;!-- set集合 --&amp;gt;
         &amp;lt;property name=&quot;sets&quot;&amp;gt;
             &amp;lt;set&amp;gt;
                 &amp;lt;value&amp;gt;哈哈&amp;lt;/value&amp;gt;
                 &amp;lt;value&amp;gt;呵呵&amp;lt;/value&amp;gt;
             &amp;lt;/set&amp;gt;
         &amp;lt;/property&amp;gt;
         &amp;lt;!-- map集合 --&amp;gt;
         &amp;lt;property name=&quot;map&quot;&amp;gt;
             &amp;lt;map&amp;gt;
                 &amp;lt;entry key=&quot;aa&quot; value=&quot;rainbow&quot;/&amp;gt;
                 &amp;lt;entry key=&quot;bb&quot; value=&quot;hellowvenus&quot;/&amp;gt;
             &amp;lt;/map&amp;gt;
         &amp;lt;/property&amp;gt;
         &amp;lt;!-- 属性文件 --&amp;gt;
         &amp;lt;property name=&quot;pro&quot;&amp;gt;
             &amp;lt;props&amp;gt;
                 &amp;lt;prop key=&quot;username&quot;&amp;gt;root&amp;lt;/prop&amp;gt;
                 &amp;lt;prop key=&quot;password&quot;&amp;gt;123&amp;lt;/prop&amp;gt;
             &amp;lt;/props&amp;gt;
         &amp;lt;/property&amp;gt;
     &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 3）测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 测试注入集合
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run3(){
        ApplicationContext ac&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
        User user&lt;/span&gt;= (User) ac.getBean(&quot;user&quot;&lt;span&gt;);
        System.out.println(user);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 &lt;strong&gt;&lt;span&gt;5.怎么分模块开发&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 在主配置文件加入&lt;strong&gt;&amp;lt;import&amp;gt;&lt;/strong&gt;标签&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;假如此时在com.clj.test包下定义了一个配置文件applicationContext2.xml&lt;/span&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　  &amp;lt;!-- 分模块开发之引入其他配置文件 --&amp;gt;
     &amp;lt;&lt;span&gt;import&lt;/span&gt; resource=&quot;com/clj/test/applicationContext2.xml&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;五、详解&lt;strong&gt;Spring框架的IOC之注解方式&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;1、入门&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;span&gt;　1）.导入jar包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　 除了先前6个包，玩注解还需一个&lt;strong&gt;spring-aop&lt;/strong&gt;包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180402211358472-670034252.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2）.持久层和实现层(这里忽略接口)&lt;/p&gt;
&lt;p&gt;　　 持久层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo1;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.annotation.Scope;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Repository;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * UserDaoImpl交给IOC的容器管理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save() {
        System.out.println(&lt;/span&gt;&quot;保存客户。。&quot;&lt;span&gt;);
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 业务层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo1;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.PostConstruct;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService{&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello() {
        System.out.println(&lt;/span&gt;&quot;Hello spring&quot;+&lt;span&gt;name);
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 3）.定义配置文件&lt;/p&gt;
&lt;p&gt;　　 此时约束条件需添加context约束，并添加组件扫描&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt; &amp;lt;!-- bean definitions here --&amp;gt;&lt;/span&gt;
    &amp;lt;!-- 开启注解扫面 :base-package指定扫面对 包--&amp;gt;
    &amp;lt;context:component-scan base-&lt;span&gt;package&lt;/span&gt;=&quot;com.clj.demo1&quot;/&amp;gt;&lt;br/&gt;&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4）在实现类中添加注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 组件注解,可以用来标记当前的类
 * 类似&amp;lt;bean id=&quot;userService&quot; class=&quot;com.clj.demo1.UserServiceImpl&quot;&amp;gt;
 * value表示给该类起个别名
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component(value&lt;/span&gt;=&quot;userService&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5）编写测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注解方式
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run2(){
        ApplicationContext ac&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
        UserService us&lt;/span&gt;=(UserService) ac.getBean(&quot;userService&quot;&lt;span&gt;);
        us.sayHello();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　&lt;span&gt;　2.关于bean管理常用属性&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;. @Component:组件.(作用在类上)  最原始的注解，所有需要注解的类都写这个没问题，他是通用的
&lt;/span&gt;2&lt;span&gt;. Spring中提供@Component的三个衍生注解:(功能目前来讲是一致的)
    &lt;/span&gt;* @Controller       --&lt;span&gt; 作用在WEB层
    &lt;/span&gt;* @Service          --&lt;span&gt; 作用在业务层
    &lt;/span&gt;* @Repository       --&lt;span&gt; 作用在持久层
    &lt;/span&gt;*&lt;span&gt; 说明：这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强
 
&lt;/span&gt;3&lt;span&gt;. 属性注入的注解(说明：使用注解注入的方式,可以不用提供set方法)
    &lt;/span&gt;*&lt;span&gt; 如果是注入的普通类型，可以使用value注解
    &lt;/span&gt;* @Value             --&lt;span&gt; 用于注入普通类型
    &lt;/span&gt;*&lt;span&gt; 如果注入的是对象类型，使用如下注解
        &lt;/span&gt;* @Autowired        --&lt;span&gt; 默认按类型进行自动装配   匹配的是类型，与注入类的类名无关
            &lt;/span&gt;*&lt;span&gt; 如果想按名称注入
            &lt;/span&gt;* @Qualifier    --&lt;span&gt; 强制使用名称注入            必须与Autowired一起用，指定类名，与注入的类名有关
        &lt;/span&gt;* @Resource         --&lt;span&gt; 相当于@Autowired和@Qualifier一起使用
        &lt;/span&gt;*&lt;span&gt; 强调：Java提供的注解
        &lt;/span&gt;* 属性使用name属性
&lt;/pre&gt;
&lt;p class=&quot;16&quot;&gt;4. Bean的作用范围注解&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * 注解为@Scope(value=&quot;prototype&quot;)，作用在类上。值如下：&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;        * singleton     -- 单例，默认值&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;        * prototype     -- 多例&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;5. Bean的生命周期的配置（了解）&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * 注解如下：&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;        * @PostConstruct    -- 相当于init-method&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;        * @PreDestroy       -- 相当于destroy-method&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;1.演示属性对象注解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 条件：采用扫描的方式将属性(name)和对象（userDaoImpl)注入到业务层中&lt;/p&gt;
&lt;p&gt;　　1）持久层开启注解扫描Repository&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Component(value=&quot;userDao&quot;)通用类注解&lt;/span&gt;
@Repository(value=&quot;ud&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save() {
        System.out.println(&lt;/span&gt;&quot;保存客户。。&quot;&lt;span&gt;);    
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 2）业务层针对属性和对象提供注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo1;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.PostConstruct;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Qualifier;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Value;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 组件注解,可以用来标记当前的类
 * 类似&amp;lt;bean id=&quot;userService&quot; class=&quot;com.clj.demo1.UserServiceImpl&quot;&amp;gt;
 * value表示给该类起个别名
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Scope(value=&quot;grototype&quot;)多列的(singletype为单列)&lt;/span&gt;
@Component(value=&quot;userService&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserService{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性注解：相当于给name属性注入指定的字符串，setName方法可以省略不写&lt;/span&gt;
    @Value(value=&quot;佳先森&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 引用注入方式一：Autowired()
     * 引用注入方式二：Autowired()+Qualifier
     * 引用注入方式三：@Resource(name=&quot;userDao&quot;) java方式，按名称识别注入
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Autowired()按类型自动装配注入(缺点：因为是按类型匹配，所以不是很准确)&lt;/span&gt;
&lt;span&gt;    @Autowired()
    @Qualifier(value&lt;/span&gt;=&quot;ud&quot;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按名称注入，得与Autowired一起用，两者一起能指定类&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserDao userDao;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意Qualifier中的value是指定UserDaoImpl类名顶上的注解名,也可以指定配置文件中bean的id名&lt;/span&gt;
    
    
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;public void setName(String name) {
        this.name = name;
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sayHello() {
        System.out.println(&lt;/span&gt;&quot;Hello spring&quot;+&lt;span&gt;name);
        userDao.save();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@PostConstruct标签用于action生命周期中初始化的注解&lt;/span&gt;
&lt;span&gt;    @PostConstruct
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
        System.out.println(&lt;/span&gt;&quot;初始化...&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：至于集合还是推荐使用配置文件方式&lt;/p&gt;
&lt;h3&gt;　　&lt;span&gt;2.&lt;strong&gt;Spring框架整合JUnit单元测试&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;1）添加单元测试所需依赖包&lt;/span&gt;&lt;strong&gt;spring-test.jar&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180403003656065-1768191746.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　注意：基于myeclipes自带Junit环境，但是有时因为版本问题，可能需要比较新的Junit环境，这里我在网上下了一个教新的 Junit-4.9的jar包，如果myeclipes较新的话无须考虑&lt;/p&gt;
&lt;p&gt;　　2）编写测试类，添加相对应的注解&lt;/p&gt;
&lt;p&gt;　　 @RunWith与@ContextConfiguration（此是用于加载配置文件，因为默认从WebRoot路径为一级目录，加上此是认定src为一级目录）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo2;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.demo1.UserService;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo2 {
    @Resource(name&lt;/span&gt;=&quot;userService&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService userService;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run1(){
        userService.sayHello();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;六.spring框架之AOP&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;　　1.什么是AOP&lt;/h3&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程&lt;span&gt;，功能模块化&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * AOP是一种编程范式，隶属于软工范畴，指导开发者如何组织程序结构&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * AOP最早由AOP联盟的组织提出的,制定了一套规范.Spring将AOP思想引入到框架中,必须遵守AOP联盟的规范&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * 通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * 利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，&lt;span&gt;提高程序的可重用性，同时提高了开发的效率&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　     AOP采取横向抽取机制，取代了传统纵向继承体系重复性代码（性能监视、事务管理、安全检查、缓存）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　&lt;strong&gt;2. 为什么要学习AOP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * &lt;span&gt;可以在不修改源代码的前提下，对程序进行增强！！&lt;/span&gt;&lt;span&gt;（为固定的方法生成一个代理，在访问该方法之前，先进入代理，在代理中，可以编写更多的功能，使之方法的功能更强，使得程序进行增        强）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        Aop:&lt;span&gt;面向切面编程，将一切事模块化，每个模块比较独立，模块可以共用（相同的），不同的格外自定义。用此替代传统的面向纵向编程，提高程序的可重用性&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;3.AOP的实现（实现原理）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;&lt;span&gt;　　 Aop的实现包含两种代理方式&amp;lt;1&amp;gt;实现类接口：采用JDK动态代理&amp;lt;2&amp;gt;未实现类接口：采用CGLIB动态代理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;&lt;span&gt;　　 1.实现JDK动态代理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;&lt;span&gt;　　 　1）定义持久层接口实现类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo3;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserDao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo3;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save() {
        System.out.println(&lt;/span&gt;&quot;保存用户&quot;&lt;span&gt;);
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update() {
        System.out.println(&lt;/span&gt;&quot;修改用户&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;16&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　 2）定义JDK动态代理工具类&lt;/p&gt;
&lt;p&gt;　　     此工具类是在执行持久层save方法时增加一些功能，在开发中做到在不更改源码情况下增强某方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo3;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 使用JDK的方式生成代理对象(演示AOP原理)
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyProxyUtils {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UserDao getProxy(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; UserDao dao){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Proxy类生成代理对象&lt;/span&gt;
        UserDao proxy=(UserDao)Proxy.newProxyInstance(dao.getClass().getClassLoader() , dao.getClass().getInterfaces(),&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InvocationHandler() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要代理对象一执行，invoke方法就会执行一次&lt;/span&gt;
            &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invoke(Object proxy, Method method, Object[] args)
                    &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;proxy代表当前代理对象
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;method当前对象执行的方法
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;args封装的参数
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让到类的save或者update方法正常执行下去&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(&quot;save&quot;&lt;span&gt;.equals(method.getName())){
                    System.out.println(&lt;/span&gt;&quot;执行了保存&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启事务&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; method.invoke(dao, args);
            }
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 3）测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo3;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1 {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取目标对象&lt;/span&gt;
        UserDao dao=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserDaoImpl();
        dao.save();
        dao.update();
        System.out.println(&lt;/span&gt;&quot;===============&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用工具类，获取到代理对象&lt;/span&gt;
        UserDao proxy=&lt;span&gt;MyProxyUtils.getProxy(dao);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用代理对象的方法&lt;/span&gt;
&lt;span&gt;        proxy.save();
        proxy.update();
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 &lt;strong&gt;&lt;span&gt;2.实现CGLIB技术&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　  1）定义持久层，此时没有接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo4;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BookDaoImpl {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(){
        System.out.println(&lt;/span&gt;&quot;保存图书&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(){
        System.out.println(&lt;/span&gt;&quot;修改图书&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 2）编写工具类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo4;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.Enhancer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.MethodInterceptor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.MethodProxy;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Cglib代理方式实现原理
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyCglibUtils {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 使用CGLIB方式生成代理对象
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; BookDaoImpl getProxy(){
        Enhancer enhancer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置父类&lt;/span&gt;
        enhancer.setSuperclass(BookDaoImpl.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置回调函数&lt;/span&gt;
        enhancer.setCallback(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MethodInterceptor() {
            
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object intercept(Object obj, Method method, Object[] objs,
                    MethodProxy methodProxy) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(method.getName().equals(&quot;save&quot;&lt;span&gt;)){
                System.out.println(&lt;/span&gt;&quot;我保存了&quot;&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;代理对象执行了&quot;&lt;span&gt;);
        }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; methodProxy.invokeSuper(obj, objs);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是方法执行下去&lt;/span&gt;
&lt;span&gt;            }
        });
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成代理对象&lt;/span&gt;
        BookDaoImpl proxy=&lt;span&gt;(BookDaoImpl) enhancer.create();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 3）编写测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo4;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1 {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目标对象&lt;/span&gt;
        BookDaoImpl dao=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookDaoImpl();
        dao.save();
        dao.update();
        System.out.println(&lt;/span&gt;&quot;==========&quot;&lt;span&gt;);
        BookDaoImpl proxy&lt;/span&gt;=&lt;span&gt;MyCglibUtils.getProxy();
        proxy.save();
        proxy.update();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 &lt;strong&gt;&lt;span&gt;3、Spring基于AspectJ的AOP的开发（配置文件方式）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180402221621044-506878621.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p class=&quot;16&quot;&gt; 　　1）部署环境，导入相对应的jar包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;　　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180402221945466-38997744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）创建配置文件，并引入AOP约束&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
           xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
           xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
           xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;
&lt;/span&gt;            http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
            http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）创建接口和实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo5;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; CustomerDao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo5;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 采用配置文件的方式 诠释AOP
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟异常
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int a=10/0;&lt;/span&gt;
        System.out.println(&quot;保存客户了啊&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;更新客户了啊&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 4）定义切面类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo5;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 切面类：切入点+通知
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAspectXml {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通知(具体的增强)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; log(){
        System.out.println(&lt;/span&gt;&quot;记录日志&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 方法执行成功或者异常都会执行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;最终通知&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 方法执行之后，执行后置通知，如果程序出现异常，后置通知不会执行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterReturn(){
        System.out.println(&lt;/span&gt;&quot;后置通知&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 方法执行之后，如果程序有异常，才会执行异常通知
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterThrowing(){
        System.out.println(&lt;/span&gt;&quot;异常通知&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 环绕通知：方法执行之前和方法执行之后进行通知，
     * 默认情况下，目标对象的方法不能执行的，需要手动让目标对象执行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; around(ProceedingJoinPoint joinPoint){
        System.out.println(&lt;/span&gt;&quot;环绕通知1&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手动让目标对象的方法执行&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            joinPoint.proceed();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }
        System.out.println(&lt;/span&gt;&quot;环绕通知2&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5）注入实现类和切面类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt; &amp;lt;!-- bean definitions here --&amp;gt;&lt;/span&gt;
    &amp;lt;!-- 配置客户的dao --&amp;gt;
    &amp;lt;bean id=&quot;customerDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo5.CustomerDaoImpl&quot;/&amp;gt;
    &amp;lt;!-- 编写切面类配置好 --&amp;gt;
    &amp;lt;bean id=&quot;myAspectXml&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo5.MyAspectXml&quot;/&amp;gt;
    &amp;lt;!-- 配置AOP --&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!-- 配置切面类:切入点+通知 (类型)--&amp;gt;
        &amp;lt;aop:aspect ref=&quot;myAspectXml&quot;&amp;gt;
            &amp;lt;!-- 配置前置通知，save方法执行之前，增强方法会执行 --&amp;gt;
            &amp;lt;!-- 切入点表达式：execution(&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; com.clj.demo5.CustomerDaoImpl.save()) --&amp;gt;
            &amp;lt;!--&lt;span&gt; 切入点表达式：
                &lt;/span&gt;1&lt;span&gt;.execution()固定的，必写
                &lt;/span&gt;2&lt;span&gt;.public可以省略不写
                &lt;/span&gt;3.返回值     必写,严格根据切入点方法而定，否则增强方法不会执行，可以用*&lt;span&gt;代替，表示任意的返回值
                &lt;/span&gt;4.包名      必写，可以用*代替(如：*..*(默认所有包); com.clj.*&lt;span&gt;)
                &lt;/span&gt;5.类名     必写，可以部分用*(如*DaoImpl表示以'DaoImpl'结尾的持久层实现类),但不建议用*&lt;span&gt;代替整个类名
                &lt;/span&gt;6.方法     必写，可以部分用*(如save*表示以'save'开头的方法),但不建议用*&lt;span&gt;代替整个类名
                &lt;/span&gt;7.方法参数 根据实际方法而定,可以用'..'&lt;span&gt;表示有0或者多个参数
             &lt;/span&gt;--&amp;gt;
            &amp;lt;!-- &amp;lt;aop:before method=&quot;log&quot; pointcut=&quot;execution(public void com.clj.*.CustomerDaoImpl.save(..))&quot;/&amp;gt; --&amp;gt;
            &amp;lt;aop:before method=&quot;log&quot; pointcut=&quot;execution(* *..*.*DaoImpl.save*(..))&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;
    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6）测试&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo5;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1 {
    @Resource(name&lt;/span&gt;=&quot;customerDao&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerDao customerDao;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        customerDao.save();
        customerDao.update();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　扩展：切面类升级&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&lt;span&gt;&quot;
&lt;/span&gt;        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop &lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;&lt;span&gt;&quot;&amp;gt; &amp;lt;!-- bean definitions here --&amp;gt;&lt;/span&gt;
    &amp;lt;bean id=&quot;myAspectXml&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo5.MyAspectXml&quot;/&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:aspect ref=&quot;myAspectXml&quot;&amp;gt;
            &amp;lt;!--&lt;span&gt; 配置最终通知 
            &lt;/span&gt;&amp;lt;aop:after method=&quot;after&quot; pointcut=&quot;execution(* *..*.*DaoImpl.save*(..))&quot;/&amp;gt;--&amp;gt;
            &amp;lt;!--&lt;span&gt; 配置后置通知 
            &lt;/span&gt;&amp;lt;aop:after-returning method=&quot;afterReturn&quot; pointcut=&quot;execution(* *..*.*DaoImpl.save*(..))&quot;/&amp;gt;--&amp;gt;
            &amp;lt;!--&lt;span&gt; 配置异常通知 
            &lt;/span&gt;&amp;lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut=&quot;execution(* *..*.*DaoImpl.save*(..))&quot;/&amp;gt;--&amp;gt;
            &amp;lt;aop:around method=&quot;around&quot; pointcut=&quot;execution(* *..*.*DaoImpl.update*(..))&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;
    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;4、Spring框架AOP之注解方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　  1）创建接口和实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo1;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; CustomerDao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo1;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;保存客户..&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;更新客户&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）定义切面类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo1;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.After;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Around;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Aspect;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.annotation.Pointcut;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 注解方式的切面类
 * @Aspect表示定义为切面类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Aspect
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyAspectAnno {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知类型：@Before前置通知(切入点的表达式)&lt;/span&gt;
    @Before(value=&quot;execution(public *     com.clj.demo1.CustomerDaoImpl.save())&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; log(){
        System.out.println(&lt;/span&gt;&quot;记录日志。。&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入切入点&lt;/span&gt;
    @After(value=&quot;MyAspectAnno.fun()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; after(){
        System.out.println(&lt;/span&gt;&quot;执行之后&quot;&lt;span&gt;);
    }
    @Around(value&lt;/span&gt;=&quot;MyAspectAnno.fun()&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; around(ProceedingJoinPoint joinPoint){
        System.out.println(&lt;/span&gt;&quot;环绕通知1&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;让目标对象执行&lt;/span&gt;
&lt;span&gt;            joinPoint.proceed();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;            e.printStackTrace();
        }
        System.out.println(&lt;/span&gt;&quot;环绕通知2&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义切入点&lt;/span&gt;
    @Pointcut(value=&quot;execution(public *     com.clj.demo1.CustomerDaoImpl.save())&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; fun(){
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）配置切面类和实现类，并开启自动代理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
    &amp;lt;!-- 开启自动注解代理--&amp;gt;
    &amp;lt;aop:aspectj-autoproxy/&amp;gt; 
    &amp;lt;!-- 配置目标对象 --&amp;gt;
    &amp;lt;bean id=&quot;customerDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo1.CustomerDaoImpl&quot;/&amp;gt;
    &amp;lt;!-- 配置切面类 --&amp;gt;
    &amp;lt;bean id=&quot;myAspectAnno&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo1.MyAspectAnno&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;七、Spring之JDBC&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;spring提供了JDBC模板：JdbcTemplate类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;1.快速搭建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　1）部署环境&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　这里在原有的jar包基础上，还要添加关乎jdbc的jar包，这里使用的是mysql驱动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180402224102929-1256320754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　 2）配置内置连接池，将连接数据库程序交给框架管理,并配置Jdbc模板类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
    &amp;lt;!-- 先配置连接池(内置) --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置JDBC的模板类--&amp;gt;
    &amp;lt;bean id=&quot;jdbcTemplate&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo2;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.ResultSet;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.sql.SQLException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.commons.dbcp.BasicDataSource;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.beans.BeanMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.JdbcTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.RowMapper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试JDBC的模板类，使用IOC的方式
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo2 {
    @Resource(name&lt;/span&gt;=&quot;jdbcTemplate&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JdbcTemplate jdbcTemplate;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run1(){
        String sql&lt;/span&gt;=&quot;insert into t_account values(null,?,?)&quot;&lt;span&gt;;
        jdbcTemplate.update(sql,&lt;/span&gt;&quot;李钇林&quot;,10000&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run2(){
        String sql&lt;/span&gt;=&quot;update t_account set name=? where id=?&quot;&lt;span&gt;;
        jdbcTemplate.update(sql,&lt;/span&gt;&quot;李钇林&quot;,1&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run3(){
        String sql&lt;/span&gt;=&quot;delete from t_account where id=?&quot;&lt;span&gt;;
        jdbcTemplate.update(sql,&lt;/span&gt;4&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 测试查询，通过主键来查询一条记录
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run4(){
        String sql&lt;/span&gt;=&quot;select * from t_account where id=?&quot;&lt;span&gt;;
        Account ac&lt;/span&gt;=jdbcTemplate.queryForObject(sql, &lt;span&gt;new&lt;/span&gt; BeanMapper(),1&lt;span&gt;);
        System.out.println(ac);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询所有
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run5(){
        String sql&lt;/span&gt;=&quot;select * from t_account&quot;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;Account&amp;gt; ac=jdbcTemplate.query(sql,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanMapper());
        System.out.println(ac);
    }
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 定义内部类（手动封装数据（一行一行封装数据，用于查询所有）
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; BeanMapper &lt;span&gt;implements&lt;/span&gt; RowMapper&amp;lt;Account&amp;gt;&lt;span&gt;{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Account mapRow(ResultSet rs, &lt;span&gt;int&lt;/span&gt; rowNum) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; SQLException {
        Account ac&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Account();
        ac.setId(rs.getInt(&lt;/span&gt;&quot;id&quot;&lt;span&gt;));
        ac.setName(rs.getString(&lt;/span&gt;&quot;name&quot;&lt;span&gt;));
        ac.setMoney(rs.getDouble(&lt;/span&gt;&quot;money&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ac;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 &lt;strong&gt;&lt;span&gt;2、配置开源连接池&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　  一般现在企业都是用一些主流的连接池，如c3p0和dbcp&lt;/p&gt;
&lt;p&gt;　　 首先配置dbcp&lt;/p&gt;
&lt;p&gt;　　1)导入dbcp依赖jar包&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180402230137381-1598295537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）编写配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!--&lt;span&gt; 配置DBCP开源连接池--&amp;gt; 
    &lt;/span&gt;&amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将模板类中引入的内置类datasource改为开源连接池的&lt;/p&gt;
&lt;p&gt;　　3）编写测试类&lt;/p&gt;
&lt;p&gt;　　配置c3p0&lt;/p&gt;
&lt;p&gt;　　1)导入c3p0依赖jar包&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180402230603719-1911052106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2）配置c3p0&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 配置C3P0开源连接池 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　将模板类中引入的内置类datasource改为开源连接池的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3）编写测试类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;八、Spring之事务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;1、什么是事务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1&quot; target=&quot;_blank&quot;&gt;数据库事务&lt;/a&gt;(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列&lt;a href=&quot;https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C/33052&quot; target=&quot;_blank&quot; data-lemmaid=&quot;33052&quot;&gt;操作&lt;/a&gt;，要么完全地执行，要么完全地不执行。 事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。一个逻辑工作单元要成为事务，必须满足所谓的ACID（原子性、一致性、隔离性和持久性）属性。事务是数据库运行中的逻辑工作单位，由DBMS中的事务管理子系统负责事务的处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　-----百度百科&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;&lt;span&gt;　&lt;span&gt;2、怎么解决事务安全性问题&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;读问题解决，设置数据库隔离级别;&lt;/span&gt;&lt;span&gt;写问题解决可以使用&lt;/span&gt; &lt;span&gt;悲观锁和乐观锁的方式解决&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;&lt;span&gt;　&lt;span&gt;3、快速开发&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 方式一：调用模板类，将模板注入持久层&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　1）编写相对应的持久层和也外层，这里省略接口&lt;/span&gt;　　&lt;/span&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo3;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.JdbcTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.support.JdbcDaoSupport;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccountDaoImpl &lt;span&gt;extends&lt;/span&gt; JdbcDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountDao{
   // &lt;/span&gt;&lt;span&gt;方式一：将jdbc模板类注入到配置文件中，直接在持久层写模板类
&lt;/span&gt;&lt;span&gt;      private JdbcTemplate jdbcTemplate;
      public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
          this.jdbcTemplate = jdbcTemplate;
      }

   &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; outMoney(String out, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {&lt;/span&gt;
        String sql=&quot;update t_account set money=money-? where name=?&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;&lt;span&gt;j&lt;/span&gt;&lt;/span&gt;&lt;span&gt;dbcTemplate().update(sql,money,out);
    }

    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; inMoney(String in, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        String sql&lt;/span&gt;=&quot;update t_account set money=money+? where name=?&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;&lt;span&gt;j&lt;/span&gt;&lt;/span&gt;&lt;span&gt;dbcTemplate().update(sql,money,in);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo4;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.TransactionStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionCallbackWithoutResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionTemplate;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccountServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountService{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;采用的是配置文件注入方式，必须提供set方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountDao accountDao;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAccountDao(AccountDao accountDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountDao =&lt;span&gt; accountDao;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pay(String out, String in, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        accountDao.outMoney(out, money);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=10/0&lt;span&gt;;
        accountDao.inMoney(in, money);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2)配置相对应的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
&amp;lt;!-- 配置C3P0开源连接池 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;!-- 配置JDBC的模板类 --&amp;gt;
    &amp;lt;bean id=&quot;jdbcTemplate&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;!-- 配置业务层和持久层 --&amp;gt;
    &amp;lt;bean id=&quot;accountService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo3.AccountServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;bean id=&quot;accountDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo3.AccountDaoImpl&quot;&amp;gt;
        &amp;lt;!--&lt;span&gt; 注入模板类--&amp;gt;
        &lt;/span&gt;&amp;lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&amp;gt;     
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3)测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo3;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1 {
    @Resource(name&lt;/span&gt;=&quot;accountService&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountService accountService;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Demo1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用支付的方法&lt;/span&gt;
        accountService.pay(&quot;佳先森&quot;,&quot;李钇林&quot;,100&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 方式二：持久层继承JdbcDaoSupport接口，此接口封装了模板类jdbcTemplate&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180402232924016-1841713059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　1）编写配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
    &amp;lt;!-- 配置C3P0开源连接池 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置业务层和持久层 --&amp;gt;
    &amp;lt;bean id=&quot;accountService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo3.AccountServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;accountDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo3.AccountDaoImpl&quot;&amp;gt;    
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）更改持久层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo3;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.JdbcTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.support.JdbcDaoSupport;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccountDaoImpl &lt;span&gt;extends&lt;/span&gt; JdbcDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountDao{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式一：将jdbc模板类注入到配置文件中，直接在持久层写模板类
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private JdbcTemplate jdbcTemplate;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        this.jdbcTemplate = jdbcTemplate;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式二：持久层继承JdbcDaoSupport,它里面封转了模板类，配置文件持久层无需注入模板类,也不需要配置模板类&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; outMoney(String out, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jdbcTemplate.update(psc);&lt;/span&gt;
        String sql=&quot;update t_account set money=money-? where name=?&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getJdbcTemplate().update(sql,money,out);
    }

    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; inMoney(String in, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        String sql&lt;/span&gt;=&quot;update t_account set money=money+? where name=?&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getJdbcTemplate().update(sql,money,in);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）更改业务层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo4;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.TransactionStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionCallbackWithoutResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionTemplate;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccountServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountService{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;采用的是配置文件注入方式，必须提供set方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountDao accountDao;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAccountDao(AccountDao accountDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountDao =&lt;span&gt; accountDao;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pay(String out, String in, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        accountDao.outMoney(out, money);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=10/0&lt;span&gt;;
        accountDao.inMoney(in, money);
    }
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4)测试类和上述一样&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;4、spring事务管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Spring为了简化事务管理的代码:提供了模板类 TransactionTemplate，所以手动编程的方式来管理事务，只需要使用该模板类即可！！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;九、Spring框架的事务管理之编程式的事务管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;span&gt;　&lt;strong&gt;1、&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;手动编程方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 1）快速部署，搭建配置文件,配置事务管理和事务管理模板，并在持久层注入事务管理模板&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
   
    &amp;lt;!-- 配置C3P0开源连接池 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;  
    &amp;lt;!-- 配置业务层和持久层 --&amp;gt;
    &amp;lt;bean id=&quot;accountService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo3.AccountServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&amp;gt;
        &amp;lt;property name=&quot;transactionTemplate&quot; ref=&quot;transactionTemplate&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;accountDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo3.AccountDaoImpl&quot;&amp;gt;   
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置平台事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 手动编码方式，提供了模板类，使用该类管理事务比较简单--&amp;gt;
    &amp;lt;bean id=&quot;transactionTemplate&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&amp;gt;
        &amp;lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　2）在业务层使用模板事务管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo3;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.TransactionStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionCallbackWithoutResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionTemplate;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccountServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountService{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;采用的是配置文件注入方式，必须提供set方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountDao accountDao;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入事务模板类&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; TransactionTemplate transactionTemplate;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAccountDao(AccountDao accountDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountDao =&lt;span&gt; accountDao;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setTransactionTemplate(TransactionTemplate transactionTemplate) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.transactionTemplate =&lt;span&gt; transactionTemplate;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 转账的方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pay(&lt;span&gt;final&lt;/span&gt; String out,&lt;span&gt;final&lt;/span&gt;  String in, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        transactionTemplate.execute(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TransactionCallbackWithoutResult() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事务的执行，如果没有问题，提交，如果楚翔异常，回滚&lt;/span&gt;
            &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doInTransactionWithoutResult(TransactionStatus arg0) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;                accountDao.outMoney(out, money);
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=10/0&lt;span&gt;;
                accountDao.inMoney(in, money);
            }
        });
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）测试类和上一致&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo4;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext2.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo2 {
    @Resource(name&lt;/span&gt;=&quot;accountService&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountService accountService;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Demo1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用支付的方法&lt;/span&gt;
        accountService.pay(&quot;佳先森&quot;,&quot;李钇林&quot;,100&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;十、&lt;/strong&gt;&lt;strong&gt;Spring框架的事务管理之声明式事务管理，即通过配置文件来完成事务管理(AOP思想)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　申明式事务有两种方式：&lt;/strong&gt;&lt;span&gt;基于&lt;/span&gt;AspectJ的XML方式;&lt;span&gt;基于&lt;/span&gt;AspectJ的注解方式&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;1、XML方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt;1）配置配置文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要配置平台事务管理&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 配置C3P0开源连接池 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置平台事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置事务增强&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;tx:advice id=&quot;myAdvice&quot; transaction-manager=&quot;transactionManager&quot;&amp;gt;
        &amp;lt;tx:attributes&amp;gt;
            &amp;lt;!-- 给方法设置数据库属性（隔离级别，传播行为） --&amp;gt;
            &amp;lt;!--propagation事务隔离级别：一般采用默认形式：tx:method可以设置多个  --&amp;gt;
            &amp;lt;tx:method name=&quot;pay&quot; propagation=&quot;REQUIRED&quot;/&amp;gt;
        &amp;lt;/tx:attributes&amp;gt;
    &amp;lt;/tx:advice&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　aop切面类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;aop:config&amp;gt;
        &amp;lt;!-- aop：advisor，是spring框架提供的通知--&amp;gt;
        &amp;lt;aop:advisor advice-ref=&quot;myAdvice&quot; pointcut=&quot;execution(public * com.clj.demo4.AccountServiceImpl.pay(..))&quot;/&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　全部代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
    &amp;lt;!-- 配置C3P0开源连接池 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置平台事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 申明式事务（采用XML文件的方式） --&amp;gt;
    &amp;lt;!-- 先配置通知 --&amp;gt;
    &amp;lt;tx:advice id=&quot;myAdvice&quot; transaction-manager=&quot;transactionManager&quot;&amp;gt;
        &amp;lt;tx:attributes&amp;gt;
            &amp;lt;!-- 给方法设置数据库属性（隔离级别，传播行为） --&amp;gt;
            &amp;lt;!--propagation事务隔离级别：一般采用默认形式：tx:method可以设置多个  --&amp;gt;
            &amp;lt;tx:method name=&quot;pay&quot; propagation=&quot;REQUIRED&quot;/&amp;gt;
        &amp;lt;/tx:attributes&amp;gt;
    &amp;lt;/tx:advice&amp;gt;
    &amp;lt;!-- 配置AOP:如果是自己编写的AOP,使用aop：aspect配置，使用的是Spring框架提供的通知 --&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!-- aop：advisor，是spring框架提供的通知--&amp;gt;
        &amp;lt;aop:advisor advice-ref=&quot;myAdvice&quot; pointcut=&quot;execution(public * com.clj.demo4.AccountServiceImpl.pay(..))&quot;/&amp;gt;
    &amp;lt;/aop:config&amp;gt;
    
    &amp;lt;!-- 配置业务层和持久层 --&amp;gt;
    &amp;lt;bean id=&quot;accountService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo4.AccountServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;accountDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo4.AccountDaoImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）编写持久层和业务层（省略接口）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo5;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.JdbcTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.support.JdbcDaoSupport;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccountDaoImpl &lt;span&gt;extends&lt;/span&gt; JdbcDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountDao{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式一：将jdbc模板类注入到配置文件中，直接在持久层写模板类
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private JdbcTemplate jdbcTemplate;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        this.jdbcTemplate = jdbcTemplate;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式二：持久层继承JdbcDaoSupport,它里面封转了模板类，配置文件持久层无需注入模板类,也不需要配置模板类&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; outMoney(String out, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jdbcTemplate.update(psc);&lt;/span&gt;
        String sql=&quot;update t_account set money=money-? where name=?&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getJdbcTemplate().update(sql,money,out);
    }

    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; inMoney(String in, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        String sql&lt;/span&gt;=&quot;update t_account set money=money+? where name=?&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getJdbcTemplate().update(sql,money,in);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo5;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.TransactionStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionCallbackWithoutResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionTemplate;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccountServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountService{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;采用的是配置文件注入方式，必须提供set方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountDao accountDao;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAccountDao(AccountDao accountDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountDao =&lt;span&gt; accountDao;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pay(String out, String in, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        accountDao.outMoney(out, money);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=10/0&lt;span&gt;;
        accountDao.inMoney(in, money);
    }
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo4;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext2.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo2 {
    @Resource(name&lt;/span&gt;=&quot;accountService&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountService accountService;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Demo1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用支付的方法&lt;/span&gt;
        accountService.pay(&quot;佳先森&quot;,&quot;李钇林&quot;,100&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;2、注解方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1）配置配置文件&lt;/p&gt;
&lt;p&gt;　　 　配置事务管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　开启注释事务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 开启事务的注解 --&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　全部代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
    &amp;lt;!-- 配置C3P0开源连接池 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置平台事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 开启事务的注解 --&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
    
    &amp;lt;!-- 配置业务层和持久层 --&amp;gt;
    &amp;lt;bean id=&quot;accountService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo5.AccountServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;accountDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.demo5.AccountDaoImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）业务层增加@Transactional&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo5;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.TransactionStatus;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionCallbackWithoutResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.support.TransactionTemplate;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在当前类加此注解表示当前类所有的全部都有事务&lt;/span&gt;
&lt;span&gt;@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccountServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountService{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;采用的是配置文件注入方式，必须提供set方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountDao accountDao;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAccountDao(AccountDao accountDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.accountDao =&lt;span&gt; accountDao;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pay(String out, String in, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        accountDao.outMoney(out, money);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=10/0&lt;span&gt;;
        accountDao.inMoney(in, money);
    }
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）持久层不变&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo5;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.JdbcTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.jdbc.core.support.JdbcDaoSupport;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AccountDaoImpl &lt;span&gt;extends&lt;/span&gt; JdbcDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; AccountDao{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式一：将jdbc模板类注入到配置文件中，直接在持久层写模板类
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    private JdbcTemplate jdbcTemplate;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        this.jdbcTemplate = jdbcTemplate;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式二：持久层继承JdbcDaoSupport,它里面封转了模板类，配置文件持久层无需注入模板类,也不需要配置模板类&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; outMoney(String out, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jdbcTemplate.update(psc);&lt;/span&gt;
        String sql=&quot;update t_account set money=money-? where name=?&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getJdbcTemplate().update(sql,money,out);
    }

    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; inMoney(String in, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; money) {
        String sql&lt;/span&gt;=&quot;update t_account set money=money+? where name=?&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getJdbcTemplate().update(sql,money,in);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4）测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.demo5;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext3.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo3 {
    @Resource(name&lt;/span&gt;=&quot;accountService&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AccountService accountService;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Demo1(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用支付的方法&lt;/span&gt;
        accountService.pay(&quot;佳先森&quot;,&quot;李钇林&quot;,100&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;&lt;strong&gt;　　 &lt;/strong&gt;&lt;/p&gt;









&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;




&lt;p class=&quot;16&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;




&lt;/div&gt;</description>
<pubDate>Mon, 02 Apr 2018 16:31:00 +0000</pubDate>
<dc:creator>佳先森</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cailijia52o/p/8699845.html</dc:identifier>
</item>
<item>
<title>Java代码风格和在idea中的一些设置 - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/8699198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/8699198.html</guid>
<description>&lt;h2 id=&quot;源文件基本设置&quot;&gt;源文件基本设置&lt;/h2&gt;
&lt;h3 id=&quot;文件名&quot;&gt;1. 文件名&lt;/h3&gt;
&lt;p&gt;驼峰标识，&lt;code&gt;.java&lt;/code&gt;结尾&lt;/p&gt;
&lt;h3 id=&quot;编码&quot;&gt;2. 编码&lt;/h3&gt;
&lt;p&gt;统一为UTF-8&lt;/p&gt;
&lt;p&gt;Transport...可以解决property文件不能正常显示为中文的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/846961/201804/846961-20180403000525490-170764969.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;特殊字符&quot;&gt;3. 特殊字符&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;尽量使用转义字符(\t, \n等)，而不是八进制的(\012)或者Unicode转义(\u000a)&lt;/li&gt;
&lt;li&gt;非ascii字符，最容易理解，使用unicode字符，比如：μ，不使用转义：\u03bcs&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;源文件结构&quot;&gt;源文件结构&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;license&lt;/li&gt;
&lt;li&gt;package&lt;/li&gt;
&lt;li&gt;import&lt;/li&gt;
&lt;li&gt;一个主类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每一个部分之间用一个空行隔开&lt;/p&gt;
&lt;h3 id=&quot;license&quot;&gt;1. license&lt;/h3&gt;
&lt;h3 id=&quot;包名&quot;&gt;2. 包名&lt;/h3&gt;
&lt;p&gt;不换行(line-wrapped)，一行写完&lt;/p&gt;
&lt;h3 id=&quot;import&quot;&gt;3. import&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;import的时候不使用通配符*&lt;/li&gt;
&lt;li&gt;不单独区分jdk的import和其他import，只按照静态引用和非静态引用分块&lt;/li&gt;
&lt;li&gt;静态引用、非静态引用之间用空行分开，各自的块中间没有空行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/846961/201804/846961-20180403000545230-1669226129.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;类&quot;&gt;4. 类&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;一个文件只有一个top-level类&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;格式&quot;&gt;格式&lt;/h2&gt;
&lt;h3 id=&quot;大括号braces&quot;&gt;1. 大括号(braces)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;If,lese,if else,for,do,while，这些语句块都要用大括号&lt;/li&gt;
&lt;li&gt;这些关键字后面的左大括号前面要有空格（没有换行），后面换行，右大括号前后都需要换行（如果右大括号后面有一些特殊的语句块的时候不需要换行，如：else,catch）&lt;/li&gt;
&lt;li&gt;如果语句块是空的，可以简写&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;  &lt;span class=&quot;co&quot;&gt;// This is acceptable&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doNothing&lt;/span&gt;() {}

  &lt;span class=&quot;co&quot;&gt;// This is equally acceptable&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doNothingElse&lt;/span&gt;() {
  }
  &lt;span class=&quot;co&quot;&gt;// This is not acceptable: No concise empty blocks in a multi-block statement&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
    &lt;span class=&quot;fu&quot;&gt;doSomething&lt;/span&gt;();
  } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;块缩进&quot;&gt;2. 块缩进&lt;/h3&gt;
&lt;p&gt;4个空格&lt;/p&gt;
&lt;h3 id=&quot;每行一个声明&quot;&gt;3. 每行一个声明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;变量不要连续声明&lt;/li&gt;
&lt;li&gt;每行一个语句(一个分号)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;列长限制120&quot;&gt;4. 列长限制120&lt;/h3&gt;
&lt;p&gt;列外情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不可能遵守的这个规则的情况（比如：URL）&lt;/li&gt;
&lt;li&gt;package、import&lt;/li&gt;
&lt;li&gt;注释里面的会被拷贝粘贴到命令行里运行的命令&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/846961/201804/846961-20180403000559699-789379734.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;折行line-wrapping&quot;&gt;5. 折行(line-wrapping)&lt;/h3&gt;
&lt;h4 id=&quot;什么时候折行&quot;&gt;1. 什么时候折行？&lt;/h4&gt;
&lt;p&gt;究竟应该在哪里折行？随性，一个主要的指导是：最好在语法层面上折行&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果折行的地方正好是非等号运算符，则在运算符前面折行，包括类似运算符的符号，比如：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;点运算符，&quot;.&quot;&lt;/li&gt;
&lt;li&gt;泛型，&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;如果折行的地方正好是等号运算符，则在符号后面折行，包括类似等号运算符，比如：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;foreach的&quot;:&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;方法或者构造方法的名字和左括号(&quot;(&quot;)最好在一行，即方法的左括号后折行&lt;/li&gt;
&lt;li&gt;逗号(&quot;,&quot;)和他前面的部分在一行，逗号后折行&lt;/li&gt;
&lt;li&gt;lamda的箭头后面(的&quot;{&quot;)不换行，除非j方法体部分不需要大括号&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;MyLambda&amp;lt;String, Long, Object&amp;gt; lambda =
    (String label, Long value, Object obj) -&amp;gt; {
        ...
    };

Predicate&amp;lt;String&amp;gt; predicate = str -&amp;gt;
    &lt;span class=&quot;fu&quot;&gt;longExpressionInvolving&lt;/span&gt;(str);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;有折行时候的缩进&quot;&gt;2. 有折行时候的缩进&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;有折行的情况下，每次折行都至少缩进4个空格(相较于第一行)&lt;/li&gt;
&lt;li&gt;如果多次缩进是语法上并行的元素，那么可以缩进相同，否则在持续缩进中，每次都要增加4个空格&lt;/li&gt;
&lt;li&gt;没有必要为了水平对齐而增加额外的空格&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;空白&quot;&gt;6. 空白&lt;/h3&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li&gt;
&lt;p&gt;垂直的空白&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;字段、构造方法、成员方法、内部类、静态初始化、实例初始化，这些之间用空行隔开
&lt;ol&gt;&lt;li&gt;成员字段之间不用空行，除非为了逻辑上的分组&lt;/li&gt;
&lt;li&gt;enum字段之间用空行隔开&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;为了组织代码而进行逻辑分割可以使用空行&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;类第一个成员前面不需要空行，最后一个成员后面也不需要空行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;水平空白&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;关键字后面的小括号(&quot;(&quot;)之间要有一个空格作为分隔，if,for,catch&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;关键字前面的大括号(&quot;}&quot;)之间要有一个空格作为分隔，else, catch&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;左大括号(&quot;{&quot;)前面要有一个空格，两个例外：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;@SomeAnnotation({a, b})&lt;/code&gt; (no space is used)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;String[][] x = {{&quot;foo&quot;}};&lt;/code&gt; (no space is required between &lt;code&gt;{{&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;二元或者三元运算符前后都要有空格，包括类似运算符的符号，如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;泛型中，&lt;code&gt;&amp;lt;T extends Foo &amp;amp; Bar&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;foreach中&quot;:&quot;前后&lt;/li&gt;
&lt;li&gt;lamda表达式的&quot;-&amp;gt;&quot;前后&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是不包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;点运算符&quot;.&quot;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在&lt;code&gt;,:;&lt;/code&gt;后面有空格，还有强转的右括号后面&quot;)&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;行末注释&quot;//&quot;两侧都需要空格，多个是允许的，但不是必须的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在变量类型和声明之间：List&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数组初始化的大括号里面，左大括号后面和右大括号前面的空格不是必须的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;new int[] {5, 6}&lt;/code&gt; and &lt;code&gt;new int[] { 5, 6 }&lt;/code&gt; are both valid&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;水平对齐所需要的空白：不需要&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;增加维护成本&lt;/p&gt;
&lt;h3 id=&quot;加上分组用的小括号&quot;&gt;7. 加上分组用的小括号&lt;/h3&gt;
&lt;p&gt;便于理解运算顺序，而不必记住Java优先级表&lt;/p&gt;
&lt;h3 id=&quot;特定的一些构造&quot;&gt;8. 特定的一些构造&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;enum&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果元素有构造方法或者一般方法的情况，元素之间可以用空行隔开&lt;/p&gt;
&lt;p&gt;```java&lt;br/&gt;private enum Answer {&lt;br/&gt;YES {&lt;br/&gt;@Override public String toString() {&lt;br/&gt;return &quot;yes&quot;;&lt;br/&gt;}&lt;br/&gt;},&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; NO,
 MAYBE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;​ 如果没有构造方法等可以用下面的方式&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;enum&lt;/span&gt; Suit { CLUBS, HEARTS, SPADES, DIAMONDS }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;变量声明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;一次声明一个变量，不要出现如&lt;code&gt;int a, b&lt;/code&gt;;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;局部变量在必要的还是再声明，保证最小化生命周期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数组初始化可以当做一个block，例如：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;java new int[] { new int[] { 0, 1, 2, 3 0, } 1, 2, new int[] { 3, 0, 1, } 2, 3 } new int[] {0, 1, 2, 3}&lt;/code&gt;&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;方括号跟在类型后面，方括号和类型共同组成一个类型，&lt;code&gt;String[] arr&lt;/code&gt;，而不是&lt;code&gt;String arr[]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;switch语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;case缩进4个空格&lt;/li&gt;
&lt;li&gt;冒号后换行&lt;/li&gt;
&lt;li&gt;有穿透的(case没有break)还是要说明，注释&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;保留default，即使没有代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个注解单独一行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注释&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;多行注释中第一行和最后一行不写注释&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java /* * This is // And so /* Or you can * okay. // is this. * even do this. */ */&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修饰词&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Java中修饰词的顺序&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java public protected private abstract default static final transient volatile synchronized native strictfp&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数字字面值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果是&lt;code&gt;long&lt;/code&gt;类型的字面值，最后加&quot;L&quot;，而不是&quot;l&quot;，如：&lt;code&gt;long length = 1000L;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;命名&quot;&gt;命名&lt;/h2&gt;
&lt;h3 id=&quot;通用的命名规则&quot;&gt;1. 通用的命名规则&lt;/h3&gt;
&lt;p&gt;仅仅使用ascii字符和数字，少数情况使用下划线(比如：常量命名，大写，多个单词之间使用下划线隔开)&lt;/p&gt;
&lt;h3 id=&quot;每种标识符对应的命名规则&quot;&gt;2. 每种标识符对应的命名规则&lt;/h3&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;package：全小写，不使用下划线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;class：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;使用首字母大写的驼峰标识&lt;/li&gt;
&lt;li&gt;类名使用名词或者名词短语，接口使用名词或者名词短语，部分情况使用形容词(Readable)&lt;/li&gt;
&lt;li&gt;注解没有指定的规则&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;测试类，&amp;lt;被测试的类名&amp;gt;+Test&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;method：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;方法名首字母小写的驼峰标识&lt;/li&gt;
&lt;li&gt;方法名是动词或者动词短语&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;测试方法名称：test+&amp;lt;被测试的方法名&amp;gt;+&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;constant：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;全大写，单词之间用下划线隔开&lt;/li&gt;
&lt;li&gt;名词或者名词短语&lt;/li&gt;
&lt;li&gt;怎么才算常量：
&lt;ol&gt;&lt;li&gt;static final修饰的原始类型、String、不可变的集合&lt;/li&gt;
&lt;li&gt;对象所有可被访问的状态不可变&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非常量字段命名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;首字母小写，驼峰标识&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;名词或者名词短语&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;形参名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;首字母小写，驼峰标识&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;public方法的参数名不能只有一个字母&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局部变量命名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;首字母小写的驼峰标识&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;局部变量即使是不可变的，也不能按照常量的方法来命名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泛型参数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面两种方式中选一个&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单个大写字母后面跟上数字&lt;/li&gt;
&lt;li&gt;若泛型有上限，则上限类名后面跟上大写的&lt;code&gt;T&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;驼峰标识的具体方法&quot;&gt;3. 驼峰标识的具体方法&lt;/h3&gt;
&lt;p&gt;怎么将多个单词或者单词短语转换为驼峰标识的命名方法&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将所有的单词或者短语转换为ascii，并且删除中间的任何撇号，如：&quot;Müller's algorithm&quot;转换为 &quot;Muellers algorithm&quot;。&lt;/li&gt;
&lt;li&gt;将上面得到的划分为单词，使用空格或者标点符号(特别是连字符)作为分界线。如果一个短语有惯常用法，则保留惯常用法，比如：AdWords 转换为Ad Words&lt;/li&gt;
&lt;li&gt;将得到的字符串全部转换为小写，然后将划分后的每一个单词的首字母大写(如果是第一个单词则可能第一个单词的首字母小写)&lt;/li&gt;
&lt;li&gt;然后将字符串连接起来，去掉空格&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一些例子：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;需要转换的字符串&lt;/td&gt;
&lt;td&gt;正确的&lt;/td&gt;
&lt;td&gt;不正确的&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&quot;XML HTTP request&quot;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;XmlHttpRequest&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;XMLHTTPRequest&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&quot;new customer ID&quot;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;newCustomerId&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;newCustomerID&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&quot;inner stopwatch&quot;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;innerStopwatch&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;innerStopWatch&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&quot;supports IPv6 on iOS?&quot;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;supportsIpv6OnIos&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;supportsIPv6OnIOS&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&quot;YouTube importer&quot;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;YouTubeImporter&lt;/code&gt; &lt;code&gt;YoutubeImporter&lt;/code&gt;&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;编程实践&quot;&gt;编程实践&lt;/h2&gt;
&lt;h3 id=&quot;总是写override&quot;&gt;1. 总是写&lt;code&gt;@Override&lt;/code&gt;&lt;/h3&gt;
&lt;h3 id=&quot;不忽略任何异常&quot;&gt;2. 不忽略任何异常&lt;/h3&gt;
&lt;p&gt;需要catch异常，并做处理，如果没有必要处理，要用注释说明&lt;/p&gt;
&lt;h3 id=&quot;使用类名来引用静态成员&quot;&gt;3. 使用类名来引用静态成员&lt;/h3&gt;
&lt;h3 id=&quot;不重写object.finalize&quot;&gt;4. 不重写&lt;code&gt;Object.finalize&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;如果非要重写，请阅读并理解《Effective Java》里面避免&lt;code&gt;Finalizer&lt;/code&gt;的部分&lt;/p&gt;
&lt;p&gt;其他在idea中的设置&lt;/p&gt;
&lt;h3 id=&quot;换行符&quot;&gt;换行符&lt;/h3&gt;
&lt;p&gt;统一为&quot;\n&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/846961/201804/846961-20180403000630998-1276100050.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;缩进&quot;&gt;缩进&lt;/h3&gt;
&lt;p&gt;统一为：tab 4 个空格&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/846961/201804/846961-20180403000650175-1044700553.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://google.github.io/styleguide/javaguide.html&quot;&gt;Google Java Style Guide&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Apr 2018 16:09:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/8699198.html</dc:identifier>
</item>
<item>
<title>不管人生怎么走，都需要实时回头看看 - failymao</title>
<link>http://www.cnblogs.com/failymao/p/8699180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/failymao/p/8699180.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 鲁迅爷爷说：世间本没有路，走的人多了就有了路！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　---Write to header!&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　首先，很无奈的以这样一种拙劣甚至粗俗的方式开始我的第一篇博客的开头！其实不管做任何事儿，开头都是很艰难的！一直以来，不管是二十年前自记事起，还是初次步入社会，第一次恋爱，甚至是现在已经在这个繁杂的社会摸爬滚打这么些年，身为处女座的我依然摆脱不了：选择恐惧症！其实往往越是简单的事情，一到我这里立马变成了暗物质是否存在，地球到底会不会与某年某月与某颗卫星相撞的问题！会不由自住为某些其实无关痛痒的问题设想很多没有意义的答案，自己给自己下套，而几乎每次都会为求证答案让自己陷入无尽的痛苦中！可是最后才发现，事情没我想的那么负责，记住你的第一感觉，正确率往往高于经过自己精心设计求证N次的答案！ 其实说了这么多，也是自我纠结的一种体现，敲字前，一直在纠结到底什么时候开始自己的第一篇博客，以哪种方式，是技术，还是感悟，或者是别的什么？接着，又在纠结起个什么高大上的题目？陈述性的，还是疑问句性的？ 而如上所看到的标题，是自己在瞬间脑子想到的一句话，甚至那一刻我都不知道，这篇博客到底需要表现的是什么样的主题！ 原谅我非语言专业的毕业的码字小生！接下来，就到了纠结到底该如何开始我的第一句！ 于是乎，就有了鲁迅爷爷的那句话！这是我至今唯一还记得的一句大家的人生格言！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　写到这里的时候，终于知道！写这篇博客的主旨了！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&quot;世间本没有路，走的人多了就有了路！&quot; 我并不完全赞同鲁迅爷爷说的这句话，至于就目前这个时代而言！在我看来：&quot;世间本没有路，早走的人才能走出路!&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 说说我自己！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　倔强，任性，2011年车辆工程专业毕业，同年进入世界顶级跑车制造商，工作两年后，每天朝九晚五，三点一线，做着轻车熟路的工作，三线城市拿着年薪十几万的薪水，每每春节聚会，被亲朋好友啧啧称赞的对象！却在无数个在灯红酒绿的夜晚问自己同一个问题：难道这就是我所想要的生活吗？这就是我需要耗费一辈子去追求曾经年少时许下的那些梦想吗？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2016年的夏天显的格外漫长。由于一直在纠结自己到底是要继续呆在这个舒适的环境还是在这个貌似不合适的年龄选择最初的梦想？工作提不起劲儿，工作五年，突然开始心疼自己，除了工作就是家人，从没有好好关心一下自己，开始矫情了，于是去请了个长假，一个人独自去西藏，青海，宁夏，云南，甘肃。。。可是一路上依然放不下那个深藏在自己内心的梦想？ 旅途回来后，写了辞职报告，一个月交接完所有的工作，瞒着家人，悄悄辞职！开始了全新的开始---开启曲线救国事业！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　放开书本四五年，能否继续自己年少时的梦？&lt;/span&gt;摆在眼前的似乎是一条不归路！&lt;/p&gt;
&lt;p&gt;　　双十一，买了本《Python基础教程》，我想，即使前面刀山火海，即使前路漫漫，又有何惧，大不了重头再来！万一一不小心开窍了呢？如果再不试试，那跟咸鱼有何区别？&lt;/p&gt;
&lt;p&gt;　   离职后的第二个月，每天报着这本武功秘籍，从百度到google，从贴吧到知乎！&lt;/p&gt;
&lt;p&gt;　　治疗困累的最好方式就是：饿自己，会让你时刻保持清醒的头脑！&lt;/p&gt;
&lt;p&gt;　　想放弃的时候，看看大牛们的成长经历！没有了经济来源，即使工作几年银行卡里还存有一套房子的首付和一辆车的首付，可是危机意识特强烈的自己也不敢在生活上多么造次，饱暖思淫欲，让自己处于舒适的环境下是最厉害的武器！&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;  我像一个小学生，一葫芦画瓢，却每每受挫，一段十几行的代码对于我一个完全的小白来说，那种近乎疯狂的折磨和打击让我时刻怀疑人生！看不懂，那就买视频，，从开始学习windows下安装虚拟机centos来搭建python编程的虚拟环境，到Python基础知识的学习，一个新模块的用法，抽象晦涩的面向对象，各种混淆的类方法，独立独行的生成器，爱恨交加的装饰器，scrapy框架的爬虫，再到组团进行Web的开发，一个人听着轻音乐奋战在凌晨两三点的午夜，持续几个月的黑白颠倒，时刻都感觉到自己被社会所抛弃！&lt;/p&gt;
&lt;p&gt;  历时半年多被蹂躏，有千万次想过放弃，却早已把每天的敲代码当成了一种习惯，我想这就是这段时间最大的收获吧！回顾自己这段历程，我自己成长了很多，懂得了很多，成熟了很多，改变了很多。人生拥有多少个寂寞的时间段，人生能有几次能为梦想说走就走？而今自己也越来越享受这每一次各种颜色代码浮动在屏幕上的喜悦和激动！更深深的体会到了每一个转行过来的小白，都会经历的不被理解，孤军奋战，如履薄冰...的种种困境与心酸，至少于我而言。&lt;/p&gt;
&lt;p&gt;       你以为你准备好的时候，其实老天爷还会给你更残酷的考验！觉得自己学业有成是件多么幸福的事儿！每时每刻都有跃跃欲试的冲动，事实上，生活真的会毫不留情的接二连三的给你响亮耳光！都说北上武广深机会多，于是在待了5年的北方城市，为了自己的梦想也毅然决然的选择出发，二十天奔走沿海的各个城市，每天三四个面试，穿梭在城市的大街小巷，被广州突如其来的暴雨淋成落汤鸡，被迫跟面试官打电话请求面试时间变更，被武汉高温晒得流鼻血，却最终从信心满满到心如死灰！ 退缩还是继续前进？ &lt;/p&gt;
&lt;p&gt;    事实也证明，只要你足够坚强，不怕摔倒，不怕打脸，机会总是会有的！&lt;/p&gt;
&lt;p&gt;    而如今，自己终于如愿以偿的进入这个行业，虽然很辛苦，但是很幸福，因为选择 ，因为拼搏，让自己觉得即使世界在怎么残酷，麻木不仁，我依然有一颗活着的心！生活不仅需要一帆风顺，更需要时时刻刻遭受打击，只有这样，你才会成长，才能体会到生活的意义所在！不要在你还能努力的年纪选择过上七八十岁的日子，当然如果那是你想要的生活，我无话可说，千万不要一面愤愤不平，羡慕别人，一边每天无动于衷！生命的最后会让你回忆过往时，是满目苍凉还是面目祥和！&lt;/p&gt;
&lt;p&gt;    我愿身处江湖，即便尸横遍野，也在所不惜！&lt;/p&gt;

</description>
<pubDate>Mon, 02 Apr 2018 16:08:00 +0000</pubDate>
<dc:creator>failymao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/failymao/p/8699180.html</dc:identifier>
</item>
<item>
<title>WPF自学入门（十）WPF MVVM简单介绍 - 黄昏前黎明后</title>
<link>http://www.cnblogs.com/fly-bird/p/8699105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fly-bird/p/8699105.html</guid>
<description>&lt;p&gt;　　 前面文章中，我们已经知道，WPF技术的主要特点是数据驱动UI,所以在使用WPF技术开发的过程中是以数据为核心的，WPF提供了数据绑定机制，当数据发生变化时，WPF会自动发出通知去更新UI。 &lt;/p&gt;
&lt;p&gt;　　我们不管是NET中还是WPF中使用模式目的就是想达到高内聚低耦合。在WPF开发中，经典的编程模式是MVVM，是为WPF量身定做的模式，该模式充分利用了WPF的数据绑定机制，最大限度地降低了Xmal文件和CS文件的耦合度，也就是UI显示和逻辑代码的耦合度，如需要更换界面时，逻辑代码修改很少，甚至不用修改。与WinForm开发相比，我们一般在后置代码中会使用控件的名字来操作控件的属性来更新UI，而在WPF中通常是通过数据绑定来更新UI；在响应用户操作上，WinForm是通过控件的事件来处理，而WPF可以使用命令绑定的方式来处理，耦合度将降低。&lt;/p&gt;
&lt;p&gt;一、MVVM介绍&lt;/p&gt;
&lt;p&gt;　　MVVM是Model-View-ViewModel（模型-视图-视图模型）的缩写形式，它通常被用于WPF或Silverlight开发。我们可以通过下图来直观的理解MVVM模式：　　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201804/662342-20180402235635381-1770850170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　1、View就是用xaml实现的界面，负责与用户交互，接收用户输入，把数据展现给用户。&lt;/p&gt;
&lt;p&gt;　　2、ViewModel是一个C#类，负责收集需要绑定的数据和命令，聚合Model对象，通过View类的DataContext属性绑定到View，同时也可以处理一些UI逻辑。&lt;/p&gt;
&lt;p&gt;　　3、Model，就是系统中的对象，可包含属性和行为。&lt;/p&gt;
&lt;p&gt;　　三者之间的关系：View对应一个ViewModel，ViewModel可以聚合N个Model，ViewModel可以对应多个View&lt;/p&gt;
&lt;p&gt;二、MVVM的优势&lt;/p&gt;
&lt;p&gt;      MVVM的根本思想就是界面和业务功能进行分离，View的职责就是负责如何显示数据及发送命令，ViewModel的功能就是如何提供数据和执行命令。各司其职，互不影响。在实际的业务场景中我们经常会遇到客户对界面提出建议要求修改，使用MVVM模式开发，当设计的界面不满足客户时，我们仅仅只需要对View作修改，不会影响到ViewModel中的功能代码，减少了犯错的机会。随着功能地增加，系统越来越复杂，相应地程序中会增加View和ViewModel文件，将复杂的界面分离成局部的View，局部的View对应局部的ViewModel，功能点散落在各个ViewModel中，每个ViewModel只专注自己职能之内的事情。ViewModel包含了View要显示的数据，并且知道View的交互代码，所以ViewModel就像一个无形的View。使用MVVM架构具有以下优势&lt;/p&gt;
&lt;p&gt;1、易维护&lt;/p&gt;
&lt;p&gt;2、灵活扩展&lt;/p&gt;
&lt;p&gt;3、易测试&lt;/p&gt;
&lt;p&gt;4、用户界面设计师与程序开发者能更好的合作&lt;/p&gt;

&lt;p&gt;三、MVVM简单示例&lt;/p&gt;
&lt;p&gt;      为了让大家直观地了解MVVM的编程模式，下面会用到前面讲到的数据绑定以及命令等知识。&lt;/p&gt;
&lt;p&gt;     新建WPF项目，名称WPFMVVMDemo。添加用户类，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201804/662342-20180402235646489-1334545573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      在WPF术语中，这个叫“模型”，GUI是“视图”。不可思议的是“视图模型”，通过数据绑定将它们绑在一起，它真的是一个很好的适配器能将模型变成某种WPF框架可以使用的东西。所以这个就是“模型”。&lt;/p&gt;
&lt;p&gt;      接下来我们会非常容易理解创建视图模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201804/662342-20180402235704152-923151167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      请注意这个视图模型不是十分正确的。因为我们在视图模型里暴露了属性，我们显然会想使在代码里改变的用户名和公司名自动的显示在视图上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201804/662342-20180402235719258-1417352575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;后台代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201804/662342-20180402235732593-1048132801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201804/662342-20180402235741922-100933531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       这里我们点击更新按钮不会有任何反应，因为还没有实现数据绑定。此时视图不会收到任何的关于属性改变的通知。要解决这个问题我们必须实现名称为INotifyPropertyChanged的接口。任何实现了这个接口的类，当属性发生改变的时候会通知所有监听者，所以我们需要修改视图模型NameViewModel类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201804/662342-20180402235748743-1541186742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      这里会产生多个事件。首先，我们检查了我们是否真的改变了属性。第二，如果值已经改变，我们向所有监听者注册PropertyChanged事件。现在我们有了一个模型Name和一个视图模型NameViewModel。我们只需要在定义视图。只需要修改视图MainWindow：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201804/662342-20180402235804065-1721886481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201804/662342-20180402235813790-2110155485.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文的demo下载地址：WPFMVVMDemo1.zip&lt;/p&gt;


</description>
<pubDate>Mon, 02 Apr 2018 16:04:00 +0000</pubDate>
<dc:creator>黄昏前黎明后</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fly-bird/p/8699105.html</dc:identifier>
</item>
<item>
<title>翻译：CREATE FUNCTION语句（已提交到MariaDB官方手册） - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8698943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8698943.html</guid>
<description>&lt;p&gt;本文为mariadb官方手册：CREATE FUNCTION的译文。&lt;/p&gt;
&lt;p&gt;原文：&lt;span&gt;&lt;a href=&quot;https://mariadb.com/kb/en/library/create-function/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://mariadb.com/kb/en/library/create-function/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;我提交到MariaDB官方手册的译文：&lt;span&gt;&lt;a href=&quot;https://mariadb.com/kb/zh-cn/create-function/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://mariadb.com/kb/zh-cn/create-function/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; [&lt;span class=&quot;hljs-keyword&quot;&gt;OR&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;REPLACE&lt;/span&gt;]
    [DEFINER = {&lt;span class=&quot;hljs-keyword&quot;&gt;user&lt;/span&gt; | &lt;span class=&quot;hljs-keyword&quot;&gt;CURRENT_USER&lt;/span&gt; | role | CURRENT_ROLE }]
    [&lt;span class=&quot;hljs-keyword&quot;&gt;AGGREGATE&lt;/span&gt;] &lt;span class=&quot;hljs-keyword&quot;&gt;FUNCTION&lt;/span&gt; [&lt;span class=&quot;hljs-keyword&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EXISTS&lt;/span&gt;] func_name ([func_parameter[,...]])
    &lt;span class=&quot;hljs-keyword&quot;&gt;RETURNS&lt;/span&gt; type
    [characteristic ...]
    &lt;span class=&quot;hljs-keyword&quot;&gt;RETURN&lt;/span&gt; func_body

func_parameter:
    param_name type

type:
    &lt;span class=&quot;hljs-keyword&quot;&gt;Any&lt;/span&gt; valid MariaDB &lt;span class=&quot;hljs-keyword&quot;&gt;data&lt;/span&gt; type

characteristic:
    &lt;span class=&quot;hljs-keyword&quot;&gt;LANGUAGE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;SQL&lt;/span&gt;
  | [&lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt;] DETERMINISTIC
  | { CONTAINS &lt;span class=&quot;hljs-keyword&quot;&gt;SQL&lt;/span&gt; | &lt;span class=&quot;hljs-keyword&quot;&gt;NO&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;SQL&lt;/span&gt; | READS &lt;span class=&quot;hljs-keyword&quot;&gt;SQL&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;DATA&lt;/span&gt; | MODIFIES &lt;span class=&quot;hljs-keyword&quot;&gt;SQL&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;DATA&lt;/span&gt; }
  | &lt;span class=&quot;hljs-keyword&quot;&gt;SQL&lt;/span&gt; SECURITY { DEFINER | INVOKER }
  | COMMENT &lt;span class=&quot;hljs-string&quot;&gt;'string'&lt;/span&gt;

func_body:
    Valid &lt;span class=&quot;hljs-keyword&quot;&gt;SQL&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;procedure&lt;/span&gt; statement&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;可以使用CREATE FUNCTION语句创建一个新的存储函数&lt;span&gt;&lt;a href=&quot;https://mariadb.com/kb/en/stored-functions/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;stored function&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。要使用CREATE FUNCTION语句，必须要具备&lt;span&gt;&lt;a href=&quot;https://mariadb.com/kb/en/grant/#database-privileges&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;CREATE ROUTINE&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;权限。&lt;/p&gt;
&lt;p&gt;函数可以定义任意数量的参数，在函数体(func_body)部分会返回一个值。函数体部分可以是任意有效的SQL表达式，例如某些select语句。如果你有合适的权限，你完全可以像调用内置函数一样调用存储函数。关于权限的详细信息，见下文：&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8698943.html#blogSecurity&quot;&gt;&lt;span&gt;Security&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;此外，你也可以使用CREATE FUNCTION语句的变体格式来安装一个用户自定义函数(UDF)。关于UDF，详细信息见：&lt;span&gt;&lt;a href=&quot;https://mariadb.com/kb/en/create-function-udf/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;CREATE FUNCTION (UDF)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;你可以使用一个圆括号包围SELECT作为func_body部分，正如使用子查询一样。但注意，SELECT语句必须返回单个值(标量值，即单行且单列的值)。调用函数时，如果SELECT语句返回了多列，则报1241的错误，如果SELECT语句返回了多行，则报1242的错误。为了保险，可以使用LIMIT子句保证只返回单行数据。&lt;/p&gt;
&lt;p&gt;你可以使用&lt;span&gt;&lt;a href=&quot;https://mariadb.com/kb/en/begin-end/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;BEGIN...END&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;语句块替换这里的RETURN子句，但是在语句块中，必须要包含一个RETURN语句。当调用函数时，执行到RETURN子句时将立即返回其结果，在RETURN子句之后的语句都不会再执行。&lt;/p&gt;
&lt;p&gt;默认情况下，函数是关联到默认数据库上的。如果要将函数显式关联到一个指定的数据库，可以在创建时使用全称&lt;code&gt;db_name.func_name&lt;/code&gt;。如果创建的存储函数名和内置的函数名同名，则必须使用全称来调用它。&lt;/p&gt;
&lt;p&gt;定义存储函数时，参数列表可以为空。如果指定参数名，则参数名不区分大小写。&lt;/p&gt;
&lt;p&gt;每个参数都可以声明为任意有效的数据类型，但无法使用COLLATE属性。&lt;/p&gt;
&lt;h3 id=&quot;returns-&quot;&gt;&amp;gt;RETURNS子句&lt;/h3&gt;
&lt;p&gt;RETURNS子句指定函数的返回类型。可以使用NULL值来表示返回任意有效数据类型。&lt;/p&gt;
&lt;p&gt;如果RETURN子句的返回值类型和此处定义的数据类型不一致会如何？这取决于创建函数的时候，SQL_MODE的影响行为。&lt;/p&gt;
&lt;p&gt;如果SQL_MODE为strict模式的值(即指定了STRICT_ALL_TABLES或STRICT_TRANS_TABLES)，将报1366错误。&lt;/p&gt;
&lt;p&gt;除这种情况，如果返回值类型不一致，则返回值将被强制转换为指定的数据类型。例如，RETURNS子句指定返回一个ENUM或SET数据类型，但RETURN子句返回了一个整型，则返回值将强制转换为ENUM或SET成员对应的字符串(译者注：虽然ENUM允许存储数值，但强烈建议不要存储数值，因为非常容易混淆ENUM的索引值和实际存储的数值，因此这里直接说是字符串)。&lt;/p&gt;
&lt;p&gt;MariaDB将在创建routine的时候保留系统变量SQL_MODE的值，以后任何时间调用routine时都使用该SQL_MODE值，而不管当前调用routine时的SQL MODE值是什么。&lt;/p&gt;
&lt;h3 id=&quot;language-sql&quot;&gt;&amp;gt;LANGUAGE SQL&lt;/h3&gt;
&lt;p&gt;LANGUAGE SQL代表的是一个标准的SQL子句，它是为了移植性而存在的。但是，该子句在MariaDB中没有任何意义，因为MariaDB的存储函数中唯一支持的语言只有SQL。&lt;/p&gt;
&lt;h3 id=&quot;or-replace&quot;&gt;&amp;gt;OR REPLACE&lt;/h3&gt;
&lt;p&gt;如果使用了OR REPLACE子句，它的行为等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FUNCTION&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EXISTS&lt;/span&gt; function_name;&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FUNCTION&lt;/span&gt; function_name ...;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但不会删除该函数已有的权限privileges。&lt;/p&gt;
&lt;h3 id=&quot;if-not-exists&quot;&gt;&amp;gt;IF NOT EXISTS&lt;/h3&gt;
&lt;p&gt;如果使用 IF NOT EXISTS 子句，那么当函数存在时，MariaDB将返回一个warning信息而不是直接返回错误。IF NOT EXISTS不能和OR REPLACE一起使用。&lt;/p&gt;
&lt;h3 id=&quot;-not-deterministic&quot;&gt;&amp;gt;[NOT] DETERMINISTIC&lt;/h3&gt;
&lt;p&gt;如果函数根据给定的参数列表能够返回一个确定的结果，则该函数是确定的(deterministic)。如果函数的返回值 会因某些数据、变量、随机数或任意不确定的值而受影响，则函数是不确定的。此外，如果存储函数中使用了不确定的函数(如NOW()或CURRENT_TIMESTAMP())，则该存储函数也是不确定的。&lt;/p&gt;
&lt;p&gt;如果优化器知道函数是确定的，它会选择一个更快更有效的执行计划。你可以使用DETERMINISTIC关键字来定义这个routine。如果你想显式将函数标记为不确定的(默认就是如此)，可以使用NOT DETERMINISTIC关键字。&lt;/p&gt;
&lt;p&gt;如果你将一个不确定的函数声明为DETERMINISTIC，将返回一个错误结果。如果你将一个确定的函数声明为NOT DETERMINISTIC，则某些情况下，该查询语句的性能将大幅降低。&lt;/p&gt;
&lt;p&gt;[NOT] DETERMINISTIC子句还会影响二进制日志&lt;span&gt;&lt;a href=&quot;https://mariadb.com/kb/en/binary-log/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;binary logging&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，因为日志中的语句格式无法 存储或替换不确定的语句。&lt;/p&gt;
&lt;p&gt;CONTAINS SQL, NO SQL, READS SQL DATA 以及 MODIFIES SQL DATA是信息类的子句，它们告诉服务器该函数是做什么的。MariaDB不会对这些语句做任何语法检查。如果不指定这些语句，则默认使用CONTAINS SQL。&lt;/p&gt;
&lt;h3 id=&quot;modifies-sql-data&quot;&gt;&amp;gt;MODIFIES SQL DATA&lt;/h3&gt;
&lt;p&gt;MODIFIES SQL DATA意味着函数中包含了要修改数据库中数据的语句。例如函数中使用了类似于DELETE, UPDATE, INSERT, REPLACE或DDL类的语句。&lt;/p&gt;
&lt;h3 id=&quot;reads-sql-data&quot;&gt;&amp;gt;READS SQL DATA&lt;/h3&gt;
&lt;p&gt;READS SQL DATA意味着函数中包含了从数据库中读取数据的语句，但是不会修改任何数据。例如函数中使用了不包含任何写操作的SELECT语句。&lt;/p&gt;
&lt;h3 id=&quot;contains-sql&quot;&gt;&amp;gt;CONTAINS SQL&lt;/h3&gt;
&lt;p&gt;CONTAINS SQL意味着函数包含了至少一条SQL语句，但是它不会读也不会写数据库。例如函数中包含了SET或DO子句。&lt;/p&gt;
&lt;h3 id=&quot;no-sql&quot;&gt;&amp;gt;NO SQL&lt;/h3&gt;
&lt;p&gt;NO SQL意味着什么？啥也不意味着。因为MariaDB目前除了SQL语言，不支持任何其他语言。&lt;/p&gt;

&lt;h3 id=&quot;security&quot;&gt;&amp;gt;Security&lt;/h3&gt;
&lt;p&gt;要想调用函数，你必须要拥有该函数的EXECUTE权限。&lt;/p&gt;
&lt;p&gt;MariaDB会自动为创建函数CREATE FUNCTION的用户授予EXECUTE 和 ALTER ROUTINE权限，即使使用了DEFINER子句。&lt;/p&gt;
&lt;p&gt;每个函数都有一个关联的账号(即definer)。默认情况下，definer即为函数的创建者。可以使用DEFINER子句显式指定关联到其他账号上。要使用DEFINER，你必须要拥有SUPER权限。详细信息见：&lt;span&gt;&lt;a href=&quot;https://mariadb.com/kb/en/create-user/#account-names&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Account Names&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;SQL SECURITY子句指定了当调用函数时所使用的权限。如果SQL SECURITY的值为INVOKER，则将使用函数调用者的权限去对比(即评估)函数体中的语句权限。如果SQL SECURITY的值为DEFINER，则总是使用definer用户的权限去评估函数体的权限。默认值为DEFINER。&lt;/p&gt;
&lt;p&gt;通过该子句，你可以创建一个只允许某用户访问部分数据的函数。例如，你有一张存储了员工信息的表，并且你已经授予了用户roger对该表某些列(&lt;span&gt;&lt;a href=&quot;https://mariadb.com/kb/en/grant/#column-privileges&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;only on certain columns&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;)的SELECT权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; employees (name TINYTEXT, dept TINYTEXT, salary &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;);&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; (name, dept) &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; employees &lt;span class=&quot;hljs-keyword&quot;&gt;TO&lt;/span&gt; roger;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以定义一个函数来获取部门中薪水最高的用户，并授予EXECUTE权限：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FUNCTION&lt;/span&gt; max_salary (dept TINYTEXT) &lt;span class=&quot;hljs-keyword&quot;&gt;RETURNS&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;RETURN&lt;/span&gt;
  (&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;MAX&lt;/span&gt;(salary) &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; employees &lt;span class=&quot;hljs-keyword&quot;&gt;WHERE&lt;/span&gt; employees.dept = dept);&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;EXECUTE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FUNCTION&lt;/span&gt; max_salary &lt;span class=&quot;hljs-keyword&quot;&gt;TO&lt;/span&gt; roger;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于SQL SECURITY的默认值为DEFINER，无论roger用户何时调用该函数，都会使用你的权限来执行其中的子查询。只要你有查询每个员工薪水的权限，即使函数调用者不具备直接查询薪水的权限，他们也能获取到每个部门的最高薪水。&lt;/p&gt;
&lt;h3 id=&quot;character-sets-collations&quot;&gt;&amp;gt;Character sets 和 collations&lt;/h3&gt;
&lt;p&gt;可以为函数声明使用任意有效的字符集和排序规则&lt;a href=&quot;https://mariadb.com/kb/en/character-sets/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;character set and collatio&lt;/span&gt;n&lt;/a&gt;。如果定义了它们，COLLATE属性需要定义在CHARACTER SET之后。&lt;/p&gt;
&lt;p&gt;如果没有指定字符集和排序规则，则使用函数创建时的系统默认值。即使之后系统默认字符集和排序规则改变了，函数所使用的字符集也不会随之改变。这种情况下，应该重建函数并使用数据库所使用的字符集和排序规则。&lt;/p&gt;

&lt;p&gt;下面的函数示例使用了一个参数，并在函数中执行了一个SQL内置函数&lt;code&gt;CONCAT()&lt;/code&gt;，最后返回结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FUNCTION&lt;/span&gt; hello (s &lt;span class=&quot;hljs-built_in&quot;&gt;CHAR&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;))
    &lt;span class=&quot;hljs-keyword&quot;&gt;RETURNS&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;CHAR&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;) DETERMINISTIC
    &lt;span class=&quot;hljs-keyword&quot;&gt;RETURN&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;CONCAT&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;'Hello, '&lt;/span&gt;,s,&lt;span class=&quot;hljs-string&quot;&gt;'!'&lt;/span&gt;);&lt;/span&gt;

&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; hello(&lt;span class=&quot;hljs-string&quot;&gt;'world'&lt;/span&gt;);&lt;/span&gt;
+
| hello('world') |
+
| Hello, world!  |
+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以在函数内部使用一个语句块来操作数据(即使用DML)，例如INSERT和UPDATE。下面的例子中创建了一个函数计数器，它使用了一个临时表来存储当前的值。因为语句块包含了语句终止符号&quot;;&quot;，因此必须首先使用DELIMITER语句改变语句的终止符，使得函数体中能够使用分号。更多信息见&lt;span&gt;&lt;a href=&quot;https://mariadb.com/kb/en/delimiters-in-the-mysql-client/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Delimiters in the mysql client&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TEMPORARY&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; counter (c &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;);&lt;/span&gt;
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; counter &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;
DELIMITER //
&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FUNCTION&lt;/span&gt; counter () &lt;span class=&quot;hljs-keyword&quot;&gt;RETURNS&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;
  &lt;span class=&quot;hljs-keyword&quot;&gt;BEGIN&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;UPDATE&lt;/span&gt; counter &lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; c = c + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;
    RETURN (&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;SELECT&lt;/span&gt; c &lt;span class=&quot;hljs-keyword&quot;&gt;FROM&lt;/span&gt; counter &lt;span class=&quot;hljs-keyword&quot;&gt;LIMIT&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;
  &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;END&lt;/span&gt; //
DELIMITER ;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字符集和排序规则：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;FUNCTION&lt;/span&gt; hello2 (s &lt;span class=&quot;hljs-built_in&quot;&gt;CHAR&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;))
  &lt;span class=&quot;hljs-keyword&quot;&gt;RETURNS&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;CHAR&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;) &lt;span class=&quot;hljs-built_in&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'utf8'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;COLLATE&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'utf8_bin'&lt;/span&gt; DETERMINISTIC
  &lt;span class=&quot;hljs-keyword&quot;&gt;RETURN&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;CONCAT&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;'Hello, '&lt;/span&gt;,s,&lt;span class=&quot;hljs-string&quot;&gt;'!'&lt;/span&gt;);&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8698943.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8698943.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Apr 2018 15:56:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8698943.html</dc:identifier>
</item>
<item>
<title>xShell终端下中文乱码问题 - tp_16b</title>
<link>http://www.cnblogs.com/tp-16b/p/8698870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tp-16b/p/8698870.html</guid>
<description>&lt;p&gt;今天，可能是因为不小心中途打断了xShell更新，结果打开xShell发现里面的中文全成了乱码。于是去网上查了一下原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 更新xshell（xshell5）以及其他终端中文乱码的原因无非有三种&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）xshell终端的编码问题（一般都是这出了点问题）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Linux系统的编码问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）前两种编码不匹配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;XShell终端编码出问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解决：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;文件 -&amp;gt;属性-&amp;gt;终端 -&amp;gt;编码设置为Unicode (UTF&lt;/strong&gt;-8)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180402233731432-662324731.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;417&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Linux系统编码问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果上面还是解决没解决问题，再试试下面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解决：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;22&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(1) 执行locale命令查看系统语言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180402234357858-51064223.png&quot; alt=&quot;&quot; width=&quot;378&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者输入 echo $LANG  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201804/1272978-20180402234628629-362605680.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;69&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;(2)设置系统环境变量LANG为en_US.UTF-8：&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;  export LANG=en_US.UTF-8&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者编辑文件：vim /etc/sysconfig/i18n&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;退出保存，去重启一下虚拟机。一般到这可以解决问题了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果上述操作后，还是有中文乱码问题，比如中文文件名、cat包含中文的文件等，可去&lt;/p&gt;
&lt;p&gt;修改Linux环境变量LANG，或者修改xshell终端编码：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;File-&amp;gt;Properties&lt;br/&gt;修改为&lt;strong&gt;Chinese Simplified (GB2312)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后，退出保存，一定确保重新启动虚拟机、xShell！再查看中文乱码是否修复。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 02 Apr 2018 15:50:00 +0000</pubDate>
<dc:creator>tp_16b</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tp-16b/p/8698870.html</dc:identifier>
</item>
<item>
<title>Java 多线程 从无到有 - 房上的猫</title>
<link>http://www.cnblogs.com/lsy131479/p/8698706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsy131479/p/8698706.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;个人总结：望对屏幕对面的您有所帮助&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402233129795-1409908453.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;&lt;span&gt;进程：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有独立的内存控件和系统资源&lt;/span&gt; &lt;span&gt;应用程序的执行实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动当前电脑任务管理器：&lt;/span&gt;taskmgr&lt;/p&gt;

&lt;p&gt;&lt;span&gt;进程是程序（任务）的执行过程，它持有资源（共享内存，共享文件）和线程。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;线程：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;进程中执行运算的最小的单位，可完成一个独立的顺序控制流程（执行路径）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CPU&lt;span&gt;调度和分派的基本单位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;一个线程的生命周期：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232820108-442142527.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;· &lt;strong&gt;&lt;span&gt;新建状态&lt;/span&gt;:&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt; new &lt;span&gt;关键字和&lt;/span&gt;&lt;span&gt; Thread &lt;/span&gt;&lt;span&gt;类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序&lt;/span&gt;&lt;span&gt; start() &lt;/span&gt;&lt;span&gt;这个线程。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;· &lt;strong&gt;&lt;span&gt;就绪状态&lt;/span&gt;:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;当线程对象调用了&lt;/span&gt;start()&lt;span&gt;方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span&gt;里线程调度器的调度。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;· &lt;strong&gt;&lt;span&gt;运行状态&lt;/span&gt;:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果就绪状态的线程获取&lt;/span&gt; CPU &lt;span&gt;资源，就可以执行&lt;/span&gt;&lt;span&gt; run()&lt;/span&gt;&lt;span&gt;，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;&lt;span&gt;阻塞状态&lt;/span&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个线程执行了&lt;/span&gt;sleep&lt;span&gt;（睡眠）、&lt;/span&gt;&lt;span&gt;suspend&lt;/span&gt;&lt;span&gt;（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;· &lt;strong&gt;&lt;span&gt;死亡状态&lt;/span&gt;:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程的状态转换&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232800224-1113473746.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;h3&gt;&lt;img alt=&quot;&quot; width=&quot;678&quot; height=&quot;488&quot;/&gt; &lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;新建状态（&lt;/span&gt;New&lt;span&gt;）：新创建了一个线程对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;就绪状态（&lt;/span&gt;Runnable&lt;span&gt;）：线程对象创建后，其他线程调用了该对象的&lt;/span&gt;&lt;span&gt;start()&lt;/span&gt;&lt;span&gt;方法。该状态的线程位于可运行线程池中，变得可运行，等待获取&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;的使用权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;运行状态（&lt;/span&gt;Running&lt;span&gt;）：就绪状态的线程获取了&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;，执行程序代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;阻塞状态（&lt;/span&gt;Blocked&lt;span&gt;）：阻塞状态是线程因为某种原因放弃&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（一）、等待阻塞：运行的线程执行&lt;/span&gt;wait()&lt;span&gt;方法，&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span&gt;会把该线程放入等待池中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则&lt;/span&gt;JVM&lt;span&gt;会把该线程放入锁池中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）、其他阻塞：运行的线程执行&lt;/span&gt;sleep()&lt;span&gt;或&lt;/span&gt;&lt;span&gt;join()&lt;/span&gt;&lt;span&gt;方法，或者发出了&lt;/span&gt;&lt;span&gt;I/O&lt;/span&gt;&lt;span&gt;请求时，&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span&gt;会把该线程置为阻塞状态。当&lt;/span&gt;&lt;span&gt;sleep()&lt;/span&gt;&lt;span&gt;状态超时、&lt;/span&gt;&lt;span&gt;join()&lt;/span&gt;&lt;span&gt;等待线程终止或者超时、或者&lt;/span&gt;&lt;span&gt;I/O&lt;/span&gt;&lt;span&gt;处理完毕时，线程重新转入就绪状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;span&gt;死亡状态（&lt;/span&gt;Dead&lt;span&gt;）：线程执行完了或者因异常退出了&lt;/span&gt;&lt;span&gt;run()&lt;/span&gt;&lt;span&gt;方法，该线程结束生命周期。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;多线程：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;线程是系统中最小的执行单元；同一进程中可以有多个线程；线程共享进程的资源。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;定义：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果一个进程中&lt;/span&gt; &lt;span&gt;同时运行了多个线程&lt;/span&gt; &lt;span&gt;，用来完成不同的工作，则称之为&lt;/span&gt; “多线程”&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多个线程交替占用&lt;/span&gt;CPU&lt;span&gt;资源，而非真正的并行执行（）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1）&lt;span&gt;充分利用&lt;/span&gt;CPU&lt;span&gt;资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;简化编程模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个线程控制一个指针&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;带来良好的用户体验&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;创建线程的方法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;有两种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;实现&lt;/span&gt;Runnable&lt;span&gt;接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拥有唯一方法：&lt;/span&gt;run（）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法&lt;/span&gt; run &lt;span&gt;的常规协定是，它可能执行任何所需的动作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JavaJDK  API &lt;span&gt;给出的解释：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Runnable &lt;span&gt;接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为&lt;/span&gt; &lt;span&gt;run&lt;/span&gt; &lt;span&gt;的无参数方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计该接口的目的是为希望在活动时执行代码的对象提供一个公共协议。例如，&lt;/span&gt;Thread &lt;span&gt;类实现了&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;。激活的意思是说某个线程已启动并且尚未停止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外，&lt;/span&gt;Runnable &lt;span&gt;为非&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;子类的类提供了一种激活方式。通过实例化某个&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;实例并将自身作为运行目标，就可以运行实现&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;的类而无需创建&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;的子类。大多数情况下，如果只想重写&lt;/span&gt; &lt;span&gt;run()&lt;/span&gt; &lt;span&gt;方法，而不重写其他&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;方法，那么应使用&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;接口。这很重要，因为除非程序员打算修改或增强类的基本行为，否则不应为该类创建子类。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;2. &lt;span&gt;继承&lt;/span&gt;Thread&lt;span&gt;类本身&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;Thread&lt;span&gt;类：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Java&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;java.lang.Thread&lt;/span&gt;&lt;span&gt;类支持多线程编程&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1. &lt;strong&gt;Thread&lt;span&gt;类常用的构造方法：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;&lt;tbody readability=&quot;12.148946840522&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;662&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方法描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;662&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;public &lt;strong&gt;Thread&lt;/strong&gt;()&lt;/p&gt;
&lt;p&gt;分配新的 Thread 对象。这种构造方法与 Thread(null, null, &lt;em&gt;gname&lt;/em&gt;) 具有相同的作用，其中 &lt;strong&gt;&lt;em&gt;gname&lt;/em&gt;&lt;/strong&gt; 是一个新生成的名称。自动生成的名称的形式为 &quot;Thread-&quot;+&lt;em&gt;n&lt;/em&gt;，其中的 &lt;em&gt;n&lt;/em&gt; 为整数。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11.700934579439&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;662&quot; readability=&quot;12.673981191223&quot;&gt;
&lt;p&gt;public &lt;strong&gt;Thread&lt;/strong&gt;(&lt;a title=&quot;java.lang 中的接口&quot;&gt;Runnable&lt;/a&gt;&lt;span&gt; target)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分配新的 Thread 对象。这种构造方法与 Thread(null, target,&lt;em&gt;gname&lt;/em&gt;) 具有相同的作用，其中的 &lt;em&gt;gname&lt;/em&gt; 是一个新生成的名称。自动生成的名称的形式为 “Thread-”+&lt;em&gt;n&lt;/em&gt;，其中的 &lt;em&gt;n&lt;/em&gt; 为整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;target - 其 run 方法被调用的对象。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12.241666666667&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;662&quot; readability=&quot;14.117647058824&quot;&gt;
&lt;p&gt;public &lt;strong&gt;Thread&lt;/strong&gt;(&lt;a title=&quot;java.lang 中的接口&quot;&gt;Runnable&lt;/a&gt;&lt;span&gt; target,&lt;/span&gt;&lt;a title=&quot;java.lang 中的类&quot;&gt;String&lt;/a&gt;&lt;span&gt; name)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分配新的 Thread 对象。这种构造方法与 Thread(null, target, name) 具有相同的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;target - 其 run 方法被调用的对象。&lt;/p&gt;
&lt;p&gt;name - 新线程的名称。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.1724137931034&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;662&quot; readability=&quot;11.581395348837&quot;&gt;
&lt;p&gt;public &lt;strong&gt;Thread&lt;/strong&gt;(&lt;a title=&quot;java.lang 中的类&quot;&gt;String&lt;/a&gt;&lt;span&gt; name)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分配新的 Thread 对象。这种构造方法与 Thread(null, null, name) 具有相同的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;name - 新线程的名称。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;2. &lt;strong&gt;Thread&lt;span&gt;类的一些重要方法&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;对象调用&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方法描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public void start()&lt;/strong&gt;&lt;br/&gt;使该线程开始执行；&lt;strong&gt;Java&lt;/strong&gt; 虚拟机调用该线程的 run 方法。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;public void run()&lt;/strong&gt;&lt;br/&gt;如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final void setName(String name)&lt;/strong&gt;&lt;br/&gt;改变线程名称，使之与参数 name 相同。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final void setPriority(int priority)&lt;/strong&gt;&lt;br/&gt; 更改线程的优先级。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final void setDaemon(boolean on)&lt;/strong&gt;&lt;br/&gt;将该线程标记为守护线程或用户线程。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final void join(long millisec)&lt;/strong&gt;&lt;br/&gt;等待该线程终止的时间最长为 millis 毫秒。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public void interrupt()&lt;/strong&gt;&lt;br/&gt;中断线程。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final boolean isAlive()&lt;/strong&gt;&lt;br/&gt;测试线程是否处于活动状态。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;3. &lt;strong&gt;Thread&lt;span&gt;类的&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;静态&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;直接调用&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方法描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public static void yield()&lt;/strong&gt;&lt;br/&gt;暂停当前正在执行的线程对象，并执行其他线程。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;public static void sleep(long millisec)&lt;/strong&gt;&lt;br/&gt;在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;public static boolean holdsLock(Object x)&lt;/strong&gt;&lt;br/&gt;当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public static Thread currentThread()&lt;/strong&gt;&lt;br/&gt;返回对当前正在执行的线程对象的引用。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public static void dumpStack()&lt;/strong&gt;&lt;br/&gt;将当前线程的堆栈跟踪打印至标准错误流。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;





&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;主线程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;每一个进程至少只有一个线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;main&lt;span&gt;（）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;方法即为主线程入口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;产生其他子线程的线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;必须&lt;/span&gt;&lt;span&gt;最后&lt;/span&gt;&lt;span&gt;完成执行，因为它执行各种关闭动作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232650979-723556431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; width=&quot;621&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;常见线程名词解释&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;主线程&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;JVM&lt;span&gt;调用程序&lt;/span&gt;&lt;span&gt;main()&lt;/span&gt;&lt;span&gt;所产生的线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;当前线程&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：这个是容易混淆的概念。一般指通过&lt;/span&gt;Thread.currentThread()&lt;span&gt;来获取的进程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后台线程&lt;/span&gt;&lt;span&gt;：指为其他线程提供服务的线程，也称为守护线程。&lt;/span&gt;JVM&lt;span&gt;的垃圾回收线程就是一个后台线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前台线程&lt;/span&gt;&lt;span&gt;：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过&lt;/span&gt;isDaemon()&lt;span&gt;和&lt;/span&gt;&lt;span&gt;setDaemon()&lt;/span&gt;&lt;span&gt;方法来判断和设置一个线程是否为后台线程。&lt;/span&gt;&lt;/p&gt;







&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;定义一个类继承&lt;/span&gt;Thread&lt;span&gt;类&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;建议：类名以&lt;/span&gt;Thread&lt;span&gt;结尾，（清晰）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;public class MyThread extends Thread{&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;重写&lt;/span&gt;run&lt;span&gt;（）方法，编写线程执行体&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;执行的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逻辑处理代码&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. &lt;strong&gt;&lt;span&gt;创建线程对象，调用&lt;/span&gt;start&lt;span&gt;（）方法启动线程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
类 对象 =  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; 类（）； 
        对象.start（）；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将会执行步骤二中重写后的run（）方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;当多个线程同时启动时：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程间交替执行，顺序不定，根据&lt;/span&gt;CPU&lt;span&gt;分配的时间片觉得的（不可预测）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个线程分别执行，几条不同的执行过程，交替并行执行&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;&lt;span&gt;为什么不直接调用&lt;/span&gt;run&lt;span&gt;（）方法？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;如果直接调用&lt;/span&gt;run()&lt;span&gt;方法：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;执行的线程是&lt;/span&gt;main&lt;span&gt;（）&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;主 线程，并且不是并行执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;只有&lt;/span&gt;&lt;span&gt;主线程&lt;/span&gt;&lt;span&gt;一条&lt;/span&gt;&lt;span&gt;执行路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;依次&lt;/span&gt;&lt;span&gt;调用相应次数的&lt;/span&gt;run&lt;span&gt;（）方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;相当于&lt;/span&gt;&lt;span&gt;单线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. Run&lt;span&gt;（）方法是给底层编译器用的，程序员只能用&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;（）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;执行结构图：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232442928-1756875636.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;h3&gt;&lt;img alt=&quot;&quot; width=&quot;553&quot; height=&quot;518&quot;/&gt; &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;如果是调用&lt;/span&gt;Start&lt;span&gt;（）方法：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1）&lt;span&gt;不同子线程获取到&lt;/span&gt;CPU&lt;span&gt;时间片时，执行其线程的相应操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;多态执行路径，主线程和子线程并行交替执行&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;多个线程同时执行？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;多个线程交替执行，不是真正的&lt;/span&gt; “并行”&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;线程每次执行时长由分配的&lt;/span&gt;CPU&lt;span&gt;时间片长度觉得&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;&lt;span&gt;广义解释：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;线程中的方法比较有特点，比如&lt;/span&gt;:启动（start），休眠（sleep），停止等，多个线程是交互执行的（cpu在某个时刻。只能执行一个线程，当一个线程休眠了或者执行完毕了，另一个线程才能占用cpu来执行）因为这是cpu的结构来决定的，在某个时刻cpu只能执行一个线程，不过速度相当快，对于人来将可以认为是并行执行的。&lt;/p&gt;

&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;定义类实现&lt;/span&gt;Runnable&lt;span&gt;接口&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;public class MyRunnable impleents Runnable{&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;实现&lt;/span&gt;run&lt;span&gt;（）方法，编写线程执行体&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;run()&lt;span&gt;方法中编写线程执行的代码&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. &lt;strong&gt;&lt;span&gt;创建线程对象，调用&lt;/span&gt;start&lt;span&gt;（）方法启动线程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;实现&lt;/span&gt;Runnable&lt;span&gt;接口创建的线程最终还是要通过将自身实例作为参数传递给&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;然后执行&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;语法：&lt;/span&gt;   &lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Thread actress=new Thread(Runnable target ,String name);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;   &lt;/p&gt;
&lt;p&gt;Thread actressThread=new Thread(new Actress(),&quot;Ms.runnable&quot;);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;/span&gt; actressThread.start();&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;分析：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;使用方式或限制等，与&lt;/span&gt; &lt;span&gt;继承&lt;/span&gt;Thread&lt;span&gt;类 大相径庭&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法必须实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;创建&lt;/span&gt;Runnable&lt;span&gt;实现类对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;将实现类对象交于&lt;/span&gt;Thread&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;启动线程&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4. &lt;strong&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.&lt;span&gt;可以避免&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;的单继承的特性带来的局限性；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;适合多个相同程序的代码去处理同一个资源情况，把线程同程序的代码及数据有效的分离，较好的体现了面向对象的设计思想。开发中大多数情况下都使用实现&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;接口这种方法创建线程。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;5. &lt;strong&gt;&lt;span&gt;分析：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;计算机&lt;/span&gt;CPU&lt;span&gt;处理器在同一时间同一个处理器同一个核只能运行一条线程，当一条线程休眠之后，另外一个线程才获得处理器时间&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;继承&lt;/span&gt;Thread&lt;span&gt;类&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1) &lt;span&gt;编写简单，可直接操作线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2) &lt;span&gt;适用于但继承&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;实现&lt;/span&gt;Runnable&lt;span&gt;接口&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1）&lt;span&gt;避免但继承的局限性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;便于共享资源&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. &lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;Java&lt;span&gt;只适用于单根继承）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;推荐使用&lt;/span&gt; &lt;span&gt;实现&lt;/span&gt;Runnable&lt;span&gt;接口&lt;/span&gt; &lt;span&gt;方式创建线程&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;线程的状态&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232410021-808769784.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;h2&gt;&lt;img alt=&quot;&quot; width=&quot;691&quot; height=&quot;205&quot;/&gt; &lt;/h2&gt;

&lt;p&gt;&lt;span&gt;五个状态：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建&lt;/span&gt; &lt;span&gt;就绪&lt;/span&gt; &lt;span&gt;阻塞&lt;/span&gt; &lt;span&gt;运行&lt;/span&gt; &lt;span&gt;死亡&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;线程调度的方法&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;线程调度指按照特定机制为多个线程分配&lt;/span&gt;CPU&lt;span&gt;的使用权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232327301-517692844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; width=&quot;692&quot; height=&quot;349&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;4. &lt;strong&gt;&lt;span&gt;线程唤醒：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Object&lt;span&gt;类中的&lt;/span&gt;&lt;span&gt;notify()&lt;/span&gt;&lt;span&gt;方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个&lt;/span&gt;&lt;span&gt;notifyAll()&lt;/span&gt;&lt;span&gt;，唤醒在此对象监视器上等待的所有线程。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;Thread&lt;span&gt;中&lt;/span&gt;&lt;span&gt;suspend()&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;resume()&lt;/span&gt;&lt;span&gt;两个方法在&lt;/span&gt;&lt;span&gt;JDK1.5&lt;/span&gt;&lt;span&gt;中已经废除&lt;/span&gt;&lt;span&gt;。原因：&lt;/span&gt;&lt;span&gt;有死锁倾向。&lt;/span&gt;&lt;/p&gt;




&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;调整线程优先级：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程的优先级&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;线程优先级由&lt;/span&gt;1 - 10&lt;span&gt;表示，&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;最低，默认优点级为&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优先级高的线程获得&lt;/span&gt;CPU&lt;span&gt;资源&lt;/span&gt;&lt;span&gt;概率&lt;/span&gt;&lt;span&gt;较大&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;调整线程优先级&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;setPriority()&lt;span&gt;方法&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;h5&gt;&lt;strong&gt;&lt;span&gt;取值：&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;线程的优先级代表哪个线程&lt;/span&gt;&lt;span&gt;优先&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;CPU&lt;span&gt;资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一个&lt;/span&gt;Java&lt;span&gt;线程都有一个优先级，这样&lt;/span&gt;&lt;span&gt;有助于操作系统确定线程的调度顺序&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Java&lt;span&gt;线程的&lt;/span&gt;&lt;span&gt;优先级用整数表示&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;取值范围是&lt;/span&gt;1~10&lt;span&gt;，&lt;/span&gt;Thread&lt;span&gt;类&lt;/span&gt;&lt;span&gt;有以下三个&lt;/span&gt;&lt;span&gt;静态常量&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;static int MAX_PRIORITY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          &lt;span&gt;线程可以具有的&lt;/span&gt;&lt;span&gt;最高优先级&lt;/span&gt;&lt;span&gt;，取值为&lt;/span&gt;10&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;static int MIN_PRIORITY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          &lt;span&gt;线程可以具有的&lt;/span&gt;&lt;span&gt;最低优先级&lt;/span&gt;&lt;span&gt;，取值为&lt;/span&gt;1&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;static int NORM_PRIORITY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          &lt;span&gt;分配给线程的&lt;/span&gt;&lt;span&gt;默认优先级&lt;/span&gt;&lt;span&gt;，取值为&lt;/span&gt;5&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;&lt;span&gt;补充：&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;Thread&lt;span&gt;类的&lt;/span&gt;&lt;span&gt;setPriority()&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;getPriority()&lt;/span&gt;&lt;span&gt;方法分别用来&lt;/span&gt;&lt;span&gt;设置和获取线程的优先级&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个线程都有默认的优先级。&lt;/span&gt;&lt;span&gt;主线程的默认优先级为&lt;/span&gt;Thread.NORM_PRIORITY&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;线程的优先级有继承关系&lt;/span&gt;&lt;span&gt;，比如&lt;/span&gt;A&lt;span&gt;线程中创建了&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;线程，那么&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;将和&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;具有相同的优先级。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;JVM&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具有较高优先级的线程对程序更重要，并&lt;/span&gt;&lt;span&gt;且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;线程睡眠：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;使用：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;让线程暂时睡眠指定时长，线程进入阻塞状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;睡眠过后线程会再进入可运行状态&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;sleep&lt;span&gt;（）方法：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Thread.sleep(long millis)&lt;span&gt;方法，使线程转到阻塞状态。&lt;/span&gt;&lt;span&gt;millis&lt;/span&gt;&lt;span&gt;参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;）状态。&lt;/span&gt;&lt;span&gt;sleep()&lt;/span&gt;&lt;span&gt;平台移植性好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：调度&lt;/span&gt;sleep&lt;span&gt;（）方法需处理&lt;/span&gt;&lt;span&gt;InterruptedException&lt;/span&gt;&lt;span&gt;异常&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3. &lt;strong&gt;&lt;span&gt;线程等待：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Object&lt;span&gt;类中的&lt;/span&gt;&lt;span&gt;wait()&lt;/span&gt;&lt;span&gt;方法，导致当前的线程等待，直到其他线程调用此对象的&lt;/span&gt; &lt;span&gt;notify()&lt;/span&gt; &lt;span&gt;方法或&lt;/span&gt; &lt;span&gt;notifyAll()&lt;/span&gt; &lt;span&gt;唤醒方法。这个两个唤醒方法也是&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;类中的方法，行为等价于调用&lt;/span&gt; &lt;span&gt;wait(0)&lt;/span&gt; &lt;span&gt;一样。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;使线程暂停执行，等待其他线程结束后再继续执行本线程&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;线程加入：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;join()&lt;span&gt;方法，等待其他线程终止。在当前线程中调用另一个线程的&lt;/span&gt;&lt;span&gt;join()&lt;/span&gt;&lt;span&gt;方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：需处理&lt;/span&gt;InterruptedException&lt;span&gt;异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232140006-1429946314.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; width=&quot;692&quot; height=&quot;157&quot;/&gt; &lt;/p&gt;
&lt;p&gt;Mills&lt;span&gt;：以毫秒为单位的等待时长&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Nanos&lt;span&gt;：要等待的附加纳秒时长&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;主线程将被执行，执行调用&lt;/span&gt;join&lt;span&gt;（）方法的子线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当此子线程执行完毕后，再返回执行主线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（其他线程避让（阻塞），此线程强制加入执行）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;让当前线程让出&lt;/span&gt;CPU&lt;span&gt;资源，不再参与资源抢占&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;暂停当前线程，允许其他具有相同优先级的线程获得运行机会（不一定会执行）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;改线程处于就绪状态，不转为阻塞状态&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;只能提供一种可能，但是不能保证一定会实现礼让&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;线程让步：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Thread.yield() &lt;span&gt;方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当多个线程共享同一资源同时访问一个数据的时候，一个线程未完成全部操作的时候，其他的线程来修改数据数据，会造成线程不安全问题&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;争用条件：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1&lt;span&gt;、当多个线程同时共享访问同一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏（&lt;/span&gt;&lt;span&gt;corrupted)&lt;/span&gt;&lt;span&gt;，这种现象称为争用条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、原因是，每个线程在操作数据时，会先将数据初值读【取到自己获得的内存中】，然后在内存中进行运算后，重新赋值到数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;、争用条件：线程&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;在还【未重新将值赋回去时】，线程&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;阻塞，线程&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;开始访问该数据，然后进行了修改，之后被阻塞的线程&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;再获得资源，而将之前计算的值覆盖掉线程&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;所修改的值，就出现了数据丢失情况。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;&lt;span&gt;系统占用&lt;/span&gt;CPU&lt;span&gt;资源：随机性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;同步方法：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;synchronzed&lt;span&gt;修饰的方法控制对类成员变量的访问&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Synchronized&lt;span&gt;就是为当前的线程声明一个锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一次只允许有一个线程进入执行&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;访问修饰符&lt;/span&gt; synchronized &lt;span&gt;返回类型 方法名 （参数列表）&lt;/span&gt;&lt;span&gt;{ ... ... }&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;p&gt;Synchronized &lt;span&gt;访问修饰符 返回类型 方法名 （参数列表）&lt;/span&gt;&lt;span&gt;{ ... ... }&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;&lt;span&gt;同步代码块：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;synchronized&lt;span&gt;关键字修饰的代码块&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Synchronized&lt;span&gt;（&lt;/span&gt;&lt;span&gt;syncObject&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//&lt;span&gt;需要同步的代码块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1）yncObject&lt;span&gt;为需同步的对象，通常为&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;效果与同步方法相同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;避免数据不安全问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4）&lt;span&gt;一次只允许有一个线程进入&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;互斥与同步：守恒的能量&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1、线程的特点，共享同一进程的资源，同一时刻只能有一个线程占用CPU&lt;/p&gt;
&lt;p&gt;2、由于线程有如上的特点，所以就会存在多个线程争抢资源的现象，就会存在争用条件这种现象&lt;/p&gt;
&lt;p&gt;3、为了让线程能够正确的运行，不破坏共享的数据，所以，就产生了同步和互斥的两种线程运行的机制&lt;/p&gt;
&lt;p&gt;4、线程的互斥（加锁实现）：线程的运行隔离开来，互不影响，使用synchronized关键字实现互斥行为，此关键字即可以出现在方法体之上也可以出现在方法体内，以一种块的形式出现，在此代码块中有线程的等待和唤醒动作，用于支持线程的同步控制&lt;/p&gt;
&lt;p&gt;5、线程的同步（线程的等待和唤醒：wait()+notifyAll()）：线程的运行有相互的通信控制，运行完一个再正确的运行另一个&lt;/p&gt;
&lt;p&gt;6、锁的概念：比如private final Object lockObj=new Object();&lt;/p&gt;
&lt;p&gt;7、互斥实现方式：synchronized关键字&lt;/p&gt;
&lt;p&gt;synchronized(lockObj){---执行代码----}加锁操作&lt;/p&gt;
&lt;p&gt;lockObj.wait();线程进入等待状态，以避免线程持续申请锁，而不去竞争cpu资源&lt;/p&gt;
&lt;p&gt;lockObj.notifyAll();唤醒所有lockObj对象上等待的线程&lt;/p&gt;
&lt;p&gt;8、&lt;span&gt;加锁操作会开销系统资源，降低效率&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;## &lt;span&gt;同步和锁定&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1&lt;span&gt;、锁的原理&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Java中每个对象都有一个内置锁&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当程序运行到非静态的&lt;/span&gt;synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当程序运行到&lt;/span&gt;synchronized同步方法或代码块时才该对象锁才起作用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的&lt;/span&gt;synchronized方法或代码块，直到该锁被释放。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;释放锁是指持锁线程退出了&lt;/span&gt;synchronized同步方法或代码块。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;关于锁和同步，有一下几个要点：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1）、只能同步方法，而不能同步变量和类；&lt;/p&gt;
&lt;p&gt;2）、每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？&lt;/p&gt;
&lt;p&gt;3）、不必同步类中所有的方法，类可以同时拥有同步和非同步方法。&lt;/p&gt;
&lt;p&gt;4）、如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。&lt;/p&gt;
&lt;p&gt;5）、如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。&lt;/p&gt;
&lt;p&gt;6）、线程睡眠时，它所持的任何锁都不会释放。&lt;/p&gt;
&lt;p&gt;7）、线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。&lt;/p&gt;
&lt;p&gt;8）、同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。&lt;/p&gt;
&lt;p&gt;9）、在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;多个并发线程访问同一资源的同步代码块时&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;同一时刻只能有一个线程进入&lt;/span&gt;synchronized (this )同步代码块&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;当一个线程访问一个&lt;/span&gt;synchronized (this) 同步代码块时，其他synchronized (this) 同步代码块同样被锁定&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;当一个线程访问一个&lt;/span&gt;synchronized (this) 同步代码块时，其他线程可以访问该资源的非synchronized (this) 同步代码&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;## &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;线程同步小结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1、线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏。&lt;/p&gt;
&lt;p&gt;2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。&lt;/p&gt;
&lt;p&gt;3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。&lt;/p&gt;
&lt;p&gt;4、对于同步，要时刻清醒在哪个对象上同步，这是关键。&lt;/p&gt;
&lt;p&gt;5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。&lt;/p&gt;
&lt;p&gt;6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。&lt;/p&gt;
&lt;p&gt;7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;## 深入剖析互斥与同步&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;互斥的实现（加锁）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;strong&gt;synchronized&lt;/strong&gt;(lockObj); 保证的同一时间，只有一个线程获得lockObj.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;同步的实现：&lt;/span&gt;wait()/notify()/notifyAll()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;wait()、notify()、notifyAll()方法均属于Object对象，而不是Thread对象。&lt;/p&gt;
&lt;p&gt;void notify() &lt;br/&gt;          唤醒在此对象监视器上等待的单个线程。 &lt;br/&gt; void notifyAll() &lt;br/&gt;          唤醒在此对象监视器上等待的所有线程。 &lt;br/&gt; void wait() &lt;br/&gt;          导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然，&lt;/span&gt;wait()还有另外两个重载方法：&lt;/p&gt;
&lt;p&gt; void wait(long timeout) &lt;br/&gt;          导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。 &lt;br/&gt; void wait(long timeout, int nanos) &lt;br/&gt;          导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;同步是两个线程之间的一种交互的操作（一个线程发出消息另外一个线程响应）&lt;/span&gt; &lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;关于等待&lt;/span&gt;/通知，要记住的关键点是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;必须从同步环境内调用&lt;/span&gt;wait()、notify()、notifyAll()方法。线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。&lt;/p&gt;
&lt;p&gt;wait()、notify()、notifyAll()都是Object的实例方法。与每个对象具有锁一样，每个对象可以有一个线程列表，他们等待来自该信号（通知）。线程通过执行对象上的wait()方法获得这个等待列表。从那时候起，它不再执行任何其他指令，直到调用对象的notify()方法为止。如果多个线程在同一个对象上等待，则将只选择一个线程（不保证以何种顺序）继续执行。如果没有线程等待，则不采取任何特殊操作。&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;span&gt;千万注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当在对象上调用&lt;/span&gt;wait()方法时，执行该代码的线程立即放弃它在对象上的锁。然而调用notify()时，并不意味着这时线程会放弃其锁。如果线程荣然在完成同步代码，则线程在移出之前不会放弃锁。因此，只要调用notify()并不意味着这时该锁变得可用。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;多个线程在等待一个对象锁时候使用&lt;/span&gt;notifyAll()&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在多数情况下，最好通知等待某个对象的所有线程。如果这样做，可以在对象上使用&lt;/span&gt;notifyAll()让所有在此对象上等待的线程冲出等待区，返回到可运行状态。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt; ### &lt;span&gt;如何理解同步：&lt;/span&gt;&lt;span&gt;Wait Set&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Critical Section（临界资源）Wait Set（等待区域）&lt;/p&gt;
&lt;p&gt;wait set 类似于线程的休息室，访问共享数据的代码称为critical section。一个线程获取锁，然后进入临界区，发现某些条件不满足，然后调用锁对象上的wait方法，然后线程释放掉锁资源，进入锁对象上的wait set。由于线程释放释放了理解资源，其他线程可以获取所资源，然后执行，完了以后调用notify，通知锁对象上的等待线程。&lt;/p&gt;
&lt;p&gt;Ps：若调用notify();则随机拿出（这随机拿出是内部的算法，无需了解）一条在等待的资源进行准备进入Critical Section；若调用notifyAll();则全部取出进行准备进入Critical Section。&lt;/p&gt;



&lt;h2&gt;&lt;strong&gt;&lt;span&gt;个人理解：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;span&gt;多个线程各有自己的锁，都想拿到自己的锁，但谁都不想放开自己的锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多个线程执行不同的上锁代码块但共享同一资源，双方都抢不到&lt;/span&gt;CPU&lt;span&gt;时间片，就形成了死锁&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;资料解释：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;死锁&lt;/span&gt;--&lt;span&gt;两个线程都在等待对方完成，造成程序的停滞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;死锁的条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;两个或两个以上的线程在活动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;某个线程拿到一个锁以后，还想拿第二个锁，造成锁的嵌套&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;生产者和消费者问题，生产者不断生成，消费者不断取走生产者生成的产品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生产者生产出信息之后将其放到一个区域之中，之后消费者从此区域里取出数据&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;Object&lt;span&gt;类中的&lt;/span&gt;Wait&lt;span&gt;（&lt;/span&gt;&lt;span&gt;线程等待&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt; &lt;span&gt;与&lt;/span&gt; notifyAll(&lt;span&gt;唤醒所有线程&lt;/span&gt;)&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。&lt;/p&gt;
&lt;p&gt;2、可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;为什么使用线程池？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程缺乏统一管理，占用过多系统资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺乏更多功能，如定时执行，定期执行等&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用线程池的好处&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;重用存在的线程，减少对象创建，消亡开销&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;有效控制最大并发数，提高系统资源使用率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;定时执行，定期执行&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;实现原理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（线程比作员工，线程池比作一个团队，核心池比作团队中核心团队员工数，核心池外的比作外包员工）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;有了新需求，先看核心员工数量超没超出最大核心员工数，还有名额的话就新招一个核心员工来做&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;需要获取全局锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;核心员工已经最多了，&lt;/span&gt;HR 不给批 HC 了，那这个需求只好攒着，放到待完成任务列表吧&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;如果列表已经堆满了，核心员工基本没机会搞完这么多任务了，那就找个外包吧&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;需要获取全局锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;如果核心员工&lt;/span&gt; + 外包员工的数量已经是团队最多能承受人数了，没办法，这个需求接不了了&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232041819-1948989811.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;

&lt;h2&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;使用：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;线程池所在包：&lt;/span&gt;java.util.concurrent&lt;/p&gt;
&lt;p&gt;&lt;span&gt;顶级接口是&lt;/span&gt;Excutor&lt;span&gt;，&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;子接口&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;真正的线程池接口是&lt;/span&gt;&lt;span&gt;ExecutorService&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Java.util.concurrent.Executors&lt;span&gt;类提供创建线程池的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232020192-1696493944.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; width=&quot;692&quot; height=&quot;222&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;ThreadPoolExcecutor&lt;span&gt;类的使用&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;（自定义线程池）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;构造器中各个参数的含义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。&lt;/span&gt;corePoolSize: &lt;span&gt;核心池的大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。&lt;/span&gt;maximumPoolSize: &lt;span&gt;线程池最大线程数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;keepAliveTime: &lt;span&gt;表示线程没有任务执行时最多保持多久时间会终止&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;unit: &lt;span&gt;参数&lt;/span&gt;&lt;span&gt;keepAliveTime&lt;/span&gt;&lt;span&gt;的时间单位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;workQueue: &lt;span&gt;一个阻塞队列，用来存储等待执行的任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;threadFactory: &lt;span&gt;线程工厂，主要用来创建线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;handler: &lt;span&gt;表示当拒绝处理任务时的策略&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;· corePoolSize&lt;span&gt;：核心线程池数量&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;在线程数少于核心数量时，有新任务进来就新建一个线程，即使有的线程没事干&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· &lt;span&gt;等超出核心数量后，就不会新建线程了，空闲的线程就得去任务队列里取任务执行了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· maximumPoolSize&lt;span&gt;：最大线程数量&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;包括核心线程池数量&lt;/span&gt; + 核心以外的数量&lt;/p&gt;
&lt;p&gt;· &lt;span&gt;如果任务队列满了，并且池中线程数小于最大线程数，会再创建新的线程执行任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· keepAliveTime&lt;span&gt;：核心池以外的线程存活时间，即没有任务的外包的存活时间&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;如果给线程池设置&lt;/span&gt; allowCoreThreadTimeOut(true)&lt;span&gt;，则核心线程在空闲时头上也会响起死亡的倒计时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· &lt;span&gt;如果任务是多而容易执行的，可以调大这个参数，那样线程就可以在存活的时间里有更大可能接受新任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· workQueue&lt;span&gt;：保存待执行任务的阻塞队列&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;不同的任务类型有不同的选择，下一小节介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· threadFactory&lt;span&gt;：每个线程创建的地方&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;可以给线程起个好听的名字，设置个优先级啥的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· handler&lt;span&gt;：饱和策略，大家都很忙，咋办呢，有四种策略&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· CallerRunsPolicy&lt;span&gt;：只要线程池没关闭，就直接用调用者所在线程来运行任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· AbortPolicy&lt;span&gt;：直接抛出&lt;/span&gt; RejectedExecutionException 异常&lt;/p&gt;
&lt;p&gt;· DiscardPolicy&lt;span&gt;：悄悄把任务放生，不做了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· DiscardOldestPolicy&lt;span&gt;：把队列里待最久的那个任务扔了，然后再调用&lt;/span&gt; execute() 试试看能行不&lt;/p&gt;
&lt;p&gt;· &lt;span&gt;我们也可以实现自己的&lt;/span&gt; RejectedExecutionHandler 接口自定义策略，比如如记录日志什么的&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;保存待执行任务的阻塞队列&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;当线程池中的核心线程数已满时，任务就要保存到队列中了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;线程池中使用的队列是&lt;/span&gt; BlockingQueue 接口，常用的实现有如下几种：&lt;/p&gt;
&lt;p&gt;· ArrayBlockingQueue：基于数组、有界，按 FIFO（先进先出）原则对元素进行排序&lt;/p&gt;
&lt;p&gt;· LinkedBlockingQueue：基于链表，按FIFO （先进先出） 排序元素 &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;吞吐量通常要高于&lt;/span&gt; ArrayBlockingQueue&lt;/p&gt;
&lt;p&gt;· Executors.newFixedThreadPool() 使用了这个队列&lt;/p&gt;
&lt;p&gt;· SynchronousQueue：不存储元素的阻塞队列 &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· &lt;span&gt;吞吐量通常要高于&lt;/span&gt; LinkedBlockingQueue&lt;/p&gt;
&lt;p&gt;· Executors.newCachedThreadPool使用了这个队列&lt;/p&gt;
&lt;p&gt;· PriorityBlockingQueue：具有优先级的、无限阻塞队列&lt;/p&gt;






&lt;p&gt;&lt;span&gt;扩展建议：如何扩展&lt;/span&gt;Java&lt;span&gt;并发知识&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Java Memory Mode : JMM&lt;/span&gt;&lt;span&gt;描述了&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;线程如何通过内存进行交互，了解&lt;/span&gt;&lt;span&gt;happens-before , synchronized,voliatile &amp;amp; final&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Locks % Condition&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;锁机制和等待条件的高层实现&lt;/span&gt; &lt;span&gt;java.util,concurrent.locks&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;、线程安全性：原子性与可见性，&lt;/span&gt; &lt;span&gt;java.util.concurrent.atomic synchronized&lt;/span&gt;&lt;span&gt;（锁的方法块）&lt;/span&gt;&lt;span&gt;&amp;amp;volatile&lt;/span&gt;&lt;span&gt;（定义公共资源）&lt;/span&gt; &lt;span&gt;DeadLocks(&lt;/span&gt;&lt;span&gt;死锁）&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;了解什么是死锁，死锁产生的条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4&lt;span&gt;、多线程编程常用的交互模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· Producer-Consumer&lt;span&gt;模型（生产者&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;消费者模型）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· Read-Write Lock&lt;span&gt;模型（读写锁模型）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· Future&lt;span&gt;模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· Worker Thread&lt;span&gt;模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;考虑在&lt;/span&gt;Java&lt;span&gt;并发实现当中，有哪些类实现了这些模型，供我们直接调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Java5&lt;/span&gt;&lt;span&gt;中并发编程工具：&lt;/span&gt;&lt;span&gt;java.util.concurrent&lt;/span&gt; &lt;span&gt;包下的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：线程池&lt;/span&gt;ExcutorService &lt;span&gt;、&lt;/span&gt;&lt;span&gt;Callable&amp;amp;Future&lt;/span&gt; &lt;span&gt;、&lt;/span&gt;&lt;span&gt;BlockingQueue&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img id=&quot;uploading_image_92934&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;（C） 房上的猫 。 保留所有权利。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt; https://www.cnblogs.com/lsy131479/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如需转载，请注明出处！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Apr 2018 15:33:00 +0000</pubDate>
<dc:creator>房上的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsy131479/p/8698706.html</dc:identifier>
</item>
</channel>
</rss>