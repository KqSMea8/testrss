<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>1.1用图表分析单变量数据 - 渔单渠</title>
<link>http://www.cnblogs.com/yudanqu/p/9727257.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudanqu/p/9727257.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　单变量:表达式、方程式、函数或者一元多项式等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　数据：&lt;a href=&quot;http://www.presidency.ucsb.edu/data/sourequests.php&quot; target=&quot;_blank&quot;&gt;http://www.presidency.ucsb.edu/data/sourequests.php&lt;/a&gt;&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;美国总统历年在国情咨文中对国会提起的诉求数量&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;　　&lt;span&gt;本次使用到的数据量并不多，不过还是按照常规思路，通过爬虫获取。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; urllib.request
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; crawler(url):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     headers =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     req = urllib.request.Request(url, headers=&lt;span&gt;headers)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     response =&lt;span&gt; urllib.request.urlopen(req)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;     html = response.read().decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(html))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     pat = r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;tr align=&quot;center&quot;&amp;gt;(.*?)&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     re_html = re.compile(pat, re.S) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; re.S可以使匹配换行&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     trslist = re_html.findall(html) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 匹配出每条信息的数据&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;     x =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     y =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; tr &lt;span&gt;in&lt;/span&gt;&lt;span&gt; trslist:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         re_i = re.compile(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;div align=&quot;center&quot;&amp;gt;(.*?)&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, re.S)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         i =&lt;span&gt; re_i.findall(tr)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         x.append(int(i[1].strip())) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从每条数据中取出所需要的两个数据年份和诉求数量&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         y.append(int(i[2].strip()) &lt;span&gt;if&lt;/span&gt; i[2] != &lt;span&gt;''&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; 0) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当匹配到空字符串时就是数据缺失部分，用0代替&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(x,y) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看结果发现第一组和第四组数据有误，看源码发现他们两个的分类名不是使用的center标签，为了简便，手动添加这两个数据&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     x[0] = 1946
&lt;span&gt;28&lt;/span&gt;     y[0] = 41
&lt;span&gt;29&lt;/span&gt;     x[3] = 1949
&lt;span&gt;30&lt;/span&gt;     y[3] = 28
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x, y
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.presidency.ucsb.edu/data/sourequests.php&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; x, y = crawler(url)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　得到的数据：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;x：[41, 1947, 1948, 28, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, &lt;br/&gt;1961, 1962, 1963, 1964,&lt;/span&gt;&lt;span&gt; 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, &lt;br/&gt;1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, &lt;/span&gt;&lt;span&gt;1984, 1985, 1986, 1987, 1988, 1989, 1990, &lt;br/&gt;1991, 1992, 1993, 1994, 1995, 1996, 1997] &lt;/span&gt;&lt;br/&gt;&lt;span&gt;y：[16, 23, 16, 17, 20, 11, 19, 14, 39, 32, 0, 14, 0, 16, 6, 25, 24, 18, 17, 38, 31, 27, 26, &lt;br/&gt;17, 21, 20, 17, 23, 16, &lt;/span&gt;&lt;span&gt;13, 13, 21, 11, 13, 11, 8, 8, 14, 9, 7, 5, 5, 54, 34, 18, 20, 27, &lt;br/&gt;30, 22, 25, 19, 26]&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; matplotlib.pylab &lt;span&gt;import&lt;/span&gt;&lt;span&gt; frange
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; plt.figure(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; plt.title(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;All data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; plt.plot(x, y, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ro&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; plt.xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; plt.ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;No Presedential Request&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　根据获取到的数据绘制出散点图，观察其分布情况，发现有一个极大的异常点，和两个为零的异常点（获取数据时的缺失值，默认填充为0）．&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1279674/201809/1279674-20180930000646025-1349701838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;＃ 使用numpy中的求分位数函数分别计算
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; perc_25 = np.percentile(y, 25&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; perc_50 = np.percentile(y, 50&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; perc_75 = np.percentile(y, 75&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;25th Percentile = %.2f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; perc_25)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;50th Percentile = %.2f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; perc_50)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;75th Percentile = %.2f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; perc_75)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;结果：
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;25th Percentile = 13.00
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;50th Percentile = 18.50
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;75th Percentile = 25.25
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;上面已经求得各分位数值，分别在图中画出来，为了在上面原始图中画出，要放在一起执行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在图中画出第25、50、75位的百分位水平线&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ----------------------------------------&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; plt.figure(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; plt.title(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;All data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; plt.plot(x, y, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ro&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; plt.xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; plt.ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;No Presedential Request&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ----------------------------------------&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; plt.axhline(perc_25, label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;25th perc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; plt.axhline(perc_50, label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;50th perc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; plt.axhline(perc_75, label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;75th perc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; plt.legend(loc=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;best&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1279674/201809/1279674-20180930001427869-1308282861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查生成的图形中是否有异常点，若有，使用mask函数将其删除&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 0是在起初获取数据时候的缺失值的填充，根据图像看到y=54的点远远高出其他，也按异常值处理&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; y = np.array(y) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 起初发现y为0的点没有被删掉，考虑到他是对数组进行隐藏，而本来的y是个列表，因此又加了这一句，果然去掉了两个零点&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; y_masked = np.ma.masked_where(y==&lt;span&gt;0, y)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; y_masked = np.ma.masked_where(y_masked==54&lt;span&gt;, y_masked)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(y),type(y_masked))
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;&amp;lt;class 'numpy.ndarray'&amp;gt; &amp;lt;class 'numpy.ma.core.MaskedArray'&amp;gt;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;'''&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;重新绘制图像：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重新绘制图像&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; plt.figure(2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; plt.title(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Masked data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; plt.plot(x, y_masked, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ro&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; plt.xlabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; plt.ylabel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;No Presedential Request&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; plt.ylim(0, 60&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在图中画出第25、50、75位的百分位的水平线&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; plt.axhline(perc_25, label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;25th perc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; plt.axhline(perc_50, label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;50th perc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; plt.axhline(perc_75, label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;75th perc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; plt.legend(loc=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;best&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1279674/201809/1279674-20180930001740442-786180648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;得到的最后的图像，就是去除了0和54的三个异常点后的结果。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;plot &lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; plt.close(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;all&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭之前打开的所有图形&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; plt.figure(1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给图形编号，在绘制多个图形的时候有用&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; plt.title(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;All data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置标题&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; plt.plot(x, y, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ro&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &quot;ro&quot; 表示使用红色（r）的点（o）来绘图&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;百分位数&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;一组n个观测值按数值大小排列。如，处于p%位置的值称第p百分位数。p=50，等价于中位数；p=0，等价于最小值；p=100，等价于最大值。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;plt.axhline()&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　给定y的位置，从x的最小值一直画到x的最大值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　label设置名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　c参数设置线条颜色&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　eg：perc_25 = 13.00&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　plt.axhline(perc_25, label='25th perc', c='r')&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;legend(loc) &lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;plt.legend() 是将图中一些标签显示出来&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　  loc参数让pyplot决定最佳放置位置，以免影响读图&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;numpy-mask函数 &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　删除异常点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　y_masked = np.ma.masked_where(y==0, y)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　ma.masked_where函数接受两个参数，他将数组中符合条件的点进行隐藏，而不需要删除&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 29 Sep 2018 23:04:00 +0000</pubDate>
<dc:creator>渔单渠</dc:creator>
<og:description>单变量:表达式、方程式、函数或者一元多项式等 数据：http://www.presidency.ucsb.edu/data/sourequests.php美国总统历年在国情咨文中对国会提起的诉求数量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudanqu/p/9727257.html</dc:identifier>
</item>
<item>
<title>并发编程之美，带你深入理解java多线程原理 - 学电的代码人</title>
<link>http://www.cnblogs.com/wenbinshen/p/9727262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenbinshen/p/9727262.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.什么是多线程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多线程是为了使得多个线程并行的工作以完成多项任务，以提高系统的效率。线程是在同一时间需要完成多项任务的时候被实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.了解多线程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1314758/201809/1314758-20180929234949595-463990793.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;了解多线程之前我们先搞清楚几个重要的概念！&lt;/p&gt;
&lt;p&gt;如上图所示：对我们的项目有一个主内存，这个主内存里面存放了我们的共享变量、方法区、堆中的对象等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.线程的工作过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每当我们开启一个线程的时候，线程会为我们开辟一块工作内存，将主内存中的共享变量复制一个副本存入工作内存中，并协调方法区生成栈针，以及对堆的引用(指针)。&lt;/p&gt;
&lt;p&gt;如果在执行过程中线程对工作内存中的共享变量进行的修改操作，此时会向主内存回写我们修改的变量。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.多线程带来的问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们模拟这样一个场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有十个用户同时购票，但是系统中只剩下了8张票，当每个用户同时开启自己的线程，将主内存中8张票复制到工作内存中，在方法中，会判断票数是否满足要求，此时，十个线程都判断满足，都要对票数进行操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当用户一操作后，票数=8-1=7，将数据回写至主内存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户二操作后，用户二的本地内存中票数为8，则修改后票数=8-1=7，继续回写至主内存，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以此下去，在我们假设十个用户同时开启线程的情况下最后主内存中的票数肯定是7，而且十个用户均出票成功，出现了超卖的情况，这在现实场景是很危险的事！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.多线程的特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有序性：程序执行的顺序按照代码的先后顺序执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;若两个线程在不同的cpu，那么线程1改变了i的值还没刷新到主存，线程2又使用了i，那么这个i值肯定还是之前的，线程1对变量的修改线程没看到这就是可见性问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;原子性：即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在程序编译到执行的过程中，程序会经过多次重排序，源代码-&amp;gt;编译器优化重排序-&amp;gt;指令级并行重排序-&amp;gt;内存系统重排序-&amp;gt;最终执行的指令序列,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;也就是说我们编写的代码，经过这一连串的重排序后，代码很可能就和我们写的顺序不一致了，但是我们的操作系统等会保证我们&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;最终执行的指令序列与我们的源代码的结果保持一致，我们的操作系统是可以保证单线程的有序性的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.怎么解决多线程并发带来的问题？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么时候需要使用多线程？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;竞态条件：检查后执行是否满足决定下一步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法一：加锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.监视器锁synchronized，它确保了每个线程是隔离的，而且只有当一个线程执行进入带有synchronized的方法中时加锁，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当该线程为结束此方法解锁时，其它线程将挂起，直到该线程解锁后其它线程才能继续执行下去。它能够保证上述三大特性：有序性、可见性、原子性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JMM定义内存访问规范，实现有序性、可见性、原子性，共八大规则，大家可以上网了解JMM详细规则信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同步机制：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　监视器锁synchronized&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　显示锁ReentrantLock、ReadWriteLock&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　原子变量AtomicInteger、AtomicLong、AtomicBoolean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Volatile&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题：遇到同步问题如何选择具体的实现方式？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　监视器锁在jdk1.5以后，性能得到了很大的提升，并且在java版本更新中一直在被优化，而且synchronized锁可以自动实现加锁与解锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　显示锁需要我们手动解锁、加锁，容易失误导致死锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在考虑性能时，推荐使用监视器锁，当考虑功能时，推荐使用显示锁，显示锁拥有更多自定义的选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法二：线程封闭&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是线程封闭？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当访问共享的可变数据时，通常需要同步，一种避免同步的方式就是不共享数据，如果仅在单线程内访问数据，就不需要同步，这种技术称为线程封闭。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果使用线程封闭：1.栈封闭：线程为跳用方法生成栈针时局部变量就使用了线程封闭。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　2.ThreadLocal  --&amp;gt; 只有当前线程能使用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;方法三：不可变对象一定是线程安全的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最佳方案：使用线程安全的对象是实现线程安全的。 java.util.concurrent包下的类。&lt;/p&gt;

</description>
<pubDate>Sat, 29 Sep 2018 16:29:00 +0000</pubDate>
<dc:creator>学电的代码人</dc:creator>
<og:description>1.什么是多线程？ 多线程是为了使得多个线程并行的工作以完成多项任务，以提高系统的效率。线程是在同一时间需要完成多项任务的时候被实现的。 2.了解多线程 了解多线程之前我们先搞清楚几个重要的概念！ 如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenbinshen/p/9727262.html</dc:identifier>
</item>
<item>
<title>python数据处理技巧二 - Cookie-Fei</title>
<link>http://www.cnblogs.com/cookie1026/p/9716251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cookie1026/p/9716251.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;首先&lt;/span&gt;&lt;span&gt;简单说下关于时间的介绍其中重点是时间戳的处理，时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。这里这个知识只做了解，接下来会用python三个关于时间的模块来定位时间，计算时间等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先让我们来验证下时间戳及怎么换算时间戳&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.要使用time方法首先要导入方法包import time&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.获取当前时间戳的方法是print time.time()就可以得到当前执行这个方法的时间(单位是秒)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.验证格林时间起始值1970-01-01 由于我们时区是北京所以后面时间用08:00:00来代表小时、分钟、秒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.简单介绍下时间格式中需要用到的格式单位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　%Y表示Year也就是年&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　%m表示Month也就是月份&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　%d表示Day也就是天&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　%H表示Hour也就是小时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　%M表示Minute也就是分钟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　%S表示Second也就是秒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面我们来看下图的验证结果:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1058502/201809/1058502-20180929225902036-698764706.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这里很清晰的验证了时间戳的作用就是时间一种表示方式：指的是从格林时间1970年1月1日到现在当前时间统计总秒数。以后看到时间戳不用慌张了，可以理解了接下来我们会教你如何转换时间及处理它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后我们来了解下常用的几个的time的方法，以下代码中有注释&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; date = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-08-08&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转换输入的时间为格式化的元祖&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; time_tuple = time.strptime(date, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strptime方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time_tuple
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转换元祖为时间戳&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; time_stamp =&lt;span&gt; time.mktime(time_tuple)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mktime方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time_stamp
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转换时间戳为格式化的元祖&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; local_time =&lt;span&gt;  time.localtime(time_stamp)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localtime方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,local_time
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转换元祖为格式化的字符串时间&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; format_time =  time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, local_time)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strftime方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,format_time,  type(format_time)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取当前时间点的时间戳&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.time()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取当前时间&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;asctime方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.asctime()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; GMT就是格林尼治标准时间&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gmtime方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.gmtime()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取格林时间的年份&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gmtime-tm_year方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.gmtime().tm_year
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取格林时间的月份&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gmtime-tm_mon方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.gmtime().tm_mon
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取格林时间的天&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gmtime-tm_mday方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.gmtime().tm_mday
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取格林时间的小时&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gmtime-tm_hour方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.gmtime().tm_hour
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取格林时间的分钟&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gmtime-tm_min方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.gmtime().tm_min
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取格林时间的秒数&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gmtime-tm_sec方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.gmtime().tm_sec
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取格林时间的星期几&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gmtime-tm_wday方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,time.gmtime().tm_wday
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取格林时间的一年中的第几天&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gmtime-tm_yday方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,time.gmtime().tm_yday
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1058502/201809/1058502-20180927232250201-2076552032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　我们在学习一个datetime方法，会有同学问这个很眼熟date+time？date表示日期也就是时间中日期一些处理方法。上面你看到又要记录输入时间格式又是转换来回导方法，方法名又接近很容易混淆，如果只是处理日期，其实datetime模块是个不错的选择，我也只简单介绍几个好用常用的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　&lt;span&gt;接下来我们再来了解下datetime模块中的方法，以下代码中有注释：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;-*- coding:utf-8 -*-&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印当前时间的格式&lt;/span&gt;
date_now =&lt;span&gt; datetime.datetime.now()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; date_now
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印当前时间的指定格式&lt;/span&gt;
date_str = datetime.datetime.now().strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H:%M:%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; date_str
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只打印今天的日期&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt; datetime.date.today()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取几几年(类型是整形,返回结果是数字)&lt;/span&gt;
y =&lt;span&gt; datetime.date.today().year
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取几月(类型是整形,返回结果是数字)&lt;/span&gt;
m =&lt;span&gt; datetime.date.today().month
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取几号(类型是整形,返回结果是数字)&lt;/span&gt;
d =&lt;span&gt; datetime.date.today().day
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印上面获取的结果:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,y,m,d
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;验证上面的类型:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,type(y),type(m),type(d)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取今天是周几:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,datetime.datetime(y, m, d).strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取指定日期是周几:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,datetime.datetime(2018, 10, 26).strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%w&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1058502/201809/1058502-20180929232132842-1093223459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这里肯定会有同学知道%w就是week也就是周(星期)的单位，是不是看了datetime的方法比time方法对于获取日期的方式还要简单。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  当然接下来要介绍一个calendar日历定位的方法，只要学会这个很容易结合上面的方法去处理日期时间的计算及时间转换，国际化中时区的控制等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.使用日历方法首先还是要导入calendar方法import calendar&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.介绍一个简单查看日历的方法calendar.month(year)可以查看一年所有的日历信息calendar.month(year,month)只查看当月日历信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.这里我们要注意的是方法中星期一到星期天用0到6表示类似range(7)输出的的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1058502/201809/1058502-20180929235733585-2120806572.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面让我们来看一些常用的方法已加注释&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; calendar
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;判断输入年份是否是闰年:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,calendar.isleap(2000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;计算两个年份之间的闰年总和:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,calendar.leapdays(2000,2020&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取当月总共有多少天:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,calendar.monthrange(2018,10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 星期天数对应用 0,1,2,3,4,5,6代表星期一、星期二、星期三、星期四、星期五、星期六、星期天&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取日期星期几:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,calendar.weekday(2018, 10, 01&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取当月的总天数7天为一组并标注对应索引与星期的关系&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,calendar.monthcalendar(2018,9)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1058502/201809/1058502-20180930000215287-1643579424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　到这里是不是想到怎么可以如何从数据中快速定位某一周或者3个月或指定周天的数据？或者是通过时间的转换去处理国际化时间的时差问题等等。只要灵活运用这3个方法可以让你的python对于时间日期等快速灵活的运用处理。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 16:07:00 +0000</pubDate>
<dc:creator>Cookie-Fei</dc:creator>
<og:description>python数据处理技巧二(掌控时间) 首先简单说下关于时间的介绍其中重点是时间戳的处理，时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cookie1026/p/9716251.html</dc:identifier>
</item>
<item>
<title>Centos7下搭建Django+uWSGI+nginx基于python3 - 魏大大</title>
<link>http://www.cnblogs.com/Thomas-blog/p/8998670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Thomas-blog/p/8998670.html</guid>
<description>&lt;p&gt;&lt;span&gt;Centos7 + python3.6 + virtualenv&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于centos自带的是python2.7版本，所以要自己安装新的版本，这里就不对此描述了，直接开工&lt;/p&gt;

&lt;h3&gt;使用python虚拟环境&lt;/h3&gt;
&lt;h2&gt;1.在自己想要创建虚拟环境的文件夹下创建虚拟环境，我们的uWSGI也是安装在虚拟环境中&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;virtualenv Env
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;cd Env
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;cd bin
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 启动虚拟环境  source activate  (关闭的命令 deactivate)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;2.启动之后会看到命令行左边有括号括起的环境名称&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; pip3 install uwsgi 安装uwsgi库
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.安装pycharm&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;直接用浏览器下载tar.gz包&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; 解压 tar xzvf xxx.tar.gz -&lt;span&gt;C 指定解压到的目录&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;进入该目录&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; cd bin/&lt;br/&gt;5 sh pycharm.sh&lt;br/&gt;就开启了pycharm
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.创建django项目&lt;/h2&gt;
&lt;p&gt;因为我们没有事先安装Django，直接用pycharm创建新的Django项目，指定我们刚才的虚拟环境pycharm会在这个环境下自动安装较新版本的Django，如果需要指定版本可以先用pip安装到虚拟环境，创建时项目，指定虚拟环境。&lt;/p&gt;
&lt;p&gt;使用manager.py Task 工具测试一下项目，runserver，浏览器访问一下我们的admin&lt;/p&gt;
&lt;p&gt;没有毛病继续下一步操作&lt;/p&gt;
&lt;h2&gt;5.测试uWSGI，在项目下创建一个test.py文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def application(env, start_response):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     start_response(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;200 OK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, [(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)])
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
运行 sudo uwsgi --http &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;8000&lt;/span&gt; --wsgi-file test.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后浏览 &lt;a href=&quot;http://127.0.0.1:8000/&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1:8000&lt;/a&gt;，有”Hello World”输出即安装成功。&lt;/p&gt;
&lt;p&gt;说明uWSGI没有毛病，接下一步&lt;/p&gt;
&lt;h2&gt;6.下载nginx并安装&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; wget http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;nginx.org/download/nginx-1.13.10.tar.gz&lt;br/&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;进入下载目录，解压 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;tar xzvf nginx-1.13.10.tar.gz&lt;br/&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;进入解压目录&lt;/span&gt;　　&lt;/span&gt;&lt;span&gt;cd nginx-1.13.10&lt;br/&gt;&lt;span&gt;4 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;./configure --prefix=/usr/local/nginx&lt;/span&gt;  #&lt;span&gt;把所有资源文件放在&lt;/span&gt;/usr/local/nginx&lt;span&gt;的路径中，不会杂乱。&lt;br/&gt;5 &lt;span&gt; make&lt;/span&gt;&lt;br/&gt;6   &lt;span&gt;make install&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;7. 配置uwsgi&lt;/h2&gt;
&lt;p&gt;uwsgi支持ini、xml等多种配置方式，本文ini为例， 在&lt;span&gt;项目&lt;/span&gt;&lt;span&gt;下新建wifi&lt;/span&gt;project_uwsgi.ini，添加如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#wifiproject_uwsgi.ini file
[uwsgi]

#与nginx通信
socket &lt;/span&gt;= &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;

#让uwsgi作为单独的web&lt;/span&gt;-&lt;span&gt;server,这里注释掉
#http &lt;/span&gt;= &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;

#django项目根目录
chdir &lt;/span&gt;= /home/wei/pythonproject/&lt;span&gt;wifiproject

#wsgi.py在项目中的位置
module  &lt;/span&gt;=&lt;span&gt; wifiproject.wsgi

enable&lt;/span&gt;-threads = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
#进程数
processes &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
#线成
threads &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
#退出时清空环境变量
vacuum &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;

#配uWSGI搜索静态文件目录，（及django项目下存放的static文件目录，用uwsgi作为单独服务器时才需要设置，此时我们用nginx处理静态文件
#check&lt;/span&gt;-&lt;span&gt;static&lt;/span&gt; = /home/wei/pythonproject/&lt;span&gt;wifiproject

#日志存储路径
daemonize &lt;/span&gt;= /home/wei/pythonproject/wifiproject/log/uwsgi.log
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;8. 配置nginx&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;进入到&lt;/span&gt; /usr/local/nginx &lt;span&gt;安装目录下&lt;/span&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;span&gt;我们不使用&lt;/span&gt;nginx&lt;span&gt;的默认配置运用我们的项目，&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在项目下创建一个&lt;/span&gt;conf&lt;span&gt;文件夹和&lt;/span&gt;&lt;span&gt;logs&lt;/span&gt;&lt;span&gt;文件夹分别存放配置文件和日志文件&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;　　把这三个文件分别复制拷贝到项目的&lt;/span&gt;conf&lt;span&gt;文件夹，也可以重命名&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　然后对&lt;/span&gt;nginx.conf&lt;span&gt;配置文件进行设置&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;user  root; #使用root否则静态文件可能加载失败
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; worker_processes  &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; #运行nginx工作进程，一般几个cpu核心就写ji
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; 
&lt;span&gt;  4&lt;/span&gt; #error_log  logs/&lt;span&gt;error.log;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; #error_log  logs/&lt;span&gt;error.log  notice;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; #error_log  logs/&lt;span&gt;error.log  info;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; #pid        logs/&lt;span&gt;nginx.pid;
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;events {
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     worker_connections  &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;; #一个进程能同时处理1024个请求
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;http {
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;    include       mime.types;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     default_type  application/octet-&lt;span&gt;stream;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;     #log_format  main  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;     #                  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;$status $body_bytes_sent &quot;$http_referer&quot; &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;     #                  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;     #access_log  logs/&lt;span&gt;access.log  main;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;    sendfile        on;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    #tcp_nopush     on;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;     #keepalive_timeout  &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     keepalive_timeout  &lt;span&gt;65&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;    #gzip  on;
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;#开始配置一个域名，一个server配置一般对应一个域名
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;    server {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         listen       &lt;span&gt;8002&lt;/span&gt;&lt;span&gt;; #暴露给外部的端口，等于浏览器访问的端口
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;        server_name  localhost; #域名
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         charset utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         error_log   /home/wei/pythonproject/wifiproject/log/&lt;span&gt;nginx_error.log;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         access_log  /home/wei/pythonproject/wifiproject/log/&lt;span&gt;nginx_access.log;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;#可以有多个location
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;            #root   html; #站点根目录
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;            #index  index.html index.htm; #索引文件
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     include  /home/wei/pythonproject/wifiproject/conf/&lt;span&gt;uwsgi_params; #设置将所有请求转发给uwsgi服务器处理
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     uwsgi_pass  &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;; #指定uwsgi的url，与uwsgi通信
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;         }
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; location /&lt;span&gt;static&lt;/span&gt;/&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; #设置将/&lt;span&gt;static的静态请求交给nginx，并指定静态文件的目录
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt; alias  /home/wei/pythonproject/wifiproject/&lt;span&gt;static&lt;/span&gt;/&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;         #error_page  &lt;span&gt;404&lt;/span&gt;              /&lt;span&gt;404&lt;/span&gt;&lt;span&gt;.html;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;         # redirect server error pages to the &lt;span&gt;static&lt;/span&gt; page /&lt;span&gt;50x.html
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         error_page   &lt;span&gt;500&lt;/span&gt; &lt;span&gt;502&lt;/span&gt; &lt;span&gt;503&lt;/span&gt; &lt;span&gt;504&lt;/span&gt;  /&lt;span&gt;50x.html;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;        #定义页面错误，如果出现这些错误，把站点根目录下的50x.html返回给用户
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; location = /&lt;span&gt;50x.html {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;            root   html;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt;         # proxy the PHP scripts to Apache listening on &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        #
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;         #location ~&lt;span&gt; \.php$ {
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         #    proxy_pass   http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;127.0.0.1;&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;        #}
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;         # pass the PHP scripts to FastCGI server listening on &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;        #
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         #location ~&lt;span&gt; \.php$ {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;        #    root           html;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         #    fastcgi_pass   &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;9000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        #    fastcgi_index  index.php;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         #    fastcgi_param  SCRIPT_FILENAME  /&lt;span&gt;scripts$fastcgi_script_name;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;        #    include        fastcgi_params;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;        #}
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt;         # deny access to .htaccess files, &lt;span&gt;if&lt;/span&gt; Apache&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s document root&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;         # concurs with nginx&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s one&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;        #
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         #location ~ /&lt;span&gt;\.ht {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        #    deny  all;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;        #}
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt;     # another &lt;span&gt;virtual&lt;/span&gt; host &lt;span&gt;using&lt;/span&gt; mix of IP-, name-, and port-&lt;span&gt;based configuration
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    #
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;    #server {
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     #    listen       &lt;span&gt;8000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     #    listen       somename:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    #    server_name  somename  alias  another.alias;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;     #    location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;    #        root   html;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    #        index  index.html index.htm;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;    #    }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;    #}
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;    # HTTPS server
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;    #
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;    #server {
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;     #    listen       &lt;span&gt;443&lt;/span&gt;&lt;span&gt; ssl;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    #    server_name  localhost;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;    #    ssl_certificate      cert.pem;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;    #    ssl_certificate_key  cert.key;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;    #    ssl_session_cache    shared:SSL:1m;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;    #    ssl_session_timeout  5m;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;     #    ssl_ciphers  HIGH:!aNULL:!&lt;span&gt;MD5;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;    #    ssl_prefer_server_ciphers  on;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;     #    location /&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;    #        root   html;
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;    #        index  index.html index.htm;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;    #    }
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;    #}
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;9 创建相关日志文件&lt;/h2&gt;
&lt;p&gt;　　这样 就不会在终端打印日志了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1288770/201805/1288770-20180506163110255-1962343067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;10  生产模式下diango设置&lt;/h2&gt;
&lt;p&gt;　　settings.py 中设置debug = False ，Django将不会代管静态文件，我们是交给nginx管理，所以要把django的相关静态文件收集到一个目录下，并在nginx的配置文件里指向该目录&lt;/p&gt;
&lt;p&gt;　　settings.py 添加 &lt;/p&gt;
&lt;p&gt;　　STATIC_ROOT = os.path.join(BASE_DIR,'static')&lt;/p&gt;
&lt;p&gt;　　调用manage命令 collectstatic    就会自动把相关静态文件收集到上面的路径里&lt;/p&gt;
&lt;h2&gt;11. 使用配置文件开启 uwsgi&lt;/h2&gt;
&lt;p&gt;　　使用虚拟环境进入项目&lt;/p&gt;
&lt;p&gt;　　然后运行&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1288770/201805/1288770-20180506163035622-1098676624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　如果没有报错就开启了uwsgi&lt;/p&gt;
&lt;h2&gt;12  在nginx启动目录下使用配置文件开启  nginx &lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1288770/201805/1288770-20180506163410503-1680895481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;13 使用浏览器访问&lt;/h2&gt;


</description>
<pubDate>Sat, 29 Sep 2018 15:58:00 +0000</pubDate>
<dc:creator>魏大大</dc:creator>
<og:description>1.电脑环境 Centos7 + python3.6 + virtualenv 由于centos自带的是python2.7版本，所以要自己安装新的版本，这里就不对此描述了，直接开工 2.具体流程 使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Thomas-blog/p/8998670.html</dc:identifier>
</item>
<item>
<title>探究HashMap线性不安全（三）——死循环的产生 - 比脚更长的路</title>
<link>http://www.cnblogs.com/lonelyJay/p/9726195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lonelyJay/p/9726195.html</guid>
<description>&lt;p&gt;&lt;span&gt;内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　网上很多资料都详细地讲解了HashMap底层的实现，但是讲到HashMap的并发操作不是线性安全时，往往一笔带过：&lt;strong&gt;在多个线程并发扩容时，会在执行transfer()方法转移键值对时，造成链表成环，导致程序在执行get操作时形成死循环&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;​　　对于没有研究过该过程的童鞋，很难费解这句话的含义。下面笔者分四个小节带着大家共同研究一下JDK1.7和JDK1.8版本下HashMap的线性不安全是怎么造成的，详细探究链表成环的形成过程。如果对于HashMap底层的put、get操作不清楚，建议先学习参考1中的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;适合人群&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;​　　Java进阶&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;​ 1、&lt;/span&gt;&lt;a href=&quot;https://www.toutiao.com/i6544826418210013700/&quot;&gt;&lt;span&gt;https://www.toutiao.com/i6544826418210013700/&lt;/span&gt;&lt;/a&gt; &lt;span&gt;HashMap底层数据结构原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;​ 2、&lt;/span&gt;&lt;a href=&quot;https://www.toutiao.com/i6545790064104833539/&quot;&gt;&lt;span&gt;https://www.toutiao.com/i6545790064104833539/&lt;/span&gt;&lt;/a&gt; &lt;span&gt;为什么HashMap非线程安全&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;​ 3、&lt;/span&gt;&lt;a href=&quot;https://blog.csdn.net/qq_32182461/article/details/81152025&quot;&gt;&lt;span&gt;https://blog.csdn.net/qq_32182461/article/details/81152025&lt;/span&gt;&lt;/a&gt; &lt;span&gt;hashmap并发情况下的成环原因（笔者认为该文是一种误解）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;​　　本节将探究环形链表是如何在hashMap查询时产生死循环的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;​　　以上节为例，当hashMap对象查找一个不为空的Key时，会执行getEntry(key)方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key为null时，从index为0的链表中查找数据&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; getForNullKey();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;key不为null是查找数据    &lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt; entry =&lt;span&gt; getEntry(key);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果未查找到key对应的值，那么entry为null，get方法会返回null。&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; == entry ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : entry.getValue();
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1455629/201809/1455629-20180929184812507-619155148.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;1538216304142&quot; src=&quot;https://img2018.cnblogs.com/blog/1455629/201809/1455629-20180929184813330-690467375.png&quot; alt=&quot;1538216304142&quot; width=&quot;748&quot; height=&quot;224&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;​　　getEntry(key)方法会计算Key的hash值，然后通过indexFor(hash, table.length)对hash值取模求得key对应table数组的下标index。如果这个Key对应的table数组下标为3，那么线程会在下标3处的环形链表上遍历检索目标key对应的值。当key对应的键值对不存在，线程将进入死循环，代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;K,V&amp;gt;&lt;span&gt; getEntry(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算key的hash值&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; hash = (key == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : hash(key);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过indexFor(hash, table.length)求得key对应的index，然后遍历index下表的链表&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; table[indexFor(hash, table.length)];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;          e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;          e =&lt;span&gt; e.next) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        Object k;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果链表中不存在对应key的键值对，且链表为环形，那么当前线程将在for语句中产生死循环。&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;11&lt;/span&gt;             ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;​　　至此，JDK1.7中HashMap的线性不安全特性已经论证完毕。下一节，将探究JDK1.8中HashMap的线性不安全特性。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 15:53:00 +0000</pubDate>
<dc:creator>比脚更长的路</dc:creator>
<og:description>内容 网上很多资料都详细地讲解了HashMap底层的实现，但是讲到HashMap的并发操作不是线性安全时，往往一笔带过：在多个线程并发扩容时，会在执行transfer()方法转移键值对时，造成链表成环</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lonelyJay/p/9726195.html</dc:identifier>
</item>
<item>
<title>Apache Pulsar——企业级消息订阅系统介绍 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/9727188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/9727188.html</guid>
<description>&lt;p&gt;Apache Pulsar是一款由雅虎开发的类似于Kafka的企业级消息订阅系统，在2016将其开源，由Apach基金会孵化，现在已经成长为Apache基金会的顶级项目。Pulsar在雅虎内部已经运行了三年，服务于众多的应用，主要有雅虎邮箱、雅虎财务系统、雅虎运动、Flickr、Gemini广告平台以及雅虎分布式键值对存储系统Sherpa等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Pulsar相关概念。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为Pulsar提供数据的应用叫做生产者，而从Pulsar消费数据的应用被称为消费者，有时也称为订阅者。主题Topic是Pulsar的核心资源，这个和Kafka有点类似。主题Topic就像一个管道，生产者往里面写数据，而消费者消费里面的数据。这是Pulsar的特性1，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110616/201809/110616-20180929234145393-1229463254.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;387&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Pulsar一开始创建时就支持多租户的使用场景。为了支持多租用的功能，Pulsar包含两种资源，分别是“properties”和“namespaces”。property(资产)代表系统中的租户。举个例子，假设部署一个Pulsar集群支持各种各样的应用(就像Pulsar在雅虎公司一样)，在Pulsar集群中，每一个资产代表企业中的一个团队，一个核心功能或者一条产品线。每个属性依次包含若干个namespace，例如一个namespace对应每个应用或者使用场景。一个namespace可以包含任意多个主题topic。总的来说，一个Pulsar集群包含多个资产property，一个资产property包含多个namespace，一个namespace包含多个主题topic。Pulsar集群、Property资产、Namespace和主题topic的关系图如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110616/201809/110616-20180929234400052-1316168654.png&quot; alt=&quot;&quot; width=&quot;965&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;namespace是Pulsar中最基本的管理单元，在namespace这一层面，可以设置权限，调整副本设置，管理跨集群的消息复制，控制消息策略和执行关键操作。一个主题topic可以继承其所对应的namespace的属性，因此我们只需对namespace的属性进行设置，就可以一次性设置该namespace中所有主题topic的属性。&lt;/p&gt;
&lt;p&gt;namespace有两种，分别是本地的namespace和全局的namespace：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本地namespace——仅对定义它的集群可见。&lt;/li&gt;
&lt;li&gt;全局namespace——跨集群可见，可以是同一个数据中心的集群，也可以是跨地域中心的集群，这依赖于是否在namespace中设置了跨集群拷贝数据的功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然本地namespace和全局namespace的作用域不同，但是只要对他们进行适当的设置，都可以跨团队和跨组织共享。一旦生产者获得了namespace的写入权限，那么它就可以往namespace中的所有topic主题写入数据，如果某个主题不存在，则在生产者第一次写入数据时动态创建。&lt;/p&gt;
&lt;p&gt;之前提到过，每个namespace会一个或多个主题topic，每个主题会被多个消费者订阅，每个订阅者会从其所订阅的主题topic发布的所有消息中检索和接收数据。为了给每个应用增加更多的灵活性，Pulsar支持三种不同的类型的订阅，并且它们可以在同一个主题topic中共存：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;独享型订阅(Exclusive subscription)——这种类型的订阅在任何时候都只能有一个消费者。&lt;/li&gt;
&lt;li&gt;共享型订阅(Share subscription)——多个消费者消费同一个主题topic的数据，每个消费者会接收到一小部分数据。&lt;/li&gt;
&lt;li&gt;失效型订阅(Failover subscription)——多个消费者连接到一个主题topic，但是只有一个消费者能接收数据，其他消费者只有在当前消费者失效之后才会开始接收数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Pulsar提供三种不同类型的订阅subscriptions。subscription提供一个最重要的功能就是解耦消息的生产和消费。通过支持不同类型的subscription，无需增加开发的复杂度就可以增强应用的弹性。下图展现了三种不同类型的订阅：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110616/201809/110616-20180929234731988-519397095.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据分区&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;topic主题中的数据有时会很小，小到几KB，有时会很大，大道几十TB。这意这意味着主题topic需要具备在某些情况下保持稳定的低吞吐量，在另一些情况下保持非常高的吞吐量的能力，这取决于使用者的数量。因此，当一个主题需要高吞吐率而例外一个主题需要低吞吐率时，会发生什么呢？为了解决该问题Pulsar允许你当将一个主题topic中的数据分成不同的区域然后存储在不同的机器中。这就是Pulsar的分区功能。&lt;/p&gt;
&lt;p&gt;对于处理跨多个节点的大量数据，使用分区是一个非常普通的做法，同时还可以实现高吞吐率。默认情况下，创建的主题topic是没有分区的，但是创建有分区的主题topic也很容易，使用简单的CLI命令或者通过调用API，并且指定分区数量即可。&lt;/p&gt;
&lt;p&gt;当你创建有分区的主题时，Pulsar自动将数据分区，确保消费者和生产者与分区无关。对一个还没分区但是已经写入数据的主题进行分区之后，无需对原来的代码进行修改，即可继续将数据写入该主题topic。也就是说分区和应用无关&lt;/p&gt;
&lt;p&gt;Pulsar使用一个叫做broker的进程来处理主题的分区，Pulsar集群中的每个节点都运行一个自己的broker进程，下图显示了broker节点如何如果处理分区的细节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110616/201809/110616-20180929234905775-510010306.png&quot; alt=&quot;&quot; width=&quot;827&quot; height=&quot;1266&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用程序无需修改代码即可使用分区的优点，Pulsar还额外提供了一些hooks让数据在不同分区和不同消费者之间的分布能达到最佳的效果。Pulsar提供四种不同的路由策略，根据你选择的路由策略决定数据是如何路由到指定的分区。四种分区策略如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Single partitioning(单一分区)：生产者随机获取一个分区，并将数据写入到该分区。该模式和无分区主题提供一样的保证，但是对多个生产者写入数据到主题topic的场景非常有用。&lt;/li&gt;
&lt;li&gt;Round robin partitioning(轮询调度分区)：在该应用场景，生产者将数据均匀的分布到所有的分区，第一条消息写入到第一个分区，第二条消息写入到第二个分区，以此类推。&lt;/li&gt;
&lt;li&gt;Hash partitioning(哈希分区)：在该应用场景下是如何选择分区接入数据的呢？每条消息都有一个key，然后对key调用哈希函数生成一个哈希值，根据该值来选择消息要写入的分区。哈希分区保证消息的按照key的顺序分布。&lt;/li&gt;
&lt;li&gt;Custom partitioning(自定义分区)：生产者使用自定义的函数接收消息并生成分区号，下次直接写入对应的分区中，自定义分区模式保证应用程序完全控制分区逻辑。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据持久性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一旦Pulsar broker接收并确认数据是来自生成者写入到主题topic中的，它需要保证数据在任何情况下都不丢失，不像其他的消息管理系统，Pulsar使用Apache BookKeeper提供的低延迟持久化存储特性保证数据的持久性。一旦Pulsar接收到数据，它会数据发送到多个BookKeeper节点，接收到数据的BookKeeper节点会数据写入到内存和预写日志(write-ahead log)中。在对数据确认之前会强制将日志写入到持久化存储设备中。通过将数据写入到存储设备中，即使出现断电的情况，数据也不会丢失。只有当数据写入到大多数的BookKeeper节点中，Pulsar才会发送确认消息给生产者。&lt;/p&gt;

&lt;p&gt;关注本人的公众号获取更多关于大数据和机器学习方面的知识&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/110616/201809/110616-20180929235237078-381181277.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 15:53:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>Apache Pulsar是一款由雅虎开发的类似于Kafka的企业级消息订阅系统，在2016将其开源，由Apach基金会孵化，现在已经成长为Apache基金会的顶级项目。Pulsar在雅虎内部已经运行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/9727188.html</dc:identifier>
</item>
<item>
<title>加载动态链接库——dlopen dlsym dlclose - zxzhang</title>
<link>http://www.cnblogs.com/ZhaoxiCheung/p/9424930.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhaoxiCheung/p/9424930.html</guid>
<description>&lt;h2 id=&quot;dlopendlmopendlclose&quot;&gt;DLOPEN DLMOPEN DLCLOSE&lt;/h2&gt;
&lt;h3 id=&quot;name&quot;&gt;NAME&lt;/h3&gt;
&lt;p&gt;    &lt;strong&gt;dlclose, dlopen, dlmopen&lt;/strong&gt; - 打开／关闭共享对象&lt;/p&gt;
&lt;h3 id=&quot;synopsis&quot;&gt;SYNOPSIS&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;dlfcn.h&amp;gt;

void *dlopen(const char *filename, int flags);

int dlclose(void *handle);

#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;

void *dlmopen (Lmid_t lmid, const char *filename, int flags);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;description&quot;&gt;DESCRIPTION&lt;/h3&gt;
&lt;h4 id=&quot;dlopen&quot;&gt;dlopen()&lt;/h4&gt;
&lt;p&gt;    这个函数加载由以null结尾的字符串文件名命名的动态共享对象（共享库）文件，并为加载的对象返回不透明的“句柄”。此句柄与 dlopen API 中的其他函数一起使用，例如&lt;code&gt;dlsym()&lt;/code&gt;，&lt;code&gt;dladdr()&lt;/code&gt;，&lt;code&gt;dlinfo()&lt;/code&gt;和&lt;code&gt;dlclose()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果 &lt;u&gt;filename&lt;/u&gt; 为 NULL，则返回的句柄用于主程序。如果 &lt;u&gt;filename&lt;/u&gt; 包含斜杠（“/”），则它被解释为（相对或绝对）路径名。否则，动态链接器将按如下方式搜索对象（有关详细信息，请参阅&lt;code&gt;ld.so(8)&lt;/code&gt;）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（仅限ELF）如果调用程序的可执行文件包含 DT_RPATH 标记，并且不包含 DT_RUNPATH 标记，则会搜索 DT_RPATH 标记中列出的目录。&lt;/li&gt;
&lt;li&gt;如果在程序启动时，环境变量 LD_LIBRARY_PATH 被定义为包含以冒号分隔的目录列表，则会搜索这些目录。 （作为安全措施，set-user-ID 和 set-group-ID程序将忽略此变量。）&lt;/li&gt;
&lt;li&gt;（仅限ELF）如果调用程序的可执行文件包含　DT_RUNPATH　标记，则搜索该标记中列出的目录。&lt;/li&gt;
&lt;li&gt;检查缓存文件/etc/ld.so.cache（由ldconfig（8）维护）以查看它是否包含filename的条目。&lt;/li&gt;
&lt;li&gt;搜索目录 /lib和 /usr/lib（按此顺序）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    如果 &lt;u&gt;filename&lt;/u&gt; 指定的对象依赖于其他共享对象，则动态链接器也会使用相同的规则自动加载这些对象。 （如果这些对象依次具有依赖性，则此过程可以递归地发生）&lt;/p&gt;
&lt;p&gt;&lt;u&gt;flags&lt;/u&gt; 参数必须包括以下两个值中的一个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RTLD_LAZY&lt;br/&gt;执行延迟绑定。仅在执行引用它们的代码时解析符号。如果从未引用该符号，则永远不会解析它（只对函数引用执行延迟绑定;在加载共享对象时，对变量的引用总是立即绑定）。自 glibc 2.1.1，此标志被&lt;strong&gt;LD_BIND_NOW&lt;/strong&gt;环境变量的效果覆盖。&lt;/li&gt;
&lt;li&gt;RTLD_NOW&lt;br/&gt;如果指定了此值，或者环境变量&lt;strong&gt;LD_BIND_NOW&lt;/strong&gt;设置为非空字符串，则在&lt;code&gt;dlopen()&lt;/code&gt;返回之前，将解析共享对象中的所有未定义符号。如果无法执行此操作，则会返回错误。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;flags&lt;/u&gt; 也可以通过以下零或多个值进行或运算设置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RTLD_GLOBAL&lt;br/&gt;此共享对象定义的符号将可用于后续加载的共享对象的符号解析。&lt;/li&gt;
&lt;li&gt;RTLD_LOCAL&lt;br/&gt;这与&lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt;相反，如果未指定任何标志，则为默认值。此共享对象中定义的符号不可用于解析后续加载的共享对象中的引用。&lt;/li&gt;
&lt;li&gt;RTLD_NODELETE (since glibc 2.2)&lt;br/&gt;在&lt;code&gt;dlclose()&lt;/code&gt;期间不要卸载共享对象。因此，如果稍后使用&lt;code&gt;dlopen()&lt;/code&gt;重新加载对象，则不会重新初始化对象的静态变量。&lt;/li&gt;
&lt;li&gt;RTLD_NOLOAD (since glibc 2.2)&lt;br/&gt;不要加载共享对象。这可用于测试对象是否已经驻留（如果不是，则&lt;code&gt;dlopen()&lt;/code&gt;返回 NULL，如果是驻留则返回对象的句柄）。此标志还可用于提升已加载的共享对象上的标志。例如，以前使用&lt;strong&gt;RTLD_LOCAL&lt;/strong&gt;加载的共享对象可以使用&lt;strong&gt;RTLD_NOLOAD | RTLD_GLOBAL&lt;/strong&gt;重新打开。&lt;/li&gt;
&lt;li&gt;RTLD_DEEPBIND (since glibc 2.3.4)&lt;br/&gt;将符号的查找范围放在此共享对象的全局范围之前。这意味着自包含对象将优先使用自己的符号，而不是全局符号，这些符号包含在已加载的对象中。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;dlmopen&quot;&gt;dlmopen()&lt;/h4&gt;
&lt;p&gt;    这个函数除了以下几点与&lt;code&gt;dlopen()&lt;/code&gt;有所不同外，都执行同样的任务。&lt;br/&gt;    &lt;code&gt;dlmopen()&lt;/code&gt;与&lt;code&gt;dlopen()&lt;/code&gt;的主要不同之处主要在于它接受另一个参数 &lt;u&gt;lmid&lt;/u&gt;，它指定应该被加载的共享对象的链接映射列表（也称为命名空间）。对于命名空间，&lt;u&gt;Lmid_t&lt;/u&gt; 是个不透明的句柄。&lt;br/&gt;&lt;u&gt;lmid&lt;/u&gt; 参数要么是已经存在的命名空间的ID（这个命名空间可以通过&lt;code&gt;dlinfo RTLD_DI_LMID&lt;/code&gt;请求获得）或者是以下几个特殊值中的其中一个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LM_ID_BASE&lt;br/&gt;在初始命名空间中加载共享对象（即应用程序的命名空间）。&lt;/li&gt;
&lt;li&gt;LM_ID_NEWLM&lt;br/&gt;创建新的命名空间并在该命名空间中加载共享对象。该对象必须已正确链接到引用 所有其他需要的共享对象，因为新的命名空间最初为空。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果 &lt;u&gt;filename&lt;/u&gt; 是 NULL，那么 &lt;u&gt;lmid&lt;/u&gt; 的值只能是&lt;strong&gt;LM_ID_BASE&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;dlclose&quot;&gt;dlclose()&lt;/h4&gt;
&lt;p&gt;    &lt;code&gt;dlclose()&lt;/code&gt;减少指定句柄 &lt;u&gt;handle&lt;/u&gt; 引用的动态加载共享对象的引用计数。如果引用计数减少为０，那么这个动态加载共享对象将被真正卸载。所有在&lt;code&gt;dlopen()&lt;/code&gt;被调用的时候自动加载的共享对象将以相同的方式递归关闭。&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;dlclose()&lt;/code&gt;成功返回并不保证与句柄相关的符号将从调用方的地址空间中删除。除了显式通过&lt;code&gt;dlopen()&lt;/code&gt;调用产生的引用之外，一些共享对象作为依赖项可能已被隐式加载（和引用计数）。只有当所有引用都已被释放才可以从地址空间中删除共享对象。&lt;/p&gt;
&lt;h3 id=&quot;return-value&quot;&gt;RETURN VALUE&lt;/h3&gt;
&lt;p&gt;    执行成功时，&lt;code&gt;dlopen()&lt;/code&gt;和&lt;code&gt;dlmopen()&lt;/code&gt;返回一个非空句柄。&lt;br/&gt;    执行失败时（文件找不到、不可读、错误的格式或者在加载的时候出现错误），&lt;code&gt;dlopen()&lt;/code&gt;和&lt;code&gt;dlmopen()&lt;/code&gt;返回 NULL。&lt;br/&gt;    对于&lt;code&gt;dlclose()&lt;/code&gt;成功执行，将返回０值，失败时，返回一个非０值。&lt;/p&gt;
&lt;p&gt;以上这些函数产生的错误，其错误信息都可以通过&lt;code&gt;dlerror()&lt;/code&gt;获知。&lt;/p&gt;
&lt;h3 id=&quot;notes&quot;&gt;NOTES&lt;/h3&gt;
&lt;h4 id=&quot;dlmopen-与-命名空间&quot;&gt;dlmopen() 与 命名空间&lt;/h4&gt;
&lt;p&gt;    链接映射列表定义了通过动态链接器解析的符号的孤立命名空间。在命名空间内，被依赖的共享对象根据通常的规则被隐式加载，符号引用同样以通常的规则被解析。但是这种方案受限于已经被（显式和隐式）加载进命名空间的对象的定义。&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;dlmopen()&lt;/code&gt;函数允许对象隔离加载——在新的命名空间中加载共享对象而不暴露其余的应用于新对象提供的符号。注意使用&lt;strong&gt;RTLD_LOCAL&lt;/strong&gt;标志不足以达到此目的，因为它防止一个共享对象的符号对&lt;strong&gt;任何其他&lt;/strong&gt;共享对象可用。在某些情况下，我们可能想使得由一些动态加载共享对象提供的符号对于其他共享对象可用，而不将这些符号暴露给整个应用。这可以通过使用单独的命名空间和&lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt;标志来实现。&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;dlmopen()&lt;/code&gt;函数可以提供比&lt;strong&gt;RTLD_LOCAL&lt;/strong&gt;标志更好的隔离效果。特别是，当共享对象是通过&lt;strong&gt;RTLD_LOCAL&lt;/strong&gt;标志加载的，并且其依赖的共享对象是通过&lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt;加载的，那么有可能升级为&lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt;。因此，明确控制了所有共享对象的依赖的这种情况外，&lt;strong&gt;RTLD_LOCAL&lt;/strong&gt;是不足以隔离加载的共享对象，。&lt;/p&gt;
&lt;p&gt;    &lt;code&gt;dlmopen()&lt;/code&gt;函数的一种用法是多次加载同样的对象。不使用&lt;code&gt;dlmopen()&lt;/code&gt;函数来实现这个功能的话，需要创建共享对象的一个副本。而如果使用&lt;code&gt;dlmopen()&lt;/code&gt;函数来实现的话，可以通过将相同的共享对象文件加载到不同的命名空间来实现。&lt;br/&gt;glibc实现最多支持16个命名空间。&lt;/p&gt;
&lt;h4 id=&quot;初始化和终结功能&quot;&gt;初始化和终结功能&lt;/h4&gt;
&lt;p&gt;    共享对象可以使用&lt;strong&gt;&lt;strong&gt;attribute&lt;/strong&gt; ((constructor))&lt;/strong&gt;和&lt;strong&gt;&lt;strong&gt;attribute&lt;/strong&gt; ((destructor))&lt;/strong&gt;函数属性。构造函数在&lt;code&gt;dlopen()&lt;/code&gt;返回之前执行，而析构函数在&lt;code&gt;dlclose()&lt;/code&gt;返回之前执行。共享对象可以导出多个构造函数和析构函数并且优先顺序可以和每个函数相关联来决定它们的执行顺序。&lt;/p&gt;
&lt;h2 id=&quot;dlsym&quot;&gt;DLSYM&lt;/h2&gt;
&lt;h3 id=&quot;name-1&quot;&gt;NAME&lt;/h3&gt;
&lt;p&gt;    &lt;strong&gt;dlsym, dlvsym&lt;/strong&gt; - 获取共享对象或可执行文件中符号的地址&lt;/p&gt;
&lt;h3 id=&quot;synopsis-1&quot;&gt;SYNOPSIS&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;dlfcn.h&amp;gt;

void *dlsym(void *handle, const char *symbol);

#define _GNU_SOURCE
#include &amp;lt;dlfcn.h&amp;gt;

void *dlvsym(void *handle, char *symbol, char *version);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;description-1&quot;&gt;DESCRIPTION&lt;/h3&gt;
&lt;p&gt;    &lt;code&gt;dlsym()&lt;/code&gt;接受由&lt;code&gt;dlopen()&lt;/code&gt;返回的动态加载的共享对象的“句柄”，并返回该符号加载到内存中的地址。如果未找到符号，则在加载该对象时，在指定对象或&lt;code&gt;dlopen()&lt;/code&gt;自动加载的任何共享对象中，&lt;code&gt;dlsym()&lt;/code&gt;将返回NULL。（&lt;code&gt;dlsym()&lt;/code&gt;通过这些共享对象的依赖关系树进行宽度优先搜索。）&lt;br/&gt;    因为符号本身可能是 NULL（所以&lt;code&gt;dlsym()&lt;/code&gt;返回 NULL 并不意味着错误），因此判断是否错误的正确做法是调用&lt;code&gt;dlerror()&lt;/code&gt;清除任何旧的错误条件，然后调用&lt;code&gt;dlsym()&lt;/code&gt;，并且再次调用&lt;code&gt;dlerror()&lt;/code&gt;，保存其返回值，判断这个保存的值是否是 NULL。&lt;br/&gt;    可以在句柄中指定两个特殊的伪句柄：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RTLD_DEFAULT&lt;br/&gt;使用默认共享对象搜索顺序查找所需符号的第一个匹配项。搜索将包括可执行文件中的全局符号及其依赖项，以及使用&lt;strong&gt;RTLD_GLOBAL&lt;/strong&gt; 标志动态加载的共享对象中的符号。&lt;/li&gt;
&lt;li&gt;RTLD_NEXT&lt;br/&gt;在当前对象之后的搜索顺序中查找下一个所需符号。这允许人们在另一个共享对象中提供一个函数的包装器，因此，例如，预加载的共享对象中的函数定义（参见ld.so（8）中的&lt;strong&gt;LD_PRELOAD&lt;/strong&gt;）可以找到并调用在另一个共享对象中提供的“真实”函数（或者就此而言，在存在多个预加载层的情况下，函数的“下一个”定义）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    &lt;code&gt;dlvsym()&lt;/code&gt;除了比&lt;code&gt;dlsym()&lt;/code&gt;多提供了一个额外的参数外，其余与&lt;code&gt;dlsym()&lt;/code&gt;相同。&lt;/p&gt;
&lt;h3 id=&quot;return-value-1&quot;&gt;RETURN VALUE&lt;/h3&gt;
&lt;p&gt;    执行成功，这些函数将会返回　&lt;u&gt;symbol&lt;/u&gt; 关联的地址。执行失败，它们将返回 NULL。错误的原因可以通过&lt;code&gt;dlerror()&lt;/code&gt;进行诊断。&lt;/p&gt;
&lt;h2 id=&quot;example&quot;&gt;EXAMPLE&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;dlfcn.h&amp;gt;
#include &amp;lt;gnu/lib-names.h&amp;gt;  /* Defines LIBM_SO (which will be a
                              string such as &quot;libm.so.6&quot;) */
int
main(void)
{
    void *handle;
    double (*cosine)(double);
    char *error;

    handle = dlopen(LIBM_SO, RTLD_LAZY);
    if (!handle) {
       fprintf(stderr, &quot;%s\n&quot;, dlerror());
       exit(EXIT_FAILURE);
    }

    dlerror();    /* Clear any existing error */

    cosine = (double (*)(double)) dlsym(handle, &quot;cos&quot;);

    /* According to the ISO C standard, casting between function
      pointers and 'void *', as done above, produces undefined results.
      POSIX.1-2003 and POSIX.1-2008 accepted this state of affairs and
      proposed the following workaround:

          *(void **) (&amp;amp;cosine) = dlsym(handle, &quot;cos&quot;);

      This (clumsy) cast conforms with the ISO C standard and will
      avoid any compiler warnings.

      The 2013 Technical Corrigendum to POSIX.1-2008 (a.k.a.
      POSIX.1-2013) improved matters by requiring that conforming
      implementations support casting 'void *' to a function pointer.
      Nevertheless, some compilers (e.g., gcc with the '-pedantic'
      option) may complain about the cast used in this program. */

    error = dlerror();
    if (error != NULL) {
       fprintf(stderr, &quot;%s\n&quot;, error);
       exit(EXIT_FAILURE);
    }

    printf(&quot;%f\n&quot;, (*cosine)(2.0));
    dlclose(handle);
    exit(EXIT_SUCCESS);
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 29 Sep 2018 15:02:00 +0000</pubDate>
<dc:creator>zxzhang</dc:creator>
<og:description>DLOPEN DLMOPEN DLCLOSE NAME      dlclose, dlopen, dlmopen 打开／关闭共享对象 SY</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZhaoxiCheung/p/9424930.html</dc:identifier>
</item>
<item>
<title>Antd-Select组件的深入用法 - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9726838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9726838.html</guid>
<description>&lt;h3&gt;一、Antd-Select提供几种类型&lt;/h3&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最基础版只提供下拉功能的选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;带搜索功能的下拉选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可多选的下拉选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可搜索、可多选、可随意输入内容的tag下拉选择器(支持自动分词)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;多级联动下拉选择器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;搜索远程数据下拉框&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;二、一些潜在用法&lt;/h3&gt;
&lt;h4&gt;如果Select.Option选项的数量特别大:2k、3k...&lt;/h4&gt;
&lt;p&gt;假设请求数据时间我们都解决好了,信心满满地准备把数据填充到&lt;code&gt;&amp;lt;Select.Option&amp;gt;&lt;/code&gt;后下班!过会你会发现有多绝望..&lt;/p&gt;
&lt;p&gt;这下拉框加载了&lt;code&gt;10s&lt;/code&gt;还没出来！?这时候先想着去antd文档上找解决方法,无果后百度、SF、google....因为antd每次都会重新渲染&lt;code&gt;&amp;lt;Select.Option&amp;gt;&lt;/code&gt;,所以要降低卡顿时间,唯一办法就是&lt;strong&gt;减少渲染的数量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以来体验一下:&lt;a href=&quot;https://codepen.io/anon/pen/eygNeR?editors=0010&quot; target=&quot;_blank&quot;&gt;《antd-Select加载2k条数据演示》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;发现问的人倒挺多,真正解决的回答没见到几个(我还没找到..)&lt;br/&gt;有的劝着放弃吧,加了那么多用户也不会看(确实如此),改做成一个搜索下拉框.稍微执拗一点的继续挣扎,终于找到了一个能优化加载速度的插件&lt;a href=&quot;https://github.com/bvaughn/react-select-fast-filter-options&quot; target=&quot;_blank&quot;&gt;《react-select-fast-filter-options》&lt;/a&gt;&lt;br/&gt;然后过会又发现,搜索功能肯定也需要的呀!总不能让用户翻那2000条数据.可能半夜还会被投诉.&lt;/p&gt;
&lt;p&gt;带着最后一点希望,找了一下github上&lt;code&gt;antd&lt;/code&gt;的Issues,里面给的回答倒是挺有启发的,但是还是没有正确的解决办法.&lt;a href=&quot;https://github.com/ant-design/ant-design/issues/7086&quot; target=&quot;_blank&quot;&gt;《ant-design:Issues》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;于是就自己设计了一个,新手代码请见谅,希望对你有帮助.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//render
const { optionsData } = this.state;

&amp;lt;Select style={{ width: 200 }} 
    showSearch
    onChange={this.handleSecChange}
    placeholder=&quot;请输入/选择xxx&quot;   
    onSearch={this.handleSerach}
&amp;gt;
{
    optionsData.length &amp;amp;&amp;amp; optionsData.map( (item, index) =&amp;gt; (
        &amp;lt;Select.Option key={index} value={item}&amp;gt;{item}&amp;lt;/Select.Option&amp;gt;)
    ) 
}
&amp;lt;/Select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//搜索Value值改变触发回调函数
handleSerach(e){
  let { clusterValue } = this.state;
  let that = this;
  //类似函数节流
  setTimeout(function(){
    that.loadOption(clusterValue, e)
  },300)
  
}

loadOption(clusterValue, keyWords){
    const { options } = this.props.data;   //获得2k条数据
    let newOptionsData = [];
    let arrData = options[clusterValue]; 
    if(Object.keys(options).length){
      let len;
      if(arrData.length &amp;gt; 100)  len = 100;
      else len = arrData.length;
      
      //初始化
      if(keyWords == ''){
        for(var i=0;i&amp;lt;len;i++){
          newOptionsData.push(arrData[i])
        } 
      }
        
      //用户搜索
      else{
        newOptionsData = [];
        for(var j = 0; j &amp;lt; arrData.length; j++){
          if(arrData[j].indexOf(keyWords) != -1){
            newOptionsData.push(arrData[j]);
            if(newOptionsData.length &amp;gt; 100) break;
          }
        }         
      } 
    }

    // return newOptionsData
    this.setState({
      optionsData: newOptionsData
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;handleSearch&lt;/code&gt;函数添加定时是为了解决每次输入都立刻请求,导致卡顿;用户输入完成后再统一查找,虽然会导致在搜索的时候增加300ms空白期,但是比用户输入卡顿要好&lt;/li&gt;
&lt;li&gt;把渲染数量控制在&lt;code&gt;100条内&lt;/code&gt;,防止卡顿,一般用户查找一个数据,也会输入得比较完整,不可能会在100条内查找。&lt;/li&gt;
&lt;li&gt;区分初始化和搜索两个不同情况,用户刚进入界面的时候,并没有关键字搜索,所以这时候要初始化&lt;code&gt;前100条&lt;/code&gt;内容给用户,当然你也可以按照一定的条件渲染数据给用户,只要保证合理数量以内即可&lt;/li&gt;
&lt;li&gt;因为我的数据是多级联动的&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;options:{
'key': [xxx,xxx1,xxx2...],
'key1': [xxx,xxx1,xxx2...]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我的写法是&lt;code&gt;options[xxx]&lt;/code&gt;,然后遍历相应的数组即可&lt;/p&gt;
&lt;p&gt;当然这仅仅是一种思路,更好的实现方法有很多！希望这能成为你的方法的一个垫脚石&lt;/p&gt;
&lt;p&gt;有时候多看看官方文档真的很有帮助.学习的不仅仅是它的方法,还有它的思路。如果遇到它的一些特殊语法(语法糖),也可以到&lt;code&gt;ant-design-pro&lt;/code&gt;里查阅&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pro.ant.design/docs/getting-started-cn&quot; target=&quot;_blank&quot;&gt;《ant-design-pro》&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 13:53:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、Antd Select提供几种类型 1. 最基础版只提供下拉功能的选择器 2. 带搜索功能的下拉选择器 3. 可多选的下拉选择器 4. 可搜索、可多选、可随意输入内容的tag下拉选择器(支持自动分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9726838.html</dc:identifier>
</item>
<item>
<title>.NET Core中的数据保护组件 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/9726191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/9726191.html</guid>
<description>&lt;blockquote readability=&quot;1.3917525773196&quot;&gt;
&lt;p&gt;原文地址： &lt;a href=&quot;https://tahirnaushad.com/2017/09/09/preventing-insecure-object-references-in-asp-net-core-2-0/&quot;&gt;PREVENTING INSECURE OBJECT REFERENCES IN ASP.NET CORE 2.0&lt;/a&gt;&lt;br/&gt;作者： &lt;a href=&quot;https://tahirnaushad.com/about/&quot;&gt;Tahir Naushad&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在 OWASP(开放式 Web 应用程序安全项目) 2013 年发布的报告中，将不安全的直接对象引用(Insecure Direct Object Reference)标记为 十大 Web 应用程序风险之一, 其表现形式是对象的引用(例如数据库主键)被各种恶意攻击利用, 所以对于Api返回的各种主键外键ID, 我们需要进行加密。&lt;/p&gt;

&lt;p&gt;.NET Core 中内置了一个&lt;code&gt;IDataProtectionProvider&lt;/code&gt;接口和一个&lt;code&gt;IDataProtector&lt;/code&gt;接口。其中IDataProtectionProvider是创建保护组件的接口，IDataProtector是数据保护的接口。开发人员可以实现这 2 个接口，创建数据保护组件。&lt;/p&gt;
&lt;h2 id=&quot;内置的数据保护组件&quot;&gt;内置的数据保护组件&lt;/h2&gt;
&lt;p&gt;.NET Core 中默认提供了一个数据保护组件, 下面我们来尝试使用这个默认组件来保护我们的数据。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;例: 当前我们有一个&lt;code&gt;Movie&lt;/code&gt;类，代码如下, 我们期望当获取Movie对象的时候，Id字段是加密的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;    public class Movie
    {
        public Movie(int id, string title)
        {
            Id = id;
            Title = title;
        }

        public int Id { get; set; }
        public string Title { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先我们需要在&lt;code&gt;Startup.cs&lt;/code&gt;中&lt;code&gt;ConfigureService&lt;/code&gt;方法中配置使用默认的数据保护组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc();
        services.AddDataProtection();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码会启用.NET Core默认的数据保护器。&lt;/p&gt;
&lt;p&gt;然后我们创建一个&lt;code&gt;MoviesController&lt;/code&gt;, 并在构造函数中注入&lt;code&gt;IDataProtectionProvider&lt;/code&gt;对象, 然后使用这个Provider对象创建一个实现&lt;code&gt;IDataProtector&lt;/code&gt;接口的数据保护器对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [Route(&quot;movies&quot;)]
    public class MoviesController : Controller
    {
        private readonly IDataProtector protector;
 
        public MoviesController(IDataProtectionProvider provider)
        {
            this.protector = provider.CreateProtector(&quot;protect_my_query_string&quot;);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;TIPS: 使用Provider创建Protector的时候，我们传入了一个参数&quot;protect_my_query_string&quot;, 这个参数标明了这个保护器的用途，你也可以把它就当成这个保护器的名字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意： &lt;strong&gt;不同用途的保护器不能解密对方的加密字符串。&lt;/strong&gt;, 如果使用了保护器A去解密保护器B生成的字符串，会产生以下异常CryptographicException: The payload was invalid.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我们在&lt;code&gt;MovieController&lt;/code&gt;中添加2个Api, 一个是获取所有Movies对象的，一个是获取指定Movie对象的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   [HttpGet]
   public IActionResult Get()
   {
       var model = GetMovies();
       
       var outputModel = model.Select(item =&amp;gt; new
       {
           Id = this.protector.Protect(item.Id.ToString()),
           item.Title,
           item.ReleaseYear,
           item.Summary
       });

       return Ok(outputModel);
   }

   [HttpGet(&quot;{id}&quot;)]
   public IActionResult Get(string id)
   {
       var orignalId = int.Parse(this.protector.Unprotect(id));

       var model = GetMovies(); 
       
       var outputModel = model.Where(item =&amp;gt; item.Id == orignalId);

       return Ok(outputModel);
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码解释&quot;&gt;代码解释&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在获取Movie列表的api中，我们使用了&lt;code&gt;IDataProtector&lt;/code&gt;接口的&lt;code&gt;Protect&lt;/code&gt;方法对Id字段进行了加密&lt;/li&gt;
&lt;li&gt;相应的在获取单个Movie对象的api中, 我们需要使用&lt;code&gt;IDataProtector&lt;/code&gt;接口的&lt;code&gt;Unprotect&lt;/code&gt;方法对Id字段进行解密。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;最终效果&quot;&gt;最终效果&lt;/h3&gt;
&lt;p&gt;首先我们调用/api/movies, 返回结果如下, id字段已经被正确加密了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[{
   &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6ygyO6avkgI2teCQGZQShNwsxC9ApDdsnyYd1K5IyNHjhZcRoGd6W31se3W6TWM8H9UdLEPn4fJpS5uKkqUa0PMV6a0ZZHBQSnlGoisSnj29g&quot;,
   &quot;title&quot;: &quot;泰坦尼克号&quot;
}, {
   &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6wkMUYyzflIzy3CwoMhcaO-np2WOy4czIL3WZd2FWi7Tsy119tDeFq7yAeye4o2W-KmbffpGXnTDZzNv2QbCrAm7-AyEN35g3pkfAYHa3X7aQ&quot;,
   &quot;title&quot;: &quot;我是谁&quot;
}, {
   &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6x2AXM6ulCwts2-uQSfzIU8UquTz-OAZIl-49D5-CYYl5H4mfZH8VihhCBJ60MMrZOlZla9qvb8EIP6GYRkEap4nhktbzGxW0Qu5r3edm6_Kg&quot;,
   &quot;title&quot;: &quot;蜘蛛侠&quot;
}, {
   &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6zDZeLtPIVlkRLCd_V6Mr2kTzWsCkfYgmS0-cqhFAOu4dUWGtx6d402_eKnObAOFUClEDdF4mrUeDQawE71DDa805umhbAvX2712i7UgYO5MA&quot;,
   &quot;title&quot;: &quot;钢铁侠&quot;
}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们继续调用api, 查询钢铁侠的电影信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/api/movies/CfDJ8D9KlbQBeipPoQwll5uLR6zDZeLtPIVlkRLCd_V6Mr2kTzWsCkfYgmS0-cqhFAOu4dUWGtx6d402_eKnObAOFUClEDdF4mrUeDQawE71DDa805umhbAvX2712i7UgYO5MA  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果也正确的返回了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[{&quot;id&quot;:4,&quot;title&quot;:&quot;钢铁侠&quot;}]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;带过期时间的数据保护器limited-lifetime&quot;&gt;带过期时间的数据保护器(Limited Lifetime)&lt;/h2&gt;
&lt;p&gt;.NET Core默认还提供了一种带过期时间的数据保护器, 这种数据保护器许多使用场景，最常用的场景就是当为一个重置密码操作的Token设置失效时间, 这样一旦超时的, Token就不能解密成功, 从而我们就可以认定重置密码操作超时了。&lt;/p&gt;
&lt;p&gt;.NET Core中, 我们可以使用&lt;code&gt;IDataProtector&lt;/code&gt;接口的&lt;code&gt;ToTimeLimitedDataProtector&lt;/code&gt;方法创建一个带过期时间的数据保护器。&lt;/p&gt;
&lt;p&gt;这里我们还是使用默认还是继续以上面的例子为例, 代码修改如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private readonly ITimeLimitedDataProtector protector;

    public MoviesController(IDataProtectionProvider provider)
    {
        this.protector = provider.CreateProtector(&quot;protect_my_query_string&quot;)
                 .ToTimeLimitedDataProtector();
    }

    [HttpGet]
    public IActionResult Get()
    {
        var model = GetMovies(); // simulate call to repository
        
        var outputModel = model.Select(item =&amp;gt; new
        {
            Id = this.protector.Protect(item.Id.ToString(), 
                                        TimeSpan.FromSeconds(10)),
            item.Title,
            item.ReleaseYear,
            item.Summary
        });

        return Ok(outputModel);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码解释-1&quot;&gt;代码解释&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这里我们定义了一个&lt;code&gt;ITimeLimitedDataProtector&lt;/code&gt;接口对象protector, 并在构造函数中使用&lt;code&gt;ToTimeLimitedDataProtector&lt;/code&gt;方法，将一个普通的数据保护器转换成了一个带过期时间的数据保护器&lt;/li&gt;
&lt;li&gt;在获取Movie列表的api中, 我们依然使用&lt;code&gt;Protect&lt;/code&gt;方法来加密Id字段, 与之前不同的是，这里我们加入了第二个&lt;code&gt;TimeSpan&lt;/code&gt;参数，这个参数表示了当前加密的有效时间只有10秒。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;最终效果-1&quot;&gt;最终效果&lt;/h3&gt;
&lt;p&gt;现在我们重新运行项目，还是和之前一样先调用/api/movies方法来获取Movies列表, 结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[{
    &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6yzbDbZ931toH32VC6Jqg8DWsrmiLrOxOFFViH4QWZne43jwSVzBjzJIfctYKZniZKNVbr50RRIZpW2fe9UtPajEzBhI-H32Effm-F0ColUaA&quot;,
    &quot;title&quot;: &quot;泰坦尼克号&quot;
}, {
    &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6zDDVymvftZK9lKBIjEyuoNTzOEu0SC2-qfTy6quXir2S8f3A1r44f9Yz3Sd_cyLZUp-_4gfJAasMfE8_ngYLrJmdsjN9LZ0g4vox0WJLjiGA&quot;,
    &quot;title&quot;: &quot;我是谁&quot;
}, {
    &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6zL-M2jzv2HCeTiHjevkXvI2216NERplp43TOjCXtj4S52ll68sLyQNtG2FhhWlsOmFGvYY5G4gm5SKfASMMgE1jBr20xc2b_djWdLhWLIxnA&quot;,
    &quot;title&quot;: &quot;蜘蛛侠&quot;
}, {
    &quot;id&quot;: &quot;CfDJ8D9KlbQBeipPoQwll5uLR6wAoZKCHTG0lvgYS3If_0_eAD30a2YV8RjNagwLXUdCSKsO3kyS58hqDqAPHw_KHwNpd-hjDFl3hFPa8LOWHyk901oc6ZuSxwzxFlljaVreFA&quot;,
    &quot;title&quot;: &quot;钢铁侠&quot;
}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待10秒钟后，我们继续调用api, 查询钢铁侠的电影信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/api/movies/CfDJ8D9KlbQBeipPoQwll5uLR6wAoZKCHTG0lvgYS3If_0_eAD30a2YV8RjNagwLXUdCSKsO3kyS58hqDqAPHw_KHwNpd-hjDFl3hFPa8LOWHyk901oc6ZuSxwzxFlljaVreFA&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回了错误信息CryptographicException: The payload expired at 9/29/2018 11:25:05 AM +00:00. 这说明当前加密的有效期已过, 不能正确解密了。&lt;/p&gt;
&lt;h2 id=&quot;tips-使用action-filter解密参数&quot;&gt;Tips: 使用Action Filter解密参数&lt;/h2&gt;
&lt;p&gt;在之前的代码中，我们在获取单个Movie的方法中，我们手动调用了&lt;code&gt;Unprotected&lt;/code&gt;方法来解密id属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [HttpGet(&quot;{id}&quot;)]
    public IActionResult Get(string id)
    {
        var orignalId = int.Parse(this.protector.Unprotect(id));

        var model = GetMovies(); // simulate call to repository
        
        var outputModel = model.Where(item =&amp;gt; item.Id == orignalId);

        return Ok(outputModel);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们改用Action Filter来改进这部分代码。&lt;/p&gt;
&lt;p&gt;首先我们创建一个&lt;code&gt;DecryptReferenceFilter&lt;/code&gt;, 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class DecryptReferenceFilter : IActionFilter
    {
        private readonly IDataProtector protector;

        public DecryptReferenceFilter(IDataProtectionProvider provider)
        {
            this.protector = provider.CreateProtector(&quot;protect_my_query_string&quot;);
        }

        public void OnActionExecuting(ActionExecutingContext context)
        {
            object param = context.RouteData.Values[&quot;id&quot;].ToString();
            var id = int.Parse(this.protector.Unprotect(param.ToString()));
            context.ActionArguments[&quot;id&quot;] = id;
        }

        public void OnActionExecuted(ActionExecutedContext context)
        {

        }
    }

    public class DecryptReferenceAttribute : TypeFilterAttribute
    {
        public DecryptReferenceAttribute() :
            base(typeof(DecryptReferenceFilter))
        { }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;代码解释-2&quot;&gt;代码解释&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这里&lt;code&gt;DecryptReferenceFilter&lt;/code&gt;实现了&lt;code&gt;IActionFilter&lt;/code&gt;接口, 并实现了&lt;code&gt;OnActionExecuting&lt;/code&gt;和&lt;code&gt;OnActionExecuted&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;DecryptReferenceFilter&lt;/code&gt;类中，我们注入了默认的数据保护器提供器，并在构造函数中初始化了一个数据保护器&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;OnActionExecuting&lt;/code&gt;中我们从&lt;code&gt;RouteData&lt;/code&gt;中获取到未解密的id字段, 然后将其解密之后，替换了之前未解密的id字段，这样ModelBinder就会使用解密后的字符串来绑定模型。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;最终修改&quot;&gt;最终修改&lt;/h3&gt;
&lt;p&gt;最后我们修改一下获取单个Movie的api, 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [HttpGet(&quot;{id}&quot;)]
    [DecryptReference]
    public IActionResult Get(int id)
    {
        var model = GetMovies();

        var outputModel = model.Where(item =&amp;gt; item.Id == id);

        return Ok(outputModel);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在获取单个Movie的方法上添加了&lt;code&gt;DecryptReference&lt;/code&gt;特性。&lt;br/&gt;运行代码之后，代码和之前的效果一样。&lt;/p&gt;
</description>
<pubDate>Sat, 29 Sep 2018 13:20:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/9726191.html</dc:identifier>
</item>
<item>
<title>Flask：01-三分钟入门Flask，多一分钟手把手带飞 - Sunwj_Monkey</title>
<link>http://www.cnblogs.com/swjblog/p/9726612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swjblog/p/9726612.html</guid>
<description>&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;视图函数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'&amp;lt;h1&amp;gt;Hello Flask!&amp;lt;/h1&amp;gt;'&lt;/span&gt;


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/welcome/&amp;lt;name&amp;gt;/&amp;lt;uid&amp;gt;/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;welcome&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(name, uid)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'Hello {} {}'&lt;/span&gt;.format(name, uid)


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/user/&amp;lt;int:uid&amp;gt;/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(uid)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'Hello {}号'&lt;/span&gt;.format(uid)


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/path/&amp;lt;path:p&amp;gt;/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(p)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; p
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;1.路由末尾的'/'建议都加上，防止出现路由多敲'/'出现的问题
2.若需要路由参数，参数需要放在&amp;lt;&amp;gt;中，对应的视图函数需要同名的参数
3.路由参数可以指定多个，也可以指定类型
4.常用参数类型：str(默认)、int、float、path，使用时放在参数前面，使用':'与参数连接
5.path类型其实是str类型，只是将'/'作为普通字符处理罢了。
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;请求(request)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; request


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/request/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; request.headers.get(&lt;span class=&quot;hljs-string&quot;&gt;'User-Agent'&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;响应(response)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; make_response


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/response/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;response&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    
    
    
    
    
    resp = make_response(&lt;span class=&quot;hljs-string&quot;&gt;'这是通过函数构造的响应'&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;404&lt;/span&gt;)
    
    resp.headers[&lt;span class=&quot;hljs-string&quot;&gt;'uid'&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; resp
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;重定向(redirect)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; redirect, url_for


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/old/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    
    
    
    
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; redirect(url_for(&lt;span class=&quot;hljs-string&quot;&gt;'new'&lt;/span&gt;))

&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/new/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'新的数据'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;反向构造路由(url_for)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/urlfor/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;urlfor&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    
    
    
    
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; url_for(&lt;span class=&quot;hljs-string&quot;&gt;'user'&lt;/span&gt;, uid=&lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt;, name=&lt;span class=&quot;hljs-string&quot;&gt;'cuihua'&lt;/span&gt;, _external=&lt;span class=&quot;hljs-keyword&quot;&gt;True&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;终止及错误定制&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-decorator&quot;&gt;@app.route('/abort/')&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    
    
    abort(&lt;span class=&quot;hljs-number&quot;&gt;404&lt;/span&gt;)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'正常'&lt;/span&gt;


&lt;span class=&quot;hljs-decorator&quot;&gt;@app.errorhandler(404)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;page_not_found&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(e)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'是不是搞错了大哥？'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
</description>
<pubDate>Sat, 29 Sep 2018 12:48:00 +0000</pubDate>
<dc:creator>Sunwj_Monkey</dc:creator>
<og:description>Flask入门 WEB工作原理 C/S与B/S架构：客户端-服务器，浏览器-服务器 B/S架构工作原理 客户端(浏览器) &lt;=&gt; WEB服务器(nginx) &lt;=&gt; WSGI(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/swjblog/p/9726612.html</dc:identifier>
</item>
</channel>
</rss>