<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>TFS在项目中DevOps落地进程（下） - LeoLaw</title>
<link>http://www.cnblogs.com/leolaw/p/7847062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leolaw/p/7847062.html</guid>
<description>&lt;p&gt;紧接上篇 &lt;a href=&quot;http://www.cnblogs.com/leolaw/p/7821335.html&quot; target=&quot;_blank&quot;&gt;TFS在项目中Devops落地进程（上）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再接着说TFS相关之前先插入一个番外篇，虽然跟TFS关系不大但跟DevOps关系很大，觉得有必要在此乱入一下。&lt;/p&gt;
&lt;h2&gt;番外篇--监控之Application Insights&lt;/h2&gt;
&lt;p&gt;我们之前并没有任何监控类产品（我指的是应用程序级别的），发生任何异常都是往数据库的表里insert个错误日志，all系统共用同一张错误表。&lt;/p&gt;
&lt;p&gt;这其实意味着我们当时的系统是：&lt;strong&gt;系统异常基本不关注（线上数据库开发肯定没法查对吧），关注的时候肯定都出事了&lt;/strong&gt;，对自己负责的系统的运行状态基本不了解，什么性能之类东西纯粹靠猜。&lt;/p&gt;
&lt;p&gt;然后我就希望我们能有办法获取到我们系统的各种状态，而此时在VS2015的时候整合在VS里的application insights引起了我的关注。&lt;/p&gt;
&lt;p&gt;简要介绍下application insights,是微软基于azure所推出的一款SAAS性质的APM(Application Performance Management,应用程序性能管理)服务，本人不会详细介绍这个，详情可参阅&lt;a href=&quot;https://azure.microsoft.com/zh-cn/services/application-insights/&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然后也感谢我大学年代曾经当过MSP（微软校园菁英）并透过这个拿到过Visual Studio Enterprise的订阅，然后里面附赠的每个月150美元额度的Azure费用，让我有条件可以先试用Application Insights。&lt;/p&gt;
&lt;p&gt;然后自己将自己负责的站点搭上Insights做了个小Demo展示了给老大看，然后老大也对此表示满意。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230718921-2106972961.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230719437-1361165305.png&quot; alt=&quot;image&quot; width=&quot;457&quot; height=&quot;445&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;(Application Insights的概览图)&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在后续的一次PMO会上我将此拿出来进行了演示，也获得了CTO的认可和支持，然后终于可以将Application Insights投入到线上使用（当然此时用的是公司正式的账号而不是我那个150刀每月的测试号了）。&lt;/p&gt;
&lt;p&gt;但是有Insights投入初期其他小伙伴热情度并不高，大家还是觉得记数据库挺好的，直到后面发生了一件事…&lt;/p&gt;
&lt;p&gt;事情是这样的，那是一个要常规发布的夜晚，因为并没有数据库相关的修改，所以DBA已经下班了（要加班到夜里发布，DBA只是正常下班），然后某站点发布上去的时候报错了，然后对应的开发小伙伴不知道为什么，就知道出异常了。&lt;/p&gt;
&lt;p&gt;然后此时DBA不在，无法查线上数据库，然后就干着急，最后通过在代码里让异常本地写txt临时解决了发布上的问题，但这个问题完整暴露出记录数据库的不靠谱：万一DBA不在呢？毕竟如果没数据库内容的话总把DBA留下来的话其实也不合理，我们应该要从更长远和更科学的方案解决这个问题。&lt;/p&gt;
&lt;p&gt;至此后续我们所有项目加入Insights的进程就加快了，因为Insights里我们可以自主的查看到性能/请求/异常等各种数据了。&lt;/p&gt;
&lt;p&gt;另外有了Insights后我们开发自己第一次有了自己的程序运行数据，有时候我们也会针对Insights里的数据做一些对应的优化。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230719921-607689985.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230720406-561131836.png&quot; alt=&quot;image&quot; width=&quot;648&quot; height=&quot;313&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图，这是一个通过城市Id获取城市名称的接口，原先调用量巨大（当时设置了50%采样率，所以实际调用量要比图中翻一倍）但是其实这个接口返回的内容可变性不高，然后让前端加了缓存后从原来至少10K以上每小时调用量下降到现在100多的调用量，而这些都是因为我们有了Insights之后才能进行的。&lt;/p&gt;
&lt;p&gt;所以说：&lt;strong&gt;优化不能靠猜，我们要用数据说话。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而Insights的Analysis功能/智能预警功能等特性也在实际中帮我们解决了不少问题。&lt;/p&gt;
&lt;p&gt;然后Insights也是可以跟TFS进行一定程度的整合的，其中主要包括自动发布的时候打上注解和在TFS的面板里查看Insights的信息&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230720921-531263069.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230721546-89277069.png&quot; alt=&quot;image&quot; width=&quot;586&quot; height=&quot;368&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;版本注解，有了这个我们可以从监控系统里知道什么时候上了预发布环境&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230721827-739512646.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230722249-834399410.png&quot; alt=&quot;image&quot; width=&quot;466&quot; height=&quot;160&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;可添加在TFS上的widget(新版本的，详情可参看&lt;/span&gt;&lt;/em&gt;&lt;a href=&quot;https://azure.microsoft.com/en-us/blog/vstsdashboardchartwidget/&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;&lt;span&gt;Application Insights: VSTS dashboard chart widget now available&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;&lt;em&gt;&lt;span&gt;)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;然后最近Insights里还有各种Preview的功能，比如新的Preview性能面板里能查看到95线/99线等，新的异常面板里还能给你分析出你异常的共同点之类的，Insights也一直在进步着。&lt;/p&gt;
&lt;p&gt;在定型监控系统的时候我们曾经议论过听云和是否自建服务端（当时确定了监控的SDK都是用Insights的，但是纠结于是否基于ELK自建服务端）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;听云：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;老实说从默认的图表来说，听云比Insights的图表更全面，但听云缺乏一个Insights里有的一个很重要功能，查询分析Analysis：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230722827-56581608.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230723359-1979679627.png&quot; alt=&quot;image&quot; width=&quot;652&quot; height=&quot;366&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;在Insights的Analysis里，可以通过一个长的很像Sql的一种语句，可以快速查询你想要的任何原始数据（精确到每一条）,此语句也能绘制图表，这个绝对是对程序员Friendly的一个功能&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;比方说出了异常，可能从运维层面更关注异常的趋势，而开发层面更关注的是具体的每一个异常，和每一个异常对应的每一个请求等，另外听云因为是服务器层面的监控无法在代码层面埋点，我们Insights里则埋了如果异常的话将错误请求的Body记录到Insights的Traces里，这样就算是Post/Put之类的请求报错我们也能拿到原始请求报文。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自建服务端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于这个我觉得在我们现在连Redis啊队列啊这些更紧急的东西都没有落实的情况下在分出人力去搞这个，就担心做出来后就是个永恒的1.0版本，觉得类似这种东西除非说有专职负责这个的人/团队不然不应该自建，再说那个时候我们组已经用Insights好一段时间了（有接近1年了吧）习惯了上面各种高级特性，而原始版的ELK则呵呵哒（一个自个买的原始毛胚房VS一个租来的豪华精装房），当然如果有专职人员专门投入到上面基于ELK做定制开发我相信也肯定能做的跟Insights那样或者比Insights更好，但是，我们有更多更紧急的事不是么？&lt;/p&gt;
&lt;p&gt;不过倒是有一点是因为费用问题我们的Insights是使用了采样率的（就是说并不是收集全部而是部分收集），但是我们希望异常不要被采样，所以后面可能要基于ELK搞个Exceptionless来专门记录异常。&lt;/p&gt;

&lt;p&gt;另外Insights跟VS的整合也是棒棒哒，比如下面这样，直接告诉我哪个方法发生了异常，直接反映在CodeLens里&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230723640-452127040.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230723968-1202539132.png&quot; alt=&quot;image&quot; width=&quot;592&quot; height=&quot;166&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;第4篇--自行管理BuildAgent&lt;/h2&gt;
&lt;p&gt;原先整个TFS服务器的搭建和维护都在运维那边，那为什么要拿出这个来说呢？&lt;/p&gt;
&lt;p&gt;首先我们现在正处于一个快速发展的年代，什么框架啊每月总能冒出几个，技术各种日新月异，虽然绝大多数企业本着稳定至上的原则不会说总是用最新，但这不是固步自封，不思进取的借口，&lt;strong&gt;在一个“最新”变为”稳定“之后总要试着跳出舒适区步入现代化进程吧？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后我们遇到的第一件事就是.Net版本升级,我们计划升级到.Net 4.6.2（原来是4.0到4.5.1不等），然后因为自动打包的原因所以要求Build Agent也要升级，然后原先运维部署配置的TFS是服务器+Build Agent放在同一个机器上的，搭载的是VS2015.&lt;/p&gt;
&lt;p&gt;然后除了4.6.2之外的话我们有个别类库项目使用上了.Net Core里全新的xproj格式来进行多target framework的开发，这也要求服务器上要有.Net Core的Sdk。&lt;/p&gt;
&lt;p&gt;在另外此时在讨论到代码质量审核，然后我们初定使用Sonarqube，而这个也要求Build Agent服务器要有Java的功能。&lt;/p&gt;
&lt;p&gt;基于上述原因外加后面我们技术部某神秘人物毛哥批了一批（2台）服务器（也就一般工作电脑）资源给我，后面还有CTO批了一台大服务器（真·服务器，当时可是嘻嘻哒的内心&lt;img class=&quot;wlEmoticon wlEmoticon-openmouthedsmile&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230724265-1538565385.png&quot; alt=&quot;Open-mouthed smile&quot;/&gt;），然后我开始自己搭建Build Agent。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230724562-1568226300.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230724906-1414605862.png&quot; alt=&quot;image&quot; width=&quot;684&quot; height=&quot;234&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;当前我们组自行维护的4台Build Agent，承载了包括持续集成，自动打包，代码分析，自动测试等一系列任务&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230725624-396322728.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230726124-1428178777.png&quot; alt=&quot;image&quot; width=&quot;631&quot; height=&quot;380&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;装上了一堆现在要用或将来希望想用的功能，满足当前及其可预见的一段时间内的需求&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;其实关于Build Agent主要觉得这个必须要能适应开发组的步伐，首先我们.Net 4.5-&amp;gt;.Net 4.6.2的时候，要求Build Agent要支持.Net 4.6.2或以上，之后我们有计划要上.Net Core（此时已经有基于.Net Core项目的Dll包了），而且之后.Net Core还有2.0版本（主要是NetStandard 2.0），所以我觉得这个Build Agent在我们组内的话我们能更好适配我们的前进步伐。&lt;/p&gt;
&lt;p&gt;现在我们的Build Agent里装的是Vs2017 17.3 + .Net 4.7 + .Net Core 2.0 + Docker 17.03.2-ee + CMake 3.9.1 + Python 3.6.2(x64) + JMeter 3.0 + F# 4.1 + Node.js 8.4(x64) + Java 1.8&lt;/p&gt;
&lt;p&gt;估计小半年内基本都能满足需求。&lt;/p&gt;

&lt;h2&gt;第5篇--自动代码质量检查&lt;/h2&gt;
&lt;p&gt;接着上篇说，我们有了自己的Build Agent，然后自动发布之类的基础功能也有了，于是我们就有更高层次的自动化追求了。&lt;/p&gt;
&lt;p&gt;首先就是自动化代码质量检查，在此先声明一点：&lt;strong&gt;任何自动化代码质量检查工具都不能代替人肉的Code Review，但能减少人肉Code Review的工作量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后在选型上我们选了Sonarqube，当然你们会问为什么选Sonarqube，说来惭愧其实我之前并不了解相关产品，然后在TFS商店里看到了这货然后才知道还能自动化代码检查…然后就去研究这货，发觉总体还可以（规则之类的啊，还有跨平台等），在跟我们技术部神秘人物毛哥上报下技术选型获得认证后就拍板开始干。&lt;/p&gt;
&lt;p&gt;通过自己手头有的服务器资源，搭建了个Sonarqube服务器，然后通过TFS的任务加上去&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230726515-1331298563.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230727015-1871075295.png&quot; alt=&quot;image&quot; width=&quot;514&quot; height=&quot;305&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;一个带Sonarqube分析的编译过程，作为C#程序员看上去好像一个using的结构（开始-&amp;gt;释放)&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230727624-2070712436.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230728171-432310209.png&quot; alt=&quot;image&quot; width=&quot;713&quot; height=&quot;347&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;某项目分析结果&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;好，然后代码分析质量有了，大家就能照着上面去“优化”代码了。&lt;/p&gt;
&lt;p&gt;慢着，我写了一段代码，因为水平问题我也不知道有没有咖喱，然后一提交，然后上面就留下了一个永恒的污点（有历史记录的），这样肯定很不爽，所以后面我们就纠结有没办法能够让代码在进入到Sonarqube系统之前先有个反馈。&lt;/p&gt;
&lt;p&gt;然后此时微软就发布了TFS2017，具体参考 &lt;a href=&quot;https://www.visualstudio.com/zh-cn/news/releasenotes/tfs2017-relnotes&quot; target=&quot;_blank&quot;&gt;TFS2017RTM Release Note&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中它引入了这么一个功能&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230728827-494870580.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230729421-200252370.png&quot; alt=&quot;image&quot; width=&quot;773&quot; height=&quot;395&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;在拉取请求的时候显示Sonarqube的分析结果（直接定位到你代码上），且该分析结果不记录到Sonarqube服务器里&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;接着怂恿下老大出面让运维那边帮忙升个级。&lt;/p&gt;
&lt;p&gt;然后为了配合Sonarqube，那么每个项目在Pull Request的时候都要进行编译的过程（编译了Sonarqube才能分析），因此也顺带加上了阻止合并不能编译的代码这个额外附加项。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230729952-1936059889.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230730124-726421654.png&quot; alt=&quot;image&quot; width=&quot;337&quot; height=&quot;189&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;同意一次Pull Request需要一个非本人外的其他人同意且要编译成功&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后审核人也能看到Sonarqube分析的结果就不用每行仔细看也能大概知道个所以然。&lt;/p&gt;
&lt;p&gt;当然实践过程中，看别人的代码发现不少什么超过3重if嵌套啊，类超过1000行啊这些，他们总说由于某些原因实在不好改的，那就只能忍了（你能怎么办呢，特别是多重if的往往都是各种业务条件判断复杂，然后自己也没空深入去看他们的业务），但自己项目要求要严格点，要严格控制不能出现任何形式的咖喱。&lt;/p&gt;
&lt;p&gt;另外在此吐槽一点：&lt;em&gt;TFS不能直接在Dashboard里浏览Sonarqube的结果，要看Sonarqube结果还要跳到Soanrqube里去，这不符合All in one的TFS理念啊，就没人想过弄个Widget什么的来解决解决这个问题？&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;第6章--自动测试&lt;/h2&gt;
&lt;p&gt;自动测试在这里想主要分2块来说，单元测试和集成测试。&lt;/p&gt;
&lt;p&gt;首先我觉得对于这2个概念尽管有很官方的说明但实践中很多人都有自己的理解，我简单说下我自己对上述2个词的理解和定义&lt;/p&gt;
&lt;p&gt;单元测试：在代码内部进行的不依赖外部环境（网络/数据库等）进行的对某个方法级的测试，特点是只能测试一小块逻辑,能模拟数据且运行较快（毫秒级），代码执行结果可预测。&lt;/p&gt;
&lt;p&gt;集成测试：可能是代码也可能是脚本依赖外部环境（网络/数据库等）进行的针对某个流程上的测试，特点是要造数据且运行较慢（至少是秒级），代码执行结果绝大多数情况下可预测（受外部因素影响不能100%可控）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单元测试：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要让代码可以被单元测试，首先代码先要是可测试的，要如何做到代码可测试呢？答案很简单，随便街上抓一个伪计算机专业的都能给出你正确答案：解耦。&lt;/p&gt;
&lt;p&gt;但是你要真的落实“解耦”到你的代码里，又往往是一个异常艰巨的任务（Talk is cheat, show me the code)。&lt;/p&gt;
&lt;p&gt;首先在我自己负责的项目里，完全使用依赖注入的形式重构了，另外抽象出了各种各样的接口，理论上要做到所有的”Service“都是可以”被替换”的。&lt;/p&gt;
&lt;p&gt;严格限制对static和new这2个关键字的使用（绝大多数情况下static或者new都意味着不可测试，当然static一个数据无关的方法比如Math.Min之类的或者new一个纯数据类这些例外）&lt;/p&gt;
&lt;p&gt;在自己一番折腾下，现在自己负责的项目单元测试覆盖率70%+，也算是一个自己比较满意的数字了（这个是Resharper收集的，它将单元测试项目本身也包含进去了的）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230730437-2080294727.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230730718-1669917387.png&quot; alt=&quot;image&quot; width=&quot;624&quot; height=&quot;123&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在单元测试的加持下，自己想重构代码什么的都能放开手去重构，有没有影响老逻辑？测试跑一下就知道了。&lt;/p&gt;
&lt;p&gt;而加新逻辑的时候也能知道会对原有流程造成怎么样的影响。&lt;/p&gt;
&lt;p&gt;总之有单元测试后，你会对你的代码更加倍有信心。关于单元测试看看日后是否专门开一篇文章来说说，里面也有大学问。&lt;/p&gt;
&lt;p&gt;上面说了那么多单元测试，那么它跟TFS有啥关系呢？测试写完了是吧？你怎么能确保它一定是有在跑呢？这时就可以将单元测试的运行整合在自动编译的流程里&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230731031-1300186720.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230731359-1118110124.png&quot; alt=&quot;image&quot; width=&quot;687&quot; height=&quot;280&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;整合到编译流程里的单元测试，每次跑完后会报告结果，如果单元测试失败那么会阻止pull request&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230731624-1763890394.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230731921-1255536173.png&quot; alt=&quot;image&quot; width=&quot;489&quot; height=&quot;228&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;在TFS主页的Dashboard里展示单元测试结果&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集成测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们的集成测试现在主要是QA那边负责，QA那边有基于Jmeter来进行的测试，具体细节因为不是我负责所以我不是特别清楚，但是在Build Agent里装好Jmeter后（QA配置好了各种他们要的插件的版本）然后在自动发布的时候运行下就好了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230732281-572402579.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230732577-299425818.png&quot; alt=&quot;image&quot; width=&quot;526&quot; height=&quot;291&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;运行QA他们指定的Jmeter，先从一个位置拷贝配置文件过来然后运行命令行，没错，从TFS角度去理解的话它只是去执行个命令行而已&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;不过当前QA他们弄的Jmeter是运行后发一个结果邮件，如果能够将Jmeter的测试结果转变为TFS可接收的某种测试结果格式（什么JUnit或者Xunit之类的测试结果）展示到TFS上那就更好了（如果有会的人请赐教）&lt;/p&gt;
&lt;p&gt;在集成测试方面我自己也有一套基于代码的（当然现在主流都是基于脚本了）&lt;/p&gt;
&lt;p&gt;基于Specflow+xunit的方式我自己做了几个我旗下项目主流程的测试用例（就是那种一出问题QA就邮件出来：”测试环境挂拉“的那种）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230732874-855166059.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230733187-1108388083.png&quot; alt=&quot;image&quot; width=&quot;425&quot; height=&quot;297&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;基于Specflow的BDD形式的描述文档，尽可能弄的贴近业务层面&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230733468-2093920120.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230733827-593255059.png&quot; alt=&quot;image&quot; width=&quot;388&quot; height=&quot;353&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;描述文档背后对应的是若干代码&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230734077-999020571.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230734421-178698240.png&quot; alt=&quot;image&quot; width=&quot;418&quot; height=&quot;128&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;目前我自己这套集成测试仅放在Demo环境（第一个测试环境）使用，主要是一旦发觉个风吹草动，立马还原代码…(逃…&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;关于集成测试按道理此处应有以Selenium为代表的UI自动化测试，不过我自己主要负责的是接口，然后让折腾UI的那位同事目前也只是处于演示级阶段还没正式投入使用，此处就不献丑了。&lt;/p&gt;
&lt;p&gt;当然TFS上还有管理手工测试等各种功能，不过由于QA组是基于Jira来管理任务所以并没使用。&lt;/p&gt;

&lt;h2&gt;第7章--引入NetCore的打包&lt;/h2&gt;
&lt;p&gt;尽管我们当前在经过一番折腾后全组项目目前已经统一到.Net 4.6.2，但短时间内也不会用上NetCore，但背后一直为了NetCore的迁移在默默准备着。&lt;/p&gt;
&lt;p&gt;主要是考虑到在NetCore 2.0后出了个NetStandard2.0，它跟NetCore 2.0以及.Net Framework 4.6.1是兼容的。&lt;/p&gt;
&lt;p&gt;那么我们现在项目代码的目标都是兼容Netstandard2.0（底层类库)，但之后真要迁移的时候就改个TargetFramework以及表现层稍微改下就好了（嗯，很丰满的理想）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说这篇呢主要是分享一个，我们现在TFS是2017Update2，在这个版本下你用常规方法是无法引用任何Netstandard2.0的包的（不信你们试试）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其本质是因为TFS2017Update2自带的Nuget还原工具是4.0版，而4.0是不支持NetStandard2.0，要4.3才可以，那难道我们在现有的TFS下（2018又没Release）就拿NetStandard没辙了？&lt;/p&gt;
&lt;p&gt;然后就找到了这篇文章&lt;a href=&quot;https://blogs.msdn.microsoft.com/devops/2017/09/29/using-the-latest-nuget-in-your-build/&quot; target=&quot;_blank&quot;&gt;Using the latest NuGet in your build&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章指引下，将它 &lt;a href=&quot;https://github.com/keithrob/tools/blob/master/vstsfetchnuget-min.ps1&quot; target=&quot;_blank&quot;&gt;那堆Powershell脚本&lt;/a&gt; 粘贴上去执行,下面参数写个4.3.0&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230734749-1556676043.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230734999-1764488419.png&quot; alt=&quot;image&quot; width=&quot;610&quot; height=&quot;251&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后使用自定义的nuget&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230735609-1634736384.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230736124-208173853.png&quot; alt=&quot;image&quot; width=&quot;610&quot; height=&quot;289&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后就迎来了胜利的曙光&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230736546-1768023670.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230737109-603471690.png&quot; alt=&quot;image&quot; width=&quot;613&quot; height=&quot;286&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;第8章--我们基于TFS的小折腾&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;任务管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然我司一直是基于Jira做任务管理的，不过因为Jira并不能直接跟TFS上的代码进行关联，所以我私自上是喜欢在TFS里建对应任务然后关联上去&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230737593-356761878.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230738202-476105337.png&quot; alt=&quot;image&quot; width=&quot;402&quot; height=&quot;246&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;还能跟代码里结合起来&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230738781-1984439649.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230739390-619303554.png&quot; alt=&quot;image&quot; width=&quot;382&quot; height=&quot;95&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在TFS里也能做可视化的关联查询&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230739890-318470525.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230740124-2123804809.png&quot; alt=&quot;image&quot; width=&quot;380&quot; height=&quot;338&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动备份分支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是最近折腾出来的小玩意&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230740531-2000670103.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/658343/201711/658343-20171116230740859-386094877.png&quot; alt=&quot;image&quot; width=&quot;488&quot; height=&quot;230&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在Release里加上这个步骤（这是个插件提供的，&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=jabbera.git-tag-on-release-task&quot; target=&quot;_blank&quot;&gt;插件详情请点此处&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;然后在执行到对应发布步骤的时候就会自动将当前发布的代码拉一个分支出来，全自动的哟。&lt;/p&gt;

&lt;h2&gt;第9章—VNext&lt;/h2&gt;
&lt;p&gt;上面的大概就是我们现在折腾TFS的成果，但我们的道路远没结束，或者说，现在又处在某种程度上的开始。&lt;/p&gt;
&lt;p&gt;首先，Docker这个大趋势肯定之后或多或少都要涉足进去的（不过觉得先将诸如服务发现之类的前置条件先搞定在做这个）&lt;/p&gt;
&lt;p&gt;还有撇了下隔壁TFS2018的Release Note,这回引入了Wiki功能，回头可能可以直接在TFS上直接写上各种知识库文章了&lt;/p&gt;
&lt;p&gt;还有想整个OWASP ZAP然后跟TFS流程整合下来个自动渗透测试分析什么的，让我们自动化更上一层楼(if有空弄的话)。&lt;/p&gt;
&lt;p&gt;大概就是扯那么多了。&lt;/p&gt;
&lt;p&gt;The End。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 15:08:00 +0000</pubDate>
<dc:creator>LeoLaw</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leolaw/p/7847062.html</dc:identifier>
</item>
<item>
<title>Celery 源码解析五： 远程控制管理 - 行者酱油君</title>
<link>http://www.cnblogs.com/makor/p/remote-control-manager.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/makor/p/remote-control-manager.html</guid>
<description>&lt;p&gt;今天要聊的话题可能被大家关注得不过，但是对于 Celery 来说确实很有用的功能，曾经我在工作中遇到这类情况，就是我们将所有的任务都放在同一个队列里面，然后有一天突然某个同学的代码写得不对，导致大量的耗时任务被同时塞进了消息队列里面，这就悲剧了，这直接导致了其他服务长时间不可用，例如发送登录短信验证码无法使用了，还有支付信息无法同步了等等，反正就是造成了一些不小的影响。&lt;/p&gt;
&lt;p&gt;当时我们的处理方式就很被动，只能手动连接上 MQ，然后把消息卸掉，其实也就手动将这些消息抛弃掉，从而让其他业务的消息可能正常运行。但是，这种方式也只适合当初作为少量流量的情况，对于搭建了大集群和大量任务的消息队列来说，这种方式是不可想象的，这么做是要死人的，不仅仅是被累垮，上头的口水都能把你淹了。所以，这个时候，我需要介绍一个 Celery 不太常被人使用的功能——远程控制。&lt;/p&gt;
&lt;h3 id=&quot;toc_0&quot;&gt;远程控制功能&lt;/h3&gt;
&lt;p&gt;其实 Celery 很早之前就存在控制命令，例如可以使用 Python shell 的 shell 命令，可以查看任务状态的 status 命令等等，但是这些命令都是本地的，不能让人觉得有意思，但是，这里有两个系列的命令很厉害，它们分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;inspect：主要用于查看 Celery 状态信息&lt;/li&gt;
&lt;li&gt;control：主要用于设置 Celery 状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，我在机器 A 运行着一个 Celery，机器 B 也运行着一个 Celery，机器 C &lt;strong&gt;没有运行&lt;/strong&gt; Celery，但是我可以在机器 C 上查询机器 A 或者机器 B 上的任务状态，甚至可以删除和停止任务，这些都是很简单可以实现的，但是本文不是讲解这些功能的文章，而是解析这些功能的文章，所以有兴趣的同学可以参考这份&lt;a href=&quot;http://docs.celeryproject.org/en/latest/userguide/monitoring.html#management-command-line-utilities-inspect-control&quot;&gt;官方文档&lt;/a&gt;继续了解。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;远程控制功能组件&lt;/h3&gt;
&lt;p&gt;要实现远程控制功能，我们需要从宏观上先看看 Celery 的设计思路，在 Celery 中，采用的是分布式的管理方式，其实没有太大秘密，就是每个节点之间都是通过广播/单播进行通信，从而达到协同效果，但是这过程还是有很多不好之处的，值得我们来思考一番。&lt;/p&gt;
&lt;p&gt;Celery 每个运行的实例都维护着一个 Control Node，其实就是一个可以接收/发送消息的对象，这个对象的封装是 &lt;code&gt;Kombu.pidbox.Mailbox.Node&lt;/code&gt;，我们就先来看看创建的实现吧。&lt;/p&gt;
&lt;p&gt;还是回到第一篇，在 Consumer 的 Blueprint 中，有一个叫做 Control 的 Bootstep，这个就是用于节点管理和通信的，我们来看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223840515-1302394605.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;其实代码还是比较简单的，有两个地方值得我们关注，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Line 25&lt;/strong&gt;：这里是构建了一个 Pidbox&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Line 26 - Line 28&lt;/strong&gt;：这个 Bootstep 的 start、stop 和 shutdown 方法都是使用的 box 的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以这个 Pidbox 是什么就很重要了，在我们看之前，不放看下上面的注释，也许会更容易一些：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223838812-147213621.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;虽然这里关系说得很明确了，但是我们还是有必要看看的，毕竟有可能里面有设置什么特殊的东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839140-2103648824.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;ok，确实还好，很诚实得就是用 Kombu 的 mailbox，但是 kombu 的 mailbox 是什么，可能很多人都没试过，我之前也没试过，后来试了一下，感觉还挺有意思的，注意，下面这段可能是现在互联网上公开的为数不多的可以运行得 Kombu Demo 示例，甚至于讲解。&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;Kombu Mailbox&lt;/h3&gt;
&lt;p&gt;在 Kombu 中提供了 Mailbox 的实现，它的作用就是通过 Mailbox 我们可以实现不同实例之间的消息发送和处理，具体可以是&lt;strong&gt;单播&lt;/strong&gt; 和 &lt;strong&gt;广播&lt;/strong&gt;，这个在 Celery 中是作为 Control 的功能使用的，但是，在其他的模型里面，例如 Celery 试图实现但是没有实现的 Actor 模型里面也是可以用的。&lt;/p&gt;
&lt;p&gt;Anyway，下面还是讲讲 Kombu 中的 Mailbox 是怎么用的吧，当初找相关的资料费了老大力了，但是，并没有太大收获，所以自己总结了一番。在 Kombu 中，Mailbox 中只有一个概念，那就是 &lt;strong&gt;Node&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Node：每个 Node 都是一个实例，互相直接没有关联，可以完全独立，他们通过 mailbox 进行通信&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是，为了测试，我们还会引入一个 &lt;strong&gt;client&lt;/strong&gt; 的概念，但是这个概念不是 Kombu 自己的，而是我为了演示效果添加进来的，所以现在我们应该有两个地方，分别是：&lt;strong&gt;Node&lt;/strong&gt; 和 &lt;strong&gt;Client&lt;/strong&gt;，其中可以认为 &lt;strong&gt;Node&lt;/strong&gt; 是 &lt;strong&gt;Server&lt;/strong&gt; 端，&lt;strong&gt;Client&lt;/strong&gt; 是触发端，你会发现，&lt;strong&gt;Client&lt;/strong&gt; 只是做了一件触发的工作，没有其他更多的事情：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839171-1112446425.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这是 &lt;strong&gt;node&lt;/strong&gt; 的代码，你会发现它底层其实还是依赖于 Kombu 的 &lt;strong&gt;Connection&lt;/strong&gt;，所以可以看到依赖的还是我们 Celery 里面的 Broker，这点很重要。然后再看看我们是怎么触发的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839202-1327379571.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;可以发现这里非常简单，还是通过 &lt;strong&gt;Connection&lt;/strong&gt; 构建出 mailbox，有一点需要注意的就是，&lt;strong&gt;Broker&lt;/strong&gt; 要一致，不然你让他们怎么通信？执行这段代码，然后你就会在 node 上看到执行效果了，具体怎样，体验之后就明了。&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;Celery 的远程控制&lt;/h3&gt;
&lt;p&gt;看过 Kombu 的实现例子之后，我们来看看 Celery 是怎么构建这些对象的，首先还是得从最开始的 control 开始说起，control 在 Celery 中也是有两处的，一处是 &lt;strong&gt;app/control.py&lt;/strong&gt;，另外一处就是：&lt;strong&gt;woker/control.py&lt;/strong&gt;，可以认为第一处的是对外的接口，而第二处的是初始化的入口，实现自然就是 Kombu 提供的了，这里只是用到他们而已。&lt;/p&gt;
&lt;p&gt;所以，现在来看，我们的目标很简单了，无非是看&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何初始化 mailbox 和 Node 的&lt;/li&gt;
&lt;li&gt;提供了那些对外接口可以使用的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面就这两个问题进行一一解答&lt;/p&gt;
&lt;h4 id=&quot;toc_4&quot;&gt;mailbox 的初始化&lt;/h4&gt;
&lt;p&gt;故事是从 control 这个 Bootstep 开始说起，这是是初始化的起源：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839124-1720768701.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这段代码我们前面已经见过了，同时我们也已经知道了 &lt;code&gt;self.box&lt;/code&gt; 是个啥了，但是，对于更进一步的 &lt;code&gt;c.app.control.mailbox.Node&lt;/code&gt; 中的 &lt;code&gt;c.app.control.mailbox&lt;/code&gt; 是啥还不知道，不妨来看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839140-1349789913.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;ok，这里也很清晰，因为这个 control_cls 就是我们后面要看的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;control_cls = 'celery.app.control:Control'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以 Mailbox 也就是 Kombu 的 Mailbox 了，这里没做什么改动。除此之外，还有一个地方需要我们去关注的，那就是收到消息后怎么处理，这个得看到 Bootstep 的 &lt;code&gt;start&lt;/code&gt; 操作，这里是初始化过程中会被调用到的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839515-46113056.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;&lt;code&gt;start&lt;/code&gt; 的第一句（&lt;strong&gt;Line 50&lt;/strong&gt;）没毛病，因为用的都是 Celery 的 &lt;strong&gt;Connection&lt;/strong&gt;，然后是第二句，这里我们根据之前的例子，已经很清楚会发生什么事情了，所以关键就是 &lt;strong&gt;Line 37&lt;/strong&gt; 中的 &lt;code&gt;on_message&lt;/code&gt;，每当有其他消息过来的时候，这里都是处理点。&lt;/p&gt;
&lt;p&gt;从 &lt;strong&gt;Line 42&lt;/strong&gt; 来看，Celery 还是甩锅给了 Kombu，但是这也不是啥问题，所以我们得找 Kombu 问清楚它是怎么处理的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839593-1796055321.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;ok，这里一直有个叫 clock 的东西，我先不看，后面再说一下，先看看 dispatch 是如何处理的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839781-1791369437.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Line 99&lt;/strong&gt; 这里其实是通过是否有发送主体（&lt;strong&gt;参数传过来的 reply_to&lt;/strong&gt;）来判断是 &lt;strong&gt;单播&lt;/strong&gt; 还是 &lt;strong&gt;多播&lt;/strong&gt; 的消息，然后选择不同的处理方式，分别是 &lt;strong&gt;Line 118&lt;/strong&gt; 中的 &lt;code&gt;handle_call&lt;/code&gt; 用来处理 &lt;strong&gt;单播&lt;/strong&gt;，而 &lt;strong&gt;Line 121&lt;/strong&gt; 中的 &lt;code&gt;handler_cast&lt;/code&gt; 用来处理 &lt;strong&gt;多播&lt;/strong&gt;。这里有一个点，那就是 &lt;strong&gt;Line 116&lt;/strong&gt; 中的 &lt;code&gt;handlers&lt;/code&gt; 里面放置了所有注册的函数的信息，这个我们稍后会看到。&lt;/p&gt;
&lt;h4 id=&quot;toc_5&quot;&gt;接口的注册&lt;/h4&gt;
&lt;p&gt;前面说了，Celery 注册了很多管理接口给我们使用，我们就看看有那些注册接口以及这些接口是如何注册进去的，我们是否可以自定义管理接口。关于接口注册相关的代码，我们得走到 &lt;code&gt;celery/worker/control.py&lt;/code&gt; 中，现在进来看一看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223840577-1196766256.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这里有两个注册函数，其实也就是我们前面说过的对应的两类操作，分别是 &lt;strong&gt;查看&lt;/strong&gt; 和 &lt;strong&gt;设置&lt;/strong&gt; 类，然后也可以发现，其实注册就是往 Panel 这个 Dict 里头写入一些 key 和 value 对，然而，这里有两个 Dict 是需要我们关注的，他们分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;data&lt;/code&gt;：key 就是名称，value 是处理函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;meta&lt;/code&gt;：key 是名称，value 是元数据，整个数据描述为：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839874-123764861.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;ok，了解完这些我们就知道了&lt;strong&gt;远程命令的对象和处理函数的对应关系都放在 data 和 meta 里面&lt;/strong&gt;，这有什么用？回想一下之前 Mailbox 的构造函数的地方：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223839843-1225473291.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;注意看 &lt;strong&gt;Line 28&lt;/strong&gt;，用的就是这里的 data，然后就直接用来构造 Node 了，现在和前面的关系对应起来，了解了吧？&lt;/p&gt;
&lt;p&gt;下面我就找个复杂点的例子看看，是怎么讲一个函数注册进 data 这个 &lt;strong&gt;Dict&lt;/strong&gt; 里面的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223840140-539668243.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这个功能很明确了，在注释中已经提及了，但是，我们并不 care 它的功能，我们更多的是关注它是怎么发生的，在 &lt;strong&gt;Line 227&lt;/strong&gt; 这里就是调用注册函数进行注册，可以看到，args 分别对应到我们下面的几个命名参数，然后调用 &lt;code&gt;control_command&lt;/code&gt; 之后其实就是直接挂在 Dict 上了，没有其他操作，需要注意的是 &lt;strong&gt;Line 51&lt;/strong&gt; 的 &lt;code&gt;if args&lt;/code&gt; 这个条件，我在整个 Celery 中都没有看到有使用，所以应该这里是预留的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重要：&lt;/strong&gt;有一点值得注意的是，前面也有稍微提到，Celery 的分布式实现机制是&lt;strong&gt;广播&lt;/strong&gt;，所以我们在单机上发送的命令，只要没有指定主机，那么都是以广播的形式发送出去，所有的实例都将受到这个消息，然后根据消息处理本机的事务，所以我们在看代码的时候需要着重关注这一理念。&lt;/p&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;远程控制客户端&lt;/h3&gt;
&lt;p&gt;关于控制消息接收和处理的逻辑我们已经看完了，那么我们来看看我们在命令行中敲下命令的时候，这一切是怎么运行起来的。要看这些逻辑，我推荐的入口是：&lt;code&gt;celery/bin/control.py&lt;/code&gt;，这是一条典型的 Celery 命令类，这里的结构就比较复杂了，我不多说，直接看最后的结果，那就是调用的时候：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201711/469840-20171116223840202-250103633.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;可以发现这里很简单得就直接用一个 &lt;strong&gt;广播&lt;/strong&gt; 了事，还有比这更粗暴的么？&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 14:39:00 +0000</pubDate>
<dc:creator>行者酱油君</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/makor/p/remote-control-manager.html</dc:identifier>
</item>
<item>
<title>通过两个小栗子来说说Java的sleep、wait、notify、notifyAll的用法 - xingoo</title>
<link>http://www.cnblogs.com/xing901022/p/7846809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing901022/p/7846809.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;线程是计算程序运行的最小载体，由于单个单核CPU的硬件水平发展到了一定的瓶颈期，因此就出现了多核多CPU的情况，直接就导致程序员多线程编程的复杂。由此可见线程对于高性能开发的重要性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么线程在计算机中有好几种状态，他们之间是怎么切换的？sleep和wait又有什么区别？notify和notifyAll怎么用？带着这些问题，我们来看看Java的线程吧！&lt;/p&gt;

&lt;p&gt;先来看看Thread类里面都有哪几种状态，在Thread.class中可以找到这个枚举，它定义了线程的相关状态:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/449064/201711/449064-20171116221041921-1954520922.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;NEW 新建状态，线程创建且没有执行start方法时的状态&lt;/li&gt;
&lt;li&gt;RUNNABLE 可运行状态，线程已经启动，但是等待相应的资源（比如IO或者时间片切换）才能开始执行&lt;/li&gt;
&lt;li&gt;BLOCKED 阻塞状态，当遇到synchronized或者lock且没有取得相应的锁，就会进入这个状态&lt;/li&gt;
&lt;li&gt;WAITING 等待状态，当调用&lt;code&gt;Object.wait&lt;/code&gt;或者&lt;code&gt;Thread.join()&lt;/code&gt;且没有设置时间，在或者&lt;code&gt;LockSupport.park&lt;/code&gt;时，都会进入等待状态。&lt;/li&gt;
&lt;li&gt;TIMED_WAITING 计时等待，当调用&lt;code&gt;Thread.sleep()&lt;/code&gt;或者&lt;code&gt;Object.wait(xx)&lt;/code&gt;或者&lt;code&gt;Thread.join(xx)&lt;/code&gt;或者&lt;code&gt;LockSupport.parkNanos&lt;/code&gt;或者&lt;code&gt;LockSupport.partUntil&lt;/code&gt;时，进入该状态&lt;/li&gt;
&lt;li&gt;TERMINATED 终止状态，线程中断或者运行结束的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于wait方法是在Object上的，而sleep方法是在Thread上，当调用Thread.sleep时，并不能改变对象的状态，因此也不会释放锁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/449064/201711/449064-20171116220938421-728584518.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这让我想起来我家的两个主子，一只泰迪一只美短，虽然他们两个是不同的物种，但是却有着相同的爱好，就是爱吃牛肉。偶尔给它们两个开荤，奈何只有一个食盆，每次只能一个主子吃肉。这就好比是两个线程，在争用同一个变量。如果使用thread.sleep，那么他们吃完后，不会释放锁等资源；如果使用wait，就会释放。&lt;/p&gt;
&lt;p&gt;详细的看一下下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.xingoo.test.basic.thread;

public class AnimalEat {

    public static void main(String[] args) {
        System.out.println(&quot;盆里有20块肉&quot;);
        Animal animal = new Animal();
        try{
            Thread tidy = new Thread(animal,&quot;泰迪&quot;);
            Thread cat  = new Thread(animal,&quot;美短&quot;);
            tidy.start();
            cat.start();
        }catch (Exception e){
            e.printStackTrace();
        }
        System.out.println(&quot;盆里的肉吃完了！&quot;);
    }


}
class Animal implements Runnable {
    int count = 0;

    @Override
    public void run() {
        while(count &amp;lt; 20){
            synchronized (this){
                try {
                    System.out.println(Thread.currentThread().getName()+&quot;吃力第&quot;+count+&quot;块肉&quot;);
                    count++;
                    //Thread.sleep(100);
                    this.wait(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用this.wait(100)的时候，会输出下面的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;盆里有20块肉
泰迪吃力第0块肉
美短吃力第1块肉
盆里的肉吃完了！
泰迪吃力第2块肉
美短吃力第3块肉
泰迪吃力第4块肉
美短吃力第5块肉
泰迪吃力第6块肉
美短吃力第7块肉
泰迪吃力第8块肉
美短吃力第9块肉
泰迪吃力第10块肉
美短吃力第11块肉
美短吃力第12块肉
泰迪吃力第13块肉
美短吃力第14块肉
泰迪吃力第15块肉
美短吃力第16块肉
泰迪吃力第17块肉
美短吃力第18块肉
泰迪吃力第19块肉&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，输出的信息并不是完美的交替，这是因为调用wait之后，并不一定马上时另一个线程执行，而是要根据CPU的时间分片轮转等其他的条件来定，轮到谁就看运气了。&lt;/p&gt;
&lt;p&gt;当使用Thread.sleep(100)的时候，可以得到下面的信息:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;盆里有20块肉
泰迪吃力第0块肉
盆里的肉吃完了！
泰迪吃力第1块肉
泰迪吃力第2块肉
泰迪吃力第3块肉
泰迪吃力第4块肉
泰迪吃力第5块肉
泰迪吃力第6块肉
泰迪吃力第7块肉
泰迪吃力第8块肉
泰迪吃力第9块肉
泰迪吃力第10块肉
泰迪吃力第11块肉
泰迪吃力第12块肉
泰迪吃力第13块肉
泰迪吃力第14块肉
泰迪吃力第15块肉
泰迪吃力第16块肉
泰迪吃力第17块肉
泰迪吃力第18块肉
美短吃力第19块肉
泰迪吃力第20块肉&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意看最后面有一只美短。这是因为synchronized的代码同步时在while循环里面，因此最后一次两个主子都进入到了while里面，然后才开始等待相应的锁。这就导致第19次轮到了另一个主子。&lt;/p&gt;
&lt;p&gt;总结来说，sleep不会释放线程的锁,wait会释放线程的资源。&lt;/p&gt;

&lt;p&gt;wait、notify、notifyall这几个一般都一起使用。不过需要注意下面几个重要的点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用wait\notify\notifyall方法时，需要与锁或者synchronized搭配使用，不然会报错&lt;code&gt;java.lang.IllegalMonitorStateException&lt;/code&gt;，因为任何时刻，对象的控制权只能一个线程持有，因此调用wait等方法的时候，必须确保对其的控制权。&lt;/li&gt;
&lt;li&gt;如果对简单的对象调用wait等方法，如果对他们进行赋值也会报错，因为赋值相当于修改的原有的对象，因此如果有修改需求可以外面包装一层。&lt;/li&gt;
&lt;li&gt;notify可以唤醒一个在该对象上等待的线程，notifyAll可以唤醒所有等待的线程。&lt;/li&gt;
&lt;li&gt;wait(xxx) 可以挂起线程，并释放对象的资源，等计时结束后自动恢复；wait()则必须要其他线程调用notify或者notifyAll才能唤醒。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/449064/201711/449064-20171116220720359-2087847499.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个通俗点的例子，我记得在高中的时候，每天上午快放学的时候大家都很紧张——因为那个时候小饭馆正好播放一些港台剧，大家就总愿意抢电视机旁边的位置，所以每次快要中午放学的时候，大家都做好冲刺跑步的准备。&lt;/p&gt;
&lt;p&gt;但是有的老师总愿意压堂，搞的大家怨声载道。&lt;/p&gt;
&lt;p&gt;比如，下面这位老师有的时候会用notifyall通知大家集体放学；有的时候会检查背书，背好了，才能走。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package cn.xingoo.test.basic.thread;

public class School {
    private DingLing dingLing = new DingLing(false);

    class Teacher extends Thread{
        Teacher(String name){
            super(name);
        }
        @Override
        public void run() {
            //synchronized (dingLing){
                try {
                    dingLing.wait(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                dingLing.flag = true;

                System.out.println(&quot;放学啦&quot;);
                dingLing.notifyAll();

                /*for (int i = 0; i &amp;lt; 3; i++) {
                    System.out.println(&quot;放一个走吧&quot;);
                    dingLing.notify();
                    try {
                        dingLing.wait(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }*/
           // }
        }
    }
    class Student extends Thread{
        Student(String name){
            super(name);
        }
        @Override
        public void run(){
            synchronized (dingLing){
                while(!dingLing.flag){
                    System.out.println(Thread.currentThread().getName()+&quot;开始等待&quot;);
                    try {
                        dingLing.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(Thread.currentThread().getName()+&quot;去吃饭啦&quot;);
            }
        }
    }

    public static void main(String[] args) {
        School school = new School();
        Teacher teacher  = school.new Teacher(&quot;老师&quot;);
        Student zhangsan = school.new Student(&quot;张三&quot;);
        Student lisi     = school.new Student(&quot;李四&quot;);
        Student wangwu   = school.new Student(&quot;王五&quot;);
        teacher.start();
        zhangsan.start();
        lisi.start();
        wangwu.start();
    }
}

class DingLing{
    Boolean flag = false;
    public DingLing(Boolean flag){
        this.flag = flag;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当老师统一喊放学的时候，即调用&lt;code&gt;dingLing.notifyAll();&lt;/code&gt;，会得到下面的输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;张三开始等待
李四开始等待
王五开始等待
放学啦
王五去吃饭啦
李四去吃饭啦
张三去吃饭啦&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果检查背书，那么每次老师只会调用一次notify，让一个同学（线程）走（工作）,就会得到下面的输出:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;张三开始等待
李四开始等待
王五开始等待
放一个走吧
张三去吃饭啦
放一个走吧
李四去吃饭啦
放一个走吧
王五去吃饭啦&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意的是，调用wait可以释放dingling的占用，这样才能让别的线程进行检查，如果改成Thread.sleep，有兴趣的童鞋就可以自己去看看效果啦！&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;最简单的实例说明wait、notify、notifyAll的使用方法：&lt;a href=&quot;http://longdick.iteye.com/blog/453615&quot; class=&quot;uri&quot;&gt;http://longdick.iteye.com/blog/453615&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Java sleep和wait的区别：&lt;a href=&quot;http://www.jb51.net/article/113587.htm&quot; class=&quot;uri&quot;&gt;http://www.jb51.net/article/113587.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;sleep和wait解惑:&lt;a href=&quot;https://www.zhihu.com/question/23328075&quot; class=&quot;uri&quot;&gt;https://www.zhihu.com/question/23328075&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 16 Nov 2017 14:11:00 +0000</pubDate>
<dc:creator>xingoo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xing901022/p/7846809.html</dc:identifier>
</item>
<item>
<title>我的第一个python web开发框架（16）——产品分类管理 - AllEmpty</title>
<link>http://www.cnblogs.com/EmptyFS/p/7846746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyFS/p/7846746.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　产品分类管理的html页面之前忘记做了，这次附件里补上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好了先上图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201711/129385-20171116211852812-643814092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从页面效果图来看，我们需要开发列表获取接口、添加接口、单条记录获取接口、编辑接口和删除接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于产品分类列表，我们将使用jqgrid前端表格框架，jqgrid与接口交互时，它会提交页面索引、页面大小、排序字段名以及顺序还是倒序排序这几个参数，而返回的结果也有格式约束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　返回格式要求：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [],
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　产品分类列表获取接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product_class/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    获取列表数据
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面索引&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     page_number = convert_helper.to_int1(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;, False))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面显示记录数量&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     page_size = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;, False))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 排序字段&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     sidx = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sidx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;, False)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 顺序还是倒序排序&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     sord = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sord&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;, False)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化排序字段&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     order_by = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sort asc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; sidx:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         order_by = sidx + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; +&lt;span&gt; sord
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化输出格式（前端使用jqgrid列表，需要指定输出格式）&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     data =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: [],
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行sql，获取指定条件的记录总数量&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     sql = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select count(1) as records from product_class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果查询失败或不存在指定条件记录，则直接返回初始值&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; result &lt;span&gt;or&lt;/span&gt; result[0][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; data
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存总记录数量&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 0)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置分页索引与页面大小 ###&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置分页大小&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; page_size &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;or&lt;/span&gt; page_size &amp;lt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         page_size = 10
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算总页数&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] % page_size ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] //&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         page_total = data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;records&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] // page_size + 1
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总页面数量&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断提交的页码是否超出范围&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; page_number &amp;lt; 1 &lt;span&gt;or&lt;/span&gt; page_number &amp;gt;&lt;span&gt; page_total:
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         page_number =&lt;span&gt; page_total
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录当前页面索引值&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; page_number
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算当前页面要显示的记录起始位置&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;     record_number = (page_number - 1) *&lt;span&gt; page_size
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置查询分页条件&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     paging = &lt;span&gt;'&lt;/span&gt;&lt;span&gt; limit &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(page_size) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt; offset &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(record_number)
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;## 设置排序 ###&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; order_by:
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         order_by = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id desc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;############################################################&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 组合sql查询语句&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select * from product_class order by %(orderby)s %(paging)s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;           {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orderby&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: order_by, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;paging&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: paging}
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储记录&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;         data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; result
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; data:
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出json&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_raise(json.dumps(data, cls=&lt;span&gt;json_helper.CJsonEncoder))
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这段代码有点长，从功能上可以分为四段，第一段是接收客户端提交的参数；第二段获取当前查询条件下有多少条记录数量；第三段是处理分页，并组合查询sql语句；第四段是提交查询请求，并返回结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　get方式提交，我们使用web_helper.get_query()函数获取参数值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　具体代码有详细注释，这里就不细说了，大家如果有不明白的地方留言或到群里问我。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　界面中的删除按钮对应的是删除接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @delete(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product_class/&amp;lt;id:int&amp;gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(id):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    删除指定记录
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断该分类是否已经被引用，是的话不能直接删除&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     sql = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;select count(*) as total from product where product_class_id=%s&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt; %&lt;span&gt; (id,)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; result &lt;span&gt;and&lt;/span&gt; result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, -1) &amp;gt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该分类已被引用，请清除对该分类的绑定后再来删除&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 编辑记录&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     sql = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;delete from product_class where id=%s returning id&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     vars =&lt;span&gt; (id,)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入数据库&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     result =&lt;span&gt; db_helper.write(sql, vars)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否提交成功&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在做删除前，需要判断一下这个分类是否已经被相关的产品引用绑定了，如果是的话，直接删除将会造成前端相关产品无法展示，所以需要做出提醒，让用户清除绑定后再进行删除操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　增改删操作都是对数据库的写操作，所以都使用db_helper.write()函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在postgresql数据库中，returning是一个非常棒非常好用的函数，它可以指定返回的字段，即进行增改删操作后，将这些记录的指定字段值返回给我们，我们可以通过检查返回值是否存在来判定是否执行成功。而且在进行条件操作时，它能返回我们想要的主键id值，方便我们进行我们想要的操作，比如删除nosql缓存对应值。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　点击列表上面的添加按钮，会弹出一个小框，让用户输入新增记录值，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201711/129385-20171116214833077-1580065426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接口代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @post(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product_class/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    新增记录
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     name = web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'分类&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     is_enable = convert_helper.to_int0(web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_enable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;是否启用&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加记录（使用returning这个函数能返回指定的字段值，这里要求返回新添加记录的自增id值）&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     sql = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;insert into product_class (name, is_enable) values (%s, %s) returning id&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     vars =&lt;span&gt; (name, is_enable)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入数据库&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     result =&lt;span&gt; db_helper.write(sql, vars)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否提交成功&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result and result[0].get('id'):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　post方式提交，我们使用web_helper.get_form()函数获取参数值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　编辑记录和添加记录一样，使用同一个窗口，但在接口上，它需要获取记录值和编辑后保存两个接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/129385/201711/129385-20171116213351702-1534679545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product_class/&amp;lt;id:int&amp;gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(id):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    获取指定记录
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     sql = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;select * from product_class where id = %s&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt; %&lt;span&gt; (id,)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     result =&lt;span&gt; db_helper.read(sql)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出json&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, result[0])
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; @put(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/product_class/&amp;lt;id:int&amp;gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(id):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    修改记录
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     name = web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'分类&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     is_enable = convert_helper.to_int0(web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_enable&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;是否启用&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 编辑记录&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     sql = &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;update product_class set name=%s, is_enable=%s where id=%s returning id&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     vars =&lt;span&gt; (name, is_enable, id)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入数据库&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     result =&lt;span&gt; db_helper.write(sql, vars)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否提交成功&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; result &lt;span&gt;and&lt;/span&gt; result[0].get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　暂时还没有朋友说看不明白，所以就不往细说了，大家看代码注释，有人不明白提出后我再补上吧（最近太忙了，所以更新可能会有点慢，大家耐心等一等，我们尽量抽空码完代码后更新上来的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　联系我们的前端代码与接口代码都在下载包中，大家自己比较一下自己处理的结果和我的是不是一样。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://pan.baidu.com/s/1c1236SC&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;本文对应的源码下载&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者：AllEmpty&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;出处：http://www.cnblogs.com/EmptyFS/&lt;br/&gt;有兴趣的朋友可以加加python开发QQ群：669058475 ，大家一起探讨。大家有问题的话可以在群里发问，当然我平时工作也非常繁忙不一定会及时回复。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文为AllEmpty原创，欢迎转载，但未经同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 14:03:00 +0000</pubDate>
<dc:creator>AllEmpty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyFS/p/7846746.html</dc:identifier>
</item>
<item>
<title>Linux系列教程（二十）——Linux的shell概述以及如何执行脚本 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/7819316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/7819316.html</guid>
<description>&lt;p&gt;　　从这篇博客开始，我们将进入Linux的shell脚本的学习，这对于Linux学习爱好者而言是特别重要的一节，也是特别有意思的一节，shell 脚本就像我们知道的Java，php类似的编程语言一样，通过shell脚本，我们能完成很多有意思的应用程序。在学习中找到乐趣，这也是最重要的。&lt;/p&gt;
&lt;p&gt;　　本篇博客我们先给大家介绍一下什么是shell，以及bash的基本功能。&lt;/p&gt;
&lt;h3&gt;1、Shell 是什么？&lt;/h3&gt;
&lt;p&gt;　　和大家通常说的shell是一门编程语言的说法其实是不完全正确的。&lt;/p&gt;
&lt;p&gt;　　①、shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 shell 来启动、挂起、停止甚至是编写一些程序。&lt;/p&gt;
&lt;p&gt;　　　　比如，我们现在操作的界面就是shell，我们输入一些命令，通过shell 去翻译为机器语言，然后由硬件去执行这些命令。&lt;/p&gt;
&lt;p&gt;　　②、shell 是一个功能很强大的编程语言，它易编写、易调试，而且灵活性强。shell 是解释执行的脚本语言，在 shell 中可以直接调用 Linux 系统命令。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111151841388-2063112669.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其实windows类似于shell的就是它的图形交互界面，我们在windows系统中打开文件，删除文件等操作，就是向windows系统发送命令。&lt;/p&gt;

&lt;h3&gt;2、Shell 的分类&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152355966-1316017495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152406434-2142670219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152420028-1218779368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152458231-9424378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3、查看Linux系统支持的 shell：/etc/shells&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152607809-2130666013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以在shell解释器中直接输入shell名称进行切换&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111152752809-249220999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4、echo 输出命令&lt;/h3&gt;
&lt;p&gt;　　这个命令如果学过Java的类似于 System.out.println()，如果学过C语言的类似于 printf()，在shell 当中语法形式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
echo 【选项】【输出内容】
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　-e  表示支持反斜杠控制的字符转换，也就是转义字符。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111192744497-1540705727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　范例：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111192954934-2079362484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5、脚本执行方式&lt;/h3&gt;
&lt;p&gt;　　首先我们编写一个shell 脚本。通过 vi hello.sh，打开 hello.sh 文件，然后在文件中添加如下内容：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111193623763-538783684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　①、我们说Linux系统是不区分文件后缀名的，这里我们学习的是 bash,所以创建文件 hello.sh，后缀名最好加上.sh（虽然不加也没问题），便于我们识别。&lt;/p&gt;
&lt;p&gt;　　②、脚本的第一行 #!,这是一个约定的标记，它告诉系统这个脚本需要用什么解释器去执行，即使用哪一种 shell，所以学习 bash，第一行固定都是 #!/bin/bash。这是不能省略的。&lt;/p&gt;
&lt;p&gt;　　创建完毕之后，接下来执行该脚本，有如下两种方式：&lt;/p&gt;
&lt;h4&gt;　　①、作为可执行程序&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
cd /tmp                     #进入到脚本所在的目录
chmod +x ./hello.sh   #使得脚本具有可执行权限
./hello.sh                  #执行脚本
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，一定要写成 ./hello.sh，而不是 hello.sh，运行其它二进制的程序也一样，直接写 hello.sh，linux 系统会去 PATH 里寻找有没有叫 hello.sh 的（这是后面会讲的环境变量的配置），而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 hello.sh 是会找不到命令的，要用 ./hello.sh 告诉系统说，就在当前目录找。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1120165/201711/1120165-20171111194432044-121736781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　②、作为解释器参数&lt;/h4&gt;
&lt;p&gt;　　也就是直接运行解释器，其参数就是 shell 脚本的文件名，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/bin/sh hello.sh
或者
bash hello.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：这种方式执行脚本，并不需要第一行写上 #!/bin/bash。&lt;/p&gt;

</description>
<pubDate>Thu, 16 Nov 2017 13:28:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/7819316.html</dc:identifier>
</item>
<item>
<title>《天书夜读：从汇编语言到windows内核编程》十一 用C++编写内核程序（c++对象反汇编剖析） - SChivas</title>
<link>http://www.cnblogs.com/SChivas/p/7846458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SChivas/p/7846458.html</guid>
<description>&lt;p&gt;1） C++的“高级”特性，是它的优点也是它的缺点，微软对于使用C++写内核程序即不推崇也不排斥，使用C++写驱动需注意：&lt;/p&gt;
&lt;p&gt;　　a）New等操作符不能直接使用，如果要使用，必须进行重载。&lt;/p&gt;
&lt;p&gt;　　b）标准C接口的声明，在包含头文件以及入口例程的前面要声明extern “C”&lt;/p&gt;
&lt;p&gt;　　c）类的静态成员函数的使用：在类内部声明一个静态函数作为分发函数Dispatch，这个静态函数当做普通的C函数调用，而C++声明的非静态函数调用该函数进行分配。&lt;/p&gt;
&lt;p&gt;　　这一部分读下来，其实大多不是和内核相关，而是了解C++语言的汇编代码。&lt;/p&gt;

&lt;p&gt;2）下面是一个实例的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;ntifs.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;  TAG  'abcd'
&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;DRIVER_UNLOAD DriverUnload;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; DRIVER_INITIALIZE DriverEntry;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyDriver
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    MyDriver(PDRIVER_OBJECT driver);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可派生的Dispath虚函数（在DDK编译环境中可行）
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;VS2005编译器环境定义可派生虚函数报错，这里采用重载方式去实现
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原因未知&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; NTSTATUS OnDispatch(PDEVICE_OBJECT dev,PIRP irp)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_UNSUCCESSFUL;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态成员，总是记录被唯一实例化的MyDriver指针&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; MyDriver *&lt;span&gt;d_my_driver;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态成员函数，用来做为dispatch函数使用&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt; NTSTATUS sDispatch(PDEVICE_OBJECT dev,PIRP irp);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    PDRIVER_OBJECT d_driver;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现代码&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; MyDriver *MyDriver::d_my_driver =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;MyDriver::MyDriver(PDRIVER_OBJECT driver):d_driver(driver)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    size_t i;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; ( i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt;= IRP_MJ_MAXIMUM_FUNCTION ; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         driver-&amp;gt;MajorFunction[i] =&lt;span&gt; sDispatch;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     driver-&amp;gt;DriverUnload =&lt;span&gt; DriverUnload;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     d_my_driver = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态的分发函数的实现：调用虚函数，以便以后派生&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;NTSTATUS MyDriver::sDispatch(PDEVICE_OBJECT dev,PIRP irp)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; d_my_driver-&amp;gt;&lt;span&gt;OnDispatch(dev,irp);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     
&lt;span&gt;51&lt;/span&gt;     
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数size_t是必须外置的，编译器会自动用sizeof(clsName)求取长度并作为第一个参数&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* __cdecl &lt;span&gt;operator&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(size_t size,POOL_TYPE pool_type,ULONG pool_tag)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;{    
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     ASSERT((pool_type &amp;lt; MaxPoolType) &amp;amp;&amp;amp; (&lt;span&gt;0&lt;/span&gt; !=&lt;span&gt; size));
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(size == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;     
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中断级检查。分发级别和以上的级别只能分配非分页内存   &lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     ASSERT(pool_type ==  NonPagedPool ||(KeGetCurrentIrql() &amp;lt;&lt;span&gt; DISPATCH_LEVEL));
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; ExAllocatePoolWithTag(pool_type,static_cast&amp;lt;ULONG&amp;gt;&lt;span&gt;(size),pool_tag);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;} 
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     
&lt;span&gt;63&lt;/span&gt;     
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自己实现delete&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __cdecl &lt;span&gt;operator&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;*&lt;span&gt; pointer)  
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;{    
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     ASSERT(NULL !=&lt;span&gt; pointer);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL !=&lt;span&gt; pointer)
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        ExFreePool(pointer); 
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;     
&lt;span&gt;72&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动实现delete[]操作&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; __cdecl &lt;span&gt;operator&lt;/span&gt; &lt;span&gt;delete&lt;/span&gt;[](&lt;span&gt;void&lt;/span&gt;*&lt;span&gt; pointer)  
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;{   
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;     ASSERT(NULL !=&lt;span&gt; pointer);
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (NULL !=&lt;span&gt; pointer) 
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        ExFreePool(pointer);  
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;     
&lt;span&gt;80&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供一个Unload函数值是为了让这个程序能动态卸载，方便调试&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt; &lt;span&gt;VOID DriverUnload(PDRIVER_OBJECT driver)
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印一句&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt;     KdPrint((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CPP Driver is unloading...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;     
&lt;span&gt;87&lt;/span&gt; &lt;span&gt;extern&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; NTSTATUS DriverEntry(PDRIVER_OBJECT driver,PUNICODE_STRING reg)
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;     MyDriver::d_my_driver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;(NonPagedPool, TAG) MyDriver(driver); 
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;     KdPrint((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CPP Driver Test!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt;     driver-&amp;gt;DriverUnload =&lt;span&gt; DriverUnload;
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; MyDriver::d_my_driver;
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_SUCCESS;
&lt;/span&gt;&lt;span&gt;94&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116202513265-2060930752.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3）选择WDK的“X86 check build enviroment”编译上述代码（如果没有虚函数，可用VS2005将项目属性中C/C++选项卡下的优化项选择为禁止，然后编译）。下面是DriverEnter函数的反汇编代码（用IDA反汇编，感觉比WIND32ASM好用，带可视化的图形模块），注意一些调用约定：其中的new与delete都在定义时指定为cdecl，而类一般为thiscall，其它默认函数为stdcall，在下一章中，还将使用fastcall调用约定：&lt;/p&gt;
&lt;p&gt;　　a）Stdcall：通常用于win32API中在Microsoft C++系列的C/C++编译器中，常常用PASCAL宏来声明这个调用约定，类似的宏还有WINAPI和CALLBACK。stdcall的调用约定意味着：参数从右向左压入堆栈；函数自身修改堆栈；函数名自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸（如常见的“_function@8”等格式）&lt;/p&gt;
&lt;p&gt;　　b）Cdecl：有的地方写成cdcall，即C语言调用约定，是C语言缺省的调用方式。Cdecl调用约定也是参数从右向左压入堆栈，但是函数本身不清理堆栈，由调用者来清理，由于这种特性，C语言调用约定允许函数参数个数是不定的。&lt;/p&gt;
&lt;p&gt;　　c）Thiscall：thiscall是唯一一个不能明确指明的函数修饰，因为thiscall不是关键字。它是C++类成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理，thiscall意味着：参数从右向左入栈；如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈；对参数个数不定的，调用者清理堆栈，否则函数自己清理堆栈。&lt;/p&gt;
&lt;p&gt;　　d） Fastcall：fastcall调用约定与stdcall调用几乎完全相同，唯一的区别是，前两个参数不被放入堆栈中传入，而是放入ecx与edx中，ecx保存第一个参数，而edx保存第二个参数，其它参数采用堆栈传递。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116203021124-998196681.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;DriverEntry反汇编&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　第一：类的构造函数的调用代码是C++编译器自动生成的，构造函数对程序员来说不能自行调用，也不能定义返回值，但从汇编代码来看，这里是&lt;span&gt;返回了对象实例自身的指针&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　第二：var_4、var_C、P从分析上来看存放的都是同一个值，就是类实例的一个指针值。&lt;/p&gt;
&lt;p&gt;　　第三：driver-&amp;gt;DriverUnload = DriverUnload被书写了2次（入口函数中一次，构造函数中也写了一次），这个是我的失误，不过不影响代码的执行。在读汇编类似的代码时，可以查看DRIVER_OBJECT结构体具体内容来判断偏移34H到底是哪个域。&lt;/p&gt;
&lt;p&gt;　　第四：[ebp + p]这个局部变量完全没有定义的必要，debug版本反汇编虽然和最初的编写逻辑很对应，但是会发现很多的无用代码，而release版本经编译器优化以后模样大变，实际上看debug版本能了解语言特性，而看release版本才是比较实用的，因为没人会发布debug版本。&lt;/p&gt;

&lt;p&gt;4）构造函数反汇编：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116203551796-1781292151.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;C++构造函数反汇编&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　第一：&lt;span&gt;对象内存空间一开始存放的并不是数据成员，而是虚函数表（假如定义有虚函数）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第二：&lt;span&gt;对象内存空间在虚函数表之后存放的是数据成员，不包含静态的数据成员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第三：&lt;span&gt;对象的静态数据成员并不在对象实例内存空间，而采用的全局变量来使用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;5）虚函数派生反汇编，新增派生类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MySubDriver:&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyDriver
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    MySubDriver(PDRIVER_OBJECT driver):MyDriver(driver){};
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; NTSTATUS OnDispatch(PDEVICE_OBJECT dev,PIRP irp)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         KdPrint((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is the dispatch function of MySubDriver!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; STATUS_UNSUCCESSFUL;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　改写DriverEntry下面一句：&lt;/p&gt;
&lt;p&gt;　　MyDriver::d_my_driver = new(NonPagedPool, TAG) MySubDriver(driver);&lt;/p&gt;
&lt;p&gt;　　派生类构造函数：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116204456281-1569769078.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;C++子类构造函数反汇编&lt;/p&gt;

&lt;p&gt;　　第一：从此可解释，C++派生类的构造函数是从最原始的基类向子类来执行的&lt;/p&gt;
&lt;p&gt;　　第二：&lt;span&gt;填写虚函数地址表时，实际上执行的是覆盖。&lt;/span&gt;这里在基类中已经写入了基类的虚函数地址，然后当基类构造函数执行完毕以后，派生类会再次写入虚函数地址（如果派生类重写了虚函数，则该地址会覆盖基类的填写的虚函数地址，否则保留基类的虚函数）。&lt;/p&gt;
&lt;p&gt;　　第三：这是一个无用代码的说明，在标准现场保护完毕之后，调用基类的构造函数之前，应该只需要将传入参数driver压入栈，可是之前却还压入了ecx（也就是类实例this指针），从基类构造函数以及派生类构造函数后面的代码中可分析，这个压入的值并没有被使用，也没有再弹出。&lt;/p&gt;
&lt;p&gt;　　虚函数调用代码：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116204800843-276424862.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;C++虚函数调用反汇编&lt;/p&gt;

&lt;p&gt;　　关于虚函数的调用机制，还得看下所谓的虚函数地址表到底是怎么一回事：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1278213/201711/1278213-20171116210007218-990611927.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;C++虚函数地址表&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;　　可见，&lt;span&gt;虚函数地址表实际上是一些常量指针值，这些常量指针值保存了各个虚函数的定义代码的地址值，构造函数在填写虚函数的时候，并没有直接写人虚函数的函数地址，而是写入的常量指针值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　那么，调用虚函数的汇编代码就解释得清楚了，首先从类实例中取得虚函数常量指针值到eax，再通过mov edx,[eax]将虚函数真正所在的地址放入edx，再call edx实行调用。&lt;/p&gt;
&lt;p&gt;　　第一：基类和派生类虚函数地址表各有一份，并不会覆盖，但是在&lt;span&gt;实例化一个类以后，这个实例的内存空间中，维持着一个虚函数地址表，这个表里面对应的是实际使用的虚函数地址&lt;/span&gt;（最初是原始基类的虚函数地址表，但随着之后各个类的派生，会随着虚函数的重定义而重新改写表中的数值）。&lt;/p&gt;
&lt;p&gt;　　第二：不同的编译器对虚函数地址的改写方式可能会有不同。&lt;/p&gt;
&lt;p&gt;　　第三：&lt;span&gt;对虚函数地址表的存在，为修改虚函数地址表来实现HOOK提供了可能&lt;/span&gt;。&lt;/p&gt;

</description>
<pubDate>Thu, 16 Nov 2017 13:05:00 +0000</pubDate>
<dc:creator>SChivas</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SChivas/p/7846458.html</dc:identifier>
</item>
<item>
<title>salesforce零基础学习（八十三）analytics:reportChart实现Dashboard(仪表盘)功能效果 - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/7845944.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/7845944.html</guid>
<description>&lt;p&gt;项目中经常会用到Report以及Dashboard来分析汇总数据，Dashboard可以指定view as user，如果针对不同的用户需要显示其允许查看的数据，比如  根据role hierarchy来显示数据，需要指定run as login user.但是dashboards runas the logged-in user是有数量的限制的，针对此种情况，就需要使用自定义实现Dashboard功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201711/910966-20171116191748015-263126549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用自定义操作可以通过apex class获取数据，在visualforce page上画不同组的chart，点击chart以后跳转到相关详情的report页面，但是这种情况无法处理funnel chart的情况，因为visualforce的api没有提供funnel chart样式的元素。&lt;/p&gt;
&lt;p&gt;这种情况下，比较偷懒的操作为在Report上使用Role Hierarchy进行限制来对数据进行获取，然后在Report中配置chart，使用aynalytics:reportChart传递需要显示的report ids进行展示，从而实现dashboard的效果。&lt;/p&gt;
&lt;p&gt; 功能：实现自定义Dashboard，Dashboard显示两个chart，分别为通过Type对Account进行分组以及通过State/Province对Account分组，每个用户只能看到当前用户以及下级的内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备工作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.创建Report，此Report通过Type进行分组，developername为Account_Report_By_Type&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201711/910966-20171116200641843-1319418130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.创建Report，此Report通过State/Province进行分组，developername为Account_By_Billing_State_Province&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201711/910966-20171116201015874-921088245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.创建Dashboard,包含上面的两个Report，datasource也分别对应上面两个report。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201711/910966-20171116201102140-1124605470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备工作结束，现在需要通过程序来实现上面的Dashboard。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.AnalyticsReportChartController:用来获取上述两个report id，并放在reportIds&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; with sharing &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AnalyticsReportChartController {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;Id&amp;gt;&lt;span&gt; reportIds{get;set;}
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AnalyticsReportChartController() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         reportIds = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Id&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        reportIds.add(accountByTypeReportId);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        reportIds.add(accountByStateProvinceReportId);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Id accountByTypeReportId{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        get {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(accountByTypeReportId == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 Report rt = [select id from Report where DeveloperName = 'Account_Report_By_Type' limit 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 accountByTypeReportId =&lt;span&gt; rt.Id;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; accountByTypeReportId;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }set;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Id accountByStateProvinceReportId {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        get {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(accountByStateProvinceReportId == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 Report rt = [select id from Report where DeveloperName = 'Account_By_Billing_State_Province' limit 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 accountByStateProvinceReportId =&lt;span&gt; rt.Id;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; accountByStateProvinceReportId;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }set;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.AnalyticsReportChart.page：实现展示两个report的chart，点击后跳转到相关的report中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:page &lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;=&quot;AnalyticsReportChartController&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:panelGrid &lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:outputPanel &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;reportPanel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;apex:repeat &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{!reportIds}&quot;&lt;/span&gt;&lt;span&gt; var&lt;/span&gt;&lt;span&gt;=&quot;report&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;display: inline-block;width: 400px;height: 400px;vertical-align: top;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;analytics:reportChart &lt;/span&gt;&lt;span&gt;reportId&lt;/span&gt;&lt;span&gt;=&quot;{!report}&quot;&lt;/span&gt;&lt;span&gt; showRefreshButton&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt; size&lt;/span&gt;&lt;span&gt;=&quot;small&quot;&lt;/span&gt;&lt;span&gt; cacheResults&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;analytics:reportChart&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:repeat&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:outputPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:panelGrid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;apex:page&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;效果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/910966/201711/910966-20171116202037952-1580319916.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;使用analytics:reportChart可以很方便的实现DashBoard的展示效果，但是此种方式仅限于Dashboard中的一个Chart对应一个Report，而不是一个Chart对应多个Report，如果出现一个Chart对应多个Report，需要创建成一对一的关系才能实现。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 12:27:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/7845944.html</dc:identifier>
</item>
<item>
<title>一次触摸，Android到底干了啥 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/7846047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/7846047.html</guid>
<description>&lt;div readability=&quot;51&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们在写带有UI的程序的时候，如果想获取输入事件，仅仅是写一个回调函数，比如(onKeyEvent,onTouchEvent….)，输入事件有可能来自按键的，来自触摸的，也有来自键盘的，其实软键盘也是一种独立的输入事件。那么为什么我能通过回调函数获取这些输入事件呢？系统是如何精确的让程序获得输入事件并去响应的呢？为什么系统只能同一时间有一个界面去获得触摸事件呢？ 下面我们通过Android系统输入子系统的分析来回答这些问题。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、输入事件的转发流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201711/992994-20171116194041171-1627224336.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、物理设备是如何将输入数据发送给内核的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;物理设备将数据发送给内核是通过设备驱动传输的，在linux下的/dev/input/目录下有几个设备文件,event0,event1,event2……… 这些设备文件实际上是驱动创建的,他们共用一个主设备号，仅仅是次设备号不同,表示这是一类设备。比如触摸屏对应event0,触摸屏驱动被挂载后，驱动程序会进行初始化，主要是初始化CPU引脚，设置中断处理程序。&lt;/p&gt;
&lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201711/992994-20171116194058531-1493348496.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;&lt;div readability=&quot;290.1076011846&quot;&gt;
&lt;p&gt;当按下触摸屏的时候触摸屏有个引脚电平变低了，相连的CPU引脚检查到这个连接的引脚电压变低了，那么就会触发中断，这个在触摸驱动中初始化好的，CPU有个中断向量表，这里就到了我们驱动中写好的中断处理函数，中断处理函数中就会读取触摸屏的数据，就是通过相连接的引脚组成的二进制数据比如(01011010),这个时候我们的内核就拿到的触摸屏的数据。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201711/992994-20171116194122562-1795328359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;触摸屏芯片的时序图&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、内核是如何把输入数据发送给用户空间Android framework的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;内核拿到触摸屏的数据后，经过平滑处理，滤波，数据还是在内核空间，那么Android怎么拿到触摸数据呢？ Android实际上是运行在linux内核上一组进程，这一组进程组合为用户提供UI,应用程序的安装等等服务。&lt;/p&gt;
&lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201711/992994-20171116194139187-2007488865.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;手机开机流程是linux内核先启动，启动完成之后会将Android进程组启动起来，FrameWork属于这个进程组之中。Framewok中有个服务InputManagerService，&lt;strong&gt;我们看Android源码它在哪里实例化的：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     SystemServer.java-----------&amp;gt;&lt;/p&gt;
&lt;p&gt;              startOtherServices()------&amp;gt;&lt;/p&gt;
&lt;p&gt;              /*构造InputManagerService*/&lt;/p&gt;
&lt;p&gt;              inputManager = new InputManagerService(context);&lt;/p&gt;
&lt;p&gt;                 /*将inputManager传递给WindowManagerService去&lt;/p&gt;
&lt;p&gt;                 wm=WindowManagerService.main(context, inputManager,&lt;/p&gt;
&lt;p&gt;                mFactoryTestMode !=FactoryTest.FACTORY_TEST_LOW_LEVE !mFirstBoot, mOnlyCore);&lt;/p&gt;
&lt;p&gt;                 /*给InputManagerService设置回调*/&lt;/p&gt;
&lt;p&gt;                 inputManager.setWindowManagerCallbacks(wm.getInputMonitor());&lt;/p&gt;
&lt;p&gt;                  /* 全初始化好后，SystemServer调用start()函数让InputManager中两个线程开始运行。先看InputReaderThread，它是事件在用户态处理过程的起点*/&lt;/p&gt;
&lt;p&gt;                 inputManager.start();&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;所以可以看到它在SystemServer进程中实例化并且启动，所以我们首先需要看看InputManagerService的构造函数都做了什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构造函数会调用到jni创建NativeInputManager的c++对象, NativeInputManager构造函数中创建&lt;/p&gt;
&lt;p&gt;Sp&amp;lt;EventHub&amp;gt; eventHub = new EventHub()&lt;/p&gt;
&lt;p&gt;mInputManager = new InputManager(eventhub,this,this);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;eventHub对象构造函数做了下面几件事情：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 1. 创建epoll对象,之后就可以把各个输入设备的fd添加进来多路等待输入事件&lt;/p&gt;
&lt;p&gt;2. 利用inotify机制监听/dev/input目录下的变更,如果有则意味着设备变换,需要处理,输入设备的增减删除操作的监听，将代表inotify的fd添加到epoll中&lt;/p&gt;
&lt;p&gt;3. 创建pipe,管道只能用来在具有公共祖先的两个之间通信.读端添加epoll中&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;InputManager对象构造函数做了下面几件事：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 创建InputDispatcher&lt;/p&gt;
&lt;p&gt;2. 创建InputReader(eventhub,inputdispatcher)，InputDispatcher继承InputListenerInterface&lt;/p&gt;
&lt;p&gt;3. 创建InputReaderThread&lt;/p&gt;
&lt;p&gt;4. 创建InputDispatcherThread&lt;/p&gt;

&lt;p&gt;我们还记得最SystemServer.java中最后通过inputManager.start(); 来运行我们的InputManagerService,所以继续看start方法，实际上在native层的inputManager对象中,将上面创建的两个线程InputReaderThread和InputDispatcherThread的start方法中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于InputReaderThread的start方法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 调用构造函数中保存的eventHub的getEvents方法获取input事件，在getEvent方法中做的事&lt;/p&gt;

&lt;p&gt;1）判断是不是需要打开input设备驱动，如果需要打开设备驱动,扫描/dev/input目录下的设备文件并打开这些设备，同时会判断设备列表中有没有虚拟键盘,没有的话就创建一个device添加进去&lt;/p&gt;

&lt;p&gt;2）到下一步中至少系统存在两个输入设备,一个是触摸屏,一个是虚拟键盘,因为上面这次getEvent的调用需要打开设备，所有就将这些动作封装成RawEvent事件，这里两个DEVICE_ADDED事件+FINISH_DEVICE_SCAN事件,将这些事件返回，不会往下走了&lt;/p&gt;

&lt;p&gt;3）如果第二次进入getEvents方法中就会等待读取输入事件，将读取的touch事件发送返回&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201711/992994-20171116194153874-927813090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到这里我们就知道了内核空间的触摸输入数据是如何传递到了用户空间的Android framework中的,实际上就是通过/dev/input目录下，去扫描这个目录，如果有device就打开这个device ,并添加到epoll对象中,多路等待输入事件，在loop中获取数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、Android framework是怎样将输入数据发送给APP进程的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Android framework获取了触摸输入的数据，但是在系统中有那么多进程，那么多进程都在获取输入，它是如何进一步处理，准确的分发事件的呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;InputReaderThread的start方法中做的第二件事情:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用processEventsLocked方法处理上面的getEvents方法返回的的RawEvent&lt;/p&gt;
&lt;p&gt;1）根据RawEvent的类型不同，调用不同的方法处理,有  ● 普通的touch事件&lt;/p&gt;
&lt;p&gt;.● 添加设备的事件&lt;/p&gt;
&lt;p&gt;.● 删除设备的事件&lt;/p&gt;
&lt;p&gt;.● FiNISHED_DEVICE_SCAN&lt;/p&gt;

&lt;p&gt;2）对于touch事件: 调用这个touch事件对应的输入设备(之间创建的InputDevice)的process方法，该方法内部调用内部的InputMapper的process方法,一个输入设备有很多个Mapper,遍历所有的Mapper,并调用process,假定我们是一个支持多点触摸的touch screen，它的mapper是MultiTouchInputMapper,调用它的process方法。&lt;/p&gt;

&lt;p&gt;3）MultiTouchInputMapper的process方法内部会这样处理：&lt;/p&gt;
&lt;p&gt;首先每次一个touchEvent获取Slot,在没有收到EV_SYN之前对应的Slot都是相同的,然后依次处理x,y,pressure,touch_major，这些值初始化slot的各个变量；&lt;/p&gt;

&lt;p&gt;当收到ev.type== EV_SYN并且ev.code = SYN_MT_REPORT那么当前的slot的index加1，给下一次触摸事件去记录，同时sync函数处理这次触摸事件；&lt;/p&gt;

&lt;p&gt;然后CurrentCookedPointerData和LastCookedPointerData进行一些列的操作，up,down还是move事件，然后对应的不同事件，调用dispatchMotion,内部调用InputDispatcher的notifyMotion&lt;/p&gt;

&lt;p&gt;4）对于InputDispatcher的notifyMotion：&lt;/p&gt;
&lt;p&gt; ● 如果InputDispatcher设置了inputFilter,那么首先调用inputFilter来消费这些事件&lt;/p&gt;
&lt;p&gt; ● 如果没有inputFiler,或者inputFilter对这些事件不感兴趣,那么就会构造一个MotionEntry,添加到mInboundQueue,并唤醒InputDispatcher线程处理&lt;/p&gt;

&lt;p&gt;5）对于InputDispatcher的线程处理循环：&lt;/p&gt;
&lt;p&gt; ● 优化app切换延迟,当切换超时，则抢占分发，丢弃其他所有即将要处理的事件；&lt;/p&gt;
&lt;p&gt; ● 分发事件：&lt;/p&gt;
&lt;p&gt; 首先调用findTouchedWindowTagetsLocked寻找有focus的window窗口， 并把这些创建保存在inputTargets数组中；&lt;/p&gt;

&lt;p&gt;之前注册的monitor的InputChannel这里也会添加到inputTargets数组中；&lt;/p&gt;

&lt;p&gt;然后向inputTargets数组一一分发事件。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201711/992994-20171116194214874-1879960505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到这里我们就知道了是如何找到这个APP进程的了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、APP进程是如何将输入数据发送给它对应的Activity的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Activity是一个进程的基本组件，可以认为它代表了一个界面，是一堆View的集合，每次Activity启动的时候都做了什么呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、实际上取决于它背后的ViewRootImpl做了什么，在ViewRootImpl.java中的setView方法中,实例化InputChannel,当然会判断当前的窗口能不能接受输入事件,接着在调用到session.java中的addToDisplay方法传递给WindowManagerService,实际上是调用WindowManagerService的addWindow方法,在WindowManagerService中会创建一对InputChannel[],然后InputChannel[1]转移到这个inputChannel， 然后setView方法继续创建一个WindowInputEventReceiver对象,然后将上面创建好的InputChannel&lt;/p&gt;

&lt;p&gt;2、WindowManagerService中的addWindow方法:&lt;/p&gt;
&lt;p&gt;    InputChannel[] inputChannels = InputChannel.openInputChannelPair(name)&lt;/p&gt;
&lt;p&gt;    /*Channel[0]保存在server端*/&lt;/p&gt;
&lt;p&gt;    win.setInputChannel[inputChannels[0]]&lt;/p&gt;
&lt;p&gt;    /* Channel[1]返回给ViewRootImpl端*/&lt;/p&gt;
&lt;p&gt;    inputChannels[1].transferTo(outInputChannel)&lt;/p&gt;
&lt;p&gt;    /*注册到inputManagerService中*/&lt;/p&gt;
&lt;p&gt;   mInputManager.registerInputChannel(win.mInputChannel,win.mInputWindowHandle)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/992994/201711/992994-20171116194237406-619610567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到这里我们就能明白如何将时间分发给对应的Activity了，其实是给了它背后的ViewRootImpl。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、Activity又是如何将输入数据发送给具体的View的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后一步就是将事件分发到Activity中具体的View了,从ViewRootImpl中将事件分发给具体的View,很好理解，因为触摸的范围在到这里是知道的，每个View的位置以及状态到这里也是知道的，因为View要正确渲染的话，Android图形框架会搞定这一切，测量每个View的大小，确定每个View的位置，ViewRootImpl会一层一层将数据分发到自己每个View中，但是每个View自己知道这个触摸事件是不是作用在自己身上的，如果不是就丢弃了，往下面分发。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;触摸事件的分发流程看起来挺复杂，但是Android实现的还是很优雅的，我们去分析它的流程，对于我们想实现一些比较的酷的功能是有帮助的。当然对于我们调试代码也会有帮助，当发现触摸后，系统无响应，将上面的流程分解，总是能分析出原因。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;腾讯WeTest提供上千台真实手机&lt;/strong&gt;，随时随地进行测试，保障应用/手游品质。节省百万硬件费用，加速敏捷研发流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同时腾讯WeTest兼容性测试团队积累了10年的手游测试经验&lt;/strong&gt;，旨在通过制定针对性的测试方案，精准选取目标机型，执行专业、完整的测试用例，来提前发现游戏版本的兼容性问题，针对性地做出修正和优化，来保障手游产品的质量。目前该团队已经支持所有腾讯在研和运营的手游项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎进入：&lt;/strong&gt;&lt;strong&gt;&lt;a href=&quot;http://wetest.qq.com/product/cloudphone?from=content_cnblogs&quot; target=&quot;_blank&quot;&gt;http://wetest.qq.com/product/cloudphone &lt;/a&gt;体验安卓真机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎进入：&lt;a href=&quot;http://wetest.qq.com/product/expert-compatibility-testing?from=content_cnblogs&quot; target=&quot;_blank&quot;&gt;http://wetest.qq.com/product/expert-compatibility-testing &lt;/a&gt;使&lt;/strong&gt;&lt;strong&gt;用专家兼容测试服务。&lt;/strong&gt;WeTest兼容性测试团队期待与您交流！You Create，We Test！&lt;/p&gt;

&lt;p&gt;如果对使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：800024531&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Thu, 16 Nov 2017 11:44:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/7846047.html</dc:identifier>
</item>
<item>
<title>通过hibernate封装数据库持久化过程回顾泛型/继承/实现等概念 - 窗外天空晴朗</title>
<link>http://www.cnblogs.com/young-z/p/7842905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/young-z/p/7842905.html</guid>
<description>&lt;h2&gt;　　前言&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在开发过程中，我们不难发现，客户的需求以及产品的定位对开发内容的走向有很大的决策作用，而这些往往需要在一开始就尽可能考虑周全和设计完善。为什么说是尽可能，因为我们都知道，需求这种东西，一言难尽...作为开发者，既然无法掌控需求的变更等因素，那我们就要把握好自身能决定的工具资源等，架构设计、技术选型等等。有的人可能会说，我才多久经验之类，架构什么的不都是leader们大佬们的事情么，选什么数据库用什么技术又不是我能决定的。如果你有这种想法，我只能觉得你说得很对。不知道大家在开发过程中，有没有遇到，某个场景或者效果用现有的工具技术你觉得无法实现或者很难实现，又或者你知道又可以实现的技术框架却不会用？echarts、POI等，对于我来说，都符合上述场景。总的来说，有的东西在开发过程中可以当作学习，有些东西却需要你额外花时间在工作之外去研究。当然，如果你说你工作中不管需要什么新技术，你一天之类就可以掌握，那也是能力。而且这不是嘲讽什么的，是实实在在的，我现在愈发觉得学习能力的重要性，他对一个人的潜在能力增长曲线的影响太大，当然你有能力却不学习，那也注定是一条直线射穿。Spring、Strus 2、Hibernate、Mybatis、Spring MVC是比较常见的Web项目会用到的框架，持久层目前来看主要有Hibernate、Mybatis、Spring data jpa等，目前我在用Spring data jpa，这个东西真的厉害，用起来比我以前的想法又上了一个台阶，而且跟hibernate支持的也很好，Hibernate本身也是jpa规范的实现。接下来文中项目中类与方法设计的思路是之前基于Hibernate的，正好回顾一下，认识下其中的不足，好结合现在用的Jpa改进。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　　项目结构一览&lt;/h2&gt;
&lt;p&gt;以web项目技术框架选型为Spring+Hibernate+Spring MVC为例，忽略配置以及web前端文件，后台结果最精简情况大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1179031/201711/1179031-20171116100104140-456390324.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从数据库方向依次向前介绍:&lt;/p&gt;
&lt;p&gt;1.domain层，这个东西的标准解释是领域模型，我们orm对象关系映射的实体类一般就放在该层下，即实体层，类似的叫法，entity、model、pojo等作用大抵如此；&lt;/p&gt;
&lt;p&gt;2.repository层，数据库访问层，这个就是dao层，存放数据库访问操作的方法；&lt;/p&gt;
&lt;p&gt;3.service层，业务逻辑层，用于存放业务逻辑方法的地方，与dao层相比，有的人可能开始会觉得这个service层没有什么必要，或者不太清楚两者的区别。首先关于两者区别：业务逻辑层，故名思意，他的重要定位是业务，业务需求什么，他就要提供什么，举个例子，dao层提供了你删除商品的方法和添加日志的方法，这两个方法分别对应有两个实体对象商品和日志，操作的也是数据库相应的单个表，但是实际情况是你通过单个方法总感觉哪里不对劲，业务场景下，如果需要你删除东西后会有相应的日志记录，而日志又不会凭空捏造，需要有事件对应。这时候，service层的作用就体现出来了，简单的可以这么理解，复杂的数据库处理你靠单个dao方法无法实现的时候，你在service层去构造这个方法就行，通过SpringIOC特性，在service层注入你需要的调用的dao方法所在的类或者接口，实际场景一般都是接口。其次关于必要性，我曾经也想过，直接在controller里面注入多个dao类或者接口不是也能达到想要的效果吗？Controller顾名思义，控制器，它在web结果中，主要起到一个接受和转发请求并控制的作用，当你的业务逻辑相对简单的时候，你觉得看不出多大区别，当实际项目业务逻辑相对复杂很多的情况下，这个controller就有点炸了，像个身兼多职操劳过度的苦工，另外结合上一个疑惑，还有一个很重要的概念就是事务，而Spring的事务管理做得也很到位，通过编程式事务管理或者声明式事务管理都可以实现，而事务一般就设置在业务逻辑也就是service层上，关于事务也是很重要和精髓的一块，需要学习也值得学习。&lt;/p&gt;
&lt;p&gt;4.controller层，控制层，用struts 2也许会叫action层吧，或者通用点，叫web层其实也可以。他可以&lt;span class=&quot;con&quot;&gt;接收不同的请求url，调用相应的service层代码，操作数据库，跳转到制定页面，也可以不跳转，直接返回数据，这里的数据目前用json的比较多，典型的应用场景：ajax发起异步请求，DispatcherServlet捕获请求后对url进行解析，分发到相应的控制类中的相应方法中执行其中代码，该方法上加上@ResponseBody即可。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;con&quot;&gt;　　关于Hibernate在项目中的定位&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;con&quot;&gt;Hibernate是一个典型的ORM持久层框架，ORM即Object Relational Mapping（对象关系映射），即实体类与数据库表之间的关系映射，通俗的讲，一张表对应一个实体类，一条记录对应一个实体类对象，字段对应实体类属性。对数据库的操作在Hibernate中有一个重要对象session，通过session封装一系列数据库操作方法在数据库访问层，所以在上面的结构中，Hibernate主要操作和作用的有domain层和repository层,下面示例也省略其他层代码。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span class=&quot;con&quot;&gt;　　示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;con&quot;&gt;domain层，这里简单使用，Mysql数据库主键也用的int自增型，实际应用数据量较大等情况下会用varchar，保存使用UUID赋值主键。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Entity
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @Table(name=&quot;TBL_USER&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String password;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Id
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     @GeneratedValue(strategy=&lt;span&gt;GenerationType.AUTO)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setId(Integer id) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPassword() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; password;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPassword(String password) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.password =&lt;span&gt; password;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;User [id=&quot; + id + &quot;, username=&quot; + username + &quot;, password=&quot; + password + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     
&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt;     
&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;repository层&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;con&quot;&gt;BaseDao泛型接口&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; BaseDao&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; edit(Object obj);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加或者更新一条记录 &lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete(&lt;span&gt;int&lt;/span&gt; id);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据主键删除一条记录&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; T load(&lt;span&gt;int&lt;/span&gt; id);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据主键查找一条记录(懒加载)&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; T get(&lt;span&gt;int&lt;/span&gt; id);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据主键查找一条记录(非懒加载)&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;con&quot;&gt;BaseDao泛型实现类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseDaoImpl&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt; BaseDao&amp;lt;T&amp;gt;&lt;span&gt; {
    @Resource
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SessionFactory factory;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Class&amp;lt;T&amp;gt; clazz = GeneriscUtil.getGenericType(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass());
    
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Session getSession() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; factory.getCurrentSession();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; edit(Object obj) {
        getSession().saveOrUpdate(obj);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        Object object &lt;/span&gt;=&lt;span&gt; getSession().get(clazz, id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(object != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            getSession().delete(object);
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T load(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T) getSession().load(clazz, id);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T) getSession().get(clazz, id);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;泛型工具类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeneriscUtil {
    @SuppressWarnings(&lt;/span&gt;&quot;rawtypes&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Class getGenericType(Class clazz){
        Type genType &lt;/span&gt;= clazz.getGenericSuperclass();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取泛型父类  &lt;/span&gt;
        Type[] types =&lt;span&gt; ((ParameterizedType) genType).getActualTypeArguments();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(types[0] &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Class)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;   
        } 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Class) types[0&lt;span&gt;];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最后:UserDao接口和UserDaoImpl实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; UserDao &lt;span&gt;extends&lt;/span&gt; BaseDao&amp;lt;User&amp;gt;&lt;span&gt; {
    User login(String username, String password);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
@Repository(&quot;UserDao&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserDaoImpl &lt;span&gt;extends&lt;/span&gt; BaseDaoImpl&amp;lt;User&amp;gt; &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserDao {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User login(String username, String password) {
        String hql &lt;/span&gt;= &quot;from User u where u.username=:un and u.password=:pwd&quot;&lt;span&gt;;
        Query query &lt;/span&gt;=&lt;span&gt; getSession().createQuery(hql);
        query.setString(&lt;/span&gt;&quot;un&quot;&lt;span&gt;, username) 
            .setString(&lt;/span&gt;&quot;pwd&quot;&lt;span&gt;, password);
        Object obj &lt;/span&gt;=&lt;span&gt; query.uniqueResult();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj != &lt;span&gt;null&lt;/span&gt; ? (User)obj : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　还有其的XXXDao和XXXDaoImpl,通过继承和实现，可以让全部Impl实现类很轻松地就拥有基本的CRUD等通用数据库操作方法，如果某个实体有特殊的Dao操作只需要在相应Dao接口实现，然后在Impl实现类中实现该特殊方法就行，以前认识到的知识点在这里有了深入理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　泛型是一种思想，也是一种技术，动态的获取类型，让编程更加灵活，这里利用泛型，我们可以先不制定实体类对象具体类型，构造一个泛型的Dao接口和实现类，让后面各自具体的实体Dao去继承泛型的时候再确定类型，从而也得到了泛型中定义的基本方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　继承体现的是代码重用思想，当一个方法被构造多次的时候我们就要思考代码重用的问题了，在这里每个实体对象都需要基本的数据库操作方法，如果一个个的去定义将会十分繁琐和枯燥，通过继承我们可以省去很多代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　实现不同于继承，它没有节省代码，而且又涉及到抽象的概念，在单个父类与多个子类的继承关系中，父类某个方法对应的子类实现有差异时，我们对于父类的该方法，即可定义为抽象方法，子类各自实现具体细节即可。举个例子：动物父类，子类有鸟、鱼等，定义动物时，会定义睡觉方法，但是每种动物睡觉情况都不一样，鸟睡树上，鱼睡水下，你没法指定具体实现细节，所以就可以定义一个抽象的睡觉方法void sleep（）；具体的动物实现接口后，重写该抽象方法，展示实现细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　总结继承和实现：继承通用的，实现特殊的。在文中构造的持久层中，我们的所有实体通过继承轻松地拥有了所有的通用数据库操作方法，各自特殊的操作需求可在各自接口中生命然后在实现类中实现即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最后，文中的项目中其实还存在许多不足的地方，主键的类型其实也可以用泛型,dao层有通用组件，service层是否应该也有通用的，若是有该如何构造等等，一些问题我在现在用的spring data jpa中得到了答案，所以应该会另外梳理一下写出来。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 16 Nov 2017 11:29:00 +0000</pubDate>
<dc:creator>窗外天空晴朗</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/young-z/p/7842905.html</dc:identifier>
</item>
<item>
<title>机器学习训练模型的一般错误 - 学会思考の小R</title>
<link>http://www.cnblogs.com/hello-world-n/p/7845925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hello-world-n/p/7845925.html</guid>
<description>&lt;p&gt;在我们构建完机器学习模型，经常会遇到训练得到模型无法正确预测，这之后我们往往会采取下面的一些方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增加训练数据&lt;/li&gt;
&lt;li&gt;减少特征的个数&lt;/li&gt;
&lt;li&gt;增加更多的特征&lt;/li&gt;
&lt;li&gt;增加多项式特征（X1*X2 ...）&lt;/li&gt;
&lt;li&gt;增大lambda的值&lt;/li&gt;
&lt;li&gt;减小lambda的值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;若是不了解模型具体的问题所在，而根据随便拿出一个方案去试错，这往往都是既费力又费心，往往个把月过去了仍然在进行模型的调试。&lt;/p&gt;
&lt;h2 id=&quot;cv-数据集-数据集处理&quot;&gt;CV 数据集 [数据集处理]&lt;/h2&gt;
&lt;p&gt;将一个数据集先按下面进行划分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Training set: 60%&lt;/li&gt;
&lt;li&gt;Cross validation set: 20%&lt;/li&gt;
&lt;li&gt;Test set: 20%&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;计算模型误差-误差计算&quot;&gt;计算模型误差 [误差计算]&lt;/h2&gt;
&lt;p&gt;1.线性回归，直接使用代价函数即可，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for i = 1:m
    %依次递增的数据量进行训练模型
    theta = trainLinearReg(X(1:i,:), y(1:i), lambda);
    %train数据集的测试，使用时去除lambda
    error_train(i) =linearRegCostFunction(X(1:i,:), y(1:i), theta, 0);
    %cv数据集的测试
    error_val(i) = linearRegCostFunction(Xval, yval, theta, 0);
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.logistic回归，引出0-1错分率：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171116192053312-822260243.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;过拟合和欠拟合-误差分析&quot;&gt;过拟合和欠拟合 [误差分析]&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171116192011640-2036375820.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欠拟合：高&lt;em&gt;偏差&lt;/em&gt;，Jcv近似于Jtrain。&lt;br/&gt;过拟合：高&lt;em&gt;方差&lt;/em&gt;，Jcv远大于Jtrain。&lt;br/&gt;这2个问题是机器学习中最经典的错误情况，很多现象也是由它们一手操办的，来看看下面的3种情况：&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;样本&quot;&gt;样本&lt;/h3&gt;
&lt;p&gt;根据上面误差计算部分得来的Training set和cv set得到相应图片&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171116192021812-645357694.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;High bias：Jcv与Jtrain非常接近，&lt;strong&gt;加入过多样本，对模型的优化没作用&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171116192030202-830326963.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;High variance：Jcv远大于Jtrain，&lt;strong&gt;增加样本，可以对模型进行优化&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171116192039406-2061575307.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;多项式特征&quot;&gt;多项式特征&lt;/h3&gt;
&lt;p&gt;多项式特征的选择的多少往往也会给我们带来很大的麻烦，过多的多项式特征会使模型过拟合，而过少的多项式特征会使模型欠拟合。&lt;br/&gt;那么我们该如何进行多项式的选择，下面便引入解决方案：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171116192101077-2083666451.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用training set训练每一个多项式，得出相应的theta值。&lt;/li&gt;
&lt;li&gt;使用cv set获得误差最小的多项式。&lt;/li&gt;
&lt;li&gt;最后使用test set对多项式进行评估。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h3 id=&quot;lambda&quot;&gt;lambda&lt;/h3&gt;
&lt;p&gt;正规化的引入，就是为了防止过拟合，而lambda对拟合程度有着很大影响。若是没有lambda则会出现过拟合现象；而若是lambda过大则会出现欠拟合现象。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171116192108140-2040754352.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那怎么选择一个较好的lambda呢？&lt;br/&gt;方法类似于多项式特征的选取，稍有不同的就是自己要定义lambda集合。&lt;/p&gt;
&lt;p&gt;测试代码段&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for i = 1:length(lambda_vec)
        lambda = lambda_vec(i);
        theta = trainLinearReg(X, y, lambda);
        %评估时切记不可在cv set和test set中加入lambda值
        error_train(i) = linearRegCostFunction(X, y, theta, 0);
        error_val(i) = linearRegCostFunction(Xval, yval, theta, 0);
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1006924/201711/1006924-20171116192117031-778675845.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;学习曲线&quot;&gt;学习曲线&lt;/h2&gt;
&lt;p&gt;很多情况下因为特征很多，我们往往很难将数据展现出来，而可视化的数据往往给我们的分析带来了很大的帮助；learning curve的绘制无疑是一大助手，learning curve通常是由training set和cv set的误差绘制出来的，中间最重要的就是将training set使用递增的方式进行训练，而cv set则是全部进行使用。如【计算模型误差的代码部分】。&lt;/p&gt;
</description>
<pubDate>Thu, 16 Nov 2017 11:22:00 +0000</pubDate>
<dc:creator>学会思考の小R</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hello-world-n/p/7845925.html</dc:identifier>
</item>
</channel>
</rss>