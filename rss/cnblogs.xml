<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【抽象那些事】 命令式抽象 - 喜欢天黑却怕鬼</title>
<link>http://www.cnblogs.com/songwenjie/p/8977618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/8977618.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180501/J93f1aEF2g.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这种坏味是由操作转换为类引起的，表现为类中只定义了一个方法，有时候类名和方法名相同。这种坏味还常常表现为方法操作的数据位于另一个类中。&lt;/p&gt;
&lt;h2 id=&quot;为什么不能命令式抽象&quot;&gt;为什么不能命令式抽象？&lt;/h2&gt;
&lt;p&gt;面向对象的基本原则是，识别真实世界中的事物，并使用抽象来表示它们。在解决方案域中，必须将问题域的对象表示出来，为此可采用&lt;strong&gt;映射域实体&lt;/strong&gt;这一实现手法，抽象的每个类都必须封装数据和相关的方法。只包含一个操作的类根本不是抽象，其操作的数据位于其它地方时尤其如此。这样很多操作相同数据的方法位于不同的类中，减低了类的内聚性，违反了封装和模块化原则。&lt;/p&gt;
&lt;h2 id=&quot;命令式抽象潜在的原因&quot;&gt;命令式抽象潜在的原因&lt;/h2&gt;
&lt;h3 id=&quot;过程式思维&quot;&gt;过程式思维&lt;/h3&gt;
&lt;p&gt;数据和操作这些数据的方法被封装在不同类中，典型的过程式思维。&lt;/p&gt;
&lt;h2 id=&quot;示例分析&quot;&gt;示例分析&lt;/h2&gt;
&lt;p&gt;来看报表生成功能，它使用了CreateReport、CopyReport、DisplayReport等类。其中每个类只包含一个方法。与报表相关的数据项，如报表名称等都放在了Report类。很显然程序中存在“命令式抽象”，这种坏味不仅增加了类的数量（至少4个类，理想情况下只需要1个类），而且内聚的方法进行了分离，增加了开发和维护的复杂性。该设计采取的是“&lt;strong&gt;功能分解&lt;/strong&gt;”，而非“&lt;strong&gt;面向对象分解&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180501/mBGH81Eicb.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Report
{
    public string ReportName { get; set; }
}

public class CreateReport
{
    public void Create()
    {
        //Create
    }
}

public class DisplayReport
{
    public void Display()
    {
        //Display
    }
}

public class CopyReport
{
    public void Copy()
    {
        //Copy
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重构：我们将所有存在“命令式抽象”坏味的类中的方法都移到Report类中，那么Report类就变成了一个恰当的抽象，同时消除了“命令式抽象”坏味。&lt;/p&gt;
&lt;p&gt;重构后的实现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180501/DJHJ2C3Hie.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Report
{
    public string ReportName { get; set; }

    public void Create()
    {
        //Create
    }
    public void Display()
    {
        //Display
    }
    public void Copy()
    {
        //Copy
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;现实考虑&quot;&gt;现实考虑&lt;/h2&gt;
&lt;h3 id=&quot;具体化&quot;&gt;具体化&lt;/h3&gt;
&lt;p&gt;具体化指的是将不是对象的东西提升为对象。将行为具体化后，便可对其进行存储、传递和转换。具体化可提高系统的灵活性，但是代价是增加了系统的复杂度。&lt;/p&gt;
&lt;p&gt;很多设计模式都使用了具体化：状态模式、命令模式、策略模式。&lt;/p&gt;
&lt;p&gt;为了提高可重用性、灵活性和可扩展性而有意识地将原本不是对象的东西提升为对象，这不能算是坏味。&lt;/p&gt;
&lt;p&gt;参考：《软件设计重构》&lt;/p&gt;

&lt;div class=&quot;content&quot; readability=&quot;26.253521126761&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;

&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;div readability=&quot;7.9328063241107&quot;&gt;&lt;strong&gt;来源：&lt;a href=&quot;http://songwenjie.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;http://songwenjie.cnblogs.com/&lt;/a&gt;&lt;br/&gt;&lt;/strong&gt;
&lt;p&gt;&lt;strong&gt;声明：本文为博主学习感悟总结，水平有限，如果不当，欢迎指正。如果您认为还不错，不妨点击一下下方的&lt;span onclick=&quot;Digg();&quot;&gt;【&lt;span&gt;推荐&lt;/span&gt;】&lt;/span&gt;按钮，谢谢支持。转载与引用请注明出处。&lt;/strong&gt;&lt;/p&gt;
&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;



</description>
<pubDate>Fri, 04 May 2018 23:41:00 +0000</pubDate>
<dc:creator>喜欢天黑却怕鬼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/8977618.html</dc:identifier>
</item>
<item>
<title>入职第一天：前端leader手把手教我入门Vue服务器端渲染（SSR） - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/8993499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/8993499.html</guid>
<description>&lt;p&gt;继前段时间西安电面之后顺利拿到了OFFER，今天（5月2号）是我入职第一天，在简短的内部培训了一上午后，前端leader让我先了解下什么是&lt;strong&gt;vue的服务器端渲染（SSR）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201805/701424-20180505045737014-897206613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SSR，英文全称叫 Server side rendering ，国人叫它服务器端渲染。&lt;/p&gt;
&lt;p&gt;首先听到这个名词，我头脑就有点眩晕。咱们还是先去官网了解下SSR的定义：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Vue.js 可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记&quot;混合&quot;为客户端上完全交互的应用程序。这种在服务器和客户端都可以运行的代码程序，也可以叫做“同构”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我弱弱地问了leader一句，&lt;strong&gt;咱们公司为什么要使用服务端渲染&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;leader冷冷地回复，有两点原因，第一点，因为我们公司的站点很注重SEO，页面又是异步获取内容；第二点，同时也希望用户更快速地看到完整渲染的页面，从而提高用户体验。基于这两点，所以需要服务器端渲染(SSR)来解决这些问题。&lt;/p&gt;
&lt;p&gt;那服务端渲染的流程究竟是怎样的呢？话不多说，先上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201805/701424-20180505045757717-1853349695.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;在使用服务端渲染的时候，首先要有个server端。因为在开发vue项目时，需要起一个webpack-dev-server的服务，端口8000。因为我们要使用它的热更替，这样能加快开发效率。&lt;/p&gt;

&lt;p&gt;由于webpack是一个自主的server，我们没有办法在里面添加服务端渲染的代码，而这段代码是需要自己去写的，所以需要再起一个node server，去执行服务端渲染的逻辑。我们会用到vue-server-renderer这个包来帮我们在node.js环境里面去渲染出vue代码生成的HTML代码，这部分代码是直接返回给用户的，用户可以在浏览器里直接看到HTML的内容。&lt;/p&gt;

&lt;p&gt;以图为例，我们看到两个渲染的过程，两种server。如果直接访问webpack-dev-server，就跟我们之前开发的过程一样，它是一个纯前端渲染的过程。如果我们要走服务端渲染的流程，就要走node server服务，端口3333以示区别。而且需要打包一个逻辑到node端运行，通过webpack-server-compiler去生成一个server bundle，也就是服务端的app.js。 当node server 获取到server bundle之后，就可以执行vue-server-renderer，去渲染出HTML的代码，直接返回给用户，这样的话就不需要通过js再去渲染出页面内容，减少了用户的等待时间。&lt;/p&gt;

&lt;p&gt;今天这篇文章的主要任务是，先用webpack创建一个配置文件来打包server端的代码。&lt;/p&gt;
&lt;p&gt;入门第一步，如何编写服务器端渲染的配置文件？&lt;/p&gt;

&lt;p&gt;首先我们需要在项目根目录里面找到build文件夹，然后在其下面新建一个webpack.config.server.js文件，具体配置代码，我先撸为敬：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; path = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;path&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; ExtractPlugin = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;extract-text-webpack-plugin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; webpack = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;webpack&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; merge = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;webpack-merge&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; baseConfig = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./webpack.config.base&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; VueServerPlugin = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue-server-renderer/server-plugin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

let config

config &lt;/span&gt;=&lt;span&gt; merge(baseConfig, {
  target: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  entry: path.join(__dirname, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../client/server-entry.js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
  devtool: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;source-map&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
  output: {
    libraryTarget: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;commonjs2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    filename: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;server-entry.js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    path: path.join(__dirname, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../server-build&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  },
  externals: Object.keys(require(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../package.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).dependencies),
  module: {
    rules: [
      {
        test: &lt;/span&gt;/\.styl/&lt;span&gt;,
        use: ExtractPlugin.extract({
          fallback: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue-style-loader&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
          use: [
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;css-loader&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            {
              loader: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;postcss-loader&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
              options: {
                sourceMap: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
              }
            },
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;stylus-loader&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
          ]
        })
      }
    ]
  },
  plugins: [
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ExtractPlugin(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;styles.[contentHash:8].css&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DefinePlugin({
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;process.env.NODE_ENV&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: JSON.stringify(process.env.NODE_ENV || &lt;span&gt;'&lt;/span&gt;&lt;span&gt;development&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;process.env.VUE_ENV&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;server&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    }),
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; VueServerPlugin()
  ]
})

module.exports &lt;/span&gt;= config
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;刚接触SSR的童鞋，看完以上代码是不是感觉有点晕？别着急，我来带大家一一分析下。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
target: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;target需要指定为node，因为打包出来的程序是在node端运行的，不是在浏览器端运行，所以要指定打包的目标是node环境。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
entry: path.join(__dirname, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../client/server-entry.js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;),
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;entry需要提供一个单独的入口文件，所以需要在client文件夹下新建一个server-entry.js文件。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
devtool: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;source-map&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;devtool需要指定source-map，因为vue-server-renderer有个webpack插件，它能提供代码调试的功能，不过只能提示到出错的文件出在哪一行。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
libraryTarget: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;commonjs2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定libraryTarget的类型为commonjs2，用来指定代码export出去的入口的形式。在node.js中模块是module.exports = {...}，commonjs2打包出来的代码出口形式就类似于此。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
externals: Object.keys(require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;../package.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).dependencies),
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;externals是外部因素的意思，首先我们可以打开package.json文件看看dependencies&lt;/p&gt;

&lt;p&gt;我们用Object.keys()得到的就是一个数组。externals就是告诉webpack不要去打包node_modules里面的js代码。devDependencies里面是一些工具型的东西，在应用真正跑起来的时候是不需要的。只有在执行一些打包，工具化操作的时候才会需要它。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;process.env.VUE_ENV&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;server&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是vue服务端官方建议我们这么去做的，在vue-server-renderer里面可能会用到这个属性。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; VueServerPlugin = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue-server-renderer/server-plugin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个插件能帮我们单独地生成一个json文件，用于在vue的服务端渲染里面能帮助我们处理一些很复杂的逻辑。&lt;/p&gt;

&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;文章写到这儿，Vue的服务端渲染的入门工作就算完成了（先用webpack创建一个配置文件来打包server端的代码），下一篇文章将介绍如何使用koa这个node服务端框架去实现node server，最新文章都会第一时间更新在我的公众号&amp;lt;&lt;strong&gt;闰土大叔&lt;/strong&gt;&amp;gt;里面，欢迎关注。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201805/701424-20180505050108012-135246261.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 04 May 2018 21:04:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/8993499.html</dc:identifier>
</item>
<item>
<title>Angular使用总结 --- 模版驱动表单 - Shapeying</title>
<link>http://www.cnblogs.com/shapeY/p/8962139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shapeY/p/8962139.html</guid>
<description>&lt;p&gt;　　表单的重要性就不多说了，Angular支持表单的双向数据绑定，校验，状态管理等，总结下。&lt;/p&gt;
&lt;h2&gt;获取用户输入&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container-fluid login-page&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Angular表单&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;login-area&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;login-name&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入登录帐号&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;pwd&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;login-pwd&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入登录密码&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-block btn-success&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;登录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　假如有以上简单表单，先不论优劣，有哪些方式可以获取到表单数据呢？ 先看两种简单粗暴的&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1）事件$event的方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在监听事件的时候，将整个&lt;strong&gt;事件载荷 $event&lt;/strong&gt; 传递到事件处理函数，它会携带触发元素的各种信息。这里监听form元素的submit事件，将整个form的信息传给处理函数，并打印出来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;login-area&quot;&lt;/span&gt;&lt;span&gt;  (submit)&lt;/span&gt;&lt;span&gt;=&quot;testInput($event)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;testInput ( _input: any) {
    console.dir(_input);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　触发submit后，查看结果。非常眼熟，就是传统方式中的event嘛，后面就不用多说了，target即为form元素，再定位到input子元素，分别获取value即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072774/201804/1072774-20180427114427020-2016160116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　为了获取input的Value，我们传递了非常多的无用信息，处理函数根本就不关心元素的位置，属性等等，它只需要value值。所以这种方式不可取&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2) 模版引用变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Angular中可以用 &lt;strong&gt;模版引用变量(#var)&lt;/strong&gt;来引用DOM元素/Angular组件/指令。通常模版引用变量就是代表声明的那个元素，当然也可以修改指向，可以代表Angular指令(比如后续用到的ngForm指令和ngModel指令)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模版引用变量代表Form元素&lt;/span&gt;
&amp;lt;form class=&quot;login-area&quot; #test  (submit)=&quot;testInput(test)&quot;&amp;gt;

&lt;span&gt;// 模版引用变量代表ngForm指令
&lt;/span&gt;&amp;lt;form class=&quot;login-area&quot; #test=&quot;ngForm&quot;(submit)=&quot;testInput(test)&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从下图可以看到不同，第一个和$event.target一样，是DOM元素；第二个是&lt;strong&gt;ngForm指令，可以跟踪每个控件的值和状态&lt;/strong&gt;(是否输入过？是否校验通过？等等)，后续会详细说&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072774/201804/1072774-20180427151223007-1821529591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以当我们直接用模版引用变量引用input元素时，就可以直接在&lt;strong&gt;模版中传递input元素的value&lt;/strong&gt;，而不需要传递整个元素信息。这种方式也不好，必须要通过事件触发才可以传递&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;login-area&quot;&lt;/span&gt;&lt;span&gt; (submit)&lt;/span&gt;&lt;span&gt;=&quot;testInput(&lt;strong&gt;test.value&lt;/strong&gt;)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; #test&lt;/strong&gt;  type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;login-name&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入登录帐号&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;注意：模版引用变量的作用域是整个模版，所以在同一个模版中，不能有同名的模版引用变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这两种获取表单数据的方式只是了解下，因为Angular提供了两种更好的构建表单的方式---模版驱动表单和模型驱动表单&lt;/p&gt;
&lt;h2&gt;模版驱动表单&lt;/h2&gt;
&lt;p&gt;　　顾名思义，是使用 &lt;strong&gt;HTML模版 + 表单专业指令&lt;/strong&gt; 来构建表单。使用模版驱动表单，记得要&lt;strong&gt;先在应用模块中import &lt;span class=&quot;typ&quot;&gt;FormsModule 。 &lt;/span&gt;&lt;/strong&gt;说明以下几点：&lt;/p&gt;
&lt;p&gt;　　1、模版驱动表单使用 [(ngModel)] 语法进行双向数据绑定，非常简单就可以把表单数据绑定到模型中。&lt;strong&gt;注意在表单中使用[ngModel]时，必须要定义name属性&lt;/strong&gt;，因为Angular在处理表单时，会创建一些&lt;strong&gt;FormControl，用来跟踪单个表单控件的值和状态&lt;/strong&gt;，而&lt;strong&gt;表单控件name属性就是键值&lt;/strong&gt;，所以必须要指定name属性。(这应该算是指出了获取表单数据的两种科学的方式：[ngModel]语法绑定 和 通过formControl的Api获取)&lt;/p&gt;
&lt;p&gt;　　2、使用 &lt;strong&gt;ngForm指令，来监听整个表单的有效性(valid属性)&lt;/strong&gt;。Angular会自动为form表单自动创建并添加ngForm指令，直接使用即可&lt;/p&gt;
&lt;p&gt;　　3、使用&lt;strong&gt;ngModel指令，来监听单个表单控件的状态&lt;/strong&gt;，还会使用特定的&lt;strong&gt;Angular css来更新控件样式 ， &lt;/strong&gt;我们可以通过这些class来控制不同状态时，表单控件的展示&lt;/p&gt;

&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072774/201805/1072774-20180503181028040-5243196.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　4、表单验证可以&lt;strong&gt;使用 HTML原生的表单验证属性&lt;/strong&gt;(required , pattern , max , min 等等) ，验证出错时，3中提到的errors属性就会有对应的错误项；&lt;/p&gt;
&lt;p&gt;　　　  还可以自定义验证器，因为模版驱动表单不直接访问FormControl实例，所以需要把自定义的验证器用指令包装。&lt;/p&gt;
&lt;p&gt;　　通过以下栗子来展示模版驱动表单简单使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 模版引用变量指向ngForm指令 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;login-area&quot;&lt;/span&gt;&lt;span&gt; #testform&lt;/span&gt;&lt;span&gt;=&quot;ngForm&quot;&lt;/span&gt;&lt;span&gt; (submit)&lt;/span&gt;&lt;span&gt;=&quot;testInput()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; ngModel绑定数据 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; required 和 pattern 指定校验规则 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 模版引用变量指向ngModel指令 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;login-name&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入登录帐号&quot;&lt;/span&gt;&lt;span&gt;
               [(ngModel)] &lt;/span&gt;&lt;span&gt;= &quot;user.name&quot;&lt;/span&gt;&lt;span&gt;   
               required
               pattern&lt;/span&gt;&lt;span&gt;=&quot;[0-9A-z]+&quot;&lt;/span&gt;&lt;span&gt;
               #nameinput &lt;/span&gt;&lt;span&gt;= &quot;ngModel&quot;&lt;/span&gt;
               &lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 通过表单控件的状态控制是否展示错误说明及展示何种错误说明 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt; *ngIf&lt;/span&gt;&lt;span&gt;=&quot;nameinput.touched&amp;amp;&amp;amp;nameinput.invalid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;error-info&quot;&lt;/span&gt;&lt;span&gt; *ngIf&lt;/span&gt;&lt;span&gt;=&quot;nameinput.errors?.required&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户名不能为空！&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;error-info&quot;&lt;/span&gt;&lt;span&gt; *ngIf&lt;/span&gt;&lt;span&gt;=&quot;nameinput.errors?.pattern&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户名只能包含英文或数字！&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;pwd&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;login-pwd&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;请输入登录密码&quot;&lt;/span&gt;&lt;span&gt;
             [(ngModel)] &lt;/span&gt;&lt;span&gt;= &quot;user.pwd&quot;&lt;/span&gt;&lt;span&gt;
             required
             #pwdinput &lt;/span&gt;&lt;span&gt;= &quot;ngModel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt; *ngIf&lt;/span&gt;&lt;span&gt;=&quot;pwdinput.touched&amp;amp;&amp;amp;pwdinput.invalid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;error-info&quot;&lt;/span&gt;&lt;span&gt; *ngIf&lt;/span&gt;&lt;span&gt;=&quot;pwdinput.errors?.required&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;密码不能为空！&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 通过表单的状态控制按钮是否可用 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-block btn-success&quot;&lt;/span&gt;&lt;span&gt; [disabled]&lt;/span&gt;&lt;span&gt;=&quot;testform.invalid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;登录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;通过Angular css 自动添加的class来控制表单样式  &lt;/strong&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
input.ng-invalid.ng-touched{
        border: 2px solid red;
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看下效果，&lt;strong&gt;表单校验、样式反馈、按钮状态管理、数据获取&lt;/strong&gt;都很方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1072774/201805/1072774-20180505011614994-476581255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　至于如何自定义验证器会和模型驱动表单的自定义验证器一起说明，那就是下一篇了；随笔中有不足的欢迎大家指正···&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 17:22:00 +0000</pubDate>
<dc:creator>Shapeying</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shapeY/p/8962139.html</dc:identifier>
</item>
<item>
<title>Numpy快速入门(一)——shape属性 - 梁夏荣</title>
<link>http://www.cnblogs.com/liangxiarong/p/8993300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangxiarong/p/8993300.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;对于学习NumPy（Numeric Python）,首先需要知道一点是：Numpy 是用来处理矩阵数组的。因此，知道一个数组是多少维度是很有必要的。&lt;/p&gt;
&lt;h2&gt;shape 属性&lt;/h2&gt;
&lt;p&gt;对于shape函数，官方文档是这么说明：&lt;/p&gt;
&lt;p&gt;the dimensions of the array. This is a tuple of integers indicating the size of the array in each dimension.&lt;/p&gt;
&lt;p&gt;直译：数组的维度。这是一个整数的元组，元组中的每一个元素对应着每一维度的大小(size)。&lt;/p&gt;
&lt;p&gt;再直译一点理解就是，若元组只有一个元素，则说明这个数组是一维数组：如元组(2,)   表示一维数组，只含有2个元素；同理，可知(1,3)表示的是一个2维数组，因为含有2个元素 :1,3&lt;/p&gt;
&lt;h3&gt;举例说明：&lt;/h3&gt;
&lt;h4&gt;一维数组&lt;/h4&gt;
&lt;p&gt;import numpy as np&lt;/p&gt;
&lt;p&gt;a = np.array([1,2,3])&lt;/p&gt;
&lt;p&gt;print(a.shape) # 输出 (3,)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：这里输出的元组(3,)按官方的文档理解，这里的3表示的是第一个维度中元素的大小（size）;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理，对于&lt;span&gt;二维数组&lt;span&gt;myarray&lt;/span&gt;&lt;/span&gt;，可推测出myarray.shape输出的应该类似(n,m)只含有&lt;span&gt;两个元素&lt;/span&gt;的元组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，第一个元素n代表中一维数组中元素的个数;m代表第二维度中元素的个数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b = np.array([[1,2,3],[3,4,5]])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;print(b.shape) # 输出(2,3)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;元组(2,3) 说明这是一个二维数组，其中第一个维度含有2个元素，第二个维度中每一个元素都含有3个元素(1,2,3).&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;通过以上的例子，我们可以知道对于numpy中数组的shape属性输出的元组，有以下两个结论：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;元组的元素的个数等于维度数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;元组中每一个元素又代表中每一维度元素的个数（从左到右，依次为第一维度中元素的个数，第二维度中元素的个数...第n维度元素的个数）&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;如，若某一个numpy数组test_array 调用shape输出为(2,3,3,4) 我们根据上面的结论，就可以很快的知道这是一个&lt;span&gt;4&lt;/span&gt;维的数组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，第一个维度只有2个元素。&lt;/span&gt;&lt;span&gt;第二个维度有3个元素，第三个维度也有3个元素，最后的第四个维度有4个元素。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;最后的最后&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 对于numpy中的数组，若是不知道他是几维的，我们可以输出他的shape属性，然后，&lt;span&gt;数一下&lt;/span&gt;有几个元素就很easy 知道数组是几维数组啦。&lt;/p&gt;

</description>
<pubDate>Fri, 04 May 2018 16:43:00 +0000</pubDate>
<dc:creator>梁夏荣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liangxiarong/p/8993300.html</dc:identifier>
</item>
<item>
<title>MyBatis 框架之快速入门程序 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8993151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8993151.html</guid>
<description>&lt;p&gt;关于如何快速创建 Maven 项目，这个可以参考下面这篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5MTE0ODcwNQ==&amp;amp;mid=2247484175&amp;amp;idx=1&amp;amp;sn=3bfecf0c6f889560d02f07ad30879961&amp;amp;chksm=fe3220c1c945a9d75f5a3205edfe8907081d931c69d9377128b422b7c622440ae59c352f01fb#rd&quot;&gt;Maven 项目管理工具基础入门系列（一）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打开 &lt;code&gt;pom.xml&lt;/code&gt; 文件，快速配置 jar 包，配置代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&amp;lt;project xmlns=&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt; xmlns:xsi=&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
  xsi:schemaLocation=&lt;span class=&quot;st&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;modelVersion&amp;gt;&lt;span class=&quot;fl&quot;&gt;4.0.0&lt;/span&gt;&amp;lt;/modelVersion&amp;gt;
  &amp;lt;groupId&amp;gt;com.&lt;span class=&quot;fu&quot;&gt;mybatis&lt;/span&gt;&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;MyBatisDemo&amp;lt;/artifactId&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;
  &amp;lt;version&amp;gt;&lt;span class=&quot;fl&quot;&gt;0.0.1&lt;/span&gt;-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;name&amp;gt;MyBatisDemo Maven Webapp&amp;lt;/name&amp;gt;
  &amp;lt;url&amp;gt;http:&lt;span class=&quot;co&quot;&gt;//maven.apache.org&amp;lt;/url&amp;gt;&lt;/span&gt;
  &amp;lt;dependencies&amp;gt;

    &amp;lt;!-- MyBatis 依赖包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.&lt;span class=&quot;fu&quot;&gt;mybatis&lt;/span&gt;&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;&lt;span class=&quot;fl&quot;&gt;3.4.5&lt;/span&gt;&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- 数据库驱动依赖包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;&lt;span class=&quot;fl&quot;&gt;5.1.25&lt;/span&gt;&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- junit 测试依赖包 --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;&lt;span class=&quot;fl&quot;&gt;3.8.1&lt;/span&gt;&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    
  &amp;lt;/dependencies&amp;gt;

  &amp;lt;build&amp;gt;
    &amp;lt;finalName&amp;gt;MyBatisDemo&amp;lt;/finalName&amp;gt;
    &amp;lt;resources&amp;gt;
      &amp;lt;resource&amp;gt;
        &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
        &amp;lt;includes&amp;gt;
          &amp;lt;include&amp;gt;**&lt;span class=&quot;co&quot;&gt;/*.xml&amp;lt;/include&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        &amp;lt;/includes&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      &amp;lt;/resource&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &amp;lt;/resources&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;  &amp;lt;/build&amp;gt;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建 pojo 类 &lt;code&gt;User.java&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.mybatis.pojo;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; User{

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; id;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String username;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String password;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; age;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; id;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; id) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;id&lt;/span&gt; = id;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getUsername&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; username;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setUsername&lt;/span&gt;(String username) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;username&lt;/span&gt; = username;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getPassword&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; password;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setPassword&lt;/span&gt;(String password) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;password&lt;/span&gt; = password;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getAge&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; age;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setAge&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; age) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;age&lt;/span&gt; = age;
    }
    
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;User [id=&quot;&lt;/span&gt; + id + &lt;span class=&quot;st&quot;&gt;&quot;, username=&quot;&lt;/span&gt; + username + &lt;span class=&quot;st&quot;&gt;&quot;, password=&quot;&lt;/span&gt;
                + password + &lt;span class=&quot;st&quot;&gt;&quot;, age=&quot;&lt;/span&gt; + age + &lt;span class=&quot;st&quot;&gt;&quot;]&quot;&lt;/span&gt;;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;新建数据库 mybatis_db，创建表 t_user，建表代码如下：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CREATE TABLE `t_user`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `age` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;创建接口 &lt;code&gt;UserDao.java&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.mybatis.dao;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.mybatis.pojo.User;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; UserDAO {
    
    &lt;span class=&quot;co&quot;&gt;//新增用户&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addUser&lt;/span&gt;(User user);
    
    &lt;span class=&quot;co&quot;&gt;//根据id删除用户&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;deleteUser&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; id);
    
    &lt;span class=&quot;co&quot;&gt;//修改用户&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;updateUser&lt;/span&gt;(User user);
    
    &lt;span class=&quot;co&quot;&gt;//根据id查询用户&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; User &lt;span class=&quot;fu&quot;&gt;selectUserById&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; id);
    
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建 xml 文件 &lt;code&gt;UserDaoMapper.xml&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt; 

&lt;span class=&quot;kw&quot;&gt;&amp;lt;mapper&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; namespace=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mybatis.dao.UserDao&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
     
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;insert&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;addUser&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; parameterType=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mybatis.pojo.User&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
       insert into t_user (username,password,age) values (#{username},#{password},#{age})
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/insert&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;delete&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;deleteUser&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; parameterType=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;int&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
       delete from t_user where id=#{id}  
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/delete&amp;gt;&lt;/span&gt; 
    
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;update&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;updateUser&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
       update t_user set username=#{username},password=#{password},age=#{age} where id=#{id}
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/update&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;select&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;selectUserById&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; parameterType=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;int&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; resultType=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mybatis.pojo.User&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
       select * from t_user where id=#{id}
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/select&amp;gt;&lt;/span&gt;
    
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/mapper&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建 xml 文件 &lt;code&gt;mybatis-comfig.xml&lt;/code&gt;，具体配置如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 配置 MyBatis 运行环境 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;environments&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; default=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;environment&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;development&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 配置 JDBC 事务管理 --&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;transactionManager&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;JDBC&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- POOLED 配置 JDBC 数据源连接池 --&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;dataSource&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;POOLED&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;driver&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jdbc:mysql://localhost:3306/mybatis_db?useUnicode=true&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;&amp;amp;amp;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;characterEncoding=UTF-8&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dataSource&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/environment&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/environments&amp;gt;&lt;/span&gt;
    
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 注册 UserDAO.xml --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;mappers&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;mapper&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; resource=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com/mybatis/dao/UserDaoMapper.xml&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/mappers&amp;gt;&lt;/span&gt;
    
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建测试类 &lt;code&gt;Test.java&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.mybatis.test;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.io.InputStream;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSession;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSessionFactory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.ibatis.session.SqlSessionFactoryBuilder;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import com.mybatis.dao.UserDao;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.mybatis.pojo.User;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Test {
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {

        &lt;span class=&quot;co&quot;&gt;//加载MyBatis配置文件&lt;/span&gt;
        InputStream is = Test.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getResourceAsStream&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;mybatis-config.xml&quot;&lt;/span&gt;);
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SqlSessionFactoryBuilder&lt;/span&gt;();
        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.&lt;span class=&quot;fu&quot;&gt;build&lt;/span&gt;(is);

        &lt;span class=&quot;co&quot;&gt;//获取SqlSession&lt;/span&gt;
        SqlSession sqlSession = sqlSessionFactory.&lt;span class=&quot;fu&quot;&gt;openSession&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;//获取实现接口的代理对象&lt;/span&gt;
        UserDao userDAO = sqlSession.&lt;span class=&quot;fu&quot;&gt;getMapper&lt;/span&gt;(UserDao.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        
        &lt;span class=&quot;co&quot;&gt;//新增用户&lt;/span&gt;
        User user = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;User&lt;/span&gt;();
        user.&lt;span class=&quot;fu&quot;&gt;setUsername&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;孔乙己&quot;&lt;/span&gt;);
        user.&lt;span class=&quot;fu&quot;&gt;setPassword&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;);
        user.&lt;span class=&quot;fu&quot;&gt;setAge&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;21&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(userDAO.&lt;span class=&quot;fu&quot;&gt;addUser&lt;/span&gt;(user));
        sqlSession.&lt;span class=&quot;fu&quot;&gt;commit&lt;/span&gt;();
        
&lt;span class=&quot;co&quot;&gt;//      //删除用户&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      System.out.println(userDAO.deleteUser(1));&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      sqlSession.commit();&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      //查询用户&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      User user1 = userDAO.selectUserById(1);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      System.out.println(user1);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      //修改用户&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      User user2 = userDAO.selectUserById(1);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      user2.setUsername(&quot;指南者&quot;);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      System.out.println(userDAO.updateUser(user2));&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//      sqlSession.commit();&lt;/span&gt;

    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/4/1632b98599f10f30?w=425&amp;amp;h=140&amp;amp;f=png&amp;amp;s=6649&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/4/1632b98788288aed?w=547&amp;amp;h=236&amp;amp;f=png&amp;amp;s=12242&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本程序和数据库相关的代码已经上传到 GitHub 上，GitHub 地址：&lt;a href=&quot;https://github.com/compassblog/MyBatisDemo&quot;&gt;点击这里直接获取项目源码&lt;/a&gt;&lt;/p&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;-----------------------------------------&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/5/4/1632b9a25daec092?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27341&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 15:41:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8993151.html</dc:identifier>
</item>
<item>
<title>【基础】CSS实现多重边框的5种方式 - 毛三十</title>
<link>http://www.cnblogs.com/ifat3/p/8993088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ifat3/p/8993088.html</guid>
<description>&lt;h2 id=&quot;简言&quot;&gt;简言&lt;/h2&gt;
&lt;p&gt;目前最优雅地实现多重边框的方案是利用&lt;code&gt;CSS3&lt;/code&gt; 的 &lt;code&gt;box-shadow&lt;/code&gt;属性，但如果要兼容老的浏览器，则需要选择其它的方案。本文简要地列举了几种多重边框的实现方案，大家可以根据项目实际及兼容性要求等情况，选择最适合的实现方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/eaflrdo1.jpg&quot; alt=&quot;CSS多重边框&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;利用描边outline属性&quot;&gt;1 利用描边(&lt;code&gt;outline&lt;/code&gt;)属性&lt;/h2&gt;
&lt;p&gt;方案1利用描边(&lt;code&gt;outline&lt;/code&gt;)属性结合&lt;code&gt;border&lt;/code&gt;属性实现双重边框。此方案实现简单，兼容性好，能兼容除&lt;code&gt;IE6,7&lt;/code&gt;以外的浏览器。&lt;/p&gt;
&lt;h3 id=&quot;核心代码&quot;&gt;1.1 核心代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.borders&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#fff&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;outline:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#888&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;  
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;演示程序&quot;&gt;1.2 演示程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/df9cihc8.jpg&quot; alt=&quot;利用outline实现双重边框&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.42du.cn/run/175&quot;&gt;演示程序&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;说明&quot;&gt;1.3 说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;只能实现双重边框&lt;/li&gt;
&lt;li&gt;边框样式灵活，可以实现虚线等样式的边框&lt;/li&gt;
&lt;li&gt;描边在盒模型之外，会与外部元素发生重叠&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;利用额外的div&quot;&gt;2 利用额外的DIV&lt;/h2&gt;
&lt;p&gt;方案2利用额外的DIV嵌套的方式实现多重边框。这也是唯一不存在兼容性问题的方案。&lt;/p&gt;
&lt;h3 id=&quot;核心代码-1&quot;&gt;2.1 核心代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.outer&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#888&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#fff&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.inner&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#222&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;演示程序-1&quot;&gt;2.2 演示程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/mbamxafi.jpg&quot; alt=&quot;利用额外的DIV嵌套实现双重边框&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.42du.cn/run/176&quot;&gt;演示程序&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;说明-1&quot;&gt;2.3 说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;兼容性好&lt;/li&gt;
&lt;li&gt;可以实现多重边框，虚线边框等样式&lt;/li&gt;
&lt;li&gt;需要额外的DIV元素，增加了代码复杂性&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;利用伪元素&quot;&gt;3 利用伪元素&lt;/h2&gt;
&lt;p&gt;方案3利用伪元素（&lt;code&gt;:before&lt;/code&gt;）的方式实现双重边框。实现代码略复杂，属于hack的实现方式，不推荐。&lt;/p&gt;
&lt;h3 id=&quot;核心代码-2&quot;&gt;3.1 核心代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.borders&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#fff&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.borders&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;:before&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;content:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;position:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;absolute&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-12px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;left:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-12px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;right:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-12px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;bottom:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-12px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#888&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;演示程序-2&quot;&gt;3.2 演示程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/amlsefsh.jpg&quot; alt=&quot;利用伪元素实现双重边框&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.42du.cn/run/177&quot;&gt;演示程序&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;说明-2&quot;&gt;3.3 说明&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IE6,7,8&lt;/code&gt;不兼容&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;:after&lt;/code&gt;也可以&lt;/li&gt;
&lt;li&gt;同时应用&lt;code&gt;:before&lt;/code&gt;和&lt;code&gt;:after&lt;/code&gt;可以实现三重边框&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;利用border-image属性&quot;&gt;4 利用&lt;code&gt;border-image&lt;/code&gt;属性&lt;/h2&gt;
&lt;p&gt;方案4利用&lt;code&gt;CSS3&lt;/code&gt;的&lt;code&gt;border-image&lt;/code&gt;属性实现多重边框。实现方法简单，但需要制做一个额外的边框图片，兼容性较差。&lt;/p&gt;
&lt;h3 id=&quot;核心代码-3&quot;&gt;4.1 核心代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.borders&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;transparent&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;border-image:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;url(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'borders.jpg'&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;repeat&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;演示程序-3&quot;&gt;4.2 演示程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/qluvsthf.jpg&quot; alt=&quot;利用border-image属性实现双重边框&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.42du.cn/run/178&quot;&gt;演示程序&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;说明-3&quot;&gt;4.3 说明&lt;/h3&gt;
&lt;p&gt;本例中，利用&lt;code&gt;border-image-slice&lt;/code&gt;将边框图片分成如下图所示的9个区域：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/1bmrorni.jpg&quot; alt=&quot;border-image-slice示例图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中包括四个角（1，2，3，4），四条边（5，6，7，8）以及中间区域（9）。&lt;br/&gt;&lt;code&gt;repeat&lt;/code&gt;表示四条边都在相应的边框上重复的平铺。&lt;/p&gt;
&lt;h2 id=&quot;利用box-shadow属性&quot;&gt;5 利用&lt;code&gt;box-shadow&lt;/code&gt;属性&lt;/h2&gt;
&lt;p&gt;方案5利用&lt;code&gt;box-shadow&lt;/code&gt;属性实现多重边框。方案5是最简单，最直接的实现多重边框的方式。只有一行代码就可以实现多重边框效果。利用了阴影（&lt;code&gt;box-shadow&lt;/code&gt;）实现边框多少有一些hack的味道。&lt;/p&gt;
&lt;h3 id=&quot;核心代码-4&quot;&gt;5.1 核心代码&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.borders&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;box-shadow:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;6px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#fff&lt;/span&gt;, &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;12px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#888&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;演示程序-4&quot;&gt;5.2 演示程序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://res.42du.cn/up/201805/ecfwlrrk.jpg&quot; alt=&quot;利用box-shadow属性实现多重边框&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.42du.cn/run/179&quot;&gt;演示程序&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;说明-4&quot;&gt;5.3 说明&lt;/h3&gt;
&lt;p&gt;为了用阴影模拟边框，本例中使用了两个阴影效果，设置偏移值和模糊值为&lt;code&gt;0&lt;/code&gt;，并适当地设置阴影的尺寸，从而实现了双重边框的效果。因为一个阴影重叠在另一个阴影之上，第二个阴影的尺寸要设置成第一个阴影尺寸的两倍。关键部分是将模糊值设成0，从而产生像边框一样的纯色阴影，看起来和边框一样。&lt;/p&gt;
&lt;p&gt;和描边（&lt;code&gt;outline&lt;/code&gt;）属性一样，&lt;code&gt;box-shadow&lt;/code&gt;属性可能会和周边元素发生重叠，因此要适当地设置元素的外边距。&lt;code&gt;box-shadow&lt;/code&gt;兼容性一般。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;6 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/border-image&quot;&gt;MDN border-image&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/box-shadow&quot;&gt;MDN box-shadow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.impressivewebs.com/multiple-borders-css/&quot;&gt;Multiple Borders with CSS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://css-tricks.com/snippets/css/multiple-borders/&quot;&gt;CSS-tricks Multiple Borders&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;7 结语&lt;/h2&gt;
&lt;p&gt;本文简述了5种多重边框的实现方式，各有优缺点，大家要根据实际情况进行取舍。&lt;/p&gt;
&lt;p&gt;文中所述部分文字及代码汇编于网络。因时间不足，能力有限等原因，存在文字阐述不准及代码测试不足等诸多问题。&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 15:29:00 +0000</pubDate>
<dc:creator>毛三十</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ifat3/p/8993088.html</dc:identifier>
</item>
<item>
<title>用js来实现那些数据结构14（树02-AVL树） - Zaking</title>
<link>http://www.cnblogs.com/zaking/p/8976362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaking/p/8976362.html</guid>
<description>&lt;p&gt;　　在使用二叉搜索树的时候会出现 一个问题，就是树的一条分支会有很多层，而其他的分支却只有几层，就像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180501165824710-1188482354.png&quot; alt=&quot;&quot; width=&quot;1011&quot; height=&quot;429&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果数据量够大，那么我们在某条边上进行增删改查的操作时，就会消耗大量的时间。我们花费精力去构造一个可以提高效率的结构，反而事与愿违。这不是我们想要的。所以，我们需要另外一种树来解决这样的问题，那就是自平衡二叉搜索树--Adelson-Velskii-Landi（AVL）。什么意思呢？就是说这种树的任何一个节点左右两侧子树的高度之差最多为1。也就是说这种树会在添加或删除节点时尽量试着成为一棵完全树。&lt;/p&gt;
&lt;p&gt;　　自平衡二叉搜索树和二叉搜索树的实现几乎是一模一样的，唯一的区别就在于每次在插入或者删除节点的时候，我们需要检测它的&lt;strong&gt;平衡因子&lt;/strong&gt;（因为只有再插入或者删除的时候才有可能会影响到树的平衡性）&lt;strong&gt;。&lt;/strong&gt;如果有需要，那么就将其逻辑应用于树的自平衡。&lt;/p&gt;
&lt;p&gt;　　首先我们需要知道这个平衡因子是如何计算的。平衡因子的计算是来自于每个节点的右子树高度（hr）和左子树高度（hl）的差值， 该值应为0，1，-1.如果不是这三个值，那么说明需要平衡该AVL树。这就是平衡因子的简单计算方式。什么意思呢？&lt;/p&gt;
&lt;p&gt; 　　我们以上图为例，根节点11的平衡因子6 - 3 = 3。左侧子节点7的平衡因子是2 - 2 = 0；右侧子节点18的平衡因子就是5 - 2 = 3；节点70的平衡因子是0，要记住所有的叶节点（外部节点）的平衡因子都是0。因为叶节点没有子节点。还有一点一定要注意。我们所计算的平衡因子，是&lt;strong&gt;该节点的左右子树的高度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们学会了如何去计算平衡因子，那么我们下面进行一项及其重要的仪式......噢，sorry。是及其重要的知识——&lt;strong&gt;旋转。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在开始讲解旋转之前，我们先来点开胃菜。看看我们插入子节点后，导致该树不平衡的可能的情况有哪些。我会画几个图，以便大家看得仔细透彻。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504200406909-1770788260.png&quot; alt=&quot;&quot; width=&quot;251&quot; height=&quot;186&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　首先，我们以上面这张图（截取前面树结构的一部分）作为初始的树，这棵树绝对一定必然是平衡的。大家都没意见吧。那么RR,LL,RL,LR是什么意思呢？那么我们继续往下看。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第一种情况：RR。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　我们在18的右侧子节点再加一个节点20，右侧是要加入比父节点大的值的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504200851899-874560197.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;358&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　在我们加入了一个节点20之后，我们发现这棵树还是平衡的！唉？不对啊，跟我想要的结果好像不太一样。我再加一个节点试试？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504202638277-308936184.png&quot; alt=&quot;&quot; width=&quot;671&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　嗯......现在绝壁不平衡了。那么我们来看看怎么回事。在加入节点21（19）后，11节点左侧子树的深度是1，而右侧子树的深度是1，2，3。是3没错。那么1-3等于-2。嗯，十以内加减法应该不会算错。我们确定在节点18后面加入了两个右侧（R）节点后，这棵树就不平衡了。而现在有一个重要的问题。就是是哪一棵子树导致这棵树不平衡的呢？是在我们加入节点21（19）之后，也就是上图我们用小圈圈诅咒它的那一部分。那么我们可以用一句话来描述，我们在&lt;strong&gt;该树右侧子节点的右侧子节点加入了一个右侧子节点(如果加入的是左侧子节点也是一样的)之后&lt;/strong&gt;，导致了该树的不平衡，所以我们这时候需要去操作也就是旋转&lt;strong&gt;右侧的子节点&lt;/strong&gt;也就是18节点，来使这颗自平衡树来自平衡。换句话说，如果我们加入了一个节点（或者删除了一个节点），导致了我们整颗树的不平衡，那么我们首先要找到&lt;strong&gt;最近的不平衡的树来进行调整。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　上面RR情况的我分别加入了19，和21两个字节点，要说明一下，这两个子节点是为了更为清晰的告诉大家在&lt;span&gt;root的右节点的右节点下，无论插入的是左节点还是右节点都属于RR的情况&lt;/span&gt;。下同。在具体旋转的时候会给大家详细介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　换句话说，我们判断在增删节点的时候是否会导致不平衡的情况，由插入节点的前两个父节点来确定！大家要注意噢！很重要！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;趁热打铁，上面解释了RR的情况，那么其实下面的LL，LR，RL等情况也是一样的。思路没有任何区别。但是这个时候我想打断大家一下。问大家两个问题。这两个问题的解决会为后面的学习带来极大的便利。&lt;/p&gt;
&lt;p&gt;　　　　1、在AVL树或者其他树中，是否可以出现重复的值，比如树中已经有了一个11，我还想再加入一个11，是否允许？是否可以？&lt;/p&gt;
&lt;p&gt;　　　　2、看上图（RR情况图），是否有可能出现除了这四种情况外的其他情况？或者说，节点的平衡因子是否可能出现大于2或者小于-2的情况？（这种情况我们要旋转树超过两次，也就超出了我们这四种情况之外。）&lt;/p&gt;
&lt;p&gt;　　　　OK。希望大家闭上眼睛，想一想你的梦中情人，哦不对。想一想你的答案。&lt;/p&gt;
&lt;p&gt;　　　　不卖关子了，但是我真的希望大家想一想，因为这很必要也很重要。&lt;/p&gt;
&lt;p&gt;　　　　好吧，我开始回答第一个问题。其实在前一篇实现的树中是不允许重复的值出现的，我们可以去看一下上一篇的代码，如果相等则会覆盖。那么可能有人会问，我想要这棵树存储重复的值（当然其实这种情况出现的话大多数都是你的设计有问题。。。没有唯一标识了啊......需求还怎么实现）。那么我记得在&lt;a href=&quot;http://www.cnblogs.com/zaking/p/8950607.html&quot; target=&quot;_blank&quot;&gt;hashMap篇&lt;/a&gt;中有一个解决冲突的办法，是不是可以通过链表来存储key值相同的映射呢？是否还可以使用其他的存储方式？答案比较开放。所以是否可以存放重复的值，看你的实际需求咯。&lt;/p&gt;
&lt;p&gt;　　　　第二个问题的答案，不可能出现，因为大家一定要记住一个前提，&lt;strong&gt;就是我们在插入了一个导致该树不平衡的节点前，该树一定是平衡的。&lt;/strong&gt;为什么这么说呢？因为我们的AVL树，是自平衡二叉搜索树，如果在插入之前就是不平衡的，那你告诉我你这是啥?赶紧回头看代码，有BUG了亲。&lt;/p&gt;
&lt;p&gt;　　　　这里希望大家已经解除了心中不少的疑惑，如果还有问题，大家可以继续留言探讨。&lt;/p&gt;
&lt;p&gt;　　　　那么我们下面继续，把其它几种情况的图示画完。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第二种情况：LL。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504202910521-1120364309.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;484&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;第三种情况：LR。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504203110712-1017393203.png&quot; alt=&quot;&quot; width=&quot;654&quot; height=&quot;502&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;第四种情况：RL。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504203238973-188631473.png&quot; alt=&quot;&quot; width=&quot;711&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　那么看完上面这几幅图想必大家都了解了在插入节点的时候影响到树的平衡的4种可能性。那么为了面对这4种可能性。我们给出了与之相对应的4种解决不平衡的方法(其实就两种)。那么这里我们就要进入本篇最重要的内容了，&lt;strong&gt;旋转&lt;/strong&gt;。在开始之前，希望大家记住一句话。那就是，&lt;strong&gt;什么情况导致的不平衡，那就用相反方向的旋转&lt;/strong&gt;。什么意思呢，比如是LL导致的不平衡，那么我们就向右旋转。如果是RR导致的不平衡我们就向左，如果是RL，我们就LL再RR。如果是LR，我们就先RR再LL。好了，下面我们来看看究竟是如何旋转的吧。&lt;/p&gt;
&lt;p&gt;　　　那么下面就有点意思了。希望大家可以仔细看。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、RR情况的&lt;strong&gt;左旋转&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;我们还得来看图说话，我尽量把图画的让人容易误解，哦不，容易理解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504204934636-991364172.png&quot; alt=&quot;&quot; width=&quot;971&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　本人那个，画图工具用得还不是太熟练，拐歪的曲线没画出来，我拿嘴说吧......&lt;/p&gt;
&lt;p&gt;　　大家看上图，左旋是以18为轴心整个树的左部分向左旋转，这样就使18变成了根节点，11变成了18的左侧子节点。这样旋转一下，就相当于减少了一层右侧字树的一层深度，从而使整颗树变成了平衡树。那么可能还有下面的这种情况，但其实是一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504205449853-253239433.png&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么这种情况是要旋转的轴心节点（18），还有左侧子节点，在旋转之后，&lt;strong&gt;18的左侧子节点13就会变成11的右侧子节点。其实可以简单的认为是左旋过后被节点11给“&lt;/strong&gt;挤”过来的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;其实，18的左侧子节点在旋转过后会成为11的右侧子节点还有一个原因，就是，&lt;strong&gt;18左侧子节点的值一定是大于11小于18的（旋转之前的图）&lt;/strong&gt;。为什么自己想。那么在旋转过后，它也一定是大于11的，所以它可以成为11的右侧子节点。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、LL情况的&lt;strong&gt;右旋转&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　那么LL情况的右旋转就没什么好说的了，跟RR情况是一样的，我们直接上图吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504210239188-943252077.png&quot; alt=&quot;&quot; width=&quot;813&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这绝壁没问题吧，原理都是一样的。只不过换了一个方向而已。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504210358940-1268146257.png&quot; alt=&quot;&quot; width=&quot;983&quot; height=&quot;405&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样没啥好说的了，对吧。下面我们看看其他地情况。双旋转......&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三、LR情况的&lt;strong&gt;左旋（RR）&lt;/strong&gt;再&lt;strong&gt;右旋（LL）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们还是直接上图，然后再解释，解释完这个RL情况的又不用再啰嗦了。挺好......挺省事，嘿嘿。&lt;/p&gt;
&lt;p&gt;　　其实让人有点懵逼的是名字，我特意加了个括号，希望你别懵逼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504212506581-669244102.png&quot; alt=&quot;&quot; width=&quot;1298&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不知道大家看没看懂，总感觉这图不是很友好啊，还有8节点的小瑕疵就不要在意了，反正都是虚线......还有指向节点10的那条线是虚线.....不影响.....嘿嘿。&lt;/p&gt;
&lt;p&gt;　　解释一下，我们需要双旋转的情况下，第一次旋转的是红框部分，也就是说，&lt;strong&gt;如果我们需要双旋转，两次旋转的轴心点是不一样的，第一次旋转的轴心是&lt;span&gt;插入节点的父节点&lt;span&gt;，而第二次旋转的轴心是&lt;span&gt;插入节点的祖父节点&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;大家一定要注意。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　那么这里可能会有一个疑问，就是8节点在第一次旋转过后，为什么会成为7节点的右侧子节点。这里十分重要，直接关系到你是否理解了AVL树的旋转。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　我们先看第一次旋转，如果插入的是8节点而不是10节点，那么在第一次左旋的时候，节点7会成为节点9的左侧子节点，而这个时候8节点是无处可去的，因为7占了我的位置，这咋整，不能因为一次平衡就删除我这个节点啊，节点8肯定不干，不然你插入我干啥.....哎？感觉有点不对劲.....额咳咳....咱们继续吧....而节点8这个位置一定比9小比7大，所以我们在旋转过后，让它成为7节点的右子节点就可以了。希望我说明白了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　那么这个时候可能还存在7节点有左侧子节点的情况，上面没画，没关系啊，你是7节点的左侧子节点，左旋转过后你还在原来的位置，没人占你的位置，你就不用动了。嗯，就这样.....完毕！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;四、RL情况的&lt;strong&gt;右旋（LL）&lt;/strong&gt;&lt;strong&gt;再&lt;/strong&gt;&lt;/span&gt;左&lt;strong&gt;旋（RR）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;其实这里真没啥好说的了，我一点都不解释，大家自己看，看不懂你就从头看！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1184971/201805/1184971-20180504215125824-1291387398.png&quot; alt=&quot;&quot; width=&quot;1209&quot; height=&quot;495&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　唉.......说了一大堆，终于可以到最后的代码了，&lt;span&gt;&lt;strong&gt;上代码！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是我们计算当前节点的高度的方法&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; heightNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有那就为-1&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果存在执行逻辑&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么说一下这里我的理解吧，Math.max比较左节点和右节点的大小，返回大的那个值，然后 + 1。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为什么要返回大的那个值呢？因为如果左节点存在，那么值为0（-1 + 1）；并且右节点是不存在的，那么右节点为-1。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;但是此时我们是有高度的，所以我们要选取有高度的那个节点，也就是值大的那一个。&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;那为什么要+1呢？因为高度只能为0不能为-1。-1是我们通过相减计算得到的，而不是计算高度得到的。记住这里是计算高度。&lt;/span&gt;
            console.log(Math.max(heightNode(node.left),heightNode(node.right)) + 1&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.max(heightNode(node.left),heightNode(node.right)) + 1&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RR:向左的单旋转&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; rotationRR = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp =&lt;span&gt; node.right;
        node.right &lt;/span&gt;=&lt;span&gt; tmp.left;
        tmp.left &lt;/span&gt;=&lt;span&gt; node;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LL:向右的单旋转&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; rotationLL = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp =&lt;span&gt; node.left;
        node.left &lt;/span&gt;=&lt;span&gt; tmp.right;
        tmp.right &lt;/span&gt;=&lt;span&gt; node;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LR:向右得到双旋转&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; rotationLR = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        node.left &lt;/span&gt;=&lt;span&gt; rotationRR(node.left);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotationLL(node);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;RL:向左的双旋转&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; rotationRL = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node) {
        node.right &lt;/span&gt;=&lt;span&gt; rorarionLL(node.right);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rorarionRR(node);
    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; balanceInsertNode = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (node,element) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果node的位置没有值，那么直接加入就好了。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            node &lt;/span&gt;=&lt;span&gt; newNode(element);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果假如的值是小于当前节点的话，说明我们要加在当前节点的左侧。&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(element &amp;lt;&lt;span&gt; node.key) {
            node.left &lt;/span&gt;=&lt;span&gt; insertNode(node.left,element);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么下面就要判断是否是null，如果是null，那么没问题，直接加上就好了。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(node.left !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不是，我们就要计算node的左侧高度减去右侧高度是否大于1，如果是，说明不平衡，需要来调用平衡方法来平衡。&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;((heightNode(node.left) - heightNode(node.right)) &amp;gt; 1&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前插入的节点的值小于node.left的值，说明是LL的情况，我们需要右旋。否则的话我们就需要先左旋，再右旋。&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;(element &amp;lt;&lt;span&gt; node.left.key) {
                        node &lt;/span&gt;=&lt;span&gt; rorarionLL(node);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        node &lt;/span&gt;=&lt;span&gt; rorarionLR(node);
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(element &amp;gt;&lt;span&gt; node.key) {
            node.right &lt;/span&gt;=&lt;span&gt; insertNode(node.right,element);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(node.right !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((heightNode(node.right) - heightNode(node.left)) &amp;gt; 1&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(element &amp;gt;&lt;span&gt; node.right.key) {
                        node &lt;/span&gt;=&lt;span&gt; rorarionRR(node);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        node &lt;/span&gt;=&lt;span&gt; rorarionRL(node);
                    }&lt;br/&gt;}
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　代码中多了一个balanceInsertNode方法，这个方法是需要替换我们前面写好的insertNode方法的，这样写是为了让大家更好的对比下。这些代码不像以前那样，写了一大堆的注释用来解释。其实要说的很多，都在前面的图和语言描述中说过了。所以大家看这个代码的时候。有不明白的地方，对照着前面的逻辑一点一点看，肯定就看明白了。比如rotationLL和rotationRR内部的替换以及为什么要这样替换，都在前面说过了。所以就不再在代码中啰嗦了。&lt;/p&gt;
&lt;p&gt;　　这一篇文章有点长，也花了我一点心思才完成。很重要，如果你想要对树有一个不错的了解，这些必须要会。我尽可能的用我理解的思路给大家讲解，如果有什么不清楚的地方，大家可以留言讨论。&lt;/p&gt;
&lt;p&gt;　　哦对了，本来还要跟大家说说其他树的，但是想了想也没什么必要，给大家一个链接，大家可以自行去做一些简单的了解，比如红黑树，堆积树，还有B树等等等等。种类很多。要想都讲完大概几十篇都不够，希望这两篇树结构的文章可以抛砖引玉。让大家提起对数据结构的兴趣。&lt;/p&gt;
&lt;p&gt;　　大家可以看一下这个了解&lt;a href=&quot;https://zh.wikipedia.org/wiki/AVL%E6%A0%91&quot; target=&quot;_blank&quot;&gt;https://zh.wikipedia.org/wiki/AVL%E6%A0%91&lt;/a&gt;，滑动到页底，你就能看到其他的树结构了。&lt;/p&gt;
&lt;p&gt;　　好了，终于，自平衡二叉搜索树到这里基本就结束了。下一部分会讲解最后一种也是最复杂的一种非线性数据结构——图。&lt;/p&gt;

&lt;p&gt;　　最后，&lt;strong&gt;由于本人水平有限，能力与大神仍相差甚远，若有错误或不明之处，还望大家不吝赐教指正。非常感谢！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 14:34:00 +0000</pubDate>
<dc:creator>Zaking</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaking/p/8976362.html</dc:identifier>
</item>
<item>
<title>继续死磕SDRAM控制器 - NingHeChuan</title>
<link>http://www.cnblogs.com/ninghechuan/p/8992683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ninghechuan/p/8992683.html</guid>
<description>&lt;h2&gt;SDRAM控制器&lt;/h2&gt;
&lt;p&gt;       博主上一篇介绍了一些SDRAM的基本原理&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/ninghechuan/p/8903938.html&quot;&gt;是否有必要学习使用纯Verilog写一个SDRAM控制器&lt;/a&gt;，接下来记录SDRAM控制器的工作原理。首先是上电初始化。&lt;/p&gt;
&lt;h2&gt;上电初始化&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214530880-1503814774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时序图中，tRP、tRC、这些时间参数可以从手册中找到，这里的系统时钟采用50Mhz。&lt;/p&gt;
&lt;p&gt;从初始化的时序图可以看出，首先在进行预充电（Precharge）命令之前要等待100us（手册要求是至少100us，我们设定延时200us），等待系统上电稳定和时钟稳定，然后对所有bank进行预充电（Precharge），经历一个trp（20ns，一个时钟周期，手册可以查询）时间，然后进行至少两次自刷新（Auto refresh）（我这里设置进行8次自刷新，），每次自刷新至少需要trc（63ns，四个时钟周期，手册查询）时间，最后进行模式寄存器（MODE register）的配置，需要tmrd（两个时钟周期）时间，初始化完成。&lt;/p&gt;
&lt;p&gt;预充电时当A10为高电平对所有的bank进行操作，当A10为低电平时对单个bank进行操作，BA0，BA1选择bank。我们这里预充电时对所有的bank操作，把A10置高即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214540592-795716570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214547992-1389575754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;SDRAM初始化流程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;上电后延时200us&lt;/li&gt;
&lt;li&gt;对所有的bank进行预充电（Precharge）&lt;/li&gt;
&lt;li&gt;8个自刷新操作，每次自刷新使用四个时钟周期&lt;/li&gt;
&lt;li&gt;进行模式寄存器的配置 ，配置完后输出初始化完成标志。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里先设置SDRAM的突发长度为4               Addr = 12’b0000_0110_0010&lt;/p&gt;
&lt;h4&gt;SDRAM初始化仿真&lt;/h4&gt;
&lt;p&gt;这里仿真需要用到SDRAM的仿真模型，通过仿真模型可以把当前SDRAM进行的操作打印出来，如果有错误也会提示错误，这时候再去查看波形时序。这里需要注意的是仿真的时候sdram_dqm信号必须和仿真模型连接，否则数据是写不进去的，设置sdram_dqm = 0就可以了。&lt;/p&gt;
&lt;p&gt;将SDRAM仿真模型添加进去后，要对放着模型的参数进行重定义&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214619802-2010736069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于各个参数的值，不同的SDRAM芯片的参数是不同的，具体根据手册而定，mem_sizes设置的是1个bank的容量。Verilog语法笔记：这种方式可以对例化模块里面已有的宏定义进行重定义，写法是defparam + 例化之后的模块名+ . +需要重定义名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214627482-1121142286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在transcript中输入run 200us，先跑200us等待系统上电稳定，在输入run 50us，如上图所示CAS Latency（列选通潜伏期）为3，burst length（突发长度）为4，burst type（突发类型）顺序（Sequrntial）执行，模式寄存器配置都按照我们设置的进行。&lt;/p&gt;
&lt;h2&gt;SDRAM工作原理&lt;/h2&gt;
&lt;p&gt;初始化模块设计完成后，对SDRAM已经有了一些简单的了解，下面先来看看SDRAM的工作原理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214647069-1576227981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;粗线——自动跳转，细线——受到命令后才能跳转（看不清楚图片点击阅读原文）&lt;/p&gt;
&lt;p&gt;从一个官方给的SDRAM手册的参考状态转移图看，我们可以简单写一下SDRAM的工作流程。这部分用状态机来实现最好不过了。&lt;/p&gt;
&lt;p&gt;上电后，给一个Precharge命令，进入Precharge状态，然后自动进入IDLE（初始化）状态，然后给自刷新命令，进入自刷新状态，自刷新完后回到IDLE状态，IDLE状态给一个配置模式寄存器命令，进入模式寄存器的配置，配置完后才能自动回到IDLE状态，然后进行读写状态的操作。&lt;/p&gt;
&lt;p&gt;以写操作为例，需要给一个行激发命令，进入行激发状态，给出写命令才能进入写状态，写完后自动返回行激发状态，给一次写命令，会写入一个突发长度的数据，在一行没有写完不需要跳回行激发状态，只需要继续给写命令，只有当一行写完或刷新请求来临或数据写完才会跳出写状态，这里后面设计写模块再讲。数据写完或刷新请求来临或数据写完，需要先进入预充电状态，给一次预充电命令，然后自动跳转到初始状态进行重新等待命令。至于读模块的操作和写模块是完全一样的，读者自行读图。&lt;/p&gt;
&lt;p&gt;这里要提的是图中有两个状态WRITEA和READA，这里我们不需要用到，如图也可以看到，这两个状态在进行一次读或写后会自动跳入预充电状态，从而回到初始化状态，这样和WRITE和READ这两个状态相比，读写速度肯定是会慢的，WRITE和READ可以连续给读写命令进行读写，所以直接忽略掉这两个状态不管。&lt;/p&gt;
&lt;h2&gt;仲裁机制&lt;/h2&gt;
&lt;p&gt;       这里要引出一个设计技巧，初始化完成后，进行自刷新和读写操作状态都是相互独立的，所以我们需要写一个状态机去完后这些状态之间的跳转，大概意思就如下图所示，写一个仲裁状态机，当SDRAM控制器要进行自刷新时，自刷新模块需要给一个刷新请求，仲裁状态收到后，就结束当前进行的状态，给一个刷新使能，刷新模块才会进行刷新操作。同样的，当SDRAM控制器要进行写数据时，写数据模块需要给一个写请求，仲裁状态收到后，就结束当前进行的状态，给一个写使能，写数据模块才会进行写操作。后面的模块相应的也是这样的设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214659870-1252278010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;刷新模块&lt;/h2&gt;
&lt;p&gt;手册规定SDRAM自刷新需在64ms内刷新4096次（不同型号的芯片对应的不同），必须64ms是因为SDRAM内部使用电容存储数据的，它保证不断电的时间就是64ms。4096次的意思是，我所使用的这款SDRAM芯片它的行地址为A0~A11，一共是12位，2的12次方一共是4096行，我们每给一次刷新命令实际上是刷新一行，且是四个bank同时刷新，所以说一共要刷新4096次。两次刷新间隔15us。刷新是在SDRAM初始化完成后就要开始进行刷新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214708328-1229574275.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;从时序图可以看出，先给一个precharge命令（一般都是对all bank进行操作），经过trp（20ns，一个周期）时间进行一次自刷新命令，再过trc时间，进行再一次自刷新命令，然后trc（63ns， 四个周期）时间后激发读或写命令。&lt;/p&gt;
&lt;p&gt;在时序图中我们看到了两次自刷新命令，但是实际上只要给一次自刷新命令即可，所以不要被时序图忽悠了，当然给两次也是没有什么关系的。这里的意思是，每次进行自刷新操作都需要给一次预充电即可。&lt;/p&gt;
&lt;h3&gt;刷新模块仿真&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214716057-991571163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仿真的时候发现我犯了一个错误，就是每15us的刷新操作是不用每次都给预充电（Percharge）命令，但是从另一个状态跳转到自刷新状态是需要给一个预充电（Percharge）命令。之后便不需要再给了，这上面这里的原因是因为在刷新模块里有预充电（Percharge）命令，所以每次状态跳转到执行刷新模块，都会给一个预充电（Percharge）命令。这个问题已经得到解决。如图每15us进行一个自刷新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504214721858-304578974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       关于SDRAM的读模块和写模块操作，下一篇再写。博主最近基于上次50Mhz下的简易SDRAM控制器的基础上修改成100Mhz的SDRAM控制器，实现用上位机串口发送一副彩色图片到SDRAM存储，再用VGA显示，下一步的目标是实现摄像头实时采集视频流数据显示。目前把最近写的这两个项目工程放到了Github上分享出来，希望能一起讨论，多多指点，这个东西我个人感觉不懂内部的操作时序，想要移植也是很麻烦的，所以干脆直接分享出来，后面博主会继续优化，尽量做成一个像IP Core一样的直接修改参数就可以调用的一个SDRAM控制器。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NingHeChuan/Open-FPGA.git&quot;&gt;https://github.com/NingHeChuan/Open-FPGA.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1057546/201805/1057546-20180504215344741-1000234809.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/1057546/201706/1057546-20170611114905559-478053885.jpg&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;289&quot;/&gt;&lt;/p&gt;

&lt;p&gt;转载请注明出处：NingHeChuan（宁河川）&lt;/p&gt;
&lt;p&gt;个人微信订阅号：开源FPGA&lt;/p&gt;
&lt;p&gt;如果你想及时收到个人撰写的博文推送，可以扫描左边二维码（或者长按识别二维码）关注个人微信订阅号&lt;/p&gt;
&lt;p&gt;知乎ID：&lt;a href=&quot;https://www.zhihu.com/people/zhu-he-chuan/activities&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微博ID：&lt;a href=&quot;http://weibo.com/6059461073/profile?rightmod=1&amp;amp;wvr=6&amp;amp;mod=personinfo&amp;amp;is_all=1&quot; target=&quot;_blank&quot;&gt;NingHeChuan&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 死磕SDRAM控制器（二）&quot; href=&quot;http://www.cnblogs.com/ninghechuan/p/8992683.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/ninghechuan/p/8992683.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 04 May 2018 14:31:00 +0000</pubDate>
<dc:creator>NingHeChuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ninghechuan/p/8992683.html</dc:identifier>
</item>
<item>
<title>C 标准库基础 IO 操作总结 - 肖邦linux</title>
<link>http://www.cnblogs.com/liwei0526vip/p/8992792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liwei0526vip/p/8992792.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;其实输入与输出对于不管什么系统的设计都是异常重要的，比如设计 C 接口函数，首先要设计好输入参数、输出参数和返回值，接下来才能开始设计具体的实现过程。C 语言标准库提供的接口功能很有限，不像 Python 库。不过想把它用好也不容易，本文总结 C 标准库基础 IO 的常见操作和一些特别需要注意的问题，如果你觉着自己还不是大神，那么请相信我，读完全文后你肯定会有不少收获。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一操作句柄&quot;&gt;一、操作句柄&lt;/h2&gt;
&lt;p&gt;打开文件其实就是在操作系统中分配一些资源用于保存该文件的状态信息及文件的标识，以后用户程序可以用这个标识做各种读写操作，关闭文件则释放占用的资源。&lt;/p&gt;
&lt;p&gt;打开文件的函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
FILE *fopen(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *path, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *mode);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;FILE 是 C 标准库定义的结构体类型，其包含文件在内核中的标识（文件描述符）、I／O 缓冲区和当前读写位置信息，调用者不需知道 FILE 的具体成员，由库函数内部维护，调用者不应该直接访问这些成员。像 FILE* 这样的文件指针称为句柄（Handle）。&lt;/p&gt;
&lt;p&gt;打开文件操作是对文件资源进行操作的，所以有可能打开文件失败，所以在打开函数时一定要判断返回值，如果失败则返回错误信息，以方便快速定位错误。&lt;/p&gt;
&lt;p&gt;打开文件应该与关闭文件成对存在，虽然程序在退出时会释放相应的资源，但是对于一个长时间运行服务程序来说，经常打开而不关闭文件是会造成进程资源耗尽的，因为进程的文件描述符个数是有限的，及时关闭文件是个好习惯。&lt;/p&gt;
&lt;p&gt;关闭文件的函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fclose(FILE *fp);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fopen 函数参数 mode 总结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&quot;r&quot;：只读，文件必须存在。&lt;/li&gt;
&lt;li&gt;&quot;w&quot;：只写，如果不存在则创建，存在则覆盖。&lt;/li&gt;
&lt;li&gt;&quot;a&quot;：追加，如果不存在则创建。&lt;/li&gt;
&lt;li&gt;&quot;r+&quot;：允许读和写，文件必须存在。&lt;/li&gt;
&lt;li&gt;&quot;w+&quot;：允许读和写，文件不存在则创建，存在则覆盖。&lt;/li&gt;
&lt;li&gt;&quot;a+&quot;：允许读和追加，文件不存在则创建。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二关于stdinstdoutstderr&quot;&gt;二、关于stdin/stdout/stderr&lt;/h2&gt;
&lt;p&gt;在用户程序启动时，main 函数还没开始执行之前，会自动打开三个 FILE* 指针分别是：stdin、stdout、stderr，这三个文件指针是 libc 中定义的全局变量，在 stdio.h 中声明，printf 向 stdout 写，而 scanf 从 stdin 读，用户程序也可以直接使用这三个文件指针。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stdin 只用于读操作，称为标准输入&lt;/li&gt;
&lt;li&gt;stdout 只用于写操作，称为标准输出&lt;/li&gt;
&lt;li&gt;stderr 也用于写操作，称为标准错误输出&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常程序的运行结果打印到标准输出，而错误提示打印到标准错误输出，一般标准输出和标准错误都是屏幕。通常可以标准输出重定向到一个常规文件，而标准错误输出仍然对应终端设备，这样就可以将运行结果与错误信息分开。&lt;/p&gt;
&lt;h2 id=&quot;三以字节为单位的io函数&quot;&gt;三、以字节为单位的IO函数&lt;/h2&gt;
&lt;p&gt;fgetc 函数从指定的文件中读一个字节，getchar从标准输入读一个字节，调用 getchar() 相当于 fgetc(stdin)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fgetc(FILE *stream);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; getchar(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fputc 函数向指定的文件写入一个字节，putchar 向标准输出写一个字节，调用 putchar() 相当于调用 fputc(c, stdout)。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fputc(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c, FILE *stream);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; putchar(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数和返回值类型为什么使用 int 类型？可以看到这几个函数的参数和返回值类型都是 int，而非 unsigned char 型。因为错误或读到文件末尾时将返回 EOF，即 -1，如果返回值是 unsigned char（0xff），与实际读到字节 0xff 无法区分，如果使用 int 就可以避免这个问题。&lt;/p&gt;
&lt;h2 id=&quot;四操作读写位置函数&quot;&gt;四、操作读写位置函数&lt;/h2&gt;
&lt;p&gt;当我们在操作文件时，有一个叫「文件指针」的家伙来记录当前操作的文件位置，比如刚打开文件，调用了 1 次 fgetc 后，此时文件指针指向了第 1 个字节后边，注意是以字节为单位记录的。&lt;/p&gt;
&lt;p&gt;改变文件指针位置的函数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fseek(FILE *stream, &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; offset, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; whence);
whence：从何处开始移动，取值：SEEK_SET | SEEK_CUR | SEEK_END
offset：移动偏移量，取值：可取正 | 负
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; rewind(FILE *stream);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举几个简单例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;fseek(fp, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;, SEEK_SET);     &lt;span class=&quot;co&quot;&gt;// 从文件头向后移动5个字节&lt;/span&gt;
fseek(fp, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, SEEK_CUR);     &lt;span class=&quot;co&quot;&gt;// 从当前位置向后移动6个字节&lt;/span&gt;
fseek(fp, -&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, SEEK_END);    &lt;span class=&quot;co&quot;&gt;// 从文件尾向前移动3个字节&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;offset 可正可负，负值表示向文件开头的方向移动，正值表示向文件尾方向移动，如果向前移动的字节数超过文件开头则出错返回，如果向后移动的字节数超过了文件末尾，再次写入会增加文件尺寸，文件空洞字节都是 0&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;$ echo &lt;span class=&quot;st&quot;&gt;&quot;5678&quot;&lt;/span&gt; &amp;gt; file.txt

fp = fopen(&lt;span class=&quot;st&quot;&gt;&quot;file.txt&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;r+&quot;&lt;/span&gt;);
fseek(fp, &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;, SEEK_SET);
fputc('K', fp)
fclose(fp)

&lt;span class=&quot;co&quot;&gt;// 通过结果可以看出字母K是从第10个位置开始写的&lt;/span&gt;
liwei:/tmp$ od -tx1 -tc -Ax file.txt 
&lt;span class=&quot;dv&quot;&gt;0000000&lt;/span&gt;    &lt;span class=&quot;dv&quot;&gt;35&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;36&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;37&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;38&lt;/span&gt;  0a  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  4b                    
           &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;   &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;   &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;   &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;  \n  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   K&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rewind(fp) 等价于 fseek(fp, 0, SEEK_SET)&lt;/p&gt;
&lt;p&gt;ftell(fp) 函数比较简单，直接返回当前文件指针在文件中的位置&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 实现计算文件字节数的功能&lt;/span&gt;
fseek(fp, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, SEEK_END);
ftell(fp);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;五以字符串为单位的io函数&quot;&gt;五、以字符串为单位的IO函数&lt;/h2&gt;
&lt;p&gt;fgets 从指定的文件中读一行字符到调用者提供的缓冲区，读入内容不超过 size 。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *fgets(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *s, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; size, FILE *stream);
&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *gets(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *s);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先要说明 gets() 函数强烈不推荐使用，类似 strcpy 函数，用户不可以指定缓冲区大小，很容易造成缓冲区溢出错误。不过 strcpy 程序员还是可以避免，而 gets 的输入用户可以提供任意长的字符串，唯一避免方法就是不使用 gets，而使用 fgets(buf, size, stdin)&lt;/p&gt;
&lt;p&gt;fgets 函数从 stream 所指文件读取以 '\n' 结尾的一行，包括 '\n' 在内，存到缓冲区中，并在该行结尾添加一个 '\0' 组成完整的字符串。如果文件一行太长，fgets 从文件中读了 size-1 个字符还没有读到 '\n'，就把已经读到的 size-1 个字符和一个 '\0' 字符存入缓冲区，文件行剩余的内容可以在下次调用 fgets 时继续读。&lt;/p&gt;
&lt;p&gt;若一次 fgets 调用在读入若干字符后到达文件末尾，则将已读到的字符加上 '\0' 存入缓冲区并返回，如果再次调用则返回 NULL，可以据此判断是否读到文件末尾。&lt;/p&gt;
&lt;p&gt;fputs 向指定文件写入一个字符串，缓冲区保存的是以 '\0' 结尾的字符串，与 fgets 不同的是，fputs 不关心字符串中的 '\n' 字符。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fputs(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *s, FILE *stream);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; puts(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *s);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;六以记录为单位的io函数&quot;&gt;六、以记录为单位的IO函数&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;size_t fread(&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *ptr, size_t size, size_t nmemb, FILE *stream);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fread 和 fwrite 用于读写记录，这里的记录是指一串固定长度的字节，比如一个 int、一个结构体货或一个定长数组。&lt;/p&gt;
&lt;p&gt;参数 size 指出一条记录的长度，nmemb 指出要读或写多少条记录，这些记录在 ptr 所指内存空间连续存放，共占 size * nmemb 个字节。&lt;/p&gt;
&lt;p&gt;fread 和 fwrite 返回的记录数有可能小于 nmemb 指定的记录数。例如当读写位置距文件末尾只有一条记录长度，调用 fread 指定 nmemb 为 2，则返回值为 1。如果写文件时出错，则 fwrite 的返回值小于 nmemb 指定的值。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; t{
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;   a;
    &lt;span class=&quot;dt&quot;&gt;short&lt;/span&gt; b;
};
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; t val = {&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;};
FILE *fp = fopen(&lt;span class=&quot;st&quot;&gt;&quot;file.txt&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;w&quot;&lt;/span&gt;);
fwrite(&amp;amp;val, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(val), &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, fp);
fclose(fp);

liwei:/tmp$ od -tx1 -tc -Ax file.txt 
&lt;span class=&quot;dv&quot;&gt;0000000&lt;/span&gt;    &lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;02&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;  &lt;span class=&quot;dv&quot;&gt;00&lt;/span&gt;                                
         &lt;span class=&quot;dv&quot;&gt;001&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;002&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;  \&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从结果可以看出，写入的是 8 个字节，有兴趣的同学可以就此分析下系统的「大小端」和结构体的「对齐补齐」问题。&lt;/p&gt;
&lt;h2 id=&quot;七格式化io函数&quot;&gt;七、格式化IO函数&lt;/h2&gt;
&lt;h3 id=&quot;printf-scanf&quot;&gt;(1). printf / scanf&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; printf(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; scanf(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个函数是我们学习 C 语言最早接触，可能也是接触比较多的了，没什么特别要说的。printf 就是格式化打印到标准输出。下面总结下 printf 常用的方式。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;printf(&lt;span class=&quot;st&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;);            &lt;span class=&quot;co&quot;&gt;// 打印整数 5&lt;/span&gt;
printf(&lt;span class=&quot;st&quot;&gt;&quot;-%10s-&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;hello&quot;&lt;/span&gt;)   &lt;span class=&quot;co&quot;&gt;// 设置显示宽度并左对齐：-     hello-&lt;/span&gt;
printf(&lt;span class=&quot;st&quot;&gt;&quot;-%-10s-&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;hello&quot;&lt;/span&gt;)  &lt;span class=&quot;co&quot;&gt;// 设置显示宽度并右对齐：-     hello-&lt;/span&gt;
printf(&lt;span class=&quot;st&quot;&gt;&quot;%#x&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;bn&quot;&gt;0xff&lt;/span&gt;);        &lt;span class=&quot;co&quot;&gt;// 0xff 不加#则显示ff&lt;/span&gt;
printf(&lt;span class=&quot;st&quot;&gt;&quot;%p&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, main);         &lt;span class=&quot;co&quot;&gt;// 打印 main 函数首地址&lt;/span&gt;
printf(&lt;span class=&quot;st&quot;&gt;&quot;%%&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;);               &lt;span class=&quot;co&quot;&gt;// 打印一个 %&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;scanf 就是从标准输入中读取格式化数据，简单举个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; year, month, day;
scanf(&lt;span class=&quot;st&quot;&gt;&quot;%d/%d/%d&quot;&lt;/span&gt;, &amp;amp;year, &amp;amp;month, &amp;amp;day);
printf(&lt;span class=&quot;st&quot;&gt;&quot;year = %d, month = %d, day = %d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, year, month, day);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;sprintf-sscanf-snprintf&quot;&gt;(2). sprintf / sscanf / snprintf&lt;/h3&gt;
&lt;p&gt;sprintf 并不打印到文件，而是打印到用户提供的缓冲区中并在末尾加 '\0'，由于格式化后的字符串长度很难预计，所以很可能造成缓冲区溢出，强烈推荐 snprintf 更好一些，参数 size 指定了缓冲区长度，如果格式化后的字符串超过缓冲区长度，snprintf 就把字符串截断到 size - 1 字节，再加上一个 '\0'，保证字符串以 '\0' 结尾。如果发生截断，返回值是截断之前的长度，通过对比返回值与缓冲区实际长度对比就知道是否发生截断。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sscanf(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *str, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sprintf(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *str, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; snprintf(&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *str, size_t size, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sscanf 是从输入字符串中按照指定的格式去读取相应的数据，函数功能非常的强大，支持类似正则表达式匹配的功能。具体的使用格式请自行查询官方手册，这里总结出最常用、最重要的几种使用场景和方式。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;最基本的用法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; buf[&lt;span class=&quot;dv&quot;&gt;1024&lt;/span&gt;] = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
sscanf(&lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, buf);
printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：123456&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;取指定长度的字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;123456&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%4s&quot;&lt;/span&gt;, buf);
printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：1234&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;取第1个字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;hello world&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%s&quot;&lt;/span&gt;, buf);
printf(&lt;span class=&quot;st&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：hello  因为默认是以空格来分割字符串的，%s读取第一个字符串hello&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;读取到指定字符为止的字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;123456#abcdef&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%[^#]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：123456&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// %[^#]表示读取到#符号停止，不包括#&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;读取仅包含指定字符集的字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;123456abcdefBCDEF&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%[1-9a-z]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：123456abcdef&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 表达式是要匹配数字和小写字母，匹配到大写字母就停止匹配了。&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;读取指定字符集为止的字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;123456abcdefBCDEF&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%[^A-Z]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：123456abcdef&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;读取两个符号之间的内容(@和.之间的内容)&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;liwei0526vip@linuxblogs.cn&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%*[^@]@%[^.]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：linuxblogs&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 先读取@符号前边内容并丢弃，然后读@，接着读取.符号之前的内容linuxblogs，不包含字符.&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;给一个字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%*s%s&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：world&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 先忽略一个字符串&quot;hello,&quot;，遇到空格直接跳过，匹配%s，保存 world 到 buf&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// %*s 表示第 1 个匹配到的被过滤掉，即跳过&quot;hello,&quot;，如果没有空格，则结果为 NULL&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;稍微复杂点的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;ABCabcAB=&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%*[A-Z]%*[a-z]%[^a-z=]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：AB  自己尝试分析哈&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;包含特殊字符处理&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;sscanf(&lt;span class=&quot;st&quot;&gt;&quot;201*1b_-cdZA&amp;amp;&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;%[0-9|_|--|a-z|A-Z|&amp;amp;|*]&quot;&lt;/span&gt;, buf);
&lt;span class=&quot;co&quot;&gt;// 结果为：201*1b_-cdZA&amp;amp;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果能将上述几个例子搞明白，相信基本上已经掌握了 sscanf 的用法，实践才是检验真理的唯一标准，只有多使用，多思考才能真正理解它的用法。&lt;/p&gt;
&lt;h3 id=&quot;fprintf-fscanf&quot;&gt;(3). fprintf / fscanf&lt;/h3&gt;
&lt;p&gt;fprintf 打印到指定的文件 stream 中，fscanf 从文件中格式化读取数据，类似 scanf 函数。相关函数的声明如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fprintf(FILE *stream, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fscanf(FILE *stream, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *format, ...);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还是通过简单实例来说明基本用法。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;FILE *fp = fopen(&lt;span class=&quot;st&quot;&gt;&quot;file.txt&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;w&quot;&lt;/span&gt;);
fprintf(fp, &lt;span class=&quot;st&quot;&gt;&quot;%d-%s-%f&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span class=&quot;fl&quot;&gt;0.12&lt;/span&gt;);
fclose(fp);

liwei:/tmp$ cat file.txt 
&lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;-hello&lt;span class=&quot;fl&quot;&gt;-0.120000&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而 fscanf 函数的使用基本上与 sscanf 函数使用方式相同。&lt;/p&gt;
&lt;h2 id=&quot;八io缓冲区&quot;&gt;八、IO缓冲区&lt;/h2&gt;
&lt;p&gt;还有个关于 IO 非常重要的概念，就是 IO 缓冲区。&lt;/p&gt;
&lt;p&gt;C 标准库为每个打开的文件分配一个 I/O 缓冲区，用户调用读写函数大多数都在 I/O 缓冲区中读写，只有少数请求传递给内核。&lt;/p&gt;
&lt;p&gt;以 fgetc／fputc 为例，当第一次调用 fgetc 读一个字节时，fgetc 函数可能通过系统调用进入内核读 1k 字节到缓冲区，然后返回缓冲区中第一个字节给用户，以后用户再调用 fgetc，就直接从缓冲区读取。&lt;/p&gt;
&lt;p&gt;另一方面，fputc 通常只是写到缓冲区中，如果缓冲区满了，fputc 就通过系统调用把缓冲区数据传递给内核，内核将数据写回磁盘。如果希望把缓冲区数据立即写入磁盘，可以调用 fflush 函数。&lt;/p&gt;
&lt;p&gt;C 标准库 IO 缓冲区有三种类型：全缓冲、行缓冲和无缓冲区，不同类型的缓冲区具有不同的特性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;全缓冲&lt;/code&gt;：如果缓冲区写满了就写回内核。常规文件通常是全缓冲的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;行缓冲&lt;/code&gt;：如果程序写的数据中有换行符就把这一行写回内核，或者缓冲区满就写回内核。标准输入和标准输出对应终端设备时通常是行缓冲的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;无缓冲&lt;/code&gt;：用户程序每次调用库函数做写操作都要通过系统调用写回内核。标准错误输出通常是无缓冲的，用户程序的错误信息可以尽快输出到设备。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;printf(&lt;span class=&quot;st&quot;&gt;&quot;hello world&quot;&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
&lt;span class=&quot;co&quot;&gt;// 运行程序会发现屏幕并没有打印hello world&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 因为缓冲区没满，且没有\n符号&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了写满缓冲区、写入换行符之外，行缓冲还有一种情况会自动做 flush 操作，如果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户程序调用库函数从无缓冲的文件中读取&lt;/li&gt;
&lt;li&gt;或从行缓冲的文件中读取，且这次读操作会引发系统调用从内核读取数据，那么会读之前自动 flush 所有行缓冲&lt;/li&gt;
&lt;li&gt;程序退出时通常也会自动 flush 缓冲区&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果不想完全依赖自动的 flush 操作，可以调用 fflush 函数手动操作。若调用 fflush(NULL) 可以对所有打开文件的 IO 缓冲区做 flush 操作。缓冲区大小也可以自定义设置，一般情况无需设置，默认即可。&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注公众号-linuxblogs&quot;&gt;欢迎关注公众号: 「linuxblogs」&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yVibDjicRT1VsV0RH8KV6zMUhvJIajBDGibNAM19nKibia5Ae59EOnic3MJNrhJYdXOPqpVLXAvnr4ICAaZTBhW1JUxA/0?wx_fmt=jpeg&quot; alt=&quot;微信二维码&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 14:15:00 +0000</pubDate>
<dc:creator>肖邦linux</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liwei0526vip/p/8992792.html</dc:identifier>
</item>
<item>
<title>python--Numpy and Pandas 基本语法 - 渔单渠</title>
<link>http://www.cnblogs.com/yudanqu/p/python_numpy_pandas.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudanqu/p/python_numpy_pandas.html</guid>
<description>&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;numpy和pandas是python进行数据分析的非常简洁方便的工具，话不多说，下面先简单介绍一些关于他们入门的一些知识。下面我尽量通过一些简单的代码来解释一下他们该怎么使用。以下内容并不是系统的知识体系，我只是尽可能把最基础的知识点列写一下。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、numpy&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、array&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy
&lt;/span&gt;2 list_1 = [1,2,3,4&lt;span&gt;]
&lt;/span&gt;3 array_1 = numpy.array(list_1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一维数组&lt;/span&gt;
4 list_2 = [4,5,6,7&lt;span&gt;]
&lt;/span&gt;5 array_2 = numpy.array([list_1,list_2]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 二维数组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; array_2.shape &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看数组特征，eg：2行4列&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; array_2.size &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看元素个数, eg:8&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; array_2.dtype &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看数组类型，eg：int64&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：numpy.arange(n) #与python中的range区别是前面有个a&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; numpy.zeros(s) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 全0矩阵，s可以为一个数也可以为一个列表，eg：[2,3]表示2*3的二维数组&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; numpy.eye(a) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单位矩阵，生成的是浮点数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;访问数组中元素：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　一维：array_1[2] 、array_1[1:4]&lt;br/&gt;　　二维：array_2[1][2] 、array_2[1,2] 、array_2[:1,1:4]&lt;/p&gt;
&lt;p&gt;　　其中可以根据python中列表的切片来访问数据&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、数组与矩阵运算&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;~~数组array&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; numpy.random.randn(10) &lt;span&gt;# &lt;/span&gt;&lt;span&gt;十个元素的一维数组&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; numpy.random.randint(10,size=20).reshape(4,5) &lt;span&gt;# &lt;/span&gt;&lt;span&gt;产生20个10以内的随机整数，后面的reshape是将这些数重新写成一个4*5的二维数组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;数组之间维度相同可以直接进行加减乘除（除数不能为0）&lt;/li&gt;
&lt;li&gt;numpy.unique(array_1) # 找到里面所有的数但不重复&lt;/li&gt;
&lt;li&gt;sum:二维数组中对每一列求和 sum(array_2)
&lt;ul&gt;&lt;li&gt;sum(array_2[0) 对第一行求和&lt;/li&gt;
&lt;li&gt;sum(array_2[:,0] 对第一列求和&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;array_2.max() #求最大值，对某行某列求则同sum&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;~~矩阵matric&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; numpy.mat([1,2,3],[4,5,6]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成一个二维矩阵&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; numpy.mat(array_1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将数组转换成矩阵&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：矩阵之间维度相同可以直接进行加减运算，而乘除运算需要行和列交叉对应，参照线性代数中的知识。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3、input和output:&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; f = open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x.pkl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;序列化到硬盘&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;pickle&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pickle
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; pickle.dump(x,f) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 产生pkl文件&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; pickle.load(f) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取pkl文件&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;numpy本身的工具&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; numpy.save(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one_array&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,x)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; numpy.load(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;one_array.npy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; numpy.savez(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;two_array.npz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,a=x,b=y) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对多个进行操作，进行压缩储存&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; c = numpy.load(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;two_array.npz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取文件&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; c[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一个文件&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; c[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第二个文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;1、Series&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;下面是创建Series的三种方法&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;方法1：s1 = pd.Series([1,2,3,4]) &lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;方法2：s2 = pd.Series(np.arange(10)) # 通过numpy.arange创建&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;方法3：s3 = pd.Series({'1':1,'2':2,'3':3}) # 通过字典创建&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; s1.values &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看值&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; s1.index &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看索引&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; s4 = pa.Series([1,2,3,4],index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置索引&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; s4.to_dict() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转化成字典&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; pd.isnull(s4) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;判断其中元素是否为NaN，pd.notnull()同理&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、DataFrame&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; pandas &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Series,DataFrame
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过粘贴板导入dataframe&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; df = pd.read_clipboard() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在此之前需要你copy一个表&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; df.columns  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出列名&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; df.&lt;span&gt;'&lt;/span&gt;&lt;span&gt;列名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出列的数值(是一个Series)&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; df_new = DataFrame(df,columns=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;列名1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;列名2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; s1 = pd.Series(df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;列名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出这一列，dataframe的每一列是一个series&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; s1.index\values 即对series操作，或者通过s1[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;索引值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;df1.iterrows() #返回一个生成器，可以用for循环来访问
&lt;ul&gt;&lt;li&gt;eg: for row in df1.iterrows():&lt;/li&gt;
&lt;li&gt;print(row) #返回的数据为一个tuple&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;s1,s2,s3为3个Series，用其组成一个人dataframe：
&lt;ul&gt;&lt;li&gt;df_new = pd.DataFrame([s1,s2,s3],index=['A','B','C'])&lt;/li&gt;
&lt;li&gt;　　# index是每个Series的名称&lt;/li&gt;
&lt;li&gt;　　# 初始是按横向拼接成的dataframe&lt;/li&gt;
&lt;li&gt;　　df1 = df1.T #转置，转置之后就和直接用dataframe生成的一样了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1、从粘贴板读取&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df1 =&lt;span&gt; pd.read_clipboard()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; df1.to_clipboard() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入粘贴板&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2、CSV文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df1.to_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;名字.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,index=False) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; false则表示不添加索引号&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; df2 = pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df1.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取CSV文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3、json&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df1.to_json() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转化成json文件&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; pd.read_json(df1.to_json()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取json文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4、html&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df1.to_html(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df1_html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转换成HTML文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5、excel&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df1.to_excel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df1.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成Excel文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df.head() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回前五行&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; df.tail() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回后五行&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回更多的内容则在括号中写出来，不写则默认为五行&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; df.iloc[:,:] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;索引切片，定位，基于index，与索引名无关&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; df.loc[:,:] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据索引名来，label来过滤&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Reindex:&lt;/h2&gt;
&lt;h3&gt;~~series&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; s1.reindex(index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],fill_value=10&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; fill_value 是指当重新写的index中有原来没有的，那么他本身输出为NaN，fill值为添加到这个索引下的值&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个新Series，另一种赋值的方法&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; s2 = Series([&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],index=[1,5,10&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; s2.reindex(index=range(15)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成15个索引的Series，除了原有的其他的都是NaN&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; s2.reindex(index=range(15)，method=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ffill&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在上一步的基础上，按顺序将上一个value填充到他下面的几个中（forward fill）&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; s1.drop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表示删除A的内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;~~dataframe&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个5*5的，通过numpy进行reshape&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; df1 = DataFrame(np.random.rand(25).reshape([5,5]),index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],colums=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c4&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遗漏的index中的C，通过reindex来恢复&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; df1.reindex(index=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; C被恢复并把value填充为NaN&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; columns 同理&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当index减少时就表现出切割的现象&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; df1.drop(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,axis=0) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; axis=0，代表删除行；axis=1，代表删除列（后面遇到axis同样是这个意思）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;n = np.nan
&lt;ul&gt;&lt;li&gt;type(n) 是个浮点数float&lt;/li&gt;
&lt;li&gt;与nan的运算结果均是nan&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;nan in series：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;s1.isnull\notnull() 判断是否为nan&lt;/li&gt;
&lt;li&gt;s1.dropna() # 删除掉value为NaN的行&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;nan in dataframe：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;判断同series&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; df.dropna(axis=0,how=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;any&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;，thresh=None) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; axis表示行和列0,1来表示,how为any时表示有Nan就删掉，为all时表示全为nan时才删掉；thresh表示一个界限，超过这个数字的nan则被删掉&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; df.fillna(value=1) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表示所有为nan的地方填充为1&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; df.fillna(value={0:0,1:1,2:2,3:3}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 表示第一列的填充1，第二列的填充2，后面同理&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注：dropna,fillna不改变原始数组&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;index=[['1','1','1','2','2','2'],['a','b','c','a','b','c']] # 1,2为一级标题，abc为二级标题，即1的series下有abc，原始series下有1,2；获取内容时，可以s1['1']['a']&lt;/li&gt;
&lt;li&gt;s1[:,'a'] 返回所有一级series里的a&lt;/li&gt;
&lt;li&gt;与dataframe的转换：
&lt;ul&gt;&lt;li&gt;df1 = s1.unstack()&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;逆转换：
&lt;ul&gt;&lt;li&gt;s2 = df1.unstack() # 这时一二级换了位置&lt;/li&gt;
&lt;li&gt;s2 = df1.T.unstack() # 这时是和原始完全一样的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注：dataframe的index和columns都可以转换成多级的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;当想在一个dataframe中加一列(columns)，可以直接加df['列名']=Series([数据])&lt;br/&gt;也可以通过map：创建一个字典，字典中的键是dataframe中的columns：&lt;br/&gt;df1['新列名'] = df1['字典中的键那一列'].map(那个字典) 这个可以固定对应位置，方便改值，可以指定index来改值&lt;/p&gt;
&lt;h3&gt;replace in series:&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; s1.replace({1,np.nan}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过字典来改值&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; s1.replace([1,2,3],[10,20,30]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把123索引改成10,20,30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;em&gt;以上内容是我的一点点总结，希望能给有需要的朋友带来带你帮助，也希望有大神来指点指点。&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 May 2018 13:07:00 +0000</pubDate>
<dc:creator>渔单渠</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudanqu/p/python_numpy_pandas.html</dc:identifier>
</item>
</channel>
</rss>