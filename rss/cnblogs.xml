<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>快速入门vue-cli配置 - 手撕黄油</title>
<link>http://www.cnblogs.com/caideyipi/p/8496656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caideyipi/p/8496656.html</guid>
<description>&lt;div readability=&quot;65&quot;&gt;
&lt;pre&gt;
const path = require('path'&lt;span&gt;)
const utils &lt;/span&gt;= require('./utils'&lt;span&gt;)
const config &lt;/span&gt;= require('../config'&lt;span&gt;)
const vueLoaderConfig &lt;/span&gt;= require('./vue-loader.conf'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;resolve这个函数返回的是当前目录下&quot;../dir&quot;这个文件夹，__dirname指的是当前文件所在路径&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; resolve (dir) {  &lt;span&gt;return&lt;/span&gt; path.join(__dirname, '..'&lt;span&gt;, dir)}

module.exports &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回项目的根路径  &lt;/span&gt;
    context: path.resolve(__dirname, '../'&lt;span&gt;),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;入口文件  &lt;/span&gt;
&lt;span&gt;    entry: {    
      app: &lt;/span&gt;'./src/main.js'&lt;span&gt;  
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出口文件  &lt;/span&gt;
&lt;span&gt;    output: {   
        path: config.build.assetsRoot,    
        filename: &lt;/span&gt;'[name].js'&lt;span&gt;,    
        publicPath: process.env.NODE_ENV &lt;/span&gt;=== 'production'      
        ?&lt;span&gt; config.build.assetsPublicPath      
        : config.dev.assetsPublicPath  
    },  
    resolve: {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动解析扩展，比如引入对应的文件，js,vue,json的后缀名就可以省略了    &lt;/span&gt;
        extensions: ['.js', '.vue', '.json'&lt;span&gt;],    
        alias: {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;精准匹配，使用vue来替代vue/dist/vue.esm.js      &lt;/span&gt;
            'vue$': 'vue/dist/vue.esm.js'&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用@替代src路径，当你引入src下的文件是可以使用import XXfrom &quot;@/xx&quot;&lt;/span&gt;
            '@': resolve('src'&lt;span&gt;),    
        }  
    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一些loader配置，避免篇幅过长我省略一部分，大家可以看自己的文件 &lt;/span&gt;
&lt;span&gt;    module: {    
        rules: [     
            {        
                test: &lt;/span&gt;/\.vue$/&lt;span&gt;,        
                loader: &lt;/span&gt;'vue-loader'&lt;span&gt;,        
                options: vueLoaderConfig      
            },      
            {        
                test: &lt;/span&gt;/\.js$/&lt;span&gt;,        
                loader: &lt;/span&gt;'babel-loader'&lt;span&gt;,        
                include: [resolve(&lt;/span&gt;'src'), resolve('test'), resolve('node_modules/webpack-dev-server/client'&lt;span&gt;)]      
            },      
            ......    
        ]  
    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;node里的这些选项是都是Node.js全局变量和模块，这里主要是防止webpack注入一些Node.js的东西到vue中  &lt;/span&gt;
&lt;span&gt;    node: {    
        setImmediate: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,    
        dgram: &lt;/span&gt;'empty'&lt;span&gt;,    
        fs: &lt;/span&gt;'empty'&lt;span&gt;,    
        net: &lt;/span&gt;'empty'&lt;span&gt;,    
        tls: &lt;/span&gt;'empty'&lt;span&gt;,    
        child_process: &lt;/span&gt;'empty'&lt;span&gt;  
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;74&quot;&gt;
&lt;pre&gt;
const utils = require('./utils'&lt;span&gt;)
const webpack &lt;/span&gt;= require('webpack'&lt;span&gt;)
const config &lt;/span&gt;= require('../config'&lt;span&gt;)
const merge &lt;/span&gt;= require('webpack-merge'&lt;span&gt;)
const path &lt;/span&gt;= require('path'&lt;span&gt;)
const baseWebpackConfig &lt;/span&gt;= require('./webpack.base.conf'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个负责拷贝资源的插件&lt;/span&gt;
const CopyWebpackPlugin = require('copy-webpack-plugin'&lt;span&gt;)

const HtmlWebpackPlugin &lt;/span&gt;= require('html-webpack-plugin'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个更友好的展示webpack错误提示的插件&lt;/span&gt;
const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个自动检索端口的包&lt;/span&gt;
const portfinder = require('portfinder'&lt;span&gt;)

const HOST &lt;/span&gt;= process.env.HOSTconst PORT = process.env.PORT &amp;amp;&amp;amp;&lt;span&gt; Number(process.env.PORT)

const devWebpackConfig &lt;/span&gt;=&lt;span&gt; merge(baseWebpackConfig, {  
    module: {    
        rules: utils.styleLoaders({ 
            sourceMap: config.dev.cssSourceMap,
            usePostCSS: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt; 
        })  
    },  
    
    devtool: config.dev.devtool,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; devServer的配置大家看文档就好了 &lt;/span&gt;
&lt;span&gt;    devServer: {    
        clientLogLevel: &lt;/span&gt;'warning'&lt;span&gt;,    
        historyApiFallback: {      
            rewrites: [        
                { from: &lt;/span&gt;/.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html'&lt;span&gt;) },      
            ],    
        },    
        hot: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,    
        contentBase: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,   
        compress: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,    
        host: HOST &lt;/span&gt;||&lt;span&gt; config.dev.host,    
        port: PORT &lt;/span&gt;||&lt;span&gt; config.dev.port,    
        open: config.dev.autoOpenBrowser,   
        overlay: config.dev.errorOverlay      
        &lt;/span&gt;? { warnings: &lt;span&gt;false&lt;/span&gt;, errors: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; }      
        : &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,    
        publicPath: config.dev.assetsPublicPath,    
        proxy: config.dev.proxyTable,    
        quiet: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,    
        watchOptions: {      
            poll: config.dev.poll,    
        }  
    },  
    plugins: [
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还记得之前说的生产环境和开发环境的变量在哪儿定义的吗？对，就是这里    &lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DefinePlugin({      
            process.env: require(&lt;/span&gt;'../config/dev.env'&lt;span&gt;)    
        }),

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块热替换的插件，修改模块不需要刷新页面    &lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.HotModuleReplacementPlugin(),

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当使用HotModuleReplacementPlugin时，这个插件会显示模块正确的相对路径    &lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.NamedModulesPlugin(),

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在编译出错时，使用NoEmitOnErrorsPlugin来跳过输出阶段，这样可以确保输出资源不会包含错误&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.NoEmitOnErrorsPlugin(),   
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; HtmlWebpackPlugin({      
            filename: &lt;/span&gt;'index.html'&lt;span&gt;,      
            template: &lt;/span&gt;'index.html'&lt;span&gt;,      
            inject: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;    
        }),    

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将static文件夹和里面的内容拷贝到开发模式下的路径,比如static下有个img文件夹，里面有张图片&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们可以这样访问：localhost:8080/static/img/logo.png    &lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CopyWebpackPlugin([     
            {        
                from: path.resolve(__dirname, &lt;/span&gt;'../static'&lt;span&gt;),        
                to: config.dev.assetsSubDirectory,        
                ignore: [&lt;/span&gt;'.*'&lt;span&gt;]      
            }    
        ])  
    ]
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里主要是做端口的检索以及npm run dev后对错误的处理，我们可以看这里使用了前面引入的&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;'friendly-errors-webpack-plugin'插件&lt;/span&gt;
module.exports = &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
  portfinder.basePort &lt;/span&gt;= process.env.PORT ||&lt;span&gt; config.dev.port
  portfinder.getPort((err, port) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      reject(err)
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; publish the new Port, necessary for e2e tests&lt;/span&gt;
      process.env.PORT =&lt;span&gt; port
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; add port to devServer config&lt;/span&gt;
      devWebpackConfig.devServer.port =&lt;span&gt; port

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add FriendlyErrorsPlugin&lt;/span&gt;
      devWebpackConfig.plugins.push(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FriendlyErrorsPlugin({
        compilationSuccessInfo: {
          messages: [`Your application is running here: http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;${devWebpackConfig.devServer.host}:${port}`],&lt;/span&gt;
&lt;span&gt;        },
        onErrors: config.dev.notifyOnErrors
        &lt;/span&gt;?&lt;span&gt; utils.createNotifierCallback()
        : undefined
      }))

      resolve(devWebpackConfig)
    }
  })
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;15.5&quot;&gt;
&lt;div readability=&quot;26&quot;&gt;
&lt;p&gt;关于devServer有两点要说明一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;contentBase是来告诉服务器在哪里提供静态的内容，这里我们使用false的原因是使用了“copy-webpack-plugin”插件，不需要使用contentBase了；&lt;/li&gt;
&lt;li&gt;quiet开启后(true)，除了初始启动信息之外的任何内容都不会被打印到控制台，即使是webpack 的错误或警告在控制台也不可见。不过我们用了'friendly-errors-webpack-plugin'插件，就可以设为true了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;6.webpack.prod.conf.js &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过前面这么多代码的分析，其实webpack.prod.conf.js的配置已经很简单了，大致跟webpack.dev.conf.js的配置方式差不多，就是多了几个plugins：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UglifyJsPlugin是用来压缩JS代码&lt;/li&gt;
&lt;li&gt;optimize-css-assets-webpack-plugin是用来压缩css代码&lt;/li&gt;
&lt;li&gt;HashedModuleIdsPlugin会根据模块的相对路径生成一个四位数的hash作为模块id&lt;/li&gt;
&lt;li&gt;ModuleConcatenationPlugin可以预编译所有模块到一个包中，加快浏览器的运行速度&lt;/li&gt;
&lt;li&gt;CommonsChunkPlugin拆分公共模块，vue里拆分了vendor，manifest和app三个模块&lt;/li&gt;
&lt;li&gt;compression-webpack-plugin gzip压缩&lt;/li&gt;
&lt;li&gt;webpack-bundle-analyzer可以查看打包的具体情况，比如打了多少个包，每个包多大等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了，plugins的介绍到此结束，接下来就是最后一个文件，也是npm run build编译时的入口文件——build.js了。&lt;/p&gt;
&lt;p&gt;同样的，build.js文件其实也没什么可说的了，无非就是执行webpack.prod.conf.js文件，遇到错误时在命令行提示。需要注意的是，build.js里引入了“rimraf”的包，它的作用是每次编译时清空dist文件，避免多次编译时造成文件夹的重复和混乱。&lt;/p&gt;
&lt;h3 data-id=&quot;heading-3&quot;&gt;四.结尾&lt;/h3&gt;
&lt;p&gt;到这里其实关于Vue-cli配置的分析基本结束了，相信了解webpack的朋友看起来一定非常简单，配置主要麻烦的地方在于低耦合导致经常需要来回翻文件才能看懂配置，如果大家结合着文章开头的脑图看可能会相对容易些。&lt;/p&gt;
&lt;p&gt;一个坏消息是这个文章发布的时候webpack4.0已经上线了，Vue-cli新版也进入了Beta测试阶段，所以这篇文章大家看看就好，了解一下思路，马上配置又会更新的......&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 03 Mar 2018 06:36:00 +0000</pubDate>
<dc:creator>手撕黄油</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caideyipi/p/8496656.html</dc:identifier>
</item>
<item>
<title>理解Activity.runOnUiThread() - vHow</title>
<link>http://www.cnblogs.com/vhow/p/8496551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vhow/p/8496551.html</guid>
<description>&lt;p&gt;这是一篇译文（&lt;strong&gt;中英对照&lt;/strong&gt;），原文链接：&lt;a href=&quot;https://medium.com/@yossisegev/understanding-activity-runonuithread-e102d388fe93&quot;&gt;Understanding Activity.runOnUiThread()&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;When developing Android applications we always have to be mindful about our application Main Thread.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在开发Android应用时，经常需要对&lt;strong&gt;UI线程&lt;/strong&gt;倍加留意。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;The Main Thread is busy dealing with everyday stuff such as drawing our UI, responding to user interactions and generally, by default, executing (most) of the code we write.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;UI线程很忙，忙着绘制界面，忙着响应用户操作，忙着执行App程序员编写的&lt;strong&gt;多数&lt;/strong&gt;代码。&lt;/p&gt;
&lt;p&gt;译注：&lt;strong&gt;多数&lt;/strong&gt;？——App程序员打交道最多的Activity、Service等组件的回调函数都在UI线程中运行。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;A good developer knows she/he needs to off load heavy tasks to a worker Thread to avoid clogging the Main Thread and allow a smoother user experience and avoid ANR.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个优秀的开发者，需要知道如何创建&lt;strong&gt;工作线程&lt;/strong&gt;来完成&lt;strong&gt;耗时操作&lt;/strong&gt;——不能事事都麻烦UI线程——这样做既能让用户获得更流畅的体验，也能避免ANR。&lt;/p&gt;
&lt;p&gt;译注：&lt;strong&gt;流畅&lt;/strong&gt;？——UI线程的负担轻了，才能够专心绘制UI，才能够及时处理用户的输入事件。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;But, when the time comes to update the UI we must “return” to the Main Thread, as only he’s allowed to touch and update the application UI.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是，还是得从工作线程返回到UI线程，毕竟只有UI线程才能更新UI。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;A common way to achieve this is to call the Activity’s runOnUiThread() method:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如何返回呢？——常用方法是调用Activity的&lt;code&gt;runOnUiThread()&lt;/code&gt;：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;runOnUiThread&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// 在这里更新UI&lt;/span&gt;
    }
});&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;This will magically cause the Runnable code to get executed on the Main Thread.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的代码很神奇，它能把&lt;code&gt;Runnable&lt;/code&gt;中的代码放到UI线程之中去执行。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Magical things are great… but only outside of our app source code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;神奇的东西好啊，但代码可不能神奇。&lt;/p&gt;
&lt;p&gt;译注：“神奇”的代码，意味着不了解，不靠谱，不值得依赖。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;In this blog post, I will try to shed some light on what is actually going on inside &lt;code&gt;runOnUiThread()&lt;/code&gt; and (hopefully) ruin the magic.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇博客，我会尽力解开&lt;code&gt;runOnUiThread&lt;/code&gt;的面纱，让它不再神奇。&lt;/p&gt;
&lt;h2 id=&quot;打破神奇&quot;&gt;打破神奇&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Let‘s peek at the relevant parts of the Activity source code:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Activity中的相关源码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// android.app.Activity&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Handler mHandler = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Handler();

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Thread mUiThread;

&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;runOnUiThread&lt;/span&gt;(Runnable action) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;() != mUiThread) {
        mHandler.&lt;span class=&quot;fu&quot;&gt;post&lt;/span&gt;(action);
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        action.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Seems pretty straightforward, first we check if the current Thread we’re running on is the Main Thread.&lt;br/&gt;If it is the Main Thread — Great! Just invoke the Runnable &lt;code&gt;run()&lt;/code&gt; method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看起来挺直观的。首先，检查当前线程是否是UI线程。如果是，直接调用其&lt;code&gt;run()&lt;/code&gt;方法。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;But what if it’s not the Main Thread? In that case, we call &lt;code&gt;mHandler.post()&lt;/code&gt; and pass in our Runnable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但如果不是呢？就调用&lt;code&gt;mHandler.post()&lt;/code&gt;，并传入Runnable对象。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;So what is actually happening here? Before we can answer that we really should talk about something called a Looper.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体发生了什么？在回答这个问题之前，我们需要先来看一下&lt;code&gt;Looper&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;looper&quot;&gt;Looper&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;When we create a new Java Thread we override its &lt;code&gt;run()&lt;/code&gt; method. A simple Thread implementation could look like that:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Java中，可以创建一个Thread对象并覆写其&lt;code&gt;run()&lt;/code&gt;方法。像这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyThread &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Thread {
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// Do stuff&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Take a good look at that &lt;code&gt;run()&lt;/code&gt; method, when the Thread finishes executing every statement inside of it, the Thread is Done. Finished. Useless.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看看&lt;code&gt;run()&lt;/code&gt;方法，当其中指令执行完毕，线程也就终止了。除非…&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;If we want to reuse a Thread (a good reason would be to avoid spawning new Threads and reduce our memory footprint) we have to keep him alive and waiting for new instructions. A common way to achieve this is to create a loop inside the Thread’s &lt;code&gt;run()&lt;/code&gt; method:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想重用线程（既可以避免切换线程所需的开销，又能节省内存），就得让线程保持存活，并等待和执行新的指令。常见的做法是在&lt;code&gt;run()&lt;/code&gt;方法中创建一个循环：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyThread &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Thread {
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (running) {
            &lt;span class=&quot;co&quot;&gt;// Do stuff&lt;/span&gt;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;As long as the while loop is running (ie: The &lt;code&gt;run()&lt;/code&gt; method hasn’t finished yet) — that Thread is staying alive.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只要循环尚未终止，线程就保持存活。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;That’s exactly what a Looper is doing: The Looper is.. well, LOOPING, and keeping its Thread alive.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是Looper所做的事：Looper，循环器，循环，保持线程存活。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Some things about the Looper worth mentioning:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Threads don’t get a Looper by default.&lt;/li&gt;
&lt;li&gt;You can create and attach a Looper to a Thread.&lt;/li&gt;
&lt;li&gt;There can only be one Looper per Thread.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;关于Looper，请注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认情况下，线程没有Looper&lt;/li&gt;
&lt;li&gt;你可以为线程创建一个与之关联的Looper&lt;/li&gt;
&lt;li&gt;每个线程最多只能有一个Looper&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;So, Let’s go ahead and replace the while loop with a Looper implementation:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在，用&lt;code&gt;Looper&lt;/code&gt;替换上面的&lt;code&gt;for&lt;/code&gt;循环方案：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyThread &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Thread {
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
        Looper.&lt;span class=&quot;fu&quot;&gt;prepare&lt;/span&gt;();
        Looper.&lt;span class=&quot;fu&quot;&gt;loop&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;This is actually really simple:&lt;br/&gt;上面的代码很简单：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Calling &lt;code&gt;Looper.prepare()&lt;/code&gt; checks if there is no Looper already attached to our Thread (remember, only one Looper per Thread) and then creating and attaching a Looper.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调用&lt;code&gt;Looper.prepare()&lt;/code&gt;，如果尚未有Looper附着于此线程，就创建一个Looper，并且和此线程相关联。（提醒：每个线程只能有一个Looper）&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Calling &lt;code&gt;Looper.loop()&lt;/code&gt; cause our Looper to start looping.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调用&lt;code&gt;Looper.loop()&lt;/code&gt;，开启循环。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;So, Now the Looper is looping and keeping our Thread alive, but there is no point in keeping a Thread alive without passing in instructions, work, things for our Thread to actually do…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前，Looper持续循环并保持线程存活。但是，如果不能接受指令，不做事情，这又是何必呢。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Luckily, the Looper isn’t just looping. When we created the Looper a work queue was created with him. That queue is called the MessageQueue because he holds &lt;strong&gt;Message&lt;/strong&gt; objects.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;幸好，Looper不止是循环运行。当创建Looper对象的时候，一个与之关联的队列也被创建了。因为这个队列是用来持有&lt;strong&gt;消息&lt;/strong&gt;对象的，所以叫做&lt;strong&gt;消息队列&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;消息&quot;&gt;消息&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;These Message objects are actually sets of &lt;strong&gt;instructions&lt;/strong&gt;. They can hold data such as Strings and integers or they can hold tasks AKA Runnables.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这些消息对象是一些指令，它们能够携带数据（例如字符串、整数等），也能够携带Runnable任务。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;So, when a Message enters Thread’s Looper Message queue, and when the Message turn (it is a &lt;strong&gt;queue&lt;/strong&gt; after all) has come — The Message instructions are executed &lt;strong&gt;on that very Thread&lt;/strong&gt;. Which means that…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，当一个消息对象被加到了线程Looper的消息队列之后，等它出队的时候，线程就会执行/处理这个消息。也就是说…&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;If we want a Runnable to be executed on a specific Thread, all we have to do is to put that Runnable into a Message and add that Message to the Thread’s Looper Message queue!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想让一个Runnable任务在特定的线程中执行，我们需要做的就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把&lt;strong&gt;Runnable&lt;/strong&gt;封装到一个&lt;strong&gt;消息&lt;/strong&gt;对象里&lt;/li&gt;
&lt;li&gt;把消息加入到线程Looper&lt;strong&gt;消息队列&lt;/strong&gt;之中&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Great! How do we do that? That’s Easy. We use a &lt;strong&gt;Handler&lt;/strong&gt;. (You can see where this is going, right?)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好，具体怎么做呢？——用&lt;strong&gt;Handler&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;handler&quot;&gt;Handler&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;The Handler is doing all the hard work.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Handler做了所有的重活儿。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;He is responsible for adding Messages to a Looper’s queue and when their time has come he is responsible for executing the same Messages on the Looper’s Thread.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他（Handler）负责：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加消息。向消息队列中添加消息。&lt;/li&gt;
&lt;li&gt;执行消息。在Looper线程中处理/执行这条消息。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;When a Handler is created he is pointed toward a specific Looper. (ie: pointed toward a specific Thread)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当Handler被创建的时候，他指向一个特定的Looper。（也就指向一个特定的线程）&lt;/p&gt;
&lt;p&gt;译注：Handler → 线程 → Looper → 消息队列&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;There are two ways to create a Handler:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有两种创建Handler的方式：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;(1) Specify its Looper in the constructor:&lt;/p&gt;&lt;p&gt;&lt;code&gt;Handler handler = new Handler(Looper looper);&lt;/code&gt;&lt;/p&gt;&lt;p&gt;Now the handler is pointed toward the Looper (actually, the Looper MessageQueue) we provided.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一、在构造函数中指定Looper&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Handler handler = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Handler(Looper looper); &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个&lt;code&gt;handler&lt;/code&gt;对象就指向传入的&lt;code&gt;looper&lt;/code&gt;（其实是looper的消息队列）。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;(2) Use empty constructor:&lt;/p&gt;&lt;p&gt;&lt;code&gt;Handler handler = new Handler();&lt;/code&gt;&lt;/p&gt;&lt;p&gt;When using the empty constructor the Handler will automatically point toward the Looper attached to the current Thread. How convenient!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二、使用空构造函数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Handler handler = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Handler();&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，这个&lt;code&gt;handler&lt;/code&gt;自动指向和关联到当前的线程。多方便啊！&lt;/p&gt;
&lt;p&gt;译注：谁创建的归谁。例如，如果是在Activity中&lt;code&gt;new Handler()&lt;/code&gt;，那构建出来的Handler对象就和UI线程相关联。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;The Handler has convenience methods to create Messages and automatically add them to its Looper queue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Handler提供了一些便捷的方法，可以创建消息对象，并自动把它们加入到消息队列之中。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;For example, the &lt;code&gt;post()&lt;/code&gt; method creates a Message and add it to the end of the Looper’s queue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如，&lt;code&gt;post()&lt;/code&gt;方法会创建一个消息，并把它追加到消息队列（队尾）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;If we want this Message to hold a task (a Runnable) we simply pass the Runnable into the &lt;code&gt;post()&lt;/code&gt; call:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你希望这个消息携带一个任务（Runnable），只传入Runnable：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;handler.&lt;span class=&quot;fu&quot;&gt;post&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Runnable() {
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// Do stuff...&lt;/span&gt;
    }
});&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;面熟不？&lt;/p&gt;
&lt;h2 id=&quot;再看activity源码&quot;&gt;再看Activity源码&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Now we can take a slightly more educated look at &lt;code&gt;runOnUiThread()&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过之前的学习，再来看&lt;code&gt;runOnUiThread()&lt;/code&gt;源码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// android.app.Activity&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Handler mHandler = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Handler();

&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Thread mUiThread;

&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;runOnUiThread&lt;/span&gt;(Runnable action) {
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;() != mUiThread) {
        mHandler.&lt;span class=&quot;fu&quot;&gt;post&lt;/span&gt;(action);
    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
        action.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;First, a Handler is created with an empty constructor.&lt;br/&gt;Remember: this code is executed on the Main Thread.&lt;br/&gt;That means mHandler is pointed toward the Main Thread Looper.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，通过空构造函数创建了一个Handler对象。注意，这个代码是在UI线程上执行的，所以&lt;code&gt;mHandler&lt;/code&gt;指向UI线程的Looper。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Yes, The application Main Thread is the only Thread we get with a Looper attached to him by default.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是的，UI线程自带Looper。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;So… when this line is getting executed:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，当这行代码执行的时候：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;mHandler.&lt;span class=&quot;fu&quot;&gt;post&lt;/span&gt;(action);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;The Handler is creating a Message that holds our Runnable, and that Message is then added to the Main Thread Looper’s queue, Where it will stay until the Handler will execute it on its Looper Thread — &lt;strong&gt;The Main Thread&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Handler会：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个&lt;strong&gt;消息&lt;/strong&gt;（携带着传入的Runnable）&lt;/li&gt;
&lt;li&gt;把这个消息添加到&lt;strong&gt;UI线程&lt;/strong&gt;的Looper的&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;等轮到这个消息时，&lt;strong&gt;UI线程&lt;/strong&gt;会执行/处理它&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;That’s it! No more magic.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上，不再神奇。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Mar 2018 06:06:00 +0000</pubDate>
<dc:creator>vHow</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vhow/p/8496551.html</dc:identifier>
</item>
<item>
<title>剑指offer面试题-Java版-持续更新 - ik-heu</title>
<link>http://www.cnblogs.com/ik-heu/p/8462025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ik-heu/p/8462025.html</guid>
<description>&lt;p&gt;&lt;span&gt;最近在用Java刷剑指offer（第二版）的面试题。书中原题的代码采用C++编写，有些题的初衷是为了考察C++的指针、模板等特性，这些题使用Java编写有些不合适。但多数题还是考察通用的算法、数据结构以及编程思想等，与语言本身无太大关系。因此在选择编程语言时，我还是选择了Java。好吧，主要是我C++不怎么会，仅仅是曾经学过俩月，使用Java顺手一些。后续可能再用Python刷一遍。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;面试题3  数组中重复的数字&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;题目一：找出数组中重复的数字&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;描述：在长度为n的数组里所有数字都在0~n-1范围内。数组中某些数字是重复的，请找出任意一个重复的数字。如数组｛2, 3, 1, 0, 2, 5, 3｝，输出的重复的数字为2或3。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;思路：利用数组的索引在0~n-1这个范围的性质，将数字i移至索引i的位置。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;考点：对数组的理解以及对问题的分析能力。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;题目二：不修改数组找出重复的数字&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;描述：在长度为n+1的数组里所有数字都在1~n范围内。找出重复的数字，但不修改数组。&lt;/li&gt;
&lt;li&gt;思路：当然可完全利用题目一的方法，只是需要辅助空间。不需要辅助空间是最好的了。这里使用二分法，对数组进行计数，逐渐缩小重复的数字所处的范围。&lt;/li&gt;
&lt;li&gt;考点：对二分查找的灵活应用，毕竟写出正确无误的二分法时有些难度的。同时要重视与面试官的沟通，明确需求，如是否能更改数组，是否可以使用辅助空间等。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; sword_offer;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;page 39 数组中重复的数字&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution3 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;题目1
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出数组中重复的数字，空间复杂度O(1)，时间复杂度O(n)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组长度为n，数字在0~n-1范围内&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; duplicate(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arr.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(i);&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (arr[i] !=&lt;span&gt; i) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr[i] ==&lt;span&gt; arr[arr[i]])
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr[i];
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt; arr[i];
                    arr[i] &lt;/span&gt;=&lt;span&gt; arr[temp];
                    arr[temp] &lt;/span&gt;=&lt;span&gt; temp;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(Arrays.toString(arr));&lt;/span&gt;
&lt;span&gt;                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;题目2
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出数组中重复的数字，空间复杂度O(1)，时间复杂度O(nlog(n))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组长度为n+1，数字在1~n范围内，要求不修改数组，并不使用辅助空间&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; myGetDuplication(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; start = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; middle = arr.length / 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; end =&lt;span&gt; middle;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(end &amp;gt;=&lt;span&gt; start) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;&quot; + start + end);&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arr.length; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr[i] &amp;gt;= start &amp;amp;&amp;amp; arr[i] &amp;lt;= end) count++&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (end ==&lt;span&gt; start) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;gt; 1&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; start;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;gt; end - start + 1&lt;span&gt;) {
                middle &lt;/span&gt;= (start + end) / 2&lt;span&gt;;
                end &lt;/span&gt;=&lt;span&gt; middle;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                start &lt;/span&gt;= middle + 1&lt;span&gt;;
                end &lt;/span&gt;= arr.length - 1&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出数组中重复的数字，空间复杂度O(1)，时间复杂度O(nlog(n))
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组长度为n+1，数字在1~n范围内，要求不修改数组，并不使用辅助空间
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比上一个函数逻辑清晰一点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getDuplication(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; start = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; end = arr.length - 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(end &amp;gt;=&lt;span&gt; start) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; middle = (end - start) / 2 + start;
            &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; getCount(arr, start, middle);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (end ==&lt;span&gt; start) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;gt; 1&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; start;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;gt; middle - start + 1&lt;span&gt;) {
                end &lt;/span&gt;=&lt;span&gt; middle;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                start &lt;/span&gt;= middle + 1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1;
&lt;span&gt;    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算数组arr元素处在[start, end]范围内元素个数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getCount(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; end) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; arr.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr[i] &amp;gt;= start &amp;amp;&amp;amp; arr[i] &amp;lt;= end) count++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr = {1, 2, 3, 1&lt;span&gt;};
        System.out.println(duplicate(arr));
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr2 = {2, 3, 5, 4, 3, 2, 6, 7&lt;span&gt;};
        System.out.println(myGetDuplication(arr2));
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] arr3 = {2, 3, 5, 4, 3, 2, 6, 7&lt;span&gt;};
        System.out.println(getDuplication(arr3));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt; 面试题4  二维数组中的查找&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;描述：二维数组中，数字按从左到右、从上到下的顺序递增。给定一个整数，判断该数组中是否含有该整数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;思路：从数组的右上角或左下角开始进行查找数据，缩小可能包含该数的范围。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;考点：画图分析问题，寻求问题的突破口。并能正确编写程序，避免死循环等问题。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，从二维数组$\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{1}&amp;amp;{2}&amp;amp;{8}&amp;amp;9 \\ &lt;br/&gt;{1}&amp;amp;{4}&amp;amp;{9}&amp;amp;{12} \\ &lt;br/&gt;{4}&amp;amp;{7}&amp;amp;{10}&amp;amp;{13} \\ &lt;br/&gt;{6}&amp;amp;{8}&amp;amp;{11}&amp;amp;{15} &lt;br/&gt;\end{array}} \right]$中寻找是否包含数字7。&lt;/p&gt;
&lt;p&gt;从右上角查找时，逐渐向左下方缩小范围。红色的代表包含目标值7的区域，过程如下：&lt;/p&gt;
&lt;p&gt;$$\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{\color{red}1}&amp;amp;{\color{red}2}&amp;amp;{\color{red}8}&amp;amp;9 \\&lt;br/&gt;{\color{red}1}&amp;amp;{\color{red}4}&amp;amp;{\color{red}9}&amp;amp;{12} \\&lt;br/&gt;{\color{red}4}&amp;amp;{\color{red}7}&amp;amp;{\color{red}{10}}&amp;amp;{13} \\&lt;br/&gt;{\color{red}6}&amp;amp;{\color{red}8}&amp;amp;{\color{red}{11}}&amp;amp;{15}&lt;br/&gt;\end{array}} \right]\to\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{\color{red}1}&amp;amp;{\color{red}2}&amp;amp;{8}&amp;amp;9 \\&lt;br/&gt;{\color{red}1}&amp;amp;{\color{red}4}&amp;amp;{9}&amp;amp;{12} \\&lt;br/&gt;{\color{red}4}&amp;amp;{\color{red}7}&amp;amp;{10}&amp;amp;{13} \\&lt;br/&gt;{\color{red}6}&amp;amp;{\color{red}8}&amp;amp;{11}&amp;amp;{15}&lt;br/&gt;\end{array}} \right]\to\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{1}&amp;amp;{2}&amp;amp;{8}&amp;amp;9 \\&lt;br/&gt;{\color{red}1}&amp;amp;{\color{red}4}&amp;amp;{9}&amp;amp;{12} \\&lt;br/&gt;{\color{red}4}&amp;amp;{\color{red}7}&amp;amp;{10}&amp;amp;{13} \\&lt;br/&gt;{\color{red}6}&amp;amp;{\color{red}8}&amp;amp;{11}&amp;amp;{15}&lt;br/&gt;\end{array}} \right]\to\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{1}&amp;amp;{2}&amp;amp;{8}&amp;amp;9 \\&lt;br/&gt;{1}&amp;amp;{4}&amp;amp;{9}&amp;amp;{12} \\&lt;br/&gt;{\color{red}4}&amp;amp;{\color{red}7}&amp;amp;{10}&amp;amp;{13} \\&lt;br/&gt;{\color{red}6}&amp;amp;{\color{red}8}&amp;amp;{11}&amp;amp;{15}&lt;br/&gt;\end{array}} \right]$$&lt;/p&gt;
&lt;p&gt;从左下角查找时，逐渐向右上方缩小范围。过程如下：&lt;/p&gt;
&lt;p&gt;$$\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{1}&amp;amp;{\color{red}2}&amp;amp;{\color{red}8}&amp;amp;{\color{red}9} \\ &lt;br/&gt;{1}&amp;amp;{\color{red}4}&amp;amp;{\color{red}9}&amp;amp;{\color{red}{12}} \\ &lt;br/&gt;{4}&amp;amp;{\color{red}7}&amp;amp;{\color{red}{10}}&amp;amp;{\color{red}{13}} \\ &lt;br/&gt;{6}&amp;amp;{\color{red}8}&amp;amp;{\color{red}{11}}&amp;amp;{\color{red}{15}} &lt;br/&gt;\end{array}} \right]\to\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;{1}&amp;amp;{\color{red}2}&amp;amp;{\color{red}8}&amp;amp;{\color{red}9} \\ &lt;br/&gt;{1}&amp;amp;{\color{red}4}&amp;amp;{\color{red}9}&amp;amp;{\color{red}{12}} \\ &lt;br/&gt;{4}&amp;amp;{\color{red}7}&amp;amp;{\color{red}{10}}&amp;amp;{\color{red}{13}} \\ &lt;br/&gt;{6}&amp;amp;{8}&amp;amp;{11}&amp;amp;{15} &lt;br/&gt;\end{array}} \right]$$&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; sword_offer;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;page 44 二维数组中的查找&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution4 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从右上角的元素开始查找，逐渐缩小范围&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; findNum(&lt;span&gt;int&lt;/span&gt;[][] arr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; target) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; found = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; row = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; col = arr[0].length - 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (col &amp;gt; 0 &amp;amp;&amp;amp; row &amp;lt;=&lt;span&gt; arr.length) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; diff = arr[row][col] -&lt;span&gt; target;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (diff == 0&lt;span&gt;) {
                found &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (diff &amp;gt; 0&lt;span&gt;) 
                col&lt;/span&gt;--&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
                row&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; found;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[][] arr = {{1,2,8,9},{2,4,9,12},{4,7,10,13},{6,8,11,15&lt;span&gt;}};
        System.out.println(findNum(arr, &lt;/span&gt;9&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;面试题5  替换空格&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;描述：将字符串中的每个空格替换成%20。如输入&quot;we are fine&quot;，输出&quot;we%20are%20fine&quot;。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;思路：原题考察了C++中指针的操作。Java里数组不可变，因此本题变得没有难度了。利用String对象的.charAt函数遍历每个字符，并&lt;/span&gt;&lt;/span&gt;&lt;span&gt;使用StringBuilder构建新的字符串。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;考点：对字符串的处理。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; sword_offer;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;page 51 替换空格&lt;/span&gt;

&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution5 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在Java中字符串时不可变的，因而只能构造一个新的字符串。原文中该题的难点也无法体现出来了。&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String replaceBlank(String str) {
        StringBuilder strb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; str.length(); i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (str.charAt(i) == ' '&lt;span&gt;) {
                strb.append(&lt;/span&gt;&quot;%20&quot;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
                strb.append(str.charAt(i));
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; strb.toString();
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        String str &lt;/span&gt;= &quot;We are happr.&quot;&lt;span&gt;;
        System.out.println(replaceBlank(str));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;面试题6  从尾到头打印链表&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;描述：输入一个链表的头节点，从尾到头打印每个节点的值。&lt;/li&gt;
&lt;li&gt;思路：从尾到头打印，即为“先进后出”，则可以使用栈来处理；考虑递归的本质也是一个栈结构，可递归输出。&lt;/li&gt;
&lt;li&gt;考点：对链表、栈、递归的理解。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; sword_offer;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;page 58 从尾到头打印链表&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Stack;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ListNode{
    ListNode next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution6 {
        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法1：使用Stack栈的先push后pop&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printListReverse(ListNode listNode) {
        Stack&lt;/span&gt;&amp;lt;ListNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;ListNode&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(listNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            stack.push(listNode);
            listNode &lt;/span&gt;=&lt;span&gt; listNode.next;
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;stack.isEmpty()) {
            System.out.println(stack.pop().value);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法2：使用递归的方式，相当于从内部往外部推&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printListReverse_rec(ListNode listNode) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(listNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (listNode.next != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                printListReverse_rec(listNode.next);
            System.out.println(listNode.value);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ListNode ln1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListNode();
        ListNode ln2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListNode();
        ListNode ln3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListNode();
        ln1.next &lt;/span&gt;=&lt;span&gt; ln2;
        ln2.next &lt;/span&gt;=&lt;span&gt; ln3;
        ln1.value &lt;/span&gt;= 1&lt;span&gt;;
        ln2.value &lt;/span&gt;= 2&lt;span&gt;;
        ln3.value &lt;/span&gt;= 3&lt;span&gt;;
        printListReverse_rec(ln1);
        printListReverse(ln1);        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;面试题7  重建二叉树&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;描述：输入某二叉树的前序遍历和中序遍历结果，重建该二叉树。假设前序遍历或中序遍历的结果中无重复的数字。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;思路：前序遍历的第一个元素为根节点的值，据此将中序遍历数组拆分为左子树+root+右子树，前序遍历数组拆分为root+左子树+右子树。再对左右子树进行同样的操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;考点：对二叉树不同遍历方法的掌握。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285395/201803/1285395-20180303000350734-2051132774.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; sword_offer;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;page 62 重建二叉树

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二叉树类，包含左右子树，以及用于查看的方法&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BinaryTreeNode {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
    BinaryTreeNode leftNode;
    BinaryTreeNode rightNode;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中序遍历输出查看&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printList() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (leftNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            leftNode.printList();
        System.out.println(value);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rightNode != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            rightNode.printList();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution7 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重建二叉树函数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BinaryTreeNode rebultTree(&lt;span&gt;int&lt;/span&gt;[] preorder, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] inorder) {
        BinaryTreeNode root &lt;/span&gt;= rebultTree(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重写函数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; BinaryTreeNode rebultTree(&lt;span&gt;int&lt;/span&gt;[] preorder, &lt;span&gt;int&lt;/span&gt; startPre, &lt;span&gt;int&lt;/span&gt; endPre, &lt;span&gt;int&lt;/span&gt;[] inorder, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; startIn,
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; endIn) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (startPre &amp;gt; endPre || startIn &amp;gt;&lt;span&gt; endIn)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        BinaryTreeNode root &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryTreeNode();
        root.value &lt;/span&gt;=&lt;span&gt; preorder[startPre];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = startIn; i &amp;lt;= endIn; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (inorder[i] ==&lt;span&gt; preorder[startPre]) {
                root.leftNode &lt;/span&gt;= rebultTree(preorder, startPre + 1, startPre + i - startIn, inorder, startIn, i - 1&lt;span&gt;);
                root.rightNode &lt;/span&gt;= rebultTree(preorder, startPre + i - startIn + 1, endPre, inorder, i + 1&lt;span&gt;, endIn);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] preorder = { 1, 2, 4, 7, 3, 5, 6, 8&lt;span&gt; };
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] inorder = { 4, 7, 2, 1, 5, 3, 8, 6&lt;span&gt; };
        BinaryTreeNode root &lt;/span&gt;=&lt;span&gt; rebultTree(preorder, inorder);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(root.leftNode.rightNode.value);&lt;/span&gt;
&lt;span&gt;        root.printList();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt; &lt;/strong&gt;面试题8  二叉树的下一个节点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;描述：给定一棵二叉树和其中的一个节点，找出中序遍历序列的下一个节点。树中应定义指向左节点、右节点、父节点的三个变量。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;思路：该节点若存在右节点，右子树的最左节点则为下一节点；若不存在右节点，则向上遍历，直至找到是父节点的左节点的那个节点，该节点的父节点则为下一节点。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;考点：对中序遍历的理解。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; sword_offer;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;page 65 二叉树的下一个节点

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义二叉树类，包含左右子树、父节点，以及用于查看的函数&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TreeNode {
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; value;
    TreeNode left;
    TreeNode right;
    TreeNode father;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中序遍历输出查看&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; printList() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            left.printList();
        System.out.println(value);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            right.printList();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution8 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; TreeNode findNext(TreeNode node) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有右节点，找到右子树的最左节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (node.right!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            node &lt;/span&gt;=&lt;span&gt; node.right;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(node.left != &lt;span&gt;null&lt;/span&gt;) node =&lt;span&gt; node.left;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无右节点，则向上遍历，直至找到节点为父节点的左子节点&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(node.father != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.father.left == node) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node.father;
            node &lt;/span&gt;=&lt;span&gt; node.father;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立一个二叉树节点的数组，并tree[i].value赋值&lt;/span&gt;
        TreeNode[] tree = &lt;span&gt;new&lt;/span&gt; TreeNode[9&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] chars = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'&lt;span&gt;};
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; tree.length; i++&lt;span&gt;) {
            tree[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TreeNode();
            tree[i].value &lt;/span&gt;=&lt;span&gt; chars[i];
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         *        a
         *      /   \
         *     b     c
         *    / \   / \
         *   d   e  f  g
         *      / \
         *     h   i
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左右节点关系&lt;/span&gt;
        tree[0].left = tree[1&lt;span&gt;];
        tree[&lt;/span&gt;0].right = tree[2&lt;span&gt;];
        tree[&lt;/span&gt;1].left = tree[3&lt;span&gt;];
        tree[&lt;/span&gt;1].right = tree[4&lt;span&gt;];
        tree[&lt;/span&gt;2].left = tree[5&lt;span&gt;];
        tree[&lt;/span&gt;2].right = tree[6&lt;span&gt;];
        tree[&lt;/span&gt;4].left = tree[7&lt;span&gt;];
        tree[&lt;/span&gt;4].right = tree[8&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父节点关系&lt;/span&gt;
        tree[1].father = tree[0&lt;span&gt;];
        tree[&lt;/span&gt;2].father = tree[0&lt;span&gt;];
        tree[&lt;/span&gt;3].father = tree[1&lt;span&gt;];
        tree[&lt;/span&gt;4].father = tree[1&lt;span&gt;];
        tree[&lt;/span&gt;5].father = tree[2&lt;span&gt;];
        tree[&lt;/span&gt;6].father = tree[2&lt;span&gt;];
        tree[&lt;/span&gt;7].father = tree[4&lt;span&gt;];
        tree[&lt;/span&gt;8].father = tree[4&lt;span&gt;];
        
        tree[&lt;/span&gt;0&lt;span&gt;].printList();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;面试题9  两个栈实现队列&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;描述：使用两个栈实现一个队列。队列中实现尾部插入和头部删除函数。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;思路：栈结构“先进后出”，插入数据时进入第一个栈；删除数据时，将第一个栈的所有数据都弹出到第二个栈，这时原先先插入的数据位于栈的顶端。即可满足队列的“先进先出”。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;考点：对栈和队列的理解；对泛型的使用等。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1285395/201803/1285395-20180303003639010-637165035.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; sword_offer;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;page 68 两个栈实现队列&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Stack;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列类，包含两个栈、两个操作队列的方法&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Queue &amp;lt;T&amp;gt;&lt;span&gt;{
    Stack&lt;/span&gt;&amp;lt;T&amp;gt; stack1 = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;&lt;span&gt;();
    Stack&lt;/span&gt;&amp;lt;T&amp;gt; stack2 = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入节点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; appendTail(T element) {
        stack1.push(element);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除节点&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T deleteHead(){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stack2.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;stack1.isEmpty()) {
                T data &lt;/span&gt;=&lt;span&gt; stack1.pop();
                stack2.push(data);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;为空时，输出异常&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stack2.isEmpty())
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;queue is empty&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stack2.pop();
        
    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution9 {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Queue&lt;/span&gt;&amp;lt;Integer&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; Queue&amp;lt;&amp;gt;&lt;span&gt;();
        queue.appendTail(&lt;/span&gt;1&lt;span&gt;);
        queue.appendTail(&lt;/span&gt;2&lt;span&gt;);
        queue.appendTail(&lt;/span&gt;3&lt;span&gt;);
        System.out.println(queue.deleteHead());
        System.out.println(queue.deleteHead());
        queue.appendTail(&lt;/span&gt;4&lt;span&gt;);
        System.out.println(queue.deleteHead());
        System.out.println(queue.deleteHead());
        System.out.println(queue.deleteHead());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 03 Mar 2018 05:39:00 +0000</pubDate>
<dc:creator>ik-heu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ik-heu/p/8462025.html</dc:identifier>
</item>
<item>
<title>设计原则 - 甜橙很酸</title>
<link>http://www.cnblogs.com/hdwgxz/p/8496413.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hdwgxz/p/8496413.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、面向对象应用程序开发原则（&lt;/span&gt;SOLID&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1&lt;span&gt;单一职责原则（&lt;/span&gt;&lt;span&gt;SRP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;定义：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个类应该只有一个发生变化的原因。这条原则曾被称为内聚性，即一个模块的组成元素之间的功能相关性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么要遵守这条原则？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个类承担的职责过多，就等于把这些职责耦合到了一起。一个职责的变化可能削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用与辨析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例&lt;/span&gt;1&lt;span&gt;：记录日志&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Logger
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; LogToFile&amp;lt;T&amp;gt;&lt;span&gt;(T msg);
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; LogToDB&amp;lt;T&amp;gt;&lt;span&gt;(T msg);
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; LogToWindows&amp;lt;T&amp;gt;&lt;span&gt;(T msg);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个例子定义了一个日志类，包含三种方法：将日志写入本地文件、数据库或&lt;/span&gt;windows&lt;span&gt;系统日志。一般会人为日志类记录日志这个动作算做一个职责，然而事实并非如此，将日志记录到不同的存储介质算作不同的职责。基于这种认识，断定这个类包含了太多的职责，应该将职责分离出来。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;例&lt;/span&gt;2&lt;span&gt;：一个大的业务层类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个用户履历操作相关的类，包括：用户的教育背景，社会兼职职务，工作经历个人简历，获得的荣誉等，示例如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserResumeService
{
&lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 社会兼职
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加社会兼职&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AddParttime(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId, Parttime item)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除社会兼职信息&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; DelParttime(&lt;span&gt;int&lt;/span&gt; userId, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; parttimeId)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新社会兼职&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; UpdateParttime(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId, Parttime item)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; 教育背景
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加教育背景&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AddEducation(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId, EducationInfo item)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除教育背景&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; DelEducation(&lt;span&gt;int&lt;/span&gt; userId, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; educationId)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新教育背景&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; UpdateEducation(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId, EducationInfo item)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;        

        &lt;span&gt;#region&lt;/span&gt; 工作经历
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加工作经历&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AddWork(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId, WorkInfo item)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除工作经历&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; DelWork(&lt;span&gt;int&lt;/span&gt; userId, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; workId)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新工作经历&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; UpdateWork(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId, WorkInfo item)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; 科研项目
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加科研项目&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; AddProject(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId, Project item)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除科研项目&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; DelProject(&lt;span&gt;int&lt;/span&gt; userId, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; projectId)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新科研项目&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; UpdateProject(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; userId, Project item)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;这个类实在太大了，以至于不等不用&lt;/span&gt;#region将每块功能收起来。虽然这些操作都是针对一个用户的，但这不是一个职责，也不是俩个职责，这个类包含了太多职责，然而这不是一个工具类！如果是工具类还说得过去。解决的办法就是，将这个大类拆为几个小类，每个类表达一个职责，譬如教育背景相关操作归为一个小类，社会兼职相关操作也归为一个小类，其他依次类推。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 &lt;span&gt;开放封闭原则（&lt;/span&gt;&lt;span&gt;OCP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;软件实体（类、模块、函数等）应该是可以扩展的，但不可修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么要遵守此原则？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;任何系统在其生命周期都极有可能发生变化，如果不遵循此原则，那么系统将难以应对发生的变化，这很可能迫使我们抛弃现有版本，这会给我们带来极大的损失。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;违反原则的情形&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那些包含&lt;/span&gt;switch&lt;span&gt;、&lt;/span&gt;&lt;span&gt;if/else&lt;/span&gt;&lt;span&gt;的代码段极有可能违反了开放封闭原则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用的方式方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建出固定的、能够描述一组任意个可能行为的抽象基类或接口，然后针对每一个可能的行为创建一个派生自抽象基类或接口的子类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用与辨析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种做法的缺点是有可能会产生很多类，这样就增加了代码量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;据此修改上面日志记录的例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;定义日志接口&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ILogger
{
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Log&amp;lt;T&amp;gt;&lt;span&gt;(T msg);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;实现接口&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggerToFile : ILogger
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Log&amp;lt;T&amp;gt;&lt;span&gt;(T msg)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggerToDB : ILogger
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Log&amp;lt;T&amp;gt;&lt;span&gt;(T msg)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggerToWindows : ILogger
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Log&amp;lt;T&amp;gt;&lt;span&gt;(T msg)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3&lt;span&gt;里氏替换原则（&lt;/span&gt;&lt;span&gt;LSP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子类型能够替换掉它们的基类型，而不影响对象的行为和规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么要遵循此原则？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们要遵循&lt;/span&gt;OCP&lt;span&gt;原则，&lt;/span&gt;&lt;span&gt;OCP&lt;/span&gt;&lt;span&gt;背后的机制是抽象和多态，支持抽象和多态的关键机制是继承（比如&lt;/span&gt;&lt;span&gt;C#&lt;/span&gt;&lt;span&gt;是这样），那么是什么设计规则支配着这种继承用法？最佳的继承层次特征是什么？如何使我们创建的类层次结构符合&lt;/span&gt;&lt;span&gt;OCP&lt;/span&gt;&lt;span&gt;？这是本原则要解答的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;违反原则的情形&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）显示的使用&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;语句或&lt;/span&gt;&lt;span&gt;if/else&lt;/span&gt;&lt;span&gt;语句去确定一个对象的类型，以便可以选择针对不同对象实现不同操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;）对于继承是&lt;/span&gt;&lt;span&gt;IS-A(&lt;/span&gt;&lt;span&gt;是一个&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;关系，即如果一个新类型的对象被认为和一个已知类型的对象之间满足&lt;/span&gt;&lt;span&gt;IS-A&lt;/span&gt;&lt;span&gt;关系，那么这个新对象的类应该从这个已有对象的类派生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;）完成的功能少于其基类的派生类通常是不能替换其基类的，因此违反&lt;/span&gt;&lt;span&gt;LSP&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4&lt;span&gt;）当派生类中抛出基类没有的异常时，违反&lt;/span&gt;&lt;span&gt;LSP&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用的方式方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;基于契约编程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;契约是通过为每一个方法声明前置条件和后置条件来指定的。要使一个方法得以执行，前置条件必须要为真；执行完毕后，该方法要保证后置条件为真。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;派生类的前置条件和后置条件规则为：在重新声明派生类中的例程时，只能使用相等或者更弱的前置条件来替换原始的前置条件，只能使用相等或者更强的后置条件来替换原始的后置条件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;提取公共部分而不使用继承&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一组类都支持一个公共的职责，将这个职责提取出来，放到一个父类中，然后让这组类继承此父类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用与辨析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;见接口隔离原则的例子。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4&lt;span&gt;接口隔离原则（&lt;/span&gt;&lt;span&gt;ISP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不应该强迫客户程序依赖并未使用的方法。接口不应包含所有的对象行为，接口应尽可能的小。这个原则用来处理&lt;/span&gt;“胖”接口所存在的缺点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么要遵循此原则？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果程序中的一部分更改会影响到程序中完全和它无关的其他部分，那么更改的代价和影响就变得不可预测。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;违反原则的情形&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接口污染，即接口被一个它不总是需要的方法污染，也就是说不是此接口的每一个派生类都需要那个方法。但由于接口已经定义了这个方法，那么不需要它的派生类也要实现这个方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用的方式方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）使用委托分离接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象的客户端不通过该对象的接口去访问它，而是通过委托去访问他。此方案的缺点：委托处理会导致一些很小但仍然存在的运行时间和内存的开销。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;）使用多重继承分离接口：通常这种做法是首选的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用与辨析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;web&lt;span&gt;应用开发中使用仓储模式来封装对底层数据库的访问，为此创建&lt;/span&gt;&lt;span&gt;IRepository&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;接口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IRepository&amp;lt;T&amp;gt;&lt;span&gt;
    {
        T GetById(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Delete(T entity);
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Save(T entity);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update(T entity);
        IList&lt;/span&gt;&amp;lt;T&amp;gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; condition);

        ......
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;这是一个典型的胖接口，并不是每一个子类都会实现这么多的方法。对于继承了这个接口却不需要实现其中某些方法的接口，只能将方法体设置为空实现或抛出异常。例如下面的类中不需要实现&lt;/span&gt;Get&lt;span&gt;方法，所以在方法体中抛出了异常&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MRepository&amp;lt;T&amp;gt; : IRepository&amp;lt;T&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T GetById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Delete(T entity)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Save(T entity)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update(T entity)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不需要实现此方法&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; IList&amp;lt;T&amp;gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; condition)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;在接口的实现里抛出异常，这样做显然违背了&lt;/span&gt;&lt;span&gt;里氏替换原则（&lt;/span&gt;LSP&lt;span&gt;），解决的办法是将&lt;/span&gt;IRepository&amp;lt;T&amp;gt;&lt;span&gt;拆分成两个以上的更小的接口，按需实现接口，修改如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IRepository&amp;lt;T&amp;gt;&lt;span&gt;
    {
        T GetById(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id);
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Delete(T entity);
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Save(T entity);
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update(T entity);

    }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IRepositoryAL&amp;lt;T&amp;gt;&lt;span&gt;
    {
        IList&lt;/span&gt;&amp;lt;T&amp;gt; Get(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; condition);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MRepository&amp;lt;T&amp;gt; : IRepository&amp;lt;T&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T GetById(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Delete(T entity)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Save(T entity)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update(T entity)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体实现&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5 &lt;span&gt;依赖倒置原则（&lt;/span&gt;&lt;span&gt;DIP&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高层模块不应依赖于低层模块。二者都应依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。这样高层组件与低层组件之间通过抽象的接口来交换而不是具体类。该原则是框架设计的核心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么要遵守此原则？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果高层模块依赖于低层模块，那么对低层模块的改动会直接影响到高层模块，从而迫使他们一次做出改动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;违反原则的情形&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高低层组件通过具体类来实现交互。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用的方式方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“倒置”不仅仅是依赖关系的倒置，也是接口所有权的倒置。当使用&lt;span&gt;DIP&lt;/span&gt;&lt;span&gt;原则时，往往客户拥有抽象接口，而他们的服务者则从这些抽象接口派生。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启发式的方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;）找到那些指向具体类的引用的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;）找到任何派生自具体类的类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;）找到那些重写方法，而基类方法已经实现过了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用与辨析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;依赖倒置式控制反转的精髓，通过控制反转可以深刻的体会到依赖倒置的作用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6 迪米特法则（LoD,又名最少知道原则）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个对象应当对其他对象有尽可能少的了解&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;只和自己关系最密切对象直接作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关系最密切的对象含义是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前对象本身，通过该对象方法参数传入的对象，此类的其他实例化对象，以及其所在聚集类的其他成员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么要遵守此原则？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;降低耦合，减少依赖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;违反原则的情形&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和除了上述关系最密切的对象之间通信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用的方式方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1)限制类及其成员的访问权限。&lt;/p&gt;
&lt;p&gt;2）引入门面模式和中介者模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;组合&lt;/span&gt;/聚合复用原则&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;CARP&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将已有&lt;/span&gt;&lt;span&gt;的多个&lt;/span&gt;&lt;span&gt;对象组成一个新对象，达到复用的目的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么要遵守此原则？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在建模的过程中，我们会发现，某些实体之间不具有继承关系，但是他们之间却有一些像是的操作，为了实现这种无法用继承表达的关系，我们遵照&lt;/span&gt;CARP&lt;span&gt;原则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、&lt;/span&gt;DRY原则（不要重复自己）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;避免重复相同或相似的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用与辨析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义拦截器或过滤器充分体现了&lt;/span&gt;DRY原则。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如使用&lt;/span&gt;ASP.NET MVC&lt;span&gt;创建企业级应用的过程中，定义了如下的控制器：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExcludedDataController : BaseController
{
       [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Add(ExcludedDataInfo info)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Request.IsAjaxRequest())
            {
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他代码&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmptyResult();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Del(ExcludedDataInfo info)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Request.IsAjaxRequest())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他代码&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmptyResult();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult BatchAdd(&lt;span&gt;string&lt;/span&gt; itemCodes, &lt;span&gt;int&lt;/span&gt; currentNavId, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; library_DataBase_ID)
       {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Request.IsAjaxRequest())
            {
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他代码&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EmptyResult();
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;其中三个方法中都调用了&lt;/span&gt;Request.IsAjaxRequest()&lt;span&gt;方法，明显违反了&lt;/span&gt;&lt;span&gt;DRY&lt;/span&gt;&lt;span&gt;原则，解决的办法是可以在控制器上添加拦截器。但是或许此控制器的操作中还有不被&lt;/span&gt;&lt;span&gt;Ajax&lt;/span&gt;&lt;span&gt;调用的操作，那么可以将这些操作移除，放入一个新的控制器中。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、控制反转（&lt;/span&gt;IoC&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制反转是基于面向对象的原则，提倡松耦合理念的设计原则，允许独立开发应用程序的各个组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;实现方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现方式有两种：依赖注入，服务定位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;依赖注入&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;引用其他的&lt;/span&gt;dll&lt;span&gt;，组件之间的引用，一个类持有另一个类，这些都可以被看做是依赖。最常遇到的是一个类持有另一个类的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;依赖注入有三种方式：构造函数注入，属性注入，方法注入。最常使用的是构造函数的注入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;服务定位&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;通过&lt;/span&gt;IoC&lt;span&gt;容器获取依赖的具体类型，并将其赋给接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;运用与辨析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记录&lt;/span&gt;Entity Framework&lt;span&gt;执行&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;语句对优化系统有极大的帮助。为记录&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;定扩展命令拦截器&lt;/span&gt;&lt;span&gt;IDbCommandInterceptor&lt;/span&gt;&lt;span&gt;，在实现的方法中记录&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;。可以将&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;记录到本地文本文件中，也可以将&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;存储到数据库中，实现如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommandInterceptor : IDbCommandInterceptor
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Logger logger = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Logger();
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; NonQueryExecuted(DbCommand command, DbCommandInterceptionContext&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; interceptionContext)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.logger.Log&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(command, interceptionContext);
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他方法......&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;上面的实现包含了一个依赖项，即&lt;/span&gt;Logger&lt;span&gt;，如果后续改变存储&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;的媒介，那么就要修改&lt;/span&gt;&lt;span&gt;Logger.Log&lt;/span&gt;&lt;span&gt;这个方法，明显违反了&lt;/span&gt;&lt;span&gt;OCP&lt;/span&gt;&lt;span&gt;原则，也没有遵循&lt;/span&gt;&lt;span&gt;DIP&lt;/span&gt;&lt;span&gt;原则。所以将其更改如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommandInterceptor : IDbCommandInterceptor
{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICommandLogger logger;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CommandInterceptor(ICommandLogger logger)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.logger =&lt;span&gt; logger;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; NonQueryExecuted(DbCommand command, DbCommandInterceptionContext&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; interceptionContext)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.logger.Log&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(command, interceptionContext);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其他代码&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 03 Mar 2018 05:12:00 +0000</pubDate>
<dc:creator>甜橙很酸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hdwgxz/p/8496413.html</dc:identifier>
</item>
<item>
<title>MySQL 之 视图、触发器、存储过程、函数、事物与数据库锁 - 人生不如戏</title>
<link>http://www.cnblogs.com/fu-yong/p/8496361.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fu-yong/p/8496361.html</guid>
<description>&lt;h2&gt;浏览目录:&lt;/h2&gt;
&lt;h2&gt;1.视图&lt;/h2&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt; &lt;strong&gt;视图:&lt;/strong&gt;&lt;span&gt;是一个虚拟表，其内容由查询定义&lt;/span&gt;。同真实的表一样，视图包含一系列带有名称的列和行数据&lt;/p&gt;
&lt;p&gt;视图有如下特点;&lt;br/&gt;　　1. 视图的列可以来自不同的表，是表的抽象和逻辑意义上建立的新关系。&lt;br/&gt;　　2. 视图是由基本表（实表）产生的表（虚表）。&lt;br/&gt;　　3. 视图的建立和删除不影响基本表。&lt;br/&gt;　　4. 对视图内容的更新（添加、删除和修改）直接影响基本表。&lt;br/&gt;　　5. 当视图来自多个基本表时，不允许添加,修改和删除数据。&lt;/p&gt;
&lt;p&gt;　1.创建视图&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
create view 视图名称  as sql 查询语句       
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　2.使用视图&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
select * from 视图名称;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　3.更新视图&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
alter view 视图名称 AS SQL语句
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　4. 删除视图&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
drop view ren_view;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2.触发器-trigger&lt;/h2&gt;
&lt;blockquote readability=&quot;84&quot;&gt;
&lt;p&gt;&lt;strong&gt;触发器&lt;/strong&gt;：&lt;span&gt;监视某种情况，并触发某种操作&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;触发器创建语法四要素：1.监视地点(table)&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　2.监视事件(insert/update/delete)&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　   3.触发时间(after/before)&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　4.触发事件(insert/update/delete)&lt;/p&gt;
&lt;p&gt;1.创建触发器语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
 create trigger triggerName  after/before  insert/update/delete
      on 表名 for each row #这句话是固定的
  begin
      #需要执行的sql语句
  end
 注意1:after/before: 只能选一个 ,after 表示 后置触发, before 表示前置触发
 注意2:insert/update/delete:只能选一个
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;创建两张表&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td readability=&quot;6&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;span&gt;商品表&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;create table goods(&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;  id int primary key auto_increment,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;  name varchar(20),&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;  num int&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#&lt;/span&gt;&lt;span&gt;订单表&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;create table order_table(&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;    oid int primary key auto_increment,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;    gid int,&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;    much int&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;);&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;MsoNormal&quot;&gt;添加3条商品数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
insert into goods(name,num) values('商品1',10),('商品2',10),('商品3',10);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;如果我们在没使用触发器之前：假设我们现在卖了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;&lt;span&gt;个商品&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;，我们需要做两件事&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;/span&gt;&lt;span&gt;往订单表插入一条记录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
insert into order_table(gid,much) values(1,3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.&lt;/span&gt;&lt;span&gt;更新商品表商品&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;的剩余数量&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
update goods set num=num-3 where id=1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;现在，我们来创建一个触发器：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
 create trigger tg1 after insert on  order_table 
 for each row
 begin     
   update goods set num = num -3 where id = 1; 
 end 
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;这时候我们只要执行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
insert into order_table(gid,much) values(1,3);   
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;会发现商品&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;的数量变为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;7&lt;/span&gt;&lt;span&gt;了，说明在我们插入一条订单的时候，&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;触发器自动帮我们做了更新操作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;但现在会有一个问题，因为我们触发器里面&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;num&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;id&lt;/span&gt;&lt;span&gt;都是写死的，所以不管我们买哪个商品，最终更新的都是商品&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;的数量。比如：我们往订单表再插入一条记录：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
insert into order_table(gid,much) values(2,3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;执行完后会发现商品&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;span&gt;的数量变&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;&lt;span&gt;了，而商品&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;的数量没变，这样显然不是我们想要的结果。我们需要改改我们之前创建的触发器。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;我们如何在触发器引用行的值，也就是说我们要得到我们新插入的订单记录中的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;gid&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;much&lt;/span&gt;&lt;span&gt;的值。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;对于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;insert&lt;/span&gt;&lt;span&gt;而言，&lt;span&gt;新插入的行用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;new&lt;/span&gt;&lt;span&gt;来表示，行中的每一列的值用&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;new.&lt;/span&gt;&lt;span&gt;列名来表示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;所以现在我们可以这样来改我们的触发器:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
create trigger tg2 after insert on order_table
for each row
begin 
 update goods set num = num-new.much  where id = new.gid;
end 
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;第二个触发器创建完毕，我们先把第一个触发器删掉&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
drop trigger tg1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;再来测试一下，插入一条订单记录：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
insert into order_table(gid,much) values(2,3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;执行完发现商品&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;span&gt;的数量变为&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;7&lt;/span&gt;&lt;span&gt;了，现在就对了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;现在还存在两种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;1.&lt;/span&gt;&lt;span&gt;当用户撤销一个订单的时候，我们这边直接删除一个订单，我们是不是需要把对应的商品数量再加回去呢？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;span&gt;对于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;delete&lt;/span&gt;&lt;span&gt;而言：原本有一行&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;后来被删除，想引用被删除的这一行，&lt;span&gt;用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;old&lt;/span&gt;&lt;span&gt;来表示旧表中的值，&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;old.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;列名可以引用原(旧)表中的值&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;那我们的触发器就该这样写：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
create trigger tg3 afert delete  on order_table 
for each row 
bigen 
    update goods set num = num + old.much where id = old.gid;-- (注意这边的变化)
end 
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.&lt;/span&gt;&lt;span&gt;当用户修改一个订单的数量时，我们触发器修改怎么写&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;?&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
create trigger tg4 after update on order_table
for each row
begin
    update goods set num = num+old.much-new.much where id = old.gid;
end
&lt;/pre&gt;&lt;/div&gt;

&lt;/blockquote&gt;
&lt;h2&gt;3.存储过程&lt;/h2&gt;
&lt;blockquote readability=&quot;53&quot;&gt;
&lt;p&gt; &lt;span lang=&quot;EN-US&quot;&gt;MySQL数据库在&lt;span lang=&quot;EN-US&quot;&gt;5.0版本后开始支持存储过程，那么什么是存储过程呢？怎么创建、查看和删除存储过程呢？存储过程有什么优点？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;存储过程&lt;/strong&gt;：&lt;/span&gt;&lt;span&gt;&lt;span&gt;类似于函数(方法)&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;简单的说存储过程是为了完成某个数据库中的特定功能而编写的语句集合，该语句集包括&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;语句（对数据的增删改查）、条件语句和循环语句等&lt;/span&gt;。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;.&lt;/span&gt; &lt;span&gt;查看现有的存储过程&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
show procedure status;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　2 .删除存储过程&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
drop procedure 存储过程名称;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   &lt;span&gt;3&lt;/span&gt;. 调用 存储过程&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
call 存储过程名称(参数入/出类型 参数名 数据类型);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4.创建存储过程&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;1.体会封装&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
#1.体会封装
create procedure p1 ()
begin 
    select * from account;   
end
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;2.SQL 体会参数&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
create procedure p2(in i int,out n varchar(50))
begin 
 select name &lt;span&gt;into&lt;/span&gt; n from account where id = i;
end

-- 调用
set @name =null;
CALL p2(1,@name);
select @name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;brush:sql;gutter:true;&quot;&gt;&lt;span&gt;注意1: mysql中有三种出入参数类型:分别为:1. &lt;strong&gt;in&lt;/strong&gt; 入参类型  2.&lt;strong&gt;out&lt;/strong&gt; 出参类型   3. &lt;strong&gt;inout&lt;/strong&gt; 出入参类型 &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;brush:sql;gutter:true;&quot;&gt;&lt;span&gt;注意2: into 关键字 可以 将前面字段的查询结果 执行 给 into 后面的变量.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;brush:sql;gutter:true;&quot;&gt;3.SQL 体会控制&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
 #3.SQL 体会控制
  create procedure p3(in x int,in c char(1))
  begin
     if c ='d' then
          select * from account where money &amp;gt;x;
    else 
          select * from account where money &amp;lt;x;      
 　　end if;
 end
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;brush:sql;gutter:true;&quot;&gt; 4.体会循环:计算1-100累加的和,并且返回计算结果.&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
#4.体会循环:计算1-100累加的和,并且返回计算结果.
create procedure p4(inout n int)
begin
      DECLARE sum int default 0; -- 设置总和变量,并且指定初始值0
      declare i int; -- 声明变量
      set i = 0;    -- 通过set为变量设置值
　　  while i&amp;lt;=n DO  -- 开始循环
            set sum = sum +i;
            set i = i+1;
      end while; -- 结束循环

　　  select sum; -- 提供结果
                    
     set n = sum;--将计算结果提供给 输出变量 n;
end;
                
 -- 调用:
 set @n = 100;
 call p4(@n);
 select @n;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;strong&gt;&lt;span&gt;存储过程优点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;&lt;span&gt;        1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;、存储过程增强了&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL&lt;/span&gt;&lt;span&gt;语言灵活性。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　　　　　存储过程可以使用控制语句编写，可以完成复杂的判断和较复杂的运算，有很强的灵活性；&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;&lt;span&gt;        2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;、减少网络流量，降低了网络负载。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　　　　　存储过程在服务器端创建成功后，只需要调用该存储过程即可，而传统的做法是每次都将大量的&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL&lt;/span&gt;&lt;span&gt;语句通过网络发送至数据库服务器端然后再执行&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;&lt;span&gt;        3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;、存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot;&gt;&lt;span&gt;　　　　　　一般&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;SQL&lt;/span&gt;&lt;span&gt;语句每执行一次就编译一次&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;&lt;span&gt;所以使用存储过程可提高数据库执行速度。&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;存储过程缺点&lt;/strong&gt;：&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　 　1、扩展功能不方便&lt;/p&gt;
&lt;p&gt;　　 2、不便于系统后期维护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;4.函数　&lt;/h2&gt;
&lt;blockquote readability=&quot;13.957532861476&quot;&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;MySQL提供的内建函数:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60.5&quot;&gt;&lt;img id=&quot;code_img_closed_12b023ad-0453-4895-a2cc-3d28c5250968&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_12b023ad-0453-4895-a2cc-3d28c5250968&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_12b023ad-0453-4895-a2cc-3d28c5250968&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;116&quot;&gt;
&lt;pre&gt;
&lt;span&gt;一、数学函数
    &lt;/span&gt;&lt;span&gt;ROUND&lt;/span&gt;&lt;span&gt;(x,y)
        返回参数x的四舍五入的有y位小数的值
        
    &lt;/span&gt;&lt;span&gt;RAND&lt;/span&gt;&lt;span&gt;()
        返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。

二、聚合函数(常用于GROUP BY从句的SELECT查询中)
    &lt;/span&gt;&lt;span&gt;AVG&lt;/span&gt;&lt;span&gt;(col)返回指定列的平均值
    &lt;/span&gt;&lt;span&gt;COUNT&lt;/span&gt;&lt;span&gt;(col)返回指定列中非NULL值的个数
    &lt;/span&gt;&lt;span&gt;MIN&lt;/span&gt;&lt;span&gt;(col)返回指定列的最小值
    &lt;/span&gt;&lt;span&gt;MAX&lt;/span&gt;&lt;span&gt;(col)返回指定列的最大值
    &lt;/span&gt;&lt;span&gt;SUM&lt;/span&gt;&lt;span&gt;(col)返回指定列的所有值之和
    GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果    
    
三、字符串函数

    CHAR_LENGTH(&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;)
        返回值为字符串str 的长度，长度的单位为字符。一个多字节字符算作一个单字符。
    CONCAT(str1,str2,...)
        字符串拼接
        如有任何一个参数为NULL ，则返回值为 &lt;/span&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;。
    CONCAT_WS(separator,str1,str2,...)
        字符串拼接（自定义连接符）
        CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 &lt;/span&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;）。

    FORMAT(X,D)
        将数字X 的格式写为&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#,###,###.##&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,以四舍五入的方式保留小数点后 D 位， 并将结果以字符串的形式返回。若  D 为 &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, 则返回结果不带有小数点，或不含小数部分。
        例如：
            &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; FORMAT(&lt;span&gt;12332.1&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;); 结果为： &lt;span&gt;'&lt;/span&gt;&lt;span&gt;12,332.1000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    
    &lt;span&gt;INSERT&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt;,pos,&lt;span&gt;len&lt;/span&gt;&lt;span&gt;,newstr)
        在str的指定位置插入字符串
            pos：要替换位置其实位置
            &lt;/span&gt;&lt;span&gt;len&lt;/span&gt;&lt;span&gt;：替换的长度
            newstr：新字符串
        例如:
            &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abcd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); 结果为: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ttcd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
            &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;INSERT&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abcd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); 结果为: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        特别的：
            如果pos超过原字符串长度，则返回原字符串
            如果len超过原字符串长度，则由新字符串完全替换
    
    INSTR(&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;,substr)
        返回字符串 &lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt; 中子字符串的第一个出现位置。

    &lt;/span&gt;&lt;span&gt;LEFT&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt;,&lt;span&gt;len&lt;/span&gt;&lt;span&gt;)
        返回字符串str 从开始的len位置的子序列字符。
        例如:
            &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; INSTR(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); 结果为： &lt;span&gt;3&lt;/span&gt;
            &lt;span&gt;SELECT&lt;/span&gt; INSTR(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); 结果为： &lt;span&gt;0&lt;/span&gt;
            
    &lt;span&gt;LOWER&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt;&lt;span&gt;)
        变小写

    &lt;/span&gt;&lt;span&gt;UPPER&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt;&lt;span&gt;)
        变大写
   
    &lt;/span&gt;&lt;span&gt;REVERSE&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt;&lt;span&gt;)
        返回字符串 &lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt; ，顺序和字符顺序相反。
        例如:
            &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;REVERSE&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1234567&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) 结果为：&lt;span&gt;7654321&lt;/span&gt;
            
    &lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt;,pos) , &lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; pos) &lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt;,pos,&lt;span&gt;len&lt;/span&gt;) , &lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; pos &lt;span&gt;FOR&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;)
        不带有len 参数的格式从字符串str返回一个子字符串，起始于位置 pos。带有len参数的格式从字符串str返回一个长度同len字符相同的子字符串，起始于位置 pos。 使用 FROM的格式为标准 SQL 语法。也可能对pos使用一个负值。假若这样，则子字符串的位置起始于字符串结尾的pos 字符，而不是字符串的开头位置。在以下格式的函数中可以对pos 使用一个负值。

        mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Quadratically&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;); &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 从第5位开始截取&lt;/span&gt;
            &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ratically&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

        mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;foobarbar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;); &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 从第4位开始截取&lt;/span&gt;
            &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;barbar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

        mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Quadratically&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;); &lt;span&gt;--&lt;/span&gt;&lt;span&gt;从第5位开始截取,截取6个长度&lt;/span&gt;
            &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ratica&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

        mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sakila&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;-&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;);    &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 从倒数第3位开始截取&lt;/span&gt;
            &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ila&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

        mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;SUBSTRING&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sakila&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;-&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;); &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 从倒数第5位开始截取,截取3个长度&lt;/span&gt;
            &lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;aki&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
            
四、日期和时间函数
    CURDATE()或CURRENT_DATE() 返回当前的日期
    CURTIME()或CURRENT_TIME() 返回当前的时间
    DAYOFWEEK(date)   返回date所代表的一星期中的第几天(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;)
    DAYOFMONTH(date)  返回date是一个月的第几天(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;&lt;span&gt;)
    DAYOFYEAR(date)   返回date是一年的第几天(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;366&lt;/span&gt;&lt;span&gt;)
    DAYNAME(date)   返回date的星期名，如：&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; DAYNAME(&lt;span&gt;CURRENT_DATE&lt;/span&gt;&lt;span&gt;);
    FROM_UNIXTIME(ts,fmt)  根据指定的fmt格式，格式化UNIX时间戳ts
    HOUR(time)   返回time的小时值(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;)
    MINUTE(time)   返回time的分钟值(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;MONTH&lt;/span&gt;(date)   返回date的月份值(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
    MONTHNAME(date)   返回date的月份名，如：&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; MONTHNAME(&lt;span&gt;CURRENT_DATE&lt;/span&gt;&lt;span&gt;);
    NOW()    返回当前的日期和时间
    QUARTER(date)   返回date在一年中的季度(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;)，如SELECT QUARTER(&lt;span&gt;CURRENT_DATE&lt;/span&gt;&lt;span&gt;);
    WEEK(date)   返回日期date为一年中第几周(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;YEAR&lt;/span&gt;(date)   返回日期date的年份(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;)
    
    重点:
    DATE_FORMAT(date,format) 根据format字符串格式化date值

       mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; DATE_FORMAT(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2009-10-04 22:23:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%W %M %Y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sunday October 2009&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
       mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; DATE_FORMAT(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2007-10-04 22:23:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%H:%i:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;22:23:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
       mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; DATE_FORMAT(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1900-10-04 22:23:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;                 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%D %y %a %d %m %b %j&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;4th 00 Thu 04 10 Oct 277&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
       mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; DATE_FORMAT(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1997-10-04 22:23:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;                 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%H %k %I %r %T %S %w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;22 22 10 10:23:00 PM 22:23:00 00 6&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
       mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; DATE_FORMAT(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1999-01-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%X %V&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1998 52&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
       mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt; DATE_FORMAT(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2006-06-00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        
五、加密函数
    MD5()    
        计算字符串str的MD5校验和
        例如:
            &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; MD5(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) 结果为：81dc9bdb52d04dc20036dbd8313ed055
    PASSWORD(&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;)   
        返回字符串str的加密版本，这个加密过程是不可逆转的
        例如:
            &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; PASSWORD(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1234&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) 结果为:&lt;span&gt;*&lt;/span&gt;&lt;span&gt;A4B6157319038724E3560894F7F932C8886EBFCF
        
六、控制流函数            
    &lt;/span&gt;&lt;span&gt;CASE&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;result1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;...&lt;span&gt;ELSE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;END&lt;/span&gt;&lt;span&gt;
        如果testN是真，则返回resultN，否则返回default
    &lt;/span&gt;&lt;span&gt;CASE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;WHEN&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;val1&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;...&lt;span&gt;ELSE&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;  
        如果test和valN相等，则返回resultN，否则返回default

    &lt;/span&gt;&lt;span&gt;IF&lt;/span&gt;&lt;span&gt;(test,t,f)   
        如果test是真，返回t；否则返回f

    IFNULL(arg1,arg2) 
        如果arg1不是空，返回arg1，否则返回arg2
        例如:
            &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; IFNULL(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;); 结果为: bbb
            &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; IFNULL(&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);  结果为: abc

    &lt;/span&gt;&lt;span&gt;NULLIF&lt;/span&gt;&lt;span&gt;(arg1,arg2) 
        如果arg1&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;arg2返回NULL；否则返回arg1
        例如:
            &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;NULLIF&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);结果为： &lt;span&gt;null&lt;/span&gt;
            &lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;NULLIF&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);结果为： aaa
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;MySQL内建函数&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;更多函数: &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/functions.html&quot; target=&quot;_blank&quot;&gt;官方猛击这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、自定义函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
CREATE FUNCTION fun1(i1 int,i2 int)

RETURNS INT //设置返回类型

BEGIN
    DECLARE sum int default 0;
    set sum = i1+i2;
    RETURN(sum); //返回结果
end 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.调用自定义函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
#直接调用自定义函数
select fun1(1,5);

#在sql语句中使用自定义函数
select fun1(参数1,参数2),name from 表名
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.删除自定义函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
DROP FUNCTION fun_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4.函数与存储过程的区别:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1284211/201801/1284211-20180110165949129-789952402.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;5.事物处理&lt;/h2&gt;
&lt;blockquote readability=&quot;50&quot;&gt;
&lt;p&gt;&lt;strong&gt; 一、 什么是事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　   一组sql语句批量执行,要么全部执行成功,要么全部执行失败&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;strong&gt;二、为什么出现这种技术&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;　　为什么要使用事务这个技术呢？ 现在的很多软件都是多用户，多程序，多线程的，对同一个表可能同时有很多人在用，为保持数据的一致性，所以提出了事务的概念。这样很抽象，举个例子： &lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;A 给B 要划钱，A 的账户-1000元， B 的账户就要+1000元，这两个update 语句必须作为一个整体来执行，不然A 扣钱了，B 没有加钱这种情况很难处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、事物的特性　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　80年代中国人结婚四大件：手表、自行车、缝纫机、收音机（三转一响）。要把事务娶回家同样需要四大件，所以事务很刻薄（ACID），四大件清单：原子性(Atom）、一致性（Consistent）、隔离性（Isolate）、持久性（Durable）。ACID就是数据库事务正确执行的四个特性的缩写。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt;：要么不谈，要谈就要结婚！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　对于其数据修改，要么全都执行，要么全都不执行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一致性&lt;/strong&gt;：恋爱时，什么方式爱我；结婚后还得什么方式爱我；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　数据库原来有什么样的约束，事务执行之后还需要存在这样的约束，所有规则都必须应用于事务的修改，以保持所有数据的完整性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;隔离性&lt;/strong&gt;：闹完洞房后，是俩人的私事。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　一个事务不能知道另外一个事务的执行情况（中间状态）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;持久性&lt;/strong&gt;：一旦领了结婚证，无法后悔。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　即使出现致命的系统故障也将一直保持。不要告诉我系统说commit成功了，回头电话告诉我，服务器机房断电了，我的事务涉及到的数据修改可能没有进入数据库。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外需要注意&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 MySQL 中只有使用了 Innodb 数据库引擎的数据库或表才支持事务。&lt;/li&gt;
&lt;li&gt;事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。&lt;/li&gt;
&lt;li&gt;事务用来管理 insert,update,delete 语句&lt;/li&gt;
&lt;/ul&gt;&lt;h5&gt;&lt;span&gt;四、事务控制语句：&lt;/span&gt;&lt;/h5&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;BEGIN 或 START TRANSACTION；显式地开启一个事务；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;COMMIT；也可以使用COMMIT WORK，不过二者是等价的。COMMIT会提交事务，并使已对数据库进行的所有修改称为永久性的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ROLLBACK；有可以使用ROLLBACK WORK，不过二者是等价的。回滚会结束用户的事务，并撤销正在进行的所有未提交的修改；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;SAVEPOINT : 保存点,可以把一个事物分割成几部分.在执行ROLLBACK 时 可以指定在什么位置上进行回滚操作.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意: SET AUTOCOMMIT=0 ;禁止自动提交 和 SET AUTOCOMMIT=1 开启自动提交.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、例子: 鲁班转账给后羿&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.创建表 &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
create table account(
    id int(50) not null auto_increment primary key,
    name VARCHAR(50) not null,
    money DOUBLE(5,2) not NULL
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.插入数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
insert into account (name,money) values('鲁班',250),('后羿',5000);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.执行转账&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
start transaction; -- 开启事物
 --  执行sql语句操作
 update account set money = money - 500 where id ='1';   
 update account set money = money+500 where id = '2';

commit;  -- 手动提交事物
rollback; -- 回滚事物 

--  查看结果
select * from account;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4.保存点使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
START TRANSACTION ;

insert into account (name,money) values('李元芳',1000);

SAVEPOINT s1; -- 设置保存点

insert into account (name,money) values('张桂枝',1500);

ROLLBACK to s1; -- 事物回滚到保存点&lt;br/&gt;COMMIT; --提交事物
&lt;/pre&gt;&lt;/div&gt;

&lt;/blockquote&gt;
&lt;h2&gt;6.数据锁&lt;/h2&gt;
&lt;blockquote readability=&quot;90.855708245243&quot;&gt;
&lt;p align=&quot;left&quot;&gt;需求: 有一个账户,两个人在同一时间要对此账户操作,A要对账户充值100块,B要从账户中取出100块.操作前都要先看一下账户的 余额然后再操作.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_360a3b43-2c06-46ba-adde-dc629a84685b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_360a3b43-2c06-46ba-adde-dc629a84685b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_360a3b43-2c06-46ba-adde-dc629a84685b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 窗口1 用户进行充值&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 充值前 先查看余额&lt;/span&gt;
&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@m&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;money&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; &lt;span&gt;@m&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; account &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;@m&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 看到余额后 充值100 块&lt;/span&gt;
&lt;span&gt;update&lt;/span&gt; account &lt;span&gt;set&lt;/span&gt; &lt;span&gt;money&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@m&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;100&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; account;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;------------------------------------------------------------&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; 窗口2 用户进行取款&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 取款前 先查看余额&lt;/span&gt;
&lt;span&gt;set&lt;/span&gt; &lt;span&gt;@m&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;money&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; &lt;span&gt;@m&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; account &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;@m&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 看到余额后 取款100 块&lt;/span&gt;
&lt;span&gt;update&lt;/span&gt; account &lt;span&gt;set&lt;/span&gt; &lt;span&gt;money&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;@m&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;100&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; account;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;示例&lt;/span&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;1. &lt;/strong&gt;&lt;strong&gt;锁的基本概念&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. &lt;/strong&gt;&lt;strong&gt;锁的基本类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;多个事务同时读取一个对象的时候，是不会有冲突的。同时读和写，或者同时写才会产生冲突。因此为了提高数据库的并发性能，通常会定义两种锁：&lt;strong&gt;共享锁和排它锁。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;　　2.1 &lt;/strong&gt;&lt;strong&gt;共享锁（&lt;/strong&gt;&lt;strong&gt;Shared Lock&lt;/strong&gt;&lt;strong&gt;，也叫&lt;/strong&gt;&lt;strong&gt;S&lt;/strong&gt;&lt;strong&gt;锁）&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　共享锁(S)表示对数据进行读操作。因此多个事务可以同时为一个对象加共享锁。（如果试衣间的门还没被锁上，顾客都能够同时进去参观）&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.2 &lt;/strong&gt;&lt;strong&gt;排他锁&lt;/strong&gt;&lt;strong&gt;(Exclusive Lock&lt;/strong&gt;&lt;strong&gt;，也叫&lt;/strong&gt;&lt;strong&gt;X&lt;/strong&gt;&lt;strong&gt;锁&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　排他锁(X)表示对数据进行写操作。如果一个事务对 对象加了排他锁，其他事务就不能再给它加任何锁了。(某个顾客把试衣间从里面反锁了，其他顾客想要使用这个试衣间，就只有等待锁从里面给打开了).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 实际开发中常见的两种锁:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.1悲观锁 顾名思义&lt;/strong&gt;，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block(阻塞)直到它拿到锁。传统的关系型&lt;a title=&quot;MySQL知识库&quot; href=&quot;http://lib.csdn.net/base/mysql&quot; target=&quot;_blank&quot;&gt;数据库&lt;/a&gt;里边就用到了很多这种锁机制.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：要使用悲观锁，我们必须关闭&lt;span lang=&quot;EN-US&quot;&gt;mysql数据库的自动提交属性.&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;因为&lt;span lang=&quot;EN-US&quot;&gt;MySQL默认使用&lt;span lang=&quot;EN-US&quot;&gt;autocommit模式，也就是说，当你执行一个更新操作后，&lt;span lang=&quot;EN-US&quot;&gt;MySQL会立刻将结果进行提交。关闭自动提交命令为：&lt;span lang=&quot;EN-US&quot;&gt;set autocommit=0;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
-- 0.开始事务
start transaction;

-- 1.查询账户余额
set @m = 0; -- 账户余额
select money into @m from account where id = 1 for update;
select @m;

-- 2.修改账户余额
update account set money = @m -100 where id = 1;

select * FROM account where id = 1;
-- 3. 提交事务
commit;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在另外的查询页面执行:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
-- 0.开始事务
start transaction;

-- 1.查询账户余额
set @m = 0; -- 账户余额
select money into @m from account where id = 1 for update;
select @m;

-- 2.修改账户余额
update account set money = @m +100 where id = 1;

select * FROM account where id = 1;
-- 3. 提交事务
commit;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会发现当前查询会进入到等待状态,不会显示出数据,当上面的sql执行完毕提交事物后,当前sql才会显示结果.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意1:在使用悲观锁时,如果表中没有指定主键,则会进行锁表操作.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意2: 悲观锁的确保了数据的安全性，在数据被操作的时候锁定数据不被访问，但是这样会带来很大的性能问题。因此悲观锁在实际开发中使用是相对比较少的。&lt;/span&gt;　　&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt; 3.2 乐观锁, 顾名思义&lt;/strong&gt;，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。　&lt;/p&gt;
&lt;p&gt;使用乐观锁的两种方式:&lt;/p&gt;
&lt;p&gt;　　1.使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现 方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录 的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数 据。&lt;/p&gt;
&lt;p&gt; 代码示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
-- 1.查询账户余额
set @m = 0; -- 账户余额
select money into @m from account where id = 1 ;
select @m;
-- 2.查询版本号
set @version = 0; -- 版本号
select version into @version from account where id = 1 ;
select @version;

-- 3.修改账户余额
update account set money = @m -100,version=version+1 where id = 1 and version = @version;

select * FROM account where id = 1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳 （datatime）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;悲观锁与乐观锁的优缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　两种锁各有其有点缺点,不能单纯的讲哪个更好.&lt;/p&gt;
&lt;p&gt;　　　　乐观锁适用于写入比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。&lt;/p&gt;
&lt;p&gt;　　　　但如果经常产生冲突，上层应用会不断的进行重试操作，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt; 7.数据库备份&lt;/h2&gt;
&lt;p&gt;　　mysqldump 命令将数据库中的数据备份成一个文本文件。表的结构和表中的数据将存储在生成的文本文件中。&lt;/p&gt;
&lt;p&gt;　　mysqldump命令的工作原理很简单。它先查出需要备份的表的结构，再在文本文件中生成一个CREATE语句。然后，将表中的所有记录转换成一条INSERT语句。然后通过这些语句，就能够创建表并插入数据。&lt;/p&gt;
&lt;blockquote readability=&quot;9.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;/strong&gt;使用mysqldump实现逻辑备份&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
#语法：
# mysqldump -h 服务器 -u用户名 -p密码 数据库名 &amp;gt; 备份文件.sql

#示例：
#单库备份
mysqldump -uroot -p123456 db1 &amp;gt; c:/db1.sql
mysqldump -uroot -p123456 db1 table1 table2 &amp;gt; c:/db1-table1-table2.sql

#多库备份
mysqldump -uroot -p123456 --databases db1 db2 mysql db3 &amp;gt; c:/db1_db2_mysql_db3.sql

#备份所有库
mysqldump -uroot -p123456 --all-databases &amp;gt; c:/all.sql 
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53.5&quot;&gt;&lt;img id=&quot;code_img_closed_1ae00234-612e-41a9-860a-344558a47463&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1ae00234-612e-41a9-860a-344558a47463&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1ae00234-612e-41a9-860a-344558a47463&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;102&quot;&gt;
&lt;pre&gt;
--all-databases  , -&lt;span&gt;A
导出全部数据库。
mysqldump  &lt;/span&gt;-uroot -p --all-&lt;span&gt;databases
&lt;/span&gt;--all-tablespaces  , -&lt;span&gt;Y
导出全部表空间。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --all-&lt;span&gt;tablespaces
&lt;/span&gt;--no-tablespaces  , -&lt;span&gt;y
不导出任何表空间信息。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --no-&lt;span&gt;tablespaces
&lt;/span&gt;--add-drop-&lt;span&gt;database
每个数据库创建之前添加drop数据库语句。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --add-drop-&lt;span&gt;database
&lt;/span&gt;--add-drop-&lt;span&gt;table
每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用&lt;/span&gt;--skip-add-drop-&lt;span&gt;table取消选项)
mysqldump  &lt;/span&gt;-uroot -p --all-&lt;span&gt;databases  (默认添加drop语句)
mysqldump  &lt;/span&gt;-uroot -p --all-databases –skip-add-drop-&lt;span&gt;table  (取消drop语句)
&lt;/span&gt;--add-&lt;span&gt;locks
在每个表导出之前增加LOCK TABLES并且之后UNLOCK  TABLE。(默认为打开状态，使用&lt;/span&gt;--skip-add-&lt;span&gt;locks取消选项)
mysqldump  &lt;/span&gt;-uroot -p --all-&lt;span&gt;databases  (默认添加LOCK语句)
mysqldump  &lt;/span&gt;-uroot -p --all-databases –skip-add-&lt;span&gt;locks   (取消LOCK语句)
&lt;/span&gt;--allow-&lt;span&gt;keywords
允许创建是关键词的列名字。这由表名前缀于每个列名做到。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --allow-&lt;span&gt;keywords
&lt;/span&gt;--apply-slave-&lt;span&gt;statements
在&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CHANGE MASTER&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;前添加&lt;span&gt;'&lt;/span&gt;&lt;span&gt;STOP SLAVE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;，并且在导出的最后添加&lt;span&gt;'&lt;/span&gt;&lt;span&gt;START SLAVE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --apply-slave-&lt;span&gt;statements
&lt;/span&gt;--character-sets-&lt;span&gt;dir
字符集文件的目录
mysqldump  &lt;/span&gt;-uroot -p --all-databases  --character-sets-dir=/usr/local/mysql/share/mysql/&lt;span&gt;charsets
&lt;/span&gt;--&lt;span&gt;comments
附加注释信息。默认为打开，可以用&lt;/span&gt;--skip-&lt;span&gt;comments取消
mysqldump  &lt;/span&gt;-uroot -p --all-&lt;span&gt;databases  (默认记录注释)
mysqldump  &lt;/span&gt;-uroot -p --all-databases --skip-&lt;span&gt;comments   (取消注释)
&lt;/span&gt;--&lt;span&gt;compatible
导出的数据将和其它数据库或旧版本的MySQL 相兼容。值可以为ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options等，
要使用几个值，用逗号将它们隔开。它并不保证能完全兼容，而是尽量兼容。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --compatible=&lt;span&gt;ansi
&lt;/span&gt;--&lt;span&gt;compact
导出更少的输出信息(用于调试)。去掉注释和头尾等结构。可以使用选项：&lt;/span&gt;--skip-add-drop-table  --skip-add-locks --skip-comments --skip-disable-&lt;span&gt;keys
mysqldump  &lt;/span&gt;-uroot -p --all-databases --&lt;span&gt;compact
&lt;/span&gt;--complete-insert,  -&lt;span&gt;c
使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --complete-&lt;span&gt;insert
&lt;/span&gt;--compress, -&lt;span&gt;C
在客户端和服务器之间启用压缩传递所有信息
mysqldump  &lt;/span&gt;-uroot -p --all-databases --&lt;span&gt;compress
&lt;/span&gt;--create-options,  -&lt;span&gt;a
在CREATE TABLE语句中包括所有MySQL特性选项。(默认为打开状态)
mysqldump  &lt;/span&gt;-uroot -p --all-&lt;span&gt;databases
&lt;/span&gt;--databases,  -&lt;span&gt;B
导出几个数据库。参数后面所有名字参量都被看作数据库名。
mysqldump  &lt;/span&gt;-uroot -p --&lt;span&gt;databases test mysql
&lt;/span&gt;--&lt;span&gt;debug
输出debug信息，用于调试。默认值为：d:t,&lt;/span&gt;/tmp/&lt;span&gt;mysqldump.trace
mysqldump  &lt;/span&gt;-uroot -p --all-databases --&lt;span&gt;debug
mysqldump  &lt;/span&gt;-uroot -p --all-databases --debug=” d:t,/tmp/&lt;span&gt;debug.trace”
&lt;/span&gt;--debug-&lt;span&gt;check
检查内存和打开文件使用说明并退出。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --debug-&lt;span&gt;check
&lt;/span&gt;--debug-&lt;span&gt;info
输出调试信息并退出
mysqldump  &lt;/span&gt;-uroot -p --all-databases --debug-&lt;span&gt;info
&lt;/span&gt;--&lt;span&gt;default&lt;/span&gt;-character-&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
设置默认字符集，默认值为utf8
mysqldump  &lt;/span&gt;-uroot -p --all-databases --&lt;span&gt;default&lt;/span&gt;-character-&lt;span&gt;set&lt;/span&gt;=&lt;span&gt;utf8
&lt;/span&gt;--delayed-&lt;span&gt;insert
采用延时插入方式（INSERT DELAYED）导出数据
mysqldump  &lt;/span&gt;-uroot -p --all-databases --delayed-&lt;span&gt;insert
&lt;/span&gt;--delete-master-&lt;span&gt;logs
master备份后删除日志. 这个参数将自动激活&lt;/span&gt;--master-&lt;span&gt;data。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --delete-master-&lt;span&gt;logs
&lt;/span&gt;--disable-&lt;span&gt;keys
对于每个表，用&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;!40000 ALTER TABLE tbl_name DISABLE KEYS &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;;和&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;!40000 ALTER TABLE tbl_name ENABLE KEYS &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;;语句引用INSERT语句。这样可以更快地导入dump出来的文件，因为它是在插入所有行后创建索引的。该选项只适合MyISAM表，默认为打开状态。
mysqldump  &lt;/span&gt;-uroot -p --all-&lt;span&gt;databases 
&lt;/span&gt;--dump-&lt;span&gt;slave
该选项将主的binlog位置和文件名追加到导出数据的文件中(show slave status)。设置为1时，将会以CHANGE MASTER命令输出到数据文件；设置为2时，会在change前加上注释。该选项将会打开&lt;/span&gt;--&lt;span&gt;lock&lt;/span&gt;-all-tables，除非--single-transaction被指定。该选项会自动关闭--&lt;span&gt;lock&lt;/span&gt;-&lt;span&gt;tables选项。默认值为0。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --dump-slave=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
mysqldump  &lt;/span&gt;-uroot -p --all-databases --dump-slave=&lt;span&gt;2&lt;/span&gt;
--master-&lt;span&gt;data
该选项将当前服务器的binlog的位置和文件名追加到输出文件中(show master status)。如果为1，将会输出CHANGE MASTER 命令；如果为2，输出的CHANGE  MASTER命令前添加注释信息。该选项将打开&lt;/span&gt;--&lt;span&gt;lock&lt;/span&gt;-all-tables 选项，除非--single-transaction也被指定（在这种情况下，全局读锁在开始导出时获得很短的时间；其他内容参考下面的--single-transaction选项）。该选项自动关闭--&lt;span&gt;lock&lt;/span&gt;-&lt;span&gt;tables选项。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --master-data=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --master-data=&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;--events, -&lt;span&gt;E
导出事件。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --&lt;span&gt;events
&lt;/span&gt;--extended-insert,  -&lt;span&gt;e
使用具有多个VALUES列的INSERT语法。这样使导出文件更小，并加速导入时的速度。默认为打开状态，使用&lt;/span&gt;--skip-extended-&lt;span&gt;insert取消选项。
mysqldump  &lt;/span&gt;-uroot -p --all-&lt;span&gt;databases
mysqldump  &lt;/span&gt;-uroot -p --all-databases--skip-extended-&lt;span&gt;insert   (取消选项)
&lt;/span&gt;--fields-terminated-&lt;span&gt;by
导出文件中忽略给定字段。与&lt;/span&gt;--tab选项一起使用，不能用于--databases和--all-&lt;span&gt;databases选项
mysqldump  &lt;/span&gt;-uroot -p test test --tab=”/home/mysql” --fields-terminated-by=&lt;span&gt;”#”
&lt;/span&gt;--fields-enclosed-&lt;span&gt;by
输出文件中的各个字段用给定字符包裹。与&lt;/span&gt;--tab选项一起使用，不能用于--databases和--all-&lt;span&gt;databases选项
mysqldump  &lt;/span&gt;-uroot -p test test --tab=”/home/mysql” --fields-enclosed-by=&lt;span&gt;”#”
&lt;/span&gt;--fields-optionally-enclosed-&lt;span&gt;by
输出文件中的各个字段用给定字符选择性包裹。与&lt;/span&gt;--tab选项一起使用，不能用于--databases和--all-&lt;span&gt;databases选项
mysqldump  &lt;/span&gt;-uroot -p test test --tab=”/home/mysql”  --fields-enclosed-by=”#” --fields-optionally-enclosed-by  =&lt;span&gt;”#”
&lt;/span&gt;--fields-escaped-&lt;span&gt;by
输出文件中的各个字段忽略给定字符。与&lt;/span&gt;--tab选项一起使用，不能用于--databases和--all-&lt;span&gt;databases选项
mysqldump  &lt;/span&gt;-uroot -p mysql user --tab=”/home/mysql” --fields-escaped-by=&lt;span&gt;”#”
&lt;/span&gt;--flush-&lt;span&gt;logs
开始导出之前刷新日志。
请注意：假如一次导出多个数据库(使用选项&lt;/span&gt;--databases或者--all-databases)，将会逐个数据库刷新日志。除使用--&lt;span&gt;lock&lt;/span&gt;-all-tables或者--master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用--&lt;span&gt;lock&lt;/span&gt;-all-tables 或者--master-data 和--flush-&lt;span&gt;logs。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --flush-&lt;span&gt;logs
&lt;/span&gt;--flush-&lt;span&gt;privileges
在导出mysql数据库之后，发出一条FLUSH  PRIVILEGES 语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --flush-&lt;span&gt;privileges
&lt;/span&gt;--&lt;span&gt;force
在导出过程中忽略出现的SQL错误。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --&lt;span&gt;force
&lt;/span&gt;--&lt;span&gt;help
显示帮助信息并退出。
mysqldump  &lt;/span&gt;--&lt;span&gt;help
&lt;/span&gt;--hex-&lt;span&gt;blob
使用十六进制格式导出二进制字符串字段。如果有二进制数据就必须使用该选项。影响到的字段类型有BINARY、VARBINARY、BLOB。
mysqldump  &lt;/span&gt;-uroot -p --all-databases --hex-&lt;span&gt;blob
&lt;/span&gt;--host, -&lt;span&gt;h
需要导出的主机信息
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-&lt;span&gt;databases
&lt;/span&gt;--ignore-&lt;span&gt;table
不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：&lt;/span&gt;--ignore-table=database.table1 --ignore-table=&lt;span&gt;database.table2 ……
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --ignore-table=&lt;span&gt;mysql.user
&lt;/span&gt;--include-master-host-&lt;span&gt;port
在&lt;/span&gt;--dump-slave产生的&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CHANGE  MASTER TO..&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;语句中增加&lt;span&gt;'&lt;/span&gt;&lt;span&gt;MASTER_HOST=&amp;lt;host&amp;gt;，MASTER_PORT=&amp;lt;port&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --include-master-host-&lt;span&gt;port
&lt;/span&gt;--insert-&lt;span&gt;ignore
在插入行时使用INSERT IGNORE语句.
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --insert-&lt;span&gt;ignore
&lt;/span&gt;--lines-terminated-&lt;span&gt;by
输出文件的每行用给定字符串划分。与&lt;/span&gt;--tab选项一起使用，不能用于--databases和--all-&lt;span&gt;databases选项。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost test test --tab=”/tmp/mysql”  --lines-terminated-by=&lt;span&gt;”##”
&lt;/span&gt;--&lt;span&gt;lock&lt;/span&gt;-all-tables,  -&lt;span&gt;x
提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭&lt;/span&gt;--single-transaction 和--&lt;span&gt;lock&lt;/span&gt;-&lt;span&gt;tables 选项。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --&lt;span&gt;lock&lt;/span&gt;-all-&lt;span&gt;tables
&lt;/span&gt;--&lt;span&gt;lock&lt;/span&gt;-tables,  -&lt;span&gt;l
开始导出前，锁定所有表。用READ  LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，&lt;/span&gt;--single-&lt;span&gt;transaction是一个更好的选择，因为它根本不需要锁定表。
请注意当导出多个数据库时，&lt;/span&gt;--&lt;span&gt;lock&lt;/span&gt;-&lt;span&gt;tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --&lt;span&gt;lock&lt;/span&gt;-&lt;span&gt;tables
&lt;/span&gt;--log-&lt;span&gt;error
附加警告和错误信息到给定文件
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases  --log-error=/tmp/&lt;span&gt;mysqldump_error_log.err
&lt;/span&gt;--&lt;span&gt;max_allowed_packet
服务器发送和接受的最大包长度。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --max_allowed_packet=&lt;span&gt;10240&lt;/span&gt;
--&lt;span&gt;net_buffer_length
TCP&lt;/span&gt;/&lt;span&gt;IP和socket连接的缓存大小。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --net_buffer_length=&lt;span&gt;1024&lt;/span&gt;
--no-&lt;span&gt;autocommit
使用autocommit&lt;/span&gt;/&lt;span&gt;commit 语句包裹表。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --no-&lt;span&gt;autocommit
&lt;/span&gt;--no-create-db,  -&lt;span&gt;n
只导出数据，而不添加CREATE DATABASE 语句。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --no-create-&lt;span&gt;db
&lt;/span&gt;--no-create-info,  -&lt;span&gt;t
只导出数据，而不添加CREATE TABLE 语句。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --no-create-&lt;span&gt;info
&lt;/span&gt;--no-data, -&lt;span&gt;d
不导出任何数据，只导出数据库表结构。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --no-&lt;span&gt;data
&lt;/span&gt;--no-&lt;span&gt;set&lt;/span&gt;-names,  -&lt;span&gt;N
等同于&lt;/span&gt;--skip-&lt;span&gt;set&lt;/span&gt;-&lt;span&gt;charset
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --no-&lt;span&gt;set&lt;/span&gt;-&lt;span&gt;names
&lt;/span&gt;--&lt;span&gt;opt
等同于&lt;/span&gt;--add-drop-table,  --add-locks, --create-options, --quick, --extended-insert, --&lt;span&gt;lock&lt;/span&gt;-tables,  --&lt;span&gt;set&lt;/span&gt;-charset, --disable-keys 该选项默认开启,  可以用--skip-&lt;span&gt;opt禁用.
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --&lt;span&gt;opt
&lt;/span&gt;--order-by-&lt;span&gt;primary
如果存在主键，或者第一个唯一键，对每个表的记录进行排序。在导出MyISAM表到InnoDB表时有效，但会使得导出工作花费很长时间。 
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --order-by-&lt;span&gt;primary
&lt;/span&gt;--password, -&lt;span&gt;p
连接数据库密码
&lt;/span&gt;--&lt;span&gt;pipe(windows系统可用)
使用命名管道连接mysql
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --&lt;span&gt;pipe
&lt;/span&gt;--port, -&lt;span&gt;P
连接数据库端口号
&lt;/span&gt;--&lt;span&gt;protocol
使用的连接协议，包括：tcp, socket, pipe, memory.
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --protocol=&lt;span&gt;tcp
&lt;/span&gt;--quick, -&lt;span&gt;q
不缓冲查询，直接导出到标准输出。默认为打开状态，使用&lt;/span&gt;--skip-&lt;span&gt;quick取消该选项。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-&lt;span&gt;databases 
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --skip-&lt;span&gt;quick
&lt;/span&gt;--quote-names,-&lt;span&gt;Q
使用（`）引起表和列名。默认为打开状态，使用&lt;/span&gt;--skip-quote-&lt;span&gt;names取消该选项。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-&lt;span&gt;databases
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --skip-quote-&lt;span&gt;names
&lt;/span&gt;--&lt;span&gt;replace
使用REPLACE INTO 取代INSERT INTO.
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --&lt;span&gt;replace
&lt;/span&gt;--result-file,  -&lt;span&gt;r
直接输出到指定文件中。该选项应该用在使用回车换行对（\\r\\n）换行的系统上（例如：DOS，Windows）。该选项确保只有一行被使用。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --result-file=/tmp/&lt;span&gt;mysqldump_result_file.txt
&lt;/span&gt;--routines, -&lt;span&gt;R
导出存储过程以及自定义函数。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --&lt;span&gt;routines
&lt;/span&gt;--&lt;span&gt;set&lt;/span&gt;-&lt;span&gt;charset
添加&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SET NAMES  default_character_set&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;到输出文件。默认为打开状态，使用--skip-&lt;span&gt;set&lt;/span&gt;-&lt;span&gt;charset关闭选项。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-&lt;span&gt;databases 
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --skip-&lt;span&gt;set&lt;/span&gt;-&lt;span&gt;charset
&lt;/span&gt;--single-&lt;span&gt;transaction
该选项在导出数据之前提交一个BEGIN SQL语句，BEGIN 不会阻塞任何应用程序且能保证导出时数据库的一致性状态。它只适用于多版本存储引擎，仅InnoDB。本选项和&lt;/span&gt;--&lt;span&gt;lock&lt;/span&gt;-tables 选项是互斥的，因为LOCK  TABLES 会使任何挂起的事务隐含提交。要想导出大表的话，应结合使用--&lt;span&gt;quick 选项。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --single-&lt;span&gt;transaction
&lt;/span&gt;--dump-&lt;span&gt;date
将导出时间添加到输出文件中。默认为打开状态，使用&lt;/span&gt;--skip-dump-&lt;span&gt;date关闭选项。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-&lt;span&gt;databases
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --skip-dump-&lt;span&gt;date
&lt;/span&gt;--skip-&lt;span&gt;opt
禁用–opt选项.
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --skip-&lt;span&gt;opt
&lt;/span&gt;--socket,-&lt;span&gt;S
指定连接mysql的socket文件位置，默认路径&lt;/span&gt;/tmp/&lt;span&gt;mysql.sock
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --socket=/tmp/&lt;span&gt;mysqld.sock
&lt;/span&gt;--tab,-&lt;span&gt;T
为每个表在给定路径创建tab分割的文本文件。注意：仅仅用于mysqldump和mysqld服务器运行在相同机器上。注意使用&lt;/span&gt;--tab不能指定--&lt;span&gt;databases参数
mysqldump  &lt;/span&gt;-uroot -p --host=localhost test test --tab=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home/mysql&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
--&lt;span&gt;tables
覆盖&lt;/span&gt;--databases (-&lt;span&gt;B)参数，指定需要导出的表名，在后面的版本会使用table取代tables。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --databases test --&lt;span&gt;tables test
&lt;/span&gt;--&lt;span&gt;triggers
导出触发器。该选项默认启用，用&lt;/span&gt;--skip-&lt;span&gt;triggers禁用它。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --&lt;span&gt;triggers
&lt;/span&gt;--tz-&lt;span&gt;utc
在导出顶部设置时区TIME_ZONE&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+00:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ，以保证在不同时区导出的TIMESTAMP 数据或者数据被移动其他时区时的正确性。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --tz-&lt;span&gt;utc
&lt;/span&gt;--user, -&lt;span&gt;u
指定连接的用户名。
&lt;/span&gt;--verbose, --&lt;span&gt;v
输出多种平台信息。
&lt;/span&gt;--version, -&lt;span&gt;V
输出mysqldump版本信息并退出
&lt;/span&gt;--&lt;span&gt;where&lt;/span&gt;, -&lt;span&gt;w
只转储给定的WHERE条件选择的记录。请注意如果条件包含命令解释符专用空格或字符，一定要将条件引用起来。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --&lt;span&gt;where&lt;/span&gt;=” user=&lt;span&gt;’root’”
&lt;/span&gt;--xml, -&lt;span&gt;X
导出XML格式.
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --&lt;span&gt;xml
&lt;/span&gt;--&lt;span&gt;plugin_dir
客户端插件的目录，用于兼容不同的插件版本。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --plugin_dir=”/usr/local/lib/&lt;span&gt;plugin”
&lt;/span&gt;--&lt;span&gt;default_auth
客户端插件默认使用权限。
mysqldump  &lt;/span&gt;-uroot -p --host=localhost --all-databases --&lt;span&gt;default&lt;/span&gt;-auth=”/usr/local/lib/plugin/&amp;lt;PLUGIN&amp;gt;”
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;参数说明&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_710c82bf-16e5-4612-9ea7-a284f12dc94b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_710c82bf-16e5-4612-9ea7-a284f12dc94b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_710c82bf-16e5-4612-9ea7-a284f12dc94b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;解决办法是：

&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;. 删除my.ini [client]下的 no-&lt;span&gt;beep 参数;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;. 在 mysqldump 后加--no-defaults参数,即:mysqldump --no-defualts -h主机IP -u用户名 -p密码 数据库 &amp;gt; xxx.sql 。
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;unknown option '--no-beep'&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.恢复逻辑备份&lt;/strong&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
#在mysql命令下，用source命令导入备份文件：
mysql&amp;gt;  USE 数据库名;
mysql&amp;gt;  source 备份文件.sql;

注意：只能在cmd界面下执行source命令，不能在mysql工具里面执行source命令，会报错，因为cmd是直接调用mysql.exe来执行命令的。　　
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 03 Mar 2018 04:45:00 +0000</pubDate>
<dc:creator>人生不如戏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fu-yong/p/8496361.html</dc:identifier>
</item>
<item>
<title>Linux下搭建FTP服务器 - 水果味的C</title>
<link>http://www.cnblogs.com/SyMind/p/8243454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SyMind/p/8243454.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、搭建环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        阿里云 CentOS 7.3 64位&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、FTP协议基础知识&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.1 简介&lt;/p&gt;
&lt;p&gt;        FTP 是 File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文件协议”。用于 Internet 上的控制文件的双向传输。&lt;/p&gt;
&lt;p&gt;2.2 FTP的运作流程与使用端口&lt;/p&gt;
&lt;p&gt;        FTP 的传输使用的是 TCP 传输协议，由于 FTP 服务的特点是数据量大、控制信息相对较少，因此在设计的时分别对控制信息与数据进行处理的方式，这样用于通信的 TCP 连接有两个：控制连接与数据连接。其中，控制连接用于在通信双方之间传输 FTP 命令与响应信息，完成连接建立、身份认证与异常处理等控制操作；数据连接用于在通信双方之间传输文件或目录信息。&lt;/p&gt;
&lt;p&gt;        FTP支持两种模式：Standard（PORT方式，主动方式），Passive（PASV，被动方式）。&lt;/p&gt;
&lt;p&gt;2.2.1 PORT 方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1138123/201801/1138123-20180109080921051-721607763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        图1 FTP服务器的 PORT 方式示意图&lt;/p&gt;
&lt;p&gt;        至于连接的过程是这样的：&lt;/p&gt;
&lt;p&gt;（1） 建立命令通道的连接&lt;/p&gt;
&lt;p&gt;        如上图所示，用户端会随机取一个大于1024以上的端口（port AA）来与FTP服务器端的port 21进行连接，这个过程当然需要经历TCP的三次握手！完成连接后用户端便可透过这个连接来对TCP服务器下达指令，包括查询文件名、下载、上传等等指令都是利用这个通道来下达的。&lt;/p&gt;
&lt;p&gt;（2）通知FTP服务器端使用 active 且告知连接的端口号&lt;/p&gt;
&lt;p&gt;        FTP 服务器的 21 端口主要用在命令下达，但是当关系到数据流时，就不是使用这个连接了。用户端在需要数据的情况下，会告知服务器端需要用什么方式来连接，如果是 PORT 模式时，用户端会先随机启用一个端口（图中的port BB），且通过命令通道告知 FTP 服务器这两个信息，并等待 FTP 服务器的连接。&lt;/p&gt;
&lt;p&gt;（3）FTP服务器【主动】向用户端连接&lt;/p&gt;
&lt;p&gt;        FTP 服务器由命令通道了解用户端的需求后，会主动的由 20 这个端口向用户端的 port BB 连接，这个连接当然也会经历 TCP 的三次握手！此时 FTP 的用户端与服务器端会建立两条连线，分别用在命令的下达与数据的传送。而预设 FTP 服务器端使用的主动连接端口就是port 20。&lt;/p&gt;
&lt;p&gt;2.2.2 PASV 方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1138123/201803/1138123-20180303120404721-1261888542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        图2 FTP服务器的 PASV 方式示意图&lt;/p&gt;
&lt;p&gt;（1）用户与服务器建立命令通道&lt;/p&gt;
&lt;p&gt;        同样的需要建立命令通道，通过三次握手就可以建立起这个通道了。&lt;/p&gt;
&lt;p&gt;（2）用户端发出PASV的连接请求&lt;/p&gt;
&lt;p&gt;        当有使用数据通道的指令时，用户端可通过命令通道发出 PASV 的被动式连接要求（Passive 的缩写），并等待服务器的回应。&lt;/p&gt;
&lt;p&gt;（3）FTP服务器启动数据端口，并通知用户端连接&lt;/p&gt;
&lt;p&gt;        如果你的 FTP 服务器能够处理被动式连接，此时 FTP 服务器会先启动一个端口在监听。这个端口号码可能是随机的，也可以是某一范围的端口，具体看你的 FTP 服务器软件而定。然后你的 FTP 服务器会通过命令通道告知用户端已经启动的端口（图中的 port PASV），并等待用户端的连接。&lt;/p&gt;
&lt;p&gt;（4）用户端随机取用大于1024的端口进行连接&lt;/p&gt;
&lt;p&gt;         然后你的用户端会随机取用一个大于 1024 的端口号来对主机的 port PASV 连接。&lt;/p&gt;
&lt;p&gt;2.3 用户分类&lt;/p&gt;
&lt;p&gt;2.2.1 Real账户&lt;/p&gt;
&lt;p&gt;        这类用户是指在FTP服务上拥有账号。当这类用户登陆FTP服务器的时候，其默认的主目录就是其账号命名的目录。但是，其还可以变更到其他目录中去。如系统的主目录等等。&lt;/p&gt;
&lt;p&gt;2.2.2 Guest用户&lt;/p&gt;
&lt;p&gt;        在FTP服务器中，我们往往会给不同的部门或者某个特定的用户设置一个帐户。但是，这个账户有个特点，就是其只能够访问自己的主目录。服务器通过这种方式来保障FTP服务上其他文件的安全性。这类帐户，在Vsftpd软件中就叫做Guest用户。拥有这类用户的帐户，只能够访问其主目录下的目录，而不得访问主目录以外的文件。&lt;/p&gt;
&lt;p&gt;2.2.3 Anonymous（匿名）用户&lt;/p&gt;
&lt;p&gt;        这也是我们通常所说的匿名访问。这类用户是指在FTP服务器中没有指定帐户，但是其仍然可以进行匿名访问某些公开的资源。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、VSFTP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.1 简介&lt;/p&gt;
&lt;p&gt;        VSFTP 是一个基于 GPL 发布的类 Unix 系统上使用的 FTP 服务器软件，它的全称是 Very Secure FTP。&lt;/p&gt;
&lt;p&gt;3.2 安装&lt;/p&gt;
&lt;p&gt;        查看是否装有 vsftpd 服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rpm -qa | &lt;span&gt;grep&lt;/span&gt; vsftpd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        若不存在，则使用 yum 命令直接安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; -y &lt;span&gt;install&lt;/span&gt; vsftpd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.3 配置 vsftpd&lt;/p&gt;
&lt;p&gt;        修改配置文件，默认路径为 /etc/vsftpd/vsftpd.conf，命令如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vim /etc/ftpd/ftpd.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        以下为需要修改或添加的配置项。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;anonymous_enable=NO #不允许匿名用户登陆&lt;/li&gt;
&lt;li&gt;chroot_list_enable=YES #chroot_list_file 指定文件中指定的用户禁锢在其主目录中&lt;/li&gt;
&lt;li&gt;chroot_list_file=/etc/vsftpd/chroot_list&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        在 /etc/vsftpd 目录下建立文件 chroot_list，命令如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /etc/&lt;span&gt;vsftpd
&lt;/span&gt;&lt;span&gt;touch&lt;/span&gt; chroot_list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        在 chroot_list 里添加 FTP 用户的用户名，每个用户一样，这里我添加的用户名为 symind。&lt;/p&gt;
&lt;p&gt;3.4 添加 FTP 用户组及用户&lt;/p&gt;
&lt;p&gt;        添加一个用户组，这里我命名为 webftp。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
groupadd webftp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        在用户组中添加用户，并指定用户的主目录。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
useradd -g webftp -M -d /home/www -s /sbin/nologin symind
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        设置密码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;passwd&lt;/span&gt; symind
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt; 修改目录拥有者。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;chown&lt;/span&gt; -R symind.webftp /home/www
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt; 修改目录权限，vsftp 默认要求如果用户被限定在了其主目录下，则该用户的主目录不能再具有写权限了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;chmod&lt;/span&gt; u=rx /home/www
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        也可以更改 vsftpd 的配置，allow_writeable_chroot=YES。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. 百度百科 - ftp（文件传输协议） https://baike.baidu.com/item/ftp/13839?fr=aladdin&lt;/p&gt;
&lt;p&gt;2. 百度百科 - VSFTP https://baike.baidu.com/item/VSFTP/2596628?fr=aladdin&lt;/p&gt;
&lt;p&gt;3. 鳥哥的&lt;span class=&quot;text_head_en&quot;&gt; Linux 私房菜 - &lt;span class=&quot;text_head0&quot;&gt;檔案伺服器之三&lt;span class=&quot;text_head_en&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;http://linux.vbird.org/linux_server/0410vsftpd.php&lt;/p&gt;
&lt;p&gt;4. vsftpd：500 OOPS: vsftpd: refusing to run with writable root inside chroot()错误的解决方法 http://blog.csdn.net/bluishglc/article/details/42399439&lt;/p&gt;
&lt;p&gt;5. CentOS下vsftp设置、匿名用户&amp;amp;本地用户设置、PORT、PASV模式设置 http://desert3.iteye.com/blog/1685734&lt;/p&gt;
</description>
<pubDate>Sat, 03 Mar 2018 04:41:00 +0000</pubDate>
<dc:creator>水果味的C</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SyMind/p/8243454.html</dc:identifier>
</item>
<item>
<title>五子棋的判断输赢规则 -- java编程（简单优化完整版） - 弹琴不谈情</title>
<link>http://www.cnblogs.com/lrj1009IRET/p/8496299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lrj1009IRET/p/8496299.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五子棋的判断输赢规则代码 —— 完整优化版&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;之前浏览过很多网上的方法，但总找不到比较完整，也get不到其他大神的思路，就直接画图分析，分析了之后就有了如下的代码，当然还想到更加优化的一种，只不过，还在完善中，后续再发上来分享。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 二&lt;strong&gt;、分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;&lt;span&gt;1、分析图水平方向，以传入的 X 坐标作为分割线，Y 坐标为偏移点左右遍历。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1333070/201803/1333070-20180303121618110-1587691783.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　       2、分析图垂直方向，以传入的 Y 坐标作为分割线，X 坐标为偏移点上下遍历。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1333070/201803/1333070-20180303121544855-345349399.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　3、分析图左上右下方向，以传入的 坐标点上的与对角线平行的线作为分割线，按箭头方向左右遍历。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1333070/201803/1333070-20180303121703342-809691606.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　   4、分析图右下左上方向，以传入的 坐标点上的与对角线平行的线作为分割线，按箭头方向左右遍历。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1333070/201803/1333070-20180303121841864-1513314257.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　请理解分析图在看代码-------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　三、代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;1、方法说明：判断是否五子连线 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　2、参数：坐标：x，y；棋子颜色&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;、返回类型：boolean&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isWon2(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;char&lt;/span&gt;&lt;span&gt; color) {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; count = 1;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本身一点为 1&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; posX = 0&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; posY = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;判断水平方向上的胜负
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;        /* 将水平方向以传入的点x上的y轴作为分隔线分为两部分
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;         * 先向左边遍历，判断到的相同的连续的点  count++
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(posX = x - 1; posX &amp;gt; 0 ; posX--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (board[posX][y] ==&lt;span&gt; color) {
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;                 count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (count &amp;gt;= 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;         }    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;向右边遍历&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(posX = x + 1; posX &amp;lt;= 15; posX++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (board[posX][y] ==&lt;span&gt; color) {
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;                 count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (count &amp;gt;= 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;判断垂直方向上的胜负
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;        /* 将垂直方向以传入的点y上的x轴作为分隔线分为两部分
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;         * 先向上遍历，判断到的相同的连续的点  count++
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(posY = y - 1; posY &amp;gt; 0; posY--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (board[x][posY] ==&lt;span&gt; color) {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;                 count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (count &amp;gt;= 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向下遍历&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(posY = y + 1; posY &amp;lt;= 15; posY++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (board[x][posY] ==&lt;span&gt; color) {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (count &amp;gt;= 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;判断左上右下方向上的胜负
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;         * 以坐标点为分割线，将棋盘分为左右两个等腰三角形 
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;         * 先判断左边的
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(posX = x - 1, posY = y - 1; posX &amp;gt; 0 &amp;amp;&amp;amp; posY &amp;gt; 0; posX--, posY--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (board[posX][posY] ==&lt;span&gt; color) {
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                 count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (count &amp;gt;= 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                     count = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断右边的&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(posX = x + 1, posY = y + 1; posX &amp;lt;= 15 &amp;amp;&amp;amp; posY &amp;lt;= 15; posX++, posY++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (board[posX][posY] ==&lt;span&gt; color) {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                 count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (count &amp;gt;= 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                     count = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;判断右下左下方向上的胜负
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;         * 以坐标点为分割线，将棋盘分为左右两个等腰三角形 
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;         * 先判断左边的
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(posX = x + 1, posY = y - 1; posX &amp;lt;= 15 &amp;amp;&amp;amp; posY &amp;gt; 0; posX++, posY--&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (board[posX][posY] ==&lt;span&gt; color) {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                 count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (count &amp;gt;= 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;         }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断右边的&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(posX = x - 1, posY = y + 1; posX &amp;gt; 0 &amp;amp;&amp;amp; posY &amp;lt;= 15; posX--, posY++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (board[posX][posY] ==&lt;span&gt; color) {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                 count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (count &amp;gt;= 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　四、后续&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1、这个算法原理也是很简单的，不过比全部遍历法要优化很多，而且规范&lt;/p&gt;
&lt;p&gt;　　　　2、后续有空我会把我想到的一个最优化的算法分析图放上来，判断的运行时间更短。&lt;/p&gt;
&lt;p&gt;　　　　3、喜欢点个推荐呗，有错误还望各位指出，本人新手，谢谢！&lt;/p&gt;
&lt;p&gt;　　　　4、转发请注原文地址，谢谢。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Mar 2018 04:25:00 +0000</pubDate>
<dc:creator>弹琴不谈情</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lrj1009IRET/p/8496299.html</dc:identifier>
</item>
<item>
<title>浅谈 maxMemory , totalMemory , freeMemory 和 OOM 与 native Heap - 指尖下的幽灵</title>
<link>http://www.cnblogs.com/linguanh/p/8496002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linguanh/p/8496002.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：林冠宏 / 指尖下的幽灵&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.80357142857143&quot;&gt;
&lt;p&gt;掘金：&lt;a href=&quot;https://juejin.im/user/587f0dfe128fe100570ce2d8&quot; class=&quot;uri&quot;&gt;https://juejin.im/user/587f0dfe128fe100570ce2d8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.0975609756098&quot;&gt;
&lt;p&gt;博客：&lt;a href=&quot;http://www.cnblogs.com/linguanh/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/linguanh/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.3095238095238&quot;&gt;
&lt;p&gt;GitHub ： &lt;a href=&quot;https://github.com/af913337456/&quot; class=&quot;uri&quot;&gt;https://github.com/af913337456/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.2179487179487&quot;&gt;
&lt;p&gt;腾讯云专栏： &lt;a href=&quot;https://cloud.tencent.com/developer/user/1148436/activities&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/user/1148436/activities&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;回答内存管理类面试问题可以说出下面这些内容加分&quot;&gt;回答内存管理类面试问题可以说出下面这些内容，加分。&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;&lt;code&gt;前言： 站在巨人的肩膀上，总结此文。&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Java runtime 三个计算内存函数&lt;/li&gt;
&lt;li&gt;OOM 的说法，为什么大型游戏能申请那么多内存？&lt;/li&gt;
&lt;li&gt;如何绕过dalvikvm heap size的限制 ？&lt;/li&gt;
&lt;li&gt;Bitmap分配在native heap还是dalvik heap上？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;java-runtime-三个计算内存函数&quot;&gt;1，Java runtime 三个计算内存函数：&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;maxMemory&lt;/code&gt;&lt;br/&gt;获取当前 APP 最大能够申请的内存，在 Java Heap 部分。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;totalMemory&lt;/code&gt;&lt;br/&gt;获取当前 APP 已经从系统拿到的内存，包含使用上了的和没有用上的，因为一般申请会申请多一部分，它总是慢慢按需要从系统拿取。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;freeMemory&lt;/code&gt;&lt;br/&gt;获取当前 APP 拿到的内存中，还没用上的，即是可以被 gc 回收的。&lt;/p&gt;
&lt;p&gt;计算此刻 APP 在 Java Heap 层次已经使用了的内存 &lt;code&gt;usedMemory&lt;/code&gt; ：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
usedMemory = totalMemory - freeMemory&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;oom-的说法为什么大型游戏能申请那么多内存&quot;&gt;2，OOM 的说法，为什么大型游戏能申请那么多内存？&lt;/h2&gt;
&lt;p&gt;在不同的 Android 系统版本中，OOM 的判断是不一样的。&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通俗来说，OOM 是当前进程共申请的内存综和超过一个限制，而被抛出。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;专业来说，Android为每个进程设置Dalvik Heap Size阈值，这个阈值在不同的设备上会因为RAM大小不同而各有差异。如果APP想要分配的内存超过这个阈值，就会发生OOM。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Android &lt;code&gt;3.x以前&lt;/code&gt;，Bitmap分配在Native heap中，而在&lt;code&gt;3.x之后&lt;/code&gt;，Bitmap分配在Dalvik或ART的Java heap中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Android 2.x系统，当dalvik allocated + native allocated + 新分配的大小 &amp;gt;= dalvik heap 最大值时候就会发生OOM，也就是说在2.x系统中，考虑native heap对每个进程的内存限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Android 3.x系统，废除了native的计数器，类似bitmap的分配改到dalvik的java heap中申请，只要allocated + 新分配的内存 &amp;gt;= dalvik heap 最大值的时候就会发生OOM（art运行环境的统计规则还是和dalvik保持一致），也就是说在3.x系统中，不考虑native heap对每个进程的内存限制，native heap只会收到本机总内存（包括RAM以及SWAP区或分页文件）的限制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;这也是为什么有些app比如大型游戏可以超过-dalvik-heap-size-这个值那是因为java内存又分为java-heap和native-heap3.x-后-native-heap是不受该值约束的像cc的内存都是在native-heap中分配的另外bitmap是在java-heap中分配的我们开发过程中经常遇到由bitmap引起的oom这就是一个例子&quot;&gt;这也是为什么有些APP（比如大型游戏）可以超过 Dalvik Heap Size 这个值？那是因为Java内存又分为Java Heap和Native Heap，3.X 后 Native Heap是不受该值约束的。像C/C++的内存都是在Native Heap中分配的。另外Bitmap是在Java Heap中分配的，我们开发过程中经常遇到由Bitmap引起的OOM，这就是一个例子。&lt;/h4&gt;
&lt;h2 id=&quot;如何绕过dalvikvm-heap-size的限制&quot;&gt;3，如何绕过dalvikvm heap size的限制 ？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;创建子进程上面说了内存分配按进程来再使用进程通讯&quot;&gt;创建子进程，上面说了，内存分配按进程来。再使用进程通讯&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;创建一个新的进程，那么我们就可以把一些对象分配到新进程的heap上了，从而达到一个应用程序使用更多的内存的目的，当然，创建子进程会增加系统开销，而且并不是所有应用程序都适合这样做，视需求而定。&lt;/p&gt;
&lt;p&gt;创建子进程的方法：使用android:process标签&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;按不同的系统版本使用-jni-在native-heap上申请空间推荐使用&quot;&gt;按不同的系统版本，使用 jni 在native heap上申请空间（推荐使用）&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.X 后的系统 native heap的增长并不受dalvik vm heapsize的限制，只要RAM有剩余空间，程序员可以一直在native heap上申请空间，当然如果 RAM快耗尽，memory killer会杀进程释放RAM。大家使用一些软件时，有时候会闪退，就可能是软件在native层申请了比较多的内存导致的。比如，我就碰到过UC web在浏览内容比较多的网页时闪退，原因就是其native heap增长到比较大的值，占用了大量的RAM，被memory killer杀掉了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;使用显存操作系统预留ram的一部分作为显存&quot;&gt;使用显存（操作系统预留RAM的一部分作为显存）&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用OpenGL textures等API，texture memory不受dalvik vm heapsize限制，这个我没有实践过。再比如Android中的GraphicBufferAllocator申请的内存就是显存。&lt;/p&gt;
&lt;h2 id=&quot;bitmap分配在native-heap还是dalvik-heap上&quot;&gt;4，Bitmap分配在native heap还是dalvik heap上？&lt;/h2&gt;
&lt;p&gt;上面说了，不同的系统版本不同，那么在 3.X 及其之后，为什么在 java heap 而不是在 native heap 。请看下面源码。&lt;/p&gt;
&lt;p&gt;主要的文件&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;framework/base/graphic/java/Android/graphics/BitmapFactory.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;  
framework/base/core/jni/Android/graphics/BitmapFactory.&lt;span class=&quot;fu&quot;&gt;cpp&lt;/span&gt;  
framework/base/core/jni/Android/graphics/Graphics.&lt;span class=&quot;fu&quot;&gt;cpp&lt;/span&gt;  &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BitmapFactory.java 里面有几个decode***方法用来创建bitmap，最终都会调用：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; staticnative Bitmap &lt;span class=&quot;fu&quot;&gt;nativeDecodeStream&lt;/span&gt;(InputStream is, &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] storage,Rect padding,Options opts);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而&lt;code&gt;nativeDecodeStream()&lt;/code&gt;会调用到&lt;code&gt;BitmapFactory.cpp&lt;/code&gt;中的&lt;code&gt;deDecode&lt;/code&gt;方法，最终会调用到&lt;code&gt;Graphics.cpp&lt;/code&gt;的&lt;code&gt;createBitmap&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;createBitmap方法的实现:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode c++&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;jobjectGraphicsJNI::createBitmap(JNIEnv* env, SkBitmap* bitmap, jbyteArray buffer,  
                                  boolisMutable, jbyteArray ninepatch, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; density)  
{  
    SkASSERT(bitmap);  
    SkASSERT(bitmap-&amp;gt;pixelRef());  
   
    jobject obj = env-&amp;gt;NewObject(gBitmap_class, gBitmap_constructorMethodID,  
           &lt;span class=&quot;kw&quot;&gt;static_cast&lt;/span&gt;&amp;lt;jint&amp;gt;(&lt;span class=&quot;kw&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;uintptr_t&amp;gt;(bitmap)),  
            buffer, isMutable, ninepatch,density);  
    hasException(env); &lt;span class=&quot;co&quot;&gt;// For the side effectof logging.  &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; obj;  
}  &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从代码中可以看到&lt;code&gt;bitmap&lt;/code&gt;对象是通过&lt;code&gt;env-&amp;gt;NewOject(...)&lt;/code&gt;创建的，到这里疑惑就解开了，bitmap对象是虚拟机创建的，JNIEnv的NewOject方法返回的是java对象，并不是native对象，所以它会分配到&lt;code&gt;dalvik heap&lt;/code&gt;中。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Mar 2018 02:46:00 +0000</pubDate>
<dc:creator>指尖下的幽灵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linguanh/p/8496002.html</dc:identifier>
</item>
<item>
<title>javascript 函数详解 - 柴小智</title>
<link>http://www.cnblogs.com/chaixiaozhi/p/6718110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaixiaozhi/p/6718110.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、函数的一些基础概念：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.js中的函数使用function来声明。&lt;/p&gt;
&lt;p&gt;2.关于return：&lt;/p&gt;
&lt;p&gt;2.1  函数在执行到return语句后悔立即停止并退出，return后面的代码永远不会得到执行；&lt;/p&gt;
&lt;p&gt;2.2  函数不必指定是否返回值，&lt;span&gt;只要return语句后跟要返回的值即可实现返回值&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;2.3  return语句不带任何返回值时，会返回undefined值，这种做法一般用在需要提前停止函数执行而又不需要返回值的情况。&lt;/p&gt;
&lt;p&gt;3.理解参数：&lt;/p&gt;
&lt;p&gt;3.1  函数不介意传递进来&lt;strong&gt;参数个数以及类型&lt;/strong&gt;，因为js中的参数在内部是用一个数组来表示的，&lt;strong&gt;函数接收到的始终是这个数组&lt;/strong&gt;，至于数组中包含的内容并不关心。&lt;/p&gt;
&lt;p&gt;（&lt;span&gt;即使你定义的函数只接收两个参数，那么你传递一个或三个或不传参数都无所谓&lt;/span&gt;）；&lt;/p&gt;
&lt;p&gt;3.2  可以使用arguments对象来访问参数数组，arguments[i]来访问第i+1个参数，arguments.length确定传递进来的参数的个数；&lt;/p&gt;
&lt;p&gt;3.3  没有传递值的命名参数将被自动赋值undefined；&lt;/p&gt;
&lt;p&gt;3.4 &lt;span&gt; js中所有的参数都是值传递，没有引用传递；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;span&gt;没有重载：&lt;/span&gt;如果出现两个相同名字的函数，后者会覆盖前者。但是我们可以&lt;span&gt;控制传递参数的类型和数量&lt;/span&gt;让函数做出不同的反应，从而模仿重载的实现。&lt;/p&gt;

&lt;p&gt;二、深入理解Function类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JS 中Function类型实际上是一种对象，每一个函数实际上都是Function类型的一个实例，&lt;/strong&gt;函数通常是使用函数声明语法定义的，每一个函数都有一些默认的属性和方法；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于函数是对象，故函数名实际上也是一个指向函数对象的指针变量，不会与某个函数绑定，&lt;/strong&gt;&lt;span&gt;函数是对象，函数名是指针&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.函数声明与表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数声明会优先被读取使用（可以提前访问）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    console.log(test(10,10&lt;span&gt;))　　&lt;span&gt;//20
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(num1,num2) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1+&lt;span&gt;num2;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;函数表达式则必须等到执行完它所在的表达行后再可以使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    console.log(test(10,10&lt;span&gt;))　　&lt;span&gt;//会报错
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; test = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (num1,num2) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1+&lt;span&gt;num2;
    };&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.作为值的函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;js中的函数名本身就是变量，所以函数也可以作为值来使用，可以像传递参数一样把一个函数传递给另一个函数。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sum (num1, num2) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fuc (num3, num4) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num3 +&lt;span&gt; num4;
}
console.log(fuc(sum(&lt;/span&gt;2,3), 5));　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;js中的函数名本身就是变量，所以可以将一个函数作为另一个函数的结果返回。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sum (num1, num2) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1+&lt;span&gt;num2;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func(num1){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sum(num1,10&lt;span&gt;);
}
alert(func(&lt;/span&gt;10));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;line number2 index1 alt1&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;函数&lt;strong&gt;内部属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在函数内部包含两个特殊的对象：arguments和this&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;arguments:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;arguments 是一个类数组，用来保存函数传递过来的参数。&lt;/p&gt;
&lt;p&gt;arguments 中还有一个很重要的属性就是&lt;strong&gt;callee，是一个指针变量&lt;/strong&gt;，指向的是&lt;strong&gt;arguments所在的函数本身&lt;/strong&gt;，&lt;strong&gt;在递归的时候最好用这个属性&lt;/strong&gt;，因为如果函数名改变了，也不需要改变内部的实现，&lt;strong&gt;arguments.callee()始终代表的是这个函数本身。 &lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用arguments.callee的好处是，当函数名改变了以后，不需要改动递归出的函数，&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; box(num){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(num&amp;lt;=1&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num*arguments.callee(num-1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;arguments.callee代表的是函数的本身，故和上面是同样的效果&lt;/span&gt;
&lt;span&gt;    }
}
alert(box(&lt;/span&gt;3));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;this:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;this 这个属性代表的是&lt;span&gt;它所在的对象本身&lt;/span&gt;，&lt;strong&gt;this 引用的是函数据以&lt;span&gt;执行的环境对象，也就是函数执行的作用域&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;window是JS中最大的一个对象，在window对象中声明一个变量其实就是给window这个对象声明一个属性，var box=1;相当于 window.box=1;也就等价于this.box=1;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当在全局作用域中调用函数时，this 对象引用的就是 window。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在显示的声明一个对象box，这个box中使用的this就代表的是box本身，&lt;/strong&gt;this.color就是返回的box中属性color的值，而不是window对象中color的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this 代表的是对象本身，下面在对象box中的this，就代表对象box&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; color='红色'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; window对象的属性，&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; box=&lt;span&gt;{
    color:&lt;/span&gt;'蓝色'&lt;span&gt;,
    run:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        alert(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;蓝色&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.color;
    }
}
alert(window.color);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;红色&lt;/span&gt;
alert(&lt;span&gt;this&lt;/span&gt;.color); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;红色 此处this代表的是window对象，故this.color是代表的window的属性&lt;/span&gt;
alert(box.run()); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;蓝色&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.函数的属性和方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个函数都包含两个属性：length和prototype&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;length:函数的属性length代表的是函数希望接收的参数的个数，是由声明函数时参数列表中的个数决定的。&lt;/p&gt;
&lt;p&gt;prototype:&lt;strong&gt;prototype 是保存所有实例方法的真正所在，也就是原型。&lt;/strong&gt;  &lt;/p&gt;
&lt;p&gt;prototype 下面有两个方法&lt;span&gt;&lt;strong&gt; apply()，call()，&lt;/strong&gt;&lt;/span&gt;这两个方法都是函数&lt;strong&gt;非继承而来的方法&lt;/strong&gt;，  是每一个函数都具有的方法。&lt;/p&gt;
&lt;p&gt;这两个方法的&lt;strong&gt;&lt;span&gt;用途都是在特定的作用域中调用函数&lt;/span&gt;(看this指向的作用域是谁)&lt;/strong&gt;，也就是说调用特定的对象下面调用函数，有点类似于&lt;strong&gt;C#的反射&lt;/strong&gt;中调用对象的方法。  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sum (num1, num2) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = sum.apply(&lt;span&gt;this&lt;/span&gt;,[10,20&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = sum.call(&lt;span&gt;this&lt;/span&gt;,10,20&lt;span&gt;);
console.log(result);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;func.apply():&lt;/strong&gt;这个方法有两个参数，&lt;strong&gt;第一个是要执行这个方法的作用域&lt;/strong&gt;，也就是传递一个对象过去，&lt;strong&gt;第二个参数是一个数组&lt;/strong&gt;，这个数组中是存放的调用的函数func的实参，也就是要传递给func的值，当然第二个参数可以省略。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;func.call()：&lt;/strong&gt;这个方法和上面的apply()方法是一样的，不同的是参数，第一个同样是作用域，是一样的，&lt;strong&gt;其余的参数是逐个列举出啦传递给函数的，而不是传递一个数组过去&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; color='red'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; box=&lt;span&gt;{
    color:&lt;/span&gt;'green'&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sayColor(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.color;
}

alert(sayColor());          　　　　　　  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;red       对象是window&lt;/span&gt;
alert(sayColor.apply(window));  　　　　 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;red       对象是window&lt;/span&gt;
alert(sayColor.apply(&lt;span&gt;this&lt;/span&gt;));            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;red       对象是window&lt;/span&gt;
alert(sayColor.apply(box));     　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;green      对象是box&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;使用这apply()和call()这两个方法来&lt;span&gt;扩充作用域&lt;/span&gt;最大的好处是&lt;span&gt;对象不需要与方法发生任何的耦合关系&lt;/span&gt;&lt;/strong&gt;，也就是上面说的对象中可能不存在这个方法，但只要存在这个对象就OK。&lt;/p&gt;

</description>
<pubDate>Sat, 03 Mar 2018 02:41:00 +0000</pubDate>
<dc:creator>柴小智</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaixiaozhi/p/6718110.html</dc:identifier>
</item>
<item>
<title>试着把.net的GC讲清楚(3) - 奔跑的Abbott</title>
<link>http://www.cnblogs.com/fenqi/p/8495919.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fenqi/p/8495919.html</guid>
<description>&lt;h3 id=&quot;root&quot;&gt;root&lt;/h3&gt;
&lt;p&gt;第一篇文章中讲了GC在遍历存活对象的时候，都是从root开始的，root是一些对象的引用，例如：全局对象、静态对象等。&lt;/p&gt;
&lt;p&gt;如果要减少root的个数，那么就可以从静态对象入手，减少静态对象，毕竟静态对象一直存活到程序结束。&lt;/p&gt;
&lt;p&gt;全局对象为什么不考虑？原因很简单，就是静态对象更容易优化，全局对象的一个程序中也没有几个，如果优化过程中，必然需要把全局对象的内容放到其它的地方，例如塞到另一个类里面，那么会造成这个类膨胀起来。&lt;br/&gt;当然这也是一种方法。&lt;/p&gt;
&lt;h3 id=&quot;loh&quot;&gt;LOH&lt;/h3&gt;
&lt;p&gt;之前了解到&amp;gt;=85000个字节的对象，会放到大对象的堆里面，并且在gen2回收的时候才进行回收，且不进行内存压缩，内存稍紧张的时候，就会造成少许浪费，所以&lt;br/&gt;这个我们需要控制对象的体积，让它尽可能&amp;lt;85000。&lt;/p&gt;
&lt;h3 id=&quot;gen0gen1gen2&quot;&gt;gen0、gen1、gen2&lt;/h3&gt;
&lt;p&gt;当gc触发回收gen0的时候，那么此次存活的对象会升代，理想情况让gen0的大小在一次回收过程中，就可以得到内存空间，也就是需要减少一个对象的生存周期，让对象的生存周期尽可能短。&lt;/p&gt;
&lt;p&gt;在生存周期非常短的情况，那么gen0的回收一次会获取很大的内存空间，且升代的对象非常少，那么gc就没有必要再向OS申请内存资源了。&lt;/p&gt;
&lt;h3 id=&quot;gc申请内存资源&quot;&gt;gc申请内存资源&lt;/h3&gt;
&lt;p&gt;在创建对象的时候，gc在自己可用内存不够的情况下，会向os申请新的内存资源，并在gc回收内存后，并不会返回内存给os。所以就如之前的前一节说的，减少对象&lt;br/&gt;可以让os有更多的可调配资源。&lt;/p&gt;
&lt;h3 id=&quot;weak-reference&quot;&gt;Weak Reference&lt;/h3&gt;
&lt;p&gt;在GC回收的时候，weak reference的对象是会被当做垃圾的，所以这个慎用，基于这个特性，在某些场景下，weak reference的对象在使用的时候可以进行判断是否已经被回收。&lt;br/&gt;如果回收了，那么重新在申请，比如某些占内存的外部资源，就可以使用weak reference来减少内存紧张带来的问题。&lt;/p&gt;
&lt;h3 id=&quot;finalize方法&quot;&gt;finalize方法&lt;/h3&gt;
&lt;p&gt;还记得一个对象含有finalize方法的特点吗？需要GC两次才可能被回收，且GC的时间不定，所以非托管资源尽可能不使用finalize，对于内存紧张的情况，就不要使用了，不然&lt;br/&gt;需要2次gc，gc的时候程序性能特别差。&lt;/p&gt;
&lt;h3 id=&quot;workstationserver-gc-mode&quot;&gt;workstation、server gc mode&lt;/h3&gt;
&lt;p&gt;保守的资源用workstation gc mode，非保守的资源用server gc mode，然后在用用cocurrent方式提升一下gc的性能，减少程序执行挂起时间。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;用理论指导实际，需要场景来支持，现在很多的程序的各种结构和算法都是为了提高性能而设计的，所以为了性能，很多的架构或者程序算法还有其他的辅助功能，也是很合理了。&lt;/p&gt;
</description>
<pubDate>Sat, 03 Mar 2018 02:14:00 +0000</pubDate>
<dc:creator>奔跑的Abbott</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fenqi/p/8495919.html</dc:identifier>
</item>
</channel>
</rss>