<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Kubernetes的简单部署 - (|^_^|||)</title>
<link>http://www.cnblogs.com/L-dongf/p/9539464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/L-dongf/p/9539464.html</guid>
<description>&lt;h3 id=&quot;一基础环境配置&quot;&gt;一、基础环境配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;操作系统：CentOS 7.5，三台节点，1台master，2台nodes&lt;/li&gt;
&lt;li&gt;关闭selinux和firewalld&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# vim /etc/selinux/config
SELINUX=disabled
# setenforce 0
# systemctl stop firewalld
# systemctl disable firewalld&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置chronyd服务，保证各node时间同步（此处使用阿里巴巴提供的ntp时间服务器）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# yum install chrony
# vim /etc/chrony.conf
server ntp.aliyun.com iburst
stratumweight 0
driftfile /var/lib/chrony/drift
rtcsync
makestep 10 3
bindcmdaddress 127.0.0.1
bindcmdaddress ::1
keyfile /etc/chrony.keys
commandkey 1
generatecommandkey
logchange 0.5
logdir /var/log/chrony
# systemctl enable chronyd 
# systemctl start chronyd&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;基于ssh秘钥认证，并且基于域名解析&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# vim /etc/hosts
192.168.0.12    master.dongfei.tech master
192.168.0.13    node01.dongfei.tech node01
192.168.0.14    node02.dongfei.tech node02
[root@master ~]# ssh-keygen
[root@master ~]# ssh-copy-id -i .ssh/id_rsa.pub node01
[root@master ~]# ssh-copy-id -i .ssh/id_rsa.pub node02
[root@master ~]# scp /etc/hosts node01:/etc/
[root@master ~]# scp /etc/hosts node02:/etc/&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;网络环境规划&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;节点网络：192.168.0.0/24（需要手动配置，推荐配置静态地址）&lt;/p&gt;
&lt;p&gt;Pod网络：10.244.0.0/16&lt;/p&gt;
&lt;p&gt;Service网络：10.96.0.0/12&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;配置yum源&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# cd /etc/yum.repos.d/
[root@master yum.repos.d]# vim kubernetes.repo
[kubernetes]
name=Kubernetes Repo
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
gpgcheck=0
enabled=1
[root@master yum.repos.d]# wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
[root@master yum.repos.d]# sed -i 's/gpgcheck=1/gpgcheck=0/g' docker-ce.repo  #注意，将gpgcheck改为0
[root@master yum.repos.d]# scp kubernetes.repo docker-ce.repo node01:/etc/yum.repos.d/
[root@master yum.repos.d]# scp kubernetes.repo docker-ce.repo node02:/etc/yum.repos.d/&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二安装docker和kubernetes&quot;&gt;二、安装docker和kubernetes&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;解决docker-ce依赖包&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# wget https://mirrors.aliyun.com/centos-vault/7.3.1611/extras/x86_64/Packages/container-selinux-2.9-4.el7.noarch.rpm
[root@master ~]# yum -y localinstall container-selinux-2.9-4.el7.noarch.rpm&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;安装docker并配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# yum install docker-ce -y
[root@node01 ~]# yum install docker-ce -y
[root@node02 ~]# yum install docker-ce -y
[root@master ~]# vim /usr/lib/systemd/system/docker.service
[Service]
Environment=&quot;HTTPS_PROXY=http://www.ik8s.io:10080&quot;
Environment=&quot;NO_PROXY=127.0.0.0/8&quot;
[root@master ~]# systemctl daemon-reload
[root@master ~]# systemctl start docker
[root@master ~]# systemctl enable docker
[root@master ~]# docker info
HTTPS Proxy: http://www.ik8s.io:10080
No Proxy: 127.0.0.0/8&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;确认bridge-nf-call-iptables参数的值为1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@master ~]# cat /proc/sys/net/bridge/bridge-nf-call-iptables
1&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在master节点上安装配置kubernetes&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# yum install kubelet kubeadm kubectl -y
[root@master ~]# systemctl enable kubelet
[root@master ~]# vim /etc/sysconfig/kubelet
KUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;初始化master&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubeadm init --kubernetes-version=v1.11.1 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap
[root@master ~]# mkdir -p $HOME/.kube
[root@master ~]# cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
[root@master ~]# kubectl get cs  #如果此处状态非健康，请检查之前的操作
NAME                 STATUS    MESSAGE              ERROR
scheduler            Healthy   ok                   
controller-manager   Healthy   ok                   
etcd-0               Healthy   {&quot;health&quot;: &quot;true&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;将以下信息记录下来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubeadm join 192.168.0.12:6443 --token vlqtub.4827hc5ga73c9q8c --discovery-token-ca-cert-hash sha256:88f3a75bc1eef8077e4a97736faba1696e25fd3bc86e8347904b1db23f796556&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;部署flannel&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
[root@master ~]# kubectl get nodes  #等待数分钟，状态为Ready即成功&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;ul&gt;&lt;li&gt;将master的各配置文件同步到各nodes&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# scp container-selinux-2.9-4.el7.noarch.rpm node01:
[root@master ~]# scp container-selinux-2.9-4.el7.noarch.rpm node02:
[root@master ~]# scp /usr/lib/systemd/system/docker.service node01:/usr/lib/systemd/system/docker.service
[root@master ~]# scp /usr/lib/systemd/system/docker.service node02:/usr/lib/systemd/system/docker.service
[root@master ~]# scp /etc/sysconfig/kubelet node01:/etc/sysconfig/kubelet
[root@master ~]# scp /etc/sysconfig/kubelet node02:/etc/sysconfig/kubelet&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在node01节点中安装配置kubernetes（node02相同操作）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@node01 ~]# yum localinstall container-selinux-2.9-4.el7.noarch.rpm -y
[root@node01 ~]# yum install docker-ce kubelet kubeadm -y
[root@node01 ~]# systemctl enable docker kubelet
[root@node01 ~]# systemctl daemon-reload
[root@node01 ~]# systemctl start docker
[root@node01 ~]# systemctl enable docker
[root@node01 ~]# docker info
HTTPS Proxy: http://www.ik8s.io:10080
No Proxy: 127.0.0.0/8
[root@node01 ~]# kubeadm join 192.168.0.12:6443 --token vlqtub.4827hc5ga73c9q8c --discovery-token-ca-cert-hash sha256:88f3a75bc1eef8077e4a97736faba1696e25fd3bc86e8347904b1db23f796556  --ignore-preflight-errors=Swap&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在master节点上查看集群状态&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl get nodes
NAME                  STATUS    ROLES     AGE       VERSION
master.dongfei.tech   Ready     master    28m       v1.11.2
node01.dongfei.tech   Ready     &amp;lt;none&amp;gt;    3m        v1.11.2
node02.dongfei.tech   Ready     &amp;lt;none&amp;gt;    3m        v1.11.2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三kubectl的简单使用&quot;&gt;三、kubectl的简单使用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;创建2个nginx的pod&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl run nginx-deploy --image=nginx:1.14-alpine --port=80 --replicas=2
deployment.apps/nginx-deploy created&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl get deployment
[root@master ~]# kubectl get pods
[root@master ~]# kubectl get pods -w
[root@master ~]# kubectl get pods -o wide
[root@master ~]# kubectl get pods --show-labels&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建Service&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl expose deployment nginx-deploy --name=nginx --port=80 --target-port=80 --protocol=TCP&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;查看svc命令&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl get svc
[root@master ~]# kubectl get svc -n kube-system
[root@master ~]# kubectl describe svc nginx
[root@master ~]# kubectl run client --image=busybox --replicas=1 -it --restart=Never  #创建测试client
/ # wget -O - -q http://nginx:80/  #俩个pod实现负载均衡
Welcome to nginx!&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修改svc，使其可以在集群外部访问&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@master ~]# kubectl edit svc nginx
  type: NodePort
[root@master ~]# kubectl get svc nginx
NAME      TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
nginx     NodePort   10.98.231.135   &amp;lt;none&amp;gt;        80:30562/TCP   6m
外部访问：http://192.168.0.12:30562&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;感谢阅读，未完待续。。。&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 15:13:00 +0000</pubDate>
<dc:creator>(|^_^|||)</dc:creator>
<og:description>一、基础环境配置 操作系统：CentOS 7.5，三台节点，1台master，2台nodes 关闭selinux和firewalld 配置chronyd服务，保证各node时间同步（此处使用阿里巴巴提</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/L-dongf/p/9539464.html</dc:identifier>
</item>
<item>
<title>消息队列1：消息队列概述 - 养码青年</title>
<link>http://www.cnblogs.com/zhenghengbin/p/9539422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenghengbin/p/9539422.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;最近在看消息队列，找了好多资料。终于能够简单的理解了消息队列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;维基百科定义&quot;&gt;维基百科定义&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列互交。消息会保存在队列中，直到接收者取回它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说实话，我看了也是一脸懵逼。下面结合具体的案例来分析下。&lt;/p&gt;
&lt;h3 id=&quot;案例说明&quot;&gt;案例说明&lt;/h3&gt;
&lt;blockquote readability=&quot;4.1176470588235&quot;&gt;
&lt;p&gt;下面内容参考自知乎上&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24860107&quot;&gt;祁达方&lt;/a&gt;的文章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;小红是小明的姐姐。&lt;/p&gt;
&lt;p&gt;小红希望小明多读书，常寻找好书给小明看，之前的方式是这样：小红问小明什么时候有空，把书给小明送去，并亲眼监督小明读完书才走。久而久之，两人都觉得麻烦。&lt;/p&gt;
&lt;p&gt;后来的方式改成了：小红对小明说「我放到书架上的书你都要看」，然后小红每次发现不错的书都放到书架上，小明则看到书架上有书就拿下来看。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;书架就是一个消息队列，小红是生产者，小明是消费者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p7zk4x9pv.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180826223448.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Producer：消息生产者，负责产生和发送消息到 Broker；&lt;/li&gt;
&lt;li&gt;Broker：消息处理中心。负责消息存储、确认、重试等，一般其中会包含多个 queue；&lt;/li&gt;
&lt;li&gt;Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;消息队列的好处&quot;&gt;消息队列的好处&lt;/h4&gt;
&lt;p&gt;1.小红想给小明书的时候，不必问小明什么时候有空，亲手把书交给他了，小红只把书放到书架上就行了。这样小红小明的时间都更自由。&lt;/p&gt;
&lt;p&gt;2.小红相信小明的读书自觉和读书能力，不必亲眼观察小明的读书过程，小红只要做一个放书的动作，很节省时间。&lt;/p&gt;
&lt;p&gt;3.当明天有另一个爱读书的小伙伴小强加入，小红仍旧只需要把书放到书架上，小明和小强从书架上取书即可（唔，姑且设定成多个人取一本书可以每人取走一本吧，可能是拷贝电子书或复印，暂不考虑版权问题）。&lt;/p&gt;
&lt;p&gt;4.书架上的书放在那里，小明阅读速度快就早点看完，阅读速度慢就晚点看完，没关系，比起小红把书递给小明并监督小明读完的方式，小明的压力会小一些。&lt;/p&gt;
&lt;p&gt;这就是消息队列的四大好处：&lt;/p&gt;
&lt;h5 id=&quot;解耦&quot;&gt;解耦&lt;/h5&gt;
&lt;p&gt;每个成员不必受其他成员影响，可以更独立自主，只通过一个简单的容器来联系。&lt;/p&gt;
&lt;p&gt;小红甚至可以不知道从书架上取书的是谁，小明也可以不知道往书架上放书的人是谁，在他们眼里，都只有书架，没有对方。&lt;/p&gt;
&lt;p&gt;毫无疑问，与一个简单的容器打交道，比与复杂的人打交道容易一万倍，小红小明可以自由自在地追求各自的人生。&lt;/p&gt;
&lt;h5 id=&quot;提速&quot;&gt;提速&lt;/h5&gt;
&lt;p&gt;小红选择相信「把书放到书架上，别的我不问」，为自己节省了大量时间。&lt;/p&gt;
&lt;p&gt;小红很忙，只能抽出五分钟时间，但这时间足够把书放到书架上了。&lt;/p&gt;
&lt;h5 id=&quot;广播&quot;&gt;广播&lt;/h5&gt;
&lt;p&gt;小红只需要劳动一次，就可以让多个小伙伴有书可读，这大大地节省了她的时间，也让新的小伙伴的加入成本很低。&lt;/p&gt;
&lt;h5 id=&quot;削峰&quot;&gt;削峰&lt;/h5&gt;
&lt;p&gt;假设小明读书很慢，如果采用小红每给一本书都监督小明读完的方式，小明有压力，小红也不耐烦。&lt;/p&gt;
&lt;p&gt;反正小红给书的频率也不稳定，如果今明两天连给了五本，之后隔三个月才又给一本，那小明只要在三个月内从书架上陆续取走五本书读完就行了，压力就不那么大了。&lt;/p&gt;
&lt;h4 id=&quot;消息队列的缺点&quot;&gt;消息队列的缺点&lt;/h4&gt;
&lt;h5 id=&quot;引入复杂度&quot;&gt;引入复杂度&lt;/h5&gt;
&lt;p&gt;毫无疑问，「书架」这东西是多出来的，需要地方放它，还需要防盗。&lt;/p&gt;
&lt;h5 id=&quot;暂时的不一致性&quot;&gt;暂时的不一致性&lt;/h5&gt;
&lt;p&gt;假如妈妈问小红「小明最近读了什么书」，在以前的方式里，小红因为亲眼监督小明读完书了，可以底气十足地告诉妈妈，但新的方式里，小红回答妈妈之后会心想「小明应该会很快看完吧……」&lt;/p&gt;
&lt;p&gt;这中间存在着一段「妈妈认为小明看了某书，而小明其实还没看」的时期，当然，小明最终的阅读状态与妈妈的认知会是一致的，这就是所谓的「最终一致性」。&lt;/p&gt;
&lt;h4 id=&quot;消息队列的使用场景&quot;&gt;消息队列的使用场景&lt;/h4&gt;
&lt;h5 id=&quot;生产者不需要从消费者处获得反馈&quot;&gt;生产者不需要从消费者处获得反馈&lt;/h5&gt;
&lt;p&gt;引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走——即所谓异步——成为了可能。&lt;/p&gt;
&lt;p&gt;小红放完书之后小明到底看了没有，小红根本不问，她默认他是看了，否则就只能用原来的方法监督到看完了。&lt;/p&gt;
&lt;h5 id=&quot;容许短暂的不一致性&quot;&gt;容许短暂的不一致性&lt;/h5&gt;
&lt;p&gt;妈妈可能会发现「有时候据说小明看了某书，但事实上他还没看」，只要妈妈满意于「反正他最后看了就行」，异步处理就没问题。&lt;/p&gt;
&lt;p&gt;如果妈妈对这情况不能容忍，对小红大发雷霆，小红也就不敢用书架方式了。&lt;/p&gt;
&lt;h5 id=&quot;确实是用了有效果&quot;&gt;确实是用了有效果&lt;/h5&gt;
&lt;p&gt;即解耦、提速、广播、削峰这些方面的收益，超过放置书架、监控书架这些成本。&lt;/p&gt;
&lt;p&gt;否则如果是盲目照搬，「听说老赵家买了书架，咱们家也买一个」，买回来却没什么用，只是让步骤变多了，还不如直接把书递给对方呢，那就不对了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不得不佩服大牛的解释的这么通俗易懂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;[1]-祁达方:好书一起读(149)：消息队列(&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24860107&quot; class=&quot;uri&quot;&gt;https://zhuanlan.zhihu.com/p/24860107&lt;/a&gt;)&lt;br/&gt;[2]-jasonGeng88:一个故事告诉你什么是消息队列 (&lt;a href=&quot;https://github.com/jasonGeng88/blog/blob/master/201705/MQ.md&quot; class=&quot;uri&quot;&gt;https://github.com/jasonGeng88/blog/blob/master/201705/MQ.md&lt;/a&gt;)&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 15:02:00 +0000</pubDate>
<dc:creator>养码青年</dc:creator>
<og:description>最近在看消息队列，找了好多资料。终于能够简单的理解了消息队列。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenghengbin/p/9539422.html</dc:identifier>
</item>
<item>
<title>Spring Boot系列——Spring Boot如何启动 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/springboot-start.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/springboot-start.html</guid>
<description>&lt;h3 id=&quot;spring-boot启动过程&quot;&gt;Spring Boot启动过程&lt;/h3&gt;
&lt;p&gt;​上篇《Spring Boot系列——5分钟构建一个应用》介绍了如何快速创建一个Spring Boot项目并运行。虽然步骤少流程简单，为开发者省去了很多重复性的配置工作，但是其底层实现并没有这么简单。&lt;/p&gt;
&lt;p&gt;这篇，我们就通过入口类TutorialApplication看看Spring Boot是如何启动的。&lt;/p&gt;
&lt;h4 id=&quot;注解&quot;&gt;注解&lt;/h4&gt;
&lt;p&gt;写过Spring Boot都知道需要有一个入口类，就是本例子中的TutorialApplication，而这个类上面必不可上的需要有一个@SpringBootApplication注解。&lt;/p&gt;
&lt;p&gt;点击进入该注解，我们可以发现其是一个复合注解，包括@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
/**
 * Indicates a {@link Configuration configuration} class that declares one or more
 * {@link Bean @Bean} methods and also triggers {@link EnableAutoConfiguration
 * auto-configuration} and {@link ComponentScan component scanning}. This is a convenience
 * annotation that is equivalent to declaring {@code @Configuration},
 * {@code @EnableAutoConfiguration} and {@code @ComponentScan}.
 *
 * @author Phillip Webb
 * @author Stephane Nicoll
 * @since 1.2.0
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {

   /**
    * Exclude specific auto-configuration classes such that they will never be applied.
    * @return the classes to exclude
    */
   @AliasFor(annotation = EnableAutoConfiguration.class)
   Class&amp;lt;?&amp;gt;[] exclude() default {};

   /**
    * Exclude specific auto-configuration class names such that they will never be
    * applied.
    * @return the class names to exclude
    * @since 1.3.0
    */
   @AliasFor(annotation = EnableAutoConfiguration.class)
   String[] excludeName() default {};

   /**
    * Base packages to scan for annotated components. Use {@link #scanBasePackageClasses}
    * for a type-safe alternative to String-based package names.
    * @return base packages to scan
    * @since 1.3.0
    */
   @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackages&quot;)
   String[] scanBasePackages() default {};

   /**
    * Type-safe alternative to {@link #scanBasePackages} for specifying the packages to
    * scan for annotated components. The package of each class specified will be scanned.
    * &amp;lt;p&amp;gt;
    * Consider creating a special no-op marker class or interface in each package that
    * serves no purpose other than being referenced by this attribute.
    * @return base packages to scan
    * @since 1.3.0
    */
   @AliasFor(annotation = ComponentScan.class, attribute = &quot;basePackageClasses&quot;)
   Class&amp;lt;?&amp;gt;[] scanBasePackageClasses() default {};

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;@SpringBootConfiguration&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该注解底层其实就是@Configuration注解。熟悉Spring的发展里程碑就知道这是Java Config的配置形式。&lt;/p&gt;
&lt;p&gt;通过该注解修饰，表示该类是一个配置类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@EnableAutoConfiguration&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该注解其实也是一个复合注解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
/**
 * Enable auto-configuration of the Spring Application Context, attempting to guess and
 * configure beans that you are likely to need. Auto-configuration classes are usually
 * applied based on your classpath and what beans you have defined. For example, if you
 * have {@code tomcat-embedded.jar} on your classpath you are likely to want a
 * {@link TomcatServletWebServerFactory} (unless you have defined your own
 * {@link ServletWebServerFactory} bean).
 * &amp;lt;p&amp;gt;
 * When using {@link SpringBootApplication}, the auto-configuration of the context is
 * automatically enabled and adding this annotation has therefore no additional effect.
 * &amp;lt;p&amp;gt;
 * Auto-configuration tries to be as intelligent as possible and will back-away as you
 * define more of your own configuration. You can always manually {@link #exclude()} any
 * configuration that you never want to apply (use {@link #excludeName()} if you don't
 * have access to them). You can also exclude them via the
 * {@code spring.autoconfigure.exclude} property. Auto-configuration is always applied
 * after user-defined beans have been registered.
 * &amp;lt;p&amp;gt;
 * The package of the class that is annotated with {@code @EnableAutoConfiguration},
 * usually via {@code @SpringBootApplication}, has specific significance and is often used
 * as a 'default'. For example, it will be used when scanning for {@code @Entity} classes.
 * It is generally recommended that you place {@code @EnableAutoConfiguration} (if you're
 * not using {@code @SpringBootApplication}) in a root package so that all sub-packages
 * and classes can be searched.
 * &amp;lt;p&amp;gt;
 * Auto-configuration classes are regular Spring {@link Configuration} beans. They are
 * located using the {@link SpringFactoriesLoader} mechanism (keyed against this class).
 * Generally auto-configuration beans are {@link Conditional @Conditional} beans (most
 * often using {@link ConditionalOnClass @ConditionalOnClass} and
 * {@link ConditionalOnMissingBean @ConditionalOnMissingBean} annotations).
 *
 * @author Phillip Webb
 * @author Stephane Nicoll
 * @see ConditionalOnBean
 * @see ConditionalOnMissingBean
 * @see ConditionalOnClass
 * @see AutoConfigureAfter
 * @see SpringBootApplication
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {

   String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;

   /**
    * Exclude specific auto-configuration classes such that they will never be applied.
    * @return the classes to exclude
    */
   Class&amp;lt;?&amp;gt;[] exclude() default {};

   /**
    * Exclude specific auto-configuration class names such that they will never be
    * applied.
    * @return the class names to exclude
    * @since 1.3.0
    */
   String[] excludeName() default {};

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实现也是通过类似@Import的方式注入AutoConfigurationImportSelector类，并借助该类将所有符合条件的Configuration注解修饰的配置类加载到Spring Boot容器中。从classpath中搜索所有的META-INF/spring.factories配置文件，将其中org.springframework.boot.autoconfigure.EnableAutoConfiguration对应配置项通过反射的形式实例化为标注了@Configuration和javaconfig形式的IOC容器配置类，然后汇总为一个并加载到ioc容器中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201808/619240-20180826201528912-758766169.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@ComponentScan&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个注解就不需要多介绍了吧，其作用自动扫描加载符合条件的bean。&lt;/p&gt;
&lt;h4 id=&quot;springapplication&quot;&gt;SpringApplication&lt;/h4&gt;
&lt;p&gt;从项目的入口第一个碰到的就是SpringApplication类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
@SpringBootApplication
public class TutorialApplication {

    public static void main(String[] args) {
        SpringApplication.run(TutorialApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入该类的静态方法run，可以看到其在构造SpringApplication对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public static ConfigurableApplicationContext run(Class&amp;lt;?&amp;gt;[] primarySources,
      String[] args) {
   return new SpringApplication(primarySources).run(args);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入SpringApplication构造方法，可以看到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) {
   this.resourceLoader = resourceLoader;
   Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
   this.primarySources = new LinkedHashSet&amp;lt;&amp;gt;(Arrays.asList(primarySources));
   this.webApplicationType = deduceWebApplicationType();
   setInitializers((Collection) getSpringFactoriesInstances(
         ApplicationContextInitializer.class));
   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
   this.mainApplicationClass = deduceMainApplicationClass();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要做了如下几件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;加载Source，这里只有只有Application&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201808/619240-20180826201551185-1192216766.png&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;推断WebApplicationType，该枚举有三种类型NONE、SERVLET、REACTIVE。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;设置初始化器变量setInitializers，初始化后得到6个初始化变量，这些类在上面提到的spring.factories中可以找到&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201808/619240-20180826201608312-1899398156.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置监听器，与上面setInitializers实现类似，最终得到如下10个listeners&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/619240/201808/619240-20180826201633312-464084317.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最后推断带有main函数的所在类，即入口类，这里就是TutorialApplication&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
private Class&amp;lt;?&amp;gt; deduceMainApplicationClass() {
   try {
      StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();
      for (StackTraceElement stackTraceElement : stackTrace) {
         if (&quot;main&quot;.equals(stackTraceElement.getMethodName())) {
            return Class.forName(stackTraceElement.getClassName());
         }
      }
   }
   catch (ClassNotFoundException ex) {
      // Swallow and continue
   }
   return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;run方法&quot;&gt;run方法&lt;/h4&gt;
&lt;p&gt;看完SpringApplication是如何初始化后，我们来看下这个后面的run方法具体做了哪些事。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
public ConfigurableApplicationContext run(String... args) {
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   Collection&amp;lt;SpringBootExceptionReporter&amp;gt; exceptionReporters = new ArrayList&amp;lt;&amp;gt;();
   configureHeadlessProperty();
   SpringApplicationRunListeners listeners = getRunListeners(args);
   listeners.starting();
   try {
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
      configureIgnoreBeanInfo(environment);
      Banner printedBanner = printBanner(environment);
      context = createApplicationContext();
      exceptionReporters = getSpringFactoriesInstances(
            SpringBootExceptionReporter.class,
            new Class[] { ConfigurableApplicationContext.class }, context);
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
      refreshContext(context);
      afterRefresh(context, applicationArguments);
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
      listeners.started(context);
      callRunners(context, applicationArguments);
   }
   catch (Throwable ex) {
      handleRunFailure(context, ex, exceptionReporters, listeners);
      throw new IllegalStateException(ex);
   }

   try {
      listeners.running(context);
   }
   catch (Throwable ex) {
      handleRunFailure(context, ex, exceptionReporters, null);
      throw new IllegalStateException(ex);
   }
   return context;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;StopWatch，这是一个spring-core中的工具类，用来给程序运行计时（对于经常遇到需要计算某方法或接口耗时的场景，这个比System.currentTimeMillis好用）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;configureHeadlessProperty配置，设置系统属性 java.awt.headless，这里设置为 true，表示运行在服务器端，在没有显示器和鼠标键盘的模式下工作，模拟输入输出设备功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遍历listeners并启动&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;封装入参args为AppliationArguments对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;打印banner（就是我们启动时看到的spring标识）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;后面就是初始化上下文并加载上下文，具体实现就不进去看了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的“&lt;strong&gt;推荐&lt;/strong&gt;”将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4459384-f166f03afb66b79f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 12:22:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>Spring Boot几乎是傻瓜式一键启动，省去了很多冗余的配置，甚至不需要配置tomcat容器，本篇通过源码了解Spring Boot是如何启动的。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bigdataZJ/p/springboot-start.html</dc:identifier>
</item>
<item>
<title>大话音频变声原理 附简单示例代码 - cpuimage</title>
<link>http://www.cnblogs.com/cpuimage/p/9538448.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cpuimage/p/9538448.html</guid>
<description>&lt;p&gt;关于音频变声算法，这个是一个很多人特别感兴趣的话题。&lt;/p&gt;
&lt;p&gt;当然也有不少开源算法可以参阅学习，有基于时域，也有基于频域的算法。&lt;/p&gt;
&lt;p&gt;最终算法想要达到的目的是一致。&lt;/p&gt;
&lt;p&gt;最近也有不少网友问过关于变声算法的一些细节问题，邮件询问我。&lt;/p&gt;
&lt;p&gt;要给出一个比较合理或者说通俗易懂的解释，看似简单，其实还蛮难的。&lt;/p&gt;
&lt;p&gt;按照大概的一个逻辑思路，稍微理一理，所以这个主题必须加上“大话”这个前缀。&lt;/p&gt;
&lt;p&gt;也不打算讲特别高深的，当然也是因为讲不来。&lt;/p&gt;
&lt;p&gt;之于图像算法领域，非常重要的算法是高斯模糊，&lt;/p&gt;
&lt;p&gt;当然也可以认为是卷积，高斯模糊是卷积的一种特例，这里就不展开了。&lt;/p&gt;
&lt;p&gt;而之于音频，也许你也猜到了，基于时间的，毫无疑问，就是重采样算法。&lt;/p&gt;
&lt;p&gt;音频采样率是指录音设备在一秒钟内对声音信号的采样次数，&lt;/p&gt;
&lt;p&gt;采样频率越高声音的还原就越真实越自然。&lt;/p&gt;
&lt;p&gt;在当今的主流采集卡上，采样频率一般共分为22.05KHz、44.1KHz、48KHz三个等级，&lt;/p&gt;
&lt;p&gt;22.05KHz只能达到FM广播的声音品质，&lt;/p&gt;
&lt;p&gt;44.1KHz则是理论上的CD音质界限，48KHz则更加精确一些。&lt;/p&gt;
&lt;p&gt;看到这里，也许大多数人还是没法理解采样频率大概是什么意思。&lt;/p&gt;
&lt;p&gt;换个角度来说的话，就是假设一个人说“你好”，花了20毫秒，而机器在这20毫秒内，&lt;/p&gt;
&lt;p&gt;采集的数据多少就可以理解为采样率高低。&lt;/p&gt;
&lt;p&gt;也就是说，20毫秒内，采集到的数据量就是可以大概认为目前的采样率，数据量越大，精度越高，采样率越高。&lt;/p&gt;
&lt;p&gt;那么，我们再换一个思路，想一个问题。&lt;/p&gt;
&lt;p&gt;如果在同样的速率的情况下，&lt;/p&gt;
&lt;p&gt;一个人的语速快，一个人的语速慢，那也可能造成采样数据分布不一致。&lt;/p&gt;
&lt;p&gt;这里就可以展开一个音频算法，就是变速。&lt;/p&gt;
&lt;p&gt;嗯，是的，就是变速。&lt;/p&gt;
&lt;p&gt;从原理上来讲的话，其实变速就是在同样的采样率环境下，对采样数据进行拉伸或压缩。&lt;/p&gt;
&lt;p&gt;从算法的角度上来说的话，可以认为是插值或抽值。&lt;/p&gt;
&lt;p&gt;如果你让一个人讲话的速度变得更快怎么做，&lt;/p&gt;
&lt;p&gt;很明显，就是在同样的采样率下，抽掉一些样本。&lt;/p&gt;
&lt;p&gt;反之，降速则是插入一些样本。&lt;/p&gt;
&lt;p&gt;最终决定变速效果的就是插入样本和抽离样本的权重计算。&lt;/p&gt;
&lt;p&gt;例如原来采样到的数据是&lt;/p&gt;
&lt;p&gt;1234&lt;/p&gt;
&lt;p&gt;加速的时候，抽离样本 1 和 4&lt;/p&gt;
&lt;p&gt;23&lt;/p&gt;
&lt;p&gt;降速的时候，增加样本 &lt;/p&gt;
&lt;p&gt;11223344&lt;/p&gt;
&lt;p&gt;当然只是举个例子，便于大家理解这个概念逻辑。&lt;/p&gt;
&lt;p&gt;看到这里，肯定有人会问，&lt;/p&gt;
&lt;p&gt;那声音的大小呢？或者说信号的强弱呢？&lt;/p&gt;
&lt;p&gt;其实也就是提升音量和降低音量，我想这个应该不用解释。&lt;/p&gt;
&lt;p&gt;变速是时域变，空间不变。&lt;/p&gt;
&lt;p&gt;而音量则反之，时域不变，空间变。&lt;/p&gt;
&lt;p&gt;可以简单粗暴地理解，就是线性拉伸。&lt;/p&gt;
&lt;p&gt;例如原来采样到的数据是&lt;/p&gt;
&lt;p&gt;1234&lt;/p&gt;
&lt;p&gt;每个样本+4，直接拉伸为&lt;/p&gt;
&lt;p&gt;5678&lt;/p&gt;
&lt;p&gt;也有采用乘法进行拉伸的，&lt;/p&gt;
&lt;p&gt;例如 乘以2&lt;/p&gt;
&lt;p&gt;2468&lt;/p&gt;
&lt;p&gt;上面是增大音量，降低音量反之就是减和除。&lt;/p&gt;
&lt;p&gt;而最终不管变速还是音量调节，&lt;/p&gt;
&lt;p&gt;最终算法要做的事情就是确定对应位置的对应权重。&lt;/p&gt;
&lt;p&gt;当然也要看最终想要达到什么样的效果，适配权重。&lt;/p&gt;
&lt;p&gt;饶了这么一大圈，还是没有说到变声的问题。&lt;/p&gt;
&lt;p&gt;其实，变声就是变速+音量调节。&lt;/p&gt;
&lt;p&gt;以上变速也好，音量调节也好，相对而言都是线性拉伸，&lt;/p&gt;
&lt;p&gt;直接的加减乘除然后插值抽值就能达到的。&lt;/p&gt;
&lt;p&gt;而变声的概念其实也是类似的，&lt;/p&gt;
&lt;p&gt;就是在在同一时域内同时调节对应时域的音量权重。&lt;/p&gt;
&lt;p&gt;换言之就是在同一个采样率内，同时控制语速和音量在一个特定的权重内。&lt;/p&gt;
&lt;p&gt;其实就是一个时域和空间的二维拉伸。&lt;/p&gt;
&lt;p&gt;理解这个逻辑确实有点绕。&lt;/p&gt;
&lt;p&gt;用采样算法来做一个简单的示例。&lt;/p&gt;
&lt;p&gt;参阅前面的文章&lt;a href=&quot;https://www.cnblogs.com/cpuimage/p/8654297.html&quot; target=&quot;_blank&quot;&gt;《简洁明了的插值音频重采样算法例子 (附完整C代码)》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个示例中的采样函数是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; resampler(&lt;span&gt;char&lt;/span&gt; *in_file, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;out_file) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;音频采样率&lt;/span&gt;
    uint32_t in_sampleRate = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总音频采样数&lt;/span&gt;
    uint64_t totalSampleCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    int16_t &lt;/span&gt;*data_in = wavRead_int16(in_file, &amp;amp;in_sampleRate, &amp;amp;&lt;span&gt;totalSampleCount);
    uint32_t out_sampleRate &lt;/span&gt;= in_sampleRate * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    uint32_t out_size &lt;/span&gt;= (uint32_t) (totalSampleCount * ((&lt;span&gt;float&lt;/span&gt;) out_sampleRate /&lt;span&gt; in_sampleRate));
    int16_t &lt;/span&gt;*data_out = (int16_t *) &lt;span&gt;malloc&lt;/span&gt;(out_size * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(int16_t));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果加载成功&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (data_in != NULL &amp;amp;&amp;amp; data_out !=&lt;span&gt; NULL) {
        resampleData(data_in, in_sampleRate, (uint32_t) totalSampleCount, data_out, out_sampleRate);
        wavWrite_int16(out_file, data_out, out_sampleRate, (uint32_t) out_size);
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(data_in);
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(data_out);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data_in) &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(data_in);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data_out) &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(data_out);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;让我们稍微变通一下，设一个采样速率，用来调节声音的速度，同时保证采样率不变。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; resampler(&lt;span&gt;char&lt;/span&gt; *in_file, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;out_file) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;音频采样率&lt;/span&gt;
    uint32_t in_sampleRate = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总音频采样数&lt;/span&gt;
    uint64_t totalSampleCount = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    int16_t &lt;/span&gt;*data_in = wavRead_int16(in_file, &amp;amp;in_sampleRate, &amp;amp;&lt;span&gt;totalSampleCount);
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; speed = &lt;span&gt;0.88&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加一个速度权重&lt;/span&gt;
    uint32_t out_sampleRate = in_sampleRate *&lt;span&gt; speed;
    uint32_t out_size &lt;/span&gt;= (uint32_t) (totalSampleCount * ((&lt;span&gt;float&lt;/span&gt;) out_sampleRate /&lt;span&gt; in_sampleRate));
    int16_t &lt;/span&gt;*data_out = (int16_t *) &lt;span&gt;malloc&lt;/span&gt;(out_size * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(int16_t));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果加载成功&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (data_in != NULL &amp;amp;&amp;amp; data_out !=&lt;span&gt; NULL) {
        resampleData(data_in, in_sampleRate, (uint32_t) totalSampleCount, data_out, out_sampleRate);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;out_sampleRate改为输出一样的采样率in_sampleRate&lt;/span&gt;
&lt;span&gt;        wavWrite_int16(out_file, data_out, in_sampleRate, (uint32_t) out_size);
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(data_in);
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(data_out);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data_in) &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(data_in);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data_out) &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(data_out);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改后是这个样子的。&lt;/p&gt;
&lt;p&gt;有心的朋友发现了。out_size数值有可能增大或缩小了。&lt;/p&gt;
&lt;p&gt;以上示例代码，就是一个简单的变速算法。&lt;/p&gt;
&lt;p&gt;变速就是这么一个原理，音量增大降低就不做示例了。&lt;/p&gt;
&lt;p&gt;而变声是一个什么算法呢?&lt;/p&gt;
&lt;p&gt;说白了，就是变速的同时保证out_size还是原来的totalSampleCount。&lt;/p&gt;
&lt;p&gt;那要怎么保证呢？&lt;/p&gt;
&lt;p&gt;答案就是插值，如果简单粗暴一点，补0或者删0即可。&lt;/p&gt;
&lt;p&gt;当然这样做的话，可能会导致音量不一致，最终发声不对的情况。&lt;/p&gt;
&lt;p&gt;这肯定是不科学的，最终的插值时候的权重和对应的内容，产生的效果就看各家本领了。&lt;/p&gt;
&lt;p&gt;以上原理，也说得差不多了，具体怎么实现的话，&lt;/p&gt;
&lt;p&gt;大家自行参阅相关的开源代码，再去理解一下。&lt;/p&gt;
&lt;p&gt;另外说一下前面&lt;a href=&quot;https://www.cnblogs.com/cpuimage/p/8321878.html&quot; target=&quot;_blank&quot;&gt;《声音变调算法PitchShift(模拟汤姆猫) 附完整C++算法实现代码》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章中的sin和cos 没有在有效区间内，所以fastsin fastcos计算的结果是有问题的。&lt;/p&gt;
&lt;p&gt;详情大家还是参阅作者原算法吧。&lt;/p&gt;
&lt;p&gt;当然，后面有时间我会放出，&lt;/p&gt;
&lt;p&gt;简单清晰的变声算法的完整c代码和对应的示例代码。&lt;/p&gt;
&lt;p&gt;而关于基于傅里叶变换的重采样算法，&lt;a href=&quot;http://www.cnblogs.com/cpuimage/p/《基于傅里叶变换的音频重采样算法%20(附完整c代码)》&quot; target=&quot;_blank&quot;&gt;《基于傅里叶变换的音频重采样算法 (附完整c代码)》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在对应的github 项目&lt;a href=&quot;https://github.com/cpuimage/fftResample&quot; target=&quot;_blank&quot;&gt;fftResample&lt;/a&gt;上，我也做了算法逻辑上的修正。&lt;/p&gt;
&lt;p&gt;发表过的文章一般很少进行二次编辑了，&lt;/p&gt;
&lt;p&gt;关于后期的一些修正和变更，大家还是关注一下github项目的更新比较直接一点。&lt;/p&gt;
&lt;p&gt;具体变声的实现原理，&lt;/p&gt;
&lt;p&gt;如上所述，希望通过这篇文章，&lt;/p&gt;
&lt;p&gt;大家对音频变声算法能有比较直观的理解和认识。&lt;/p&gt;
&lt;p&gt;以上，权当抛砖引玉。&lt;/p&gt;
&lt;p&gt;独乐乐不如一起玩乐。&lt;/p&gt;
&lt;p&gt;若有其他相关问题或者需求也可以邮件联系俺探讨。&lt;/p&gt;
&lt;p&gt;邮箱地址是: &lt;br/&gt;gaozhihan@vip.qq.com&lt;/p&gt;

</description>
<pubDate>Sun, 26 Aug 2018 12:02:00 +0000</pubDate>
<dc:creator>cpuimage</dc:creator>
<og:description>关于音频变声算法，这个是一个很多人特别感兴趣的话题。 当然也有不少开源算法可以参阅学习，有基于时域，也有基于频域的算法。 最终算法想要达到的目的是一致。 最近也有不少网友问过关于变声算法的一些细节问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cpuimage/p/9538448.html</dc:identifier>
</item>
<item>
<title>深究CSS中Position的属性和特性 - xiaobe</title>
<link>http://www.cnblogs.com/soyxiaobi/p/9538432.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/soyxiaobi/p/9538432.html</guid>
<description>&lt;h4 id=&quot;一position的概念&quot;&gt;一、position的概念&lt;/h4&gt;
&lt;p&gt;作为布局必不可缺少的元素之一,深究其属性以及一些注意点是非常必要的。&lt;/p&gt;
&lt;p&gt;定义:规定元素的定位类型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4 id=&quot;position属性&quot;&gt;position属性:&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;absolute&lt;/td&gt;
&lt;td&gt;生成绝对定位的元素，相对于&lt;span&gt;static定位&lt;/span&gt;以外的第一个父元素进行定位。&lt;/td&gt;
&lt;td&gt;&lt;span&gt;★★&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;relative&lt;/td&gt;
&lt;td&gt;生成相对定位的元素，相对于其在文档流正常位置进行定位。&lt;/td&gt;
&lt;td&gt;&lt;span&gt;★★&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;fixed&lt;/td&gt;
&lt;td&gt;生成绝对定位的元素，相对于&lt;span&gt;浏览器窗口&lt;/span&gt;进行定位。&lt;/td&gt;
&lt;td&gt;&lt;span&gt;★☆&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;static&lt;/td&gt;
&lt;td&gt;默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）&lt;/td&gt;
&lt;td&gt;&lt;span&gt;☆☆&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从表格中可以了解到position的主要概念,有几点需要注意:&lt;/p&gt;
&lt;h4 id=&quot;二position属性的一些注意点&quot;&gt;二、position属性的一些注意点&lt;/h4&gt;
&lt;h5 id=&quot;absolute的定位问题&quot;&gt;1. absolute的定位问题&lt;/h5&gt;
&lt;p&gt;absolute所定位的位置是最近带有position属性并且属性值不为static的父级元素。子元素默认定位在父元素的左上角位置。&lt;/p&gt;
&lt;p&gt;如果子元素仅仅设置了position:absolute,而未设置left、top之类的元素。和对应的padding无关。&lt;/p&gt;
&lt;p&gt;举个例子:如果子元素设置了bottom:0;如果父元素存在padding:20px;那么padding-bottom:20px;会失效,但是padding-left:20px;依然奏效。比如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//css
div{
    width:200px;
    height:200px;
}
.fatherDiv{
    background-color:#12B7F5;
    position:relative;
    padding:20px;
    margin-top:20px;
}
.childDiv{
    width:100px;
    height:100px;
    background-color:#F9b041;
    position:absolute;
    bottom:0px;
}

//html
&amp;lt;div class=&quot;fatherDiv&quot;&amp;gt;
    &amp;lt;div class=&quot;childDiv&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201808/1414709-20180826171712582-341449689.png&quot; alt=&quot;padding-left&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然如果你既设置了left、又设置了bottom.那么父元素的padding的任何设置是对子元素产生不了任何影响&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里需要注意,margin无论什么值都也都会影响到子元素,因为它是直接影响父级。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;relative的定位问题&quot;&gt;2. relative的定位问题&lt;/h5&gt;
&lt;p&gt;以下例子都以下面为基础样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//css
div{
    width:200px;
    height:200px;
}
.brotherDiv{
    background-color:#12B7F5;
}
.brotherDiv1{
    background-color:#F9b041;
}

//html
&amp;lt;div class=&quot;brotherDiv&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;brotherDiv1&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;i. 两个div为块级(block)元素&lt;/p&gt;
&lt;p&gt;两者的left、top....都不会相互影响.因为即使元素位置改变了,但是它在文档流占用的空间不变,所以并不会影响到布局。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.brotherDiv{
    position:relative;
    top:40px;
}
.brotherDiv1{
    position: relative;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201808/1414709-20180826184759906-1008843614.png&quot; alt=&quot;relative&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外还可以通过z-index设置显示的层次。例如给brotherDiv设置z-index:1,则蓝色块会覆盖黄色(z-index默认为0)&lt;/p&gt;
&lt;p&gt;ii. 两个div为行内-块级(inline-block)元素&lt;/p&gt;
&lt;p&gt;除了同样拥有第一个特性以外,还多了一个特有的特性:&lt;br/&gt;&lt;span&gt;margin和padding都会影响到同行元素&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.brotherDiv{
    position:relative;
    display: inline-block;
    margin-top:40px;
}
.brotherDiv1{
    background-color:#F9b041;
    position:relative;
    display: inline-block;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201808/1414709-20180826191911029-779795220.png&quot; alt=&quot;margin-top&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看一下两个div的style面板&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201808/1414709-20180826192633370-659929795.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201808/1414709-20180826192639688-1538665298.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现brotherDiv1并不存在margin.&lt;/p&gt;
&lt;p&gt;我们用JS获取一下两个margin:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;window.onload = function(){
    var div = document.querySelector('.brotherDiv');
    var div1 = document.querySelector('.brotherDiv1');
    
    console.log(div.offsetTop);     //40
    console.log(div1.offsetTop);    //40
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用js的话是可以获取两者的偏移量的,也就是说brotherDiv1实际上也偏移了。&lt;/p&gt;
&lt;p&gt;而用padding的情况就比较常见.两个元素默认会底部对齐。并且高度低的元素会获得偏移量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//css
.brotherDiv{
    background-color:#12B7F5;
    position:relative;
    display: inline-block;
    padding:20px;
}
.brotherDiv1{
    background-color:#F9b041;
    display: inline-block;
    position:relative;
}

//html
&amp;lt;div class=&quot;brotherDiv&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;brotherDiv1&quot;&amp;gt;&amp;lt;/div&amp;gt;

//js
window.onload = function(){
    var div = document.querySelector('.brotherDiv');
    var div1 = document.querySelector('.brotherDiv1');
    
    console.log(div.offsetTop);     //0
    console.log(div1.offsetTop);    //40
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1414709/201808/1414709-20180826194951295-179180794.png&quot; alt=&quot;padding&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然,对齐的方法相信大家都非常熟悉了。&lt;br/&gt;在高低较低的元素设置css&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//把元素的顶端与行中最高元素的顶端对齐
vertical: top;

//把此元素放置在父元素的中部
vertical: middle;

//  把元素的顶端与行中最低的元素的顶端对齐
vertical: bottom;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意,这里的middle并非是相对行内元素居中的意思。&lt;/p&gt;
&lt;p&gt;感兴趣的可以看看这篇文章:&lt;a href=&quot;https://www.cnblogs.com/soyxiaobi/p/9519895.html&quot; target=&quot;_blank&quot;&gt;《HTML元素垂直居中的n种方法》&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 11:56:00 +0000</pubDate>
<dc:creator>xiaobe</dc:creator>
<og:description>一、position的概念 作为布局必不可缺少的元素之一,深究其属性以及一些注意点是非常必要的。 定义:规定元素的定位类型。 position属性: 属性 | 描述 | 常用性 | : : | : a</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/soyxiaobi/p/9538432.html</dc:identifier>
</item>
<item>
<title>T-SQL:排除阻塞（十六） - 薛定谔家的猫</title>
<link>http://www.cnblogs.com/yuanzijian-ruiec/p/9538183.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanzijian-ruiec/p/9538183.html</guid>
<description>&lt;p&gt;当一个事务持有事务的资源锁，并且另一个事务请求同一资源的不兼容锁时，请求被阻塞并且请求者进入等待状态，直到锁定者释放干扰锁。&lt;/p&gt;
&lt;p&gt;长时间运行事务会导致锁被长时间持有，所以只对要开启事务的表操作代码开启事务，不应将业务逻辑也放入事务中  。这样做只会增加开启事务的时间 会导致其他请求阻塞。&lt;/p&gt;
&lt;p&gt;首先我们来模拟一个阻塞情况 打开SQL Server 建立一个实例链接 再打开建立一个实例链接 也就是进程 建两个进程连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826173321135-108238390.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826173326574-819470587.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826174221344-1050544487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;新建查询开启进程 sa(进程ID)&lt;/p&gt;
&lt;p&gt;在第一个连接中加断点  调试卡住断点  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826173126701-1260790400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 在第二个连接中执行查询&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Nums &lt;span&gt;where&lt;/span&gt; n&lt;span&gt;=&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826174847628-942875274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到请求被阻塞了 &lt;/p&gt;
&lt;p&gt;环境已经模拟了 接下来是排除问题了 &lt;/p&gt;
&lt;p&gt;获取锁的信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; use * to explore&lt;/span&gt;
  request_session_id            &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; spid,
  resource_type                 &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;&lt;span&gt; restype,
  resource_database_id          &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;&lt;span&gt; dbid,
  &lt;/span&gt;&lt;span&gt;DB_NAME&lt;/span&gt;(resource_database_id) &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; dbname,
  resource_description          &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;&lt;span&gt; res,
  resource_associated_entity_id &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;&lt;span&gt; resid,
  request_mode                  &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;&lt;span&gt; mode,
  request_status                &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt;&lt;span&gt; status
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; sys.dm_tran_locks;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826175407175-614724617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;spid 进程 &lt;/p&gt;
&lt;p&gt; type 锁类型&lt;/p&gt;
&lt;p&gt;dbid数据库ID &lt;/p&gt;
&lt;p&gt;name 数据库名&lt;/p&gt;
&lt;p&gt;  res 资源   &lt;/p&gt;
&lt;p&gt;mode 锁模式    S:共享锁  X:排他锁 IX:意向排他锁  IS：意向共享锁   &lt;/p&gt;
&lt;p&gt;status （grant）是否加了锁 (wait) 等待&lt;/p&gt;
&lt;p&gt;可以在看到 在修改是 除了行是排他锁（X） （表）对象和页都是 意向排他锁（IX）  下面更改锁模式 让 表锁升级&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826180036360-338789944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时在运行至此 查看锁模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826180229512-1714467690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对象锁已经被表锁 从意向排他锁升级成排他锁&lt;/p&gt;
&lt;p&gt;刚刚只是查找那些资源被加锁  进一步的想要查看是加锁信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; use * to explore&lt;/span&gt;
  session_id &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; spid,
  connect_time,
  last_read,
  last_write,
  most_recent_sql_handle
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; sys.dm_exec_connections
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取每个进程读写时间  和最近运行的批处理语句  由于被加锁了 可以推断 事务还在运行 虽然可能不是最准确的但判别发生的场景&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826181248737-2113268696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在通过 dm_exec_sql_text 把 handle 连接看到调用的最后一个批处理代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; session_id, &lt;span&gt;text&lt;/span&gt; 
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; sys.dm_exec_connections
  &lt;/span&gt;&lt;span&gt;CROSS&lt;/span&gt; APPLY sys.dm_exec_sql_text(most_recent_sql_handle) &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; ST 
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; session_id &lt;span&gt;IN&lt;/span&gt;(&lt;span&gt;52&lt;/span&gt;, &lt;span&gt;55&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 通过甄别 看到52最后运行代码 可以确定因为阻塞的代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826181507280-1431266465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在通过 sys.dm_exec_sessions 查看主机名 确定是那台电脑出现的原因&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; use * to explore&lt;/span&gt;
  session_id &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; spid,
  login_time,
  &lt;/span&gt;&lt;span&gt;host_name&lt;/span&gt;&lt;span&gt;,
  program_name,
  login_name,
  nt_user_name,
  last_request_start_time,
  last_request_end_time
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; sys.dm_exec_sessions
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; session_id &lt;span&gt;=&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826182339166-537024147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可用dm_exec_requests 排除阻塞情况 因为被阻塞的请求session_id是大于0的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; use * to explore&lt;/span&gt;
  session_id &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; spid,
  blocking_session_id,
  command,
  sql_handle,
  database_id,
  wait_type,
  wait_time,
  wait_resource
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; sys.dm_exec_requests
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; blocking_session_id &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再开一个连接 3  我们让连接1 卡断点 连接2 请求被锁资源  连接3 执行以上代码  可用看到被阻塞的请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826182729193-556816449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以通过设置请求过期时间 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SET&lt;/span&gt; LOCK_TIMEOUT &lt;span&gt;5000&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然如果加锁的电脑一直占用资源 或者不知道什么情况可能 直接终止 进程&lt;/p&gt;

&lt;p&gt;释放资源 解除锁  而52进程 连接的电脑会包以下错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1222663/201808/1222663-20180826183221803-391961482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自动回滚&lt;/p&gt;






</description>
<pubDate>Sun, 26 Aug 2018 10:33:00 +0000</pubDate>
<dc:creator>薛定谔家的猫</dc:creator>
<og:description>当一个事务持有事务的资源锁，并且另一个事务请求同一资源的不兼容锁时，请求被阻塞并且请求者进入等待状态，直到锁定者释放干扰锁。 长时间运行事务会导致锁被长时间持有，所以只对要开启事务的表操作代码开启事务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanzijian-ruiec/p/9538183.html</dc:identifier>
</item>
<item>
<title>【面试必备】手撕代码，你怕不怕？ - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/9538177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/9538177.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-2d09aea119299075.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;：不管是远程的视频面试，还是现场的面试，都有可能会有手撕代码的环节，这也是很多童鞋包括我(虽然还没遇到过..)都很头疼的东西，可能是因为 IDE 自动提示功能用惯了或是其他一些原因，总之让我手写代码就是感觉很奇怪..但是我想的话，这应该侧重考察的是一些细节或者是习惯方面的一些东西，所以还是防患于未然吧，把一些可能手撕的代码给准备准备，分享分享，&lt;strong&gt;希望可以得到各位的指正，然后能有一些讨论&lt;/strong&gt;，由于我字太丑就不上传自己默写的代码了，但还是希望各位潦草写一遍加深一下印象吧，以上；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;这绝对是属于重点了，不管是考察对于该重要模型的理解还是考察代码能力，这都是一道很好的考题，所以很有必要的，我们先来回顾一下什么是生产者-消费者问题；&lt;/p&gt;
&lt;h2 id=&quot;问题简单回顾&quot;&gt;问题简单回顾&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-f3b7afe4955ca3bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产者消费者问题&lt;/strong&gt;（英语：Producer-consumer problem），也称&lt;strong&gt;有限缓冲问题&lt;/strong&gt;（英语：Bounded-buffer problem），是一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%A4%9A%E7%BA%BF%E7%A8%8B&quot; title=&quot;多线程&quot;&gt;多线程&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5&quot; title=&quot;同步&quot;&gt;同步&lt;/a&gt;问题的经典案例。该问题描述了共享固定大小&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%BC%93%E5%86%B2%E5%8C%BA&quot; title=&quot;缓冲区&quot;&gt;缓冲区&lt;/a&gt;的两个线程——即所谓的“生产者”和“消费者”——在实际运行时会发生的问题。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。&lt;strong&gt;该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。&lt;/strong&gt;(摘自维基百科：&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98&quot;&gt;生产者消费者问题&lt;/a&gt;)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt; 生产者-消费者模式中的内存缓存区的主要功能是数据在多线程间的共享，此外，通过该缓冲区，可以缓解生产者和消费者的性能差；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;几种实现方式&quot;&gt;几种实现方式&lt;/h2&gt;
&lt;p&gt;上面说到该问题的关键是：&lt;strong&gt;如何保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区空时消耗数据；&lt;/strong&gt;解决思路可以简单概括为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生产者持续生产，直到缓冲区满，&lt;strong&gt;满时阻塞&lt;/strong&gt;；缓冲区不满后，继续生产；&lt;/li&gt;
&lt;li&gt;消费者持续消费，直到缓冲区空，&lt;strong&gt;空时阻塞&lt;/strong&gt;；缓冲区不空后，继续消费；&lt;/li&gt;
&lt;li&gt;生产者和消费者都可以有多个；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么在 Java 语言中，能达到上述要求的，自然而然的就会有如下的几种写法，但是问题的核心都是能够让消费者和生产者在各自满足条件需要阻塞时能够起到正确的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt;/&lt;code&gt;notify()&lt;/code&gt;方式；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;await()&lt;/code&gt;/&lt;code&gt;signal()&lt;/code&gt;方式；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BlockingQueue&lt;/code&gt;阻塞队列方式；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PipedInputStream&lt;/code&gt;/&lt;code&gt;PipedOutputStream&lt;/code&gt;方式；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;手写代码，我们着重掌握上面对应的第一种和第三种写法就足够了；&lt;/p&gt;
&lt;h3 id=&quot;waitnotify方式实现&quot;&gt;wait()/notify()方式实现&lt;/h3&gt;
&lt;p&gt;在手写代码之前，我们需要现在 IDE 上实现一遍，理解其中的过程并且找到一些重点/细节，我们先来代码走一遍，然后我把我理解的重点给圈儿出来：&lt;/p&gt;
&lt;h4 id=&quot;生产者代码&quot;&gt;生产者代码&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Producer implements Runnable {
    private volatile boolean isRunning = true;
    private final Vector sharedQueue;                            // 内存缓冲区
    private final int SIZE;                                      // 缓冲区大小
    private static AtomicInteger count = new AtomicInteger();    // 总数，原子操作
    private static final int SLEEPTIME = 1000;

    public Producer(Vector sharedQueue, int SIZE) {
        this.sharedQueue = sharedQueue;
        this.SIZE = SIZE;
    }

    @Override
    public void run() {
        int data;
        Random r = new Random();

        System.out.println(&quot;start producer id = &quot; + Thread.currentThread().getId());
        try {
            while (isRunning) {
                // 模拟延迟
                Thread.sleep(r.nextInt(SLEEPTIME));

                // 当队列满时阻塞等待
                while (sharedQueue.size() == SIZE) {
                    synchronized (sharedQueue) {
                        System.out.println(&quot;Queue is full, producer &quot; + Thread.currentThread().getId()
                                + &quot; is waiting, size：&quot; + sharedQueue.size());
                        sharedQueue.wait();
                    }
                }

                // 队列不满时持续创造新元素
                synchronized (sharedQueue) {
                    data = count.incrementAndGet();                 // 构造任务数据
                    sharedQueue.add(data);
                    System.out.println(&quot;producer create data:&quot; + data + &quot;, size：&quot; + sharedQueue.size());
                    sharedQueue.notifyAll();
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupted();
        }
    }

    public void stop() {
        isRunning = false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了上面的提到的解决思路，应该很容易实现，但是这里主要提一下一些细节和重点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;创造数据&lt;/strong&gt;：生产者-消费者解决的问题就是数据在多线程间的共享，所以我们首要关心的问题就应该是数据，我们这里采用的是使用一个&lt;code&gt;AtomicInteger&lt;/code&gt;类来为我们创造数据，使用它的好处是该类是一个保证原子操作的类，我们使用其中的&lt;code&gt;incrementAndGet()&lt;/code&gt;方法不仅能够保证线程安全，还可以达到一个计数的效果，所以是一个既简单又实用的选择，当然也可以使用其他的数据来代替，&lt;strong&gt;这里注意的是要保证该类在内存中只存在一份，使用&lt;code&gt;static&lt;/code&gt;修饰&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存缓冲区&lt;/strong&gt;：要保证在多线程环境下内存缓冲区的安全，所以我们考虑使用简单的&lt;code&gt;Vector&lt;/code&gt;类来作为我们的内存缓冲区，并且使用&lt;code&gt;final&lt;/code&gt;修饰保证内存缓冲区的唯一，然后的话我们需要判断队列是否满，需要手动添加一个标识缓冲区大小的变量&lt;code&gt;SIZE&lt;/code&gt;，注意也是&lt;code&gt;final&lt;/code&gt;修饰；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模拟延迟&lt;/strong&gt;：这里主要模拟的是一个网络延迟，我们首先定义了一个&lt;code&gt;SLEEPTIME&lt;/code&gt;的延迟范围，&lt;strong&gt;注意使用的是&lt;code&gt;static final&lt;/code&gt;修饰&lt;/strong&gt;，然后使用&lt;code&gt;Random()&lt;/code&gt;类的&lt;code&gt;nextInt()&lt;/code&gt;方法来随机选取一个该范围内的值来模拟网络环境中的延迟；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;停止方法&lt;/strong&gt;：首先需要知道在&lt;code&gt;Thread&lt;/code&gt;类中有一个弃用的&lt;code&gt;stop()&lt;/code&gt;方法，我们自己增加一个标志位&lt;code&gt;isRunning&lt;/code&gt;来完成我们自己的&lt;code&gt;stop()&lt;/code&gt;功能，&lt;strong&gt;需要注意的是使用&lt;code&gt;volatile&lt;/code&gt;来修饰&lt;/strong&gt;，保证该标志位的可见性；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;错误处理&lt;/strong&gt;：当捕获到错误时，我们应该使用&lt;code&gt;Thread&lt;/code&gt;类中的&lt;code&gt;interrupted()&lt;/code&gt;方法来终止当前的进程；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息提示&lt;/strong&gt;：我们主要是要在控制台输出该生产者的信息，包括当前队列的状态，大小，当前线程的生产者信息等，&lt;strong&gt;注意的是信息格式的统一(后面的消费者同样的)&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;消费者代码&quot;&gt;消费者代码&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Consumer implements Runnable {

    private final Vector sharedQueue;                            // 内存缓冲区
    private final int SIZE;                                      // 缓冲区大小
    private static final int SLEEPTIME = 1000;

    public Consumer(Vector sharedQueue, int SIZE) {
        this.sharedQueue = sharedQueue;
        this.SIZE = SIZE;
    }

    @Override
    public void run() {

        Random r = new Random();

        System.out.println(&quot;start consumer id = &quot; + Thread.currentThread().getId());
        try {
            while (true) {
                // 模拟延迟
                Thread.sleep(r.nextInt(SLEEPTIME));

                // 当队列空时阻塞等待
                while (sharedQueue.isEmpty()) {
                    synchronized (sharedQueue) {
                        System.out.println(&quot;Queue is empty, consumer &quot; + Thread.currentThread().getId()
                                + &quot; is waiting, size：&quot; + sharedQueue.size());
                        sharedQueue.wait();
                    }
                }

                // 队列不空时持续消费元素
                synchronized (sharedQueue) {
                    System.out.println(&quot;consumer consume data：&quot; + sharedQueue.remove(0) + &quot;, size：&quot; + sharedQueue.size());
                    sharedQueue.notifyAll();
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟生产者相同的，你需要注意&lt;strong&gt;内存缓冲区&lt;/strong&gt;/ &lt;strong&gt;模拟延迟&lt;/strong&gt;/ &lt;strong&gt;错误处理&lt;/strong&gt;/ &lt;strong&gt;消息提示&lt;/strong&gt;这些方面的细节问题，总体来说消费者就是持续不断的消费，也比较容易实现；&lt;/p&gt;
&lt;h4 id=&quot;主线程代码&quot;&gt;主线程代码&lt;/h4&gt;
&lt;p&gt;有了我们的消费者和生产者代码，我们需要来验证一下它们的正确性，照常理来说我们直接创建一些消费者和生产者的线程让它们执行就可以了啊，但是为了“加分”考虑呢，我们还是使用线程池吧..也不是特别复杂：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String args[]) throws InterruptedException {
    // 1.构建内存缓冲区
    Vector sharedQueue = new Vector();
    int size = 4;

    // 2.建立线程池和线程
    ExecutorService service = Executors.newCachedThreadPool();
    Producer prodThread1 = new Producer(sharedQueue, size);
    Producer prodThread2 = new Producer(sharedQueue, size);
    Producer prodThread3 = new Producer(sharedQueue, size);
    Consumer consThread1 = new Consumer(sharedQueue, size);
    Consumer consThread2 = new Consumer(sharedQueue, size);
    Consumer consThread3 = new Consumer(sharedQueue, size);
    service.execute(prodThread1);
    service.execute(prodThread2);
    service.execute(prodThread3);
    service.execute(consThread1);
    service.execute(consThread2);
    service.execute(consThread3);

    // 3.睡一会儿然后尝试停止生产者
    Thread.sleep(10 * 1000);
    prodThread1.stop();
    prodThread2.stop();
    prodThread3.stop();

    // 4.再睡一会儿关闭线程池
    Thread.sleep(3000);
    service.shutdown();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家可以自行去看看运行的结果，是没有问题的，不会出现多生产或者多消费之类的多线程问题，运行一段时间等生产者都停止之后，我们可以观察到控制台三个消费者都在等待数据的情况：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Queue is empty, consumer 17 is waiting, size：0
Queue is empty, consumer 15 is waiting, size：0
Queue is empty, consumer 16 is waiting, size：0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;blockingqueue阻塞队列方式实现&quot;&gt;BlockingQueue阻塞队列方式实现&lt;/h3&gt;
&lt;p&gt;该方式对比起上面一种方式实现起来要简单一些，因为不需要手动的去通知其他线程了，生产者直接往队列中放数据直到队列满，消费者直接从队列中获取数据直到队列空，BlockingQueue会自动帮我们完成阻塞这个动作，还是先来看看代码&lt;/p&gt;
&lt;h4 id=&quot;生产者代码-1&quot;&gt;生产者代码&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Producer implements Runnable {
    private volatile boolean isRunning = true;
    private BlockingQueue&amp;lt;Integer&amp;gt; queue;                        // 内存缓冲区
    private static AtomicInteger count = new AtomicInteger();    // 总数，原子操作
    private static final int SLEEPTIME = 1000;

    public Producer(BlockingQueue&amp;lt;Integer&amp;gt; queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        int data;
        Random r = new Random();

        System.out.println(&quot;start producer id = &quot; + Thread.currentThread().getId());
        try {
            while (isRunning) {
                // 模拟延迟
                Thread.sleep(r.nextInt(SLEEPTIME));

                // 往阻塞队列中添加数据
                data = count.incrementAndGet();                 // 构造任务数据
                System.out.println(&quot;producer &quot; + Thread.currentThread().getId() + &quot; create data：&quot; + data
                        + &quot;, size：&quot; + queue.size());
                if (!queue.offer(data, 2, TimeUnit.SECONDS)) {
                    System.err.println(&quot;failed to put data：&quot; + data);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupted();
        }
    }

    public void stop() {
        isRunning = false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟上面一种方式没有很大的差别，倒是代码更加简单通透，不过需要注意的是对&lt;strong&gt;阻塞队列添加失败的错误处理&lt;/strong&gt;；&lt;/p&gt;
&lt;h4 id=&quot;消费者代码-1&quot;&gt;消费者代码&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Consumer implements Runnable {

    private BlockingQueue&amp;lt;Integer&amp;gt; queue;                            // 内存缓冲区
    private static final int SLEEPTIME = 1000;

    public Consumer(BlockingQueue&amp;lt;Integer&amp;gt; queue) {
        this.queue = queue;
    }

    @Override
    public void run() {

        int data;
        Random r = new Random();

        System.out.println(&quot;start consumer id = &quot; + Thread.currentThread().getId());
        try {
            while (true) {
                // 模拟延迟
                Thread.sleep(r.nextInt(SLEEPTIME));

                // 从阻塞队列中获取数据
                if (!queue.isEmpty()) {
                    data = queue.take();
                    System.out.println(&quot;consumer &quot; + Thread.currentThread().getId() + &quot; consume data：&quot; + data
                            + &quot;, size：&quot; + queue.size());
                } else {
                    System.out.println(&quot;Queue is empty, consumer &quot; + Thread.currentThread().getId()
                            + &quot; is waiting, size：&quot; + queue.size());
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;主线程代码-1&quot;&gt;主线程代码&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String args[]) throws InterruptedException {
    // 1.构建内存缓冲区
    BlockingQueue&amp;lt;Integer&amp;gt; queue = new LinkedBlockingDeque&amp;lt;&amp;gt;();

    // 2.建立线程池和线程
    ExecutorService service = Executors.newCachedThreadPool();
    Producer prodThread1 = new Producer(queue);
    Producer prodThread2 = new Producer(queue);
    Producer prodThread3 = new Producer(queue);
    Consumer consThread1 = new Consumer(queue);
    Consumer consThread2 = new Consumer(queue);
    Consumer consThread3 = new Consumer(queue);
    service.execute(prodThread1);
    service.execute(prodThread2);
    service.execute(prodThread3);
    service.execute(consThread1);
    service.execute(consThread2);
    service.execute(consThread3);

    // 3.睡一会儿然后尝试停止生产者
    Thread.sleep(10 * 1000);
    prodThread1.stop();
    prodThread2.stop();
    prodThread3.stop();

    // 4.再睡一会儿关闭线程池
    Thread.sleep(3000);
    service.shutdown();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为队列中添加和删除的操作比较频繁，所以这里使用&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;来作为阻塞队列，所以这里除了内存缓冲区有所不同以外，其他的都差不多...当然你也可以指定一个队列的大小；&lt;/p&gt;
&lt;h3 id=&quot;总结以及改进&quot;&gt;总结以及改进&lt;/h3&gt;
&lt;p&gt;生产者-消费者模式很好地对生产者线程和消费者线程进行解耦，优化了系统整体的结构，同时由于缓冲区的作用，允许生产者线程和消费者线程存在执行上的性能差异，从一定程度上缓解了性能瓶颈对系统性能的影响；上面两种写法都是非常常规的写法，只能说能起码能在及格的基础上加个那么点儿分数，如果想要得高分可以去搜索搜搜 Disruptor 来实现一个无锁的生产者-消费者模型....这里就不提及了..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;改进：&lt;/strong&gt;上面的线程输出可能会有点儿不友好（不直观），因为我们这里是直接使用的线程的 ID 来作为输出，我们也可以给线程弄一个名字来作为输出，以上；&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;排序算法当然也算是重点考察的对象之一了，毕竟基础且偏算法，当然我们有必要去了解常见的排序算法以及它们采取了怎样的思想又是如何实现的还有复杂度的问题，但是这里的话，主要就提及两种考的比较常见的排序算法：&lt;strong&gt;冒泡&lt;/strong&gt;和&lt;strong&gt;快排&lt;/strong&gt;，以及分别对它们进行的一些优化；&lt;/p&gt;
&lt;h2 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h2&gt;
&lt;p&gt;冒泡应该是比较基础的一种算法，我们以从小到大排序为例，它的基础思想是：&lt;strong&gt;从第一个数开始直到数组倒数第二个数，每一轮都去比较数组中剩下的数，如果后面的数据更小则两数交换&lt;/strong&gt;，这样一轮一轮的比较交换下来，最大的那个数也就“沉到”了数组的最后，最小的“冒”到了数组的最前面，这样就完成了排序工作；&lt;/p&gt;
&lt;h3 id=&quot;基础算法代码未优化&quot;&gt;基础算法代码（未优化）&lt;/h3&gt;
&lt;p&gt;很简单，直接上代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 冒泡排序
 *
 * @param nums 待排序的数组
 */
public void bubbleSort(int[] nums) {
    // 正确性判断
    if (null == nums || nums.length &amp;lt;= 1) {
        return;
    }

    // 从小到大排序
    for (int i = 0; i &amp;lt; nums.length - 1; i++) {
        for (int j = i + 1; j &amp;lt; nums.length; j++) {
            if (nums[i] &amp;gt; nums[j]) {
                nums[i] = nums[i] + nums[j];
                nums[j] = nums[i] - nums[j];
                nums[i] = nums[i] - nums[j];
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意：&lt;strong&gt;加上正确性判断&lt;/strong&gt;；（讨论：其实我看大多数地方都是没有这个的，不知道有没有加上的必要...求讨论）&lt;/p&gt;
&lt;p&gt;另外光写完实现冒泡排序的算法是不算完的，还要养成良好的习惯去写测试单元用例，而且尽可能要考虑到多的点，例如这里的负数、多个相同的数之类的特殊情况，我就大概写一个吧，也欢迎指正：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void bubbleSortTester() {

    // 测试用例1：验证负数是否满足要求
    int[] nums = {1, 4, 2, -2, 5, 11, -7, 0};
    bubbleSort(nums);
    // 输出测试结果
    for (int i = 0; i &amp;lt; nums.length; i++) {
        System.out.print(nums[i] + &quot;, &quot;);
    }
    System.out.println();

    // 测试用例2：验证多个相同的数是否满足要求
    nums = new int[]{1, 1, 5, 7, 7, 3, 1};
    bubbleSort(nums);
    // 输出测试结果
    for (int i = 0; i &amp;lt; nums.length; i++) {
        System.out.print(nums[i] + &quot;, &quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;冒泡排序优化&quot;&gt;冒泡排序优化&lt;/h3&gt;
&lt;p&gt;想象一个这样的场景：如果该数组基本有序，或者在数组的后半段基本有序，上面的算法就会浪费许多的时间开销，所以我们不再使用双重嵌套去比较每两个元素的值，而只是不断比较数组每前后两个数值，让大的那个数不断“冒”到数组的最后，然后缩小尾边界的范围，并且增加一个标志位，表示这一趟是否发生了交换，如果没有那么证明该数组已经有序则完成了排序了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 改进的冒泡排序
 *
 * @param nums 待排序的数组
 */
public void bubbleSort2(int[] nums) {
    // 正确性判断
    if (null == nums || nums.length &amp;lt;= 1) {
        return;
    }
    
    // 使用一个数来记录尾边界
    int length = nums.length;
    boolean flag = true;// 发生了交换就为true, 没发生就为false，第一次判断时必须标志位true。
    while (flag) {
        flag = false;// 每次开始排序前，都设置flag为未排序过
        for (int i = 1; i &amp;lt; length; i++) {
            if (nums[i - 1] &amp;gt; nums[i]) {// 前面的数字大于后面的数字就交换
                int temp;
                temp = nums[i - 1];
                nums[i - 1] = nums[i];
                nums[i] = temp;

                // 表示交换过数据;
                flag = true;
            }
        }
        length--; // 减小一次排序的尾边界
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的记得写单元测试函数；&lt;/p&gt;
&lt;h3 id=&quot;冒泡排序进一步优化&quot;&gt;冒泡排序进一步优化&lt;/h3&gt;
&lt;p&gt;顺着这个思路，我们进一步想象一个场景：现在有一个包含 1000 个数的数组，仅有前面 100 个数无序，后面的 900 个数都比前面的 100 个数更大并且已经排好序，那么上面优化的方法又会造成一定的时间浪费，所以我们进一步增加一个变量记录最后发生交换的元素的位置，也就是排序的尾边界了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 冒泡算法最优解
 *
 * @param nums 待排序的数组
 */
public static void bubbleSort3(int[] nums) {
    int j, k;
    int flag = nums.length;// flag来记录最后交换的位置，也就是排序的尾边界

    while (flag &amp;gt; 0) {// 排序未结束标志
        k = flag;// k 来记录遍历的尾边界
        flag = 0;

        for (j = 1; j &amp;lt; k; j++) {
            if (nums[j - 1] &amp;gt; nums[j]) {// 前面的数字大于后面的数字就交换
                // 交换a[j-1]和a[j]
                int temp;
                temp = nums[j - 1];
                nums[j - 1] = nums[j];
                nums[j] = temp;

                // 表示交换过数据;
                flag = j;// 记录最新的尾边界.
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这应该是最优的冒泡排序了，同时也别忘记了最后要写测试单元用例代码；&lt;/p&gt;
&lt;h2 id=&quot;快速排序&quot;&gt;快速排序&lt;/h2&gt;
&lt;p&gt;快排也是一种很经典的算法，它使用了一种分治的思想，基本思想是：&lt;strong&gt;通过一趟排序将待排序的数组分成两个部分，其中一部分记录的是比关键字更小的，另一部分是比关键字更大的，然后再分别对着两部分继续进行排序，直到整个序列有序；&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础实现&quot;&gt;基础实现&lt;/h3&gt;
&lt;p&gt;非常经典的代码，直接上吧：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void quickSort(int[] arr) {
    qsort(arr, 0, arr.length - 1);
}

private static void qsort(int[] arr, int low, int high) {
    if (low &amp;lt; high) {
        int pivot = partition(arr, low, high);        // 将数组分为两部分
        qsort(arr, low, pivot - 1);                   // 递归排序左子数组
        qsort(arr, pivot + 1, high);                  // 递归排序右子数组
    }
}

private static int partition(int[] arr, int low, int high) {
    int pivot = arr[low];               // 枢轴记录
    while (low &amp;lt; high) {
        while (low &amp;lt; high &amp;amp;&amp;amp; arr[high] &amp;gt;= pivot) --high;
        arr[low] = arr[high];           // 交换比枢轴小的记录到左端
        while (low &amp;lt; high &amp;amp;&amp;amp; arr[low] &amp;lt;= pivot) ++low;
        arr[high] = arr[low];           // 交换比枢轴小的记录到右端
    }
    // 扫描完成，枢轴到位
    arr[low] = pivot;
    // 返回的是枢轴的位置
    return low;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，在手撕的时候需要注意函数上的 Java Doc 格式的注释，这里省略掉是为了节省篇幅，另外&lt;strong&gt;别忘了测试单元用例代码&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;上面的代码也很容易理解，&lt;strong&gt;其实就是一个“填坑”的过程&lt;/strong&gt;，第一个“坑”挖在每次排序的第一个位置&lt;code&gt;arr[low]&lt;/code&gt;，从序列后面往前找第一个比&lt;code&gt;pivot&lt;/code&gt;小的数来把这个“坑”填上，这时候的“坑”就变成了当前的&lt;code&gt;arr[high]&lt;/code&gt;，然后再从序列前面往后用第一个比&lt;code&gt;pivot&lt;/code&gt;大的数把刚才的“坑”填上，如此往复，始终有一个“坑”需要我们填上，直到最后一个“坑”出现，这个“坑”使用一开始的&lt;code&gt;pivot&lt;/code&gt;填上就可以了，而这个“坑”的位置也就是&lt;code&gt;pivot&lt;/code&gt;该填上的正确位置，我们再把这个位置返回，就可以把当前序列分成两个部分再依次这样操作最终就达到排序的目的了，不得不说这样的思想挺神奇的；&lt;/p&gt;
&lt;h3 id=&quot;算法优化&quot;&gt;算法优化&lt;/h3&gt;
&lt;p&gt;上面这个快速排序算法可以说是最基本的快速排序，因为它并没有考虑任何输入数据。但是，我们很容易发现这个算法的缺陷：这就是在我们输入数据基本有序甚至完全有序的时候，这算法退化为冒泡排序，不再是O(n㏒n)，而是O(n^2)了。&lt;/p&gt;
&lt;p&gt;究其根源，在于我们的代码实现中，每次只从数组第一个开始取。如果我们采用“三者取中”，即 arr[low], arr[high], arr[(low+high)/2] 三者的中值作为枢轴记录，则可以大大提高快速排序在最坏情况下的性能。但是，我们仍然无法将它在数组有序情形下的性能提高到O(n)。还有一些方法可以不同程度地提高快速排序在最坏情况下的时间性能。&lt;/p&gt;
&lt;p&gt;此外，快速排序需要一个递归栈，通常情况下这个栈不会很深，为log(n)级别。但是，如果每次划分的两个数组长度严重失衡，则为最坏情况，栈的深度将增加到O(n)。此时，由栈空间带来的空间复杂度不可忽略。如果加上额外变量的开销，这里甚至可能达到恐怖的O(n^2)空间复杂度。所以，快速排序的最差空间复杂度不是一个定值，甚至可能不在一个级别。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们可以在每次划分后比较两端的长度，并先对短的序列进行排序（目的是先结束这些栈以释放空间），可以将最大深度降回到O(㏒n)级别。&lt;/p&gt;
&lt;p&gt;关于优化的话，了解一个大概的思路就可以了，那在这里稍微总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;①三数取中作为枢轴记录；&lt;/li&gt;
&lt;li&gt;②当待排序序列的长度分割到一定大小之后，使用插入排序；&lt;/li&gt;
&lt;li&gt;③在一次分割结束后，可以把与&lt;code&gt;pivot&lt;/code&gt;相等的元素聚在一起，继续下次分割时，不用再对与&lt;code&gt;pivot&lt;/code&gt;相等的元素分割；&lt;/li&gt;
&lt;li&gt;④优化递归操作；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;参考文章：http://blog.51cto.com/flyingcat2013/1281614&lt;br/&gt;想要了解的更多的童鞋可以戳这里：https://blog.csdn.net/insistGoGo/article/details/7785038&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;二叉树也是一个容易提及的概念和写算法的问题，特别是它的几种递归遍历和非递归遍历，都是基础且常考的点，那在这里就稍微整理整理吧...&lt;/p&gt;
&lt;h2 id=&quot;二叉树的几种递归遍历&quot;&gt;二叉树的几种递归遍历&lt;/h2&gt;
&lt;p&gt;前序、中序、后序遍历都是非常基础且容易的遍历方法，重点还是在后面的中序和后续的非递归遍历上，当然还有层序遍历，所以这里不多说，直接给代码；&lt;/p&gt;
&lt;h3 id=&quot;前序遍历递归实现&quot;&gt;前序遍历递归实现&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void preOrderTraverse1(TreeNode root) {
    if (root != null) {
        System.out.print(root.val + &quot;  &quot;);
        preOrderTraverse1(root.left);
        preOrderTraverse1(root.right);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;中序遍历递归实现&quot;&gt;中序遍历递归实现&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void inOrderTraverse1(TreeNode root) {
    if (root != null) {
        preOrderTraverse1(root.left);
        System.out.print(root.val + &quot;  &quot;);
        preOrderTraverse1(root.right);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;后序遍历递归实现&quot;&gt;后序遍历递归实现&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void postOrderTraverse1(TreeNode root) {
    if (root != null) {
        preOrderTraverse1(root.left);
        preOrderTraverse1(root.right);
        System.out.print(root.val + &quot;  &quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面三种遍历，也就是输出结点数据的位置不同而已，所以很容易，但是如果手写，建议问清楚面试官要求，是在遍历时直接输出还是需要函数返回一个List集合，然后&lt;strong&gt;注意写测试用例代码！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二叉树的几种非递归遍历&quot;&gt;二叉树的几种非递归遍历&lt;/h2&gt;
&lt;h3 id=&quot;层序遍历&quot;&gt;★★层序遍历★★&lt;/h3&gt;
&lt;p&gt;层序遍历我们只需要增加使用一个队列即可，看代码很容易理解：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void levelTraverse(TreeNode root) {
    if (root == null) {
        return;
    }
    LinkedList&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
    queue.offer(root);
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        System.out.print(node.val + &quot;  &quot;);
        if (node.left != null) {
            queue.offer(node.left);
        }
        if (node.right != null) {
            queue.offer(node.right);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;前序遍历非递归实现&quot;&gt;前序遍历非递归实现&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void preOrderTraverse2(TreeNode root) {
    if (root == null) {
        return;
    }
    LinkedList&amp;lt;TreeNode&amp;gt; stack = new LinkedList&amp;lt;&amp;gt;();
    TreeNode pNode = root;
    while (pNode != null || !stack.isEmpty()) {
        if (pNode != null) {
            System.out.print(pNode.val + &quot;  &quot;);
            stack.push(pNode);
            pNode = pNode.left;
        } else { //pNode == null &amp;amp;&amp;amp; !stack.isEmpty()
            TreeNode node = stack.pop();
            pNode = node.right;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;中序遍历非递归实现&quot;&gt;★★中序遍历非递归实现★★&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 非递归中序遍历二叉树
 *
 * @param root 二叉树根节点
 * @return 中序遍历结果集
 */
public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) {

    List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    ArrayDeque&amp;lt;TreeNode&amp;gt; stack = new ArrayDeque&amp;lt;&amp;gt;();

    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            stack.addFirst(root);
            root = root.left;
        }
        root = stack.removeFirst();
        list.add(root.val);
        root = root.right;
    }
    return list;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;后续遍历非递归实现&quot;&gt;★★后续遍历非递归实现★★&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 二叉树的后序遍历
 *
 * @param root 二叉树根节点
 * @return 后序遍历结果集
 */
public List&amp;lt;Integer&amp;gt; postorderTraversal(TreeNode root) {
    List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    Deque&amp;lt;TreeNode&amp;gt; stack = new ArrayDeque&amp;lt;&amp;gt;();
    TreeNode pre = null;
    while (!stack.isEmpty() || root != null) {

        while (root != null) {
            stack.push(root);
            root = root.left;
        }

        root = stack.peek();
        // i ：判断如果右子树不为空且不为
        if (root.right != null &amp;amp;&amp;amp; root.right != pre) {
            root = root.right;
        } else {
            root = stack.pop();
            list.add(root.val);
            pre = root;
            root = null;
        }
    }
    return list;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果比较难以理解的话，可以自己尝试着跟跟 Debug 然后看看过程；&lt;/p&gt;
&lt;h2 id=&quot;二叉树相关其他算法题&quot;&gt;二叉树相关其他算法题&lt;/h2&gt;
&lt;p&gt;另外的话还有一些比较常见的关于树的算法，在文章的末尾，这里就不再赘述了：&lt;/p&gt;
&lt;p&gt;链接：https://www.jianshu.com/p/4ef1f50d45b5&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;除了上面 3 Part 比较重要的点之外，还有一些其他的算法也是经常考到的，下面我们来说；&lt;/p&gt;
&lt;h2 id=&quot;反转链表&quot;&gt;1.反转链表&lt;/h2&gt;
&lt;p&gt;这是一道很经典的题，不仅考你对链表的理解，而且还有一些&lt;strong&gt;细节（例如正确性判断/ 测试用例）&lt;/strong&gt;需要你从代码层面去展现，下面我们给出两段代码，读者可以自行去比较，我只是提供一个思路；&lt;/p&gt;
&lt;h3 id=&quot;思路一使用一个-node-不断链接&quot;&gt;思路一：使用一个 Node 不断链接&lt;/h3&gt;
&lt;p&gt;这是最经典的算法，也是需要我们牢牢掌握的方法，最重要的还是理解 &lt;code&gt;while()&lt;/code&gt; 循环中的过程：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
public ListNode reverseList(ListNode head) {

    // 正确性判断
    if (null == head || null == head.next) {
        return head;
    }

    ListNode pre = null;
    while (null != head) {
        ListNode temp = head;
        head = head.next;
        temp.next = pre;
        pre = temp;
    }

    return pre;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;思路二反转元素值然后重新赋给-node&quot;&gt;思路二：反转元素值然后重新赋给 Node&lt;/h3&gt;
&lt;p&gt;这是一个很简单的思路，比上个思路要多遍历一遍链表，但是好处是简单，思路清晰，实现起来容易，emm，像这一类问题我觉得另一个比较重要的就是&lt;strong&gt;举一反三&lt;/strong&gt;的能力吧，在这里我只提供两个思路，其实还有很多种实现方法，当然也别忘了&lt;strong&gt;细节&lt;/strong&gt;的东西~&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ListNode reverseList(ListNode head) {
    // 1.正确性判断
    if (null == head || null == head.next) {
        return head;
    }

    // 2.遍历链表head并将结果保存在List集合中
    List&amp;lt;ListNode&amp;gt; list = new LinkedList();
    ListNode tempNode = head;
    while (null != tempNode) {
        list.insert(tempNode.val);
        tempNode = tempNode.next;
    }   // end while：遍历完了链表并将结果保存在了List集合中

    // 3.反转集合，并将值依次复制给链表
    Collections.reverse(list);
    tempNode = head;
    while (null != tempNode) {
        tempNode.val = list.remove(0);
        tempNode = tempNode.next;
    }

    return head;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;合并两个有序链表&quot;&gt;2.合并两个有序链表&lt;/h2&gt;
&lt;p&gt;问题描述：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的；&lt;/p&gt;
&lt;p&gt;同样的经典算法，需要掌握：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
    if (l1 == null) {
        return l2;
    }
    if (l2 == null) {
        return l1;
    }
    ListNode head = null;
    if (l1.val &amp;lt; l2.val) {
        head = l1;
        head.next = mergeTwoLists(l1.next, l2);
    } else {
        head = l2;
        head.next = mergeTwoLists(l1, l2.next);
    }
    return head;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这道题也是 LeetCode 上的一道题，我当时的做法是下面这样的，虽然看起来代码量多了不少而且看起来蠢蠢的..但是经过 LeetCode 测试，甚至比上面的实现要快上那么 2ms，&lt;strong&gt;特别提醒：下面的代码只是用作一个思路的参考，着重掌握上面的代码&lt;/strong&gt; ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ListNode mergeTwoLists(ListNode l1, ListNode l2) {

    // 定义一个虚拟头结点方便遍历
    ListNode dummyHead = new ListNode(-1);
    dummyHead.next = l1;
    ListNode pre = dummyHead;

    // 遍历l1链表
    int len1 = 0;
    while (null != pre.next) {
        len1++;
        pre = pre.next;
    }

    int[] nums1 = new int[len1];

    // 保存l1链表的数据
    pre = dummyHead;
    for (int i = 0; i &amp;lt; len1; i++) {
        nums1[i] = pre.next.val;
        pre = pre.next;
    }

    // 遍历l2链表
    int len2 = 0;
    dummyHead.next = l2;
    pre = dummyHead;
    while (null != pre.next) {
        len2++;
        pre = pre.next;
    }

    int[] nums2 = new int[len2];

    // 保存l2链表的数据
    pre = dummyHead;
    for (int i = 0; i &amp;lt; len2; i++) {
        nums2[i] = pre.next.val;
        pre = pre.next;
    }

    int[] nums = new int[len1 + len2];
    // 将两个链表的数据整合并排序
    System.arraycopy(nums1, 0, nums, 0, len1);
    System.arraycopy(nums2, 0, nums, len1, len2);
    Arrays.sort(nums);

    // 拼接一个链表
    ListNode dummy = new ListNode(-1);
    pre = dummy;
    for (int i = 0; i &amp;lt; nums.length; i++) {
        ListNode node = new ListNode(nums[i]);
        pre.next = node;
        pre = pre.next;
    }

    return dummy.next;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;两个链表的第一个公共结点&quot;&gt;3.两个链表的第一个公共结点&lt;/h2&gt;
&lt;p&gt;题目描述：找出两个链表的第一个公共结点；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 求两个链表中第一个公共结点
 *
 * @param pHead1 链表1头结点
 * @param pHead2 链表2头结点
 * @return 链表第一个公共结点
 */
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    // 1.正确性判断
    if (null == pHead1 || null == pHead2) {
        return null;
    }

    // 2.遍历链表1把所有结点保存在列表中中
    Vector&amp;lt;ListNode&amp;gt; nodeList1 = new Vector&amp;lt;&amp;gt;();
    while (null != pHead1) {
        nodeList1.add(pHead1);
        pHead1 = pHead1.next;
        // 判断是否成环，成环则退出循环
        if (nodeList1.contains(pHead1)) {
            break;
        }
    }   // end while：链表1中的所有结点都存入了nodeList1中

    // 3.遍历链表2比较列表中的数据
    Vector&amp;lt;ListNode&amp;gt; nodeList2 = new Vector&amp;lt;&amp;gt;();
    while (null != pHead2) {
        // 先判断nodeList1中是否存在相同结点，存在则返回
        if (nodeList1.contains(pHead2)) {
            return pHead2;
        }
        // 如果不存在则继续遍历，并判断是否成环
        nodeList2.add(pHead2);
        pHead2 = pHead2.next;
        if (nodeList2.contains(pHead2)) {
            break;
        }
    }   // end while：遍历完了链表2并将所有结点保存在了nodeList2中

    // 如果遍历完链表2则返回null
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的细节是：①正确性判断；②判断链表是否自己成环；③注释；&lt;strong&gt;④注意要自己写测试用例啊&lt;/strong&gt;...&lt;/p&gt;
&lt;p&gt;另外还有一些类似的题目像是：①链表入环结点；②链表倒数第k个结点；之类的都是需要掌握的...&lt;/p&gt;
&lt;h2 id=&quot;二分查找算法&quot;&gt;4.二分查找算法&lt;/h2&gt;
&lt;p&gt;二分查找也是一类比较常考的题目，其实代码也比较容易理解，直接上吧，再再再提醒一下：&lt;strong&gt;注意正确性判断还有测试用例...&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;普通实现&quot;&gt;普通实现&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 二分查找普通实现。
 *
 * @param srcArray 有序数组
 * @param key      查找元素
 * @return 不存在返回-1
 */
public static int binSearch(int srcArray[], int key) {
    int mid;
    int start = 0;
    int end = srcArray.length - 1;
    while (start &amp;lt;= end) {
        mid = (end - start) / 2 + start;
        if (key &amp;lt; srcArray[mid]) {
            end = mid - 1;
        } else if (key &amp;gt; srcArray[mid]) {
            start = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;递归实现&quot;&gt;递归实现&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 二分查找递归实现。
 *
 * @param srcArray 有序数组
 * @param start    数组低地址下标
 * @param end      数组高地址下标
 * @param key      查找元素
 * @return 查找元素不存在返回-1
 */
public static int binSearch(int srcArray[], int start, int end, int key) {
    int mid = (end - start) / 2 + start;
    if (srcArray[mid] == key) {
        return mid;
    }
    if (start &amp;gt;= end) {
        return -1;
    } else if (key &amp;gt; srcArray[mid]) {
        return binSearch(srcArray, mid + 1, end, key);
    } else if (key &amp;lt; srcArray[mid]) {
        return binSearch(srcArray, start, mid - 1, key);
    }
    return -1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;斐波那契数列&quot;&gt;5.斐波那契数列&lt;/h2&gt;
&lt;p&gt;这也是一道很经典的题，通常是要要求 N 值的范围的，常规写法应该很简单，所以需要掌握的是优化之后的算法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int Fibonacci(int n) {
    // 正确性判断
    if (0 == n || 1 == n) {
        return n;
    }

    int nums1 = 0, nums2 = 1;
    int res = 0;
    for (int i = 2; i &amp;lt;= n; i++) {
        res = nums1 + nums2;
        nums1 = nums2;
        nums2 = res;
    }

    return res;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是注意正确性判断然后写测试用例...&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;如果用手写代码的话，确实是个挺麻烦的事儿，首先需要对代码有相当的熟悉程度，然后其次的话考察的都是一些细节的东西，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;编码规范&lt;/strong&gt;：包括一些命名的规范/ 注释的规范等等；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缩进&lt;/strong&gt;：这个我自己倒是挺在意的..关于这个可以去参考参考阿里出的那个规范手册；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注释&lt;/strong&gt;：如果命名规范做得好的话其实是可以达到代码即注释的，但是仍然有一些需要标注的地方例如函数头之类的，最好还是做好注释；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;代码的完整性&lt;/strong&gt;：我觉得这个包括对于&lt;strong&gt;错误的处理/ 正确性判断&lt;/strong&gt;这样一类的东西；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试用例&lt;/strong&gt;：每个函数都需要一定的测试来保证其正确性，所以这个还是挺有必要的，特别是一些边界情况，null 值判断之类的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;想好再下笔&lt;/strong&gt;：这一点其实也蛮重要的，不管是在纸上还是在我们平时的编程中，思路永远都是更重要的；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说来说去还是关于代码的事，我觉得还是&lt;strong&gt;理清思路&lt;/strong&gt;最重要，所以我们需要在一遍一遍熟悉代码的过程中，熟知这些代码的思路，只有搞清楚这些代码背后的原理了，我们才能正确且快速的写出我们心中想要的代码，而不是简单的去背诵，这样是没有很大效果的，以上...&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6.1847389558233&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;简书ID：&lt;a href=&quot;https://www.jianshu.com/u/a40d61a49221&quot;&gt;@我没有三颗心脏&lt;/a&gt;&lt;br/&gt;github：&lt;a href=&quot;https://github.com/wmyskxz/&quot;&gt;wmyskxz&lt;/a&gt;&lt;br/&gt;欢迎关注公众微信号：wmyskxz_javaweb&lt;br/&gt;分享自己的Java Web学习之路以及各种Java学习资料&lt;br/&gt;想要交流的朋友也可以加qq群：3382693&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 26 Aug 2018 10:32:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<og:description>前言 ：不管是远程的视频面试，还是现场的面试，都有可能会有手撕代码的环节，这也是很多童鞋包括我(虽然还没遇到过..)都很头疼的东西，可能是因为 IDE 自动提示功能用惯了或是其他一些原因，总之让我手写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmyskxz/p/9538177.html</dc:identifier>
</item>
<item>
<title>移动端适配方案进阶 - 左手拍拍</title>
<link>http://www.cnblogs.com/zuoshoupai/p/9538068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuoshoupai/p/9538068.html</guid>
<description>&lt;p&gt;         Web页面做移动端适配，就是在不同尺寸的手机设备上，页面“相对性的达到合理的展示（自适应）”或者“保持统一效果的等比缩放（看起来差不多）”。有几个要点必须要掌握，一个是不同尺寸，一个是清晰，还有一个是合理。为什么强调这几个词当然是有原因的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、目标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1．  页面布局总是按照一定规则来进行的。但是移动设备却是多种多样的，屏幕尺寸大小不同，分辨率不同，像素比不同，宽高也不同（相应的概念会在后面介绍）。所以要让一套代码适应所有设备，是最棘手的。、&lt;/p&gt;
&lt;p&gt;2．  要保证清晰度，小屏手机和大屏手机用同样的图片，通过缩放效果显示的大小比例是一致的，但是图片放大会失真，高清图缩小预览又浪费。这就需要综合考虑情况了。&lt;/p&gt;
&lt;p&gt;3．  所谓合理展示，指的是不论什么设备都能有原设计稿一样的视觉和体验效果。如果单纯的按照固定的像素px来设置宽高，结果会怎样。要么小屏手机出现滚动条，要么大屏手机有留白。虽说是原样输出，但这并不是设计稿的效果。人家设计稿是全屏完美展示，不能到手机上变成半屏或两屏了。所以说还原设计稿可以理解成等比例缩放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、思考&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们的目的搞清楚了，但是还是不得不先泼一泼冷水。首先，没有绝对完美的适配方案。不可能让所有设备真正100%还原设计稿。因为设备的宽高比例就不尽相同五花八门，光这一点就没办法解决，比如说你想用同一张图片给正方形和长方形做壁纸，总有一个会被拉伸或是留白。所以目前通用的原则是文字流式，控件弹性，图片等比缩放。借用万能网络上图片展示下效果。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1139713/201808/1139713-20180826180105805-1045675078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了目标和大致想法接下来差不多上方案了，为了更好讲解，还得科普几个知识点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、基本概念&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://images2018.cnblogs.com/blog/1139713/201808/1139713-20180826180115560-499634598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;屏幕尺寸（inch）：手机设备的对角线长度，比如iphone5为4英寸。&lt;/p&gt;
&lt;p&gt;屏幕宽高比：手机的高度与宽度的比例 为16：9&lt;/p&gt;
&lt;p&gt;物理像素（px）: 显示器(手机屏幕)上最小的物理显示单元，比如iphone5的物理像素是640*1136&lt;/p&gt;
&lt;p&gt;像素密度（PPI）: 表示沿着对角线，每英寸所拥有的物理像素（Pixel）数目,值越低颗粒感越强，超过300人眼很难分辨&lt;/p&gt;
&lt;p&gt;设备独立像素|密度无关像素|逻辑像素(px): 可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。比如iphone5的物理像素是320*568&lt;/p&gt;
&lt;p&gt;像素比(pdr): 物理像素和设备独立像素的对应关系，设备像素比 = 物理像素 / 设备独立像素，比如iphone5的像素比是2。&lt;/p&gt;


&lt;p&gt;以上概念如果一下接受不了自行百度吧。在这里主要解释下pdr,原来的显示设备的pdr都是1，后来引入了高清屏有了retina，这个pdr就出现了。当然是值越高，显示效果越清楚，同时意味着用css控制某个像素的时候，实际上控制的是成倍的物理像素。最简单的例子是用Iphone5截个图，虽然css下最宽只有320px,但是把图片放到电脑上就成了640px了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四，深入了解适配下的高清问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用多大的图片才能清晰？&lt;/p&gt;
&lt;p&gt;如果在pdr为1的情况下，要显示100*100的图片，用50*50，100*100还是200*200的图片。当然我们都能理解50*50肯定是要排除的。不过，原因是什么我们还需要讨论一下。换个更形象的说法，要用要求的红黄颜料填满2个坑，是要用一种颜料还是2种还是4种。如果用一种颜料同时显示红与黄的效果，那么只能把两种颜料先混合再倒入，结果肯定会失真；如果用两种，分别用红和黄倒入，那么就泾渭分明；如果用4种呢，就得压缩一半塞进去，也就是说红和黄已经被压缩了一半，还会渗进其它颜色才填满。这个时侯，显示效果会失去锐度。所以不论给的图片大了还是小了都不会模糊。&lt;/p&gt;
&lt;p&gt;但是好多设备不是单单的pdr为1，如果等于2的时候，要显示100*100的图片，就需要200*200的图片；如果pdr为3，就要引入300*300的图片，同样有更多像素比的设备，不可能一一满足，因此普通做法是提供2x，3x图片。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、适配方案&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;终于要讲到方案了，上面也讲到了要实现自适应就是等比例缩放。因此我们想到三种方案。&lt;/p&gt;
&lt;p&gt;一，按百分比设置宽高。可能实现适配效果，缺点是会出现拉伸，模糊，因为设备宽高比不同，高度很难用百分比控制。&lt;/p&gt;
&lt;p&gt;二，viewport缩放&lt;/p&gt;
&lt;pre&gt;
        在页面内可以设置viewport的scale
&lt;/pre&gt;
&lt;p&gt;属性来控制页面显示比例。类似于放大缩小图片，通过计算设备宽度与设计稿的比例来得出缩放的倍数，最终实现适配效果。为了适配大多数设备并保证清晰度要采用更大分辨率的设计稿，感觉有些浪费资源。&lt;/p&gt;
&lt;p&gt;三、rem相对单位&lt;/p&gt;
&lt;p&gt;因为rem是相对单位，它会以Htm的font-size的大小为基数来计量长度。所以计算设备屏幕宽度与设计稿的比例来动态设备html的font-size,。这样就能在不同设备上等比例来显示。相当于先把屏幕宽度等分成固定的份数，然后再以份数作为单位计量。&lt;/p&gt;
&lt;p&gt;其实现在的适配方案不外乎这么几种，尤其第三种操作起来很方便（后面会附上代码）。不过，阿里团队为了追求清晰度和解决1px的问题又推出了高清适配方案，主要是把像素比考虑进去，结合第二种第三种方案来实现。方法是先用设备宽度与pdr相乘然后取到与设计稿的比例，动态设置html的font-size,最后再根据pdr的值动态设置scale来实现缩放。&lt;/p&gt;
&lt;p&gt;备注:1px问题指的是在使用rem后，会出现像素值为小数的情况，小数位可能会被系统直接忽略掉，出现宽窄不同的现象。&lt;/p&gt;
&lt;p&gt;附普通适配方案（代码摘自网络）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; _self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     _self.width =1080;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置UI提供的基准尺寸&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     _self.fontSize = 200;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认字体大小，使用时除以此参数作为rem,建议取10或100容易计算。为保证谷歌良好适配，320/_self.width*_self.fontSize&amp;gt;12&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     _self.widthProportion = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; p = (document.body&amp;amp;&amp;amp;
&lt;span&gt; 8&lt;/span&gt;       document.body.clientWidth ||
&lt;span&gt; 9&lt;/span&gt;       document.getElementsByTagName(&quot;html&quot;)[0].offsetWidth)/_self.width;
&lt;span&gt;10&lt;/span&gt;       
&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; p&amp;gt;0.71?0.71:(p&amp;lt;0.3?0.3:p);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置安全尺寸最宽768px,最小320px&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    console.log(_self.widthProportion());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     _self.changePage = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         document.getElementsByTagName(&quot;html&quot;)[0].setAttribute(&quot;style&quot;,&quot;font-size:&quot;+_self.widthProportion()*_self.fontSize+&quot;px !important&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    _self.changePage();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     window.addEventListener(&quot;resize&quot;,&lt;span&gt;function&lt;/span&gt;(){_self.changePage();},&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;高清适配方案（代码摘自网络）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 2&lt;/span&gt; (&lt;span&gt;function&lt;/span&gt;(doc, win, designSize) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;designSize为设计稿的尺寸(宽) &lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; docEl =&lt;span&gt; document.documentElement, 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     devWidth = docEl.clientWidth &amp;gt; 1080 ? 1080&lt;span&gt; : docEl.clientWidth,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     dpr = devicePixelRatio || 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     scale = 1 /&lt;span&gt; dpr, 
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     width = dpr *&lt;span&gt; devWidth, 
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     resizeEvt = 'orientationchange' &lt;span&gt;in&lt;/span&gt; window ? 'orientationchange' : 'onresize', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断横屏和窗口重置 &lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     recalc = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() { 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;               &lt;span&gt;var&lt;/span&gt; clientWidth =&lt;span&gt; docEl.clientWidth; 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;               &lt;span&gt;if&lt;/span&gt; (!clientWidth) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;               document.querySelector('meta[name=&quot;viewport&quot;]') .setAttribute('content','width=' + width + '&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;               initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;               docEl.style.fontSize = devWidth / (designSize / 100) * dpr + 'px'&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }; 
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!doc.addEventListener) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     win.addEventListener(resizeEvt, recalc, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     doc.addEventListener('DOMContentLoaded', recalc, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; })(document, window, 750&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p align=&quot;left&quot;&gt;&lt;br/&gt;参考文章：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;https://segmentfault.com/a/1190000008767416&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;http://www.aliued.com/?p=3166&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;https://www.jianshu.com/p/07669cb3e7c5&lt;/p&gt;

</description>
<pubDate>Sun, 26 Aug 2018 10:01:00 +0000</pubDate>
<dc:creator>左手拍拍</dc:creator>
<og:description>Web页面做移动端适配，就是在不同尺寸的手机设备上，页面“相对性的达到合理的展示（自适应）”或者“保持统一效果的等比缩放（看起来差不多）”。有几个要点必须要掌握，一个是不同尺寸，一个是清晰，还有一个是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuoshoupai/p/9538068.html</dc:identifier>
</item>
<item>
<title>纠正：关于@webFilter使用@Order无效问题 - oKong_趔趄的猿</title>
<link>http://www.cnblogs.com/okong/p/correct-webfilter.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okong/p/correct-webfilter.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;blockquote readability=&quot;5.6528301886792&quot;&gt;
&lt;p&gt;在&lt;code&gt;SpringBoot&lt;/code&gt;系列文章的&lt;a href=&quot;http://blog.lqdev.cn/2018/07/19/springboot/chapter-seven/&quot; title=&quot;《第七章：过滤器、监听器、拦截器》&quot;&gt;《第七章：过滤器、监听器、拦截器》&lt;/a&gt;中，小技巧中指出，可使用&lt;code&gt;@Order&lt;/code&gt;设置过滤器的执行顺序。由于没有自己求证过，看了相关材料后，想当然的写进了文章中，这个进行更正下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;通过&lt;code&gt;过滤器名称&lt;/code&gt;和设置&lt;code&gt;@Order&lt;/code&gt;的方法都是不行的。抱歉了，各位。之后在编写文章时，会本着负责且持着大胆猜测小心求证的态度，会对相关事项进行核对的！再次，抱歉，误导了大家&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里要感谢简书网友：&lt;strong&gt;&lt;a href=&quot;https://www.jianshu.com/u/6aba888b2198&quot;&gt;形而上学本尊&lt;/a&gt;&lt;/strong&gt;，指出此错误！再次感谢！&lt;/p&gt;
&lt;h2 id=&quot;正确设置排序方式&quot;&gt;正确设置排序方式&lt;/h2&gt;
&lt;blockquote readability=&quot;5.3991031390135&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.lqdev.cn/2018/07/19/springboot/chapter-seven/&quot; title=&quot;《第七章：过滤器、监听器、拦截器》&quot;&gt;《第七章：过滤器、监听器、拦截器》&lt;/a&gt;也有指出，利用&lt;code&gt;FilterRegistrationBean&lt;/code&gt;可以设置排序顺序。那是否还有其他方式呢。有的，只是这种方案不是很优雅。这里简单说明下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;先说结论：可以通过&lt;code&gt;过滤器&lt;/code&gt;的类名进行约定排序。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;浅谈servletcomponentscan注解的启动方式&quot;&gt;浅谈ServletComponentScan注解的启动方式&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;既然遇到了，那就简单分析下使用&lt;code&gt;@WebFilter&lt;/code&gt;和&lt;code&gt;@ServletComponentScan&lt;/code&gt;的启动方式吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我们来看下，注解&lt;code&gt;@ServletComponentScan&lt;/code&gt;(删除了相关注解):&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(ServletComponentScanRegistrar.class)
public @interface ServletComponentScan {

    @AliasFor(&quot;basePackages&quot;)
    String[] value() default {};

    @AliasFor(&quot;value&quot;)
    String[] basePackages() default {};

    Class&amp;lt;?&amp;gt;[] basePackageClasses() default {};

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来说，此注解就是指定扫描路径的，通过&lt;code&gt;value&lt;/code&gt;、&lt;code&gt;basePackages&lt;/code&gt;或者&lt;code&gt;basePackageClasses&lt;/code&gt;。主要还是看下&lt;code&gt;ServletComponentScanRegistrar&lt;/code&gt;类，这才是关键。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class ServletComponentScanRegistrar implements ImportBeanDefinitionRegistrar {

    private static final String BEAN_NAME = &quot;servletComponentRegisteringPostProcessor&quot;;

    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        // 获取包路径
        Set&amp;lt;String&amp;gt; packagesToScan = getPackagesToScan(importingClassMetadata);
        // 若已注册，则更新，否则新增
        if (registry.containsBeanDefinition(BEAN_NAME)) {
            updatePostProcessor(registry, packagesToScan);
        } else {
            addPostProcessor(registry, packagesToScan);
        }
    }

    private void updatePostProcessor(BeanDefinitionRegistry registry, Set&amp;lt;String&amp;gt; packagesToScan) {
        BeanDefinition definition = registry.getBeanDefinition(BEAN_NAME);
        ValueHolder constructorArguments = definition.getConstructorArgumentValues().getGenericArgumentValue(Set.class);
        @SuppressWarnings(&quot;unchecked&quot;)
        Set&amp;lt;String&amp;gt; mergedPackages = (Set&amp;lt;String&amp;gt;) constructorArguments.getValue();
        mergedPackages.addAll(packagesToScan);
        constructorArguments.setValue(mergedPackages);
    }

    private void addPostProcessor(BeanDefinitionRegistry registry, Set&amp;lt;String&amp;gt; packagesToScan) {
        GenericBeanDefinition beanDefinition = new GenericBeanDefinition();
        // 设置类
        beanDefinition.setBeanClass(ServletComponentRegisteringPostProcessor.class);
        // 设置构造函数参数
        beanDefinition.getConstructorArgumentValues().addGenericArgumentValue(packagesToScan);
        beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
        // 注册
        registry.registerBeanDefinition(BEAN_NAME, beanDefinition);
    }

    private Set&amp;lt;String&amp;gt; getPackagesToScan(AnnotationMetadata metadata) {
        // 获取注解ServletComponentScan的属性信息
        AnnotationAttributes attributes = AnnotationAttributes
                .fromMap(metadata.getAnnotationAttributes(ServletComponentScan.class.getName()));
        // 获取属性basePackages和basePackageClasses
        String[] basePackages = attributes.getStringArray(&quot;basePackages&quot;);
        Class&amp;lt;?&amp;gt;[] basePackageClasses = attributes.getClassArray(&quot;basePackageClasses&quot;);
        Set&amp;lt;String&amp;gt; packagesToScan = new LinkedHashSet&amp;lt;String&amp;gt;();
        packagesToScan.addAll(Arrays.asList(basePackages));
        // basePackageClasses 最后也是根据basePackageClasses来获取塔对应的包路径
        for (Class&amp;lt;?&amp;gt; basePackageClass : basePackageClasses) {
            packagesToScan.add(ClassUtils.getPackageName(basePackageClass));
        }
        // 默认不填写时，获取的是被注解类所在包路径，所以一般放在启动类上
        if (packagesToScan.isEmpty()) {
            packagesToScan.add(ClassUtils.getPackageName(metadata.getClassName()));
        }
        return packagesToScan;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看见，它是一个&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;的实现类，&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;可以动态地装载&lt;code&gt;Bean&lt;/code&gt;。再来看看&lt;code&gt;ServletComponentRegisteringPostProcessor&lt;/code&gt;类，此类是个&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;，BeanFactory的后置处理器，简单理解就是扩展点吧。启动的时候会调用&lt;code&gt;postProcessBeanFactory&lt;/code&gt;方法。&lt;br/&gt;&lt;code&gt;ServletComponentRegisteringPostProcessor&lt;/code&gt;源码就不贴了，简单来说，它的作用就是：扫描被&lt;code&gt;@WebServlet&lt;/code&gt;、&lt;code&gt;@WebFilter&lt;/code&gt;及&lt;code&gt;@WebListener&lt;/code&gt;的类，最后通过对应的&lt;code&gt;ServletRegistrationBean&lt;/code&gt;、&lt;code&gt;FilterRegistrationBean&lt;/code&gt;及&lt;code&gt;ServletListenerRegistrationBean&lt;/code&gt;进行注册。看见这些是不是很熟悉了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//部分代码
    static {
        List&amp;lt;ServletComponentHandler&amp;gt; servletComponentHandlers = new ArrayList&amp;lt;ServletComponentHandler&amp;gt;();
        servletComponentHandlers.add(new WebServletHandler());
        servletComponentHandlers.add(new WebFilterHandler());
        servletComponentHandlers.add(new WebListenerHandler());
        HANDLERS = Collections.unmodifiableList(servletComponentHandlers);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键看这个方法&lt;code&gt;scanPackage&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private void scanPackage(
            ClassPathScanningCandidateComponentProvider componentProvider,
            String packageToScan) {
        for (BeanDefinition candidate : componentProvider
                .findCandidateComponents(packageToScan)) {
            if (candidate instanceof ScannedGenericBeanDefinition) {
                for (ServletComponentHandler handler : HANDLERS) {
                    handler.handle(((ScannedGenericBeanDefinition) candidate),
                            (BeanDefinitionRegistry) this.applicationContext);
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看见，通过&lt;code&gt;componentProvider.findCandidateComponents(packageToScan)&lt;/code&gt;方法获取到对应的注解类，同时判断是否为以上说的三种，最后调用其&lt;code&gt;doHandle&lt;/code&gt;方法完成注册功能。以下是&lt;code&gt;WebFilterHandler&lt;/code&gt;的&lt;code&gt;doHandler&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-25/25542572.jpg&quot; alt=&quot;WebFilterHandler&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，我们看看&lt;code&gt;findCandidateComponents&lt;/code&gt;方法怎么获取对应注解类的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-25/12260106.jpg&quot; alt=&quot;findCandidateComponents&quot;/&gt;&lt;/p&gt;
&lt;p&gt;断点之后，可以看见是&lt;code&gt;AnnotationConfigEmbeddedWebApplicationContext&lt;/code&gt;类，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-25/95298519.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续断点进去，最后是使用&lt;code&gt;PathMatchingResourcePatternResolver&lt;/code&gt;类进行资源获取的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-25/23800624.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过递归的方式，获取所有的类：&lt;br/&gt;&lt;img src=&quot;http://qiniu.xds123.cn/18-8-25/2435932.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后关键就是这个&lt;code&gt;Arrays.sort(dirContents)&lt;/code&gt;了。所以简单来说，可以通过class类名来达到排序效果。但这种方案要限制类名，还是使用&lt;code&gt;FilterRegistrationBean&lt;/code&gt;之类的来设置吧。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;写的可能有点乱也有点水，⊙﹏⊙‖∣。主要还是想纠正下原先的错误，O__O…。&lt;strong&gt;知其然知其所以然，还有很长的路要走。没有写里面的细节，只是大致讲解了下。有兴趣的可以自行跟踪看看。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;目前互联网上很多大佬都有&lt;code&gt;SpringBoot&lt;/code&gt;系列教程，如有雷同，请多多包涵了。&lt;strong&gt;原创不易，码字不易&lt;/strong&gt;，还希望大家多多支持。若文中有所错误之处，还望提出，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;老生常谈&quot;&gt;老生常谈&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;个人QQ：&lt;code&gt;499452441&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;微信公众号：&lt;code&gt;lqdevOps&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://qiniu.xds123.cn/default/wxgzh8cm.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人博客：&lt;a href=&quot;http://blog.lqdev.cn/&quot; class=&quot;uri&quot; title=&quot;http://blog.lqdev.cn&quot;&gt;http://blog.lqdev.cn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.lqdev.cn/2018/08/26/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/correct-webfilter/&quot;&gt;http://blog.lqdev.cn/2018/08/26/%E6%97%A5%E5%B8%B8%E7%A7%AF%E7%B4%AF/correct-webfilter/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 Aug 2018 09:58:00 +0000</pubDate>
<dc:creator>oKong_趔趄的猿</dc:creator>
<og:description>前言 在 系列文章的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okong/p/correct-webfilter.html</dc:identifier>
</item>
<item>
<title>吴恩达深度学习笔记 course4 week3 目标检测 - Dar_Alpha</title>
<link>http://www.cnblogs.com/Dar-/p/9538025.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dar-/p/9538025.html</guid>
<description>
&lt;h3&gt;1.Objection localization &lt;/h3&gt;
&lt;p&gt;图片检测问题分为:&lt;/p&gt;
&lt;p&gt;1.图片分类:是否为汽车(结果只为单个对象)&lt;/p&gt;
&lt;p&gt;2.分类与定位:是否为汽车 ,汽车位置(结果只为单个对象)&lt;/p&gt;
&lt;p&gt;3.目标检测: 检测不同物体 并定位(结果可能含多个对象)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826115257149-1754366244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分类与定位的表示:&lt;/p&gt;
&lt;p&gt;分类与定位的输出层可用如下表示:                                             &lt;/p&gt;
&lt;p&gt;1.Pc  是否存在&lt;/p&gt;
&lt;p&gt;2.bx  目标中心的坐标 x&lt;/p&gt;
&lt;p&gt;3.by 目标中心的坐标 y&lt;/p&gt;
&lt;p&gt;4.bH 目标高度&lt;/p&gt;
&lt;p&gt;5.bW 目标宽度&lt;/p&gt;
&lt;p&gt;6.C1  是否为分类1&lt;/p&gt;
&lt;p&gt;7.C2 是否为分类2&lt;/p&gt;
&lt;p&gt;8.C3 是否为分类3&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826120245759-60316103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模型训练时，bx、by、bh、bw都由人为确定其数值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826115612909-1449213327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;损失函数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Pc=1，即&lt;span id=&quot;MathJax-Element-8-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-178&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-179&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-180&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-181&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-182&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-183&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-184&quot; class=&quot;mn&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;y^1=1：&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　　　　　&lt;span id=&quot;MathJax-Element-9-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot; display=&amp;quot;block&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;L&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mover&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;&amp;amp;#x005E;&amp;lt;/mo&amp;gt;&amp;lt;/mover&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mover&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;&amp;amp;#x005E;&amp;lt;/mo&amp;gt;&amp;lt;/mover&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo&amp;gt;+&amp;lt;/mo&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mover&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;&amp;amp;#x005E;&amp;lt;/mo&amp;gt;&amp;lt;/mover&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo&amp;gt;+&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x22EF;&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;+&amp;lt;/mo&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mover&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;&amp;amp;#x005E;&amp;lt;/mo&amp;gt;&amp;lt;/mover&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mn&amp;gt;8&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;8&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-185&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-186&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-187&quot; class=&quot;mi&quot;&gt;L&lt;span id=&quot;MathJax-Span-188&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-189&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-190&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-191&quot; class=&quot;munderover&quot;&gt;&lt;span id=&quot;MathJax-Span-192&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-193&quot; class=&quot;mo&quot;&gt;^&lt;span id=&quot;MathJax-Span-194&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-195&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-196&quot; class=&quot;mo&quot;&gt;)&lt;span id=&quot;MathJax-Span-197&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-198&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-199&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-200&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-201&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-202&quot; class=&quot;munderover&quot;&gt;&lt;span id=&quot;MathJax-Span-203&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-204&quot; class=&quot;mo&quot;&gt;^&lt;span id=&quot;MathJax-Span-205&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-206&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-207&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-208&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-209&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-210&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-211&quot; class=&quot;mo&quot;&gt;)&lt;span id=&quot;MathJax-Span-212&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-213&quot; class=&quot;mo&quot;&gt;+&lt;span id=&quot;MathJax-Span-214&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-215&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-216&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-217&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-218&quot; class=&quot;munderover&quot;&gt;&lt;span id=&quot;MathJax-Span-219&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-220&quot; class=&quot;mo&quot;&gt;^&lt;span id=&quot;MathJax-Span-221&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-222&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-223&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-224&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-225&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-226&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-227&quot; class=&quot;mo&quot;&gt;)&lt;span id=&quot;MathJax-Span-228&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-229&quot; class=&quot;mo&quot;&gt;+&lt;span id=&quot;MathJax-Span-230&quot; class=&quot;mo&quot;&gt;⋯&lt;span id=&quot;MathJax-Span-231&quot; class=&quot;mo&quot;&gt;+&lt;span id=&quot;MathJax-Span-232&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-233&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-234&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-235&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-236&quot; class=&quot;munderover&quot;&gt;&lt;span id=&quot;MathJax-Span-237&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-238&quot; class=&quot;mo&quot;&gt;^&lt;span id=&quot;MathJax-Span-239&quot; class=&quot;mn&quot;&gt;8&lt;span id=&quot;MathJax-Span-240&quot; class=&quot;mo&quot;&gt;−&lt;span id=&quot;MathJax-Span-241&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-242&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-243&quot; class=&quot;mn&quot;&gt;8&lt;span id=&quot;MathJax-Span-244&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-245&quot; class=&quot;mo&quot;&gt;)&lt;span id=&quot;MathJax-Span-246&quot; class=&quot;mn&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML MJX_Assistive_MathML_Block&quot;&gt;L(y^,y)=(y^1−y1)2+(y^2−y2)2+⋯+(y^8−y8)2&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Pc=0，即&lt;span id=&quot;MathJax-Element-10-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-247&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-248&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-249&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-250&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-251&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-252&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-253&quot; class=&quot;mn&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;y1=0&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;　　　　　　L(y^1,y)=(y^1-y1)&lt;sup&gt;2    &lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;当然在实际的目标定位应用中，我们可以使用更好的方式是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对 &lt;span id=&quot;MathJax-Element-16-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;c&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-176&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-177&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-178&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-179&quot; class=&quot;mi&quot;&gt;c&lt;span id=&quot;MathJax-Span-180&quot; class=&quot;mn&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;、&lt;span id=&quot;MathJax-Element-17-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;c&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-181&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-182&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-183&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-184&quot; class=&quot;mi&quot;&gt;c&lt;span id=&quot;MathJax-Span-185&quot; class=&quot;mn&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;、&lt;span id=&quot;MathJax-Element-18-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;c&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;3&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-186&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-187&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-188&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-189&quot; class=&quot;mi&quot;&gt;c&lt;span id=&quot;MathJax-Span-190&quot; class=&quot;mn&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt; 通过 softmax 输出；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对边界框的四个值应用平方误差或者类似的方法；&lt;/li&gt;
&lt;li&gt;对 &lt;span id=&quot;MathJax-Element-19-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;P&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;c&amp;lt;/mi&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-191&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-192&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-193&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-194&quot; class=&quot;mi&quot;&gt;P&lt;span id=&quot;MathJax-Span-195&quot; class=&quot;mi&quot;&gt;c&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt; 应用 logistic regression 损失函数，或者平方预测误差。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;P&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;c&amp;lt;/mi&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;比较而言，平方误差已经能够取得比较好的效果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826120501981-1137526064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.Landmark detection&lt;/h3&gt;
&lt;p&gt;除上述的矩形检测外,还可以对目标的关键点特征进行一个检测&lt;/p&gt;
&lt;p&gt;其输出为:&lt;/p&gt;
&lt;p&gt;1.Pc &lt;/p&gt;
&lt;p&gt;2.l1_x,l1_y   (记录关键点点特征的位置)&lt;/p&gt;
&lt;p&gt;3.l2_x,l2_y&lt;/p&gt;
&lt;p&gt;..........&lt;/p&gt;
&lt;p&gt;我们通过标定训练数据集中特征点的位置信息，来对人脸进行不同位置不同特征的定位和标记。AR的应用就是基于人脸表情识别来设计的，如脸部扭曲、增加头部配饰等。&lt;/p&gt;
&lt;p&gt;在人体姿态检测中，同样可以通过对人体不同的特征位置关键点的标注，来记录人体的姿态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826121850977-2042779044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.Objection detection&lt;/h3&gt;
&lt;p&gt;目标检测的一种简单算法是滑动窗口检测&lt;/p&gt;
&lt;p&gt;首先:搜集一些目标图片和非目标图片作为训练集的样本进行训练得到一个CNN模型 如下图:&lt;/p&gt;
&lt;p&gt;注意:训练集图片尺寸较小，尽量仅包含相应目标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826135516469-492053545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后从测试图片选择合适的窗口,进行从左到右,从上到下的滑动,对每一个窗口使用已经训练好的CNN模型,观察是否有该目标.&lt;/p&gt;
&lt;p&gt;若判断有目标，则此窗口即为目标区域；若判断没有目标，则此窗口为非目标区域。&lt;/p&gt;
&lt;p&gt;优点:原理简单，且不需要人为选定目标区域（检测出目标的滑动窗即为目标区域）。&lt;/p&gt;
&lt;p&gt;缺点:滑动窗口的大小,步长过大选取都会影响到目标检测到的成功率. 由于会对每个选取的窗口进行CNN网络计算,如果步长小,则会造成计算量大,性能低下.&lt;/p&gt;
&lt;p&gt;总而言之,滑动窗口算法不够快,不够灵活&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826135915164-1294972308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.Convolutional implentation of sliding windows&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;卷积实现滑动窗口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将全连接层转为卷积层:&lt;/p&gt;
&lt;p&gt;在上一周课程中，Ng讲授过 &lt;span id=&quot;MathJax-Element-21-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x00D7;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-201&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-202&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-203&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-204&quot; class=&quot;mo&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;×1 的卷积核相当于在一个三维图像的切片上应用了一个全连接的神经网络。同样，全连接层也可以由 &lt;span id=&quot;MathJax-Element-22-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x00D7;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-206&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-207&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-208&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-209&quot; class=&quot;mo&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;×1 大小卷积核的卷积层来替代。需注意卷积核的个数与隐层神经元个数相同(即保证输出具有相同的channel)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x00D7;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x00D7;&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;最终得到的输出层维度是1 x 1 x 4，代表4类输出值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826122246818-1706934544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们以训练好的模型，输入一个16x16x3大小的整幅图片，图中蓝色部分代表滑动窗口的大小。我们以2为大小的步幅滑动窗口，分别与卷积核进行卷积运算，最后得到4幅10×10×16大小的特征图，然而因为在滑动窗口的操作时，输入部分有大量的重叠，也就是有很多重复的运算，导致在下一层中的特征图值也存在大量的重叠，所以最后得到的第二层激活值（特征图）构成一副12×12×16大小的特征图。对于后面的池化层和全连接层也是同样的过程。&lt;/p&gt;

&lt;p&gt;那么由此可知，滑动窗口在整幅图片上进行滑动卷积的操作过程，就等同于在该图片上直接进行卷积运算的过程。所以卷积层实现滑动窗口的这个过程，我们不需要把输入图片分割成四个子集分别执行前向传播，而是把他们作为一张图片输入到卷积神经网络中进行计算，其中的重叠部分（公共区域）可以共享大量的计算.&lt;/p&gt;

&lt;p&gt;值得一提的是，窗口步进长度与选择的MAX POOL大小有关。如果需要步进长度为4，只需设置MAX POOL为4 x 4即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826160045777-722849115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依据上面的方法，我们将整张图片输入到训练好的卷积神经网络中。无需再利用滑动窗口分割图片，只需一次前向传播，我们就可以同时得到所有图片子集的预测值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826160315926-471651250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5.Bounding Box Prodiction&lt;/h3&gt;
&lt;p&gt;滑动窗口算法所存在的问题,可能无法精准的输出边界框&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826160628525-78169202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为解决这个问题,我们可以采用YOLO（You Only Look Once）算法&lt;/p&gt;
&lt;p&gt;YOLO算法:将目标图片划分为N X N个区域,为了简便,接下来的都划分为 3 X3,&lt;/p&gt;
&lt;p&gt;然后对每一个小区域都采用目标检测与定位的算法,每一个小区域的输出和之前所讲的分类与定位的输出是一致的&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mrow&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826162307336-1813481801.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;其中当前区域的Pc=0时,即是检测到的目标中心不再此区域中,反之,则在此区域  &lt;span&gt;(这里不明白它是怎么判断目标中心在此区域的,如果在某个区域内检测到目标的部分,就可以判断其中心是否在此区域吗,它又如何判断它的完整边界).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; YOLO是一次卷积实现，并不是在 n×n 网格上进行&lt;span id=&quot;MathJax-Element-139-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-297&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-298&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-299&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-300&quot; class=&quot;mi&quot;&gt;n^&lt;span id=&quot;MathJax-Span-301&quot; class=&quot;mn&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;运算，而是单次卷积实现，算法实现效率高，运行速度快，可以实现实时识别。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/duboya/DeepLearning.ai-pragramming-code/master/Note_image/43.12.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bounding boxes 细节：&lt;/p&gt;
&lt;p&gt;　　利用YOLO算法实现目标探测的时候，对于存在目标对象的网格中，定义训练标签Y的时候，边界框的指定参数的不同对其预测精度有很大的影响。这里给出一个较为合理的约定：（其他定值方式可阅读论文）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于每个网格，以左上角为(0,0)，以右下角为(1,1)；&lt;/li&gt;
&lt;li&gt;中点bx、by表示坐标值，在0~1之间；&lt;/li&gt;
&lt;li&gt;宽高bh、bw表示比例值，存在&amp;gt;1的情况。 &lt;span&gt;(不理解如何判断其完整bounding boxes)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;6.Intersection-Over-Union&lt;/h3&gt;
&lt;p&gt;Intersection-Over-Union是用来评估其Bounding boxes检测是否准确的,计算公式为:&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;MathJax-Span-384&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-385&quot; class=&quot;mi&quot;&gt;I&lt;span id=&quot;MathJax-Span-386&quot; class=&quot;mi&quot;&gt;o&lt;span id=&quot;MathJax-Span-387&quot; class=&quot;mi&quot;&gt;U&lt;span id=&quot;MathJax-Span-388&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-389&quot; class=&quot;mfrac&quot;&gt;&lt;span id=&quot;MathJax-Span-390&quot; class=&quot;mi&quot;&gt;I/&lt;span id=&quot;MathJax-Span-391&quot; class=&quot;mi&quot;&gt;U&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mrow&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;span class=&quot;mfrac&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mi&quot;&gt;一般在目标检测任务中，约定如果 IoU⩾0.5 ，那么就说明检测正确。当然标准越大，则对目标检测算法越严格。得到的IoU值越大越好。:&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826163641009-1644168639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7.Non-max suppression&lt;/h3&gt;
&lt;p&gt;YOLO算法中,若是邻近的区域都被判断有同一个目标时,该如何选择,如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826170737209-1104996161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;non-max suppression(非极大值抑制):&lt;/p&gt;
&lt;p&gt;1.去掉 Pc&amp;lt;阈值的所有网格&lt;/p&gt;
&lt;p&gt;2.对于剩下的,先选取其中Pc最大的,在利用IoU,屏蔽与其交叠较大的网格,重复这个过程,直到结束&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826171742347-1941407520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;8.Anchor boxes&lt;/h3&gt;
&lt;p&gt;之前介绍的都是一个网格只存在一个object的情况,对于一个grid cell存在多个object的情况该如何处理?&lt;/p&gt;
&lt;p&gt;引入Anchor boxes&lt;/p&gt;
&lt;p&gt;只是在输出中加了个与Anchor box相对应的分量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826172323943-391132242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在进行YOLO算法时,其选取方法与上节的非极大值抑制一样,只是分别对每一个Anchor box 进行 NMS.&lt;/p&gt;
&lt;p&gt;难点问题：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果我们使用了两个Anchor box，但是同一个格子中却有三个对象的情况，此时只能用一些额外的手段来处理；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;同一个格子中存在两个对象，但它们的Anchor box 形状相同，此时也需要引入一些专门处理该情况的手段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是以上的两种问题出现的可能性不会很大，对目标检测算法不会带来很大的影响。&lt;/p&gt;

&lt;p&gt;Anchor box 的选择：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一般人工指定Anchor box 的形状，选择5~10个以覆盖到多种不同的形状，可以涵盖我们想要检测的对象的形状；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;高级方法：K-means 算法：将不同对象形状进行聚类，用聚类后的结果来选择一组最具代表性的Anchor box，以此来代表我们想要检测对象的形状。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826173714610-682833329.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;9.Putting it togerther YOLO agorithm&lt;/h3&gt;
&lt;p&gt;此节即是对之前的进行总结,内容如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826173808552-1029289536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826173844977-1717970327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;10.Region Proposal (Optional)&lt;/h3&gt;
&lt;p&gt;R-CNN：&lt;/p&gt;
&lt;p&gt;R-CNN（Regions with convolutional networks），会在我们的图片中选出一些目标的候选区域，从而避免了传统滑动窗口在大量无对象区域的无用运算。&lt;/p&gt;
&lt;p&gt;所以在使用了R-CNN后，我们不会再针对每个滑动窗口运算检测算法，而是只选择一些候选区域的窗口，在少数的窗口上运行卷积网络。&lt;/p&gt;
&lt;p&gt;具体实现：运用图像分割算法，将图片分割成许多不同颜色的色块，然后在这些色块上放置窗口，将窗口中的内容输入网络，从而减小需要处理的窗口数量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1389768/201808/1389768-20180826174149421-1091548944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Region Proposals共有三种方法：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;R-CNN: 滑动窗的形式，一次只对单个区域块进行目标检测，运算速度慢。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Fast R-CNN: 利用卷积实现滑动窗算法，类似第4节做法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Faster R-CNN: 利用卷积对图片进行分割，进一步提高运行速度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比较而言，Faster R-CNN的运行速度还是比YOLO慢一些。&lt;/p&gt;








&lt;p&gt;补充:参考自https://blog.csdn.net/red_stone1/article/details/79028058&lt;/p&gt;
&lt;p&gt;　　https://blog.csdn.net/Dby_freedom/article/details/79865515&lt;/p&gt;

</description>
<pubDate>Sun, 26 Aug 2018 09:47:00 +0000</pubDate>
<dc:creator>Dar_Alpha</dc:creator>
<og:description>1.Objection localization 图片检测问题分为: 1.图片分类:是否为汽车(结果只为单个对象) 2.分类与定位:是否为汽车 ,汽车位置(结果只为单个对象) 3.目标检测: 检测不同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Dar-/p/9538025.html</dc:identifier>
</item>
</channel>
</rss>