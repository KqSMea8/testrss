<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【JavaScript系列】浅谈JavaScript之函数(一) - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/9656942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/9656942.html</guid>
<description>&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;       在编程语言中，无论是面向过程的&lt;span lang=&quot;EN-US&quot;&gt;C,兼备面过程和对象的&lt;span lang=&quot;EN-US&quot;&gt;c++，还是面向对象的编程语言，如&lt;span lang=&quot;EN-US&quot;&gt;java,.net,php等，函数均扮演着重要的角色。当然，在面向对象编程语言&lt;span lang=&quot;EN-US&quot;&gt;JavaScript中&lt;span lang=&quot;EN-US&quot;&gt;(严格来说，&lt;span lang=&quot;EN-US&quot;&gt;JS属于弱面向对象编程语言&lt;span lang=&quot;EN-US&quot;&gt;)，函数&lt;span lang=&quot;EN-US&quot;&gt;(function)更扮演着极其重要的角色和占有极其重要的地位。在本篇文章中，不论述什么是&lt;span lang=&quot;EN-US&quot;&gt;JS，&lt;span lang=&quot;EN-US&quot;&gt;JS解决什么问题等之类问题，而是重点阐述&lt;span lang=&quot;EN-US&quot;&gt;JS中的函数&lt;span lang=&quot;EN-US&quot;&gt;(function)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一  什么是javascript函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.函数定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关于函数的定义，我们先从两个角度来思考：数学角度和编程语言角度。&lt;/p&gt;
&lt;p&gt;(1)数学角度：在数学领域，关于“函数”二字，再熟悉不过，如三角函数，反三角函数，幂函数，对数函数，指数函数，微积分函数等；&lt;/p&gt;
&lt;p&gt;(2)编程角度：在编程领域，大家最熟悉且最先接触的应该是&quot;Main函数&quot;了，除此外，如日期函数(Date)，数学函数(Math)等，当然除了内置函数外，还包括用户自定义函数；&lt;/p&gt;
&lt;p&gt;      综合1，2点，我们不难发现，函数的定义应该是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
函数是解决某类问题的集合，是某类问题的高度抽象，它具有一定的通用性和复用性。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.js中两种经典函数定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在Javascript中，存在两种经典的函数定义方式：函数声明式和函数表达式&lt;/p&gt;
&lt;p&gt;(1)函数声明式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2)函数表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，在用函数表达式定义时，一般采用匿名函数定义，即如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Question：为什么函数表达式用匿名函数，而函数声明式不用匿名？&lt;/p&gt;
&lt;p&gt;答：因为函数表达式调用时，使用的是函数表达式名，不需要函数名，因此函数名可以匿名，而函数声明式调用时，使用函数名调用，因此不用匿名函数；&lt;/p&gt;
&lt;p&gt; 声明式调用1：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; console.log(Add(10,20));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;声明式自调用:&lt;/p&gt;
&lt;p&gt;自调用只存在函数声明式中，也叫立即调用，不能在在函数表达式中调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;        console.log(num1 +&lt;span&gt; num2);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   })(10,20);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;声明式调用3:错误调用方式&lt;/p&gt;
&lt;p&gt;请大家想想，这种调用方式为什么会错？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (num1, num2) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; console.log((10,20));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 调用结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201809/1066923-20180916203650057-1041235974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;表达式调用1：推荐写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; console.log(AddFun(10,20));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 表达式调用2：不推荐写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; console.log(AddFun(10,20));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;表达式调用3:错误调用方式&lt;/p&gt;
&lt;p&gt;请大家想想，这种调用方式为什么会错？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; console.log(AddNum(10,20));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201809/1066923-20180916204052159-316593335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 3.变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在JavaScript编程语言中，变量的定义是通过var关键字来定义的(若变量不通过var定义，则为全局变量，但不推荐这么做)，与其他编程语言一样，变量也分为两大类，即局部变量和全局变量。&lt;/p&gt;
&lt;p&gt;(1)局部变量：作用域为其所在的函数；&lt;/p&gt;
&lt;p&gt;(2)全局变量：作用域为整个过程；&lt;/p&gt;
&lt;p&gt;(3)变量作用域：JS中的变量作用域是通过this指针，从当前的作用域开始，从当前作用域由内向外查找，直到找到位置，这里分为几个逻辑：&lt;/p&gt;
&lt;p&gt;a.从当前作用域由内向外查找,若找到，就停止查找，否则，继续查找，直到查到window全局作用域为止；&lt;/p&gt;
&lt;p&gt;b.当内部作用域变量名与外部作用域变量名相同时，内部作用域的覆盖外部作用域。&lt;/p&gt;
&lt;p&gt;我们来看一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; dateTime='2018-09-16'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetUserInfo(){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; age=120&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; name=&quot;Alan_beijing&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Say(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;        &lt;span&gt;var&lt;/span&gt; name=&quot;老王&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;        &lt;span&gt;var&lt;/span&gt; address=&quot;shanghai&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;        console.log(address+&quot;-&quot;+name+&quot;-&quot;+age+&quot;-&quot;+dateTime);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shanghai-老王-2018-06-05&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Say();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; GetUserInfo();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;shanghai-老王-120-2018-09-16&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来分析一下变量及其作用域：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201809/1066923-20180916222457579-164742583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，有4个作用域，当函数执行如下语句时，发生如下过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; console.log(address+&quot;-&quot;+name+&quot;-&quot;+age+&quot;-&quot;+dateTime);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a.js当前this环境作用域为4作用域；&lt;/p&gt;
&lt;p&gt;b.this指针寻找变量：addresss,name,age,dateTime，从当前作用域向外作用域逐层寻找，知道寻找到变量值为止,若寻找到最外层作用域任然没找到，则该变量返回undefined；&lt;/p&gt;
&lt;p&gt;c.当内外层变量相同时，内层变量覆盖外层变量，如4作用域的name覆盖3作用域的name;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.函数声明式定义存在的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 在js中，存在声明提前问题，看看如下例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; globleName=&quot;Alan_beijing&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Say(){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    console.log(localName);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined,不报错，是因为变量声明提前&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;    &lt;span&gt;var&lt;/span&gt; localName=&quot;Alan&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;    console.log(localName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Alan&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看过如上代码，你可能会问，函数执行到console.log(localName); 时，应该报错，因为localName未定义。&lt;/p&gt;
&lt;p&gt;如果在后端语言，如java,.net中，可能会报错，但是在js中，却不会，不报错的原因是：在js中存在声明提前。&lt;/p&gt;
&lt;p&gt;如上代码相当于如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; globleName=&quot;Alan_beijing&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Say(){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; localName;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;   console.log(localName);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;    localName=&quot;Alan&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;   console.log(localName);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 二  函数几大关键点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.匿名函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;匿名函数，顾名思义，就是没名字的的函数，我们来看看如下两个例子：&lt;/p&gt;
&lt;p&gt;函数表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个数相加函数&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; AddFun=&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (num1, num2) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; num1 +&lt;span&gt; num2;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;立即执行函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; AddNum(num1, num2) {
      console.log(num1 &lt;/span&gt;+&lt;span&gt; num2);
   })(&lt;/span&gt;10,20);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从如上，不难看出，匿名函数主要用域函数表达式和立即执行函数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.闭包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;闭包的根源在于变量的作用域问题。&lt;/p&gt;
&lt;p&gt;我们先来考虑这样一个问题，假设在面向对象编程语言中，某个方法的变量被定义为私有变量，其他函数要获取访问该变量，.net怎么处理？&lt;/p&gt;
&lt;p&gt;方法一：构造函数&lt;/p&gt;
&lt;p&gt;方法二：单例模式&lt;/p&gt;
&lt;p&gt;同样地，在js中，同样存在外部函数调用内部函数变量问题，js运用的技术就叫做闭包。&lt;/p&gt;
&lt;p&gt;所谓闭包,就是将不可访问的变量作为函数返回值的形式返回来，从而实现函数外部访问函数内部变量目的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;闭包&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetName() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; name = &quot;Alan_beijing&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; age = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; age = 30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; name +&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.js多态问题(重载问题)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在面向对象编程语言，如.net中，实现多态的方式大致有如下：&lt;/p&gt;
&lt;p&gt;a.接口&lt;/p&gt;
&lt;p&gt;b.抽象类&lt;/p&gt;
&lt;p&gt;c.虚方法&lt;/p&gt;
&lt;p&gt;d.方法重载&lt;/p&gt;
&lt;p&gt;然而，在js中，没有面向对象之说(OO)，那么js是如何实现多态的呢？根据方法实际传递的参数来决定。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重载&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SetUserInfo(userName, age, address, tel, sex) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     console.log(arguments.length);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; SetUserInfo('Alan_beijing',44,'china-shanghai','xxxx');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从如上可以看出，传递多少个参数，就接收多个参数，如果在现象对象编程语言中实现该功能，至少需要写一堆代码，这也是体现js强大之一。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.递归&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;来看看一个递归阶乘函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; factorial(num) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (num &amp;lt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; num * arguments.callee(num-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是.net，我们一般会这样写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; factorial(num) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (num &amp;lt; 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; num * factorial(num-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而，这样写，却会存在异常情况&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;var&lt;/span&gt; factorial1 =&lt;span&gt; factorial;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     factorial = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将factorial变量设置为null&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     console.log(factorial1(4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 5.原型和原型链&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;面向对象编程语言的显著特征之一是面向对象，然而，在js中，没有对象，那么js是如何面向对象的功能的呢（封装，继承，多态）？当然是通过原型和原型链来实现的。&lt;/p&gt;
&lt;p&gt;大家都比较怕原型和原型链，其实很简单，它的功能相当于面向对象的继承，主要解决继承和复用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;介于篇幅有限，余下的内容，将在下篇文章阐述.....&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 三  参考文献&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【01】JavaScript 高级程序设计(第三版)   （美）Nicholas C.Zakas 著       李松峰   曹力  译&lt;/p&gt;
&lt;p&gt;【02】JavaScript 权威指南 (第6版)    David  Flanagan 著&lt;/p&gt;

</description>
<pubDate>Sun, 16 Sep 2018 15:45:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<og:description>在编程语言中，无论是面向过程的C,兼备面过程和对象的c++，还是面向对象的编程语言，如java,.net,php等，函数均扮演着重要的角色。当然，在面向对象编程语言JavaScript中(严格来说，J</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/9656942.html</dc:identifier>
</item>
<item>
<title>浅谈Comparable与Comparator的区别 - 陈灬大灬海</title>
<link>http://www.cnblogs.com/c-h-y/p/9658261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-h-y/p/9658261.html</guid>
<description>&lt;p&gt;&lt;span&gt;平时进行自定义排序一直使用实现&lt;strong&gt;Comparable&lt;/strong&gt;接口，一段时间后操作的时候居然发现有了个&lt;strong&gt;Comparator&lt;/strong&gt;接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上网差了些资料，总结笔记一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基本原理就是比较，底层是&lt;strong&gt;二叉树&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如是3,6,5,1,7,4,9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;排序的时候先放入3,之后6比3大，烦恼如3右边，5比6小，放左边，一次类推就是线面这图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1158451/201809/1158451-20180916233537137-2024178139.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;首先看一下Comparable的接口定义&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; java.lang;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; java.util.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Comparable&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(T o);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Comparable对实现它的每个类的对象进行整体排序。这个接口需要类本身去实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实例分析&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.list.customsort;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSort {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;Person&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;fd&quot;,20&lt;span&gt;));
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;chy&quot;,22&lt;span&gt;));
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;wgj&quot;,21&lt;span&gt;));
        System.out.println(list);
        Collections.sort(list);
        System.out.println(list);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt; Comparable&amp;lt;Person&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(String name, Integer age) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;&lt;span&gt;;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compareTo(Person o) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        return this.getAge().compareTo(o.getAge());&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getName().compareTo(o.getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按姓名进行正序排序。abc&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;是根据person的name属性进行排序  结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1158451/201809/1158451-20180916221807435-1222599198.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不使用Collections.sort()方法的话，可以直接使用treeSet集合进行操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Set&amp;lt;Person&amp;gt; set = &lt;span&gt;new&lt;/span&gt; TreeSet&amp;lt;&amp;gt;&lt;span&gt;();
        set.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;fd&quot;,20&lt;span&gt;));
        set.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;chy&quot;,22&lt;span&gt;));
        set.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(&quot;wgj&quot;,21&lt;span&gt;));
        System.out.println(set);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果跟上面时一模一样的也是根据name来实现了排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么呢，查看treeset源码会发现走还是compareto方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1158451/201809/1158451-20180916222823115-1533740439.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1158451/201809/1158451-20180916223021341-666238549.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1158451/201809/1158451-20180916223041784-598493400.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以使用Collections.sort(list) 跟直接new TreeSet是一样的效果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Comparator&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Comparator是比较接口，我们如果需要控制某个类的次序，而该类本身不支持排序(即没有实现Comparable接口)，那么我们就可以建立一个“该类的比较器”来进行排序，这个“比较器”只需要实现Comparator接口即可。也就是说，我们可以通过实现Comparator来新建一个比较器，然后通过这个比较器对类进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接口定义&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; java.util;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Comparator&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(T o1, T o2);
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码实例分析&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.list.customsort;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collections;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Comparator;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Set;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.TreeSet;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestSort2 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;Person2&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person2(&quot;fd&quot;,20&lt;span&gt;));
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person2(&quot;chy&quot;,22&lt;span&gt;));
        list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person2(&quot;wgj&quot;,21&lt;span&gt;));
        System.out.println(list);
        Collections.sort(list,&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Person2&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; compare(Person2 o1, Person2 o2) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o1.getAge().compareTo(o2.getAge());
            }
        });
        System.out.println(list);
    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person2{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person2(String name, Integer age) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Person2 [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;&lt;span&gt;;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;main方法的sort方法可以使用lambda来进行简化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（public static &amp;lt;T&amp;gt; void sort(List&amp;lt;T&amp;gt; list, Comparator&amp;lt;? super T&amp;gt; c) ）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Collections.sort(list,(s1,s2)-&amp;gt; Integer.compare(s1.getAge(),s2.getAge()));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这个时候使用treeset集合的话就没效果了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为它底层使用的是compareTo方法。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Comparable和Comparator区别比较&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 16 Sep 2018 15:39:00 +0000</pubDate>
<dc:creator>陈灬大灬海</dc:creator>
<og:description>平时进行自定义排序一直使用实现Comparable接口，一段时间后操作的时候居然发现有了个Comparator接口 上网差了些资料，总结笔记一下。 基本原理就是比较，底层是二叉树 比如是3,6,5,1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-h-y/p/9658261.html</dc:identifier>
</item>
<item>
<title>AOP从静态代理到动态代理 Emit实现 - 7tiny</title>
<link>http://www.cnblogs.com/7tiny/p/9657451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/7tiny/p/9657451.html</guid>
<description>&lt;h2&gt;【前言】&lt;/h2&gt;
&lt;p&gt;　　AOP为Aspect Oriented Programming的缩写，意思是面向切面编程的技术。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;何为切面？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一个和业务没有任何耦合相关的代码段，诸如：调用日志，发送邮件，甚至路由分发。一切能为代码所有且能和代码充分解耦的代码都可以作为一个业务代码的切面。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;我们为什么要AOP？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　那我们从一个场景举例说起：&lt;/p&gt;
&lt;p&gt;　　如果想要采集用户操作行为，我们需要掌握用户调用的每一个接口的信息。这时候的我们要怎么做?&lt;/p&gt;
&lt;p&gt;　　如果不采用AOP技术，也是最简单的，所有方法体第一句话先调用一个日志接口将方法信息传递记录。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;有何问题？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　实现业务没有任何问题，但是随之而来的是代码臃肿不堪，难以调整维护的诸多问题（可自行脑补）。&lt;/p&gt;
&lt;p&gt;　　如果我们采用了AOP技术，我们就可以在系统启动的地方将所有将要采集日志的类注入，每一次调用方法前，AOP框架会自动调用我们的日志代码。&lt;/p&gt;
&lt;p&gt;　　是不是省去了很多重复无用的劳动？代码也将变得非常好维护（有朝一日不需要了，只需将切面代码注释掉即可）&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;接下来我们看看AOP框架的工作原理以及实过程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;【实现思路】&lt;/h2&gt;
&lt;p&gt;　　AOP框架呢，一般通过静态代理和动态代理两种实现方式。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916193617813-735810735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;　　何为静态代理？ &lt;/h4&gt;
&lt;p&gt;　　静态代理，又叫编译时代理，就是在编译的时候，已经存在代理类，运行时直接调用的方式。说的通俗一点，就是自己手动写代码实现代理类的方式。&lt;/p&gt;
&lt;p&gt;　　我们通过一个例子来展现一下静态代理的实现过程：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;我们这里有一个业务类，里面有方法Test()，我们要在Test调用前和调用后分别输出日志。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916194836292-73630614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们既然要将Log当作一个切面，我们肯定不能去动原有的业务代码，那样也违反了面向对象设计之开闭原则。&lt;/p&gt;
&lt;p&gt;　　那么我们要怎么做呢？我们定义一个新类 &lt;strong&gt;BusinessProxy&lt;/strong&gt; 去包装一下这个类。为了便于在多个方法的时候区分和辨认，方法也叫 &lt;strong&gt;Test（）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916200524778-1251580494.png&quot; alt=&quot;&quot; width=&quot;924&quot; height=&quot;146&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这样，我们如果要在所有的Business类中的方法都添加Log，我们就在BusinessProxy代理类中添加对应的方法去包装。既不破坏原有逻辑，又可以实现前后日志的功能。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;当然，我们可以有更优雅的实现方式：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916200828858-119861194.png&quot; alt=&quot;&quot; width=&quot;979&quot; height=&quot;144&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以定义代理类，继承自业务类。将业务类中的方法定义为虚方法。那么我们可以重写父类的方法并且在加入日志以后再调用父类的原方法。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然，我们还有更加优雅的实现方式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916203240962-1888175636.png&quot; alt=&quot;&quot; width=&quot;869&quot; height=&quot;141&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以使用发射的技术，写一个通用的Invoke方法，所有的方法都可以通过该方法调用。&lt;/p&gt;
&lt;p&gt;　　我们这样便实现了一个静态代理。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;那我们既然有了静态代理，为什么又要有动态代理呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们仔细回顾静态代理的实现过程。我们要在所有的方法中添加切面，我们就要在代理类中重写所有的业务方法。更有甚者，我们有N个业务类，就要定义N个代理类。这是很庞大的工作量。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916201847593-668123609.png&quot; alt=&quot;&quot; width=&quot;907&quot; height=&quot;408&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这就是动态代理出现的背景，相比都可以猜得到，动态代理就是将这一系列繁琐的步骤自动化，让程序自动为我们生成代理类。&lt;/p&gt;
&lt;h4&gt;　　何为动态代理？&lt;/h4&gt;
&lt;p&gt;　　动态代理，又成为运行时代理。在程序运行的过程中，调用了生成代理类的代码，将自动生成业务类的代理类。不需要我们手共编写，极高的提高了工作效率和&lt;strong&gt;&lt;span&gt;调整了程序员的心态&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　原理不必多说，就是动态生成静态代理的代码。我们要做的，就是选用一种生成代码的方式去生成。&lt;/p&gt;
&lt;p&gt;　　今天我分享一个简单的AOP框架，代码使用Emit生成。当然，Emit 代码的写法不是今天要讲的主要内容，需要提前去学习。&lt;/p&gt;
&lt;p&gt;　　先说效果：&lt;/p&gt;
&lt;p&gt;　　定义一个Action特性类 &lt;strong&gt;&lt;span&gt;ActionAttribute &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;继承自&lt;/span&gt; ActionBaseAttribute&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，里面在Before和After方法中输出两条日志；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916221625350-114694590.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;256&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　定义一个Action特性类 &lt;strong&gt;&lt;span&gt;InterceptorAttribute&lt;/span&gt;&lt;/strong&gt; 继承自 &lt;strong&gt;&lt;span&gt;InterceptorBaseAttribute&lt;/span&gt;&lt;/strong&gt;，里面捕获了方法调用异常，以及执行前后分别输出日志；&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916221743492-596476989.png&quot; alt=&quot;&quot; width=&quot;802&quot; height=&quot;414&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后定义一个业务类 &lt;strong&gt;&lt;span&gt;BusinessClass&lt;/span&gt;&lt;/strong&gt; 实现了 &lt;strong&gt;&lt;span&gt;IBusinessClass&lt;/span&gt;&lt;/strong&gt; 接口，定义了各种类型的方法&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916222454627-753994470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916222547445-1674102958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　多余的方法不贴图了。&lt;/p&gt;
&lt;p&gt;　　我们把上面定义的方法调用切面标签放在业务类上，表示该类下所有的方法都执行异常过滤；&lt;/p&gt;
&lt;p&gt;　　我们把Action特性放在Test方法上，表明要在 Test（） 方法的 Before 和 After 调用时记录日志；&lt;/p&gt;
&lt;p&gt;　　我们定义测试类：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916222926610-995776134.png&quot; alt=&quot;&quot; width=&quot;813&quot; height=&quot;495&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　调用一下试试：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916223118774-754669069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可见，全类方法标签 &lt;strong&gt;&lt;span&gt;Interceptor&lt;/span&gt;&lt;/strong&gt; 在 &lt;strong&gt;&lt;span&gt;Test&lt;/span&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;span&gt;GetInt&lt;/span&gt;&lt;/strong&gt; 方法调用前后都打出了对应的日志；&lt;/p&gt;
&lt;p&gt;　　Action方法标签只在 &lt;strong&gt;&lt;span&gt;Test&lt;/span&gt;&lt;/strong&gt; 方法上做了标记，那么&lt;strong&gt;&lt;span&gt;Test &lt;/span&gt;&lt;/strong&gt;方法 &lt;strong&gt;&lt;span&gt;Before&lt;/span&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;span&gt;After&lt;/span&gt;&lt;/strong&gt; 执行时打出了日志；&lt;/p&gt;
&lt;h2&gt;【实现过程】&lt;/h2&gt;
&lt;p&gt;　　实现的思路在上面已经有详细的讲解，可以参考静态代理的实现思路。&lt;/p&gt;
&lt;p&gt;　　我们定义一个动态代理生成类 &lt;strong&gt;&lt;span&gt;DynamicProxy&lt;/span&gt;&lt;/strong&gt;，用于原业务代码的扫描和代理类代码的生成；&lt;/p&gt;
&lt;p&gt;　　定义两个过滤器标签，&lt;strong&gt;&lt;span&gt;ActionBaseAttribute&lt;/span&gt;&lt;/strong&gt;，提供 &lt;span&gt;&lt;strong&gt;Before &lt;/strong&gt;&lt;/span&gt;和 &lt;span&gt;&lt;strong&gt;After &lt;/strong&gt;&lt;/span&gt;切面方法；&lt;strong&gt;&lt;span&gt;InterceptorBaseAttribute&lt;/span&gt;&lt;/strong&gt;，提供 &lt;span&gt;&lt;strong&gt;Invoke&lt;/strong&gt;&lt;/span&gt; “全调用”包装的切面方法；&lt;/p&gt;
&lt;p&gt;　　Before可以获取到当前调用的方法和参数列表，After可以获取到当前方法调用以后的结果。&lt;/p&gt;
&lt;p&gt;　　Invoke 可以拿到当前调用的对象和方法名，参数列表。在这里进行反射动态调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, AllowMultiple = &lt;span&gt;false&lt;/span&gt;, Inherited = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ActionBaseAttribute : Attribute
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Before(&lt;span&gt;string&lt;/span&gt; @method, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] parameters) { }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; After(&lt;span&gt;string&lt;/span&gt; @method, &lt;span&gt;object&lt;/span&gt; result) { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result; }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; [AttributeUsage(AttributeTargets.Class, AllowMultiple = &lt;span&gt;false&lt;/span&gt;, Inherited = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InterceptorBaseAttribute : Attribute
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Invoke(&lt;span&gt;object&lt;/span&gt; @object, &lt;span&gt;string&lt;/span&gt; @method, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] parameters)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; @object.GetType().GetMethod(@method).Invoke(@object, parameters);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代理生成类采用Emit的方式生成运行时IL代码。&lt;/p&gt;
&lt;p&gt;　　先把代码放在这里：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('56e97627-2ee2-4ce2-8b25-d40886a82457')&quot; readability=&quot;66&quot;&gt;&lt;img id=&quot;code_img_closed_56e97627-2ee2-4ce2-8b25-d40886a82457&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_56e97627-2ee2-4ce2-8b25-d40886a82457&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('56e97627-2ee2-4ce2-8b25-d40886a82457',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_56e97627-2ee2-4ce2-8b25-d40886a82457&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;127&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DynamicProxy
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TInterface CreateProxyOfRealize&amp;lt;TInterface, TImp&amp;gt;() &lt;span&gt;where&lt;/span&gt; TImp : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;() &lt;span&gt;where&lt;/span&gt; TInterface : &lt;span&gt;class&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Invoke&amp;lt;TInterface, TImp&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TProxyClass CreateProxyOfInherit&amp;lt;TProxyClass&amp;gt;() &lt;span&gt;where&lt;/span&gt; TProxyClass : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Invoke&amp;lt;TProxyClass, TProxyClass&amp;gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; TInterface Invoke&amp;lt;TInterface, TImp&amp;gt;(&lt;span&gt;bool&lt;/span&gt; inheritMode = &lt;span&gt;false&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; TImp : &lt;span&gt;class&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;() &lt;span&gt;where&lt;/span&gt; TInterface : &lt;span&gt;class&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; impType = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TImp);
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; nameOfAssembly = impType.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProxyAssembly&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; nameOfModule = impType.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProxyModule&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt; nameOfType = impType.Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Proxy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; assemblyName = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AssemblyName(nameOfAssembly);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; assembly =&lt;span&gt; AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.Run);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; moduleBuilder =&lt;span&gt; assembly.DefineDynamicModule(nameOfModule);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var assembly = AppDomain.CurrentDomain.DefineDynamicAssembly(assemblyName, AssemblyBuilderAccess.RunAndSave);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var moduleBuilder = assembly.DefineDynamicModule(nameOfModule, nameOfAssembly + &quot;.dll&quot;);&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;            TypeBuilder typeBuilder;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (inheritMode)
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;                 typeBuilder =&lt;span&gt; moduleBuilder.DefineType(nameOfType, TypeAttributes.Public, impType);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;                 typeBuilder = moduleBuilder.DefineType(nameOfType, TypeAttributes.Public, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TInterface) });
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt;             InjectInterceptor&amp;lt;TImp&amp;gt;(typeBuilder, impType.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;(InterceptorBaseAttribute))?&lt;span&gt;.GetType(), inheritMode);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; t =&lt;span&gt; typeBuilder.CreateType();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;assembly.Save(nameOfAssembly + &quot;.dll&quot;);&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Activator.CreateInstance(t) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TInterface;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; InjectInterceptor&amp;lt;TImp&amp;gt;(TypeBuilder typeBuilder, Type interceptorAttributeType, &lt;span&gt;bool&lt;/span&gt; inheritMode = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; impType = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TImp);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ---- define fields ----&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;             FieldBuilder fieldInterceptor = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (interceptorAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                 fieldInterceptor = typeBuilder.DefineField(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_interceptor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, interceptorAttributeType, FieldAttributes.Private);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ---- define costructors ----&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (interceptorAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; constructorBuilder = typeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ilOfCtor =&lt;span&gt; constructorBuilder.GetILGenerator();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;                ilOfCtor.Emit(OpCodes.Ldarg_0);
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                 ilOfCtor.Emit(OpCodes.Newobj, interceptorAttributeType.GetConstructor(&lt;span&gt;new&lt;/span&gt; Type[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;                ilOfCtor.Emit(OpCodes.Stfld, fieldInterceptor);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;                ilOfCtor.Emit(OpCodes.Ret);
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ---- define methods ----&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; methodsOfType = impType.GetMethods(BindingFlags.Public |&lt;span&gt; BindingFlags.Instance);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;string&lt;/span&gt;[] ignoreMethodName = &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ToString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetHashCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Equals&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; method &lt;span&gt;in&lt;/span&gt;&lt;span&gt; methodsOfType)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ignore method&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ignoreMethodName.Contains(method.Name))
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; methodParameterTypes = method.GetParameters().Select(p =&amp;gt;&lt;span&gt; p.ParameterType).ToArray();
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;                MethodAttributes methodAttributes;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (inheritMode)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                     methodAttributes = MethodAttributes.Public |&lt;span&gt; MethodAttributes.Virtual;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;                     methodAttributes = MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.NewSlot | MethodAttributes.Virtual |&lt;span&gt; MethodAttributes.Final;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; methodBuilder =&lt;span&gt; typeBuilder.DefineMethod(method.Name, methodAttributes, CallingConventions.Standard, method.ReturnType, methodParameterTypes);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ilMethod =&lt;span&gt; methodBuilder.GetILGenerator();
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set local field&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; impObj = ilMethod.DeclareLocal(impType);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;instance of imp object&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; methodName = ilMethod.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;));     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;instance of method name&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; parameters = ilMethod.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;[]));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;instance of parameters&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; result = ilMethod.DeclareLocal(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;));         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;instance of result&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;                 LocalBuilder actionAttributeObj = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;attribute init&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;                 Type actionAttributeType = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (method.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;(ActionBaseAttribute)) != &lt;span&gt;null&lt;/span&gt; || impType.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;(ActionBaseAttribute)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;method can override class attrubute&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (method.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;(ActionBaseAttribute)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                         actionAttributeType = method.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ActionBaseAttribute)).GetType();
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (impType.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;(ActionBaseAttribute)) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;                         actionAttributeType = impType.GetCustomAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ActionBaseAttribute)).GetType();
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;                     actionAttributeObj =&lt;span&gt; ilMethod.DeclareLocal(actionAttributeType);
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                     ilMethod.Emit(OpCodes.Newobj, actionAttributeType.GetConstructor(&lt;span&gt;new&lt;/span&gt; Type[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Stloc, actionAttributeObj);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;instance imp&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt;                 ilMethod.Emit(OpCodes.Newobj, impType.GetConstructor(&lt;span&gt;new&lt;/span&gt; Type[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;                ilMethod.Emit(OpCodes.Stloc, impObj);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if no attribute&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (fieldInterceptor != &lt;span&gt;null&lt;/span&gt; || actionAttributeObj != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldstr, method.Name);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Stloc, methodName);
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldc_I4, methodParameterTypes.Length);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                     ilMethod.Emit(OpCodes.Newarr, &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Stloc, parameters);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; 
&lt;span&gt;130&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; build the method parameters&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; methodParameterTypes.Length; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;                        ilMethod.Emit(OpCodes.Ldloc, parameters);
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                        ilMethod.Emit(OpCodes.Ldc_I4, j);
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                         ilMethod.Emit(OpCodes.Ldarg, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;box&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt; &lt;span&gt;                        ilMethod.Emit(OpCodes.Box, methodParameterTypes[j]);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;                        ilMethod.Emit(OpCodes.Stelem_Ref);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; 
&lt;span&gt;142&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dynamic proxy action before&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (actionAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;load arguments&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, actionAttributeObj);
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, methodName);
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, parameters);
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;                     ilMethod.Emit(OpCodes.Call, actionAttributeType.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Before&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (interceptorAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;load arguments&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;                     ilMethod.Emit(OpCodes.Ldarg_0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;
&lt;span&gt;156&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldfld, fieldInterceptor);
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, impObj);
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, methodName);
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, parameters);
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; call Invoke() method of Interceptor&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt;                     ilMethod.Emit(OpCodes.Callvirt, interceptorAttributeType.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invoke&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;direct call method&lt;/span&gt;
&lt;span&gt;166&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (method.ReturnType == &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;) &amp;amp;&amp;amp; actionAttributeType == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt; &lt;span&gt;                        ilMethod.Emit(OpCodes.Ldnull);
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; 
&lt;span&gt;171&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, impObj);
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; methodParameterTypes.Length; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;                         ilMethod.Emit(OpCodes.Ldarg, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Callvirt, impType.GetMethod(method.Name));
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;box&lt;/span&gt;
&lt;span&gt;178&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (actionAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (method.ReturnType != &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; &lt;span&gt;                            ilMethod.Emit(OpCodes.Box, method.ReturnType);
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;183&lt;/span&gt; &lt;span&gt;                            ilMethod.Emit(OpCodes.Ldnull);
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt; 
&lt;span&gt;187&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dynamic proxy action after&lt;/span&gt;
&lt;span&gt;188&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (actionAttributeType != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Stloc, result);
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;load arguments&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, actionAttributeObj);
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, methodName);
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Ldloc, result);
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;                     ilMethod.Emit(OpCodes.Call, actionAttributeType.GetMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;After&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; 
&lt;span&gt;198&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pop the stack if return void&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (method.ReturnType == &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;                    ilMethod.Emit(OpCodes.Pop);
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;204&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;unbox,if direct invoke,no box&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (fieldInterceptor != &lt;span&gt;null&lt;/span&gt; || actionAttributeObj != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (method.ReturnType.IsValueType)
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;                            ilMethod.Emit(OpCodes.Unbox_Any, method.ReturnType);
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;211&lt;/span&gt; &lt;span&gt;                            ilMethod.Emit(OpCodes.Castclass, method.ReturnType);
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; complete&lt;/span&gt;
&lt;span&gt;215&lt;/span&gt; &lt;span&gt;                ilMethod.Emit(OpCodes.Ret);
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;DynamicProxy&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　里面实现了两种代理方式，一种是 &lt;strong&gt;&lt;span&gt;面向接口实现&lt;/span&gt;&lt;/strong&gt; 的方式，另一种是 &lt;strong&gt;&lt;span&gt;继承重写&lt;/span&gt;&lt;/strong&gt; 的方式。&lt;/p&gt;
&lt;p&gt;　　但是继承重写的方式需要把业务类的所有方法写成virtual虚方法，动态类会重写该方法。&lt;/p&gt;
&lt;p&gt;　　我们从上一节的Demo中获取到运行时生成的代理类dll，用ILSpy反编译查看源代码：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916223720818-1841024126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，我们的代理类分别调用了我们特性标签中的各项方法。&lt;/p&gt;
&lt;h4&gt;　　核心代码分析（源代码在上面折叠部位已经贴出）：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916223920601-1625855177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解释：如果该方法存在Action标签，那么加载 action 标签实例化对象，加载参数，执行Before方法；如果该方法存在Interceptor标签，那么使用类字段this._interceptor调用该标签的Invoke方法。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916224137586-485542959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解释：如果面的Interceptor特性标签不存在，那么会加载当前扫描的方法对应的参数，直接调用方法；如果Action标签存在，则将刚才调用的结果包装成object对象传递到After方法中。&lt;/p&gt;
&lt;p&gt;　　这里如果目标参数是object类型，而实际参数是直接调用返回的明确的值类型，需要进行装箱操作，否则运行时报调用内存错误异常。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916224453688-1921510276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解释：如果返回值是void类型，则直接结束并返回结果；如果返回值是值类型，则需要手动拆箱操作，如果是引用类型，那么需要类型转换操作。&lt;/p&gt;
&lt;p&gt;　　IL实现的细节，这里不做重点讨论。&lt;/p&gt;
&lt;h2&gt;【系统测试】&lt;/h2&gt;
&lt;h4&gt; 　　1.接口实现方式，Api测试（各种标签使用方式对应的不同类型的方法调用）：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916224807922-881794360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论：对于上述穷举的类型，各种标签使用方式皆成功打出了日志；&lt;/p&gt;
&lt;h4&gt;　　2.继承方式，Api测试（各种标签使用方式对应的不同类型的方法调用）：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916225030627-152889864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论：继承方式和接口实现方式的效果是一样的，只是方法上需要不同的实现调整；&lt;/p&gt;
&lt;h4&gt;　　3.直接调用三个方法百万次性能结果：&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916225119697-1659768917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论：直接调用三个方法百万次调用耗时 58ms&lt;/p&gt;
&lt;h4&gt;　　4.使用实现接口方式三个方法百万次调用结果&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916225300673-759343359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论：结果见上图，需要注意是三个方法百万次调用，也就是300w次的方法调用&lt;/p&gt;
&lt;h4&gt;　　5.使用继承方式三个方法百万次调用结果&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916225341394-675024693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论：结果见上图，需要注意是三个方法百万次调用，也就是300w次的方法调用&lt;/p&gt;
&lt;p&gt;　　事实证明，IL Emit的实现方式性能还是很高的。&lt;/p&gt;
&lt;h4&gt;　　综合分析：&lt;/h4&gt;
&lt;p&gt;　　通过各种的调用分析，可以看出使用代理以后和原生方法调用相比性能损耗在哪里。性能差距最大的，也是耗时最多的实现方式就是添加了全类方法代理而且是使用Invoke进行全方法切面方式。该方式耗时的原因是使用了反射Invoke的方法。&lt;/p&gt;
&lt;p&gt;　　直接添加Action代理类实现 Before和After的方式和原生差距不大，主要损耗在After触发时的拆装箱上。&lt;/p&gt;
&lt;p&gt;　　综上分析，我们使用的时候，尽量针对性地对某一个方法进行AOP注入，而尽量不要全类方法进行AOP注入。&lt;/p&gt;
&lt;h2&gt;【总结】&lt;/h2&gt;
&lt;p&gt;　　通过自己实现一个AOP的动态注入框架，对Emit有了更加深入的了解，最重要的是，对CLR IL代码的执行过程有了一定的认知，受益匪浅。&lt;/p&gt;
&lt;p&gt;　　该方法在使用的过程中也发现了问题，比如有ref和out类型的参数时，会出现问题，需要后续继续改进&lt;/p&gt;
&lt;p&gt;　　本文的源代码已托管在GitHub上，又需要可以自行拿取（顺手Star哦~）：&lt;a href=&quot;https://github.com/sevenTiny/CodeArts&quot; target=&quot;_blank&quot;&gt;https://github.com/sevenTiny/CodeArts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　该代码的位置在 CodeArts.CSharp 分区下&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916230322670-1176024942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　VS打开后，可以在 EmitDynamicProxy 分区下找到；本博客所有的测试项目都在项目中可以找到。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201809/998608-20180916230439074-730727376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再次放上源代码地址，供一起学习的朋友参考，希望能帮助到你：&lt;a href=&quot;https://github.com/sevenTiny/CodeArts&quot; target=&quot;_blank&quot;&gt;https://github.com/sevenTiny/CodeArts&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 15:22:00 +0000</pubDate>
<dc:creator>7tiny</dc:creator>
<og:description>【前言】 AOP为Aspect Oriented Programming的缩写，意思是面向切面编程的技术。 何为切面？ 一个和业务没有任何耦合相关的代码段，诸如：调用日志，发送邮件，甚至路由分发。一切</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/7tiny/p/9657451.html</dc:identifier>
</item>
<item>
<title>前后端分离与前后端不分离的区别 - skaarl</title>
<link>http://www.cnblogs.com/skaarl/p/9658114.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skaarl/p/9658114.html</guid>
<description>
&lt;p&gt;&lt;span&gt;前后端不分离&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      在前后端不分离的应用模式中，前端页面看到的效果都是由后端控制，由后端渲染页面或重定向，也就是后端需要控制前端的展示，前端与后端的耦合度很高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        这种应用模式比较适合纯网页应用，但是当后端对接App时，App可能并不需要后端返回一个HTML网页，而仅仅是数据本身，所以后端原本返回网页的接口不再&lt;img id=&quot;uploading_image_96603&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;适用于前端App应用，为了对接App后端还需再开发一套接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请求的数据交互如下图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1394466/201809/1394466-20180916231510365-285933655.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;282&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前后端分离&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      在前后端分离的应用模式中，后端仅返回前端所需的数据，不再渲染HTML页面，不再控制前端的效果。至于前端用户看到什么效果，从后端请求的数据如何加载到前端中，都由前端自己决定，网页有网页的处理方式，App有App的处理方式，但无论哪种前端，所需的数据基本相同，后端仅需开发一套逻辑对外提供数据即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在前后端分离的应用模式中 ，前端与后端的耦合度相对较低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在前后端分离的应用模式中，我们通常将后端开发的每个视图都称为一个接口，或者API，前端通过访问接口来对数据进行增删改查。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对应的数据交互如下图 :&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1394466/201809/1394466-20180916231716242-1862208927.png&quot; alt=&quot;&quot; width=&quot;514&quot; height=&quot;329&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 16 Sep 2018 15:20:00 +0000</pubDate>
<dc:creator>skaarl</dc:creator>
<og:description>前后端不分离 在前后端不分离的应用模式中，前端页面看到的效果都是由后端控制，由后端渲染页面或重定向，也就是后端需要控制前端的展示，前端与后端的耦合度很高。 这种应用模式比较适合纯网页应用，但是当后端对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skaarl/p/9658114.html</dc:identifier>
</item>
<item>
<title>NPM的正确使用方式 - Leinov</title>
<link>http://www.cnblogs.com/leinov/p/9658110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leinov/p/9658110.html</guid>
<description>&lt;h3 id=&quot;registry配置&quot;&gt;registry配置&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;npm registry原意为记录、登记、登记处的意思，这里指的也就是node包存放的服务器地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;查看registry&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;-&amp;gt; npm config get registry

http://registry.npmjs.org //默认registry&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修改为淘宝镜像&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;默认情况下我们执行 npm install * 这个命令时就是从http://registry.npmjs.org 这个服务器上将node包下载到本地，但该服务器在美国，这样下载就会非常慢，所以我们把 registry改为国内淘宝镜像&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;npm config set registry http://registry.npm.taobao.org  //将registry设置为淘宝镜像
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;再次查看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;-&amp;gt; npm config get registry

http://registry.npm.taobao.org //已修改为淘宝镜像&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;注意&quot;&gt;注意&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果自己本地已经设置为淘宝镜像，在publish本地node包时要改回原地址 不然会报401错误&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;npm config set registry http://registry.npmjs.org &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;一些命令&quot;&gt;一些命令&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1.查看当前目录下安装了哪些node包&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;npm ls&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2.登陆npm&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;-&amp;gt; npm login

Username: leinov
Password:
Email: (this IS public)
Email: (this IS public) 1425795233@qq.com
Logged in as leinov on http://registry.npmjs.org/.&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.查看当前npm用户&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;-&amp;gt; npm whoami

leinov //当前用户&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如下提示表明还未登陆npm 该命令只在登陆状态下使用，或者使用npm adduser添加新用户&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;npm ERR! code ENEEDAUTH
npm ERR! need auth this command requires you to be logged in.
npm ERR! need auth You need to authorize this machine using `npm adduser`

npm ERR! A complete log of this run can be found in:
npm ERR!     /Users/leinov/.npm/_logs/2018-09-14T08_13_10_900Z-debug.log
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.查看当前目录下安装了哪些node包&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;-&amp;gt; npm ls

xcx@1.0.0 /Users/*/node/xcx
└── axios@0.18.0 extraneous&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;5.发布本地包&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;进入本地项目目录执行下面命令&lt;br/&gt;```&lt;br/&gt;-&amp;gt; npm publish&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;util@1.0.0 //发布成功 可通过网页进入npmjs.org查看自己上传的包&lt;br/&gt;```&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 16 Sep 2018 15:19:00 +0000</pubDate>
<dc:creator>Leinov</dc:creator>
<og:description>registry配置 npm registry原意为记录、登记、登记处的意思，这里指的也就是node包存放的服务器地址。 查看registry 修改为淘宝镜像 默认情况下我们执行 npm instal</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leinov/p/9658110.html</dc:identifier>
</item>
<item>
<title>Struts2拦截器再认识 - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9658031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9658031.html</guid>
<description>&lt;h2&gt;拦截器（Interceptor）是 Struts 2 的核心组成部分。&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Struts2 很多功能都是构建在拦截器基础之上的，例如文件的上传和下载、国际化、数据类型转换和数据校验等等。&lt;/li&gt;
&lt;li&gt;Struts2 拦截器在访问某个 Action 方法之前或之后实施拦截 Struts2 拦截器是可插拔的, 拦截器是 AOP（面向切面编程） 的一种实现．&lt;/li&gt;
&lt;li&gt;拦截器栈(Interceptor Stack): 将拦截器按一定的顺序联结成一条链. 在访问被拦截的方法时,&lt;/li&gt;
&lt;li&gt;Struts2 拦截器链中的拦截器就会按其之前定义的顺序被依次调用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img title=&quot;规则&quot; src=&quot;https://img2018.cnblogs.com/blog/1160484/201809/1160484-20180916230740680-956028037.png&quot; alt=&quot;规则&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面说明了栈的调用次序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置拦截器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;FirstInterceptor&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;Interceptor.FirstInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;value&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;YEN&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;SecondInterceptor&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;Interceptor.SecondInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 　　　　　　　　//次序为 FirstInterceptor==》SecondInterceptor===》defaultStack===》SecondInterceptor====》FirstInterceptor&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;AllInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;FirstInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;SecondInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;LoginAction&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;Action.LoginAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;AllInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;success&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201809/1160484-20180916230752063-1613936713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;struts2自带的拦截器：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201809/1160484-20180916230841090-1692590162.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201809/1160484-20180916230853493-710366533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;自定义规则&lt;/h2&gt;
&lt;p&gt;struts2提供的 &lt;strong&gt;interceptor-stack&lt;/strong&gt; 不是让我们偷懒的，很多时候，我定义自己很多的拦截器，每一个拦截器在不同业务场景下是不同的，我们不能为了图方便，把所以拦截器全部配置为一个拦截器栈来使用，这回极大的加强服务器的负担，&lt;/p&gt;
&lt;p&gt;比如说：&lt;strong&gt;methodFirstceptor&lt;/strong&gt; 是一个方法拦截器，我们配置需要拦截的方法，而&lt;strong&gt;function&lt;/strong&gt; 拦截器又不需要拦截相关的方法，所以就没有必要把他们放在一起。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 拦截器栈配置属于自己的拦截器规则 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;methodFirstceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;funtion&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;fileUpload.maximumSize&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2097152&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;param name=&quot;fileUpload.allowedTypes&quot;&amp;gt;text/html,text/xml&amp;lt;/param&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;fileUpload.allowedExtensions&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;html,dtd,xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 注意：默认拦截器 也叫全局拦截器 （也就是说我们 一定要注意在配置 默认拦截器的时候 不要加过多无用的拦截器，只要那些都需要作用到每个Action上的拦截器，才能配置拦截器栈 以及默认拦截器）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 为此包下的所有action应用拦截器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;  
&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;default-interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;permissionStack&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;普通拦截器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以实现Interceptor&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyInterceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractInterceptor {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; String intercept(ActionInvocation invocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         
&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;before invocation.invoke...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以不调用&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         String result =&lt;span&gt; invocation.invoke();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt;         System.out.println(&quot;after invocation.invoke...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;success&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;方法拦截器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MethodFirstceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; MethodFilterInterceptor {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; String doIntercept(ActionInvocation aInvocation) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;进入方法拦截器&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         String str =&lt;span&gt; aInvocation.invoke();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         System.out.println(&quot;退出方法拦截器&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; getExcludeMethodsSet() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getExcludeMethodsSet();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Set&amp;lt;String&amp;gt;&lt;span&gt; getIncludeMethodsSet() {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getIncludeMethodsSet();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;struts2配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE struts PUBLIC
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置国际化资源文件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constant &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts.custom.i18n.resources&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;i18n&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constant&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constant &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts.devMode&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;constant&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt; namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;方法拦截器配置 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;methodFirstceptor&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                class&lt;/span&gt;&lt;span&gt;=&quot;interceptors.MethodFirstceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置参数 ：拦截什么方法 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;includeMethods控制能访问哪些 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;includeMethods&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;add&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;excludeMethods控制能访问哪些 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 自定义拦截器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;hello&quot;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                class&lt;/span&gt;&lt;span&gt;=&quot;interceptors.MyInterceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 拦截器栈配置属于自己的拦截器规则 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-stack &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;methodFirstceptor&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;hello&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;fileUpload.maximumSize&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2097152&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;param name=&quot;fileUpload.allowedTypes&quot;&amp;gt;text/html,text/xml&amp;lt;/param&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;fileUpload.allowedExtensions&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;html,dtd,xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-stack&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;default-interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;default-interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 执行默认的方法的时候 是不会被拦截的 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;loginAction&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;action.LoginAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         
&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 执行要拦截的方法 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;addAction&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;action.LoginAction&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;add&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;         
&lt;span&gt;57&lt;/span&gt;         
&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;testUpload&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;upload.UploadAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/upload.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;testUpload2&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;upload.MulUploadAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;input&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/uploadmul.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; 
&lt;span&gt;70&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;testDownload&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;download.DownLoadAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;stream&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;bufferSize&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2048&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;                 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;param name=&quot;contentType&quot;&amp;gt;${contentType}&amp;lt;/param&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt;                 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 调用当前action中的getContentType()方法 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;contentDisposition&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;attachment;filename=${filename}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;inputStream&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;${inputStream}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt;                 &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 调用当前action中的getInputStream()方法 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 表单重复提交问题 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt; 
&lt;span&gt;83&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;testToken&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;token.TokenAction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;mystack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;85&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 会转到标记为invalid-token的页面 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;86&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;interceptor-ref name=&quot;token&quot;&amp;gt;&amp;lt;/interceptor-ref&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;87&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 停留在当前页面，不做任何操作 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;88&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;tokenSession&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;89&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 必须调用默认的拦截器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;90&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;interceptor-ref &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;defaultStack&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;interceptor-ref&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;91&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/success.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;92&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;invalid.token&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/token-error.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;93&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;94&lt;/span&gt; 
&lt;span&gt;95&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;96&lt;/span&gt; 
&lt;span&gt;97&lt;/span&gt; 
&lt;span&gt;98&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;default&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;extends&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;struts-default&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;interceptors&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;FirstInterceptor&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;Interceptor.FirstInterceptor&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;value&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;span&gt;YEN&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;param&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;interceptor&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;interceptor&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;SecondInterceptor&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;Interceptor.SecondInterceptor&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;interceptor&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;interceptor-stack&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;AllInterceptor&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;interceptor-ref&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;FirstInterceptor&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;interceptor-ref&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;interceptor-ref&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;SecondInterceptor&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;interceptor-ref&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;interceptor-ref&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;defaultStack&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;interceptor-ref&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;interceptor-stack&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;interceptors&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;LoginAction&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;Action.LoginAction&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;interceptor-ref&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;AllInterceptor&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;interceptor-ref&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;hljs-value&quot;&gt;&quot;success&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;success.jsp&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;result&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-title&quot;&gt;action&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 15:09:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>拦截器（Interceptor）是 Struts 2 的核心组成部分。 下面说明了栈的调用次序： struts2自带的拦截器： 自定义规则 struts2提供的 interceptor-stack 不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9658031.html</dc:identifier>
</item>
<item>
<title>微信小程序 this.data与this.setData - code_xia</title>
<link>http://www.cnblogs.com/code-xia/p/9657980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/code-xia/p/9657980.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489500/201809/1489500-20180916222118220-932832386.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　小程序中我们会经常使用到this.data与this.setData。其中this.data是用来获取页面data对象的，而this.setData是用来更新界面的。那么他们之间的区别与联系你真的搞懂了吗？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;this.data可以获取页面data对象，但是它返回的对象到底是新的对象还是仅仅只是一个引用呐。这个很关键，在日常开发中很可能因为不知道或者是自己的疏忽导致bug，而且很难排查原因。带着这个疑问我们来做一下试验。由于时间比较紧，博主就不单独写demo了，项目中可能有大量其它代码干扰我们分析，还请见谅。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;this&lt;/span&gt;.data.swiperItems[currentSwiper];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;这行代码使用this.data获取了我需要的对象，并且赋值给data变量，下面分别打印data和this.data的相应对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489500/201809/1489500-20180916223538939-2066439448.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到这两个对象的内容是一致的。下面我将在data变量中添加一个test字段，然后再看这两者的打印结果。注意我并不会对this.data操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489500/201809/1489500-20180916224023607-283740585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;可以看到他们都发生了变换，所以这是浅拷贝，也就是两个变量指向了同一片存储区域，无论通过哪个变量操作这片存储区域，相应的两个变量得出的值都会变换。为了继续证明我们的猜想是正确的，下面我只操作this.data而不操作data。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1489500/201809/1489500-20180916224413905-1021498930.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　跟我们预想的一样，即使我先赋值后加字段，data得出的结果也是被修改了的。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可能有人会问，那为啥用使用this.setData后才能看到界面的变换呢？至于this.setData我们可以看成是更新界面，并且貌似this.setData里面又托管了一个this.data的副本。因为在我改变this.data后立马去执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;this&lt;/span&gt;.setData({});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　界面并不会更新，这就说明我们需要更新this.setData管理的那个数据对象才能更新界面，而界面真正加载的数据也是来自那里。想要知道具体怎么实现的，那就要去看源代码了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　总结一下就是：this.data与this.setData的关系就是this.setData里面存储的是this.data的副本，而界面是从this.setData里面托管的this.data的副本取数据的。所以我们更改this.data并不会直接更新界面，因为这个时候的this.setData里面的副本还是没有更新前的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;span&gt;推荐、推荐、推荐。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Sun, 16 Sep 2018 14:59:00 +0000</pubDate>
<dc:creator>code_xia</dc:creator>
<og:description>一、摘要 小程序中我们会经常使用到this.data与this.setData。其中this.data是用来获取页面data对象的，而this.setData是用来更新界面的。那么他们之间的区别与联系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/code-xia/p/9657980.html</dc:identifier>
</item>
<item>
<title>微信小程序-06-详解介绍.js 逻辑层文件-注册页面 - 肖朋伟</title>
<link>http://www.cnblogs.com/xpwi/p/9657793.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xpwi/p/9657793.html</guid>
<description>&lt;p&gt;上一篇介绍的是 app.js 逻辑层文件中注册程序，对应的每个分页面都会有的 js 文件中 page() 函数注册页面&lt;/p&gt;
&lt;h2 id=&quot;微信小程序-06-详解介绍.js-逻辑层文件-注册页面&quot;&gt;微信小程序-06-详解介绍.js 逻辑层文件-注册页面&lt;/h2&gt;
&lt;h3 id=&quot;页面-page&quot;&gt;页面 Page&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Page(Object)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Page(Object) 函数用来注册一个页面。接受一个 Object 类型参数，其指定的初始数据、声明周期回调、时间处理函数等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object 参数说明：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8.9839572192513&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/p/9657793.html#data&quot;&gt;data&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;页面的初始数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7818181818182&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/p/9657793.html#onloadobject-query&quot;&gt;onLoad&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;生命周期回调—监听页面加载&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7818181818182&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/p/9657793.html#onshow&quot;&gt;onShow&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;生命周期回调—监听页面显示&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7941176470588&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/p/9657793.html#onready&quot;&gt;onReady&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;生命周期回调—监听页面初次渲染完成&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7818181818182&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/p/9657793.html#onhide&quot;&gt;onHide&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;生命周期回调—监听页面隐藏&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.719298245614&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/p/9657793.html#onunload&quot;&gt;onUnload&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;生命周期回调—监听页面卸载&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/p/9657793.html#onpulldownrefresh&quot;&gt;onPullDownRefresh&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;监听用户下拉动作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.5806451612903&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/p/9657793.html#onreachbottom&quot;&gt;onReachBottom&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;页面上拉触底事件的处理函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.3703703703704&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/p/9657793.html#onshareappmessageobject&quot;&gt;onShareAppMessage&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;用户点击右上角转发&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6065573770492&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/p/9657793.html#onpagescrollobject&quot;&gt;onPageScroll&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;页面滚动触发事件的处理函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.6307692307692&quot;&gt;&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/p/9657793.html#ontabitemtapobject&quot;&gt;onTabItemTap&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;当前是 tab 页时，点击 tab 时触发&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;其他&lt;/td&gt;
&lt;td&gt;Any&lt;/td&gt;
&lt;td&gt;开发者可以添加任意的函数或数据到 &lt;code&gt;Object&lt;/code&gt; 参数中，在页面的函数中用 &lt;code&gt;this&lt;/code&gt; 可以访问&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Object 内容在页面加载时会进行一次深拷贝，需考虑数据大小对页面加载的开销&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//和 app 一样，输入 page 根据提示回车，会自动生成预制的函数
Page({

  /**
   * 页面的初始数据
   */
  data: {
    text: &quot;这里写页面数据&quot;
  },

  /**
   * 生命周期函数--监听页面加载
   */
  onLoad: function (options) {
    
  },

  /**
   * 生命周期函数--监听页面初次渲染完成
   */
  onReady: function () {
    
  },

  /**
   * 生命周期函数--监听页面显示
   */
  onShow: function () {
    
  },

  /**
   * 生命周期函数--监听页面隐藏
   */
  onHide: function () {
    
  },

  /**
   * 生命周期函数--监听页面卸载
   */
  onUnload: function () {
    
  },

  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
    
  },

  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
    
  },

  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function () {
    
  },

  /**
   * 当页面滚动的时候执行
   */
  onPageScroll: function() {

  },

  onTabItemTap(item) {
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)
  },
  /**
   * 事件处理
   */
  viewTap: function() {
    this.setData({
      text: '为更新视图设置一些数据'
    ), function() {
      // 这里是设置数据回调
    }
  },
  
  customData: {
    hi: 'MINA'
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;data&quot;&gt;data&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt; // wxml 文件
 &amp;lt;view&amp;gt;{{text}}&amp;lt;/view&amp;gt;
 &amp;lt;view&amp;gt;{{array[0].msg}}&amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//js 文件
Page({
  data: {
    text: 'int data',
    array:[{msg: '1'}, {msg: '2'}]
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生命周期回调函数&quot;&gt;生命周期回调函数&lt;/h3&gt;
&lt;table readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;query&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;打开当前页面的路径中的参数&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;h3 id=&quot;onshow&quot;&gt;onShow()&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;页面显示、切入前台时触发&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;onready&quot;&gt;onReady()&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;页面初次渲染完成触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互&lt;/li&gt;
&lt;li&gt;【注意】：对界面内容进行设置的 API 如 wx.setNavigationBarTitle，请在 onReady 之后进行。详见生命周期（本篇后面介绍）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;onhide&quot;&gt;onHide()&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;页面隐藏、切入后台时触发。如 navigationTo 或底部 tab 切换到其他压面，小程序切入后台等&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;onunload&quot;&gt;onUnload()&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;页面卸载时触发。如 redirectTo 或 navigateBack 到其他页面时&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;页面处理函数&quot;&gt;页面处理函数&lt;/h2&gt;
&lt;h3 id=&quot;onpulldownrefresh&quot;&gt;onPullDownRefresh()&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;监听用户下拉刷新事件
&lt;ul&gt;&lt;li&gt;需要在 app.json 的 window 选项中或页面配置中开启 enablePullDownRefresh&lt;/li&gt;
&lt;li&gt;可以通过 wx.startPullDownRefresh 触发下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致&lt;/li&gt;
&lt;li&gt;当处理完数据刷新后，wx.stopPullDownRefresh 可以停止当前页面的下拉刷新&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;onreachbottom&quot;&gt;onReachBottom()&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;监听用户上拉触底事件
&lt;ul&gt;&lt;li&gt;可以在 app.josn 的 window 选项中或页面配置中设置触发距离 onReachBottomDistance&lt;/li&gt;
&lt;li&gt;在触发距离内滑动期间，本事件只会被触发一次&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;onpagescrollobject&quot;&gt;onPageScroll(Object)&lt;/h3&gt;
&lt;table readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;scrollTop&lt;/td&gt;
&lt;td&gt;Number&lt;/td&gt;
&lt;td&gt;页面在垂直方向已滚动的距离（单位px）&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;h3 id=&quot;onshareappmessageobject&quot;&gt;onShareAppMessage(Object)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;监听用户点击页面内转发按钮（button 组件 open-type=&quot;share&quot;）或右上角菜单 “转发” 按钮的行为，性自定义转发内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;【注意】：只有定义了此事件处理函数，右上角菜单才会显示 “转发” 按钮&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object 参数说明：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.8543689320388&quot;&gt;&lt;tr readability=&quot;1.9&quot;&gt;&lt;td&gt;from&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;转发事件来源。&lt;br/&gt;&lt;code&gt;button&lt;/code&gt;：页面内转发按钮；&lt;br/&gt;&lt;code&gt;menu&lt;/code&gt;：右上角转发菜单&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/compatibility.html&quot; title=&quot;基础库 1.2.4 开始支持，低版本需做兼容处理。&quot;&gt;1.2.4&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.9152542372881&quot;&gt;&lt;td&gt;target&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;如果 &lt;code&gt;from&lt;/code&gt; 值是 &lt;code&gt;button&lt;/code&gt;，则 &lt;code&gt;target&lt;/code&gt; 是触发这次转发事件的 &lt;code&gt;button&lt;/code&gt;，否则为 &lt;code&gt;undefined&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/compatibility.html&quot; title=&quot;基础库 1.2.4 开始支持，低版本需做兼容处理。&quot;&gt;1.2.4&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.8876404494382&quot;&gt;&lt;td&gt;webViewUrl&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;页面中包含&lt;code&gt;&amp;lt;web-view&amp;gt;&lt;/code&gt;组件时，返回当前&lt;code&gt;&amp;lt;web-view&amp;gt;&lt;/code&gt;的url&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/compatibility.html&quot; title=&quot;基础库 1.6.4 开始支持，低版本需做兼容处理。&quot;&gt;1.6.4&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;此事件需要 return 一个 Object，用于自定义转发内容，返回内容如下：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义转发内容&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.4586092715232&quot;&gt;&lt;tr&gt;&lt;td&gt;title&lt;/td&gt;
&lt;td&gt;转发标题&lt;/td&gt;
&lt;td&gt;当前小程序名称&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;path&lt;/td&gt;
&lt;td&gt;转发路径&lt;/td&gt;
&lt;td&gt;当前页面 path ，必须是以 / 开头的完整路径&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.9189189189189&quot;&gt;&lt;td&gt;imageUrl&lt;/td&gt;
&lt;td&gt;自定义图片路径，可以是本地文件路径、代码包文件路径或者网络图片路径。支持PNG及JPG。显示图片长宽比是 5:4。&lt;/td&gt;
&lt;td&gt;使用默认截图&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/compatibility.html&quot; title=&quot;基础库 1.5.0 开始支持，低版本需做兼容处理。&quot;&gt;1.5.0&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;示例代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Page({
  onShareAppMessage: function (res) {
    if (res.from === 'button') {
      // 来自页面内转发按钮
      console.log(res.target)
    }
    return {
      title: '自定义转发标题',
      path: '/page/user?id=123'
    }
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ontabitemtapobject&quot;&gt;onTabItemTap(Object)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;基础库 1.9.0 开始支持，低版本需做兼容处理&lt;/li&gt;
&lt;li&gt;点击 tab 时触发&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Object 参数说明：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.7204968944099&quot;&gt;&lt;tr readability=&quot;1.8245614035088&quot;&gt;&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;被点击tabItem的序号，从0开始&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/compatibility.html&quot; title=&quot;基础库 1.9.0 开始支持，低版本需做兼容处理。&quot;&gt;1.9.0&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.811320754717&quot;&gt;&lt;td&gt;pagePath&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;被点击tabItem的页面路径&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/compatibility.html&quot; title=&quot;基础库 1.9.0 开始支持，低版本需做兼容处理。&quot;&gt;1.9.0&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7959183673469&quot;&gt;&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;被点击tabItem的按钮文字&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/compatibility.html&quot; title=&quot;基础库 1.9.0 开始支持，低版本需做兼容处理。&quot;&gt;1.9.0&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;示例代码&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Page({
  onTabItemTap(item) {
    console.log(item.index)
    console.log(item.pagePath)
    console.log(item.text)
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;组件事件处理函数&quot;&gt;组件事件处理函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Page 中还可以定义组件事件处理函数。在渲染层的组件中加入事件绑定，当事件被触发时，就会执行 Page 中定义的事件处理函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;示例代码：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;view bindtap=&quot;viewTap&quot;&amp;gt; click me &amp;lt;/view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Page({
  viewTap: function() {
    console.log('view tap')
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;page.route&quot;&gt;Page.route&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;基础库 1.2.0 开始支持，低版本需做兼容处理&lt;/li&gt;
&lt;li&gt;到当前页面的路径，类型为String&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;Page({
  onShow: function() {
    console.log(this.route)
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;page.prototype.setdataobject-data-function-callback&quot;&gt;Page.prototype.setData(Object data, Function callback)&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;必填&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;最低版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;0.96062992125984&quot;&gt;&lt;tr&gt;&lt;td&gt;data&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;这次要改变的数据&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.8837209302326&quot;&gt;&lt;td&gt;callback&lt;/td&gt;
&lt;td&gt;Function&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;setData引起的界面更新渲染完毕后的回调函数&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.cnblogs.com/xpwi/compatibility.html&quot; title=&quot;基础库 1.5.0 开始支持，低版本需做兼容处理。&quot;&gt;1.5.0&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!--index.wxml--&amp;gt;
&amp;lt;view&amp;gt;{{text}}&amp;lt;/view&amp;gt;
&amp;lt;button bindtap=&quot;changeText&quot;&amp;gt; Change normal data &amp;lt;/button&amp;gt;
&amp;lt;view&amp;gt;{{num}}&amp;lt;/view&amp;gt;
&amp;lt;button bindtap=&quot;changeNum&quot;&amp;gt; Change normal num &amp;lt;/button&amp;gt;
&amp;lt;view&amp;gt;{{array[0].text}}&amp;lt;/view&amp;gt;
&amp;lt;button bindtap=&quot;changeItemInArray&quot;&amp;gt; Change Array data &amp;lt;/button&amp;gt;
&amp;lt;view&amp;gt;{{object.text}}&amp;lt;/view&amp;gt;
&amp;lt;button bindtap=&quot;changeItemInObject&quot;&amp;gt; Change Object data &amp;lt;/button&amp;gt;
&amp;lt;view&amp;gt;{{newField.text}}&amp;lt;/view&amp;gt;
&amp;lt;button bindtap=&quot;addNewField&quot;&amp;gt; Add new data &amp;lt;/button&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//index.js
Page({
  data: {
    text: 'init data',
    num: 0,
    array: [{text: 'init data'}],
    object: {
      text: 'init data'
    }
  },
  changeText: function() {
    // this.data.text = 'changed data'  // bad, it can not work
    this.setData({
      text: 'changed data'
    })
  },
  changeNum: function() {
    this.data.num = 1
    this.setData({
      num: this.data.num
    })
  },
  changeItemInArray: function() {
    // you can use this way to modify a danamic data path
    this.setData({
      'array[0].text':'changed data'
    })
  },
  changeItemInObject: function(){
    this.setData({
      'object.text': 'changed data'
    });
  },
  addNewField: function() {
    this.setData({
      'newField.text': 'new data'
    })
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;生命周期&quot;&gt;生命周期&lt;/h2&gt;
&lt;h4 id=&quot;以下内容你不需要立马完全弄明白不过以后它会有帮助&quot;&gt;以下内容你不需要立马完全弄明白，不过以后它会有帮助&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;下图说明了 Page 实例的生命周期&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img-blog.csdn.net/2018091622211865?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMTQ3ODYz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;更多文章链接微信小程序&quot;&gt;更多文章链接：&lt;a href=&quot;https://blog.csdn.net/qq_40147863/article/category/8059937&quot;&gt;微信小程序&lt;/a&gt;&lt;/h3&gt;
</description>
<pubDate>Sun, 16 Sep 2018 14:26:00 +0000</pubDate>
<dc:creator>肖朋伟</dc:creator>
<og:description>上一篇介绍的是 app.js 逻辑层文件中注册程序，对应的每个分页面都会有的 js 文件中 page() 函数注册页面 微信小程序 06 详解介绍.js 逻辑层文件 注册页面 宝典官方文档： http</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xpwi/p/9657793.html</dc:identifier>
</item>
<item>
<title>Android View 的事件分发原理解析 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/9656394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/9656394.html</guid>
<description>&lt;p&gt;作为一名 Android 开发者，每天接触最多的就是 View 了。Android View 虽然不是四大组件，但其并不比四大组件的地位低。而 View 的核心知识点事件分发机制则是不少刚入门同学的拦路虎，也是面试过程中基本上都会问的。理解 View 的事件能够让你写出更好自定义 View 以及解决滑动冲突。&lt;/p&gt;
&lt;h2&gt;1、 View 事件认识&lt;/h2&gt;
&lt;h3&gt;1.1 MotionEvent 事件&lt;/h3&gt;
&lt;p&gt;当你用手指轻触屏幕，这个过程在 Android 中主要可以分为以下三个过程：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ACTION_DOWN：手指刚接触屏幕，按下去的那一瞬间产生该事件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ACTION_MOVE：手指在屏幕上移动时候产生该事件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ACTION_UP：手指从屏幕上松开的瞬间产生该事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从 ACTION_DOWN 开始到 ACTION_UP 结束我们称为一个事件序列&lt;/p&gt;
&lt;p&gt;正常情况下，无论你手指在屏幕上有多么骚的操作，最终呈现在 MotionEvent 上来讲无外乎下面两种动作。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;点击（点击后抬起，也就是单击操作）：ACTION_DOWN -&amp;gt; ACTION_UP&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;滑动（点击后再滑动一段距离，再抬起）：ACTION_DOWN -&amp;gt; ACTION_MOVE -&amp;gt; ... -&amp;gt; ACTION_MOVE -&amp;gt; ACTION_UP&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.2  理论知识&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;public boolean dispatchTouchEvent(MotionEvent ev)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　return true: &lt;/span&gt;表示消耗了当前事件，有可能是当前 View 的 &lt;code&gt;onTouchEvent &lt;/code&gt;或者是子 View 的 &lt;code&gt;dispatchTouchEvent &lt;/code&gt;消费了，事件终止，不再传递。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　return false: &lt;/span&gt;调用父 ViewGroup 或 Activity 的 &lt;code&gt;onTouchEvent&lt;/code&gt;。 （不再往下传）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　return super.dispatherTouchEvent:&lt;/span&gt; 则继续往下(子 View )传递，或者是调用当前 View 的 onTouchEvent 方法;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;用来分发事件，即事件序列的大门，如果事件传递到当前 View 的 &lt;code&gt;onTouchEvent &lt;/code&gt;或者是子 View 的 &lt;code&gt;dispatchTouchEvent&lt;/code&gt;，即该方法被调用了。 另外如果不消耗 ACTION_DOWN 事件，那么 down, move, up 事件都与该 View 无关，交由父类处理(父类的 &lt;code&gt;onTouchEvent &lt;/code&gt;方法)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;public boolean onInterceptTouchEvent(MotionEvent ev)&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　return true: &lt;/span&gt;ViewGroup 将该事件拦截，交给自己的&lt;code&gt;onTouchEvent&lt;/code&gt;处理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　return false: &lt;/span&gt;继续传递给子元素的&lt;code&gt;dispatchTouchEvent&lt;/code&gt;处理。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　return super.dispatherTouchEvent:&lt;/span&gt; 事件默认不会被拦截。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;在 &lt;code&gt;dispatchTouchEvent &lt;/code&gt;内部调用，顾名思义就是判断是否拦截某个事件。(注：&lt;span&gt;ViewGroup 才有的方法，View 因为没有子View了，所以不需要也没有该方法&lt;/span&gt;) 。而且这一个事件序列（当前和其它事件）都只能由该 ViewGroup 处理，并且不会再调用该 &lt;code&gt;onInterceptTouchEvent &lt;/code&gt;方法去询问是否拦截。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;public boolean onTouchEvent(MotionEvent ev)&lt;/span&gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　return true: &lt;/span&gt;事件消费，当前事件终止。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　return false: &lt;/span&gt;交给父 View 的 &lt;code&gt;onTouchEvent&lt;/code&gt;。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　return super.dispatherTouchEvent:&lt;/span&gt; 默认处理事件的逻辑和返回 false 时相同。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;在&lt;code&gt;dispatchTouchEvent&lt;/code&gt;内部调用 &lt;/p&gt;
&lt;p&gt;上面三个方法之间的调用关系可以用下面的代码表示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent ev) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; consume = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件是否被消费&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (onInterceptTouchEvent(ev)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用 onInterceptTouchEvent 判断是否拦截事件&lt;/span&gt;
            consume = onTouchEvent(ev);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果拦截则调用自身的onTouchEvent方法&lt;/span&gt;
        }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            consume &lt;/span&gt;= child.dispatchTouchEvent(ev);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不拦截调用子View的dispatchTouchEvent方法&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; consume;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回值表示事件是否被消费，true事件终止，false调用父View的onTouchEvent方法&lt;/span&gt;
    } 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;1.3 事件传递顺序&lt;/h3&gt;
&lt;p&gt;对于一个点击事件，Activity 会先收到事件的通知，接着再将其传给 DecorView（根 view），通过 DecorView 在将事件逐级进行传递。具体传递逻辑见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/916005/201809/916005-20180916163020660-1402814391.png&quot; alt=&quot;&quot; width=&quot;834&quot; height=&quot;980&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看出事件的传递过程都是从父 View 到子 View。但是这里有三点需要特别强调一下&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;子 View 可以&lt;span&gt;通过 requestDisallowInterceptTouchEvent 方法干预父 View 的事件分发过程&lt;/span&gt;（ ACTION_DOWN 事件除外），而这就是我们处理滑动冲突常用的关键方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于 View（注意！ViewGroup 也是 View）而言，如果设置了onTouchListener，那么 OnTouchListener 方法中的 onTouch 方法会被回调。onTouch 方法返回 true，则 onTouchEvent 方法不会被调用（onClick 事件是在 onTouchEvent 中调用）&lt;span&gt;所以三者优先级是 onTouch-&amp;gt;onTouchEvent-&amp;gt;onClick&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;View 的 onTouchEvent 方法默认都会消费掉事件（返回 true），除非它是不可点击的（clickable 和 longClickable 同时为 false），View 的longClickable 默认为 false，clickable 需要区分情况，如 Button 的 clickable 默认为 true，而TextView的 clickable 默认为 false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;2、View 事件分发源码&lt;/h2&gt;
&lt;p&gt;先从 Activity 中的 dispatchTouchEvent 方法出发：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent ev) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dispatchTouchEvent(ev);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Activity 将事件传给父 Activity 来处理，下面看父 Activity 是怎么处理的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Called to process touch screen events.  You can override this to
     * intercept all touch screen events before they are dispatched to the
     * window.  Be sure to call this implementation for touch screen events
     * that should be handled normally.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; ev The touch screen event.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; boolean Return true if this event was consumed.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent ev) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ev.getAction() ==&lt;span&gt; MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (getWindow().superDispatchTouchEvent(ev)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; onTouchEvent(ev);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中有个 onUserInteraction 方法，该方法是只要用户在 Activity 的任何一处点击或者滑动都会响应，一般不使用。接下去看getWindow().superDispatchTouchEvent(ev) 所代表的具体含义。getWindow() 返回对应的 Activity 的 window。&lt;span&gt;一个Activity 对应一个 Window 也就是 PhoneWindow, 一个 PhoneWindow 持有一个 DecorView 的实例, DecorView 本身是一个 FrameLayout。&lt;span&gt;这句话一定要牢记。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Retrieve the current {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; android.view.Window} for the activity.
     * This can be used to directly access parts of the Window API that
     * are not available through Activity/Screen.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; Window The current window, or null if the activity is not
     *         visual.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Window getWindow() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mWindow;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Window 的源码有说明 The only existing implementation of this abstract class is&lt;br/&gt;android.view.PhoneWindow，Window 的唯一实现类是 PhoneWindow。那么去看 PhoneWindow 对应的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; superDispatchTouchEvent(MotionEvent event) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mDecor.superDispatchTouchEvent(event);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PhoneWindow 又调用了 DecorView 的 superDispatchTouchEvent 方法。而这个 DecorView 就是 Window 的根 View，我们通过 setContentView 设置的 View 是它的子 View（Activity 的 setContentView，最终是调用 PhoneWindow 的 setContentView ）&lt;/p&gt;
&lt;p&gt;到这里事件已经被传递到根 View 中，而根 View 其实也是 ViewGroup。那么事件在 ViewGroup 中又是如何传递的呢？ &lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.1 ViewGroup 事件分发&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent ev) {
            ......

            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; action =&lt;span&gt; ev.getAction();
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; actionMasked = action &amp;amp;&lt;span&gt; MotionEvent.ACTION_MASK;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (actionMasked ==&lt;span&gt; MotionEvent.ACTION_DOWN) {
                cancelAndClearTouchTargets(ev);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除FLAG_DISALLOW_INTERCEPT，并且设置mFirstTouchTarget为null&lt;/span&gt;
&lt;span&gt;                resetTouchState(){
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(mFirstTouchTarget!=&lt;span&gt;null&lt;/span&gt;){mFirstTouchTarget==&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;}
                    mGroupFlags &lt;/span&gt;&amp;amp;= ~&lt;span&gt;FLAG_DISALLOW_INTERCEPT;
                    ......
                };
            }
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; intercepted;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ViewGroup是否拦截事件

            &lt;/span&gt;&lt;span&gt;&lt;strong&gt;// &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;mFirstTouchTarget是ViewGroup中处理事件(return true)的子View
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有子View处理则mFirstTouchTarget=null,ViewGroup自己处理&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; disallowIntercept = (mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;disallowIntercept) {
                    intercepted &lt;/span&gt;= onInterceptTouchEvent(ev);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;onInterceptTouchEvent&lt;/span&gt;
&lt;span&gt;                    ev.setAction(action);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    intercepted &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果子类设置requestDisallowInterceptTouchEvent（true）
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ViewGroup将无法拦截MotionEvent.ACTION_DOWN以外的事件&lt;/span&gt;
&lt;span&gt;                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                intercepted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;actionMasked != MotionEvent.ACTION_DOWN并且没有子View处理事件，则将事件拦截
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;并且不会再调用onInterceptTouchEvent询问是否拦截&lt;/span&gt;
&lt;span&gt;            }

            ......
            ......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 先看标红的代码，这句话的意思是：当 ACTION_DOWN 事件到来时，或者有子元素处理事件（ mFirstTouchTarget != null ），如果子 view 没有调用 requestDisallowInterceptTouchEvent 来阻止 ViewGroup 的拦截，那么 ViewGroup 的 onInterceptTouchEvent 就会被调用，来判断是否是要拦截。所以，当子 View 不让父 View 拦截事件的时候，即使父 View onInterceptTouchEvent 中返回true 也没用了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;另外，&lt;/span&gt;FLAG_DISALLOW_INTERCEPT 这个&lt;/code&gt;标记位是通过子 View &lt;code&gt;requestDisallowInterceptTouchEvent &lt;/code&gt;方法设置的。&lt;/span&gt; 具体可参看如下代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; requestDisallowInterceptTouchEvent(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; disallowIntercept) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (disallowIntercept == ((mGroupFlags &amp;amp; FLAG_DISALLOW_INTERCEPT) != 0&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We're already in this state, assume our ancestors are too&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (disallowIntercept) {
            mGroupFlags &lt;/span&gt;|=&lt;span&gt; FLAG_DISALLOW_INTERCEPT;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            mGroupFlags &lt;/span&gt;&amp;amp;= ~&lt;span&gt;FLAG_DISALLOW_INTERCEPT;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Pass it up to our parent&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (mParent != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 同时，如果这个 ViewGroup 有父 View 的时候，还得让父父 View 不能拦截。继续看 ViewGroup 的 dispatchTouchEvent 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent ev) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; View[] children =&lt;span&gt; mChildren;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = childrenCount - 1; i &amp;gt;= 0; i--&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; childIndex =&lt;span&gt; getAndVerifyPreorderedIndex(childrenCount, i, customOrder);
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; View child =&lt;span&gt; getAndVerifyPreorderedView(preorderedList, children, childIndex);

            ......

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) 
            {
                ev.setTargetAccessibilityFocus(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果子View没有播放动画，而且点击事件的坐标在子View的区域内，继续下面的判断&lt;/span&gt;
                &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否有子View处理了事件&lt;/span&gt;
            newTouchTarget =&lt;span&gt; getTouchTarget(child);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newTouchTarget != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果已经有子View处理了事件，即mFirstTouchTarget!=null，终止循环。&lt;/span&gt;
                newTouchTarget.pointerIdBits |=&lt;span&gt; idBitsToAssign;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dispatchTransformedTouchEvent(ev, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, child, idBitsToAssign)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点击dispatchTransformedTouchEvent代码发现其执行方法实际为
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return child.dispatchTouchEvent(event); （因为child!=null）
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所以如果有子View处理了事件，我们就进行下一步：赋值&lt;/span&gt;
&lt;span&gt;
                ......

                newTouchTarget &lt;/span&gt;=&lt;span&gt; addTouchTarget(child, idBitsToAssign);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;addTouchTarget方法里完成了对mFirstTouchTarget的赋值&lt;/span&gt;
                alreadyDispatchedToNewTouchTarget = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; TouchTarget addTouchTarget(@NonNull View child, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pointerIdBits) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; TouchTarget target =&lt;span&gt; TouchTarget.obtain(child, pointerIdBits);
        target.next &lt;/span&gt;=&lt;span&gt; mFirstTouchTarget;
        mFirstTouchTarget &lt;/span&gt;=&lt;span&gt; target;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; dispatchTransformedTouchEvent(MotionEvent event, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; cancel,
            View child, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; desiredPointerIdBits) {
            ......

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (child == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有子View处理事件，就自己处理&lt;/span&gt;
                handled = &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.dispatchTouchEvent(event);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有子View，调用子View的dispatchTouchEvent方法&lt;/span&gt;
                handled =&lt;span&gt; child.dispatchTouchEvent(event);

            ......

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handled;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面为 ViewGroup 对事件的分发，主要有 2 点&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果有子 View，则调用子 View 的 dispatchTouchEvent 方法判断是否处理了事件，如果处理了便赋值 mFirstTouchTarget，赋值成功则跳出循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ViewGroup 的事件分发最终还是调用 View 的 &lt;code&gt;dispatchTouchEvent &lt;/code&gt;方法，具体如上代码所述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.2 View 的事件分发&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatchTouchEvent(MotionEvent event) {  

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mOnTouchListener != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED &amp;amp;&amp;amp;&lt;span&gt;  
                mOnTouchListener.onTouch(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, event)) {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
        } 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; onTouchEvent(event);  
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述方法只有以下3个条件都为真，dispatchTouchEvent() 才返回 true；否则执行 onTouchEvent()。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt; mOnTouchListener != null&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt; (mViewFlags &amp;amp; ENABLED_MASK) == ENABLED&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt; mOnTouchListener.onTouch(this, event)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这也就说明如果调用了 &lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;setOnTouchListener 设置了 listener, 就会先调用 onTouch 方法。没有的话才会去调用 &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;onTouchEvent 方法。接下去，我们看 onTouchEvent 源码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onTouchEvent(MotionEvent event) {  
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; viewFlags =&lt;span&gt; mViewFlags;  

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((viewFlags &amp;amp; ENABLED_MASK) ==&lt;span&gt; DISABLED) {  
         
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (((viewFlags &amp;amp; CLICKABLE) == CLICKABLE ||&lt;span&gt;  
                (viewFlags &lt;/span&gt;&amp;amp; LONG_CLICKABLE) ==&lt;span&gt; LONG_CLICKABLE));  
    }  &lt;br/&gt;&lt;span&gt;　　// 如果进行了事件代理，就会被拦截，不会在往下面走了
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mTouchDelegate != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (mTouchDelegate.onTouchEvent(event)) {  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
        }  
    }  

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若该控件可点击，则进入switch判断中&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (((viewFlags &amp;amp; CLICKABLE) == CLICKABLE ||&lt;span&gt;  
            (viewFlags &lt;/span&gt;&amp;amp; LONG_CLICKABLE) ==&lt;span&gt; LONG_CLICKABLE)) {  

                &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (event.getAction()) { 

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a. 若当前的事件 = 抬起View（主要分析）&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_UP:  
                        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; prepressed = (mPrivateFlags &amp;amp; PREPRESSED) != 0&lt;span&gt;;  

                            ...&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 经过种种判断，此处省略

                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行performClick() -&amp;gt;&amp;gt;分析1&lt;/span&gt;
&lt;span&gt;                            performClick();  
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; b. 若当前的事件 = 按下View&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_DOWN:  
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mPendingCheckForTap == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
                            mPendingCheckForTap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckForTap();  
                        }  
                        mPrivateFlags &lt;/span&gt;|=&lt;span&gt; PREPRESSED;  
                        mHasPerformedLongPress &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());  
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; c. 若当前的事件 = 结束事件（非人为原因）&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_CANCEL:  
                        mPrivateFlags &lt;/span&gt;&amp;amp;= ~&lt;span&gt;PRESSED;  
                        refreshDrawableState();  
                        removeTapCallback();  
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; d. 若当前的事件 = 滑动View&lt;/span&gt;
                    &lt;span&gt;case&lt;/span&gt;&lt;span&gt; MotionEvent.ACTION_MOVE:  
                        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; x = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) event.getX();  
                        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; y = (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) event.getY();  
        
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; slop =&lt;span&gt; mTouchSlop;  
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((x &amp;lt; 0 - slop) || (x &amp;gt;= getWidth() + slop) ||&lt;span&gt;  
                                (y &lt;/span&gt;&amp;lt; 0 - slop) || (y &amp;gt;= getHeight() +&lt;span&gt; slop)) {  
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Outside button  &lt;/span&gt;
&lt;span&gt;                            removeTapCallback();  
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((mPrivateFlags &amp;amp; PRESSED) != 0&lt;span&gt;) {  
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove any future long press/tap checks  &lt;/span&gt;
&lt;span&gt;                                removeLongPressCallback();  
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Need to switch from pressed to not pressed  &lt;/span&gt;
                                mPrivateFlags &amp;amp;= ~&lt;span&gt;PRESSED;  
                                refreshDrawableState();  
                            }  
                        }  
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;  
                }  
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若该控件可点击，就一定返回true&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
            }  
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若该控件不可点击，就一定返回false&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
        }

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * 分析1：performClick（）
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; performClick() {  

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mOnClickListener != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {  
            playSoundEffect(SoundEffectConstants.CLICK);  
            mOnClickListener.onClick(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只要我们通过setOnClickListener（）为控件View注册1个点击事件
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么就会给mOnClickListener变量赋值（即不为空）
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 则会往下回调onClick（） &amp;amp; performClick（）返回true&lt;/span&gt;
&lt;span&gt;        }  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;  
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的代码我们可以知道，当手指抬起的时候，也就是处于 MotionEvent.ACTION_UP 时，才会去调用 performClick（）。而 performClick 中会调用 onClick  方法。&lt;/p&gt;
&lt;p&gt;也就说明了：&lt;span&gt;三者优先级是 onTouch-&amp;gt;onTouchEvent-&amp;gt;onClick&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;至此 View 的事件分发机制讲解完毕。&lt;/p&gt;

&lt;h3&gt;参考文献：&lt;/h3&gt;
&lt;p class=&quot;title-article&quot;&gt;1、&lt;a href=&quot;https://blog.csdn.net/qian520ao/article/details/77429593&quot; target=&quot;_blank&quot;&gt;Android View的事件分发机制和滑动冲突解决&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;2、&lt;a href=&quot;https://blog.csdn.net/u010302764/article/details/72636459&quot; target=&quot;_blank&quot;&gt;一文读懂Android View事件分发机制&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;3、&lt;a href=&quot;https://www.jianshu.com/p/38015afcdb58&quot; target=&quot;_blank&quot;&gt;Android事件分发机制详解：史上最全面、最易懂&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 16 Sep 2018 14:08:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>作为一名 Android 开发者，每天接触最多的就是 View 了。Android View 虽然不是四大组件，但其并不比四大组件的地位低。而 View 的核心知识点事件分发机制则是不少刚入门同学的拦</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huansky/p/9656394.html</dc:identifier>
</item>
<item>
<title>SQL快速入门 ( MySQL快速入门, MySQL参考, MySQL快速回顾 ) - 晴天_雨天</title>
<link>http://www.cnblogs.com/lihuanqing/p/9657345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lihuanqing/p/9657345.html</guid>
<description>&lt;h2 id=&quot;sql&quot;&gt;SQL&lt;/h2&gt;
&lt;p&gt;先说点废话，很久没发文了，整理了下自己当时入门 SQL 的笔记，无论用于入门，回顾，参考查询，应该都是有一定价值的，可以按照目录各取所需。SQL数据库有很多，MySQL是一种，本文基本都是SQL通用标准，有些标准很不统一的地方就用MySQL的写法了。希望本文帮你快速了解SQL的基本操作和概念。&lt;br/&gt;文章格式上有些问题，可以点击&lt;a href=&quot;https://github.com/huanqingli/life-note/blob/master/%E5%8E%9F%E5%88%9B%E6%96%87%E7%AB%A0/%E6%8A%80%E6%9C%AF%E7%B1%BB/SQL%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8.md&quot;&gt;这里&lt;/a&gt;获得更加的阅读体验&lt;/p&gt;
&lt;h3 id=&quot;目录&quot;&gt;目录&lt;/h3&gt;
&lt;h4 id=&quot;检索&quot;&gt;检索&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;检索某表中单个列：&lt;br/&gt;SELECT 列名&lt;br/&gt;FROM 表名;&lt;/li&gt;
&lt;li&gt;检索某表中多个列：&lt;br/&gt;SELECT 列名,列名,列名&lt;br/&gt;FROM 表名;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;检索某表中所有列：（尽量不用）&lt;br/&gt;SELECT *&lt;br/&gt;FROM 表名;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;只检索某表中某列里不重复的项：&lt;br/&gt;SELECT DISTINCT 列名 (如果有两列或以上，需要这些列组合起来是不重复的)&lt;br/&gt;FROM 表名;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;检索指定行数：&lt;br/&gt;SELECT 列名&lt;br/&gt;FROM 表名&lt;br/&gt;LIMIT 5 OFFSET n; （mySQL中，选第n行后的五行。 OFFSET n 可不填写默认为0，其它 SQL 数据库中有不同写法）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;过滤检索结果&quot;&gt;过滤检索结果&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;寻找指定行：（举例）&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT prod_name, prod_price  
    FROM Products  
    WHERE prod_price = 3.49;（和字符串比较加单引号，数值不用）&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;查找列名为prod_name和列名为prod_price的两列，检索其中prod_price = 3.49; 的所有行。  
= 可以替换为其它操作符，如下表

| 操作符 | 描述 |
| --- | --- |
| = | 等于 |
| &amp;lt;&amp;gt; | 不等于 |
| &amp;gt; | 大于 |
| &amp;lt; | 小于 |
| &amp;gt;= | 大于等于 |
| &amp;lt;= | 小于等于 |
| BETWEEN | 在某个范围内 |
| LIKE | 搜索某种模式 |&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;组合WHERE子句：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT prod_id, prod_price, prod_name
    FROM Products
    WHERE vend_id = 'DLL01' AND prod_price &amp;lt;= 4;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;AND 连接同时需要满足的两个条件，OR即满足一个条件即可，NOT 找到与后边条件不匹配的行。  
且not，and和or可以组合使用，用小括号声明逻辑循序。  
`WHERE vend_id IN ( 'DLL01', 'BRS01' ) `  
IN 起到作用类似于or，速度更快，逻辑更清晰。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通配符搜索：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT prod_id, prod_name
    FROM Products
    WHERE prod_name LIKE '%bean bag%';&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;％表示任意字符出现任意次数。也可以出现在中间位置。  
_ 表示一个字符。  
[charlist] 表示包含在里面的任意字符，[^charlist]不包含在里面的任意字符。
少使用通配符，搜索速度较慢。  &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数据汇总处理&quot;&gt;数据汇总处理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;算术计算：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT prod_id,
            quantity,
            item_price,
            quantity * item_price AS expanded_price
    FROM OrderItems
    WHERE order_num = 20008;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;`expanded_price`成为计算出来的新列。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;字符串拼接：&lt;br/&gt;不同数据库有差异，MySQL中：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT concat(vend_name , vend_country)
            AS vend_title
    FROM Vendors
    ORDER BY vend_name;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;concat_ws( ':' , vend_name , vend_country) 形式第一个参数为分隔符。  
其他数据库用＋或者||拼接字符串。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;日期时间处理不同数据库差异较大。&lt;/li&gt;
&lt;li&gt;内置方法：
&lt;ul&gt;&lt;li&gt;求平均值：&lt;br/&gt;SELECT AVG(prod_price) AS avg_price&lt;br/&gt;FROM Products;&lt;br/&gt;表Products中prod_price的平均值。返回给 avg_price。&lt;br/&gt;可以配合WHERE语句计算指定行的平均值。&lt;/li&gt;
&lt;li&gt;求最大值：MAX(prod_price)&lt;/li&gt;
&lt;li&gt;求最小值：MIN(prod_price)&lt;/li&gt;
&lt;li&gt;求和：SUM(prod_price)&lt;/li&gt;
&lt;li&gt;近似的小数点后几位：ROUND(column_name,decimals)&lt;/li&gt;
&lt;li&gt;当前日期： Now()&lt;/li&gt;
&lt;li&gt;求行数：&lt;br/&gt;SELECT COUNT(＊) AS num_cust&lt;br/&gt;FROM Customers;&lt;br/&gt;求表Customers有几行。返回给num_cust。&lt;br/&gt;＊可以换成指定列如：cust_email。计算所得行数不包括该列值为null的行。&lt;br/&gt;DISTINCT 列名，求不重复的列。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;组合：&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT COUNT(＊) AS num_items,
           MIN(prod_price) AS price_min,
           MAX(prod_price) AS price_max,
           AVG(prod_price) AS price_avg
    FROM Products;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;分组&quot;&gt;分组&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;创建分组：&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT vend_id
    FROM Products
    GROUP BY vend_id;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;根据 vend_id列中内容对 vend_id分组，  
第一行换成 `SELECT vend_id, COUNT(＊) AS num_prods` 即对每一个组计算行数。  
注意：多行NULL会分为一组，GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。  
可以对一个以上的列进行 GROUP BY&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;过滤分组：&lt;br/&gt;HAVING：类似于WHERE。唯一的差别是，WHERE过滤行，而HAVING过滤分组。&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT vend_id, COUNT(＊) AS num_prods
    FROM Products
    WHERE prod_price &amp;gt;= 4
    GROUP BY vend_id
    HAVING num_prods &amp;gt;= 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;过滤出有（两个价格大与4的产品）的供应商&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;给检索结果排序&quot;&gt;给检索结果排序&lt;/h4&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT Company, OrderNumber 
FROM Orders 
ORDER BY Company DESC, OrderNumber ASC  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以 ORDER BY 列名1,列名2; 先按列名1内容排序，排序结果相同的按列名2内容排序。&lt;br/&gt;列名后接 DESC 按该列内容倒序排列，ASC 正序(默认)。&lt;br/&gt;ORDER BY 命令放在查询、分组等语句的最后。&lt;/p&gt;
&lt;h4 id=&quot;表操作&quot;&gt;表操作&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;创建表:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    CREATE  TABLE  newProducts
    (
        prod_id         CHAR(10)           NOT NULL,
        vend_id         CHAR(10)           NOT NULL,
        prod_name       CHAR(254)          NOT NULL,
        prod_price      DECIMAL(8,2)       NOT NULL,
        prod_desc       VARCHAR(1000)      NULL
    );&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;NOT NULL 非空约束，不允许列中有NULL值下面介绍其他约束。  
列的设置可以加上默认值，如NOT NULL后边接 DEFAULT  CURRENT_DATE() ，默认值为当前日期。（每个数据库获取当前日期语句不同。）
后面接 PRIMARY KEY 即设置改列为主键。
后面接  AUTO_INCREMENT 即设置为自增，只有int型可以设置。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;约束：&lt;br/&gt;每个列可以有一种或几种约束。
&lt;ul&gt;&lt;li&gt;NOT NULL 非空约束.&lt;/li&gt;
&lt;li&gt;UNIQUE 唯一约束，可唯一标识数据库表中的每条记录。&lt;/li&gt;
&lt;li&gt;PRIMARY KEY 主键约束，唯一标识数据库表中的每条记录，唯一且非空。&lt;/li&gt;
&lt;li&gt;FOREIGN KEY 外键约束，一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。&lt;/li&gt;
&lt;li&gt;CHECK 检查约束，用于限制列中的值的范围。&lt;/li&gt;
&lt;li&gt;DEFAULT 默认约束，用于向列中插入默认值&lt;br/&gt;每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。&lt;br/&gt;每种约束可以创建表时设置好，也可以后期增删.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;索引：&lt;br/&gt;在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    CREATE INDEX 索引名
    ON Person (列名[，列名])  &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;复制表或表中部分列:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    CREATE  TABLE CustCopy AS
    SELECT * FROM Customers;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;创建Customers表的复制，CustCopy。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;修改表:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    ALTER TABLE Vendors
    ADD vend_phone CHAR(20);
    ALTER TABLE Vendors
    DROP COLUMN vend_phone;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;各数据库有不兼容现象，复杂表操作列可能要新建表删除旧表。  
ALTER 还可以用来添加删除约束，删除索引等。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;删除表：&lt;br/&gt;&lt;code&gt;DROP TABLE CustCopy;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重命名表：&lt;br/&gt;&lt;code&gt;RENAME Table oldTable TO newTable;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;插入数据&quot;&gt;插入数据&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;插入整行或部分行：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    INSERT INTO Customers(cust_id,
                            cust_name,
                            cust_address,
                            cust_city,
                            cust_state,
                            cust_zip,
                            cust_country,
                            cust_contact,
                            cust_email)
    VALUES('1000000007',
            'Toy Land',
            '123 Any Street',
            'New York',
            'NY',
            '11111',
            'USA',
            NULL,
            NULL);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;插入整行时，可省略 Customers 括号内的内容，即按照列的顺序，分别插入数据（不推荐）。省略 Customers 括号内的内容时，无内容的列必须用NULL占位。  
插入部分行时，把要插入的列填入 Customers 括号内，与VALUES内容一一对应，没有提到的列默认NULL或其他默认值。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;插入查询到的值:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    INSERT INTO Customers(cust_id,
                            cust_contact,
                            cust_email,
                            cust_name,
                            cust_address,
                            cust_city,
                            cust_state,
                            cust_zip,
                            cust_country)
    SELECT cust_id,
            cust_contact,
            cust_email,
            cust_name,
            cust_address,
            cust_city,
            cust_city,
            cust_state,
            cust_zip,
            cust_country
    FROM CustNew;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;把从CustNew表中查到的内容插入 Customers表中。一次插入多行的方式。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;更新和删除数据&quot;&gt;更新和删除数据:&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;更新数据：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    UPDATE Customers
    SET cust_email = 'kim@thetoystore.com'
    WHERE cust_id = '1000000005';&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;步骤为，要更新的表，要更新的列，要更新的行。一个SET可以跟多个列用逗号隔开。  
删除某个值，即设置他为NULL。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;删除数据：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    DELETE FROM Customers
    WHERE cust_id = '1000000008';&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;删除表中指定整行，删除部分列用UPDATE  
在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。如果不写WHERE会更新或删除所有行内容。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;子查询-迭代查询&quot;&gt;子查询-迭代查询&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;一种形式：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT cust_name, cust_contact
    FROM Customers
    WHERE cust_id IN (SELECT cust_id
        FROM Orders
        WHERE order_num IN (SELECT order_num
            FROM OrderItems
            WHERE prod_id = 'RGAN01'));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;先从第二个括号选择符合条件的order_num，成为第二个括号内容，再向上找到第一个括号，查到符合条件的cust_id返回给第一个括号，最后根据第一个括号内容执行主查询语句。性能问题不要嵌套太多层。  
也就是对Customers表的查询要用到Orders表查询后返回的内容，对Orders表的查询要用到OrderItems表查询后返回的内容。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;另一种形式：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT cust_name,
        cust_state,
        (SELECT COUNT(＊)
            FROM Orders
            WHERE Orders.cust_id = Customers.cust_id) AS orders
    FROM Customers&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;根据Customers 表中的cust_id，去Orders表中取得计算后的数据。  &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;同一个表迭代查询：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT cust_id, cust_name, cust_contact
    FROM Customers
    WHERE cust_name = (SELECT cust_name
                    FROM Customers
                    WHERE cust_contact = 'Jim Jones');&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;联结-关联多个表&quot;&gt;联结-关联多个表&lt;/h4&gt;
&lt;ul readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;22&quot;&gt;两个表：
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;      SELECT vend_name, prod_name, prod_price
      FROM Vendors, Products
      WHERE Vendors.vend_id = Products.vend_id;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  根据两个表共同的列vend_id把Vendors, Products关联起来。
  与&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;      SELECT vend_name, prod_name, prod_price
      FROM Vendors INNER JOIN Products
      ON Vendors.vend_id = Products.vend_id;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  结果相同。都是内联结，前一种是后一种的简写。  
  INNER 可省略。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;外联结：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;      SELECT Customers.cust_id, Orders.order_num
      FROM Customers LEFT OUTER JOIN Orders
      ON Orders.cust_id = Customers.cust_id;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  LEFT OUTER JOIN 把Customers表中没有被匹配到的 cust_id 也联结进去（会显示在结果里）。  
  RIGHT OUTER JOIN 是把Orders表中没有被匹配到的 cust_id 也联结进去（会显示在结果里）。  
  FULL OUTER JOIN 会把两张表中没有匹配到的列也显示出来(mysql 不支持，可通过 UNION 实现)
  OUTER 可省略。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;多个表：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT cust_name, cust_contact
    FROM Customers, Orders, OrderItems
    WHERE Customers.cust_id = Orders.cust_id
    AND OrderItems.order_num = Orders.order_num
    AND prod_id = 'RGAN01';&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;作用同子查询中a。同样不要关联太多，有性能问题。其中表名可以使用别名，如：  &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    SELECT cust_name, cust_contact
    FROM Customers AS C, Orders AS O, OrderItems AS OI
    WHERE C.cust_id = O.cust_id
    AND OI.order_num = O.order_num
    AND prod_id = 'RGAN01';&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;组合查询&quot;&gt;组合查询&lt;/h4&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT cust_name, cust_contact, cust_email 
FROM Customers 
WHERE cust_state IN ('IL','IN','MI') 
UNION ALL
SELECT cust_name, cust_contact, cust_email 
FROM Customers 
WHERE cust_name = 'Fun4All';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UNION ALL 链接两句查询语句，统一返回结果，包含重复结果。&lt;br/&gt;去掉ALL以后，去掉重复结果。&lt;br/&gt;此处（从同一个表中查询）可以用WHERE ， OR代替。&lt;br/&gt;常用作从不同表中查询时，只要列数相同就可以拼接到一起，列名按照第一句中查询的列名。&lt;/p&gt;
&lt;h4 id=&quot;视图&quot;&gt;视图&lt;/h4&gt;
&lt;p&gt;对已存在的表，进行筛选，数据处理，联结等操作后返回的数据，创建的虚拟表。视图是为了重用和简化常用的查询。对视图的查询同表。&lt;br/&gt;视图总是显示最近的数据。每当用户查询视图时，数据库引擎通过使用 SQL 语句来重建数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建视图:&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;    CREATE  VIEW ProductCustomers AS                
    SELECT cust_name, cust_contact, prod_id
    FROM Customers, Orders, OrderItems
    WHERE Customers.cust_id = Orders.cust_id
    AND OrderItems.order_num = Orders.order_num;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;对OrderItems， Orders和Customers三个表进行联结，联结后结果形成 ProductCustomers 视图，可以把它当一张表来查询。&lt;/code&gt;
&lt;/pre&gt;
</description>
<pubDate>Sun, 16 Sep 2018 12:56:00 +0000</pubDate>
<dc:creator>晴天_雨天</dc:creator>
<og:description>SQL 先说点废话，很久没发文了，整理了下自己当时入门 SQL 的笔记，无论用于入门，回顾，参考查询，应该都是有一定价值的，可以按照目录各取所需。SQL数据库有很多，MySQL是一种，本文基本都是SQ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lihuanqing/p/9657345.html</dc:identifier>
</item>
</channel>
</rss>