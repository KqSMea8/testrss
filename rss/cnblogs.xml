<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【11.18总结】从SAML出发在重定向中发现的XSS漏洞 - zoe宇</title>
<link>http://www.cnblogs.com/zz0eyu/p/9978447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zz0eyu/p/9978447.html</guid>
<description>&lt;p&gt;Write-up地址：&lt;a href=&quot;https://blog.fadyothman.com/how-i-discovered-xss-that-affects-over-20-uber-subdomains/&quot;&gt;How I Discovered XSS that Affects around 20 Uber Subdomains&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://twitter.com/Fady_Othman&quot;&gt;fady mohammed osman&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总算回家了，完全没想到这次要外出一个月，今天开始恢复更新。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;前几天忘记在哪里看到了这个write up的中文翻译了，当时也没看，今天打算写总结的时候刚好发现了这篇write-up，决定就是这篇了。&lt;/p&gt;
&lt;p&gt;这个在uber发现的漏洞实现上是&lt;span&gt;由logout时重定向引起的反射型XSS&lt;/span&gt;，是作者在分析uber的SAML功能时发现的，本来作者是打算做bypass SAML authentication的，但是没有成功，之后才转向分析其他可能的漏洞。&lt;/p&gt;
&lt;h2&gt;什么是SAML&lt;/h2&gt;
&lt;p&gt;在说SAML(Security Assertion Markup Language)之前，要先说一下什么是SSO(Single Sign-On)，SAML是SSO的一种解决方案。&lt;/p&gt;
&lt;p&gt;所有使用互联网的用户应该都知道登录是怎么回事，通过注册并登录一个网站应用，你就可以享受专门针对你个人的网站应用服务了。由于HTTP的无状态性，为了避免对一个网站应用的多次登录，网站应用会使用session ID(例如cookies)来标识用户，这样你只要登录一次该网站应用，在session ID有效期间就不需要再次登录了。但存在一个问题——cookies只在同一个domain下才有效。对于一个大型的网站，它可能有多个应用，而不同应用有不用的domain，这个时候使用cookies就不合适了。&lt;/p&gt;
&lt;p&gt;于是就出现了一个解决办法，网站单独建立一个身份提供者(Identity Provider)，该应用创建、维护并管理用户认证，而不同的应用作为服务提供者(Service Provider)，当用户登录一个应用时，应用会根据用户的origin将其重定向到身份提供者那里，身份提供者验证用户身份，返回一个响应，告诉服务提供者用户是否验证通过，若验证通过，用户就可以使用该应用了。提供一个典型的应用场景，打开淘宝(https://www.taobao.com/)和天猫(https://www.tmall.com/)页面，这时候两个都是未登录状态，如果你这时候登陆淘宝，再刷新天猫页面，会发现天猫页面也是登陆状态。&lt;/p&gt;
&lt;p&gt;实现SSO有多重方式，OpenID、Oauth和SAML等，这里要说的就是SAML，顾名思义，SAML是一个基于XML的开源标准数据格式，它规定了身份提供者和服务提供者之间交换认证信息等数据的数据格式，也就是说使用SAML，在应用向身份提供者请求验证用户时，两者之间是通过xml传递信息的。&lt;/p&gt;
&lt;h2&gt;漏洞发现过程&lt;/h2&gt;
&lt;p&gt; 在作者对uber的子域名进行扫描收集时，发现很多内部域名都会被重定向到&lt;a href=&quot;http://www.cnblogs.com/zz0eyu/p/uber.onelogin.com&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;uber.onelogin.com&lt;/code&gt;&lt;/a&gt;进行身份验证，onelogin是一个统一访问管理平台，提供基于SAML的SSO，而之前在使用SAML的应用中&lt;span&gt;已经存在一些身份认证绕过的漏洞&lt;/span&gt;，所以作者尝试寻找uber中是否存在这些漏洞，但是发现已经有人提交过了。&lt;/p&gt;
&lt;p&gt;根据上面对于SSO的介绍，我们知道当用户访问一个uber的内部网站(&lt;a href=&quot;https://carbon-prototype.uberinternal.com/&quot; target=&quot;_blank&quot;&gt;https://carbon-prototype.uberinternal.com:443/&lt;/a&gt;)时，会被重定向到&lt;code&gt;&lt;a href=&quot;http://www.cnblogs.com/zz0eyu/p/uber.onelogin.com&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;uber.onelogin.com&lt;/code&gt;&lt;/a&gt;，即有一个请求发向&lt;a href=&quot;http://www.cnblogs.com/zz0eyu/p/uber.onelogin.com&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;uber.onelogin.com&lt;/code&gt;&lt;/a&gt;，而登陆后&lt;a href=&quot;http://www.cnblogs.com/zz0eyu/p/uber.onelogin.com&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;uber.onelogin.com&lt;/code&gt;&lt;/a&gt;又会向内部网站返回一个响应，作者观察了发向&lt;a href=&quot;http://www.cnblogs.com/zz0eyu/p/uber.onelogin.com&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;uber.onelogin.com&lt;/code&gt;&lt;/a&gt;的请求，里面有一个使用base64编码&lt;code&gt;SAMLRequest的参数，通过解码可以获得接收响应的URL(&lt;a href=&quot;https://carbon-prototype.uberinternal.com/oidauth/saml_consume&quot; target=&quot;_blank&quot;&gt;https://carbon-prototype.uberinternal.com:443/oidauth/saml_consume&lt;/a&gt;)，这时作者再一次试图绕过身份认证，但是失败了，因此作者&lt;span&gt;对oidauth/这个目录进行扫描&lt;/span&gt;，想看一下有没有其他有趣的文件或目录&lt;/code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./dirsearch.py -u https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;carbon-prototype.uberinternal.com:443/oidauth/ -ejson&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https://carbon-prototype.uberinternal.com:443/oidauth/logout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个页面吸引了作者的注意力，&lt;span&gt;因为logout功能通常会伴随着一个重定向，而这个过程中可能存在XSS漏洞&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;打开上面的页面，会被重定向到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https://carbon-prototype.uberinternal.com/oidauth/prompt?base=&lt;span&gt;https%3A%2F%2Fcarbon-prototype.uberinternal.com%3A443%2Foidauth&lt;/span&gt;&amp;amp;return_to=%2F%3Fopenid_c%3D1542156766.5%2FSnNQg%3D%3D&amp;amp;splash_disabled=1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意里面的base参数，是一个URL，当作者把它修改为&lt;code&gt;javascript:alert(123);&lt;/code&gt;后，成功实现了反射型的XSS。&lt;/p&gt;
&lt;p&gt;最后作者通过脚本，找到所有接收SAML响应的网址，然后请求该域名下的&lt;code&gt;oidauth/prompt&lt;/code&gt;目录，看是否存在该反射型XSS漏洞&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;1. 对一个新的应用进行测试时，可以看是否存在在其他应用中已经发现的漏洞&lt;/p&gt;
&lt;p&gt;2. 为什么会想到目录扫描：在请求包的数据中发现一个oidauth/目录&lt;/p&gt;
&lt;p&gt;3. logout功能可能存在XSS漏洞，值得进一步测试&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 15:36:00 +0000</pubDate>
<dc:creator>zoe宇</dc:creator>
<og:description>Write-up地址：How I Discovered XSS that Affects around 20 Uber Subdomains 作者：fady mohammed osman 总算回家了，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zz0eyu/p/9978447.html</dc:identifier>
</item>
<item>
<title>hadoop的特性 - 会飞的猪仔</title>
<link>http://www.cnblogs.com/huifeidezhuzai/p/9980478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huifeidezhuzai/p/9980478.html</guid>
<description>&lt;p&gt;hadoop是一个能够对大量数据进行分布式处理的软件框架，并且是一种可靠，高效，可伸缩的方式进行处理的，它有一下几方面特性：&lt;/p&gt;
&lt;p&gt;1.高可靠性：采用冗余数据存贮方式，即使一个副本发生故障，其他副本也可以保证对外工作的正常进行。&lt;/p&gt;
&lt;p&gt;2.高效性：作为并行分布式计算平台，hadoop采用分布式存贮和分布式处理两大核心技术，能够高效的处理PB级别的数据&lt;/p&gt;
&lt;p&gt;3.高可扩展性：hadoop的设计目标是可以高效稳定的运行在廉价的计算机集群上，可以扩展到数以千计的计算机节点上。&lt;/p&gt;
&lt;p&gt;4.高容错性：采用冗余数据存贮方式，自动保存数据的多个副本，并且能够自动将失败的任务重新分配。&lt;/p&gt;
&lt;p&gt;5.成本低：hadoop采用廉价的计算机集群，普通的用户也可以pc机搭建环境&lt;/p&gt;
&lt;p&gt;6.运行在linux平台上，hadoop是基于java语言开发的，可以较好的运行在linux的平台上&lt;/p&gt;
&lt;p&gt;7.支持多种编程语言，如：C++等/&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 15:31:00 +0000</pubDate>
<dc:creator>会飞的猪仔</dc:creator>
<og:description>hadoop是一个能够对大量数据进行分布式处理的软件框架，并且是一种可靠，高效，可伸缩的方式进行处理的，它有一下几方面特性： 1.高可靠性：采用冗余数据存贮方式，即使一个副本发生故障，其他副本也可以保</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huifeidezhuzai/p/9980478.html</dc:identifier>
</item>
<item>
<title>ML.NET速览 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/9980303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/9980303.html</guid>
<description>&lt;p&gt;ML.NET是由微软创建，为.NET开发者准备的开源机器学习框架。它是跨平台的，可以在macOS，Linux及Windows上运行。&lt;/p&gt;

&lt;p&gt;ML.NET通过管道(pipeline)方式组合机器学习过程。整个管道分为以下四个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Load Data 加载数据&lt;/li&gt;
&lt;li&gt;Transform Data 转换数据&lt;/li&gt;
&lt;li&gt;Choose Algorithm 选择算法&lt;/li&gt;
&lt;li&gt;Train Model 训练模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;建立一个控制台项目。&lt;/p&gt;
&lt;pre class=&quot;ps&quot;&gt;
&lt;code&gt;dotnet new console -o myApp
cd myApp&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加ML.NET类库包。&lt;/p&gt;
&lt;pre class=&quot;ps&quot;&gt;
&lt;code&gt;dotnet add package Microsoft.ML&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在工程文件夹下创建一个名为iris-data.txt的文本文件，内容如下：&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;5.1,3.5,1.4,0.2,Iris-setosa
4.9,3.0,1.4,0.2,Iris-setosa
4.7,3.2,1.3,0.2,Iris-setosa
4.6,3.1,1.5,0.2,Iris-setosa
5.0,3.6,1.4,0.2,Iris-setosa
5.4,3.9,1.7,0.4,Iris-setosa
4.6,3.4,1.4,0.3,Iris-setosa
5.0,3.4,1.5,0.2,Iris-setosa
4.4,2.9,1.4,0.2,Iris-setosa
4.9,3.1,1.5,0.1,Iris-setosa
5.4,3.7,1.5,0.2,Iris-setosa
4.8,3.4,1.6,0.2,Iris-setosa
4.8,3.0,1.4,0.1,Iris-setosa
4.3,3.0,1.1,0.1,Iris-setosa
5.8,4.0,1.2,0.2,Iris-setosa
5.7,4.4,1.5,0.4,Iris-setosa
5.4,3.9,1.3,0.4,Iris-setosa
5.1,3.5,1.4,0.3,Iris-setosa
5.7,3.8,1.7,0.3,Iris-setosa
5.1,3.8,1.5,0.3,Iris-setosa
5.4,3.4,1.7,0.2,Iris-setosa
5.1,3.7,1.5,0.4,Iris-setosa
4.6,3.6,1.0,0.2,Iris-setosa
5.1,3.3,1.7,0.5,Iris-setosa
4.8,3.4,1.9,0.2,Iris-setosa
5.0,3.0,1.6,0.2,Iris-setosa
5.0,3.4,1.6,0.4,Iris-setosa
5.2,3.5,1.5,0.2,Iris-setosa
5.2,3.4,1.4,0.2,Iris-setosa
4.7,3.2,1.6,0.2,Iris-setosa
4.8,3.1,1.6,0.2,Iris-setosa
5.4,3.4,1.5,0.4,Iris-setosa
5.2,4.1,1.5,0.1,Iris-setosa
5.5,4.2,1.4,0.2,Iris-setosa
4.9,3.1,1.5,0.1,Iris-setosa
5.0,3.2,1.2,0.2,Iris-setosa
5.5,3.5,1.3,0.2,Iris-setosa
4.9,3.1,1.5,0.1,Iris-setosa
4.4,3.0,1.3,0.2,Iris-setosa
5.1,3.4,1.5,0.2,Iris-setosa
5.0,3.5,1.3,0.3,Iris-setosa
4.5,2.3,1.3,0.3,Iris-setosa
4.4,3.2,1.3,0.2,Iris-setosa
5.0,3.5,1.6,0.6,Iris-setosa
5.1,3.8,1.9,0.4,Iris-setosa
4.8,3.0,1.4,0.3,Iris-setosa
5.1,3.8,1.6,0.2,Iris-setosa
4.6,3.2,1.4,0.2,Iris-setosa
5.3,3.7,1.5,0.2,Iris-setosa
5.0,3.3,1.4,0.2,Iris-setosa
7.0,3.2,4.7,1.4,Iris-versicolor
6.4,3.2,4.5,1.5,Iris-versicolor
6.9,3.1,4.9,1.5,Iris-versicolor
5.5,2.3,4.0,1.3,Iris-versicolor
6.5,2.8,4.6,1.5,Iris-versicolor
5.7,2.8,4.5,1.3,Iris-versicolor
6.3,3.3,4.7,1.6,Iris-versicolor
4.9,2.4,3.3,1.0,Iris-versicolor
6.6,2.9,4.6,1.3,Iris-versicolor
5.2,2.7,3.9,1.4,Iris-versicolor
5.0,2.0,3.5,1.0,Iris-versicolor
5.9,3.0,4.2,1.5,Iris-versicolor
6.0,2.2,4.0,1.0,Iris-versicolor
6.1,2.9,4.7,1.4,Iris-versicolor
5.6,2.9,3.6,1.3,Iris-versicolor
6.7,3.1,4.4,1.4,Iris-versicolor
5.6,3.0,4.5,1.5,Iris-versicolor
5.8,2.7,4.1,1.0,Iris-versicolor
6.2,2.2,4.5,1.5,Iris-versicolor
5.6,2.5,3.9,1.1,Iris-versicolor
5.9,3.2,4.8,1.8,Iris-versicolor
6.1,2.8,4.0,1.3,Iris-versicolor
6.3,2.5,4.9,1.5,Iris-versicolor
6.1,2.8,4.7,1.2,Iris-versicolor
6.4,2.9,4.3,1.3,Iris-versicolor
6.6,3.0,4.4,1.4,Iris-versicolor
6.8,2.8,4.8,1.4,Iris-versicolor
6.7,3.0,5.0,1.7,Iris-versicolor
6.0,2.9,4.5,1.5,Iris-versicolor
5.7,2.6,3.5,1.0,Iris-versicolor
5.5,2.4,3.8,1.1,Iris-versicolor
5.5,2.4,3.7,1.0,Iris-versicolor
5.8,2.7,3.9,1.2,Iris-versicolor
6.0,2.7,5.1,1.6,Iris-versicolor
5.4,3.0,4.5,1.5,Iris-versicolor
6.0,3.4,4.5,1.6,Iris-versicolor
6.7,3.1,4.7,1.5,Iris-versicolor
6.3,2.3,4.4,1.3,Iris-versicolor
5.6,3.0,4.1,1.3,Iris-versicolor
5.5,2.5,4.0,1.3,Iris-versicolor
5.5,2.6,4.4,1.2,Iris-versicolor
6.1,3.0,4.6,1.4,Iris-versicolor
5.8,2.6,4.0,1.2,Iris-versicolor
5.0,2.3,3.3,1.0,Iris-versicolor
5.6,2.7,4.2,1.3,Iris-versicolor
5.7,3.0,4.2,1.2,Iris-versicolor
5.7,2.9,4.2,1.3,Iris-versicolor
6.2,2.9,4.3,1.3,Iris-versicolor
5.1,2.5,3.0,1.1,Iris-versicolor
5.7,2.8,4.1,1.3,Iris-versicolor
6.3,3.3,6.0,2.5,Iris-virginica
5.8,2.7,5.1,1.9,Iris-virginica
7.1,3.0,5.9,2.1,Iris-virginica
6.3,2.9,5.6,1.8,Iris-virginica
6.5,3.0,5.8,2.2,Iris-virginica
7.6,3.0,6.6,2.1,Iris-virginica
4.9,2.5,4.5,1.7,Iris-virginica
7.3,2.9,6.3,1.8,Iris-virginica
6.7,2.5,5.8,1.8,Iris-virginica
7.2,3.6,6.1,2.5,Iris-virginica
6.5,3.2,5.1,2.0,Iris-virginica
6.4,2.7,5.3,1.9,Iris-virginica
6.8,3.0,5.5,2.1,Iris-virginica
5.7,2.5,5.0,2.0,Iris-virginica
5.8,2.8,5.1,2.4,Iris-virginica
6.4,3.2,5.3,2.3,Iris-virginica
6.5,3.0,5.5,1.8,Iris-virginica
7.7,3.8,6.7,2.2,Iris-virginica
7.7,2.6,6.9,2.3,Iris-virginica
6.0,2.2,5.0,1.5,Iris-virginica
6.9,3.2,5.7,2.3,Iris-virginica
5.6,2.8,4.9,2.0,Iris-virginica
7.7,2.8,6.7,2.0,Iris-virginica
6.3,2.7,4.9,1.8,Iris-virginica
6.7,3.3,5.7,2.1,Iris-virginica
7.2,3.2,6.0,1.8,Iris-virginica
6.2,2.8,4.8,1.8,Iris-virginica
6.1,3.0,4.9,1.8,Iris-virginica
6.4,2.8,5.6,2.1,Iris-virginica
7.2,3.0,5.8,1.6,Iris-virginica
7.4,2.8,6.1,1.9,Iris-virginica
7.9,3.8,6.4,2.0,Iris-virginica
6.4,2.8,5.6,2.2,Iris-virginica
6.3,2.8,5.1,1.5,Iris-virginica
6.1,2.6,5.6,1.4,Iris-virginica
7.7,3.0,6.1,2.3,Iris-virginica
6.3,3.4,5.6,2.4,Iris-virginica
6.4,3.1,5.5,1.8,Iris-virginica
6.0,3.0,4.8,1.8,Iris-virginica
6.9,3.1,5.4,2.1,Iris-virginica
6.7,3.1,5.6,2.4,Iris-virginica
6.9,3.1,5.1,2.3,Iris-virginica
5.8,2.7,5.1,1.9,Iris-virginica
6.8,3.2,5.9,2.3,Iris-virginica
6.7,3.3,5.7,2.5,Iris-virginica
6.7,3.0,5.2,2.3,Iris-virginica
6.3,2.5,5.0,1.9,Iris-virginica
6.5,3.0,5.2,2.0,Iris-virginica
6.2,3.4,5.4,2.3,Iris-virginica
5.9,3.0,5.1,1.8,Iris-virginica&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;粘贴下面的代码到Program文件中。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;
using Microsoft.ML;
using Microsoft.ML.Runtime.Api;
using Microsoft.ML.Runtime.Data;

namespace myApp
{
    class Program
    {
        public class IrisData
        {
            public float SepalLength;
            public float SepalWidth;
            public float PetalLength;
            public float PetalWidth;
            public string Label;
        }

        public class IrisPrediction
        {
            [ColumnName(&quot;PredictedLabel&quot;)]
            public string PredictedLabels;
        }

        static void Main(string[] args)
        {
            var mlContext = new MLContext();

            string dataPath = &quot;iris-data.txt&quot;;
            var reader = mlContext.Data.TextReader(new TextLoader.Arguments()
            {
                Separator = &quot;,&quot;,
                HasHeader = true,
                Column = new[]
                {
                    new TextLoader.Column(&quot;SepalLength&quot;, DataKind.R4, 0),
                    new TextLoader.Column(&quot;SepalWidth&quot;, DataKind.R4, 1),
                    new TextLoader.Column(&quot;PetalLength&quot;, DataKind.R4, 2),
                    new TextLoader.Column(&quot;PetalWidth&quot;, DataKind.R4, 3),
                    new TextLoader.Column(&quot;Label&quot;, DataKind.Text, 4)
                }
            });

            IDataView trainingDataView = reader.Read(new MultiFileSource(dataPath));

            var pipeline = mlContext.Transforms.Categorical.MapValueToKey(&quot;Label&quot;)
                .Append(mlContext.Transforms.Concatenate(&quot;Features&quot;, &quot;SepalLength&quot;, &quot;SepalWidth&quot;, &quot;PetalLength&quot;, &quot;PetalWidth&quot;))
                .Append(mlContext.MulticlassClassification.Trainers.StochasticDualCoordinateAscent(label: &quot;Label&quot;, features: &quot;Features&quot;))
                .Append(mlContext.Transforms.Conversion.MapKeyToValue(&quot;PredictedLabel&quot;));

            var model = pipeline.Fit(trainingDataView);

            var prediction = model.MakePredictionFunction&amp;lt;IrisData, IrisPrediction&amp;gt;(mlContext).Predict(
                new IrisData()
                {
                    SepalLength = 3.3f,
                    SepalWidth = 1.6f,
                    PetalLength = 0.2f,
                    PetalWidth = 5.1f,
                });

            Console.WriteLine($&quot;Predicted flower type is: {prediction.PredictedLabels}&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;dotnet run&lt;/code&gt;命令运行程序后可得到预测结果。&lt;/p&gt;
&lt;pre class=&quot;console&quot;&gt;
&lt;code&gt;Predicted flower type is: Iris-virginica&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;例子中定义了两个类，IrisData与IrisPrediction。IrisData类是用于训练的数据结构，而IrisPrediction则用于预测。&lt;/p&gt;
&lt;p&gt;MLContext类用于定义ML.NET的上下文(context)，可以理解为是它的运行时环境。&lt;/p&gt;
&lt;p&gt;接着，创建一个TextReader，用于读取数据集文件，可以看到其中规定了读取的格式。这里即是机器学习管道的第一步。&lt;/p&gt;
&lt;p&gt;第二步，转换IrisData类中Label属性的类型，使之成为数值类型，因为只有数值类型的数据才能在模型训练中被使用。再将SepalLength，SepalWidth，PetalLength与PetalWidth合并为一，统合为数据集的Features。&lt;/p&gt;
&lt;p&gt;第三步，为训练选择合适的算法，并传入标签(Label)和特征(Features)。&lt;/p&gt;
&lt;p&gt;第四步，训练模型。&lt;/p&gt;
&lt;p&gt;完成模型后，就可以用它进行预测了。因为最后预测的结果是字符串类型，所以在上述第三步的操作后有必要加上转换操作，把结果从数值类型再转回字符串类型。&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 15:08:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>什么是ML.NET？ ML.NET是由微软创建，为.NET开发者准备的开源机器学习框架。它是跨平台的，可以在macOS，Linux及Windows上运行。 机器学习管道 ML.NET通过管道(pipe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/9980303.html</dc:identifier>
</item>
<item>
<title>聊聊kafka结构 - 黄青石</title>
<link>http://www.cnblogs.com/huangqingshi/p/9979909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangqingshi/p/9979909.html</guid>
<description>&lt;p&gt;　　因为kafka用到的地方比较多，日志收集、数据同步等，所以咱们来聊聊kafka。&lt;/p&gt;
&lt;p&gt;　　首先先看看kafaka的结构，producer将消息放到一个Topic然后push到broker，然后cosumer从broker中拉取对应Topic的消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236784/201811/1236784-20181118214850692-2016265703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　broker可能大家不太熟悉，这个broker就是构成kafka集群的机器，用于实现将数据持久化并且其他数据从leader broker中进行备份，一旦其中一台 broker出现问题之后将由其他broker直接升级为leader，然后代替原来的broker。&lt;/p&gt;
&lt;p&gt;　　zookeeper的作用是记录当前leader broker的id，并将其发送给producer，并且记录每个consumer的进行的offset。offset就是消息存在的位置，这块与其他消息组件不同的是其他的消息组件消费完了直接就没有了，但是kafka会将消息持久化一段时间，这个时间可以是几天时间，用于消息重新再读取。&lt;/p&gt;
&lt;p&gt;　　接下来咱们再继续看看broker的内部实现：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236784/201811/1236784-20181118215644951-1539016918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在每一个broker里边有相应的partition，这个partition就是按照Topic将消息分发到不同的partition, 然后consumer再到相应的partition获取对应的消息。如果producer发送消息到某个指定的key上，那么kafka会将这个key进行hash到指定的partition上。在kafka里边可以指定factor，这个factor的作用是备份，对partition的备份。如果指定factor=2，那么一个partion会有2个备份。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236784/201811/1236784-20181118220817225-1352077471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面说一下consumer group,  因为partion设置的数量固定，所以在consumer group中的数量一定是小于等于partition的数量，因为最多每个consumer消息一个，consumer多了就消费不过来了。&lt;/p&gt;
&lt;p&gt;　　consumer group 是拥有相同group id的机器，这些机器是单独的机器，每个机器都可以指定topic、partition进行消费。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1236784/201811/1236784-20181118221851000-1098308089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　这些就是基本的kafka结构了，当然里边还有很多非常详细的内容，这里就不单独说了。kafka的功能非常强大，分布式，可动态扩展，消息复制，高可用低延迟等特点，这就是为什么很多人喜欢使用kafka。kafka单台机器生产消费机器的话，每秒处理70-80万左右的消息。当然消息备份采用异步处理，如果消息采用同步处理的话，一秒可以处理的数据每秒也有30-40万左右。&lt;/p&gt;
&lt;p&gt;　　kafka支持消息持久化，这个持久化的时间可以进行配置，也就是消息可以被consumer多次消费。这个是其他消息队列所没有的。&lt;/p&gt;
&lt;p&gt;　　kafka支持consumer进行assign(分配）topic，也就是单独消费某一个消息，在consumer group里边只有一台机器消费此topic。也支持Pub-Sub模式，所有订阅指定Topic的consumer会收到消息。同时支持取消订阅功能。&lt;/p&gt;
&lt;p&gt;　　kafka还支持connector(连接器），可以进行数据库连接，连上数据库后可以将数据库的记录读取到，按照自增列id或者timestamp（时间戳）进行读取，然后将消息写入到需要的地方，比如写到数据分析的地方。&lt;/p&gt;
&lt;p&gt;　　kafka支持stream(流）,可以将消息写入到stream，并将消息以流的形式从一个topic写入到另一个topic中，这个功能其他队列也没有。&lt;/p&gt;
&lt;p&gt;　　kafka一般用于消息队列，日志收集，网站行为记录等，当然它也有区别，比如不能topic不能使用通配符，connector的支持的语言不是特别多。&lt;/p&gt;
&lt;p&gt;　　好了，关于kafka咱们先聊到这里，还有很多地方没有说到，有觉得那些写的不好的地方还望同学不吝赐教。&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 14:57:00 +0000</pubDate>
<dc:creator>黄青石</dc:creator>
<og:description>因为kafka用到的地方比较多，日志收集、数据同步等，所以咱们来聊聊kafka。 首先先看看kafaka的结构，producer将消息放到一个Topic然后push到broker，然后cosumer从</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangqingshi/p/9979909.html</dc:identifier>
</item>
<item>
<title>HBase之HRegionServer启动（含与HMaster交互） - letsfly</title>
<link>http://www.cnblogs.com/letsfly/p/9980232.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/letsfly/p/9980232.html</guid>
<description>&lt;p&gt;　　在我的博文《HBase——HMaster启动之一》、《HBase——HMaster启动之二》中已经详细介绍过HMaster在启动过程中调用的各种方法。下面，单就HRegionServer在启动过程中与HMaster的交互做一下深入分析。&lt;/p&gt;
&lt;div readability=&quot;32&quot;&gt;　　首先，让我们来到HRegionServer.run,由于其也是间接实现了Runnable接口。因此，在这里，就从他的run方法开始分析。对于前面的preRegistrationInitialization方法我在这里并不打算讲，因为在我的博文《HBase——HMaster启动之一》中已经详细描述过。这里，就后面的两个方法reportForDuty、handleReportForDutyResponse进行详细描述。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224220934-2029110712.png&quot; alt=&quot;&quot;/&gt;　　让我们来到reportForDuty方法中。在下图中我已经将其中的重点框选出来。其中的第一个方法是HRegionServer作为与HMaster交互的重点。我在本节将详细讲述。至于第二个方法，相信我在仔细描述第一个方法之后，大家就会感觉清晰明了。首先来到createRegionServerStatusStub方法。由于是长图，所以没有办法编辑，还请大家谅解。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224257833-531441215.png&quot; alt=&quot;&quot;/&gt;　　首先，来到masterAddressTracker.getMasterAddress方法。这个MasterAddressTracker在HRegionServer构造时创建并启动，他所监听的ZK上的路径是/hasse/master。refresh为true,这里强制去ZK上查询HMaster的信息。然后调用了rpcClient.createBlockingRpcChannel。这里的rpcClient是在preRegistrationInitialization方法中构造的。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224325738-615646794.png&quot; alt=&quot;&quot;/&gt;　　由于在rpcClient.createBlockingRpcChannel方法中仅仅返回了新构造的BlockingRpcChannelImplementation，因此，让我们来到BlockingRpcChannelImplementation的构造方法。这里，我特别标明了BlockingRpcChannel，这个类的完整名称是org.apache.hbase.thirdparty.com.google.protobuf.BlockingRpcChannel。这是由于hbase中将protobuf加入了其第三方包中。其真正类名应该是com.google.protobuf.BlockingRpcChannel。不论如何，他都是PB中的一个接口。这里的BlockingRpcChannelImplementation重写了接口中的callBlockingMethod方法，也就是说，在实际调用的时候，真正调用了rpcClient.callBlockingMethod方法。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224358081-237707658.png&quot; alt=&quot;&quot;/&gt;　　接着，我们回到HRegionServer.createRegionServerStatusStub方法中。由上面的那张长图可以看到，由rpcClient.createBlockingRpcChannel返回的对象传入了RegionServerStatusService.newBlockingStub、LockService.newBlockingStub中，构造了这两个service的本地stub。这是PB的基础用法，与HDFS中对于PB的使用方式不用。这里封装的并不是很好。接着，将这两个service赋给HRegionServer的成员变量。&lt;/div&gt;
&lt;p&gt;　　然后，我们就可以回到reportForDuty方法的第二个重点方法this.rssStub.regionServerStartup。这里的rssStub就是刚刚构建的service。其在具体方法调用的时候，正是通过BlockingRpcChannelImplementation中复写的方法来实现的。&lt;/p&gt;
&lt;p&gt;　　也就是说在实际调用rssStub.regionServerStartup，调用到了AbstractRpcClient.callBlockingMethod。关于调用的详细流程，我在博文《hbase之RPC调用流程简介》中有简单介绍，如果大家感觉不是很详细，可以私信我的163邮箱15935152719@163.com。我然后再写一篇博文来详述。这里我们假定这个请求已经发送到了服务端。且服务端的MasterRpcServices.regionServerStartup已经开始调用。&lt;/p&gt;
&lt;div readability=&quot;22&quot;&gt;　　接下来，我们到达HMaster端的MasterRpcServices.regionServerStartup。如下图所示，这里主要调用了ServerManager.regionServerStartup。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224442855-1832319677.png&quot; alt=&quot;&quot;/&gt;　　让我们继续深入ServerManager.regionServerStartup，由于其只是调用了ServerManager.checkAndRecordNewServer方法，并没有其它重点内容，我在这里就不贴图了。而是来到ServerManager.checkAndRecordNewServer。如下图所示。findServerWithSameHostnamePortWithLock主要是查看当前已注册的RegionServer中是否有同名的ServerName，如果有，则返回ServerName，如果没有，则返回null。然后调用recordNewServerWithLock方法，将其ServerName放入成员变量onlineServers中，也就是说，该RegionServer已经实现了HMaster端的注册。接着调用已注册listeners的serverAdded方法，这些listeners都实现了ServerListener。主要有三个实现ServerListener接口的类：AssignmentManager、RSProcedureDispatcher、DrainingServerTracker。其中DrainingServerTracker是在其start方法中构造的匿名类。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224510310-908328512.png&quot; alt=&quot;&quot;/&gt;　　至此，HMaster端实现与HRegionServer的第一次通信。接着，HRegionServer开始调用HRegionServe.handleReportForDutyResponse方法。如下图所示。一开始的for循环是为了将HMaster端返回的部分信息添加到当前的conf成员变量中。紧接着createMyEphemeralNode方法将当前RegionServer的节点信息写入ZK中，路径为/hbase/rs/~。然后调用ZNodeClearer.writeMyEphemeralNodeOnDisk将信息本地化。再然后调用了setupWALAndReplication、startReplicationService两个方法。由于setupWALAndReplication方法比较重要，我将在后面贴图详细介绍。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224534666-1839609176.png&quot; alt=&quot;&quot;/&gt;　　首先，我们来到setupWALAndReplication方法。在setupWALAndReplication方法中，主要做了两件事情，其一是构造WALFactory，另外一个就是调用createNewReplicationInstance。&lt;/div&gt;
&lt;p&gt;　　在构造WALFactory过程中，主要通过反射了AsyncFSWALProvider并将其封装到SyncReplicationWALProvider中，然后调用其init方法。&lt;/p&gt;
&lt;div readability=&quot;20&quot;&gt;　　在createNewReplicationInstance方法中主要通过反射方法创建了Replication，并调用了其initialize方法。并将新构建的Replication赋给了HRegionServer.replicationSourceHandler与HRegionServer.replicationSinkHandler。由于这里的Replication比较重要，我将在下面详细介绍。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224636670-892143325.png&quot; alt=&quot;&quot;/&gt;　　接下来，让我们来到Replication.initialize方法，如下图所示。方法很长，但重点只是构造了ReplicationSourceManager。而在ReplicationSourceManager的构造方法也只是将入参封装，并构建了一个线程池。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224656620-1736501353.png&quot; alt=&quot;&quot;/&gt;　　接下来，来到handleReportForDutyResponse中第二个重要也是最重要的方法startServices。这个方法很长，几乎所有的RegionServer的服务都是直接或间接通过这个方法启动的。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224729939-197592359.png&quot; alt=&quot;&quot;/&gt;　　首先，我们来看initializeThreads。&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;　　这里首先构造了MemStoreFlusher。在构造MemStoreFlusher时，值得我们注意的是，实例化了FlushHandler。接下来构实例化了CompactSplit。在构造CompactSplit的过程中，有值得我们关注的地方。下面我们跳过这张图，来到CompactSplit的构造方法。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224759019-1526385226.png&quot; alt=&quot;&quot;/&gt;　　来到CompactSplit的构造方法以及他在构造方法中主要调用的两个方法。在他的createCompactionExecutors方法中构造了一个StealJobQueue对象。这个类继承自PriorityBlockingQueue，并且内部有一个BlockingQueue类型的stealFromQueue成员变量。然后构建了两个线程池，分别以StealJobQueue、StealJobQueue.stealFromQueue为线程池的工作队列。&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;　　接下来构建了一个PressureAwareCompactionThroughputController，并调用了其setup方法。由于其实现了Configurable接口，所以在通过ReflectionUtils.newInstance实例化的时候，调用了其setConf方法。在调用其setup时，实例化并调用了一个ScheduledChore对象，该对象在其复写的chore方法中调用了PressureAwareCompactionThroughputController.tune。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224837931-983038244.png&quot; alt=&quot;&quot;/&gt;　　介绍完CompactSplit的实例化后，让我们继续回到HRegionServer.initializeThreads方法中。在方法内，接着构造了CompactionChecker、PeriodicMemStoreFlusher这两个ScheduledChore。接下来构造了Leases（看到这里，你是不是很容易想到HDFS的租约系统LeaseManager）。他扩展了Thread而不是Chore，因为当有事情要做时，睡眠时间可以被中断，而不是Chore睡眠时间是不变的。&lt;/div&gt;
&lt;p&gt;　　紧接着，分别调用MovedRegionsCleaner.create、nonceManager.createCleanupScheduledChore创建了两个ScheduledChore，在二者的chore方法中调用的方法分别是：regionServer.cleanMovedRegions、ServerNonceManager.cleanUpOldNonces。&lt;/p&gt;
&lt;p&gt;　　然后构造了RegionServerRpcQuotaManager与RegionServerSpaceQuotaManager，最后调用了registerConfigurationObservers，将相关的ConfigurationObserver注册到ConfigurationManager中。&lt;/p&gt;
&lt;p&gt;　　介绍完initializeThreads方法后，让我们回到startServices方法。&lt;/p&gt;
&lt;p&gt;　　在startServices方法中接着构建了SecureBulkLoadManager并调用了其start方法。在其start方法中在hadoop上创建了/hbase.rootdir/staging目录。&lt;/p&gt;
&lt;p&gt;　　接着构建了LogRoller，他的作用是定期运行以确定是否应该滚动WAL。同样，他继承了Thread而不是Chore，因为当有事情要做时，睡眠时间可以被中断，而不是Chore睡眠时间是不变的。&lt;/p&gt;
&lt;p&gt;　　然后方法FlushThroughputControllerFactory.create的调用构造了NoLimitThroughputController。&lt;/p&gt;
&lt;p&gt;　　接着构建了RemoteProcedureResultReporter与CompactedHFilesDischarger(继承自ScheduledChore)。&lt;/p&gt;
&lt;p&gt;　　然后呢，就像HMaster在startServiceThreads方法中一样，创建了一大堆有不同用途的线程池，由ExecutorService管理（注：这里的ExecutorService是org.apache.hadoop.hbase.executor.ExecutorService）。&lt;/p&gt;
&lt;p&gt;　　紧接着，调用了walRoller、cacheFlusher、procedureResultReporter线程的start方法。这里简单介绍一下cacheFlusher.start。其中cacheFlusher是我们在initializeThreads方法中构造的，他的类型是MemStoreFlusher，其成员变量flushHandlers在构造期间已经完成初始化。在这里完成了赋值与线程的启动。&lt;/p&gt;
&lt;p&gt;　　再然后，启动了this.leases线程。构造并启动了SplitLogWorker。&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;　　最后，分别调用了startHeapMemoryManager、initializeMemStoreChunkCreator。关于initializeMemStoreChunkCreator方法的调用，我在HMaster启动那一节已经介绍过，这里就略过了。需要注意的是在构建ChunkCreator时创建MemStoreChunkPool都注册到了startHeapMemoryManager方法创建的hMemManager，也就是交由hMemManager管理。所以，这里只是介绍startHeapMemoryManager。如下图所示，调用HeapMemoryManager.create创建了HeapMemoryManager。然后调用HeapMemoryManager.start方法创建了HeapMemoryTunerChore并将其加入到ChoreService中调用。值得注意的是，在构建HeapMemoryTunerChore时，其内部的成员变量heapMemTuner类型为DefaultHeapMemoryTuner，并且，这个类实现了Configurable接口。当然他也是通过ReflectionUtils.newInstance方法创建的。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118224953137-630217694.png&quot; alt=&quot;&quot;/&gt;　　到此为止，我们已经介绍完了上面所有贴图。下面，让我们回到HRegionServer.run方法的后半部分。在这里，已经接近结束了。我只是简单介绍一下。&lt;/div&gt;
&lt;p&gt;　　大家可能对这里的rspmHost很迷惑，这个是什么时候出现的。确实，我之前并没有介绍过，在这里补充一下。在HRegionServer.initializeZooKeeper方法的最后，构建了RegionServerProcedureManagerHost，并将其赋给了成员变量rspmHost。接着，便调用了rspmHost.loadProcedures、rspmHost.initialize。实现了他的初始调用。&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;　　来到最后的tryRegionServerReport，HRegionServer正是通过这个方法与HMaster保持心跳。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1365945/201811/1365945-20181118225009309-869013619.png&quot; alt=&quot;&quot;/&gt;　　本节到这里就结束了，大家有什么不懂的地方可以私信我的邮箱15935152719@163.com。如果感觉不错，希望留下你的赞。你的肯定是小编继续前进的动力。&lt;/div&gt;
</description>
<pubDate>Sun, 18 Nov 2018 14:56:00 +0000</pubDate>
<dc:creator>letsfly</dc:creator>
<og:description>在我的博文《HBase——HMaster启动之一》、《HBase——HMaster启动之二》中已经详细介绍过HMaster在启动过程中调用的各种方法。下面，单就HRegionServer在启动过程中与</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/letsfly/p/9980232.html</dc:identifier>
</item>
<item>
<title>NOIP2018游记 - ivanovcraft</title>
<link>http://www.cnblogs.com/ivanovcraft/p/9980165.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ivanovcraft/p/9980165.html</guid>
<description>&lt;p&gt;&lt;span&gt;$Update~On~11.18$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\large\text{出分}Day-1$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这几天在学数学，有了点反演基础，然后学了波杜教筛，找点例题？网上好像没很多题可做，找了个题，$NOI$的，听说是好题，一个黑的，刚了一天&lt;span&gt;（推了5页）&lt;/span&gt;，也算是一半是自己推的吧&lt;span&gt;（我还没有独立完成过反演题）&lt;/span&gt;，想到明天$NOIP$出分，不知道还能不能继续学下去，就在这里随便写点东西吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\large{September}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;暑假还是一如既往的颓废了（六月份还在天天做橙题，真不知道我暑假第六是哪来的，要是不退役，真的就不能再刷水题的，也是给大家一个警告吧：难题不会？看题解可以，只做水题不行）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刚开学，前五就停课了，而我处于尴尬的第六&lt;span&gt;（而且我之前还挺喜欢学高考）&lt;/span&gt;，有些人也是要停课，但是教练没有允许。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;才发现自己已经不适应学高考的生活了，随着前五都一个个停课了，我才意识到$NOIP$快到了，本身就菜的我如果不能停课，差距只会增大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来就是力求停课，一开始是见缝插针，把下午的课和晚自习停掉了&lt;span&gt;（副科高一就停了）&lt;/span&gt;，然后看到别人有的班管的松，已经基本上是全天停了，做出了最终停课的决定，就利用楼下楼上的信息不对称，跳过了批准，基本上是全天停的了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;九月份开始，考试就挺多的了，暑假完之后成绩稍有退步，一开始不以为然，只是觉得不稳定，然后有次考了个$120$，这种分原来也不是没有过，只是这次真的是$NOIP$题，教练也警告了我&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下午就不知所干，无心做题，在外面走了走，平复了下心情，做出了让我$NOIP$能上四百的最重要的一个决定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下午晚上就什么都没有干，针对$NOIP$制定了一个超详细的复习计划，涵盖接下来的三个月&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;命名为“秋季风暴”，希望能像风暴一样扫清一切发展的障碍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没错，它就像一场风暴&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;九月底，$NOIP$前的可以说是最辉煌的一个时期了，从第十左右一路反杀，稳定在前五，$Rank$前三也拿过好多次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随即收到消息，说是国庆假期培训，本来考虑了，可能会影响我计划的执行，但是最后还是决定培训完动态调整&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;培训前一天晚上，和同学出去吃了点饭，然后颓了会&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\large{October}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;培训如期而至，只是和我所想的略有不同，$Day1$省选数学&lt;span&gt;（就是我这几天刚学的）&lt;/span&gt;，走了不到一分钟神吧，一天连定义都搞不懂，晚上未来的队爷跟我$QQ$上说不会，我说都说了是省选内容了，我不用会。然后他$fAKe$了句，嗯有理。后来应他要求，我还是推荐了个集训队大爷的博客给他&lt;span&gt;（那时候我还没看过）&lt;/span&gt;，然后他就会了（我还能说什么。。。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后几天是一如既往的懵逼，都不知道干什么了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后发现我原来的整个计划都被打乱了，“秋季风暴”走向了崩溃&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有的人就是听课特别有用，但是我，应该是因为思维慢，容易跟不上，然后一旦一个地方跟不上，一天就凉了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我就是自己找资料自己学的效果更好，毕竟学什么的时候，想到的扩展的东西也比较多&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整个十月就变成了一个耻辱的历史，月底我也试图制定其他计划来挽救，但是为时已晚，只能看着名次一步一步掉到倒数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\large{November}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后还是要$NOIP$了，考前再熟悉下模板吧，然后就花了好几天敲板子，“秋季风暴”的遗产也给了我很大的帮助，熟悉了下各种巧妙的解题思路，但是心态还是不太稳定，各种杂事挺多，总之就是打板子的几天&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\large{Day-1}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;挺平常的一天，当时应该是为退役准备最充分的人了吧，想到四机房能用的机子本来就不多，就在电脑上新建了个没密码的账户，以后给学弟学妹用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;晚上没上晚自习，回家收拾了下明天的东西，本来说要早点睡，之后也没早睡成。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\large{Day0}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在火车上，旁边是一个学弟，不知道是哪个校区的，他之后就做到其他同学旁边去了，然后开神犇就坐过来了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;火车上颓了会，然后就是吃饭以及跟开神犇聊了会天，之后稍微睡了会，也没睡着就到了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到宾馆，住的房间比省选摸鱼的时候要好，然后去试机，他们都在敲各种数据结构，但是我一个也不会，也是不想敲了，敲了个$Hello~World$，$A+B$还有个快速幂就走了，$wzy$和$tbl$也走的挺早（不知留在那试机能干啥）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;晚上回宾馆，有些记的不太清楚的板子，又看了下，然后就没怎么学习，习惯考前不学习了，跟他们联机玩了会，但是网速实在是慢，不是很爽啊&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后学长讲了些注意事项，回去就没干什么，早点睡了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\Large{Day1}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\text{考前}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$Day1$呢，本来就打算着尽量往高里拿分的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;早晨，不知几点（后来知道是五点半），感到周围一阵巨响，强烈的震动感，大概有些意识了，发现是手机振动，一看是铃声，我就掐了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后是$5:40,5:50,6:00$，直到$wyt$醒了，他没关手机铃声。。。然后就多睡了会&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基本上是最后一批去吃饭的，被催了半天，随便吃了点很随便的伙食，教练送了条士力架带进考场吃&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\large\text{考试开始}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;密码一次就输对了，很开心，也算是占得先机吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$T1$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读懂题意之后，有点惊讶，这不是那个积木。。积木什么来着&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;贪心思路还记得，但是一时竟忘了怎么做，只是记得挺简单&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后来想了想，扫一遍就好了（想看题解自己去找吧，我就不再说了）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后直接过两个样例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;做完$T1$，看了看表，才过了十分钟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$T2$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在是绿的，感觉自己很菜&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读懂题意，看了下样例，突然想到，如果一个数能被其他数线性表出，那肯定不用选&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是不知道选择截然不同的数有没有更优方案，假装没有了吧。。。&lt;span&gt;（这种做题态度，我还能说什么）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后问题就转化为了考虑一个数能否被其他数线性表出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后就懵逼了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想了半个多小时，瞎歪歪出来一个计数$DP$做法，能拿$80$分，当时觉得$T2$能拿$80$不亏，就做$T3$去了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$T3$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一眼二分，然后就懵逼了，考虑各种$DP$啊，贪心啊什么的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后一种没有被我自己$Hack$的方案脱颖而出，大致证了下正确性就上手去写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写完过了编译，测了发样例，三个全过，当时都想喊出来，$280$分了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;啊啊啊特别激动，激动的我一下吃了一整个士力架（平时吃不了太甜的，所以哪能一下吃了这么甜的东西）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看时间，还有一个半小时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\text{优化与调试}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$T3$看数据范围复杂度应该是$O(nlognlogn)$的，但是我在$set$上二分有三个$log$，而且有大常数，虽然其中两个$log$都是假的，但是菊花图就能卡回原形&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;造了个数据，果然跑不过去，考虑优化，卡了波二分边界，然后就稳过了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后怕二分边界卡错了（虽然证出来，这样是阔以的，但是反正也闲得慌），拿卡了的和没卡的拍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拍着我就去看$T2$了，还是没什么正解思路，但是发现我的技术$DP$最后只用判可行性，于是加了个大剪枝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$O(25000*25000*20)$的算法跑随机的数据稳定在五六百毫秒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后看$T3$，竟然拍$WA$了，出人意料，原来从来没想过会拍出错来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过不断努力，发现菊花图容易死，当时有点懵，不知道是咋，最后也就没时间了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\text{考完}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本来是说考完坚决不对答案的，结果一想能拿至少二百多，就不慌了，说说也无妨嘛，可能是一样的心态，大家也都在说&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回宾馆之后，验完程序，大部分人都没事&lt;span&gt;（wzy少了两个，不过都找回来了）&lt;/span&gt;，打开洛谷，民间数据还没有登陆，就把$T1$交到积木大赛，$AC$虽然是意料之中，但是也是挺开心&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有点累，就躺了会，等到了$T2$的民间数据，交上去，$A$了！暴力加剪枝把民间数据碾过去了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是随后就传来噩耗，说数据加强了，象征性地把我卡到$95$了（笑哭）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$T3$的数据咕咕了，然后我就到处翻点东西，看都在说什么，才知道$Day1$三道都是原题。。。ε=(´ο｀*)))唉我还能说什么，只做过一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后听说甚至一个题是考前教练给的复习幻灯片上的题，很多人都做过，而我恰好没看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下午按计划去看海，$zzh$挺早就来找$wyt$了，他们本来还叫上我，但是我因为提前跟$yzh,zyc,zyz$约好一块去的，就没有去。@某人，亏我还等你&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后才看到$QQ$上，$yzh$大概半个小时之前叫我去，然后我就问他在哪，他就发了个马路的照片。。。&lt;span&gt;（什么人啊，也不来找我）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那还去个毛线啊，之后就等$wyt$和$zzh$回来一块吃的晚饭&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;吃完饭回来，看到$T3$的数据到了，测了发，$80$，跟别人讨论了下做法，都说我的做法是假的，就是个骗分（这里留坑待填）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算了算了，不管了，&lt;span&gt;骗到80就跑&lt;/span&gt;，所以洛谷上$Day1$最终是$275$分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;晚上看到大家好多人都说要$Day2$翻盘，我当时很天真啊，一个是认识到自己很菜，$Day2$不被拉开差距就好，另外也是觉得$275$挺高了（后来才知道那么多$290$以上的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;晚上又强调了点东西，一个是说题简单，拉不开差距，另外就是说明天题可能很难，写好暴力&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后听两个教练说考的不错，嗯，那第二天继续加油&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\Large{Day2}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\text{考前}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$Day1$之后，我的目标就从保省一变成了冲省队&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;早晨的铃已经被$wyt$关了，睡了个好觉，早起去吃饭，没什么人，精挑细选了一番，发现真没什么好吃的，草草吃完，教练又发了两个脆脆鲨&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\large\text{考试开始}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;密码还是一次输对&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$T1$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;旁边是个唐山一中的大佬，我还没读懂题，他就好像把$T1$切了，然后我发现，这不就是个裸的$prim$吗&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;花了几分钟敲完，过不了第二个样例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后发现自己读错题了，感觉$T1$受旁边人干扰挺大的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后看了会，不会，先敲好暴力，$60$分，明显不够啊，又想了想，最后还是没想出来，算了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时间：开考一小时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$T2$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好不容易读懂题意，毫无思路，看数据范围，像是状压，但是时空复杂度好像都不对&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不妨先写个爆搜，看有什么收获，想了想，不好写？容斥一下好像就比较轻松了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是一个$O(2^{n*m})$的爆搜就诞生了，$2*2$的样例轻松过掉，但是$3*3$的就萎了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当时是真的懵逼了，搜索写萎，心态爆炸&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是啃了个脆脆鲨，然后去厕所遛了一圈，调整心情&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;手画了下$2*3$的情况，和程序跑出来的一样，就拿一个自己都不确定正确性的程序打了个表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;做好了$20$分的准备，时间：开考两小时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$T3$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好像做过原题，就是在树上覆盖的问题，一个点打标记能覆盖与之相邻的所有点，在每个点打标记有个不同的权值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写完发现过不了第二个小样例，不知道为啥，还好是小样例，手画了下，和程序结果一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;果然是又读错题了，改了发转移方程，就顺利过了所有样例，$44$分$get$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\text{没时间再干什么了}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后就只剩十几分钟了，查了下文件，$T3$的$.out$写成$.ans$了，还好查出来了，其他的就没有问题了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$$\text{考完}$$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大巴已经在门口接了，回宾馆拿上行李，直接赶往火车站，$yjc$一句枚举删边，我$T1$直接会了，蛮可惜的，但是谁让自己想不到呢&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好像很多人都切掉$T1$了，大佬们都很厉害，我估的$154$，这个分呢，洛谷上高点是$159$，牛客和校内数据是$154$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;火车站吃了点德克士，就赶火车去了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;才知道很多大佬$Day2$都有点炸，我发现他们有一个共性，就是刚$T1$太久了，然后导致没给$T2T3$留够时间，这样一慌乱，就容易出错，或者该拿的暴力没拿到（当然还有一类神仙是刚$T3$，调动态$DP$）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实我这个小蒟蒻$Day2$也是因为时间的关系，没拿全暴力分的，读错题和暴力写萎确实耽误时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以发现时间分配是很重要的啊，平时考试一个都不会的时候的时间分配的经验教训让我不至于死在$NOIP$上，毕竟$yjc$那种一个小时拿满两道题的暴力分的神仙极为罕见$orz$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回去的火车上，不知道该干啥&lt;span&gt;（没有网）&lt;/span&gt;，心情复杂，看看窗外的景色吧，问自己一切都结束了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过两天的大起大落，真的累了，就睡了会&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回家在洛谷上测是$434$，牛客上是$429$，听说学校内部数据是$444$，看来成绩还是比较稳定的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不知道是因为在车上睡了还是心事太重，晚上睡不着，在真正面临退役之前，从没体会到过这是一件如此可怕的事&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;算法竞赛，不敢说是一种信仰，但是当你走入其中，它一定是一种无法舍弃的情怀&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;设计出一种算法，通过不懈的优化，以优秀的时间和最少的资源占用解决一个问题，这真的是一个无比快乐的过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;既然说是一种情怀，用语言自然是难以形容，该懂的人，自然会懂&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 18 Nov 2018 14:41:00 +0000</pubDate>
<dc:creator>ivanovcraft</dc:creator>
<og:description>$Update~On~11.18$ $$\large\text{出分}Day-1$$ 这几天在学数学，有了点反演基础，然后学了波杜教筛，找点例题？网上好像没很多题可做，找了个题，$NOI$的，听说是好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ivanovcraft/p/9980165.html</dc:identifier>
</item>
<item>
<title>【netty】(1)---BIO NIO AIO演变 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9979769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9979769.html</guid>
<description>&lt;p&gt;     Netty是一个提供异步事件驱动的网络应用框架，用以快速开发高性能、高可靠的网络服务器和客户端程序。Netty简化了网络程序的开发，是很多框架和公司都在使用的技术。&lt;/p&gt;
&lt;p&gt;Netty并非横空出世，它是在BIO，NIO，AIO演变中的产物，是一种NIO框架。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、BIO的理解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中&lt;span&gt;服务端提供位置信息（绑定的IP地址和监听端口），客户端通过连接操作向服务端监听的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;地址发送连接请求，通过三次握手建立连接&lt;/span&gt;，如果连接成功，双方就可以通过网络套接字(Socket)进行通信。在基于同步堵塞模式开发中，&lt;span&gt;ServerSocket负责绑定Ip地址，启动监&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;听端口。Socket负责发起连接操作&lt;/span&gt;。连接成功之后，双方通过输入和输出流进行同步堵塞式通信。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;BIO流程图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201811/1090617-20181118215610086-2008700581.png&quot; alt=&quot;&quot; width=&quot;1001&quot; height=&quot;272&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BIO&lt;/strong&gt; 全称Block-IO 是一种&lt;span&gt;阻塞同步的通信模式&lt;/span&gt;。我们常说的StockIO一般指的是BIO。是一个比较传统的通信方式，&lt;span&gt;模式简单，使用方便。但并发处理能力低，通信耗时，依赖网速&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;BIO 设计原理&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;       服务器通过一个&lt;span&gt;Acceptor&lt;/span&gt;线程负责监听客户端请求和为每个客户端创建一个新的线程进行链路处理。典型的一请求一应答模式。若客户端数量增多，频繁地创建和销毁线程会&lt;/p&gt;
&lt;p&gt;给服务器打开很大的压力。后改良为用线程池的方式代替新增线程，被称为伪异步IO。服务器提供IP地址和监听的端口，客户端通过TCP的三次握手与服务器连接，连接成功后，双&lt;/p&gt;
&lt;p&gt;放才能通过套接字(Stock)通信。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小结&lt;/span&gt;：BIO模型中通过Socket和ServerSocket完成套接字通道的实现。阻塞，同步，建立连接耗时。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、NIO的理解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;       与Socket类和ServerSocket类相对应，NIO也提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现。这两种新增的通道都支持阻塞和非阻塞两种模&lt;/p&gt;
&lt;p&gt;式。阻塞模式使用非常简单，但是性能和可靠性都不好，非阻塞模式则正好相反。幵发人员一般可以根据自己的需要来选择合适的模式，一般来说，低负载、低并发的应用程序可&lt;/p&gt;
&lt;p&gt;以选择同步阻塞I/O以降低编程父杂度，但是对于高负载、高并发的网络络应用，需要使用NIO的非堵塞模式迸行幵发。&lt;/p&gt;
&lt;p&gt;NIO 全称New IO，也叫Non-Block IO 是一种&lt;span&gt;非阻塞同步的通信模式&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;NIO流程图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201811/1090617-20181118215941745-323892415.png&quot; alt=&quot;&quot; width=&quot;1004&quot; height=&quot;377&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;NIO 设计原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     NIO 相对于BIO来说一大进步。客户端和服务器之间通过Channel通信。NIO可以在Channel进行读写操作。这些Channel都会被注册在Selector多路复用器上。Selector通过&lt;/p&gt;
&lt;p&gt;一个线程不停的轮询这些Channel。找出已经准备就绪的Channel执行IO操作。NIO 通过一个线程轮询，实现千万个客户端的请求，这就是非阻塞NIO的特点。&lt;/p&gt;
&lt;p&gt;NIO几个新概念&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）缓冲区Buffer&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      它是NIO与BIO的一个重要区别。BIO是将数据直接写入或读取到Stream对象中。而NIO的数据操作都是在缓冲区中进行的。缓冲区实际上是一个数组。Buffer最常见的类型&lt;/p&gt;
&lt;p&gt;是ByteBuffer，另外还有CharBuffer，ShortBuffer，IntBuffer，LongBuffer，FloatBuffer，DoubleBuffer。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）通道Channel&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;和流不同，通道是双向的&lt;/span&gt;。NIO可以通过Channel进行数据的读，写和同时读写操作。通道与流之间不同之处是通道是双向的，流只能一个方向移动（一个流必须是&lt;/p&gt;
&lt;p&gt;InputStream或者OutputStream的子类）。 通道分为两大类：一类是网络读写（SelectableChannel），一类是用于文件操作（FileChannel），我们使用的SocketChannel&lt;/p&gt;
&lt;p&gt;和ServerSocketChannel都是SelectableChannel的子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）多路复用器Selector&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     NIO编程的基础。多路复用器提供选择已经就绪的任务的能力。就是Selector会不断地轮询注册在其上的通道（Channel），如果某个通道处于就绪状态，会被Selector轮询出&lt;/p&gt;
&lt;p&gt;来，然后通过SelectionKey可以取得就绪的Channel集合，从而进行后续的IO操作。服务器端只要提供一个线程负责Selector的轮询，就可以接入成千上万个客户端，这就是&lt;/p&gt;
&lt;p&gt;JDK NIO库的巨大进步。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、AIO理解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      异步无非是通知系统做一件事情。然后忘掉它，自己做其他事情去了。很多时候系统做完某一件事情后需要一些后续的操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AIO 也叫NIO2.0 是一种非阻塞异步的通信模式&lt;/span&gt;。在NIO的基础上引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;AIO流程图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201811/1090617-20181118221221582-1287720922.png&quot; alt=&quot;&quot; width=&quot;571&quot; height=&quot;518&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      AIO 并没有采用NIO的多路复用器，而是使用异步通道的概念。其read，write方法的返回类型都是Future对象。而Future模型是异步的，其核心思想是：去主函数等待时间。&lt;/p&gt;
&lt;p&gt;AIO模型中通过&lt;span&gt;AsynchronousSocketChannel&lt;/span&gt;和&lt;span&gt;AsynchronousServerSocketChannel&lt;/span&gt;完成套接字通道的实现。非阻塞，异步。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1 IO，NIO，AIO区别&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;    IO 阻塞同步通信模式，客户端和服务器连接需要三次握手，使用简单，但吞吐量小。&lt;/p&gt;
&lt;p&gt;    NIO 非阻塞同步通信模式，客户端与服务器通过Channel连接，采用多路复用器轮询注册的Channel。提高吞吐量和可靠性。&lt;/p&gt;
&lt;p&gt;    AIO 非阻塞异步通信模式，NIO的升级版，采用异步通道实现异步通信，其read和write方法均是异步方法。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2 Stock通信的伪代码实现流程&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      服务器绑定端口：server = new ServerSocket(PORT)&lt;/p&gt;
&lt;p&gt;      服务器阻塞监听：socket = server.accept()&lt;/p&gt;
&lt;p&gt;      服务器开启线程：new Thread(Handle handle)&lt;/p&gt;
&lt;p&gt;      服务器读写数据：BufferedReader PrintWriter&lt;/p&gt;
&lt;p&gt;     客户端绑定IP和PORT：new Socket(IP_ADDRESS, PORT)&lt;/p&gt;
&lt;p&gt;     客户端传输接收数据：BufferedReader PrintWriter&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3 什么是同步阻塞BIO，同步非阻塞NIO，异步非阻塞AIO&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     同步阻塞IO&lt;/strong&gt; : 用户进程发起一个IO操作以后，必须等待IO操作的真正完成后，才能继续运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     同步非阻塞IO&lt;/strong&gt;: 用户进程发起一个IO操作以后，可做其它事情，但用户进程需要经常询问IO操作是否完成，这样造成不必要的CPU资源浪费。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     异步非阻塞IO&lt;/strong&gt;: 用户进程发起一个IO操作然后，立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知。类比Future模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     1）BIO模型中通过Socket和ServerSocket完成套接字通道实现。阻塞，同步，连接耗时。&lt;/p&gt;
&lt;p&gt;    2） NIO模型中通过SocketChannel和ServerSocketChannel完成套接字通道实现。非阻塞/阻塞，同步，避免TCP建立连接使用三次握手带来的开销。&lt;/p&gt;
&lt;p&gt;    3） AIO模型中通过AsynchronousSocketChannel和AsynchronousServerSocketChannel完成套接字通道实现。非阻塞，异步。&lt;/p&gt;
&lt;p&gt;再附上netty权威指南书中一张图、&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201811/1090617-20181118221832172-1747040798.png&quot; alt=&quot;&quot; width=&quot;831&quot; height=&quot;314&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;五、参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;    主要参考一篇文章：&lt;a href=&quot;http://www.cnblogs.com/itdragon/p/8337234.html&quot; target=&quot;_blank&quot;&gt;BIO NIO AIO演变&lt;/a&gt; 文章中有这三种类型的代码演示。&lt;/p&gt;
&lt;p&gt;             GitHub地址:  &lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/tree/master/Netty/socket-io&quot; target=&quot;_blank&quot;&gt;https://github.com/ITDragonBlog/daydayup/tree/master/Netty/socket-io&lt;/a&gt; （感谢作者分享）&lt;/p&gt;
&lt;p&gt;其它的一些参考：&lt;/p&gt;
&lt;p&gt;    1、《netty权威指南》第二章&lt;/p&gt;
&lt;p&gt;    2、&lt;a href=&quot;https://www.jianshu.com/p/c84141e1a678&quot; target=&quot;_blank&quot;&gt;NIO基础详解(代码部分解释的也很好很好) &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    3、&lt;a href=&quot;http://www.jasongj.com/java/nio_reactor/#comments&quot; target=&quot;_blank&quot;&gt;Java I/O模型从BIO到NIO和Reactor模式（图片解释更清晰）&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;如果一个人充满快乐，正面的思想，那么好的人事物就会和他共鸣，而且被他吸引过来。同样，一个人老带悲伤，倒霉的事情也会跟过来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                                       ——在自己心情低落的时候，告诫自己不要把负能量带给别人。（大校9）&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 18 Nov 2018 14:29:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>BIO NIO AIO演变 Netty是一个提供异步事件驱动的网络应用框架，用以快速开发高性能、高可靠的网络服务器和客户端程序。Netty简化了网络程序的开发，是很多框架和公司都在使用的技术。 Net</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9979769.html</dc:identifier>
</item>
<item>
<title>使用 JS 输出螺旋矩阵 - 叙帝利</title>
<link>http://www.cnblogs.com/nzbin/p/9886498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nzbin/p/9886498.html</guid>
<description>&lt;h2 id=&quot;关于螺旋矩阵&quot;&gt;关于螺旋矩阵&lt;/h2&gt;
&lt;p&gt;这是我曾经遇到过的面试题，在 LeetCode 上找到了题目的原型，难度中等。题目描述如下：&lt;/p&gt;
&lt;p&gt;给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;输入:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
输出: [1,2,3,4,8,12,11,10,9,5,6,7]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解题思路&quot;&gt;解题思路&lt;/h2&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;[[1, 1, 1, 1, 1, 1, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 2, 3, 3, 3, 2, 1],
 [1, 2, 2, 2, 2, 2, 1],
 [1, 1, 1, 1, 1, 1, 1]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一道难度中等的题目，但是第一次看到题目时还是有一些困惑，不过仔细分析后很容易找到思路。比较直观的思路是逐层法，从外向内循环每一层。其中单层循环的方法也有很多，我使用了插入法循环每一层。以下是 4X4 矩阵循环的步骤：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * --------------------------------------------
 * 以 4X4 矩阵为例
 * 
 * [[ 1, 2, 3, 4],
 *  [ 5, 6, 7, 8],
 *  [ 9,10,11,12],
 *  [13,14,15,16]]
 *
 * --------------------------------------------
 * 循环第一层
 * 
 * [[ 1, 2, 3, 4],  |
 *  [ 5,       8],  |
 *  [ 9,      12],  |
 *  [13,14,15,16]]  ▼
 *
 * --------------------------------------------
 * 将元素按顺序插入数组，`|` 表示插入位置
 * 
 * [ 1, 2, 3, 4, |]
 *         (8, 5)┘
 *         
 * [ 1, 2, 3, 4, 8, |, 5]
 *           (12, 9)┘
 *           
 * [ 1, 2, 3, 4, 8, 12, |, 9, 5]
 *      (16, 15, 14, 13)┘
 *      
 * [ 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5]
 * 
 * 第一层循环结束
 * 
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上步骤拆分，可以看到输出螺旋矩阵还是比较容易的，以下是具体的 JS 代码。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * @param {number[][]} matrix
 * @return {number[]}
 */
var spiralOrder = function(matrix) {
    // 最终返回的结果数组
    var ans = [];

    var spiralLoop = function() {
        // 临时数组
        var arr = [];

        for (var i = 0; i &amp;lt; matrix.length; i++) {

            if (i === 0) {
                arr = arr.concat(matrix[0]);
            }

            if (i &amp;gt; 0 &amp;amp;&amp;amp; i &amp;lt; matrix.length - 1) {
                var insertRight = matrix[0].length === 1 ? 
                                  [] : 
                                  arr.splice(-(i - 1), i - 1), // 插入位置右侧的元素
                    last = matrix[i].splice(-1, 1), // 中间行尾元素
                    first = matrix[i].splice(0, 1); // 中间行首元素
                // 在指定位置插入元素
                arr = arr.concat(last, first, insertRight);
            }

            if (matrix.length &amp;gt; 1 &amp;amp;&amp;amp; i === matrix.length - 1) {
                var insertRight  = matrix[0].length === 1 ? 
                                   [] : 
                                   arr.splice(-(matrix.length - 2), matrix.length - 2);
                // 将最后一行倒叙排列然后插入指定位置
                arr = arr.concat(matrix[matrix.length - 1].reverse(), insertRight);
            }

        }
        // 删除矩阵的首尾行，得到的就是下一次需要遍历的矩阵
        matrix.splice(0, 1);
        matrix.splice(-1, 1);

        ans = ans.concat(arr);
        // 根据矩阵内是否还存在数组进行递归
        if (matrix.length &amp;gt;= 1) {
            spiralLoop(matrix);
        }

    }

    spiralLoop(matrix);

    return ans;

};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上程序的运行时间大约在 60 ms 左右，超过所有提交答案的五成，中规中矩吧，距离最优算法还有一定差距。&lt;/p&gt;
&lt;h2 id=&quot;官方答案&quot;&gt;官方答案&lt;/h2&gt;
&lt;p&gt;LeetCode 原站给出了这道题的解题思路及代码，中文站则没有。官方介绍了两种方法，一种是模拟法，另一种是逐层法，其中逐层法的思路和我的思路是相同的，不过单层循环的方法不同。对于二维矩阵的题目，我最先想到的也是模拟法，也就是模拟行走路线及方向，但是因为判断条件有点复杂而放弃了。具体实现可以看官网文章 &lt;a href=&quot;https://leetcode.com/articles/spiral-matrix/&quot; class=&quot;uri&quot;&gt;https://leetcode.com/articles/spiral-matrix/&lt;/a&gt;，以下是两种方法的 python 实现，因时间关系，我就不写 JS 版本了，后续有时间再补上，感兴趣的博友可以自己转换。&lt;/p&gt;
&lt;p&gt;1、模拟法&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;class Solution(object):
    def spiralOrder(self, matrix):
        if not matrix: return []
        R, C = len(matrix), len(matrix[0])
        seen = [[False] * C for _ in matrix]
        ans = []
        dr = [0, 1, 0, -1]
        dc = [1, 0, -1, 0]
        r = c = di = 0
        for _ in range(R * C):
            ans.append(matrix[r][c])
            seen[r][c] = True
            cr, cc = r + dr[di], c + dc[di]
            if 0 &amp;lt;= cr &amp;lt; R and 0 &amp;lt;= cc &amp;lt; C and not seen[cr][cc]:
                r, c = cr, cc
            else:
                di = (di + 1) % 4
                r, c = r + dr[di], c + dc[di]
        return ans&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、逐层法&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;class Solution(object):
    def spiralOrder(self, matrix):
        def spiral_coords(r1, c1, r2, c2):
            for c in range(c1, c2 + 1):
                yield r1, c
            for r in range(r1 + 1, r2 + 1):
                yield r, c2
            if r1 &amp;lt; r2 and c1 &amp;lt; c2:
                for c in range(c2 - 1, c1, -1):
                    yield r2, c
                for r in range(r2, r1, -1):
                    yield r, c1

        if not matrix: return []
        ans = []
        r1, r2 = 0, len(matrix) - 1
        c1, c2 = 0, len(matrix[0]) - 1
        while r1 &amp;lt;= r2 and c1 &amp;lt;= c2:
            for r, c in spiral_coords(r1, c1, r2, c2):
                ans.append(matrix[r][c])
            r1 += 1; r2 -= 1
            c1 += 1; c2 -= 1
        return ans&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 18 Nov 2018 14:22:00 +0000</pubDate>
<dc:creator>叙帝利</dc:creator>
<og:description>关于螺旋矩阵 这是我曾经遇到过的面试题，在 LeetCode 上找到了题目的原型，难度中等。题目描述如下： 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nzbin/p/9886498.html</dc:identifier>
</item>
<item>
<title>Netty ByteBuf（图解之 2）|  秒懂 - 疯狂创客圈</title>
<link>http://www.cnblogs.com/crazymakercircle/p/9979897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crazymakercircle/p/9979897.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;&lt;span&gt;疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之16 【 &lt;span&gt;博客园 总入口&lt;/span&gt; 】&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;源码工程&quot;&gt;源码工程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;源码IDEA工程获取链接&lt;/strong&gt;：&lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;Java 聊天室 实战 源码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;​ 大家好，我是作者尼恩。&lt;/p&gt;
&lt;p&gt;​ 今天是百万级流量 Netty 聊天器 打造的系列文章的第16篇，这是一个基础篇，介绍ByteBuf 的使用。&lt;/p&gt;
&lt;p&gt;​ 由于关于ByteBuf的内容比较多，分两篇文章：&lt;/p&gt;
&lt;p&gt;​ &lt;a href=&quot;https://blog.csdn.net/crazymakercircle/article/details/84198042&quot;&gt;第一篇：图解 ByteBuf的分配、释放和如何避免内存泄露&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ 第二篇：图解 ByteBuf的具体使用&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;本篇为第二篇&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;bytebuf-的四个逻辑部分&quot;&gt;ByteBuf 的四个逻辑部分&lt;/h2&gt;
&lt;p&gt;ByteBuf 是一个字节容器，内部是一个字节数组。&lt;/p&gt;
&lt;p&gt;从逻辑上来分，字节容器内部，可以分为四个部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018111821555591.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个部分是已经丢弃的字节，这部分数据是无效的；&lt;/p&gt;
&lt;p&gt;第二部分是可读字节，这部分数据是 ByteBuf 的主体数据， 从 ByteBuf 里面读取的数据都来自这一部分;&lt;/p&gt;
&lt;p&gt;第三部分的数据是可写字节，所有写到 ByteBuf 的数据都会写到这一段。&lt;/p&gt;
&lt;p&gt;第四部分的字节，表示的是该 ByteBuf 最多还能扩容的大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四个部分的逻辑功能，如下图所示&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118215630736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;bytebuf-的三个指针&quot;&gt;ByteBuf 的三个指针&lt;/h2&gt;
&lt;p&gt;ByteBuf 通过三个整型的指针（index），有效地区分可读数据和可写数据，使得读写之间相互没有冲突。&lt;/p&gt;
&lt;p&gt;这个三个指针，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;readerIndex（读指针）&lt;/li&gt;
&lt;li&gt;writerIndex（写指针）&lt;/li&gt;
&lt;li&gt;maxCapacity（最大容量）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201811182157068.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 这三个指针，是三个int 型的成员属性，定义在 AbstractByteBuf 抽象基类中。&lt;/p&gt;
&lt;p&gt;​ 三个指针的代码截图，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118215741873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;readerIndex 读指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指示读取的起始位置。&lt;/p&gt;
&lt;p&gt;每读取一个字节，readerIndex 自增1 。一旦 readerIndex 与 writerIndex 相等，ByteBuf 不可读 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;writerIndex 写指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指示写入的起始位置。&lt;/p&gt;
&lt;p&gt;每写一个字节，writerIndex 自增1。一旦增加到 writerIndex 与 capacity（） 容量相等，表示 ByteBuf 已经不可写了 。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;capacity（）容量不是一个成员属性，是一个成员方法。表示 ByteBuf 内部的总容量。 注意，这个不是最大容量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;maxCapacity 最大容量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指示可以 ByteBuf 扩容的最大容量。&lt;/p&gt;
&lt;p&gt;当向 ByteBuf 写数据的时候，如果容量不足，可以进行扩容。&lt;/p&gt;
&lt;p&gt;扩容的最大限度，直到 capacity（） 扩容到 maxCapacity为止，超过 maxCapacity 就会报错。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;capacity（）扩容的操作，是底层自动进行的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;bytebuf-的三组方法&quot;&gt;ByteBuf 的三组方法&lt;/h2&gt;
&lt;p&gt;从三个维度三大系列，介绍ByteBuf 的常用 API 方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2018111821581333.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;第一组容量系列&quot;&gt;第一组：容量系列&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法 一：capacity()&lt;/p&gt;
&lt;p&gt;表示 ByteBuf 的容量，包括丢弃的字节数、可读字节数、可写字节数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;方法二：maxCapacity()&lt;/p&gt;
&lt;p&gt;表示 ByteBuf 底层最大能够占用的最大字节数。当向 ByteBuf 中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到 maxCapacity。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;第二组写入系列&quot;&gt;第二组：写入系列&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;方法一：isWritable()&lt;/p&gt;
&lt;p&gt;表示 ByteBuf 是否可写。如果 capacity（） 容量大于 writerIndex 指针的位置 ，则表示可写。否则为不可写。&lt;/p&gt;
&lt;p&gt;isWritable()的源码，也是很简单的。具体如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    public boolean isWritable() {
        return this.capacity() &amp;gt; this.writerIndex;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：如果 isWritable() 返回 false，并不代表不能往 ByteBuf 中写数据了。 如果Netty发现往 ByteBuf 中写数据写不进去的话，会自动扩容 ByteBuf。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;16.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;方法二：writableBytes()&lt;/p&gt;
&lt;p&gt;返回表示 ByteBuf 当前可写入的字节数，它的值等于 capacity（）- writerIndex。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118215841725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;方法三：maxWritableBytes()&lt;/p&gt;
&lt;p&gt;返回可写的最大字节数，它的值等于 maxCapacity-writerIndex 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;方法四：&lt;strong&gt;writeBytes(byte[] src)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把字节数组 src 里面的数据全部写到 ByteBuf。&lt;/p&gt;
&lt;p&gt;这个是最为常用的一个方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;方法五：writeTYPE(TYPE value） 基础类型写入方法&lt;/p&gt;
&lt;p&gt;基础数据类型的写入，包含了 8大基础类型的写入。&lt;/p&gt;
&lt;p&gt;具体如下：writeByte()、 writeBoolean()、writeChar()、writeShort()、writeInt()、writeLong()、writeFloat()、writeDouble() ，向 ByteBuf写入基础类型的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;方法六：setTYPE(TYPE value）基础类型写入，不改变指针值&lt;/p&gt;
&lt;p&gt;基础数据类型的写入，包含了 8大基础类型的写入。&lt;/p&gt;
&lt;p&gt;具体如下：setByte()、 setBoolean()、setChar()、setShort()、setInt()、setLong()、setFloat()、setDouble() ，向 ByteBuf 写入基础类型的数据。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;setType 系列与writeTYPE系列的不同&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;setType 系列 &lt;strong&gt;不会&lt;/strong&gt; 改变写指针 writerIndex ；&lt;/p&gt;
&lt;p&gt;writeTYPE系列 &lt;strong&gt;会&lt;/strong&gt; 改变写指针 writerIndex 的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;方法七：markWriterIndex() 与 resetWriterIndex()&lt;/p&gt;
&lt;p&gt;这里两个方法一起介绍。&lt;/p&gt;
&lt;p&gt;前一个方法，表示把当前的写指针writerIndex 保存在 markedWriterIndex 属性中；&lt;/p&gt;
&lt;p&gt;后一个方法，表示把当前的写指针 writerIndex 恢复到之前保存的 markedWriterIndex 值 。&lt;/p&gt;
&lt;p&gt;标记 markedWriterIndex 属性， 定义在 AbstractByteBuf 抽象基类中。&lt;/p&gt;
&lt;p&gt;截图如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118215912474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;第三组读取系列&quot;&gt;第三组：读取系列&lt;/h4&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;方法一：isReadable()&lt;/p&gt;
&lt;p&gt;表示 ByteBuf 是否可读。如果 writerIndex 指针的值大于 readerIndex 指针的值 ，则表示可读。否则为不可写。&lt;/p&gt;
&lt;p&gt;isReadable()的源码，也是很简单的。具体如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;   public boolean isReadable() {
        return this.writerIndex &amp;gt; this.readerIndex;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;14&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;方法二：readableBytes()&lt;/p&gt;
&lt;p&gt;返回表示 ByteBuf 当前可读取的字节数，它的值等于 writerIndex - readerIndex 。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/201811182159430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;方法三： &lt;strong&gt;readBytes(byte[] dst)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把 ByteBuf 里面的数据全部读取到 dst 字节数组中，这里 dst 字节数组的大小通常等于 readableBytes() 。 这个方法，也是最为常用的一个方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;方法四：readType(） 基础类型读取&lt;/p&gt;
&lt;p&gt;基础数据类型的读取，可以读取 8大基础类型。&lt;/p&gt;
&lt;p&gt;具体如下：readByte()、readBoolean()、readChar()、readShort()、readInt()、readLong()、readFloat()、readDouble() ，从 ByteBuf读取对应的基础类型的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;方法五：getTYPE(TYPE value）基础类型读取，不改变指针值&lt;/p&gt;
&lt;p&gt;基础数据类型的读取，可以读取 8大基础类型。&lt;/p&gt;
&lt;p&gt;具体如下：getByte()、 getBoolean()、getChar()、getShort()、getInt()、getLong()、getFloat()、getDouble() ，从 ByteBuf读取对应的基础类型的数据。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;getType 系列与readTYPE系列的不同&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;getType 系列 &lt;strong&gt;不会&lt;/strong&gt; 改变读指针 readerIndex ；&lt;/p&gt;
&lt;p&gt;readTYPE系列 &lt;strong&gt;会&lt;/strong&gt; 改变读指针 readerIndex 的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;方法六：markReaderIndex() 与 resetReaderIndex()&lt;/p&gt;
&lt;p&gt;这里两个方法一起介绍。&lt;/p&gt;
&lt;p&gt;前一个方法，表示把当前的读指针ReaderIndex 保存在 markedReaderIndex 属性中。&lt;/p&gt;
&lt;p&gt;后一个方法，表示把当前的读指针 ReaderIndex 恢复到之前保存的 markedReaderIndex 值 。&lt;/p&gt;
&lt;p&gt;标记 markedReaderIndex 属性， 定义在 AbstractByteBuf 抽象基类中。&lt;/p&gt;
&lt;p&gt;截图如下：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118220042664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;bytebuf-的引用计数&quot;&gt;ByteBuf 的引用计数&lt;/h2&gt;
&lt;p&gt;Netty 的 ByteBuf 的内存回收工作，是通过引用计数的方式管理的。&lt;/p&gt;
&lt;p&gt;大致的引用计数的规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认情况下，当创建完一个 ByteBuf 时，它的引用为1。&lt;/li&gt;
&lt;li&gt;每次调用 retain()方法， 它的引用就加 1 ；&lt;/li&gt;
&lt;li&gt;每次调用 release() 方法，是将引用计数减 1。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果引用为0，再次访问这个 ByteBuf 对象，将会抛出异常。&lt;/p&gt;
&lt;p&gt;如果引用为0，表示这个 ByteBuf 没有地方被引用到，需要回收内存。&lt;/p&gt;
&lt;p&gt;Netty的内存回收分为两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Pooled 池化的内存，放入可以重新分配的 ByteBuf 池子，等待下一次分配。&lt;/li&gt;
&lt;li&gt;Unpooled 未池化的 ByteBuf 内存，确保GC 可达，确保 能被 JVM 的 GC 回收器回收到。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;bytebuf-的浅层复制&quot;&gt;ByteBuf 的浅层复制&lt;/h2&gt;
&lt;p&gt;ByteBuf 的浅层复制分为两种，有切片slice 浅层复制，和duplicate 浅层复制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118220155569.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;slice-切片浅层复制&quot;&gt;slice 切片浅层复制&lt;/h4&gt;
&lt;p&gt;​ 首先说明一下，这是一种非常重要的操作。&lt;strong&gt;可以很大程度的避免内存拷贝&lt;/strong&gt;。这一点，对于大规模消息通讯来说，是非常重要的。&lt;/p&gt;
&lt;p&gt;​ slice 操作可以获取到一个 ByteBuf 的一个切片。一个ByteBuf，可以进行多次的切片操作，多个切片可以共享一个存储区域的 ByteBuf 对象。&lt;/p&gt;
&lt;p&gt;​ slice 操作方法有两个重载版本：&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li&gt;public ByteBuf slice();&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;public ByteBuf slice(int index, int length);&lt;/p&gt;
&lt;p&gt;两个版本有非常紧密的联系。&lt;br/&gt;不带参数的 slice 方法，等同于 buf.slice(buf.readerIndex(), buf.readableBytes()) 调用, 即返回 ByteBuf 实例中可读部分的切片。&lt;br/&gt;而带参数 slice(int index, int length) 方法，可以通过灵活的设置不同的参数，来获取到 buf 的不同区域的切片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用slice（）方法后，返回的 ByteBuf 的切片，大致如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181118220215891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NyYXp5bWFrZXJjaXJjbGU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用slice（）方法后，返回的ByteBuf 切片的属性，大致如下：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;slice 的 readerIndex（读指针）的值为 0&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;slice 的 writerIndex（写指针） 的 值为源Bytebuf的 readableBytes() 可读字节数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;slice 的 maxCapacity（最大容量） 的值为源Bytebuf的 readableBytes() 可读字节数。maxCapacity 与 writerIndex 值相同，切片不可以写。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;切片的可读字节数，为自己的 writerIndex - readerIndex。所有，切片和源Bytebuf的 readableBytes() 可读字节数相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;也就是说，切片可读，不可写。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;slice（）切片和原ByteBuf的联系&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;切片不会拷贝原ByteBuf底层数据，底层数组和原ByteBuf的底层数组是同一个&lt;/li&gt;
&lt;li&gt;切片不会改变原 ByteBuf 的引用计数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;根本上，调用slice（）方法生成的切片，是 源Bytebuf 可读部分的浅层复制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面的例子展示了 ByteBuf.slice 方法的演示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void testSlice() {
    ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(9, 100);
    print(&quot;allocate ByteBuf(9, 100)&quot;, buffer);

    buffer.writeBytes(new byte[]{1, 2, 3, 4});
    print(&quot;writeBytes(1,2,3,4)&quot;, buffer);

    ByteBuf buffer1= buffer.slice();
    print(&quot;buffer slice&quot;, buffer1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;after ===========allocate ByteBuf(9, 100)============
capacity(): 9
maxCapacity(): 100
readerIndex(): 0
readableBytes(): 0
isReadable(): false
writerIndex(): 0
writableBytes(): 9
isWritable(): true
maxWritableBytes(): 100

after ===========writeBytes(1,2,3,4)============
capacity(): 9
maxCapacity(): 100
readerIndex(): 0
readableBytes(): 4
isReadable(): true
writerIndex(): 4
writableBytes(): 5
isWritable(): true
maxWritableBytes(): 96

after ===========buffer slice============
capacity(): 4
maxCapacity(): 4
readerIndex(): 0
readableBytes(): 4
isReadable(): true
writerIndex(): 4
writableBytes(): 0
isWritable(): false
maxWritableBytes(): 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;duplicate-浅层复制&quot;&gt;duplicate() 浅层复制&lt;/h4&gt;
&lt;p&gt;duplicate() 返回的是源ByteBuf 的整个对象的一个浅层复制，包括如下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;duplicate() 会创建自己的读写指针，但是值与源ByteBuf 的读写指针相同；&lt;/li&gt;
&lt;li&gt;duplicate() 不会改变源 ByteBuf 的引用计数&lt;/li&gt;
&lt;li&gt;duplicate() 不会拷贝 源ByteBuf 的底层数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;duplicate() 和slice() 方法，都是浅层复制。不同的是，slice() 方法是切取一段的浅层复制，duplicate() 是整个的浅层复制。&lt;/p&gt;
&lt;h4 id=&quot;浅层复制的问题&quot;&gt;浅层复制的问题&lt;/h4&gt;
&lt;p&gt;​ 浅层复制方法不会拷贝数据，也不会改变 ByteBuf 的引用计数，这就会导致一个问题。&lt;/p&gt;
&lt;p&gt;​ 在源 ByteBuf 调用 release() 之后，引用计数为零，变得不能访问。这个时候，源 ByteBuf 的浅层复制实例，也不能进行读写。如果再对浅层复制实例进行读写，就会报错。&lt;/p&gt;
&lt;p&gt;​ 因此，在调用浅层复制实例时，可以通过调用一次 retain() 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在浅层复制实例用完后，需要调用两次 release() 方法，将引用计数减一，不影响源ByteBuf的内存释放。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;​ 至此为止，终于完成ByteBuf的具体使用B介绍。&lt;/p&gt;
&lt;p&gt;​ 如果想知道ByteBuf的分配、释放， 请看：&lt;/p&gt;
&lt;p&gt;​ &lt;a href=&quot;https://blog.csdn.net/crazymakercircle/article/details/84198042&quot;&gt;第一篇：ByteBuf的分配、释放和如何避免内存泄露&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;疯狂创客圈-java-死磕系列&quot;&gt;疯狂创客圈 Java 死磕系列&lt;/h2&gt;
&lt;ul readability=&quot;-0.85082872928177&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Java (Netty) 聊天程序【 亿级流量】实战 开源项目实战&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Netty 源码、原理、JAVA NIO 原理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Java 面试题 一网打尽&lt;/strong&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.37209302325581&quot;&gt;
&lt;p&gt;疯狂创客圈 &lt;a href=&quot;https://www.cnblogs.com/crazymakercircle/p/9904544.html&quot;&gt;&lt;strong&gt;【 博客园 总入口 】&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;</description>
<pubDate>Sun, 18 Nov 2018 14:08:00 +0000</pubDate>
<dc:creator>疯狂创客圈</dc:creator>
<og:description>Netty ByteBuf（图解二）：API 图解 疯狂创客圈 Java 分布式聊天室【 亿级流量】实战系列之16 【 博客园 总入口 】 [toc] 源码工程 源码IDEA工程获取链接 ：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crazymakercircle/p/9979897.html</dc:identifier>
</item>
<item>
<title>O(n*logn)级别的算法之一（归并排序及其优化） - Tom-shushu</title>
<link>http://www.cnblogs.com/Tom-shushu/p/9978413.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tom-shushu/p/9978413.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;原理：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设两个有序的子序列(相当于输入序列)放在同一序列中相邻的位置上：array[low..m]，array[m + 1..high]，先将它们合并到一个局部的暂存序列 temp (相当于输出序列)中，待合并完成后将 temp 复制回 array[low..high]中，从而完成排序。&lt;/p&gt;
&lt;p&gt;在具体的合并过程中，设置 i，j 和 p 三个指针，其初值分别指向这三个记录区的起始位置。合并时依次比较 array[i] 和 array[j] 的关键字，取关键字较小（或较大）的记录复制到 temp[p] 中，然后将被复制记录的指针 i 或 j 加 1，以及指向复制位置的指针 p加 1。重复这一过程直至两个输入的子序列有一个已全部复制完毕(不妨称其为空)，此时将另一非空的子序列中剩余记录依次复制到 array 中即可&lt;/p&gt;
&lt;p&gt;备注：图片原理来源：https://blog.csdn.net/yinjiabin/article/details/8265827/&lt;/p&gt;
&lt;h2&gt;待排序列(14,12,15,13,11,16)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;假设我们有一个没有排好序的序列，那么首先我们使用分割的办法将这个序列分割成一个个已经排好序的子序列。然后再利用归并的方法将一个个的子序列合并成排序好的序列。分割和归并的过程可以看下面的图例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398504/201811/1398504-20181118215420723-472178848.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先&quot;分割&quot;再&quot;合并&quot;&lt;/p&gt;
&lt;p&gt;从上图可以看出，我们首先把一个未排序的序列从中间分割成2部分，再把2部分分成4部分，依次分割下去，直到分割成一个一个的数据，再把这些数据两两归并到一起，使之有序，不停的归并，最后成为一个排好序的序列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398504/201811/1398504-20181118215612352-1791725896.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;测试用例：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef INC_02_MERGE_SORT_SORTTESTHELPER_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; INC_02_MERGE_SORT_SORTTESTHELPER_H&lt;span&gt;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;ctime&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cassert&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; SortTestHelper {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; *generateRandomArray(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; range_l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; range_r) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
        srand(time(NULL));
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            arr[i] &lt;/span&gt;= rand() % (range_r - range_l + &lt;span&gt;1&lt;/span&gt;) +&lt;span&gt; range_l;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个近乎有序的数组
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先生成一个含有[0...n-1]的完全有序数组, 之后随机交换swapTimes对数据
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; swapTimes定义了数组的无序程度&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; *generateNearlyOrderedArray(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; swapTimes){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; n ; i ++&lt;span&gt; )
            arr[i] &lt;/span&gt;=&lt;span&gt; i;
        srand(time(NULL));
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; swapTimes ; i ++&lt;span&gt; ){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; posx = rand()%&lt;span&gt;n;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; posy = rand()%&lt;span&gt;n;
            swap( arr[posx] , arr[posy] );
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拷贝整型数组a中的所有元素到一个新的数组, 并返回新的数组&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; *copyIntArray(&lt;span&gt;int&lt;/span&gt; a[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[n];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;* 在VS中, copy函数被认为是不安全的, 请大家手动写一遍for循环:)&lt;/span&gt;
        copy(a, a+&lt;span&gt;n, arr);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印arr数组的所有内容&lt;/span&gt;
    template&amp;lt;typename T&amp;gt;
    &lt;span&gt;void&lt;/span&gt; printArray(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;)
            cout &lt;/span&gt;&amp;lt;&amp;lt; arr[i] &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        cout &lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断arr数组是否有序&lt;/span&gt;
    template&amp;lt;typename T&amp;gt;
    &lt;span&gt;bool&lt;/span&gt; isSorted(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n - &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (arr[i] &amp;gt; arr[i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试sort排序算法排序arr数组所得到结果的正确性和算法运行时间&lt;/span&gt;
    template&amp;lt;typename T&amp;gt;
    &lt;span&gt;void&lt;/span&gt; testSort(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &amp;amp;sortName, &lt;span&gt;void&lt;/span&gt; (*sort)(T[], &lt;span&gt;int&lt;/span&gt;), T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
        clock_t startTime &lt;/span&gt;=&lt;span&gt; clock();
        sort(arr, n);
        clock_t endTime &lt;/span&gt;=&lt;span&gt; clock();
        cout &lt;/span&gt;&amp;lt;&amp;lt; sortName &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;double&lt;/span&gt;(endTime - startTime) / CLOCKS_PER_SEC &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
        assert(isSorted(arr, n));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
};
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;INC_02_MERGE_SORT_SORTTESTHELPER_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;插入排序（因为等下优化时需要用到）：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef INC_03_MERGE_SORT_ADVANCE_INSERTIONSORT_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; INC_03_MERGE_SORT_ADVANCE_INSERTIONSORT_H&lt;span&gt;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
template&lt;/span&gt;&amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; insertionSort(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt; ; i &amp;lt; n ; i ++&lt;span&gt; ) {
        T e &lt;/span&gt;=&lt;span&gt; arr[i];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = i; j &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; arr[j-&lt;span&gt;1&lt;/span&gt;] &amp;gt; e; j--&lt;span&gt;)
            arr[j] &lt;/span&gt;= arr[j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        arr[j] &lt;/span&gt;=&lt;span&gt; e;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对arr[l...r]范围的数组进行插入排序&lt;/span&gt;
template&amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; insertionSort(T arr[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = l+&lt;span&gt;1&lt;/span&gt; ; i &amp;lt;= r ; i ++&lt;span&gt; ) {
        T e &lt;/span&gt;=&lt;span&gt; arr[i];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = i; j &amp;gt; l &amp;amp;&amp;amp; arr[j-&lt;span&gt;1&lt;/span&gt;] &amp;gt; e; j--&lt;span&gt;)
            arr[j] &lt;/span&gt;= arr[j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        arr[j] &lt;/span&gt;=&lt;span&gt; e;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;INC_03_MERGE_SORT_ADVANCE_INSERTIONSORT_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;一般归并排序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#ifndef INC_03_MERGE_SORT_ADVANCE_MERGESORT_H
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; INC_03_MERGE_SORT_ADVANCE_MERGESORT_H&lt;span&gt;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将arr[l...mid]和arr[mid+1...r]两部分进行归并&lt;/span&gt;
template&amp;lt;typename  T&amp;gt;
&lt;span&gt;void&lt;/span&gt; __merge(T arr[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; mid, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
    T aux[r&lt;/span&gt;-l+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; i = l ; i &amp;lt;= r; i ++&lt;span&gt; )
        aux[i&lt;/span&gt;-l] =&lt;span&gt; arr[i];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; i = l, j = mid+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;int&lt;/span&gt; k = l ; k &amp;lt;= r; k ++&lt;span&gt; ){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( i &amp;gt; mid ){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果左半部分元素已经全部处理完毕&lt;/span&gt;
            arr[k] = aux[j-l]; j ++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( j &amp;gt; r ){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果右半部分元素已经全部处理完毕&lt;/span&gt;
            arr[k] = aux[i-l]; i ++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( aux[i-l] &amp;lt; aux[j-l] ) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左半部分所指元素 &amp;lt; 右半部分所指元素&lt;/span&gt;
            arr[k] = aux[i-l]; i ++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左半部分所指元素 &amp;gt;= 右半部分所指元素&lt;/span&gt;
            arr[k] = aux[j-l]; j ++&lt;span&gt;;
        }
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递归使用归并排序,对arr[l...r]的范围进行排序&lt;/span&gt;
template&amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; __mergeSort(T arr[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( l &amp;gt;=&lt;span&gt; r )
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid = (l+r)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    __mergeSort(arr, l, mid);
    __mergeSort(arr, mid&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, r);
    __merge(arr, l, mid, r);
}
template&lt;/span&gt;&amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; mergeSort(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
    __mergeSort( arr , &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; , n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt; );
}
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;INC_03_MERGE_SORT_ADVANCE_MERGESORT_H&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;优化后的归并排序：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SortTestHelper.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;InsertionSort.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MergeSort.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用优化的归并排序算法, 对arr[l...r]的范围进行排序&lt;/span&gt;
template&amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; __mergeSort2(T arr[], &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; r){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 优化2: 对于小规模数组, 使用插入排序&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;( r - l &amp;lt;= &lt;span&gt;15&lt;/span&gt;&lt;span&gt; ){
        insertionSort(arr, l, r);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mid = (l+r)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    __mergeSort2(arr, l, mid);
    __mergeSort2(arr, mid&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, r);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 优化1: 对于arr[mid] &amp;lt;= arr[mid+1]的情况,不进行merge
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于近乎有序的数组非常有效,但是对于一般情况,有一定的性能损失&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;( arr[mid] &amp;gt; arr[mid+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;] )
        __merge(arr, l, mid, r);
}
template&lt;/span&gt;&amp;lt;typename T&amp;gt;
&lt;span&gt;void&lt;/span&gt; mergeSort2(T arr[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
    __mergeSort2( arr , &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; , n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt; );
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;50000&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试1 一般性测试&lt;/span&gt;
    cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test for random array, size = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, random range [0, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;* arr1 = SortTestHelper::generateRandomArray  (n,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,n);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;* arr2 =&lt;span&gt; SortTestHelper::copyIntArray(arr1, n);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;* arr3 =&lt;span&gt; SortTestHelper::copyIntArray(arr1, n);
    SortTestHelper::testSort(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Insertion Sort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, insertionSort, arr1, n);
    SortTestHelper::testSort(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Merge Sort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,     mergeSort,     arr2, n);
    SortTestHelper::testSort(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Merge Sort 2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,   mergeSort2,    arr3, n);
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] arr1;
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] arr2;
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] arr3;
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试2 测试近乎有序的数组&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; swapTimes = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
    assert( swapTimes &lt;/span&gt;&amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt; );
    cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test for nearly ordered array, size = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;n&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, swap time = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;swapTimes&amp;lt;&amp;lt;&lt;span&gt;endl;
    arr1 &lt;/span&gt;=&lt;span&gt; SortTestHelper::generateNearlyOrderedArray(n,swapTimes);
    arr2 &lt;/span&gt;=&lt;span&gt; SortTestHelper::copyIntArray(arr1, n);
    arr3 &lt;/span&gt;=&lt;span&gt; SortTestHelper::copyIntArray(arr1, n);
    SortTestHelper::testSort(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Insertion Sort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, insertionSort, arr1, n);
    SortTestHelper::testSort(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Merge Sort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,     mergeSort,     arr2, n);
    SortTestHelper::testSort(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Merge Sort 2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,   mergeSort2,    arr3, n);
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] arr1;
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] arr2;
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] arr3;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;测试结果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1398504/201811/1398504-20181118164949856-272648763.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 18 Nov 2018 14:02:00 +0000</pubDate>
<dc:creator>Tom-shushu</dc:creator>
<og:description>原理： 设两个有序的子序列(相当于输入序列)放在同一序列中相邻的位置上：array[low..m]，array[m + 1..high]，先将它们合并到一个局部的暂存序列 temp (相当于输出序列)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tom-shushu/p/9978413.html</dc:identifier>
</item>
</channel>
</rss>