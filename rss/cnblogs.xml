<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java代码查错 - 夏叶四夕Spring</title>
<link>http://www.cnblogs.com/everything-will-flowing/p/7682099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/everything-will-flowing/p/7682099.html</guid>
<description>&lt;p&gt;1.&lt;br/&gt;abstract class Name {&lt;br/&gt;   private String name;&lt;br/&gt;   public abstract boolean isStupidName(String name) {}&lt;br/&gt;}&lt;br/&gt;有何错误?&lt;br/&gt;-------------- &lt;span&gt;抽象类里的抽象方法没有方法体，以分号结尾&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2.&lt;br/&gt;public class Something {&lt;br/&gt;   void doSomething () {&lt;br/&gt;       private String s = &quot;&quot;;&lt;br/&gt;       int l = s.length();&lt;br/&gt;   }&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;--------------&lt;span&gt;方法内不能使用访问修饰符&lt;/span&gt;&lt;br/&gt;3.&lt;br/&gt;abstract class Something {&lt;br/&gt;   private abstract String doSomething ();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;---------------&lt;span&gt;private和abstract不能在一起用&lt;/span&gt;&lt;br/&gt;4.&lt;br/&gt;public class Something {&lt;br/&gt;   public int addOne(final int x) {&lt;br/&gt;       return ++x;&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;----------------&lt;span&gt;当final修饰的标量作为参数时，可以被应用一次，但是其值不能被改变&lt;/span&gt;&lt;/p&gt;&lt;p&gt;5.&lt;br/&gt;public class Something {&lt;br/&gt;   public static void main(String[] args) {&lt;br/&gt;       Other o = new Other();&lt;br/&gt;       new Something().addOne(o);&lt;br/&gt;   }&lt;br/&gt;   public void addOne(final Other o) {&lt;br/&gt;       o.i++;&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;class Other {&lt;br/&gt;   public int i;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;-----------------没错（&lt;span&gt;O的引用并没有变，只是调用他的属性&lt;/span&gt;）&lt;br/&gt;6.&lt;br/&gt;class Something {&lt;br/&gt;    int i;&lt;br/&gt;    public void doSomething() {&lt;br/&gt;        System.out.println(&quot;i = &quot; + i);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;有什么错呢?&lt;br/&gt;------------------没错，&lt;span&gt;成员变量有defaultValue;&lt;/span&gt;&lt;br/&gt;7.&lt;br/&gt;class Something {&lt;br/&gt;    final int i;&lt;br/&gt;    public void doSomething() {&lt;br/&gt;        System.out.println(&quot;i = &quot; + i);&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;-------------------&lt;span&gt;final修饰的成员变量没有defaultValues&lt;/span&gt;&lt;br/&gt;8.&lt;br/&gt;public class Something {&lt;br/&gt;     public static void main(String[] args) {&lt;br/&gt;        Something s = new Something();&lt;br/&gt;        System.out.println(&quot;s.doSomething() returns &quot; + doSomething());&lt;br/&gt;    }&lt;br/&gt;    public String doSomething() {&lt;br/&gt;        return &quot;Do something ...&quot;;&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;----------------------&lt;span&gt;main方法是static的，不能直接调用non-static方法&lt;/span&gt;&lt;br/&gt;9.&lt;br/&gt;此处，Something类的文件名叫OtherThing.java&lt;br/&gt;class Something {&lt;br/&gt;    private static void main(String[] something_to_do) {       &lt;br/&gt;        System.out.println(&quot;Do something ...&quot;);&lt;br/&gt;    }&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;----------------------没错，&lt;span&gt;非public的类名可以与文件名不一样&lt;/span&gt;&lt;br/&gt;10．&lt;br/&gt;interface  A{&lt;br/&gt;   int x = 0;&lt;br/&gt;}&lt;br/&gt;class B{&lt;br/&gt;   int x =1;&lt;br/&gt;}&lt;br/&gt;class C extends B implements A {&lt;br/&gt;   public void pX(){&lt;br/&gt;      System.out.println(x);&lt;br/&gt;   }&lt;br/&gt;   public static void main(String[] args) {&lt;br/&gt;      new C().pX();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;------------------------&lt;span&gt;-&lt;span&gt;调用不明确&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;11.&lt;br/&gt;interface Playable {&lt;br/&gt;    void play();&lt;br/&gt;}&lt;br/&gt;interface Bounceable {&lt;br/&gt;    void play();&lt;br/&gt;}&lt;br/&gt;interface Rollable extends Playable, Bounceable {&lt;br/&gt;    Ball ball = new Ball(&quot;PingPang&quot;);&lt;br/&gt;}&lt;br/&gt;class Ball implements Rollable {&lt;br/&gt;    private String name;&lt;br/&gt;    public String getName() {&lt;br/&gt;        return name;&lt;br/&gt;    }&lt;br/&gt;    public Ball(String name) {&lt;br/&gt;        this.name = name;       &lt;br/&gt;    }&lt;br/&gt;   public void play() {&lt;br/&gt;        ball = new Ball(&quot;Football&quot;);&lt;br/&gt;        System.out.println(ball.getName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;----------------------------&lt;span&gt;接口的成员变量默认为public static final，故  ball = new Ball(&quot;Football&quot;);改变了其引用，故错误&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Oct 2017 07:50:00 +0000</pubDate>
<dc:creator>夏叶四夕Spring</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/everything-will-flowing/p/7682099.html</dc:identifier>
</item>
<item>
<title>【源码】canal和otter的高可靠性分析 - 端木轩</title>
<link>http://www.cnblogs.com/f-zhao/p/7681960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-zhao/p/7681960.html</guid>
<description>[unable to retrieve full-text content]一般来说，我们对于数据库最主要的要求就是：数据不丢。不管是主从复制，还是使用类似otter+canal这样的数据库同步方案，我们最基本的需求是，在数据不丢失的前提下，尽可能的保证系统的高可用，也就是在某个节点挂掉，或者数据库发生主从切换等情况下，我们的数据同步系统依然能够发挥它的作用 数据同步。本文</description>
<pubDate>Tue, 17 Oct 2017 07:34:00 +0000</pubDate>
<dc:creator>端木轩</dc:creator>
<dc:identifier>http://www.cnblogs.com/f-zhao/p/7681960.html</dc:identifier>
</item>
<item>
<title>Android之View绘制流程源码分析 - WangLei_ClearHeart</title>
<link>http://www.cnblogs.com/leipDao/p/7573803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leipDao/p/7573803.html</guid>
<description>&lt;p&gt;&lt;span&gt;版权声明：本文出自汪磊的博客，转载请务必注明出处。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于稍有自定义View经验的安卓开发者来说，onMeasure，onLayout，onDraw这三个方法都不会陌生，起码多少都有所接触吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在安卓中，一个View显示到屏幕上基本上都是经过测量，摆放，绘制这三个过程才显示出来，那么这三个过程到底是怎么执行的呢？本文与大家一起探讨一下安卓中View的绘制流程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一，View树绘制流程开始的地方(API23)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对一个布局进项测量，摆放，绘制肯定要有开始的地方吧，这里就直接跟大家说了，View绘制流程开始的地方是ViewRootImpl类的performTraversals()方法（至于为什么是这里不是本篇重点，后续有时间写一篇针对这里的文章说明一下），接下来我们看下&lt;span&gt;performTraversals()&lt;/span&gt;方法（此方法过长，只列出重要逻辑代码）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 private void performTraversals() {
 2         ......
 3         int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
 4         int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
 5          ......
 6          // Ask host how big it wants to be
 7          performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
 8          ......
 9          performLayout(lp, desiredWindowWidth, desiredWindowHeight);
10          ......
11          performDraw();
12         ......
13      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 第3,4行代码调用&lt;span&gt;getRootMeasureSpec&lt;/span&gt;方法生成对应宽高，我们先看下&lt;span&gt;getRootMeasureSpec&lt;/span&gt;都做了什么，源码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1   /**
 2      * Figures out the measure spec for the root view in a window based on it's
 3      * layout params.
 4      *
 5      * @param windowSize
 6      *            The available width or height of the window
 7      *
 8      * @param rootDimension
 9      *            The layout params for one dimension (width or height) of the
10      *            window.
11      *
12      * @return The measure spec to use to measure the root view.
13      */
14     private static int getRootMeasureSpec(int windowSize, int rootDimension) {
15         int measureSpec;
16         switch (rootDimension) {
17 
18         case ViewGroup.LayoutParams.MATCH_PARENT:
19             // Window can't resize. Force root view to be windowSize.
20             measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
21             break;
22         case ViewGroup.LayoutParams.WRAP_CONTENT:
23             // Window can resize. Set max size for root view.
24             measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
25             break;
26         default:
27             // Window wants to be an exact size. Force root view to be that size.
28             measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
29             break;
30         }
31         return measureSpec;
32     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;先说一下&lt;span&gt;&lt;span&gt;MeasureSpec这个概念：也叫测量规格&lt;/span&gt;，&lt;span&gt;MeasureSpec是一个32位整数，由SpecMode和SpecSize两部分组成，其中，高2位为SpecMode，低30位为SpecSize。SpecMode为测量模式，SpecSize为相应测量模式下的测量尺寸。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;View（包括普通View和ViewGroup）的SpecMode由本View的LayoutParams结合父View的MeasureSpec生成(普通View的&lt;span&gt;&lt;span&gt;&lt;span&gt;MeasureSpec&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是由其父类ViewGroup生成的，后面会详细讲到)。&lt;br/&gt;SpecMode的取值可为以下三种：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;language-txt hljs cs has-numbering&quot;&gt; MeasureSpec.EXACTLY &lt;/code&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;getRootMeasureSpec方法就是生成根视图的&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;MeasureSpec&lt;/code&gt;，还记得我们上一篇《&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/leipDao/p/7509222.html&quot;&gt;&lt;span&gt;Android之View绘制流程开胃菜---setContentView(...)详细分析&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;》中分析的吗，平时我们自己写的布局都是被添加到DecorView中id为content的布局中的，&lt;/code&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;这里传入进来的windowSize参数是window的可用宽高信息，rootDimension宽高参数均为MATCH_PARENT。&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们上面说&lt;span&gt;&lt;span&gt;&lt;span&gt;普通View的&lt;span&gt;&lt;span&gt;&lt;span&gt;MeasureSpec是由其父类ViewGroup生成的，但是根视图&lt;span&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;DecorView是没有父类的，所以&lt;span&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;getRootMeasureSpec&lt;/code&gt;&lt;/span&gt;就是给根视图生成测量规格的，生成的&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;MeasureSpec中&lt;span&gt;&lt;span&gt;&lt;span&gt;SpecMode&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;为&lt;span&gt;&lt;code class=&quot;language-txt hljs cs has-numbering&quot;&gt;MeasureSpec.EXACTLY&lt;/code&gt;&lt;/span&gt;，&lt;span&gt;&lt;span&gt;&lt;span&gt;SpecSize&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;则为窗口的可用尺寸。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;回到&lt;span&gt;performTraversals()方法中：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3,4行代码分别生成宽高的测量规格&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;7,9,11行代码分别执行performMeasure(childWidthMeasureSpec, childHeightMeasureSpec)， performLayout(lp, desiredWindowWidth, desiredWindowHeight)，performDraw();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;方法，我们看下这三个方法源码：都经过简化处理&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {
2         Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);
3         try {
4             mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
5         } finally {
6             Trace.traceEnd(Trace.TRACE_TAG_VIEW);
7         }
8     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1    private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,
2             int desiredWindowHeight) {
3   
4         ...
5         final View host = mView;
6 
7         host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());
8        ...
9     }        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1     private void performDraw() {
2            ...
3             draw(fullRedrawNeeded);
4             ...
5     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 private void draw(boolean fullRedrawNeeded) {
2 
3           ...
4           if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) {
5              return;
6           }
7           ...
8     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1     private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,
2             boolean scalingRequired, Rect dirty) {
3         ...
4          mView.draw(canvas);
5         ...
6         return true;
7     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;performMeasure方法最核心的是第4行调用&lt;/span&gt;&lt;span&gt;mView的measure方法。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;performLayout方法通过5，7行代码发现其实也是调用的&lt;/span&gt;&lt;span&gt;mView的&lt;/span&gt;&lt;span&gt;layout方法。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;performDraw最终调用的也是调用的&lt;/span&gt;&lt;span&gt;mView的&lt;/span&gt;&lt;span&gt;draw方法。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;上面的mView就是DecorView，我们知道&lt;/span&gt;&lt;span&gt;DecorView是FrameLayout，&lt;span&gt;FrameLayout&lt;/span&gt;继承自ViewGroup，&lt;span&gt;ViewGroup&lt;/span&gt;继承自View,所以最终都会调用View类中&lt;span&gt;measure&lt;/span&gt;，&lt;br/&gt;layout&lt;/span&gt;，&lt;span&gt;draw方法。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;实际上View的绘制流程可以分为三个阶段:&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;measure: 判断是否需要重新计算View的大小，需要的话则计算；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;layout: 判断是否需要重新计算View的位置，需要的话则计算；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;draw: 判断是否需要重新绘制View，需要的话则重绘制。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;span&gt;大体流程如图:&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/794139/201710/794139-20171009163658965-221991207.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;二，View绘制流程第一步measure过程分析&lt;/strong&gt;&lt;span&gt;(API23)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;接下来我们看下View中的measure源码：简化处理&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1    /**
 2      * &amp;lt;p&amp;gt;
 3      * This is called to find out how big a view should be. The parent
 4      * supplies constraint information in the width and height parameters.
 5      * &amp;lt;/p&amp;gt;
 6      *
 7      * &amp;lt;p&amp;gt;
 8      * The actual measurement work of a view is performed in
 9      * {@link #onMeasure(int, int)}, called by this method. Therefore, only
10      * {@link #onMeasure(int, int)} can and must be overridden by subclasses.
11      * &amp;lt;/p&amp;gt;
12      *
13      *
14      * @param widthMeasureSpec Horizontal space requirements as imposed by the
15      *        parent
16      * @param heightMeasureSpec Vertical space requirements as imposed by the
17      *        parent
18      *
19      * @see #onMeasure(int, int)
20      */
21     public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
22         ...
23         // measure ourselves, this should set the measured dimension flag back
24         onMeasure(widthMeasureSpec, heightMeasureSpec);
25          ...
26     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注释已经给出大体描述：这个被调用用来测算出view大小，并且其父类提供了约束信息&lt;span&gt;widthMeasureSpec与heightMeasureSpec。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们发现measure方法被final修饰，所以这个方法不能被子类重写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际的测量是在onMeasure方法进行，所以在View的普通子类中需要重写onMeasure方法来实现自己的测量逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于普通View，调用View类的onMeasure()方法来进行实际的测量工作即可，当然我们也可以重载onMeasure并调用setMeasuredDimension来设置任意大小的布局。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们看下默认情况下View类中&lt;span&gt;onMeasure&lt;/span&gt;方法都做了什么，源码如下;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1     /**
 2      * &amp;lt;p&amp;gt;
 3      * Measure the view and its content to determine the measured width and the
 4      * measured height. This method is invoked by {@link #measure(int, int)} and
 5      * should be overridden by subclasses to provide accurate and efficient
 6      * measurement of their contents.
 7      * &amp;lt;/p&amp;gt;
 8      *
 9      * &amp;lt;p&amp;gt;
10      * &amp;lt;strong&amp;gt;CONTRACT:&amp;lt;/strong&amp;gt; When overriding this method, you
11      * &amp;lt;em&amp;gt;must&amp;lt;/em&amp;gt; call {@link #setMeasuredDimension(int, int)} to store the
12      * measured width and height of this view. Failure to do so will trigger an
13      * &amp;lt;code&amp;gt;IllegalStateException&amp;lt;/code&amp;gt;, thrown by
14      * {@link #measure(int, int)}. Calling the superclass'
15      * {@link #onMeasure(int, int)} is a valid use.
16      * &amp;lt;/p&amp;gt;
17      *
18      * &amp;lt;p&amp;gt;
19      * The base class implementation of measure defaults to the background size,
20      * unless a larger size is allowed by the MeasureSpec. Subclasses should
21      * override {@link #onMeasure(int, int)} to provide better measurements of
22      * their content.
23      * &amp;lt;/p&amp;gt;
24      *
25      * &amp;lt;p&amp;gt;
26      * If this method is overridden, it is the subclass's responsibility to make
27      * sure the measured height and width are at least the view's minimum height
28      * and width ({@link #getSuggestedMinimumHeight()} and
29      * {@link #getSuggestedMinimumWidth()}).
30      * &amp;lt;/p&amp;gt;
31      *
32      * @param widthMeasureSpec horizontal space requirements as imposed by the parent.
33      *                         The requirements are encoded with
34      *                         {@link android.view.View.MeasureSpec}.
35      * @param heightMeasureSpec vertical space requirements as imposed by the parent.
36      *                         The requirements are encoded with
37      *                         {@link android.view.View.MeasureSpec}.
38      *
39      * @see #getMeasuredWidth()
40      * @see #getMeasuredHeight()
41      * @see #setMeasuredDimension(int, int)
42      * @see #getSuggestedMinimumHeight()
43      * @see #getSuggestedMinimumWidth()
44      * @see android.view.View.MeasureSpec#getMode(int)
45      * @see android.view.View.MeasureSpec#getSize(int)
46      */
47     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
48         setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),
49                 getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));
50     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-title&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;我们看到系统默认的onMeasure方法只是直接调用了setMeasuredDimension，setMeasuredDimension函数是一个很关键的函数，它对View的成员变量mMeasuredWidth和mMeasuredHeight变量赋值，measure的主要目的就是对View树中的每个View的mMeasuredWidth和mMeasuredHeight进行赋值，所以一旦这两个变量被赋值意味着该View的测量工作结束。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们看看设置的默认View宽高，默认宽高都是通过getDefaultSize方法来获取的，而getDefaultSize又调用了getSuggestedMinimumXXX方法，我们先看下getSuggestedMinimumXXX方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 protected int getSuggestedMinimumHeight() {
2         return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());
3 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 protected int getSuggestedMinimumWidth() {
2         return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());
3 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;mMinHeight或&lt;/span&gt;&lt;span&gt;&lt;span&gt;mMinWidth就是我们设置的android:minHeight或android:minWidth参数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果我们没有设置背景则直接返回mMinHeight或mMinWidth，如果设置了背景，则返回miniXXX属性与&lt;/span&gt;&lt;span&gt;&lt;span&gt;mBackground二者中较大者。如背景以及miniXXX属性都没设置呢？那就返回0了。&lt;br/&gt;接下来再看getDefaultSize方法源码：&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 public static int getDefaultSize(int size, int measureSpec) {
 2         int result = size;
 3         int specMode = MeasureSpec.getMode(measureSpec);
 4         int specSize = MeasureSpec.getSize(measureSpec);
 5 
 6         switch (specMode) {
 7         case MeasureSpec.UNSPECIFIED:
 8             result = size;
 9             break;
10         case MeasureSpec.AT_MOST:
11         case MeasureSpec.EXACTLY:
12             result = specSize;
13             break;
14         }
15         return result;
16 }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;getDefaultSize返回值由上面讲到的&lt;span&gt;&lt;span&gt;&lt;span&gt;getSuggestedMinimumXXX&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;方法获取的Size以及父类传递过来的&lt;span&gt;measureSpec共同决定。&lt;br/&gt;&lt;span&gt;可以看到如果specMode等于AT_MOST或EXACTLY就返回specSize，这也是系统默认的规格。&lt;br/&gt;到此为止，普通View(非ViewGroup)的测量就基本讲完了。但是&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;ViewGroup&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;这种容器类布局是怎么测量其内每个子View的呢？&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;ViewGroup容器类布局大部分情况下是用来嵌套具体子View的，所以需要负责其子View的测量，在ViewGroup中定义了&lt;br/&gt;measureChildren(int widthMeasureSpec, int heightMeasureSpec)&lt;br/&gt;measureChild(View child, int parentWidthMeasureSpec,int parentHeightMeasureSpec)&lt;br/&gt;以及measureChildWithMargins(View child,int parentWidthMeasureSpec, int widthUsed,int parentHeightMeasureSpec, int heightUsed)&lt;br/&gt;三个方法来供其子类调用对具体子View进行测量。&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;measureChildren&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;measureChild&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;源码如下：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {
 2         final int size = mChildrenCount;
 3         final View[] children = mChildren;
 4         for (int i = 0; i &amp;lt; size; ++i) {
 5             final View child = children[i];
 6             if ((child.mViewFlags &amp;amp; VISIBILITY_MASK) != GONE) {
 7                 measureChild(child, widthMeasureSpec, heightMeasureSpec);
 8             }
 9         }
10}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 protected void measureChild(View child, int parentWidthMeasureSpec,
 2             int parentHeightMeasureSpec) {
 3         final LayoutParams lp = child.getLayoutParams();
 4 
 5         final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
 6                 mPaddingLeft + mPaddingRight, lp.width);
 7         final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
 8                 mPaddingTop + mPaddingBottom, lp.height);
 9 
10         child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
11}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看到了吧，measureChildren只是循环调用&lt;span&gt;measureChild&lt;/span&gt;方法，而&lt;span&gt;&lt;span&gt;measureChild方法中会根据父类提供的测量规格&lt;span&gt;parentXXXMeasureSpec一级子类自己&lt;span&gt;LayoutParams&lt;/span&gt;调用&lt;span&gt;getChildMeasureSpec&lt;/span&gt;方法生成子类自己具体的测量规格。(&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;getChildMeasureSpec&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;稍后会具体分析)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来我们看下measureChildWithMargins方法源码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 protected void measureChildWithMargins(View child,
 2             int parentWidthMeasureSpec, int widthUsed,
 3             int parentHeightMeasureSpec, int heightUsed) {
 4         final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();
 5 
 6         final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
 7                 mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin
 8                         + widthUsed, lp.width);
 9         final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
10                 mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin
11                         + heightUsed, lp.height);
12 
13         child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
14 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;language-java hljs has-numbering&quot;&gt;与measureChild相比最主要的区别就是&lt;span&gt;measureChildWithMargins额外将具体子View &lt;span&gt;LayoutParams&lt;/span&gt;参数的margin也当作参数来生成测量规格。&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;measureChild与measureChildWithMargins均调用了&lt;span&gt;getChildMeasureSpec&lt;/span&gt;方法来生成具体测量规格，接下来我们重点看下这个方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1     public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
 2         int specMode = MeasureSpec.getMode(spec);//获取父View的mode 3         int specSize = MeasureSpec.getSize(spec);&lt;span&gt;//获取父View的size&lt;/span&gt;
 4 　　　　 //&lt;span&gt;&lt;span&gt;父View的size减去&lt;span&gt;padding&lt;/span&gt;与0比较取其大，&lt;span&gt;specSize - padding&lt;/span&gt;得到的值是父View可以用来盛放子View的空间大小&lt;/span&gt;&lt;/span&gt;
 5         int size = Math.max(0, specSize - padding);
 6 
 7         int resultSize = 0;
 8         int resultMode = 0;
 9 
10         switch (specMode) {
11         // Parent has imposed an exact size on us
12         case MeasureSpec.EXACTLY://父View希望子View是明确大小
13             if (childDimension &amp;gt;= 0) {//&lt;span&gt;子View&lt;/span&gt;设置了明确的大小：如 10dp,20dp
14                 resultSize = childDimension;//设置子View&lt;span&gt;&lt;span&gt;测量规格&lt;/span&gt;&lt;/span&gt;大小为其本身设置的大小
15                 resultMode = MeasureSpec.EXACTLY;//mode设置为&lt;span&gt;EXACTLY&lt;/span&gt;
16             } else if (childDimension == LayoutParams.MATCH_PARENT) {//子VIEW的宽或者高设置为&lt;span&gt;MATCH_PARENT&lt;/span&gt;，表明子View想和父View一样大小
17                 // Child wants to be our size. So be it.
18                 resultSize = size;//&lt;span&gt;设置子View测量规格大小为父View可用空间的大小&lt;/span&gt;
19                 resultMode = MeasureSpec.EXACTLY;&lt;span&gt;//mode设置为&lt;span&gt;EXACTLY&lt;/span&gt;&lt;/span&gt;
20             } else if (childDimension == LayoutParams.WRAP_CONTENT) {&lt;span&gt;//子VIEW的宽或者高设置为&lt;span&gt;&lt;span&gt;WRAP_CONTENT&lt;/span&gt;，表明子View大小是动态的&lt;/span&gt;&lt;/span&gt;
21                 // Child wants to determine its own size. It can't be
22                 // bigger than us.
23                 resultSize = size;&lt;span&gt;//&lt;span&gt;设置子View&lt;span&gt;&lt;span&gt;测量规格&lt;/span&gt;&lt;/span&gt;大小为父View可用空间的大小&lt;/span&gt;&lt;/span&gt;
24                 resultMode = MeasureSpec.AT_MOST;&lt;span&gt;&lt;span&gt;//mode设置为&lt;span&gt;AT_MOST，表明子View宽高最大值不能超过&lt;span&gt;resultSize &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
25             }
26             break;27 　　　　　//其余情况请自行分析
28         ......&lt;br/&gt;29         return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
30     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;想说的注释已经给出。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的方法展现了根据父View的MeasureSpec和子View的LayoutParams生成子View的MeasureSpec的过程， 子View的LayoutParams表示了子View的期待大小。这个产生的MeasureSpec用于指导子View自身的测量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在我们自定义View的时候一般会重写onMeasure(int widthMeasureSpec, int heightMeasureSpec)方法其中的&lt;span&gt;widthMeasureSpec&lt;/span&gt;与&lt;span&gt;heightMeasureSpec&lt;/span&gt;参数就是父类通过&lt;span&gt;getChildMeasureSpec方法生成的。一个好的自定义View会根据父类传递过来的测量规格动态设置大小，而不是直接写死其大小。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;好了，到此为止View的测量过程想说的就差不多都说完了，我们稍微总结一下关键的部分;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;View的measure方法是final的，不允许重载，View子类只能重载onMeasure来完成自己的测量逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;最顶层DecorView测量时的MeasureSpec是由ViewRootImpl中getRootMeasureSpec方法确定的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;ViewGroup类提供了measureChild，measureChild和measureChildWithMargins方法，以供容器类布局测量自身子View使用&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;使用View的getMeasuredWidth()和getMeasuredHeight()方法来获取View测量的宽高，必须保证这两个方法在onMeasure流程之后被调用才能返回有效值，只有&lt;span&gt;onMeasure&lt;/span&gt;流程完后mMeasuredWidth与mMeasuredHeight才会被赋值&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;View的布局大小是由父View和子View共同决定的。我们平时设置的宽高可以理解为希望的大小，具体大小还要结合父类大小来确定。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;


&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;strong&gt;三，View绘制流程第二步layout过程分析&lt;/strong&gt;&lt;span&gt;(API23)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;performMeasure执行完，接着就会执行performLayout：&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1    private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,
2             int desiredWindowHeight) {
3   
4         ...
5         final View host = mView;
6 
7         host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());
8        ...
9     }&lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;mView为根View，即DecorView,&lt;span&gt;DecorView&lt;/span&gt;是FrameLayout的子类，最终会调用ViewGroup中layout方法。&lt;br/&gt;所以接下来我们看下&lt;span&gt;ViewGroup中layout方法源码：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 @Override
 2     public final void layout(int l, int t, int r, int b) {
 3         if (!mSuppressLayout &amp;amp;&amp;amp; (mTransition == null || !mTransition.isChangingLayout())) {
 4             if (mTransition != null) {
 5                 mTransition.layoutChange(this);
 6             }
 7             super.layout(l, t, r, b);
 8         } else {
 9             // record the fact that we noop'd it; request layout when transition finishes
10             mLayoutCalledWhileSuppressed = true;
11         }
12     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 第7行代码表明又调用父类View的&lt;span&gt;layout方法。所以我们看下View的layout源码，如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1     public void layout(int l, int t, int r, int b) {
2　　　　　&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;span/&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;java spaces&quot;&gt;　　　　　 &lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;
3　　　　　...
4         boolean changed = isLayoutModeOptical(mParent) ?
5                 setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);
6 
7         if (changed || (mPrivateFlags &amp;amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) {
8             onLayout(changed, l, t, r, b);
9   　　 ...
10     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4,5行代码主要判断View的位置是否发生变化，发生变化则changed 会为true,并且setOpticalFrame也是调用的setFrame方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看下setFrame方法源码:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 protected boolean setFrame(int left, int top, int right, int bottom) {
 2         boolean changed = false;
 3 
 4 
 5 　　　　 ...
 6         if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
 7             changed = true;
 8     
 9             ...
10             mLeft = left;
11             mTop = top;
12             mRight = right;
13             mBottom = bottom;
14 　　　　 ...
15         }
16         return changed;
17     }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 　　 public final int getMeasuredWidth() {
 2         return mMeasuredWidth &amp;amp; MEASURED_SIZE_MASK;
 3     }
 4 
 5     public final int getMeasuredHeight() {
 6         return mMeasuredHeight &amp;amp; MEASURED_SIZE_MASK;
 7     }
 8 
 9     public final int getWidth() {
10         return mRight - mLeft;
11     }
12 
13     public final int getHeight() {
14         return mBottom - mTop;
15     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在讨论View的measure过程时提到过mMeasuredWidth与&lt;span&gt;mMeasuredHeight只有测量过程完成才会被赋值，所以只有测量过程完成调用&lt;span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-title&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
2     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 /**
2      * {@inheritDoc}
3      */
4     @Override
5     protected abstract void onLayout(boolean changed,
6             int l, int t, int r, int b);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1     @Override
 2     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
 3         layoutChildren(left, top, right, bottom, false /* no force left gravity */);
 4     }
 5 
 6     void layoutChildren(int left, int top, int right, int bottom,
 7                                   boolean forceLeftGravity) {
 8         final int count = getChildCount();
 9 
10         ......
11 
12         for (int i = 0; i &amp;lt; count; i++) {
13             final View child = getChildAt(i);
14             if (child.getVisibility() != GONE) {
15                .....
16 
17                 child.layout(childLeft, childTop, childLeft + width, childTop + height);
18             }
19         }
20     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;View.layout方法可被重载，ViewGroup.layout为final的不可重载，ViewGroup.onLayout为abstract的，具体&lt;span&gt;ViewGroup&lt;/span&gt;子类必须重载来按照自己规则对子View进行摆放。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;measure操作完成后得到的是对每个View经测量过的measuredWidth和measuredHeight，layout操作完成之后得到的是对每个View进行位置分配后的mLeft、mTop、mRight、mBottom，这些值都是相对于父View来说的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;使用View的getWidth()和getHeight()方法来获取View测量的宽高，必须保证这两个方法在onLayout流程之后被调用才能返回有效值。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;四，View绘制流程第三步draw过程分析&lt;/strong&gt;&lt;span&gt;(API23)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;performMeasure, performLayout过程执行完，接下来就执行performDraw()逻辑了，ViewGroup没有重写View的draw方法，最终调用的是View中的draw方法，源码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1    public void draw(Canvas canvas) {
        final int privateFlags = mPrivateFlags;&lt;br/&gt;2    final boolean dirtyOpaque = (privateFlags &amp;amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;amp;&amp;amp;&lt;br/&gt;(mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
 3 
 4         /*
 5          * Draw traversal performs several drawing steps which must be executed
 6          * in the appropriate order:
 7          *
 8          *      1. Draw the background
 9          *      2. If necessary, save the canvas' layers to prepare for fading
10          *      3. Draw view's content
11          *      4. Draw children
12          *      5. If necessary, draw the fading edges and restore layers
13          *      6. Draw decorations (scrollbars for instance)
14          */
15 
16         // Step 1, draw the background, if needed
17         int saveCount;
18 
19         if (!dirtyOpaque) {
20             drawBackground(canvas);
21         }
22         
23         // skip step 2 &amp;amp; 5 if possible (common case)
24         final int viewFlags = mViewFlags;
25         boolean horizontalEdges = (viewFlags &amp;amp; FADING_EDGE_HORIZONTAL) != 0;
26         boolean verticalEdges = (viewFlags &amp;amp; FADING_EDGE_VERTICAL) != 0;
27         if (!verticalEdges &amp;amp;&amp;amp; !horizontalEdges) {
28             // Step 3, draw the content
29             if (!dirtyOpaque) onDraw(canvas);
30 
31             // Step 4, draw the children
32             dispatchDraw(canvas);
33 
34             // Overlay is part of the content and draws beneath Foreground
35             if (mOverlay != null &amp;amp;&amp;amp; !mOverlay.isEmpty()) {
36                 mOverlay.getOverlayView().dispatchDraw(canvas);
37             }
38 
39             // Step 6, draw decorations (foreground, scrollbars)
40             onDrawForeground(canvas);
41 
42             // we're done...
43             return;
44         }
45         ...
46         // Step 2, save the canvas' layers
47         ....
48         // Step 3, draw the content
49         if (!dirtyOpaque) onDraw(canvas);
50 
51         // Step 4, draw the children
52         dispatchDraw(canvas);
53 
54         // Step 5, draw the fade effect and restore layers
55         ....
56         // Step 6, draw decorations (foreground, scrollbars)
57         onDrawForeground(canvas);
58     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;5到14行注释可以看到draw过程分为6&lt;span&gt;步&lt;/span&gt;，再看23行提示大部分情况下跳过第2,5&lt;span&gt;步&lt;/span&gt;。所以我们着重分析其余4步。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;19-21行执行第一步，绘制背景源码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 private void drawBackground(Canvas canvas) {
 2         final Drawable background = mBackground;
 3         if (background == null) {
 4             return;
 5         }
 6 　　　　 ....
 7         setBackgroundBounds();
 8         ....
 9         background.draw(canvas);
10        
11     }
12 
13 
14     void setBackgroundBounds() {
15         if (mBackgroundSizeChanged &amp;amp;&amp;amp; mBackground != null) {
16             mBackground.setBounds(0, 0,  mRight - mLeft, mBottom - mTop);
17             mBackgroundSizeChanged = false;
18             rebuildOutline();
19         }
20     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;只要逻辑就是获取我们在xml文件或者代码中设置的背景，然后根据layout过程摆放的位置绘制出来。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;第29行执行绘制内容逻辑，源码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1     /**
2      * Implement this to do your drawing.
3      *
4      * @param canvas the canvas on which the background will be drawn
5      */
6     protected void onDraw(Canvas canvas) {
7     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看到了吧，是一个空方法，需要具体子类自己去实现，因为每个具体View要绘制的内容是不同的,所以子类需要实现这个方法来绘制自身的内容。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 /**
2      * Called by draw to draw the child views. This may be overridden
3      * by derived classes to gain control just before its children are drawn
4      * (but after its own view has been drawn).
5      * @param canvas the canvas on which to draw the view
6      */
7     protected void dispatchDraw(Canvas canvas) {
8 
9     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1  @Override
 2     protected void dispatchDraw(Canvas canvas) {
 3         boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
 4         final int childrenCount = mChildrenCount;
 5         final View[] children = mChildren;
 6         .......
 7         for (int i = 0; i &amp;lt; childrenCount; i++) {
 8             while (transientIndex &amp;gt;= 0 &amp;amp;&amp;amp; mTransientIndices.get(transientIndex) == i) {
 9                 final View transientChild = mTransientViews.get(transientIndex);
10                 if ((transientChild.mViewFlags &amp;amp; VISIBILITY_MASK) == VISIBLE ||
11                         transientChild.getAnimation() != null) {
12                     more |= drawChild(canvas, transientChild, drawingTime);
13                 }
14                 .......
15             }
16           ......
17         }
18         ......   
19     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
2         return child.draw(canvas, this, drawingTime);
3 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 private void initViewGroup() {
2         // ViewGroup doesn't draw by default
3         if (!debugDraw()) {
4             setFlags(WILL_NOT_DRAW, DRAW_MASK);
5         }
6         ......
7 }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1  final int privateFlags = mPrivateFlags;&lt;br/&gt;2  final boolean dirtyOpaque = (privateFlags &amp;amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;amp;&amp;amp;
3      (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &amp;lt;com.wanglei.clearheart.MyView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
 2     xmlns:tools=&quot;http://schemas.android.com/tools&quot;
 3     android:layout_width=&quot;match_parent&quot;
 4     android:layout_height=&quot;match_parent&quot;
 5     android:gravity=&quot;center&quot;
 6     android:orientation=&quot;vertical&quot;
 7     tools:context=&quot;.MainActivity&quot; &amp;gt;
 8 
 9 
10 &amp;lt;/com.wanglei.clearheart.MyView &amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;MyView源码如下：同样极其简单&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 public class MyView extends ViewGroup {
 2 
 3     private Paint mPaint;
 4     public MyView(Context context, AttributeSet attrs) {
 5         super(context, attrs);
 6         mPaint = new Paint();
 7         mPaint.setColor(Color.RED);
 8         mPaint.setStyle(Style.STROKE);
 9         mPaint.setStrokeWidth(10); 
10         
11     }
12     
13     @Override
14     protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
15         
16         super.onMeasure(widthMeasureSpec, heightMeasureSpec);
17     }
18     
19     @Override
20     protected void onLayout(boolean changed, int l, int t, int r, int b) {
21         // TODO Auto-generated method stub
22         
23     }
24     
25     @Override
26     protected void onDraw(Canvas canvas) {
27         // TODO Auto-generated method stub
28         canvas.drawCircle(getMeasuredWidth()/2, getMeasuredHeight()/2, 360, mPaint);
29     }
30 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1     public void setWillNotDraw(boolean willNotDraw) {
2         setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);
3     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 public MyView(Context context, AttributeSet attrs) {
2         super(context, attrs);
3         mPaint = new Paint();
4         mPaint.setColor(Color.RED);
5         mPaint.setStyle(Style.STROKE);
6         mPaint.setStrokeWidth(10); 
7         setWillNotDraw(false);
8         
9 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;






&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 17 Oct 2017 07:17:00 +0000</pubDate>
<dc:creator>WangLei_ClearHeart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leipDao/p/7573803.html</dc:identifier>
</item>
<item>
<title>如何抽象一个 Vue 公共组件 - Daryl</title>
<link>http://www.cnblogs.com/ghost-xyx/p/7640204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ghost-xyx/p/7640204.html</guid>
<description>&lt;p&gt;&lt;span&gt;之前一直想写一篇关于抽象 Vue 组件的随笔，无奈一直没想到好的例子。恰巧最近为公司项目做了一个数字键盘的组件，于是就以这个为例聊聊如何抽象 Vue 的组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先上 &lt;a href=&quot;https://darylxyx.github.io/Demo/Vue-keyboard/&quot; target=&quot;_blank&quot;&gt;Demo&lt;/a&gt; 与 &lt;a href=&quot;https://github.com/Darylxyx/Vue-Demo/tree/master/keyboard&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;。（demo最好在浏览器里以手机模式浏览）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在讲具体实现前，我想先分享下自己认为的理想的公用组件是什么样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 黑盒性，即除了你自己以外，其他的开发者在快速阅读使用文档之后可以立刻上手，而不用关心你的内部实现；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 独立性，即做好解耦，不与父组件有过多关联；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3 自定义性，适当地暴露一些输入接口或者方法给外部用于自定义，同时也要设置好这些属性在外部未输入时的默认值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面我们先以黑盒的方式看看 demo 中数字键盘组件是如何调用的（已省略非关键部分代码）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;App.vue&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;&lt;span&gt;
......
    &lt;/span&gt;&lt;span&gt;&amp;lt;keyboard @submit-event='handleSubmit' @change-event='handleChange'&amp;gt;&amp;lt;/keyboard&amp;gt;&lt;/span&gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
import keyboard from &lt;/span&gt;'Keyboard.vue'&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            value: &lt;/span&gt;''&lt;span&gt;
        };
    },
    methods: {
        handleChange(value, currentValue) {
            console.log(value, currentValue);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
        },
        handleSubmit() {
            console.log(&lt;/span&gt;'submit: ' + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.value);
        }
    }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上，最基本的调用就完成了。效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/613712/201710/613712-20171016143738584-1650664575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着，点击 1-6 与“确定”。如果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/613712/201710/613712-20171016143927724-842425902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到数字键盘已经如我们预期工作了，接下来分析下该数字键盘组件所有的输入项。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;@change-event&lt;/span&gt;&lt;/strong&gt;：该事件为自定义事件，父组件通过 &lt;span&gt;v-on&lt;/span&gt; 注册监听，子组件内部通过 &lt;span&gt;$emit&lt;/span&gt; 进行触发（更多自定义事件相关内容请参考：&lt;a href=&quot;https://cn.vuejs.org/v2/guide/components.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6&quot; target=&quot;_blank&quot;&gt;Vue官方教程&lt;/a&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一次点击数字按键以及退格键均会触发该事件，其传递两个参数：value，累积点击的字符组合；currentValue，当前点击的字符。父组件通过 &lt;span&gt;handleChange&lt;/span&gt; 方法接收该事件的回调内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;@submit-event&lt;/span&gt;&lt;/strong&gt;：当点击“确定”键即会触发该事件，其不传递参数，只是告诉父组件“我的确定按钮被点击了，你要做什么操作自己看着办吧，之前点击的数字已经通过 &lt;span&gt;change-event &lt;span&gt;传给你了&lt;/span&gt;&lt;/span&gt;”。父组件通过 &lt;span&gt;handleSubmit&lt;/span&gt; 方法接收回调。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果只写这两个方法未免也太没诚意了，我还根据一些场景编写了以下几个自定义属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;max&lt;/span&gt;&lt;/strong&gt;：最大输入长度，超过的部分将不会触发 &lt;span&gt;change-event&lt;/span&gt; 事件，默认无限制。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;keyboard &lt;span&gt;max='6'&lt;/span&gt;&amp;gt;&amp;lt;/keyboard&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;sp-key&lt;/span&gt;&lt;/strong&gt;：自定义的特殊字符，如身份证输入时的“X”，会添加到左下角空白格，默认无。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;keyboard &lt;span&gt;sp-key='X'&lt;/span&gt;&amp;gt;&amp;lt;/keyboard&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/613712/201710/613712-20171016170728693-49621461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;random&lt;/span&gt;&lt;/strong&gt;：是否打乱数字顺序，一些有关银行账户或密码的输入经常会见到这种场景，默认 false。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;keyboard &lt;span&gt;random='true'&lt;/span&gt;&amp;gt;&amp;lt;/keyboard&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/613712/201710/613712-20171016171606099-1414964584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的几个自定义属性与事件，我们大概知道了父组件是如何向子组件传值以及监听子组件的变化，但父组件该如何直接调用子组件内部的函数呢？我们看下面这个场景。&lt;/p&gt;
&lt;p&gt;数字键盘上的键盘图标，点击之后会将数字键盘收起隐藏。组件内部拥有一个方法 &lt;span&gt;keyboardToggle(true|false)&lt;/span&gt; 来控制键盘的弹起和收回，那么如果在组件外部也想调用这个方法呢？比如当父组件中的 input 获取到焦点时。&lt;/p&gt;
&lt;p&gt;可以通过 Vue 中的 &lt;span&gt;ref&lt;/span&gt; 属性来获取到键盘的组件引用，从而调用其内部的方法，如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;$refs.[refName].keyboardToggle(true|false)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
    &amp;lt;input type='text' &lt;span&gt;@focus='handleShowKeyboard($event)'&lt;/span&gt; /&amp;gt;
    &amp;lt;keyboard &lt;span&gt;ref='kbref'&lt;/span&gt;&amp;gt;&amp;lt;/keyboard&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
import keyboard from &lt;/span&gt;'Keyboard'&lt;span&gt;;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;    methods: {
        handleShowKeyboard(e) {
            e &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt; e.preventDefault();
            &lt;/span&gt;&lt;span&gt;this.$refs.kbref.keyboardToggle(true&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
        }
    }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上面这种形式便可以在父组件上下文中调用子组件内的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;$refs.[refName].handleInit()&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数字键盘组件内部的初始化方法，用于重新渲染组件。若 &lt;span&gt;random&lt;/span&gt; 属性为 true，则数字键会刷新随机排列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;$refs.[refName].handleClear()&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;清除之前输入的字符组合，并触发 &lt;span&gt;change-event&lt;/span&gt; 且返回空字符串。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面分享了这个组件所有对外的属性与事件，可以发现我们并未看过该组件内部的一行代码，但已经可以完整的使用它了，下面来聊聊内部实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先来看看布局，我将键盘分为左右两部分，右边部分不用多说，左边的部分是将一个键位数组通过 &lt;span&gt;v-for&lt;/span&gt; 循环生成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/613712/201710/613712-20171017112526474-1184985595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么是如何让 0 和 9 之间空出一格呢，下面看下初始化键盘组件的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;keyboard.vue&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;handleInit()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;div class='kb-left'&amp;gt;
            &amp;lt;div class='kb-item' v-&lt;span&gt;for&lt;/span&gt;='item in keyArr'&amp;gt;{{item}}&amp;lt;/div&amp;gt;
            &amp;lt;div class='kb-item kb-toggle'&amp;gt;&amp;lt;/div&amp;gt; &lt;span&gt;//键盘图标&lt;/span&gt;
        &amp;lt;/div&amp;gt;
        &amp;lt;div class='kb-right'&amp;gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...        &lt;/span&gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            baseArr: []
        }
    },
    computed: {
        keyArr() {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.handleInit();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.baseArr;
        }
    },
    methods: {
        handleInit() {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.baseArr = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;this.baseArr.splice(this.baseArr.length - 1, 0, ''&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
        }
    }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即在键位数组倒数第二位插入一个空字符，然后循环生成按键。下面看下自定义参数是如何生效的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sp-key&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    props: [&lt;/span&gt;'spKey'&lt;span&gt;],
    data() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            baseArr: []
        }
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;
&lt;span&gt;    methods: {
        handleInit() {
            let spKey &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.spKey;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.baseArr = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'&lt;span&gt;];&lt;/span&gt;&lt;span&gt;　　　　　　　this&lt;/span&gt;.baseArr.splice(&lt;span&gt;this&lt;/span&gt;.baseArr.length - 1, 0&lt;span&gt;, spKey);
        }
    }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在组件内部通过 props 属性接收父组件传递的 spKey，之后就可在组件内的属性和方法中通过 this.spKey 进行访问。首先判断 spKey 值是否有效，并代替空字符插入键位数组倒数第二项。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;random&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    props: [&lt;/span&gt;'spKey', 'random'&lt;span&gt;],
    data() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            baseArr: []
        }
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....&lt;/span&gt;
&lt;span&gt;    methods: {
        handleInit() {
            let spKey &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.spKey;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.baseArr = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0'&lt;span&gt;];&lt;/span&gt;&lt;span&gt;

        　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.random &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.random != 'false'&lt;span&gt;) {
           　　&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.baseArr.sort(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.random() -&lt;span&gt; Math.random();
        　　　　});
           }

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.baseArr.splice(&lt;span&gt;this&lt;/span&gt;.baseArr.length - 1, 0&lt;span&gt;, spKey);
        }
    }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将键位打乱顺序其实也很简单，只要通过数组的 sort 方法。sort 方法可以接收一个函数作为参数，若函数返回正数则交换前后两项的位置，若函数返回负数则不作交换。所以将两个随机数相减的结果返回，即可将键位数组随机排序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面看看在组件内部是如何触发 &lt;span&gt;change-event&lt;/span&gt; 的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;handleInput()&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;div class='kb-left'&amp;gt;
            &amp;lt;div @click='handleInput(item)' class='kb-item' v-&lt;span&gt;for&lt;/span&gt;='item in keyArr'&amp;gt;{{item}}&amp;lt;/div&amp;gt;
            &amp;lt;div class='kb-item kb-toggle'&amp;gt;&amp;lt;/div&amp;gt; //键盘图标
        &amp;lt;/div&amp;gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
    data() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
            inputStr: &lt;/span&gt;''&lt;span&gt;
        }
    },
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
&lt;span&gt;    methods: {
        handleInput(value) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.inputStr +=&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this.$emit('change-event', this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.inputStr, value);&lt;/span&gt;
        }
    }
}
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;增加了 &lt;span&gt;max&lt;/span&gt; 属性后修改方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;handleInput(value) {
    let max &lt;/span&gt;= Number(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.max);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isNaN(max) &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;.inputStr.length+1 &amp;gt;&lt;span&gt; max) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.inputStr +=&lt;span&gt; value;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$emit('change-event', &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.inputStr, value);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;最后看看退格删除是如何实现的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;handleDelete()&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;handleDelete() {
    let str &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.inputStr;
　　 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!str.length) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.inputStr = str.substring(0, str.length - 1&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$emit('change-event', &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.inputStr);
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的例子都是些核心代码的片段，并且其他辅助函数并未列出，想查看完整的代码请看&lt;a href=&quot;https://github.com/Darylxyx/Vue-Demo/tree/master/keyboard&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;感谢你的浏览，希望能有所帮助。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Oct 2017 07:05:00 +0000</pubDate>
<dc:creator>Daryl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ghost-xyx/p/7640204.html</dc:identifier>
</item>
<item>
<title>当谈到 GitLab CI 的时候，我们该聊些什么（上篇） - 又拍云</title>
<link>http://www.cnblogs.com/upyun/p/7681645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upyun/p/7681645.html</guid>
<description>&lt;p&gt;“微服务”这个概念近两年非常热，正在慢慢改变 DevOps 的思路。微服务架构把一个庞大的业务系统拆解开来，每一个组件变得更加独立自治、松耦合。但是，同时也伴随着部署单元粒度越来越小，对交付效率要求也越来越高。一套高效、灵活、高可用的 CI/CD 系统就很关键。所以说 CI/CD 是微服务架构下必不可少的一部分。&lt;/p&gt;

&lt;p&gt;这方面有很多的开源项目和工具，比如 Jenkins、Github 默认支持的 Travis 以及本文主要介绍的GitLab CI。&lt;/p&gt;

&lt;p&gt;那么“当谈到 GitLab CI 的时候，我们都该聊些什么？”&lt;/p&gt;
&lt;h2&gt;什么是 GitLab WorkFlow&lt;/h2&gt;
&lt;p&gt;本章主要讲了 GitLab WorkFlow 从研发到发布交付的一个流程，介绍 CI/CD 所做的事情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/585973/201710/585973-20171017145024709-134074108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1&lt;/p&gt;
&lt;p&gt;图 1 来自 GitLab 官方文档，可以让我们更加方便的了解 CI/CD 做了哪些事情。&lt;/p&gt;

&lt;p&gt;从左往右看，首先研发人员完成需求提交代码到 GitLab。GitLab 触发一次 Build，构建好服务，然后开始跑单元测试、集成测试。等待测试结果通过后，再由负责该项目的同事进行 CodeReview，灰度发布，正式部署到线上。CI/CD 就是指测试和发布环节，如果能够做到自动化，那么就可以大大加快开发迭代的速度。&lt;/p&gt;
&lt;h2&gt;如何配置 GitLab Runner 如何把项目接入 CI&lt;/h2&gt;
&lt;h2&gt;GitLab CI 相关术语&lt;/h2&gt;
&lt;p&gt;在介绍 GitLab 之前，先介绍一下本文主要涉及到术语。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Job/Build，它是最小的任务单元，只负责一件事情，要么编译，要么测试等；&lt;/li&gt;
&lt;li&gt;Stage，阶段，每一个 Job 都会有一个阶段，一个阶段可以包含多个 Job。阶段是有先后顺序的。通过 stage 可以间接的控制 Job 执行的先后顺序；&lt;/li&gt;
&lt;li&gt;Pipeline，多个 Stage 有顺序的排列就是 Pipeline，流水线；&lt;/li&gt;
&lt;li&gt;GitLab Runner，是实际处理 Job 的，每个 Runner 可以单独配置，Runner 支持多种类型的 Job，同一时间单个 runner 只能处理一个 Job；&lt;/li&gt;
&lt;li&gt;GitLab Multi Runner，是一个 GitLab 的开源项目，用来统一管理 Runner；&lt;/li&gt;
&lt;li&gt;Executor，每个 Runner 都需要指定一个 Executor，来决定 runner 最终使用哪个执行器进行处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/585973/201710/585973-20171017145040271-1897717977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图2&lt;/p&gt;
&lt;p&gt;图 2 是一个典型的 Pipeline，一共有 5 个阶段，Build，Test，Release， Staging， Production，每个阶段里都至少有一个 Job，Test 中有两个 Job。GitLab 会从左往右依次把任务给到 Runner 处理，如果中途有一个任务没有处理成功的话，整个 Pipeline 就会退出。这就是持续集成（CI）、持续发布（CD） 的一个流程。&lt;/p&gt;
&lt;h2&gt;如何使用 GitLab CI&lt;/h2&gt;
&lt;h2&gt;注册 Runner&lt;/h2&gt;
&lt;h2&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/585973/201710/585973-20171017145054912-514539866.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;p&gt;图3&lt;/p&gt;
&lt;p&gt;GitLab 中提供了两种 Runner 的类型，图 3 这个界面可以在 GitLab 项目设置页中找到的，一个是特定的 Specific Runner，另一个是共享的 Shared Runner 。特定的 Runner 只能供部分项目使用，而共享的 Runner 是所有 GitLab 中的项目都可以使用的。而这两种类型的 Runner 的注册方式都是一样。&lt;/p&gt;

&lt;p&gt;从注册一个特定的 Runner 开始讲，首先安装一个 GitLab Mutli Runner，因为是 Go 语言实现的，所以安装起来会比较简单，直接采用二进制安装即可。第二步正式开始注册，输入 Gitlab 地址、token、描述、标签执行器等。输入上述数据之后 Runner 就注册好了，由于 Multi Runner 支持动态加载配置，所以 Runner 就立即生效了。可以在刚才的界面中看到新增了一个 Runner。有了 Runner，第二步就是如何在项目中增加 .gitlab-ci.yml 的 CI 配置文件。&lt;/p&gt;
&lt;h2&gt;在项目中增加 .gitlab-ci.yml 的 CI 配置文件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/585973/201710/585973-20171017145158474-716042872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图 4&lt;/p&gt;
&lt;p&gt;上文所示是一个非常简单的 CI 配置文件。定义了两个阶段，一个 test，一个 build，先执行 test 再执行 build，test 阶段有一个 job 叫做 test，执行的指令是 echo skip，但是这个 job 需要跑在带有 opentalk 的这个标签的 runner 上。build 阶段也有一个 job，叫做 build，它会执行 make docker，去构建 docker 镜像并且推送到私有仓库中，这个任务只有当分支中有 tag 提交才会触发，并且需要跑在带有 online docker builder 的 runner 上。写好这样一个 gitlab-ci.yml 后，commit 一下提交到 Gitlab，你就可以看到 CI/CD 页面（图4）中增加一条正在跑的任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/585973/201710/585973-20171017145233896-1930931471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图 5&lt;/p&gt;
&lt;p&gt;接下来看看 GitLab Runner 的内部实现是怎样的？&lt;/p&gt;
&lt;h2&gt;GitLab Runner 的实现细节&lt;/h2&gt;
&lt;p&gt;本章主要分析了 GitLab CI 跟 Runner 信息交互的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/585973/201710/585973-20171017145249006-1528406114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图 6&lt;/p&gt;
&lt;p&gt;从图 6 可以看出 GitLab CI 是这样一个结构，最上面 GitLab 服务，负责托管代码，支配分解 Job。下面几个是 GitLabMultiRunner，由于支持多操作系统环境，所以图 6 中都加了标注，每一个 GitLabMultiRunner 可以配置多个 GitLab Runner，GitLab Runner 直接跟 GitLab 做交互，这一层通信是通过 HTTP 协议实现的，之后也会讲到。另外有些同学可能已经注意到了，图中 GitLab 是部署在公网上的，而 GitLab Runner 则是在 Nat 之下的，这个设计非常友好，不需要把 GitLab Runner 跟 GitLab 部署在一起，GitLab Runner 甚至可以在自己的笔记本上。&lt;/p&gt;

&lt;p&gt;当我们看完了 GitLab CI 的整体结构后，再看看 Runner 跟 GitLab 之间的信息交互是怎样的？&lt;/p&gt;
&lt;h2&gt;Runner 跟 GitLab 之间的信息交互是怎样的？&lt;/h2&gt;
&lt;p&gt;信息交互分为几个部分，第一个部分是 Runner 注册。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/585973/201710/585973-20171017145307959-2012051957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 7&lt;/p&gt;
&lt;p&gt;Runner 会向 GitLab 发送一个注册请求，请求内容中包含 token、 tag 等重要信息，这些其实都是之前配置的时候需要填写的， GitLab 接收一个注册请求之后就会返回一个 token 给 Runner，Runner 之后的请求中都会带上这个 token。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/585973/201710/585973-20171017145328099-1528982206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图 8&lt;/p&gt;
&lt;p&gt;在收到 GitLab 注册成功的消息之后，Runner 就会不停的向 GitLab 请求 Job，时间间隔是 3s。可以看到请求中的 token 已经改成注册时 GitLab 返回的 token 了。&lt;/p&gt;

&lt;p&gt;这时会有两种情况：&lt;/p&gt;

&lt;p&gt;第一种是没有任务，GitLab 返回 204 No Content；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/585973/201710/585973-20171017145339209-304857910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图 9&lt;/p&gt;
&lt;p&gt;第二种情况是有任务，GitLab 会把任务信息返回回来，包括任务的 token，job_info，git_info，runner_info 等等。Runner 在接收到 Job 之后，就会向 GitLab 发送一个确认请求，同时更新任务的状态。发送完这个请求，Runner 就开始正式跑任务了。Runner 会定时的发送输出的中间数据，通过向 GitLab 发 Patch 请求的方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/585973/201710/585973-20171017145359084-175527990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图 10&lt;/p&gt;
&lt;p&gt;等任务处理完后，Runner 会发送最终结果、状态、日志等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/585973/201710/585973-20171017145410459-1742699505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图 11&lt;/p&gt;
&lt;p&gt;最后总结下，第一个注册 Runner，注册成功后 3s 定时请求 Job，接收到 Job 之后发送确认请求，然后开始运行任务，定时把中间结果输出给 GitLab，等任务处理完了，把结果发送给 GitLab。上述内容就是 Runner 跟 GitLab 之间的信息交互流程。&lt;/p&gt;

&lt;p&gt;现在 Runner 已经从 GitLab 获取到了任务，下一步 Runner 是怎么做的呢，Executor 又是怎么实现？下篇《当谈到 GitLab CI 的时候，我们都在聊些什么》将会重点为大家介绍 Docker Executor 的实现细节。&lt;/p&gt;

&lt;p&gt;更多阅读：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=https%3A//tech.upyun.com/article/246/%25E5%25BD%2593%25E8%25B0%2588%25E5%2588%25B0%2520GitLab%2520CI%2520%25E7%259A%2584%25E6%2597%25B6%25E5%2580%2599%25EF%25BC%258C%25E6%2588%2591%25E4%25BB%25AC%25E9%2583%25BD%25E8%25AF%25A5%25E8%2581%258A%25E4%25BA%259B%25E4%25BB%2580%25E4%25B9%2588%25EF%25BC%2588%25E4%25B8%258B%25E7%25AF%2587%25EF%25BC%2589.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;当谈到 GitLab CI 的时候，我们都该聊些什么（下篇）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Oct 2017 06:55:00 +0000</pubDate>
<dc:creator>又拍云</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/upyun/p/7681645.html</dc:identifier>
</item>
<item>
<title>为什么阿里的程序员那么帅？---原来他们都有&quot;编码规约扫描&quot;神器在手 - 禁心尽力</title>
<link>http://www.cnblogs.com/1315925303zxz/p/7681275.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1315925303zxz/p/7681275.html</guid>
<description>&lt;p&gt;&lt;span&gt;       &lt;span&gt;为了迎接十九大的到来，帝都城这几天也是满城风雨，听说早高峰期地铁站的人都排到天桥上了，哎，这就是该死的北漂生活。但是无论怎样，我依然在北京向各位问好！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       之前总结过俩篇关于阿里Java开发手册的编程规约(&lt;a href=&quot;http://www.cnblogs.com/1315925303zxz/p/6934575.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/1315925303zxz/p/6934575.html&lt;/a&gt;、&lt;a href=&quot;http://www.cnblogs.com/1315925303zxz/p/6899728.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/1315925303zxz/p/6899728.html&lt;/a&gt;)的博客，我想说那近乎纸上谈兵，很多自律性比较差的同志坚持几天就又回归原点了，又是每天在SVN上自由发挥着自己狠个性的代码风格。不过没关系今天我督促你一把，我一直是一个对代码有洁癖的程序员，所以就比较喜欢这类东西的出现，也比较喜欢和各位总结分享，说不定哪天我去你们公司碰上你写的代码，恰好是我分享的编码规约，那岂不皆大欢喜。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       好了，不是废话的也说了这么多，想必大家都知道公元2017-10-15，阿里首发了Java开发规约插件，当时我在地铁上看的那叫一个兴奋，由于昨天有点忙，所以今天抽空给各位分享一下该插件的安装和使用，以及我们需要修行的代码风格。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;阿里代码规约插件的安装：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;       &lt;span&gt;官方推荐&lt;strong&gt;IDEA使用编码规约插件jdk至少是1.7+，eclipse使用编码规约插件jdk至少是1.8+。&lt;/strong&gt;但是本人使用的是Spring Tool Suite开发工具(spring的一个开发插件)，&lt;strong&gt;jdk是1.7的，但是今天安装后能够正常使用，具体原因我也没有详细去查，但是结果是好的，再说一次能够正常使用。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       打开eclipse或者Spring Tool Suite工具，通过 &lt;strong&gt;Help 菜单&amp;gt;&amp;gt;选择 Install New Software&lt;/strong&gt;，然后输入&lt;a href=&quot;https://p3c.alibaba.com/plugin/eclipse/update&quot; target=&quot;_blank&quot;&gt;https://p3c.alibaba.com/plugin/eclipse/update&lt;/a&gt; 即可看到安装列表，然后安装即可，如果在安装过程中如果出现警告信息则可不比关心，跳过即可。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;阿里代码规约插件的使用：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;       &lt;span&gt;如果你已经在你的开发工具中安装了阿里代码规约插件，你可以在某个类或者某个包上鼠标右键，就会看到【阿里编码规约扫描】神器了，抓紧试试，看看自己写的代码是有多丑。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/855612/201710/855612-20171017125451256-1365081507.png&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/855612/201710/855612-20171017125812974-638944226.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;阿里编码规约扫描的结果总结：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;      &lt;span&gt; 通过阿里代码规约插件的几通扫描，丑陋的代码原形毕露，我可是费了老半天才帮它们化好妆的。首先普及各位三个单词：&lt;strong&gt;blocker&lt;/strong&gt;(雏形锻模，预锻模)、&lt;strong&gt;Critical&lt;/strong&gt;(关键的; 批评的，爱挑剔的; 严重的; 极重要的)、&lt;strong&gt;Major&lt;/strong&gt;(主要的; 重要的; 大调的)。这三个单词代表代码规约插件扫描出来的三类不规范的信息列表，具体的信息你自己去体验一把就知道了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       当你右键执行&amp;gt;&amp;gt;&lt;strong&gt;阿里编码规约扫描&lt;/strong&gt;时，就会在开发工具的通知栏中出现以下俩个选项卡&lt;strong&gt;P3C Results和Rule Detail&lt;/strong&gt;，前者代表扫描出的不规范的错误列表，后者代表各个列表项不规范的详细情况，最主要的是举例教你如何改正，我喜欢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/855612/201710/855612-20171017132323365-659220025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/855612/201710/855612-20171017132522693-1705939855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;就我今天扫描出的不规范代码，有几点是值得注意的，特此记录一下：&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的代码风格：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if (ip.equals(&quot;127.0.0.1&quot;) || ip.equals(&quot;0:0:0:0:0:0:0:1&quot;)) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插件代码风格：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if (&quot;127.0.0.1&quot;.equals(ip) || &quot;0:0:0:0:0:0:0:1&quot;.equals(ip)) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、不允许任何魔法值（即未经定义的常量）直接出现在代码中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的代码风格：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if (currentMonth &amp;gt;= 1 &amp;amp;&amp;amp; currentMonth &amp;lt;= 3) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;插件代码风格：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String KEY_PRE = &quot;Id#taobao_1&quot;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if(key.equals(KEY_PRE)){&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/* */注释。注意与代码对齐。 【注释这块我个人是非常重视的】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、类、类属性、类方法的注释必须使用javadoc规范，使用/**内容*/格式，不得使用//xxx方式和/*xxx*/方式。说明：在IDE编辑窗口中，javadoc方式会提示相关注释，生成javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、循环体内，字符串的联接方式，使用StringBuilder的append方法进行扩展。说明：反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反例:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;String result;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for (String string : tagNameList) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;result = result + string;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;正例:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;StringBuilder stringBuilder = new StringBuilder();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for (String string : tagNameList) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;stringBuilder.append(string);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;String result = stringBuilder.toString();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、集合初始化时，指定集合初始值大小。HashMap使用如下构造方法进行初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可。&lt;strong&gt;这块我个人的代码扫出了一大堆，以后真得防范了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       到这儿可能就会有人站出来反对，功能实现了比啥都重要，至于浪费精力去关注代码的规范性嘛，那么我想送朋友一句话：谁会愿意通过一张邋遢的外表去发现内心一颗高尚的心。日常开发中也是一样，如果你写的代码再优再牛逼，你试试将一个项目中所有代码搞得长一行短一行格式乱七八糟，甚至连最基本的类、接口注释都不写，谁会愿意去发现你是一位牛逼的程序员。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　最后给那些插件开发的伙伴们付出的247个日夜点个赞，他们的确很棒，愿他们在以后的开发路上激情永在，薪水倍升！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 17 Oct 2017 06:00:00 +0000</pubDate>
<dc:creator>禁心尽力</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1315925303zxz/p/7681275.html</dc:identifier>
</item>
<item>
<title>Hadoop（六）之HDFS的存储原理（运行原理） - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/7681059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/7681059.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　其实说到HDFS的存储原理，无非就是读操作和写操作，那接下来我们详细的看一下HDFS是怎么实现读写操作的！&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017105649615-77202035.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;356&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1）客户端通过调用FileSystem对象的open()来读取希望打开的文件。对于HDFS来说，这个对象是分布式文件系统的一个实例。&lt;/p&gt;
&lt;p&gt;　　2）DistributedFileSystem通过RPC来调用namenode，以&lt;span&gt;确定文件的开头部分的块位置。对于每一块，namenode返回具有该块副本的datanode地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　 此外，这些&lt;span&gt;datanode根据他们与client的距离来排序（根据网络集群的拓扑）。如果该client本身就是一个datanode，便从本地datanode中读取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;           DistributedFileSystem返回一个FSDataInputStream对象给client读取数据，FSDataInputStream转而包装了一个DFSInputStream对象。&lt;/p&gt;
&lt;p&gt;　　3）接着client对这个输入流调用read()。&lt;span&gt;存储着文件开头部分的块的数据节点的地址DFSInputStream随即与这些块最近的datanode相连接&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　4）通过在数据流中反复调用read()，数据会从datanode返回client。&lt;/p&gt;
&lt;p&gt;　　5）&lt;span&gt;到达块的末端时，DFSInputStream会关闭与datanode间的联系&lt;/span&gt;，然后&lt;span&gt;为下一个块找到最佳的datanode&lt;/span&gt;。client端&lt;span&gt;只需要读取一个连续的流，这些对于client来说都是透明的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　6）在读取的时候，如果client与datanode通信时遇到一个错误，那么它就会去尝试对这个块来说下一个最近的块。它也会记住那个故障节点的datanode，以保证不会再对之后的块进行徒劳无益的尝试。&lt;/p&gt;
&lt;p&gt;　　　 client也会确认datanode发来的数据的校验和。如果发现一个损坏的块，它就会在client试图从别的datanode中读取一个块的副本之前报告给namenode。&lt;/p&gt;
&lt;p&gt;　　7）这个设计的一个重点是，client直接联系datanode去检索数据，并被namenode指引到块中最好的datanode。因为数据流在此集群中是在所有datanode分散进行的。&lt;/p&gt;
&lt;p&gt;　　　 所以这种设计能使HDFS可扩展到最大的并发client数量。同时，n&lt;span&gt;amenode只不过提供块的位置请求（存储在内存中，十分高效），不是提供数据。否则如果客户端数量增长，namenode就会快速成为一个“瓶颈”&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　注意：&lt;/p&gt;
&lt;p&gt;　　　　这里HdfsDataInputStream是FSDataInputStream的子类，这里是通过子类创建父类对象。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017110606959-703354081.png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;157&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017110710584-534466576.png&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1）客户端&lt;span&gt;通过在DistributedFileSystem中调用create()来创建文&lt;/span&gt;件。&lt;/p&gt;
&lt;p&gt;　　2）DistributedFileSystem 使用RPC去调用namenode，&lt;span&gt;在文件系统的命名空间创一个新的文件，没有块与之相联系&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　 　namenode执行各种不同的检查（这个文件存不存在，有没有权限去写，能不能存的下这个文件）以确保这个文件不会已经存在，并且在client有可以创建文件的适当的许可。&lt;/p&gt;
&lt;p&gt;　　　 如果检查通过，namenode就会生成一个新的文件记录；否则，文件创建失败并向client抛出一个IOException异常。&lt;/p&gt;
&lt;p&gt;　　    &lt;span&gt;分布式文件系统返回一个文件系统数据输出流，让client开始写入数据。就像读取事件一样，文件系统数据输出流控制一个DFSOutputStream，负责处理datanode和namenode之间的通信&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　3）在client写入数据时&lt;span&gt;，DFSOutputStream将它分成一个个的包，写入内部的队列，成为数据队列&lt;/span&gt;。&lt;span&gt;数据队列随数据流流动&lt;/span&gt;，&lt;span&gt;数据流的责任是根据适合的datanode的列表要求这些节点为副本分配新的块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　  这个数据节点的列表形成一个管线&lt;/span&gt;——假设副本数是3，所以有3个节点在管线中。&lt;/p&gt;
&lt;p&gt;　　4）数据流&lt;span&gt;将包分流给管线中第一个的datanode，这个节点会存储包并且发送给管线中的第二个datanode。同样地，第二个datanode存储包并且传给管线中的第三个数据节点。&lt;/span&gt;　　&lt;/p&gt;
&lt;p&gt;　　5）DFSOutputStream也有一个内部的包队列来等待datanode收到确认，成为确认队列。&lt;span&gt;一个包只有在被管线中所有的节点确认后才会被移除出确认队列&lt;/span&gt;。如果在有数据写入期间，datanode发生故障，&lt;/p&gt;
&lt;p&gt;　　　 则会执行下面的操作，当然这对写入数据的client而言是透明的。首先管线被关闭，确认队列中的任何包都会被添加回数据队列的前面，以确保故障节点下游的datanode不会漏掉任意一个包。&lt;/p&gt;
&lt;p&gt;　　　为存储在另一正常datanode的当前数据块制定一个新的标识，并将该标识传给namenode，以便故障节点datanode在恢复后可以删除存储的部分数据块。&lt;/p&gt;
&lt;p&gt;　　　从管线中删除故障数据节点并且把余下的数据块写入管线中的两个正常的datanode。namenode注意到块复本量不足时，会在另一个节点上创建一个新的复本。&lt;/p&gt;
&lt;p&gt;　　　后续的数据块继续正常接收处理。只要dfs.replication.min的副本（默认是1）被写入，写操作就是成功的，并且这个块会在集群中被异步复制，直到其满足目标副本数（dfs.replication 默认值为3）。&lt;/p&gt;
&lt;p&gt;　　6）&lt;span&gt;client完成数据的写入后，就会在流中调用close()&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　7）在向namenode节点发送完消息之前，此方法会将余下的所有包放入datanode管线并等待确认。&lt;/p&gt;
&lt;p&gt;　　　namenode节点已经知道文件由哪些块组成（通过Data streamer 询问块分配），所以它只需在返回成功前等待块进行最小量的复制。&lt;/p&gt;
&lt;p&gt;　　8）补充说明——复本的布局：Hadoop的默认布局策略是在运行客户端的节点上放第1个复本（如果客户端运行在集群之外，就随机选择一个节点，不过系统会避免挑选那些存储太满或太忙的节点。）&lt;/p&gt;
&lt;p&gt;　　　第2个复本放在与第1个复本不同且随机另外选择的机架的节点上（离架）。第3个复本与第2个复本放在相同的机架，且随机选择另一个节点。其他复本放在集群中随机的节点上，不过系统会尽量避免相同的机架放太多复本。&lt;/p&gt;

&lt;h2&gt;3.1、写入操作&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017123908365-812973557.png&quot; alt=&quot;&quot; width=&quot;674&quot; height=&quot;448&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　前提：&lt;/p&gt;
&lt;p&gt;　　　　有一个文件FileA，100M大小。Client将FileA写入到HDFS上。&lt;br/&gt;　　　　HDFS按默认配置。&lt;br/&gt;　　　　HDFS分布在三个机架上Rack1，Rack2，Rack3。&lt;/p&gt;
&lt;p&gt;　　步骤：&lt;/p&gt;
&lt;p&gt;　　　　1） Client将FileA按64M分块。分成两块，block1和Block2;&lt;br/&gt;　　　　2） Client向nameNode发送写数据请求，如图蓝色虚线①------&amp;gt;。&lt;br/&gt;　　　　3） NameNode节点，记录block信息。并返回可用的DataNode，如粉色虚线②---------&amp;gt;。&lt;br/&gt;　　　　　　Block1: host2,host1,host3&lt;br/&gt;　　　　　　Block2: host7,host8,host4&lt;br/&gt;　　　　　　原理：&lt;br/&gt;　　　　　　　　NameNode具有RackAware机架感知功能，这个可以配置。&lt;br/&gt;　　　　　　　　若client为DataNode节点，那存储block时，规则为：副本1，同client的节点上；副本2，不同机架节点上；副本3，同第二个副本机架的另一个节点上；其他副本随机挑选。&lt;br/&gt;　　　　　　　　若client不为DataNode节点，那存储block时，规则为：副本1，随机选择一个节点上；副本2，不同副本1，机架上；副本3，同副本2相同的另一个节点上；其他副本随机挑选。&lt;br/&gt;　　　　4）client向DataNode发送block1；发送过程是以流式写入。&lt;br/&gt;　　　　　　流式写入过程：&lt;br/&gt;　　　　　　　　第一步：将64M的block1按64k的package划分;&lt;br/&gt;　　　　　　　　第二步：然后将第一个package发送给host2;&lt;br/&gt;　　　　　　　　第三步：host2接收完后，将第一个package发送给host1，同时client想host2发送第二个package；&lt;br/&gt;　　　　　　　　第四步：host1接收完第一个package后，发送给host3，同时接收host2发来的第二个package。&lt;br/&gt;　　　　　　　　第五步：以此类推，如图红线实线所示，直到将block1发送完毕。&lt;br/&gt;　　　　　　　　第六步：host2,host1,host3向NameNode，host2向Client发送通知，说“消息发送完了”。如图粉红颜色实线所示。&lt;br/&gt;　　　　　　　　第七步：client收到host2发来的消息后，向namenode发送消息，说我写完了。这样就真完成了。如图黄色粗实线&lt;br/&gt;　　　　　　　　第八步：发送完block1后，再向host7，host8，host4发送block2，如图蓝色实线所示。&lt;br/&gt;　　　　　　　　第九步：发送完block2后，host7,host8,host4向NameNode，host7向Client发送通知，如图浅绿色实线所示。&lt;br/&gt;　　　　　　　　第十步：client向NameNode发送消息，说我写完了，如图黄色粗实线。。。这样就完毕了。&lt;/p&gt;
&lt;p&gt;　　分析：&lt;/p&gt;
&lt;p&gt;　　　　通过写过程，我们可以了解到：&lt;br/&gt;　　　　　　1）写1T文件，我们需要3T的存储，3T的网络流量贷款。&lt;br/&gt;　　　　　　2）在执行读或写的过程中，NameNode和DataNode通过HeartBeat进行保存通信，确定DataNode活着。&lt;br/&gt;　　　　　　　　如果发现DataNode死掉了，就将死掉的DataNode上的数据，放到其他节点去。读取时，要读其他节点去。&lt;br/&gt;　　　　　　3）挂掉一个节点，没关系，还有其他节点可以备份；甚至，挂掉某一个机架，也没关系；其他机架上，也有备份。&lt;/p&gt;
&lt;h2&gt;3.2、读取操作&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017124508115-406617425.png&quot; alt=&quot;&quot; width=&quot;690&quot; height=&quot;458&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　读操作就简单一些了，如图所示，client要从datanode上，读取FileA。而FileA由block1和block2组成。 &lt;/p&gt;
&lt;p&gt;　　那么，读操作流程为：&lt;br/&gt;　　　　1）client向namenode发送读请求。&lt;br/&gt;　　　　2）namenode查看Metadata信息，返回fileA的block的位置。&lt;br/&gt;　　　　　　block1:host2,host1,host3&lt;br/&gt;　　　　　　block2:host7,host8,host4&lt;br/&gt;　　　　3）block的位置是有先后顺序的，先读block1，再读block2。而且block1去host2上读取；然后block2，去host7上读取；&lt;br/&gt;　　上面例子中，client位于机架外，那么如果client位于机架内某个DataNode上，例如,client是host6。那么读取的时候，遵循的规律是：优选读取本机架上的数据。&lt;/p&gt;

&lt;p&gt;以简洁易懂的漫画形式讲解HDFS存储机制与运行原理&lt;/p&gt;
&lt;h2&gt;4.1、角色出演&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017115404162-882657315.png&quot; alt=&quot;&quot; width=&quot;475&quot; height=&quot;257&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如上图所示，HDFS存储相关角色与功能如下：&lt;br/&gt;　　　　Client：客户端，系统使用者，调用HDFS API操作文件;与NN交互获取文件元数据;与DN交互进行数据读写。&lt;br/&gt;　　　　Namenode：元数据节点，是系统唯一的管理者。负责元数据的管理;与client交互进行提供元数据查询;分配数据存储节点等。&lt;br/&gt;　　　　Datanode：数据存储节点，负责数据块的存储与冗余备份;执行数据块的读写操作等。&lt;/p&gt;
&lt;h2&gt;4.2、读取操作&lt;/h2&gt;
&lt;p&gt;　　1）用户需求　&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017115600381-1937204210.png&quot; alt=&quot;&quot; width=&quot;253&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　HDFS采用的是&lt;span&gt;“一次写入多次读取&lt;/span&gt;”的文件访问模型。&lt;span&gt;一个文件经过创建、写入和关闭之后就不需要改变&lt;/span&gt;。这一假设简化了数据一致性问题，并且使高吞吐量的数据访问成为可能。&lt;/p&gt;
&lt;p&gt;　　2）先联系元数据节点&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017115715818-106559749.png&quot; alt=&quot;&quot; width=&quot;275&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017115735584-298761244.png&quot; alt=&quot;&quot; width=&quot;367&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017115803365-446826441.png&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）下载数据&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017120239506-1321837399.png&quot; alt=&quot;&quot; width=&quot;344&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　数据存储已经按照客户端与DataNode节点之间的距离进行了排序，距客户端越近的DataNode节点被放在最前面，客户端会优先从本地读取该数据块。&lt;/p&gt;
&lt;h2&gt;3.2、写入操作&lt;/h2&gt;
&lt;p&gt;　　1）发送写数据请求&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017120523037-232654893.png&quot; alt=&quot;&quot; width=&quot;446&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　HDFS中的存储单元是block。文件通常被分成64或128M一块的数据块进行存储。与普通文件系统不同的是，在HDFS中，如果一个文件大小小于一个数据块的大小，它是不需要占用整个数据块的存储空间的。&lt;/p&gt;
&lt;p&gt;　　2）文件切分&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017120632271-685114694.png&quot; alt=&quot;&quot; width=&quot;462&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　3）DN分配&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017120708896-1097940794.png&quot; alt=&quot;&quot; width=&quot;470&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017120740177-2080183156.png&quot; alt=&quot;&quot; width=&quot;462&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4）数据写入&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017120905006-890579808.png&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017121002927-918212893.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5）写入完成&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017121120318-1469835837.png&quot; alt=&quot;&quot; width=&quot;440&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017121149724-595564306.png&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;253&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017121220506-1492352464.png&quot; alt=&quot;&quot; width=&quot;434&quot; height=&quot;238&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　6）角色定位&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/999804/201710/999804-20171017121330771-1122967699.png&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 喜欢就点个“推荐”哦！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Oct 2017 04:48:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/7681059.html</dc:identifier>
</item>
<item>
<title>使用binlog2sql做数据恢复的简单示例 - 飘扬的红领巾</title>
<link>http://www.cnblogs.com/leefreeman/p/7680953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leefreeman/p/7680953.html</guid>
<description>&lt;p&gt;    有时我们会遇到操作人员误删或者误更新数据的情况，这时我们迫切希望把原来的数据还原回来，今天我们介绍一个简单的工具来方便的实现此功能。&lt;/p&gt;
&lt;p class=&quot;catalog&quot;&gt;&lt;span&gt;前提条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在实现数据恢复之前，需要我们的MySQL满足以下配置条件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[mysqld]
server_id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
log_bin &lt;/span&gt;= &lt;span&gt;bin
max_binlog_size &lt;/span&gt;=&lt;span&gt; 1G
binlog_format &lt;/span&gt;=&lt;span&gt; row
binlog_row_image &lt;/span&gt;= full
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上配置都是MySQL的常规配置，不存在特殊配置的情况，所以你其实不用太担心。&lt;/p&gt;
&lt;p class=&quot;catalog&quot;&gt;&lt;span&gt;构造实验数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来我们建一个简单的user表，并插入示例数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;&lt;span&gt;` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `username` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `password` &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  `create_date` &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; CHARSET&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; ----------------------------&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; Records of user&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt; ----------------------------&lt;/span&gt;
&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;liping&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ADFASDFASDF&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-10-17 10:57:42&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xiaoming&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SDDSFGSDFGSDG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-10-17 10:58:06&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; `&lt;span&gt;user&lt;/span&gt;` &lt;span&gt;VALUES&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xiaohong&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;QEWFGFGDSFGSDG&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2017-10-17 10:58:29&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;catalog&quot;&gt;&lt;span&gt;执行误操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来如果操作人员执行了一个误操作，试图修改liping的密码为123456,但忘记了加where条件，即执行了SQL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;update&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; `password`&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导致所有的用户密码都被设置为了123456。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115844209-1223530241.png&quot;&gt;&lt;img title=&quot;W3R83DZK)BA1_GM4]RYBK52&quot; border=&quot;0&quot; alt=&quot;W3R83DZK)BA1_GM4]RYBK52&quot; src=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115844912-878332586.png&quot; width=&quot;360&quot; height=&quot;101&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;catalog&quot;&gt;&lt;span&gt;数据恢复&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来我们将尝试恢复原来的数据，首先因为我们开启了二进制日志，所以其实我们的每次操作都被记录到了二进制日志当中，我们可以使用二进制查看命令，查询到我们刚才所做的操作痕迹。&lt;/p&gt;
&lt;p&gt;首先定位到当前MySQL写到了哪个二进制文件中，进入到MySQL执行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
show master status;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115845302-1274604767.png&quot;&gt;&lt;img title=&quot;WOU`]BQ3O(P30R`%OGDF{ZI&quot; border=&quot;0&quot; alt=&quot;WOU`]BQ3O(P30R`%OGDF{ZI&quot; src=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115845724-1532322073.png&quot; width=&quot;594&quot; height=&quot;120&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到当前的二进制文件写到了bin.000002。于是我们用二进制文件查看命令，找出刚才操作的痕迹。（请注意二进制文件的路径，修改为你的二进制文件路径）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysqlbinlog &lt;span&gt;--&lt;/span&gt;&lt;span&gt;no-defaults -v -v --base64-output=DECODE-ROWS /mdata/mysql_data/bin.000002 | grep -B 15 '123456'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115846256-866998756.png&quot;&gt;&lt;img title=&quot;P)[3D)$H3$@ERU1SCXQJJD2&quot; border=&quot;0&quot; alt=&quot;P)[3D)$H3$@ERU1SCXQJJD2&quot; src=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115847021-265009090.png&quot; width=&quot;808&quot; height=&quot;487&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出二进制文件记录了我们对每行数据修改的痕迹，其中@1 @2 @3 @4表示我们user表中的4个字段，看到这些记录你应该可以想到，如果我们把这些记录逆向执行，这数据就可以恢复。所以这里提供了一个思路，就是可以通过文本操作，把update set前后的字符串调换，保存成SQL，即可实现数据还原，但真正实现起来还是挺麻烦的。这里我们介绍binlog2sql工具，你不用那么麻烦的去实现此功能。&lt;/p&gt;
&lt;p class=&quot;catalog&quot;&gt;&lt;span&gt;binlog2sql工具&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;binlog2sql是大众点评开源的一款用于解析binlog的工具，详见：&lt;a title=&quot;https://github.com/danfengcao/binlog2sql&quot; href=&quot;https://github.com/danfengcao/binlog2sql&quot;&gt;https://github.com/danfengcao/binlog2sql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用binlog2sql将二进制文件转换为SQL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python binlog2sql.py &lt;span&gt;-&lt;/span&gt;h10.&lt;span&gt;89.1&lt;/span&gt;.&lt;span&gt;143&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;P3306 &lt;span&gt;-&lt;/span&gt;udev &lt;span&gt;-&lt;/span&gt;p&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;dtest &lt;span&gt;-&lt;/span&gt;t &lt;span&gt;user&lt;/span&gt; &lt;span&gt;--&lt;/span&gt;&lt;span&gt;start-file='bin.000002'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115848099-1113252565.png&quot;&gt;&lt;img title=&quot;G_PH_5D$}2@Q(Q4@FJ`48D4&quot; border=&quot;0&quot; alt=&quot;G_PH_5D$}2@Q(Q4@FJ`48D4&quot; src=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115849240-244103582.png&quot; width=&quot;769&quot; height=&quot;577&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用binlog2sql将二进制文件解析为了SQL格式，这个文件当中包括我们之前做的建表SQL以及插入示例数据的SQL，当然也包括我们误操作的UPDATE语句。&lt;/p&gt;
&lt;p&gt;这里我们重点看黄色框包含的内容，它是我们update语句记录在二进制文件当中的起止位置，我们可以看到三条UPDATE语句都记录到：#start 2616 end 3028，所以我们待会恢复时，只需要恢复这个位置的数据就可以了。&lt;/p&gt;
&lt;p&gt;使用binlog2sql生成回滚SQL&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
python binlog2sql.py &lt;span&gt;--&lt;/span&gt;&lt;span&gt;flashback -h10.89.1.143 -P3306 -udev -p'123456' -dtest -tuser --start-file='bin.000002' --start-position=2616 --stop-position=3028&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115850177-435642914.png&quot;&gt;&lt;img title=&quot;image&quot; border=&quot;0&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115850959-1020259405.png&quot; width=&quot;765&quot; height=&quot;234&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到binlog2sql生成了：#start 2616 end 3028位置的回滚SQL。我们把这个SQL复制下来到MySQL中执行，即可实现数据恢复。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115851396-431165785.png&quot;&gt;&lt;img title=&quot;image&quot; border=&quot;0&quot; alt=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/352511/201710/352511-20171017115851802-1811669724.png&quot; width=&quot;407&quot; height=&quot;110&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Oct 2017 03:59:00 +0000</pubDate>
<dc:creator>飘扬的红领巾</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leefreeman/p/7680953.html</dc:identifier>
</item>
<item>
<title>基于HTML5和WebGL的3D网络拓扑结构图 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/7680809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/7680809.html</guid>
<description>&lt;p&gt;现在，3D模型已经用于各种不同的领域。在医疗行业使用它们制作器官的精确模型；电影行业将它们用于活动的人物、物体以及现实电影；视频游戏产业将它们作为计算机与视频游戏中的资源；在科学领域将它们作为化合物的精确模型；建筑业将它们用来展示提议的建筑物或者风景表现；工程界将它们用于设计新设备、交通工具、结构以及其它应用领域；在最近几十年，地球科学领域开始构建三维地质模型，而且3D模型经常做成动画，例如，在故事片电影以及计算机与视频游戏中大量地应用三维模型。它们可以在三维建模工具中使用或者单独使用。为了容易形成动画，通常在模型中加入一些额外的数据，例如，一些人类或者动物的三维模型中有完整的骨骼系统，这样运动时看起来会更加真实，并且可以通过关节与骨骼控制运动。&lt;/p&gt;
&lt;p&gt;这些种种都让我们前端开发者觉得如果我们可以不用学习unity3d或者其他游戏开发工具就能实现3D效果，而且能够精准的靠代码来控制移动或者方向就好了。。。于是我利用&lt;a title=&quot;HT For Web&quot; href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT For Web&lt;/a&gt;中的&lt;a title=&quot;3D 组件&quot; href=&quot;http://www.hightopo.com/guide/guide/core/3d/ht-3d-guide.html&quot; target=&quot;_blank&quot;&gt;3D组件&lt;/a&gt;来实现了一个小例子，用了&lt;a title=&quot;HT&quot; href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT&lt;/a&gt;中&lt;a title=&quot;3D 组件&quot; href=&quot;http://www.hightopo.com/guide/guide/core/3d/ht-3d-guide.html&quot; target=&quot;_blank&quot;&gt;3D组件&lt;/a&gt;的大部分功能，做这个例子就是想把&lt;a title=&quot;3D 组件&quot; href=&quot;http://www.hightopo.com/guide/guide/core/3d/ht-3d-guide.html&quot; target=&quot;_blank&quot;&gt;3D组件&lt;/a&gt;好好的掌握，尽量放进一个例子中，到时候别人有需要就可以参考了，但是因为之前从来没有实现过3D的效果，再加上现在手册没有很完整，所以这个例子对我来说还是有点难度的。&lt;/p&gt;
&lt;p&gt;本例位置：&lt;a href=&quot;http://www.hightopo.com/demo/3DTopology/index.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/demo/3DTopology/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先来看看整体实现的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/591709/201710/591709-20171017113905474-830306380.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用&lt;a href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT for Web&lt;/a&gt;，现有的3d模板创建三层底板不是问题，问题是要如何将图中第一层的“电脑”和“机柜组件”放上去？我是在网上down下来的obj格式的文件，然后我利用&lt;a title=&quot;HT&quot; href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;HT&lt;/a&gt;中的ht.Default.loadObj(objUrl, mtlUrl, params)函数将模型加载进去，其中的params部分可以参考&lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/obj/ht-obj-guide.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/guide/guide/plugin/obj/ht-obj-guide.html&lt;/a&gt;，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
ht.Default.loadObj('obj/机柜组件1.obj', 'obj/机柜组件1.mtl'&lt;span&gt;, {  
    cube: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,  
    center: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,  
    shape3d: &lt;/span&gt;'box'&lt;span&gt;,  
    finishFunc: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(modelMap, array, rawS3){  
        window.rawS3 &lt;/span&gt;=&lt;span&gt; rawS3;  
     　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(modelMap){  
　　      device2 &lt;/span&gt;= createNode('box'&lt;span&gt;, floor1);  
　　　　device2.p3([x1&lt;/span&gt;-120, y1+13, z1+60&lt;span&gt;]);  
　　　　device2.s3(rawS3);  
　　　　createEdge(device1, device2);  
　　　　device3 &lt;/span&gt;= createNode('box'&lt;span&gt;, floor1);  
　　　　device3.s3(rawS3);  
　　　　device3.p3([x1&lt;/span&gt;+120, y1+13, z1+60&lt;span&gt;]);  
　　　　createEdge(device1, device3);  
    　 }  
    }  
}); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“电脑”上方有个红色的立体能旋转的“警告”，是依靠ht.Default.setShape3dModel函数(&lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/modeling/ht-modeling-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 建模手册&lt;/a&gt;)注册的一个3d模型，在ht中，封装好的建模函数有很多，比较基础的就是球体，圆柱，立方体等等，这边我用的是构造环形的方法createRingModel来生成“警告”最外面的环，感叹号的上部分就是用的createSmoothSphereModel构造的球体，感叹号的下部分就是用createSmoothCylinderModel来构造的圆柱。我一开始直接使用了3d模型中封装好的函数，导致后来根本不知道函数中使用的参数是做什么用的，而且也不明白3d模型是怎么构成的，然后自己又重新看了前面的“模型基础”，才知道原来3d模型采用的一个面，最基础的是三角面，之后复杂的面也是由多个三角面来形成的，然后绕着一根特定的轴旋转之后形成的，当然，这个轴是你来决定的，不同的轴可以生成不同的形状，对于颜色等风格方面的设置可以参考&lt;a href=&quot;http://www.hightopo.com/guide/guide/core/theme/ht-theme-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 风格手册&lt;/a&gt;。至于如何让这个3d模型旋转起来，ht中封装了addScheduleTask(Task)方法，我在第三层Task中调用了ht封装的一个旋转函数setRotation来设置旋转的顺序和方向，并且指定了旋转的对象。以下是自定义“警告”的3d模型的方法（注意：因为本例的模型是自定义组合的，如果要设置整体模型的颜色要用“all.blend”style属性）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; ringModel = ht.Default.createRingModel([8, 1, 10, 1, 10, -1, 8, -1, 8, 1], &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, 100&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sphereModel = ht.Default.createSmoothSphereModel(8, 8, 0, Math.PI*2, 0, Math.PI, 2&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cylinderModel = ht.Default.createSmoothCylinderModel(8, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, 1, 2, 0, Math.PI*2, 8&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr =&lt;span&gt; [  
    {  
        r3: [Math.PI&lt;/span&gt;/2, 0, 0],  
        color: 'red'&lt;span&gt;  
    },{  
        shape3d: sphereModel,  
        t3: [&lt;/span&gt;0, 4, 0&lt;span&gt;],  
        color: &lt;/span&gt;'red'&lt;span&gt;  
    },{  
        shape3d: cylinderModel,  
        t3: [&lt;/span&gt;0, -3, 0&lt;span&gt;],  
        color: &lt;/span&gt;'red'&lt;span&gt;  
    }  
];  
ht.Default.setShape3dModel(&lt;/span&gt;'alarm'&lt;span&gt;, {  
    shape3d: arr  
}); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要实现3D界面上展现2d图片，只要按照平常的路走就行，因为ht中的Graph3dView和其他的组件的根部都是div，在div上生成图片用的就是原生js，new Image()，再将image的src和大小赋值，并且加到3d面板上就行了，注意这里是加到3d的底层div上，要用g3d.getView().appendChild来添加，我们还可以看到管线上有虚线流动的痕迹，这是通过不断改变“shape3d.uv.offset”参数实现管道流动的特殊效果，详情请参考&lt;a href=&quot;http://hightopo.com/guide/guide/core/shape/ht-shape-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 形状手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;想让2d图片在3d管线上移动则是使用g3d.toViewPosition(position)来获取3d模型的二维坐标，这个函数中的参数就是三维模型的3d坐标，我们可以直接将polyline管线上的点传入toViewPosition函数中，这边获取管线上的点在ht中已经封装好三个函数getLineCacheInfo、getLineLength、getLineOffset，这样就可以直接获取到二维坐标，然后将img的坐标设置上去即可，以下是img图片在管道上移动的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; delta = 10&lt;span&gt;;  
params &lt;/span&gt;=&lt;span&gt; {  
    frames: Infinity,  
    interval: &lt;/span&gt;50&lt;span&gt;,  
    action: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(v, t){  
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length = (polyline.a('total') || 0) % polyline.a('length') +&lt;span&gt; delta;  
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cache =&lt;span&gt; ht.Default.getLineCacheInfo(polyline.getPoints(), polyline.getSegments());  
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lineLength =&lt;span&gt; ht.Default.getLineLength(cache);  
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; offset =&lt;span&gt; ht.Default.getLineOffset(cache, length);  
        arr &lt;/span&gt;=&lt;span&gt; [offset.point.x, offset.point.y, offset.point.z];  
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; position =&lt;span&gt; g3d.toViewPosition(arr);  
            img.style.left &lt;/span&gt;= (position.x - 5) + 'px'&lt;span&gt;;  
            img.style.top &lt;/span&gt;= (position.y - 5) + 'px'&lt;span&gt;;  
            polyline.a(&lt;/span&gt;'total'&lt;span&gt;, length);  
    }  
};  
anim &lt;/span&gt;= ht.Default.startAnim(params);  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到图中第二层中的立方体上有“SDH”的字样，我是通过设置shape3d.top.img: imgURL来实现的，这边的imgURL可以是图片的相对路径，也可以是ht中用ht.Default.setImage声明的img的名称，还可以是json格式构造的图片。在ht中，2D文字显现在3D上，则字体周围会出现“锯齿”，这个时候只要设置“label.transparent: true”即可。&lt;/p&gt;
&lt;p&gt;我们还可以看到第二层上有两个特殊的多边形“平行四边形”和“梯形”，因为之前有客户说不知道如何使用createExtrusionModel这个模型函数（&lt;a href=&quot;http://hightopo.com/guide/guide/plugin/modeling/ht-modeling-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 建模手册&lt;/a&gt;），我索性就写了一下，平行四边形是靠createParallelogramModel模型函数，这个函数比较简单，createExtrusionModel(array, segments, top, bottom, resolution, repeatUVLength, tall, elevation)，array是你要形成的图形的坐标点，这边只是针对于xz轴上画的平面图形，segments指的是如何连接这几个坐标点，可参考&lt;a href=&quot;http://hightopo.com/guide/guide/core/shape/ht-shape-guide.html&quot; target=&quot;_blank&quot;&gt;HT for Web 形状手册&lt;/a&gt;，top和bottom就是让你选择是否有顶部或者底部，resolution微分段数，我们描绘一段曲线的时候可能只要确认几个个别的点然后在每两个点之间的连线上把它分成多个段，这样这条线段就会变得平滑，ht为了用户能够轻松操作这些线段，就封装了这一个参数，repeatUVLength默认为空，设置值后顶部和底部的贴图将根据制定长度值进行重复，tall模型的高度，默认为5，elevation模型中心的&lt;code&gt;y&lt;/code&gt;轴位置，默认值为0，设置这个值可以使xz上的平面绕着y轴旋转。&lt;/p&gt;
&lt;p&gt;底层的一个环形的效果是通过一个算法来实现的，环形得确认这个环形上有多少个元素，然后算每两个之间的角度，在通过sin、cos来计算每一个元素的位置，得出了如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
names = ['设备2', '设备3', '设备4', '设备5', '设备6', '设备7', '设备8', '设备9'&lt;span&gt;];  
names.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name, index) {  
　　　　x &lt;/span&gt;= 400, y = 200, angle = 45, r = 120&lt;span&gt;;  
　　　　x &lt;/span&gt;= x3 + Math.sin((2 * Math.PI / 360) * angle * index) *&lt;span&gt; r;  
　　　　y &lt;/span&gt;= z3 + Math.cos((2 * Math.PI / 360) * angle * index) *&lt;span&gt; r;  
　　　　device &lt;/span&gt;= createRect([x, y3 + 15, y], [w * 0.1, 15, h * 0.1], '', ''&lt;span&gt;, floor3);  
　　　　createEdge(device5, device);  
}); &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 17 Oct 2017 03:36:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/7680809.html</dc:identifier>
</item>
<item>
<title>一款低延迟的分布式数据库同步系统--databus - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/7652386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/7652386.html</guid>
<description>&lt;p&gt;　　每次看到马路对面摩托罗拉的大牌子，都想起谷歌125亿美元收购摩托罗拉移动，后来又以29亿美元卖给联想的事情。谷歌所做的决策都比较考虑长远利益，在这串交易中，谷歌获得了摩托罗拉最有价值的几千项专利，稳健了Android的生态。谷歌曾经在美国一个地区占用巨大的面积建立了太阳能发电站，人称“烤鸟”项目。因为鸟儿从此地飞过会因为太热而从天上掉下来变成熟鸟。而产生的电能仅够一个小村庄使用。但是正是这种愿意去尝试才推动了科技的发展。让谷歌这么多年屹立不倒。&lt;/p&gt;

&lt;p&gt;　　Databus是LinkedIn开源的一款低延迟的分布式数据库同步系统（a source-agnostic distributed change data capture system），它提供可靠的数据捕获、流转和数据处理功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　  主要应用场景：跨部门之间或者跨机房之间进行数据库的数据订阅。同类产品有阿里的canal。支持Oracle和Mysql数据库。&lt;/p&gt;
&lt;p&gt;      Databus和canal一样，数据都是基于数据库日志挖掘来做的。我之前的博客也提到了，当今的数据处理大致可以分为两类：联机事务处理OLTP(OnLine Transaction Processing)和联机分析处理OLAP(OnLine Analytical Processing)。&lt;/p&gt;
&lt;p&gt;　　OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。但是平常所说的OLTP是集成到SQL Server中的数据库引擎组件，因为微软有个白皮书《SQL Server In-Memory OLTP Internals Overview》。但是OLTP实际上可以称之为：面向交易的实时处理系统。性能指标是TPS。&lt;/p&gt;
&lt;p&gt;　　OLAP是快速响应多维分析的一种解决方案。面向的数据源是数据仓库。支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。&lt;/p&gt;
&lt;p&gt;　　再回来说Databus，Databus最重要的特点是其无限回溯功能。当消费者完整数据拷贝，或者消费者的已有数据和主OLTP数据库相差很大时能够低延时的进行同步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;核心组件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Databus的核心组件是Databus Relay。主要负责两个工作：&lt;/p&gt;
&lt;p&gt;　　1&amp;gt;从Databus源数据库中读取变化行，并序列化为事件流保存至内存中。&lt;/p&gt;
&lt;p&gt;　　2&amp;gt;接受客户端的请求，并将数据变化事件流返回给客户端。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　databus使用了open-replocator作为获取数据库变更事件的组件。功能是实时获取mysql的binlog日志，并封装成Event对象，然后调用已注册的listener进行处理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;技术架构：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Event Producer:用来读取数据库的变化事件，转化为AVRO类型并存储至内存中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　下面说说AVRO. Apache Avro是一个独立于编程语言的数据序列化系统，该项目由Hadoop之父牵头创建。它可以提供：丰富的数据结构类型，快速可压缩的二进制数据形式，存储持久数据的文件容器，远程过程调用，同动态语言的简单集成。读写数据文件和使用RPC协议都不需要生成代码，而代码生成作为一种可选的优化只值得在静态类型语言中实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Circular Buffer:Relay有一个或多个环形的缓冲池用来保存按递增的系统变化号(SCN)为顺序的变化事件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　细心的读者会发现每个中间件都有自己比较独特的缓冲策略，这种缓冲策略很大成熟决定了此中间件的好坏。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SCN Writer/Reader:用来读取和吸入SCN号至硬盘。&lt;/li&gt;
&lt;li&gt;RESTFUL interface:它暴露一个restful接口，用来推送数据变化事件至客户端。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;源码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Databus是用java开发的。github地址是：https://github.com/linkedin/databus。　　&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跑题时间：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　自从毕业后上班开始就时不时自己能够感觉到一些问题。比如：比较着急的时候我眉头是紧锁着的，说话客气不起来了。再比如我说话的方式也是技巧不足的。这些看起来不是核心的问题现在却是我的第一要务。因为之前有问题没关系，我不做管理，我就管我自己。那么这些小毛病顶多影响我自己。现在我的很多决定都直接影响到我们团队。&lt;/p&gt;
&lt;p&gt;　　所以，在实际影响范围可控的情况下，我反而会将问题更明显出来，自己制造些小矛盾。为什么这么做呢，因为我从来不做“大家都说这样做是对的”的事情。我只做自己心里完全接受的事情。　　&lt;/p&gt;
&lt;p&gt;　　之前认识我的人都知道我嗓门很大。现在好一点了，虽然也有时会忘了降低嗓门。我娘家在我们镇上最繁华的地段，后面是菜市场。每天早上3点就很吵了。我屋的窗户正好对着市场。所以我从小练就了“再吵和我没关系”的本事，所以我对噪音很不敏感。所以我是花了很大力气才让自己心里完全接受了“这样会打扰别人，最好的音量是不要太大，震到别人耳朵，也不要太小，别人听不清”&lt;/p&gt;
&lt;p&gt;　　我现在需要让自己了解到自己的问题会产生什么样的后果，确实是有问题的。但是这样做确实是很笨的方法。聪明人是自己完全可以预见到的，人生会走很多弯路。&lt;/p&gt;
&lt;p&gt;　　我工作十年，实质性的提高是没有的。刚毕业的时候，我的学历差不多就是目前所在这个级别的公司。人人，乐视，新美大。并没有级别上的提升，反而职级上比同届的要低。&lt;/p&gt;
&lt;p&gt;　　跟别人相比，可能我一年过了日语1级，去过日本。后来去过美国硅谷。也有上百个专利。我在想这些为什么都没能给我带来实实在在的好处。&lt;/p&gt;
&lt;p&gt;　　我学语言能力确实很强，但是我单纯只想做技术。自己的任性是要有代价的。代价就是语言能力没有用武之地。&lt;/p&gt;
&lt;p&gt;　　去过日本和硅谷，这是工作机遇，并不是什么能力。应该给我带来的是气质，谈吐。但是我的气质和谈吐并没有上去。也就是我白去了，去了没学到东西。素养没提高。&lt;/p&gt;
&lt;p&gt;　　专利是要真正给公司带来利益才有价值的，和数量没有关系。我并没有哪个专利特别好，发挥了特牛逼的作用。&lt;/p&gt;
&lt;p&gt;　　总的来看，我是一个非常普通，还有1个半月就过31岁生日的老技术。完全没有优势。并且，我还有点浮躁。&lt;/p&gt;
&lt;p&gt;　　去乐视之前，我的每一次努力都发生在不得不努力的时候。升学前，因为担心，考不上怎么办呀，于是努力成绩上去了。危机没了又回到原来。上班有任务压我，我就努力干。因为干不完怎么办呀，这是我的责任。然后基本就是忙一个月两个月闲个半年。&lt;/p&gt;
&lt;p&gt;　　去乐视的时候，我有个好开头。为什么呢，因为去乐视之前，我自己趟了趟浑水，当然不是工作上的。但是我在乐视的时间自己都很郁闷。直到最后我在自己脸上身上刻了好几个疤，近1年才好，这段时间我都在郁闷自己身上的疤，原来因为什么事情郁闷完全都不记得了。所以这是我最不浮躁的一段时间。不过，我觉得和别人相比，也挺浮躁的。&lt;/p&gt;
&lt;p&gt;　　现在来说，我觉得起点是很低的。突然觉得自己一无所有。但是好歹各个阶段该做的事情都做了，该试的错也实实在在试过了。我得到了我真正想得到的东西。放弃的，都是自己觉得不值得。就剩一件事了，我想在工作上达到我应该达到的高度。因为IT行业对年龄和女孩子都是很残酷的。我不图名，不图利，不爱权利，但是我想工作。&lt;/p&gt;
&lt;p&gt;　　现在的公司，大家都有我很多我值得学习的地方。不跟着别人学，自身的成长也需要很多的提高。方法论方面，架构方面。我还不能拖的时间很长来适应，我需要尽快能够有一些时间，每天写点代码，根本的东西不想放下。&lt;/p&gt;
&lt;p&gt;　　一直以来都不喜欢被别人叫老。也一直以来都没成熟大方得体。有时候头发很乱，有时候不经考虑。这是年轻，希望别人喜欢自己原本的样子。现在，越来越多的考虑怎么把事情做好。静儿的文章哪有不秀恩爱的。今天我只想说谢谢男神在我还年轻的时候遇到我，一心做事情的人恐怕不会再爱上谁。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Oct 2017 03:09:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/7652386.html</dc:identifier>
</item>
</channel>
</rss>