<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用于浏览器桌面通知的Web API 接口 -notification - 恩恩先生</title>
<link>http://www.cnblogs.com/engeng/p/8341988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/engeng/p/8341988.html</guid>
<description>&lt;pre class=&quot;line-numbers language-html&quot;&gt;
&lt;code class=&quot; language-html&quot;&gt;notification&lt;/code&gt; 接口用于浏览器向用户提供通知内容；常见的如网页版的微信：&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038573/201801/1038573-20180124133158506-805825013.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、实现，需要Notifications API 提供的&lt;strong&gt;通知&lt;/strong&gt;接口：&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let notification = &lt;span&gt;new&lt;/span&gt; Notification(title, options)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;title参数：用于通知的主题；&lt;/p&gt;
&lt;p&gt;options参数：是一个对象；用于&lt;strong&gt;配置被通知对象 notification 的属性&lt;/strong&gt;；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; options=&lt;span&gt;{
    dir:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;auto自动；ltr 从左到右；rtl 从右到左；&lt;/span&gt;
    lang：&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定通知使用的语言；&lt;/span&gt;
    body:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知中额外显示的字符串；&lt;/span&gt;
    icon:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片的URL，用于通知的图标；&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; options =&lt;span&gt; {
  body: &lt;/span&gt;'this is a beautiful world'&lt;span&gt;,
  dir: &lt;/span&gt;'rtl'&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; notify1 = &lt;span&gt;new&lt;/span&gt; Notification('hello world'&lt;span&gt;,options);

console.log(options.body&lt;/span&gt;==notify1.body)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true;&lt;/span&gt;
console.log(options.dir==notify1.dir)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//options对象的属性都是绑定到 Notifiaction 的实例对象属性上的。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仅仅是构造一个Notification 对象的实例还不够；&lt;/p&gt;
&lt;p&gt;2、获取通知权限 &lt;code&gt;&lt;code&gt;Notification.permission：&lt;/code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　granted: &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户已经明确的授予了显示通知的权限。.&lt;/span&gt;
　　denied: &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户已经明确的拒绝了显示通知的权限。&lt;/span&gt;
　　&lt;span&gt;default&lt;/span&gt;: &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户还未被询问是否授权; 这种情况下权限将视为 denied.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、请求用户权限：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Notification.requestPermission()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;requestPermission()方法接受一个回调函数；这个&lt;strong&gt;回调函数接受一个参数；即requestPermission()返回的 &lt;code&gt;&lt;code&gt;permission&lt;/code&gt;&lt;/code&gt; 状态&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;4、完整的通知权限请求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
        &amp;lt;button onclick=&quot;notify()&quot;&amp;gt;点我查看&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先检查浏览器是否支持&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; notify(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!('Notification' &lt;span&gt;in&lt;/span&gt;&lt;span&gt; window)) {
        alert(&lt;/span&gt;'你的浏览器不支持Notification'&lt;span&gt;)
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否拥有通知权限；有就通知，没有请求；&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Notification.permission=='granted'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options=&lt;span&gt;{
        icon:&lt;/span&gt;'http://www.itechat.cn/ya8526/html/images/img10.jpg'&lt;span&gt;,
        body:&lt;/span&gt;'such a beautiful wolrld!'&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; notification=&lt;span&gt;new&lt;/span&gt; Notification('hello wolrld!'&lt;span&gt;,options);
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Notification.permission !== 'denied'&lt;span&gt;){
    Notification.requestPermission(
            &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(permission){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (permission=='granted'&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; notification=&lt;span&gt;new&lt;/span&gt; Notification('hello wolrld!'&lt;span&gt;);
                }
            }
        );
}
}
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是；第一次需要申请权限；用户授权之后就能正常显示通知内容；用户如果忽视请求，再次点击会再次请求；用户选择拒绝，则浏览器会忽视，代码终止。&lt;/p&gt;
&lt;p&gt;再次注意的是 ；Notification.requestPermission(callback)这种回调写法已经被弃用；取而代之的是基于promise的语法；其中js部分&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先检查浏览器是否支持&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; notify(){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!('Notification' &lt;span&gt;in&lt;/span&gt;&lt;span&gt; window)) {
        alert(&lt;/span&gt;'你的浏览器不支持Notification'&lt;span&gt;)
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否拥有通知权限；有就通知，没有请求；&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Notification.permission=='granted'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options=&lt;span&gt;{
        icon:&lt;/span&gt;'http://www.itechat.cn/ya8526/html/images/img10.jpg'&lt;span&gt;,
        body:&lt;/span&gt;'such a beautiful wolrld!'&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; notification=&lt;span&gt;new&lt;/span&gt; Notification('hello wolrld!'&lt;span&gt;,options);

}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (Notification.permission !== 'denied'&lt;span&gt;){
    Notification.requestPermission().then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(result){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(result=='granted'&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; notification=&lt;span&gt;new&lt;/span&gt; Notification('hello wolrld!'&lt;span&gt;,options);
        }
    })    
}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.itechat.cn/notification.html&quot; target=&quot;_blank&quot;&gt;测试地址(火狐正常)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;谷歌浏览器对于这种写法没有响应，火狐正常； 原因是http站点的安全性问题，需要将站点升级到HTTPS。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1038573/201801/1038573-20180124152751053-1122303487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MDN上有更多的实例属性和事件处理；&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/notification&quot; target=&quot;_blank&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;





&lt;pre class=&quot;line-numbers language-html&quot;&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 24 Jan 2018 07:47:00 +0000</pubDate>
<dc:creator>恩恩先生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/engeng/p/8341988.html</dc:identifier>
</item>
<item>
<title>【端-iOS】iOS开发编码规范小结 - colorful_flowers</title>
<link>http://www.cnblogs.com/zhanqin/p/8341967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanqin/p/8341967.html</guid>
<description>&lt;p&gt;规范编码可以提高代码的可读性，降低维护成本。作为一个程序员，要对自己写的代码负责，虽然bug无可避免，但是写代码时最基本的编码规则还是应该遵守的，否则不是坑自己就是坑别人，因为代码肯定是要维护的。&lt;br/&gt;下面我主要讲一下从建项目到开发写代码时应该注意的一些地方和自己的一点建议。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;项目名称：项目名字的英文或者拼音全拼形式（如果比较长也可以选择缩写），建议每个单词或者拼音的首字母都大写。&lt;/li&gt;
&lt;li&gt;Bundle Identifier：唯一标识符，最好包含公司的名字和项目名字，我一般用的格式为：www.公司名称或缩写.项目名称.www，已经被别人在开发者证书中心注册过的Bundle Identifier就无法再次添加到自己的证书中心，所以带上公司名和项目名可以防止用了已经被占用的Bundle Identifier。&lt;/li&gt;
&lt;li&gt;目录结构中的文件夹命名：在用xcode开发时，左边的项目目录结构用的比较多，也是一个很关键的地方，所以建议这里的文件夹目录能放的比较有层次，这样在找代码和修改代码的时候方便。文件夹的名字应该与文件夹中所放代码的作用或者所属模块相关联，名字可用英文或者拼音缩写，首字母大写，中文也是可以用的，但是我个人不建议用中文，原因大家都懂。文件夹可以含多层，比如首页模块的功能，第一层可以是Home文件夹，然后在这个里面可以再细分视图、数据、交互等。另外有些人也有习惯给代码中的文件夹加上统一的前缀，这也是可以的，看上去也很舒服。&lt;/li&gt;
&lt;li&gt;类名：建议带上固定的前缀和相应的后缀，在二者之间填上类所实现的功能。先来说固定的前缀，比如说AFNetWorking，这个第三方库，类名都是以AF开头的，我们自己写的类名也可以，这个前缀可以用项目名字的首字母缩写、公司名缩写或者任何你喜欢的字母组成，加这个前缀有两个好处，一个项目目录整齐，还有一个就是项目中的模块拿到别的项目中使用可以很大程度上降低类名相同而造成不能直接使用的概率。相应的后缀指的是此类所属的类型，比如如果此类为ViewController的子类，那么类名可以以ViewController或者简写成VC来结尾，这样这个类是个ViewController还是个view一目了然。中间为此类要实现的功能相关是为了看类名就能知道这个类是干什么用的，比如MMHomeViewController这个类名，MM为项目名称缩写，Home代表首页，ViewController表示该类为一个视图控制器，一看这个类名就很容易知道这个类中写的是首页的实现的代码。有一些继承自NSObject类的单例可以以Manager为后缀。类名首字母大写。&lt;/li&gt;
&lt;li&gt;成员变量：最最基本的应该见名知意，最好有变量对应的类型的后缀，首字母小写。比如loginButton，这样就很好理解，一看就知道这代表一个登录按钮。成员变量是整个类都能用的，如果起名很随意，代码理解起来可能比较困难。首字母小写，遵守驼峰规则。&lt;/li&gt;
&lt;li&gt;局部变量：同上需要见名知意，虽然存在的范围小，但是也很影响阅读性，千万不要取什么arr1、arr2之类的，很难知道里面放的是什么。首字母小写，遵守驼峰规则。&lt;/li&gt;
&lt;li&gt;代理/协议名：该协议对应的类的类名+Delegate/Protocol，首字母大写。&lt;/li&gt;
&lt;li&gt;方法名：每个参数前的英文块首字母小写，遵守驼峰规则。方法名以该方法所实现的功能为主，所需参数的参数名最好能带上该参数的类型，这样调用起来方便，看方法名可知在哪儿用，看参数名可知所需什么参数。&lt;/li&gt;
&lt;li&gt;注释：在这里特意加上注释，其实并不是要谈注释的规范，而是想说，命名不会规范的程序员在写代码的时候记得多写点注释，绝对没坏处！！！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后说一下自己的亲身体验，接手过一套代码，类名随便取，很多继承自ViewController的视图控制器都以view结尾，变量名更不用说，看代码的时候还得靠猜这个变量里面放的是什么。记得印象比较深的是，在一个单例类中有一个type变量，看调用的地方挺多，有设置为1的，有设置为2的，也有拿来做判断条件的，完全不知道这个值的意义是什么。跟写代码的人沟通，他自己也忘记掉了，也不知道用的地方为什么那么用。这只是印象比较深的一个，他唯一的说辞是他自己开发技术太菜。但是我觉得，编码是否规范与技术水平高低关系不是很大，代码风格更多的是反映一个程序员的编程习惯的态度。实在不会规范，那就加注释，简单的注释一下变量是用来干嘛的等等。&lt;br/&gt;编程技术水平有高低，但是认真的态度不该有差别，一个程序员可以写不出很炫很酷很牛的代码，但是千万不要随意的写出难以阅读和维护的代码！&lt;br/&gt;这些规范也是我自己的一些小总结，希望能给刚入门的一些人一点提醒和帮助。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 07:44:00 +0000</pubDate>
<dc:creator>colorful_flowers</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanqin/p/8341967.html</dc:identifier>
</item>
<item>
<title>Redis进阶实践之五Redis的高级特性 - PatrickLiu</title>
<link>http://www.cnblogs.com/PatrickLiu/p/8341951.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PatrickLiu/p/8341951.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;    上一篇文章写了Redis的特征，使用场景，同时也介绍了Redis的基本数据类型，redis的数据类型是操作redis的基础，这个必须好好的掌握。今天我们开始介绍一些Redis的高级特性，虽然有些命令很简单，但是这些命令是使用很广泛的，并且是通用的一些命令，好好的把握这些命令，通过组合这些命令可以完成比较复杂的任务，这都是基础，我们就开始我们今天的学习之旅吧。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;二、Redis的高级特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   下面我们就是Redis高级特性的每个知识点，只是个人的理解，随着学习的深入，也会更新相关的章节。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;  1、通用命令：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;    1.1】、语法：keys pattern，pattern可以是类似正则的匹配规则，可以是*，也可以是?，返回匹配规则的键值key的列表。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;3&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys n*
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys s*
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys &lt;span&gt;set&lt;/span&gt;?
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;set1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys n?&lt;span&gt;me
           &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.2】、语法：exists key [key ...]，判断一个或者多个key是否存在，并返回存在key的个数，不存在返回0。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;exists name age address(该值存在)
           （integer）&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;exists name1 age1 address(该值存在)
           （integer）&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.3】、语法：expire key seconds，给指定的key设置过期时间，单位是秒。用ttl命令可以查看剩余的时间，如果想更精确的、性能更好的倒计时功能，可以使用该功能。设置过期时间成功返回值为1，此命令可以多次执行，后面的过期值会覆盖前面的过期值。过期的数据会从Redis数据库里删除。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;expire name &lt;span&gt;60&lt;/span&gt;&lt;span&gt; 设置name过期时间为60秒
           （integer）&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;expire name &lt;span&gt;50&lt;/span&gt;&lt;span&gt; 设置name过期时间为50秒
           （integer）&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;ttl name
           （integer）&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;ttl name
           （integer）&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;&lt;span&gt;

            ttl返回值：

              &lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;、过期时间不存在

              &lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;、过期操作成功，数据已经移除
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.4】、语法：persist key，取消已经设置了过期时间的key的过期策略。取消过期策略成功返回1，key没有过期策略返回0。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;expire name &lt;span&gt;60&lt;/span&gt;&lt;span&gt; 设置name过期时间为60秒
           （integer）&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;persist name
           （integer）&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功取消设置的过期策略&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;persist name
           （integer）&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上一步已经取消了，在此执行取消操作返回0。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.5】、语法：select index，在Redis中，逻辑划分为16个数据库，索引从0-15，我们在使用的过程中，可以针对不同的业务逻辑把数据缓存在不同的数据库，这是一个很好的架构设计，切记不要把所有的数据放在0号数据库里，不便于管理和分类。这16个数据库数据是分离的，不是共享的，或者说数据都是独立的。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
           OK

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;]&amp;gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;]&amp;gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
           OK

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;[&lt;span&gt;5&lt;/span&gt;]&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.6】、语法：move key db,至指定名称为key的键值对转移到指定数据库db里面，db是数据下标索引。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引为0的数据库&lt;/span&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引为5的数据库&lt;/span&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;[&lt;span&gt;5&lt;/span&gt;]&amp;gt;keys *&lt;span&gt;
           (empty list or &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;)

           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在索引为5的数据库里面增加sex键值对，然后把其移动到索引为0的数据库&lt;/span&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;[&lt;span&gt;5&lt;/span&gt;]&amp;gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt; sex nan
           OK

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;[&lt;span&gt;5&lt;/span&gt;]&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;[&lt;span&gt;5&lt;/span&gt;]&amp;gt;move sex &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
           (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;

           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引为0的数据库&lt;/span&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从索引为5的数据已经移动到了索引为0的数据库&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.7】、语法：randomkey，随机返回当前数据库中的key，其实这个功能我们可以使用在抽奖的场景，如果在并发比较高，而且有要保证性能的情况下，我建议大家使用Redis的这个功能来完成抽奖的功能。有时候会返回重复的值，如果做抽奖需要做处理一下。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;randomkey
           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;randomkey
           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;randomkey
           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.8】、语法：rename key newkey，重新给指定的key命名。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;rename name name1
           OK

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;rename name1 name
           OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.9】、语法：echo message，在当前介质上打印message信息。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;echo patrickLiu
           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;patrickLiu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.10】、语法：dbsize，返回当前数据中键值对的个数，或者更准确的说是key的个数。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;dbsize
           &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.11】、语法：info [section]，可以获取当前数据的详细信息。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;info &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示当前数据的所有数据&lt;/span&gt;


           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;info replication &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示指定节的信息&lt;/span&gt;
&lt;span&gt;           # Replication

           role：master
           connected_slaves:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
           ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.12】、语法：config get *，获取配置文件中的所有的配置数据。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;config &lt;span&gt;get&lt;/span&gt; *&lt;span&gt;
           ...

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;config &lt;span&gt;get&lt;/span&gt;&lt;span&gt; bind
           &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.127.128&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;config &lt;span&gt;get&lt;/span&gt;&lt;span&gt; port
           &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;）&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.13】、语法：flushdb，清空当前数据所有的键值对。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;flushdb
           OK

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *&lt;span&gt;
           (empty list or &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;    1.14】、语法：flushall，清空所有数据库的所有键值对。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;flushall
           OK


           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;]&amp;gt;keys *&lt;span&gt;
           (empty list or &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;)

           ...

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;[&lt;span&gt;5&lt;/span&gt;]&amp;gt;keys *&lt;span&gt;
           (empty list or &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;)

           ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;  2、安全设置&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     &lt;strong&gt;2.1】、vi 或者 vim 编辑 redis.conf 文档，修改&lt;/strong&gt;&lt;br/&gt;     &lt;br/&gt;          #requirepass 123456 （设置密码）&lt;br/&gt;          &lt;br/&gt;           requirepass admin&lt;/p&gt;&lt;p&gt;  &lt;strong&gt;   2.2】、重启服务器 pkill redis-server&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
           [root@linux~]# application/program/redis-tool/redis-cli -h &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt; -p &lt;span&gt;6379&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *&lt;span&gt;
           (error)NOAUTH Authentication required.

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;auth admin   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;授权&lt;/span&gt;
&lt;span&gt;            OK

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以执行&lt;/span&gt;
           (empty list or &lt;span&gt;set&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;     &lt;strong&gt;2.3】、[root@linux~]/root/application/program/redis-tool/redis-cli -h 192.168.127.128 -p 6379 -a admin&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;  3、事务模型&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     redis也是支持事务的，但是这个事务是比较简单的，之所以说简单，是因为redis的事务不能保证操作的同时成功或者同时失败而进行提交或者回滚，这种情形很容易导致数据的不一致性，大家使用的时候要特别注意。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;     3.1】、首先通过multi命令开启事务，然后进行事务性的设置，这些设置完的数据会存储在虚拟队列中，最后可以通过exec命令执行事务。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前数据库中无值&lt;/span&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *&lt;span&gt;
           (empty list or &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;)


           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;multi
           OK

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; p1 &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
           QUEUED

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; p2 &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
           QUEUED

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; p3 &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
           QUEUED

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;exec
           &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)OK
           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)OK
           &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)OK

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;3&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;   &lt;strong&gt;  3.2】、redis的事务可以通过discard命令取消事务。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前数据库中的值&lt;/span&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;3&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;multi
           OK

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; p4 &lt;span&gt;4&lt;/span&gt;&lt;span&gt;
           QUEUED

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;set&lt;/span&gt; p5 &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
           QUEUED

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;discard  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消事务&lt;/span&gt;
&lt;span&gt;           OK

           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;值没变&lt;/span&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;3&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;  &lt;strong&gt;   3.3】、特别注意redis事务的不一致性。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前数据库中的值&lt;/span&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;keys *
           &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; name
           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;huangfeihong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; age
           (integer)&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;multi
           OK

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;incr name
           QUEUED

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;incr age
           QUEUED

           &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;exec
           &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)(error)ERR value &lt;span&gt;is&lt;/span&gt; not an integer or &lt;span&gt;out&lt;/span&gt;&lt;span&gt; of range
           &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;)(integer)&lt;span&gt;19&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; name
           &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;huangfeihong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;姓名没有改变&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt; age
           (integer)&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前年龄已经修改&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;      再次强调，在真正的产品环境中，要特别注意Redis事务的这个特点，或者说是弊端，不能保证数据的一致性。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;  4、持久化&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     Redis是一种高级key-value数据库。它跟memcached类似，不过数据可以持久化。Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。所以来说，总结起来，Redis的数据持久化就有两种方式。&lt;/p&gt;&lt;p&gt;     &lt;strong&gt;4.1】、第一种方法filesnapshotting（rdb）&lt;/strong&gt;：默认redis是会以快照的形式将数据持久化到磁盘的（一个二进制文件，dump.rdb，这个文件名字可以指定），在配置文件中的格式是：save N（秒数） M（改变的个数），表示在N秒之内，redis至少发生M次修改，redis才生成快照并持久化到磁盘。当然我们也可以手动执行save或者bgsave（异步）做快照。该模式无论怎么设置，都会产生时间间隔，如果在这时间间隔断电，数据还是会丢失，会对数据持久化产生不利的影响，在实际的生产环境中，不建议使用该模式。&lt;/p&gt;&lt;p&gt;          save 900 1     900秒内有超过1个的key值被修改了就发起快照保存&lt;/p&gt;&lt;p&gt;          save 300 30    300秒内有超过30个的key值被修改了就发起快照保存&lt;/p&gt;&lt;p&gt;          save 60  10000 60秒内有超过10000个的key值被修改了就发起快照保存&lt;/p&gt;&lt;p&gt;   &lt;strong&gt;  4.2】、第二种方法是Append-only-file（aof）&lt;/strong&gt;：Append-only方法可以做到全部数据不丢失，但redis的性能就要差些。AOF就可以做到全程持久化，只需要在配置文件中开启，默认是不打开AOF功能的（appendonly no），appendonly yes开启AOF之后，redis每执行一个修改数据的命令，都会把它添加到aof文件中，当redis重启时，将会读取AOF文件进行“重放”以恢复到redis关闭前的最后时刻。&lt;/p&gt;&lt;p&gt;          appendfsync有三个选项：always、everysec和no：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;         1、always：服务器会在每执行一个事件就把AOF缓冲区的内容强制性的写入硬盘上的AOF文件里，可以看成你每执行一个redis写入命令就往AOF文件里记录这条命令，这保证了数据持久化的完整性，但效率是最慢的，却也是最安全的；&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;         2、everysec：服务端每执行一次写操作也会把该条命令追加到一个单独的AOF缓冲区的末尾，并将AOF缓冲区写入AOF文件，然后每隔一秒才会进行一次文件同步把内存缓冲区里的AOF缓存数据真正写入AOF文件里，这个模式兼顾了效率的同时也保证了数据的完整性，即使在服务器宕机也只会丢失一秒内对redis数据库做的修改；&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         &lt;strong&gt;3、no：你完全可以接受Redis数据的丢失，它虽然也会把每条写命令追加到AOF缓冲区的末尾，然后写入文件，但什么时候进行文件同步真正把数据写入AOF文件里则由系统自身决定，即当内存缓冲区的空间被填满或者是超过了设定的时限后系统自动同步。这种模式下效率是最快的，但对数据来说也是最不安全的，如果redis里的数据都是从后台数据库如mysql中取出来的，属于随时可以找回或者不重要的数据，那么可以考虑设置成这种模式。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;        [root@linux~]# more application/program/redis-tool/redis.conf&lt;br/&gt;        dir &quot;/root/application/program/redis-tool/datas/&quot;           #AOF或者RDB文件存放目录&lt;br/&gt;        appendonly yes                       #启用AOF持久化，默认关闭，RDB模式就关闭了，两者是二选一的情况&lt;br/&gt;        appendfilename &quot;appendonly.aof&quot;      #AOF持久化的文件名称（默认）&lt;br/&gt;        appendfsync no                       #AOF持久化的策略&lt;br/&gt;        auto-aof-rewrite-percentage 100      #触发AOF文件重写的条件（默认）&lt;br/&gt;        auto-aof-rewrite-min-size 64mb       #触发AOF文件重写的条件（默认）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;  5、发布订阅&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;     Redis的这个发布订阅功能有点类似MQ（消息队列）功能，但是这功能不能滥用，它的使用场景非常有限，并且数据量也不能太大。比如：成千上万条的数据场景是可以满足的，如果订阅和发布的数据量超过N万、十万、千万或者亿级别，这样的场景就很难满足了，到那时候我们就需要使用真正的MQ来满足该功能了。&lt;/p&gt;&lt;p&gt;     5.1】、&lt;strong&gt;语法：subscribe channel [channel ...]&lt;/strong&gt;，进行订阅监听，可以接受来之发布端的消息了。可以定义多个频道，这个频道的名称是自己可以定义的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;subscribe c1 c2
           Reading messages...(press Ctrl&lt;/span&gt;-&lt;span&gt;C quit)         
           &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;subscribe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;3&lt;/span&gt;)(integer)&lt;span&gt;1&lt;/span&gt;
           &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;subscribe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;3&lt;/span&gt;)(integer)&lt;span&gt;2&lt;/span&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接受的到的消息&lt;/span&gt;
           &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;3&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
           &lt;span&gt;3&lt;/span&gt;)&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处于等待状态，可以接收消息了&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;     5.2】、&lt;strong&gt;语法：publish channel message&lt;/strong&gt;，针对指定的消息频道发布消息，订阅端就可以接受到消息了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;publish c1 hello
           (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布消息成功&lt;/span&gt;

           &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;127.128&lt;/span&gt;:&lt;span&gt;6379&lt;/span&gt;&amp;gt;&lt;span&gt;publish c2 redis
           (integer)&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布消息成功&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;三、总结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;   随着学习的深入，理解的越来越全面和深刻了，以前很多联系不起来的知识点都联系起来了，以后还需继续努力，如果有了新的学习心得，还会持续更新相关的章节。随着学习的继续，也让自己养成学习的习惯。努力吧！！！！&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 07:42:00 +0000</pubDate>
<dc:creator>PatrickLiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PatrickLiu/p/8341951.html</dc:identifier>
</item>
<item>
<title>如何开发由Create-React-App 引导的应用（一） - JobbyM</title>
<link>http://www.cnblogs.com/JobbyM/p/8341928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JobbyM/p/8341928.html</guid>
<description>&lt;blockquote readability=&quot;1.8235294117647&quot;&gt;
&lt;p&gt;此文章是翻译&lt;a href=&quot;https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md&quot;&gt;How to develop apps bootstrapped with Create React App&lt;/a&gt; 官方文档&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;系列文章&quot;&gt;系列文章&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;如何开发由Create-React-App 引导的应用&lt;/li&gt;
&lt;li&gt;如何开发由Create-React-App 引导的应用（二）&lt;/li&gt;
&lt;li&gt;如何开发由Create-React-App 引导的应用（三）&lt;/li&gt;
&lt;li&gt;如何开发由Create-React-App 引导的应用（四）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;updating-to-new-release&quot;&gt;Updating to New Release&lt;/h2&gt;
&lt;p&gt;Creat React App 分成两个包：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;create-react-app&lt;/code&gt; 是用于创建新项目的全局命令行工具。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;react-scripts&lt;/code&gt; 是在新建项目中的开发依赖。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;几乎不需要更新&lt;code&gt;create-react-app&lt;/code&gt; 自身：它将所有的设置委托给了&lt;code&gt;react-scripts&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;当你运行&lt;code&gt;create-react-app&lt;/code&gt; 时，它总是使用&lt;code&gt;react-scripts&lt;/code&gt; 的最新版本来创建项目，以便你自动获得所有的新特性和改进。&lt;/p&gt;
&lt;p&gt;要将现有项目更新为&lt;code&gt;react-scripts&lt;/code&gt; 的最新版本，&lt;a href=&quot;https://github.com/facebookincubator/create-react-app/blob/master/CHANGELOG.md&quot;&gt;打开更新日志&lt;/a&gt;，找到你当前正在用的版本（可以在&lt;code&gt;package.json&lt;/code&gt;中找到），按照最新版本的迁移说明来操作。&lt;/p&gt;
&lt;p&gt;在大多数情况下，更改&lt;code&gt;packages.json&lt;/code&gt; 中&lt;code&gt;react-scripts&lt;/code&gt; 的版本号，然后运行&lt;code&gt;npm install&lt;/code&gt; 应该就可以了，但是对于潜在的重大变化，请参考&lt;a href=&quot;https://github.com/facebookincubator/create-react-app/blob/master/CHANGELOG.md&quot;&gt;更新日志&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们致力于保持最小的重大变化，从而可以无痛的升级&lt;code&gt;react-scripts&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;sending-feedback&quot;&gt;Sending Feedback&lt;/h2&gt;
&lt;p&gt;我们总是关注&lt;a href=&quot;https://github.com/facebookincubator/create-react-app/issues&quot;&gt;您的反馈&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;folder-structure&quot;&gt;Folder Structure&lt;/h2&gt;
&lt;p&gt;创建完成后，你的项目应该看上去像这样：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;er&quot;&gt;my-app/&lt;/span&gt;
  &lt;span class=&quot;er&quot;&gt;README.md&lt;/span&gt;
  &lt;span class=&quot;er&quot;&gt;node_modules/&lt;/span&gt;
  &lt;span class=&quot;er&quot;&gt;package.json&lt;/span&gt;
  &lt;span class=&quot;er&quot;&gt;public/&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;index.html&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;favicon.ico&lt;/span&gt;
  &lt;span class=&quot;er&quot;&gt;src/&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;App.css&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;App.js&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;App.test.js&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;index.css&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;index.js&lt;/span&gt;
    &lt;span class=&quot;er&quot;&gt;logo.svg&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于要构建的项目，这些文件必须存在：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public/index.html&lt;/code&gt; 是页面模版；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;src/index.js&lt;/code&gt; 是JavaScript 入门点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你可以删除或重命名其它的文件。&lt;/p&gt;
&lt;p&gt;你可以在&lt;code&gt;src&lt;/code&gt; 中创建子目录。为了更快的重构，只有位于&lt;code&gt;src&lt;/code&gt; 中的文件会被Webpack 处理。&lt;br/&gt;你需要&lt;em&gt;将任何JS 和CSS 放到&lt;code&gt;src&lt;/code&gt; 中&lt;/em&gt;，否则Webpack 将不会处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;public/index.html&lt;/code&gt; 只能使用&lt;code&gt;public&lt;/code&gt; 中的文件。&lt;br/&gt;阅读使用JavaScript 和HTML 资源的说明。&lt;/p&gt;
&lt;p&gt;但是，你可以创建更多的顶级目录。&lt;br/&gt;它们不会被包含在生产版本中，因此你可以将它们用于文档说明等。&lt;/p&gt;
&lt;h2 id=&quot;available-scripts&quot;&gt;Available Scripts&lt;/h2&gt;
&lt;p&gt;在项目目录中，你可以运行：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;npm start&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在开发模式下运行应用。&lt;br/&gt;打开 &lt;a href=&quot;http://localhost:3000/&quot; class=&quot;uri&quot;&gt;http://localhost:3000&lt;/a&gt; 在浏览器中查看。&lt;/p&gt;
&lt;p&gt;如果你进行了修改，页面将重新加载。&lt;br/&gt;你还可以在控制台中看到lint error。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;npm test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在交互观察者模式下，启动test runner。&lt;br/&gt;更多信息请参考&lt;a href=&quot;https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#running-tests&quot;&gt;running tests&lt;/a&gt; 章节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;npm run build&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;构建生产版本应用到build 文件夹。&lt;br/&gt;它在生产模式下正确地绑定了React，并且优化了构建以获得最佳性能。&lt;/p&gt;
&lt;p&gt;构建是minified 并且文件名包含哈希值。&lt;br/&gt;你的应用已经准备好部署了！&lt;/p&gt;
&lt;p&gt;更多信息请参考&lt;a href=&quot;https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#deployment&quot;&gt;deployment&lt;/a&gt; 章节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;npm run eject&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：这是一个单向操作。一旦你&lt;code&gt;eject&lt;/code&gt;，你不能返回！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你对构建工具和配置选项不满意，你可以运行&lt;code&gt;eject&lt;/code&gt;。此命令将从项目中删除单个构建依赖。&lt;/p&gt;
&lt;p&gt;相反，它会将所有配置文件和转变的依赖（Webpack、Babel、ESLint 等）复制到你的项目中，所以你可以完全控制它们。除了&lt;code&gt;eject&lt;/code&gt; 外所有的命令仍将其作用，但它们将指向复制的脚本，以便你调整它们。在这一点，完全看你自己。&lt;/p&gt;
&lt;p&gt;你不必使用&lt;code&gt;eject&lt;/code&gt;。The curated feature set 适用于中小型部署。但是我们明白，当你准备使用这个工具时，如果你不能自定义它，则它将没有用。&lt;/p&gt;
&lt;h2 id=&quot;supported-language-features-and-polyfills&quot;&gt;Supported Language Features and Polyfills&lt;/h2&gt;
&lt;p&gt;这个项目支持最新JavaScript 标准的超集。&lt;br/&gt;除了&lt;a href=&quot;https://github.com/lukehoban/es6features&quot;&gt;ES6&lt;/a&gt; 语法，它还支持：&lt;/p&gt;
&lt;p&gt;学习更多关于&lt;a href=&quot;https://babeljs.io/docs/plugins/#presets-stage-x-experimental-presets-&quot;&gt;不同提案阶段&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;虽然我们建议你谨慎使用这些实验性提案，但Facebook 在产品代码中大量使用这些功能，因此，如果将来这些提案发生变化，我吗将提供&lt;a href=&quot;https://medium.com/@cpojer/effective-javascript-codemods-5a6686bb46fb&quot;&gt;codemods&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;注意&lt;strong&gt;这个项目只包括几个ES6&lt;a href=&quot;https://en.wikipedia.org/wiki/Polyfill&quot;&gt;polyfills&lt;/a&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你使用任何需要&lt;strong&gt;运行时支持&lt;/strong&gt;的ES6+ 特性（像&lt;code&gt;Array.from()&lt;/code&gt; 或&lt;code&gt;Symbol&lt;/code&gt;）,确保你手动添加了合适的polyfill，或者你的目标浏览器已经支持它们了。&lt;/p&gt;
&lt;h2 id=&quot;syntax-highlighting-in-the-editor&quot;&gt;Syntax Highlighting in the Editor&lt;/h2&gt;
&lt;p&gt;要在你喜欢的文本编辑器中配置语法高亮，前往&lt;a href=&quot;https://babeljs.io/docs/editors&quot;&gt;相关的Babel 文档说明页&lt;/a&gt;，然后按照说明操作。包含大部分流行的编辑器。&lt;/p&gt;
&lt;h2 id=&quot;displaying-lint-output-in-the-editor&quot;&gt;Displaying Lint Output in the Editor&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：这个特性需呀&lt;code&gt;react-scripts@0.2.0&lt;/code&gt; 或更高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一些编辑器，包括Sublime Text、Atom 和Visual Studio Code 提供了ESLint 插件。&lt;/p&gt;
&lt;p&gt;对于linting 它们不是必须要的。你会在终端以及浏览器控制台中看到linter 输出。但是，如果你喜欢在编辑器中显示lint 结果，则需要执行一些额外的操作。&lt;/p&gt;
&lt;p&gt;首先，你需要为你的编辑器安装ESLint 插件。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Atom 用户使用 &lt;code&gt;linter-eslint&lt;/code&gt; 笔记&lt;br/&gt;如果你正在使用Atom &lt;code&gt;linter-eslint&lt;/code&gt; 插件，确保 &lt;strong&gt;Use global ESLint installation&lt;/strong&gt; 选项已经选中：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1177396/201801/1177396-20180124153546100-1241489991.png&quot;/&gt;&lt;br/&gt;Visual Studio Code 用户&lt;br/&gt;VS Code ESLint 插件会自动侦测Create React App 的配置文件。所以你不需要在根目录下创建&lt;code&gt;eslintrc.json&lt;/code&gt; 文件，除非你想要添加你自己的规则。在这种情况下，你应该包含CRA 的配置，通过添加下面这行：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;co&quot;&gt;// ...&lt;/span&gt;
 &lt;span class=&quot;st&quot;&gt;&quot;extends&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;react-app&quot;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后将下面这块代码添加到你的项目中的&lt;code&gt;package.json&lt;/code&gt; 文件中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;co&quot;&gt;//...&lt;/span&gt;
 &lt;span class=&quot;st&quot;&gt;&quot;eslintConfig&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;extends&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;react-app&quot;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，你需要全局安装一些包：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; install -g eslint-config-react-app@0.3.0 eslint@3.8.1 babel-eslint@7.0.0 eslint-plugin-react@6.4.1 eslint-plugin-import@2.0.1 eslint-plugin-jsx-a11y@4.0.0 eslint-plugin-flowtype@2.21.0&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们认识到这是次优的，由于我们隐藏ESLint 依赖的方式，它目前是必须的。ESLint 团队已经在为此&lt;a href=&quot;https://github.com/eslint/eslint/issues/3458&quot;&gt;提供解决方案&lt;/a&gt;，因此在几个月内可以会变得不必要。&lt;/p&gt;
&lt;h2 id=&quot;debugging-in-the-editor&quot;&gt;Debugging in the Editor&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;这个特性目前只有&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;Visual Studio Code&lt;/a&gt;编辑器支持。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio Code 支持实时编辑和调试，使用Create React App 开箱即用。这能够使你作为一个开发者不需要离开编辑器就可以进行编写和调试你的React 代码，最重要的是它可以让您拥有持续的开发工作流程，其中上下文切换是最小的，因为你不必在不同工具之间进行切换。&lt;/p&gt;
&lt;p&gt;你需要确保&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VS Code&lt;/a&gt; 是最新版本，并且VS Code 的&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome&quot;&gt;Chrome Debugger Extension&lt;/a&gt; 已经安装了。&lt;/p&gt;
&lt;p&gt;然后将下面代码添加到你的&lt;code&gt;launch.json&lt;/code&gt; 文件，并将其放到你的应用根目录下的&lt;code&gt;.vscode&lt;/code&gt; 文件夹中。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;0.2.0&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;configurations&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Chrome&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;chrome&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;request&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;launch&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;url&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;http://localhost:3000&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;webRoot&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;${workspaceRoot}/src&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;userDataDir&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;${workspaceRoot}/.vscode/chrome&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;sourceMapPathOverrides&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;&quot;webpack:///src/*&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;${webRoot}/*&quot;&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行&lt;code&gt;npm start&lt;/code&gt; 启动你的应用，按&lt;code&gt;F5&lt;/code&gt; 或点击绿色debug 图标在VS Code 中调试。现在你可以写代码、设置断点、修改代码以及调试你最新修改的代码--所有都在你的编辑器中实现。&lt;/p&gt;
&lt;h2 id=&quot;changing-the-page-title&quot;&gt;Changing the Page &lt;strong&gt;title&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;你可以在生成项目的&lt;code&gt;public&lt;/code&gt; 文件夹下知道源HTML 文件。你可以编辑&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; 标签，把“React App” 标题改为其他任何东西。&lt;/p&gt;
&lt;p&gt;请注意，通常你不会经常在&lt;code&gt;public&lt;/code&gt; 目录下编辑文件。例如，可以在不更改HTML 情况下，&lt;a href=&quot;https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#adding-a-stylesheet&quot;&gt;添加CSS 文件&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如果你需要根据内容来动态更新页面的标题，你可以使用浏览器的&lt;a href=&quot;http://www.cnblogs.com/JobbyM/p/8341928.html&quot;&gt;document.title&lt;/a&gt; API。对于要从React 组件更改标题的更复杂的场景，可以使用&lt;a href=&quot;https://github.com/nfl/react-helmet&quot;&gt;React Helmet&lt;/a&gt; 这个第三方库。&lt;/p&gt;
&lt;p&gt;在生产环境中，你为自己的应用使用自定义服务器，要将标题在发送到浏览器之前修改，你可以遵循&lt;a href=&quot;https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#generating-dynamic-meta-tags-on-the-server&quot;&gt;本章&lt;/a&gt; 建议。或者，你可以预构建每一个页面为静态HTML 文件，然后加载JavaScript 包，将在&lt;a href=&quot;https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#pre-rendering-into-static-html-files&quot;&gt;这里&lt;/a&gt;介绍。&lt;/p&gt;
&lt;h2 id=&quot;installing-a-dependency&quot;&gt;Installing a Dependency&lt;/h2&gt;
&lt;p&gt;生成的项目中包括React 和ReactDOM 依赖。它也包括Create React App 使用的一组脚本作为开发依赖。你也可以使用&lt;code&gt;npm&lt;/code&gt;安装其它的依赖（例如，React Router）：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; install --save &lt;span class=&quot;kw&quot;&gt;&amp;lt;&lt;/span&gt;library-name&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 24 Jan 2018 07:38:00 +0000</pubDate>
<dc:creator>JobbyM</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JobbyM/p/8341928.html</dc:identifier>
</item>
<item>
<title>ASP.NET CORE中使用Cookie身份认证 - PowerCoder</title>
<link>http://www.cnblogs.com/OpenCoder/p/8341843.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OpenCoder/p/8341843.html</guid>
<description>&lt;p&gt;大家在使用ASP.NET的时候一定都用过FormsAuthentication做登录用户的身份认证，FormsAuthentication的核心就是Cookie，ASP.NET会将用户名存储在Cookie中。&lt;/p&gt;
&lt;p&gt;现在到了ASP.NET CORE的时代，但是ASP.NET CORE中没有FormsAuthentication这个东西，那么怎么做身份认证呢？答案是ASP.NET CORE已经为我们内置了Cookie身份认证的功能，而且使用起来非常方便，注意本文是基于ASP.NET CORE 2.0版本来阐述Cookie认证方式的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.从ASP.NET CORE OWIN框架中启用Cookie身份认证功能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;要在ASP.NET CORE中使用Cookie身份认证，第一步就是在项目中的OWIN框架文件Startup.cs中启用Cookie身份认证中间件。&lt;/p&gt;
&lt;p&gt;首先我们在Startup中的ConfigureServices方法中使用services.AddAuthentication注册Cookie认证服务，如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    services.AddMvc();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册Cookie认证服务&lt;/span&gt;
&lt;span&gt;    services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme).AddCookie();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在Startup中的Configure方法中使用app.UseAuthentication启用Cookie认证中间件（注意其中app.UseAuthentication和app.UseMvc的调用顺序不能反），如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
        app.UseBrowserLink();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        app.UseExceptionHandler(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    app.UseStaticFiles();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意app.UseAuthentication方法一定要放在下面的app.UseMvc方法前面，否者后面就算调用HttpContext.SignInAsync进行用户登录后，使用
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HttpContext.User还是会显示用户没有登录，并且HttpContext.User.Claims读取不到登录用户的任何信息。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这说明Asp.Net OWIN框架中MiddleWare的调用顺序会对系统功能产生很大的影响，各个MiddleWare的调用顺序一定不能反&lt;/span&gt;
&lt;span&gt;    app.UseAuthentication();

    app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        routes.MapRoute(
            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    });

            
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.登录用户&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;在ASP.NET CORE中使用Cookie认证登录用户的方法和传统的FormsAuthentication不太一样，大致步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建Claim类型的数组，将登录用户的所有信息（比如用户名）存储在Claim类型的字符串键值对中&lt;/li&gt;
&lt;li&gt;将上面创建的Claim类型的数组传入ClaimsIdentity中，用来构造一个ClaimsIdentity对象&lt;/li&gt;
&lt;li&gt;将上面创建的ClaimsIdentity对象传入ClaimsPrincipal中，用来构造一个ClaimsPrincipal对象&lt;/li&gt;
&lt;li&gt;调用HttpContext.SignInAsync方法，传入上面创建的ClaimsPrincipal对象，完成用户登录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以我们可以看到整个ASP.NET CORE的Cookie认证登录流程比以前ASP.NET的FormsAuthentication还是要复杂许多，毕竟以前一个FormsAuthentication.SetAuthCookie方法就搞定了。&lt;/p&gt;

&lt;p&gt;在本文的例子中我们在项目中默认的HomeController中创建了一个Acion方法Login，来实现用户登录的代码。当然这里我们实现的是最简的Cookie登录，下面代码中实际上还可以设置Cookie是否持久化、Cookie多久过期、存储登录用户信息的Cookie的名字是什么等，我们就不做过多介绍了，大家可以阅读本文最后推荐的两份官方文档了解更多。&lt;/p&gt;
&lt;p&gt;Login方法的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 该Action登录用户Wangdacui到Asp.Net Core
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Login()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面的变量claims是Claim类型的数组，Claim是string类型的键值对，所以claims数组中可以存储任意个和用户有关的信息，
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不过要注意这些信息都是加密后存储在客户端浏览器cookie中的，所以最好不要存储太多特别敏感的信息，这里我们只存储了用户名到claims数组,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示当前登录的用户是谁&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; claims = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[]
        {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UserName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wangdacui&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claimsIdentity = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClaimsIdentity(
    claims,
    CookieAuthenticationDefaults.AuthenticationScheme);

    ClaimsPrincipal user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClaimsPrincipal(claimsIdentity);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录用户，相当于ASP.NET中的FormsAuthentication.SetAuthCookie &lt;/span&gt;
&lt;span&gt;    HttpContext.SignInAsync(
    CookieAuthenticationDefaults.AuthenticationScheme,
    user).Wait();
            
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;3.读取登录用户信息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;那么用户登录后怎么将登录用户的信息（比如用户名）读取出来呢？我们在HomeController的Index方法中演示了如何判断当前用户是否已经登录，并且读出登录用户的用户名，Index方法的代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; Index action判断当前用户是否已经登录，如果已经登录，就把用户名读取出来
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果HttpContext.User.Identity.IsAuthenticated为true，
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者HttpContext.User.Claims.Count()大于0表示用户已经登录&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (HttpContext.User.Identity.IsAuthenticated)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里通过 HttpContext.User.Claims 可以将我们在Login这个Action中存储到cookie中的所有
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;claims键值对都读出来，比如我们刚才定义的UserName的值Wangdacui就在这里读取出来了&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; userName =&lt;span&gt; HttpContext.User.Claims.First().Value;
    }
            
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.注销用户&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;那么登录用户后怎么注销登录呢？我们在HomeController的Logout方法中演示了如何注销登录的用户，代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 该Action从Asp.Net Core中注销登录的用户
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Logout()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注销登录的用户，相当于ASP.NET中的FormsAuthentication.SignOut  &lt;/span&gt;
&lt;span&gt;    HttpContext.SignOutAsync().Wait();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;前面说了实际上在ASP.NET CORE的Cookie认证中还可以设置Cookie的名字、是否持久化存储等，可以参考如下两篇官方文档了解：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/security/authentication/cookie?tabs=aspnetcore2x#tabpanel_o9XcN0Bk3e_aspnetcore2x&quot; target=&quot;_blank&quot;&gt;Using Cookie Authentication without ASP.NET Core Identity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/magazine/mt842501.aspx&quot; target=&quot;_blank&quot;&gt;Cutting Edge - Cookies, Claims and Authentication in ASP.NET Core&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 24 Jan 2018 07:25:00 +0000</pubDate>
<dc:creator>PowerCoder</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OpenCoder/p/8341843.html</dc:identifier>
</item>
<item>
<title>Docker+Jenkins持续集成环境(4):使用etcd+confd实现容器服务注册与发现 - JadePeng</title>
<link>http://www.cnblogs.com/xiaoqi/p/Jenkins-etcd-confd.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoqi/p/Jenkins-etcd-confd.html</guid>
<description>&lt;p&gt;前面我们已经通过jenkins+docker搭建了基本的持续集成环境，实现了服务的自动构建和部署，但是，我们遇到一个问题，jenkins构建出来的镜像部署后，需要通过ip:port去访问，有什么更好的方法吗？肯定是通过域名啊！前提是你注册一个域名，或者修改机器hosts文件。&lt;br/&gt;本文介绍通过引入etcd+confd实现部署服务的自动注册，自动生成nginx配置文件，实现每个服务独立域名访问。&lt;/p&gt;
&lt;h2 id=&quot;配置域名&quot;&gt;配置域名&lt;/h2&gt;
&lt;p&gt;假设你的域名是： example.com,那么我们可以规划&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dev.$servicename.example.com作为开发环境，&lt;/li&gt;
&lt;li&gt;test.$servicename.example.comz作为服务的测试环境。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置步骤:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先将*.example.com 指向一台nginx服务器&lt;/li&gt;
&lt;li&gt;增加vhost配置文件，假设86.6,86.8,86.11 是docker swarm集群中的机器，服务的名称为allinoneservice，那么我们可以增加一个配置文件nginx_vhosts/service.conf：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;    upstream test_service_allinoneservice {
        server 192.168.86.11:10091;
        server 192.168.86.6:10091;
        server 192.168.86.8:10091;
    }

    server {
        listen       80;
        server_name test.allinoneservice.example.com;
        location / {
            proxy_redirect off;
            proxy_set_header Host $host;
            proxy_read_timeout 300;
            proxy_set_header X-Real-IP $http_x_forwarded_for;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_pass http://test_service_allinoneservice;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;修改nginx配置文件nginx.conf,在最后一个大括号前，将刚新建的配置文件包含进去：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;include nginx_vhosts/*.conf;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;重启nginx，就可以通过test.allinoneservice.example.com访问服务了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;通过服务注册自动生成配置文件&quot;&gt;通过服务注册自动生成配置文件&lt;/h2&gt;
&lt;p&gt;第一步里，我们需要手动编写配置文件，有更好的方式吗？答案是通过服务注册+confd，自动生成配置文件。&lt;/p&gt;
&lt;h3 id=&quot;docker-安装etcd集群&quot;&gt;docker 安装etcd集群&lt;/h3&gt;
&lt;p&gt;首先，docker安装etcd作为注册中心，我们安装一个包含3个实例的集群，编写docker-compose.yml:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;version: '3'
services:
  etcd0:
    image: 192.168.86.8:5000/etcd
    ports:
      - &quot;2379:2379&quot;
    volumes:
      - etcd0:/etcd_data
    command:
      - /usr/local/bin/etcd
      - -name
      - etcd0
      - --data-dir
      - /etcd_data
      - -advertise-client-urls
      - http://etcd0:2379
      - -listen-client-urls
      - http://0.0.0.0:2379
      - -initial-advertise-peer-urls
      - http://etcd0:2380
      - -listen-peer-urls
      - http://0.0.0.0:2380
      - -initial-cluster
      - etcd0=http://etcd0:2380,etcd1=http://etcd1:2380,etcd2=http://etcd2:2380
  etcd1:
    image: 192.168.86.8:5000/etcd
    ports:
      - &quot;2380:2379&quot;
    volumes:
      - etcd1:/etcd_data
    command:
      - /usr/local/bin/etcd
      - -name
      - etcd1
      - --data-dir
      - /etcd_data
      - -advertise-client-urls
      - http://etcd1:2379
      - -listen-client-urls
      - http://0.0.0.0:2379
      - -initial-advertise-peer-urls
      - http://etcd1:2380
      - -listen-peer-urls
      - http://0.0.0.0:2380
      - -initial-cluster
      - etcd0=http://etcd0:2380,etcd1=http://etcd1:2380,etcd2=http://etcd2:2380
  etcd2:
    image: 192.168.86.8:5000/etcd
    ports:
      - &quot;2381:2379&quot;
    volumes:
      - etcd2:/etcd_data
    command:
      - /usr/local/bin/etcd
      - -name
      - etcd2
      - --data-dir
      - /etcd_data
      - -advertise-client-urls
      - http://etcd2:2379
      - -listen-client-urls
      - http://0.0.0.0:2379
      - -initial-advertise-peer-urls
      - http://etcd2:2380
      - -listen-peer-urls
      - http://0.0.0.0:2380
      - -initial-cluster
      - etcd0=http://etcd0:2380,etcd1=http://etcd1:2380,etcd2=http://etcd2:2380
volumes:
  etcd0:
  etcd1:
  etcd2:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，上面的image: 192.168.86.8:5000/etcd 是用的私有仓库，大家可以使用官方版本quay.io/coreos/etcd&lt;/p&gt;
&lt;p&gt;然后启动etcd:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker stack deploy -c docker-compose.yml etcd&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;服务注册&quot;&gt;服务注册&lt;/h3&gt;
&lt;p&gt;etcd注册就简单了，可以通过etcd的rest api，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;curl http://192.168.86.11:2379/v2/keys/services/test/allinoneservice/service1 -XPUT -d value=&quot;192.168.86.8:10091&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，我们修改一下jenkins里的docker部署脚本，服务部署后自动向etcd注册，由于是swarm集群，因此我们可以注册多个ip。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;start remove old service&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; service rm  &lt;span class=&quot;ot&quot;&gt;${service_name}&lt;/span&gt;-&lt;span class=&quot;ot&quot;&gt;${env}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;start create new service with latest builded image&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;docker&lt;/span&gt; service create --name &lt;span class=&quot;ot&quot;&gt;${service_name}&lt;/span&gt;-&lt;span class=&quot;ot&quot;&gt;${env}&lt;/span&gt; --replicas &lt;span class=&quot;ot&quot;&gt;${replicas}&lt;/span&gt; --publish &lt;span class=&quot;ot&quot;&gt;${service_port}&lt;/span&gt;:&lt;span class=&quot;ot&quot;&gt;${docker_expose_port}&lt;/span&gt; 192.168.86.8:5000/&lt;span class=&quot;ot&quot;&gt;${service_name}&lt;/span&gt;-&lt;span class=&quot;ot&quot;&gt;${env}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;publish service to nginx&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;curl&lt;/span&gt; http://192.168.86.11:2379/v2/keys/services/&lt;span class=&quot;ot&quot;&gt;${env}&lt;/span&gt;/&lt;span class=&quot;ot&quot;&gt;${service_name}&lt;/span&gt;/service1 -XPUT -d value=&lt;span class=&quot;st&quot;&gt;&quot;192.168.86.8:&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;${service_port}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;curl&lt;/span&gt; http://192.168.86.11:2379/v2/keys/services/&lt;span class=&quot;ot&quot;&gt;${env}&lt;/span&gt;/&lt;span class=&quot;ot&quot;&gt;${service_name}&lt;/span&gt;/service2 -XPUT -d value=&lt;span class=&quot;st&quot;&gt;&quot;192.168.86.11:&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;${service_port}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;curl&lt;/span&gt; http://192.168.86.11:2379/v2/keys/services/&lt;span class=&quot;ot&quot;&gt;${env}&lt;/span&gt;/&lt;span class=&quot;ot&quot;&gt;${service_name}&lt;/span&gt;/service3 -XPUT -d value=&lt;span class=&quot;st&quot;&gt;&quot;192.168.86.6:&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;${service_port}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意，上面的service_name是jenkins参数化构建里定义的参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oyqmmpkcm.bkt.clouddn.com/1516776350328.jpg&quot; title=&quot;1516776350328&quot; alt=&quot;jenkins参数化构建&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通过confd生成nginx配置文件&quot;&gt;通过confd生成nginx配置文件&lt;/h3&gt;
&lt;p&gt;confd 是一个配置文件生成工具，可以从etcd、consul等注册中心读取数据根据模板生成配置文件，并在配置发生变化后自动更新配置文件，还能自动重启服务，是服务自动发现的居家必备良药。&lt;/p&gt;
&lt;p&gt;首先讲下怎么安装，根据官方文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://github.com/kelseyhightower/confd/releases/download/v0.14.0/confd-0.14.0-linux-amd64
mkdir -p /opt/confd/bin
mv confd-0.14.0-linux-amd64 /opt/confd/bin/confd
chmod +x /opt/confd/bin/confd
export PATH=&quot;$PATH:/opt/confd/bin&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便使用，最好修改下/etc/profile,加入export PATH=&quot;$PATH:/opt/confd/bin&quot;，然后source /etc/profile让配置生效。&lt;/p&gt;
&lt;p&gt;然后编写confd配置文件/etc/confd/conf.d/myapp-nginx.toml：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[template]
src = &quot;nginx.conf.tmpl&quot;
dest = &quot;/opt/third_party/nginx_vhosts/service.conf&quot;
keys = [
    &quot;/services/dev&quot;,
    &quot;/services/test&quot;,
]
reload_cmd = &quot;/opt/third_party/sbin/nginx -s reload&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面配置了，会读取的keys，以及dest目标配置文件地址，和配置文件更新后的reload_cmd，用于重启nginx&lt;/p&gt;
&lt;p&gt;接着编写模板文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{{range $dir := lsdir &quot;/services/test&quot;}}
upstream test_service_{{base $dir}} {
    {{$custdir := printf &quot;/services/test/%s/*&quot; $dir}}{{range getvs $custdir}}
    server {{.}};
    {{end}}
}

server {
    listen       80;
    server_name test.{{base $dir}}.iflyresearch.com;
    location / {
        proxy_redirect off;
        proxy_set_header Host $host;
        proxy_read_timeout 300;
        proxy_set_header X-Real-IP $http_x_forwarded_for;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_pass http://test_service_{{base $dir}};
    }
}
{{end}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的模板比较简单，通过lsdir指令读取服务列表，然后通过range getvs获取服务对应的负载地址。&lt;/p&gt;
&lt;p&gt;然后启动confd，需要指定etcd的地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nohup confd -backend etcd -node http://192.168.86.11:2379 &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;搞定！&lt;/p&gt;
&lt;h2 id=&quot;延伸阅读&quot;&gt;延伸阅读&lt;/h2&gt;
&lt;p&gt;Jenkins+Docker 搭建持续集成环境：&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;7.3156342182891&quot;&gt;
&lt;p&gt;作者：Jadepeng&lt;br/&gt;出处：jqpeng的技术记事本--&lt;a href=&quot;http://www.cnblogs.com/xiaoqi&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xiaoqi&lt;/a&gt;&lt;br/&gt;您的支持是对博主最大的鼓励，感谢您的认真阅读。&lt;br/&gt;本文版权归作者所有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 24 Jan 2018 06:52:00 +0000</pubDate>
<dc:creator>JadePeng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoqi/p/Jenkins-etcd-confd.html</dc:identifier>
</item>
<item>
<title>自写 zTree搜索功能 -- 关键字查询 -- 递归无限层 - 谎言让你心安</title>
<link>http://www.cnblogs.com/wbsndbf/p/8341294.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wbsndbf/p/8341294.html</guid>
<description>&lt;h3&gt;&lt;span&gt;唠叨一哈&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;前两天朋友跟我说要一个ztree的搜索功能，我劈头就是一巴掌：这种方法难道无数前辈还做少了？自己去找，我很忙~然后我默默地蹲着写zTree的搜索方法去了。为什么呢？因为我说了句“找不到是不可能的啊，肯定有很多人早做了无数了，找不到我给你写还请你恰午饭”，然而我也去找了很久也没有找到（泪崩，我的计划，我的午饭~）。绝大多数都是用的API里面的getNodesByParamFuzzy()或者高亮之类的。然而朋友表示需求不符合：1. 匹配失败父节点也隐藏；2.能自定义匹配规则，即能匹配name还能匹配属性......（反正就是我想要的不是辣个，小生脸上笑嘻嘻，心里.......那我给你写呗~），下面进入正文：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;思维导图&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/921970/201801/921970-20180124111010803-228016681.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　一般搜索功能只是在“既定范围内（方便称呼）”匹配关键字，“既定范围”即我们已经知道搜索的范围：比如说一个文本库，一个下拉框，换而言之我们匹配的对象集大小已经确定了。然而这一点在ztree上不可行，为什么呢？在我考虑了一下ztree搜索功能实现逻辑的时候问了一句：那啥，这棵树的层级是固定的吗？还是说不确定有多少层？老哥看着我会心一笑：你按无限层来写~小生小腿肚子一抽。。因为树的层级不确定，所以搜索范围不确定，举个栗子：目标节点匹配成功，如果这个节点是子节点，那么它的父节点也应该是显示的，然后它父节点的父节点也应该是显示的，然后它父节点的父节点的父节点的...Orz...这仿佛永远写不到尽头了...没办法，只能：&lt;span&gt;递归&lt;/span&gt;，找到目标节点的所有父节点和子节点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;逻辑关键点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;在上面的思维导图中我大致列出了逻辑，目标节点在什么情况下显示，什么情况下隐藏，这是我们必须清楚的关键点，下面我们具体看下目标节点存在的情况：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/921970/201801/921970-20180124135744756-630435909.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　到了这里，相信对于如何实现满足我们需求的搜索功能开发，已经能做到了然于心了，剩下的只是实现的方法，然而这完全不是事~（小生窃以为真正让人忧心的理不清功能的流程，至于实现方法你们都懂的吧？0.0..）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;关于树节点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;要完成上述流程中各种方法，我们需要知道树节点的一系列属性，我们都知道有api这种神器，然而api有一个特点就是齐全（齐全得我们想精确的找到某一个属性或者方法时可能得一顿好找），这里我们想要的是如何快速得到自己想要的属性或者方法，我们在控制台打印出树节点集合:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;var&lt;/span&gt; treeObj=$.fn.zTree.getZTreeObj(&quot;homeTree&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置根节点&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; node = treeObj.getNodes(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取根节点&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; nodes = treeObj.transformToArray(node); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取所有节点&lt;/span&gt;
        console.log(nodes);    
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　看图：我们能看到所有节点，其中有id，name等各种属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/921970/201801/921970-20180124120724162-321026784.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再看图：我们能看到任意节点的各种属性，有我们想要的子节点集合 childern,父节点属性 isParent ,节点id tId，父节点id parentTid...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/921970/201801/921970-20180124120945162-756941256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;万事俱备，动手&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;下面看一下相关方法，很多小细节需要在真正编码过程中才能发现，这里为了方便展示就直接列举方法了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;声明备用数组：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 地区搜索&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; parentArray =&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; childArray = [];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 　　递归获取目标节点父节点集合：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递归获取目标节点所有父节点&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getParentsNode(treeNode){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisParentNode = treeNode.getParentNode(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到该节点的父节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;( thisParentNode != &lt;span&gt;null&lt;/span&gt; ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 父节点存在&lt;/span&gt;
            parentArray.push(thisParentNode); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 储存至数组&lt;/span&gt;
            getParentsNode(thisParentNode); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重调 &lt;/span&gt;
        }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }           
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　递归获取目标节点子节点集合：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 递归获取目标节点所有子节点&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getChildrenNode(treeNode){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisIsParent = treeNode.isParent; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取目标节点 isParent 属性，判断是否为父节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;( thisIsParent == &lt;span&gt;true&lt;/span&gt;&lt;span&gt; ){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisChildrenNode = treeNode.children; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到该节点的子节点集合&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;thisChildrenNode.length;i++&lt;span&gt;){
                childArray.push(thisChildrenNode[i]); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将该子节点加入数组中&lt;/span&gt;
                getChildrenNode(thisChildrenNode[i]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重调       &lt;/span&gt;
&lt;span&gt;            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这里建议将匹配节点部分摘出来单独写一个方法，方便进行拓展匹配规则，这里我们假设除了匹配name还需要匹配节点的 entity_code 属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;匹配节点&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; matchNode(treeNode,num){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; inputArea = $(&quot;input[name='searchArea']&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; name =&lt;span&gt; treeNode.name;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; entityCode = treeNode.entity_code|| ''&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val = inputArea.val(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取检索值&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; numName =&lt;span&gt; name.indexOf(val);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; numCode =&lt;span&gt; entityCode.indexOf(val);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; num = -1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( numName != -1 || numCode !=-1&lt;span&gt; ){
            num &lt;/span&gt;= 1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( numName == -1 &amp;amp;&amp;amp; numCode == -1&lt;span&gt; ){
            num &lt;/span&gt;= -1&lt;span&gt;;   
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　节点匹配成功方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点匹配成功&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkTrueArray(arr,treeNode){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisTid =&lt;span&gt; treeNode.tId;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisLi = $(&quot;#&quot;+&lt;span&gt;thisTid);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; n=0;n&amp;lt;arr.length;n++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisNodeId =&lt;span&gt; arr[n].tId;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisNodeLi = $(&quot;#&quot;+&lt;span&gt;thisNodeId);
            thisLi.show();
            thisNodeLi.show();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　节点匹配失败方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点匹配失败&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkFalseArray(arr,treeNode){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result2 =&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisTid =&lt;span&gt; treeNode.tId;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisLi = $(&quot;#&quot;+&lt;span&gt;thisTid);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val = inputArea.val(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取检索值&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; thisParent =  treeNode.getParentNode();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取目标节点父节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;( thisParent != &lt;span&gt;null&lt;/span&gt; ){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有父节点&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; thisBrotherArr =  treeNode.getParentNode().children; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到包含自身的兄弟数组&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; m=0;m&amp;lt;arr.length;m++){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配父节点&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; num =&lt;span&gt; matchNode(arr[m]);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( num != -1&lt;span&gt; ){
                    result.push(arr[m]);
                }
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; resultLength =&lt;span&gt; result.length;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; m=0;m&amp;lt;thisBrotherArr.length;m++ ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配兄弟节点&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; num =&lt;span&gt; matchNode(thisBrotherArr[m]);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( num != -1&lt;span&gt; ){
                    result2.push(thisBrotherArr[m]);
                }
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; resultLength2 =&lt;span&gt; result2.length;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于自身匹配失败的节点，要显示必须满足有父节点匹配成功，且兄弟级节点都匹配失败&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;( (resultLength == 0 &amp;amp;&amp;amp; resultLength2 == 0) || resultLength2 != 0&lt;span&gt; ){
                thisLi.hide();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( resultLength !=0 &amp;amp;&amp;amp; resultLength2 == 0&lt;span&gt; ){
                thisLi.show();
            }
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            thisLi.hide();
        }    
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　 目标节点匹配失败 目标节点即有父节点又有子节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 目标节点匹配失败 目标节点即有父节点又有子节点&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkAllArray(arr,arr2,treeNode){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result2 =&lt;span&gt; [];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisTid =&lt;span&gt; treeNode.tId;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisLi = $(&quot;#&quot;+&lt;span&gt;thisTid);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val = inputArea.val(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取检索值&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; m=0;m&amp;lt;arr.length;m++){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配子节点或父节点&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; num =&lt;span&gt; matchNode(arr[m]);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( num != -1&lt;span&gt; ){
                result.push(arr[m]); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配成功储存至数组&lt;/span&gt;
&lt;span&gt;            }
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; resultLength = result.length; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取匹配成功后返回的数组长度&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; m=0;m&amp;lt;arr2.length;m++){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配子节点或父节点&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; num =&lt;span&gt; matchNode(arr2[m]);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( num != -1&lt;span&gt; ){
                result2.push(arr2[m]); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配成功储存至数组&lt;/span&gt;
&lt;span&gt;            }
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; resultLength2 = result2.length; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取匹配成功后返回的数组长度&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;( resultLength == 0 &amp;amp;&amp;amp; resultLength2 == 0 ){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 子节点和父节点都匹配失败&lt;/span&gt;
&lt;span&gt;            thisLi.hide();
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{ 
            thisLi.show(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有一种匹配成功或都匹配成功&lt;/span&gt;
&lt;span&gt;        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定义搜索方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;function&lt;/span&gt; searchArea(treeId, treeNode){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义搜索方法&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; inputArea = $(&quot;input[name='searchArea']&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val = inputArea.val(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取检索值&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; treeObj=$.fn.zTree.getZTreeObj(&quot;homeTree&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置根节点&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; node = treeObj.getNodes(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取根节点&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; nodes = treeObj.transformToArray(node); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取所有节点&lt;/span&gt;
&lt;span&gt;        console.log(nodes);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;nodes.length;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisNodePid =&lt;span&gt; nodes[i].pId;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; thisParentNode =&lt;span&gt;  
            parentArray &lt;/span&gt;=&lt;span&gt; [];
            childArray &lt;/span&gt;=&lt;span&gt; [];
            getParentsNode(nodes[i]); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取目标节点所有父节点 返回数组&lt;/span&gt;
            getChildrenNode(nodes[i]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取目标节点所有子节点 返回数组&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; num =&lt;span&gt; matchNode(nodes[i]);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( nodes[i].isParent == &lt;span&gt;false&lt;/span&gt;&lt;span&gt; ){ 
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( num != -1&lt;span&gt; ){
                    checkTrueArray(parentArray,nodes[i]);
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    checkFalseArray(parentArray,nodes[i]);
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( nodes[i].isParent == &lt;span&gt;true&lt;/span&gt;&lt;span&gt; ){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( num != -1&lt;span&gt; ){
                    checkTrueArray(parentArray,nodes[i]);  
                    checkTrueArray(childArray,nodes[i]);                  
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    checkAllArray(parentArray,childArray,nodes[i]);
                }
            }            
        }
       
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　调用搜索方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用搜索方法&lt;/span&gt;
    $(&quot;.searchAreaBtn&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(treeId, treeNode){
        searchArea(treeId, treeNode);
    });
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; inputArea = $(&quot;input[name='searchArea']&quot;&lt;span&gt;);
    inputArea.keyup(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(treeId, treeNode,e){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; e = event ||&lt;span&gt; window.event;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val =&lt;span&gt; inputArea.val();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( e.keyCode == 13 || val == &quot;&quot;&lt;span&gt; ){
            searchArea(treeId, treeNode);
        }
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　看效果（电脑ps出问题了，用美图秀秀拼的图~囧...）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/921970/201801/921970-20180124134513522-2147338123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;理论上来说应该是能支持无限层的，最多试了四层，没有问题，没有做更多测试，有兴趣的看官可以试试，需要demo的可以留言，互相学习，一起进步，么么哒~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 24 Jan 2018 05:50:00 +0000</pubDate>
<dc:creator>谎言让你心安</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wbsndbf/p/8341294.html</dc:identifier>
</item>
<item>
<title>数据库副本的自动种子设定（自增长） - DB乐之者</title>
<link>http://www.cnblogs.com/wenBlog/p/8341245.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenBlog/p/8341245.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;span data-ttu-id=&quot;f12ff-104&quot;&gt;背景&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span data-ttu-id=&quot;f12ff-104&quot;&gt;在 SQL Server 2012 和 2014 中，初始化 SQL Server Always On 可用性组中的次要副本的唯一方法是使用备份、复制和还原。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在一个高可用组里面添加一个数据库需要很多手动任务和一些必要条件。需要完成的这些工作中，有一些是有些困难的，比如:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;我们需要从主副本中备份数据库，并将这个备份分发到可用组的其他副本中。这是基于手动操作的，因为这需要你从主数据库备份还原数据库到次要副本。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有时候，我们不能通过网络防火墙在副本之间传送数据库备份文件。这种情况下，需要开放SMB协议端口，以便能在节点间传输备份文件。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通常，复制一个备份文件会占用更多空间，这是额外的需求，更多的磁盘空间。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;特别是针对第三方备份的方案，会导致备份/还原链的中断。但是这又取决于数据库的备份策略。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;分发和还原数据库是耗时并且不透明的过程。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;作为一个兼职DBA，我不喜欢处理这些问题。当我创建数据库在主节点上时，我想要数据库被自动创建在所有副本上，幸运的是SQLServer 2016以后这样的工作就容易多了。为了更好的帮助DBA们处理这些问题，微软引入了可用组的自动增长数据库。即&lt;span data-ttu-id=&quot;f12ff-105&quot;&gt;SQL Server 2016 引入了用于初始化次要副本的新功能 - 我一般称之为数据库自增长（自动种子设定）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;那么这个自动化如何实现的？&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;当你打算创建一个数据库在主副本上，并且加入数据库到AG里面时，自动填充就会在数据库镜像端间进行通信，并且复制数据库到次要副本中。假设有一个可用组，由N个副本组成，replicas - Replica1, Replica2, ... ReplicaN。当前你的主副本是Replica2 ，然后你创建一个新的数据库在主副本上。下一步就是要尽快把数据库加入到可用组的其他副本上。这个解决方案就如下图的流程所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://www.sqlservercentral.com/Images/33717.jpg&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;数据库自动种子设定（自增长），没有特殊的必要条件和限制，只是需要数据和日志文件路径在可用组中是完全一致的。这个可用组配置自增长，数据库在可用组中一定是完整还原模式，需要有一个完成备份以及事务日志备份。如果在可用组中用手动同步加入的数据库也需要上述一样的条件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;启动自动种子设定功能&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在每一个需要自增长数据库的副本上，需要允许可用组创建数据库。下面的脚本用来允许AG创建数据库，但是确保你可以连接到master数据库并且能够对所有可用组中的副本执行这个脚本:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;ALTER AVAILABILITY GROUP [{your_AG_name}]
GRANT CREATE ANY DATABASE;
GO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;可用组必须被切换为自动增长模式。该模式可以通过在每个副本中执行下面额T-SQL代码来实现（或者每个副本中启动自增模式）:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;ALTER AVAILABILITY GROUP [{your_AG_name}]
MODIFY REPLICA ON &lt;span&gt;'&lt;span&gt;{your_replica_name}&lt;span&gt;'&lt;span&gt;
WITH (SEEDING_MODE =&lt;span&gt; AUTOMATIC);
GO&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;另外，对于Always On 的可用组来说，自增期间能够使用跟踪标记trace flag 9567压缩数据流，从而大大减少传输时间。相关内容可以再找个连接看到: &lt;a href=&quot;https://docs.microsoft.com/en-us/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql&quot;&gt;https://docs.microsoft.com/en-us/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;添加一个带有自增长属性的数据库&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;打开SSMS并且连接可用组主节点。导航到AlwaysOn 高可用（AlwaysOn High Availability）文件，打开“Availability Groups”，然后找到打算添加数据库的可用组。在打开&quot;Availability Databases&quot; 文件夹。右击&quot;Availability Databases&quot;，右键菜单&quot;Add databases..&quot;, 这个菜单选项将会激活配置向导如下:&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/306519/201801/306519-20180124144420287-548356862.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择打算加入到可用组的数据库:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/306519/201801/306519-20180124144431303-1459760502.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意，这个数据库一定满足一下必要条件。选择选项“Skip initial data synchronization”:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/306519/201801/306519-20180124144447694-118235309.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在次要节点，你会看到数据库已经被还原的信息:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/306519/201801/306519-20180124144457334-2121960374.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;因此，你也可以在msdb.dbo.restorehistory 表中看到每个数据库的增加信息。在主服务器，可以在表&lt;em&gt;msdb.dbo.backupmediafamily 中看到每个数据库信息，数据库可以shiyo8ng下面的T-SQL语句实现&lt;/em&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;ALTER AVAILABILITY GROUP {your_AG_name} ADD DATABASE {your_database_name};&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/306519/201801/306519-20180124144505615-1091066075.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个脚本必须在可用组的每个数据库上执行。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;优缺点&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我通常使用自动数据库填充为可用组并且发现它很有价值。例如，微软SharePoint 支持组有权去创建新的数据库在主副本上，但是他们不能直接把数据库加入到可用组中，因为这样做影响了数据库的高可用。当我们使用自动数据填充在指定的可用组上时，我们可以自动添加新的Sharepoint 数据库在可用组上，使用一个将所有最近创建的Sharepoint 数据库添加到可用组上的脚本，使用2016这个特性不在需要使用手动操作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;综上所述，使用自动填充的优势有如下几点:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;操作过程简单.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;节省磁盘空间.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;节省备份还原事件，因为SQLServer复制数据库使用网络.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用追踪标记9567，能够大大减少同步时间。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;在可用组中使用自动增长的缺点:&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 05:35:00 +0000</pubDate>
<dc:creator>DB乐之者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenBlog/p/8341245.html</dc:identifier>
</item>
<item>
<title>浅析Entity Framework Core2.0的日志记录与动态查询条件 - GuZhenYin</title>
<link>http://www.cnblogs.com/GuZhenYin/p/8341216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GuZhenYin/p/8341216.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 2.0更新也已经有一段时间了,园子里也有不少的文章..&lt;/p&gt;
&lt;p&gt;本文主要是浅析一下Entity Framework Core2.0的日志记录与动态查询条件&lt;/p&gt;
&lt;p&gt;去年我写过一篇关于Entity Framework Core1.0和1.1的日志记录和事务的文章:&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/GuZhenYin/p/6862505.html&quot;&gt;一步步学习EF Core(2.事务与日志)&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;时过境迁..EF Core也更新到2.0了..&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;在日志记录方面,有了比较大的变化..所以我觉得还是需要学习学习&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;早在Entity Framework Core1.0 ,我们就使用相关的ILoggerProvider ILogger 这些基础接口类.来实现过日志记录.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在Entity Framework Core2.0  估计是为了配合ASP.NET Core的日志.所以对这些接口进行了更进一步的包装,也弃用了一些接口和类,如:&lt;/strong&gt;IRelationalCommandBuilderFactory ,DbCommandLogData&lt;/p&gt;
&lt;p&gt;但是Entity Framework Core2.0 在DbContextOptionsBuilder添加了新的扩展方法.&lt;strong&gt;UseLoggerFactory&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;看到LoggerFactory,研究过ASP.NET Core日志记录的同学,应该就很熟悉了..这是ASP.NET Core日志记录的工厂类.&lt;/p&gt;
&lt;p&gt;也就是为什么我们如果在ASP.NET Core中注入自己的日志记录,也可以通过配置来记录相关的SQL操作的原因.&lt;/p&gt;
&lt;p&gt;这里我们主要是直接只监控EF Core的日志.&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BloggingContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BloggingContext(DbContextOptions&amp;lt;BloggingContext&amp;gt;&lt;span&gt; options)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(options)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Database.EnsureCreated();&lt;/span&gt;
&lt;span&gt;        }
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建日志工厂&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ILoggerFactory Mlogger =&amp;gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggerFactory()
                 .AddDebug((categoryName, logLevel) &lt;/span&gt;=&amp;gt; (logLevel == LogLevel.Information) &amp;amp;&amp;amp; (categoryName ==&lt;span&gt; DbLoggerCategory.Database.Command.Name))
                .AddConsole((categoryName, logLevel) &lt;/span&gt;=&amp;gt; (logLevel == LogLevel.Information) &amp;amp;&amp;amp; (categoryName ==&lt;span&gt; DbLoggerCategory.Database.Command.Name));
        
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loggerFactory =&lt;span&gt; 
            optionsBuilder
                .UseLoggerFactory(Mlogger) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入日志工厂&lt;/span&gt;
                .UseMySql(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Server=1.1.1.1;database=666;uid=6666;pwd=88888;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blogs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们直接创建一个日志工厂类,然后注入到EF Core上下文中即可.&lt;/p&gt;
&lt;p&gt;这里作为例子,只将日志记录在了调试窗口..当然也可以记录在自己的文件中..具体请参考LoggerFactory的相关说明..&lt;/p&gt;
&lt;p&gt;我们编写查询代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; GetList(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; a)
        {
           &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; date =  _bloggingContext.Blogs.Where(c =&amp;gt; &lt;span&gt;1&lt;/span&gt; == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;).ToList();
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;() { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LiLei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZhangSan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LiSi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;监控效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/653851/201801/653851-20180124130846803-514159230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Entity Framework Core2.0出来这么久了..Github上面也有很多相关的扩展类库..今天我们就来玩玩这个动态查询库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开源地址:&lt;a href=&quot;https://github.com/StefH/System.Linq.Dynamic.Core/&quot; target=&quot;_blank&quot;&gt;https://github.com/StefH/System.Linq.Dynamic.Core/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这个库还是蛮强大的.支持.NET4.0+ 和 .NET Standard 标准.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个库在nuget中分了几个版本.所以..&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们使用EF Core,所以需要引用它的 Microsoft.EntityFrameworkCore.DynamicLinq 这个库.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个库针对IQueryable进行了动态条件的扩展..&lt;/p&gt;
&lt;p&gt;官方例子的代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; query =&lt;span&gt; db.Customers
    .Where(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;City == @0 and Orders.Count &amp;gt;= @1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;London&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
    .OrderBy(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CompanyName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    .Select(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new(CompanyName as Name, Phone)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到.where条件可以传递格式化字符串.包括排序与查询..都可以传入字符串的条件..&lt;/p&gt;
&lt;p&gt;这样,我们写一些相对比较灵活的模块就可以使用了.比如一个表的查询字段.来源于另一个表.&lt;/p&gt;
&lt;p&gt;下面我们来自己试试效果.&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; GetList(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; a)
        {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; _bloggingContext.Blogs.Add(new Blog() { Url = &quot;asd&quot; });
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  _bloggingContext.SaveChanges();&lt;/span&gt;
           &lt;span&gt;var&lt;/span&gt; date =  _bloggingContext.Blogs.Where(c =&amp;gt; &lt;span&gt;1&lt;/span&gt; == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;).ToList();
           &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; date2 =  _bloggingContext.Blogs.Where(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1==1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new(Url)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).ToDynamicList();
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;() { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LiLei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ZhangSan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LiSi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们直接给一个恒成立的条件来查询所有的数据.&lt;/p&gt;
&lt;p&gt;监控效果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/653851/201801/653851-20180124132116256-1417807243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现,这个库还是很强大的..&lt;/p&gt;
&lt;p&gt;因为它是对IQueryable进行的扩展,所以没有数据库不支持的情况..只要有相关的驱动,就可以基于驱动来生成相关的SQL代码..(我这里访问的就是MySQL)&lt;/p&gt;
&lt;p&gt;..&lt;/p&gt;



&lt;p&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;就到这里了.. EF core2.0已经完全可以用于生产环境了..虽然在之前的线路图中答应的事情..比如更方便的映射..比如分组..比如拦截..都延期到了2.1版本..但是这些并不影响它的强大~..&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 05:28:00 +0000</pubDate>
<dc:creator>GuZhenYin</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GuZhenYin/p/8341216.html</dc:identifier>
</item>
<item>
<title>vhost：一种 virtio 高性能的后端驱动实现 - bakari</title>
<link>http://www.cnblogs.com/bakari/p/8341133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bakari/p/8341133.html</guid>
<description>&lt;h2 id=&quot;什么是-vhost&quot;&gt;什么是 vhost&lt;/h2&gt;
&lt;p&gt;vhost 是 virtio 的一种后端实现方案，在 virtio 简介中，我们已经提到 virtio 是一种半虚拟化的实现方案，需要虚拟机端和主机端都提供驱动才能完成通信，通常，virtio 主机端的驱动是实现在用户空间的 qemu 中，而 vhost 是实现在内核中，是内核的一个模块 vhost-net.ko。为什么要实现在内核中，有什么好处呢，请接着往下看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180124125738740-1456641872.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么要用-vhost&quot;&gt;为什么要用 vhost&lt;/h2&gt;
&lt;p&gt;在 virtio 的机制中，guest 与 用户空间的 Hypervisor 通信，会造成多次的数据拷贝和 CPU 特权级的上下文切换。例如 guest 发包给外部网络，首先，guest 需要切换到 host kernel，然后 host kernel 会切换到 qemu 来处理 guest 的请求， Hypervisor 通过系统调用将数据包发送到外部网络后，会切换回 host kernel ， 最后再切换回 guest。这样漫长的路径无疑会带来性能上的损失。&lt;/p&gt;
&lt;p&gt;vhost 正是在这样的背景下提出的一种改善方案，它是位于 host kernel 的一个模块，用于和 guest 直接通信，数据交换直接在 guest 和 host kernel 之间通过 virtqueue 来进行，qemu 不参与通信，但也没有完全退出舞台，它还要负责一些控制层面的事情，比如和 KVM 之间的控制指令的下发等。&lt;/p&gt;
&lt;h2 id=&quot;vhost-的数据流程&quot;&gt;vhost 的数据流程&lt;/h2&gt;
&lt;p&gt;下图左半部分是 vhost 负责将数据发往外部网络的过程， 右半部分是 vhost 大概的数据交互流程图。其中，qemu 还是需要负责 virtio 设备的适配模拟，负责用户空间某些管理控制事件的处理，而 vhost 实现较为纯净，以一个独立的模块完成 guest 和 host kernel 的数据交换过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180124125838428-1934116043.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;vhost 与 virtio 前端的通信主要采用一种事件驱动 eventfd 的机制来实现，guest 通知 vhost 的事件要借助 kvm.ko 模块来完成，vhost 初始化期间，会启动一个工作线程 work 来监听 eventfd，一旦 guest 发出对 vhost 的 kick event，kvm.ko 触发 ioeventfd 通知到 vhost，vhost 通过 virtqueue 的 avail ring 获取数据，并设置 used ring。同样，从 vhost 工作线程向 guest 通信时，也采用同样的机制，只不过这种情况发的是一个回调的 call envent，kvm.ko 触发 irqfd 通知 guest。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;vhost 与 kvm 的事件通信通过 eventfd 机制来实现，主要包括两个方向的 event，一个是 guest 到 vhost 方向的 kick event，通过 ioeventfd 实现；另一个是 vhost 到 guest 方向的 call event，通过 irqfd 实现。&lt;/p&gt;
&lt;p&gt;代码分析整个通信的流程：&lt;br/&gt;&lt;a href=&quot;http://royluo.org/2014/08/22/vhost/&quot; class=&quot;uri&quot;&gt;http://royluo.org/2014/08/22/vhost/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：对云计算感兴趣的小伙伴可以关注我的微信公众号：aCloudDeveloper，专注云计算领域，坚持分享干货。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/431521/201801/431521-20180124130147350-1762387315.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jan 2018 05:04:00 +0000</pubDate>
<dc:creator>bakari</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bakari/p/8341133.html</dc:identifier>
</item>
</channel>
</rss>