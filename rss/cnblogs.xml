<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深入浅出经典面试题：从浏览器中输入URL到页面加载发生了什么 - Part 1 - 张太国</title>
<link>http://www.cnblogs.com/confach/p/10050013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/confach/p/10050013.html</guid>
<description>&lt;p&gt;“从浏览器中输入URL到页面加载的发生了什么“，这是一道经典的面试题，涉及到的知识面非常多，但作为一个自认为对网络知识掌握的比较好的老码农来说，回答这个问题自然不在话下。如果这道题目如果在面试出现，对我来说就是送分题啊。尽管如此，我还是愿意花一些时间根据我自己的理解回答一下这个题目，看我自己到底掌握的有多深，同时也把自己的知识梳理一下。&lt;/p&gt;
&lt;p&gt;这让我想起另外一件往事，这道题有点类似于“在手机上浏览器上输入一个URL，手机做了一些什么”，我当时学习通信里的核心网时就给自己提出过这个问题。&lt;/p&gt;
&lt;p&gt;我非常愿意将这个面试题的答案共享出来，一是希望得到大家的意见，二是也希望对那些不是特别熟的人起到一些帮助。&lt;/p&gt;
&lt;p&gt;因为文章较长，我将它们分为三大部份，后面会提供该文章的完整PDF版本，供大家下载。&lt;/p&gt;

&lt;p&gt;正如前面所说，这篇文章涉及到的知识面非常丰富，我相信您绝对可以从本文里学到很多基础知识，还有一些高级话题。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DNS的解析原理，常用命令，端口等&lt;/li&gt;
&lt;li&gt;TCP/IP模型，三次握手，四次挥手。&lt;/li&gt;
&lt;li&gt;HTTP/HTTPS的原理和解析。&lt;/li&gt;
&lt;li&gt;浏览器render一个页面&lt;/li&gt;
&lt;li&gt;Web安全性问题&lt;/li&gt;
&lt;li&gt;抓包，分析TCP模型，三次握手，SSL/TLS，让学起来不再枯燥。&lt;/li&gt;
&lt;li&gt;其他一些高级话题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;自认为是目前写的最详细的一篇文章了，因为里面有理论，有实战，应该会起到一个比较好的效果。&lt;/p&gt;

&lt;p&gt;总的来说，当你输入在浏览器里输入一个URL到页面加载，发生的顺序如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;DNS查询&lt;/li&gt;
&lt;li&gt;TCP连接&lt;/li&gt;
&lt;li&gt;发送HTTP请求&lt;/li&gt;
&lt;li&gt;Server处理HTTP请求并返回HTTP报文&lt;/li&gt;
&lt;li&gt;浏览器解析并render页面&lt;/li&gt;
&lt;li&gt;HTTP连接断开&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;后面将对以上步骤详细介绍。&lt;/p&gt;

&lt;h2&gt;DNS解析流程&lt;/h2&gt;
&lt;p&gt;假设输入的URL是包含域名的，那肯定会涉及到DNS解析。当然，如果URL仅仅是IP，那就不会涉及到DNS的。域名的出现是为了方便记忆，因为域名比IP好记。我们这里假设URL包含域名。&lt;/p&gt;
&lt;p&gt;解析的步骤大致如下图：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249/201812/1249-20181201164228952-1248762918.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;首先，在&lt;strong&gt;本地域名服务器&lt;/strong&gt;中根据域名查询IP地址，如果没有找到的情况下，本地域名服务器会向&lt;strong&gt;根域名服务器&lt;/strong&gt;发送一个请求。&lt;/p&gt;
&lt;p&gt;如果根域名服务器也不存在该域名时，本地域名会向com&lt;strong&gt;顶级域名服务&lt;/strong&gt;器（TLD）发送一个请求，依次类推下去。&lt;/p&gt;
&lt;p&gt;直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。&lt;/p&gt;


&lt;p&gt;需要说明的是Root DNS Server一般有13个，后面有个点（.），别忘了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;a.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;c.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;j.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;b.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;i.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;d.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;k.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;f.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;l.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;h.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;m.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;g.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;e.root-servers.net.&lt;/em&gt;&lt;/p&gt;
&lt;div readability=&quot;12.675177176086&quot;&gt;
&lt;h2&gt;DNS的优化&lt;/h2&gt;
&lt;p&gt;我们发现，一个DNS查询在没有缓存的情况下会有6步，这将是一个耗时的过程，如果DNS 查询时间过长，甚至会影响到用户体验。&lt;/p&gt;

&lt;p&gt;那么现阶段是怎么优化的呢？缓存。DNS是存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。&lt;/p&gt;
&lt;div readability=&quot;37.981578197702&quot;&gt; 
&lt;p&gt;我们以Chrome为例子，输入&lt;em&gt;chrome://net-internals/#dns&lt;/em&gt;，我们会看到如下界面：&lt;/p&gt;
&lt;div readability=&quot;79.35197431474&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249/201812/1249-20181201164749085-1820419182.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;这里的Capacity: 1000，代表缓存1K条，那么每条记录缓存多久呢？参看&lt;/p&gt;
&lt;p&gt;&lt;span&gt;timeout 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里的1代表1分钟。&lt;/p&gt;
&lt;p&gt;如果是系统缓存，一般分2种情况：&lt;/p&gt;

&lt;p&gt;Linux 操作系统&lt;/p&gt;
&lt;p&gt;见下图，一般在/etc/hosts下。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/537FB745D7984501AFFDE5D321525B2D&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1249/201812/1249-20181201164857119-1179449091.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Windows操作系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般在&lt;em&gt;C:\Windows\System32\Drivers\etc\hosts&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;谈到这里，我给大家&lt;strong&gt;分享一个特别有用的技巧&lt;/strong&gt;。&lt;/p&gt;
&lt;div readability=&quot;11.815104166667&quot;&gt;我们在做开发和测试时，会有一种情况，经常会去访问某个（测试）URL，例如&lt;a href=&quot;http://192.168.1.8:8080/admin/login&quot;&gt;http://192.168.1.8:8080/admin/login&lt;/a&gt;, 如果这样的话，我们极有可能存在一个问题，觉得每次输入ip真的很麻烦。怎么解决？那么我们可以这么做，利用DNS的原理，将某个伪hostname（abc-test）加入到hosts里，只需加入一条记录：&lt;/div&gt;
&lt;p&gt;&lt;em&gt;192.168.1.8． abc-test&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;DNS负载均衡&lt;/h2&gt;
&lt;p&gt;不知道大家有没有注意或思考过一个问题，Google在全球都有服务器，不同的国家或区域访Google，是不是都很快，这就是Google GSLB的作用。也就是说不同的区域访问Google返回的IP是不一样的，甚至在同一个办公室访问Google，返回回来的IP也有可能是不一样的。&lt;/p&gt;
&lt;p&gt;为什么呢？这里用的就是DNS负载均衡，不然Google怎么去支持全球几十亿客户的请求呢。总之，DNS会根据你的位置或IP返回一个合适的IP给你用。除了Google，一些CDN的SP例如Akamai、AWS、Azure、阿里云都有类似的服务。&lt;/p&gt;
&lt;h2&gt;DNS Record（记录）&lt;/h2&gt;
&lt;p&gt;DNS记录是一个非常重好的概念。DNS记录类型如下表。&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;5128-1543654249829&quot;&gt;
&lt;p&gt;记录类型&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;2960-1543654249829&quot;&gt;
&lt;p&gt;含义简介&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;9287-1543654249829&quot;&gt;
&lt;p&gt;A（Address）&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;2345-1543654249829&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;指定域名对应的IPv4地址&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;7424-1543654249829&quot;&gt;
&lt;p&gt;AAAA&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;4069-1543654249829&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;指定域名对应的IPv6地址&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;6349-1543654249829&quot;&gt;
&lt;p&gt;NS（Name Server）&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;4912-1543654249829&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;指定该域名由哪个DNS服务器来进行解析&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td data-cell-id=&quot;6022-1543654249829&quot;&gt;
&lt;p&gt;MX（Mail Exchanger）&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;1058-1543654249829&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;邮件交换记录，用于电子邮件系统发邮件时根据收信人的地址后缀来定位邮件服务器&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;4544-1543654249830&quot;&gt;
&lt;p&gt;CNAME&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8436-1543654249830&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;别名记录，多个域名映射到同一台计算机（如同一主机提供mail和www服务）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;1275-1543654249830&quot;&gt;
&lt;p&gt;TXT&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;7991-1543654249830&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;主机名或域名的说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;2130-1543654249830&quot;&gt;
&lt;p&gt;TTL（Time-To-Live）&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;5914-1543654249830&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;DNS服务器中保存的时间&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;9396-1543654249830&quot;&gt;
&lt;p&gt;PTR&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8473-1543654249830&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;将一个主机地址映射到对应的域名&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;3431-1543654249830&quot;&gt;
&lt;p&gt;HINFO&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;5469-1543654249830&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;说明映射到特定 DNS 主机名的 CPU 类型和操作系统类型&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;在这里只介绍常用的A Record， CNAME，MX，NS。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A记录是用的最多的一种类型。&lt;/p&gt;
&lt;p&gt;A (Address) 记录是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的Web Server上。&lt;/p&gt;
&lt;p&gt;同时也可以设置该域名的子域名。通俗来说A记录就是服务器的IP,域名绑定A记录就是告诉DNS,当你输入域名的时候给你引导向设置在DNS的A记录所对应的服务器。&lt;/p&gt;
&lt;p&gt;后面的抓包分析会对A记录进行分析，让您有直观认识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CNAME记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CNAME记录是另一种用的比较多的记录，可以将一个域名或者子域名指向另外一个主机名。&lt;/p&gt;

&lt;p&gt;最常用的使用场景是什么呢？没错，CDN就是这种方式。举个例子，例如公司A想把自己的图片放在Akamai的CDN上，A的子域名是img.abc.com, 而 Akamai的CDN服务域名是img.akaimacdn.com. 但是A公司期望用自己的域名吗，而不是Akamai的域名。为了实现这个目标，怎么办？是的，使用CNAME，只需要将子域名img.abc.com指向到img.akaimacdn.com。问题又来了，在哪里设置呢？肯定是在公司A这边的DNS server上，而不是Akamai那边。&lt;/p&gt;
&lt;p&gt;后面的抓包分析会对MX进行分析，让您有直观认识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MX记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MX（Mail Exchanger）记录，字面意思很直观，知道它用来做邮件路由，用户可以将域名下的邮件服务器指向到自己的邮件服务器上，然后可以自己操控所有的邮箱设置。所以只需在线填写服务器的IP地址，即可以将域名下的邮件全部转到您自己设定相应的邮件服务器上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NS记录 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NS记录用来解析服务器记录，表明由哪台服务器对该域名进行解析，这里的NS记录只对子域名生效。&lt;/p&gt;
&lt;p&gt;例如用户希望由12.34.56.78这台服务器解析sub1.mydomain.com，则需要设置 sub1.mydomain.com的NS记录。&lt;/p&gt;
&lt;p&gt;这里涉及到一个问题，细心的我们会发现A记录也有该功能，这里就涉及到优先级的问题了。NS记录优先于A记录。如果一个主机地址同时存在NS记录和A记录，则A记录不生效。&lt;/p&gt;

&lt;div readability=&quot;22.209386878202&quot;&gt;
&lt;h2&gt;DNS常用命令和工具&lt;/h2&gt;
&lt;p&gt;只介绍2个常用的命令dig和nslookup。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;dig&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dig是一个DNS查询工具。&lt;/p&gt;

&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;40.5&quot;&gt;&lt;td data-cell-id=&quot;5372-1543654348138&quot; readability=&quot;62&quot;&gt;
&lt;p&gt;[warren]$ dig&lt;/p&gt;

&lt;p&gt;; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.9.5-3ubuntu0.16-Ubuntu &amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;;; global options: +cmd&lt;/p&gt;
&lt;p&gt;;; Got answer:&lt;/p&gt;
&lt;p&gt;;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 57775&lt;/p&gt;
&lt;p&gt;;; flags: qr rd ra ad; QUERY: 1, ANSWER: 13, AUTHORITY: 0, ADDITIONAL: 1&lt;/p&gt;

&lt;p&gt;;; OPT PSEUDOSECTION:&lt;/p&gt;
&lt;p&gt;; EDNS: version: 0, flags:; udp: 4096&lt;/p&gt;
&lt;p&gt;;; QUESTION SECTION:&lt;/p&gt;
&lt;p&gt;;.                              IN      NS&lt;/p&gt;

&lt;p&gt;;; ANSWER SECTION:&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      a.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      c.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      j.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      b.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      i.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      d.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      k.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      f.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      l.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      h.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      m.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      g.root-servers.net.&lt;/p&gt;
&lt;p&gt;.                       16265   IN      NS      e.root-servers.net.&lt;/p&gt;

&lt;p&gt;;; Query time: 0 msec&lt;/p&gt;
&lt;p&gt;;; SERVER: 208.113.157.202#53(208.113.157.202)&lt;/p&gt;
&lt;p&gt;;; WHEN: Thu Nov 29 18:04:06 PST 2018&lt;/p&gt;
&lt;p&gt;;; MSG SIZE  rcvd: 239&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div readability=&quot;5.8333333333333&quot;&gt;再看看dig 京东的域名&lt;a href=&quot;http://www.jd.com&quot;&gt;www.jd.com&lt;/a&gt; 会有什么效果。&lt;/div&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;4.9250374812594&quot;&gt;&lt;tr readability=&quot;21.177661169415&quot;&gt;&lt;td data-cell-id=&quot;8934-1543654348148&quot; readability=&quot;25.610194902549&quot;&gt;


&lt;p&gt;; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.10.6 &amp;lt;&amp;lt;&amp;gt;&amp;gt; www.jd.com&lt;/p&gt;
&lt;p&gt;;; global options: +cmd&lt;/p&gt;
&lt;p&gt;;; Got answer:&lt;/p&gt;
&lt;p&gt;;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 2675&lt;/p&gt;
&lt;p&gt;;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 0&lt;/p&gt;

&lt;p&gt;;; QUESTION SECTION:&lt;/p&gt;
&lt;p&gt;;www.jd.com.                   IN    A&lt;/p&gt;

&lt;p&gt;;; ANSWER SECTION:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;www.jd.com.            300  IN    CNAME    www.jd.com.gslb.qianxun.com.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;www.jd.com.gslb.qianxun.com. 300 IN CNAME    www.jdcdn.com.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;www.jdcdn.com.        300  IN    A     61.174.55.1&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;;; Query time: 3 msec&lt;/p&gt;
&lt;p&gt;;; SERVER: 192.168.1.1#53(192.168.1.1)&lt;/p&gt;
&lt;p&gt;;; WHEN: Fri Nov 30 10:07:37 CST 2018&lt;/p&gt;
&lt;p&gt;;; MSG SIZE  rcvd: 106&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;红色部分为有CNAME记录和A记录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nslookup&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nslookup适用于Windows，Linux，macOS等操作系统。&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td data-cell-id=&quot;7839-1543654348153&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;nslookup www.jd.com&lt;/p&gt;
&lt;p&gt;Server:            192.168.1.1&lt;/p&gt;
&lt;p&gt;Address:   192.168.1.1#53&lt;/p&gt;

&lt;p&gt;Non-authoritative answer:&lt;/p&gt;
&lt;p&gt;www.jd.com      canonical name = www.jd.com.gslb.qianxun.com.&lt;/p&gt;
&lt;p&gt;www.jd.com.gslb.qianxun.com    canonical name = www.jdcdn.com.&lt;/p&gt;
&lt;p&gt;Name:      www.jdcdn.com&lt;/p&gt;
&lt;p&gt;Address: 61.174.55.1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;


&lt;h2&gt;DNS抓包分析&lt;/h2&gt;
&lt;p&gt;说了这么多，有些同学可能还是觉得只有概念，没法完全理解。所以，我们还是来点实战更为实际，这也是我更进一步了解DNS的工作方式，因为在我看来想了解根本，最有效的方法是抓包，然后深入查探DNS的packet。&lt;/p&gt;

&lt;p&gt;本文都会使用Wireshark，相信大家都用过这个工具吧。如果没用过，可以下载一个，入门很简单的，别担心。&lt;/p&gt;

&lt;div readability=&quot;14.780210867802&quot;&gt;
&lt;p&gt;&lt;strong&gt;A记录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是抓包图，过滤条件是dns，即protocol为DNS。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/09AA3FDD037E419B8482FB48045F919D&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1249/201812/1249-20181201165640223-1265391909.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;6.0277777777778&quot;&gt;请参看第89和90包，这是查询&lt;a href=&quot;http://www.jd.com&quot;&gt;www.jd.com&lt;/a&gt; 的request和response。&lt;/div&gt;

&lt;p&gt;第89包细节图如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249/201812/1249-20181201165657989-1647407821.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://note.youdao.com/src/4699D3DE81BF4A59AFF38EED879AF61D&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;5.8888888888889&quot;&gt;我们可以看到上图，Name是&lt;a href=&quot;http://www.jd.com&quot;&gt;www.jd.com&lt;/a&gt;, Type是A记录。&lt;/div&gt;

&lt;div readability=&quot;14.790279027903&quot;&gt;

&lt;p&gt;另外，我们可以看到其他信息，&lt;span&gt;DNS是通过UDP传送。其实，有时候也是通过TCP来传送。那么什么时候用TCP，什么时候用UDP？很简单，当response的packet大于512字节时，就用TCP，反之，则用UDP。再回头看着89包，长度为70，所以用UDP了&lt;/span&gt;。那多问一个问题，什么情况下DNS查询包超过512？CNAME就有可能。可以参考下面的CNAME抓包。&lt;/p&gt;

&lt;p&gt;端口是多少呢？53，是的，&lt;span&gt;DNS用的是53端口，非常重要&lt;/span&gt;，一般防火墙要打开，否则DNS解析不了，也意味着无法访问域名的website。&lt;/p&gt;

&lt;p&gt;那么返回什么呢？继续看第90包。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249/201812/1249-20181201165824687-942063995.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;6.0140845070423&quot;&gt;我们可以看到&lt;a href=&quot;http://www.jd.com&quot;&gt;www.jd.com&lt;/a&gt; 的DNS A记录，IP地址是61.174.55.1。&lt;/div&gt;

&lt;div readability=&quot;18.349269588313&quot;&gt;
&lt;p&gt;&lt;strong&gt;CNAME&lt;/strong&gt;&lt;/p&gt;



&lt;div readability=&quot;33.754559873117&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249/201812/1249-20181201165913506-695249745.png&quot; alt=&quot;&quot;/&gt;&lt;h2&gt;DNS标准和协议&lt;/h2&gt;

&lt;p&gt;我认为学习协议，框架，或技术，最佳的方法就是阅读官方资料。例如，这里学习DNS可以直接看RFC文档，学习Angular，可以访问其官网。&lt;/p&gt;
&lt;h2&gt;DNS 10问&lt;/h2&gt;
&lt;p&gt;如果面试，下面10问基本可以覆盖全了，答案在上面已经说过了：&lt;/p&gt;
&lt;p&gt;1.     为什么要用域名？&lt;/p&gt;
&lt;p&gt;2.    DNS解析的基本流程？&lt;/p&gt;
&lt;p&gt;3.    DNS的根域名是什么，有几个Server？TLD DNS是什么？&lt;/p&gt;
&lt;p&gt;4.    DNS的优化策略是什么？在各个环节怎么做的？Chrome和各个操作系统怎么做的？&lt;/p&gt;
&lt;p&gt;5.    DNS负载均衡是什么，为什么要用？&lt;/p&gt;
&lt;p&gt;6.    DNS的记录类型有哪些？CNAME一般用在哪些场合？举例子说明一下。&lt;/p&gt;
&lt;p&gt;7.    DNS的常用工具和命令有哪些？&lt;/p&gt;
&lt;p&gt;8.    DNS查询是用TCP还是UDP？一般用哪个端口？&lt;/p&gt;
&lt;p&gt;9.    DNS抓包抓过吗？Wireshark有用过吗？&lt;/p&gt;
&lt;div readability=&quot;5.8863636363636&quot;&gt;10.  请说明一下&lt;a href=&quot;http://www.google.com&quot;&gt;www.google.com&lt;/a&gt; 和google.com的区别，如何设置它们的DNS？&lt;/div&gt;

&lt;p&gt;本章介绍完DNS，下一章节介绍TCP/IP，三次握手，四次挥手，以及SSL/TLS，内容绝对不能错过。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 02 Dec 2018 22:40:00 +0000</pubDate>
<dc:creator>张太国</dc:creator>
<og:description>背景 “从浏览器中输入URL到页面加载的发生了什么“，这是一道经典的面试题，涉及到的知识面非常多，但作为一个自认为对网络知识掌握的比较好的老码农来说，回答这个问题自然不在话下。如果这道题目如果在面试出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/confach/p/10050013.html</dc:identifier>
</item>
<item>
<title>一起学爬虫——PyQuery常用用法总结 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/10056551.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/10056551.html</guid>
<description>&lt;p&gt;&lt;strong&gt;什么是PyQuery&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PyQuery是一个类似于jQuery的解析网页工具，使用lxml操作xml和html文档，它的语法和jQuery很像。和XPATH，Beautiful Soup比起来，PyQuery更加灵活，提供增加节点的class信息，移除某个节点，提取文本信息等功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始化PyQuery对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;html文档的所有操作都需要PyQuery对象来完成，初始化PyQuery对象主要有三种方式，分别是通过网址、字符串和文件名创建。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式一：通过网址初始化PyQyery对象&lt;/strong&gt;&lt;br/&gt;先看一段代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq

s = '&amp;lt;html&amp;gt;&amp;lt;title&amp;gt;PyQuery用法总结&amp;lt;title&amp;gt;&amp;lt;/html&amp;gt;'
doc = pq(s)
print(doc('title'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;title&amp;gt;PyQuery用法总结&amp;lt;/title&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先要import PyQuery类，然后将字符串传递给PyQuery类，这样就生成了一个PyQuery对象，通过该对象就可以访问字符串中的title节点。&lt;br/&gt;PyQuery还会将残缺的html文档补全。看下面的代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq

s = '&amp;lt;html&amp;gt;&amp;lt;title&amp;gt;PyQuery用法总结&amp;lt;/title&amp;gt;'
doc = pq(s)
print(doc('html'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行的结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;PyQuery用法总结&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以我们的字符串的html节点是没有闭合的，并且缺少head节点。初始化PyQuery对象之后，会把html文档补全，并且自动加上head节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式二：URL网址初始化PyQyery对象&lt;/strong&gt;&lt;br/&gt;将要解析的URL网址当做参数传递给PyQuery类：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq

url = 'http://www.bigdata17.com'
doc = pq(url=url,encoding='utf-8')
print(doc('title'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;title&amp;gt;Home - Summer哥的自留地&amp;lt;/title&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式三：通过文件初始化PyQyery对象&lt;/strong&gt;&lt;br/&gt;这个方式也比较常用，很多时候我们会将网站爬取下来然后保存在本地磁盘：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq

doc = pq(filename='test_pyquery.html',encoding='utf-8')
print(doc('title'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;访问节点属性：&lt;/strong&gt;&lt;br/&gt;使用attr()方法访问节点的属性:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq
li = pq('&amp;lt;li id=&quot;test1&quot; class=&quot;test1&quot;&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;li id=&quot;test2&quot; class=&quot;test2&quot;&amp;gt;&amp;lt;/li&amp;gt;')('li')
print(li.attr(&quot;id&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;test1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中有两个id不同的li节点，但是attr()方法只取第一个li节点的id属性值，而不取第二个，我们把上面的代码修改下，把第一个li节点的id属性去掉，attr方法是否只取第一个复合条件节点的属性值：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq
li = pq('&amp;lt;li class=&quot;test1&quot;&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;li id=&quot;test2&quot; class=&quot;test2&quot;&amp;gt;&amp;lt;/li&amp;gt;')('li')
print(li.attr(&quot;id&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个li节点没有id属性，因此返回结果为None，所以可见，attr()方法返回的是第一个节点的属性值。&lt;/p&gt;
&lt;p&gt;那要取多个li节点的属性值，要怎么做呢？这就要结合items()方法来实现。items()方法是返回的节点的生成器&lt;code&gt;generator object PyQuery.items&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq
li = pq('&amp;lt;li id=&quot;test1&quot; class=&quot;test1&quot;&amp;gt;&amp;lt;/li&amp;gt;&amp;lt;li id=&quot;test2&quot; class=&quot;test2&quot;&amp;gt;&amp;lt;/li&amp;gt;')('li')
print(li.items())
for item in li.items():
    print(item.attr(&quot;id&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;generator object PyQuery.items at 0x0000027F26082728&amp;gt;
test1
test2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;动态添加节点属性&lt;/strong&gt;&lt;br/&gt;PyQuery有很多方法动态添加节点的属性，我们挑选几个比较常用的方法介绍个大伙。&lt;br/&gt;&lt;strong&gt;addClass()&lt;/strong&gt;,动态添加节点class属性：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq
html = '&amp;lt;li id=&quot;test1&quot; class=&quot;test1&quot;&amp;gt;&amp;lt;/li&amp;gt;'
li = pq(html)('li')
li.addClass(&quot;addClass&quot;)
print(li)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;code&gt;&amp;lt;li id=&quot;test1&quot; class=&quot;test1 addClass&quot;/&amp;gt;&lt;/code&gt;&lt;br/&gt;可见li节点的calss属性值有test1变为test1 addclass。&lt;/p&gt;
&lt;p&gt;addClass()方法只能动态添加节点class属性的值，能不能动态添加其他属性呢？答案是当然可以，attr()方法就可以实现：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq
html = '&amp;lt;li id=&quot;test1&quot; class=&quot;test1&quot;&amp;gt;&amp;lt;/li&amp;gt;'
li = pq(html)('li')
li.attr(&quot;name&quot;,&quot;li name&quot;)
print(li)
li.attr(&quot;type&quot;,&quot;li&quot;)
print(li)
print(li.attr(&quot;type&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;li id=&quot;test1&quot; class=&quot;test1&quot; name=&quot;li name&quot;/&amp;gt;
&amp;lt;li id=&quot;test1&quot; class=&quot;test1&quot; name=&quot;li name&quot; type=&quot;li&quot;/&amp;gt;
li&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码一共执行了3次attr()方法，执行第一次attr()方法时，有两个参数，分别是name和li name。这是给li节点添加name属性及属性值。执行第二次attr()方法也有两个参数，分别是type和li，这是给li几点添加type属性及type属性值。执行第三次方法attr()方法只有一个type参数，根据前面介绍的attr()方法的用法可知，是获取li节点type属性的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt; attr()方法只有一个参数时，是获取节点的属性值，有两个参数时，是给节点添加属性及属性值，第一个参数时属性，第二个参数时属性值。&lt;/p&gt;
&lt;p&gt;removeClass(),动态移除节点的class属性：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq
html = '&amp;lt;li id=&quot;test1&quot; class=&quot;test1&quot;&amp;gt;&amp;lt;/li&amp;gt;'
li = pq(html)('li')
li.removeClass(&quot;test1&quot;)
print(li)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;br/&gt;&lt;code&gt;&amp;lt;li id=&quot;test1&quot; class=&quot;&quot;/&amp;gt;&lt;/code&gt;&lt;br/&gt;将class节点的属性值有test1变为“”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态添加/修改文本值&lt;/strong&gt;&lt;br/&gt;PyQuery支持动态给节点添加文本值：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq
html = '&amp;lt;li id=&quot;test1&quot; class=&quot;test1&quot;&amp;gt;&amp;lt;/li&amp;gt;'
li = pq(html)('li')
li.html(&quot;use html() dynamic add text&quot;)
print(li)
li.text(&quot;use text() dynamic add text&quot;)
print(li)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;li id=&quot;test1&quot; class=&quot;test1&quot;&amp;gt;use html() dynamic add text&amp;lt;/li&amp;gt;
&amp;lt;li id=&quot;test1&quot; class=&quot;test1&quot;&amp;gt;use text() dynamic add text&amp;lt;/li&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见使用html()和text()方法都可以动态的给节点添加或修改节点的文本值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取节点文本值&lt;/strong&gt;&lt;br/&gt;PyQuery提供text()和html()方法获取节点的文本属性值：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq
html = '&amp;lt;li id = &quot;test_id&quot;&amp;gt;li text value&amp;lt;/li&amp;gt;'
li = pq(html)('li')
print(li.text())
print(li.html())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;li text value
li text value&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt; html()和text()如果没参数，则是获取属性的文本值，如果有参数，则是改变或者添加节点的属性值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;移除节点：&lt;/strong&gt;&lt;br/&gt;remove()方法可以动态移除节点：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq
html = '''
&amp;lt;ul&amp;gt;
hello I am ul tag
&amp;lt;li&amp;gt;hello I am li tag&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
'''
ul = pq(html)('ul')
print(ul.text())
print('执行remove()移除节点')
ul.find('li').remove()
print(ul.text())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hello I am ul tag
hello I am li tag
执行remove()移除节点
hello I am ul tag&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码的ul节点中有个li节点，执行ul.text()方法会返回包括li节点的文本信息，如果我们不想返回li节点的文本信息，仅仅只需要ul节点的文本信息“hell I am ul tag”，要怎么做呢？这时候remove()方法就派上用场了，它删除掉ul节点内的li节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查找节点&lt;/strong&gt;&lt;br/&gt;PyQuery支持使用css的.和#来查找节点：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from pyquery import PyQuery as pq
html = '''
&amp;lt;div class=&quot;div_tag&quot;&amp;gt;
&amp;lt;ul id = &quot;ul_tag&quot;&amp;gt;
hello I am ul tag
&amp;lt;li&amp;gt;hello I am li tag&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
'''
doc = pq(html)
print(doc('.div_tag #ul_tag li'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;li&amp;gt;hello I am li tag&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码是通过.div_tag获取class为div_tag的节点，然后通过#ul_tag获取id为ul_tag的节点，最后返回所有的li节点。&lt;/p&gt;
&lt;p&gt;find()方法查找节点：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;html = '''
&amp;lt;div class=&quot;div_tag&quot;&amp;gt;
&amp;lt;ul id = &quot;ul_tag&quot;&amp;gt;
hello I am ul tag
&amp;lt;li&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
'''
doc = pq(html)
print(doc('.div_tag #ul_tag').find(&quot;li&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;li&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见find(&quot;li&quot;)是把所有li节点及子节点都查找出来。&lt;/p&gt;
&lt;p&gt;还有一个children()方法，是获取当前节点的所有子节点。该方法可以传入css选择器：children('.ul_tag')。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;html = '''
&amp;lt;div class=&quot;div_tag&quot;&amp;gt;
&amp;lt;ul id = &quot;ul_tag&quot;&amp;gt;
hello I am ul tag
&amp;lt;li&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
'''
doc = pq(html)
print(doc('.div_tag #ul_tag').find(&quot;li&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;li&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用parent()方法获取当前节点的父亲节点：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;html = '''
&amp;lt;div class=&quot;div_tag&quot;&amp;gt;
&amp;lt;ul id = &quot;ul_tag&quot;&amp;gt;
hello I am ul tag
&amp;lt;li&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
'''
doc = pq(html)
print(doc('.div_tag #ul_tag li').parent())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;ul id=&quot;ul_tag&quot;&amp;gt;
hello I am ul tag
&amp;lt;li&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码通过.div_tag #ul_tag li css选择器定位到li节点，然后调用parent()方法获取li节点的父节点ul。&lt;/p&gt;
&lt;p&gt;parents()返回当前节点的所有祖宗节点：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;html = '''
&amp;lt;div class=&quot;div_tag&quot;&amp;gt;
&amp;lt;ul id = &quot;ul_tag&quot;&amp;gt;
hello I am ul tag
&amp;lt;li&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
'''
doc = pq(html)
print(doc('.div_tag #ul_tag li').parents())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div class=&quot;div_tag&quot;&amp;gt;
&amp;lt;ul id=&quot;ul_tag&quot;&amp;gt;
hello I am ul tag
&amp;lt;li&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;div class=&quot;div_tag&quot;&amp;gt;
&amp;lt;ul id=&quot;ul_tag&quot;&amp;gt;
hello I am ul tag
&amp;lt;li&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;&amp;lt;div class=&quot;div_tag&quot;&amp;gt;
&amp;lt;ul id=&quot;ul_tag&quot;&amp;gt;
hello I am ul tag
&amp;lt;li&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;ul id=&quot;ul_tag&quot;&amp;gt;
hello I am ul tag
&amp;lt;li&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码返回li节点的所有祖宗节点：html，body,div,ul。&lt;/p&gt;
&lt;p&gt;siblings()方法返回当前节点的兄弟节点：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;html = '''
&amp;lt;div class=&quot;div_tag&quot;&amp;gt;
&amp;lt;ul id = &quot;ul_tag&quot;&amp;gt;
hello I am ul tag
&amp;lt;li class=&quot;li_class1&quot;&amp;gt;hello I am li tag&amp;lt;a&amp;gt;www.bigdata17.com&amp;lt;/li&amp;gt;
&amp;lt;li class=&quot;li_class2&quot;&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;li class=&quot;li_class3&quot;&amp;gt;hello I am the third li tag&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
'''
doc = pq(html)
print(doc('.div_tag #ul_tag .li_class1').siblings())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;li class=&quot;li_class2&quot;&amp;gt;hello I am li tag too&amp;lt;/li&amp;gt;
&amp;lt;li class=&quot;li_class3&quot;&amp;gt;hello I am the third li tag&amp;lt;/li&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用.div_tag #ul_tag .li_class1 CSS节点选择器获取到class为liclassq1的li节点，就是第一个li节点，然后调用siblings()方法获取到子节点，分别是&lt;br/&gt;第二和第三个li节点。&lt;/p&gt;
&lt;p&gt;sibligs()还支持传入css选择器筛选符合条件的li节点：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(doc('.div_tag #ul_tag .li_class1').siblings('.li_class3'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;li class=&quot;li_class3&quot;&amp;gt;hello I am the third li tag&amp;lt;/li&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结：本文讲述了如何使用PyQuery获取网页节点，节点的文本信息，改变节点属性，删除节点属性，增加节点属性等知识点。&lt;/p&gt;
</description>
<pubDate>Sun, 02 Dec 2018 22:00:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>什么是PyQuery PyQuery是一个类似于jQuery的解析网页工具，使用lxml操作xml和html文档，它的语法和jQuery很像。和XPATH，Beautiful Soup比起来，PyQu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/10056551.html</dc:identifier>
</item>
<item>
<title>详解MongoDB中的多表关联查询（$lookup） - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/10055535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/10055535.html</guid>
<description>&lt;h2&gt;一.  聚合框架 &lt;/h2&gt;
&lt;p&gt;聚合框架是MongoDB的高级查询语言，它允许我们通过转换和合并多个文档中的数据来生成新的单个文档中不存在的信息。&lt;/p&gt;
&lt;p&gt;聚合管道操作主要包含下面几个部分：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;命令&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;功能描述&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;$project&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;指定输出文档里的字段.&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;$match&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选择要处理的文档，与fine()类似。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;$limit&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;限制传递给下一步的文档数量。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;$skip&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;跳过一定数量的文档。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;$unwind&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;扩展数组，为每个数组入口生成一个输出文档。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;$group&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;根据key来分组文档。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;$sort&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;排序文档。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;$geoNear&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;选择某个地理位置附近的的文档。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;$out&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;把管道的结果写入某个集合。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;$redact&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;控制特定数据的访问。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;$lookup&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;address&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多表关联（3.2版本新增）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/address&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在本篇幅中，我们聚焦$lookup的使用。&lt;/p&gt;
&lt;h2&gt;二.  $lookup的功能及语法&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 主要功能 &lt;/strong&gt;&lt;/span&gt;是将每个输入待处理的文档，经过$lookup 阶段的处理，输出的新文档中会包含一个新生成的数组列（户名可根据需要命名新key的名字 ）。数组列存放的数据 是 来自 被Join 集合的适配文档，如果没有，集合为空（即 为[ ]）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt; &lt;strong&gt;基本语法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
   $lookup:
     {
       &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;: &lt;span&gt;&amp;lt;&lt;/span&gt;collection &lt;span&gt;to&lt;/span&gt; &lt;span&gt;join&amp;gt;&lt;/span&gt;&lt;span&gt;,
       localField: &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;field &lt;span&gt;from&lt;/span&gt; the input documents&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,
       foreignField: &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;field &lt;span&gt;from&lt;/span&gt; the documents &lt;span&gt;of&lt;/span&gt; the &quot;&lt;span&gt;from&lt;/span&gt;&quot; collection&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;as&lt;/span&gt;: &lt;span&gt;&amp;lt;&lt;/span&gt;output array field&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;3. 语法的解释说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;语法值&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;strong&gt;解释说明&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;同一个数据库下等待被Join的集合。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;
&lt;pre&gt;
&lt;span&gt;localField&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;源集合中的match值，如果输入的集合中，某文档没有 localField&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个Key（Field），在处理的过程中，会默认为此文档含&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有 localField：null的键值对。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;pre&gt;
&lt;span&gt;foreignField&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;待Join的集合的match值，如果待Join的集合中，文档没有foreignField&lt;/span&gt;&lt;br/&gt;&lt;span&gt;值，在处理的过程中，会默认为此文档含有 foreignField：null的键值对。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;pre&gt;
&lt;span&gt;as&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;为输出文档的新增值命名。如果输入的集合中已存在该值，则会覆盖掉，&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;（注：null = null 此为真）&lt;/p&gt;
&lt;p&gt;其语法功能类似于下面的伪SQL语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;, &lt;span&gt;&amp;lt;&lt;/span&gt;output array field&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; collection
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;output array field&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;IN&lt;/span&gt; (&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;
                               &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;collection &lt;span&gt;to&lt;/span&gt; &lt;span&gt;join&amp;gt;&lt;/span&gt;
                               &lt;span&gt;WHERE&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;foreignField&lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;collection.localField&lt;span&gt;&amp;gt;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三. 案例&lt;/h2&gt;
&lt;p&gt;以上的语法介绍有些枯燥，不易理解，我们直接分析品味案例好了。&lt;/p&gt;
&lt;p&gt;假设 有 &lt;strong&gt;&lt;span&gt;订单集合&lt;/span&gt;&lt;/strong&gt;， 存储的测试数据 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
db.orders.&lt;span&gt;insert&lt;/span&gt;(&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
   { &quot;_id&quot; : 1, &quot;item&quot; : &quot;almonds&quot;, &quot;price&quot; : 12, &quot;quantity&quot; : 2 },
   { &quot;_id&quot; : 2, &quot;item&quot; : &quot;pecans&quot;, &quot;price&quot; : 20, &quot;quantity&quot; : 1 },
   { &quot;_id&quot; : 3  }
&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 item 对应 数据为 &lt;strong&gt;商品名称&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;另外 一个 就是就是&lt;/span&gt; &lt;strong&gt;商品库存集合&lt;/strong&gt;&lt;/span&gt; ，存储的测试数据 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
db.inventory.&lt;span&gt;insert&lt;/span&gt;(&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
   { &quot;_id&quot; : 1, &quot;sku&quot; : &quot;almonds&quot;, description: &quot;product 1&quot;, &quot;instock&quot; : 120 },
   { &quot;_id&quot; : 2, &quot;sku&quot; : &quot;bread&quot;, description: &quot;product 2&quot;, &quot;instock&quot; : 80 },
   { &quot;_id&quot; : 3, &quot;sku&quot; : &quot;cashews&quot;, description: &quot;product 3&quot;, &quot;instock&quot; : 60 },
   { &quot;_id&quot; : 4, &quot;sku&quot; : &quot;pecans&quot;, description: &quot;product 4&quot;, &quot;instock&quot; : 70 },
   { &quot;_id&quot; : 5, &quot;sku&quot;: null, description: &quot;Incomplete&quot; },
   { &quot;_id&quot; : 6 }
&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此集合中的 sku 数据等同于 订单 集合中的 &lt;strong&gt;商品名称&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在这种模式设计下，如果要查询订单表对应商品的库存情况，应如何写代码呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很明显这需要两个集合Join。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;场景简单，不做赘述，直送答案 。其语句 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
db.orders.aggregate(&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
   {
     $lookup:
       {
         from: &quot;inventory&quot;,
         localField: &quot;item&quot;,
         foreignField: &quot;sku&quot;,
         as: &quot;inventory_docs&quot;
       }
  }
&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回的执行结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;item&quot; : &quot;almonds&quot;,
    &quot;price&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;quantity&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
        {
            &quot;_id&quot; : NumberInt(&quot;1&quot;),
            &quot;sku&quot; : &quot;almonds&quot;,
            &quot;description&quot; : &quot;product 1&quot;,
            &quot;instock&quot; : NumberInt(&quot;120&quot;)
        }
    &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}


{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;item&quot; : &quot;pecans&quot;,
    &quot;price&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;quantity&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
        {
            &quot;_id&quot; : NumberInt(&quot;4&quot;),
            &quot;sku&quot; : &quot;pecans&quot;,
            &quot;description&quot; : &quot;product 4&quot;,
            &quot;instock&quot; : NumberInt(&quot;70&quot;)
        }
    &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}


{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
        {
            &quot;_id&quot; : NumberInt(&quot;5&quot;),
            &quot;sku&quot; : null,
            &quot;description&quot; : &quot;Incomplete&quot;
        },
        {
            &quot;_id&quot; : NumberInt(&quot;6&quot;)
        }
    &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;分析查询语句和结果，回扣$lookup定义，可以将上面的处理过程，描述如下：&lt;/p&gt;
&lt;p&gt;从集合order中逐个获取文档处理，拿到一个文档后，会根据localField 值 遍历 被 Join的 inventory集合（from: &quot;inventory&quot;），看inventory集合文档中 foreignField值是否与之相等。如果相等，就把符合条件的inventory文档  整体 内嵌到聚合框架新生成的文档中，并且新key 统一命名为 inventory_docs。考虑到符合条件的文档不唯一，这个Key对应的Value是个数组形式。原集合中Key对应的值为Null值或不存在时，需特别小心。&lt;/p&gt;
&lt;h2&gt;四. 说明&lt;/h2&gt;
&lt;p&gt;在以下的说明中，为描述方便，将 from对应的集合定义为 &lt;strong&gt;被join集合；&lt;/strong&gt;待聚合的表成为&lt;strong&gt;源表； &lt;/strong&gt;将 localField 和 foreignField 对应的Key 定义 &lt;strong&gt;比较列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.&lt;/span&gt; &lt;/strong&gt;&lt;/span&gt;因客户端工具显示的问题，上面示例中查询结果重Int 类型值都自动显示为了 NumberInt(&quot;&quot;)。这个NumberInt标注，请忽略，不影响我们的功能测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.&lt;/span&gt; &lt;/strong&gt;这个示例中，一共输出了三个文档，在没有再次聚合（$match）的条件下，这个输出文档数量是以输入文档的数量来决定的（由order来决定），而不是以被Join的集合（&lt;span class=&quot;s2&quot;&gt;inventory&lt;/span&gt;）文档数量决定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.&lt;/span&gt; &lt;/strong&gt;在此需要特别强调的是输出的第三个文档。在源库中原文档没有要比较的列（即item值不存在，既不是Null值，也不是值为空），此时 和 被Join 集合比较，如果 被Join集合中 比较列 也恰好 为NUll 或 不存在的值，此时，判断相等 ，即会把 被Join集合中 比较列 为NUll 或 值不存在 文档 吸收进来。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. &lt;/strong&gt;&lt;/span&gt;假设 源表（order） 中比较列 为某一个值，而此值在待比较表（inventory）的所有文档中都不存在，那么查询结果会是什么样子呢？&lt;/p&gt;
&lt;p&gt;order 集合在现有数据的基础上，再被insert 进一笔测试数据，这个订单的商品为 Start，在库存商品中根本没有此数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
db.orders.&lt;span&gt;insert&lt;/span&gt;({&quot;_id&quot; : &lt;span&gt;4&lt;/span&gt;, &quot;item&quot; : &quot;Start&quot;, &quot;price&quot; : &lt;span&gt;2000&lt;/span&gt;, &quot;quantity&quot; : &lt;span&gt;1&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;order集合的文档数量由之前的3个增长为4个。&lt;/p&gt;
&lt;p&gt;再次执行查询&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
db.orders.aggregate(&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
   {
     $lookup:
       {
         from: &quot;inventory&quot;,
         localField: &quot;item&quot;,
         foreignField: &quot;sku&quot;,
         as: &quot;inventory_docs&quot;
       }
  }
&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时查看结果 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;item&quot; : &quot;almonds&quot;,
    &quot;price&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;quantity&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
        {
            &quot;_id&quot; : NumberInt(&quot;1&quot;),
            &quot;sku&quot; : &quot;almonds&quot;,
            &quot;description&quot; : &quot;product 1&quot;,
            &quot;instock&quot; : NumberInt(&quot;120&quot;)
        }
    &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}

{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;item&quot; : &quot;pecans&quot;,
    &quot;price&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;quantity&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
        {
            &quot;_id&quot; : NumberInt(&quot;4&quot;),
            &quot;sku&quot; : &quot;pecans&quot;,
            &quot;description&quot; : &quot;product 4&quot;,
            &quot;instock&quot; : NumberInt(&quot;70&quot;)
        }
    &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}


{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
        {
            &quot;_id&quot; : NumberInt(&quot;5&quot;),
            &quot;sku&quot; : null,
            &quot;description&quot; : &quot;Incomplete&quot;
        },
        {
            &quot;_id&quot; : NumberInt(&quot;6&quot;)
        }
    &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}


{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;item&quot; : &quot;Start&quot;,
    &quot;price&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;quantity&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt; &lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 查询出的结果也由之前的3个变成了4个。比较特别的是第四个文档 ，其&lt;strong&gt;新增列 为 &quot;inventory_docs&quot; : [ ] ，即值为空&lt;/strong&gt; 。所以，此时，实现的功能非常像关系型数据库的 left join。&lt;/p&gt;
&lt;p&gt;那么，可不可以&lt;strong&gt;只筛选出新增列为空的文档呢&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;即 我们查询出 ，比较列的条件下，刷选出只在A集合中，而不在集合B的文档呢？ 就像关系数据库中量表Join的&lt;strong&gt; left join on a.key =b.key where b.key is null&lt;/strong&gt; .&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答案是可以的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其实回到聚合框架上来，再次聚合一下就可以了，来一次$match就可以了。&lt;/p&gt;
&lt;p&gt;执行的语句调整一下就OK了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
db.orders.aggregate(&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
   {
     $lookup:
       {
         from: &quot;inventory&quot;,
         localField: &quot;item&quot;,
         foreignField: &quot;sku&quot;,
         as: &quot;inventory_docs&quot;
       }
  },
  { $match : {&quot;inventory_docs&quot; : [ &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;} }
])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果 为 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;item&quot; : &quot;Start&quot;,
    &quot;price&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;quantity&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt; &lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出执行结果只有一个文档。这个文档表明的含义是：订单中有这个商品，但是库存中没有这个商品。&lt;/p&gt;
&lt;p&gt;（&lt;strong&gt;$look只是聚合框架的一个stage，在其前前后后，都可以嵌入到其他的聚合管道的命令，例如$match.$group等。&lt;/strong&gt;下面的说明5，也可以说明一二）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.&lt;/span&gt; &lt;/strong&gt;&lt;/span&gt;以上的比较列都是单一的Key/Value,如果复杂一点，如果&lt;strong&gt;比较的列是&lt;span&gt;数组&lt;/span&gt;&lt;/strong&gt;，我们又该如何关联呢？&lt;/p&gt;
&lt;p&gt;我们接下来再来测试一把。将之前 集合order 、inventory 插入的数据清空。&lt;/p&gt;
&lt;p&gt;插入此场景下的新数据，向order中插入的数据，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
db.orders.&lt;span&gt;insert&lt;/span&gt;({ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;item&quot; : &quot;MON1003&quot;, &quot;price&quot; : &lt;span&gt;350&lt;/span&gt;, &quot;quantity&quot; : &lt;span&gt;2&lt;/span&gt;, &quot;specs&quot; :&lt;span&gt;[&lt;/span&gt;&lt;span&gt; &quot;27 inch&quot;, &quot;Retina display&quot;, &quot;1920x1080&quot; &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;, &quot;type&quot; : &quot;Monitor&quot; })
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
specs 对应的value是数组格式。
&lt;/pre&gt;
&lt;p&gt;向集合inventory 新插入的数据 如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
db.inventory.&lt;span&gt;insert&lt;/span&gt;({ &quot;_id&quot; : &lt;span&gt;1&lt;/span&gt;, &quot;sku&quot; : &quot;MON1003&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;instock&quot; : &lt;span&gt;120&lt;/span&gt;,&quot;size&quot; : &quot;&lt;span&gt;27&lt;/span&gt; inch&quot;, &quot;resolution&quot; : &quot;192&lt;span&gt;0x1080&lt;/span&gt;&lt;span&gt;&quot; })

db.inventory.&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;({ &quot;_id&quot; : &lt;span&gt;2&lt;/span&gt;, &quot;sku&quot; : &quot;MON1012&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;instock&quot; : &lt;span&gt;85&lt;/span&gt;,&quot;size&quot; : &quot;&lt;span&gt;23&lt;/span&gt; inch&quot;, &quot;resolution&quot; : &quot;128&lt;span&gt;0x800&lt;/span&gt;&lt;span&gt;&quot; })

db.inventory.&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;({ &quot;_id&quot; : &lt;span&gt;3&lt;/span&gt;, &quot;sku&quot; : &quot;MON1031&quot;, &quot;type&quot; : &quot;Monitor&quot;, &quot;instock&quot; : &lt;span&gt;60&lt;/span&gt;,&quot;size&quot; : &quot;&lt;span&gt;23&lt;/span&gt; inch&quot;, &quot;display_type&quot; : &quot;LED&quot; })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询的语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
db.orders.aggregate(&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
   {
      $unwind: &quot;$specs&quot;
   },
   {
      $lookup:
         {
            from: &quot;inventory&quot;,
            localField: &quot;specs&quot;,
            foreignField: &quot;size&quot;,
            as: &quot;inventory_docs&quot;
        }
   },
   {
      $match: { &quot;inventory_docs&quot;: { $ne: [&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt; } }
   }
])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询显示结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;item&quot; : &quot;MON1003&quot;,
    &quot;price&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;350&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;quantity&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;specs&quot; : &quot;&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;&lt;span&gt; inch&quot;,
    &quot;type&quot; : &quot;Monitor&quot;,
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
        {
            &quot;_id&quot; : NumberInt(&quot;1&quot;),
            &quot;sku&quot; : &quot;MON1003&quot;,
            &quot;type&quot; : &quot;Monitor&quot;,
            &quot;instock&quot; : NumberInt(&quot;120&quot;),
            &quot;size&quot; : &quot;27 inch&quot;,
            &quot;resolution&quot; : &quot;1920x1080&quot;
        }
    &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仔细看啊，输出文档中的 specs 对应的数据变成了字符串类型（原集合为数组）。是什么发挥了如此神奇功效？？？，请看黑板，请将目光集中在&lt;/p&gt;
&lt;pre&gt;
{
      $unwind: &quot;$specs&quot;
   }
&lt;/pre&gt;
&lt;p&gt;还有个小问题，大家猜一下，如果查询语句中没有&lt;/p&gt;
&lt;pre&gt;
{
      $match: { &quot;inventory_docs&quot;: { $ne: []&lt;span&gt; } }
   }&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;结果会是什么样呢？即查看语句修改为：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
db.orders.aggregate(&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
   {
      $unwind: &quot;$specs&quot;
   },
   {
      $lookup:
         {
            from: &quot;inventory&quot;,
            localField: &quot;specs&quot;,
            foreignField: &quot;size&quot;,
            as: &quot;inventory_docs&quot;
        }
   }
&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家猜猜看！&lt;/p&gt;
&lt;p&gt;大家猜猜看！&lt;/p&gt;
&lt;p&gt;大家猜猜看！&lt;/p&gt;
&lt;p&gt;呵呵...此时的结果是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;文档1
{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;item&quot; : &quot;MON1003&quot;,
    &quot;price&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;350&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;quantity&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;specs&quot; : &quot;&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;&lt;span&gt; inch&quot;,
    &quot;type&quot; : &quot;Monitor&quot;,
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;
        {
            &quot;_id&quot; : NumberInt(&quot;1&quot;),
            &quot;sku&quot; : &quot;MON1003&quot;,
            &quot;type&quot; : &quot;Monitor&quot;,
            &quot;instock&quot; : NumberInt(&quot;120&quot;),
            &quot;size&quot; : &quot;27 inch&quot;,
            &quot;resolution&quot; : &quot;1920x1080&quot;
        }
    &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}

文档2 
{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;item&quot; : &quot;MON1003&quot;,
    &quot;price&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;350&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;quantity&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;specs&quot; : &quot;Retina display&quot;,
    &quot;type&quot; : &quot;Monitor&quot;,
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt; &lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}

文档3

{
    &quot;_id&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;item&quot; : &quot;MON1003&quot;,
    &quot;price&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;350&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;quantity&quot; : NumberInt(&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;),
    &quot;specs&quot; : &quot;192&lt;/span&gt;&lt;span&gt;0x1080&lt;/span&gt;&lt;span&gt;&quot;,
    &quot;type&quot; : &quot;Monitor&quot;,
    &quot;inventory_docs&quot; : &lt;/span&gt;&lt;span&gt;[&lt;/span&gt; &lt;span&gt;]&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你推算出正确结果了吗？&lt;/p&gt;
&lt;p&gt;谢谢！！！&lt;/p&gt;
&lt;p&gt;希望以上的讲解和演示能对大家学习$lookup有所帮助。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;注：以上案例数据参考MongoDB官方网站，大家也可访问官网获取更多、更全的相关知识。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;/&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 02 Dec 2018 17:42:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>一. 聚合框架 聚合框架是MongoDB的高级查询语言，它允许我们通过转换和合并多个文档中的数据来生成新的单个文档中不存在的信息。 聚合管道操作主要包含下面几个部分： $lookup 在本篇幅中，我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/10055535.html</dc:identifier>
</item>
<item>
<title>一分钟读懂PDCA 循环 - Sumie</title>
<link>http://www.cnblogs.com/sumie/p/10056481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sumie/p/10056481.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这是与你分享的第 ② 种思维方法：PDCA 循环；&lt;/p&gt;
&lt;p&gt;原文来自WX公众号【运营进阶之路】&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;span&gt;  什么是PDCA循环？&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;PDCA 循环&lt;/strong&gt;因为经戴明博士在日本推广应用，所以，又称“戴明环”。&lt;/p&gt;
&lt;p&gt;PDCA 循环分为4个阶段，如下：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;P（Plan）：计划，确定方针和目标，确定活动计划；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;D（Do）：执行，实地去做，实现计划中的内容；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;C（Check）：检查，总结执行计划的结果，关注效果，找出问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;A（Action）：行动，对总结检查的结果进行处理，成功的经验加以肯定并适当推广、标准化；失败的教训加以总结，以免重现，未解决的问题放到下一个PDCA循环。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;span&gt;  PDCA循环的八个步骤  &lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;PDCA循环的四个阶段又可以细分为以下八个步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K8y1mpPPUnU6iac7aSDBI2icSDwwrP7TVFIMQZJAshPqSicCzL3C5mibqS1zotpAUXoibib2A9SwKXic46GbwcBby1PNQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;312&quot; data-ratio=&quot;0.5967213114754099&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;610&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  步骤一：分析现状，找出问题  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分析现状，找出目前存在的问题，发现问题是解决问题的第一步，是分析问题的前提。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  步骤二：分析各种影响因素或原因  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找出问题后分析产生问题的原因，可以使用头脑风暴法等多种集思广益的科学方法，尽可能把导致问题的所有原因都罗列出来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  步骤三：找出主要因素  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即找出影响问题的主要因素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  步骤四：拟定措施，制定计划  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对导致问题的主要因素制定出有操作性的计划。在制定计划时可使用&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MjU1OTMyNg==&amp;amp;mid=2247483696&amp;amp;idx=1&amp;amp;sn=22a03c8fe7bd86800740012c590f0c7a&amp;amp;chksm=fc66e101cb116817df9c2710ed3fc6d548b26419915de3ca8716f613f7de991d0b6c01e38a33&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;5W2H 原则&lt;/a&gt;，即需要计划好预计达成的目标、采取的措施、执行人员、执行地点、执行时期、成本等内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  步骤五：执行、实施计划  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即按照预定的计划，在实施的基础上，努力实现预期目标的过程。实施过程中也包括对工作计划的调整（比如人员变动、时间变动等等），此外，在这一阶段应同时建立起数据采集，收集实施计划时的原始记录和数据等文档。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  步骤六：检查计划执行结果  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用采集的数据来检查效果，确认目标是否完成。若是未出现预期目标，首先应确认是否有严格按照计划实施对策，若是有严格按照计划执行，则说明对策失效，需要重新确定最佳方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  步骤七：标准化  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对有效的措施进行标准化，制定成工作标准，组织有关人员培训，巩固已取得的成绩。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;  步骤八：问题总结  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于这一循环未解决的问题，或者新出现的问题进行总结，为开展新一轮的PDCA循环提供依据，并转入下一个PDCA 循环的第一步。&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;  PDCA循环的特点 &lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;一、大环套小环  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果把整个企业的工作作为一个大的戴明循环，那么各个部门、小组还有各自小的戴明循环，就像一个行星轮系一样，大环带动小环，一级带一级，有机地构成一个运转的体系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K8y1mpPPUnU6iac7aSDBI2icSDwwrP7TVFSHgGaktFec8F9ib8mOf64MA6ibwO3pc1SiaF3SDTJuU1XunsmWloRaaibA/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.963855421686747&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;415&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;  二、阶梯式上升  &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PDCA 循环不是在同一水平上循环，每循环一次，就解决一部分问题，取得一部分成果，工作就前进一步，水平就提高一步。到了下一次循环，又有了新的目标和内容，更上一层楼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K8y1mpPPUnU6iac7aSDBI2icSDwwrP7TVF0GtDZ9HkcwWIQicvqLDtZhkDnnMdeWSbyeJ959nMoXDJXXxAqvsuGwg/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.975609756097561&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;451&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;  案例分析  &lt;/span&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt; 举个常见的例子，以需要增加社区平台人数为例：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Plan：先确定清楚目标是什么？即增加社区平台用户人数。随后拟定方案，制定计划。当然，计划应尽可能详尽，计划包含预计增加的人数、采取的措施、执行人员、执行渠道、执行时期、成本等内容；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Do：实施计划；实施的过程中需要记录可获取的各项数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Check：检查事项是否完成；对比定下的目标，检查实际增加人数是否达到了目标数量；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Action：复盘总结。若是达成目标，总结规律，优化流程，传承经验。也可以进一步思考，执行方案过程中，是否有办法可以更快的达成目标？有没有出现新的问题？若是没有达成目标，思考阻碍目标达成的阻碍点在哪？继续开展新一轮的PDCA循环，并转入下一个PDCA 循环的第一步。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/b96CibCt70iaa8r7PJoyAtlfHAKe8RosE3wYVKBac55p1HPBJHZS42ywnG4yYtD3jo9A9e5kawBZs4IE6R1C4wibw/640?&quot; alt=&quot;&quot; width=&quot;19px&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;19&quot;/&gt;&lt;/p&gt;
&lt;p&gt;- End -&lt;/p&gt;

&lt;p class=&quot;ql-align-justify&quot;&gt;我猜，也许你还想看...&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;&amp;gt;&amp;gt; &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/sumie/p/10041486.html&quot; target=&quot;_blank&quot;&gt;5W2H分析法——你肯定听过的一种思维工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt; &lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/sumie/p/10019692.html&quot; target=&quot;_blank&quot;&gt;你真的懂如何进行用户调查么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt; &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/sumie/p/9949588.html&quot;&gt;精选互联网运营必读的 8 本书籍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1271999/201811/1271999-20181129224126368-2064039161.png&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;147&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/K8y1mpPPUnU6iac7aSDBI2icSDwwrP7TVFGK3tWWoeOvQOZWCnLHdGyGL3rF4kz1qt2sic8oaUujyJTGe9icXM7YQg/640?wx_fmt=gif&quot; alt=&quot;&quot; data-ratio=&quot;0.5975&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-width=&quot;100%&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 02 Dec 2018 17:07:00 +0000</pubDate>
<dc:creator>Sumie</dc:creator>
<og:description>PDCA 循环是一种能帮助你有效控制工作质量的工具，也称为戴明循环...</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sumie/p/10056481.html</dc:identifier>
</item>
<item>
<title>python设计模式之观察者模式 - sfencs</title>
<link>http://www.cnblogs.com/sfencs-hcy/p/10056376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sfencs-hcy/p/10056376.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;67&quot;&gt;

&lt;blockquote&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建型模式基于对象的创建机制，隔离了对象的创建细节，使代码能够与要创建的对象的类型相互独立&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;结构型模式用于设计对象和类的结构，使它们可以相互协作以获得更大的结构&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;行为型模式主要关注对象的责任，用来处理对象之间的交互，以实现更大的功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;观察者模式是一种行为型模式，在观察者模式当中，主题维护了一个依赖（观察者）列表，以便主题可以使用观察者定义的任何方法通知所有观察者它所发生的变化。&lt;/p&gt;
&lt;p&gt;我们使用UML图来理解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1469015/201812/1469015-20181202225306395-146610457.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Observer为观察者定义了一个接口，里边定义了观察者获得通知的方法，ConcreteObserver（具体观察者）实现这些接口，并与主题创建相关联系，Subject主题存储所有注册的观察者，并向所有观察者发送新消息。&lt;/p&gt;
&lt;p&gt;简单理解：观察者模式即为许多对象等待着某个主题对象的新消息，当主题对象有了新消息的时候，它就会通知所有的观察着它的对象，就像是很多的用户都订阅了一位新闻发布者，当新闻发布者发布了一个新的新闻后，他就会通知它的所有订阅者，就像是手机上一些应用的通知栏通知。&lt;/p&gt;

&lt;p&gt;观察者模式有两种通知方式，拉模型和推模型&lt;/p&gt;
&lt;h3 id=&quot;1-&quot;&gt;1.拉模型&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; abc &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ABCMeta,abstractmethod

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NewsPublisher&lt;/span&gt;:&lt;/span&gt;           
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        self.__subscribers = []
        self.__latestNews = &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;attach&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,subscriber)&lt;/span&gt;:&lt;/span&gt;
        self.__subscribers.append(subscriber)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;detach&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.__subscribers.pop()

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;notifySubscribers&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; sub &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; self.__subscribers:
            sub.update()

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;addNews&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,news)&lt;/span&gt;:&lt;/span&gt;
        self.__latestNews = news

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getNews&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'Got News:'&lt;/span&gt;+self.__latestNews

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Subscriber&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(metaclass=ABCMeta)&lt;/span&gt;:&lt;/span&gt;       

    &lt;span class=&quot;hljs-decorator&quot;&gt;@abstractmethod&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConcreteSubscriber1&lt;/span&gt;:&lt;/span&gt;           
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,publisher)&lt;/span&gt;:&lt;/span&gt;
        self.publisher=publisher
        self.publisher.attach(self)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        print(type(self).__name__,self.publisher.getNews())

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConcreteSubscriber2&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, publisher)&lt;/span&gt;:&lt;/span&gt;
        self.publisher = publisher
        self.publisher.attach(self)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        print(type(self).__name__, self.publisher.getNews())

news_publisher = NewsPublisher()
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; Subscribers &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [ConcreteSubscriber1,ConcreteSubscriber2]:  
    Subscribers(news_publisher)

news_publisher.addNews(&lt;span class=&quot;hljs-string&quot;&gt;'HELLO WORLD'&lt;/span&gt;)
news_publisher.notifySubscribers()
news_publisher.detach()
news_publisher.addNews(&lt;span class=&quot;hljs-string&quot;&gt;'SECOND NEWS'&lt;/span&gt;)
news_publisher.notifySubscribers()
&lt;span class=&quot;hljs-string&quot;&gt;'''
ConcreteSubscriber1 Got News:HELLO WORLD
ConcreteSubscriber2 Got News:HELLO WORLD
ConcreteSubscriber1 Got News:SECOND NEWS
'''&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码应该很容易就读懂了，但是拉模型在这里是什么意思呢，先看一下拉模型的含义：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每当发生变化时，主题都会向所有已经注册的观察者进行广播&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;出现变化后，观察者负责获取相应的变化情况，或者从订户那里拉去数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;拉模型涉及两个步骤，主题通知观察者，观察者从主题那里提取数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体到代码中，主题通知观察者步骤即为news_publisher.notifySubscribers()中调用所有观察者的update方法，这里的update方法没有参数，观察者从主题那里提取数据步骤即为具体观察者的update方法中又调用self.publisher.getNews()来获得数据&lt;/p&gt;
&lt;h3 id=&quot;2-&quot;&gt;2.推模型&lt;/h3&gt;
&lt;p&gt;了解了拉模型，推模型就很容易理解了，它与拉模型的不同之处就在于它一步到位，主题直接发送信息到观察者，代码只需将拉模型的稍微改动即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-python&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; abc &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; ABCMeta,abstractmethod

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NewsPublisher&lt;/span&gt;:&lt;/span&gt;           
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        self.__subscribers = []
        self.__latestNews = &lt;span class=&quot;hljs-keyword&quot;&gt;None&lt;/span&gt;

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;attach&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,subscriber)&lt;/span&gt;:&lt;/span&gt;
        self.__subscribers.append(subscriber)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;detach&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; self.__subscribers.pop()

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;notifySubscribers&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; sub &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; self.__subscribers:
            sub.update(self.__latestNews)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;addNews&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,news)&lt;/span&gt;:&lt;/span&gt;
        self.__latestNews = news

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getNews&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'Got News:'&lt;/span&gt;+self.__latestNews

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Subscriber&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(metaclass=ABCMeta)&lt;/span&gt;:&lt;/span&gt;       

    &lt;span class=&quot;hljs-decorator&quot;&gt;@abstractmethod&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConcreteSubscriber1&lt;/span&gt;:&lt;/span&gt;           
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,publisher)&lt;/span&gt;:&lt;/span&gt;
        self.publisher=publisher
        self.publisher.attach(self)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,news)&lt;/span&gt;:&lt;/span&gt;
        print(type(self).__name__,news)

&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ConcreteSubscriber2&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, publisher)&lt;/span&gt;:&lt;/span&gt;
        self.publisher = publisher
        self.publisher.attach(self)

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self,news)&lt;/span&gt;:&lt;/span&gt;
        print(type(self).__name__, news)

news_publisher = NewsPublisher()
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; Subscribers &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; [ConcreteSubscriber1,ConcreteSubscriber2]:  
    Subscribers(news_publisher)

news_publisher.addNews(&lt;span class=&quot;hljs-string&quot;&gt;'HELLO WORLD'&lt;/span&gt;)
news_publisher.notifySubscribers()
news_publisher.detach()
news_publisher.addNews(&lt;span class=&quot;hljs-string&quot;&gt;'SECOND NEWS'&lt;/span&gt;)
news_publisher.notifySubscribers()

&lt;span class=&quot;hljs-string&quot;&gt;'''
ConcreteSubscriber1 HELLO WORLD
ConcreteSubscriber2 HELLO WORLD
ConcreteSubscriber1 SECOND NEWS
'''&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只将update函数添加了传递的数据参数，并在notifySubscribers函数中传递了参数。&lt;/p&gt;
&lt;p&gt;这种方式只有一个步骤就是主题发送数据，所以能够提高性能，但缺点就是观察者会获得可能自己不需要的数据，当有大量数据观察者都用不到的话就会很浪费了，使响应时间过长。两种方式各有利弊&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;它使彼此交互的对象保持松耦合&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当需要添加其他对象时，无需对主题和观察者做任何修改&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以随时添加和删除观察者&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 02 Dec 2018 15:59:00 +0000</pubDate>
<dc:creator>sfencs</dc:creator>
<og:description>一.行为型模式 创建型模式基于对象的创建机制，隔离了对象的创建细节，使代码能够与要创建的对象的类型相互独立 结构型模式用于设计对象和类的结构，使它们可以相互协作以获得更大的结构 行为型模式主要关注对象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sfencs-hcy/p/10056376.html</dc:identifier>
</item>
<item>
<title>jmeter录制浏览器操作回放 - 学海无涯...继续学</title>
<link>http://www.cnblogs.com/learn-now/p/10056362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learn-now/p/10056362.html</guid>
<description>&lt;p&gt;&lt;span&gt;录制浏览器操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、默认有testpplan,即测试计划；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、为测试计划 添加group，线程组或setup thread group;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305220/201812/1305220-20181202234709298-1225155530.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3、为group新增一个recording controller即录制控制器；&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305220/201812/1305220-20181202234815508-1924044592.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;4、为testplan行政一个Test Script Recorder 即HTTP代理服务器&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305220/201812/1305220-20181202234846838-2110644658.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;5、修改浏览器 网络代理 的设置&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305220/201812/1305220-20181202234923812-285528262.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;6、jmeter中启动代理服务，浏览器中开始执行要录制的操作，jmeter开始录制；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;变量的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、用户自定义变量&lt;/p&gt;
&lt;p&gt;用户自定义key：value值；&lt;/p&gt;
&lt;p&gt;2、计数器&lt;/p&gt;
&lt;p&gt;确认初始值，递增值，最大值，并注意修改引用名称；&lt;/p&gt;
&lt;p&gt;字符串中可以包含变量，无需转义处理&lt;/p&gt;
&lt;p&gt;&quot;domainName&quot;:&quot;zq${id}.com&quot;&lt;/p&gt;
&lt;p&gt;cookie管理中添加如下cookie内容：如pin&lt;/p&gt;

</description>
<pubDate>Sun, 02 Dec 2018 15:50:00 +0000</pubDate>
<dc:creator>学海无涯...继续学</dc:creator>
<og:description>jmeter</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learn-now/p/10056362.html</dc:identifier>
</item>
<item>
<title>STP生成树协议 - 湘北10#</title>
<link>http://www.cnblogs.com/lovelitao/p/10056321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovelitao/p/10056321.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;

&lt;p&gt;&lt;span&gt;1.消除环路：通过阻断冗余链路来消除网络中可能存在的链路&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.链路备份：当活动那个路径发生故障时，激活备份链路，及时恢复网络连通性。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;每个交换机启动STP后，都认为自己是根桥。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根桥选举是根据的是桥ID，简称BID，&lt;span&gt;由桥优先级+MAC地址组成。&lt;/span&gt;&lt;span&gt;桥优先级越小越优先，如果优先级相同，则会比较MAC地址，一样遵循越小越优先的原则。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233344063-1197379522.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233344651-1336658761.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;486&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;非根交换机在选举根端口时依据该端口的&lt;span&gt;根路径开销（RPC）、对端BID、对端PID和本端PID。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根路径开销：非根桥到达根桥的根路径开销值之和叫根路径开销&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;一般情况下，根桥的所有端口都是指定端口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非根交换机在选举指定端口是依据路径开销、本端BID、PID。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有多少个冲突域就有多少个指定端口&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;1.交换机使用默认参数运行STP则桥优先级、PID、和PC开销值一样，桥优先级默认参数为32768，PID默认缺省为128，PC开销默认2000。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2 .选举过程：根桥—根端口—指定端口——其余为阻塞段口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.在STP协议中，都是越小越优先&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233345217-123888931.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233345840-769093570.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;557&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;disabled:禁用状态。端口既不处理和转发BPDU报文，也不转发用户流量。某个端口变成转发状态经过30S~50S。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Blocking:阻塞状态。&lt;span&gt;能接收并处理BPDU，不能转发BPDU。也不能转发用户流量。&lt;/span&gt;此状态是预备端口的最终状态。（0~20S）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Listening:监听状态。&lt;span&gt;端口可以转发BPDU报文，但不能转发用户流量&lt;/span&gt;。15S。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Learming:学习状态。端口可以根据收到的用户流量构建MAC地址表，&lt;span&gt;但不能转发用户流量&lt;/span&gt;。作用是防止临时环路。15S&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Forwarding:转发状态。端口既可以转发用户流量也可以转发BPDU报文，只有根端口或者指定端口才能进入Forwarding。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;BPDU:桥协议数据单元。包含两种配置BPDU和TCN BPDU&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置BPDU:选举根桥和非根桥、根端口和指定端口发送的BPDU&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCN BPDU：当链路发生状态改变发送的BPDU&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233346270-668506091.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233346650-1942218793.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;193&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Message Age：配置BPDU在网络中传播的生存期。&lt;br/&gt;Max Age：配置BPDU在设备中能够保存的最大生存期。(20S)&lt;br/&gt;Hello Time：配置BPDU发送的周期（2S）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Forward Delay：端口状态迁移的延时。(15S)&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233347239-2083075535.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233347991-2060676524.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;603&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233348586-1442730536.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233349379-938792275.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;325&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;查看STP协议：display stp  华为交换机默认的STP模式为MSTP。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改成STP命令：stp mode stp&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面是在非根桥上STP配置的信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233911482-1171977468.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233912106-1117656293.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;120&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.本机BID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.FwDly转发延迟 MaxHop最大跳数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.根桥信息 ERPC表示到达根桥开销值为2000 如果是0，表示本交换机就是根桥&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233912596-2058017448.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1476264/201812/1476264-20181202233913130-323628869.png&quot; alt=&quot;image&quot; width=&quot;800&quot; height=&quot;241&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.FORWARDING转发状态 DISCARDING（阻塞状态）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.Port Role（端口角色）:Designated Port（指定端口 ）Root Port（根端口）Alternate Port（预备端口）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.Port Priority :128  端口优先级 128&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.Port Cost(Dot1T ) :Config=auto / Active=20000（端口开销值20000）&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;1.通过修改优先级来控制根桥的选举&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;stp priority 4096&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.直接指定某一个交换机为根桥&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[Huawei]stp root ?&lt;br/&gt;  primary    Primary root switch----首要的&lt;br/&gt;  secondary  Secondary root switch-----次根桥，当首要根桥失效时，直接变成根桥，不经过选举&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;br/&gt; &lt;/p&gt;

</description>
<pubDate>Sun, 02 Dec 2018 15:39:00 +0000</pubDate>
<dc:creator>湘北10#</dc:creator>
<og:description>STP主要作用 1.消除环路：通过阻断冗余链路来消除网络中可能存在的链路 2.链路备份：当活动那个路径发生故障时，激活备份链路，及时恢复网络连通性。 根桥选举 每个交换机启动STP后，都认为自己是根桥</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovelitao/p/10056321.html</dc:identifier>
</item>
<item>
<title>Redis持久化 - MrChengs</title>
<link>http://www.cnblogs.com/Mrchengs/p/10056294.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchengs/p/10056294.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis的持久化：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以参考官网的说明：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;https://redis.io/topics/persistence&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;持久下主要有一下两种：&lt;/p&gt;
&lt;p&gt;1.RDB（Redis DataBase）&lt;/p&gt;
&lt;p&gt;2.AOF（Append Only File）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;RDB&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.what&lt;/p&gt;
&lt;p&gt;    在指定的时间间隔内将内存中的数据集快照写入磁盘，&lt;/p&gt;
&lt;p&gt;    也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里&lt;/p&gt;

&lt;p&gt;    Redis会&lt;span&gt;单独&lt;/span&gt;创建（fork）一个子进程来进行持久化，会先将数据写入到&lt;/p&gt;
&lt;p&gt;    一个&lt;span&gt;临时文件&lt;/span&gt;中，待持久化过程都结束了，再用这个&lt;span&gt;临时文件&lt;/span&gt;替换上次&lt;span&gt;持久化好的文件&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;    整个过程中，&lt;span&gt;主进程是不进行任何IO操作的&lt;/span&gt;，这就确保了极高的性能&lt;/p&gt;
&lt;p&gt;    如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方&lt;/p&gt;
&lt;p&gt;    式要比AOF方式更加的高效。&lt;span&gt;RDB的缺点是最后一次持久化后的数据可能丢失&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;2.fork&lt;/p&gt;
&lt;p&gt;    fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）&lt;/p&gt;
&lt;p&gt;    数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。&lt;/p&gt;

&lt;p&gt;3.rdb 保存的是dump.rdb文件&lt;/p&gt;

&lt;p&gt;4.&lt;span&gt;如何触发RDB快照&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    参考配置文件的解析---&amp;gt;SNAPSHOTTING快照&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/Mrchengs/p/10053560.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    a.配置文件中默认的快照配置&lt;/p&gt;
&lt;p&gt;        冷拷贝后重新使用-&amp;gt;可以cp dump.rdb dump_new.rdb&lt;/p&gt;
&lt;p&gt;    b.命令save或者是bgsave&lt;/p&gt;
&lt;p&gt;        Save：save时只管保存，其它不管，全部阻塞&lt;/p&gt;
&lt;p&gt;        BGSAVE：Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。可以通过lastsave&lt;/p&gt;
&lt;p&gt;                命令获取最后一次成功执行快照的时间&lt;/p&gt;
&lt;p&gt;    c.执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义&lt;/p&gt;

&lt;p&gt;5.如何恢复&lt;/p&gt;
&lt;p&gt;    a.将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可&lt;/p&gt;
&lt;p&gt;    b.CONFIG GET dir获取目录&lt;/p&gt;

&lt;p&gt;6.优势&lt;/p&gt;
&lt;p&gt;    a.适合大规模的数据恢复&lt;/p&gt;
&lt;p&gt;    b.对数据完整性和一致性要求不高&lt;/p&gt;

&lt;p&gt;7.劣势&lt;/p&gt;
&lt;p&gt;    a.在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改&lt;/p&gt;
&lt;p&gt;    b.fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑&lt;/p&gt;

&lt;p&gt;8.如何停止&lt;/p&gt;
&lt;p&gt;    动态所有停止RDB保存规则的方法：redis-cli config set save &quot;&quot;&lt;/p&gt;

&lt;p&gt;9.小结&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181202232949368-1967509570.png&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; AOF&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1.what&lt;/p&gt;
&lt;p&gt;    以&lt;span&gt;日志的形式&lt;/span&gt;来&lt;span&gt;记录每个写操作&lt;/span&gt;，将Redis执行过的所有写指令记录下来(读操作不记录)，&lt;/p&gt;
&lt;p&gt;    只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis&lt;/p&gt;
&lt;p&gt;    重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作&lt;/p&gt;


&lt;p&gt;2.Aof保存的是appendonly.aof文件&lt;/p&gt;
&lt;p&gt;    参考redis配置文件的APPEND ONLY MODE追加&lt;/p&gt;
&lt;p&gt; https://www.cnblogs.com/Mrchengs/p/10053560.html&lt;/p&gt;

&lt;p&gt;3.AOF启动/修复/恢复&lt;/p&gt;
&lt;p&gt;    正常恢复：&lt;/p&gt;
&lt;p&gt;    a.启动：设置Yes -&amp;gt; 修改默认的appendonly no，改为yes&lt;/p&gt;
&lt;p&gt;    b.将有数据的aof文件复制一份保存到对应目录(config get dir)&lt;/p&gt;
&lt;p&gt;    c.恢复：重启redis然后重新加载&lt;/p&gt;

&lt;p&gt;    异常恢复：&lt;/p&gt;
&lt;p&gt;    a.启动：设置Yes ---&amp;gt;修改默认的appendonly no，改为yes&lt;/p&gt;
&lt;p&gt;    b.备份被写坏的AOF文件&lt;/p&gt;
&lt;p&gt;    c.修复 ---&amp;gt;redis-check-aof --fix进行修复&lt;/p&gt;
&lt;p&gt;    d.恢复：重启redis然后重新加载&lt;/p&gt;

&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;4.rewrite&lt;/p&gt;
&lt;p&gt;    .aof文件越来越多.....&lt;/p&gt;
&lt;p&gt;    如何压缩精减&lt;/p&gt;

&lt;p&gt;    是什么：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    AOF采用&lt;span&gt;文件追加方式&lt;/span&gt;，文件会越来越大为避免出现此种情况，新增了&lt;span&gt;重写机制&lt;/span&gt;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    当AOF&lt;span&gt;文件的大小&lt;/span&gt;超过所设定的&lt;span&gt;阈值&lt;/span&gt;时，Redis就会启动AOF文件的内容压缩，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    只保留可以恢复数据的最小指令集.&lt;span&gt;可以使用命令bgrewriteaof&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181202233148663-2147196276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    重写原理：&lt;/p&gt;
&lt;p&gt;    AOF文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，&lt;/p&gt;
&lt;p&gt;    遍历新进程的内存中数据，每条记录有一条的Set语句。重写aof文件的操作，并没有读取旧的aof文件，&lt;/p&gt;
&lt;p&gt;    而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似&lt;/p&gt;

&lt;p&gt;　 触发机制&lt;/p&gt;
&lt;p&gt;    Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍&lt;/p&gt;
&lt;p&gt;    且文件大于64M时触发&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# Specify a percentage of zero &lt;span&gt;in&lt;/span&gt;&lt;span&gt; order to disable the automatic AOF
# rewrite feature.

&lt;span&gt;auto&lt;/span&gt;&lt;/span&gt;&lt;span&gt;-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5.优势&lt;/p&gt;
&lt;p&gt;    a.每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘 &lt;/p&gt;
&lt;p&gt;        性能较差但数据完整性比较好&lt;/p&gt;
&lt;p&gt;    b.每秒同步：appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失&lt;/p&gt;
&lt;p&gt;    c.不同步：appendfsync no   从不同步&lt;/p&gt;

&lt;p&gt;6.劣势&lt;/p&gt;
&lt;p&gt;    a.相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb&lt;/p&gt;
&lt;p&gt;    b.aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同&lt;/p&gt;

&lt;p&gt;7.小结&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488757/201812/1488757-20181202233252298-1033661666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 02 Dec 2018 15:34:00 +0000</pubDate>
<dc:creator>MrChengs</dc:creator>
<og:description>Redis的持久化： 可以参考官网的说明： https://redis.io/topics/persistence 持久下主要有一下两种： 1.RDB（Redis DataBase） 2.AOF（Ap</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mrchengs/p/10056294.html</dc:identifier>
</item>
<item>
<title>e2e测试框架之Cypress - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/10056217.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/10056217.html</guid>
<description>&lt;p&gt;谈起web自动化测试，大家首先想到的是Selenium！随着近几年前端技术的发展，出现了不少前端测试框架，这些测试框架大多并不依赖于Selenium，这一点跟后端测试框架有很大不同，如Robot Framework做Web自动化测试本质上还是使用的Selenium，包括各语言的xUnit单元测试框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201812/311516-20181202231228547-1967475075.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多吧！这还只是一部分呢？你以为这些都是不知名的小项目？错了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201812/311516-20181202231314309-1593929253.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我特地把Selenium加了进来，其中mocha和jtest在Github上的stats是多于Selenium的，剩下的其它项目也都不弱。&lt;/p&gt;
&lt;p&gt;本文要介绍的是Cypress测试框架! why? 因为人家的文档都是带视频的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201812/311516-20181202231340879-359679250.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看一下人家官方的文档，像这样的视频还有好几段，简直是对新手的宠爱。&lt;/p&gt;
&lt;p&gt;看到这么好的教程，不学一学感觉都对不起人家，是的！这就是我选择了解一下Cypress的原因。&lt;/p&gt;

&lt;h3 id=&quot;官网&quot;&gt;官网：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.cypress.io&quot; class=&quot;uri&quot;&gt;https://docs.cypress.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The web has evolved. Finally, testing has too.&lt;/p&gt;
&lt;p&gt;Web已经进化了，最后，测试也有。&lt;/p&gt;
&lt;p&gt;这类测试框架统称为e2e测试，即end to end（端到端）测试。理论上前端页面由前端框架来测试确实更为合适。这几天我在搭建UI自动化测试框架，顺便封装了一些元素定位，随着对前端技术的了解，我几乎将所有元素定位都换成了CSS，配合JS处理一些Selenium很难操作的元素，确实效率提高了很多，页面元素也没那么难操作了，包括学了点Jenkins的配置，当然，这个话题会放到下一次来分享。&lt;/p&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装：&lt;/h3&gt;
&lt;p&gt;安装很简单，首先你要安装node.js。&lt;/p&gt;
&lt;p&gt;创建cypress_sample练习目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; mkdir cypress_sample
&amp;gt; cd cypress_sample&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装cypress：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cypress_sample &amp;gt; npm install cypress --save-dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动cypress：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cypress_sample &amp;gt; ./node_modules/.bin/cypress open&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次启动Cypress，它已经为我们准备了丰富的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201812/311516-20181202231608869-1150002192.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过vs code 打开cypress_sample项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201812/311516-20181202232012916-811033913.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在examples/目录下面创建baidu.spec.js文件，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;
describe('My First Test', function () {
    it('Does not do much!', function () {
        cy.visit(&quot;https://www.baidu.com&quot;)

        cy.get(&quot;#kw&quot;, {timeout: 2000}).type(&quot;cypress test&quot;)
       
        cy.wait(100)
       
        cy.get(&quot;#su&quot;, { timeout: 2000 }).click()

    })
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上上图，找到在Tests列表中找到 baidu.spec.js文件，点击运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/311516/201812/311516-20181202231650165-423646469.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在VS code 中编辑保存脚本后，上图的窗口会自动执行，速度上比selenium快多了，Selenium启动浏览器怎么着也得3~5秒吧，上面的脚本不到2秒就跑完了，元素定位主要以CSS为主，这其实不是问题，CSS本来就很强大的说。&lt;/p&gt;
&lt;p&gt;也许，这是未来前端测试的方向，至少对于前端人员来说，快速验证界面功能，我想不到有什么理由不选择它，而是Selenium。当然，对于测试人员，脚本的可维护性，报告的生成，以及与持续集成的结合都有一整套成熟的方案。对于Cypress来说（其它前端测试框架不了解），整合能力还不够强，可能JavaScript也是一个门槛。毕竟，这两年，大家刚学会Python。&lt;/p&gt;
</description>
<pubDate>Sun, 02 Dec 2018 15:20:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>e2e测试框架之Cypress</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/10056217.html</dc:identifier>
</item>
<item>
<title>LeetCode_1.Two Sum - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10056169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10056169.html</guid>
<description>&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;
&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;p&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;/p&gt;
&lt;p&gt;Because nums[0] + nums[1] = 2 + 7 = 9,&lt;br/&gt;return [0, 1].&lt;/p&gt;

&lt;p&gt;一般思路：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        # Time Limit Exceeded
        for i in range(len(nums) - 1):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i, j]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法在LeetCode中运行会超时:-(&lt;/p&gt;
&lt;p&gt;改进方式：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Solution:
    def twoSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        dict = {}
        for i in range(len(nums)):
            if target - nums[i] in dict:
                return [dict[target - nums[i]], i]
            else:
                dict[nums[i]] = i&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;时间复杂度从O(n² )降至O(n)。&lt;/p&gt;
</description>
<pubDate>Sun, 02 Dec 2018 15:18:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>问题 Given an array of integers, return indices of the two numbers such that they add up to a specific</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10056169.html</dc:identifier>
</item>
</channel>
</rss>