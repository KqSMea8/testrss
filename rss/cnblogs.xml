<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java 多线程 从无到有 - 房上的猫</title>
<link>http://www.cnblogs.com/lsy131479/p/8698706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsy131479/p/8698706.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;个人总结：望对屏幕对面的您有所帮助&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402233129795-1409908453.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;&lt;span&gt;进程：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有独立的内存控件和系统资源&lt;/span&gt; &lt;span&gt;应用程序的执行实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;启动当前电脑任务管理器：&lt;/span&gt;taskmgr&lt;/p&gt;

&lt;p&gt;&lt;span&gt;进程是程序（任务）的执行过程，它持有资源（共享内存，共享文件）和线程。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;线程：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;进程中执行运算的最小的单位，可完成一个独立的顺序控制流程（执行路径）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CPU&lt;span&gt;调度和分派的基本单位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;一个线程的生命周期：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232820108-442142527.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h4&gt;· &lt;strong&gt;&lt;span&gt;新建状态&lt;/span&gt;:&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt; new &lt;span&gt;关键字和&lt;/span&gt;&lt;span&gt; Thread &lt;/span&gt;&lt;span&gt;类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序&lt;/span&gt;&lt;span&gt; start() &lt;/span&gt;&lt;span&gt;这个线程。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;· &lt;strong&gt;&lt;span&gt;就绪状态&lt;/span&gt;:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;当线程对象调用了&lt;/span&gt;start()&lt;span&gt;方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span&gt;里线程调度器的调度。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;· &lt;strong&gt;&lt;span&gt;运行状态&lt;/span&gt;:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;如果就绪状态的线程获取&lt;/span&gt; CPU &lt;span&gt;资源，就可以执行&lt;/span&gt;&lt;span&gt; run()&lt;/span&gt;&lt;span&gt;，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;· &lt;strong&gt;&lt;span&gt;阻塞状态&lt;/span&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个线程执行了&lt;/span&gt;sleep&lt;span&gt;（睡眠）、&lt;/span&gt;&lt;span&gt;suspend&lt;/span&gt;&lt;span&gt;（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;· &lt;strong&gt;&lt;span&gt;死亡状态&lt;/span&gt;:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程的状态转换&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232800224-1113473746.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;h3&gt;&lt;img alt=&quot;&quot; width=&quot;678&quot; height=&quot;488&quot;/&gt; &lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;新建状态（&lt;/span&gt;New&lt;span&gt;）：新创建了一个线程对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;就绪状态（&lt;/span&gt;Runnable&lt;span&gt;）：线程对象创建后，其他线程调用了该对象的&lt;/span&gt;&lt;span&gt;start()&lt;/span&gt;&lt;span&gt;方法。该状态的线程位于可运行线程池中，变得可运行，等待获取&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;的使用权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;运行状态（&lt;/span&gt;Running&lt;span&gt;）：就绪状态的线程获取了&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;，执行程序代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;阻塞状态（&lt;/span&gt;Blocked&lt;span&gt;）：阻塞状态是线程因为某种原因放弃&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（一）、等待阻塞：运行的线程执行&lt;/span&gt;wait()&lt;span&gt;方法，&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span&gt;会把该线程放入等待池中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则&lt;/span&gt;JVM&lt;span&gt;会把该线程放入锁池中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（三）、其他阻塞：运行的线程执行&lt;/span&gt;sleep()&lt;span&gt;或&lt;/span&gt;&lt;span&gt;join()&lt;/span&gt;&lt;span&gt;方法，或者发出了&lt;/span&gt;&lt;span&gt;I/O&lt;/span&gt;&lt;span&gt;请求时，&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt;&lt;span&gt;会把该线程置为阻塞状态。当&lt;/span&gt;&lt;span&gt;sleep()&lt;/span&gt;&lt;span&gt;状态超时、&lt;/span&gt;&lt;span&gt;join()&lt;/span&gt;&lt;span&gt;等待线程终止或者超时、或者&lt;/span&gt;&lt;span&gt;I/O&lt;/span&gt;&lt;span&gt;处理完毕时，线程重新转入就绪状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;span&gt;死亡状态（&lt;/span&gt;Dead&lt;span&gt;）：线程执行完了或者因异常退出了&lt;/span&gt;&lt;span&gt;run()&lt;/span&gt;&lt;span&gt;方法，该线程结束生命周期。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;多线程：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;线程是系统中最小的执行单元；同一进程中可以有多个线程；线程共享进程的资源。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;定义：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果一个进程中&lt;/span&gt; &lt;span&gt;同时运行了多个线程&lt;/span&gt; &lt;span&gt;，用来完成不同的工作，则称之为&lt;/span&gt; “多线程”&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多个线程交替占用&lt;/span&gt;CPU&lt;span&gt;资源，而非真正的并行执行（）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1）&lt;span&gt;充分利用&lt;/span&gt;CPU&lt;span&gt;资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;简化编程模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个线程控制一个指针&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;带来良好的用户体验&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;创建线程的方法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;有两种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;实现&lt;/span&gt;Runnable&lt;span&gt;接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拥有唯一方法：&lt;/span&gt;run（）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法&lt;/span&gt; run &lt;span&gt;的常规协定是，它可能执行任何所需的动作。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JavaJDK  API &lt;span&gt;给出的解释：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Runnable &lt;span&gt;接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为&lt;/span&gt; &lt;span&gt;run&lt;/span&gt; &lt;span&gt;的无参数方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设计该接口的目的是为希望在活动时执行代码的对象提供一个公共协议。例如，&lt;/span&gt;Thread &lt;span&gt;类实现了&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;。激活的意思是说某个线程已启动并且尚未停止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外，&lt;/span&gt;Runnable &lt;span&gt;为非&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;子类的类提供了一种激活方式。通过实例化某个&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;实例并将自身作为运行目标，就可以运行实现&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;的类而无需创建&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;的子类。大多数情况下，如果只想重写&lt;/span&gt; &lt;span&gt;run()&lt;/span&gt; &lt;span&gt;方法，而不重写其他&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;方法，那么应使用&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;接口。这很重要，因为除非程序员打算修改或增强类的基本行为，否则不应为该类创建子类。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;2. &lt;span&gt;继承&lt;/span&gt;Thread&lt;span&gt;类本身&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;Thread&lt;span&gt;类：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Java&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;java.lang.Thread&lt;/span&gt;&lt;span&gt;类支持多线程编程&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1. &lt;strong&gt;Thread&lt;span&gt;类常用的构造方法：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;&lt;tbody readability=&quot;12.148946840522&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;662&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方法描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;662&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;public &lt;strong&gt;Thread&lt;/strong&gt;()&lt;/p&gt;
&lt;p&gt;分配新的 Thread 对象。这种构造方法与 Thread(null, null, &lt;em&gt;gname&lt;/em&gt;) 具有相同的作用，其中 &lt;strong&gt;&lt;em&gt;gname&lt;/em&gt;&lt;/strong&gt; 是一个新生成的名称。自动生成的名称的形式为 &quot;Thread-&quot;+&lt;em&gt;n&lt;/em&gt;，其中的 &lt;em&gt;n&lt;/em&gt; 为整数。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11.700934579439&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;662&quot; readability=&quot;12.673981191223&quot;&gt;
&lt;p&gt;public &lt;strong&gt;Thread&lt;/strong&gt;(&lt;a title=&quot;java.lang 中的接口&quot;&gt;Runnable&lt;/a&gt;&lt;span&gt; target)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分配新的 Thread 对象。这种构造方法与 Thread(null, target,&lt;em&gt;gname&lt;/em&gt;) 具有相同的作用，其中的 &lt;em&gt;gname&lt;/em&gt; 是一个新生成的名称。自动生成的名称的形式为 “Thread-”+&lt;em&gt;n&lt;/em&gt;，其中的 &lt;em&gt;n&lt;/em&gt; 为整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;target - 其 run 方法被调用的对象。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12.241666666667&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;662&quot; readability=&quot;14.117647058824&quot;&gt;
&lt;p&gt;public &lt;strong&gt;Thread&lt;/strong&gt;(&lt;a title=&quot;java.lang 中的接口&quot;&gt;Runnable&lt;/a&gt;&lt;span&gt; target,&lt;/span&gt;&lt;a title=&quot;java.lang 中的类&quot;&gt;String&lt;/a&gt;&lt;span&gt; name)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分配新的 Thread 对象。这种构造方法与 Thread(null, target, name) 具有相同的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;target - 其 run 方法被调用的对象。&lt;/p&gt;
&lt;p&gt;name - 新线程的名称。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.1724137931034&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;662&quot; readability=&quot;11.581395348837&quot;&gt;
&lt;p&gt;public &lt;strong&gt;Thread&lt;/strong&gt;(&lt;a title=&quot;java.lang 中的类&quot;&gt;String&lt;/a&gt;&lt;span&gt; name)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分配新的 Thread 对象。这种构造方法与 Thread(null, null, name) 具有相同的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;name - 新线程的名称。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;2. &lt;strong&gt;Thread&lt;span&gt;类的一些重要方法&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;对象调用&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方法描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public void start()&lt;/strong&gt;&lt;br/&gt;使该线程开始执行；&lt;strong&gt;Java&lt;/strong&gt; 虚拟机调用该线程的 run 方法。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;public void run()&lt;/strong&gt;&lt;br/&gt;如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final void setName(String name)&lt;/strong&gt;&lt;br/&gt;改变线程名称，使之与参数 name 相同。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final void setPriority(int priority)&lt;/strong&gt;&lt;br/&gt; 更改线程的优先级。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final void setDaemon(boolean on)&lt;/strong&gt;&lt;br/&gt;将该线程标记为守护线程或用户线程。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final void join(long millisec)&lt;/strong&gt;&lt;br/&gt;等待该线程终止的时间最长为 millis 毫秒。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public void interrupt()&lt;/strong&gt;&lt;br/&gt;中断线程。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public final boolean isAlive()&lt;/strong&gt;&lt;br/&gt;测试线程是否处于活动状态。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;h3&gt;3. &lt;strong&gt;Thread&lt;span&gt;类的&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;静态&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;（&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;直接调用&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;方法描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public static void yield()&lt;/strong&gt;&lt;br/&gt;暂停当前正在执行的线程对象，并执行其他线程。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;public static void sleep(long millisec)&lt;/strong&gt;&lt;br/&gt;在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;public static boolean holdsLock(Object x)&lt;/strong&gt;&lt;br/&gt;当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public static Thread currentThread()&lt;/strong&gt;&lt;br/&gt;返回对当前正在执行的线程对象的引用。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;36&quot;&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;661&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;public static void dumpStack()&lt;/strong&gt;&lt;br/&gt;将当前线程的堆栈跟踪打印至标准错误流。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;





&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;主线程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;每一个进程至少只有一个线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;main&lt;span&gt;（）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;方法即为主线程入口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;产生其他子线程的线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;必须&lt;/span&gt;&lt;span&gt;最后&lt;/span&gt;&lt;span&gt;完成执行，因为它执行各种关闭动作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232650979-723556431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; width=&quot;621&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;常见线程名词解释&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;主线程&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;JVM&lt;span&gt;调用程序&lt;/span&gt;&lt;span&gt;main()&lt;/span&gt;&lt;span&gt;所产生的线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;当前线程&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：这个是容易混淆的概念。一般指通过&lt;/span&gt;Thread.currentThread()&lt;span&gt;来获取的进程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后台线程&lt;/span&gt;&lt;span&gt;：指为其他线程提供服务的线程，也称为守护线程。&lt;/span&gt;JVM&lt;span&gt;的垃圾回收线程就是一个后台线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前台线程&lt;/span&gt;&lt;span&gt;：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过&lt;/span&gt;isDaemon()&lt;span&gt;和&lt;/span&gt;&lt;span&gt;setDaemon()&lt;/span&gt;&lt;span&gt;方法来判断和设置一个线程是否为后台线程。&lt;/span&gt;&lt;/p&gt;







&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;定义一个类继承&lt;/span&gt;Thread&lt;span&gt;类&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;建议：类名以&lt;/span&gt;Thread&lt;span&gt;结尾，（清晰）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;public class MyThread extends Thread{&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;重写&lt;/span&gt;run&lt;span&gt;（）方法，编写线程执行体&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;执行的操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逻辑处理代码&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. &lt;strong&gt;&lt;span&gt;创建线程对象，调用&lt;/span&gt;start&lt;span&gt;（）方法启动线程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
类 对象 =  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; 类（）； 
        对象.start（）；&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将会执行步骤二中重写后的run（）方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;span&gt;当多个线程同时启动时：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程间交替执行，顺序不定，根据&lt;/span&gt;CPU&lt;span&gt;分配的时间片觉得的（不可预测）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个线程分别执行，几条不同的执行过程，交替并行执行&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;&lt;span&gt;为什么不直接调用&lt;/span&gt;run&lt;span&gt;（）方法？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;如果直接调用&lt;/span&gt;run()&lt;span&gt;方法：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;执行的线程是&lt;/span&gt;main&lt;span&gt;（）&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;主 线程，并且不是并行执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;只有&lt;/span&gt;&lt;span&gt;主线程&lt;/span&gt;&lt;span&gt;一条&lt;/span&gt;&lt;span&gt;执行路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;依次&lt;/span&gt;&lt;span&gt;调用相应次数的&lt;/span&gt;run&lt;span&gt;（）方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;相当于&lt;/span&gt;&lt;span&gt;单线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. Run&lt;span&gt;（）方法是给底层编译器用的，程序员只能用&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;（）&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;执行结构图：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232442928-1756875636.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;h3&gt;&lt;img alt=&quot;&quot; width=&quot;553&quot; height=&quot;518&quot;/&gt; &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;如果是调用&lt;/span&gt;Start&lt;span&gt;（）方法：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1）&lt;span&gt;不同子线程获取到&lt;/span&gt;CPU&lt;span&gt;时间片时，执行其线程的相应操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;多态执行路径，主线程和子线程并行交替执行&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;多个线程同时执行？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;多个线程交替执行，不是真正的&lt;/span&gt; “并行”&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;线程每次执行时长由分配的&lt;/span&gt;CPU&lt;span&gt;时间片长度觉得&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;&lt;span&gt;广义解释：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;线程中的方法比较有特点，比如&lt;/span&gt;:启动（start），休眠（sleep），停止等，多个线程是交互执行的（cpu在某个时刻。只能执行一个线程，当一个线程休眠了或者执行完毕了，另一个线程才能占用cpu来执行）因为这是cpu的结构来决定的，在某个时刻cpu只能执行一个线程，不过速度相当快，对于人来将可以认为是并行执行的。&lt;/p&gt;

&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;定义类实现&lt;/span&gt;Runnable&lt;span&gt;接口&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;public class MyRunnable impleents Runnable{&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;实现&lt;/span&gt;run&lt;span&gt;（）方法，编写线程执行体&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;run()&lt;span&gt;方法中编写线程执行的代码&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. &lt;strong&gt;&lt;span&gt;创建线程对象，调用&lt;/span&gt;start&lt;span&gt;（）方法启动线程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;实现&lt;/span&gt;Runnable&lt;span&gt;接口创建的线程最终还是要通过将自身实例作为参数传递给&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;然后执行&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;语法：&lt;/span&gt;   &lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Thread actress=new Thread(Runnable target ,String name);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;   &lt;/p&gt;
&lt;p&gt;Thread actressThread=new Thread(new Actress(),&quot;Ms.runnable&quot;);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;/span&gt; actressThread.start();&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;分析：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;使用方式或限制等，与&lt;/span&gt; &lt;span&gt;继承&lt;/span&gt;Thread&lt;span&gt;类 大相径庭&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法必须实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;创建&lt;/span&gt;Runnable&lt;span&gt;实现类对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;将实现类对象交于&lt;/span&gt;Thread&lt;span&gt;对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;启动线程&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4. &lt;strong&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.&lt;span&gt;可以避免&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;的单继承的特性带来的局限性；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;span&gt;适合多个相同程序的代码去处理同一个资源情况，把线程同程序的代码及数据有效的分离，较好的体现了面向对象的设计思想。开发中大多数情况下都使用实现&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;接口这种方法创建线程。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;5. &lt;strong&gt;&lt;span&gt;分析：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;计算机&lt;/span&gt;CPU&lt;span&gt;处理器在同一时间同一个处理器同一个核只能运行一条线程，当一条线程休眠之后，另外一个线程才获得处理器时间&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;继承&lt;/span&gt;Thread&lt;span&gt;类&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1) &lt;span&gt;编写简单，可直接操作线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2) &lt;span&gt;适用于但继承&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;实现&lt;/span&gt;Runnable&lt;span&gt;接口&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1）&lt;span&gt;避免但继承的局限性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;便于共享资源&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. &lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;Java&lt;span&gt;只适用于单根继承）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;推荐使用&lt;/span&gt; &lt;span&gt;实现&lt;/span&gt;Runnable&lt;span&gt;接口&lt;/span&gt; &lt;span&gt;方式创建线程&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;线程的状态&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232410021-808769784.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;h2&gt;&lt;img alt=&quot;&quot; width=&quot;691&quot; height=&quot;205&quot;/&gt; &lt;/h2&gt;

&lt;p&gt;&lt;span&gt;五个状态：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建&lt;/span&gt; &lt;span&gt;就绪&lt;/span&gt; &lt;span&gt;阻塞&lt;/span&gt; &lt;span&gt;运行&lt;/span&gt; &lt;span&gt;死亡&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;线程调度的方法&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;线程调度指按照特定机制为多个线程分配&lt;/span&gt;CPU&lt;span&gt;的使用权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232327301-517692844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; width=&quot;692&quot; height=&quot;349&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;4. &lt;strong&gt;&lt;span&gt;线程唤醒：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Object&lt;span&gt;类中的&lt;/span&gt;&lt;span&gt;notify()&lt;/span&gt;&lt;span&gt;方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个&lt;/span&gt;&lt;span&gt;notifyAll()&lt;/span&gt;&lt;span&gt;，唤醒在此对象监视器上等待的所有线程。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;Thread&lt;span&gt;中&lt;/span&gt;&lt;span&gt;suspend()&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;resume()&lt;/span&gt;&lt;span&gt;两个方法在&lt;/span&gt;&lt;span&gt;JDK1.5&lt;/span&gt;&lt;span&gt;中已经废除&lt;/span&gt;&lt;span&gt;。原因：&lt;/span&gt;&lt;span&gt;有死锁倾向。&lt;/span&gt;&lt;/p&gt;




&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;调整线程优先级：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程的优先级&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;线程优先级由&lt;/span&gt;1 - 10&lt;span&gt;表示，&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;最低，默认优点级为&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优先级高的线程获得&lt;/span&gt;CPU&lt;span&gt;资源&lt;/span&gt;&lt;span&gt;概率&lt;/span&gt;&lt;span&gt;较大&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;调整线程优先级&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;setPriority()&lt;span&gt;方法&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;h5&gt;&lt;strong&gt;&lt;span&gt;取值：&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;线程的优先级代表哪个线程&lt;/span&gt;&lt;span&gt;优先&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;CPU&lt;span&gt;资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每一个&lt;/span&gt;Java&lt;span&gt;线程都有一个优先级，这样&lt;/span&gt;&lt;span&gt;有助于操作系统确定线程的调度顺序&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Java&lt;span&gt;线程的&lt;/span&gt;&lt;span&gt;优先级用整数表示&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;取值范围是&lt;/span&gt;1~10&lt;span&gt;，&lt;/span&gt;Thread&lt;span&gt;类&lt;/span&gt;&lt;span&gt;有以下三个&lt;/span&gt;&lt;span&gt;静态常量&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;static int MAX_PRIORITY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          &lt;span&gt;线程可以具有的&lt;/span&gt;&lt;span&gt;最高优先级&lt;/span&gt;&lt;span&gt;，取值为&lt;/span&gt;10&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;static int MIN_PRIORITY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          &lt;span&gt;线程可以具有的&lt;/span&gt;&lt;span&gt;最低优先级&lt;/span&gt;&lt;span&gt;，取值为&lt;/span&gt;1&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;static int NORM_PRIORITY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          &lt;span&gt;分配给线程的&lt;/span&gt;&lt;span&gt;默认优先级&lt;/span&gt;&lt;span&gt;，取值为&lt;/span&gt;5&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h5&gt;&lt;strong&gt;&lt;span&gt;补充：&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;Thread&lt;span&gt;类的&lt;/span&gt;&lt;span&gt;setPriority()&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;getPriority()&lt;/span&gt;&lt;span&gt;方法分别用来&lt;/span&gt;&lt;span&gt;设置和获取线程的优先级&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个线程都有默认的优先级。&lt;/span&gt;&lt;span&gt;主线程的默认优先级为&lt;/span&gt;Thread.NORM_PRIORITY&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;线程的优先级有继承关系&lt;/span&gt;&lt;span&gt;，比如&lt;/span&gt;A&lt;span&gt;线程中创建了&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;线程，那么&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;将和&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;具有相同的优先级。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;JVM&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具有较高优先级的线程对程序更重要，并&lt;/span&gt;&lt;span&gt;且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;线程睡眠：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;使用：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;让线程暂时睡眠指定时长，线程进入阻塞状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;睡眠过后线程会再进入可运行状态&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;sleep&lt;span&gt;（）方法：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Thread.sleep(long millis)&lt;span&gt;方法，使线程转到阻塞状态。&lt;/span&gt;&lt;span&gt;millis&lt;/span&gt;&lt;span&gt;参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（&lt;/span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;span&gt;）状态。&lt;/span&gt;&lt;span&gt;sleep()&lt;/span&gt;&lt;span&gt;平台移植性好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：调度&lt;/span&gt;sleep&lt;span&gt;（）方法需处理&lt;/span&gt;&lt;span&gt;InterruptedException&lt;/span&gt;&lt;span&gt;异常&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3. &lt;strong&gt;&lt;span&gt;线程等待：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Object&lt;span&gt;类中的&lt;/span&gt;&lt;span&gt;wait()&lt;/span&gt;&lt;span&gt;方法，导致当前的线程等待，直到其他线程调用此对象的&lt;/span&gt; &lt;span&gt;notify()&lt;/span&gt; &lt;span&gt;方法或&lt;/span&gt; &lt;span&gt;notifyAll()&lt;/span&gt; &lt;span&gt;唤醒方法。这个两个唤醒方法也是&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;类中的方法，行为等价于调用&lt;/span&gt; &lt;span&gt;wait(0)&lt;/span&gt; &lt;span&gt;一样。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;使线程暂停执行，等待其他线程结束后再继续执行本线程&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;线程加入：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;join()&lt;span&gt;方法，等待其他线程终止。在当前线程中调用另一个线程的&lt;/span&gt;&lt;span&gt;join()&lt;/span&gt;&lt;span&gt;方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：需处理&lt;/span&gt;InterruptedException&lt;span&gt;异常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232140006-1429946314.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; width=&quot;692&quot; height=&quot;157&quot;/&gt; &lt;/p&gt;
&lt;p&gt;Mills&lt;span&gt;：以毫秒为单位的等待时长&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Nanos&lt;span&gt;：要等待的附加纳秒时长&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;主线程将被执行，执行调用&lt;/span&gt;join&lt;span&gt;（）方法的子线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当此子线程执行完毕后，再返回执行主线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（其他线程避让（阻塞），此线程强制加入执行）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;让当前线程让出&lt;/span&gt;CPU&lt;span&gt;资源，不再参与资源抢占&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;暂停当前线程，允许其他具有相同优先级的线程获得运行机会（不一定会执行）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;改线程处于就绪状态，不转为阻塞状态&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;只能提供一种可能，但是不能保证一定会实现礼让&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1. &lt;strong&gt;&lt;span&gt;线程让步：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Thread.yield() &lt;span&gt;方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当多个线程共享同一资源同时访问一个数据的时候，一个线程未完成全部操作的时候，其他的线程来修改数据数据，会造成线程不安全问题&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;争用条件：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1&lt;span&gt;、当多个线程同时共享访问同一数据（内存区域）时，每个线程都尝试操作该数据，从而导致数据被破坏（&lt;/span&gt;&lt;span&gt;corrupted)&lt;/span&gt;&lt;span&gt;，这种现象称为争用条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、原因是，每个线程在操作数据时，会先将数据初值读【取到自己获得的内存中】，然后在内存中进行运算后，重新赋值到数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;、争用条件：线程&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;在还【未重新将值赋回去时】，线程&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;阻塞，线程&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;开始访问该数据，然后进行了修改，之后被阻塞的线程&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;再获得资源，而将之前计算的值覆盖掉线程&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;所修改的值，就出现了数据丢失情况。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;&lt;span&gt;系统占用&lt;/span&gt;CPU&lt;span&gt;资源：随机性&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;线程的同步是为了防止多个线程访问一个数据对象时，对数据造成的破坏。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;同步方法：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;synchronzed&lt;span&gt;修饰的方法控制对类成员变量的访问&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Synchronized&lt;span&gt;就是为当前的线程声明一个锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一次只允许有一个线程进入执行&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;访问修饰符&lt;/span&gt; synchronized &lt;span&gt;返回类型 方法名 （参数列表）&lt;/span&gt;&lt;span&gt;{ ... ... }&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;p&gt;Synchronized &lt;span&gt;访问修饰符 返回类型 方法名 （参数列表）&lt;/span&gt;&lt;span&gt;{ ... ... }&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt;&lt;span&gt;同步代码块：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;synchronized&lt;span&gt;关键字修饰的代码块&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Synchronized&lt;span&gt;（&lt;/span&gt;&lt;span&gt;syncObject&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//&lt;span&gt;需要同步的代码块&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;解析：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1）yncObject&lt;span&gt;为需同步的对象，通常为&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;效果与同步方法相同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;避免数据不安全问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4）&lt;span&gt;一次只允许有一个线程进入&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;互斥与同步：守恒的能量&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1、线程的特点，共享同一进程的资源，同一时刻只能有一个线程占用CPU&lt;/p&gt;
&lt;p&gt;2、由于线程有如上的特点，所以就会存在多个线程争抢资源的现象，就会存在争用条件这种现象&lt;/p&gt;
&lt;p&gt;3、为了让线程能够正确的运行，不破坏共享的数据，所以，就产生了同步和互斥的两种线程运行的机制&lt;/p&gt;
&lt;p&gt;4、线程的互斥（加锁实现）：线程的运行隔离开来，互不影响，使用synchronized关键字实现互斥行为，此关键字即可以出现在方法体之上也可以出现在方法体内，以一种块的形式出现，在此代码块中有线程的等待和唤醒动作，用于支持线程的同步控制&lt;/p&gt;
&lt;p&gt;5、线程的同步（线程的等待和唤醒：wait()+notifyAll()）：线程的运行有相互的通信控制，运行完一个再正确的运行另一个&lt;/p&gt;
&lt;p&gt;6、锁的概念：比如private final Object lockObj=new Object();&lt;/p&gt;
&lt;p&gt;7、互斥实现方式：synchronized关键字&lt;/p&gt;
&lt;p&gt;synchronized(lockObj){---执行代码----}加锁操作&lt;/p&gt;
&lt;p&gt;lockObj.wait();线程进入等待状态，以避免线程持续申请锁，而不去竞争cpu资源&lt;/p&gt;
&lt;p&gt;lockObj.notifyAll();唤醒所有lockObj对象上等待的线程&lt;/p&gt;
&lt;p&gt;8、&lt;span&gt;加锁操作会开销系统资源，降低效率&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;## &lt;span&gt;同步和锁定&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1&lt;span&gt;、锁的原理&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Java中每个对象都有一个内置锁&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当程序运行到非静态的&lt;/span&gt;synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当程序运行到&lt;/span&gt;synchronized同步方法或代码块时才该对象锁才起作用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的&lt;/span&gt;synchronized方法或代码块，直到该锁被释放。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;释放锁是指持锁线程退出了&lt;/span&gt;synchronized同步方法或代码块。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;关于锁和同步，有一下几个要点：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1）、只能同步方法，而不能同步变量和类；&lt;/p&gt;
&lt;p&gt;2）、每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？&lt;/p&gt;
&lt;p&gt;3）、不必同步类中所有的方法，类可以同时拥有同步和非同步方法。&lt;/p&gt;
&lt;p&gt;4）、如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。&lt;/p&gt;
&lt;p&gt;5）、如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。&lt;/p&gt;
&lt;p&gt;6）、线程睡眠时，它所持的任何锁都不会释放。&lt;/p&gt;
&lt;p&gt;7）、线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。&lt;/p&gt;
&lt;p&gt;8）、同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。&lt;/p&gt;
&lt;p&gt;9）、在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;多个并发线程访问同一资源的同步代码块时&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;同一时刻只能有一个线程进入&lt;/span&gt;synchronized (this )同步代码块&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;当一个线程访问一个&lt;/span&gt;synchronized (this) 同步代码块时，其他synchronized (this) 同步代码块同样被锁定&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;当一个线程访问一个&lt;/span&gt;synchronized (this) 同步代码块时，其他线程可以访问该资源的非synchronized (this) 同步代码&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;## &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;线程同步小结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1、线程同步的目的是为了保护多个线程访问一个资源时对资源的破坏。&lt;/p&gt;
&lt;p&gt;2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，这个锁与一个特定的对象关联，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他同步方法。&lt;/p&gt;
&lt;p&gt;3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。&lt;/p&gt;
&lt;p&gt;4、对于同步，要时刻清醒在哪个对象上同步，这是关键。&lt;/p&gt;
&lt;p&gt;5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。&lt;/p&gt;
&lt;p&gt;6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。&lt;/p&gt;
&lt;p&gt;7、死锁是线程间相互等待锁锁造成的，在实际中发生的概率非常的小。真让你写个死锁程序，不一定好使，呵呵。但是，一旦程序发生死锁，程序将死掉。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;## 深入剖析互斥与同步&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;互斥的实现（加锁）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;strong&gt;synchronized&lt;/strong&gt;(lockObj); 保证的同一时间，只有一个线程获得lockObj.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;同步的实现：&lt;/span&gt;wait()/notify()/notifyAll()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：&lt;/span&gt;wait()、notify()、notifyAll()方法均属于Object对象，而不是Thread对象。&lt;/p&gt;
&lt;p&gt;void notify() &lt;br/&gt;          唤醒在此对象监视器上等待的单个线程。 &lt;br/&gt; void notifyAll() &lt;br/&gt;          唤醒在此对象监视器上等待的所有线程。 &lt;br/&gt; void wait() &lt;br/&gt;          导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然，&lt;/span&gt;wait()还有另外两个重载方法：&lt;/p&gt;
&lt;p&gt; void wait(long timeout) &lt;br/&gt;          导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。 &lt;br/&gt; void wait(long timeout, int nanos) &lt;br/&gt;          导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;同步是两个线程之间的一种交互的操作（一个线程发出消息另外一个线程响应）&lt;/span&gt; &lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;关于等待&lt;/span&gt;/通知，要记住的关键点是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;必须从同步环境内调用&lt;/span&gt;wait()、notify()、notifyAll()方法。线程不能调用对象上等待或通知的方法，除非它拥有那个对象的锁。&lt;/p&gt;
&lt;p&gt;wait()、notify()、notifyAll()都是Object的实例方法。与每个对象具有锁一样，每个对象可以有一个线程列表，他们等待来自该信号（通知）。线程通过执行对象上的wait()方法获得这个等待列表。从那时候起，它不再执行任何其他指令，直到调用对象的notify()方法为止。如果多个线程在同一个对象上等待，则将只选择一个线程（不保证以何种顺序）继续执行。如果没有线程等待，则不采取任何特殊操作。&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;span&gt;千万注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当在对象上调用&lt;/span&gt;wait()方法时，执行该代码的线程立即放弃它在对象上的锁。然而调用notify()时，并不意味着这时线程会放弃其锁。如果线程荣然在完成同步代码，则线程在移出之前不会放弃锁。因此，只要调用notify()并不意味着这时该锁变得可用。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;多个线程在等待一个对象锁时候使用&lt;/span&gt;notifyAll()&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在多数情况下，最好通知等待某个对象的所有线程。如果这样做，可以在对象上使用&lt;/span&gt;notifyAll()让所有在此对象上等待的线程冲出等待区，返回到可运行状态。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt; ### &lt;span&gt;如何理解同步：&lt;/span&gt;&lt;span&gt;Wait Set&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Critical Section（临界资源）Wait Set（等待区域）&lt;/p&gt;
&lt;p&gt;wait set 类似于线程的休息室，访问共享数据的代码称为critical section。一个线程获取锁，然后进入临界区，发现某些条件不满足，然后调用锁对象上的wait方法，然后线程释放掉锁资源，进入锁对象上的wait set。由于线程释放释放了理解资源，其他线程可以获取所资源，然后执行，完了以后调用notify，通知锁对象上的等待线程。&lt;/p&gt;
&lt;p&gt;Ps：若调用notify();则随机拿出（这随机拿出是内部的算法，无需了解）一条在等待的资源进行准备进入Critical Section；若调用notifyAll();则全部取出进行准备进入Critical Section。&lt;/p&gt;



&lt;h2&gt;&lt;strong&gt;&lt;span&gt;个人理解：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;span&gt;多个线程各有自己的锁，都想拿到自己的锁，但谁都不想放开自己的锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多个线程执行不同的上锁代码块但共享同一资源，双方都抢不到&lt;/span&gt;CPU&lt;span&gt;时间片，就形成了死锁&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;资料解释：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;死锁&lt;/span&gt;--&lt;span&gt;两个线程都在等待对方完成，造成程序的停滞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;死锁的条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;两个或两个以上的线程在活动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;某个线程拿到一个锁以后，还想拿第二个锁，造成锁的嵌套&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;生产者和消费者问题，生产者不断生成，消费者不断取走生产者生成的产品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生产者生产出信息之后将其放到一个区域之中，之后消费者从此区域里取出数据&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;Object&lt;span&gt;类中的&lt;/span&gt;Wait&lt;span&gt;（&lt;/span&gt;&lt;span&gt;线程等待&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt; &lt;span&gt;与&lt;/span&gt; notifyAll(&lt;span&gt;唤醒所有线程&lt;/span&gt;)&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。&lt;/p&gt;
&lt;p&gt;2、可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;为什么使用线程池？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程缺乏统一管理，占用过多系统资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺乏更多功能，如定时执行，定期执行等&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用线程池的好处&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;重用存在的线程，减少对象创建，消亡开销&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;有效控制最大并发数，提高系统资源使用率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;定时执行，定期执行&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;实现原理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;（线程比作员工，线程池比作一个团队，核心池比作团队中核心团队员工数，核心池外的比作外包员工）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;有了新需求，先看核心员工数量超没超出最大核心员工数，还有名额的话就新招一个核心员工来做&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;需要获取全局锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;核心员工已经最多了，&lt;/span&gt;HR 不给批 HC 了，那这个需求只好攒着，放到待完成任务列表吧&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;如果列表已经堆满了，核心员工基本没机会搞完这么多任务了，那就找个外包吧&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;需要获取全局锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;如果核心员工&lt;/span&gt; + 外包员工的数量已经是团队最多能承受人数了，没办法，这个需求接不了了&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232041819-1948989811.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;

&lt;h2&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;使用：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;线程池所在包：&lt;/span&gt;java.util.concurrent&lt;/p&gt;
&lt;p&gt;&lt;span&gt;顶级接口是&lt;/span&gt;Excutor&lt;span&gt;，&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;子接口&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;真正的线程池接口是&lt;/span&gt;&lt;span&gt;ExecutorService&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Java.util.concurrent.Executors&lt;span&gt;类提供创建线程池的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1211814/201804/1211814-20180402232020192-1696493944.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&quot;&quot; width=&quot;692&quot; height=&quot;222&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;ThreadPoolExcecutor&lt;span&gt;类的使用&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;（自定义线程池）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;构造器中各个参数的含义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。&lt;/span&gt;corePoolSize: &lt;span&gt;核心池的大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;。&lt;/span&gt;maximumPoolSize: &lt;span&gt;线程池最大线程数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;keepAliveTime: &lt;span&gt;表示线程没有任务执行时最多保持多久时间会终止&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;unit: &lt;span&gt;参数&lt;/span&gt;&lt;span&gt;keepAliveTime&lt;/span&gt;&lt;span&gt;的时间单位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;workQueue: &lt;span&gt;一个阻塞队列，用来存储等待执行的任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;threadFactory: &lt;span&gt;线程工厂，主要用来创建线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;handler: &lt;span&gt;表示当拒绝处理任务时的策略&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;· corePoolSize&lt;span&gt;：核心线程池数量&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;在线程数少于核心数量时，有新任务进来就新建一个线程，即使有的线程没事干&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· &lt;span&gt;等超出核心数量后，就不会新建线程了，空闲的线程就得去任务队列里取任务执行了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· maximumPoolSize&lt;span&gt;：最大线程数量&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;包括核心线程池数量&lt;/span&gt; + 核心以外的数量&lt;/p&gt;
&lt;p&gt;· &lt;span&gt;如果任务队列满了，并且池中线程数小于最大线程数，会再创建新的线程执行任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· keepAliveTime&lt;span&gt;：核心池以外的线程存活时间，即没有任务的外包的存活时间&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;如果给线程池设置&lt;/span&gt; allowCoreThreadTimeOut(true)&lt;span&gt;，则核心线程在空闲时头上也会响起死亡的倒计时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· &lt;span&gt;如果任务是多而容易执行的，可以调大这个参数，那样线程就可以在存活的时间里有更大可能接受新任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· workQueue&lt;span&gt;：保存待执行任务的阻塞队列&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;不同的任务类型有不同的选择，下一小节介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· threadFactory&lt;span&gt;：每个线程创建的地方&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;可以给线程起个好听的名字，设置个优先级啥的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· handler&lt;span&gt;：饱和策略，大家都很忙，咋办呢，有四种策略&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;· CallerRunsPolicy&lt;span&gt;：只要线程池没关闭，就直接用调用者所在线程来运行任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· AbortPolicy&lt;span&gt;：直接抛出&lt;/span&gt; RejectedExecutionException 异常&lt;/p&gt;
&lt;p&gt;· DiscardPolicy&lt;span&gt;：悄悄把任务放生，不做了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· DiscardOldestPolicy&lt;span&gt;：把队列里待最久的那个任务扔了，然后再调用&lt;/span&gt; execute() 试试看能行不&lt;/p&gt;
&lt;p&gt;· &lt;span&gt;我们也可以实现自己的&lt;/span&gt; RejectedExecutionHandler 接口自定义策略，比如如记录日志什么的&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;保存待执行任务的阻塞队列&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;当线程池中的核心线程数已满时，任务就要保存到队列中了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;线程池中使用的队列是&lt;/span&gt; BlockingQueue 接口，常用的实现有如下几种：&lt;/p&gt;
&lt;p&gt;· ArrayBlockingQueue：基于数组、有界，按 FIFO（先进先出）原则对元素进行排序&lt;/p&gt;
&lt;p&gt;· LinkedBlockingQueue：基于链表，按FIFO （先进先出） 排序元素 &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;吞吐量通常要高于&lt;/span&gt; ArrayBlockingQueue&lt;/p&gt;
&lt;p&gt;· Executors.newFixedThreadPool() 使用了这个队列&lt;/p&gt;
&lt;p&gt;· SynchronousQueue：不存储元素的阻塞队列 &lt;/p&gt;
&lt;p&gt;· &lt;span&gt;每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· &lt;span&gt;吞吐量通常要高于&lt;/span&gt; LinkedBlockingQueue&lt;/p&gt;
&lt;p&gt;· Executors.newCachedThreadPool使用了这个队列&lt;/p&gt;
&lt;p&gt;· PriorityBlockingQueue：具有优先级的、无限阻塞队列&lt;/p&gt;






&lt;p&gt;&lt;span&gt;扩展建议：如何扩展&lt;/span&gt;Java&lt;span&gt;并发知识&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Java Memory Mode : JMM&lt;/span&gt;&lt;span&gt;描述了&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;线程如何通过内存进行交互，了解&lt;/span&gt;&lt;span&gt;happens-before , synchronized,voliatile &amp;amp; final&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Locks % Condition&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;锁机制和等待条件的高层实现&lt;/span&gt; &lt;span&gt;java.util,concurrent.locks&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;、线程安全性：原子性与可见性，&lt;/span&gt; &lt;span&gt;java.util.concurrent.atomic synchronized&lt;/span&gt;&lt;span&gt;（锁的方法块）&lt;/span&gt;&lt;span&gt;&amp;amp;volatile&lt;/span&gt;&lt;span&gt;（定义公共资源）&lt;/span&gt; &lt;span&gt;DeadLocks(&lt;/span&gt;&lt;span&gt;死锁）&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;了解什么是死锁，死锁产生的条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4&lt;span&gt;、多线程编程常用的交互模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· Producer-Consumer&lt;span&gt;模型（生产者&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;消费者模型）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· Read-Write Lock&lt;span&gt;模型（读写锁模型）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· Future&lt;span&gt;模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;· Worker Thread&lt;span&gt;模型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;考虑在&lt;/span&gt;Java&lt;span&gt;并发实现当中，有哪些类实现了这些模型，供我们直接调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Java5&lt;/span&gt;&lt;span&gt;中并发编程工具：&lt;/span&gt;&lt;span&gt;java.util.concurrent&lt;/span&gt; &lt;span&gt;包下的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：线程池&lt;/span&gt;ExcutorService &lt;span&gt;、&lt;/span&gt;&lt;span&gt;Callable&amp;amp;Future&lt;/span&gt; &lt;span&gt;、&lt;/span&gt;&lt;span&gt;BlockingQueue&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img id=&quot;uploading_image_92934&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;（C） 房上的猫 。 保留所有权利。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt; https://www.cnblogs.com/lsy131479/&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如需转载，请注明出处！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Apr 2018 15:33:00 +0000</pubDate>
<dc:creator>房上的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsy131479/p/8698706.html</dc:identifier>
</item>
<item>
<title>Spring-Data-JPA整合MySQL和配置 - 浅浅_浅默</title>
<link>http://www.cnblogs.com/zeryts/p/8698673.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zeryts/p/8698673.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　（1）、MySQL是一个关系型数据库系统,是如今互联网公司最常用的数据库和最广泛的数据库。为服务端数据库，能承受高并发的访问量。&lt;/p&gt;
&lt;p&gt;　　（2）、Spring-Data-Jpa是在JPA规范下提供的Repository层的实现，可以使用不同的实现框架如Hibernate、OpenJpa等框架进行开发,这样可以使得Repository变得简单，也解决了其与业务层的耦合性。&lt;/p&gt;
&lt;p&gt;本此学习我们使用MySQL+Spring-Data-Jpa搭建,Jpa实现方式使用Hibernate，数据库连接池使用dbcp进行连接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、项目搭建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;1、引入MySQL以及Jpa相关依赖:　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; spring-jdbc相关依赖 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-jdbc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 用于连接mysql的相关依赖 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; jpa相关的依赖 &lt;code class=&quot;hljs xml has-numbering&quot;/&gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-jpa&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要引入三个依赖，jdbc为spring整合MySQL需要的依赖，第二个为MySQL的数据库驱动依赖,第三个为Spring-Data-Jpa相关的依赖包含：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1358569/201804/1358569-20180402220231050-1576840627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中其包含AOP、jdbc、Spring-ORM、事务Transaction-api和Hibernate等依赖来支持。所以Jpa默认为使用Hibernate进行实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;span&gt;　2 、配置文件配置:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　配置文件我们选择.yml格式文件进行配置，并且使用dpcp2配置连接池参数:&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1)项目相关配置:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;server:&lt;/span&gt;
 &lt;span&gt; #配置端口号&lt;/span&gt;
  &lt;span&gt;port:&lt;/span&gt; 8088
&lt;span&gt;spring:&lt;/span&gt;
  &lt;span&gt;application:&lt;/span&gt; 
  &lt;span&gt;  #配置服务名称&lt;/span&gt;
   &lt;span&gt; name:&lt;/span&gt; cms-dept&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处为配置配置服务器开启的相关信息，主要为配置服务器名称和端口&lt;/p&gt;
&lt;p&gt;　　2)MySQL相关配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#数据源和jpa配置&lt;/span&gt;
 &lt;span&gt; datasource:&lt;/span&gt;
   &lt;span&gt; #数据库相关的配置url  -SSL连接设置为false&lt;/span&gt;
   &lt;span&gt; url:&lt;/span&gt; jdbc:mysql://localhost:3306/crm?characterEncoding=utf8&lt;/span&gt;&lt;span&gt;&amp;amp;useSSL&lt;/span&gt;&lt;span&gt;=false
  &lt;span&gt;  #配置用户名&lt;/span&gt;
    &lt;span&gt;username:&lt;/span&gt; ***
   &lt;span&gt; #配置密码&lt;/span&gt;
   &lt;span&gt; password:&lt;/span&gt; ***
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处为数据库相关的一些配置,主要为配置数据库url、账号和密码。url后配置信息为连接MySQL的编码格式和是否启用SSL加密。&lt;/p&gt;
&lt;p&gt;　　3)DBCP相关配置　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;spring:&lt;/span&gt;
   &lt;span&gt; #下面为连接池相关配置&lt;/span&gt;
   &lt;span&gt; dbcp2:&lt;/span&gt;
     &lt;span&gt; #初始化连接池大小&lt;/span&gt;
     &lt;span&gt; initial-size:&lt;/span&gt; 10
     &lt;span&gt; #陪住最小连接池数&lt;/span&gt;
     &lt;span&gt; min-idle:&lt;/span&gt; 10      
      #配置最大连接池数
     &lt;span&gt; max-idle:&lt;/span&gt; 30
     &lt;span&gt; #配置获取超时连接的等待时间&lt;/span&gt;
     &lt;span&gt; max-wait-millis:&lt;/span&gt; 30000
      #配置多长时间进行一次检测,检测需要关闭的数据库连接
     &lt;span&gt; time-between-eviction-runs-millis:&lt;/span&gt; 200000
     &lt;span&gt; #配置连接在连接池的最小生存时间&lt;/span&gt;
      &lt;span&gt;remove-abandoned-on-maintenance:&lt;/span&gt; 200000
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要配置为一些连接池的信息，配置详情如上注释所示。&lt;/p&gt;
&lt;p&gt;　　4）Spring-Data-Jpa依据iHibernata相关配置　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;spring:&lt;/span&gt; 
&lt;span&gt;  jpa:&lt;/span&gt;
  &lt;span&gt;  #配置数据库类型&lt;/span&gt;
   &lt;span&gt; database:&lt;/span&gt; MYSQL
  &lt;span&gt;  #配置是否打印sql&lt;/span&gt;
   &lt;span&gt; show-sql:&lt;/span&gt; true
    #Hibernate相关配置
  &lt;span&gt;  hibernate:&lt;/span&gt;
    &lt;span&gt;  #配置级联等级 &lt;/span&gt; 
      &lt;span&gt;ddl-auto:&lt;/span&gt; update
    &lt;span&gt;  naming:&lt;/span&gt;
      &lt;span&gt;  #命名策略&lt;/span&gt;
       &lt;span&gt; strategy:&lt;/span&gt; org.hibernate.cfg.ImprovedNamingStrategy
  &lt;span&gt;  properties:&lt;/span&gt;
  &lt;span&gt;    hibernate:&lt;/span&gt; 
       &lt;span&gt; dialect:&lt;/span&gt; org.hibernate.dialect.MySQL5Dialect&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置依次为连接数据库类型,是否打印Sql和hIbernate级联方式,有以下几种:&lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt;1)、validate- 加载hibernate时，验证创建数据库表结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2)、create- 每次加载hibernate，重新创建数据库表结构，这就是导致数据库表数据丢失的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3)、create-drop 加载hibernate时创建，退出是删除表结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4)、update-级联更新 加载hibernate自动更新数据库结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在此选择级联更新，在原有表基础上进行迭代。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;命名策略有以下两种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1)、&lt;span&gt;&lt;span&gt;&lt;span&gt;org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy&lt;/span&gt;&lt;/span&gt;   遇到大写字母 加”_”的命名。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　2)、&lt;span&gt;org.hibernate.cfg.ImprovedNamingStrategy   无修改命名 。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3 、相关类进行配置:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　配置类需要配置与气动类的平级目录或者子目录下,才能被配置成功，此处我们使用Java类配置取代xml方式进行配置：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @功能描述:用于MySQL相关配置的类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面此行用来排序的注解接口,用于处理加载优先级的问题,拥有两个枚举变量 &lt;/span&gt;
&lt;span&gt;@Order(Ordered.HIGHEST_PRECEDENCE)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面此行代表此类为配置类&lt;/span&gt;
&lt;span&gt;@Configuration 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面此行代表此类开启事务管理&lt;/span&gt;
@EnableTransactionManagement(proxyTargetClass = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以定义为类 如DeptRepository.class   也可以定义过滤器 includeFilters={ @ComponentScan.Filter(type=FilterType.ANNOTATION,value=Service.class)} &lt;/span&gt;
@EnableJpaRepositories(basePackages=&quot;com.hzt.**.repository&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MySQLConfig {
    &lt;/span&gt;&lt;span&gt;
    @Bean
    PersistenceExceptionTranslationPostProcessor persistenceExceptionTranslationPostProcessor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PersistenceExceptionTranslationPostProcessor();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;span&gt; 1）、@Order注解，&lt;span&gt;用于配置类的加载优先级别,其拥有两个枚举变量&lt;/span&gt;：&lt;br/&gt;　　&lt;/span&gt;&lt;span&gt;　Ordered.HIGHEST_PRECEDENCE- Integer.MIN_VALUE -最小值,拥有最高优先级&lt;/span&gt;&lt;span&gt;&lt;br/&gt;　　　Ordered.LOWEST_PRECEDENCE -Integer.MAX_VALUE -最大值,拥有最低优先级&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2)、&lt;span&gt;@Configuration 注解，代表此类为配置类&lt;br/&gt;3)、@EnableTransactionManagement 用于MySQL的事务管理 proxyTargetClass= &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;代表开启类的事务管理&lt;br/&gt;4)、@EnableJpaRepositories 用于配置事务,此处以cgnl表达式表示路径&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;,也可以定义为具体的类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;,例如DeptRepository.class&lt;br/&gt;　　其子元素includeFilters可以定义&lt;/span&gt;事务拦截器,如&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span readability=&quot;1&quot;&gt;&lt;span readability=&quot;2&quot;&gt;includeFilters={ @ComponentScan.Filter(type=FilterType.ANNOTATION,value=Service.class)}&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4 、ORM映射Java类相关代码:&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1)数据库表结构&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1358569/201804/1358569-20180402224045462-1127904759.png&quot; alt=&quot;&quot; width=&quot;457&quot; height=&quot;167&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　&lt;strong&gt;　2)实体类映射&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
@Entity  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;代表此类为一个表的映射entity类&lt;/span&gt;
@Table(name=&quot;tbl_dept&quot;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置对应的表名&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dept &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable{
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 功能描述:序列化时候的唯一性，&lt;span&gt;&lt;span&gt;相应的get和set方法已经省略。&lt;/span&gt;&lt;/span&gt;
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 1L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 主键-id uuid &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Id  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此备注代表该字段为该类的主键&lt;/span&gt;
    @GeneratedValue(generator=&quot;system-uuid&quot;&lt;span&gt;)
    @GenericGenerator(name&lt;/span&gt;=&quot;system-uuid&quot;,strategy = &quot;uuid&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;//name - &lt;span&gt;指定对应列的名称&lt;/span&gt; ,&lt;/span&gt;&lt;span&gt;length - 最大长度&lt;/span&gt;
    @Column(name=&quot;id&quot;,length=32) &lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String id;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 数字,具有唯一性 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;nullable - 是否可以为null,默认为true   unique - 是否唯一,默认为false&lt;/span&gt;
    @Column(name=&quot;no&quot;,nullable=&lt;span&gt;false&lt;/span&gt;,unique=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer no;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 部门名称 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Column(name&lt;/span&gt;=&quot;name&quot;,unique=&lt;span&gt;true&lt;/span&gt;,nullable=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 部门管理的主键-id uuid &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Column(name&lt;/span&gt;=&quot;manager&quot;,unique=&lt;span&gt;true&lt;/span&gt;,nullable=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String manager;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 部门描述 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Column(name&lt;/span&gt;=&quot;description&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String description;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 部门电话 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Column(name&lt;/span&gt;=&quot;phone&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String phone;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 部门创建时间 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Column(name&lt;/span&gt;=&quot;createTime&quot;&lt;span&gt;)&lt;br/&gt;　　@DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date createTime;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 部门修改时间 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Column(name&lt;/span&gt;=&quot;editTime&quot;&lt;span&gt;)&lt;br/&gt;　　@DateTimeFormat(pattern=&quot;yyyy-MM-dd HH:mm:ss&quot;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Date editTime;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;(1)、@Entity 代表此类映射为数据库的表结构&lt;br/&gt;(2)、@Table(name=&quot;tbl_dept&quot;)此注解用于配置实体类与表映射的关系,name代表映射的表名&lt;br/&gt;(3)、&lt;span&gt; @Id&lt;/span&gt;注解代表此类为一个主键&lt;br/&gt;(4)、@GeneratedValue注解用于配置主键相关信息,generator属性用于配置生成策略有以下几种枚举值:&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;1、auto - 主键由程序控制 。&lt;br/&gt;　　2、IDENTITY - 由数据库自动生成。&lt;br/&gt;　　3、enerator -指定生成主键使用的生成器 。&lt;br/&gt;　4、SEQUENCE - 根据底层数据库的序列来生成主键 。&lt;br/&gt;　　5、TABLE - 使用一个特定的数据库表来保存主键。&lt;br/&gt;　　6、system-uuid 代表使用系统生成的uuid进行配。&lt;br/&gt;(5)、@Column用于配置列相关信息的注解&lt;br/&gt;　　1、name字段用于指定映射到表结构的映射字段。&lt;br/&gt;　　2、length&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;代表此字段的长度约束,可以省略。&lt;br/&gt;　　3、unique属性代表此字段是否开启唯一性约束，默认为false,唯一则为true 。&lt;br/&gt;　　4、nullable代表此字段是否可以为空,默认为true 。 false代表不能为空 。&lt;br/&gt;（6）、&lt;span&gt;@DateTimeFormat&lt;/span&gt;用于映射数据库表时间的格式。&lt;br/&gt;相应的get和set方法已经省略。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;strong&gt;&lt;span&gt;3)DeptRepository层实现&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1358569/201804/1358569-20180402230010350-1439315505.jpg&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;149&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt; 如图，Respository为一个接口规范,有不同的子接口继承,每个子接口除了继承父接口所有功能外还会添加额外的方法,用于不同的实现。CrudRepository类定义了基本方法,其子类分别进行扩展。&lt;br/&gt;如PagingAndSortingRepository类除了继承CrudRepository的所有方法,还额外对其进行扩展,增加了分页查找的相关方法:&lt;br/&gt;　　Iterable&amp;lt;T&amp;gt; findAll(Sort sort);&lt;br/&gt;　　Page&amp;lt;T&amp;gt; findAll(Pageable pageable);&lt;br/&gt;而JpaRepository则是在&lt;span&gt;&lt;span&gt;&lt;span&gt;PagingAndSortingRepository&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的基础上再进行扩展。&lt;br/&gt;&lt;strong&gt;1、Repository层:&lt;/strong&gt;&lt;br/&gt;　&lt;span&gt;@Repository 代表将此类交由spring管理,并且其为一个dao层&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @功能描述:用于部门表操作的dao层接口
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Repository&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代表此为一个dao层实现&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; DeptRepository &lt;span&gt;extends&lt;/span&gt; JpaRepository&amp;lt;Dept, String&amp;gt;&lt;span&gt;{

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;根据实现类不同，其拥有不同的方法可调用，一般此处方法大家见名知意都能知道其用法。泛型中&amp;lt;Dept, String&amp;gt; 第一个参数代表表映射的实体类,第二个参数代表主键类型。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2、Service层实现:&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @功能描述:用于部门service操作的实现类
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DeptServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; DeptService{
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 日志处理类 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger log =&lt;span&gt; LoggerFactory.getLogger(getClass());
    
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DeptRepository repository;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Dept queryById(String id) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Dept result &lt;/span&gt;=&lt;span&gt; repository.findOne(id);
            log.info(result.toString());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            log.info(e.toString(),e);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServiceException(&quot;根据id查询时发生异常!&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;其中&lt;span&gt;findOne为JpaRepository实现的方法。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3、Controller层实现:&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
@RequestMapping(&lt;/span&gt;&quot;/api/v1/dept&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DeptController&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 日志记录类 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Logger log =&lt;span&gt; LoggerFactory.getLogger(getClass());
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 自家的service &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DeptService service;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * @功能描述:根据id查询部门内容的方法
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; Dept
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/id/get&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Result getById( String id) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        verify(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; VerifyParam(&quot;部门id&quot;&lt;span&gt;, id));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result(&quot;通过id获取部门信息成功!&quot;&lt;span&gt;, service.queryById(id));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中RestController代表此Controller为返回Json格式的控制器，@RequestMapping定义其类映射的url,此处我们接受的数据为普通String类型,如果需要接受Json类型,则需 @RequestBody String id 如此配置接受请求参数。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4 、测试:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1358569/201804/1358569-20180402232003949-619016067.png&quot; alt=&quot;&quot; width=&quot;546&quot; height=&quot;274&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;模拟进行发送get请求,完成Spring-Data-Jpa与MySQL的整合和配置。&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 02 Apr 2018 15:22:00 +0000</pubDate>
<dc:creator>浅浅_浅默</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zeryts/p/8698673.html</dc:identifier>
</item>
<item>
<title>JVM笔记7-内存分配与回收策略 - 蜗居在小黑屋操控世界</title>
<link>http://www.cnblogs.com/huangjuncong/p/8698599.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/8698599.html</guid>
<description>&lt;p&gt;1.对象优先在Eden分配&lt;/p&gt;
&lt;p&gt;　　大多数情况下，对象在新生代Eden区中分配。当Eden区中没有足够空间分配时，虚拟机将发起一次Minor GC。虚拟机提供了-XX:PrintGCDetails 这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。&lt;/p&gt;
&lt;p&gt;　　现在我们看如下例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package hjc.test9;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/4/2.&lt;br/&gt;* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestGC {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; _1MB = &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testAllocation(){
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] allcation1, allcation2, allcation3, allcation4;

        allcation1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt; *&lt;span&gt; _1MB];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestGC.testAllocation();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201804/1202638-20180402174203470-1656639104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;testAllocation()方法中，尝试分配3个2MB大小和1个4MB大小的对象，在运行时-Xms20M -Xmx20M -Xmn10M 这三个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下10MB分配给老年代。-XX:SurvivorRatio=8 决定了新生代中&lt;/p&gt;
&lt;p&gt;Eden区与一个Survivor区的空间比例为8:1,从输出的结果可以看到eden space 8192K,from space 1024K,to space 1024K,的信息，新生代总可用空间为9216KB(Eden+1个Survivor的总容量)。&lt;/p&gt;
&lt;p&gt;执行testAllocaton（）中分配Allocation4对象的语句时发生一次Minor GC,这次GC的结果是新生代6651KB变成148KB，而总内存占用量则几乎没有减多少，因为allocation1,allocation2,allocation3三个对象都是存活的，虚拟机几乎没有找到可回收对象。这次GC&lt;/p&gt;
&lt;p&gt;发生的原因是给allocaton4分配内存的时候发现Eden已经被占用了6MB，剩余空间已经不足以分配allocation4所需的4MB，因此，发生Minor GC。GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间(Survivor空间只有1MB大小)，所以只好分配担保机制&lt;/p&gt;
&lt;p&gt;提前转移到老年代去。这次GC结束后，4MB的allocation4对象顺利分配在Eden中，因此程序执行完的结果是Eden占用4MB(被allocation4占用)，Survivor空闲，老年代被占用6MB(被allocation1,allocation2,allocation3占用)。&lt;/p&gt;

&lt;p&gt;2.大对象直接进入老年代&lt;/p&gt;
&lt;p&gt;　　所谓的大对象是指，需要大量连续内存的Java对象，最经典的大对象就是那种很长的字符串以及数组，大对象对虚拟机的内存分配来说是一个坏消息，经常出现大对象容易导致内存还有不少空间就提前出发垃圾收集以获取足够的练习空间来安置它们。&lt;/p&gt;
&lt;p&gt;　　虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对新疆直接在老年代分配，这样做的目的是避免在Eden区以及两个Survivor区之间发生大量的内存复制。&lt;/p&gt;
&lt;p&gt;　　例子如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package hjc.test9;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/4/2.&lt;br/&gt;* -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8&lt;br/&gt;*-XX:PretenureSizeThreshold=3145728
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestGC1 {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; _1MB = &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testPretenureSizeThreshold(){
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] allocation;
        allocation &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;5&lt;/span&gt; *&lt;span&gt; _1MB]; //出现一次Minor GC
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestGC1.testPretenureSizeThreshold();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201804/1202638-20180402204914432-9235717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行testPretenureSizeThreshold()方法后，我们看到Eden空间几乎没有被使用，而老年代的10MB空间被使用了40%，也就是说4MB的allocation对象直接就分配在老年代中，这是因为PretenureSizeThreshold被设置为3MB(就是3145728，这个参数不能想-Xmx之类的参数一样直接写3MB)&lt;/p&gt;
&lt;p&gt;因此超过3MB的对象会直接在老年代进行分配。&lt;/p&gt;

&lt;p&gt;3.长期存活的对象将进入老年代&lt;/p&gt;
&lt;p&gt;　　虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经历过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1.对象在Survivor区中没熬过一次GC，年龄就增加1岁，当它的年龄增加到一定程度(默认15岁),&lt;/p&gt;
&lt;p&gt;　　就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。这里分别用-XX:MaxTenuringThreshold=1 和 -XX:MaxTenuringThreshold=15演示。&lt;/p&gt;
&lt;p&gt;　　例子如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package hjc.test9;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/4/2.
 * 
 * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestGC2 {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; _1MB = &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

    @SuppressWarnings(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unused&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testTenuringThreshold(){
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] allcation1, allcation2, allcation3, allcation4;
        allcation1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1MB / &lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;什么时候进入老年代取决于XX:MaxTenuringThreshold设置&lt;/span&gt;
        allcation2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1MB / &lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
        allcation3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation4 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        allcation4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt; *&lt;span&gt; _1MB];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestGC2.testTenuringThreshold();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201804/1202638-20180402215155733-475254748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201804/1202638-20180402215211753-284399072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;testTenuringThreshold()方法中的allocation1对象需要256KB内存，Surivivor空间可以容纳。当MaxTenringThreshold=1时，allocation1对象在第二次GC发生时进入老年代，新生代已使用的内存GC后非常干净的0KB。&lt;/p&gt;

&lt;p&gt;自己在修改MaxTenringThreshold=15时，这里就第二次GC发生后，allocation对象则还留在新生代Survivor空间，这时新生代仍然有404KB被占用。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201804/1202638-20180402215728662-1668850071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.动态对对象年龄判定。&lt;/p&gt;
&lt;p&gt;　　为了能更好的适应不同程序的内存情况，虚拟机并不是永远地要求对象年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代，&lt;/p&gt;
&lt;p&gt;　　无需等到MaxTenuringThreshold中要求的年龄。&lt;/p&gt;
&lt;p&gt;　　例子如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package hjc.test9;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/4/2.
 *
 * -verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestGC2 {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; _1MB = &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

    @SuppressWarnings(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unused&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testTenuringThreshold(){
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] allcation1, allcation2, allcation3, allcation4;
        allcation1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1MB / &lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;allcation1+allcation2 大于Survivor空间的一般&lt;/span&gt;
        allcation2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1MB / &lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
        allcation3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation4 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        allcation4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt; *&lt;span&gt; _1MB];
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestGC2.testTenuringThreshold();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201804/1202638-20180402220623791-1276950707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以看到testTenuringThreshold方法设置-XX:MaxTenuringThreshold=15，会发现运行结果中Survivor的空间占用仍谈为0%，而老年代比预期增加了6%，也就是说allocation1，2  直接进入老年代，没到等到15岁的临界年龄。因为这两对象&lt;/p&gt;
&lt;p&gt;加起来已经达到了512KB,并且它们都是同年的，满足同年对象达到Survivor空间的一般规则。&lt;/p&gt;

&lt;p&gt;5.空间分配担保&lt;/p&gt;
&lt;p&gt;　　在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间付否大于新生代所有对象总空间，如果这条件成立，那么MinorGC可以确保是安全的，如果不成立，则虚拟机会看HandlePromotionFailure设置是否允许担保失败。如果允许&lt;/p&gt;
&lt;p&gt;　　那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年带对象的平均大小，如果大于，则尝试进行一次MinorGC,尽管这次Minor GC是有风险的，如果小于，或者HandlePromotionFailure设置不允许冒险，这是也要进行一次Full GC&lt;/p&gt;
&lt;p&gt;　　取平均值进行比较其实仍然是一种动态概率的手段，如果某次Minor GC存活的对象突增，远高于平均值的话，依然会出现担保失败(Handle Promotion Failure)，如果出现了担保失败,那就只好重新发起一次Full GC.虽然担保失败时绕圈子是最大的。&lt;/p&gt;
&lt;p&gt;　　但大部分情况下都还是会将HandlePromotionFailure开关打开。避免Full GC过于频繁。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package hjc.test9;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/4/2.
 *
 * -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:HandlePromotionFailure
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestGC2 {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; _1MB = &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

    @SuppressWarnings(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unused&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testTenuringThreshold(){
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] allcation1, allcation2, allcation3, allcation4, allcation5, allcation6, allcation7;
        allcation1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation1 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        allcation4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation5 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation6 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; _1MB];
        allcation4 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        allcation5 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        allcation6 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        allcation7 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; _1MB];

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        TestGC2.testTenuringThreshold();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201804/1202638-20180402230411939-635564366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201804/1202638-20180402230420264-709199585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 02 Apr 2018 15:07:00 +0000</pubDate>
<dc:creator>蜗居在小黑屋操控世界</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/8698599.html</dc:identifier>
</item>
<item>
<title>[Android]上传到多个Maven仓库的Gradle插件RapidMavenPushPlugin - 天天_byconan</title>
<link>http://www.cnblogs.com/tiantianbyconan/p/8698509.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiantianbyconan/p/8698509.html</guid>
<description>&lt;p&gt;博客搬迁至&lt;a href=&quot;https://blog.wangjiegulu.com&quot; class=&quot;uri&quot;&gt;https://blog.wangjiegulu.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RSS订阅：&lt;a href=&quot;https://blog.wangjiegulu.com/feed.xml&quot; class=&quot;uri&quot;&gt;https://blog.wangjiegulu.com/feed.xml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用于上传你的 library 库到多个 Maven 仓库的 Gradle 插件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Github: &lt;a href=&quot;https://github.com/wangjiegulu/RapidMavenPushPlugin&quot; class=&quot;uri&quot;&gt;https://github.com/wangjiegulu/RapidMavenPushPlugin&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;怎么使用&quot;&gt;1. 怎么使用&lt;/h2&gt;
&lt;h3 id=&quot;添加依赖&quot;&gt;1.1 添加依赖&lt;/h3&gt;
&lt;p&gt;在你项目根目录的 &lt;code&gt;build.gradle&lt;/code&gt; 文件中增加 &lt;code&gt;RapidMavenPushPlugin&lt;/code&gt; 依赖：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://search.maven.org/#search%7Cga%7C1%7Crapidmavenpush&quot;&gt;检查最新版本&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;buildscript {

    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.0.1'
        classpath('com.github.wangjiegulu:rapidmavenpush:x.x.x') {
            exclude group: 'com.android.tools.build', module: 'gradle'
        }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建-properties-files&quot;&gt;1.2 创建 properties files&lt;/h3&gt;
&lt;p&gt;现在你有3个 Maven 仓库（&lt;code&gt;maven type&lt;/code&gt;s），所以需要创建3个 maven properties archive 文件和1个通用的 archive properties 文件（properties 文件的名字和位置可以是任意的）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;maven_local.properties&lt;/strong&gt;: 上传 archives 到本地的 maven 仓库, 默认在你电脑的 &lt;code&gt;~/.m2/repository&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maven_company.properties&lt;/strong&gt;: 上传 archives 到你公司的 maven 仓库，他部署在你公司的服务器上面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;maven_central.properties&lt;/strong&gt;: 上传 archives 到 maven 中央库。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;common.properties&lt;/strong&gt;: 上面3个 maven 仓库的通用 properties。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: 当 &lt;code&gt;project.afterEvaluate&lt;/code&gt; 时, 所有 properties 都会被自动注入到 &lt;code&gt;project.ext&lt;/code&gt;中，所以在那之后你可以以诸如 &lt;code&gt;$POM_ARCHIVE_ID&lt;/code&gt; 的方式来使用它们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;maven_common.properties&quot;&gt;1.2.1 maven_common.properties&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# project info
POM_ARCHIVE_GROUP=com.github.wangjiegulu
#POM_ARCHIVE_VERSION_NAME=0.0.1-SNAPSHOT (command typed)
# aar or jar
POM_PACKAGING=aar
POM_DESC=test-mavenpush-plugin
POM_URL=https://github.com/wangjiegulu
POM_SCM_URL=scm:git@github.com:wangjiegulu
POM_SCM_CONNECTION=scm:git@github.com:wangjiegulu
POM_SCM_DEV_CONNECTION=git@github.com:wangjiegulu
POM_LICENCE_NAME=The Apache Software License, Version 2.0
POM_LICENCE_URL=http://www.apache.org/licenses/LICENSE-2.0.txt
POM_LICENCE_DIST=wangjie
POM_DEVELOPER_ID=wangjie
POM_DEVELOPER_NAME=Wang Jie
POM_DEVELOPER_EMAIL=tiantian.china.2@gmail.com&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;maven_local.properties&quot;&gt;1.2.2 maven_local.properties&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;# maven repository
POM_REPOSITORY_URL=/Users/wangjie/.m2/repository
POM_REPOSITORY_URL_SNAPSHOT=/Users/wangjie/.m2/repository
POM_SIGN=false

# project info
POM_ARCHIVE_ID=mavenpush-plugin-depmodule-local
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;maven_central.properties&quot;&gt;1.2.3 maven_central.properties&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;POM_OSSRH_USERNAME=username
POM_OSSRH_PASSWORD=password

# maven repository
POM_REPOSITORY_URL=https://oss.sonatype.org/service/local/staging/deploy/maven2/
POM_REPOSITORY_URL_SNAPSHOT=https://oss.sonatype.org/content/repositories/snapshots/

POM_SIGN=true
# Already configure in ~/.gradle/gradle.properties
#signing.keyId=
#signing.password=
#signing.secretKeyRingFile=

# project info
POM_ARCHIVE_ID=mavenpush-plugin-depmodule&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;应用-plugin-properties&quot;&gt;1.3 应用 Plugin &amp;amp; properties&lt;/h3&gt;
&lt;p&gt;在你 library 的 &lt;code&gt;build.gradle&lt;/code&gt; 文件中, 你需要以如下方式来 apply RapidMavenPushPlugin 插件：&lt;/p&gt;
&lt;pre class=&quot;gradle&quot;&gt;
&lt;code&gt;apply plugin: 'com.github.wangjiegulu.plg.rapidmavenpush'

rapidMavenPush {
    // 如果是 true，会在编译时期打印被注入的 properties
    printProperties = true
    // 如果是 true，在注入 properties 发生错误时会终止编译
    abortOnError = false
    // 是否禁用 Rapid Maven Push Plugin
    disable = false
    // 如果 `POM_MAVEN_TYPE` 没有被设置，则使用默认的 maven type。
    defaultMavenType = 'local'
    mavens {
        maven {
            mavenType = 'local'
            propertyFiles = [
                    file(&quot;mavenupload/maven_common.properties&quot;),
                    file(&quot;mavenupload/maven_local.properties&quot;)
            ]
            // Property Inject Mode: If the properties is already set, replace it or skip
            // property 注入模式：如果 properties 已经被设置过，则替换还是跳过
            propertyInjectMode = 'replace'
        }
        maven {
            mavenType = 'company'
            propertyFiles = [
                    file(&quot;mavenupload/maven_common.properties&quot;),
                    file(&quot;mavenupload/maven_company.properties&quot;)
            ]
            propertyInjectMode = 'replace'
        }
        maven {
            mavenType = 'central'
            propertyFiles = [
                    file(&quot;mavenupload/maven_common.properties&quot;),
                    file(&quot;mavenupload/maven_central.properties&quot;)
            ]
            propertyInjectMode = 'replace'
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;上传-archives&quot;&gt;1.4 上传 Archives&lt;/h3&gt;
&lt;p&gt;在编译之后，rapid maven push plugin 自动创建了一个名为 &lt;code&gt;rapidUploadArchives&lt;/code&gt; 的 task。&lt;/p&gt;
&lt;p&gt;执行这个 task !&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上传 archives 到本地仓库:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./gradlew clean :depmodule:rapidUploadArchives -PPOM_MAVEN_TYPE=local&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;上传 archives to 到中央库:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./gradlew clean :depmodule:rapidUploadArchives -PPOM_MAVEN_TYPE=central&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: 如果你没有在 &lt;code&gt;build.gradle&lt;/code&gt; 使用 &lt;code&gt;ext.POM_MAVEN_TYPE=xxx&lt;/code&gt; 的方式进行设置的话，&lt;code&gt;POM_MAVEN_TYPE&lt;/code&gt; 参数是必要的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;支持的-parameters-properties&quot;&gt;1.5 支持的 parameters &amp;amp; properties&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// maven type, 只能通过在 `build.gradle` 设置 `ext.POM_MAVEN_TYPE=xxx` 或者在命令行中设置 `-PPOM_MAVEN_TYPE=xxx` 或者在 `gradle.properties` 中设置 `PPOM_MAVEN_TYPE=xxx`
POM_MAVEN_TYPE

// maven repository parameters
POM_REPOSITORY_URL
POM_REPOSITORY_URL_SNAPSHOT
POM_OSSRH_USERNAME
POM_OSSRH_PASSWORD

// sign parameters
POM_SIGN
signing.keyId
signing.password
signing.secretKeyRingFile

// archive parameters
POM_ARCHIVE_GROUP
POM_ARCHIVE_ID
POM_ARCHIVE_VERSION_NAME
POM_PACKAGING
POM_DESC
POM_URL
POM_SCM_URL
POM_SCM_CONNECTION
POM_SCM_DEV_CONNECTION
POM_LICENCE_NAME
POM_LICENCE_URL
POM_LICENCE_DIST
POM_DEVELOPER_ID
POM_DEVELOPER_NAME
POM_DEVELOPER_EMAIL&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;Copyright 2018 Wang Jie

Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 02 Apr 2018 14:55:00 +0000</pubDate>
<dc:creator>天天_byconan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiantianbyconan/p/8698509.html</dc:identifier>
</item>
<item>
<title>构建微服务开发环境3————Java应用的优秀管理工具Maven的下载安装及配置 - 云开发</title>
<link>http://www.cnblogs.com/cloud-dev/p/gou-jian-wei-fu-wu-kai-fa-huan-jing3Java-ying-yong.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloud-dev/p/gou-jian-wei-fu-wu-kai-fa-huan-jing3Java-ying-yong.html</guid>
<description>&lt;p&gt;【内容指引】&lt;br/&gt;下载安装包；&lt;br/&gt;MacOS下Maven的安装及配置；&lt;br/&gt;Windows下Maven的安装及配置。&lt;/p&gt;
&lt;h2 id=&quot;toc_0&quot;&gt;一、下载安装包&lt;/h2&gt;
&lt;p&gt;进入Maven的官方下载地址：&lt;a href=&quot;http://maven.apache.org/download.cgi&quot;&gt;http://maven.apache.org/download.cgi&lt;/a&gt;&lt;br/&gt;当前Maven最新版本为3.5.3，在下图所示的&quot;Binary zip archive&quot;旁点击下载“apache-maven-3.5.3-bin.zip”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402225013490-1055168376.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;二、MacOS下Maven的安装及配置&lt;/h2&gt;
&lt;p&gt;1.将压缩包解压后剪切到Mac的某个目录下就完成了Maven的安装(本例存放在资源库的java文件夹下，JDK也是安装在这里)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402225008978-644246363.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;2.在终端中打开.bash_profile文件，进行Maven的环境变量配置：&lt;br/&gt;指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
open -e .bash_profile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在.bash_profile窗口中加入如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
MAVEN_HOME=/Library/Java/apache-maven-3.5.3&lt;span&gt;
$MAVEN_HOME&lt;/span&gt;/&lt;span&gt;bin:
export MAVEN_HOME&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402225008689-383513734.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;3.保存上述配置，然后使用&quot;source .bash_profile&quot;使配置生效，然后输入&quot;mvn -v&quot;,看到了3.5.3的版本号则说明Maven已配置成功:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402225010128-680256099.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;三、Windows下Maven的安装及配置&lt;/h2&gt;
&lt;p&gt;1.可以将下载的Maven压缩包解压后放入Java目录下，和之前安装的JDK放在一块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402231904919-1425542743.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;2.在“高级系统设置”中点击“环境变量”，点击“新建”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402231905423-1417928806.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;3.在新建系统变量中设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MAVEN_HOME
C:\Program Files\Java\apache&lt;/span&gt;-maven-3.5.3
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402231905627-1883644260.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;4.编辑系统变量Path，加入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
%MAVEN_HOME%\bin;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402231904728-1295104180.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;5.Dos命令行状态输入：&lt;/p&gt;

&lt;p&gt;看到版本号为3.5.3就代表Maven安装、配置成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1340917/201804/1340917-20180402231905753-797288592.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
</description>
<pubDate>Mon, 02 Apr 2018 14:50:00 +0000</pubDate>
<dc:creator>云开发</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloud-dev/p/gou-jian-wei-fu-wu-kai-fa-huan-jing3Java-ying-yong.html</dc:identifier>
</item>
<item>
<title>漫谈进程和线程 - 木可大大</title>
<link>http://www.cnblogs.com/neal-ke/p/8698464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neal-ke/p/8698464.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;为了帮助大家理解什么是进程，以厨师做蛋糕为例。厨师做蛋糕，首先需要厨师（CPU），其次，需要食谱（程序）和原料(输入数据)，而用原料做蛋糕的一些列动作的总和就是进程。某天厨师正在后厨做着蛋糕，突来听到儿子哭着跑进后厨，说自己被蜜蜂蛰了 ，厨师放下手中工具，并记录下当前做到哪一步了（保存上下文信息） ，然后拿出急救手册，按其中的说明为儿子进行处理（开始另外一个进程）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;进程概览&lt;/h2&gt;
&lt;p&gt;我们知道文件是对I/O设备的抽象，虚拟存储器是对文件和主存的抽象，指令集是对CPU的抽象，进程是对指令集和虚拟存储器的抽象。如下图所示 。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-73c4c5738fac5648.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/10175366-73c4c5738fac5648.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;br/&gt;&lt;/div&gt;

&lt;h2&gt;进程在内存的逻辑布局&lt;/h2&gt;
&lt;p&gt;从上可知，进程包括指令集和虚拟存储器。我们着重介绍进程在虚拟存储器中的逻辑布局，它包括用户栈、堆、程序数据和程序代码，其中，用户栈从上往下生长，堆从下往上生长，程序数据和程序代码从可执行文件加载而来，将程序代码改写成汇编指令就是类似于&lt;code&gt;movl、imul、addl等指令&lt;/code&gt;。如下图所示&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-61459e80a4543092.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/10175366-61459e80a4543092.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;br/&gt;&lt;/div&gt;

&lt;p&gt;此时，CPU运行到地址为304的指令， 假设CPU时间片刚好用完，就需要进行进程切换，在进行进程切换之前，需要保护现场，即保存寄存器信息、PC、打开的文件， 代码段地址、数据地址、堆栈信息等，这些信息称为进程的上下文。当操作系统切换到进程时，首先将进程2的上下文信息加载到操作系统中，找到PC，然后接着执行就可以了。&lt;/p&gt;
&lt;h2&gt;进程控制块（PCB）&lt;/h2&gt;
&lt;p&gt;进程的上下文信息是以某个数据结构保存在内存中的，而这种数据结构就是PCB。在Linux操作系统中PCB对应的数据结构就是task_struct，它保存着进程的重要信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct &lt;span class=&quot;hljs-title&quot;&gt;task_struct{
  &lt;span class=&quot;hljs-keyword&quot;&gt;pid_t pid:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;进程的状态&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;进程的状态包括新建态、就绪态、等待态、运行态、退出态&lt;/li&gt;
&lt;li&gt;流程：首先进程被新建，然后进入到就绪状态，此时，进程并没有进入到运行状态，而是等待CPU调度，如果被CPU调度则进入到运行态，而当时间片用完时，进程从运行态返回到就绪态，而当等待I/O操作时，则由运行态进入阻塞态。需要注意的是：只有运行态的进程拥有CPU，而处于就绪态和等待态的进程只是处于内存，等待CPU调度，因此CPU调度是一个很关键的流程。&lt;br/&gt;&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-ab69a120d0b90378.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/10175366-ab69a120d0b90378.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;CPU调度&lt;/h2&gt;
&lt;p&gt;像上文描述的那样，CPU调度就是到底哪个进程占有CPU，它可以分为非抢占式和抢占式。非抢占式是指调度程序一旦把CPU分配给某一进程后便让它一直运行下去，直到进程完成或发生某件事件而不能运行时，才将CPU分配给其他进程。它适合批处理系统，简单、系统开销小。抢占式是指当一个进程正在执行时，系统可以基于某种策略剥夺CPU给其他进程。剥夺的原则有优先权原则、端进程优先原则、时间片原则，它适用于交互式系统。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;评价标准&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;公平：合理的分配CPU&lt;/li&gt;
&lt;li&gt;响应时间：从用户输入到产生反映的时间&lt;/li&gt;
&lt;li&gt;吞吐量：单位时间完成的任务数量&lt;/li&gt;
&lt;li&gt;但是这些目标是矛盾的，例如：我们希望前端进程能够快速得到响应，这样一来后端进程就不能得到快速响应。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;批处理系统中的调度&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;先来先服务（公平、FIFO队列、非抢占式）&lt;/li&gt;
&lt;li&gt;最短作业优先（系统的平均等待时间最短，但是需要预先知道每个任务的运行时间）&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;交互式调度策略&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;轮转，每个进程分配一个固定的时间片，但是定义时间片长度是个问题，假设进程切换一次的开销为1ms，如果时间片太短，那么很多时间都浪费在切换上，例如时间片为4ms，那么20%的时间浪费在切换上；如果时间片太长，浪费时间就减少了，但是最后一个经常等待的时间就非常久，譬如，时间片100ms，浪费的时间1%，假设有50个进程，最后一个需要等待5s。&lt;/li&gt;
&lt;li&gt;静态优先级，给每个进程赋予优先级，优先级高的先执行，优先级低的后执行，但是该方法存在一定问题：低优先级的进程存在被饿死的情况，例如新来的进程的优先级都比原来的高，怎么办呢？我们根据等待时间的增加而调整优先级大小---多级反馈队列&lt;/li&gt;
&lt;li&gt;动态优先级---多级反馈队列，即进程的优先级会随着等待时间的增长而增长。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;进程间同步&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们知道，打印机有一个缓存，叫做打印队列，如下图所示，打印队列有5个空格，就是说这个打印队列最多可以容纳5个待打印文件，打印机进程就是消费者，而其他待打印进程是生产者，生产者不断地向队列中放数据，例如：A.java、B.doc等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;临界区：多个进程需要互斥的访问共享资源，共享资源可以是变量、表和文件等，例如打印队列就是共享资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当生产者将队列放满时，需要等待消费者；如果消费者把所有文件都打印完了，则需要等待生产者，这就是进程间的同步问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-ea2c2d9e5346f053.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/10175366-ea2c2d9e5346f053.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;进程间同步的本质&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;进程调度是不可控的&lt;/li&gt;
&lt;li&gt;在机器层面，count++，count--并不是原子操作，即一条代码，对应汇编层面多条指令。两者缺一不可，如果进程调度是可控的，那么，即使count++对应多条指令，当执行完第一条指令时，发生CPU切换，进程调度控制接下来的进程还是原来的进程控制CPU。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;解决方案&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;关闭中断&lt;br/&gt;缺点：把中断操作（CPU收到时钟中断以后，会检查当前进程的时间片是否用完，用完则切换）开放给应用程序，这是极其危险的事情，例如：当某个程序关闭中断之后，执行完毕之后，忘记打开中断，导致整个系统都终止了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用硬件指令来实现锁&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;TestAndSet&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;boolean *lock){
  &lt;span class=&quot;hljs-keyword&quot;&gt;boolean rv = *lock;
  *lock = TRUE;
  &lt;span class=&quot;hljs-keyword&quot;&gt;return rv;
}

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;注意：操作系统会锁住系统总线，防止其他CPU访问内存变量&lt;/li&gt;
&lt;li&gt;注意TestAndSet函数中的三条指令是原子执行的&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;信号量&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;信号量S是个整形变量，除了初始化外，有两个操作，wait()、signal()。&lt;/li&gt;
&lt;li&gt;为了确保信号量操作，需要用一种原子的方式实现它，操作系统来实现原子性。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;wait(S){
  &lt;span class=&quot;hljs-keyword&quot;&gt;while(S&amp;lt;=0){
  ...//啥也不做
  }
  S--;
}
signal(S){
  S++;
}

//
semaphore mutext = 1;
&lt;span class=&quot;hljs-built_in&quot;&gt;wait(mutex);
进入临界区
signal(mutex);
剩余区
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;不能忙等问题&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;用硬件指令实现锁的方案和信号量方案都有忙等问题，即某个进程获得了CPU时间片，但是啥事干不了，&lt;code&gt;while(S &amp;lt; = 0){...}&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新增进程队列，当发现value&amp;lt;0，将当前队列加入到阻塞队列中，同时，阻塞进程，而不像之前的方法那样无限等待下去&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct{
  &lt;span class=&quot;hljs-keyword&quot;&gt;int value;
  &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct &lt;span class=&quot;hljs-title&quot;&gt;process *&lt;span class=&quot;hljs-title&quot;&gt;list;
} semaphore;

wait(semaphore *s){
  s -&amp;gt; value--;
  &lt;span class=&quot;hljs-keyword&quot;&gt;if(s-&amp;gt;value&amp;lt;&lt;span class=&quot;hljs-number&quot;&gt;0){
  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;线程&lt;/h2&gt;
&lt;p&gt;由于进程之间是相互独立的，所以进程间数据共享只能通过内核实现，开销很麻烦，因此我们提出了线程这个概念。线程之间的数据是共享的；一个进程可以只有一个线程，也可以有多个线程（一个进程至少有一个线程）；当一个进程有多个线程时，每个线程都有一套独立的寄存器和堆栈信息，而代码、数据和文件是共享的，如下图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-128c7de2676f3350.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/10175366-128c7de2676f3350.png?imageMogr2/auto-orient/strip&quot;/&gt;&lt;br/&gt;&lt;/div&gt;

&lt;h2&gt;线程的实现&lt;/h2&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;完全在用户层实现（当用户要执行硬件设备，必须从用户空间到内核空间，这是一种保护措施，保护操作系统不被恶意程序所破坏），线程在应用层实现有一个优点就是线程切换不用内核介入，线程切换会非常的快。也就是说线程的调度策略是自己实现的。但是这里也有一个巨大的缺陷：由于内核只知道进程而不知道线程，那么进程1中的任何一个线程被阻塞，导致进程1中的其他线程也被阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;内核实现线程和用户空间一一对应，可以有效的解决方案一中的缺点，但是由于在内核中实现用户空间相同数量的线程数，开销比较大&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;用户空间中多个线程映射到内核中的一个线程，这样一来，内核中的线程就不用创建那么多， 而且阻塞的概率也降低了，这是一种平衡和折中的方式。JVM就是实现了这种方式 。JVM本身就是一个进程，JVM可以创建很多线程，然后对应内核中的线程，内核中的线程调度CPU。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;div class=&quot;image-package&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10175366-01c723579344a892?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; data-original-src=&quot;https://upload-images.jianshu.io/upload_images/10175366-01c723579344a892?imageMogr2/auto-orient/strip&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;p&gt;欢迎关注微信公众号：木可大大，所有文章都将同步在公众号上。&lt;/p&gt;
</description>
<pubDate>Mon, 02 Apr 2018 14:48:00 +0000</pubDate>
<dc:creator>木可大大</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/neal-ke/p/8698464.html</dc:identifier>
</item>
<item>
<title>C++高效安全的运行时动态类型转换 - Ldlchina</title>
<link>http://www.cnblogs.com/ldlchina/p/8698346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ldlchina/p/8698346.html</guid>
<description>&lt;p&gt;关键字：static_cast，dynamic_cast，fast_dynamic_cast，VS 2015。&lt;/p&gt;
&lt;p&gt;OS：Window 10。&lt;/p&gt;

&lt;h3&gt;C++类之间类型转换有：static_cast、dynamic_cast、reinterpret_cast、和const_cast。&lt;/h3&gt;
&lt;p&gt;static_cast - 编译时类型检查。如果没有继承关系的类之间转换编译不通过。优点是快，缺点是从父类转换到子类不安全的。&lt;/p&gt;
&lt;p&gt;dynamic_cast - 运行时类型检查。可以父子之间转换，也可以兄弟之间转换。优点是安全，缺点是运行时效率低。&lt;/p&gt;
&lt;p&gt;reinterpret_cast - 强制转换。最不安全。只有特定场合才能使用。&lt;/p&gt;
&lt;p&gt;const_cast - const类型和非const类型互转。&lt;/p&gt;
&lt;p&gt;一般从父类转换到子类，或兄弟类之间转换使用dynamic_cast是正确的选择。但是对于大型应用程序的底层开发，dynamic_cast的性能问题就暴露出来了，使用static_cast又不能保证安全，这时就需要自己实现一套高效安全的运行时动态类型转换。&lt;/p&gt;

&lt;h3&gt;基于虚函数+类型检查的类型转换&lt;/h3&gt;
&lt;p&gt;1. 为每个类实现classType和queryObject方法。运行时，通过虚函数queryObject调用以及在queryObject里面检查classType来找到合适的对象。具体实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; classType();
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; A::classType()
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* s_classType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s_classType;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* A::queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (classType ==&lt;span&gt; A::classType())
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; const_cast&amp;lt;A*&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; classType();
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; B::classType()
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* s_classType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s_classType;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* B::queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (classType ==&lt;span&gt; B::classType())
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; const_cast&amp;lt;B*&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; C : &lt;span&gt;public&lt;/span&gt; A, &lt;span&gt;public&lt;/span&gt;&lt;span&gt; B
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; classType();
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; C::classType()
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* s_classType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s_classType;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* C::queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (classType ==&lt;span&gt; C::classType())
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; const_cast&amp;lt;C*&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt;* res =&lt;span&gt; A::queryObject(classType))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt;* res =&lt;span&gt; B::queryObject(classType))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; D : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; A
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; classType();
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; D::classType()
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* s_classType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s_classType;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* D::queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (classType ==&lt;span&gt; D::classType())
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; const_cast&amp;lt;D*&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; A::queryObject(classType);
    }

    template &lt;/span&gt;&amp;lt;typename To, typename From&amp;gt;&lt;span&gt;
    To&lt;/span&gt;* fast_dynamic_cast(&lt;span&gt;const&lt;/span&gt; From* &lt;span&gt;from&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;from&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; static_cast&amp;lt;To*&amp;gt;(&lt;span&gt;from&lt;/span&gt;-&amp;gt;&lt;span&gt;queryObject(To::classType()));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2. new对象C，用指针A指向C对象。C继承于A和B。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    A* a = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; C();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A* a = new C();&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3. 测试类型转换从A到C，计时和检验转换结果。从测试结果看，dyanmic_cast、static_cast、fast_dynamic_cast结果都正确，static_cast效率最高，fast_dynamic_cast其次，dyanmic_cast效率最差。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===== cast from pointer A to pointer C, should be not null =====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    
    C&lt;/span&gt;* c =&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        c &lt;/span&gt;= dynamic_cast&amp;lt;C*&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dynamic_cast from A to C: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    c &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        c &lt;/span&gt;= static_cast&amp;lt;C*&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static_cast from A to C: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    c &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        c &lt;/span&gt;= fast_dynamic_cast&amp;lt;C&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fast_dynamic_cast from A to C: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
===== cast &lt;span&gt;from&lt;/span&gt; pointer A to pointer C, should be not &lt;span&gt;null&lt;/span&gt; =====&lt;span&gt;
dynamic_cast &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; A to C: 00000202D48C9FE0, Time: &lt;span&gt;2227&lt;/span&gt;&lt;span&gt;
static_cast &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; A to C: 00000202D48C9FE0, Time: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
fast_dynamic_cast &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; A to C: 00000202D48C9FE0, Time: &lt;span&gt;199&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4.  测试类型转换从A到B，计时和检验转换结果。从测试结果看，static_cast编译不通过，dyanmic_cast、fast_dynamic_cast结果都正确，fast_dynamic_cast效率比dyanmic_cast高。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n===== cast from pointer A to pointer B, should be not null =====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    B&lt;/span&gt;* b =&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        b &lt;/span&gt;= dynamic_cast&amp;lt;B*&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dynamic_cast from A to B: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    b &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;b = static_cast&amp;lt;B*&amp;gt;(a); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;compiler error&lt;/span&gt;
&lt;span&gt;    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static_cast from A to B: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;compiler error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    b &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        b &lt;/span&gt;= fast_dynamic_cast&amp;lt;B&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fast_dynamic_cast from A to B: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
===== cast &lt;span&gt;from&lt;/span&gt; pointer A to pointer B, should be not &lt;span&gt;null&lt;/span&gt; =====&lt;span&gt;
dynamic_cast &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; A to B: 000001D65F2FA308, Time: &lt;span&gt;2927&lt;/span&gt;&lt;span&gt;
static_cast &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; A to B: compiler error
fast_dynamic_cast &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; A to B: 000001D65F2FA308, Time: &lt;span&gt;208&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5. 测试类型转换从A到D，计时和检验转换结果。从测试结果看，static_cast结果不正确，应为空指针，dyanmic_cast、fast_dynamic_cast结果都正确，fast_dynamic_cast效率比dyanmic_cast高。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n===== cast from pointer A to pointer D, should be null =====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    D&lt;/span&gt;* d =&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        d &lt;/span&gt;= dynamic_cast&amp;lt;D*&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dynamic_cast from A to D: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    d &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        d &lt;/span&gt;= static_cast&amp;lt;D*&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static_cast from A to D: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    d &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        d &lt;/span&gt;= fast_dynamic_cast&amp;lt;D&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fast_dynamic_cast from A to D: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
===== cast &lt;span&gt;from&lt;/span&gt; pointer A to pointer D, should be &lt;span&gt;null&lt;/span&gt; =====&lt;span&gt;
dynamic_cast &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; A to D: &lt;span&gt;0000000000000000&lt;/span&gt;, Time: &lt;span&gt;3534&lt;/span&gt;&lt;span&gt;
static_cast &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; A to D: 0000026050C6D310, Time: &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
fast_dynamic_cast &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; A to D: &lt;span&gt;0000000000000000&lt;/span&gt;, Time: &lt;span&gt;227&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总结：根据以上测试结果，fast_dynamic_cast和dynamic_cast行为完全一致，并且效率上fast_dynamic_cast比dynamic_cast快10倍以上，在追求性能的底层开发完全可以用fast_dynamic_cast代替dynamic_cast。&lt;/p&gt;

&lt;p&gt;附完整代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_533523c9-e94e-4eee-bf7a-5783f2e9ef5e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_533523c9-e94e-4eee-bf7a-5783f2e9ef5e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_533523c9-e94e-4eee-bf7a-5783f2e9ef5e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
#include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;time.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unordered_map&amp;gt;

&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; classType();
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; A::classType()
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* s_classType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s_classType;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* A::queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (classType ==&lt;span&gt; A::classType())
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; const_cast&amp;lt;A*&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; classType();
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; B::classType()
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* s_classType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s_classType;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* B::queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (classType ==&lt;span&gt; B::classType())
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; const_cast&amp;lt;B*&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; C : &lt;span&gt;public&lt;/span&gt; A, &lt;span&gt;public&lt;/span&gt;&lt;span&gt; B
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; classType();
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; C::classType()
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* s_classType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s_classType;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* C::queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (classType ==&lt;span&gt; C::classType())
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; const_cast&amp;lt;C*&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt;* res =&lt;span&gt; A::queryObject(classType))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;void&lt;/span&gt;* res =&lt;span&gt; B::queryObject(classType))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; D : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; A
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; classType();
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; D::classType()
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* s_classType = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s_classType;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;* D::queryObject(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;* classType) &lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (classType ==&lt;span&gt; D::classType())
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; const_cast&amp;lt;D*&amp;gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; A::queryObject(classType);
    }

    template &lt;/span&gt;&amp;lt;typename To, typename From&amp;gt;&lt;span&gt;
    To&lt;/span&gt;* fast_dynamic_cast(&lt;span&gt;const&lt;/span&gt; From* &lt;span&gt;from&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;from&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nullptr;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; static_cast&amp;lt;To*&amp;gt;(&lt;span&gt;from&lt;/span&gt;-&amp;gt;&lt;span&gt;queryObject(To::classType()));
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; _tmain(&lt;span&gt;int&lt;/span&gt; argc, _TCHAR*&lt;span&gt; argv[])
{
    A&lt;/span&gt;* a = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; C();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A* a = new C();&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    clock_t start, stop;
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;100000000&lt;/span&gt;&lt;span&gt;;

    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;===== cast from pointer A to pointer C, should be not null =====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
    
    C&lt;/span&gt;* c =&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        c &lt;/span&gt;= dynamic_cast&amp;lt;C*&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dynamic_cast from A to C: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    c &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        c &lt;/span&gt;= static_cast&amp;lt;C*&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static_cast from A to C: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    c &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        c &lt;/span&gt;= fast_dynamic_cast&amp;lt;C&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fast_dynamic_cast from A to C: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; c &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n===== cast from pointer A to pointer B, should be not null =====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    B&lt;/span&gt;* b =&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        b &lt;/span&gt;= dynamic_cast&amp;lt;B*&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dynamic_cast from A to B: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    b &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;b = static_cast&amp;lt;B*&amp;gt;(a); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;compiler error&lt;/span&gt;
&lt;span&gt;    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static_cast from A to B: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;compiler error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    b &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        b &lt;/span&gt;= fast_dynamic_cast&amp;lt;B&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fast_dynamic_cast from A to B: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n===== cast from pointer A to pointer D, should be null =====&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;

    D&lt;/span&gt;* d =&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        d &lt;/span&gt;= dynamic_cast&amp;lt;D*&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dynamic_cast from A to D: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    d &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        d &lt;/span&gt;= static_cast&amp;lt;D*&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static_cast from A to D: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    d &lt;/span&gt;=&lt;span&gt; nullptr;
    start &lt;/span&gt;=&lt;span&gt; clock();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; count; i++&lt;span&gt;)
    {
        d &lt;/span&gt;= fast_dynamic_cast&amp;lt;D&amp;gt;&lt;span&gt;(a);
    }
    stop &lt;/span&gt;=&lt;span&gt; clock();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fast_dynamic_cast from A to D: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; d &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Time: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; stop - start &amp;lt;&amp;lt;&lt;span&gt; endl;

    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; a;
    a &lt;/span&gt;=&lt;span&gt; nullptr;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;完整代码&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 02 Apr 2018 14:32:00 +0000</pubDate>
<dc:creator>Ldlchina</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ldlchina/p/8698346.html</dc:identifier>
</item>
<item>
<title>自己写编程语言-m语言 - McKay</title>
<link>http://www.cnblogs.com/aarond/p/m_language.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aarond/p/m_language.html</guid>
<description>&lt;p&gt;一直对技术有很强的兴趣，终于，决定要写自己的语言（m语言）。那就先从最简单的开始：解释执行器。&lt;/p&gt;
&lt;p&gt;一套完整的语言包含的肯定不止解释执行器了，还要有编译器和IDE，也就还要有语法高亮、智能提示等，不过还没学会那些，先搞个最基本的解释执行器。&lt;/p&gt;
&lt;p&gt;思路如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定义好希望的语法（基本语句有：顺序执行、if语句、for语句、while语句、系统自有函数定义、用户函数定义、函数调用）&lt;/li&gt;
&lt;li&gt;找一款词法语法解析器工具，让字符串流变成语法书（AST）&lt;/li&gt;
&lt;li&gt;编写解释执行器
&lt;ol&gt;&lt;li&gt;元数据收集&lt;/li&gt;
&lt;li&gt;变量作用域定义、查找&lt;/li&gt;
&lt;li&gt;解释执行&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先设想我们的m语言语法要怎么牛b啊，比如下面这段demo语法代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;go 计算标准体重(年龄)
{
    体重:年龄&lt;/span&gt;*&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
    体重;
}

体重:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
a:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
a:输出(体重);
b:&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;;
a:&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;+&lt;span&gt;10&lt;/span&gt;+&lt;span&gt;b;
输出(a);
(a&lt;/span&gt;==&lt;span&gt;135&lt;/span&gt;)-&amp;gt;&lt;span&gt;
{
    a:a&lt;/span&gt;+a+&lt;span&gt;a;
    输出(a);
}
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
{
    输出(b);
};
a:&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; a&amp;lt;&lt;span&gt;10&lt;/span&gt; -&amp;gt;&lt;span&gt;{
    a:a&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    输出(a);
};

输出(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WHILE OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);



repeat i &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; to &lt;span&gt;100&lt;/span&gt; step &lt;span&gt;10&lt;/span&gt;-&amp;gt;&lt;span&gt;{
    输出(i);
}
init&lt;/span&gt;-&amp;gt;&lt;span&gt;{
    输出(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FOR INIT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}
onerror&lt;/span&gt;-&amp;gt;&lt;span&gt;{
    输出(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FOR ERROR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;-&amp;gt;&lt;span&gt;{
    输出(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FOR FINALLY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
};
输出(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;FOR OK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

a:&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
输出(计算标准体重(a));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 很显然，第一个语句块是用户函数的定义方式，以&quot;go&quot;字符串为函数定义的开始，接着是常规的函数名称、参数、函数方法块。&lt;/p&gt;
&lt;p&gt;剩下的大致上就是顺序执行了，其中穿插着一些循环语句等，repeat循环自定义的比较厉害，好叼。。。感觉。。真的好叼。。。。&lt;/p&gt;
&lt;p&gt;每个语句以封号后缀结束、赋值以冒号来标识。&lt;/p&gt;
&lt;p&gt;接着来看看基于ANTLR的词法定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/68230/201804/68230-20180402214001047-312025758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;m.g4：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
grammar m;

import basic,function,assignStmt,ifStmt,forStmt,whileStmt;

nomalStmt
    :assignStmt
    |ifStmt
    |forStmt
    |whileStmt
    ;
declarationStmt
    :functionDeclare
    ;
stmt
    :nomalStmt LS
    |declarationStmt
    ;

&lt;span&gt;program&lt;/span&gt;
    : stmt+
    ;　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 由于词法语法定义较多，不贴代码了，可以下载代码看全部的（基于ideas/需要安装antlr4插件）&lt;/p&gt;
&lt;p&gt;接下来是时候让我们load进demo代码解析成AST树啦：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
String code=Utils.readTxtFile(&lt;span&gt;&quot;F:\\BaiduYunDownload\\mLanguage(4)\\m_code2.m&quot;&lt;/span&gt;);//这个是放demo代码的文件
code=code.substring(1);//去掉第一个特殊字符


CharStream is = CharStreams.fromString(code);　　　　　　　　　　　　　　　　 //antlr对象，读入字符串
mLexer lexer = new mLexer(is);　　　　　　　　　　　　　　　　　　　　　　　　  //mLexer是antlr自动生成的一个词法类
CommonTokenStream tokens = new CommonTokenStream(lexer);　　　　　　　　   //antlr对象
mParser parser = new mParser(tokens);　　　　　　　　　　　　　　　　　　　　　//mParser是antlr自动生成的一个此法解析类

mParser.ProgramContext tree=parser.program();　　　　　　　　　　　　　　　　//&lt;span&gt;program&lt;/span&gt;是入口规则，根规则

program program= NodeParser.parseProgram(tree);　　　　　　　　　　　　　　 //&lt;span&gt;自己写的NodeParser类，需要一堆自定义的节点类型配合解析整棵AST树&lt;/span&gt;

mRuntime runtime=new mRuntime(program);

runtime.plainInterpreter();　　　　　　　　　　　　　　　　　　　　　　　　　　　//解释器执行

System.out.println(&quot;&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AST节点的定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/68230/201804/68230-20180402215319628-1435458079.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;demo代码构建成AST树的效果图（antlr插件中能看）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/68230/201804/68230-20180402215458653-316275394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 转换成为AST树后，剩下的就是编写解释执行器，其实相当于前端编译器。&lt;/p&gt;
&lt;p&gt;主要步骤是3步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;收集元数据&lt;/li&gt;
&lt;li&gt;定义变量作用域&lt;/li&gt;
&lt;li&gt;语句块的解释执行 &lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(program program) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1. 先扫描函数定义，收集元数据&lt;/span&gt;
&lt;span&gt;        collectMetaData(program);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 变量作用域&lt;/span&gt;
&lt;span&gt;        walkAST4Variables(program);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3. 解释执行代码&lt;/span&gt;
&lt;span&gt;        runCode(program);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 1. 收集元数据，其实就是对自定义函数的收集，统一放到一个Dictionary里，以便到时候引用到了执行语句块（和参数的传递）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; collectMetaData(program program) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(com.mckay.language.m.core.nodes.m.stmt stmt:program.stmts)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(stmt.declarationStmt!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.userDefinedFunctionSymbols.defineMethod(stmt.declarationStmt.&lt;span&gt;functionDeclare&lt;/span&gt;.functionIdentifier.getIdentifier(), stmt.declarationStmt.functionDeclare);
    }


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserDefinedFunctionSymbols {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Dictionary&amp;lt;String, &lt;span&gt;functionDeclare&lt;/span&gt;&amp;gt; methods=&lt;span&gt;new&lt;/span&gt; Hashtable&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&lt;span&gt; functionDeclare&lt;/span&gt; getMethod(String identifier) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methods.get(identifier);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; defineMethod(String identifier, &lt;span&gt;functionDeclare&lt;/span&gt; ast) {
        methods.put(identifier, ast);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; functionDeclare是具体的node，属于AST中众多节点类型中的一种，代表函数声明节点。&lt;/p&gt;
&lt;p&gt;2. 定义变量作用域，由于存在函数（自定义函数、系统自带函数），因此需要有变量Scope的概念，存在局部变量覆盖全局变量现象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
private void walkAST4Variables(program program)
    {
        program.&lt;span&gt;VariableSymbols&lt;/span&gt;=&lt;span&gt;globalVariableSymbol&lt;/span&gt;;
        for(com.mckay.language.m.core.nodes.m.stmt stmt:program.stmts)
        {
            stmt.&lt;span&gt;VariableSymbols&lt;/span&gt;=program.&lt;span&gt;VariableSymbols&lt;/span&gt;;
            if(stmt.declarationStmt!=null)
            {
                stmt.declarationStmt.&lt;span&gt;VariableSymbols&lt;/span&gt;=stmt.&lt;span&gt;VariableSymbols&lt;/span&gt;;
                VarWalker.walk(stmt.declarationStmt);
            }

            if(stmt.nomalStmt!=null)
            {
                stmt.nomalStmt.&lt;span&gt;VariableSymbols&lt;/span&gt;=stmt.&lt;span&gt;VariableSymbols&lt;/span&gt;;
                VarWalker.walk(stmt.nomalStmt);
            }
        }
    }




public class VariableSymbol {
    private Dictionary&amp;lt;String, Variable&amp;gt; variables=new Hashtable&amp;lt;&amp;gt;();
    private &lt;span&gt;VariableSymbol&lt;/span&gt; parentVariableSymbol;

    public void setParentVariableSymbol(VariableSymbol parentVariableSymbol)
    {
        this.parentVariableSymbol=parentVariableSymbol;
    }

    public void defineVariable(String name, Variable variable) {
        variables.put(name, variable);
    }

    public void setValue(String name, Object value)
    {
        Variable variable=getVariable(name);
        variable.Value=value;
    }
    public Object getValue(String name)
    {
        Variable variable=getVariable(name);
        return variable.Value;
    }

    private Variable &lt;span&gt;getVariable&lt;/span&gt;(String name) {
        List&amp;lt;String&amp;gt; keys=Collections.list(variables.keys());
        if(keys.contains(name))
            return this.variables.get(name);

        &lt;span&gt;if(this.parentVariableSymbol!=null)
            return this.parentVariableSymbol.getVariable(name);&lt;/span&gt;

        throw new RuntimeException(&quot;变量未定义&quot;);
    }
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当局部变量中没有找到本地变量定义时，会根据parent关联向上找变量，直到为null。&lt;/p&gt;
&lt;p&gt;3. 语句块的解释执行，这个可以说是最容易理解的地方了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
private void runCode(program program) {
        StmtExecutor executor=new StmtExecutor(this);

        for(com.mckay.language.m.core.nodes.m.stmt stmt:program.stmts)
            if(stmt.nomalStmt!=null)
                executor.execute(stmt.nomalStmt);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; StmtExecutor.execute(nomalStmt)会调用一系列子语句，如下图就一图就懂：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/68230/201804/68230-20180402220922690-934765160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图中，针对expression是调用calc的，一堆calc，expression中套expression。&lt;/p&gt;
&lt;p&gt;system built-in函数的定义，是通过NativeMethodNode.setCode来标识的，比如当前实现的code为OUTPUT，功能如下：System.out.print/Console.Write()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/68230/201804/68230-20180402221444701-569060494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个红框是native node中判断code是哪个system built-in函数的编码代号&lt;/p&gt;
&lt;p&gt;第二个红框是对应built-in函数的java语句执行。&lt;/p&gt;
&lt;p&gt;demo m代码对应的解释执行输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
10 
135 
405 
3 
5 
7 
9 
11 
WHILE OK 
FOR INIT 
0 
10 
20 
30 
40 
50 
60 
70 
80 
90 
100 
FOR FINALLY 
FOR OK 
30 
ok　　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://files.cnblogs.com/files/aarond/mLanguage%284%29.rar&quot; target=&quot;_blank&quot;&gt;代码下载&lt;/a&gt;(基于java)&lt;/p&gt;

</description>
<pubDate>Mon, 02 Apr 2018 14:22:00 +0000</pubDate>
<dc:creator>McKay</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aarond/p/m_language.html</dc:identifier>
</item>
<item>
<title>使用PostMan进行API自动化测试 - 贾顺名</title>
<link>http://www.cnblogs.com/jiasm/p/8698275.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiasm/p/8698275.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最近在进行一个老项目的升级，第一步是先将node版本从&lt;code&gt;4.x&lt;/code&gt;升级到&lt;code&gt;8.x&lt;/code&gt;，担心升级会出现问题，所以需要将服务的接口进行验证；&lt;br/&gt;如果手动输入各种URL，人肉check，一个两个还行，整个服务。。大几十个接口，未免太浪费时间了-.-；&lt;br/&gt;因为是一个纯接口服务的项目，所以打算针对对应的API进行一波自动化测试；&lt;br/&gt;所以就开始寻找对应的工具，突然发现，平时使用的&lt;code&gt;PostMan&lt;/code&gt;貌似也是支持写测试用例的-.-，所以就照着文档怼了一波；&lt;br/&gt;一下午的时间，很是激动，之前使用&lt;code&gt;PostMan&lt;/code&gt;仅限于修改&lt;code&gt;Header&lt;/code&gt;，添加&lt;code&gt;Body&lt;/code&gt;发送请求，从来没有考虑过拿&lt;code&gt;PostMan&lt;/code&gt;来进行测试，一下午的使用，感觉发现了新大陆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;PostMan的安装&quot;&gt;PostMan的安装&lt;/h2&gt;
&lt;p&gt;貌似下载和使用&lt;code&gt;PostMan&lt;/code&gt;必须要FQ-.-&lt;br/&gt;因为现在提供两种形态的App：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;chrome&lt;/code&gt;的插件 &lt;em&gt;（已经快要被废弃了，推荐使用独立App）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;独立的App&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而且在使用时需要登录账号，我这边是直接登录的&lt;code&gt;Google&lt;/code&gt;账号-。-貌似有其它方式，但是我并没有去尝试。&lt;/p&gt;
&lt;p&gt;独立App版云盘地址（&lt;code&gt;Mac&lt;/code&gt;版本，今天刚下载的6.0.10，需要的请自取）：&lt;br/&gt;链接:&lt;a href=&quot;https://pan.baidu.com/s/18CDp2MUQCLgk_USlmVc-Gw&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/18CDp2MUQCLgk_USlmVc-Gw&lt;/a&gt; 密码:&lt;code&gt;mrpf&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下载完毕解压后直接运行即可，然后就是注册账号之类的，目测账号这一块主要是用于后续的小组分享需要（可以直接将你的调用记录分享给其他人）。&lt;/p&gt;
&lt;h2 id=&quot;发送一个请求&quot;&gt;发送一个请求&lt;/h2&gt;
&lt;p&gt;这是&lt;code&gt;PostMan&lt;/code&gt;最基础的一个用法，用来发送一个请求。&lt;br/&gt;可以设置&lt;code&gt;Header&lt;/code&gt;，&lt;code&gt;Body&lt;/code&gt;等信息。&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-1.png&quot; alt=&quot;&quot; width=&quot;851&quot; height=&quot;509&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;Collections&quot;&gt;Collections&lt;/h2&gt;
&lt;p&gt;我们可以将每次发送的请求进行保存，方便下次请求该接口时，直接调用即可，&lt;br/&gt;如果保存请求的话，会被保存到一个&lt;code&gt;Collections&lt;/code&gt;里去，类似一个集合。&lt;br/&gt;&lt;code&gt;PostMan&lt;/code&gt;提供了方法，能够一键运行整个&lt;code&gt;Collections&lt;/code&gt;中所有的请求。&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-2.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;249&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-3.png&quot; alt=&quot;&quot; width=&quot;738&quot; height=&quot;555&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们就可以在需要的时候，直接运行集合中所有的请求了。&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-4.png&quot; alt=&quot;&quot; width=&quot;365&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存请求记录的时候，在下边选择对应的&lt;code&gt;Collection&lt;/code&gt;即可&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-5.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;1018&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始API测试&quot;&gt;开始API测试&lt;/h2&gt;
&lt;h3 id=&quot;测试脚本位置&quot;&gt;测试脚本位置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-6.png&quot; alt=&quot;&quot; width=&quot;871&quot; height=&quot;367&quot;/&gt;&lt;br/&gt;&lt;code&gt;PostMan&lt;/code&gt;针对请求编写的测试脚本，在这个位置，采用的是&lt;code&gt;JavaScript&lt;/code&gt;语法，右侧是一些预先配置的代码片段。&lt;br/&gt;以及我们可以在&lt;code&gt;Pre-request Script&lt;/code&gt;中编写脚本，用于在发送请求前执行。&lt;/p&gt;
&lt;h3 id=&quot;一些简单的语法&quot;&gt;一些简单的语法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;PostMan&lt;/code&gt;也提供了一种断言，来帮助做一些验证。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; tests['Status code is 200'] = responseCode.code === 200
&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; tests['Data length &amp;gt;= 10'] = JSON.parse(responseBody).data.length &amp;gt;= 10
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;赋值为&lt;code&gt;true&lt;/code&gt;即表示通过，&lt;code&gt;false&lt;/code&gt;为失败。&lt;br/&gt;&lt;code&gt;tests&lt;/code&gt;的直接赋值作用比较局限，如果在脚本中进行一些其他异步操作，则需要用到&lt;code&gt;pm.test&lt;/code&gt;了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; setTimeout(() =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   pm.test(&quot;test check&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     pm.expect(&lt;span&gt;false&lt;/span&gt;).to.be.&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  })
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; })
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;只用上边的&lt;code&gt;tests&lt;/code&gt;赋值+&lt;code&gt;pm.test/pm.expect&lt;/code&gt;已经能够满足我们的需求了，其余的一些只是在这之上的语法糖而已。&lt;br/&gt;&lt;a href=&quot;https://www.getpostman.com/docs/v6/postman/scripts/test_examples&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;各种语法示例&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;在测试脚本中发送请求&quot;&gt;在测试脚本中发送请求&lt;/h3&gt;
&lt;p&gt;我们可以在拿到一个&lt;code&gt;API&lt;/code&gt;返回结果后，根据该结果发送一些新的请求，然后添加断言。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; let responseJSON =&lt;span&gt; JSON.parse(responseBody)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取关注的第一个用户，并请求他的用户信息&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; pm.sendRequest(responseJSON[0].url, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (err, response) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   let responseJSON =&lt;span&gt; response.json()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;   pm.test('has email', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     pm.expect(responseJSON.email).is.be.&lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果用户email不存在，断言则会失败&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  })
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果我们有一些动态接口要进行测试，可以尝试这种写法。&lt;br/&gt;一级接口返回&lt;code&gt;List&lt;/code&gt;&lt;br/&gt;二级接口根据&lt;code&gt;List&lt;/code&gt;的&lt;code&gt;ID&lt;/code&gt;进行获取对应信息。&lt;/p&gt;
&lt;h3 id=&quot;如何处理大量重复的断言逻辑&quot;&gt;如何处理大量重复的断言逻辑&lt;/h3&gt;
&lt;p&gt;针对单个API，去编写对应的断言脚本，这个是没有什么问题的。&lt;br/&gt;但是如果是针对一个项目的所有&lt;code&gt;API&lt;/code&gt;去编写，类似于判断&lt;code&gt;statusCode&lt;/code&gt;这样的断言就会显得很溶于，所以&lt;code&gt;PostMan&lt;/code&gt;也考虑到了这点。&lt;br/&gt;在我们创建的&lt;code&gt;Collection&lt;/code&gt;以及下层的文件夹中，我们可以直接编写针对这个目录下的所有请求的断言脚本。&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-8.png&quot; alt=&quot;&quot; width=&quot;453&quot; height=&quot;665&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-7.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;614&quot;/&gt;&lt;br/&gt;这里的脚本会作用于目录下所有的请求。&lt;br/&gt;这样我们就可以将一些通用性的断言挪到这里了，在每个请求的&lt;code&gt;Tests&lt;/code&gt;下编写针对性的断言脚本。&lt;/p&gt;
&lt;h3 id=&quot;变量的使用&quot;&gt;变量的使用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;PostMan&lt;/code&gt;提供了两种变量使用，一个是&lt;code&gt;global&lt;/code&gt;，一个是&lt;code&gt;environment&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;global&quot;&gt;global&lt;/h4&gt;
&lt;p&gt;代码操作的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; pm.globals.set(&quot;variable_key&quot;, &quot;variable_value&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set variable&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; pm.globals.get(&quot;variable_key&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get variable&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; pm.globals.unset(&quot;variable_key&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove variable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通过GUI设置：&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-9.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;354&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-10.png&quot; alt=&quot;&quot; width=&quot;860&quot; height=&quot;568&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置完后我们就可以这样使用了：&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-11.png&quot; alt=&quot;&quot; width=&quot;904&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本上在所有的可输入的地方，我们都能够使用这些变量。&lt;/p&gt;
&lt;h4 id=&quot;environment&quot;&gt;environment&lt;/h4&gt;
&lt;p&gt;环境变量，这个是权重比&lt;code&gt;global&lt;/code&gt;要高一些的变量，是针对某些环境来进行设置的值。&lt;br/&gt;操作方式类似。&lt;/p&gt;
&lt;p&gt;在使用代码操作的方式时，只需将&lt;code&gt;globals&lt;/code&gt;替换为&lt;code&gt;environment&lt;/code&gt;即可。&lt;br/&gt;在发起一个请求，或者一键发送所有请求时，我们可以勾选对应的环境，来使用不同的变量。&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-12.png&quot; alt=&quot;&quot; width=&quot;458&quot; height=&quot;161&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在针对大量API测试时，拿&lt;code&gt;environment&lt;/code&gt;来设置一个&lt;code&gt;domain&lt;/code&gt;将是一个不错的选择。&lt;br/&gt;这样在请求中我们只需这样写即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; {{domain}}/res1
&lt;span&gt;2&lt;/span&gt; {{domain}}/res2
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; domain: https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;api.github.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;一个简单的示例：&quot;&gt;一个简单的示例：&lt;/h3&gt;
&lt;p&gt;通过直接运行一个&lt;code&gt;Collection&lt;/code&gt;，我们可以很直观的看到所有的接口验证情况。&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-13.png&quot; alt=&quot;&quot; width=&quot;1013&quot; height=&quot;562&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://blog.jiasm.org/images/postman-usage/postman-pic-14.png&quot; alt=&quot;&quot; width=&quot;1012&quot; height=&quot;562&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.getpostman.com/docs/v6/&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;https://www.getpostman.com/docs/v6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前使用&lt;code&gt;PostMan&lt;/code&gt;，最多就是模拟一下&lt;code&gt;POST&lt;/code&gt;请求，最近刚好碰到类似的需求，发现原来&lt;code&gt;PostMan&lt;/code&gt;还可以做的更多。&lt;br/&gt;这篇只是使用&lt;code&gt;PostMan&lt;/code&gt;进行API测试的最基础操作，还有一些功能目前我并没有用到，例如集成测试、生成&lt;code&gt;API&lt;/code&gt;文档之类的。&lt;/p&gt;
&lt;p&gt;接口相当于是获取和操作服务资源的方式，肯定属于产品的核心。&lt;br/&gt;所以测试是必须的，在交付QA同学之前，自己进行一遍测试，想必一定能节省一部分的时间。&lt;/p&gt;
</description>
<pubDate>Mon, 02 Apr 2018 14:18:00 +0000</pubDate>
<dc:creator>贾顺名</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiasm/p/8698275.html</dc:identifier>
</item>
<item>
<title>vue内置指令详解——小白速会 - 柴小智</title>
<link>http://www.cnblogs.com/chaixiaozhi/p/8698222.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaixiaozhi/p/8698222.html</guid>
<description>&lt;p&gt;&lt;strong&gt;指令 (Directives) 是带有 &lt;code&gt;v-&lt;/code&gt; 前缀的特殊属性，&lt;/strong&gt;&lt;strong&gt;职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内置指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、v-bind：响应并更新DOM特性；例如：v-bind:href  v-bind:class  v-bind:title  等等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要用法是绑定属性，动态更新HTML元素上的属性&lt;/strong&gt;；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;a v-bind:href=&quot;url&quot;&amp;gt;...&amp;lt;/a&amp;gt;
&amp;lt;!-- 缩写 --&amp;gt;
&amp;lt;a :href=&quot;url&quot;&amp;gt;...&amp;lt;/a&amp;gt;&lt;br/&gt;&amp;lt;div :title='title'&amp;gt;标题&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
   el: &lt;/span&gt;'#app'&lt;span&gt;,
   data: { 
       url: &lt;/span&gt;'www.baidu.com',&lt;br/&gt;　　　　title: 'bind'
    },
}）
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、v-on：用于监听DOM事件； 例如：v-on:click  v-on:keyup&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺带讲一下方法与事件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 @click 的表达式可以直接使用JavaScript 语句，也可以是一个在Vue 实例中methods 选项内的函数名，可以在方法中传递参数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
&amp;lt;!-- 完整语法 --&amp;gt;
&amp;lt;a v-on:click=&quot;doSomething&quot;&amp;gt;...&amp;lt;/a&amp;gt;
&amp;lt;!-- 缩写 --&amp;gt;
&amp;lt;a @click=&quot;doSomething()&quot;&amp;gt;...&amp;lt;/a&amp;gt;　　　　//是一个方法名&lt;p&gt;&amp;lt;p ng-if='show'&amp;gt;一段文本&amp;lt;/p&amp;gt;&lt;br/&gt;&amp;lt;button @click=&quot;show=false&quot;&amp;gt;点击隐藏文本&amp;lt;/button&amp;gt;　　//直接是一个内联的语句&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;button &lt;span class=&quot;attr&quot;&gt;v-on:click=&lt;span class=&quot;string&quot;&gt;&quot;count++&quot;&amp;gt;Add 1&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;button&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
   el: &lt;/span&gt;'#app'&lt;span&gt;,&lt;br/&gt;　　data:{&lt;br/&gt;　　　　show: true，&lt;br/&gt;　　　　counter： 0&lt;br/&gt;　　},
   methods: {
        doSomething: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.title);
        },
    }
}）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.2方法与事件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vue 提供了一个特殊变量$event ，用于访问原生DOM 事件，可以阻止事件冒泡或者阻止链接打开&lt;/p&gt;
&lt;p&gt;写一个阻止冒泡的例子：&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;stopClick1('stop1',$event)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;stopClick2('stop2',$event)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;@click&lt;/span&gt;&lt;span&gt;=&quot;stopClick3('stop3',$event)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;阻止冒泡&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　&amp;lt;/div&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;methods:{
        stopClick3: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(message, event){
            console.log(message);
            event.stopPropagation();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻止冒泡&lt;/span&gt;
&lt;span&gt;        },
        stopClick2: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(message, event){
            console.log(message);
        },
        stopClick1: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(message, event){
            console.log(message);
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.3修饰符：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在＠绑定的事件后加小圆点“．”，再跟一个后缀来使用修饰符。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的阻止冒泡事件，可以直接用户修饰符的方式写为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;@click.stop&lt;/span&gt;&lt;span&gt;=&quot;stopClick3('stop3')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;阻止冒泡&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;　　&lt;span&gt;//不用通过$event事件再来写了&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常用的一些修饰符有：&lt;/p&gt;
&lt;p&gt;• .stop&lt;br/&gt;• .prevent&lt;br/&gt;• .capture&lt;br/&gt;• .self&lt;br/&gt;• .once&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;＜ ！一阻止单击事件冒泡一〉
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;@click.stop&lt;/span&gt;&lt;span&gt;=”handle &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
〈！一修饰符可以串联一〉
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;@click.stop.prevent&lt;/span&gt;&lt;span&gt;=” &lt;/span&gt;&lt;span&gt;handle ” &lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
〈！一添加事件侦听器时使用事件捕获模式一〉
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;@click . capture&lt;/span&gt;&lt;span&gt;=”handle &lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; ... &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
〈！一只当事件在该元素本身（而不是子元素） 触发时触发回调一〉
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;@click.self&lt;/span&gt;&lt;span&gt;=” &lt;/span&gt;&lt;span&gt;handle ”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; ... &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
＜ ！一只触发一次，组件同样适用一〉
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;@click.once&lt;/span&gt;&lt;span&gt;=” &lt;/span&gt;&lt;span&gt;handle ”&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; ... &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span readability=&quot;4&quot;&gt;&amp;gt;&lt;p&gt;&lt;span&gt;在表单元素上监昕键盘事件时，还可以使用按键修饰符，比如按下具体某个键时才调用方法：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;＜ ！一只有在keyCode 是13 时调用vm.submit()一〉&lt;/span&gt;&lt;br/&gt;&amp;lt;input @keyup.13 ＝“ submit ”〉&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、v-model：数据双向绑定；用于表单输入等；例如：&amp;lt;&lt;span class=&quot;name&quot;&gt;input &lt;span class=&quot;attr&quot;&gt;v-model=&lt;span class=&quot;string&quot;&gt;&quot;message&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4、v-show：条件渲染指令，为DOM设置css的style属性&lt;/p&gt;
&lt;p&gt;5、v-if：条件渲染指令，动态在DOM内添加或删除DOM元素&lt;/p&gt;
&lt;p&gt;6、v-else：条件渲染指令，必须跟v-if成对使用&lt;/p&gt;
&lt;p&gt;7、v-else-if：判断多层条件，必须跟v-if成对使用；&lt;/p&gt;
&lt;p&gt;8、v-text：更新元素的textContent；例如：&amp;lt;span v-text=&quot;msg&quot;&amp;gt;&amp;lt;/span&amp;gt; 等同于 &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;span&amp;gt;{{msg}}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;span&amp;gt;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;9、v-html：更新元素的innerHTML；会把标签名也带上。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;10、v-for：循环指令；例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;= &quot;app &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;book in books&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{ { book.name } }&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app =&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;'#app'&lt;span&gt;,
    data: {
        books: [
            {name: &lt;/span&gt;'&amp;lt;vue.js实战&amp;gt;'&lt;span&gt;},
            {name: &lt;/span&gt;'&amp;lt;javascript语言精粹&amp;gt;'&lt;span&gt;},
            {name: &lt;/span&gt;'&amp;lt;javascript高级程序设计&amp;gt;'&lt;span&gt;}
        ]
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;10.1　v- for 的表达式遍历数组时支持一个可选参数作为当前项的索引， 例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(book , index) in books &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ index}} - {{book.name })&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 10.2　v- for 的表达式遍历对象属性时，有两个可选参数，分别是键名和索引：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;= &quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;(value , key , index) in user &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                { { index } } - { { key } } : { { value } }
            &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;'#app'&lt;span&gt;,
    data: {
        name: &lt;/span&gt;'Aresn'&lt;span&gt;,
        grender: &lt;/span&gt;'男'&lt;span&gt;,
        age:&lt;/span&gt;23&lt;span&gt;
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;10.3　v- for 的表达式还可以迭代整数：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;n in 10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{n}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;10.4　数组更新&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;当我们修改数组时， Vue 会检测到数据变化，所以用v-for 渲染的视图也会立即更新。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;• push()&lt;br/&gt;• pop()&lt;br/&gt;• shift()&lt;br/&gt;• unshit（）&lt;br/&gt;• splice()&lt;br/&gt;• sort（）&lt;br/&gt;• reverse()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt; 这些方法会改变被这些方法调用的原始数组&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;例如，我们将之前一个示例的数据books 添加一项：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;app.books.push({
    name: &lt;/span&gt;'《css世界》'&lt;span&gt;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;有些方法不会改变原数组，例如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;• filter()&lt;br/&gt;• concat()&lt;br/&gt;• slice()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;它们返回的是一个新数组，在使用这些非变异方法时，可以用新数组来替换原数组，如：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
app.books = app.books.filter(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item . name.match(/JavaScript/&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;Vue 在检测到数组变化时，并不是直接重新渲染整个列表，而是最大化地复用DOM 元素。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;替换的数组中，含有相同元素的项不会被重新渲染，因此可以大胆地用新数组来替换旧数组，不用担心性能问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;10.5 过滤与排序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你不想改变原数组，想通过一个数组的副本来做过滤或排序的显示时，&lt;span&gt;可以使用计算属性来返回过滤或排序后的数组&lt;/span&gt;，例如：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;v-for&lt;/span&gt;&lt;span&gt;=&quot;book in filterBooks&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;书名：{{book.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;作者：{{book.author}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; app= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el: &lt;/span&gt;'#app'&lt;span&gt;,
    computed: {
        filterBooks: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.books.filter(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (book) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; book.name.match(/JavaScript/&lt;span&gt;);
            })
        },
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;11、v-cloak：不需要表达式，这个指令保持在元素上直到关联实例结束编译；&lt;span&gt;v-cloak 是一个解决初始化慢导致页面闪动的最佳实践&lt;/span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;12、v-once：也是一个不需要表达式的指令，作用是定义它的元素或组件只渲染一次，包括元素或组件的所有子节点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span&gt;首次渲染后，不再随数据的变化重新渲染，将被视为静态内容；&lt;/span&gt;v-once 在业务中也很少使用，当你需要进一步优化性能时，可能会用到。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;&lt;span class=&quot;attr&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;name&quot;&gt;13、v-pre：不需要表达式，跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度；例如：&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;span &lt;span class=&quot;attr&quot;&gt;v-pre&amp;gt;{{ this will not be compiled }}&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;span&amp;gt;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan&lt;/p&gt;
</description>
<pubDate>Mon, 02 Apr 2018 14:14:00 +0000</pubDate>
<dc:creator>柴小智</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaixiaozhi/p/8698222.html</dc:identifier>
</item>
</channel>
</rss>